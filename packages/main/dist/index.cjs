"use strict";
const require$$0 = require("electron");
const require$$1 = require("path");
require("url");
const require$$0$3 = require("fs");
const require$$0$1 = require("constants");
const require$$0$2 = require("stream");
const require$$4 = require("util");
const require$$5 = require("assert");
const require$$3$1 = require("crypto");
const require$$5$1 = require("events");
const require$$1$1 = require("os");
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var serializeError_1;
var hasRequiredSerializeError;
function requireSerializeError() {
  if (hasRequiredSerializeError)
    return serializeError_1;
  hasRequiredSerializeError = 1;
  class NonError extends Error {
    constructor(message) {
      super(NonError._prepareSuperMessage(message));
      Object.defineProperty(this, "name", {
        value: "NonError",
        configurable: true,
        writable: true
      });
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, NonError);
      }
    }
    static _prepareSuperMessage(message) {
      try {
        return JSON.stringify(message);
      } catch {
        return String(message);
      }
    }
  }
  const commonProperties = [
    { property: "name", enumerable: false },
    { property: "message", enumerable: false },
    { property: "stack", enumerable: false },
    { property: "code", enumerable: true }
  ];
  const isCalled = Symbol(".toJSON called");
  const toJSON = (from) => {
    from[isCalled] = true;
    const json2 = from.toJSON();
    delete from[isCalled];
    return json2;
  };
  const destroyCircular = ({
    from,
    seen,
    to_,
    forceEnumerable,
    maxDepth,
    depth
  }) => {
    const to = to_ || (Array.isArray(from) ? [] : {});
    seen.push(from);
    if (depth >= maxDepth) {
      return to;
    }
    if (typeof from.toJSON === "function" && from[isCalled] !== true) {
      return toJSON(from);
    }
    for (const [key, value] of Object.entries(from)) {
      if (typeof Buffer === "function" && Buffer.isBuffer(value)) {
        to[key] = "[object Buffer]";
        continue;
      }
      if (typeof value === "function") {
        continue;
      }
      if (!value || typeof value !== "object") {
        to[key] = value;
        continue;
      }
      if (!seen.includes(from[key])) {
        depth++;
        to[key] = destroyCircular({
          from: from[key],
          seen: seen.slice(),
          forceEnumerable,
          maxDepth,
          depth
        });
        continue;
      }
      to[key] = "[Circular]";
    }
    for (const { property, enumerable } of commonProperties) {
      if (typeof from[property] === "string") {
        Object.defineProperty(to, property, {
          value: from[property],
          enumerable: forceEnumerable ? true : enumerable,
          configurable: true,
          writable: true
        });
      }
    }
    return to;
  };
  const serializeError = (value, options = {}) => {
    const { maxDepth = Number.POSITIVE_INFINITY } = options;
    if (typeof value === "object" && value !== null) {
      return destroyCircular({
        from: value,
        seen: [],
        forceEnumerable: true,
        maxDepth,
        depth: 0
      });
    }
    if (typeof value === "function") {
      return `[Function: ${value.name || "anonymous"}]`;
    }
    return value;
  };
  const deserializeError = (value, options = {}) => {
    const { maxDepth = Number.POSITIVE_INFINITY } = options;
    if (value instanceof Error) {
      return value;
    }
    if (typeof value === "object" && value !== null && !Array.isArray(value)) {
      const newError = new Error();
      destroyCircular({
        from: value,
        seen: [],
        to_: newError,
        maxDepth,
        depth: 0
      });
      return newError;
    }
    return new NonError(value);
  };
  serializeError_1 = {
    serializeError,
    deserializeError
  };
  return serializeError_1;
}
var util$2 = {};
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil)
    return util$2;
  hasRequiredUtil = 1;
  const getUniqueId = () => `${Date.now()}-${Math.random()}`;
  const getSendChannel = (channel) => `%better-ipc-send-channel-${channel}`;
  const getRendererSendChannel = (channel) => `%better-ipc-send-channel-${channel}`;
  util$2.currentWindowChannel = "%better-ipc-current-window";
  util$2.getSendChannel = getSendChannel;
  util$2.getRendererSendChannel = getRendererSendChannel;
  util$2.getResponseChannels = (channel) => {
    const id2 = getUniqueId();
    return {
      sendChannel: getSendChannel(channel),
      dataChannel: `%better-ipc-response-data-channel-${channel}-${id2}`,
      errorChannel: `%better-ipc-response-error-channel-${channel}-${id2}`
    };
  };
  util$2.getRendererResponseChannels = (channel) => {
    const id2 = getUniqueId();
    return {
      sendChannel: getRendererSendChannel(channel),
      dataChannel: `%better-ipc-response-data-channel-${channel}-${id2}`,
      errorChannel: `%better-ipc-response-error-channel-${channel}-${id2}`
    };
  };
  return util$2;
}
var main;
var hasRequiredMain;
function requireMain() {
  if (hasRequiredMain)
    return main;
  hasRequiredMain = 1;
  const electron = require$$0;
  const { serializeError, deserializeError } = requireSerializeError();
  const util2 = requireUtil();
  const { ipcMain: ipcMain2, BrowserWindow } = electron;
  const ipc = Object.create(ipcMain2 || {});
  ipc.callRenderer = (browserWindow, channel, data) => new Promise((resolve2, reject) => {
    if (!browserWindow) {
      throw new Error("Browser window required");
    }
    const { sendChannel, dataChannel, errorChannel } = util2.getRendererResponseChannels(channel);
    const cleanup = () => {
      ipcMain2.off(dataChannel, onData);
      ipcMain2.off(errorChannel, onError);
    };
    const onData = (event, result) => {
      const window2 = BrowserWindow.fromWebContents(event.sender);
      if (window2.id === browserWindow.id) {
        cleanup();
        resolve2(result);
      }
    };
    const onError = (event, error2) => {
      const window2 = BrowserWindow.fromWebContents(event.sender);
      if (window2.id === browserWindow.id) {
        cleanup();
        reject(deserializeError(error2));
      }
    };
    ipcMain2.on(dataChannel, onData);
    ipcMain2.on(errorChannel, onError);
    const completeData = {
      dataChannel,
      errorChannel,
      userData: data
    };
    if (browserWindow.webContents) {
      browserWindow.webContents.send(sendChannel, completeData);
    }
  });
  ipc.callFocusedRenderer = async (...args) => {
    const focusedWindow = BrowserWindow.getFocusedWindow();
    if (!focusedWindow) {
      throw new Error("No browser window in focus");
    }
    return ipc.callRenderer(focusedWindow, ...args);
  };
  ipc.answerRenderer = (browserWindowOrChannel, channelOrCallback, callbackOrNothing) => {
    let window2;
    let channel;
    let callback;
    if (callbackOrNothing === void 0) {
      channel = browserWindowOrChannel;
      callback = channelOrCallback;
    } else {
      window2 = browserWindowOrChannel;
      channel = channelOrCallback;
      callback = callbackOrNothing;
      if (!window2) {
        throw new Error("Browser window required");
      }
    }
    const sendChannel = util2.getSendChannel(channel);
    const listener = async (event, data) => {
      const browserWindow = BrowserWindow.fromWebContents(event.sender);
      if (window2 && window2.id !== browserWindow.id) {
        return;
      }
      const send = (channel2, data2) => {
        if (!(browserWindow && browserWindow.isDestroyed())) {
          event.sender.send(channel2, data2);
        }
      };
      const { dataChannel, errorChannel, userData } = data;
      try {
        send(dataChannel, await callback(userData, browserWindow));
      } catch (error2) {
        send(errorChannel, serializeError(error2));
      }
    };
    ipcMain2.on(sendChannel, listener);
    return () => {
      ipcMain2.off(sendChannel, listener);
    };
  };
  ipc.sendToRenderers = (channel, data) => {
    for (const browserWindow of BrowserWindow.getAllWindows()) {
      if (browserWindow.webContents) {
        browserWindow.webContents.send(channel, data);
      }
    }
  };
  main = ipc;
  return main;
}
var renderer;
var hasRequiredRenderer;
function requireRenderer() {
  if (hasRequiredRenderer)
    return renderer;
  hasRequiredRenderer = 1;
  const electron = require$$0;
  const { serializeError, deserializeError } = requireSerializeError();
  const util2 = requireUtil();
  const { ipcRenderer: ipcRenderer2 } = electron;
  const ipc = Object.create(ipcRenderer2 || {});
  ipc.callMain = (channel, data) => new Promise((resolve2, reject) => {
    const { sendChannel, dataChannel, errorChannel } = util2.getResponseChannels(channel);
    const cleanup = () => {
      ipcRenderer2.off(dataChannel, onData);
      ipcRenderer2.off(errorChannel, onError);
    };
    const onData = (_event, result) => {
      cleanup();
      resolve2(result);
    };
    const onError = (_event, error2) => {
      cleanup();
      reject(deserializeError(error2));
    };
    ipcRenderer2.once(dataChannel, onData);
    ipcRenderer2.once(errorChannel, onError);
    const completeData = {
      dataChannel,
      errorChannel,
      userData: data
    };
    ipcRenderer2.send(sendChannel, completeData);
  });
  ipc.answerMain = (channel, callback) => {
    const sendChannel = util2.getRendererSendChannel(channel);
    const listener = async (_event, data) => {
      const { dataChannel, errorChannel, userData } = data;
      try {
        ipcRenderer2.send(dataChannel, await callback(userData));
      } catch (error2) {
        ipcRenderer2.send(errorChannel, serializeError(error2));
      }
    };
    ipcRenderer2.on(sendChannel, listener);
    return () => {
      ipcRenderer2.off(sendChannel, listener);
    };
  };
  renderer = ipc;
  return renderer;
}
var ipcMain$1;
if (process.type === "renderer") {
  requireRenderer();
} else {
  ipcMain$1 = requireMain();
}
var fs$k = {};
var universalify$1 = {};
universalify$1.fromCallback = function(fn) {
  return Object.defineProperty(function(...args) {
    if (typeof args[args.length - 1] === "function")
      fn.apply(this, args);
    else {
      return new Promise((resolve2, reject) => {
        fn.call(
          this,
          ...args,
          (err, res) => err != null ? reject(err) : resolve2(res)
        );
      });
    }
  }, "name", { value: fn.name });
};
universalify$1.fromPromise = function(fn) {
  return Object.defineProperty(function(...args) {
    const cb = args[args.length - 1];
    if (typeof cb !== "function")
      return fn.apply(this, args);
    else
      fn.apply(this, args.slice(0, -1)).then((r) => cb(null, r), cb);
  }, "name", { value: fn.name });
};
var constants$1 = require$$0$1;
var origCwd = process.cwd;
var cwd = null;
var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process);
  return cwd;
};
try {
  process.cwd();
} catch (er) {
}
if (typeof process.chdir === "function") {
  var chdir = process.chdir;
  process.chdir = function(d) {
    cwd = null;
    chdir.call(process, d);
  };
  if (Object.setPrototypeOf)
    Object.setPrototypeOf(process.chdir, chdir);
}
var polyfills$1 = patch$2;
function patch$2(fs2) {
  if (constants$1.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs2);
  }
  if (!fs2.lutimes) {
    patchLutimes(fs2);
  }
  fs2.chown = chownFix(fs2.chown);
  fs2.fchown = chownFix(fs2.fchown);
  fs2.lchown = chownFix(fs2.lchown);
  fs2.chmod = chmodFix(fs2.chmod);
  fs2.fchmod = chmodFix(fs2.fchmod);
  fs2.lchmod = chmodFix(fs2.lchmod);
  fs2.chownSync = chownFixSync(fs2.chownSync);
  fs2.fchownSync = chownFixSync(fs2.fchownSync);
  fs2.lchownSync = chownFixSync(fs2.lchownSync);
  fs2.chmodSync = chmodFixSync(fs2.chmodSync);
  fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
  fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
  fs2.stat = statFix(fs2.stat);
  fs2.fstat = statFix(fs2.fstat);
  fs2.lstat = statFix(fs2.lstat);
  fs2.statSync = statFixSync(fs2.statSync);
  fs2.fstatSync = statFixSync(fs2.fstatSync);
  fs2.lstatSync = statFixSync(fs2.lstatSync);
  if (!fs2.lchmod) {
    fs2.lchmod = function(path2, mode, cb) {
      if (cb)
        process.nextTick(cb);
    };
    fs2.lchmodSync = function() {
    };
  }
  if (!fs2.lchown) {
    fs2.lchown = function(path2, uid, gid, cb) {
      if (cb)
        process.nextTick(cb);
    };
    fs2.lchownSync = function() {
    };
  }
  if (platform === "win32") {
    fs2.rename = /* @__PURE__ */ function(fs$rename) {
      return function(from, to, cb) {
        var start = Date.now();
        var backoff = 0;
        fs$rename(from, to, function CB(er) {
          if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
            setTimeout(function() {
              fs2.stat(to, function(stater, st) {
                if (stater && stater.code === "ENOENT")
                  fs$rename(from, to, CB);
                else
                  cb(er);
              });
            }, backoff);
            if (backoff < 100)
              backoff += 10;
            return;
          }
          if (cb)
            cb(er);
        });
      };
    }(fs2.rename);
  }
  fs2.read = function(fs$read) {
    function read(fd, buffer, offset, length, position, callback_) {
      var callback;
      if (callback_ && typeof callback_ === "function") {
        var eagCounter = 0;
        callback = function(er, _, __) {
          if (er && er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
          }
          callback_.apply(this, arguments);
        };
      }
      return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
    }
    if (Object.setPrototypeOf)
      Object.setPrototypeOf(read, fs$read);
    return read;
  }(fs2.read);
  fs2.readSync = /* @__PURE__ */ function(fs$readSync) {
    return function(fd, buffer, offset, length, position) {
      var eagCounter = 0;
      while (true) {
        try {
          return fs$readSync.call(fs2, fd, buffer, offset, length, position);
        } catch (er) {
          if (er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            continue;
          }
          throw er;
        }
      }
    };
  }(fs2.readSync);
  function patchLchmod(fs3) {
    fs3.lchmod = function(path2, mode, callback) {
      fs3.open(
        path2,
        constants$1.O_WRONLY | constants$1.O_SYMLINK,
        mode,
        function(err, fd) {
          if (err) {
            if (callback)
              callback(err);
            return;
          }
          fs3.fchmod(fd, mode, function(err2) {
            fs3.close(fd, function(err22) {
              if (callback)
                callback(err2 || err22);
            });
          });
        }
      );
    };
    fs3.lchmodSync = function(path2, mode) {
      var fd = fs3.openSync(path2, constants$1.O_WRONLY | constants$1.O_SYMLINK, mode);
      var threw = true;
      var ret;
      try {
        ret = fs3.fchmodSync(fd, mode);
        threw = false;
      } finally {
        if (threw) {
          try {
            fs3.closeSync(fd);
          } catch (er) {
          }
        } else {
          fs3.closeSync(fd);
        }
      }
      return ret;
    };
  }
  function patchLutimes(fs3) {
    if (constants$1.hasOwnProperty("O_SYMLINK")) {
      fs3.lutimes = function(path2, at, mt, cb) {
        fs3.open(path2, constants$1.O_SYMLINK, function(er, fd) {
          if (er) {
            if (cb)
              cb(er);
            return;
          }
          fs3.futimes(fd, at, mt, function(er2) {
            fs3.close(fd, function(er22) {
              if (cb)
                cb(er2 || er22);
            });
          });
        });
      };
      fs3.lutimesSync = function(path2, at, mt) {
        var fd = fs3.openSync(path2, constants$1.O_SYMLINK);
        var ret;
        var threw = true;
        try {
          ret = fs3.futimesSync(fd, at, mt);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs3.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs3.closeSync(fd);
          }
        }
        return ret;
      };
    } else {
      fs3.lutimes = function(_a, _b, _c, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs3.lutimesSync = function() {
      };
    }
  }
  function chmodFix(orig) {
    if (!orig)
      return orig;
    return function(target, mode, cb) {
      return orig.call(fs2, target, mode, function(er) {
        if (chownErOk(er))
          er = null;
        if (cb)
          cb.apply(this, arguments);
      });
    };
  }
  function chmodFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, mode) {
      try {
        return orig.call(fs2, target, mode);
      } catch (er) {
        if (!chownErOk(er))
          throw er;
      }
    };
  }
  function chownFix(orig) {
    if (!orig)
      return orig;
    return function(target, uid, gid, cb) {
      return orig.call(fs2, target, uid, gid, function(er) {
        if (chownErOk(er))
          er = null;
        if (cb)
          cb.apply(this, arguments);
      });
    };
  }
  function chownFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, uid, gid) {
      try {
        return orig.call(fs2, target, uid, gid);
      } catch (er) {
        if (!chownErOk(er))
          throw er;
      }
    };
  }
  function statFix(orig) {
    if (!orig)
      return orig;
    return function(target, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      function callback(er, stats) {
        if (stats) {
          if (stats.uid < 0)
            stats.uid += 4294967296;
          if (stats.gid < 0)
            stats.gid += 4294967296;
        }
        if (cb)
          cb.apply(this, arguments);
      }
      return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
    };
  }
  function statFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, options) {
      var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
      if (stats.uid < 0)
        stats.uid += 4294967296;
      if (stats.gid < 0)
        stats.gid += 4294967296;
      return stats;
    };
  }
  function chownErOk(er) {
    if (!er)
      return true;
    if (er.code === "ENOSYS")
      return true;
    var nonroot = !process.getuid || process.getuid() !== 0;
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true;
    }
    return false;
  }
}
var Stream = require$$0$2.Stream;
var legacyStreams = legacy$1;
function legacy$1(fs2) {
  return {
    ReadStream,
    WriteStream
  };
  function ReadStream(path2, options) {
    if (!(this instanceof ReadStream))
      return new ReadStream(path2, options);
    Stream.call(this);
    var self2 = this;
    this.path = path2;
    this.fd = null;
    this.readable = true;
    this.paused = false;
    this.flags = "r";
    this.mode = 438;
    this.bufferSize = 64 * 1024;
    options = options || {};
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }
    if (this.encoding)
      this.setEncoding(this.encoding);
    if (this.start !== void 0) {
      if ("number" !== typeof this.start) {
        throw TypeError("start must be a Number");
      }
      if (this.end === void 0) {
        this.end = Infinity;
      } else if ("number" !== typeof this.end) {
        throw TypeError("end must be a Number");
      }
      if (this.start > this.end) {
        throw new Error("start must be <= end");
      }
      this.pos = this.start;
    }
    if (this.fd !== null) {
      process.nextTick(function() {
        self2._read();
      });
      return;
    }
    fs2.open(this.path, this.flags, this.mode, function(err, fd) {
      if (err) {
        self2.emit("error", err);
        self2.readable = false;
        return;
      }
      self2.fd = fd;
      self2.emit("open", fd);
      self2._read();
    });
  }
  function WriteStream(path2, options) {
    if (!(this instanceof WriteStream))
      return new WriteStream(path2, options);
    Stream.call(this);
    this.path = path2;
    this.fd = null;
    this.writable = true;
    this.flags = "w";
    this.encoding = "binary";
    this.mode = 438;
    this.bytesWritten = 0;
    options = options || {};
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }
    if (this.start !== void 0) {
      if ("number" !== typeof this.start) {
        throw TypeError("start must be a Number");
      }
      if (this.start < 0) {
        throw new Error("start must be >= zero");
      }
      this.pos = this.start;
    }
    this.busy = false;
    this._queue = [];
    if (this.fd === null) {
      this._open = fs2.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
      this.flush();
    }
  }
}
var clone_1 = clone$1;
var getPrototypeOf = Object.getPrototypeOf || function(obj) {
  return obj.__proto__;
};
function clone$1(obj) {
  if (obj === null || typeof obj !== "object")
    return obj;
  if (obj instanceof Object)
    var copy2 = { __proto__: getPrototypeOf(obj) };
  else
    var copy2 = /* @__PURE__ */ Object.create(null);
  Object.getOwnPropertyNames(obj).forEach(function(key) {
    Object.defineProperty(copy2, key, Object.getOwnPropertyDescriptor(obj, key));
  });
  return copy2;
}
var fs$j = require$$0$3;
var polyfills = polyfills$1;
var legacy = legacyStreams;
var clone = clone_1;
var util$1 = require$$4;
var gracefulQueue;
var previousSymbol;
if (typeof Symbol === "function" && typeof Symbol.for === "function") {
  gracefulQueue = Symbol.for("graceful-fs.queue");
  previousSymbol = Symbol.for("graceful-fs.previous");
} else {
  gracefulQueue = "___graceful-fs.queue";
  previousSymbol = "___graceful-fs.previous";
}
function noop() {
}
function publishQueue(context, queue) {
  Object.defineProperty(context, gracefulQueue, {
    get: function() {
      return queue;
    }
  });
}
var debug$2 = noop;
if (util$1.debuglog)
  debug$2 = util$1.debuglog("gfs4");
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
  debug$2 = function() {
    var m = util$1.format.apply(util$1, arguments);
    m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
    console.error(m);
  };
if (!fs$j[gracefulQueue]) {
  var queue = commonjsGlobal[gracefulQueue] || [];
  publishQueue(fs$j, queue);
  fs$j.close = function(fs$close) {
    function close(fd, cb) {
      return fs$close.call(fs$j, fd, function(err) {
        if (!err) {
          resetQueue();
        }
        if (typeof cb === "function")
          cb.apply(this, arguments);
      });
    }
    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    });
    return close;
  }(fs$j.close);
  fs$j.closeSync = function(fs$closeSync) {
    function closeSync(fd) {
      fs$closeSync.apply(fs$j, arguments);
      resetQueue();
    }
    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    });
    return closeSync;
  }(fs$j.closeSync);
  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
    process.on("exit", function() {
      debug$2(fs$j[gracefulQueue]);
      require$$5.equal(fs$j[gracefulQueue].length, 0);
    });
  }
}
if (!commonjsGlobal[gracefulQueue]) {
  publishQueue(commonjsGlobal, fs$j[gracefulQueue]);
}
var gracefulFs = patch$1(clone(fs$j));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs$j.__patched) {
  gracefulFs = patch$1(fs$j);
  fs$j.__patched = true;
}
function patch$1(fs2) {
  polyfills(fs2);
  fs2.gracefulify = patch$1;
  fs2.createReadStream = createReadStream;
  fs2.createWriteStream = createWriteStream;
  var fs$readFile = fs2.readFile;
  fs2.readFile = readFile2;
  function readFile2(path2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$readFile(path2, options, cb);
    function go$readFile(path3, options2, cb2, startTime) {
      return fs$readFile(path3, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$readFile, [path3, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$writeFile = fs2.writeFile;
  fs2.writeFile = writeFile2;
  function writeFile2(path2, data, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$writeFile(path2, data, options, cb);
    function go$writeFile(path3, data2, options2, cb2, startTime) {
      return fs$writeFile(path3, data2, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$writeFile, [path3, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$appendFile = fs2.appendFile;
  if (fs$appendFile)
    fs2.appendFile = appendFile;
  function appendFile(path2, data, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$appendFile(path2, data, options, cb);
    function go$appendFile(path3, data2, options2, cb2, startTime) {
      return fs$appendFile(path3, data2, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$appendFile, [path3, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$copyFile = fs2.copyFile;
  if (fs$copyFile)
    fs2.copyFile = copyFile2;
  function copyFile2(src, dest, flags, cb) {
    if (typeof flags === "function") {
      cb = flags;
      flags = 0;
    }
    return go$copyFile(src, dest, flags, cb);
    function go$copyFile(src2, dest2, flags2, cb2, startTime) {
      return fs$copyFile(src2, dest2, flags2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$readdir = fs2.readdir;
  fs2.readdir = readdir;
  function readdir(path2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$readdir(path2, options, cb);
    function go$readdir(path3, options2, cb2, startTime) {
      return fs$readdir(path3, options2, function(err, files) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$readdir, [path3, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (files && files.sort)
            files.sort();
          if (typeof cb2 === "function")
            cb2.call(this, err, files);
        }
      });
    }
  }
  if (process.version.substr(0, 4) === "v0.8") {
    var legStreams = legacy(fs2);
    ReadStream = legStreams.ReadStream;
    WriteStream = legStreams.WriteStream;
  }
  var fs$ReadStream = fs2.ReadStream;
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype);
    ReadStream.prototype.open = ReadStream$open;
  }
  var fs$WriteStream = fs2.WriteStream;
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype);
    WriteStream.prototype.open = WriteStream$open;
  }
  Object.defineProperty(fs2, "ReadStream", {
    get: function() {
      return ReadStream;
    },
    set: function(val) {
      ReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(fs2, "WriteStream", {
    get: function() {
      return WriteStream;
    },
    set: function(val) {
      WriteStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileReadStream = ReadStream;
  Object.defineProperty(fs2, "FileReadStream", {
    get: function() {
      return FileReadStream;
    },
    set: function(val) {
      FileReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileWriteStream = WriteStream;
  Object.defineProperty(fs2, "FileWriteStream", {
    get: function() {
      return FileWriteStream;
    },
    set: function(val) {
      FileWriteStream = val;
    },
    enumerable: true,
    configurable: true
  });
  function ReadStream(path2, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this;
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
  }
  function ReadStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function(err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy();
        that.emit("error", err);
      } else {
        that.fd = fd;
        that.emit("open", fd);
        that.read();
      }
    });
  }
  function WriteStream(path2, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this;
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
  }
  function WriteStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function(err, fd) {
      if (err) {
        that.destroy();
        that.emit("error", err);
      } else {
        that.fd = fd;
        that.emit("open", fd);
      }
    });
  }
  function createReadStream(path2, options) {
    return new fs2.ReadStream(path2, options);
  }
  function createWriteStream(path2, options) {
    return new fs2.WriteStream(path2, options);
  }
  var fs$open = fs2.open;
  fs2.open = open;
  function open(path2, flags, mode, cb) {
    if (typeof mode === "function")
      cb = mode, mode = null;
    return go$open(path2, flags, mode, cb);
    function go$open(path3, flags2, mode2, cb2, startTime) {
      return fs$open(path3, flags2, mode2, function(err, fd) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$open, [path3, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  return fs2;
}
function enqueue(elem) {
  debug$2("ENQUEUE", elem[0].name, elem[1]);
  fs$j[gracefulQueue].push(elem);
  retry();
}
var retryTimer;
function resetQueue() {
  var now = Date.now();
  for (var i = 0; i < fs$j[gracefulQueue].length; ++i) {
    if (fs$j[gracefulQueue][i].length > 2) {
      fs$j[gracefulQueue][i][3] = now;
      fs$j[gracefulQueue][i][4] = now;
    }
  }
  retry();
}
function retry() {
  clearTimeout(retryTimer);
  retryTimer = void 0;
  if (fs$j[gracefulQueue].length === 0)
    return;
  var elem = fs$j[gracefulQueue].shift();
  var fn = elem[0];
  var args = elem[1];
  var err = elem[2];
  var startTime = elem[3];
  var lastTime = elem[4];
  if (startTime === void 0) {
    debug$2("RETRY", fn.name, args);
    fn.apply(null, args);
  } else if (Date.now() - startTime >= 6e4) {
    debug$2("TIMEOUT", fn.name, args);
    var cb = args.pop();
    if (typeof cb === "function")
      cb.call(null, err);
  } else {
    var sinceAttempt = Date.now() - lastTime;
    var sinceStart = Math.max(lastTime - startTime, 1);
    var desiredDelay = Math.min(sinceStart * 1.2, 100);
    if (sinceAttempt >= desiredDelay) {
      debug$2("RETRY", fn.name, args);
      fn.apply(null, args.concat([startTime]));
    } else {
      fs$j[gracefulQueue].push(elem);
    }
  }
  if (retryTimer === void 0) {
    retryTimer = setTimeout(retry, 0);
  }
}
(function(exports2) {
  const u2 = universalify$1.fromCallback;
  const fs2 = gracefulFs;
  const api = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((key) => {
    return typeof fs2[key] === "function";
  });
  Object.assign(exports2, fs2);
  api.forEach((method) => {
    exports2[method] = u2(fs2[method]);
  });
  exports2.exists = function(filename, callback) {
    if (typeof callback === "function") {
      return fs2.exists(filename, callback);
    }
    return new Promise((resolve2) => {
      return fs2.exists(filename, resolve2);
    });
  };
  exports2.read = function(fd, buffer, offset, length, position, callback) {
    if (typeof callback === "function") {
      return fs2.read(fd, buffer, offset, length, position, callback);
    }
    return new Promise((resolve2, reject) => {
      fs2.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
        if (err)
          return reject(err);
        resolve2({ bytesRead, buffer: buffer2 });
      });
    });
  };
  exports2.write = function(fd, buffer, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs2.write(fd, buffer, ...args);
    }
    return new Promise((resolve2, reject) => {
      fs2.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
        if (err)
          return reject(err);
        resolve2({ bytesWritten, buffer: buffer2 });
      });
    });
  };
  exports2.readv = function(fd, buffers, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs2.readv(fd, buffers, ...args);
    }
    return new Promise((resolve2, reject) => {
      fs2.readv(fd, buffers, ...args, (err, bytesRead, buffers2) => {
        if (err)
          return reject(err);
        resolve2({ bytesRead, buffers: buffers2 });
      });
    });
  };
  exports2.writev = function(fd, buffers, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs2.writev(fd, buffers, ...args);
    }
    return new Promise((resolve2, reject) => {
      fs2.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
        if (err)
          return reject(err);
        resolve2({ bytesWritten, buffers: buffers2 });
      });
    });
  };
  if (typeof fs2.realpath.native === "function") {
    exports2.realpath.native = u2(fs2.realpath.native);
  } else {
    process.emitWarning(
      "fs.realpath.native is not a function. Is fs being monkey-patched?",
      "Warning",
      "fs-extra-WARN0003"
    );
  }
})(fs$k);
var makeDir$1 = {};
var utils$1 = {};
const path$h = require$$1;
utils$1.checkPath = function checkPath(pth) {
  if (process.platform === "win32") {
    const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path$h.parse(pth).root, ""));
    if (pathHasInvalidWinCharacters) {
      const error2 = new Error(`Path contains invalid characters: ${pth}`);
      error2.code = "EINVAL";
      throw error2;
    }
  }
};
const fs$i = fs$k;
const { checkPath: checkPath2 } = utils$1;
const getMode = (options) => {
  const defaults2 = { mode: 511 };
  if (typeof options === "number")
    return options;
  return { ...defaults2, ...options }.mode;
};
makeDir$1.makeDir = async (dir, options) => {
  checkPath2(dir);
  return fs$i.mkdir(dir, {
    mode: getMode(options),
    recursive: true
  });
};
makeDir$1.makeDirSync = (dir, options) => {
  checkPath2(dir);
  return fs$i.mkdirSync(dir, {
    mode: getMode(options),
    recursive: true
  });
};
const u$e = universalify$1.fromPromise;
const { makeDir: _makeDir, makeDirSync } = makeDir$1;
const makeDir = u$e(_makeDir);
var mkdirs$2 = {
  mkdirs: makeDir,
  mkdirsSync: makeDirSync,
  // alias
  mkdirp: makeDir,
  mkdirpSync: makeDirSync,
  ensureDir: makeDir,
  ensureDirSync: makeDirSync
};
const u$d = universalify$1.fromPromise;
const fs$h = fs$k;
function pathExists$8(path2) {
  return fs$h.access(path2).then(() => true).catch(() => false);
}
var pathExists_1 = {
  pathExists: u$d(pathExists$8),
  pathExistsSync: fs$h.existsSync
};
const fs$g = fs$k;
const u$c = universalify$1.fromPromise;
async function utimesMillis$1(path2, atime, mtime) {
  const fd = await fs$g.open(path2, "r+");
  let closeErr = null;
  try {
    await fs$g.futimes(fd, atime, mtime);
  } finally {
    try {
      await fs$g.close(fd);
    } catch (e) {
      closeErr = e;
    }
  }
  if (closeErr) {
    throw closeErr;
  }
}
function utimesMillisSync$1(path2, atime, mtime) {
  const fd = fs$g.openSync(path2, "r+");
  fs$g.futimesSync(fd, atime, mtime);
  return fs$g.closeSync(fd);
}
var utimes = {
  utimesMillis: u$c(utimesMillis$1),
  utimesMillisSync: utimesMillisSync$1
};
const fs$f = fs$k;
const path$g = require$$1;
const u$b = universalify$1.fromPromise;
function getStats$1(src, dest, opts2) {
  const statFunc = opts2.dereference ? (file2) => fs$f.stat(file2, { bigint: true }) : (file2) => fs$f.lstat(file2, { bigint: true });
  return Promise.all([
    statFunc(src),
    statFunc(dest).catch((err) => {
      if (err.code === "ENOENT")
        return null;
      throw err;
    })
  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
}
function getStatsSync(src, dest, opts2) {
  let destStat;
  const statFunc = opts2.dereference ? (file2) => fs$f.statSync(file2, { bigint: true }) : (file2) => fs$f.lstatSync(file2, { bigint: true });
  const srcStat = statFunc(src);
  try {
    destStat = statFunc(dest);
  } catch (err) {
    if (err.code === "ENOENT")
      return { srcStat, destStat: null };
    throw err;
  }
  return { srcStat, destStat };
}
async function checkPaths(src, dest, funcName, opts2) {
  const { srcStat, destStat } = await getStats$1(src, dest, opts2);
  if (destStat) {
    if (areIdentical$2(srcStat, destStat)) {
      const srcBaseName = path$g.basename(src);
      const destBaseName = path$g.basename(dest);
      if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
        return { srcStat, destStat, isChangingCase: true };
      }
      throw new Error("Source and destination must not be the same.");
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
    }
  }
  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new Error(errMsg(src, dest, funcName));
  }
  return { srcStat, destStat };
}
function checkPathsSync(src, dest, funcName, opts2) {
  const { srcStat, destStat } = getStatsSync(src, dest, opts2);
  if (destStat) {
    if (areIdentical$2(srcStat, destStat)) {
      const srcBaseName = path$g.basename(src);
      const destBaseName = path$g.basename(dest);
      if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
        return { srcStat, destStat, isChangingCase: true };
      }
      throw new Error("Source and destination must not be the same.");
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
    }
  }
  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new Error(errMsg(src, dest, funcName));
  }
  return { srcStat, destStat };
}
async function checkParentPaths(src, srcStat, dest, funcName) {
  const srcParent = path$g.resolve(path$g.dirname(src));
  const destParent = path$g.resolve(path$g.dirname(dest));
  if (destParent === srcParent || destParent === path$g.parse(destParent).root)
    return;
  let destStat;
  try {
    destStat = await fs$f.stat(destParent, { bigint: true });
  } catch (err) {
    if (err.code === "ENOENT")
      return;
    throw err;
  }
  if (areIdentical$2(srcStat, destStat)) {
    throw new Error(errMsg(src, dest, funcName));
  }
  return checkParentPaths(src, srcStat, destParent, funcName);
}
function checkParentPathsSync(src, srcStat, dest, funcName) {
  const srcParent = path$g.resolve(path$g.dirname(src));
  const destParent = path$g.resolve(path$g.dirname(dest));
  if (destParent === srcParent || destParent === path$g.parse(destParent).root)
    return;
  let destStat;
  try {
    destStat = fs$f.statSync(destParent, { bigint: true });
  } catch (err) {
    if (err.code === "ENOENT")
      return;
    throw err;
  }
  if (areIdentical$2(srcStat, destStat)) {
    throw new Error(errMsg(src, dest, funcName));
  }
  return checkParentPathsSync(src, srcStat, destParent, funcName);
}
function areIdentical$2(srcStat, destStat) {
  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
}
function isSrcSubdir(src, dest) {
  const srcArr = path$g.resolve(src).split(path$g.sep).filter((i) => i);
  const destArr = path$g.resolve(dest).split(path$g.sep).filter((i) => i);
  return srcArr.every((cur, i) => destArr[i] === cur);
}
function errMsg(src, dest, funcName) {
  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
}
var stat$4 = {
  // checkPaths
  checkPaths: u$b(checkPaths),
  checkPathsSync,
  // checkParent
  checkParentPaths: u$b(checkParentPaths),
  checkParentPathsSync,
  // Misc
  isSrcSubdir,
  areIdentical: areIdentical$2
};
const fs$e = fs$k;
const path$f = require$$1;
const { mkdirs: mkdirs$1 } = mkdirs$2;
const { pathExists: pathExists$7 } = pathExists_1;
const { utimesMillis } = utimes;
const stat$3 = stat$4;
async function copy$2(src, dest, opts2 = {}) {
  if (typeof opts2 === "function") {
    opts2 = { filter: opts2 };
  }
  opts2.clobber = "clobber" in opts2 ? !!opts2.clobber : true;
  opts2.overwrite = "overwrite" in opts2 ? !!opts2.overwrite : opts2.clobber;
  if (opts2.preserveTimestamps && process.arch === "ia32") {
    process.emitWarning(
      "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
      "Warning",
      "fs-extra-WARN0001"
    );
  }
  const { srcStat, destStat } = await stat$3.checkPaths(src, dest, "copy", opts2);
  await stat$3.checkParentPaths(src, srcStat, dest, "copy");
  const include = await runFilter(src, dest, opts2);
  if (!include)
    return;
  const destParent = path$f.dirname(dest);
  const dirExists = await pathExists$7(destParent);
  if (!dirExists) {
    await mkdirs$1(destParent);
  }
  await getStatsAndPerformCopy(destStat, src, dest, opts2);
}
async function runFilter(src, dest, opts2) {
  if (!opts2.filter)
    return true;
  return opts2.filter(src, dest);
}
async function getStatsAndPerformCopy(destStat, src, dest, opts2) {
  const statFn = opts2.dereference ? fs$e.stat : fs$e.lstat;
  const srcStat = await statFn(src);
  if (srcStat.isDirectory())
    return onDir$1(srcStat, destStat, src, dest, opts2);
  if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
    return onFile$1(srcStat, destStat, src, dest, opts2);
  if (srcStat.isSymbolicLink())
    return onLink$1(destStat, src, dest, opts2);
  if (srcStat.isSocket())
    throw new Error(`Cannot copy a socket file: ${src}`);
  if (srcStat.isFIFO())
    throw new Error(`Cannot copy a FIFO pipe: ${src}`);
  throw new Error(`Unknown file: ${src}`);
}
async function onFile$1(srcStat, destStat, src, dest, opts2) {
  if (!destStat)
    return copyFile$1(srcStat, src, dest, opts2);
  if (opts2.overwrite) {
    await fs$e.unlink(dest);
    return copyFile$1(srcStat, src, dest, opts2);
  }
  if (opts2.errorOnExist) {
    throw new Error(`'${dest}' already exists`);
  }
}
async function copyFile$1(srcStat, src, dest, opts2) {
  await fs$e.copyFile(src, dest);
  if (opts2.preserveTimestamps) {
    if (fileIsNotWritable$1(srcStat.mode)) {
      await makeFileWritable$1(dest, srcStat.mode);
    }
    const updatedSrcStat = await fs$e.stat(src);
    await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
  }
  return fs$e.chmod(dest, srcStat.mode);
}
function fileIsNotWritable$1(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable$1(dest, srcMode) {
  return fs$e.chmod(dest, srcMode | 128);
}
async function onDir$1(srcStat, destStat, src, dest, opts2) {
  if (!destStat) {
    await fs$e.mkdir(dest);
  }
  const items2 = await fs$e.readdir(src);
  await Promise.all(items2.map(async (item) => {
    const srcItem = path$f.join(src, item);
    const destItem = path$f.join(dest, item);
    const include = await runFilter(srcItem, destItem, opts2);
    if (!include)
      return;
    const { destStat: destStat2 } = await stat$3.checkPaths(srcItem, destItem, "copy", opts2);
    return getStatsAndPerformCopy(destStat2, srcItem, destItem, opts2);
  }));
  if (!destStat) {
    await fs$e.chmod(dest, srcStat.mode);
  }
}
async function onLink$1(destStat, src, dest, opts2) {
  let resolvedSrc = await fs$e.readlink(src);
  if (opts2.dereference) {
    resolvedSrc = path$f.resolve(process.cwd(), resolvedSrc);
  }
  if (!destStat) {
    return fs$e.symlink(resolvedSrc, dest);
  }
  let resolvedDest = null;
  try {
    resolvedDest = await fs$e.readlink(dest);
  } catch (e) {
    if (e.code === "EINVAL" || e.code === "UNKNOWN")
      return fs$e.symlink(resolvedSrc, dest);
    throw e;
  }
  if (opts2.dereference) {
    resolvedDest = path$f.resolve(process.cwd(), resolvedDest);
  }
  if (stat$3.isSrcSubdir(resolvedSrc, resolvedDest)) {
    throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
  }
  if (stat$3.isSrcSubdir(resolvedDest, resolvedSrc)) {
    throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
  }
  await fs$e.unlink(dest);
  return fs$e.symlink(resolvedSrc, dest);
}
var copy_1 = copy$2;
const fs$d = gracefulFs;
const path$e = require$$1;
const mkdirsSync$1 = mkdirs$2.mkdirsSync;
const utimesMillisSync = utimes.utimesMillisSync;
const stat$2 = stat$4;
function copySync$1(src, dest, opts2) {
  if (typeof opts2 === "function") {
    opts2 = { filter: opts2 };
  }
  opts2 = opts2 || {};
  opts2.clobber = "clobber" in opts2 ? !!opts2.clobber : true;
  opts2.overwrite = "overwrite" in opts2 ? !!opts2.overwrite : opts2.clobber;
  if (opts2.preserveTimestamps && process.arch === "ia32") {
    process.emitWarning(
      "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
      "Warning",
      "fs-extra-WARN0002"
    );
  }
  const { srcStat, destStat } = stat$2.checkPathsSync(src, dest, "copy", opts2);
  stat$2.checkParentPathsSync(src, srcStat, dest, "copy");
  if (opts2.filter && !opts2.filter(src, dest))
    return;
  const destParent = path$e.dirname(dest);
  if (!fs$d.existsSync(destParent))
    mkdirsSync$1(destParent);
  return getStats(destStat, src, dest, opts2);
}
function getStats(destStat, src, dest, opts2) {
  const statSync = opts2.dereference ? fs$d.statSync : fs$d.lstatSync;
  const srcStat = statSync(src);
  if (srcStat.isDirectory())
    return onDir(srcStat, destStat, src, dest, opts2);
  else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
    return onFile(srcStat, destStat, src, dest, opts2);
  else if (srcStat.isSymbolicLink())
    return onLink(destStat, src, dest, opts2);
  else if (srcStat.isSocket())
    throw new Error(`Cannot copy a socket file: ${src}`);
  else if (srcStat.isFIFO())
    throw new Error(`Cannot copy a FIFO pipe: ${src}`);
  throw new Error(`Unknown file: ${src}`);
}
function onFile(srcStat, destStat, src, dest, opts2) {
  if (!destStat)
    return copyFile(srcStat, src, dest, opts2);
  return mayCopyFile(srcStat, src, dest, opts2);
}
function mayCopyFile(srcStat, src, dest, opts2) {
  if (opts2.overwrite) {
    fs$d.unlinkSync(dest);
    return copyFile(srcStat, src, dest, opts2);
  } else if (opts2.errorOnExist) {
    throw new Error(`'${dest}' already exists`);
  }
}
function copyFile(srcStat, src, dest, opts2) {
  fs$d.copyFileSync(src, dest);
  if (opts2.preserveTimestamps)
    handleTimestamps(srcStat.mode, src, dest);
  return setDestMode(dest, srcStat.mode);
}
function handleTimestamps(srcMode, src, dest) {
  if (fileIsNotWritable(srcMode))
    makeFileWritable(dest, srcMode);
  return setDestTimestamps(src, dest);
}
function fileIsNotWritable(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable(dest, srcMode) {
  return setDestMode(dest, srcMode | 128);
}
function setDestMode(dest, srcMode) {
  return fs$d.chmodSync(dest, srcMode);
}
function setDestTimestamps(src, dest) {
  const updatedSrcStat = fs$d.statSync(src);
  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
}
function onDir(srcStat, destStat, src, dest, opts2) {
  if (!destStat)
    return mkDirAndCopy(srcStat.mode, src, dest, opts2);
  return copyDir(src, dest, opts2);
}
function mkDirAndCopy(srcMode, src, dest, opts2) {
  fs$d.mkdirSync(dest);
  copyDir(src, dest, opts2);
  return setDestMode(dest, srcMode);
}
function copyDir(src, dest, opts2) {
  fs$d.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts2));
}
function copyDirItem(item, src, dest, opts2) {
  const srcItem = path$e.join(src, item);
  const destItem = path$e.join(dest, item);
  if (opts2.filter && !opts2.filter(srcItem, destItem))
    return;
  const { destStat } = stat$2.checkPathsSync(srcItem, destItem, "copy", opts2);
  return getStats(destStat, srcItem, destItem, opts2);
}
function onLink(destStat, src, dest, opts2) {
  let resolvedSrc = fs$d.readlinkSync(src);
  if (opts2.dereference) {
    resolvedSrc = path$e.resolve(process.cwd(), resolvedSrc);
  }
  if (!destStat) {
    return fs$d.symlinkSync(resolvedSrc, dest);
  } else {
    let resolvedDest;
    try {
      resolvedDest = fs$d.readlinkSync(dest);
    } catch (err) {
      if (err.code === "EINVAL" || err.code === "UNKNOWN")
        return fs$d.symlinkSync(resolvedSrc, dest);
      throw err;
    }
    if (opts2.dereference) {
      resolvedDest = path$e.resolve(process.cwd(), resolvedDest);
    }
    if (stat$2.isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
    }
    if (stat$2.isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
    }
    return copyLink(resolvedSrc, dest);
  }
}
function copyLink(resolvedSrc, dest) {
  fs$d.unlinkSync(dest);
  return fs$d.symlinkSync(resolvedSrc, dest);
}
var copySync_1 = copySync$1;
const u$a = universalify$1.fromPromise;
var copy$1 = {
  copy: u$a(copy_1),
  copySync: copySync_1
};
const fs$c = gracefulFs;
const u$9 = universalify$1.fromCallback;
function remove$2(path2, callback) {
  fs$c.rm(path2, { recursive: true, force: true }, callback);
}
function removeSync$1(path2) {
  fs$c.rmSync(path2, { recursive: true, force: true });
}
var remove_1 = {
  remove: u$9(remove$2),
  removeSync: removeSync$1
};
const u$8 = universalify$1.fromPromise;
const fs$b = fs$k;
const path$d = require$$1;
const mkdir$3 = mkdirs$2;
const remove$1 = remove_1;
const emptyDir = u$8(async function emptyDir2(dir) {
  let items2;
  try {
    items2 = await fs$b.readdir(dir);
  } catch {
    return mkdir$3.mkdirs(dir);
  }
  return Promise.all(items2.map((item) => remove$1.remove(path$d.join(dir, item))));
});
function emptyDirSync(dir) {
  let items2;
  try {
    items2 = fs$b.readdirSync(dir);
  } catch {
    return mkdir$3.mkdirsSync(dir);
  }
  items2.forEach((item) => {
    item = path$d.join(dir, item);
    remove$1.removeSync(item);
  });
}
var empty = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
};
const u$7 = universalify$1.fromPromise;
const path$c = require$$1;
const fs$a = fs$k;
const mkdir$2 = mkdirs$2;
async function createFile$1(file2) {
  let stats;
  try {
    stats = await fs$a.stat(file2);
  } catch {
  }
  if (stats && stats.isFile())
    return;
  const dir = path$c.dirname(file2);
  let dirStats = null;
  try {
    dirStats = await fs$a.stat(dir);
  } catch (err) {
    if (err.code === "ENOENT") {
      await mkdir$2.mkdirs(dir);
      await fs$a.writeFile(file2, "");
      return;
    } else {
      throw err;
    }
  }
  if (dirStats.isDirectory()) {
    await fs$a.writeFile(file2, "");
  } else {
    await fs$a.readdir(dir);
  }
}
function createFileSync$1(file2) {
  let stats;
  try {
    stats = fs$a.statSync(file2);
  } catch {
  }
  if (stats && stats.isFile())
    return;
  const dir = path$c.dirname(file2);
  try {
    if (!fs$a.statSync(dir).isDirectory()) {
      fs$a.readdirSync(dir);
    }
  } catch (err) {
    if (err && err.code === "ENOENT")
      mkdir$2.mkdirsSync(dir);
    else
      throw err;
  }
  fs$a.writeFileSync(file2, "");
}
var file = {
  createFile: u$7(createFile$1),
  createFileSync: createFileSync$1
};
const u$6 = universalify$1.fromPromise;
const path$b = require$$1;
const fs$9 = fs$k;
const mkdir$1 = mkdirs$2;
const { pathExists: pathExists$6 } = pathExists_1;
const { areIdentical: areIdentical$1 } = stat$4;
async function createLink$1(srcpath, dstpath) {
  let dstStat;
  try {
    dstStat = await fs$9.lstat(dstpath);
  } catch {
  }
  let srcStat;
  try {
    srcStat = await fs$9.lstat(srcpath);
  } catch (err) {
    err.message = err.message.replace("lstat", "ensureLink");
    throw err;
  }
  if (dstStat && areIdentical$1(srcStat, dstStat))
    return;
  const dir = path$b.dirname(dstpath);
  const dirExists = await pathExists$6(dir);
  if (!dirExists) {
    await mkdir$1.mkdirs(dir);
  }
  await fs$9.link(srcpath, dstpath);
}
function createLinkSync$1(srcpath, dstpath) {
  let dstStat;
  try {
    dstStat = fs$9.lstatSync(dstpath);
  } catch {
  }
  try {
    const srcStat = fs$9.lstatSync(srcpath);
    if (dstStat && areIdentical$1(srcStat, dstStat))
      return;
  } catch (err) {
    err.message = err.message.replace("lstat", "ensureLink");
    throw err;
  }
  const dir = path$b.dirname(dstpath);
  const dirExists = fs$9.existsSync(dir);
  if (dirExists)
    return fs$9.linkSync(srcpath, dstpath);
  mkdir$1.mkdirsSync(dir);
  return fs$9.linkSync(srcpath, dstpath);
}
var link = {
  createLink: u$6(createLink$1),
  createLinkSync: createLinkSync$1
};
const path$a = require$$1;
const fs$8 = fs$k;
const { pathExists: pathExists$5 } = pathExists_1;
const u$5 = universalify$1.fromPromise;
async function symlinkPaths$1(srcpath, dstpath) {
  if (path$a.isAbsolute(srcpath)) {
    try {
      await fs$8.lstat(srcpath);
    } catch (err) {
      err.message = err.message.replace("lstat", "ensureSymlink");
      throw err;
    }
    return {
      toCwd: srcpath,
      toDst: srcpath
    };
  }
  const dstdir = path$a.dirname(dstpath);
  const relativeToDst = path$a.join(dstdir, srcpath);
  const exists = await pathExists$5(relativeToDst);
  if (exists) {
    return {
      toCwd: relativeToDst,
      toDst: srcpath
    };
  }
  try {
    await fs$8.lstat(srcpath);
  } catch (err) {
    err.message = err.message.replace("lstat", "ensureSymlink");
    throw err;
  }
  return {
    toCwd: srcpath,
    toDst: path$a.relative(dstdir, srcpath)
  };
}
function symlinkPathsSync$1(srcpath, dstpath) {
  if (path$a.isAbsolute(srcpath)) {
    const exists2 = fs$8.existsSync(srcpath);
    if (!exists2)
      throw new Error("absolute srcpath does not exist");
    return {
      toCwd: srcpath,
      toDst: srcpath
    };
  }
  const dstdir = path$a.dirname(dstpath);
  const relativeToDst = path$a.join(dstdir, srcpath);
  const exists = fs$8.existsSync(relativeToDst);
  if (exists) {
    return {
      toCwd: relativeToDst,
      toDst: srcpath
    };
  }
  const srcExists = fs$8.existsSync(srcpath);
  if (!srcExists)
    throw new Error("relative srcpath does not exist");
  return {
    toCwd: srcpath,
    toDst: path$a.relative(dstdir, srcpath)
  };
}
var symlinkPaths_1 = {
  symlinkPaths: u$5(symlinkPaths$1),
  symlinkPathsSync: symlinkPathsSync$1
};
const fs$7 = fs$k;
const u$4 = universalify$1.fromPromise;
async function symlinkType$1(srcpath, type2) {
  if (type2)
    return type2;
  let stats;
  try {
    stats = await fs$7.lstat(srcpath);
  } catch {
    return "file";
  }
  return stats && stats.isDirectory() ? "dir" : "file";
}
function symlinkTypeSync$1(srcpath, type2) {
  if (type2)
    return type2;
  let stats;
  try {
    stats = fs$7.lstatSync(srcpath);
  } catch {
    return "file";
  }
  return stats && stats.isDirectory() ? "dir" : "file";
}
var symlinkType_1 = {
  symlinkType: u$4(symlinkType$1),
  symlinkTypeSync: symlinkTypeSync$1
};
const u$3 = universalify$1.fromPromise;
const path$9 = require$$1;
const fs$6 = fs$k;
const { mkdirs, mkdirsSync } = mkdirs$2;
const { symlinkPaths, symlinkPathsSync } = symlinkPaths_1;
const { symlinkType, symlinkTypeSync } = symlinkType_1;
const { pathExists: pathExists$4 } = pathExists_1;
const { areIdentical } = stat$4;
async function createSymlink$1(srcpath, dstpath, type2) {
  let stats;
  try {
    stats = await fs$6.lstat(dstpath);
  } catch {
  }
  if (stats && stats.isSymbolicLink()) {
    const [srcStat, dstStat] = await Promise.all([
      fs$6.stat(srcpath),
      fs$6.stat(dstpath)
    ]);
    if (areIdentical(srcStat, dstStat))
      return;
  }
  const relative = await symlinkPaths(srcpath, dstpath);
  srcpath = relative.toDst;
  const toType = await symlinkType(relative.toCwd, type2);
  const dir = path$9.dirname(dstpath);
  if (!await pathExists$4(dir)) {
    await mkdirs(dir);
  }
  return fs$6.symlink(srcpath, dstpath, toType);
}
function createSymlinkSync$1(srcpath, dstpath, type2) {
  let stats;
  try {
    stats = fs$6.lstatSync(dstpath);
  } catch {
  }
  if (stats && stats.isSymbolicLink()) {
    const srcStat = fs$6.statSync(srcpath);
    const dstStat = fs$6.statSync(dstpath);
    if (areIdentical(srcStat, dstStat))
      return;
  }
  const relative = symlinkPathsSync(srcpath, dstpath);
  srcpath = relative.toDst;
  type2 = symlinkTypeSync(relative.toCwd, type2);
  const dir = path$9.dirname(dstpath);
  const exists = fs$6.existsSync(dir);
  if (exists)
    return fs$6.symlinkSync(srcpath, dstpath, type2);
  mkdirsSync(dir);
  return fs$6.symlinkSync(srcpath, dstpath, type2);
}
var symlink = {
  createSymlink: u$3(createSymlink$1),
  createSymlinkSync: createSymlinkSync$1
};
const { createFile, createFileSync } = file;
const { createLink, createLinkSync } = link;
const { createSymlink, createSymlinkSync } = symlink;
var ensure = {
  // file
  createFile,
  createFileSync,
  ensureFile: createFile,
  ensureFileSync: createFileSync,
  // link
  createLink,
  createLinkSync,
  ensureLink: createLink,
  ensureLinkSync: createLinkSync,
  // symlink
  createSymlink,
  createSymlinkSync,
  ensureSymlink: createSymlink,
  ensureSymlinkSync: createSymlinkSync
};
function stringify$3(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
  const EOF = finalEOL ? EOL : "";
  const str = JSON.stringify(obj, replacer, spaces);
  return str.replace(/\n/g, EOL) + EOF;
}
function stripBom$1(content) {
  if (Buffer.isBuffer(content))
    content = content.toString("utf8");
  return content.replace(/^\uFEFF/, "");
}
var utils = { stringify: stringify$3, stripBom: stripBom$1 };
let _fs;
try {
  _fs = gracefulFs;
} catch (_) {
  _fs = require$$0$3;
}
const universalify = universalify$1;
const { stringify: stringify$2, stripBom } = utils;
async function _readFile(file2, options = {}) {
  if (typeof options === "string") {
    options = { encoding: options };
  }
  const fs2 = options.fs || _fs;
  const shouldThrow = "throws" in options ? options.throws : true;
  let data = await universalify.fromCallback(fs2.readFile)(file2, options);
  data = stripBom(data);
  let obj;
  try {
    obj = JSON.parse(data, options ? options.reviver : null);
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file2}: ${err.message}`;
      throw err;
    } else {
      return null;
    }
  }
  return obj;
}
const readFile$1 = universalify.fromPromise(_readFile);
function readFileSync$1(file2, options = {}) {
  if (typeof options === "string") {
    options = { encoding: options };
  }
  const fs2 = options.fs || _fs;
  const shouldThrow = "throws" in options ? options.throws : true;
  try {
    let content = fs2.readFileSync(file2, options);
    content = stripBom(content);
    return JSON.parse(content, options.reviver);
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file2}: ${err.message}`;
      throw err;
    } else {
      return null;
    }
  }
}
async function _writeFile(file2, obj, options = {}) {
  const fs2 = options.fs || _fs;
  const str = stringify$2(obj, options);
  await universalify.fromCallback(fs2.writeFile)(file2, str, options);
}
const writeFile$1 = universalify.fromPromise(_writeFile);
function writeFileSync$1(file2, obj, options = {}) {
  const fs2 = options.fs || _fs;
  const str = stringify$2(obj, options);
  return fs2.writeFileSync(file2, str, options);
}
const jsonfile$1 = {
  readFile: readFile$1,
  readFileSync: readFileSync$1,
  writeFile: writeFile$1,
  writeFileSync: writeFileSync$1
};
var jsonfile_1 = jsonfile$1;
const jsonFile$1 = jsonfile_1;
var jsonfile = {
  // jsonfile exports
  readJson: jsonFile$1.readFile,
  readJsonSync: jsonFile$1.readFileSync,
  writeJson: jsonFile$1.writeFile,
  writeJsonSync: jsonFile$1.writeFileSync
};
const u$2 = universalify$1.fromPromise;
const fs$5 = fs$k;
const path$8 = require$$1;
const mkdir = mkdirs$2;
const pathExists$3 = pathExists_1.pathExists;
async function outputFile$1(file2, data, encoding = "utf-8") {
  const dir = path$8.dirname(file2);
  if (!await pathExists$3(dir)) {
    await mkdir.mkdirs(dir);
  }
  return fs$5.writeFile(file2, data, encoding);
}
function outputFileSync$1(file2, ...args) {
  const dir = path$8.dirname(file2);
  if (!fs$5.existsSync(dir)) {
    mkdir.mkdirsSync(dir);
  }
  fs$5.writeFileSync(file2, ...args);
}
var outputFile_1 = {
  outputFile: u$2(outputFile$1),
  outputFileSync: outputFileSync$1
};
const { stringify: stringify$1 } = utils;
const { outputFile } = outputFile_1;
async function outputJson(file2, data, options = {}) {
  const str = stringify$1(data, options);
  await outputFile(file2, str, options);
}
var outputJson_1 = outputJson;
const { stringify } = utils;
const { outputFileSync } = outputFile_1;
function outputJsonSync(file2, data, options) {
  const str = stringify(data, options);
  outputFileSync(file2, str, options);
}
var outputJsonSync_1 = outputJsonSync;
const u$1 = universalify$1.fromPromise;
const jsonFile = jsonfile;
jsonFile.outputJson = u$1(outputJson_1);
jsonFile.outputJsonSync = outputJsonSync_1;
jsonFile.outputJSON = jsonFile.outputJson;
jsonFile.outputJSONSync = jsonFile.outputJsonSync;
jsonFile.writeJSON = jsonFile.writeJson;
jsonFile.writeJSONSync = jsonFile.writeJsonSync;
jsonFile.readJSON = jsonFile.readJson;
jsonFile.readJSONSync = jsonFile.readJsonSync;
var json = jsonFile;
const fs$4 = fs$k;
const path$7 = require$$1;
const { copy } = copy$1;
const { remove } = remove_1;
const { mkdirp } = mkdirs$2;
const { pathExists: pathExists$2 } = pathExists_1;
const stat$1 = stat$4;
async function move$1(src, dest, opts2 = {}) {
  const overwrite = opts2.overwrite || opts2.clobber || false;
  const { srcStat, isChangingCase = false } = await stat$1.checkPaths(src, dest, "move", opts2);
  await stat$1.checkParentPaths(src, srcStat, dest, "move");
  const destParent = path$7.dirname(dest);
  const parsedParentPath = path$7.parse(destParent);
  if (parsedParentPath.root !== destParent) {
    await mkdirp(destParent);
  }
  return doRename$1(src, dest, overwrite, isChangingCase);
}
async function doRename$1(src, dest, overwrite, isChangingCase) {
  if (!isChangingCase) {
    if (overwrite) {
      await remove(dest);
    } else if (await pathExists$2(dest)) {
      throw new Error("dest already exists.");
    }
  }
  try {
    await fs$4.rename(src, dest);
  } catch (err) {
    if (err.code !== "EXDEV") {
      throw err;
    }
    await moveAcrossDevice$1(src, dest, overwrite);
  }
}
async function moveAcrossDevice$1(src, dest, overwrite) {
  const opts2 = {
    overwrite,
    errorOnExist: true,
    preserveTimestamps: true
  };
  await copy(src, dest, opts2);
  return remove(src);
}
var move_1 = move$1;
const fs$3 = gracefulFs;
const path$6 = require$$1;
const copySync = copy$1.copySync;
const removeSync = remove_1.removeSync;
const mkdirpSync = mkdirs$2.mkdirpSync;
const stat = stat$4;
function moveSync(src, dest, opts2) {
  opts2 = opts2 || {};
  const overwrite = opts2.overwrite || opts2.clobber || false;
  const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, "move", opts2);
  stat.checkParentPathsSync(src, srcStat, dest, "move");
  if (!isParentRoot(dest))
    mkdirpSync(path$6.dirname(dest));
  return doRename(src, dest, overwrite, isChangingCase);
}
function isParentRoot(dest) {
  const parent = path$6.dirname(dest);
  const parsedPath = path$6.parse(parent);
  return parsedPath.root === parent;
}
function doRename(src, dest, overwrite, isChangingCase) {
  if (isChangingCase)
    return rename(src, dest, overwrite);
  if (overwrite) {
    removeSync(dest);
    return rename(src, dest, overwrite);
  }
  if (fs$3.existsSync(dest))
    throw new Error("dest already exists.");
  return rename(src, dest, overwrite);
}
function rename(src, dest, overwrite) {
  try {
    fs$3.renameSync(src, dest);
  } catch (err) {
    if (err.code !== "EXDEV")
      throw err;
    return moveAcrossDevice(src, dest, overwrite);
  }
}
function moveAcrossDevice(src, dest, overwrite) {
  const opts2 = {
    overwrite,
    errorOnExist: true,
    preserveTimestamps: true
  };
  copySync(src, dest, opts2);
  return removeSync(src);
}
var moveSync_1 = moveSync;
const u = universalify$1.fromPromise;
var move = {
  move: u(move_1),
  moveSync: moveSync_1
};
var lib = {
  // Export promiseified graceful-fs:
  ...fs$k,
  // Export extra methods:
  ...copy$1,
  ...empty,
  ...ensure,
  ...json,
  ...mkdirs$2,
  ...move,
  ...outputFile_1,
  ...pathExists_1,
  ...remove_1
};
var source = { exports: {} };
var isObj$1 = (value) => {
  const type2 = typeof value;
  return value !== null && (type2 === "object" || type2 === "function");
};
const isObj = isObj$1;
const disallowedKeys = /* @__PURE__ */ new Set([
  "__proto__",
  "prototype",
  "constructor"
]);
const isValidPath = (pathSegments) => !pathSegments.some((segment) => disallowedKeys.has(segment));
function getPathSegments(path2) {
  const pathArray = path2.split(".");
  const parts = [];
  for (let i = 0; i < pathArray.length; i++) {
    let p = pathArray[i];
    while (p[p.length - 1] === "\\" && pathArray[i + 1] !== void 0) {
      p = p.slice(0, -1) + ".";
      p += pathArray[++i];
    }
    parts.push(p);
  }
  if (!isValidPath(parts)) {
    return [];
  }
  return parts;
}
var dotProp = {
  get(object, path2, value) {
    if (!isObj(object) || typeof path2 !== "string") {
      return value === void 0 ? object : value;
    }
    const pathArray = getPathSegments(path2);
    if (pathArray.length === 0) {
      return;
    }
    for (let i = 0; i < pathArray.length; i++) {
      object = object[pathArray[i]];
      if (object === void 0 || object === null) {
        if (i !== pathArray.length - 1) {
          return value;
        }
        break;
      }
    }
    return object === void 0 ? value : object;
  },
  set(object, path2, value) {
    if (!isObj(object) || typeof path2 !== "string") {
      return object;
    }
    const root = object;
    const pathArray = getPathSegments(path2);
    for (let i = 0; i < pathArray.length; i++) {
      const p = pathArray[i];
      if (!isObj(object[p])) {
        object[p] = {};
      }
      if (i === pathArray.length - 1) {
        object[p] = value;
      }
      object = object[p];
    }
    return root;
  },
  delete(object, path2) {
    if (!isObj(object) || typeof path2 !== "string") {
      return false;
    }
    const pathArray = getPathSegments(path2);
    for (let i = 0; i < pathArray.length; i++) {
      const p = pathArray[i];
      if (i === pathArray.length - 1) {
        delete object[p];
        return true;
      }
      object = object[p];
      if (!isObj(object)) {
        return false;
      }
    }
  },
  has(object, path2) {
    if (!isObj(object) || typeof path2 !== "string") {
      return false;
    }
    const pathArray = getPathSegments(path2);
    if (pathArray.length === 0) {
      return false;
    }
    for (let i = 0; i < pathArray.length; i++) {
      if (isObj(object)) {
        if (!(pathArray[i] in object)) {
          return false;
        }
        object = object[pathArray[i]];
      } else {
        return false;
      }
    }
    return true;
  }
};
var pkgUp = { exports: {} };
var findUp$1 = { exports: {} };
var locatePath$1 = { exports: {} };
var pathExists$1 = { exports: {} };
const fs$2 = require$$0$3;
pathExists$1.exports = (fp) => new Promise((resolve2) => {
  fs$2.access(fp, (err) => {
    resolve2(!err);
  });
});
pathExists$1.exports.sync = (fp) => {
  try {
    fs$2.accessSync(fp);
    return true;
  } catch (err) {
    return false;
  }
};
var pathExistsExports = pathExists$1.exports;
var pLimit$2 = { exports: {} };
var pTry$2 = { exports: {} };
const pTry$1 = (fn, ...arguments_) => new Promise((resolve2) => {
  resolve2(fn(...arguments_));
});
pTry$2.exports = pTry$1;
pTry$2.exports.default = pTry$1;
var pTryExports = pTry$2.exports;
const pTry = pTryExports;
const pLimit$1 = (concurrency) => {
  if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
    return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
  }
  const queue = [];
  let activeCount = 0;
  const next = () => {
    activeCount--;
    if (queue.length > 0) {
      queue.shift()();
    }
  };
  const run = (fn, resolve2, ...args) => {
    activeCount++;
    const result = pTry(fn, ...args);
    resolve2(result);
    result.then(next, next);
  };
  const enqueue2 = (fn, resolve2, ...args) => {
    if (activeCount < concurrency) {
      run(fn, resolve2, ...args);
    } else {
      queue.push(run.bind(null, fn, resolve2, ...args));
    }
  };
  const generator = (fn, ...args) => new Promise((resolve2) => enqueue2(fn, resolve2, ...args));
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue.length
    },
    clearQueue: {
      value: () => {
        queue.length = 0;
      }
    }
  });
  return generator;
};
pLimit$2.exports = pLimit$1;
pLimit$2.exports.default = pLimit$1;
var pLimitExports = pLimit$2.exports;
const pLimit = pLimitExports;
class EndError extends Error {
  constructor(value) {
    super();
    this.value = value;
  }
}
const testElement = (el, tester) => Promise.resolve(el).then(tester);
const finder = (el) => Promise.all(el).then((val) => val[1] === true && Promise.reject(new EndError(val[0])));
var pLocate$1 = (iterable, tester, opts2) => {
  opts2 = Object.assign({
    concurrency: Infinity,
    preserveOrder: true
  }, opts2);
  const limit2 = pLimit(opts2.concurrency);
  const items2 = [...iterable].map((el) => [el, limit2(testElement, el, tester)]);
  const checkLimit = pLimit(opts2.preserveOrder ? 1 : Infinity);
  return Promise.all(items2.map((el) => checkLimit(finder, el))).then(() => {
  }).catch((err) => err instanceof EndError ? err.value : Promise.reject(err));
};
const path$5 = require$$1;
const pathExists = pathExistsExports;
const pLocate = pLocate$1;
locatePath$1.exports = (iterable, options) => {
  options = Object.assign({
    cwd: process.cwd()
  }, options);
  return pLocate(iterable, (el) => pathExists(path$5.resolve(options.cwd, el)), options);
};
locatePath$1.exports.sync = (iterable, options) => {
  options = Object.assign({
    cwd: process.cwd()
  }, options);
  for (const el of iterable) {
    if (pathExists.sync(path$5.resolve(options.cwd, el))) {
      return el;
    }
  }
};
var locatePathExports = locatePath$1.exports;
const path$4 = require$$1;
const locatePath = locatePathExports;
findUp$1.exports = (filename, opts2 = {}) => {
  const startDir = path$4.resolve(opts2.cwd || "");
  const { root } = path$4.parse(startDir);
  const filenames = [].concat(filename);
  return new Promise((resolve2) => {
    (function find(dir) {
      locatePath(filenames, { cwd: dir }).then((file2) => {
        if (file2) {
          resolve2(path$4.join(dir, file2));
        } else if (dir === root) {
          resolve2(null);
        } else {
          find(path$4.dirname(dir));
        }
      });
    })(startDir);
  });
};
findUp$1.exports.sync = (filename, opts2 = {}) => {
  let dir = path$4.resolve(opts2.cwd || "");
  const { root } = path$4.parse(dir);
  const filenames = [].concat(filename);
  while (true) {
    const file2 = locatePath.sync(filenames, { cwd: dir });
    if (file2) {
      return path$4.join(dir, file2);
    }
    if (dir === root) {
      return null;
    }
    dir = path$4.dirname(dir);
  }
};
var findUpExports = findUp$1.exports;
const findUp = findUpExports;
pkgUp.exports = async ({ cwd: cwd2 } = {}) => findUp("package.json", { cwd: cwd2 });
pkgUp.exports.sync = ({ cwd: cwd2 } = {}) => findUp.sync("package.json", { cwd: cwd2 });
var pkgUpExports = pkgUp.exports;
var envPaths$1 = { exports: {} };
const path$3 = require$$1;
const os = require$$1$1;
const homedir = os.homedir();
const tmpdir = os.tmpdir();
const { env: env$1 } = process;
const macos = (name) => {
  const library = path$3.join(homedir, "Library");
  return {
    data: path$3.join(library, "Application Support", name),
    config: path$3.join(library, "Preferences", name),
    cache: path$3.join(library, "Caches", name),
    log: path$3.join(library, "Logs", name),
    temp: path$3.join(tmpdir, name)
  };
};
const windows = (name) => {
  const appData = env$1.APPDATA || path$3.join(homedir, "AppData", "Roaming");
  const localAppData = env$1.LOCALAPPDATA || path$3.join(homedir, "AppData", "Local");
  return {
    // Data/config/cache/log are invented by me as Windows isn't opinionated about this
    data: path$3.join(localAppData, name, "Data"),
    config: path$3.join(appData, name, "Config"),
    cache: path$3.join(localAppData, name, "Cache"),
    log: path$3.join(localAppData, name, "Log"),
    temp: path$3.join(tmpdir, name)
  };
};
const linux = (name) => {
  const username = path$3.basename(homedir);
  return {
    data: path$3.join(env$1.XDG_DATA_HOME || path$3.join(homedir, ".local", "share"), name),
    config: path$3.join(env$1.XDG_CONFIG_HOME || path$3.join(homedir, ".config"), name),
    cache: path$3.join(env$1.XDG_CACHE_HOME || path$3.join(homedir, ".cache"), name),
    // https://wiki.debian.org/XDGBaseDirectorySpecification#state
    log: path$3.join(env$1.XDG_STATE_HOME || path$3.join(homedir, ".local", "state"), name),
    temp: path$3.join(tmpdir, username, name)
  };
};
const envPaths = (name, options) => {
  if (typeof name !== "string") {
    throw new TypeError(`Expected string, got ${typeof name}`);
  }
  options = Object.assign({ suffix: "nodejs" }, options);
  if (options.suffix) {
    name += `-${options.suffix}`;
  }
  if (process.platform === "darwin") {
    return macos(name);
  }
  if (process.platform === "win32") {
    return windows(name);
  }
  return linux(name);
};
envPaths$1.exports = envPaths;
envPaths$1.exports.default = envPaths;
var envPathsExports = envPaths$1.exports;
var dist$1 = {};
var consts = {};
Object.defineProperty(consts, "__esModule", { value: true });
consts.NOOP = consts.LIMIT_FILES_DESCRIPTORS = consts.LIMIT_BASENAME_LENGTH = consts.IS_USER_ROOT = consts.IS_POSIX = consts.DEFAULT_TIMEOUT_SYNC = consts.DEFAULT_TIMEOUT_ASYNC = consts.DEFAULT_WRITE_OPTIONS = consts.DEFAULT_READ_OPTIONS = consts.DEFAULT_FOLDER_MODE = consts.DEFAULT_FILE_MODE = consts.DEFAULT_ENCODING = void 0;
const DEFAULT_ENCODING = "utf8";
consts.DEFAULT_ENCODING = DEFAULT_ENCODING;
const DEFAULT_FILE_MODE = 438;
consts.DEFAULT_FILE_MODE = DEFAULT_FILE_MODE;
const DEFAULT_FOLDER_MODE = 511;
consts.DEFAULT_FOLDER_MODE = DEFAULT_FOLDER_MODE;
const DEFAULT_READ_OPTIONS = {};
consts.DEFAULT_READ_OPTIONS = DEFAULT_READ_OPTIONS;
const DEFAULT_WRITE_OPTIONS = {};
consts.DEFAULT_WRITE_OPTIONS = DEFAULT_WRITE_OPTIONS;
const DEFAULT_TIMEOUT_ASYNC = 5e3;
consts.DEFAULT_TIMEOUT_ASYNC = DEFAULT_TIMEOUT_ASYNC;
const DEFAULT_TIMEOUT_SYNC = 100;
consts.DEFAULT_TIMEOUT_SYNC = DEFAULT_TIMEOUT_SYNC;
const IS_POSIX = !!process.getuid;
consts.IS_POSIX = IS_POSIX;
const IS_USER_ROOT = process.getuid ? !process.getuid() : false;
consts.IS_USER_ROOT = IS_USER_ROOT;
const LIMIT_BASENAME_LENGTH = 128;
consts.LIMIT_BASENAME_LENGTH = LIMIT_BASENAME_LENGTH;
const LIMIT_FILES_DESCRIPTORS = 1e4;
consts.LIMIT_FILES_DESCRIPTORS = LIMIT_FILES_DESCRIPTORS;
const NOOP = () => {
};
consts.NOOP = NOOP;
var fs$1 = {};
var attemptify = {};
Object.defineProperty(attemptify, "__esModule", { value: true });
attemptify.attemptifySync = attemptify.attemptifyAsync = void 0;
const consts_1$4 = consts;
const attemptifyAsync = (fn, onError = consts_1$4.NOOP) => {
  return function() {
    return fn.apply(void 0, arguments).catch(onError);
  };
};
attemptify.attemptifyAsync = attemptifyAsync;
const attemptifySync = (fn, onError = consts_1$4.NOOP) => {
  return function() {
    try {
      return fn.apply(void 0, arguments);
    } catch (error2) {
      return onError(error2);
    }
  };
};
attemptify.attemptifySync = attemptifySync;
var fs_handlers = {};
Object.defineProperty(fs_handlers, "__esModule", { value: true });
const consts_1$3 = consts;
const Handlers = {
  isChangeErrorOk: (error2) => {
    const { code: code2 } = error2;
    if (code2 === "ENOSYS")
      return true;
    if (!consts_1$3.IS_USER_ROOT && (code2 === "EINVAL" || code2 === "EPERM"))
      return true;
    return false;
  },
  isRetriableError: (error2) => {
    const { code: code2 } = error2;
    if (code2 === "EMFILE" || code2 === "ENFILE" || code2 === "EAGAIN" || code2 === "EBUSY" || code2 === "EACCESS" || code2 === "EACCS" || code2 === "EPERM")
      return true;
    return false;
  },
  onChangeError: (error2) => {
    if (Handlers.isChangeErrorOk(error2))
      return;
    throw error2;
  }
};
fs_handlers.default = Handlers;
var retryify = {};
var retryify_queue = {};
Object.defineProperty(retryify_queue, "__esModule", { value: true });
const consts_1$2 = consts;
const RetryfyQueue = {
  interval: 25,
  intervalId: void 0,
  limit: consts_1$2.LIMIT_FILES_DESCRIPTORS,
  queueActive: /* @__PURE__ */ new Set(),
  queueWaiting: /* @__PURE__ */ new Set(),
  init: () => {
    if (RetryfyQueue.intervalId)
      return;
    RetryfyQueue.intervalId = setInterval(RetryfyQueue.tick, RetryfyQueue.interval);
  },
  reset: () => {
    if (!RetryfyQueue.intervalId)
      return;
    clearInterval(RetryfyQueue.intervalId);
    delete RetryfyQueue.intervalId;
  },
  add: (fn) => {
    RetryfyQueue.queueWaiting.add(fn);
    if (RetryfyQueue.queueActive.size < RetryfyQueue.limit / 2) {
      RetryfyQueue.tick();
    } else {
      RetryfyQueue.init();
    }
  },
  remove: (fn) => {
    RetryfyQueue.queueWaiting.delete(fn);
    RetryfyQueue.queueActive.delete(fn);
  },
  schedule: () => {
    return new Promise((resolve2) => {
      const cleanup = () => RetryfyQueue.remove(resolver);
      const resolver = () => resolve2(cleanup);
      RetryfyQueue.add(resolver);
    });
  },
  tick: () => {
    if (RetryfyQueue.queueActive.size >= RetryfyQueue.limit)
      return;
    if (!RetryfyQueue.queueWaiting.size)
      return RetryfyQueue.reset();
    for (const fn of RetryfyQueue.queueWaiting) {
      if (RetryfyQueue.queueActive.size >= RetryfyQueue.limit)
        break;
      RetryfyQueue.queueWaiting.delete(fn);
      RetryfyQueue.queueActive.add(fn);
      fn();
    }
  }
};
retryify_queue.default = RetryfyQueue;
Object.defineProperty(retryify, "__esModule", { value: true });
retryify.retryifySync = retryify.retryifyAsync = void 0;
const retryify_queue_1 = retryify_queue;
const retryifyAsync = (fn, isRetriableError) => {
  return function(timestamp) {
    return function attempt() {
      return retryify_queue_1.default.schedule().then((cleanup) => {
        return fn.apply(void 0, arguments).then((result) => {
          cleanup();
          return result;
        }, (error2) => {
          cleanup();
          if (Date.now() >= timestamp)
            throw error2;
          if (isRetriableError(error2)) {
            const delay = Math.round(100 + 400 * Math.random()), delayPromise = new Promise((resolve2) => setTimeout(resolve2, delay));
            return delayPromise.then(() => attempt.apply(void 0, arguments));
          }
          throw error2;
        });
      });
    };
  };
};
retryify.retryifyAsync = retryifyAsync;
const retryifySync = (fn, isRetriableError) => {
  return function(timestamp) {
    return function attempt() {
      try {
        return fn.apply(void 0, arguments);
      } catch (error2) {
        if (Date.now() > timestamp)
          throw error2;
        if (isRetriableError(error2))
          return attempt.apply(void 0, arguments);
        throw error2;
      }
    };
  };
};
retryify.retryifySync = retryifySync;
Object.defineProperty(fs$1, "__esModule", { value: true });
const fs = require$$0$3;
const util_1$p = require$$4;
const attemptify_1 = attemptify;
const fs_handlers_1 = fs_handlers;
const retryify_1 = retryify;
const FS = {
  chmodAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.chmod), fs_handlers_1.default.onChangeError),
  chownAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.chown), fs_handlers_1.default.onChangeError),
  closeAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.close)),
  fsyncAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.fsync)),
  mkdirAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.mkdir)),
  realpathAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.realpath)),
  statAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.stat)),
  unlinkAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.unlink)),
  closeRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.close), fs_handlers_1.default.isRetriableError),
  fsyncRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.fsync), fs_handlers_1.default.isRetriableError),
  openRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.open), fs_handlers_1.default.isRetriableError),
  readFileRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.readFile), fs_handlers_1.default.isRetriableError),
  renameRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.rename), fs_handlers_1.default.isRetriableError),
  statRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.stat), fs_handlers_1.default.isRetriableError),
  writeRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.write), fs_handlers_1.default.isRetriableError),
  chmodSyncAttempt: attemptify_1.attemptifySync(fs.chmodSync, fs_handlers_1.default.onChangeError),
  chownSyncAttempt: attemptify_1.attemptifySync(fs.chownSync, fs_handlers_1.default.onChangeError),
  closeSyncAttempt: attemptify_1.attemptifySync(fs.closeSync),
  mkdirSyncAttempt: attemptify_1.attemptifySync(fs.mkdirSync),
  realpathSyncAttempt: attemptify_1.attemptifySync(fs.realpathSync),
  statSyncAttempt: attemptify_1.attemptifySync(fs.statSync),
  unlinkSyncAttempt: attemptify_1.attemptifySync(fs.unlinkSync),
  closeSyncRetry: retryify_1.retryifySync(fs.closeSync, fs_handlers_1.default.isRetriableError),
  fsyncSyncRetry: retryify_1.retryifySync(fs.fsyncSync, fs_handlers_1.default.isRetriableError),
  openSyncRetry: retryify_1.retryifySync(fs.openSync, fs_handlers_1.default.isRetriableError),
  readFileSyncRetry: retryify_1.retryifySync(fs.readFileSync, fs_handlers_1.default.isRetriableError),
  renameSyncRetry: retryify_1.retryifySync(fs.renameSync, fs_handlers_1.default.isRetriableError),
  statSyncRetry: retryify_1.retryifySync(fs.statSync, fs_handlers_1.default.isRetriableError),
  writeSyncRetry: retryify_1.retryifySync(fs.writeSync, fs_handlers_1.default.isRetriableError)
};
fs$1.default = FS;
var lang = {};
Object.defineProperty(lang, "__esModule", { value: true });
const Lang = {
  isFunction: (x) => {
    return typeof x === "function";
  },
  isString: (x) => {
    return typeof x === "string";
  },
  isUndefined: (x) => {
    return typeof x === "undefined";
  }
};
lang.default = Lang;
var scheduler = {};
Object.defineProperty(scheduler, "__esModule", { value: true });
const Queues = {};
const Scheduler = {
  next: (id2) => {
    const queue = Queues[id2];
    if (!queue)
      return;
    queue.shift();
    const job = queue[0];
    if (job) {
      job(() => Scheduler.next(id2));
    } else {
      delete Queues[id2];
    }
  },
  schedule: (id2) => {
    return new Promise((resolve2) => {
      let queue = Queues[id2];
      if (!queue)
        queue = Queues[id2] = [];
      queue.push(resolve2);
      if (queue.length > 1)
        return;
      resolve2(() => Scheduler.next(id2));
    });
  }
};
scheduler.default = Scheduler;
var temp = {};
Object.defineProperty(temp, "__esModule", { value: true });
const path$2 = require$$1;
const consts_1$1 = consts;
const fs_1$1 = fs$1;
const Temp = {
  store: {},
  create: (filePath) => {
    const randomness = `000000${Math.floor(Math.random() * 16777215).toString(16)}`.slice(-6), timestamp = Date.now().toString().slice(-10), prefix = "tmp-", suffix = `.${prefix}${timestamp}${randomness}`, tempPath = `${filePath}${suffix}`;
    return tempPath;
  },
  get: (filePath, creator, purge = true) => {
    const tempPath = Temp.truncate(creator(filePath));
    if (tempPath in Temp.store)
      return Temp.get(filePath, creator, purge);
    Temp.store[tempPath] = purge;
    const disposer = () => delete Temp.store[tempPath];
    return [tempPath, disposer];
  },
  purge: (filePath) => {
    if (!Temp.store[filePath])
      return;
    delete Temp.store[filePath];
    fs_1$1.default.unlinkAttempt(filePath);
  },
  purgeSync: (filePath) => {
    if (!Temp.store[filePath])
      return;
    delete Temp.store[filePath];
    fs_1$1.default.unlinkSyncAttempt(filePath);
  },
  purgeSyncAll: () => {
    for (const filePath in Temp.store) {
      Temp.purgeSync(filePath);
    }
  },
  truncate: (filePath) => {
    const basename = path$2.basename(filePath);
    if (basename.length <= consts_1$1.LIMIT_BASENAME_LENGTH)
      return filePath;
    const truncable = /^(\.?)(.*?)((?:\.[^.]+)?(?:\.tmp-\d{10}[a-f0-9]{6})?)$/.exec(basename);
    if (!truncable)
      return filePath;
    const truncationLength = basename.length - consts_1$1.LIMIT_BASENAME_LENGTH;
    return `${filePath.slice(0, -basename.length)}${truncable[1]}${truncable[2].slice(0, -truncationLength)}${truncable[3]}`;
  }
};
process.on("exit", Temp.purgeSyncAll);
temp.default = Temp;
Object.defineProperty(dist$1, "__esModule", { value: true });
dist$1.writeFileSync = dist$1.writeFile = dist$1.readFileSync = dist$1.readFile = void 0;
const path$1 = require$$1;
const consts_1 = consts;
const fs_1 = fs$1;
const lang_1 = lang;
const scheduler_1 = scheduler;
const temp_1 = temp;
function readFile(filePath, options = consts_1.DEFAULT_READ_OPTIONS) {
  var _a;
  if (lang_1.default.isString(options))
    return readFile(filePath, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_ASYNC);
  return fs_1.default.readFileRetry(timeout)(filePath, options);
}
dist$1.readFile = readFile;
function readFileSync(filePath, options = consts_1.DEFAULT_READ_OPTIONS) {
  var _a;
  if (lang_1.default.isString(options))
    return readFileSync(filePath, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_SYNC);
  return fs_1.default.readFileSyncRetry(timeout)(filePath, options);
}
dist$1.readFileSync = readFileSync;
const writeFile = (filePath, data, options, callback) => {
  if (lang_1.default.isFunction(options))
    return writeFile(filePath, data, consts_1.DEFAULT_WRITE_OPTIONS, options);
  const promise = writeFileAsync(filePath, data, options);
  if (callback)
    promise.then(callback, callback);
  return promise;
};
dist$1.writeFile = writeFile;
const writeFileAsync = async (filePath, data, options = consts_1.DEFAULT_WRITE_OPTIONS) => {
  var _a;
  if (lang_1.default.isString(options))
    return writeFileAsync(filePath, data, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_ASYNC);
  let schedulerCustomDisposer = null, schedulerDisposer = null, tempDisposer = null, tempPath = null, fd = null;
  try {
    if (options.schedule)
      schedulerCustomDisposer = await options.schedule(filePath);
    schedulerDisposer = await scheduler_1.default.schedule(filePath);
    filePath = await fs_1.default.realpathAttempt(filePath) || filePath;
    [tempPath, tempDisposer] = temp_1.default.get(filePath, options.tmpCreate || temp_1.default.create, !(options.tmpPurge === false));
    const useStatChown = consts_1.IS_POSIX && lang_1.default.isUndefined(options.chown), useStatMode = lang_1.default.isUndefined(options.mode);
    if (useStatChown || useStatMode) {
      const stat2 = await fs_1.default.statAttempt(filePath);
      if (stat2) {
        options = { ...options };
        if (useStatChown)
          options.chown = { uid: stat2.uid, gid: stat2.gid };
        if (useStatMode)
          options.mode = stat2.mode;
      }
    }
    const parentPath = path$1.dirname(filePath);
    await fs_1.default.mkdirAttempt(parentPath, {
      mode: consts_1.DEFAULT_FOLDER_MODE,
      recursive: true
    });
    fd = await fs_1.default.openRetry(timeout)(tempPath, "w", options.mode || consts_1.DEFAULT_FILE_MODE);
    if (options.tmpCreated)
      options.tmpCreated(tempPath);
    if (lang_1.default.isString(data)) {
      await fs_1.default.writeRetry(timeout)(fd, data, 0, options.encoding || consts_1.DEFAULT_ENCODING);
    } else if (!lang_1.default.isUndefined(data)) {
      await fs_1.default.writeRetry(timeout)(fd, data, 0, data.length, 0);
    }
    if (options.fsync !== false) {
      if (options.fsyncWait !== false) {
        await fs_1.default.fsyncRetry(timeout)(fd);
      } else {
        fs_1.default.fsyncAttempt(fd);
      }
    }
    await fs_1.default.closeRetry(timeout)(fd);
    fd = null;
    if (options.chown)
      await fs_1.default.chownAttempt(tempPath, options.chown.uid, options.chown.gid);
    if (options.mode)
      await fs_1.default.chmodAttempt(tempPath, options.mode);
    try {
      await fs_1.default.renameRetry(timeout)(tempPath, filePath);
    } catch (error2) {
      if (error2.code !== "ENAMETOOLONG")
        throw error2;
      await fs_1.default.renameRetry(timeout)(tempPath, temp_1.default.truncate(filePath));
    }
    tempDisposer();
    tempPath = null;
  } finally {
    if (fd)
      await fs_1.default.closeAttempt(fd);
    if (tempPath)
      temp_1.default.purge(tempPath);
    if (schedulerCustomDisposer)
      schedulerCustomDisposer();
    if (schedulerDisposer)
      schedulerDisposer();
  }
};
const writeFileSync = (filePath, data, options = consts_1.DEFAULT_WRITE_OPTIONS) => {
  var _a;
  if (lang_1.default.isString(options))
    return writeFileSync(filePath, data, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_SYNC);
  let tempDisposer = null, tempPath = null, fd = null;
  try {
    filePath = fs_1.default.realpathSyncAttempt(filePath) || filePath;
    [tempPath, tempDisposer] = temp_1.default.get(filePath, options.tmpCreate || temp_1.default.create, !(options.tmpPurge === false));
    const useStatChown = consts_1.IS_POSIX && lang_1.default.isUndefined(options.chown), useStatMode = lang_1.default.isUndefined(options.mode);
    if (useStatChown || useStatMode) {
      const stat2 = fs_1.default.statSyncAttempt(filePath);
      if (stat2) {
        options = { ...options };
        if (useStatChown)
          options.chown = { uid: stat2.uid, gid: stat2.gid };
        if (useStatMode)
          options.mode = stat2.mode;
      }
    }
    const parentPath = path$1.dirname(filePath);
    fs_1.default.mkdirSyncAttempt(parentPath, {
      mode: consts_1.DEFAULT_FOLDER_MODE,
      recursive: true
    });
    fd = fs_1.default.openSyncRetry(timeout)(tempPath, "w", options.mode || consts_1.DEFAULT_FILE_MODE);
    if (options.tmpCreated)
      options.tmpCreated(tempPath);
    if (lang_1.default.isString(data)) {
      fs_1.default.writeSyncRetry(timeout)(fd, data, 0, options.encoding || consts_1.DEFAULT_ENCODING);
    } else if (!lang_1.default.isUndefined(data)) {
      fs_1.default.writeSyncRetry(timeout)(fd, data, 0, data.length, 0);
    }
    if (options.fsync !== false) {
      if (options.fsyncWait !== false) {
        fs_1.default.fsyncSyncRetry(timeout)(fd);
      } else {
        fs_1.default.fsyncAttempt(fd);
      }
    }
    fs_1.default.closeSyncRetry(timeout)(fd);
    fd = null;
    if (options.chown)
      fs_1.default.chownSyncAttempt(tempPath, options.chown.uid, options.chown.gid);
    if (options.mode)
      fs_1.default.chmodSyncAttempt(tempPath, options.mode);
    try {
      fs_1.default.renameSyncRetry(timeout)(tempPath, filePath);
    } catch (error2) {
      if (error2.code !== "ENAMETOOLONG")
        throw error2;
      fs_1.default.renameSyncRetry(timeout)(tempPath, temp_1.default.truncate(filePath));
    }
    tempDisposer();
    tempPath = null;
  } finally {
    if (fd)
      fs_1.default.closeSyncAttempt(fd);
    if (tempPath)
      temp_1.default.purge(tempPath);
  }
};
dist$1.writeFileSync = writeFileSync;
var ajv = { exports: {} };
var core$2 = {};
var validate = {};
var boolSchema = {};
var errors = {};
var codegen = {};
var code$1 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.regexpCode = exports2.getProperty = exports2.safeStringify = exports2.stringify = exports2.strConcat = exports2.addCodeArg = exports2.str = exports2._ = exports2.nil = exports2._Code = exports2.Name = exports2.IDENTIFIER = exports2._CodeOrName = void 0;
  class _CodeOrName {
  }
  exports2._CodeOrName = _CodeOrName;
  exports2.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class Name extends _CodeOrName {
    constructor(s) {
      super();
      if (!exports2.IDENTIFIER.test(s))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = s;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  exports2.Name = Name;
  class _Code extends _CodeOrName {
    constructor(code2) {
      super();
      this._items = typeof code2 === "string" ? [code2] : code2;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return false;
      const item = this._items[0];
      return item === "" || item === '""';
    }
    get str() {
      var _a;
      return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
    }
    get names() {
      var _a;
      return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names2, c) => {
        if (c instanceof Name)
          names2[c.str] = (names2[c.str] || 0) + 1;
        return names2;
      }, {});
    }
  }
  exports2._Code = _Code;
  exports2.nil = new _Code("");
  function _(strs, ...args) {
    const code2 = [strs[0]];
    let i = 0;
    while (i < args.length) {
      addCodeArg(code2, args[i]);
      code2.push(strs[++i]);
    }
    return new _Code(code2);
  }
  exports2._ = _;
  const plus = new _Code("+");
  function str(strs, ...args) {
    const expr = [safeStringify(strs[0])];
    let i = 0;
    while (i < args.length) {
      expr.push(plus);
      addCodeArg(expr, args[i]);
      expr.push(plus, safeStringify(strs[++i]));
    }
    optimize(expr);
    return new _Code(expr);
  }
  exports2.str = str;
  function addCodeArg(code2, arg) {
    if (arg instanceof _Code)
      code2.push(...arg._items);
    else if (arg instanceof Name)
      code2.push(arg);
    else
      code2.push(interpolate(arg));
  }
  exports2.addCodeArg = addCodeArg;
  function optimize(expr) {
    let i = 1;
    while (i < expr.length - 1) {
      if (expr[i] === plus) {
        const res = mergeExprItems(expr[i - 1], expr[i + 1]);
        if (res !== void 0) {
          expr.splice(i - 1, 3, res);
          continue;
        }
        expr[i++] = "+";
      }
      i++;
    }
  }
  function mergeExprItems(a, b) {
    if (b === '""')
      return a;
    if (a === '""')
      return b;
    if (typeof a == "string") {
      if (b instanceof Name || a[a.length - 1] !== '"')
        return;
      if (typeof b != "string")
        return `${a.slice(0, -1)}${b}"`;
      if (b[0] === '"')
        return a.slice(0, -1) + b.slice(1);
      return;
    }
    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
      return `"${a}${b.slice(1)}`;
    return;
  }
  function strConcat(c1, c2) {
    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
  }
  exports2.strConcat = strConcat;
  function interpolate(x) {
    return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
  }
  function stringify2(x) {
    return new _Code(safeStringify(x));
  }
  exports2.stringify = stringify2;
  function safeStringify(x) {
    return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  exports2.safeStringify = safeStringify;
  function getProperty(key) {
    return typeof key == "string" && exports2.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
  }
  exports2.getProperty = getProperty;
  function regexpCode(rx) {
    return new _Code(rx.toString());
  }
  exports2.regexpCode = regexpCode;
})(code$1);
var scope = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ValueScope = exports2.ValueScopeName = exports2.Scope = exports2.varKinds = exports2.UsedValueState = void 0;
  const code_12 = code$1;
  class ValueError extends Error {
    constructor(name) {
      super(`CodeGen: "code" for ${name} not defined`);
      this.value = name.value;
    }
  }
  var UsedValueState;
  (function(UsedValueState2) {
    UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
    UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
  })(UsedValueState = exports2.UsedValueState || (exports2.UsedValueState = {}));
  exports2.varKinds = {
    const: new code_12.Name("const"),
    let: new code_12.Name("let"),
    var: new code_12.Name("var")
  };
  class Scope {
    constructor({ prefixes, parent } = {}) {
      this._names = {};
      this._prefixes = prefixes;
      this._parent = parent;
    }
    toName(nameOrPrefix) {
      return nameOrPrefix instanceof code_12.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix) {
      return new code_12.Name(this._newName(prefix));
    }
    _newName(prefix) {
      const ng = this._names[prefix] || this._nameGroup(prefix);
      return `${prefix}${ng.index++}`;
    }
    _nameGroup(prefix) {
      var _a, _b;
      if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
        throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
      }
      return this._names[prefix] = { prefix, index: 0 };
    }
  }
  exports2.Scope = Scope;
  class ValueScopeName extends code_12.Name {
    constructor(prefix, nameStr) {
      super(nameStr);
      this.prefix = prefix;
    }
    setValue(value, { property, itemIndex }) {
      this.value = value;
      this.scopePath = code_12._`.${new code_12.Name(property)}[${itemIndex}]`;
    }
  }
  exports2.ValueScopeName = ValueScopeName;
  const line = code_12._`\n`;
  class ValueScope extends Scope {
    constructor(opts2) {
      super(opts2);
      this._values = {};
      this._scope = opts2.scope;
      this.opts = { ...opts2, _n: opts2.lines ? line : code_12.nil };
    }
    get() {
      return this._scope;
    }
    name(prefix) {
      return new ValueScopeName(prefix, this._newName(prefix));
    }
    value(nameOrPrefix, value) {
      var _a;
      if (value.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const name = this.toName(nameOrPrefix);
      const { prefix } = name;
      const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
      let vs = this._values[prefix];
      if (vs) {
        const _name = vs.get(valueKey);
        if (_name)
          return _name;
      } else {
        vs = this._values[prefix] = /* @__PURE__ */ new Map();
      }
      vs.set(valueKey, name);
      const s = this._scope[prefix] || (this._scope[prefix] = []);
      const itemIndex = s.length;
      s[itemIndex] = value.ref;
      name.setValue(value, { property: prefix, itemIndex });
      return name;
    }
    getValue(prefix, keyOrRef) {
      const vs = this._values[prefix];
      if (!vs)
        return;
      return vs.get(keyOrRef);
    }
    scopeRefs(scopeName, values = this._values) {
      return this._reduceValues(values, (name) => {
        if (name.scopePath === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return code_12._`${scopeName}${name.scopePath}`;
      });
    }
    scopeCode(values = this._values, usedValues, getCode) {
      return this._reduceValues(values, (name) => {
        if (name.value === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return name.value.code;
      }, usedValues, getCode);
    }
    _reduceValues(values, valueCode, usedValues = {}, getCode) {
      let code2 = code_12.nil;
      for (const prefix in values) {
        const vs = values[prefix];
        if (!vs)
          continue;
        const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
        vs.forEach((name) => {
          if (nameSet.has(name))
            return;
          nameSet.set(name, UsedValueState.Started);
          let c = valueCode(name);
          if (c) {
            const def2 = this.opts.es5 ? exports2.varKinds.var : exports2.varKinds.const;
            code2 = code_12._`${code2}${def2} ${name} = ${c};${this.opts._n}`;
          } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
            code2 = code_12._`${code2}${c}${this.opts._n}`;
          } else {
            throw new ValueError(name);
          }
          nameSet.set(name, UsedValueState.Completed);
        });
      }
      return code2;
    }
  }
  exports2.ValueScope = ValueScope;
})(scope);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.or = exports2.and = exports2.not = exports2.CodeGen = exports2.operators = exports2.varKinds = exports2.ValueScopeName = exports2.ValueScope = exports2.Scope = exports2.Name = exports2.regexpCode = exports2.stringify = exports2.getProperty = exports2.nil = exports2.strConcat = exports2.str = exports2._ = void 0;
  const code_12 = code$1;
  const scope_1 = scope;
  var code_2 = code$1;
  Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
    return code_2._;
  } });
  Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
    return code_2.str;
  } });
  Object.defineProperty(exports2, "strConcat", { enumerable: true, get: function() {
    return code_2.strConcat;
  } });
  Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
    return code_2.nil;
  } });
  Object.defineProperty(exports2, "getProperty", { enumerable: true, get: function() {
    return code_2.getProperty;
  } });
  Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
    return code_2.stringify;
  } });
  Object.defineProperty(exports2, "regexpCode", { enumerable: true, get: function() {
    return code_2.regexpCode;
  } });
  Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
    return code_2.Name;
  } });
  var scope_2 = scope;
  Object.defineProperty(exports2, "Scope", { enumerable: true, get: function() {
    return scope_2.Scope;
  } });
  Object.defineProperty(exports2, "ValueScope", { enumerable: true, get: function() {
    return scope_2.ValueScope;
  } });
  Object.defineProperty(exports2, "ValueScopeName", { enumerable: true, get: function() {
    return scope_2.ValueScopeName;
  } });
  Object.defineProperty(exports2, "varKinds", { enumerable: true, get: function() {
    return scope_2.varKinds;
  } });
  exports2.operators = {
    GT: new code_12._Code(">"),
    GTE: new code_12._Code(">="),
    LT: new code_12._Code("<"),
    LTE: new code_12._Code("<="),
    EQ: new code_12._Code("==="),
    NEQ: new code_12._Code("!=="),
    NOT: new code_12._Code("!"),
    OR: new code_12._Code("||"),
    AND: new code_12._Code("&&"),
    ADD: new code_12._Code("+")
  };
  class Node2 {
    optimizeNodes() {
      return this;
    }
    optimizeNames(_names, _constants) {
      return this;
    }
  }
  class Def extends Node2 {
    constructor(varKind, name, rhs) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.rhs = rhs;
    }
    render({ es5, _n }) {
      const varKind = es5 ? scope_1.varKinds.var : this.varKind;
      const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${varKind} ${this.name}${rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (!names2[this.name.str])
        return;
      if (this.rhs)
        this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      return this.rhs instanceof code_12._CodeOrName ? this.rhs.names : {};
    }
  }
  class Assign extends Node2 {
    constructor(lhs, rhs, sideEffects) {
      super();
      this.lhs = lhs;
      this.rhs = rhs;
      this.sideEffects = sideEffects;
    }
    render({ _n }) {
      return `${this.lhs} = ${this.rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (this.lhs instanceof code_12.Name && !names2[this.lhs.str] && !this.sideEffects)
        return;
      this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      const names2 = this.lhs instanceof code_12.Name ? {} : { ...this.lhs.names };
      return addExprNames(names2, this.rhs);
    }
  }
  class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
      super(lhs, rhs, sideEffects);
      this.op = op;
    }
    render({ _n }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
    }
  }
  class Label extends Node2 {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      return `${this.label}:` + _n;
    }
  }
  class Break extends Node2 {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      const label = this.label ? ` ${this.label}` : "";
      return `break${label};` + _n;
    }
  }
  class Throw extends Node2 {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render({ _n }) {
      return `throw ${this.error};` + _n;
    }
    get names() {
      return this.error.names;
    }
  }
  class AnyCode extends Node2 {
    constructor(code2) {
      super();
      this.code = code2;
    }
    render({ _n }) {
      return `${this.code};` + _n;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      this.code = optimizeExpr(this.code, names2, constants2);
      return this;
    }
    get names() {
      return this.code instanceof code_12._CodeOrName ? this.code.names : {};
    }
  }
  class ParentNode extends Node2 {
    constructor(nodes = []) {
      super();
      this.nodes = nodes;
    }
    render(opts2) {
      return this.nodes.reduce((code2, n) => code2 + n.render(opts2), "");
    }
    optimizeNodes() {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i].optimizeNodes();
        if (Array.isArray(n))
          nodes.splice(i, 1, ...n);
        else if (n)
          nodes[i] = n;
        else
          nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i];
        if (n.optimizeNames(names2, constants2))
          continue;
        subtractNames(names2, n.names);
        nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((names2, n) => addNames(names2, n.names), {});
    }
  }
  class BlockNode extends ParentNode {
    render(opts2) {
      return "{" + opts2._n + super.render(opts2) + "}" + opts2._n;
    }
  }
  class Root extends ParentNode {
  }
  class Else extends BlockNode {
  }
  Else.kind = "else";
  class If extends BlockNode {
    constructor(condition, nodes) {
      super(nodes);
      this.condition = condition;
    }
    render(opts2) {
      let code2 = `if(${this.condition})` + super.render(opts2);
      if (this.else)
        code2 += "else " + this.else.render(opts2);
      return code2;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const cond = this.condition;
      if (cond === true)
        return this.nodes;
      let e = this.else;
      if (e) {
        const ns = e.optimizeNodes();
        e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
      }
      if (e) {
        if (cond === false)
          return e instanceof If ? e : e.nodes;
        if (this.nodes.length)
          return this;
        return new If(not2(cond), e instanceof If ? [e] : e.nodes);
      }
      if (cond === false || !this.nodes.length)
        return void 0;
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a;
      this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants2);
      if (!(super.optimizeNames(names2, constants2) || this.else))
        return;
      this.condition = optimizeExpr(this.condition, names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      addExprNames(names2, this.condition);
      if (this.else)
        addNames(names2, this.else.names);
      return names2;
    }
  }
  If.kind = "if";
  class For extends BlockNode {
  }
  For.kind = "for";
  class ForLoop extends For {
    constructor(iteration) {
      super();
      this.iteration = iteration;
    }
    render(opts2) {
      return `for(${this.iteration})` + super.render(opts2);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iteration = optimizeExpr(this.iteration, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iteration.names);
    }
  }
  class ForRange extends For {
    constructor(varKind, name, from, to) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.from = from;
      this.to = to;
    }
    render(opts2) {
      const varKind = opts2.es5 ? scope_1.varKinds.var : this.varKind;
      const { name, from, to } = this;
      return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts2);
    }
    get names() {
      const names2 = addExprNames(super.names, this.from);
      return addExprNames(names2, this.to);
    }
  }
  class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
      super();
      this.loop = loop;
      this.varKind = varKind;
      this.name = name;
      this.iterable = iterable;
    }
    render(opts2) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts2);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iterable = optimizeExpr(this.iterable, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iterable.names);
    }
  }
  class Func extends BlockNode {
    constructor(name, args, async) {
      super();
      this.name = name;
      this.args = args;
      this.async = async;
    }
    render(opts2) {
      const _async = this.async ? "async " : "";
      return `${_async}function ${this.name}(${this.args})` + super.render(opts2);
    }
  }
  Func.kind = "func";
  class Return extends ParentNode {
    render(opts2) {
      return "return " + super.render(opts2);
    }
  }
  Return.kind = "return";
  class Try extends BlockNode {
    render(opts2) {
      let code2 = "try" + super.render(opts2);
      if (this.catch)
        code2 += this.catch.render(opts2);
      if (this.finally)
        code2 += this.finally.render(opts2);
      return code2;
    }
    optimizeNodes() {
      var _a, _b;
      super.optimizeNodes();
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a, _b;
      super.optimizeNames(names2, constants2);
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants2);
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      if (this.catch)
        addNames(names2, this.catch.names);
      if (this.finally)
        addNames(names2, this.finally.names);
      return names2;
    }
  }
  class Catch extends BlockNode {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render(opts2) {
      return `catch(${this.error})` + super.render(opts2);
    }
  }
  Catch.kind = "catch";
  class Finally extends BlockNode {
    render(opts2) {
      return "finally" + super.render(opts2);
    }
  }
  Finally.kind = "finally";
  class CodeGen {
    constructor(extScope, opts2 = {}) {
      this._values = {};
      this._blockStarts = [];
      this._constants = {};
      this.opts = { ...opts2, _n: opts2.lines ? "\n" : "" };
      this._extScope = extScope;
      this._scope = new scope_1.Scope({ parent: extScope });
      this._nodes = [new Root()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(prefix) {
      return this._scope.name(prefix);
    }
    // reserves unique name in the external scope
    scopeName(prefix) {
      return this._extScope.name(prefix);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(prefixOrName, value) {
      const name = this._extScope.value(prefixOrName, value);
      const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
      vs.add(name);
      return name;
    }
    getScopeValue(prefix, keyOrRef) {
      return this._extScope.getValue(prefix, keyOrRef);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(scopeName) {
      return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant) {
      const name = this._scope.toName(nameOrPrefix);
      if (rhs !== void 0 && constant)
        this._constants[name.str] = rhs;
      this._leafNode(new Def(varKind, name, rhs));
      return name;
    }
    // `const` declaration (`var` in es5 mode)
    const(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    // `var` declaration with optional assignment
    var(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    // assignment code
    assign(lhs, rhs, sideEffects) {
      return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    // `+=` code
    add(lhs, rhs) {
      return this._leafNode(new AssignOp(lhs, exports2.operators.ADD, rhs));
    }
    // appends passed SafeExpr to code or executes Block
    code(c) {
      if (typeof c == "function")
        c();
      else if (c !== code_12.nil)
        this._leafNode(new AnyCode(c));
      return this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...keyValues) {
      const code2 = ["{"];
      for (const [key, value] of keyValues) {
        if (code2.length > 1)
          code2.push(",");
        code2.push(key);
        if (key !== value || this.opts.es5) {
          code2.push(":");
          code_12.addCodeArg(code2, value);
        }
      }
      code2.push("}");
      return new code_12._Code(code2);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(condition, thenBody, elseBody) {
      this._blockNode(new If(condition));
      if (thenBody && elseBody) {
        this.code(thenBody).else().code(elseBody).endIf();
      } else if (thenBody) {
        this.code(thenBody).endIf();
      } else if (elseBody) {
        throw new Error('CodeGen: "else" body without "then" body');
      }
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(condition) {
      return this._elseNode(new If(condition));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new Else());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(If, Else);
    }
    _for(node, forBody) {
      this._blockNode(node);
      if (forBody)
        this.code(forBody).endFor();
      return this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(iteration, forBody) {
      return this._for(new ForLoop(iteration), forBody);
    }
    // `for` statement for a range of values
    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
      const name = this._scope.toName(nameOrPrefix);
      if (this.opts.es5) {
        const arr = iterable instanceof code_12.Name ? iterable : this.var("_arr", iterable);
        return this.forRange("_i", 0, code_12._`${arr}.length`, (i) => {
          this.var(name, code_12._`${arr}[${i}]`);
          forBody(name);
        });
      }
      return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
      if (this.opts.ownProperties) {
        return this.forOf(nameOrPrefix, code_12._`Object.keys(${obj})`, forBody);
      }
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(For);
    }
    // `label` statement
    label(label) {
      return this._leafNode(new Label(label));
    }
    // `break` statement
    break(label) {
      return this._leafNode(new Break(label));
    }
    // `return` statement
    return(value) {
      const node = new Return();
      this._blockNode(node);
      this.code(value);
      if (node.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(Return);
    }
    // `try` statement
    try(tryBody, catchCode, finallyCode) {
      if (!catchCode && !finallyCode)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const node = new Try();
      this._blockNode(node);
      this.code(tryBody);
      if (catchCode) {
        const error2 = this.name("e");
        this._currNode = node.catch = new Catch(error2);
        catchCode(error2);
      }
      if (finallyCode) {
        this._currNode = node.finally = new Finally();
        this.code(finallyCode);
      }
      return this._endBlockNode(Catch, Finally);
    }
    // `throw` statement
    throw(error2) {
      return this._leafNode(new Throw(error2));
    }
    // start self-balancing block
    block(body, nodeCount) {
      this._blockStarts.push(this._nodes.length);
      if (body)
        this.code(body).endBlock(nodeCount);
      return this;
    }
    // end the current self-balancing block
    endBlock(nodeCount) {
      const len = this._blockStarts.pop();
      if (len === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const toClose = this._nodes.length - len;
      if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
        throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
      }
      this._nodes.length = len;
      return this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(name, args = code_12.nil, async, funcBody) {
      this._blockNode(new Func(name, args, async));
      if (funcBody)
        this.code(funcBody).endFunc();
      return this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(Func);
    }
    optimize(n = 1) {
      while (n-- > 0) {
        this._root.optimizeNodes();
        this._root.optimizeNames(this._root.names, this._constants);
      }
    }
    _leafNode(node) {
      this._currNode.nodes.push(node);
      return this;
    }
    _blockNode(node) {
      this._currNode.nodes.push(node);
      this._nodes.push(node);
    }
    _endBlockNode(N1, N2) {
      const n = this._currNode;
      if (n instanceof N1 || N2 && n instanceof N2) {
        this._nodes.pop();
        return this;
      }
      throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
    }
    _elseNode(node) {
      const n = this._currNode;
      if (!(n instanceof If)) {
        throw new Error('CodeGen: "else" without "if"');
      }
      this._currNode = n.else = node;
      return this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const ns = this._nodes;
      return ns[ns.length - 1];
    }
    set _currNode(node) {
      const ns = this._nodes;
      ns[ns.length - 1] = node;
    }
  }
  exports2.CodeGen = CodeGen;
  function addNames(names2, from) {
    for (const n in from)
      names2[n] = (names2[n] || 0) + (from[n] || 0);
    return names2;
  }
  function addExprNames(names2, from) {
    return from instanceof code_12._CodeOrName ? addNames(names2, from.names) : names2;
  }
  function optimizeExpr(expr, names2, constants2) {
    if (expr instanceof code_12.Name)
      return replaceName(expr);
    if (!canOptimize(expr))
      return expr;
    return new code_12._Code(expr._items.reduce((items2, c) => {
      if (c instanceof code_12.Name)
        c = replaceName(c);
      if (c instanceof code_12._Code)
        items2.push(...c._items);
      else
        items2.push(c);
      return items2;
    }, []));
    function replaceName(n) {
      const c = constants2[n.str];
      if (c === void 0 || names2[n.str] !== 1)
        return n;
      delete names2[n.str];
      return c;
    }
    function canOptimize(e) {
      return e instanceof code_12._Code && e._items.some((c) => c instanceof code_12.Name && names2[c.str] === 1 && constants2[c.str] !== void 0);
    }
  }
  function subtractNames(names2, from) {
    for (const n in from)
      names2[n] = (names2[n] || 0) - (from[n] || 0);
  }
  function not2(x) {
    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : code_12._`!${par(x)}`;
  }
  exports2.not = not2;
  const andCode = mappend(exports2.operators.AND);
  function and(...args) {
    return args.reduce(andCode);
  }
  exports2.and = and;
  const orCode = mappend(exports2.operators.OR);
  function or(...args) {
    return args.reduce(orCode);
  }
  exports2.or = or;
  function mappend(op) {
    return (x, y) => x === code_12.nil ? y : y === code_12.nil ? x : code_12._`${par(x)} ${op} ${par(y)}`;
  }
  function par(x) {
    return x instanceof code_12.Name ? x : code_12._`(${x})`;
  }
})(codegen);
var util = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.checkStrictMode = exports2.getErrorPath = exports2.Type = exports2.useFunc = exports2.setEvaluated = exports2.evaluatedPropsToName = exports2.mergeEvaluated = exports2.eachItem = exports2.unescapeJsonPointer = exports2.escapeJsonPointer = exports2.escapeFragment = exports2.unescapeFragment = exports2.schemaRefOrVal = exports2.schemaHasRulesButRef = exports2.schemaHasRules = exports2.checkUnknownRules = exports2.alwaysValidSchema = exports2.toHash = void 0;
  const codegen_12 = codegen;
  const code_12 = code$1;
  function toHash(arr) {
    const hash = {};
    for (const item of arr)
      hash[item] = true;
    return hash;
  }
  exports2.toHash = toHash;
  function alwaysValidSchema(it, schema2) {
    if (typeof schema2 == "boolean")
      return schema2;
    if (Object.keys(schema2).length === 0)
      return true;
    checkUnknownRules(it, schema2);
    return !schemaHasRules(schema2, it.self.RULES.all);
  }
  exports2.alwaysValidSchema = alwaysValidSchema;
  function checkUnknownRules(it, schema2 = it.schema) {
    const { opts: opts2, self: self2 } = it;
    if (!opts2.strictSchema)
      return;
    if (typeof schema2 === "boolean")
      return;
    const rules2 = self2.RULES.keywords;
    for (const key in schema2) {
      if (!rules2[key])
        checkStrictMode(it, `unknown keyword: "${key}"`);
    }
  }
  exports2.checkUnknownRules = checkUnknownRules;
  function schemaHasRules(schema2, rules2) {
    if (typeof schema2 == "boolean")
      return !schema2;
    for (const key in schema2)
      if (rules2[key])
        return true;
    return false;
  }
  exports2.schemaHasRules = schemaHasRules;
  function schemaHasRulesButRef(schema2, RULES) {
    if (typeof schema2 == "boolean")
      return !schema2;
    for (const key in schema2)
      if (key !== "$ref" && RULES.all[key])
        return true;
    return false;
  }
  exports2.schemaHasRulesButRef = schemaHasRulesButRef;
  function schemaRefOrVal({ topSchemaRef, schemaPath }, schema2, keyword2, $data) {
    if (!$data) {
      if (typeof schema2 == "number" || typeof schema2 == "boolean")
        return schema2;
      if (typeof schema2 == "string")
        return codegen_12._`${schema2}`;
    }
    return codegen_12._`${topSchemaRef}${schemaPath}${codegen_12.getProperty(keyword2)}`;
  }
  exports2.schemaRefOrVal = schemaRefOrVal;
  function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
  }
  exports2.unescapeFragment = unescapeFragment;
  function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
  }
  exports2.escapeFragment = escapeFragment;
  function escapeJsonPointer(str) {
    if (typeof str == "number")
      return `${str}`;
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  exports2.escapeJsonPointer = escapeJsonPointer;
  function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  exports2.unescapeJsonPointer = unescapeJsonPointer;
  function eachItem(xs, f) {
    if (Array.isArray(xs)) {
      for (const x of xs)
        f(x);
    } else {
      f(xs);
    }
  }
  exports2.eachItem = eachItem;
  function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
    return (gen, from, to, toName) => {
      const res = to === void 0 ? from : to instanceof codegen_12.Name ? (from instanceof codegen_12.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_12.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
      return toName === codegen_12.Name && !(res instanceof codegen_12.Name) ? resultToName(gen, res) : res;
    };
  }
  exports2.mergeEvaluated = {
    props: makeMergeEvaluated({
      mergeNames: (gen, from, to) => gen.if(codegen_12._`${to} !== true && ${from} !== undefined`, () => {
        gen.if(codegen_12._`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, codegen_12._`${to} || {}`).code(codegen_12._`Object.assign(${to}, ${from})`));
      }),
      mergeToName: (gen, from, to) => gen.if(codegen_12._`${to} !== true`, () => {
        if (from === true) {
          gen.assign(to, true);
        } else {
          gen.assign(to, codegen_12._`${to} || {}`);
          setEvaluated(gen, to, from);
        }
      }),
      mergeValues: (from, to) => from === true ? true : { ...from, ...to },
      resultToName: evaluatedPropsToName
    }),
    items: makeMergeEvaluated({
      mergeNames: (gen, from, to) => gen.if(codegen_12._`${to} !== true && ${from} !== undefined`, () => gen.assign(to, codegen_12._`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
      mergeToName: (gen, from, to) => gen.if(codegen_12._`${to} !== true`, () => gen.assign(to, from === true ? true : codegen_12._`${to} > ${from} ? ${to} : ${from}`)),
      mergeValues: (from, to) => from === true ? true : Math.max(from, to),
      resultToName: (gen, items2) => gen.var("items", items2)
    })
  };
  function evaluatedPropsToName(gen, ps) {
    if (ps === true)
      return gen.var("props", true);
    const props = gen.var("props", codegen_12._`{}`);
    if (ps !== void 0)
      setEvaluated(gen, props, ps);
    return props;
  }
  exports2.evaluatedPropsToName = evaluatedPropsToName;
  function setEvaluated(gen, props, ps) {
    Object.keys(ps).forEach((p) => gen.assign(codegen_12._`${props}${codegen_12.getProperty(p)}`, true));
  }
  exports2.setEvaluated = setEvaluated;
  const snippets = {};
  function useFunc(gen, f) {
    return gen.scopeValue("func", {
      ref: f,
      code: snippets[f.code] || (snippets[f.code] = new code_12._Code(f.code))
    });
  }
  exports2.useFunc = useFunc;
  var Type;
  (function(Type2) {
    Type2[Type2["Num"] = 0] = "Num";
    Type2[Type2["Str"] = 1] = "Str";
  })(Type = exports2.Type || (exports2.Type = {}));
  function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
    if (dataProp instanceof codegen_12.Name) {
      const isNumber = dataPropType === Type.Num;
      return jsPropertySyntax ? isNumber ? codegen_12._`"[" + ${dataProp} + "]"` : codegen_12._`"['" + ${dataProp} + "']"` : isNumber ? codegen_12._`"/" + ${dataProp}` : codegen_12._`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return jsPropertySyntax ? codegen_12.getProperty(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
  }
  exports2.getErrorPath = getErrorPath;
  function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
    if (!mode)
      return;
    msg = `strict mode: ${msg}`;
    if (mode === true)
      throw new Error(msg);
    it.self.logger.warn(msg);
  }
  exports2.checkStrictMode = checkStrictMode;
})(util);
var names$1 = {};
Object.defineProperty(names$1, "__esModule", { value: true });
const codegen_1$t = codegen;
const names = {
  // validation function arguments
  data: new codegen_1$t.Name("data"),
  // args passed from referencing schema
  valCxt: new codegen_1$t.Name("valCxt"),
  instancePath: new codegen_1$t.Name("instancePath"),
  parentData: new codegen_1$t.Name("parentData"),
  parentDataProperty: new codegen_1$t.Name("parentDataProperty"),
  rootData: new codegen_1$t.Name("rootData"),
  dynamicAnchors: new codegen_1$t.Name("dynamicAnchors"),
  // function scoped variables
  vErrors: new codegen_1$t.Name("vErrors"),
  errors: new codegen_1$t.Name("errors"),
  this: new codegen_1$t.Name("this"),
  // "globals"
  self: new codegen_1$t.Name("self"),
  scope: new codegen_1$t.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new codegen_1$t.Name("json"),
  jsonPos: new codegen_1$t.Name("jsonPos"),
  jsonLen: new codegen_1$t.Name("jsonLen"),
  jsonPart: new codegen_1$t.Name("jsonPart")
};
names$1.default = names;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.extendErrors = exports2.resetErrorsCount = exports2.reportExtraError = exports2.reportError = exports2.keyword$DataError = exports2.keywordError = void 0;
  const codegen_12 = codegen;
  const util_12 = util;
  const names_12 = names$1;
  exports2.keywordError = {
    message: ({ keyword: keyword2 }) => codegen_12.str`must pass "${keyword2}" keyword validation`
  };
  exports2.keyword$DataError = {
    message: ({ keyword: keyword2, schemaType }) => schemaType ? codegen_12.str`"${keyword2}" keyword must be ${schemaType} ($data)` : codegen_12.str`"${keyword2}" keyword is invalid ($data)`
  };
  function reportError(cxt, error2 = exports2.keywordError, errorPaths, overrideAllErrors) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
      addError(gen, errObj);
    } else {
      returnErrors(it, codegen_12._`[${errObj}]`);
    }
  }
  exports2.reportError = reportError;
  function reportExtraError(cxt, error2 = exports2.keywordError, errorPaths) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
      returnErrors(it, names_12.default.vErrors);
    }
  }
  exports2.reportExtraError = reportExtraError;
  function resetErrorsCount(gen, errsCount) {
    gen.assign(names_12.default.errors, errsCount);
    gen.if(codegen_12._`${names_12.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign(codegen_12._`${names_12.default.vErrors}.length`, errsCount), () => gen.assign(names_12.default.vErrors, null)));
  }
  exports2.resetErrorsCount = resetErrorsCount;
  function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it }) {
    if (errsCount === void 0)
      throw new Error("ajv implementation error");
    const err = gen.name("err");
    gen.forRange("i", errsCount, names_12.default.errors, (i) => {
      gen.const(err, codegen_12._`${names_12.default.vErrors}[${i}]`);
      gen.if(codegen_12._`${err}.instancePath === undefined`, () => gen.assign(codegen_12._`${err}.instancePath`, codegen_12.strConcat(names_12.default.instancePath, it.errorPath)));
      gen.assign(codegen_12._`${err}.schemaPath`, codegen_12.str`${it.errSchemaPath}/${keyword2}`);
      if (it.opts.verbose) {
        gen.assign(codegen_12._`${err}.schema`, schemaValue);
        gen.assign(codegen_12._`${err}.data`, data);
      }
    });
  }
  exports2.extendErrors = extendErrors;
  function addError(gen, errObj) {
    const err = gen.const("err", errObj);
    gen.if(codegen_12._`${names_12.default.vErrors} === null`, () => gen.assign(names_12.default.vErrors, codegen_12._`[${err}]`), codegen_12._`${names_12.default.vErrors}.push(${err})`);
    gen.code(codegen_12._`${names_12.default.errors}++`);
  }
  function returnErrors(it, errs) {
    const { gen, validateName, schemaEnv } = it;
    if (schemaEnv.$async) {
      gen.throw(codegen_12._`new ${it.ValidationError}(${errs})`);
    } else {
      gen.assign(codegen_12._`${validateName}.errors`, errs);
      gen.return(false);
    }
  }
  const E = {
    keyword: new codegen_12.Name("keyword"),
    schemaPath: new codegen_12.Name("schemaPath"),
    params: new codegen_12.Name("params"),
    propertyName: new codegen_12.Name("propertyName"),
    message: new codegen_12.Name("message"),
    schema: new codegen_12.Name("schema"),
    parentSchema: new codegen_12.Name("parentSchema")
  };
  function errorObjectCode(cxt, error2, errorPaths) {
    const { createErrors } = cxt.it;
    if (createErrors === false)
      return codegen_12._`{}`;
    return errorObject(cxt, error2, errorPaths);
  }
  function errorObject(cxt, error2, errorPaths = {}) {
    const { gen, it } = cxt;
    const keyValues = [
      errorInstancePath(it, errorPaths),
      errorSchemaPath(cxt, errorPaths)
    ];
    extraErrorProps(cxt, error2, keyValues);
    return gen.object(...keyValues);
  }
  function errorInstancePath({ errorPath }, { instancePath }) {
    const instPath = instancePath ? codegen_12.str`${errorPath}${util_12.getErrorPath(instancePath, util_12.Type.Str)}` : errorPath;
    return [names_12.default.instancePath, codegen_12.strConcat(names_12.default.instancePath, instPath)];
  }
  function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
    let schPath = parentSchema ? errSchemaPath : codegen_12.str`${errSchemaPath}/${keyword2}`;
    if (schemaPath) {
      schPath = codegen_12.str`${schPath}${util_12.getErrorPath(schemaPath, util_12.Type.Str)}`;
    }
    return [E.schemaPath, schPath];
  }
  function extraErrorProps(cxt, { params, message }, keyValues) {
    const { keyword: keyword2, data, schemaValue, it } = cxt;
    const { opts: opts2, propertyName, topSchemaRef, schemaPath } = it;
    keyValues.push([E.keyword, keyword2], [E.params, typeof params == "function" ? params(cxt) : params || codegen_12._`{}`]);
    if (opts2.messages) {
      keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts2.verbose) {
      keyValues.push([E.schema, schemaValue], [E.parentSchema, codegen_12._`${topSchemaRef}${schemaPath}`], [names_12.default.data, data]);
    }
    if (propertyName)
      keyValues.push([E.propertyName, propertyName]);
  }
})(errors);
Object.defineProperty(boolSchema, "__esModule", { value: true });
boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
const errors_1$2 = errors;
const codegen_1$s = codegen;
const names_1$6 = names$1;
const boolError = {
  message: "boolean schema is false"
};
function topBoolOrEmptySchema(it) {
  const { gen, schema: schema2, validateName } = it;
  if (schema2 === false) {
    falseSchemaError(it, false);
  } else if (typeof schema2 == "object" && schema2.$async === true) {
    gen.return(names_1$6.default.data);
  } else {
    gen.assign(codegen_1$s._`${validateName}.errors`, null);
    gen.return(true);
  }
}
boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
function boolOrEmptySchema(it, valid2) {
  const { gen, schema: schema2 } = it;
  if (schema2 === false) {
    gen.var(valid2, false);
    falseSchemaError(it);
  } else {
    gen.var(valid2, true);
  }
}
boolSchema.boolOrEmptySchema = boolOrEmptySchema;
function falseSchemaError(it, overrideAllErrors) {
  const { gen, data } = it;
  const cxt = {
    gen,
    keyword: "false schema",
    data,
    schema: false,
    schemaCode: false,
    schemaValue: false,
    params: {},
    it
  };
  errors_1$2.reportError(cxt, boolError, void 0, overrideAllErrors);
}
var dataType = {};
var rules = {};
Object.defineProperty(rules, "__esModule", { value: true });
rules.getRules = rules.isJSONType = void 0;
const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
const jsonTypes = new Set(_jsonTypes);
function isJSONType(x) {
  return typeof x == "string" && jsonTypes.has(x);
}
rules.isJSONType = isJSONType;
function getRules() {
  const groups = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...groups, integer: true, boolean: true, null: true },
    rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
rules.getRules = getRules;
var applicability = {};
Object.defineProperty(applicability, "__esModule", { value: true });
applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
function schemaHasRulesForType({ schema: schema2, self: self2 }, type2) {
  const group = self2.RULES.types[type2];
  return group && group !== true && shouldUseGroup(schema2, group);
}
applicability.schemaHasRulesForType = schemaHasRulesForType;
function shouldUseGroup(schema2, group) {
  return group.rules.some((rule) => shouldUseRule(schema2, rule));
}
applicability.shouldUseGroup = shouldUseGroup;
function shouldUseRule(schema2, rule) {
  var _a;
  return schema2[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema2[kwd] !== void 0));
}
applicability.shouldUseRule = shouldUseRule;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.reportTypeError = exports2.checkDataTypes = exports2.checkDataType = exports2.coerceAndCheckDataType = exports2.getJSONTypes = exports2.getSchemaTypes = exports2.DataType = void 0;
  const rules_1 = rules;
  const applicability_12 = applicability;
  const errors_12 = errors;
  const codegen_12 = codegen;
  const util_12 = util;
  var DataType;
  (function(DataType2) {
    DataType2[DataType2["Correct"] = 0] = "Correct";
    DataType2[DataType2["Wrong"] = 1] = "Wrong";
  })(DataType = exports2.DataType || (exports2.DataType = {}));
  function getSchemaTypes(schema2) {
    const types2 = getJSONTypes(schema2.type);
    const hasNull = types2.includes("null");
    if (hasNull) {
      if (schema2.nullable === false)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!types2.length && schema2.nullable !== void 0) {
        throw new Error('"nullable" cannot be used without "type"');
      }
      if (schema2.nullable === true)
        types2.push("null");
    }
    return types2;
  }
  exports2.getSchemaTypes = getSchemaTypes;
  function getJSONTypes(ts) {
    const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
    if (types2.every(rules_1.isJSONType))
      return types2;
    throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
  }
  exports2.getJSONTypes = getJSONTypes;
  function coerceAndCheckDataType(it, types2) {
    const { gen, data, opts: opts2 } = it;
    const coerceTo = coerceToTypes(types2, opts2.coerceTypes);
    const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && applicability_12.schemaHasRulesForType(it, types2[0]));
    if (checkTypes) {
      const wrongType = checkDataTypes(types2, data, opts2.strictNumbers, DataType.Wrong);
      gen.if(wrongType, () => {
        if (coerceTo.length)
          coerceData(it, types2, coerceTo);
        else
          reportTypeError(it);
      });
    }
    return checkTypes;
  }
  exports2.coerceAndCheckDataType = coerceAndCheckDataType;
  const COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function coerceToTypes(types2, coerceTypes) {
    return coerceTypes ? types2.filter((t2) => COERCIBLE.has(t2) || coerceTypes === "array" && t2 === "array") : [];
  }
  function coerceData(it, types2, coerceTo) {
    const { gen, data, opts: opts2 } = it;
    const dataType2 = gen.let("dataType", codegen_12._`typeof ${data}`);
    const coerced = gen.let("coerced", codegen_12._`undefined`);
    if (opts2.coerceTypes === "array") {
      gen.if(codegen_12._`${dataType2} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, codegen_12._`${data}[0]`).assign(dataType2, codegen_12._`typeof ${data}`).if(checkDataTypes(types2, data, opts2.strictNumbers), () => gen.assign(coerced, data)));
    }
    gen.if(codegen_12._`${coerced} !== undefined`);
    for (const t2 of coerceTo) {
      if (COERCIBLE.has(t2) || t2 === "array" && opts2.coerceTypes === "array") {
        coerceSpecificType(t2);
      }
    }
    gen.else();
    reportTypeError(it);
    gen.endIf();
    gen.if(codegen_12._`${coerced} !== undefined`, () => {
      gen.assign(data, coerced);
      assignParentData(it, coerced);
    });
    function coerceSpecificType(t2) {
      switch (t2) {
        case "string":
          gen.elseIf(codegen_12._`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, codegen_12._`"" + ${data}`).elseIf(codegen_12._`${data} === null`).assign(coerced, codegen_12._`""`);
          return;
        case "number":
          gen.elseIf(codegen_12._`${dataType2} == "boolean" || ${data} === null
              || (${dataType2} == "string" && ${data} && ${data} == +${data})`).assign(coerced, codegen_12._`+${data}`);
          return;
        case "integer":
          gen.elseIf(codegen_12._`${dataType2} === "boolean" || ${data} === null
              || (${dataType2} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, codegen_12._`+${data}`);
          return;
        case "boolean":
          gen.elseIf(codegen_12._`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf(codegen_12._`${data} === "true" || ${data} === 1`).assign(coerced, true);
          return;
        case "null":
          gen.elseIf(codegen_12._`${data} === "" || ${data} === 0 || ${data} === false`);
          gen.assign(coerced, null);
          return;
        case "array":
          gen.elseIf(codegen_12._`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data} === null`).assign(coerced, codegen_12._`[${data}]`);
      }
    }
  }
  function assignParentData({ gen, parentData, parentDataProperty }, expr) {
    gen.if(codegen_12._`${parentData} !== undefined`, () => gen.assign(codegen_12._`${parentData}[${parentDataProperty}]`, expr));
  }
  function checkDataType(dataType2, data, strictNums, correct = DataType.Correct) {
    const EQ = correct === DataType.Correct ? codegen_12.operators.EQ : codegen_12.operators.NEQ;
    let cond;
    switch (dataType2) {
      case "null":
        return codegen_12._`${data} ${EQ} null`;
      case "array":
        cond = codegen_12._`Array.isArray(${data})`;
        break;
      case "object":
        cond = codegen_12._`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
        break;
      case "integer":
        cond = numCond(codegen_12._`!(${data} % 1) && !isNaN(${data})`);
        break;
      case "number":
        cond = numCond();
        break;
      default:
        return codegen_12._`typeof ${data} ${EQ} ${dataType2}`;
    }
    return correct === DataType.Correct ? cond : codegen_12.not(cond);
    function numCond(_cond = codegen_12.nil) {
      return codegen_12.and(codegen_12._`typeof ${data} == "number"`, _cond, strictNums ? codegen_12._`isFinite(${data})` : codegen_12.nil);
    }
  }
  exports2.checkDataType = checkDataType;
  function checkDataTypes(dataTypes, data, strictNums, correct) {
    if (dataTypes.length === 1) {
      return checkDataType(dataTypes[0], data, strictNums, correct);
    }
    let cond;
    const types2 = util_12.toHash(dataTypes);
    if (types2.array && types2.object) {
      const notObj = codegen_12._`typeof ${data} != "object"`;
      cond = types2.null ? notObj : codegen_12._`!${data} || ${notObj}`;
      delete types2.null;
      delete types2.array;
      delete types2.object;
    } else {
      cond = codegen_12.nil;
    }
    if (types2.number)
      delete types2.integer;
    for (const t2 in types2)
      cond = codegen_12.and(cond, checkDataType(t2, data, strictNums, correct));
    return cond;
  }
  exports2.checkDataTypes = checkDataTypes;
  const typeError = {
    message: ({ schema: schema2 }) => `must be ${schema2}`,
    params: ({ schema: schema2, schemaValue }) => typeof schema2 == "string" ? codegen_12._`{type: ${schema2}}` : codegen_12._`{type: ${schemaValue}}`
  };
  function reportTypeError(it) {
    const cxt = getTypeErrorContext(it);
    errors_12.reportError(cxt, typeError);
  }
  exports2.reportTypeError = reportTypeError;
  function getTypeErrorContext(it) {
    const { gen, data, schema: schema2 } = it;
    const schemaCode = util_12.schemaRefOrVal(it, schema2, "type");
    return {
      gen,
      keyword: "type",
      data,
      schema: schema2.type,
      schemaCode,
      schemaValue: schemaCode,
      parentSchema: schema2,
      params: {},
      it
    };
  }
})(dataType);
var defaults = {};
Object.defineProperty(defaults, "__esModule", { value: true });
defaults.assignDefaults = void 0;
const codegen_1$r = codegen;
const util_1$o = util;
function assignDefaults(it, ty) {
  const { properties: properties2, items: items2 } = it.schema;
  if (ty === "object" && properties2) {
    for (const key in properties2) {
      assignDefault(it, key, properties2[key].default);
    }
  } else if (ty === "array" && Array.isArray(items2)) {
    items2.forEach((sch, i) => assignDefault(it, i, sch.default));
  }
}
defaults.assignDefaults = assignDefaults;
function assignDefault(it, prop, defaultValue) {
  const { gen, compositeRule, data, opts: opts2 } = it;
  if (defaultValue === void 0)
    return;
  const childData = codegen_1$r._`${data}${codegen_1$r.getProperty(prop)}`;
  if (compositeRule) {
    util_1$o.checkStrictMode(it, `default is ignored for: ${childData}`);
    return;
  }
  let condition = codegen_1$r._`${childData} === undefined`;
  if (opts2.useDefaults === "empty") {
    condition = codegen_1$r._`${condition} || ${childData} === null || ${childData} === ""`;
  }
  gen.if(condition, codegen_1$r._`${childData} = ${codegen_1$r.stringify(defaultValue)}`);
}
var keyword = {};
var code = {};
Object.defineProperty(code, "__esModule", { value: true });
code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
const codegen_1$q = codegen;
const util_1$n = util;
const names_1$5 = names$1;
function checkReportMissingProp(cxt, prop) {
  const { gen, data, it } = cxt;
  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
    cxt.setParams({ missingProperty: codegen_1$q._`${prop}` }, true);
    cxt.error();
  });
}
code.checkReportMissingProp = checkReportMissingProp;
function checkMissingProp({ gen, data, it: { opts: opts2 } }, properties2, missing) {
  return codegen_1$q.or(...properties2.map((prop) => codegen_1$q.and(noPropertyInData(gen, data, prop, opts2.ownProperties), codegen_1$q._`${missing} = ${prop}`)));
}
code.checkMissingProp = checkMissingProp;
function reportMissingProp(cxt, missing) {
  cxt.setParams({ missingProperty: missing }, true);
  cxt.error();
}
code.reportMissingProp = reportMissingProp;
function hasPropFunc(gen) {
  return gen.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: codegen_1$q._`Object.prototype.hasOwnProperty`
  });
}
code.hasPropFunc = hasPropFunc;
function isOwnProperty(gen, data, property) {
  return codegen_1$q._`${hasPropFunc(gen)}.call(${data}, ${property})`;
}
code.isOwnProperty = isOwnProperty;
function propertyInData(gen, data, property, ownProperties) {
  const cond = codegen_1$q._`${data}${codegen_1$q.getProperty(property)} !== undefined`;
  return ownProperties ? codegen_1$q._`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
}
code.propertyInData = propertyInData;
function noPropertyInData(gen, data, property, ownProperties) {
  const cond = codegen_1$q._`${data}${codegen_1$q.getProperty(property)} === undefined`;
  return ownProperties ? codegen_1$q.or(cond, codegen_1$q.not(isOwnProperty(gen, data, property))) : cond;
}
code.noPropertyInData = noPropertyInData;
function allSchemaProperties(schemaMap) {
  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
}
code.allSchemaProperties = allSchemaProperties;
function schemaProperties(it, schemaMap) {
  return allSchemaProperties(schemaMap).filter((p) => !util_1$n.alwaysValidSchema(it, schemaMap[p]));
}
code.schemaProperties = schemaProperties;
function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
  const dataAndSchema = passSchema ? codegen_1$q._`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
  const valCxt = [
    [names_1$5.default.instancePath, codegen_1$q.strConcat(names_1$5.default.instancePath, errorPath)],
    [names_1$5.default.parentData, it.parentData],
    [names_1$5.default.parentDataProperty, it.parentDataProperty],
    [names_1$5.default.rootData, names_1$5.default.rootData]
  ];
  if (it.opts.dynamicRef)
    valCxt.push([names_1$5.default.dynamicAnchors, names_1$5.default.dynamicAnchors]);
  const args = codegen_1$q._`${dataAndSchema}, ${gen.object(...valCxt)}`;
  return context !== codegen_1$q.nil ? codegen_1$q._`${func}.call(${context}, ${args})` : codegen_1$q._`${func}(${args})`;
}
code.callValidateCode = callValidateCode;
function usePattern({ gen, it: { opts: opts2 } }, pattern2) {
  const u2 = opts2.unicodeRegExp ? "u" : "";
  return gen.scopeValue("pattern", {
    key: pattern2,
    ref: new RegExp(pattern2, u2),
    code: codegen_1$q._`new RegExp(${pattern2}, ${u2})`
  });
}
code.usePattern = usePattern;
function validateArray(cxt) {
  const { gen, data, keyword: keyword2, it } = cxt;
  const valid2 = gen.name("valid");
  if (it.allErrors) {
    const validArr = gen.let("valid", true);
    validateItems(() => gen.assign(validArr, false));
    return validArr;
  }
  gen.var(valid2, true);
  validateItems(() => gen.break());
  return valid2;
  function validateItems(notValid) {
    const len = gen.const("len", codegen_1$q._`${data}.length`);
    gen.forRange("i", 0, len, (i) => {
      cxt.subschema({
        keyword: keyword2,
        dataProp: i,
        dataPropType: util_1$n.Type.Num
      }, valid2);
      gen.if(codegen_1$q.not(valid2), notValid);
    });
  }
}
code.validateArray = validateArray;
function validateUnion(cxt) {
  const { gen, schema: schema2, keyword: keyword2, it } = cxt;
  if (!Array.isArray(schema2))
    throw new Error("ajv implementation error");
  const alwaysValid = schema2.some((sch) => util_1$n.alwaysValidSchema(it, sch));
  if (alwaysValid && !it.opts.unevaluated)
    return;
  const valid2 = gen.let("valid", false);
  const schValid = gen.name("_valid");
  gen.block(() => schema2.forEach((_sch, i) => {
    const schCxt = cxt.subschema({
      keyword: keyword2,
      schemaProp: i,
      compositeRule: true
    }, schValid);
    gen.assign(valid2, codegen_1$q._`${valid2} || ${schValid}`);
    const merged = cxt.mergeValidEvaluated(schCxt, schValid);
    if (!merged)
      gen.if(codegen_1$q.not(valid2));
  }));
  cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
}
code.validateUnion = validateUnion;
Object.defineProperty(keyword, "__esModule", { value: true });
keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
const codegen_1$p = codegen;
const names_1$4 = names$1;
const code_1$9 = code;
const errors_1$1 = errors;
function macroKeywordCode(cxt, def2) {
  const { gen, keyword: keyword2, schema: schema2, parentSchema, it } = cxt;
  const macroSchema = def2.macro.call(it.self, schema2, parentSchema, it);
  const schemaRef = useKeyword(gen, keyword2, macroSchema);
  if (it.opts.validateSchema !== false)
    it.self.validateSchema(macroSchema, true);
  const valid2 = gen.name("valid");
  cxt.subschema({
    schema: macroSchema,
    schemaPath: codegen_1$p.nil,
    errSchemaPath: `${it.errSchemaPath}/${keyword2}`,
    topSchemaRef: schemaRef,
    compositeRule: true
  }, valid2);
  cxt.pass(valid2, () => cxt.error(true));
}
keyword.macroKeywordCode = macroKeywordCode;
function funcKeywordCode(cxt, def2) {
  var _a;
  const { gen, keyword: keyword2, schema: schema2, parentSchema, $data, it } = cxt;
  checkAsyncKeyword(it, def2);
  const validate2 = !$data && def2.compile ? def2.compile.call(it.self, schema2, parentSchema, it) : def2.validate;
  const validateRef = useKeyword(gen, keyword2, validate2);
  const valid2 = gen.let("valid");
  cxt.block$data(valid2, validateKeyword);
  cxt.ok((_a = def2.valid) !== null && _a !== void 0 ? _a : valid2);
  function validateKeyword() {
    if (def2.errors === false) {
      assignValid();
      if (def2.modifying)
        modifyData(cxt);
      reportErrs(() => cxt.error());
    } else {
      const ruleErrs = def2.async ? validateAsync() : validateSync();
      if (def2.modifying)
        modifyData(cxt);
      reportErrs(() => addErrs(cxt, ruleErrs));
    }
  }
  function validateAsync() {
    const ruleErrs = gen.let("ruleErrs", null);
    gen.try(() => assignValid(codegen_1$p._`await `), (e) => gen.assign(valid2, false).if(codegen_1$p._`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, codegen_1$p._`${e}.errors`), () => gen.throw(e)));
    return ruleErrs;
  }
  function validateSync() {
    const validateErrs = codegen_1$p._`${validateRef}.errors`;
    gen.assign(validateErrs, null);
    assignValid(codegen_1$p.nil);
    return validateErrs;
  }
  function assignValid(_await = def2.async ? codegen_1$p._`await ` : codegen_1$p.nil) {
    const passCxt = it.opts.passContext ? names_1$4.default.this : names_1$4.default.self;
    const passSchema = !("compile" in def2 && !$data || def2.schema === false);
    gen.assign(valid2, codegen_1$p._`${_await}${code_1$9.callValidateCode(cxt, validateRef, passCxt, passSchema)}`, def2.modifying);
  }
  function reportErrs(errors2) {
    var _a2;
    gen.if(codegen_1$p.not((_a2 = def2.valid) !== null && _a2 !== void 0 ? _a2 : valid2), errors2);
  }
}
keyword.funcKeywordCode = funcKeywordCode;
function modifyData(cxt) {
  const { gen, data, it } = cxt;
  gen.if(it.parentData, () => gen.assign(data, codegen_1$p._`${it.parentData}[${it.parentDataProperty}]`));
}
function addErrs(cxt, errs) {
  const { gen } = cxt;
  gen.if(codegen_1$p._`Array.isArray(${errs})`, () => {
    gen.assign(names_1$4.default.vErrors, codegen_1$p._`${names_1$4.default.vErrors} === null ? ${errs} : ${names_1$4.default.vErrors}.concat(${errs})`).assign(names_1$4.default.errors, codegen_1$p._`${names_1$4.default.vErrors}.length`);
    errors_1$1.extendErrors(cxt);
  }, () => cxt.error());
}
function checkAsyncKeyword({ schemaEnv }, def2) {
  if (def2.async && !schemaEnv.$async)
    throw new Error("async keyword in sync schema");
}
function useKeyword(gen, keyword2, result) {
  if (result === void 0)
    throw new Error(`keyword "${keyword2}" failed to compile`);
  return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: codegen_1$p.stringify(result) });
}
function validSchemaType(schema2, schemaType, allowUndefined = false) {
  return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema2) : st === "object" ? schema2 && typeof schema2 == "object" && !Array.isArray(schema2) : typeof schema2 == st || allowUndefined && typeof schema2 == "undefined");
}
keyword.validSchemaType = validSchemaType;
function validateKeywordUsage({ schema: schema2, opts: opts2, self: self2, errSchemaPath }, def2, keyword2) {
  if (Array.isArray(def2.keyword) ? !def2.keyword.includes(keyword2) : def2.keyword !== keyword2) {
    throw new Error("ajv implementation error");
  }
  const deps = def2.dependencies;
  if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema2, kwd))) {
    throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
  }
  if (def2.validateSchema) {
    const valid2 = def2.validateSchema(schema2[keyword2]);
    if (!valid2) {
      const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def2.validateSchema.errors);
      if (opts2.validateSchema === "log")
        self2.logger.error(msg);
      else
        throw new Error(msg);
    }
  }
}
keyword.validateKeywordUsage = validateKeywordUsage;
var subschema = {};
Object.defineProperty(subschema, "__esModule", { value: true });
subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
const codegen_1$o = codegen;
const util_1$m = util;
function getSubschema(it, { keyword: keyword2, schemaProp, schema: schema2, schemaPath, errSchemaPath, topSchemaRef }) {
  if (keyword2 !== void 0 && schema2 !== void 0) {
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  }
  if (keyword2 !== void 0) {
    const sch = it.schema[keyword2];
    return schemaProp === void 0 ? {
      schema: sch,
      schemaPath: codegen_1$o._`${it.schemaPath}${codegen_1$o.getProperty(keyword2)}`,
      errSchemaPath: `${it.errSchemaPath}/${keyword2}`
    } : {
      schema: sch[schemaProp],
      schemaPath: codegen_1$o._`${it.schemaPath}${codegen_1$o.getProperty(keyword2)}${codegen_1$o.getProperty(schemaProp)}`,
      errSchemaPath: `${it.errSchemaPath}/${keyword2}/${util_1$m.escapeFragment(schemaProp)}`
    };
  }
  if (schema2 !== void 0) {
    if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    }
    return {
      schema: schema2,
      schemaPath,
      topSchemaRef,
      errSchemaPath
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
subschema.getSubschema = getSubschema;
function extendSubschemaData(subschema2, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
  if (data !== void 0 && dataProp !== void 0) {
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  }
  const { gen } = it;
  if (dataProp !== void 0) {
    const { errorPath, dataPathArr, opts: opts2 } = it;
    const nextData = gen.let("data", codegen_1$o._`${it.data}${codegen_1$o.getProperty(dataProp)}`, true);
    dataContextProps(nextData);
    subschema2.errorPath = codegen_1$o.str`${errorPath}${util_1$m.getErrorPath(dataProp, dpType, opts2.jsPropertySyntax)}`;
    subschema2.parentDataProperty = codegen_1$o._`${dataProp}`;
    subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
  }
  if (data !== void 0) {
    const nextData = data instanceof codegen_1$o.Name ? data : gen.let("data", data, true);
    dataContextProps(nextData);
    if (propertyName !== void 0)
      subschema2.propertyName = propertyName;
  }
  if (dataTypes)
    subschema2.dataTypes = dataTypes;
  function dataContextProps(_nextData) {
    subschema2.data = _nextData;
    subschema2.dataLevel = it.dataLevel + 1;
    subschema2.dataTypes = [];
    it.definedProperties = /* @__PURE__ */ new Set();
    subschema2.parentData = it.data;
    subschema2.dataNames = [...it.dataNames, _nextData];
  }
}
subschema.extendSubschemaData = extendSubschemaData;
function extendSubschemaMode(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
  if (compositeRule !== void 0)
    subschema2.compositeRule = compositeRule;
  if (createErrors !== void 0)
    subschema2.createErrors = createErrors;
  if (allErrors !== void 0)
    subschema2.allErrors = allErrors;
  subschema2.jtdDiscriminator = jtdDiscriminator;
  subschema2.jtdMetadata = jtdMetadata;
}
subschema.extendSubschemaMode = extendSubschemaMode;
var resolve$1 = {};
var fastDeepEqual = function equal(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    if (a.constructor !== b.constructor)
      return false;
    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!equal(a[i], b[i]))
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
        return false;
    for (i = length; i-- !== 0; ) {
      var key = keys[i];
      if (!equal(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
};
var jsonSchemaTraverse = { exports: {} };
var traverse$1 = jsonSchemaTraverse.exports = function(schema2, opts2, cb) {
  if (typeof opts2 == "function") {
    cb = opts2;
    opts2 = {};
  }
  cb = opts2.cb || cb;
  var pre = typeof cb == "function" ? cb : cb.pre || function() {
  };
  var post = cb.post || function() {
  };
  _traverse(opts2, pre, post, schema2, "", schema2);
};
traverse$1.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true,
  if: true,
  then: true,
  else: true
};
traverse$1.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};
traverse$1.propsKeywords = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};
traverse$1.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};
function _traverse(opts2, pre, post, schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema2 && typeof schema2 == "object" && !Array.isArray(schema2)) {
    pre(schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema2) {
      var sch = schema2[key];
      if (Array.isArray(sch)) {
        if (key in traverse$1.arrayKeywords) {
          for (var i = 0; i < sch.length; i++)
            _traverse(opts2, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema2, i);
        }
      } else if (key in traverse$1.propsKeywords) {
        if (sch && typeof sch == "object") {
          for (var prop in sch)
            _traverse(opts2, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema2, prop);
        }
      } else if (key in traverse$1.keywords || opts2.allKeys && !(key in traverse$1.skipKeywords)) {
        _traverse(opts2, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema2);
      }
    }
    post(schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}
function escapeJsonPtr(str) {
  return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
var jsonSchemaTraverseExports = jsonSchemaTraverse.exports;
var uri_all = { exports: {} };
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function(module2, exports2) {
  (function(global2, factory) {
    factory(exports2);
  })(commonjsGlobal, function(exports3) {
    function merge() {
      for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
        sets[_key] = arguments[_key];
      }
      if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
          sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join("");
      } else {
        return sets[0];
      }
    }
    function subexp(str) {
      return "(?:" + str + ")";
    }
    function typeOf(o) {
      return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
    }
    function toUpperCase(str) {
      return str.toUpperCase();
    }
    function toArray(obj) {
      return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
    }
    function assign(target, source2) {
      var obj = target;
      if (source2) {
        for (var key in source2) {
          obj[key] = source2[key];
        }
      }
      return obj;
    }
    function buildExps(isIRI) {
      var ALPHA$$ = "[A-Za-z]", DIGIT$$ = "[0-9]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$);
      subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*");
      subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*");
      var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+");
      subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+");
      subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*");
      var PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]"));
      subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+");
      subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*");
      return {
        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
        //RFC 6874, with relaxed parsing rules
      };
    }
    var URI_PROTOCOL = buildExps(false);
    var IRI_PROTOCOL = buildExps(true);
    var slicedToArray = /* @__PURE__ */ function() {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"])
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    var toConsumableArray = function(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
          arr2[i] = arr[i];
        return arr2;
      } else {
        return Array.from(arr);
      }
    };
    var maxInt = 2147483647;
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter = "-";
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7E]/;
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    var errors2 = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    function error$12(type2) {
      throw new RangeError(errors2[type2]);
    }
    function map(array, fn) {
      var result = [];
      var length = array.length;
      while (length--) {
        result[length] = fn(array[length]);
      }
      return result;
    }
    function mapDomain(string, fn) {
      var parts = string.split("@");
      var result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string = parts[1];
      }
      string = string.replace(regexSeparators, ".");
      var labels = string.split(".");
      var encoded = map(labels, fn).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      var output = [];
      var counter = 0;
      var length = string.length;
      while (counter < length) {
        var value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          var extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    var ucs2encode = function ucs2encode2(array) {
      return String.fromCodePoint.apply(String, toConsumableArray(array));
    };
    var basicToDigit = function basicToDigit2(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    };
    var digitToBasic = function digitToBasic2(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    var adapt = function adapt2(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (
        ;
        /* no initialization */
        delta > baseMinusTMin * tMax >> 1;
        k += base
      ) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var decode = function decode2(input) {
      var output = [];
      var inputLength = input.length;
      var i = 0;
      var n = initialN;
      var bias = initialBias;
      var basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (var j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error$12("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        var oldi = i;
        for (
          var w = 1, k = base;
          ;
          /* no condition */
          k += base
        ) {
          if (index >= inputLength) {
            error$12("invalid-input");
          }
          var digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base || digit > floor((maxInt - i) / w)) {
            error$12("overflow");
          }
          i += digit * w;
          var t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t2) {
            break;
          }
          var baseMinusT = base - t2;
          if (w > floor(maxInt / baseMinusT)) {
            error$12("overflow");
          }
          w *= baseMinusT;
        }
        var out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error$12("overflow");
        }
        n += floor(i / out);
        i %= out;
        output.splice(i++, 0, n);
      }
      return String.fromCodePoint.apply(String, output);
    };
    var encode = function encode2(input) {
      var output = [];
      input = ucs2decode(input);
      var inputLength = input.length;
      var n = initialN;
      var delta = 0;
      var bias = initialBias;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _currentValue2 = _step.value;
          if (_currentValue2 < 128) {
            output.push(stringFromCharCode(_currentValue2));
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      var basicLength = output.length;
      var handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        var m = maxInt;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = void 0;
        try {
          for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var currentValue = _step2.value;
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
        var handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error$12("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = void 0;
        try {
          for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _currentValue = _step3.value;
            if (_currentValue < n && ++delta > maxInt) {
              error$12("overflow");
            }
            if (_currentValue == n) {
              var q = delta;
              for (
                var k = base;
                ;
                /* no condition */
                k += base
              ) {
                var t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t2) {
                  break;
                }
                var qMinusT = q - t2;
                var baseMinusT = base - t2;
                output.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    };
    var toUnicode = function toUnicode2(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    var toASCII = function toASCII2(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    var punycode = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      "version": "2.1.0",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode,
      "encode": encode,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    var SCHEMES = {};
    function pctEncChar(chr) {
      var c = chr.charCodeAt(0);
      var e = void 0;
      if (c < 16)
        e = "%0" + c.toString(16).toUpperCase();
      else if (c < 128)
        e = "%" + c.toString(16).toUpperCase();
      else if (c < 2048)
        e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      else
        e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      return e;
    }
    function pctDecChars(str) {
      var newStr = "";
      var i = 0;
      var il = str.length;
      while (i < il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
          newStr += String.fromCharCode(c);
          i += 3;
        } else if (c >= 194 && c < 224) {
          if (il - i >= 6) {
            var c2 = parseInt(str.substr(i + 4, 2), 16);
            newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
          } else {
            newStr += str.substr(i, 6);
          }
          i += 6;
        } else if (c >= 224) {
          if (il - i >= 9) {
            var _c = parseInt(str.substr(i + 4, 2), 16);
            var c3 = parseInt(str.substr(i + 7, 2), 16);
            newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
          } else {
            newStr += str.substr(i, 9);
          }
          i += 9;
        } else {
          newStr += str.substr(i, 3);
          i += 3;
        }
      }
      return newStr;
    }
    function _normalizeComponentEncoding(components, protocol) {
      function decodeUnreserved2(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
      }
      if (components.scheme)
        components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
      if (components.userinfo !== void 0)
        components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.host !== void 0)
        components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.path !== void 0)
        components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.query !== void 0)
        components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.fragment !== void 0)
        components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      return components;
    }
    function _stripLeadingZeros(str) {
      return str.replace(/^0*(.*)/, "$1") || "0";
    }
    function _normalizeIPv4(host, protocol) {
      var matches = host.match(protocol.IPV4ADDRESS) || [];
      var _matches = slicedToArray(matches, 2), address = _matches[1];
      if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
      } else {
        return host;
      }
    }
    function _normalizeIPv6(host, protocol) {
      var matches = host.match(protocol.IPV6ADDRESS) || [];
      var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
      if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
          fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
        }
        if (isLastFieldIPv4Address) {
          fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function(acc, field, index) {
          if (!field || field === "0") {
            var lastLongest = acc[acc.length - 1];
            if (lastLongest && lastLongest.index + lastLongest.length === index) {
              lastLongest.length++;
            } else {
              acc.push({ index, length: 1 });
            }
          }
          return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function(a, b) {
          return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
          var newFirst = fields.slice(0, longestZeroFields.index);
          var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
          newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
          newHost = fields.join(":");
        }
        if (zone) {
          newHost += "%" + zone;
        }
        return newHost;
      } else {
        return host;
      }
    }
    var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
    var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
    function parse2(uriString) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var components = {};
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      if (options.reference === "suffix")
        uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
      var matches = uriString.match(URI_PARSE);
      if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
          components.scheme = matches[1];
          components.userinfo = matches[3];
          components.host = matches[4];
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = matches[7];
          components.fragment = matches[8];
          if (isNaN(components.port)) {
            components.port = matches[5];
          }
        } else {
          components.scheme = matches[1] || void 0;
          components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
          components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
          components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
          if (isNaN(components.port)) {
            components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
          }
        }
        if (components.host) {
          components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
          components.reference = "same-document";
        } else if (components.scheme === void 0) {
          components.reference = "relative";
        } else if (components.fragment === void 0) {
          components.reference = "absolute";
        } else {
          components.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
          components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
            try {
              components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
            }
          }
          _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
          _normalizeComponentEncoding(components, protocol);
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(components, options);
        }
      } else {
        components.error = components.error || "URI can not be parsed.";
      }
      return components;
    }
    function _recomposeAuthority(components, options) {
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
          return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    var RDS1 = /^\.\.?\//;
    var RDS2 = /^\/\.(\/|$)/;
    var RDS3 = /^\/\.\.(\/|$)/;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
    function removeDotSegments(input) {
      var output = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          var im = input.match(RDS5);
          if (im) {
            var s = im[0];
            input = input.slice(s.length);
            output.push(s);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output.join("");
    }
    function serialize(components) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize)
        schemeHandler.serialize(components, options);
      if (components.host) {
        if (protocol.IPV6ADDRESS.test(components.host))
          ;
        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
          try {
            components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
          } catch (e) {
            components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
          }
        }
      }
      _normalizeComponentEncoding(components, protocol);
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
      }
      var authority = _recomposeAuthority(components, options);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        var s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0) {
          s = s.replace(/^\/\//, "/%2F");
        }
        uriTokens.push(s);
      }
      if (components.query !== void 0) {
        uriTokens.push("?");
        uriTokens.push(components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
      }
      return uriTokens.join("");
    }
    function resolveComponents(base2, relative) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var skipNormalization = arguments[3];
      var target = {};
      if (!skipNormalization) {
        base2 = parse2(serialize(base2, options), options);
        relative = parse2(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base2.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base2.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                target.path = "/" + relative.path;
              } else if (!base2.path) {
                target.path = relative.path;
              } else {
                target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base2.userinfo;
          target.host = base2.host;
          target.port = base2.port;
        }
        target.scheme = base2.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function resolve2(baseURI, relativeURI, options) {
      var schemelessOptions = assign({ scheme: "null" }, options);
      return serialize(resolveComponents(parse2(baseURI, schemelessOptions), parse2(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
    }
    function normalize(uri, options) {
      if (typeof uri === "string") {
        uri = serialize(parse2(uri, options), options);
      } else if (typeOf(uri) === "object") {
        uri = parse2(serialize(uri, options), options);
      }
      return uri;
    }
    function equal3(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = serialize(parse2(uriA, options), options);
      } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
      }
      if (typeof uriB === "string") {
        uriB = serialize(parse2(uriB, options), options);
      } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
      }
      return uriA === uriB;
    }
    function escapeComponent(str, options) {
      return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
    }
    function unescapeComponent(str, options) {
      return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
    }
    var handler = {
      scheme: "http",
      domainHost: true,
      parse: function parse3(components, options) {
        if (!components.host) {
          components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
      },
      serialize: function serialize2(components, options) {
        var secure = String(components.scheme).toLowerCase() === "https";
        if (components.port === (secure ? 443 : 80) || components.port === "") {
          components.port = void 0;
        }
        if (!components.path) {
          components.path = "/";
        }
        return components;
      }
    };
    var handler$1 = {
      scheme: "https",
      domainHost: handler.domainHost,
      parse: handler.parse,
      serialize: handler.serialize
    };
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    var handler$2 = {
      scheme: "ws",
      domainHost: true,
      parse: function parse3(components, options) {
        var wsComponents = components;
        wsComponents.secure = isSecure(wsComponents);
        wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
        wsComponents.path = void 0;
        wsComponents.query = void 0;
        return wsComponents;
      },
      serialize: function serialize2(wsComponents, options) {
        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
          wsComponents.port = void 0;
        }
        if (typeof wsComponents.secure === "boolean") {
          wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
          wsComponents.secure = void 0;
        }
        if (wsComponents.resourceName) {
          var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path2 = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
          wsComponents.path = path2 && path2 !== "/" ? path2 : void 0;
          wsComponents.query = query;
          wsComponents.resourceName = void 0;
        }
        wsComponents.fragment = void 0;
        return wsComponents;
      }
    };
    var handler$3 = {
      scheme: "wss",
      domainHost: handler$2.domainHost,
      parse: handler$2.parse,
      serialize: handler$2.serialize
    };
    var O = {};
    var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]";
    var HEXDIG$$ = "[0-9A-Fa-f]";
    var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
    var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
    var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
    var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
    var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
    var UNRESERVED = new RegExp(UNRESERVED$$, "g");
    var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
    var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
    var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
    var NOT_HFVALUE = NOT_HFNAME;
    function decodeUnreserved(str) {
      var decStr = pctDecChars(str);
      return !decStr.match(UNRESERVED) ? str : decStr;
    }
    var handler$4 = {
      scheme: "mailto",
      parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = void 0;
        if (mailtoComponents.query) {
          var unknownHeaders = false;
          var headers = {};
          var hfields = mailtoComponents.query.split("&");
          for (var x = 0, xl = hfields.length; x < xl; ++x) {
            var hfield = hfields[x].split("=");
            switch (hfield[0]) {
              case "to":
                var toAddrs = hfield[1].split(",");
                for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                  to.push(toAddrs[_x]);
                }
                break;
              case "subject":
                mailtoComponents.subject = unescapeComponent(hfield[1], options);
                break;
              case "body":
                mailtoComponents.body = unescapeComponent(hfield[1], options);
                break;
              default:
                unknownHeaders = true;
                headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                break;
            }
          }
          if (unknownHeaders)
            mailtoComponents.headers = headers;
        }
        mailtoComponents.query = void 0;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
          var addr = to[_x2].split("@");
          addr[0] = unescapeComponent(addr[0]);
          if (!options.unicodeSupport) {
            try {
              addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
            } catch (e) {
              mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
            }
          } else {
            addr[1] = unescapeComponent(addr[1], options).toLowerCase();
          }
          to[_x2] = addr.join("@");
        }
        return mailtoComponents;
      },
      serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray(mailtoComponents.to);
        if (to) {
          for (var x = 0, xl = to.length; x < xl; ++x) {
            var toAddr = String(to[x]);
            var atIdx = toAddr.lastIndexOf("@");
            var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
            var domain = toAddr.slice(atIdx + 1);
            try {
              domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
            } catch (e) {
              components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
            to[x] = localPart + "@" + domain;
          }
          components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject)
          headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body)
          headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
          if (headers[name] !== O[name]) {
            fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
          }
        }
        if (fields.length) {
          components.query = fields.join("&");
        }
        return components;
      }
    };
    var URN_PARSE = /^([^\:]+)\:(.*)/;
    var handler$5 = {
      scheme: "urn",
      parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = matches[1].toLowerCase();
          var nss = matches[2];
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          urnComponents.nid = nid;
          urnComponents.nss = nss;
          urnComponents.path = void 0;
          if (schemeHandler) {
            urnComponents = schemeHandler.parse(urnComponents, options);
          }
        } else {
          urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
      },
      serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
          urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
      }
    };
    var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
    var handler$6 = {
      scheme: "urn:uuid",
      parse: function parse3(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = void 0;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
          uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
      },
      serialize: function serialize2(uuidComponents, options) {
        var urnComponents = uuidComponents;
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
      }
    };
    SCHEMES[handler.scheme] = handler;
    SCHEMES[handler$1.scheme] = handler$1;
    SCHEMES[handler$2.scheme] = handler$2;
    SCHEMES[handler$3.scheme] = handler$3;
    SCHEMES[handler$4.scheme] = handler$4;
    SCHEMES[handler$5.scheme] = handler$5;
    SCHEMES[handler$6.scheme] = handler$6;
    exports3.SCHEMES = SCHEMES;
    exports3.pctEncChar = pctEncChar;
    exports3.pctDecChars = pctDecChars;
    exports3.parse = parse2;
    exports3.removeDotSegments = removeDotSegments;
    exports3.serialize = serialize;
    exports3.resolveComponents = resolveComponents;
    exports3.resolve = resolve2;
    exports3.normalize = normalize;
    exports3.equal = equal3;
    exports3.escapeComponent = escapeComponent;
    exports3.unescapeComponent = unescapeComponent;
    Object.defineProperty(exports3, "__esModule", { value: true });
  });
})(uri_all, uri_all.exports);
var uri_allExports = uri_all.exports;
Object.defineProperty(resolve$1, "__esModule", { value: true });
resolve$1.getSchemaRefs = resolve$1.resolveUrl = resolve$1.normalizeId = resolve$1._getFullPath = resolve$1.getFullPath = resolve$1.inlineRef = void 0;
const util_1$l = util;
const equal$2 = fastDeepEqual;
const traverse = jsonSchemaTraverseExports;
const URI$1 = uri_allExports;
const SIMPLE_INLINED = /* @__PURE__ */ new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function inlineRef(schema2, limit2 = true) {
  if (typeof schema2 == "boolean")
    return true;
  if (limit2 === true)
    return !hasRef(schema2);
  if (!limit2)
    return false;
  return countKeys(schema2) <= limit2;
}
resolve$1.inlineRef = inlineRef;
const REF_KEYWORDS = /* @__PURE__ */ new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function hasRef(schema2) {
  for (const key in schema2) {
    if (REF_KEYWORDS.has(key))
      return true;
    const sch = schema2[key];
    if (Array.isArray(sch) && sch.some(hasRef))
      return true;
    if (typeof sch == "object" && hasRef(sch))
      return true;
  }
  return false;
}
function countKeys(schema2) {
  let count = 0;
  for (const key in schema2) {
    if (key === "$ref")
      return Infinity;
    count++;
    if (SIMPLE_INLINED.has(key))
      continue;
    if (typeof schema2[key] == "object") {
      util_1$l.eachItem(schema2[key], (sch) => count += countKeys(sch));
    }
    if (count === Infinity)
      return Infinity;
  }
  return count;
}
function getFullPath(id2 = "", normalize) {
  if (normalize !== false)
    id2 = normalizeId(id2);
  const p = URI$1.parse(id2);
  return _getFullPath(p);
}
resolve$1.getFullPath = getFullPath;
function _getFullPath(p) {
  return URI$1.serialize(p).split("#")[0] + "#";
}
resolve$1._getFullPath = _getFullPath;
const TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id2) {
  return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
}
resolve$1.normalizeId = normalizeId;
function resolveUrl(baseId, id2) {
  id2 = normalizeId(id2);
  return URI$1.resolve(baseId, id2);
}
resolve$1.resolveUrl = resolveUrl;
const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
function getSchemaRefs(schema2) {
  if (typeof schema2 == "boolean")
    return {};
  const { schemaId } = this.opts;
  const schId = normalizeId(schema2[schemaId]);
  const baseIds = { "": schId };
  const pathPrefix = getFullPath(schId, false);
  const localRefs = {};
  const schemaRefs = /* @__PURE__ */ new Set();
  traverse(schema2, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
    if (parentJsonPtr === void 0)
      return;
    const fullPath = pathPrefix + jsonPtr;
    let baseId = baseIds[parentJsonPtr];
    if (typeof sch[schemaId] == "string")
      baseId = addRef.call(this, sch[schemaId]);
    addAnchor.call(this, sch.$anchor);
    addAnchor.call(this, sch.$dynamicAnchor);
    baseIds[jsonPtr] = baseId;
    function addRef(ref2) {
      ref2 = normalizeId(baseId ? URI$1.resolve(baseId, ref2) : ref2);
      if (schemaRefs.has(ref2))
        throw ambiguos(ref2);
      schemaRefs.add(ref2);
      let schOrRef = this.refs[ref2];
      if (typeof schOrRef == "string")
        schOrRef = this.refs[schOrRef];
      if (typeof schOrRef == "object") {
        checkAmbiguosRef(sch, schOrRef.schema, ref2);
      } else if (ref2 !== normalizeId(fullPath)) {
        if (ref2[0] === "#") {
          checkAmbiguosRef(sch, localRefs[ref2], ref2);
          localRefs[ref2] = sch;
        } else {
          this.refs[ref2] = fullPath;
        }
      }
      return ref2;
    }
    function addAnchor(anchor) {
      if (typeof anchor == "string") {
        if (!ANCHOR.test(anchor))
          throw new Error(`invalid anchor "${anchor}"`);
        addRef.call(this, `#${anchor}`);
      }
    }
  });
  return localRefs;
  function checkAmbiguosRef(sch1, sch2, ref2) {
    if (sch2 !== void 0 && !equal$2(sch1, sch2))
      throw ambiguos(ref2);
  }
  function ambiguos(ref2) {
    return new Error(`reference "${ref2}" resolves to more than one schema`);
  }
}
resolve$1.getSchemaRefs = getSchemaRefs;
Object.defineProperty(validate, "__esModule", { value: true });
validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
const boolSchema_1 = boolSchema;
const dataType_1$1 = dataType;
const applicability_1 = applicability;
const dataType_2 = dataType;
const defaults_1 = defaults;
const keyword_1 = keyword;
const subschema_1 = subschema;
const codegen_1$n = codegen;
const names_1$3 = names$1;
const resolve_1$2 = resolve$1;
const util_1$k = util;
const errors_1 = errors;
function validateFunctionCode(it) {
  if (isSchemaObj(it)) {
    checkKeywords(it);
    if (schemaCxtHasRules(it)) {
      topSchemaObjCode(it);
      return;
    }
  }
  validateFunction(it, () => boolSchema_1.topBoolOrEmptySchema(it));
}
validate.validateFunctionCode = validateFunctionCode;
function validateFunction({ gen, validateName, schema: schema2, schemaEnv, opts: opts2 }, body) {
  if (opts2.code.es5) {
    gen.func(validateName, codegen_1$n._`${names_1$3.default.data}, ${names_1$3.default.valCxt}`, schemaEnv.$async, () => {
      gen.code(codegen_1$n._`"use strict"; ${funcSourceUrl(schema2, opts2)}`);
      destructureValCxtES5(gen, opts2);
      gen.code(body);
    });
  } else {
    gen.func(validateName, codegen_1$n._`${names_1$3.default.data}, ${destructureValCxt(opts2)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema2, opts2)).code(body));
  }
}
function destructureValCxt(opts2) {
  return codegen_1$n._`{${names_1$3.default.instancePath}="", ${names_1$3.default.parentData}, ${names_1$3.default.parentDataProperty}, ${names_1$3.default.rootData}=${names_1$3.default.data}${opts2.dynamicRef ? codegen_1$n._`, ${names_1$3.default.dynamicAnchors}={}` : codegen_1$n.nil}}={}`;
}
function destructureValCxtES5(gen, opts2) {
  gen.if(names_1$3.default.valCxt, () => {
    gen.var(names_1$3.default.instancePath, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.instancePath}`);
    gen.var(names_1$3.default.parentData, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.parentData}`);
    gen.var(names_1$3.default.parentDataProperty, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.parentDataProperty}`);
    gen.var(names_1$3.default.rootData, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.rootData}`);
    if (opts2.dynamicRef)
      gen.var(names_1$3.default.dynamicAnchors, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.dynamicAnchors}`);
  }, () => {
    gen.var(names_1$3.default.instancePath, codegen_1$n._`""`);
    gen.var(names_1$3.default.parentData, codegen_1$n._`undefined`);
    gen.var(names_1$3.default.parentDataProperty, codegen_1$n._`undefined`);
    gen.var(names_1$3.default.rootData, names_1$3.default.data);
    if (opts2.dynamicRef)
      gen.var(names_1$3.default.dynamicAnchors, codegen_1$n._`{}`);
  });
}
function topSchemaObjCode(it) {
  const { schema: schema2, opts: opts2, gen } = it;
  validateFunction(it, () => {
    if (opts2.$comment && schema2.$comment)
      commentKeyword(it);
    checkNoDefault(it);
    gen.let(names_1$3.default.vErrors, null);
    gen.let(names_1$3.default.errors, 0);
    if (opts2.unevaluated)
      resetEvaluated(it);
    typeAndKeywords(it);
    returnResults(it);
  });
  return;
}
function resetEvaluated(it) {
  const { gen, validateName } = it;
  it.evaluated = gen.const("evaluated", codegen_1$n._`${validateName}.evaluated`);
  gen.if(codegen_1$n._`${it.evaluated}.dynamicProps`, () => gen.assign(codegen_1$n._`${it.evaluated}.props`, codegen_1$n._`undefined`));
  gen.if(codegen_1$n._`${it.evaluated}.dynamicItems`, () => gen.assign(codegen_1$n._`${it.evaluated}.items`, codegen_1$n._`undefined`));
}
function funcSourceUrl(schema2, opts2) {
  const schId = typeof schema2 == "object" && schema2[opts2.schemaId];
  return schId && (opts2.code.source || opts2.code.process) ? codegen_1$n._`/*# sourceURL=${schId} */` : codegen_1$n.nil;
}
function subschemaCode(it, valid2) {
  if (isSchemaObj(it)) {
    checkKeywords(it);
    if (schemaCxtHasRules(it)) {
      subSchemaObjCode(it, valid2);
      return;
    }
  }
  boolSchema_1.boolOrEmptySchema(it, valid2);
}
function schemaCxtHasRules({ schema: schema2, self: self2 }) {
  if (typeof schema2 == "boolean")
    return !schema2;
  for (const key in schema2)
    if (self2.RULES.all[key])
      return true;
  return false;
}
function isSchemaObj(it) {
  return typeof it.schema != "boolean";
}
function subSchemaObjCode(it, valid2) {
  const { schema: schema2, gen, opts: opts2 } = it;
  if (opts2.$comment && schema2.$comment)
    commentKeyword(it);
  updateContext(it);
  checkAsyncSchema(it);
  const errsCount = gen.const("_errs", names_1$3.default.errors);
  typeAndKeywords(it, errsCount);
  gen.var(valid2, codegen_1$n._`${errsCount} === ${names_1$3.default.errors}`);
}
function checkKeywords(it) {
  util_1$k.checkUnknownRules(it);
  checkRefsAndKeywords(it);
}
function typeAndKeywords(it, errsCount) {
  if (it.opts.jtd)
    return schemaKeywords(it, [], false, errsCount);
  const types2 = dataType_1$1.getSchemaTypes(it.schema);
  const checkedTypes = dataType_1$1.coerceAndCheckDataType(it, types2);
  schemaKeywords(it, types2, !checkedTypes, errsCount);
}
function checkRefsAndKeywords(it) {
  const { schema: schema2, errSchemaPath, opts: opts2, self: self2 } = it;
  if (schema2.$ref && opts2.ignoreKeywordsWithRef && util_1$k.schemaHasRulesButRef(schema2, self2.RULES)) {
    self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
  }
}
function checkNoDefault(it) {
  const { schema: schema2, opts: opts2 } = it;
  if (schema2.default !== void 0 && opts2.useDefaults && opts2.strictSchema) {
    util_1$k.checkStrictMode(it, "default is ignored in the schema root");
  }
}
function updateContext(it) {
  const schId = it.schema[it.opts.schemaId];
  if (schId)
    it.baseId = resolve_1$2.resolveUrl(it.baseId, schId);
}
function checkAsyncSchema(it) {
  if (it.schema.$async && !it.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function commentKeyword({ gen, schemaEnv, schema: schema2, errSchemaPath, opts: opts2 }) {
  const msg = schema2.$comment;
  if (opts2.$comment === true) {
    gen.code(codegen_1$n._`${names_1$3.default.self}.logger.log(${msg})`);
  } else if (typeof opts2.$comment == "function") {
    const schemaPath = codegen_1$n.str`${errSchemaPath}/$comment`;
    const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
    gen.code(codegen_1$n._`${names_1$3.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
  }
}
function returnResults(it) {
  const { gen, schemaEnv, validateName, ValidationError: ValidationError2, opts: opts2 } = it;
  if (schemaEnv.$async) {
    gen.if(codegen_1$n._`${names_1$3.default.errors} === 0`, () => gen.return(names_1$3.default.data), () => gen.throw(codegen_1$n._`new ${ValidationError2}(${names_1$3.default.vErrors})`));
  } else {
    gen.assign(codegen_1$n._`${validateName}.errors`, names_1$3.default.vErrors);
    if (opts2.unevaluated)
      assignEvaluated(it);
    gen.return(codegen_1$n._`${names_1$3.default.errors} === 0`);
  }
}
function assignEvaluated({ gen, evaluated, props, items: items2 }) {
  if (props instanceof codegen_1$n.Name)
    gen.assign(codegen_1$n._`${evaluated}.props`, props);
  if (items2 instanceof codegen_1$n.Name)
    gen.assign(codegen_1$n._`${evaluated}.items`, items2);
}
function schemaKeywords(it, types2, typeErrors, errsCount) {
  const { gen, schema: schema2, data, allErrors, opts: opts2, self: self2 } = it;
  const { RULES } = self2;
  if (schema2.$ref && (opts2.ignoreKeywordsWithRef || !util_1$k.schemaHasRulesButRef(schema2, RULES))) {
    gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
    return;
  }
  if (!opts2.jtd)
    checkStrictTypes(it, types2);
  gen.block(() => {
    for (const group of RULES.rules)
      groupKeywords(group);
    groupKeywords(RULES.post);
  });
  function groupKeywords(group) {
    if (!applicability_1.shouldUseGroup(schema2, group))
      return;
    if (group.type) {
      gen.if(dataType_2.checkDataType(group.type, data, opts2.strictNumbers));
      iterateKeywords(it, group);
      if (types2.length === 1 && types2[0] === group.type && typeErrors) {
        gen.else();
        dataType_2.reportTypeError(it);
      }
      gen.endIf();
    } else {
      iterateKeywords(it, group);
    }
    if (!allErrors)
      gen.if(codegen_1$n._`${names_1$3.default.errors} === ${errsCount || 0}`);
  }
}
function iterateKeywords(it, group) {
  const { gen, schema: schema2, opts: { useDefaults } } = it;
  if (useDefaults)
    defaults_1.assignDefaults(it, group.type);
  gen.block(() => {
    for (const rule of group.rules) {
      if (applicability_1.shouldUseRule(schema2, rule)) {
        keywordCode(it, rule.keyword, rule.definition, group.type);
      }
    }
  });
}
function checkStrictTypes(it, types2) {
  if (it.schemaEnv.meta || !it.opts.strictTypes)
    return;
  checkContextTypes(it, types2);
  if (!it.opts.allowUnionTypes)
    checkMultipleTypes(it, types2);
  checkKeywordTypes(it, it.dataTypes);
}
function checkContextTypes(it, types2) {
  if (!types2.length)
    return;
  if (!it.dataTypes.length) {
    it.dataTypes = types2;
    return;
  }
  types2.forEach((t2) => {
    if (!includesType(it.dataTypes, t2)) {
      strictTypesError(it, `type "${t2}" not allowed by context "${it.dataTypes.join(",")}"`);
    }
  });
  it.dataTypes = it.dataTypes.filter((t2) => includesType(types2, t2));
}
function checkMultipleTypes(it, ts) {
  if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
    strictTypesError(it, "use allowUnionTypes to allow union type keyword");
  }
}
function checkKeywordTypes(it, ts) {
  const rules2 = it.self.RULES.all;
  for (const keyword2 in rules2) {
    const rule = rules2[keyword2];
    if (typeof rule == "object" && applicability_1.shouldUseRule(it.schema, rule)) {
      const { type: type2 } = rule.definition;
      if (type2.length && !type2.some((t2) => hasApplicableType(ts, t2))) {
        strictTypesError(it, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
      }
    }
  }
}
function hasApplicableType(schTs, kwdT) {
  return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
}
function includesType(ts, t2) {
  return ts.includes(t2) || t2 === "integer" && ts.includes("number");
}
function strictTypesError(it, msg) {
  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
  msg += ` at "${schemaPath}" (strictTypes)`;
  util_1$k.checkStrictMode(it, msg, it.opts.strictTypes);
}
class KeywordCxt {
  constructor(it, def2, keyword2) {
    keyword_1.validateKeywordUsage(it, def2, keyword2);
    this.gen = it.gen;
    this.allErrors = it.allErrors;
    this.keyword = keyword2;
    this.data = it.data;
    this.schema = it.schema[keyword2];
    this.$data = def2.$data && it.opts.$data && this.schema && this.schema.$data;
    this.schemaValue = util_1$k.schemaRefOrVal(it, this.schema, keyword2, this.$data);
    this.schemaType = def2.schemaType;
    this.parentSchema = it.schema;
    this.params = {};
    this.it = it;
    this.def = def2;
    if (this.$data) {
      this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
    } else {
      this.schemaCode = this.schemaValue;
      if (!keyword_1.validSchemaType(this.schema, def2.schemaType, def2.allowUndefined)) {
        throw new Error(`${keyword2} value must be ${JSON.stringify(def2.schemaType)}`);
      }
    }
    if ("code" in def2 ? def2.trackErrors : def2.errors !== false) {
      this.errsCount = it.gen.const("_errs", names_1$3.default.errors);
    }
  }
  result(condition, successAction, failAction) {
    this.failResult(codegen_1$n.not(condition), successAction, failAction);
  }
  failResult(condition, successAction, failAction) {
    this.gen.if(condition);
    if (failAction)
      failAction();
    else
      this.error();
    if (successAction) {
      this.gen.else();
      successAction();
      if (this.allErrors)
        this.gen.endIf();
    } else {
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
  }
  pass(condition, failAction) {
    this.failResult(codegen_1$n.not(condition), void 0, failAction);
  }
  fail(condition) {
    if (condition === void 0) {
      this.error();
      if (!this.allErrors)
        this.gen.if(false);
      return;
    }
    this.gen.if(condition);
    this.error();
    if (this.allErrors)
      this.gen.endIf();
    else
      this.gen.else();
  }
  fail$data(condition) {
    if (!this.$data)
      return this.fail(condition);
    const { schemaCode } = this;
    this.fail(codegen_1$n._`${schemaCode} !== undefined && (${codegen_1$n.or(this.invalid$data(), condition)})`);
  }
  error(append, errorParams, errorPaths) {
    if (errorParams) {
      this.setParams(errorParams);
      this._error(append, errorPaths);
      this.setParams({});
      return;
    }
    this._error(append, errorPaths);
  }
  _error(append, errorPaths) {
    (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
  }
  $dataError() {
    errors_1.reportError(this, this.def.$dataError || errors_1.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    errors_1.resetErrorsCount(this.gen, this.errsCount);
  }
  ok(cond) {
    if (!this.allErrors)
      this.gen.if(cond);
  }
  setParams(obj, assign) {
    if (assign)
      Object.assign(this.params, obj);
    else
      this.params = obj;
  }
  block$data(valid2, codeBlock, $dataValid = codegen_1$n.nil) {
    this.gen.block(() => {
      this.check$data(valid2, $dataValid);
      codeBlock();
    });
  }
  check$data(valid2 = codegen_1$n.nil, $dataValid = codegen_1$n.nil) {
    if (!this.$data)
      return;
    const { gen, schemaCode, schemaType, def: def2 } = this;
    gen.if(codegen_1$n.or(codegen_1$n._`${schemaCode} === undefined`, $dataValid));
    if (valid2 !== codegen_1$n.nil)
      gen.assign(valid2, true);
    if (schemaType.length || def2.validateSchema) {
      gen.elseIf(this.invalid$data());
      this.$dataError();
      if (valid2 !== codegen_1$n.nil)
        gen.assign(valid2, false);
    }
    gen.else();
  }
  invalid$data() {
    const { gen, schemaCode, schemaType, def: def2, it } = this;
    return codegen_1$n.or(wrong$DataType(), invalid$DataSchema());
    function wrong$DataType() {
      if (schemaType.length) {
        if (!(schemaCode instanceof codegen_1$n.Name))
          throw new Error("ajv implementation error");
        const st = Array.isArray(schemaType) ? schemaType : [schemaType];
        return codegen_1$n._`${dataType_2.checkDataTypes(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
      }
      return codegen_1$n.nil;
    }
    function invalid$DataSchema() {
      if (def2.validateSchema) {
        const validateSchemaRef = gen.scopeValue("validate$data", { ref: def2.validateSchema });
        return codegen_1$n._`!${validateSchemaRef}(${schemaCode})`;
      }
      return codegen_1$n.nil;
    }
  }
  subschema(appl, valid2) {
    const subschema2 = subschema_1.getSubschema(this.it, appl);
    subschema_1.extendSubschemaData(subschema2, this.it, appl);
    subschema_1.extendSubschemaMode(subschema2, appl);
    const nextContext = { ...this.it, ...subschema2, items: void 0, props: void 0 };
    subschemaCode(nextContext, valid2);
    return nextContext;
  }
  mergeEvaluated(schemaCxt, toName) {
    const { it, gen } = this;
    if (!it.opts.unevaluated)
      return;
    if (it.props !== true && schemaCxt.props !== void 0) {
      it.props = util_1$k.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
    }
    if (it.items !== true && schemaCxt.items !== void 0) {
      it.items = util_1$k.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
    }
  }
  mergeValidEvaluated(schemaCxt, valid2) {
    const { it, gen } = this;
    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
      gen.if(valid2, () => this.mergeEvaluated(schemaCxt, codegen_1$n.Name));
      return true;
    }
  }
}
validate.KeywordCxt = KeywordCxt;
function keywordCode(it, keyword2, def2, ruleType) {
  const cxt = new KeywordCxt(it, def2, keyword2);
  if ("code" in def2) {
    def2.code(cxt, ruleType);
  } else if (cxt.$data && def2.validate) {
    keyword_1.funcKeywordCode(cxt, def2);
  } else if ("macro" in def2) {
    keyword_1.macroKeywordCode(cxt, def2);
  } else if (def2.compile || def2.validate) {
    keyword_1.funcKeywordCode(cxt, def2);
  }
}
const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, { dataLevel, dataNames, dataPathArr }) {
  let jsonPointer;
  let data;
  if ($data === "")
    return names_1$3.default.rootData;
  if ($data[0] === "/") {
    if (!JSON_POINTER.test($data))
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    jsonPointer = $data;
    data = names_1$3.default.rootData;
  } else {
    const matches = RELATIVE_JSON_POINTER.exec($data);
    if (!matches)
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    const up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer === "#") {
      if (up >= dataLevel)
        throw new Error(errorMsg("property/index", up));
      return dataPathArr[dataLevel - up];
    }
    if (up > dataLevel)
      throw new Error(errorMsg("data", up));
    data = dataNames[dataLevel - up];
    if (!jsonPointer)
      return data;
  }
  let expr = data;
  const segments = jsonPointer.split("/");
  for (const segment of segments) {
    if (segment) {
      data = codegen_1$n._`${data}${codegen_1$n.getProperty(util_1$k.unescapeJsonPointer(segment))}`;
      expr = codegen_1$n._`${expr} && ${data}`;
    }
  }
  return expr;
  function errorMsg(pointerType, up) {
    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
  }
}
validate.getData = getData;
var validation_error = {};
Object.defineProperty(validation_error, "__esModule", { value: true });
class ValidationError extends Error {
  constructor(errors2) {
    super("validation failed");
    this.errors = errors2;
    this.ajv = this.validation = true;
  }
}
validation_error.default = ValidationError;
var ref_error = {};
Object.defineProperty(ref_error, "__esModule", { value: true });
const resolve_1$1 = resolve$1;
class MissingRefError extends Error {
  constructor(baseId, ref2, msg) {
    super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
    this.missingRef = resolve_1$1.resolveUrl(baseId, ref2);
    this.missingSchema = resolve_1$1.normalizeId(resolve_1$1.getFullPath(this.missingRef));
  }
}
ref_error.default = MissingRefError;
var compile = {};
Object.defineProperty(compile, "__esModule", { value: true });
compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
const codegen_1$m = codegen;
const validation_error_1 = validation_error;
const names_1$2 = names$1;
const resolve_1 = resolve$1;
const util_1$j = util;
const validate_1$1 = validate;
const URI = uri_allExports;
class SchemaEnv {
  constructor(env2) {
    var _a;
    this.refs = {};
    this.dynamicAnchors = {};
    let schema2;
    if (typeof env2.schema == "object")
      schema2 = env2.schema;
    this.schema = env2.schema;
    this.schemaId = env2.schemaId;
    this.root = env2.root || this;
    this.baseId = (_a = env2.baseId) !== null && _a !== void 0 ? _a : resolve_1.normalizeId(schema2 === null || schema2 === void 0 ? void 0 : schema2[env2.schemaId || "$id"]);
    this.schemaPath = env2.schemaPath;
    this.localRefs = env2.localRefs;
    this.meta = env2.meta;
    this.$async = schema2 === null || schema2 === void 0 ? void 0 : schema2.$async;
    this.refs = {};
  }
}
compile.SchemaEnv = SchemaEnv;
function compileSchema(sch) {
  const _sch = getCompilingSchema.call(this, sch);
  if (_sch)
    return _sch;
  const rootId = resolve_1.getFullPath(sch.root.baseId);
  const { es5, lines } = this.opts.code;
  const { ownProperties } = this.opts;
  const gen = new codegen_1$m.CodeGen(this.scope, { es5, lines, ownProperties });
  let _ValidationError;
  if (sch.$async) {
    _ValidationError = gen.scopeValue("Error", {
      ref: validation_error_1.default,
      code: codegen_1$m._`require("ajv/dist/runtime/validation_error").default`
    });
  }
  const validateName = gen.scopeName("validate");
  sch.validateName = validateName;
  const schemaCxt = {
    gen,
    allErrors: this.opts.allErrors,
    data: names_1$2.default.data,
    parentData: names_1$2.default.parentData,
    parentDataProperty: names_1$2.default.parentDataProperty,
    dataNames: [names_1$2.default.data],
    dataPathArr: [codegen_1$m.nil],
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
    topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: codegen_1$m.stringify(sch.schema) } : { ref: sch.schema }),
    validateName,
    ValidationError: _ValidationError,
    schema: sch.schema,
    schemaEnv: sch,
    rootId,
    baseId: sch.baseId || rootId,
    schemaPath: codegen_1$m.nil,
    errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: codegen_1$m._`""`,
    opts: this.opts,
    self: this
  };
  let sourceCode;
  try {
    this._compilations.add(sch);
    validate_1$1.validateFunctionCode(schemaCxt);
    gen.optimize(this.opts.code.optimize);
    const validateCode = gen.toString();
    sourceCode = `${gen.scopeRefs(names_1$2.default.scope)}return ${validateCode}`;
    if (this.opts.code.process)
      sourceCode = this.opts.code.process(sourceCode, sch);
    const makeValidate = new Function(`${names_1$2.default.self}`, `${names_1$2.default.scope}`, sourceCode);
    const validate2 = makeValidate(this, this.scope.get());
    this.scope.value(validateName, { ref: validate2 });
    validate2.errors = null;
    validate2.schema = sch.schema;
    validate2.schemaEnv = sch;
    if (sch.$async)
      validate2.$async = true;
    if (this.opts.code.source === true) {
      validate2.source = { validateName, validateCode, scopeValues: gen._values };
    }
    if (this.opts.unevaluated) {
      const { props, items: items2 } = schemaCxt;
      validate2.evaluated = {
        props: props instanceof codegen_1$m.Name ? void 0 : props,
        items: items2 instanceof codegen_1$m.Name ? void 0 : items2,
        dynamicProps: props instanceof codegen_1$m.Name,
        dynamicItems: items2 instanceof codegen_1$m.Name
      };
      if (validate2.source)
        validate2.source.evaluated = codegen_1$m.stringify(validate2.evaluated);
    }
    sch.validate = validate2;
    return sch;
  } catch (e) {
    delete sch.validate;
    delete sch.validateName;
    if (sourceCode)
      this.logger.error("Error compiling schema, function code:", sourceCode);
    throw e;
  } finally {
    this._compilations.delete(sch);
  }
}
compile.compileSchema = compileSchema;
function resolveRef(root, baseId, ref2) {
  var _a;
  ref2 = resolve_1.resolveUrl(baseId, ref2);
  const schOrFunc = root.refs[ref2];
  if (schOrFunc)
    return schOrFunc;
  let _sch = resolve.call(this, root, ref2);
  if (_sch === void 0) {
    const schema2 = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref2];
    const { schemaId } = this.opts;
    if (schema2)
      _sch = new SchemaEnv({ schema: schema2, schemaId, root, baseId });
  }
  if (_sch === void 0)
    return;
  return root.refs[ref2] = inlineOrCompile.call(this, _sch);
}
compile.resolveRef = resolveRef;
function inlineOrCompile(sch) {
  if (resolve_1.inlineRef(sch.schema, this.opts.inlineRefs))
    return sch.schema;
  return sch.validate ? sch : compileSchema.call(this, sch);
}
function getCompilingSchema(schEnv) {
  for (const sch of this._compilations) {
    if (sameSchemaEnv(sch, schEnv))
      return sch;
  }
}
compile.getCompilingSchema = getCompilingSchema;
function sameSchemaEnv(s1, s2) {
  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
}
function resolve(root, ref2) {
  let sch;
  while (typeof (sch = this.refs[ref2]) == "string")
    ref2 = sch;
  return sch || this.schemas[ref2] || resolveSchema.call(this, root, ref2);
}
function resolveSchema(root, ref2) {
  const p = URI.parse(ref2);
  const refPath = resolve_1._getFullPath(p);
  let baseId = resolve_1.getFullPath(root.baseId);
  if (Object.keys(root.schema).length > 0 && refPath === baseId) {
    return getJsonPointer.call(this, p, root);
  }
  const id2 = resolve_1.normalizeId(refPath);
  const schOrRef = this.refs[id2] || this.schemas[id2];
  if (typeof schOrRef == "string") {
    const sch = resolveSchema.call(this, root, schOrRef);
    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
      return;
    return getJsonPointer.call(this, p, sch);
  }
  if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
    return;
  if (!schOrRef.validate)
    compileSchema.call(this, schOrRef);
  if (id2 === resolve_1.normalizeId(ref2)) {
    const { schema: schema2 } = schOrRef;
    const { schemaId } = this.opts;
    const schId = schema2[schemaId];
    if (schId)
      baseId = resolve_1.resolveUrl(baseId, schId);
    return new SchemaEnv({ schema: schema2, schemaId, root, baseId });
  }
  return getJsonPointer.call(this, p, schOrRef);
}
compile.resolveSchema = resolveSchema;
const PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function getJsonPointer(parsedRef, { baseId, schema: schema2, root }) {
  var _a;
  if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
    return;
  for (const part of parsedRef.fragment.slice(1).split("/")) {
    if (typeof schema2 == "boolean")
      return;
    schema2 = schema2[util_1$j.unescapeFragment(part)];
    if (schema2 === void 0)
      return;
    const schId = typeof schema2 == "object" && schema2[this.opts.schemaId];
    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
      baseId = resolve_1.resolveUrl(baseId, schId);
    }
  }
  let env2;
  if (typeof schema2 != "boolean" && schema2.$ref && !util_1$j.schemaHasRulesButRef(schema2, this.RULES)) {
    const $ref = resolve_1.resolveUrl(baseId, schema2.$ref);
    env2 = resolveSchema.call(this, root, $ref);
  }
  const { schemaId } = this.opts;
  env2 = env2 || new SchemaEnv({ schema: schema2, schemaId, root, baseId });
  if (env2.schema !== env2.root.schema)
    return env2;
  return void 0;
}
const $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
const type$1 = "object";
const required$1 = [
  "$data"
];
const properties$2 = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
};
const additionalProperties$1 = false;
const require$$9 = {
  $id: $id$1,
  description,
  type: type$1,
  required: required$1,
  properties: properties$2,
  additionalProperties: additionalProperties$1
};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
  var validate_12 = validate;
  Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  const validation_error_12 = validation_error;
  const ref_error_12 = ref_error;
  const rules_1 = rules;
  const compile_12 = compile;
  const codegen_2 = codegen;
  const resolve_12 = resolve$1;
  const dataType_12 = dataType;
  const util_12 = util;
  const $dataRefSchema = require$$9;
  const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
  const EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]);
  const removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  };
  const deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  };
  const MAX_EXPRESSION = 200;
  function requiredOptions(o) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
    const s = o.strict;
    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
    const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
    return {
      strictSchema: (_c = (_b = o.strictSchema) !== null && _b !== void 0 ? _b : s) !== null && _c !== void 0 ? _c : true,
      strictNumbers: (_e = (_d = o.strictNumbers) !== null && _d !== void 0 ? _d : s) !== null && _e !== void 0 ? _e : true,
      strictTypes: (_g = (_f = o.strictTypes) !== null && _f !== void 0 ? _f : s) !== null && _g !== void 0 ? _g : "log",
      strictTuples: (_j = (_h = o.strictTuples) !== null && _h !== void 0 ? _h : s) !== null && _j !== void 0 ? _j : "log",
      strictRequired: (_l = (_k = o.strictRequired) !== null && _k !== void 0 ? _k : s) !== null && _l !== void 0 ? _l : false,
      code: o.code ? { ...o.code, optimize } : { optimize },
      loopRequired: (_m = o.loopRequired) !== null && _m !== void 0 ? _m : MAX_EXPRESSION,
      loopEnum: (_o = o.loopEnum) !== null && _o !== void 0 ? _o : MAX_EXPRESSION,
      meta: (_p = o.meta) !== null && _p !== void 0 ? _p : true,
      messages: (_q = o.messages) !== null && _q !== void 0 ? _q : true,
      inlineRefs: (_r = o.inlineRefs) !== null && _r !== void 0 ? _r : true,
      schemaId: (_s = o.schemaId) !== null && _s !== void 0 ? _s : "$id",
      addUsedSchema: (_t = o.addUsedSchema) !== null && _t !== void 0 ? _t : true,
      validateSchema: (_u = o.validateSchema) !== null && _u !== void 0 ? _u : true,
      validateFormats: (_v = o.validateFormats) !== null && _v !== void 0 ? _v : true,
      unicodeRegExp: (_w = o.unicodeRegExp) !== null && _w !== void 0 ? _w : true,
      int32range: (_x = o.int32range) !== null && _x !== void 0 ? _x : true
    };
  }
  class Ajv {
    constructor(opts2 = {}) {
      this.schemas = {};
      this.refs = {};
      this.formats = {};
      this._compilations = /* @__PURE__ */ new Set();
      this._loading = {};
      this._cache = /* @__PURE__ */ new Map();
      opts2 = this.opts = { ...opts2, ...requiredOptions(opts2) };
      const { es5, lines } = this.opts.code;
      this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
      this.logger = getLogger(opts2.logger);
      const formatOpt = opts2.validateFormats;
      opts2.validateFormats = false;
      this.RULES = rules_1.getRules();
      checkOptions.call(this, removedOptions, opts2, "NOT SUPPORTED");
      checkOptions.call(this, deprecatedOptions, opts2, "DEPRECATED", "warn");
      this._metaOpts = getMetaSchemaOptions.call(this);
      if (opts2.formats)
        addInitialFormats.call(this);
      this._addVocabularies();
      this._addDefaultMetaSchema();
      if (opts2.keywords)
        addInitialKeywords.call(this, opts2.keywords);
      if (typeof opts2.meta == "object")
        this.addMetaSchema(opts2.meta);
      addInitialSchemas.call(this);
      opts2.validateFormats = formatOpt;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data, meta, schemaId } = this.opts;
      let _dataRefSchema = $dataRefSchema;
      if (schemaId === "id") {
        _dataRefSchema = { ...$dataRefSchema };
        _dataRefSchema.id = _dataRefSchema.$id;
        delete _dataRefSchema.$id;
      }
      if (meta && $data)
        this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
      const { meta, schemaId } = this.opts;
      return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
    }
    validate(schemaKeyRef, data) {
      let v;
      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v)
          throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
      } else {
        v = this.compile(schemaKeyRef);
      }
      const valid2 = v(data);
      if (!("$async" in v))
        this.errors = v.errors;
      return valid2;
    }
    compile(schema2, _meta) {
      const sch = this._addSchema(schema2, _meta);
      return sch.validate || this._compileSchemaEnv(sch);
    }
    compileAsync(schema2, meta) {
      if (typeof this.opts.loadSchema != "function") {
        throw new Error("options.loadSchema should be a function");
      }
      const { loadSchema } = this.opts;
      return runCompileAsync.call(this, schema2, meta);
      async function runCompileAsync(_schema, _meta) {
        await loadMetaSchema.call(this, _schema.$schema);
        const sch = this._addSchema(_schema, _meta);
        return sch.validate || _compileAsync.call(this, sch);
      }
      async function loadMetaSchema($ref) {
        if ($ref && !this.getSchema($ref)) {
          await runCompileAsync.call(this, { $ref }, true);
        }
      }
      async function _compileAsync(sch) {
        try {
          return this._compileSchemaEnv(sch);
        } catch (e) {
          if (!(e instanceof ref_error_12.default))
            throw e;
          checkLoaded.call(this, e);
          await loadMissingSchema.call(this, e.missingSchema);
          return _compileAsync.call(this, sch);
        }
      }
      function checkLoaded({ missingSchema: ref2, missingRef }) {
        if (this.refs[ref2]) {
          throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
        }
      }
      async function loadMissingSchema(ref2) {
        const _schema = await _loadSchema.call(this, ref2);
        if (!this.refs[ref2])
          await loadMetaSchema.call(this, _schema.$schema);
        if (!this.refs[ref2])
          this.addSchema(_schema, ref2, meta);
      }
      async function _loadSchema(ref2) {
        const p = this._loading[ref2];
        if (p)
          return p;
        try {
          return await (this._loading[ref2] = loadSchema(ref2));
        } finally {
          delete this._loading[ref2];
        }
      }
    }
    // Adds schema to the instance
    addSchema(schema2, key, _meta, _validateSchema = this.opts.validateSchema) {
      if (Array.isArray(schema2)) {
        for (const sch of schema2)
          this.addSchema(sch, void 0, _meta, _validateSchema);
        return this;
      }
      let id2;
      if (typeof schema2 === "object") {
        const { schemaId } = this.opts;
        id2 = schema2[schemaId];
        if (id2 !== void 0 && typeof id2 != "string") {
          throw new Error(`schema ${schemaId} must be string`);
        }
      }
      key = resolve_12.normalizeId(key || id2);
      this._checkUnique(key);
      this.schemas[key] = this._addSchema(schema2, _meta, key, _validateSchema, true);
      return this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(schema2, key, _validateSchema = this.opts.validateSchema) {
      this.addSchema(schema2, key, true, _validateSchema);
      return this;
    }
    //  Validate schema against its meta-schema
    validateSchema(schema2, throwOrLogError) {
      if (typeof schema2 == "boolean")
        return true;
      let $schema2;
      $schema2 = schema2.$schema;
      if ($schema2 !== void 0 && typeof $schema2 != "string") {
        throw new Error("$schema must be a string");
      }
      $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
      if (!$schema2) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      const valid2 = this.validate($schema2, schema2);
      if (!valid2 && throwOrLogError) {
        const message = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid2;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(keyRef) {
      let sch;
      while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
        keyRef = sch;
      if (sch === void 0) {
        const { schemaId } = this.opts;
        const root = new compile_12.SchemaEnv({ schema: {}, schemaId });
        sch = compile_12.resolveSchema.call(this, root, keyRef);
        if (!sch)
          return;
        this.refs[keyRef] = sch;
      }
      return sch.validate || this._compileSchemaEnv(sch);
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        this._removeAllSchemas(this.schemas, schemaKeyRef);
        this._removeAllSchemas(this.refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          this._removeAllSchemas(this.schemas);
          this._removeAllSchemas(this.refs);
          this._cache.clear();
          return this;
        case "string": {
          const sch = getSchEnv.call(this, schemaKeyRef);
          if (typeof sch == "object")
            this._cache.delete(sch.schema);
          delete this.schemas[schemaKeyRef];
          delete this.refs[schemaKeyRef];
          return this;
        }
        case "object": {
          const cacheKey = schemaKeyRef;
          this._cache.delete(cacheKey);
          let id2 = schemaKeyRef[this.opts.schemaId];
          if (id2) {
            id2 = resolve_12.normalizeId(id2);
            delete this.schemas[id2];
            delete this.refs[id2];
          }
          return this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(definitions2) {
      for (const def2 of definitions2)
        this.addKeyword(def2);
      return this;
    }
    addKeyword(kwdOrDef, def2) {
      let keyword2;
      if (typeof kwdOrDef == "string") {
        keyword2 = kwdOrDef;
        if (typeof def2 == "object") {
          this.logger.warn("these parameters are deprecated, see docs for addKeyword");
          def2.keyword = keyword2;
        }
      } else if (typeof kwdOrDef == "object" && def2 === void 0) {
        def2 = kwdOrDef;
        keyword2 = def2.keyword;
        if (Array.isArray(keyword2) && !keyword2.length) {
          throw new Error("addKeywords: keyword must be string or non-empty array");
        }
      } else {
        throw new Error("invalid addKeywords parameters");
      }
      checkKeyword.call(this, keyword2, def2);
      if (!def2) {
        util_12.eachItem(keyword2, (kwd) => addRule.call(this, kwd));
        return this;
      }
      keywordMetaschema.call(this, def2);
      const definition = {
        ...def2,
        type: dataType_12.getJSONTypes(def2.type),
        schemaType: dataType_12.getJSONTypes(def2.schemaType)
      };
      util_12.eachItem(keyword2, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t2) => addRule.call(this, k, definition, t2)));
      return this;
    }
    getKeyword(keyword2) {
      const rule = this.RULES.all[keyword2];
      return typeof rule == "object" ? rule.definition : !!rule;
    }
    // Remove keyword
    removeKeyword(keyword2) {
      const { RULES } = this;
      delete RULES.keywords[keyword2];
      delete RULES.all[keyword2];
      for (const group of RULES.rules) {
        const i = group.rules.findIndex((rule) => rule.keyword === keyword2);
        if (i >= 0)
          group.rules.splice(i, 1);
      }
      return this;
    }
    // Add format
    addFormat(name, format2) {
      if (typeof format2 == "string")
        format2 = new RegExp(format2);
      this.formats[name] = format2;
      return this;
    }
    errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
      if (!errors2 || errors2.length === 0)
        return "No errors";
      return errors2.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
      const rules2 = this.RULES.all;
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      for (const jsonPointer of keywordsJsonPointers) {
        const segments = jsonPointer.split("/").slice(1);
        let keywords = metaSchema;
        for (const seg of segments)
          keywords = keywords[seg];
        for (const key in rules2) {
          const rule = rules2[key];
          if (typeof rule != "object")
            continue;
          const { $data } = rule.definition;
          const schema2 = keywords[key];
          if ($data && schema2)
            keywords[key] = schemaOrData(schema2);
        }
      }
      return metaSchema;
    }
    _removeAllSchemas(schemas, regex) {
      for (const keyRef in schemas) {
        const sch = schemas[keyRef];
        if (!regex || regex.test(keyRef)) {
          if (typeof sch == "string") {
            delete schemas[keyRef];
          } else if (sch && !sch.meta) {
            this._cache.delete(sch.schema);
            delete schemas[keyRef];
          }
        }
      }
    }
    _addSchema(schema2, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
      let id2;
      const { schemaId } = this.opts;
      if (typeof schema2 == "object") {
        id2 = schema2[schemaId];
      } else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        else if (typeof schema2 != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let sch = this._cache.get(schema2);
      if (sch !== void 0)
        return sch;
      const localRefs = resolve_12.getSchemaRefs.call(this, schema2);
      baseId = resolve_12.normalizeId(id2 || baseId);
      sch = new compile_12.SchemaEnv({ schema: schema2, schemaId, meta, baseId, localRefs });
      this._cache.set(sch.schema, sch);
      if (addSchema && !baseId.startsWith("#")) {
        if (baseId)
          this._checkUnique(baseId);
        this.refs[baseId] = sch;
      }
      if (validateSchema)
        this.validateSchema(schema2, true);
      return sch;
    }
    _checkUnique(id2) {
      if (this.schemas[id2] || this.refs[id2]) {
        throw new Error(`schema with key or id "${id2}" already exists`);
      }
    }
    _compileSchemaEnv(sch) {
      if (sch.meta)
        this._compileMetaSchema(sch);
      else
        compile_12.compileSchema.call(this, sch);
      if (!sch.validate)
        throw new Error("ajv implementation error");
      return sch.validate;
    }
    _compileMetaSchema(sch) {
      const currentOpts = this.opts;
      this.opts = this._metaOpts;
      try {
        compile_12.compileSchema.call(this, sch);
      } finally {
        this.opts = currentOpts;
      }
    }
  }
  exports2.default = Ajv;
  Ajv.ValidationError = validation_error_12.default;
  Ajv.MissingRefError = ref_error_12.default;
  function checkOptions(checkOpts, options, msg, log = "error") {
    for (const key in checkOpts) {
      const opt = key;
      if (opt in options)
        this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
    }
  }
  function getSchEnv(keyRef) {
    keyRef = resolve_12.normalizeId(keyRef);
    return this.schemas[keyRef] || this.refs[keyRef];
  }
  function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
      return;
    if (Array.isArray(optsSchemas))
      this.addSchema(optsSchemas);
    else
      for (const key in optsSchemas)
        this.addSchema(optsSchemas[key], key);
  }
  function addInitialFormats() {
    for (const name in this.opts.formats) {
      const format2 = this.opts.formats[name];
      if (format2)
        this.addFormat(name, format2);
    }
  }
  function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
      this.addVocabulary(defs);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword2 in defs) {
      const def2 = defs[keyword2];
      if (!def2.keyword)
        def2.keyword = keyword2;
      this.addKeyword(def2);
    }
  }
  function getMetaSchemaOptions() {
    const metaOpts = { ...this.opts };
    for (const opt of META_IGNORE_OPTIONS)
      delete metaOpts[opt];
    return metaOpts;
  }
  const noLogs = { log() {
  }, warn() {
  }, error() {
  } };
  function getLogger(logger) {
    if (logger === false)
      return noLogs;
    if (logger === void 0)
      return console;
    if (logger.log && logger.warn && logger.error)
      return logger;
    throw new Error("logger must implement log, warn and error methods");
  }
  const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
  function checkKeyword(keyword2, def2) {
    const { RULES } = this;
    util_12.eachItem(keyword2, (kwd) => {
      if (RULES.keywords[kwd])
        throw new Error(`Keyword ${kwd} is already defined`);
      if (!KEYWORD_NAME.test(kwd))
        throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def2)
      return;
    if (def2.$data && !("code" in def2 || "validate" in def2)) {
      throw new Error('$data keyword must have "code" or "validate" function');
    }
  }
  function addRule(keyword2, definition, dataType2) {
    var _a;
    const post = definition === null || definition === void 0 ? void 0 : definition.post;
    if (dataType2 && post)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t2 }) => t2 === dataType2);
    if (!ruleGroup) {
      ruleGroup = { type: dataType2, rules: [] };
      RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword2] = true;
    if (!definition)
      return;
    const rule = {
      keyword: keyword2,
      definition: {
        ...definition,
        type: dataType_12.getJSONTypes(definition.type),
        schemaType: dataType_12.getJSONTypes(definition.schemaType)
      }
    };
    if (definition.before)
      addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
      ruleGroup.rules.push(rule);
    RULES.all[keyword2] = rule;
    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
  }
  function addBeforeRule(ruleGroup, rule, before) {
    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i >= 0) {
      ruleGroup.rules.splice(i, 0, rule);
    } else {
      ruleGroup.rules.push(rule);
      this.logger.warn(`rule ${before} is not defined`);
    }
  }
  function keywordMetaschema(def2) {
    let { metaSchema } = def2;
    if (metaSchema === void 0)
      return;
    if (def2.$data && this.opts.$data)
      metaSchema = schemaOrData(metaSchema);
    def2.validateSchema = this.compile(metaSchema, true);
  }
  const $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function schemaOrData(schema2) {
    return { anyOf: [schema2, $dataRef] };
  }
})(core$2);
var draft7 = {};
var core$1 = {};
var id = {};
Object.defineProperty(id, "__esModule", { value: true });
const def$s = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
id.default = def$s;
var ref = {};
Object.defineProperty(ref, "__esModule", { value: true });
ref.callRef = ref.getValidate = void 0;
const ref_error_1 = ref_error;
const code_1$8 = code;
const codegen_1$l = codegen;
const names_1$1 = names$1;
const compile_1 = compile;
const util_1$i = util;
const def$r = {
  keyword: "$ref",
  schemaType: "string",
  code(cxt) {
    const { gen, schema: $ref, it } = cxt;
    const { baseId, schemaEnv: env2, validateName, opts: opts2, self: self2 } = it;
    const { root } = env2;
    if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
      return callRootRef();
    const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
    if (schOrEnv === void 0)
      throw new ref_error_1.default(baseId, $ref);
    if (schOrEnv instanceof compile_1.SchemaEnv)
      return callValidate(schOrEnv);
    return inlineRefSchema(schOrEnv);
    function callRootRef() {
      if (env2 === root)
        return callRef(cxt, validateName, env2, env2.$async);
      const rootName = gen.scopeValue("root", { ref: root });
      return callRef(cxt, codegen_1$l._`${rootName}.validate`, root, root.$async);
    }
    function callValidate(sch) {
      const v = getValidate(cxt, sch);
      callRef(cxt, v, sch, sch.$async);
    }
    function inlineRefSchema(sch) {
      const schName = gen.scopeValue("schema", opts2.code.source === true ? { ref: sch, code: codegen_1$l.stringify(sch) } : { ref: sch });
      const valid2 = gen.name("valid");
      const schCxt = cxt.subschema({
        schema: sch,
        dataTypes: [],
        schemaPath: codegen_1$l.nil,
        topSchemaRef: schName,
        errSchemaPath: $ref
      }, valid2);
      cxt.mergeEvaluated(schCxt);
      cxt.ok(valid2);
    }
  }
};
function getValidate(cxt, sch) {
  const { gen } = cxt;
  return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : codegen_1$l._`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
}
ref.getValidate = getValidate;
function callRef(cxt, v, sch, $async) {
  const { gen, it } = cxt;
  const { allErrors, schemaEnv: env2, opts: opts2 } = it;
  const passCxt = opts2.passContext ? names_1$1.default.this : codegen_1$l.nil;
  if ($async)
    callAsyncRef();
  else
    callSyncRef();
  function callAsyncRef() {
    if (!env2.$async)
      throw new Error("async schema referenced by sync schema");
    const valid2 = gen.let("valid");
    gen.try(() => {
      gen.code(codegen_1$l._`await ${code_1$8.callValidateCode(cxt, v, passCxt)}`);
      addEvaluatedFrom(v);
      if (!allErrors)
        gen.assign(valid2, true);
    }, (e) => {
      gen.if(codegen_1$l._`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
      addErrorsFrom(e);
      if (!allErrors)
        gen.assign(valid2, false);
    });
    cxt.ok(valid2);
  }
  function callSyncRef() {
    cxt.result(code_1$8.callValidateCode(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
  }
  function addErrorsFrom(source2) {
    const errs = codegen_1$l._`${source2}.errors`;
    gen.assign(names_1$1.default.vErrors, codegen_1$l._`${names_1$1.default.vErrors} === null ? ${errs} : ${names_1$1.default.vErrors}.concat(${errs})`);
    gen.assign(names_1$1.default.errors, codegen_1$l._`${names_1$1.default.vErrors}.length`);
  }
  function addEvaluatedFrom(source2) {
    var _a;
    if (!it.opts.unevaluated)
      return;
    const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
    if (it.props !== true) {
      if (schEvaluated && !schEvaluated.dynamicProps) {
        if (schEvaluated.props !== void 0) {
          it.props = util_1$i.mergeEvaluated.props(gen, schEvaluated.props, it.props);
        }
      } else {
        const props = gen.var("props", codegen_1$l._`${source2}.evaluated.props`);
        it.props = util_1$i.mergeEvaluated.props(gen, props, it.props, codegen_1$l.Name);
      }
    }
    if (it.items !== true) {
      if (schEvaluated && !schEvaluated.dynamicItems) {
        if (schEvaluated.items !== void 0) {
          it.items = util_1$i.mergeEvaluated.items(gen, schEvaluated.items, it.items);
        }
      } else {
        const items2 = gen.var("items", codegen_1$l._`${source2}.evaluated.items`);
        it.items = util_1$i.mergeEvaluated.items(gen, items2, it.items, codegen_1$l.Name);
      }
    }
  }
}
ref.callRef = callRef;
ref.default = def$r;
Object.defineProperty(core$1, "__esModule", { value: true });
const id_1 = id;
const ref_1 = ref;
const core = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  id_1.default,
  ref_1.default
];
core$1.default = core;
var validation$1 = {};
var limitNumber = {};
Object.defineProperty(limitNumber, "__esModule", { value: true });
const codegen_1$k = codegen;
const ops = codegen_1$k.operators;
const KWDs = {
  maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
  minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
  exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
  exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
};
const error$i = {
  message: ({ keyword: keyword2, schemaCode }) => codegen_1$k.str`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
  params: ({ keyword: keyword2, schemaCode }) => codegen_1$k._`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
};
const def$q = {
  keyword: Object.keys(KWDs),
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$i,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    cxt.fail$data(codegen_1$k._`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
  }
};
limitNumber.default = def$q;
var multipleOf = {};
Object.defineProperty(multipleOf, "__esModule", { value: true });
const codegen_1$j = codegen;
const error$h = {
  message: ({ schemaCode }) => codegen_1$j.str`must be multiple of ${schemaCode}`,
  params: ({ schemaCode }) => codegen_1$j._`{multipleOf: ${schemaCode}}`
};
const def$p = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$h,
  code(cxt) {
    const { gen, data, schemaCode, it } = cxt;
    const prec = it.opts.multipleOfPrecision;
    const res = gen.let("res");
    const invalid = prec ? codegen_1$j._`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : codegen_1$j._`${res} !== parseInt(${res})`;
    cxt.fail$data(codegen_1$j._`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
  }
};
multipleOf.default = def$p;
var limitLength = {};
var ucs2length$1 = {};
Object.defineProperty(ucs2length$1, "__esModule", { value: true });
function ucs2length(str) {
  const len = str.length;
  let length = 0;
  let pos = 0;
  let value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 55296 && value <= 56319 && pos < len) {
      value = str.charCodeAt(pos);
      if ((value & 64512) === 56320)
        pos++;
    }
  }
  return length;
}
ucs2length$1.default = ucs2length;
ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(limitLength, "__esModule", { value: true });
const codegen_1$i = codegen;
const util_1$h = util;
const ucs2length_1 = ucs2length$1;
const error$g = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxLength" ? "more" : "fewer";
    return codegen_1$i.str`must NOT have ${comp} than ${schemaCode} characters`;
  },
  params: ({ schemaCode }) => codegen_1$i._`{limit: ${schemaCode}}`
};
const def$o = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: true,
  error: error$g,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode, it } = cxt;
    const op = keyword2 === "maxLength" ? codegen_1$i.operators.GT : codegen_1$i.operators.LT;
    const len = it.opts.unicode === false ? codegen_1$i._`${data}.length` : codegen_1$i._`${util_1$h.useFunc(cxt.gen, ucs2length_1.default)}(${data})`;
    cxt.fail$data(codegen_1$i._`${len} ${op} ${schemaCode}`);
  }
};
limitLength.default = def$o;
var pattern = {};
Object.defineProperty(pattern, "__esModule", { value: true });
const code_1$7 = code;
const codegen_1$h = codegen;
const error$f = {
  message: ({ schemaCode }) => codegen_1$h.str`must match pattern "${schemaCode}"`,
  params: ({ schemaCode }) => codegen_1$h._`{pattern: ${schemaCode}}`
};
const def$n = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: true,
  error: error$f,
  code(cxt) {
    const { data, $data, schema: schema2, schemaCode, it } = cxt;
    const u2 = it.opts.unicodeRegExp ? "u" : "";
    const regExp = $data ? codegen_1$h._`(new RegExp(${schemaCode}, ${u2}))` : code_1$7.usePattern(cxt, schema2);
    cxt.fail$data(codegen_1$h._`!${regExp}.test(${data})`);
  }
};
pattern.default = def$n;
var limitProperties = {};
Object.defineProperty(limitProperties, "__esModule", { value: true });
const codegen_1$g = codegen;
const error$e = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxProperties" ? "more" : "fewer";
    return codegen_1$g.str`must NOT have ${comp} than ${schemaCode} items`;
  },
  params: ({ schemaCode }) => codegen_1$g._`{limit: ${schemaCode}}`
};
const def$m = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: true,
  error: error$e,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxProperties" ? codegen_1$g.operators.GT : codegen_1$g.operators.LT;
    cxt.fail$data(codegen_1$g._`Object.keys(${data}).length ${op} ${schemaCode}`);
  }
};
limitProperties.default = def$m;
var required = {};
Object.defineProperty(required, "__esModule", { value: true });
const code_1$6 = code;
const codegen_1$f = codegen;
const util_1$g = util;
const error$d = {
  message: ({ params: { missingProperty } }) => codegen_1$f.str`must have required property '${missingProperty}'`,
  params: ({ params: { missingProperty } }) => codegen_1$f._`{missingProperty: ${missingProperty}}`
};
const def$l = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: true,
  error: error$d,
  code(cxt) {
    const { gen, schema: schema2, schemaCode, data, $data, it } = cxt;
    const { opts: opts2 } = it;
    if (!$data && schema2.length === 0)
      return;
    const useLoop = schema2.length >= opts2.loopRequired;
    if (it.allErrors)
      allErrorsMode();
    else
      exitOnErrorMode();
    if (opts2.strictRequired) {
      const props = cxt.parentSchema.properties;
      const { definedProperties } = cxt.it;
      for (const requiredKey of schema2) {
        if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
          const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
          util_1$g.checkStrictMode(it, msg, it.opts.strictRequired);
        }
      }
    }
    function allErrorsMode() {
      if (useLoop || $data) {
        cxt.block$data(codegen_1$f.nil, loopAllRequired);
      } else {
        for (const prop of schema2) {
          code_1$6.checkReportMissingProp(cxt, prop);
        }
      }
    }
    function exitOnErrorMode() {
      const missing = gen.let("missing");
      if (useLoop || $data) {
        const valid2 = gen.let("valid", true);
        cxt.block$data(valid2, () => loopUntilMissing(missing, valid2));
        cxt.ok(valid2);
      } else {
        gen.if(code_1$6.checkMissingProp(cxt, schema2, missing));
        code_1$6.reportMissingProp(cxt, missing);
        gen.else();
      }
    }
    function loopAllRequired() {
      gen.forOf("prop", schemaCode, (prop) => {
        cxt.setParams({ missingProperty: prop });
        gen.if(code_1$6.noPropertyInData(gen, data, prop, opts2.ownProperties), () => cxt.error());
      });
    }
    function loopUntilMissing(missing, valid2) {
      cxt.setParams({ missingProperty: missing });
      gen.forOf(missing, schemaCode, () => {
        gen.assign(valid2, code_1$6.propertyInData(gen, data, missing, opts2.ownProperties));
        gen.if(codegen_1$f.not(valid2), () => {
          cxt.error();
          gen.break();
        });
      }, codegen_1$f.nil);
    }
  }
};
required.default = def$l;
var limitItems = {};
Object.defineProperty(limitItems, "__esModule", { value: true });
const codegen_1$e = codegen;
const error$c = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxItems" ? "more" : "fewer";
    return codegen_1$e.str`must NOT have ${comp} than ${schemaCode} items`;
  },
  params: ({ schemaCode }) => codegen_1$e._`{limit: ${schemaCode}}`
};
const def$k = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: true,
  error: error$c,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxItems" ? codegen_1$e.operators.GT : codegen_1$e.operators.LT;
    cxt.fail$data(codegen_1$e._`${data}.length ${op} ${schemaCode}`);
  }
};
limitItems.default = def$k;
var uniqueItems = {};
var equal$1 = {};
Object.defineProperty(equal$1, "__esModule", { value: true });
const equal2 = fastDeepEqual;
equal2.code = 'require("ajv/dist/runtime/equal").default';
equal$1.default = equal2;
Object.defineProperty(uniqueItems, "__esModule", { value: true });
const dataType_1 = dataType;
const codegen_1$d = codegen;
const util_1$f = util;
const equal_1$2 = equal$1;
const error$b = {
  message: ({ params: { i, j } }) => codegen_1$d.str`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
  params: ({ params: { i, j } }) => codegen_1$d._`{i: ${i}, j: ${j}}`
};
const def$j = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: true,
  error: error$b,
  code(cxt) {
    const { gen, data, $data, schema: schema2, parentSchema, schemaCode, it } = cxt;
    if (!$data && !schema2)
      return;
    const valid2 = gen.let("valid");
    const itemTypes = parentSchema.items ? dataType_1.getSchemaTypes(parentSchema.items) : [];
    cxt.block$data(valid2, validateUniqueItems, codegen_1$d._`${schemaCode} === false`);
    cxt.ok(valid2);
    function validateUniqueItems() {
      const i = gen.let("i", codegen_1$d._`${data}.length`);
      const j = gen.let("j");
      cxt.setParams({ i, j });
      gen.assign(valid2, true);
      gen.if(codegen_1$d._`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
    }
    function canOptimize() {
      return itemTypes.length > 0 && !itemTypes.some((t2) => t2 === "object" || t2 === "array");
    }
    function loopN(i, j) {
      const item = gen.name("item");
      const wrongType = dataType_1.checkDataTypes(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
      const indices = gen.const("indices", codegen_1$d._`{}`);
      gen.for(codegen_1$d._`;${i}--;`, () => {
        gen.let(item, codegen_1$d._`${data}[${i}]`);
        gen.if(wrongType, codegen_1$d._`continue`);
        if (itemTypes.length > 1)
          gen.if(codegen_1$d._`typeof ${item} == "string"`, codegen_1$d._`${item} += "_"`);
        gen.if(codegen_1$d._`typeof ${indices}[${item}] == "number"`, () => {
          gen.assign(j, codegen_1$d._`${indices}[${item}]`);
          cxt.error();
          gen.assign(valid2, false).break();
        }).code(codegen_1$d._`${indices}[${item}] = ${i}`);
      });
    }
    function loopN2(i, j) {
      const eql = util_1$f.useFunc(gen, equal_1$2.default);
      const outer = gen.name("outer");
      gen.label(outer).for(codegen_1$d._`;${i}--;`, () => gen.for(codegen_1$d._`${j} = ${i}; ${j}--;`, () => gen.if(codegen_1$d._`${eql}(${data}[${i}], ${data}[${j}])`, () => {
        cxt.error();
        gen.assign(valid2, false).break(outer);
      })));
    }
  }
};
uniqueItems.default = def$j;
var _const = {};
Object.defineProperty(_const, "__esModule", { value: true });
const codegen_1$c = codegen;
const util_1$e = util;
const equal_1$1 = equal$1;
const error$a = {
  message: "must be equal to constant",
  params: ({ schemaCode }) => codegen_1$c._`{allowedValue: ${schemaCode}}`
};
const def$i = {
  keyword: "const",
  $data: true,
  error: error$a,
  code(cxt) {
    const { gen, data, $data, schemaCode, schema: schema2 } = cxt;
    if ($data || schema2 && typeof schema2 == "object") {
      cxt.fail$data(codegen_1$c._`!${util_1$e.useFunc(gen, equal_1$1.default)}(${data}, ${schemaCode})`);
    } else {
      cxt.fail(codegen_1$c._`${schema2} !== ${data}`);
    }
  }
};
_const.default = def$i;
var _enum = {};
Object.defineProperty(_enum, "__esModule", { value: true });
const codegen_1$b = codegen;
const util_1$d = util;
const equal_1 = equal$1;
const error$9 = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode }) => codegen_1$b._`{allowedValues: ${schemaCode}}`
};
const def$h = {
  keyword: "enum",
  schemaType: "array",
  $data: true,
  error: error$9,
  code(cxt) {
    const { gen, data, $data, schema: schema2, schemaCode, it } = cxt;
    if (!$data && schema2.length === 0)
      throw new Error("enum must have non-empty array");
    const useLoop = schema2.length >= it.opts.loopEnum;
    const eql = util_1$d.useFunc(gen, equal_1.default);
    let valid2;
    if (useLoop || $data) {
      valid2 = gen.let("valid");
      cxt.block$data(valid2, loopEnum);
    } else {
      if (!Array.isArray(schema2))
        throw new Error("ajv implementation error");
      const vSchema = gen.const("vSchema", schemaCode);
      valid2 = codegen_1$b.or(...schema2.map((_x, i) => equalCode(vSchema, i)));
    }
    cxt.pass(valid2);
    function loopEnum() {
      gen.assign(valid2, false);
      gen.forOf("v", schemaCode, (v) => gen.if(codegen_1$b._`${eql}(${data}, ${v})`, () => gen.assign(valid2, true).break()));
    }
    function equalCode(vSchema, i) {
      const sch = schema2[i];
      return typeof sch === "object" && sch !== null ? codegen_1$b._`${eql}(${data}, ${vSchema}[${i}])` : codegen_1$b._`${data} === ${sch}`;
    }
  }
};
_enum.default = def$h;
Object.defineProperty(validation$1, "__esModule", { value: true });
const limitNumber_1 = limitNumber;
const multipleOf_1 = multipleOf;
const limitLength_1 = limitLength;
const pattern_1 = pattern;
const limitProperties_1 = limitProperties;
const required_1 = required;
const limitItems_1 = limitItems;
const uniqueItems_1 = uniqueItems;
const const_1 = _const;
const enum_1 = _enum;
const validation = [
  // number
  limitNumber_1.default,
  multipleOf_1.default,
  // string
  limitLength_1.default,
  pattern_1.default,
  // object
  limitProperties_1.default,
  required_1.default,
  // array
  limitItems_1.default,
  uniqueItems_1.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  const_1.default,
  enum_1.default
];
validation$1.default = validation;
var applicator = {};
var additionalItems = {};
Object.defineProperty(additionalItems, "__esModule", { value: true });
additionalItems.validateAdditionalItems = void 0;
const codegen_1$a = codegen;
const util_1$c = util;
const error$8 = {
  message: ({ params: { len } }) => codegen_1$a.str`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => codegen_1$a._`{limit: ${len}}`
};
const def$g = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: error$8,
  code(cxt) {
    const { parentSchema, it } = cxt;
    const { items: items2 } = parentSchema;
    if (!Array.isArray(items2)) {
      util_1$c.checkStrictMode(it, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    validateAdditionalItems(cxt, items2);
  }
};
function validateAdditionalItems(cxt, items2) {
  const { gen, schema: schema2, data, keyword: keyword2, it } = cxt;
  it.items = true;
  const len = gen.const("len", codegen_1$a._`${data}.length`);
  if (schema2 === false) {
    cxt.setParams({ len: items2.length });
    cxt.pass(codegen_1$a._`${len} <= ${items2.length}`);
  } else if (typeof schema2 == "object" && !util_1$c.alwaysValidSchema(it, schema2)) {
    const valid2 = gen.var("valid", codegen_1$a._`${len} <= ${items2.length}`);
    gen.if(codegen_1$a.not(valid2), () => validateItems(valid2));
    cxt.ok(valid2);
  }
  function validateItems(valid2) {
    gen.forRange("i", items2.length, len, (i) => {
      cxt.subschema({ keyword: keyword2, dataProp: i, dataPropType: util_1$c.Type.Num }, valid2);
      if (!it.allErrors)
        gen.if(codegen_1$a.not(valid2), () => gen.break());
    });
  }
}
additionalItems.validateAdditionalItems = validateAdditionalItems;
additionalItems.default = def$g;
var prefixItems = {};
var items = {};
Object.defineProperty(items, "__esModule", { value: true });
items.validateTuple = void 0;
const codegen_1$9 = codegen;
const util_1$b = util;
const code_1$5 = code;
const def$f = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(cxt) {
    const { schema: schema2, it } = cxt;
    if (Array.isArray(schema2))
      return validateTuple(cxt, "additionalItems", schema2);
    it.items = true;
    if (util_1$b.alwaysValidSchema(it, schema2))
      return;
    cxt.ok(code_1$5.validateArray(cxt));
  }
};
function validateTuple(cxt, extraItems, schArr = cxt.schema) {
  const { gen, parentSchema, data, keyword: keyword2, it } = cxt;
  checkStrictTuple(parentSchema);
  if (it.opts.unevaluated && schArr.length && it.items !== true) {
    it.items = util_1$b.mergeEvaluated.items(gen, schArr.length, it.items);
  }
  const valid2 = gen.name("valid");
  const len = gen.const("len", codegen_1$9._`${data}.length`);
  schArr.forEach((sch, i) => {
    if (util_1$b.alwaysValidSchema(it, sch))
      return;
    gen.if(codegen_1$9._`${len} > ${i}`, () => cxt.subschema({
      keyword: keyword2,
      schemaProp: i,
      dataProp: i
    }, valid2));
    cxt.ok(valid2);
  });
  function checkStrictTuple(sch) {
    const { opts: opts2, errSchemaPath } = it;
    const l = schArr.length;
    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
    if (opts2.strictTuples && !fullTuple) {
      const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
      util_1$b.checkStrictMode(it, msg, opts2.strictTuples);
    }
  }
}
items.validateTuple = validateTuple;
items.default = def$f;
Object.defineProperty(prefixItems, "__esModule", { value: true });
const items_1$1 = items;
const def$e = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (cxt) => items_1$1.validateTuple(cxt, "items")
};
prefixItems.default = def$e;
var items2020 = {};
Object.defineProperty(items2020, "__esModule", { value: true });
const codegen_1$8 = codegen;
const util_1$a = util;
const code_1$4 = code;
const additionalItems_1$1 = additionalItems;
const error$7 = {
  message: ({ params: { len } }) => codegen_1$8.str`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => codegen_1$8._`{limit: ${len}}`
};
const def$d = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: error$7,
  code(cxt) {
    const { schema: schema2, parentSchema, it } = cxt;
    const { prefixItems: prefixItems2 } = parentSchema;
    it.items = true;
    if (util_1$a.alwaysValidSchema(it, schema2))
      return;
    if (prefixItems2)
      additionalItems_1$1.validateAdditionalItems(cxt, prefixItems2);
    else
      cxt.ok(code_1$4.validateArray(cxt));
  }
};
items2020.default = def$d;
var contains = {};
Object.defineProperty(contains, "__esModule", { value: true });
const codegen_1$7 = codegen;
const util_1$9 = util;
const error$6 = {
  message: ({ params: { min, max } }) => max === void 0 ? codegen_1$7.str`must contain at least ${min} valid item(s)` : codegen_1$7.str`must contain at least ${min} and no more than ${max} valid item(s)`,
  params: ({ params: { min, max } }) => max === void 0 ? codegen_1$7._`{minContains: ${min}}` : codegen_1$7._`{minContains: ${min}, maxContains: ${max}}`
};
const def$c = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: true,
  error: error$6,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, it } = cxt;
    let min;
    let max;
    const { minContains, maxContains } = parentSchema;
    if (it.opts.next) {
      min = minContains === void 0 ? 1 : minContains;
      max = maxContains;
    } else {
      min = 1;
    }
    const len = gen.const("len", codegen_1$7._`${data}.length`);
    cxt.setParams({ min, max });
    if (max === void 0 && min === 0) {
      util_1$9.checkStrictMode(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
      return;
    }
    if (max !== void 0 && min > max) {
      util_1$9.checkStrictMode(it, `"minContains" > "maxContains" is always invalid`);
      cxt.fail();
      return;
    }
    if (util_1$9.alwaysValidSchema(it, schema2)) {
      let cond = codegen_1$7._`${len} >= ${min}`;
      if (max !== void 0)
        cond = codegen_1$7._`${cond} && ${len} <= ${max}`;
      cxt.pass(cond);
      return;
    }
    it.items = true;
    const valid2 = gen.name("valid");
    if (max === void 0 && min === 1) {
      validateItems(valid2, () => gen.if(valid2, () => gen.break()));
    } else {
      gen.let(valid2, false);
      const schValid = gen.name("_valid");
      const count = gen.let("count", 0);
      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
    }
    cxt.result(valid2, () => cxt.reset());
    function validateItems(_valid, block) {
      gen.forRange("i", 0, len, (i) => {
        cxt.subschema({
          keyword: "contains",
          dataProp: i,
          dataPropType: util_1$9.Type.Num,
          compositeRule: true
        }, _valid);
        block();
      });
    }
    function checkLimits(count) {
      gen.code(codegen_1$7._`${count}++`);
      if (max === void 0) {
        gen.if(codegen_1$7._`${count} >= ${min}`, () => gen.assign(valid2, true).break());
      } else {
        gen.if(codegen_1$7._`${count} > ${max}`, () => gen.assign(valid2, false).break());
        if (min === 1)
          gen.assign(valid2, true);
        else
          gen.if(codegen_1$7._`${count} >= ${min}`, () => gen.assign(valid2, true));
      }
    }
  }
};
contains.default = def$c;
var dependencies = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.validateSchemaDeps = exports2.validatePropertyDeps = exports2.error = void 0;
  const codegen_12 = codegen;
  const util_12 = util;
  const code_12 = code;
  exports2.error = {
    message: ({ params: { property, depsCount, deps } }) => {
      const property_ies = depsCount === 1 ? "property" : "properties";
      return codegen_12.str`must have ${property_ies} ${deps} when property ${property} is present`;
    },
    params: ({ params: { property, depsCount, deps, missingProperty } }) => codegen_12._`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
    // TODO change to reference
  };
  const def2 = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports2.error,
    code(cxt) {
      const [propDeps, schDeps] = splitDependencies(cxt);
      validatePropertyDeps(cxt, propDeps);
      validateSchemaDeps(cxt, schDeps);
    }
  };
  function splitDependencies({ schema: schema2 }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key in schema2) {
      if (key === "__proto__")
        continue;
      const deps = Array.isArray(schema2[key]) ? propertyDeps : schemaDeps;
      deps[key] = schema2[key];
    }
    return [propertyDeps, schemaDeps];
  }
  function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
    const { gen, data, it } = cxt;
    if (Object.keys(propertyDeps).length === 0)
      return;
    const missing = gen.let("missing");
    for (const prop in propertyDeps) {
      const deps = propertyDeps[prop];
      if (deps.length === 0)
        continue;
      const hasProperty = code_12.propertyInData(gen, data, prop, it.opts.ownProperties);
      cxt.setParams({
        property: prop,
        depsCount: deps.length,
        deps: deps.join(", ")
      });
      if (it.allErrors) {
        gen.if(hasProperty, () => {
          for (const depProp of deps) {
            code_12.checkReportMissingProp(cxt, depProp);
          }
        });
      } else {
        gen.if(codegen_12._`${hasProperty} && (${code_12.checkMissingProp(cxt, deps, missing)})`);
        code_12.reportMissingProp(cxt, missing);
        gen.else();
      }
    }
  }
  exports2.validatePropertyDeps = validatePropertyDeps;
  function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
    const { gen, data, keyword: keyword2, it } = cxt;
    const valid2 = gen.name("valid");
    for (const prop in schemaDeps) {
      if (util_12.alwaysValidSchema(it, schemaDeps[prop]))
        continue;
      gen.if(
        code_12.propertyInData(gen, data, prop, it.opts.ownProperties),
        () => {
          const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid2);
          cxt.mergeValidEvaluated(schCxt, valid2);
        },
        () => gen.var(valid2, true)
        // TODO var
      );
      cxt.ok(valid2);
    }
  }
  exports2.validateSchemaDeps = validateSchemaDeps;
  exports2.default = def2;
})(dependencies);
var propertyNames = {};
Object.defineProperty(propertyNames, "__esModule", { value: true });
const codegen_1$6 = codegen;
const util_1$8 = util;
const error$5 = {
  message: "property name must be valid",
  params: ({ params }) => codegen_1$6._`{propertyName: ${params.propertyName}}`
};
const def$b = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: error$5,
  code(cxt) {
    const { gen, schema: schema2, data, it } = cxt;
    if (util_1$8.alwaysValidSchema(it, schema2))
      return;
    const valid2 = gen.name("valid");
    gen.forIn("key", data, (key) => {
      cxt.setParams({ propertyName: key });
      cxt.subschema({
        keyword: "propertyNames",
        data: key,
        dataTypes: ["string"],
        propertyName: key,
        compositeRule: true
      }, valid2);
      gen.if(codegen_1$6.not(valid2), () => {
        cxt.error(true);
        if (!it.allErrors)
          gen.break();
      });
    });
    cxt.ok(valid2);
  }
};
propertyNames.default = def$b;
var additionalProperties = {};
Object.defineProperty(additionalProperties, "__esModule", { value: true });
const code_1$3 = code;
const codegen_1$5 = codegen;
const names_1 = names$1;
const util_1$7 = util;
const error$4 = {
  message: "must NOT have additional properties",
  params: ({ params }) => codegen_1$5._`{additionalProperty: ${params.additionalProperty}}`
};
const def$a = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: true,
  trackErrors: true,
  error: error$4,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, errsCount, it } = cxt;
    if (!errsCount)
      throw new Error("ajv implementation error");
    const { allErrors, opts: opts2 } = it;
    it.props = true;
    if (opts2.removeAdditional !== "all" && util_1$7.alwaysValidSchema(it, schema2))
      return;
    const props = code_1$3.allSchemaProperties(parentSchema.properties);
    const patProps = code_1$3.allSchemaProperties(parentSchema.patternProperties);
    checkAdditionalProperties();
    cxt.ok(codegen_1$5._`${errsCount} === ${names_1.default.errors}`);
    function checkAdditionalProperties() {
      gen.forIn("key", data, (key) => {
        if (!props.length && !patProps.length)
          additionalPropertyCode(key);
        else
          gen.if(isAdditional(key), () => additionalPropertyCode(key));
      });
    }
    function isAdditional(key) {
      let definedProp;
      if (props.length > 8) {
        const propsSchema = util_1$7.schemaRefOrVal(it, parentSchema.properties, "properties");
        definedProp = code_1$3.isOwnProperty(gen, propsSchema, key);
      } else if (props.length) {
        definedProp = codegen_1$5.or(...props.map((p) => codegen_1$5._`${key} === ${p}`));
      } else {
        definedProp = codegen_1$5.nil;
      }
      if (patProps.length) {
        definedProp = codegen_1$5.or(definedProp, ...patProps.map((p) => codegen_1$5._`${code_1$3.usePattern(cxt, p)}.test(${key})`));
      }
      return codegen_1$5.not(definedProp);
    }
    function deleteAdditional(key) {
      gen.code(codegen_1$5._`delete ${data}[${key}]`);
    }
    function additionalPropertyCode(key) {
      if (opts2.removeAdditional === "all" || opts2.removeAdditional && schema2 === false) {
        deleteAdditional(key);
        return;
      }
      if (schema2 === false) {
        cxt.setParams({ additionalProperty: key });
        cxt.error();
        if (!allErrors)
          gen.break();
        return;
      }
      if (typeof schema2 == "object" && !util_1$7.alwaysValidSchema(it, schema2)) {
        const valid2 = gen.name("valid");
        if (opts2.removeAdditional === "failing") {
          applyAdditionalSchema(key, valid2, false);
          gen.if(codegen_1$5.not(valid2), () => {
            cxt.reset();
            deleteAdditional(key);
          });
        } else {
          applyAdditionalSchema(key, valid2);
          if (!allErrors)
            gen.if(codegen_1$5.not(valid2), () => gen.break());
        }
      }
    }
    function applyAdditionalSchema(key, valid2, errors2) {
      const subschema2 = {
        keyword: "additionalProperties",
        dataProp: key,
        dataPropType: util_1$7.Type.Str
      };
      if (errors2 === false) {
        Object.assign(subschema2, {
          compositeRule: true,
          createErrors: false,
          allErrors: false
        });
      }
      cxt.subschema(subschema2, valid2);
    }
  }
};
additionalProperties.default = def$a;
var properties$1 = {};
Object.defineProperty(properties$1, "__esModule", { value: true });
const validate_1 = validate;
const code_1$2 = code;
const util_1$6 = util;
const additionalProperties_1$1 = additionalProperties;
const def$9 = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, it } = cxt;
    if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
      additionalProperties_1$1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1$1.default, "additionalProperties"));
    }
    const allProps = code_1$2.allSchemaProperties(schema2);
    for (const prop of allProps) {
      it.definedProperties.add(prop);
    }
    if (it.opts.unevaluated && allProps.length && it.props !== true) {
      it.props = util_1$6.mergeEvaluated.props(gen, util_1$6.toHash(allProps), it.props);
    }
    const properties2 = allProps.filter((p) => !util_1$6.alwaysValidSchema(it, schema2[p]));
    if (properties2.length === 0)
      return;
    const valid2 = gen.name("valid");
    for (const prop of properties2) {
      if (hasDefault(prop)) {
        applyPropertySchema(prop);
      } else {
        gen.if(code_1$2.propertyInData(gen, data, prop, it.opts.ownProperties));
        applyPropertySchema(prop);
        if (!it.allErrors)
          gen.else().var(valid2, true);
        gen.endIf();
      }
      cxt.it.definedProperties.add(prop);
      cxt.ok(valid2);
    }
    function hasDefault(prop) {
      return it.opts.useDefaults && !it.compositeRule && schema2[prop].default !== void 0;
    }
    function applyPropertySchema(prop) {
      cxt.subschema({
        keyword: "properties",
        schemaProp: prop,
        dataProp: prop
      }, valid2);
    }
  }
};
properties$1.default = def$9;
var patternProperties = {};
Object.defineProperty(patternProperties, "__esModule", { value: true });
const code_1$1 = code;
const codegen_1$4 = codegen;
const util_1$5 = util;
const util_2 = util;
const def$8 = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema: schema2, data, parentSchema, it } = cxt;
    const { opts: opts2 } = it;
    const patterns = code_1$1.allSchemaProperties(schema2);
    const alwaysValidPatterns = patterns.filter((p) => util_1$5.alwaysValidSchema(it, schema2[p]));
    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
      return;
    }
    const checkProperties = opts2.strictSchema && !opts2.allowMatchingProperties && parentSchema.properties;
    const valid2 = gen.name("valid");
    if (it.props !== true && !(it.props instanceof codegen_1$4.Name)) {
      it.props = util_2.evaluatedPropsToName(gen, it.props);
    }
    const { props } = it;
    validatePatternProperties();
    function validatePatternProperties() {
      for (const pat of patterns) {
        if (checkProperties)
          checkMatchingProperties(pat);
        if (it.allErrors) {
          validateProperties(pat);
        } else {
          gen.var(valid2, true);
          validateProperties(pat);
          gen.if(valid2);
        }
      }
    }
    function checkMatchingProperties(pat) {
      for (const prop in checkProperties) {
        if (new RegExp(pat).test(prop)) {
          util_1$5.checkStrictMode(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
        }
      }
    }
    function validateProperties(pat) {
      gen.forIn("key", data, (key) => {
        gen.if(codegen_1$4._`${code_1$1.usePattern(cxt, pat)}.test(${key})`, () => {
          const alwaysValid = alwaysValidPatterns.includes(pat);
          if (!alwaysValid) {
            cxt.subschema({
              keyword: "patternProperties",
              schemaProp: pat,
              dataProp: key,
              dataPropType: util_2.Type.Str
            }, valid2);
          }
          if (it.opts.unevaluated && props !== true) {
            gen.assign(codegen_1$4._`${props}[${key}]`, true);
          } else if (!alwaysValid && !it.allErrors) {
            gen.if(codegen_1$4.not(valid2), () => gen.break());
          }
        });
      });
    }
  }
};
patternProperties.default = def$8;
var not = {};
Object.defineProperty(not, "__esModule", { value: true });
const util_1$4 = util;
const def$7 = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  code(cxt) {
    const { gen, schema: schema2, it } = cxt;
    if (util_1$4.alwaysValidSchema(it, schema2)) {
      cxt.fail();
      return;
    }
    const valid2 = gen.name("valid");
    cxt.subschema({
      keyword: "not",
      compositeRule: true,
      createErrors: false,
      allErrors: false
    }, valid2);
    cxt.failResult(valid2, () => cxt.reset(), () => cxt.error());
  },
  error: { message: "must NOT be valid" }
};
not.default = def$7;
var anyOf = {};
Object.defineProperty(anyOf, "__esModule", { value: true });
const code_1 = code;
const def$6 = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: true,
  code: code_1.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
anyOf.default = def$6;
var oneOf = {};
Object.defineProperty(oneOf, "__esModule", { value: true });
const codegen_1$3 = codegen;
const util_1$3 = util;
const error$3 = {
  message: "must match exactly one schema in oneOf",
  params: ({ params }) => codegen_1$3._`{passingSchemas: ${params.passing}}`
};
const def$5 = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: true,
  error: error$3,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, it } = cxt;
    if (!Array.isArray(schema2))
      throw new Error("ajv implementation error");
    if (it.opts.discriminator && parentSchema.discriminator)
      return;
    const schArr = schema2;
    const valid2 = gen.let("valid", false);
    const passing = gen.let("passing", null);
    const schValid = gen.name("_valid");
    cxt.setParams({ passing });
    gen.block(validateOneOf);
    cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
    function validateOneOf() {
      schArr.forEach((sch, i) => {
        let schCxt;
        if (util_1$3.alwaysValidSchema(it, sch)) {
          gen.var(schValid, true);
        } else {
          schCxt = cxt.subschema({
            keyword: "oneOf",
            schemaProp: i,
            compositeRule: true
          }, schValid);
        }
        if (i > 0) {
          gen.if(codegen_1$3._`${schValid} && ${valid2}`).assign(valid2, false).assign(passing, codegen_1$3._`[${passing}, ${i}]`).else();
        }
        gen.if(schValid, () => {
          gen.assign(valid2, true);
          gen.assign(passing, i);
          if (schCxt)
            cxt.mergeEvaluated(schCxt, codegen_1$3.Name);
        });
      });
    }
  }
};
oneOf.default = def$5;
var allOf = {};
Object.defineProperty(allOf, "__esModule", { value: true });
const util_1$2 = util;
const def$4 = {
  keyword: "allOf",
  schemaType: "array",
  code(cxt) {
    const { gen, schema: schema2, it } = cxt;
    if (!Array.isArray(schema2))
      throw new Error("ajv implementation error");
    const valid2 = gen.name("valid");
    schema2.forEach((sch, i) => {
      if (util_1$2.alwaysValidSchema(it, sch))
        return;
      const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid2);
      cxt.ok(valid2);
      cxt.mergeEvaluated(schCxt);
    });
  }
};
allOf.default = def$4;
var _if = {};
Object.defineProperty(_if, "__esModule", { value: true });
const codegen_1$2 = codegen;
const util_1$1 = util;
const error$2 = {
  message: ({ params }) => codegen_1$2.str`must match "${params.ifClause}" schema`,
  params: ({ params }) => codegen_1$2._`{failingKeyword: ${params.ifClause}}`
};
const def$3 = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  error: error$2,
  code(cxt) {
    const { gen, parentSchema, it } = cxt;
    if (parentSchema.then === void 0 && parentSchema.else === void 0) {
      util_1$1.checkStrictMode(it, '"if" without "then" and "else" is ignored');
    }
    const hasThen = hasSchema(it, "then");
    const hasElse = hasSchema(it, "else");
    if (!hasThen && !hasElse)
      return;
    const valid2 = gen.let("valid", true);
    const schValid = gen.name("_valid");
    validateIf();
    cxt.reset();
    if (hasThen && hasElse) {
      const ifClause = gen.let("ifClause");
      cxt.setParams({ ifClause });
      gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
    } else if (hasThen) {
      gen.if(schValid, validateClause("then"));
    } else {
      gen.if(codegen_1$2.not(schValid), validateClause("else"));
    }
    cxt.pass(valid2, () => cxt.error(true));
    function validateIf() {
      const schCxt = cxt.subschema({
        keyword: "if",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, schValid);
      cxt.mergeEvaluated(schCxt);
    }
    function validateClause(keyword2, ifClause) {
      return () => {
        const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
        gen.assign(valid2, schValid);
        cxt.mergeValidEvaluated(schCxt, valid2);
        if (ifClause)
          gen.assign(ifClause, codegen_1$2._`${keyword2}`);
        else
          cxt.setParams({ ifClause: keyword2 });
      };
    }
  }
};
function hasSchema(it, keyword2) {
  const schema2 = it.schema[keyword2];
  return schema2 !== void 0 && !util_1$1.alwaysValidSchema(it, schema2);
}
_if.default = def$3;
var thenElse = {};
Object.defineProperty(thenElse, "__esModule", { value: true });
const util_1 = util;
const def$2 = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: keyword2, parentSchema, it }) {
    if (parentSchema.if === void 0)
      util_1.checkStrictMode(it, `"${keyword2}" without "if" is ignored`);
  }
};
thenElse.default = def$2;
Object.defineProperty(applicator, "__esModule", { value: true });
const additionalItems_1 = additionalItems;
const prefixItems_1 = prefixItems;
const items_1 = items;
const items2020_1 = items2020;
const contains_1 = contains;
const dependencies_1 = dependencies;
const propertyNames_1 = propertyNames;
const additionalProperties_1 = additionalProperties;
const properties_1 = properties$1;
const patternProperties_1 = patternProperties;
const not_1 = not;
const anyOf_1 = anyOf;
const oneOf_1 = oneOf;
const allOf_1 = allOf;
const if_1 = _if;
const thenElse_1 = thenElse;
function getApplicator(draft2020 = false) {
  const applicator2 = [
    // any
    not_1.default,
    anyOf_1.default,
    oneOf_1.default,
    allOf_1.default,
    if_1.default,
    thenElse_1.default,
    // object
    propertyNames_1.default,
    additionalProperties_1.default,
    dependencies_1.default,
    properties_1.default,
    patternProperties_1.default
  ];
  if (draft2020)
    applicator2.push(prefixItems_1.default, items2020_1.default);
  else
    applicator2.push(additionalItems_1.default, items_1.default);
  applicator2.push(contains_1.default);
  return applicator2;
}
applicator.default = getApplicator;
var format$2 = {};
var format$1 = {};
Object.defineProperty(format$1, "__esModule", { value: true });
const codegen_1$1 = codegen;
const error$1 = {
  message: ({ schemaCode }) => codegen_1$1.str`must match format "${schemaCode}"`,
  params: ({ schemaCode }) => codegen_1$1._`{format: ${schemaCode}}`
};
const def$1 = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: true,
  error: error$1,
  code(cxt, ruleType) {
    const { gen, data, $data, schema: schema2, schemaCode, it } = cxt;
    const { opts: opts2, errSchemaPath, schemaEnv, self: self2 } = it;
    if (!opts2.validateFormats)
      return;
    if ($data)
      validate$DataFormat();
    else
      validateFormat();
    function validate$DataFormat() {
      const fmts = gen.scopeValue("formats", {
        ref: self2.formats,
        code: opts2.code.formats
      });
      const fDef = gen.const("fDef", codegen_1$1._`${fmts}[${schemaCode}]`);
      const fType = gen.let("fType");
      const format2 = gen.let("format");
      gen.if(codegen_1$1._`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, codegen_1$1._`${fDef}.type || "string"`).assign(format2, codegen_1$1._`${fDef}.validate`), () => gen.assign(fType, codegen_1$1._`"string"`).assign(format2, fDef));
      cxt.fail$data(codegen_1$1.or(unknownFmt(), invalidFmt()));
      function unknownFmt() {
        if (opts2.strictSchema === false)
          return codegen_1$1.nil;
        return codegen_1$1._`${schemaCode} && !${format2}`;
      }
      function invalidFmt() {
        const callFormat = schemaEnv.$async ? codegen_1$1._`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : codegen_1$1._`${format2}(${data})`;
        const validData = codegen_1$1._`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
        return codegen_1$1._`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
      }
    }
    function validateFormat() {
      const formatDef = self2.formats[schema2];
      if (!formatDef) {
        unknownFormat();
        return;
      }
      if (formatDef === true)
        return;
      const [fmtType, format2, fmtRef] = getFormat(formatDef);
      if (fmtType === ruleType)
        cxt.pass(validCondition());
      function unknownFormat() {
        if (opts2.strictSchema === false) {
          self2.logger.warn(unknownMsg());
          return;
        }
        throw new Error(unknownMsg());
        function unknownMsg() {
          return `unknown format "${schema2}" ignored in schema at path "${errSchemaPath}"`;
        }
      }
      function getFormat(fmtDef) {
        const code2 = fmtDef instanceof RegExp ? codegen_1$1.regexpCode(fmtDef) : opts2.code.formats ? codegen_1$1._`${opts2.code.formats}${codegen_1$1.getProperty(schema2)}` : void 0;
        const fmt = gen.scopeValue("formats", { key: schema2, ref: fmtDef, code: code2 });
        if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
          return [fmtDef.type || "string", fmtDef.validate, codegen_1$1._`${fmt}.validate`];
        }
        return ["string", fmtDef, fmt];
      }
      function validCondition() {
        if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
          if (!schemaEnv.$async)
            throw new Error("async format in sync schema");
          return codegen_1$1._`await ${fmtRef}(${data})`;
        }
        return typeof format2 == "function" ? codegen_1$1._`${fmtRef}(${data})` : codegen_1$1._`${fmtRef}.test(${data})`;
      }
    }
  }
};
format$1.default = def$1;
Object.defineProperty(format$2, "__esModule", { value: true });
const format_1$1 = format$1;
const format = [format_1$1.default];
format$2.default = format;
var metadata = {};
Object.defineProperty(metadata, "__esModule", { value: true });
metadata.contentVocabulary = metadata.metadataVocabulary = void 0;
metadata.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
metadata.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(draft7, "__esModule", { value: true });
const core_1 = core$1;
const validation_1 = validation$1;
const applicator_1 = applicator;
const format_1 = format$2;
const metadata_1 = metadata;
const draft7Vocabularies = [
  core_1.default,
  validation_1.default,
  applicator_1.default(),
  format_1.default,
  metadata_1.metadataVocabulary,
  metadata_1.contentVocabulary
];
draft7.default = draft7Vocabularies;
var discriminator = {};
var types = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.DiscrError = void 0;
  (function(DiscrError) {
    DiscrError["Tag"] = "tag";
    DiscrError["Mapping"] = "mapping";
  })(exports2.DiscrError || (exports2.DiscrError = {}));
})(types);
Object.defineProperty(discriminator, "__esModule", { value: true });
const codegen_1 = codegen;
const types_1 = types;
const error = {
  message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
  params: ({ params: { discrError, tag, tagName } }) => codegen_1._`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
};
const def = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error,
  code(cxt) {
    const { gen, data, schema: schema2, parentSchema, it } = cxt;
    const { oneOf: oneOf2 } = parentSchema;
    if (!it.opts.discriminator) {
      throw new Error("discriminator: requires discriminator option");
    }
    const tagName = schema2.propertyName;
    if (typeof tagName != "string")
      throw new Error("discriminator: requires propertyName");
    if (schema2.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!oneOf2)
      throw new Error("discriminator: requires oneOf keyword");
    const valid2 = gen.let("valid", false);
    const tag = gen.const("tag", codegen_1._`${data}${codegen_1.getProperty(tagName)}`);
    gen.if(codegen_1._`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
    cxt.ok(valid2);
    function validateMapping() {
      const mapping = getMapping();
      gen.if(false);
      for (const tagValue in mapping) {
        gen.elseIf(codegen_1._`${tag} === ${tagValue}`);
        gen.assign(valid2, applyTagSchema(mapping[tagValue]));
      }
      gen.else();
      cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
      gen.endIf();
    }
    function applyTagSchema(schemaProp) {
      const _valid = gen.name("valid");
      const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
      cxt.mergeEvaluated(schCxt, codegen_1.Name);
      return _valid;
    }
    function getMapping() {
      var _a;
      const oneOfMapping = {};
      const topRequired = hasRequired(parentSchema);
      let tagRequired = true;
      for (let i = 0; i < oneOf2.length; i++) {
        const sch = oneOf2[i];
        const propSch = (_a = sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
        if (typeof propSch != "object") {
          throw new Error(`discriminator: oneOf schemas must have "properties/${tagName}"`);
        }
        tagRequired = tagRequired && (topRequired || hasRequired(sch));
        addMappings(propSch, i);
      }
      if (!tagRequired)
        throw new Error(`discriminator: "${tagName}" must be required`);
      return oneOfMapping;
      function hasRequired({ required: required2 }) {
        return Array.isArray(required2) && required2.includes(tagName);
      }
      function addMappings(sch, i) {
        if (sch.const) {
          addMapping(sch.const, i);
        } else if (sch.enum) {
          for (const tagValue of sch.enum) {
            addMapping(tagValue, i);
          }
        } else {
          throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
        }
      }
      function addMapping(tagValue, i) {
        if (typeof tagValue != "string" || tagValue in oneOfMapping) {
          throw new Error(`discriminator: "${tagName}" values must be unique strings`);
        }
        oneOfMapping[tagValue] = i;
      }
    }
  }
};
discriminator.default = def;
const $schema = "http://json-schema.org/draft-07/schema#";
const $id = "http://json-schema.org/draft-07/schema#";
const title = "Core schema meta-schema";
const definitions = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        "default": 0
      }
    ]
  },
  simpleTypes: {
    "enum": [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: true,
    "default": []
  }
};
const type = [
  "object",
  "boolean"
];
const properties = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  "default": true,
  readOnly: {
    type: "boolean",
    "default": false
  },
  examples: {
    type: "array",
    items: true
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    "default": true
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    "default": false
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    "default": {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  "const": true,
  "enum": {
    type: "array",
    items: true,
    minItems: 1,
    uniqueItems: true
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: true
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  "if": {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  "else": {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
};
const require$$3 = {
  $schema,
  $id,
  title,
  definitions,
  type,
  properties,
  "default": true
};
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
  const core_12 = core$2;
  const draft7_1 = draft7;
  const discriminator_1 = discriminator;
  const draft7MetaSchema = require$$3;
  const META_SUPPORT_DATA = ["/properties"];
  const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
  class Ajv extends core_12.default {
    _addVocabularies() {
      super._addVocabularies();
      draft7_1.default.forEach((v) => this.addVocabulary(v));
      if (this.opts.discriminator)
        this.addKeyword(discriminator_1.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      if (!this.opts.meta)
        return;
      const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
      this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
      this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
    }
  }
  module2.exports = exports2 = Ajv;
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.default = Ajv;
  var validate_12 = validate;
  Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
})(ajv, ajv.exports);
var ajvExports = ajv.exports;
var dist = { exports: {} };
var formats = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.formatNames = exports2.fastFormats = exports2.fullFormats = void 0;
  function fmtDef(validate2, compare2) {
    return { validate: validate2, compare: compare2 };
  }
  exports2.fullFormats = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: fmtDef(date, compareDate),
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: fmtDef(time, compareTime),
    "date-time": fmtDef(date_time, compareDateTime),
    // duration: https://tools.ietf.org/html/rfc3339#appendix-A
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    // uri-template: https://tools.ietf.org/html/rfc6570
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    // For the source: https://gist.github.com/dperini/729294
    // For test cases: https://mathiasbynens.be/demo/url-regex
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex,
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
    // byte: https://github.com/miguelmota/is-base64
    byte,
    // signed 32 bit integer
    int32: { type: "number", validate: validateInt32 },
    // signed 64 bit integer
    int64: { type: "number", validate: validateInt64 },
    // C-type float
    float: { type: "number", validate: validateNumber },
    // C-type double
    double: { type: "number", validate: validateNumber },
    // hint to the UI to hide input strings
    password: true,
    // unchecked string payload
    binary: true
  };
  exports2.fastFormats = {
    ...exports2.fullFormats,
    date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
    time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
    "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
  };
  exports2.formatNames = Object.keys(exports2.fullFormats);
  function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function date(str) {
    const matches = DATE.exec(str);
    if (!matches)
      return false;
    const year = +matches[1];
    const month = +matches[2];
    const day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
  }
  function compareDate(d1, d2) {
    if (!(d1 && d2))
      return void 0;
    if (d1 > d2)
      return 1;
    if (d1 < d2)
      return -1;
    return 0;
  }
  const TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
  function time(str, withTimeZone) {
    const matches = TIME.exec(str);
    if (!matches)
      return false;
    const hour = +matches[1];
    const minute = +matches[2];
    const second = +matches[3];
    const timeZone = matches[5];
    return (hour <= 23 && minute <= 59 && second <= 59 || hour === 23 && minute === 59 && second === 60) && (!withTimeZone || timeZone !== "");
  }
  function compareTime(t1, t2) {
    if (!(t1 && t2))
      return void 0;
    const a1 = TIME.exec(t1);
    const a2 = TIME.exec(t2);
    if (!(a1 && a2))
      return void 0;
    t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
    t2 = a2[1] + a2[2] + a2[3] + (a2[4] || "");
    if (t1 > t2)
      return 1;
    if (t1 < t2)
      return -1;
    return 0;
  }
  const DATE_TIME_SEPARATOR = /t|\s/i;
  function date_time(str) {
    const dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true);
  }
  function compareDateTime(dt1, dt2) {
    if (!(dt1 && dt2))
      return void 0;
    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
    const res = compareDate(d1, d2);
    if (res === void 0)
      return void 0;
    return res || compareTime(t1, t2);
  }
  const NOT_URI_FRAGMENT = /\/|:/;
  const URI2 = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function uri(str) {
    return NOT_URI_FRAGMENT.test(str) && URI2.test(str);
  }
  const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function byte(str) {
    BYTE.lastIndex = 0;
    return BYTE.test(str);
  }
  const MIN_INT32 = -(2 ** 31);
  const MAX_INT32 = 2 ** 31 - 1;
  function validateInt32(value) {
    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
  }
  function validateInt64(value) {
    return Number.isInteger(value);
  }
  function validateNumber() {
    return true;
  }
  const Z_ANCHOR = /[^\\]\\Z/;
  function regex(str) {
    if (Z_ANCHOR.test(str))
      return false;
    try {
      new RegExp(str);
      return true;
    } catch (e) {
      return false;
    }
  }
})(formats);
var limit = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.formatLimitDefinition = void 0;
  const ajv_1 = ajvExports;
  const codegen_12 = codegen;
  const ops2 = codegen_12.operators;
  const KWDs2 = {
    formatMaximum: { okStr: "<=", ok: ops2.LTE, fail: ops2.GT },
    formatMinimum: { okStr: ">=", ok: ops2.GTE, fail: ops2.LT },
    formatExclusiveMaximum: { okStr: "<", ok: ops2.LT, fail: ops2.GTE },
    formatExclusiveMinimum: { okStr: ">", ok: ops2.GT, fail: ops2.LTE }
  };
  const error2 = {
    message: ({ keyword: keyword2, schemaCode }) => codegen_12.str`should be ${KWDs2[keyword2].okStr} ${schemaCode}`,
    params: ({ keyword: keyword2, schemaCode }) => codegen_12._`{comparison: ${KWDs2[keyword2].okStr}, limit: ${schemaCode}}`
  };
  exports2.formatLimitDefinition = {
    keyword: Object.keys(KWDs2),
    type: "string",
    schemaType: "string",
    $data: true,
    error: error2,
    code(cxt) {
      const { gen, data, schemaCode, keyword: keyword2, it } = cxt;
      const { opts: opts2, self: self2 } = it;
      if (!opts2.validateFormats)
        return;
      const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
      if (fCxt.$data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen.scopeValue("formats", {
          ref: self2.formats,
          code: opts2.code.formats
        });
        const fmt = gen.const("fmt", codegen_12._`${fmts}[${fCxt.schemaCode}]`);
        cxt.fail$data(codegen_12.or(codegen_12._`typeof ${fmt} != "object"`, codegen_12._`${fmt} instanceof RegExp`, codegen_12._`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
      }
      function validateFormat() {
        const format2 = fCxt.schema;
        const fmtDef = self2.formats[format2];
        if (!fmtDef || fmtDef === true)
          return;
        if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
          throw new Error(`"${keyword2}": format "${format2}" does not define "compare" function`);
        }
        const fmt = gen.scopeValue("formats", {
          key: format2,
          ref: fmtDef,
          code: opts2.code.formats ? codegen_12._`${opts2.code.formats}${codegen_12.getProperty(format2)}` : void 0
        });
        cxt.fail$data(compareCode(fmt));
      }
      function compareCode(fmt) {
        return codegen_12._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs2[keyword2].fail} 0`;
      }
    },
    dependencies: ["format"]
  };
  const formatLimitPlugin = (ajv2) => {
    ajv2.addKeyword(exports2.formatLimitDefinition);
    return ajv2;
  };
  exports2.default = formatLimitPlugin;
})(limit);
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  const formats_1 = formats;
  const limit_1 = limit;
  const codegen_12 = codegen;
  const fullName = new codegen_12.Name("fullFormats");
  const fastName = new codegen_12.Name("fastFormats");
  const formatsPlugin = (ajv2, opts2 = { keywords: true }) => {
    if (Array.isArray(opts2)) {
      addFormats(ajv2, opts2, formats_1.fullFormats, fullName);
      return ajv2;
    }
    const [formats2, exportName] = opts2.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
    const list = opts2.formats || formats_1.formatNames;
    addFormats(ajv2, list, formats2, exportName);
    if (opts2.keywords)
      limit_1.default(ajv2);
    return ajv2;
  };
  formatsPlugin.get = (name, mode = "full") => {
    const formats2 = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
    const f = formats2[name];
    if (!f)
      throw new Error(`Unknown format "${name}"`);
    return f;
  };
  function addFormats(ajv2, list, fs2, exportName) {
    var _a;
    var _b;
    (_a = (_b = ajv2.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = codegen_12._`require("ajv-formats/dist/formats").${exportName}`;
    for (const f of list)
      ajv2.addFormat(f, fs2[f]);
  }
  module2.exports = exports2 = formatsPlugin;
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.default = formatsPlugin;
})(dist, dist.exports);
var distExports = dist.exports;
const copyProperty = (to, from, property, ignoreNonConfigurable) => {
  if (property === "length" || property === "prototype") {
    return;
  }
  if (property === "arguments" || property === "caller") {
    return;
  }
  const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
  const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
    return;
  }
  Object.defineProperty(to, property, fromDescriptor);
};
const canCopyProperty = function(toDescriptor, fromDescriptor) {
  return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
};
const changePrototype = (to, from) => {
  const fromPrototype = Object.getPrototypeOf(from);
  if (fromPrototype === Object.getPrototypeOf(to)) {
    return;
  }
  Object.setPrototypeOf(to, fromPrototype);
};
const wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
const toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
const toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
const changeToString = (to, from, name) => {
  const withName = name === "" ? "" : `with ${name.trim()}() `;
  const newToString = wrappedToString.bind(null, withName, from.toString());
  Object.defineProperty(newToString, "name", toStringName);
  Object.defineProperty(to, "toString", { ...toStringDescriptor, value: newToString });
};
const mimicFn$4 = (to, from, { ignoreNonConfigurable = false } = {}) => {
  const { name } = to;
  for (const property of Reflect.ownKeys(from)) {
    copyProperty(to, from, property, ignoreNonConfigurable);
  }
  changePrototype(to, from);
  changeToString(to, from, name);
  return to;
};
var mimicFn_1 = mimicFn$4;
const mimicFn$3 = mimicFn_1;
var debounceFn = (inputFunction, options = {}) => {
  if (typeof inputFunction !== "function") {
    throw new TypeError(`Expected the first argument to be a function, got \`${typeof inputFunction}\``);
  }
  const {
    wait = 0,
    before = false,
    after = true
  } = options;
  if (!before && !after) {
    throw new Error("Both `before` and `after` are false, function wouldn't be called.");
  }
  let timeout;
  let result;
  const debouncedFunction = function(...arguments_) {
    const context = this;
    const later = () => {
      timeout = void 0;
      if (after) {
        result = inputFunction.apply(context, arguments_);
      }
    };
    const shouldCallNow = before && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (shouldCallNow) {
      result = inputFunction.apply(context, arguments_);
    }
    return result;
  };
  mimicFn$3(debouncedFunction, inputFunction);
  debouncedFunction.cancel = () => {
    if (timeout) {
      clearTimeout(timeout);
      timeout = void 0;
    }
  };
  return debouncedFunction;
};
var re$3 = { exports: {} };
const SEMVER_SPEC_VERSION = "2.0.0";
const MAX_LENGTH$2 = 256;
const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991;
const MAX_SAFE_COMPONENT_LENGTH = 16;
var constants = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH: MAX_LENGTH$2,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  MAX_SAFE_COMPONENT_LENGTH
};
const debug$1 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
};
var debug_1 = debug$1;
(function(module2, exports2) {
  const { MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2 } = constants;
  const debug2 = debug_1;
  exports2 = module2.exports = {};
  const re2 = exports2.re = [];
  const src = exports2.src = [];
  const t2 = exports2.t = {};
  let R = 0;
  const createToken = (name, value, isGlobal) => {
    const index = R++;
    debug2(index, value);
    t2[name] = index;
    src[index] = value;
    re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
  createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
  createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NUMERICIDENTIFIER]}|${src[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NUMERICIDENTIFIERLOOSE]}|${src[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
  createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`);
  createToken("FULL", `^${src[t2.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`);
  createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:$|[^\\d])`);
  createToken("COERCERTL", src[t2.COERCE], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true);
  exports2.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true);
  exports2.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true);
  exports2.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
})(re$3, re$3.exports);
var reExports = re$3.exports;
const opts = ["includePrerelease", "loose", "rtl"];
const parseOptions$2 = (options) => !options ? {} : typeof options !== "object" ? { loose: true } : opts.filter((k) => options[k]).reduce((options2, k) => {
  options2[k] = true;
  return options2;
}, {});
var parseOptions_1 = parseOptions$2;
const numeric = /^[0-9]+$/;
const compareIdentifiers$1 = (a, b) => {
  const anum = numeric.test(a);
  const bnum = numeric.test(b);
  if (anum && bnum) {
    a = +a;
    b = +b;
  }
  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);
var identifiers = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
const debug = debug_1;
const { MAX_LENGTH: MAX_LENGTH$1, MAX_SAFE_INTEGER } = constants;
const { re: re$2, t: t$2 } = reExports;
const parseOptions$1 = parseOptions_1;
const { compareIdentifiers } = identifiers;
let SemVer$c = class SemVer {
  constructor(version, options) {
    options = parseOptions$1(options);
    if (version instanceof SemVer) {
      if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError(`Invalid Version: ${version}`);
    }
    if (version.length > MAX_LENGTH$1) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH$1} characters`
      );
    }
    debug("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    const m = version.trim().match(options.loose ? re$2[t$2.LOOSE] : re$2[t$2.FULL]);
    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`);
    }
    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map((id2) => {
        if (/^[0-9]+$/.test(id2)) {
          const num = +id2;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id2;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join(".")}`;
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  }
  comparePre(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    let i = 0;
    do {
      const a = this.prerelease[i];
      const b = other.prerelease[i];
      debug("prerelease compare", i, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    let i = 0;
    do {
      const a = this.build[i];
      const b = other.build[i];
      debug("prerelease compare", i, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          let i = this.prerelease.length;
          while (--i >= 0) {
            if (typeof this.prerelease[i] === "number") {
              this.prerelease[i]++;
              i = -2;
            }
          }
          if (i === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error(`invalid increment argument: ${release}`);
    }
    this.format();
    this.raw = this.version;
    return this;
  }
};
var semver$1 = SemVer$c;
const { MAX_LENGTH } = constants;
const { re: re$1, t: t$1 } = reExports;
const SemVer$b = semver$1;
const parseOptions = parseOptions_1;
const parse$5 = (version, options) => {
  options = parseOptions(options);
  if (version instanceof SemVer$b) {
    return version;
  }
  if (typeof version !== "string") {
    return null;
  }
  if (version.length > MAX_LENGTH) {
    return null;
  }
  const r = options.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL];
  if (!r.test(version)) {
    return null;
  }
  try {
    return new SemVer$b(version, options);
  } catch (er) {
    return null;
  }
};
var parse_1 = parse$5;
const parse$4 = parse_1;
const valid$1 = (version, options) => {
  const v = parse$4(version, options);
  return v ? v.version : null;
};
var valid_1 = valid$1;
const parse$3 = parse_1;
const clean = (version, options) => {
  const s = parse$3(version.trim().replace(/^[=v]+/, ""), options);
  return s ? s.version : null;
};
var clean_1 = clean;
const SemVer$a = semver$1;
const inc = (version, release, options, identifier) => {
  if (typeof options === "string") {
    identifier = options;
    options = void 0;
  }
  try {
    return new SemVer$a(version, options).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
};
var inc_1 = inc;
const SemVer$9 = semver$1;
const compare$a = (a, b, loose) => new SemVer$9(a, loose).compare(new SemVer$9(b, loose));
var compare_1 = compare$a;
const compare$9 = compare_1;
const eq$2 = (a, b, loose) => compare$9(a, b, loose) === 0;
var eq_1 = eq$2;
const parse$2 = parse_1;
const eq$1 = eq_1;
const diff = (version1, version2) => {
  if (eq$1(version1, version2)) {
    return null;
  } else {
    const v1 = parse$2(version1);
    const v2 = parse$2(version2);
    const hasPre = v1.prerelease.length || v2.prerelease.length;
    const prefix = hasPre ? "pre" : "";
    const defaultResult = hasPre ? "prerelease" : "";
    for (const key in v1) {
      if (key === "major" || key === "minor" || key === "patch") {
        if (v1[key] !== v2[key]) {
          return prefix + key;
        }
      }
    }
    return defaultResult;
  }
};
var diff_1 = diff;
const SemVer$8 = semver$1;
const major = (a, loose) => new SemVer$8(a, loose).major;
var major_1 = major;
const SemVer$7 = semver$1;
const minor = (a, loose) => new SemVer$7(a, loose).minor;
var minor_1 = minor;
const SemVer$6 = semver$1;
const patch = (a, loose) => new SemVer$6(a, loose).patch;
var patch_1 = patch;
const parse$1 = parse_1;
const prerelease = (version, options) => {
  const parsed = parse$1(version, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
var prerelease_1 = prerelease;
const compare$8 = compare_1;
const rcompare = (a, b, loose) => compare$8(b, a, loose);
var rcompare_1 = rcompare;
const compare$7 = compare_1;
const compareLoose = (a, b) => compare$7(a, b, true);
var compareLoose_1 = compareLoose;
const SemVer$5 = semver$1;
const compareBuild$2 = (a, b, loose) => {
  const versionA = new SemVer$5(a, loose);
  const versionB = new SemVer$5(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
var compareBuild_1 = compareBuild$2;
const compareBuild$1 = compareBuild_1;
const sort = (list, loose) => list.sort((a, b) => compareBuild$1(a, b, loose));
var sort_1 = sort;
const compareBuild = compareBuild_1;
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
var rsort_1 = rsort;
const compare$6 = compare_1;
const gt$3 = (a, b, loose) => compare$6(a, b, loose) > 0;
var gt_1 = gt$3;
const compare$5 = compare_1;
const lt$2 = (a, b, loose) => compare$5(a, b, loose) < 0;
var lt_1 = lt$2;
const compare$4 = compare_1;
const neq$1 = (a, b, loose) => compare$4(a, b, loose) !== 0;
var neq_1 = neq$1;
const compare$3 = compare_1;
const gte$2 = (a, b, loose) => compare$3(a, b, loose) >= 0;
var gte_1 = gte$2;
const compare$2 = compare_1;
const lte$2 = (a, b, loose) => compare$2(a, b, loose) <= 0;
var lte_1 = lte$2;
const eq = eq_1;
const neq = neq_1;
const gt$2 = gt_1;
const gte$1 = gte_1;
const lt$1 = lt_1;
const lte$1 = lte_1;
const cmp = (a, op, b, loose) => {
  switch (op) {
    case "===":
      if (typeof a === "object")
        a = a.version;
      if (typeof b === "object")
        b = b.version;
      return a === b;
    case "!==":
      if (typeof a === "object")
        a = a.version;
      if (typeof b === "object")
        b = b.version;
      return a !== b;
    case "":
    case "=":
    case "==":
      return eq(a, b, loose);
    case "!=":
      return neq(a, b, loose);
    case ">":
      return gt$2(a, b, loose);
    case ">=":
      return gte$1(a, b, loose);
    case "<":
      return lt$1(a, b, loose);
    case "<=":
      return lte$1(a, b, loose);
    default:
      throw new TypeError(`Invalid operator: ${op}`);
  }
};
var cmp_1 = cmp;
const SemVer$4 = semver$1;
const parse = parse_1;
const { re, t } = reExports;
const coerce = (version, options) => {
  if (version instanceof SemVer$4) {
    return version;
  }
  if (typeof version === "number") {
    version = String(version);
  }
  if (typeof version !== "string") {
    return null;
  }
  options = options || {};
  let match = null;
  if (!options.rtl) {
    match = version.match(re[t.COERCE]);
  } else {
    let next;
    while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
    }
    re[t.COERCERTL].lastIndex = -1;
  }
  if (match === null)
    return null;
  return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
};
var coerce_1 = coerce;
var iterator;
var hasRequiredIterator;
function requireIterator() {
  if (hasRequiredIterator)
    return iterator;
  hasRequiredIterator = 1;
  iterator = function(Yallist2) {
    Yallist2.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head; walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
  return iterator;
}
var yallist = Yallist$1;
Yallist$1.Node = Node;
Yallist$1.create = Yallist$1;
function Yallist$1(list) {
  var self2 = this;
  if (!(self2 instanceof Yallist$1)) {
    self2 = new Yallist$1();
  }
  self2.tail = null;
  self2.head = null;
  self2.length = 0;
  if (list && typeof list.forEach === "function") {
    list.forEach(function(item) {
      self2.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self2.push(arguments[i]);
    }
  }
  return self2;
}
Yallist$1.prototype.removeNode = function(node) {
  if (node.list !== this) {
    throw new Error("removing node which does not belong to this list");
  }
  var next = node.next;
  var prev = node.prev;
  if (next) {
    next.prev = prev;
  }
  if (prev) {
    prev.next = next;
  }
  if (node === this.head) {
    this.head = next;
  }
  if (node === this.tail) {
    this.tail = prev;
  }
  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;
  return next;
};
Yallist$1.prototype.unshiftNode = function(node) {
  if (node === this.head) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var head = this.head;
  node.list = this;
  node.next = head;
  if (head) {
    head.prev = node;
  }
  this.head = node;
  if (!this.tail) {
    this.tail = node;
  }
  this.length++;
};
Yallist$1.prototype.pushNode = function(node) {
  if (node === this.tail) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var tail = this.tail;
  node.list = this;
  node.prev = tail;
  if (tail) {
    tail.next = node;
  }
  this.tail = node;
  if (!this.head) {
    this.head = node;
  }
  this.length++;
};
Yallist$1.prototype.push = function() {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i]);
  }
  return this.length;
};
Yallist$1.prototype.unshift = function() {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i]);
  }
  return this.length;
};
Yallist$1.prototype.pop = function() {
  if (!this.tail) {
    return void 0;
  }
  var res = this.tail.value;
  this.tail = this.tail.prev;
  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.shift = function() {
  if (!this.head) {
    return void 0;
  }
  var res = this.head.value;
  this.head = this.head.next;
  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.forEach = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.next;
  }
};
Yallist$1.prototype.forEachReverse = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.prev;
  }
};
Yallist$1.prototype.get = function(n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    walker = walker.next;
  }
  if (i === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.getReverse = function(n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    walker = walker.prev;
  }
  if (i === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.map = function(fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.head; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }
  return res;
};
Yallist$1.prototype.mapReverse = function(fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.tail; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }
  return res;
};
Yallist$1.prototype.reduce = function(fn, initial) {
  var acc;
  var walker = this.head;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i);
    walker = walker.next;
  }
  return acc;
};
Yallist$1.prototype.reduceReverse = function(fn, initial) {
  var acc;
  var walker = this.tail;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i);
    walker = walker.prev;
  }
  return acc;
};
Yallist$1.prototype.toArray = function() {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.next;
  }
  return arr;
};
Yallist$1.prototype.toArrayReverse = function() {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.prev;
  }
  return arr;
};
Yallist$1.prototype.slice = function(from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next;
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.sliceReverse = function(from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev;
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.splice = function(start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1;
  }
  if (start < 0) {
    start = this.length + start;
  }
  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next;
  }
  var ret = [];
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }
  if (walker === null) {
    walker = this.tail;
  }
  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }
  for (var i = 0; i < nodes.length; i++) {
    walker = insert(this, walker, nodes[i]);
  }
  return ret;
};
Yallist$1.prototype.reverse = function() {
  var head = this.head;
  var tail = this.tail;
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }
  this.head = tail;
  this.tail = head;
  return this;
};
function insert(self2, node, value) {
  var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
  if (inserted.next === null) {
    self2.tail = inserted;
  }
  if (inserted.prev === null) {
    self2.head = inserted;
  }
  self2.length++;
  return inserted;
}
function push(self2, item) {
  self2.tail = new Node(item, self2.tail, null, self2);
  if (!self2.head) {
    self2.head = self2.tail;
  }
  self2.length++;
}
function unshift(self2, item) {
  self2.head = new Node(item, null, self2.head, self2);
  if (!self2.tail) {
    self2.tail = self2.head;
  }
  self2.length++;
}
function Node(value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list);
  }
  this.list = list;
  this.value = value;
  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }
  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}
try {
  requireIterator()(Yallist$1);
} catch (er) {
}
const Yallist = yallist;
const MAX = Symbol("max");
const LENGTH = Symbol("length");
const LENGTH_CALCULATOR = Symbol("lengthCalculator");
const ALLOW_STALE = Symbol("allowStale");
const MAX_AGE = Symbol("maxAge");
const DISPOSE = Symbol("dispose");
const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
const LRU_LIST = Symbol("lruList");
const CACHE = Symbol("cache");
const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
const naiveLength = () => 1;
class LRUCache {
  constructor(options) {
    if (typeof options === "number")
      options = { max: options };
    if (!options)
      options = {};
    if (options.max && (typeof options.max !== "number" || options.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[MAX] = options.max || Infinity;
    const lc = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  }
  // resize the cache when the max changes.
  set max(mL) {
    if (typeof mL !== "number" || mL < 0)
      throw new TypeError("max must be a non-negative number");
    this[MAX] = mL || Infinity;
    trim(this);
  }
  get max() {
    return this[MAX];
  }
  set allowStale(allowStale) {
    this[ALLOW_STALE] = !!allowStale;
  }
  get allowStale() {
    return this[ALLOW_STALE];
  }
  set maxAge(mA) {
    if (typeof mA !== "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[MAX_AGE] = mA;
    trim(this);
  }
  get maxAge() {
    return this[MAX_AGE];
  }
  // resize the cache when the lengthCalculator changes.
  set lengthCalculator(lC) {
    if (typeof lC !== "function")
      lC = naiveLength;
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC;
      this[LENGTH] = 0;
      this[LRU_LIST].forEach((hit) => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
        this[LENGTH] += hit.length;
      });
    }
    trim(this);
  }
  get lengthCalculator() {
    return this[LENGTH_CALCULATOR];
  }
  get length() {
    return this[LENGTH];
  }
  get itemCount() {
    return this[LRU_LIST].length;
  }
  rforEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].tail; walker !== null; ) {
      const prev = walker.prev;
      forEachStep(this, fn, walker, thisp);
      walker = prev;
    }
  }
  forEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].head; walker !== null; ) {
      const next = walker.next;
      forEachStep(this, fn, walker, thisp);
      walker = next;
    }
  }
  keys() {
    return this[LRU_LIST].toArray().map((k) => k.key);
  }
  values() {
    return this[LRU_LIST].toArray().map((k) => k.value);
  }
  reset() {
    if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
      this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
    }
    this[CACHE] = /* @__PURE__ */ new Map();
    this[LRU_LIST] = new Yallist();
    this[LENGTH] = 0;
  }
  dump() {
    return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
      k: hit.key,
      v: hit.value,
      e: hit.now + (hit.maxAge || 0)
    }).toArray().filter((h) => h);
  }
  dumpLru() {
    return this[LRU_LIST];
  }
  set(key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE];
    if (maxAge && typeof maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    const now = maxAge ? Date.now() : 0;
    const len = this[LENGTH_CALCULATOR](value, key);
    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key));
        return false;
      }
      const node = this[CACHE].get(key);
      const item = node.value;
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value);
      }
      item.now = now;
      item.maxAge = maxAge;
      item.value = value;
      this[LENGTH] += len - item.length;
      item.length = len;
      this.get(key);
      trim(this);
      return true;
    }
    const hit = new Entry(key, value, len, now, maxAge);
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value);
      return false;
    }
    this[LENGTH] += hit.length;
    this[LRU_LIST].unshift(hit);
    this[CACHE].set(key, this[LRU_LIST].head);
    trim(this);
    return true;
  }
  has(key) {
    if (!this[CACHE].has(key))
      return false;
    const hit = this[CACHE].get(key).value;
    return !isStale(this, hit);
  }
  get(key) {
    return get(this, key, true);
  }
  peek(key) {
    return get(this, key, false);
  }
  pop() {
    const node = this[LRU_LIST].tail;
    if (!node)
      return null;
    del(this, node);
    return node.value;
  }
  del(key) {
    del(this, this[CACHE].get(key));
  }
  load(arr) {
    this.reset();
    const now = Date.now();
    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l];
      const expiresAt = hit.e || 0;
      if (expiresAt === 0)
        this.set(hit.k, hit.v);
      else {
        const maxAge = expiresAt - now;
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge);
        }
      }
    }
  }
  prune() {
    this[CACHE].forEach((value, key) => get(this, key, false));
  }
}
const get = (self2, key, doUse) => {
  const node = self2[CACHE].get(key);
  if (node) {
    const hit = node.value;
    if (isStale(self2, hit)) {
      del(self2, node);
      if (!self2[ALLOW_STALE])
        return void 0;
    } else {
      if (doUse) {
        if (self2[UPDATE_AGE_ON_GET])
          node.value.now = Date.now();
        self2[LRU_LIST].unshiftNode(node);
      }
    }
    return hit.value;
  }
};
const isStale = (self2, hit) => {
  if (!hit || !hit.maxAge && !self2[MAX_AGE])
    return false;
  const diff2 = Date.now() - hit.now;
  return hit.maxAge ? diff2 > hit.maxAge : self2[MAX_AGE] && diff2 > self2[MAX_AGE];
};
const trim = (self2) => {
  if (self2[LENGTH] > self2[MAX]) {
    for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
      const prev = walker.prev;
      del(self2, walker);
      walker = prev;
    }
  }
};
const del = (self2, node) => {
  if (node) {
    const hit = node.value;
    if (self2[DISPOSE])
      self2[DISPOSE](hit.key, hit.value);
    self2[LENGTH] -= hit.length;
    self2[CACHE].delete(hit.key);
    self2[LRU_LIST].removeNode(node);
  }
};
class Entry {
  constructor(key, value, length, now, maxAge) {
    this.key = key;
    this.value = value;
    this.length = length;
    this.now = now;
    this.maxAge = maxAge || 0;
  }
}
const forEachStep = (self2, fn, node, thisp) => {
  let hit = node.value;
  if (isStale(self2, hit)) {
    del(self2, node);
    if (!self2[ALLOW_STALE])
      hit = void 0;
  }
  if (hit)
    fn.call(thisp, hit.value, hit.key, self2);
};
var lruCache = LRUCache;
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange)
    return range;
  hasRequiredRange = 1;
  class Range2 {
    constructor(range2, options) {
      options = parseOptions2(options);
      if (range2 instanceof Range2) {
        if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
          return range2;
        } else {
          return new Range2(range2.raw, options);
        }
      }
      if (range2 instanceof Comparator2) {
        this.raw = range2.value;
        this.set = [[range2]];
        this.format();
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range2;
      this.set = range2.split(/\s*\|\|\s*/).map((range3) => this.parseRange(range3.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${range2}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0)
          this.set = [first];
        else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.format();
    }
    format() {
      this.range = this.set.map((comps) => {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range2) {
      range2 = range2.trim();
      const memoOpts = Object.keys(this.options).join(",");
      const memoKey = `parseRange:${memoOpts}:${range2}`;
      const cached = cache.get(memoKey);
      if (cached)
        return cached;
      const loose = this.options.loose;
      const hr = loose ? re2[t2.HYPHENRANGELOOSE] : re2[t2.HYPHENRANGE];
      range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug2("hyphen replace", range2);
      range2 = range2.replace(re2[t2.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range2, re2[t2.COMPARATORTRIM]);
      range2 = range2.replace(re2[t2.TILDETRIM], tildeTrimReplace);
      range2 = range2.replace(re2[t2.CARETTRIM], caretTrimReplace);
      range2 = range2.split(/\s+/).join(" ");
      const compRe = loose ? re2[t2.COMPARATORLOOSE] : re2[t2.COMPARATOR];
      const rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator2(comp, this.options));
      rangeList.length;
      const rangeMap = /* @__PURE__ */ new Map();
      for (const comp of rangeList) {
        if (isNullSet(comp))
          return [comp];
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has(""))
        rangeMap.delete("");
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range2, options) {
      if (!(range2 instanceof Range2)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer3(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range = Range2;
  const LRU = lruCache;
  const cache = new LRU({ max: 1e3 });
  const parseOptions2 = parseOptions_1;
  const Comparator2 = requireComparator();
  const debug2 = debug_1;
  const SemVer3 = semver$1;
  const {
    re: re2,
    t: t2,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = reExports;
  const isNullSet = (c) => c.value === "<0.0.0-0";
  const isAny = (c) => c.value === "";
  const isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  const parseComparator = (comp, options) => {
    debug2("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug2("caret", comp);
    comp = replaceTildes(comp, options);
    debug2("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug2("xrange", comp);
    comp = replaceStars(comp, options);
    debug2("stars", comp);
    return comp;
  };
  const isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
  const replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
    return replaceTilde(comp2, options);
  }).join(" ");
  const replaceTilde = (comp, options) => {
    const r = options.loose ? re2[t2.TILDELOOSE] : re2[t2.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug2("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug2("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug2("tilde return", ret);
      return ret;
    });
  };
  const replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
    return replaceCaret(comp2, options);
  }).join(" ");
  const replaceCaret = (comp, options) => {
    debug2("caret", comp, options);
    const r = options.loose ? re2[t2.CARETLOOSE] : re2[t2.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug2("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug2("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug2("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug2("caret return", ret);
      return ret;
    });
  };
  const replaceXRanges = (comp, options) => {
    debug2("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((comp2) => {
      return replaceXRange(comp2, options);
    }).join(" ");
  };
  const replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re2[t2.XRANGELOOSE] : re2[t2.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug2("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<")
          pr = "-0";
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug2("xRange return", ret);
      return ret;
    });
  };
  const replaceStars = (comp, options) => {
    debug2("replaceStars", comp, options);
    return comp.trim().replace(re2[t2.STAR], "");
  };
  const replaceGTE0 = (comp, options) => {
    debug2("replaceGTE0", comp, options);
    return comp.trim().replace(re2[options.includePrerelease ? t2.GTE0PRE : t2.GTE0], "");
  };
  const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  const testSet = (set, version, options) => {
    for (let i = 0; i < set.length; i++) {
      if (!set[i].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (let i = 0; i < set.length; i++) {
        debug2(set[i].semver);
        if (set[i].semver === Comparator2.ANY) {
          continue;
        }
        if (set[i].semver.prerelease.length > 0) {
          const allowed = set[i].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range;
}
var comparator;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator)
    return comparator;
  hasRequiredComparator = 1;
  const ANY2 = Symbol("SemVer ANY");
  class Comparator2 {
    static get ANY() {
      return ANY2;
    }
    constructor(comp, options) {
      options = parseOptions2(options);
      if (comp instanceof Comparator2) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      debug2("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY2) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re2[t2.COMPARATORLOOSE] : re2[t2.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY2;
      } else {
        this.semver = new SemVer3(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version) {
      debug2("Comparator.test", version, this.options.loose);
      if (this.semver === ANY2 || version === ANY2) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer3(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp2(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator2)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range2(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range2(this.value, options).test(comp.semver);
      }
      const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      const sameSemVer = this.semver.version === comp.semver.version;
      const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      const oppositeDirectionsLessThan = cmp2(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
      const oppositeDirectionsGreaterThan = cmp2(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    }
  }
  comparator = Comparator2;
  const parseOptions2 = parseOptions_1;
  const { re: re2, t: t2 } = reExports;
  const cmp2 = cmp_1;
  const debug2 = debug_1;
  const SemVer3 = semver$1;
  const Range2 = requireRange();
  return comparator;
}
const Range$8 = requireRange();
const satisfies$3 = (version, range2, options) => {
  try {
    range2 = new Range$8(range2, options);
  } catch (er) {
    return false;
  }
  return range2.test(version);
};
var satisfies_1 = satisfies$3;
const Range$7 = requireRange();
const toComparators = (range2, options) => new Range$7(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
var toComparators_1 = toComparators;
const SemVer$3 = semver$1;
const Range$6 = requireRange();
const maxSatisfying = (versions, range2, options) => {
  let max = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$6(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!max || maxSV.compare(v) === -1) {
        max = v;
        maxSV = new SemVer$3(max, options);
      }
    }
  });
  return max;
};
var maxSatisfying_1 = maxSatisfying;
const SemVer$2 = semver$1;
const Range$5 = requireRange();
const minSatisfying = (versions, range2, options) => {
  let min = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$5(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!min || minSV.compare(v) === 1) {
        min = v;
        minSV = new SemVer$2(min, options);
      }
    }
  });
  return min;
};
var minSatisfying_1 = minSatisfying;
const SemVer$1 = semver$1;
const Range$4 = requireRange();
const gt$1 = gt_1;
const minVersion = (range2, loose) => {
  range2 = new Range$4(range2, loose);
  let minver = new SemVer$1("0.0.0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = new SemVer$1("0.0.0-0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = null;
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let setMin = null;
    comparators.forEach((comparator2) => {
      const compver = new SemVer$1(comparator2.semver.version);
      switch (comparator2.operator) {
        case ">":
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
        case "":
        case ">=":
          if (!setMin || gt$1(compver, setMin)) {
            setMin = compver;
          }
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${comparator2.operator}`);
      }
    });
    if (setMin && (!minver || gt$1(minver, setMin)))
      minver = setMin;
  }
  if (minver && range2.test(minver)) {
    return minver;
  }
  return null;
};
var minVersion_1 = minVersion;
const Range$3 = requireRange();
const validRange = (range2, options) => {
  try {
    return new Range$3(range2, options).range || "*";
  } catch (er) {
    return null;
  }
};
var valid = validRange;
const SemVer2 = semver$1;
const Comparator$1 = requireComparator();
const { ANY: ANY$1 } = Comparator$1;
const Range$2 = requireRange();
const satisfies$2 = satisfies_1;
const gt = gt_1;
const lt = lt_1;
const lte = lte_1;
const gte = gte_1;
const outside$2 = (version, range2, hilo, options) => {
  version = new SemVer2(version, options);
  range2 = new Range$2(range2, options);
  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case ">":
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = ">";
      ecomp = ">=";
      break;
    case "<":
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = "<";
      ecomp = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (satisfies$2(version, range2, options)) {
    return false;
  }
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let high = null;
    let low = null;
    comparators.forEach((comparator2) => {
      if (comparator2.semver === ANY$1) {
        comparator2 = new Comparator$1(">=0.0.0");
      }
      high = high || comparator2;
      low = low || comparator2;
      if (gtfn(comparator2.semver, high.semver, options)) {
        high = comparator2;
      } else if (ltfn(comparator2.semver, low.semver, options)) {
        low = comparator2;
      }
    });
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }
    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }
  return true;
};
var outside_1 = outside$2;
const outside$1 = outside_1;
const gtr = (version, range2, options) => outside$1(version, range2, ">", options);
var gtr_1 = gtr;
const outside = outside_1;
const ltr = (version, range2, options) => outside(version, range2, "<", options);
var ltr_1 = ltr;
const Range$1 = requireRange();
const intersects = (r1, r2, options) => {
  r1 = new Range$1(r1, options);
  r2 = new Range$1(r2, options);
  return r1.intersects(r2);
};
var intersects_1 = intersects;
const satisfies$1 = satisfies_1;
const compare$1 = compare_1;
var simplify = (versions, range2, options) => {
  const set = [];
  let min = null;
  let prev = null;
  const v = versions.sort((a, b) => compare$1(a, b, options));
  for (const version of v) {
    const included = satisfies$1(version, range2, options);
    if (included) {
      prev = version;
      if (!min)
        min = version;
    } else {
      if (prev) {
        set.push([min, prev]);
      }
      prev = null;
      min = null;
    }
  }
  if (min)
    set.push([min, null]);
  const ranges = [];
  for (const [min2, max] of set) {
    if (min2 === max)
      ranges.push(min2);
    else if (!max && min2 === v[0])
      ranges.push("*");
    else if (!max)
      ranges.push(`>=${min2}`);
    else if (min2 === v[0])
      ranges.push(`<=${max}`);
    else
      ranges.push(`${min2} - ${max}`);
  }
  const simplified = ranges.join(" || ");
  const original = typeof range2.raw === "string" ? range2.raw : String(range2);
  return simplified.length < original.length ? simplified : range2;
};
const Range = requireRange();
const Comparator = requireComparator();
const { ANY } = Comparator;
const satisfies = satisfies_1;
const compare = compare_1;
const subset = (sub, dom, options = {}) => {
  if (sub === dom)
    return true;
  sub = new Range(sub, options);
  dom = new Range(dom, options);
  let sawNonNull = false;
  OUTER:
    for (const simpleSub of sub.set) {
      for (const simpleDom of dom.set) {
        const isSub = simpleSubset(simpleSub, simpleDom, options);
        sawNonNull = sawNonNull || isSub !== null;
        if (isSub)
          continue OUTER;
      }
      if (sawNonNull)
        return false;
    }
  return true;
};
const simpleSubset = (sub, dom, options) => {
  if (sub === dom)
    return true;
  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY)
      return true;
    else if (options.includePrerelease)
      sub = [new Comparator(">=0.0.0-0")];
    else
      sub = [new Comparator(">=0.0.0")];
  }
  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease)
      return true;
    else
      dom = [new Comparator(">=0.0.0")];
  }
  const eqSet = /* @__PURE__ */ new Set();
  let gt2, lt2;
  for (const c of sub) {
    if (c.operator === ">" || c.operator === ">=")
      gt2 = higherGT(gt2, c, options);
    else if (c.operator === "<" || c.operator === "<=")
      lt2 = lowerLT(lt2, c, options);
    else
      eqSet.add(c.semver);
  }
  if (eqSet.size > 1)
    return null;
  let gtltComp;
  if (gt2 && lt2) {
    gtltComp = compare(gt2.semver, lt2.semver, options);
    if (gtltComp > 0)
      return null;
    else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<="))
      return null;
  }
  for (const eq2 of eqSet) {
    if (gt2 && !satisfies(eq2, String(gt2), options))
      return null;
    if (lt2 && !satisfies(eq2, String(lt2), options))
      return null;
    for (const c of dom) {
      if (!satisfies(eq2, String(c), options))
        return false;
    }
    return true;
  }
  let higher, lower;
  let hasDomLT, hasDomGT;
  let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
  let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }
  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
    hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
    if (gt2) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false;
        }
      }
      if (c.operator === ">" || c.operator === ">=") {
        higher = higherGT(gt2, c, options);
        if (higher === c && higher !== gt2)
          return false;
      } else if (gt2.operator === ">=" && !satisfies(gt2.semver, String(c), options))
        return false;
    }
    if (lt2) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false;
        }
      }
      if (c.operator === "<" || c.operator === "<=") {
        lower = lowerLT(lt2, c, options);
        if (lower === c && lower !== lt2)
          return false;
      } else if (lt2.operator === "<=" && !satisfies(lt2.semver, String(c), options))
        return false;
    }
    if (!c.operator && (lt2 || gt2) && gtltComp !== 0)
      return false;
  }
  if (gt2 && hasDomLT && !lt2 && gtltComp !== 0)
    return false;
  if (lt2 && hasDomGT && !gt2 && gtltComp !== 0)
    return false;
  if (needDomGTPre || needDomLTPre)
    return false;
  return true;
};
const higherGT = (a, b, options) => {
  if (!a)
    return b;
  const comp = compare(a.semver, b.semver, options);
  return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
};
const lowerLT = (a, b, options) => {
  if (!a)
    return b;
  const comp = compare(a.semver, b.semver, options);
  return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
};
var subset_1 = subset;
const internalRe = reExports;
var semver = {
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  SemVer: semver$1,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers,
  parse: parse_1,
  valid: valid_1,
  clean: clean_1,
  inc: inc_1,
  diff: diff_1,
  major: major_1,
  minor: minor_1,
  patch: patch_1,
  prerelease: prerelease_1,
  compare: compare_1,
  rcompare: rcompare_1,
  compareLoose: compareLoose_1,
  compareBuild: compareBuild_1,
  sort: sort_1,
  rsort: rsort_1,
  gt: gt_1,
  lt: lt_1,
  eq: eq_1,
  neq: neq_1,
  gte: gte_1,
  lte: lte_1,
  cmp: cmp_1,
  coerce: coerce_1,
  Comparator: requireComparator(),
  Range: requireRange(),
  satisfies: satisfies_1,
  toComparators: toComparators_1,
  maxSatisfying: maxSatisfying_1,
  minSatisfying: minSatisfying_1,
  minVersion: minVersion_1,
  validRange: valid,
  outside: outside_1,
  gtr: gtr_1,
  ltr: ltr_1,
  intersects: intersects_1,
  simplifyRange: simplify,
  subset: subset_1
};
var onetime$1 = { exports: {} };
var mimicFn$2 = { exports: {} };
const mimicFn$1 = (to, from) => {
  for (const prop of Reflect.ownKeys(from)) {
    Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
  }
  return to;
};
mimicFn$2.exports = mimicFn$1;
mimicFn$2.exports.default = mimicFn$1;
var mimicFnExports = mimicFn$2.exports;
const mimicFn = mimicFnExports;
const calledFunctions = /* @__PURE__ */ new WeakMap();
const onetime = (function_, options = {}) => {
  if (typeof function_ !== "function") {
    throw new TypeError("Expected a function");
  }
  let returnValue;
  let callCount = 0;
  const functionName = function_.displayName || function_.name || "<anonymous>";
  const onetime2 = function(...arguments_) {
    calledFunctions.set(onetime2, ++callCount);
    if (callCount === 1) {
      returnValue = function_.apply(this, arguments_);
      function_ = null;
    } else if (options.throw === true) {
      throw new Error(`Function \`${functionName}\` can only be called once`);
    }
    return returnValue;
  };
  mimicFn(onetime2, function_);
  calledFunctions.set(onetime2, callCount);
  return onetime2;
};
onetime$1.exports = onetime;
onetime$1.exports.default = onetime;
onetime$1.exports.callCount = (function_) => {
  if (!calledFunctions.has(function_)) {
    throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
  }
  return calledFunctions.get(function_);
};
var onetimeExports = onetime$1.exports;
(function(module2, exports2) {
  var __classPrivateFieldSet = commonjsGlobal && commonjsGlobal.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = commonjsGlobal && commonjsGlobal.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _a, _b;
  var _Conf_validator, _Conf_encryptionKey, _Conf_options, _Conf_defaultValues;
  Object.defineProperty(exports2, "__esModule", { value: true });
  const util_12 = require$$4;
  const fs2 = require$$0$3;
  const path2 = require$$1;
  const crypto = require$$3$1;
  const assert = require$$5;
  const events_1 = require$$5$1;
  const dotProp$1 = dotProp;
  const pkgUp2 = pkgUpExports;
  const envPaths2 = envPathsExports;
  const atomically = dist$1;
  const ajv_1 = ajvExports;
  const ajv_formats_1 = distExports;
  const debounceFn$1 = debounceFn;
  const semver$12 = semver;
  const onetime2 = onetimeExports;
  const encryptionAlgorithm = "aes-256-cbc";
  const createPlainObject = () => {
    return /* @__PURE__ */ Object.create(null);
  };
  const isExist = (data) => {
    return data !== void 0 && data !== null;
  };
  let parentDir = "";
  try {
    delete require.cache[__filename];
    parentDir = path2.dirname((_b = (_a = module2.parent) === null || _a === void 0 ? void 0 : _a.filename) !== null && _b !== void 0 ? _b : ".");
  } catch (_c) {
  }
  const checkValueType = (key, value) => {
    const nonJsonTypes = /* @__PURE__ */ new Set([
      "undefined",
      "symbol",
      "function"
    ]);
    const type2 = typeof value;
    if (nonJsonTypes.has(type2)) {
      throw new TypeError(`Setting a value of type \`${type2}\` for key \`${key}\` is not allowed as it's not supported by JSON`);
    }
  };
  const INTERNAL_KEY = "__internal__";
  const MIGRATION_KEY = `${INTERNAL_KEY}.migrations.version`;
  class Conf2 {
    constructor(partialOptions = {}) {
      var _a2;
      _Conf_validator.set(this, void 0);
      _Conf_encryptionKey.set(this, void 0);
      _Conf_options.set(this, void 0);
      _Conf_defaultValues.set(this, {});
      this._deserialize = (value) => JSON.parse(value);
      this._serialize = (value) => JSON.stringify(value, void 0, "	");
      const options = {
        configName: "config",
        fileExtension: "json",
        projectSuffix: "nodejs",
        clearInvalidConfig: false,
        accessPropertiesByDotNotation: true,
        ...partialOptions
      };
      const getPackageData = onetime2(() => {
        const packagePath = pkgUp2.sync({ cwd: parentDir });
        const packageData = packagePath && JSON.parse(fs2.readFileSync(packagePath, "utf8"));
        return packageData !== null && packageData !== void 0 ? packageData : {};
      });
      if (!options.cwd) {
        if (!options.projectName) {
          options.projectName = getPackageData().name;
        }
        if (!options.projectName) {
          throw new Error("Project name could not be inferred. Please specify the `projectName` option.");
        }
        options.cwd = envPaths2(options.projectName, { suffix: options.projectSuffix }).config;
      }
      __classPrivateFieldSet(this, _Conf_options, options, "f");
      if (options.schema) {
        if (typeof options.schema !== "object") {
          throw new TypeError("The `schema` option must be an object.");
        }
        const ajv2 = new ajv_1.default({
          allErrors: true,
          useDefaults: true
        });
        ajv_formats_1.default(ajv2);
        const schema2 = {
          type: "object",
          properties: options.schema
        };
        __classPrivateFieldSet(this, _Conf_validator, ajv2.compile(schema2), "f");
        for (const [key, value] of Object.entries(options.schema)) {
          if (value === null || value === void 0 ? void 0 : value.default) {
            __classPrivateFieldGet(this, _Conf_defaultValues, "f")[key] = value.default;
          }
        }
      }
      if (options.defaults) {
        __classPrivateFieldSet(this, _Conf_defaultValues, {
          ...__classPrivateFieldGet(this, _Conf_defaultValues, "f"),
          ...options.defaults
        }, "f");
      }
      if (options.serialize) {
        this._serialize = options.serialize;
      }
      if (options.deserialize) {
        this._deserialize = options.deserialize;
      }
      this.events = new events_1.EventEmitter();
      __classPrivateFieldSet(this, _Conf_encryptionKey, options.encryptionKey, "f");
      const fileExtension = options.fileExtension ? `.${options.fileExtension}` : "";
      this.path = path2.resolve(options.cwd, `${(_a2 = options.configName) !== null && _a2 !== void 0 ? _a2 : "config"}${fileExtension}`);
      const fileStore = this.store;
      const store2 = Object.assign(createPlainObject(), options.defaults, fileStore);
      this._validate(store2);
      try {
        assert.deepEqual(fileStore, store2);
      } catch (_b2) {
        this.store = store2;
      }
      if (options.watch) {
        this._watch();
      }
      if (options.migrations) {
        if (!options.projectVersion) {
          options.projectVersion = getPackageData().version;
        }
        if (!options.projectVersion) {
          throw new Error("Project version could not be inferred. Please specify the `projectVersion` option.");
        }
        this._migrate(options.migrations, options.projectVersion);
      }
    }
    get(key, defaultValue) {
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        return this._get(key, defaultValue);
      }
      const { store: store2 } = this;
      return key in store2 ? store2[key] : defaultValue;
    }
    set(key, value) {
      if (typeof key !== "string" && typeof key !== "object") {
        throw new TypeError(`Expected \`key\` to be of type \`string\` or \`object\`, got ${typeof key}`);
      }
      if (typeof key !== "object" && value === void 0) {
        throw new TypeError("Use `delete()` to clear values");
      }
      if (this._containsReservedKey(key)) {
        throw new TypeError(`Please don't use the ${INTERNAL_KEY} key, as it's used to manage this module internal operations.`);
      }
      const { store: store2 } = this;
      const set = (key2, value2) => {
        checkValueType(key2, value2);
        if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
          dotProp$1.set(store2, key2, value2);
        } else {
          store2[key2] = value2;
        }
      };
      if (typeof key === "object") {
        const object = key;
        for (const [key2, value2] of Object.entries(object)) {
          set(key2, value2);
        }
      } else {
        set(key, value);
      }
      this.store = store2;
    }
    /**
    	    Check if an item exists.
    
    	    @param key - The key of the item to check.
    	    */
    has(key) {
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        return dotProp$1.has(this.store, key);
      }
      return key in this.store;
    }
    /**
    	    Reset items to their default values, as defined by the `defaults` or `schema` option.
    
    	    @see `clear()` to reset all items.
    
    	    @param keys - The keys of the items to reset.
    	    */
    reset(...keys) {
      for (const key of keys) {
        if (isExist(__classPrivateFieldGet(this, _Conf_defaultValues, "f")[key])) {
          this.set(key, __classPrivateFieldGet(this, _Conf_defaultValues, "f")[key]);
        }
      }
    }
    /**
    	    Delete an item.
    
    	    @param key - The key of the item to delete.
    	    */
    delete(key) {
      const { store: store2 } = this;
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        dotProp$1.delete(store2, key);
      } else {
        delete store2[key];
      }
      this.store = store2;
    }
    /**
    	    Delete all items.
    
    	    This resets known items to their default values, if defined by the `defaults` or `schema` option.
    	    */
    clear() {
      this.store = createPlainObject();
      for (const key of Object.keys(__classPrivateFieldGet(this, _Conf_defaultValues, "f"))) {
        this.reset(key);
      }
    }
    /**
    	    Watches the given `key`, calling `callback` on any changes.
    
    	    @param key - The key wo watch.
    	    @param callback - A callback function that is called on any changes. When a `key` is first set `oldValue` will be `undefined`, and when a key is deleted `newValue` will be `undefined`.
    	    @returns A function, that when called, will unsubscribe.
    	    */
    onDidChange(key, callback) {
      if (typeof key !== "string") {
        throw new TypeError(`Expected \`key\` to be of type \`string\`, got ${typeof key}`);
      }
      if (typeof callback !== "function") {
        throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof callback}`);
      }
      return this._handleChange(() => this.get(key), callback);
    }
    /**
    	    Watches the whole config object, calling `callback` on any changes.
    
    	    @param callback - A callback function that is called on any changes. When a `key` is first set `oldValue` will be `undefined`, and when a key is deleted `newValue` will be `undefined`.
    	    @returns A function, that when called, will unsubscribe.
    	    */
    onDidAnyChange(callback) {
      if (typeof callback !== "function") {
        throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof callback}`);
      }
      return this._handleChange(() => this.store, callback);
    }
    get size() {
      return Object.keys(this.store).length;
    }
    get store() {
      try {
        const data = fs2.readFileSync(this.path, __classPrivateFieldGet(this, _Conf_encryptionKey, "f") ? null : "utf8");
        const dataString = this._encryptData(data);
        const deserializedData = this._deserialize(dataString);
        this._validate(deserializedData);
        return Object.assign(createPlainObject(), deserializedData);
      } catch (error2) {
        if (error2.code === "ENOENT") {
          this._ensureDirectory();
          return createPlainObject();
        }
        if (__classPrivateFieldGet(this, _Conf_options, "f").clearInvalidConfig && error2.name === "SyntaxError") {
          return createPlainObject();
        }
        throw error2;
      }
    }
    set store(value) {
      this._ensureDirectory();
      this._validate(value);
      this._write(value);
      this.events.emit("change");
    }
    *[(_Conf_validator = /* @__PURE__ */ new WeakMap(), _Conf_encryptionKey = /* @__PURE__ */ new WeakMap(), _Conf_options = /* @__PURE__ */ new WeakMap(), _Conf_defaultValues = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
      for (const [key, value] of Object.entries(this.store)) {
        yield [key, value];
      }
    }
    _encryptData(data) {
      if (!__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
        return data.toString();
      }
      try {
        if (__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
          try {
            if (data.slice(16, 17).toString() === ":") {
              const initializationVector = data.slice(0, 16);
              const password = crypto.pbkdf2Sync(__classPrivateFieldGet(this, _Conf_encryptionKey, "f"), initializationVector.toString(), 1e4, 32, "sha512");
              const decipher = crypto.createDecipheriv(encryptionAlgorithm, password, initializationVector);
              data = Buffer.concat([decipher.update(Buffer.from(data.slice(17))), decipher.final()]).toString("utf8");
            } else {
              const decipher = crypto.createDecipher(encryptionAlgorithm, __classPrivateFieldGet(this, _Conf_encryptionKey, "f"));
              data = Buffer.concat([decipher.update(Buffer.from(data)), decipher.final()]).toString("utf8");
            }
          } catch (_a2) {
          }
        }
      } catch (_b2) {
      }
      return data.toString();
    }
    _handleChange(getter, callback) {
      let currentValue = getter();
      const onChange = () => {
        const oldValue = currentValue;
        const newValue = getter();
        if (util_12.isDeepStrictEqual(newValue, oldValue)) {
          return;
        }
        currentValue = newValue;
        callback.call(this, newValue, oldValue);
      };
      this.events.on("change", onChange);
      return () => this.events.removeListener("change", onChange);
    }
    _validate(data) {
      if (!__classPrivateFieldGet(this, _Conf_validator, "f")) {
        return;
      }
      const valid2 = __classPrivateFieldGet(this, _Conf_validator, "f").call(this, data);
      if (valid2 || !__classPrivateFieldGet(this, _Conf_validator, "f").errors) {
        return;
      }
      const errors2 = __classPrivateFieldGet(this, _Conf_validator, "f").errors.map(({ instancePath, message = "" }) => `\`${instancePath.slice(1)}\` ${message}`);
      throw new Error("Config schema violation: " + errors2.join("; "));
    }
    _ensureDirectory() {
      fs2.mkdirSync(path2.dirname(this.path), { recursive: true });
    }
    _write(value) {
      let data = this._serialize(value);
      if (__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
        const initializationVector = crypto.randomBytes(16);
        const password = crypto.pbkdf2Sync(__classPrivateFieldGet(this, _Conf_encryptionKey, "f"), initializationVector.toString(), 1e4, 32, "sha512");
        const cipher = crypto.createCipheriv(encryptionAlgorithm, password, initializationVector);
        data = Buffer.concat([initializationVector, Buffer.from(":"), cipher.update(Buffer.from(data)), cipher.final()]);
      }
      if (process.env.SNAP) {
        fs2.writeFileSync(this.path, data);
      } else {
        try {
          atomically.writeFileSync(this.path, data);
        } catch (error2) {
          if (error2.code === "EXDEV") {
            fs2.writeFileSync(this.path, data);
            return;
          }
          throw error2;
        }
      }
    }
    _watch() {
      this._ensureDirectory();
      if (!fs2.existsSync(this.path)) {
        this._write(createPlainObject());
      }
      if (process.platform === "win32") {
        fs2.watch(this.path, { persistent: false }, debounceFn$1(() => {
          this.events.emit("change");
        }, { wait: 100 }));
      } else {
        fs2.watchFile(this.path, { persistent: false }, debounceFn$1(() => {
          this.events.emit("change");
        }, { wait: 5e3 }));
      }
    }
    _migrate(migrations, versionToMigrate) {
      let previousMigratedVersion = this._get(MIGRATION_KEY, "0.0.0");
      const newerVersions = Object.keys(migrations).filter((candidateVersion) => this._shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate));
      let storeBackup = { ...this.store };
      for (const version of newerVersions) {
        try {
          const migration = migrations[version];
          migration(this);
          this._set(MIGRATION_KEY, version);
          previousMigratedVersion = version;
          storeBackup = { ...this.store };
        } catch (error2) {
          this.store = storeBackup;
          throw new Error(`Something went wrong during the migration! Changes applied to the store until this failed migration will be restored. ${error2}`);
        }
      }
      if (this._isVersionInRangeFormat(previousMigratedVersion) || !semver$12.eq(previousMigratedVersion, versionToMigrate)) {
        this._set(MIGRATION_KEY, versionToMigrate);
      }
    }
    _containsReservedKey(key) {
      if (typeof key === "object") {
        const firsKey = Object.keys(key)[0];
        if (firsKey === INTERNAL_KEY) {
          return true;
        }
      }
      if (typeof key !== "string") {
        return false;
      }
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        if (key.startsWith(`${INTERNAL_KEY}.`)) {
          return true;
        }
        return false;
      }
      return false;
    }
    _isVersionInRangeFormat(version) {
      return semver$12.clean(version) === null;
    }
    _shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate) {
      if (this._isVersionInRangeFormat(candidateVersion)) {
        if (previousMigratedVersion !== "0.0.0" && semver$12.satisfies(previousMigratedVersion, candidateVersion)) {
          return false;
        }
        return semver$12.satisfies(versionToMigrate, candidateVersion);
      }
      if (semver$12.lte(candidateVersion, previousMigratedVersion)) {
        return false;
      }
      if (semver$12.gt(candidateVersion, versionToMigrate)) {
        return false;
      }
      return true;
    }
    _get(key, defaultValue) {
      return dotProp$1.get(this.store, key, defaultValue);
    }
    _set(key, value) {
      const { store: store2 } = this;
      dotProp$1.set(store2, key, value);
      this.store = store2;
    }
  }
  exports2.default = Conf2;
  module2.exports = Conf2;
  module2.exports.default = Conf2;
})(source, source.exports);
var sourceExports = source.exports;
const path = require$$1;
const { app, ipcMain, ipcRenderer, shell } = require$$0;
const Conf = sourceExports;
let isInitialized = false;
const initDataListener = () => {
  if (!ipcMain || !app) {
    throw new Error("Electron Store: You need to call `.initRenderer()` from the main process.");
  }
  const appData = {
    defaultCwd: app.getPath("userData"),
    appVersion: app.getVersion()
  };
  if (isInitialized) {
    return appData;
  }
  ipcMain.on("electron-store-get-data", (event) => {
    event.returnValue = appData;
  });
  isInitialized = true;
  return appData;
};
class ElectronStore extends Conf {
  constructor(options) {
    let defaultCwd;
    let appVersion;
    if (ipcRenderer) {
      const appData = ipcRenderer.sendSync("electron-store-get-data");
      if (!appData) {
        throw new Error("Electron Store: You need to call `.initRenderer()` from the main process.");
      }
      ({ defaultCwd, appVersion } = appData);
    } else if (ipcMain && app) {
      ({ defaultCwd, appVersion } = initDataListener());
    }
    options = {
      name: "config",
      ...options
    };
    if (!options.projectVersion) {
      options.projectVersion = appVersion;
    }
    if (options.cwd) {
      options.cwd = path.isAbsolute(options.cwd) ? options.cwd : path.join(defaultCwd, options.cwd);
    } else {
      options.cwd = defaultCwd;
    }
    options.configName = options.name;
    delete options.name;
    super(options);
  }
  static initRenderer() {
    initDataListener();
  }
  openInEditor() {
    shell.openPath(this.path);
  }
}
var electronStore = ElectronStore;
const Store = /* @__PURE__ */ getDefaultExportFromCjs(electronStore);
var define_import_meta_env_default$1 = { VITE_DEV_SERVER_URL: "http://localhost:5173/", BASE_URL: "/", MODE: "development", DEV: true, PROD: false, SSR: false };
const schema$1 = {
  notes: {
    type: "object",
    patternProperties: {
      "[A-Za-z0-9_-]": {
        type: "object",
        properties: {
          id: { type: "string", default: "" },
          title: { type: "string", default: "" },
          content: { type: "object", default: { type: "doc", content: [] } },
          labels: { type: "array", default: [] },
          createdAt: { type: "number", default: Date.now() },
          updatedAt: { type: "number", default: Date.now() },
          isBookmarked: { type: "boolean", default: false },
          isArchived: { type: "boolean", default: false },
          lastCursorPosition: { type: "number", default: 0 }
        }
      }
    }
  },
  labels: {
    type: "array"
  }
};
const store$1 = new Store({
  schema: schema$1,
  encryptionKey: define_import_meta_env_default$1.VITE_ENCRYPT_KEY
});
const schema = {
  dataDir: {
    type: "string",
    default: require$$0.app.getPath("userData")
  }
};
const settings = new Store({ name: "settings", schema, encryptionKey: process.env.VITE_ENCRYPT_KEY });
const store = {
  data: store$1,
  settings
};
var define_import_meta_env_default = { VITE_DEV_SERVER_URL: "http://localhost:5173/", BASE_URL: "/", MODE: "development", DEV: true, PROD: false, SSR: false };
const isSingleInstance = require$$0.app.requestSingleInstanceLock();
if (!isSingleInstance) {
  require$$0.app.quit();
  process.exit(0);
}
require$$0.app.disableHardwareAcceleration();
const env = define_import_meta_env_default;
let mainWindow = null;
const createWindow = async () => {
  mainWindow = new require$$0.BrowserWindow({
    show: false,
    width: 950,
    height: 600,
    webPreferences: {
      preload: require$$1.join(__dirname, "../../preload/dist/index.cjs"),
      contextIsolation: env.MODE !== "test",
      enableRemoteModule: env.MODE === "test",
      nodeIntegration: true
    }
  });
  mainWindow.setMenuBarVisibility(false);
  mainWindow.on("ready-to-show", () => {
    mainWindow == null ? void 0 : mainWindow.show();
    {
      mainWindow == null ? void 0 : mainWindow.webContents.openDevTools();
    }
  });
  mainWindow == null ? void 0 : mainWindow.webContents.on("new-window", function(event, url) {
    event.preventDefault();
    if (url.startsWith("note://"))
      return;
    require$$0.shell.openExternal(url);
  });
  const pageUrl = env.VITE_DEV_SERVER_URL;
  await mainWindow.loadURL(pageUrl);
};
require$$0.app.on("NSApplicationDelegate.applicationSupportsSecureRestorableState", () => {
  return true;
});
require$$0.app.on("second-instance", () => {
  if (mainWindow) {
    if (mainWindow.isMinimized())
      mainWindow.restore();
    mainWindow.focus();
  }
});
require$$0.app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    require$$0.app.quit();
  }
});
require$$0.app.whenReady().then(async () => {
  require$$0.protocol.registerFileProtocol("assets", (request, callback) => {
    const url = request.url.substr(9);
    const dir = store.settings.get("dataDir");
    const imgPath = `${dir}/notes-assets/${url}`;
    callback({ path: require$$1.normalize(imgPath) });
  });
  await lib.ensureDir(require$$1.join(require$$0.app.getPath("userData"), "notes-assets"));
  await createWindow();
}).catch((e) => console.error("Failed create window:", e));
ipcMain$1.answerRenderer("app:info", () => ({
  name: require$$0.app.getName(),
  version: require$$0.app.getVersion()
}));
ipcMain$1.answerRenderer("dialog:open", (props) => require$$0.dialog.showOpenDialog(props));
ipcMain$1.answerRenderer("dialog:message", (props) => require$$0.dialog.showMessageBox(props));
ipcMain$1.answerRenderer("dialog:save", (props) => require$$0.dialog.showSaveDialog(props));
ipcMain$1.answerRenderer("fs:copy", ({ path: path2, dest }) => lib.copy(path2, dest));
ipcMain$1.answerRenderer("fs:output-json", ({ path: path2, data }) => lib.outputJson(path2, data));
ipcMain$1.answerRenderer("fs:read-json", (path2) => lib.readJson(path2));
ipcMain$1.answerRenderer("fs:ensureDir", (path2) => lib.ensureDir(path2));
ipcMain$1.answerRenderer("fs:pathExists", (path2) => lib.pathExistsSync(path2));
ipcMain$1.answerRenderer("fs:remove", (path2) => lib.remove(path2));
ipcMain$1.answerRenderer("helper:relaunch", (options = {}) => {
  require$$0.app.relaunch({ args: process.argv.slice(1).concat(["--relaunch"]), ...options });
  require$$0.app.exit(0);
});
ipcMain$1.answerRenderer("helper:get-path", (name) => require$$0.app.getPath(name));
ipcMain$1.answerRenderer("helper:is-dark-theme", () => require$$0.nativeTheme.shouldUseDarkColors);
ipcMain$1.answerRenderer("storage:store", (name) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.store;
});
ipcMain$1.answerRenderer("storage:replace", ({ name, data }) => store[name].store = data);
ipcMain$1.answerRenderer("storage:get", ({ name, key, def: def2 }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.get(key, def2);
});
ipcMain$1.answerRenderer("storage:set", ({ name, key, value }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.set(key, value);
});
ipcMain$1.answerRenderer("storage:delete", ({ name, key }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.delete(key);
});
ipcMain$1.answerRenderer("storage:has", ({ name, key }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.has(key);
});
ipcMain$1.answerRenderer("storage:clear", (name) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.clear();
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguY2pzIiwic291cmNlcyI6WyIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tYmV0dGVyLWlwYy9ub2RlX21vZHVsZXMvc2VyaWFsaXplLWVycm9yL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWJldHRlci1pcGMvc291cmNlL3V0aWwuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tYmV0dGVyLWlwYy9zb3VyY2UvbWFpbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1iZXR0ZXItaXBjL3NvdXJjZS9yZW5kZXJlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1iZXR0ZXItaXBjL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3VuaXZlcnNhbGlmeS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9wb2x5ZmlsbHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvbGVnYWN5LXN0cmVhbXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvY2xvbmUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvZ3JhY2VmdWwtZnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2ZzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9ta2RpcnMvdXRpbHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21rZGlycy9tYWtlLWRpci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvbWtkaXJzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9wYXRoLWV4aXN0cy9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvdXRpbC91dGltZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3V0aWwvc3RhdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvY29weS9jb3B5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5L2NvcHktc3luYy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvY29weS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvcmVtb3ZlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbXB0eS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL2ZpbGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9saW5rLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvc3ltbGluay1wYXRocy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL3N5bWxpbmstdHlwZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL3N5bWxpbmsuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qc29uZmlsZS91dGlscy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qc29uZmlsZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvanNvbi9qc29uZmlsZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvb3V0cHV0LWZpbGUvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2pzb24vb3V0cHV0LWpzb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2pzb24vb3V0cHV0LWpzb24tc3luYy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvanNvbi9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvbW92ZS9tb3ZlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9tb3ZlL21vdmUtc3luYy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvbW92ZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvaXMtb2JqL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RvdC1wcm9wL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3BhdGgtZXhpc3RzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3AtdHJ5L2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3AtbGltaXQvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcC1sb2NhdGUvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9jYXRlLXBhdGgvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZmluZC11cC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wa2ctdXAvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZW52LXBhdGhzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC9jb25zdHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL2F0dGVtcHRpZnkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL2ZzX2hhbmRsZXJzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC91dGlscy9yZXRyeWlmeV9xdWV1ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hdG9taWNhbGx5L2Rpc3QvdXRpbHMvcmV0cnlpZnkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL2ZzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC91dGlscy9sYW5nLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC91dGlscy9zY2hlZHVsZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL3RlbXAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvY29kZWdlbi9jb2RlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvY29kZWdlbi9zY29wZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2NvZGVnZW4vaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS91dGlsLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvbmFtZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9lcnJvcnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9ib29sU2NoZW1hLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvcnVsZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9hcHBsaWNhYmlsaXR5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9kZWZhdWx0cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvY29kZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2tleXdvcmQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9zdWJzY2hlbWEuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZmFzdC1kZWVwLWVxdWFsL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLXRyYXZlcnNlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3VyaS1qcy9kaXN0L2VzNS91cmkuYWxsLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvcmVzb2x2ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3JlZl9lcnJvci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvcmUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvcmUvaWQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvcmUvcmVmLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9jb3JlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0TnVtYmVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL211bHRpcGxlT2YuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS91Y3MybGVuZ3RoLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0TGVuZ3RoLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL3BhdHRlcm4uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbGltaXRQcm9wZXJ0aWVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL3JlcXVpcmVkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0SXRlbXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS9lcXVhbC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi91bmlxdWVJdGVtcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9jb25zdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9lbnVtLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FkZGl0aW9uYWxJdGVtcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pdGVtcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wcmVmaXhJdGVtcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pdGVtczIwMjAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvY29udGFpbnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvZGVwZW5kZW5jaWVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3Byb3BlcnR5TmFtZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWRkaXRpb25hbFByb3BlcnRpZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJvcGVydGllcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wYXR0ZXJuUHJvcGVydGllcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9ub3QuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYW55T2YuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3Ivb25lT2YuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWxsT2YuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaWYuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvdGhlbkVsc2UuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Zvcm1hdC9mb3JtYXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Zvcm1hdC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvbWV0YWRhdGEuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2RyYWZ0Ny5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvci90eXBlcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvci9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9hanYuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvZGlzdC9mb3JtYXRzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi1mb3JtYXRzL2Rpc3QvbGltaXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvZGlzdC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZWJvdW5jZS1mbi9ub2RlX21vZHVsZXMvbWltaWMtZm4vaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGVib3VuY2UtZm4vaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2NvbnN0YW50cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvZGVidWcuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL3JlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9wYXJzZS1vcHRpb25zLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9pZGVudGlmaWVycy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9zZW12ZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wYXJzZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3ZhbGlkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY2xlYW4uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9pbmMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZXEuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9kaWZmLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbWFqb3IuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9taW5vci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3BhdGNoLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcHJlcmVsZWFzZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3Jjb21wYXJlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS1sb29zZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUtYnVpbGQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zb3J0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcnNvcnQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9ndC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbmVxLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZ3RlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbHRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY21wLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29lcmNlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3lhbGxpc3QvaXRlcmF0b3IuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMveWFsbGlzdC95YWxsaXN0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9yYW5nZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9jb21wYXJhdG9yLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvdG8tY29tcGFyYXRvcnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9tYXgtc2F0aXNmeWluZy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21pbi1zYXRpc2Z5aW5nLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWluLXZlcnNpb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy92YWxpZC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL291dHNpZGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9ndHIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9sdHIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9pbnRlcnNlY3RzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvc2ltcGxpZnkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zdWJzZXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21pbWljLWZuL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29uZXRpbWUvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9kaXN0L3NvdXJjZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1zdG9yZS9pbmRleC5qcyIsIi4uL3NyYy9zdG9yZS9tb2R1bGVzL2RhdGEuc3RvcmUuanMiLCIuLi9zcmMvc3RvcmUvbW9kdWxlcy9zZXR0aW5ncy5zdG9yZS5qcyIsIi4uL3NyYy9zdG9yZS9pbmRleC5qcyIsIi4uL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNsYXNzIE5vbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG5cdFx0c3VwZXIoTm9uRXJyb3IuX3ByZXBhcmVTdXBlck1lc3NhZ2UobWVzc2FnZSkpO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmFtZScsIHtcblx0XHRcdHZhbHVlOiAnTm9uRXJyb3InLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0d3JpdGFibGU6IHRydWVcblx0XHR9KTtcblxuXHRcdGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuXHRcdFx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgTm9uRXJyb3IpO1xuXHRcdH1cblx0fVxuXG5cdHN0YXRpYyBfcHJlcGFyZVN1cGVyTWVzc2FnZShtZXNzYWdlKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShtZXNzYWdlKTtcblx0XHR9IGNhdGNoIHtcblx0XHRcdHJldHVybiBTdHJpbmcobWVzc2FnZSk7XG5cdFx0fVxuXHR9XG59XG5cbmNvbnN0IGNvbW1vblByb3BlcnRpZXMgPSBbXG5cdHtwcm9wZXJ0eTogJ25hbWUnLCBlbnVtZXJhYmxlOiBmYWxzZX0sXG5cdHtwcm9wZXJ0eTogJ21lc3NhZ2UnLCBlbnVtZXJhYmxlOiBmYWxzZX0sXG5cdHtwcm9wZXJ0eTogJ3N0YWNrJywgZW51bWVyYWJsZTogZmFsc2V9LFxuXHR7cHJvcGVydHk6ICdjb2RlJywgZW51bWVyYWJsZTogdHJ1ZX1cbl07XG5cbmNvbnN0IGlzQ2FsbGVkID0gU3ltYm9sKCcudG9KU09OIGNhbGxlZCcpO1xuXG5jb25zdCB0b0pTT04gPSBmcm9tID0+IHtcblx0ZnJvbVtpc0NhbGxlZF0gPSB0cnVlO1xuXHRjb25zdCBqc29uID0gZnJvbS50b0pTT04oKTtcblx0ZGVsZXRlIGZyb21baXNDYWxsZWRdO1xuXHRyZXR1cm4ganNvbjtcbn07XG5cbmNvbnN0IGRlc3Ryb3lDaXJjdWxhciA9ICh7XG5cdGZyb20sXG5cdHNlZW4sXG5cdHRvXyxcblx0Zm9yY2VFbnVtZXJhYmxlLFxuXHRtYXhEZXB0aCxcblx0ZGVwdGhcbn0pID0+IHtcblx0Y29uc3QgdG8gPSB0b18gfHwgKEFycmF5LmlzQXJyYXkoZnJvbSkgPyBbXSA6IHt9KTtcblxuXHRzZWVuLnB1c2goZnJvbSk7XG5cblx0aWYgKGRlcHRoID49IG1heERlcHRoKSB7XG5cdFx0cmV0dXJuIHRvO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBmcm9tLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJyAmJiBmcm9tW2lzQ2FsbGVkXSAhPT0gdHJ1ZSkge1xuXHRcdHJldHVybiB0b0pTT04oZnJvbSk7XG5cdH1cblxuXHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmcm9tKSkge1xuXHRcdGlmICh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcblx0XHRcdHRvW2tleV0gPSAnW29iamVjdCBCdWZmZXJdJztcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0dG9ba2V5XSA9IHZhbHVlO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0aWYgKCFzZWVuLmluY2x1ZGVzKGZyb21ba2V5XSkpIHtcblx0XHRcdGRlcHRoKys7XG5cblx0XHRcdHRvW2tleV0gPSBkZXN0cm95Q2lyY3VsYXIoe1xuXHRcdFx0XHRmcm9tOiBmcm9tW2tleV0sXG5cdFx0XHRcdHNlZW46IHNlZW4uc2xpY2UoKSxcblx0XHRcdFx0Zm9yY2VFbnVtZXJhYmxlLFxuXHRcdFx0XHRtYXhEZXB0aCxcblx0XHRcdFx0ZGVwdGhcblx0XHRcdH0pO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0dG9ba2V5XSA9ICdbQ2lyY3VsYXJdJztcblx0fVxuXG5cdGZvciAoY29uc3Qge3Byb3BlcnR5LCBlbnVtZXJhYmxlfSBvZiBjb21tb25Qcm9wZXJ0aWVzKSB7XG5cdFx0aWYgKHR5cGVvZiBmcm9tW3Byb3BlcnR5XSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0bywgcHJvcGVydHksIHtcblx0XHRcdFx0dmFsdWU6IGZyb21bcHJvcGVydHldLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiBmb3JjZUVudW1lcmFibGUgPyB0cnVlIDogZW51bWVyYWJsZSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuY29uc3Qgc2VyaWFsaXplRXJyb3IgPSAodmFsdWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuXHRjb25zdCB7bWF4RGVwdGggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFl9ID0gb3B0aW9ucztcblxuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuXHRcdHJldHVybiBkZXN0cm95Q2lyY3VsYXIoe1xuXHRcdFx0ZnJvbTogdmFsdWUsXG5cdFx0XHRzZWVuOiBbXSxcblx0XHRcdGZvcmNlRW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdG1heERlcHRoLFxuXHRcdFx0ZGVwdGg6IDBcblx0XHR9KTtcblx0fVxuXG5cdC8vIFBlb3BsZSBzb21ldGltZXMgdGhyb3cgdGhpbmdzIGJlc2lkZXMgRXJyb3Igb2JqZWN0c+KAplxuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Ly8gYEpTT04uc3RyaW5naWZ5KClgIGRpc2NhcmRzIGZ1bmN0aW9ucy4gV2UgZG8gdG9vLCB1bmxlc3MgYSBmdW5jdGlvbiBpcyB0aHJvd24gZGlyZWN0bHkuXG5cdFx0cmV0dXJuIGBbRnVuY3Rpb246ICR7KHZhbHVlLm5hbWUgfHwgJ2Fub255bW91cycpfV1gO1xuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufTtcblxuY29uc3QgZGVzZXJpYWxpemVFcnJvciA9ICh2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG5cdGNvbnN0IHttYXhEZXB0aCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWX0gPSBvcHRpb25zO1xuXG5cdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0Y29uc3QgbmV3RXJyb3IgPSBuZXcgRXJyb3IoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSB1bmljb3JuL2Vycm9yLW1lc3NhZ2Vcblx0XHRkZXN0cm95Q2lyY3VsYXIoe1xuXHRcdFx0ZnJvbTogdmFsdWUsXG5cdFx0XHRzZWVuOiBbXSxcblx0XHRcdHRvXzogbmV3RXJyb3IsXG5cdFx0XHRtYXhEZXB0aCxcblx0XHRcdGRlcHRoOiAwXG5cdFx0fSk7XG5cdFx0cmV0dXJuIG5ld0Vycm9yO1xuXHR9XG5cblx0cmV0dXJuIG5ldyBOb25FcnJvcih2YWx1ZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0c2VyaWFsaXplRXJyb3IsXG5cdGRlc2VyaWFsaXplRXJyb3Jcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGdldFVuaXF1ZUlkID0gKCkgPT4gYCR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpfWA7XG5cbmNvbnN0IGdldFNlbmRDaGFubmVsID0gY2hhbm5lbCA9PiBgJWJldHRlci1pcGMtc2VuZC1jaGFubmVsLSR7Y2hhbm5lbH1gO1xuY29uc3QgZ2V0UmVuZGVyZXJTZW5kQ2hhbm5lbCA9IGNoYW5uZWwgPT4gYCViZXR0ZXItaXBjLXNlbmQtY2hhbm5lbC0ke2NoYW5uZWx9YDtcblxubW9kdWxlLmV4cG9ydHMuY3VycmVudFdpbmRvd0NoYW5uZWwgPSAnJWJldHRlci1pcGMtY3VycmVudC13aW5kb3cnO1xuXG5tb2R1bGUuZXhwb3J0cy5nZXRTZW5kQ2hhbm5lbCA9IGdldFNlbmRDaGFubmVsO1xubW9kdWxlLmV4cG9ydHMuZ2V0UmVuZGVyZXJTZW5kQ2hhbm5lbCA9IGdldFJlbmRlcmVyU2VuZENoYW5uZWw7XG5cbm1vZHVsZS5leHBvcnRzLmdldFJlc3BvbnNlQ2hhbm5lbHMgPSBjaGFubmVsID0+IHtcblx0Y29uc3QgaWQgPSBnZXRVbmlxdWVJZCgpO1xuXHRyZXR1cm4ge1xuXHRcdHNlbmRDaGFubmVsOiBnZXRTZW5kQ2hhbm5lbChjaGFubmVsKSxcblx0XHRkYXRhQ2hhbm5lbDogYCViZXR0ZXItaXBjLXJlc3BvbnNlLWRhdGEtY2hhbm5lbC0ke2NoYW5uZWx9LSR7aWR9YCxcblx0XHRlcnJvckNoYW5uZWw6IGAlYmV0dGVyLWlwYy1yZXNwb25zZS1lcnJvci1jaGFubmVsLSR7Y2hhbm5lbH0tJHtpZH1gXG5cdH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5nZXRSZW5kZXJlclJlc3BvbnNlQ2hhbm5lbHMgPSBjaGFubmVsID0+IHtcblx0Y29uc3QgaWQgPSBnZXRVbmlxdWVJZCgpO1xuXHRyZXR1cm4ge1xuXHRcdHNlbmRDaGFubmVsOiBnZXRSZW5kZXJlclNlbmRDaGFubmVsKGNoYW5uZWwpLFxuXHRcdGRhdGFDaGFubmVsOiBgJWJldHRlci1pcGMtcmVzcG9uc2UtZGF0YS1jaGFubmVsLSR7Y2hhbm5lbH0tJHtpZH1gLFxuXHRcdGVycm9yQ2hhbm5lbDogYCViZXR0ZXItaXBjLXJlc3BvbnNlLWVycm9yLWNoYW5uZWwtJHtjaGFubmVsfS0ke2lkfWBcblx0fTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBlbGVjdHJvbiA9IHJlcXVpcmUoJ2VsZWN0cm9uJyk7XG5jb25zdCB7c2VyaWFsaXplRXJyb3IsIGRlc2VyaWFsaXplRXJyb3J9ID0gcmVxdWlyZSgnc2VyaWFsaXplLWVycm9yJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsLmpzJyk7XG5cbmNvbnN0IHtpcGNNYWluLCBCcm93c2VyV2luZG93fSA9IGVsZWN0cm9uO1xuY29uc3QgaXBjID0gT2JqZWN0LmNyZWF0ZShpcGNNYWluIHx8IHt9KTtcblxuaXBjLmNhbGxSZW5kZXJlciA9IChicm93c2VyV2luZG93LCBjaGFubmVsLCBkYXRhKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdGlmICghYnJvd3NlcldpbmRvdykge1xuXHRcdHRocm93IG5ldyBFcnJvcignQnJvd3NlciB3aW5kb3cgcmVxdWlyZWQnKTtcblx0fVxuXG5cdGNvbnN0IHtzZW5kQ2hhbm5lbCwgZGF0YUNoYW5uZWwsIGVycm9yQ2hhbm5lbH0gPSB1dGlsLmdldFJlbmRlcmVyUmVzcG9uc2VDaGFubmVscyhjaGFubmVsKTtcblxuXHRjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuXHRcdGlwY01haW4ub2ZmKGRhdGFDaGFubmVsLCBvbkRhdGEpO1xuXHRcdGlwY01haW4ub2ZmKGVycm9yQ2hhbm5lbCwgb25FcnJvcik7XG5cdH07XG5cblx0Y29uc3Qgb25EYXRhID0gKGV2ZW50LCByZXN1bHQpID0+IHtcblx0XHRjb25zdCB3aW5kb3cgPSBCcm93c2VyV2luZG93LmZyb21XZWJDb250ZW50cyhldmVudC5zZW5kZXIpO1xuXHRcdGlmICh3aW5kb3cuaWQgPT09IGJyb3dzZXJXaW5kb3cuaWQpIHtcblx0XHRcdGNsZWFudXAoKTtcblx0XHRcdHJlc29sdmUocmVzdWx0KTtcblx0XHR9XG5cdH07XG5cblx0Y29uc3Qgb25FcnJvciA9IChldmVudCwgZXJyb3IpID0+IHtcblx0XHRjb25zdCB3aW5kb3cgPSBCcm93c2VyV2luZG93LmZyb21XZWJDb250ZW50cyhldmVudC5zZW5kZXIpO1xuXHRcdGlmICh3aW5kb3cuaWQgPT09IGJyb3dzZXJXaW5kb3cuaWQpIHtcblx0XHRcdGNsZWFudXAoKTtcblx0XHRcdHJlamVjdChkZXNlcmlhbGl6ZUVycm9yKGVycm9yKSk7XG5cdFx0fVxuXHR9O1xuXG5cdGlwY01haW4ub24oZGF0YUNoYW5uZWwsIG9uRGF0YSk7XG5cdGlwY01haW4ub24oZXJyb3JDaGFubmVsLCBvbkVycm9yKTtcblxuXHRjb25zdCBjb21wbGV0ZURhdGEgPSB7XG5cdFx0ZGF0YUNoYW5uZWwsXG5cdFx0ZXJyb3JDaGFubmVsLFxuXHRcdHVzZXJEYXRhOiBkYXRhXG5cdH07XG5cblx0aWYgKGJyb3dzZXJXaW5kb3cud2ViQ29udGVudHMpIHtcblx0XHRicm93c2VyV2luZG93LndlYkNvbnRlbnRzLnNlbmQoc2VuZENoYW5uZWwsIGNvbXBsZXRlRGF0YSk7XG5cdH1cbn0pO1xuXG5pcGMuY2FsbEZvY3VzZWRSZW5kZXJlciA9IGFzeW5jICguLi5hcmdzKSA9PiB7XG5cdGNvbnN0IGZvY3VzZWRXaW5kb3cgPSBCcm93c2VyV2luZG93LmdldEZvY3VzZWRXaW5kb3coKTtcblx0aWYgKCFmb2N1c2VkV2luZG93KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdObyBicm93c2VyIHdpbmRvdyBpbiBmb2N1cycpO1xuXHR9XG5cblx0cmV0dXJuIGlwYy5jYWxsUmVuZGVyZXIoZm9jdXNlZFdpbmRvdywgLi4uYXJncyk7XG59O1xuXG5pcGMuYW5zd2VyUmVuZGVyZXIgPSAoYnJvd3NlcldpbmRvd09yQ2hhbm5lbCwgY2hhbm5lbE9yQ2FsbGJhY2ssIGNhbGxiYWNrT3JOb3RoaW5nKSA9PiB7XG5cdGxldCB3aW5kb3c7XG5cdGxldCBjaGFubmVsO1xuXHRsZXQgY2FsbGJhY2s7XG5cblx0aWYgKGNhbGxiYWNrT3JOb3RoaW5nID09PSB1bmRlZmluZWQpIHtcblx0XHRjaGFubmVsID0gYnJvd3NlcldpbmRvd09yQ2hhbm5lbDtcblx0XHRjYWxsYmFjayA9IGNoYW5uZWxPckNhbGxiYWNrO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdyA9IGJyb3dzZXJXaW5kb3dPckNoYW5uZWw7XG5cdFx0Y2hhbm5lbCA9IGNoYW5uZWxPckNhbGxiYWNrO1xuXHRcdGNhbGxiYWNrID0gY2FsbGJhY2tPck5vdGhpbmc7XG5cblx0XHRpZiAoIXdpbmRvdykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdCcm93c2VyIHdpbmRvdyByZXF1aXJlZCcpO1xuXHRcdH1cblx0fVxuXG5cdGNvbnN0IHNlbmRDaGFubmVsID0gdXRpbC5nZXRTZW5kQ2hhbm5lbChjaGFubmVsKTtcblxuXHRjb25zdCBsaXN0ZW5lciA9IGFzeW5jIChldmVudCwgZGF0YSkgPT4ge1xuXHRcdGNvbnN0IGJyb3dzZXJXaW5kb3cgPSBCcm93c2VyV2luZG93LmZyb21XZWJDb250ZW50cyhldmVudC5zZW5kZXIpO1xuXG5cdFx0aWYgKHdpbmRvdyAmJiB3aW5kb3cuaWQgIT09IGJyb3dzZXJXaW5kb3cuaWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBzZW5kID0gKGNoYW5uZWwsIGRhdGEpID0+IHtcblx0XHRcdGlmICghKGJyb3dzZXJXaW5kb3cgJiYgYnJvd3NlcldpbmRvdy5pc0Rlc3Ryb3llZCgpKSkge1xuXHRcdFx0XHRldmVudC5zZW5kZXIuc2VuZChjaGFubmVsLCBkYXRhKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Y29uc3Qge2RhdGFDaGFubmVsLCBlcnJvckNoYW5uZWwsIHVzZXJEYXRhfSA9IGRhdGE7XG5cblx0XHR0cnkge1xuXHRcdFx0c2VuZChkYXRhQ2hhbm5lbCwgYXdhaXQgY2FsbGJhY2sodXNlckRhdGEsIGJyb3dzZXJXaW5kb3cpKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0c2VuZChlcnJvckNoYW5uZWwsIHNlcmlhbGl6ZUVycm9yKGVycm9yKSk7XG5cdFx0fVxuXHR9O1xuXG5cdGlwY01haW4ub24oc2VuZENoYW5uZWwsIGxpc3RlbmVyKTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlwY01haW4ub2ZmKHNlbmRDaGFubmVsLCBsaXN0ZW5lcik7XG5cdH07XG59O1xuXG5pcGMuc2VuZFRvUmVuZGVyZXJzID0gKGNoYW5uZWwsIGRhdGEpID0+IHtcblx0Zm9yIChjb25zdCBicm93c2VyV2luZG93IG9mIEJyb3dzZXJXaW5kb3cuZ2V0QWxsV2luZG93cygpKSB7XG5cdFx0aWYgKGJyb3dzZXJXaW5kb3cud2ViQ29udGVudHMpIHtcblx0XHRcdGJyb3dzZXJXaW5kb3cud2ViQ29udGVudHMuc2VuZChjaGFubmVsLCBkYXRhKTtcblx0XHR9XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXBjO1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgZWxlY3Ryb24gPSByZXF1aXJlKCdlbGVjdHJvbicpO1xuY29uc3Qge3NlcmlhbGl6ZUVycm9yLCBkZXNlcmlhbGl6ZUVycm9yfSA9IHJlcXVpcmUoJ3NlcmlhbGl6ZS1lcnJvcicpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbC5qcycpO1xuXG5jb25zdCB7aXBjUmVuZGVyZXJ9ID0gZWxlY3Ryb247XG5jb25zdCBpcGMgPSBPYmplY3QuY3JlYXRlKGlwY1JlbmRlcmVyIHx8IHt9KTtcblxuaXBjLmNhbGxNYWluID0gKGNoYW5uZWwsIGRhdGEpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0Y29uc3Qge3NlbmRDaGFubmVsLCBkYXRhQ2hhbm5lbCwgZXJyb3JDaGFubmVsfSA9IHV0aWwuZ2V0UmVzcG9uc2VDaGFubmVscyhjaGFubmVsKTtcblxuXHRjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuXHRcdGlwY1JlbmRlcmVyLm9mZihkYXRhQ2hhbm5lbCwgb25EYXRhKTtcblx0XHRpcGNSZW5kZXJlci5vZmYoZXJyb3JDaGFubmVsLCBvbkVycm9yKTtcblx0fTtcblxuXHRjb25zdCBvbkRhdGEgPSAoX2V2ZW50LCByZXN1bHQpID0+IHtcblx0XHRjbGVhbnVwKCk7XG5cdFx0cmVzb2x2ZShyZXN1bHQpO1xuXHR9O1xuXG5cdGNvbnN0IG9uRXJyb3IgPSAoX2V2ZW50LCBlcnJvcikgPT4ge1xuXHRcdGNsZWFudXAoKTtcblx0XHRyZWplY3QoZGVzZXJpYWxpemVFcnJvcihlcnJvcikpO1xuXHR9O1xuXG5cdGlwY1JlbmRlcmVyLm9uY2UoZGF0YUNoYW5uZWwsIG9uRGF0YSk7XG5cdGlwY1JlbmRlcmVyLm9uY2UoZXJyb3JDaGFubmVsLCBvbkVycm9yKTtcblxuXHRjb25zdCBjb21wbGV0ZURhdGEgPSB7XG5cdFx0ZGF0YUNoYW5uZWwsXG5cdFx0ZXJyb3JDaGFubmVsLFxuXHRcdHVzZXJEYXRhOiBkYXRhXG5cdH07XG5cblx0aXBjUmVuZGVyZXIuc2VuZChzZW5kQ2hhbm5lbCwgY29tcGxldGVEYXRhKTtcbn0pO1xuXG5pcGMuYW5zd2VyTWFpbiA9IChjaGFubmVsLCBjYWxsYmFjaykgPT4ge1xuXHRjb25zdCBzZW5kQ2hhbm5lbCA9IHV0aWwuZ2V0UmVuZGVyZXJTZW5kQ2hhbm5lbChjaGFubmVsKTtcblxuXHRjb25zdCBsaXN0ZW5lciA9IGFzeW5jIChfZXZlbnQsIGRhdGEpID0+IHtcblx0XHRjb25zdCB7ZGF0YUNoYW5uZWwsIGVycm9yQ2hhbm5lbCwgdXNlckRhdGF9ID0gZGF0YTtcblxuXHRcdHRyeSB7XG5cdFx0XHRpcGNSZW5kZXJlci5zZW5kKGRhdGFDaGFubmVsLCBhd2FpdCBjYWxsYmFjayh1c2VyRGF0YSkpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpcGNSZW5kZXJlci5zZW5kKGVycm9yQ2hhbm5lbCwgc2VyaWFsaXplRXJyb3IoZXJyb3IpKTtcblx0XHR9XG5cdH07XG5cblx0aXBjUmVuZGVyZXIub24oc2VuZENoYW5uZWwsIGxpc3RlbmVyKTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlwY1JlbmRlcmVyLm9mZihzZW5kQ2hhbm5lbCwgbGlzdGVuZXIpO1xuXHR9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpcGM7XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcblx0bW9kdWxlLmV4cG9ydHMuaXBjUmVuZGVyZXIgPSByZXF1aXJlKCcuL3NvdXJjZS9yZW5kZXJlci5qcycpO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMuaXBjTWFpbiA9IHJlcXVpcmUoJy4vc291cmNlL21haW4uanMnKTtcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmZyb21DYWxsYmFjayA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIGZuLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBmbi5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICAoZXJyLCByZXMpID0+IChlcnIgIT0gbnVsbCkgPyByZWplY3QoZXJyKSA6IHJlc29sdmUocmVzKVxuICAgICAgICApXG4gICAgICB9KVxuICAgIH1cbiAgfSwgJ25hbWUnLCB7IHZhbHVlOiBmbi5uYW1lIH0pXG59XG5cbmV4cG9ydHMuZnJvbVByb21pc2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIGNvbnN0IGNiID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdXG4gICAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgZWxzZSBmbi5hcHBseSh0aGlzLCBhcmdzLnNsaWNlKDAsIC0xKSkudGhlbihyID0+IGNiKG51bGwsIHIpLCBjYilcbiAgfSwgJ25hbWUnLCB7IHZhbHVlOiBmbi5uYW1lIH0pXG59XG4iLCJ2YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnY29uc3RhbnRzJylcblxudmFyIG9yaWdDd2QgPSBwcm9jZXNzLmN3ZFxudmFyIGN3ZCA9IG51bGxcblxudmFyIHBsYXRmb3JtID0gcHJvY2Vzcy5lbnYuR1JBQ0VGVUxfRlNfUExBVEZPUk0gfHwgcHJvY2Vzcy5wbGF0Zm9ybVxuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIWN3ZClcbiAgICBjd2QgPSBvcmlnQ3dkLmNhbGwocHJvY2VzcylcbiAgcmV0dXJuIGN3ZFxufVxudHJ5IHtcbiAgcHJvY2Vzcy5jd2QoKVxufSBjYXRjaCAoZXIpIHt9XG5cbi8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHVudGlsIG5vZGUuanMgMTIgaXMgcmVxdWlyZWRcbmlmICh0eXBlb2YgcHJvY2Vzcy5jaGRpciA9PT0gJ2Z1bmN0aW9uJykge1xuICB2YXIgY2hkaXIgPSBwcm9jZXNzLmNoZGlyXG4gIHByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZCkge1xuICAgIGN3ZCA9IG51bGxcbiAgICBjaGRpci5jYWxsKHByb2Nlc3MsIGQpXG4gIH1cbiAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb2Nlc3MuY2hkaXIsIGNoZGlyKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoXG5cbmZ1bmN0aW9uIHBhdGNoIChmcykge1xuICAvLyAocmUtKWltcGxlbWVudCBzb21lIHRoaW5ncyB0aGF0IGFyZSBrbm93biBidXN0ZWQgb3IgbWlzc2luZy5cblxuICAvLyBsY2htb2QsIGJyb2tlbiBwcmlvciB0byAwLjYuMlxuICAvLyBiYWNrLXBvcnQgdGhlIGZpeCBoZXJlLlxuICBpZiAoY29uc3RhbnRzLmhhc093blByb3BlcnR5KCdPX1NZTUxJTksnKSAmJlxuICAgICAgcHJvY2Vzcy52ZXJzaW9uLm1hdGNoKC9edjBcXC42XFwuWzAtMl18XnYwXFwuNVxcLi8pKSB7XG4gICAgcGF0Y2hMY2htb2QoZnMpXG4gIH1cblxuICAvLyBsdXRpbWVzIGltcGxlbWVudGF0aW9uLCBvciBuby1vcFxuICBpZiAoIWZzLmx1dGltZXMpIHtcbiAgICBwYXRjaEx1dGltZXMoZnMpXG4gIH1cblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL25vZGUtZ3JhY2VmdWwtZnMvaXNzdWVzLzRcbiAgLy8gQ2hvd24gc2hvdWxkIG5vdCBmYWlsIG9uIGVpbnZhbCBvciBlcGVybSBpZiBub24tcm9vdC5cbiAgLy8gSXQgc2hvdWxkIG5vdCBmYWlsIG9uIGVub3N5cyBldmVyLCBhcyB0aGlzIGp1c3QgaW5kaWNhdGVzXG4gIC8vIHRoYXQgYSBmcyBkb2Vzbid0IHN1cHBvcnQgdGhlIGludGVuZGVkIG9wZXJhdGlvbi5cblxuICBmcy5jaG93biA9IGNob3duRml4KGZzLmNob3duKVxuICBmcy5mY2hvd24gPSBjaG93bkZpeChmcy5mY2hvd24pXG4gIGZzLmxjaG93biA9IGNob3duRml4KGZzLmxjaG93bilcblxuICBmcy5jaG1vZCA9IGNobW9kRml4KGZzLmNobW9kKVxuICBmcy5mY2htb2QgPSBjaG1vZEZpeChmcy5mY2htb2QpXG4gIGZzLmxjaG1vZCA9IGNobW9kRml4KGZzLmxjaG1vZClcblxuICBmcy5jaG93blN5bmMgPSBjaG93bkZpeFN5bmMoZnMuY2hvd25TeW5jKVxuICBmcy5mY2hvd25TeW5jID0gY2hvd25GaXhTeW5jKGZzLmZjaG93blN5bmMpXG4gIGZzLmxjaG93blN5bmMgPSBjaG93bkZpeFN5bmMoZnMubGNob3duU3luYylcblxuICBmcy5jaG1vZFN5bmMgPSBjaG1vZEZpeFN5bmMoZnMuY2htb2RTeW5jKVxuICBmcy5mY2htb2RTeW5jID0gY2htb2RGaXhTeW5jKGZzLmZjaG1vZFN5bmMpXG4gIGZzLmxjaG1vZFN5bmMgPSBjaG1vZEZpeFN5bmMoZnMubGNobW9kU3luYylcblxuICBmcy5zdGF0ID0gc3RhdEZpeChmcy5zdGF0KVxuICBmcy5mc3RhdCA9IHN0YXRGaXgoZnMuZnN0YXQpXG4gIGZzLmxzdGF0ID0gc3RhdEZpeChmcy5sc3RhdClcblxuICBmcy5zdGF0U3luYyA9IHN0YXRGaXhTeW5jKGZzLnN0YXRTeW5jKVxuICBmcy5mc3RhdFN5bmMgPSBzdGF0Rml4U3luYyhmcy5mc3RhdFN5bmMpXG4gIGZzLmxzdGF0U3luYyA9IHN0YXRGaXhTeW5jKGZzLmxzdGF0U3luYylcblxuICAvLyBpZiBsY2htb2QvbGNob3duIGRvIG5vdCBleGlzdCwgdGhlbiBtYWtlIHRoZW0gbm8tb3BzXG4gIGlmICghZnMubGNobW9kKSB7XG4gICAgZnMubGNobW9kID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUsIGNiKSB7XG4gICAgICBpZiAoY2IpIHByb2Nlc3MubmV4dFRpY2soY2IpXG4gICAgfVxuICAgIGZzLmxjaG1vZFN5bmMgPSBmdW5jdGlvbiAoKSB7fVxuICB9XG4gIGlmICghZnMubGNob3duKSB7XG4gICAgZnMubGNob3duID0gZnVuY3Rpb24gKHBhdGgsIHVpZCwgZ2lkLCBjYikge1xuICAgICAgaWYgKGNiKSBwcm9jZXNzLm5leHRUaWNrKGNiKVxuICAgIH1cbiAgICBmcy5sY2hvd25TeW5jID0gZnVuY3Rpb24gKCkge31cbiAgfVxuXG4gIC8vIG9uIFdpbmRvd3MsIEEvViBzb2Z0d2FyZSBjYW4gbG9jayB0aGUgZGlyZWN0b3J5LCBjYXVzaW5nIHRoaXNcbiAgLy8gdG8gZmFpbCB3aXRoIGFuIEVBQ0NFUyBvciBFUEVSTSBpZiB0aGUgZGlyZWN0b3J5IGNvbnRhaW5zIG5ld2x5XG4gIC8vIGNyZWF0ZWQgZmlsZXMuICBUcnkgYWdhaW4gb24gZmFpbHVyZSwgZm9yIHVwIHRvIDYwIHNlY29uZHMuXG5cbiAgLy8gU2V0IHRoZSB0aW1lb3V0IHRoaXMgbG9uZyBiZWNhdXNlIHNvbWUgV2luZG93cyBBbnRpLVZpcnVzLCBzdWNoIGFzIFBhcml0eVxuICAvLyBiaXQ5LCBtYXkgbG9jayBmaWxlcyBmb3IgdXAgdG8gYSBtaW51dGUsIGNhdXNpbmcgbnBtIHBhY2thZ2UgaW5zdGFsbFxuICAvLyBmYWlsdXJlcy4gQWxzbywgdGFrZSBjYXJlIHRvIHlpZWxkIHRoZSBzY2hlZHVsZXIuIFdpbmRvd3Mgc2NoZWR1bGluZyBnaXZlc1xuICAvLyBDUFUgdG8gYSBidXN5IGxvb3BpbmcgcHJvY2Vzcywgd2hpY2ggY2FuIGNhdXNlIHRoZSBwcm9ncmFtIGNhdXNpbmcgdGhlIGxvY2tcbiAgLy8gY29udGVudGlvbiB0byBiZSBzdGFydmVkIG9mIENQVSBieSBub2RlLCBzbyB0aGUgY29udGVudGlvbiBkb2Vzbid0IHJlc29sdmUuXG4gIGlmIChwbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgZnMucmVuYW1lID0gKGZ1bmN0aW9uIChmcyRyZW5hbWUpIHsgcmV0dXJuIGZ1bmN0aW9uIChmcm9tLCB0bywgY2IpIHtcbiAgICAgIHZhciBzdGFydCA9IERhdGUubm93KClcbiAgICAgIHZhciBiYWNrb2ZmID0gMDtcbiAgICAgIGZzJHJlbmFtZShmcm9tLCB0bywgZnVuY3Rpb24gQ0IgKGVyKSB7XG4gICAgICAgIGlmIChlclxuICAgICAgICAgICAgJiYgKGVyLmNvZGUgPT09IFwiRUFDQ0VTXCIgfHwgZXIuY29kZSA9PT0gXCJFUEVSTVwiKVxuICAgICAgICAgICAgJiYgRGF0ZS5ub3coKSAtIHN0YXJ0IDwgNjAwMDApIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZnMuc3RhdCh0bywgZnVuY3Rpb24gKHN0YXRlciwgc3QpIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlciAmJiBzdGF0ZXIuY29kZSA9PT0gXCJFTk9FTlRcIilcbiAgICAgICAgICAgICAgICBmcyRyZW5hbWUoZnJvbSwgdG8sIENCKTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNiKGVyKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LCBiYWNrb2ZmKVxuICAgICAgICAgIGlmIChiYWNrb2ZmIDwgMTAwKVxuICAgICAgICAgICAgYmFja29mZiArPSAxMDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNiKSBjYihlcilcbiAgICAgIH0pXG4gICAgfX0pKGZzLnJlbmFtZSlcbiAgfVxuXG4gIC8vIGlmIHJlYWQoKSByZXR1cm5zIEVBR0FJTiwgdGhlbiBqdXN0IHRyeSBpdCBhZ2Fpbi5cbiAgZnMucmVhZCA9IChmdW5jdGlvbiAoZnMkcmVhZCkge1xuICAgIGZ1bmN0aW9uIHJlYWQgKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2tfKSB7XG4gICAgICB2YXIgY2FsbGJhY2tcbiAgICAgIGlmIChjYWxsYmFja18gJiYgdHlwZW9mIGNhbGxiYWNrXyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgZWFnQ291bnRlciA9IDBcbiAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoZXIsIF8sIF9fKSB7XG4gICAgICAgICAgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFQUdBSU4nICYmIGVhZ0NvdW50ZXIgPCAxMCkge1xuICAgICAgICAgICAgZWFnQ291bnRlciArK1xuICAgICAgICAgICAgcmV0dXJuIGZzJHJlYWQuY2FsbChmcywgZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaylcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2tfLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZzJHJlYWQuY2FsbChmcywgZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaylcbiAgICB9XG5cbiAgICAvLyBUaGlzIGVuc3VyZXMgYHV0aWwucHJvbWlzaWZ5YCB3b3JrcyBhcyBpdCBkb2VzIGZvciBuYXRpdmUgYGZzLnJlYWRgLlxuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIE9iamVjdC5zZXRQcm90b3R5cGVPZihyZWFkLCBmcyRyZWFkKVxuICAgIHJldHVybiByZWFkXG4gIH0pKGZzLnJlYWQpXG5cbiAgZnMucmVhZFN5bmMgPSAoZnVuY3Rpb24gKGZzJHJlYWRTeW5jKSB7IHJldHVybiBmdW5jdGlvbiAoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XG4gICAgdmFyIGVhZ0NvdW50ZXIgPSAwXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmcyRyZWFkU3luYy5jYWxsKGZzLCBmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBpZiAoZXIuY29kZSA9PT0gJ0VBR0FJTicgJiYgZWFnQ291bnRlciA8IDEwKSB7XG4gICAgICAgICAgZWFnQ291bnRlciArK1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJcbiAgICAgIH1cbiAgICB9XG4gIH19KShmcy5yZWFkU3luYylcblxuICBmdW5jdGlvbiBwYXRjaExjaG1vZCAoZnMpIHtcbiAgICBmcy5sY2htb2QgPSBmdW5jdGlvbiAocGF0aCwgbW9kZSwgY2FsbGJhY2spIHtcbiAgICAgIGZzLm9wZW4oIHBhdGhcbiAgICAgICAgICAgICAsIGNvbnN0YW50cy5PX1dST05MWSB8IGNvbnN0YW50cy5PX1NZTUxJTktcbiAgICAgICAgICAgICAsIG1vZGVcbiAgICAgICAgICAgICAsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVycilcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICAvLyBwcmVmZXIgdG8gcmV0dXJuIHRoZSBjaG1vZCBlcnJvciwgaWYgb25lIG9jY3VycyxcbiAgICAgICAgLy8gYnV0IHN0aWxsIHRyeSB0byBjbG9zZSwgYW5kIHJlcG9ydCBjbG9zaW5nIGVycm9ycyBpZiB0aGV5IG9jY3VyLlxuICAgICAgICBmcy5mY2htb2QoZmQsIG1vZGUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBmcy5jbG9zZShmZCwgZnVuY3Rpb24oZXJyMikge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIgfHwgZXJyMilcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmcy5sY2htb2RTeW5jID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUpIHtcbiAgICAgIHZhciBmZCA9IGZzLm9wZW5TeW5jKHBhdGgsIGNvbnN0YW50cy5PX1dST05MWSB8IGNvbnN0YW50cy5PX1NZTUxJTkssIG1vZGUpXG5cbiAgICAgIC8vIHByZWZlciB0byByZXR1cm4gdGhlIGNobW9kIGVycm9yLCBpZiBvbmUgb2NjdXJzLFxuICAgICAgLy8gYnV0IHN0aWxsIHRyeSB0byBjbG9zZSwgYW5kIHJlcG9ydCBjbG9zaW5nIGVycm9ycyBpZiB0aGV5IG9jY3VyLlxuICAgICAgdmFyIHRocmV3ID0gdHJ1ZVxuICAgICAgdmFyIHJldFxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0ID0gZnMuZmNobW9kU3luYyhmZCwgbW9kZSlcbiAgICAgICAgdGhyZXcgPSBmYWxzZVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRocmV3KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgICB9IGNhdGNoIChlcikge31cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXRcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaEx1dGltZXMgKGZzKSB7XG4gICAgaWYgKGNvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eShcIk9fU1lNTElOS1wiKSkge1xuICAgICAgZnMubHV0aW1lcyA9IGZ1bmN0aW9uIChwYXRoLCBhdCwgbXQsIGNiKSB7XG4gICAgICAgIGZzLm9wZW4ocGF0aCwgY29uc3RhbnRzLk9fU1lNTElOSywgZnVuY3Rpb24gKGVyLCBmZCkge1xuICAgICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgaWYgKGNiKSBjYihlcilcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBmcy5mdXRpbWVzKGZkLCBhdCwgbXQsIGZ1bmN0aW9uIChlcikge1xuICAgICAgICAgICAgZnMuY2xvc2UoZmQsIGZ1bmN0aW9uIChlcjIpIHtcbiAgICAgICAgICAgICAgaWYgKGNiKSBjYihlciB8fCBlcjIpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGZzLmx1dGltZXNTeW5jID0gZnVuY3Rpb24gKHBhdGgsIGF0LCBtdCkge1xuICAgICAgICB2YXIgZmQgPSBmcy5vcGVuU3luYyhwYXRoLCBjb25zdGFudHMuT19TWU1MSU5LKVxuICAgICAgICB2YXIgcmV0XG4gICAgICAgIHZhciB0aHJldyA9IHRydWVcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXQgPSBmcy5mdXRpbWVzU3luYyhmZCwgYXQsIG10KVxuICAgICAgICAgIHRocmV3ID0gZmFsc2VcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAodGhyZXcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVyKSB7fVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXRcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBmcy5sdXRpbWVzID0gZnVuY3Rpb24gKF9hLCBfYiwgX2MsIGNiKSB7IGlmIChjYikgcHJvY2Vzcy5uZXh0VGljayhjYikgfVxuICAgICAgZnMubHV0aW1lc1N5bmMgPSBmdW5jdGlvbiAoKSB7fVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNobW9kRml4IChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBtb2RlLCBjYikge1xuICAgICAgcmV0dXJuIG9yaWcuY2FsbChmcywgdGFyZ2V0LCBtb2RlLCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgICAgaWYgKGNob3duRXJPayhlcikpIGVyID0gbnVsbFxuICAgICAgICBpZiAoY2IpIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2htb2RGaXhTeW5jIChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBtb2RlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIG1vZGUpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBpZiAoIWNob3duRXJPayhlcikpIHRocm93IGVyXG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICBmdW5jdGlvbiBjaG93bkZpeCAob3JpZykge1xuICAgIGlmICghb3JpZykgcmV0dXJuIG9yaWdcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgdWlkLCBnaWQsIGNiKSB7XG4gICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIHVpZCwgZ2lkLCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgICAgaWYgKGNob3duRXJPayhlcikpIGVyID0gbnVsbFxuICAgICAgICBpZiAoY2IpIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hvd25GaXhTeW5jIChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCB1aWQsIGdpZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG9yaWcuY2FsbChmcywgdGFyZ2V0LCB1aWQsIGdpZClcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGlmICghY2hvd25Fck9rKGVyKSkgdGhyb3cgZXJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdGF0Rml4IChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIC8vIE9sZGVyIHZlcnNpb25zIG9mIE5vZGUgZXJyb25lb3VzbHkgcmV0dXJuZWQgc2lnbmVkIGludGVnZXJzIGZvclxuICAgIC8vIHVpZCArIGdpZC5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucywgY2IpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYiA9IG9wdGlvbnNcbiAgICAgICAgb3B0aW9ucyA9IG51bGxcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrIChlciwgc3RhdHMpIHtcbiAgICAgICAgaWYgKHN0YXRzKSB7XG4gICAgICAgICAgaWYgKHN0YXRzLnVpZCA8IDApIHN0YXRzLnVpZCArPSAweDEwMDAwMDAwMFxuICAgICAgICAgIGlmIChzdGF0cy5naWQgPCAwKSBzdGF0cy5naWQgKz0gMHgxMDAwMDAwMDBcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2IpIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zID8gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgICAgICA6IG9yaWcuY2FsbChmcywgdGFyZ2V0LCBjYWxsYmFjaylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdGF0Rml4U3luYyAob3JpZykge1xuICAgIGlmICghb3JpZykgcmV0dXJuIG9yaWdcbiAgICAvLyBPbGRlciB2ZXJzaW9ucyBvZiBOb2RlIGVycm9uZW91c2x5IHJldHVybmVkIHNpZ25lZCBpbnRlZ2VycyBmb3JcbiAgICAvLyB1aWQgKyBnaWQuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzdGF0cyA9IG9wdGlvbnMgPyBvcmlnLmNhbGwoZnMsIHRhcmdldCwgb3B0aW9ucylcbiAgICAgICAgOiBvcmlnLmNhbGwoZnMsIHRhcmdldClcbiAgICAgIGlmIChzdGF0cy51aWQgPCAwKSBzdGF0cy51aWQgKz0gMHgxMDAwMDAwMDBcbiAgICAgIGlmIChzdGF0cy5naWQgPCAwKSBzdGF0cy5naWQgKz0gMHgxMDAwMDAwMDBcbiAgICAgIHJldHVybiBzdGF0cztcbiAgICB9XG4gIH1cblxuICAvLyBFTk9TWVMgbWVhbnMgdGhhdCB0aGUgZnMgZG9lc24ndCBzdXBwb3J0IHRoZSBvcC4gSnVzdCBpZ25vcmVcbiAgLy8gdGhhdCwgYmVjYXVzZSBpdCBkb2Vzbid0IG1hdHRlci5cbiAgLy9cbiAgLy8gaWYgdGhlcmUncyBubyBnZXR1aWQsIG9yIGlmIGdldHVpZCgpIGlzIHNvbWV0aGluZyBvdGhlclxuICAvLyB0aGFuIDAsIGFuZCB0aGUgZXJyb3IgaXMgRUlOVkFMIG9yIEVQRVJNLCB0aGVuIGp1c3QgaWdub3JlXG4gIC8vIGl0LlxuICAvL1xuICAvLyBUaGlzIHNwZWNpZmljIGNhc2UgaXMgYSBzaWxlbnQgZmFpbHVyZSBpbiBjcCwgaW5zdGFsbCwgdGFyLFxuICAvLyBhbmQgbW9zdCBvdGhlciB1bml4IHRvb2xzIHRoYXQgbWFuYWdlIHBlcm1pc3Npb25zLlxuICAvL1xuICAvLyBXaGVuIHJ1bm5pbmcgYXMgcm9vdCwgb3IgaWYgb3RoZXIgdHlwZXMgb2YgZXJyb3JzIGFyZVxuICAvLyBlbmNvdW50ZXJlZCwgdGhlbiBpdCdzIHN0cmljdC5cbiAgZnVuY3Rpb24gY2hvd25Fck9rIChlcikge1xuICAgIGlmICghZXIpXG4gICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgaWYgKGVyLmNvZGUgPT09IFwiRU5PU1lTXCIpXG4gICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgdmFyIG5vbnJvb3QgPSAhcHJvY2Vzcy5nZXR1aWQgfHwgcHJvY2Vzcy5nZXR1aWQoKSAhPT0gMFxuICAgIGlmIChub25yb290KSB7XG4gICAgICBpZiAoZXIuY29kZSA9PT0gXCJFSU5WQUxcIiB8fCBlci5jb2RlID09PSBcIkVQRVJNXCIpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbiIsInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW1cblxubW9kdWxlLmV4cG9ydHMgPSBsZWdhY3lcblxuZnVuY3Rpb24gbGVnYWN5IChmcykge1xuICByZXR1cm4ge1xuICAgIFJlYWRTdHJlYW06IFJlYWRTdHJlYW0sXG4gICAgV3JpdGVTdHJlYW06IFdyaXRlU3RyZWFtXG4gIH1cblxuICBmdW5jdGlvbiBSZWFkU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRTdHJlYW0pKSByZXR1cm4gbmV3IFJlYWRTdHJlYW0ocGF0aCwgb3B0aW9ucyk7XG5cbiAgICBTdHJlYW0uY2FsbCh0aGlzKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5mZCA9IG51bGw7XG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuZmxhZ3MgPSAncic7XG4gICAgdGhpcy5tb2RlID0gNDM4OyAvKj0wNjY2Ki9cbiAgICB0aGlzLmJ1ZmZlclNpemUgPSA2NCAqIDEwMjQ7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIE1peGluIG9wdGlvbnMgaW50byB0aGlzXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVuY29kaW5nKSB0aGlzLnNldEVuY29kaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgaWYgKHRoaXMuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdGhpcy5zdGFydCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ3N0YXJ0IG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZW5kID0gSW5maW5pdHk7XG4gICAgICB9IGVsc2UgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdGhpcy5lbmQpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdlbmQgbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdGFydCA+IHRoaXMuZW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQgbXVzdCBiZSA8PSBlbmQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZkICE9PSBudWxsKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLl9yZWFkKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmcy5vcGVuKHRoaXMucGF0aCwgdGhpcy5mbGFncywgdGhpcy5tb2RlLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgc2VsZi5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNlbGYuZmQgPSBmZDtcbiAgICAgIHNlbGYuZW1pdCgnb3BlbicsIGZkKTtcbiAgICAgIHNlbGYuX3JlYWQoKTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gV3JpdGVTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGVTdHJlYW0pKSByZXR1cm4gbmV3IFdyaXRlU3RyZWFtKHBhdGgsIG9wdGlvbnMpO1xuXG4gICAgU3RyZWFtLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuZmQgPSBudWxsO1xuICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gICAgdGhpcy5mbGFncyA9ICd3JztcbiAgICB0aGlzLmVuY29kaW5nID0gJ2JpbmFyeSc7XG4gICAgdGhpcy5tb2RlID0gNDM4OyAvKj0wNjY2Ki9cbiAgICB0aGlzLmJ5dGVzV3JpdHRlbiA9IDA7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIE1peGluIG9wdGlvbnMgaW50byB0aGlzXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIHRoaXMuc3RhcnQpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdzdGFydCBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGFydCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydCBtdXN0IGJlID49IHplcm8nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0O1xuICAgIH1cblxuICAgIHRoaXMuYnVzeSA9IGZhbHNlO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG5cbiAgICBpZiAodGhpcy5mZCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fb3BlbiA9IGZzLm9wZW47XG4gICAgICB0aGlzLl9xdWV1ZS5wdXNoKFt0aGlzLl9vcGVuLCB0aGlzLnBhdGgsIHRoaXMuZmxhZ3MsIHRoaXMubW9kZSwgdW5kZWZpbmVkXSk7XG4gICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVxuXG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqLl9fcHJvdG9fX1xufVxuXG5mdW5jdGlvbiBjbG9uZSAob2JqKSB7XG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpXG4gICAgcmV0dXJuIG9ialxuXG4gIGlmIChvYmogaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgdmFyIGNvcHkgPSB7IF9fcHJvdG9fXzogZ2V0UHJvdG90eXBlT2Yob2JqKSB9XG4gIGVsc2VcbiAgICB2YXIgY29weSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb3B5LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpKVxuICB9KVxuXG4gIHJldHVybiBjb3B5XG59XG4iLCJ2YXIgZnMgPSByZXF1aXJlKCdmcycpXG52YXIgcG9seWZpbGxzID0gcmVxdWlyZSgnLi9wb2x5ZmlsbHMuanMnKVxudmFyIGxlZ2FjeSA9IHJlcXVpcmUoJy4vbGVnYWN5LXN0cmVhbXMuanMnKVxudmFyIGNsb25lID0gcmVxdWlyZSgnLi9jbG9uZS5qcycpXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gbm9kZSAwLnggcG9seWZpbGwgKi9cbnZhciBncmFjZWZ1bFF1ZXVlXG52YXIgcHJldmlvdXNTeW1ib2xcblxuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgLSBub2RlIDAueCBwb2x5ZmlsbCAqL1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5mb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgZ3JhY2VmdWxRdWV1ZSA9IFN5bWJvbC5mb3IoJ2dyYWNlZnVsLWZzLnF1ZXVlJylcbiAgLy8gVGhpcyBpcyB1c2VkIGluIHRlc3RpbmcgYnkgZnV0dXJlIHZlcnNpb25zXG4gIHByZXZpb3VzU3ltYm9sID0gU3ltYm9sLmZvcignZ3JhY2VmdWwtZnMucHJldmlvdXMnKVxufSBlbHNlIHtcbiAgZ3JhY2VmdWxRdWV1ZSA9ICdfX19ncmFjZWZ1bC1mcy5xdWV1ZSdcbiAgcHJldmlvdXNTeW1ib2wgPSAnX19fZ3JhY2VmdWwtZnMucHJldmlvdXMnXG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuZnVuY3Rpb24gcHVibGlzaFF1ZXVlKGNvbnRleHQsIHF1ZXVlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb250ZXh0LCBncmFjZWZ1bFF1ZXVlLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBxdWV1ZVxuICAgIH1cbiAgfSlcbn1cblxudmFyIGRlYnVnID0gbm9vcFxuaWYgKHV0aWwuZGVidWdsb2cpXG4gIGRlYnVnID0gdXRpbC5kZWJ1Z2xvZygnZ2ZzNCcpXG5lbHNlIGlmICgvXFxiZ2ZzNFxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJykpXG4gIGRlYnVnID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG0gPSB1dGlsLmZvcm1hdC5hcHBseSh1dGlsLCBhcmd1bWVudHMpXG4gICAgbSA9ICdHRlM0OiAnICsgbS5zcGxpdCgvXFxuLykuam9pbignXFxuR0ZTNDogJylcbiAgICBjb25zb2xlLmVycm9yKG0pXG4gIH1cblxuLy8gT25jZSB0aW1lIGluaXRpYWxpemF0aW9uXG5pZiAoIWZzW2dyYWNlZnVsUXVldWVdKSB7XG4gIC8vIFRoaXMgcXVldWUgY2FuIGJlIHNoYXJlZCBieSBtdWx0aXBsZSBsb2FkZWQgaW5zdGFuY2VzXG4gIHZhciBxdWV1ZSA9IGdsb2JhbFtncmFjZWZ1bFF1ZXVlXSB8fCBbXVxuICBwdWJsaXNoUXVldWUoZnMsIHF1ZXVlKVxuXG4gIC8vIFBhdGNoIGZzLmNsb3NlL2Nsb3NlU3luYyB0byBzaGFyZWQgcXVldWUgdmVyc2lvbiwgYmVjYXVzZSB3ZSBuZWVkXG4gIC8vIHRvIHJldHJ5KCkgd2hlbmV2ZXIgYSBjbG9zZSBoYXBwZW5zICphbnl3aGVyZSogaW4gdGhlIHByb2dyYW0uXG4gIC8vIFRoaXMgaXMgZXNzZW50aWFsIHdoZW4gbXVsdGlwbGUgZ3JhY2VmdWwtZnMgaW5zdGFuY2VzIGFyZVxuICAvLyBpbiBwbGF5IGF0IHRoZSBzYW1lIHRpbWUuXG4gIGZzLmNsb3NlID0gKGZ1bmN0aW9uIChmcyRjbG9zZSkge1xuICAgIGZ1bmN0aW9uIGNsb3NlIChmZCwgY2IpIHtcbiAgICAgIHJldHVybiBmcyRjbG9zZS5jYWxsKGZzLCBmZCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIHVzZXMgdGhlIGdyYWNlZnVsLWZzIHNoYXJlZCBxdWV1ZVxuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIHJlc2V0UXVldWUoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9KVxuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbG9zZSwgcHJldmlvdXNTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmcyRjbG9zZVxuICAgIH0pXG4gICAgcmV0dXJuIGNsb3NlXG4gIH0pKGZzLmNsb3NlKVxuXG4gIGZzLmNsb3NlU3luYyA9IChmdW5jdGlvbiAoZnMkY2xvc2VTeW5jKSB7XG4gICAgZnVuY3Rpb24gY2xvc2VTeW5jIChmZCkge1xuICAgICAgLy8gVGhpcyBmdW5jdGlvbiB1c2VzIHRoZSBncmFjZWZ1bC1mcyBzaGFyZWQgcXVldWVcbiAgICAgIGZzJGNsb3NlU3luYy5hcHBseShmcywgYXJndW1lbnRzKVxuICAgICAgcmVzZXRRdWV1ZSgpXG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb3NlU3luYywgcHJldmlvdXNTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmcyRjbG9zZVN5bmNcbiAgICB9KVxuICAgIHJldHVybiBjbG9zZVN5bmNcbiAgfSkoZnMuY2xvc2VTeW5jKVxuXG4gIGlmICgvXFxiZ2ZzNFxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJykpIHtcbiAgICBwcm9jZXNzLm9uKCdleGl0JywgZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zyhmc1tncmFjZWZ1bFF1ZXVlXSlcbiAgICAgIHJlcXVpcmUoJ2Fzc2VydCcpLmVxdWFsKGZzW2dyYWNlZnVsUXVldWVdLmxlbmd0aCwgMClcbiAgICB9KVxuICB9XG59XG5cbmlmICghZ2xvYmFsW2dyYWNlZnVsUXVldWVdKSB7XG4gIHB1Ymxpc2hRdWV1ZShnbG9iYWwsIGZzW2dyYWNlZnVsUXVldWVdKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaChjbG9uZShmcykpXG5pZiAocHJvY2Vzcy5lbnYuVEVTVF9HUkFDRUZVTF9GU19HTE9CQUxfUEFUQ0ggJiYgIWZzLl9fcGF0Y2hlZCkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcGF0Y2goZnMpXG4gICAgZnMuX19wYXRjaGVkID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcGF0Y2ggKGZzKSB7XG4gIC8vIEV2ZXJ5dGhpbmcgdGhhdCByZWZlcmVuY2VzIHRoZSBvcGVuKCkgZnVuY3Rpb24gbmVlZHMgdG8gYmUgaW4gaGVyZVxuICBwb2x5ZmlsbHMoZnMpXG4gIGZzLmdyYWNlZnVsaWZ5ID0gcGF0Y2hcblxuICBmcy5jcmVhdGVSZWFkU3RyZWFtID0gY3JlYXRlUmVhZFN0cmVhbVxuICBmcy5jcmVhdGVXcml0ZVN0cmVhbSA9IGNyZWF0ZVdyaXRlU3RyZWFtXG4gIHZhciBmcyRyZWFkRmlsZSA9IGZzLnJlYWRGaWxlXG4gIGZzLnJlYWRGaWxlID0gcmVhZEZpbGVcbiAgZnVuY3Rpb24gcmVhZEZpbGUgKHBhdGgsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBvcHRpb25zLCBvcHRpb25zID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJHJlYWRGaWxlKHBhdGgsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kcmVhZEZpbGUgKHBhdGgsIG9wdGlvbnMsIGNiLCBzdGFydFRpbWUpIHtcbiAgICAgIHJldHVybiBmcyRyZWFkRmlsZShwYXRoLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJHJlYWRGaWxlLCBbcGF0aCwgb3B0aW9ucywgY2JdLCBlcnIsIHN0YXJ0VGltZSB8fCBEYXRlLm5vdygpLCBEYXRlLm5vdygpXSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICB2YXIgZnMkd3JpdGVGaWxlID0gZnMud3JpdGVGaWxlXG4gIGZzLndyaXRlRmlsZSA9IHdyaXRlRmlsZVxuICBmdW5jdGlvbiB3cml0ZUZpbGUgKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBvcHRpb25zLCBvcHRpb25zID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJHdyaXRlRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBjYilcblxuICAgIGZ1bmN0aW9uIGdvJHdyaXRlRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IsIHN0YXJ0VGltZSkge1xuICAgICAgcmV0dXJuIGZzJHdyaXRlRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJHdyaXRlRmlsZSwgW3BhdGgsIGRhdGEsIG9wdGlvbnMsIGNiXSwgZXJyLCBzdGFydFRpbWUgfHwgRGF0ZS5ub3coKSwgRGF0ZS5ub3coKV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgdmFyIGZzJGFwcGVuZEZpbGUgPSBmcy5hcHBlbmRGaWxlXG4gIGlmIChmcyRhcHBlbmRGaWxlKVxuICAgIGZzLmFwcGVuZEZpbGUgPSBhcHBlbmRGaWxlXG4gIGZ1bmN0aW9uIGFwcGVuZEZpbGUgKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBvcHRpb25zLCBvcHRpb25zID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJGFwcGVuZEZpbGUocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpXG5cbiAgICBmdW5jdGlvbiBnbyRhcHBlbmRGaWxlIChwYXRoLCBkYXRhLCBvcHRpb25zLCBjYiwgc3RhcnRUaW1lKSB7XG4gICAgICByZXR1cm4gZnMkYXBwZW5kRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJGFwcGVuZEZpbGUsIFtwYXRoLCBkYXRhLCBvcHRpb25zLCBjYl0sIGVyciwgc3RhcnRUaW1lIHx8IERhdGUubm93KCksIERhdGUubm93KCldKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyRjb3B5RmlsZSA9IGZzLmNvcHlGaWxlXG4gIGlmIChmcyRjb3B5RmlsZSlcbiAgICBmcy5jb3B5RmlsZSA9IGNvcHlGaWxlXG4gIGZ1bmN0aW9uIGNvcHlGaWxlIChzcmMsIGRlc3QsIGZsYWdzLCBjYikge1xuICAgIGlmICh0eXBlb2YgZmxhZ3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gZmxhZ3NcbiAgICAgIGZsYWdzID0gMFxuICAgIH1cbiAgICByZXR1cm4gZ28kY29weUZpbGUoc3JjLCBkZXN0LCBmbGFncywgY2IpXG5cbiAgICBmdW5jdGlvbiBnbyRjb3B5RmlsZSAoc3JjLCBkZXN0LCBmbGFncywgY2IsIHN0YXJ0VGltZSkge1xuICAgICAgcmV0dXJuIGZzJGNvcHlGaWxlKHNyYywgZGVzdCwgZmxhZ3MsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kY29weUZpbGUsIFtzcmMsIGRlc3QsIGZsYWdzLCBjYl0sIGVyciwgc3RhcnRUaW1lIHx8IERhdGUubm93KCksIERhdGUubm93KCldKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyRyZWFkZGlyID0gZnMucmVhZGRpclxuICBmcy5yZWFkZGlyID0gcmVhZGRpclxuICBmdW5jdGlvbiByZWFkZGlyIChwYXRoLCBvcHRpb25zLCBjYikge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gb3B0aW9ucywgb3B0aW9ucyA9IG51bGxcblxuICAgIHJldHVybiBnbyRyZWFkZGlyKHBhdGgsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kcmVhZGRpciAocGF0aCwgb3B0aW9ucywgY2IsIHN0YXJ0VGltZSkge1xuICAgICAgcmV0dXJuIGZzJHJlYWRkaXIocGF0aCwgb3B0aW9ucywgZnVuY3Rpb24gKGVyciwgZmlsZXMpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kcmVhZGRpciwgW3BhdGgsIG9wdGlvbnMsIGNiXSwgZXJyLCBzdGFydFRpbWUgfHwgRGF0ZS5ub3coKSwgRGF0ZS5ub3coKV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChmaWxlcyAmJiBmaWxlcy5zb3J0KVxuICAgICAgICAgICAgZmlsZXMuc29ydCgpXG5cbiAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IuY2FsbCh0aGlzLCBlcnIsIGZpbGVzKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLnZlcnNpb24uc3Vic3RyKDAsIDQpID09PSAndjAuOCcpIHtcbiAgICB2YXIgbGVnU3RyZWFtcyA9IGxlZ2FjeShmcylcbiAgICBSZWFkU3RyZWFtID0gbGVnU3RyZWFtcy5SZWFkU3RyZWFtXG4gICAgV3JpdGVTdHJlYW0gPSBsZWdTdHJlYW1zLldyaXRlU3RyZWFtXG4gIH1cblxuICB2YXIgZnMkUmVhZFN0cmVhbSA9IGZzLlJlYWRTdHJlYW1cbiAgaWYgKGZzJFJlYWRTdHJlYW0pIHtcbiAgICBSZWFkU3RyZWFtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZnMkUmVhZFN0cmVhbS5wcm90b3R5cGUpXG4gICAgUmVhZFN0cmVhbS5wcm90b3R5cGUub3BlbiA9IFJlYWRTdHJlYW0kb3BlblxuICB9XG5cbiAgdmFyIGZzJFdyaXRlU3RyZWFtID0gZnMuV3JpdGVTdHJlYW1cbiAgaWYgKGZzJFdyaXRlU3RyZWFtKSB7XG4gICAgV3JpdGVTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShmcyRXcml0ZVN0cmVhbS5wcm90b3R5cGUpXG4gICAgV3JpdGVTdHJlYW0ucHJvdG90eXBlLm9wZW4gPSBXcml0ZVN0cmVhbSRvcGVuXG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnMsICdSZWFkU3RyZWFtJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFJlYWRTdHJlYW1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgUmVhZFN0cmVhbSA9IHZhbFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZzLCAnV3JpdGVTdHJlYW0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gV3JpdGVTdHJlYW1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgV3JpdGVTdHJlYW0gPSB2YWxcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG5cbiAgLy8gbGVnYWN5IG5hbWVzXG4gIHZhciBGaWxlUmVhZFN0cmVhbSA9IFJlYWRTdHJlYW1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZzLCAnRmlsZVJlYWRTdHJlYW0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gRmlsZVJlYWRTdHJlYW1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgRmlsZVJlYWRTdHJlYW0gPSB2YWxcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG4gIHZhciBGaWxlV3JpdGVTdHJlYW0gPSBXcml0ZVN0cmVhbVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnMsICdGaWxlV3JpdGVTdHJlYW0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gRmlsZVdyaXRlU3RyZWFtXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIEZpbGVXcml0ZVN0cmVhbSA9IHZhbFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcblxuICBmdW5jdGlvbiBSZWFkU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBSZWFkU3RyZWFtKVxuICAgICAgcmV0dXJuIGZzJFJlYWRTdHJlYW0uYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdGhpc1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBSZWFkU3RyZWFtLmFwcGx5KE9iamVjdC5jcmVhdGUoUmVhZFN0cmVhbS5wcm90b3R5cGUpLCBhcmd1bWVudHMpXG4gIH1cblxuICBmdW5jdGlvbiBSZWFkU3RyZWFtJG9wZW4gKCkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIG9wZW4odGhhdC5wYXRoLCB0aGF0LmZsYWdzLCB0aGF0Lm1vZGUsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmICh0aGF0LmF1dG9DbG9zZSlcbiAgICAgICAgICB0aGF0LmRlc3Ryb3koKVxuXG4gICAgICAgIHRoYXQuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGF0LmZkID0gZmRcbiAgICAgICAgdGhhdC5lbWl0KCdvcGVuJywgZmQpXG4gICAgICAgIHRoYXQucmVhZCgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIFdyaXRlU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBXcml0ZVN0cmVhbSlcbiAgICAgIHJldHVybiBmcyRXcml0ZVN0cmVhbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0aGlzXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIFdyaXRlU3RyZWFtLmFwcGx5KE9iamVjdC5jcmVhdGUoV3JpdGVTdHJlYW0ucHJvdG90eXBlKSwgYXJndW1lbnRzKVxuICB9XG5cbiAgZnVuY3Rpb24gV3JpdGVTdHJlYW0kb3BlbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgb3Blbih0aGF0LnBhdGgsIHRoYXQuZmxhZ3MsIHRoYXQubW9kZSwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhhdC5kZXN0cm95KClcbiAgICAgICAgdGhhdC5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoYXQuZmQgPSBmZFxuICAgICAgICB0aGF0LmVtaXQoJ29wZW4nLCBmZClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUmVhZFN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgZnMuUmVhZFN0cmVhbShwYXRoLCBvcHRpb25zKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlV3JpdGVTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IGZzLldyaXRlU3RyZWFtKHBhdGgsIG9wdGlvbnMpXG4gIH1cblxuICB2YXIgZnMkb3BlbiA9IGZzLm9wZW5cbiAgZnMub3BlbiA9IG9wZW5cbiAgZnVuY3Rpb24gb3BlbiAocGF0aCwgZmxhZ3MsIG1vZGUsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBtb2RlID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBtb2RlLCBtb2RlID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJG9wZW4ocGF0aCwgZmxhZ3MsIG1vZGUsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kb3BlbiAocGF0aCwgZmxhZ3MsIG1vZGUsIGNiLCBzdGFydFRpbWUpIHtcbiAgICAgIHJldHVybiBmcyRvcGVuKHBhdGgsIGZsYWdzLCBtb2RlLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgICBpZiAoZXJyICYmIChlcnIuY29kZSA9PT0gJ0VNRklMRScgfHwgZXJyLmNvZGUgPT09ICdFTkZJTEUnKSlcbiAgICAgICAgICBlbnF1ZXVlKFtnbyRvcGVuLCBbcGF0aCwgZmxhZ3MsIG1vZGUsIGNiXSwgZXJyLCBzdGFydFRpbWUgfHwgRGF0ZS5ub3coKSwgRGF0ZS5ub3coKV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZzXG59XG5cbmZ1bmN0aW9uIGVucXVldWUgKGVsZW0pIHtcbiAgZGVidWcoJ0VOUVVFVUUnLCBlbGVtWzBdLm5hbWUsIGVsZW1bMV0pXG4gIGZzW2dyYWNlZnVsUXVldWVdLnB1c2goZWxlbSlcbiAgcmV0cnkoKVxufVxuXG4vLyBrZWVwIHRyYWNrIG9mIHRoZSB0aW1lb3V0IGJldHdlZW4gcmV0cnkoKSBjYWxsc1xudmFyIHJldHJ5VGltZXJcblxuLy8gcmVzZXQgdGhlIHN0YXJ0VGltZSBhbmQgbGFzdFRpbWUgdG8gbm93XG4vLyB0aGlzIHJlc2V0cyB0aGUgc3RhcnQgb2YgdGhlIDYwIHNlY29uZCBvdmVyYWxsIHRpbWVvdXQgYXMgd2VsbCBhcyB0aGVcbi8vIGRlbGF5IGJldHdlZW4gYXR0ZW1wdHMgc28gdGhhdCB3ZSdsbCByZXRyeSB0aGVzZSBqb2JzIHNvb25lclxuZnVuY3Rpb24gcmVzZXRRdWV1ZSAoKSB7XG4gIHZhciBub3cgPSBEYXRlLm5vdygpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnNbZ3JhY2VmdWxRdWV1ZV0ubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBlbnRyaWVzIHRoYXQgYXJlIG9ubHkgYSBsZW5ndGggb2YgMiBhcmUgZnJvbSBhbiBvbGRlciB2ZXJzaW9uLCBkb24ndFxuICAgIC8vIGJvdGhlciBtb2RpZnlpbmcgdGhvc2Ugc2luY2UgdGhleSdsbCBiZSByZXRyaWVkIGFueXdheS5cbiAgICBpZiAoZnNbZ3JhY2VmdWxRdWV1ZV1baV0ubGVuZ3RoID4gMikge1xuICAgICAgZnNbZ3JhY2VmdWxRdWV1ZV1baV1bM10gPSBub3cgLy8gc3RhcnRUaW1lXG4gICAgICBmc1tncmFjZWZ1bFF1ZXVlXVtpXVs0XSA9IG5vdyAvLyBsYXN0VGltZVxuICAgIH1cbiAgfVxuICAvLyBjYWxsIHJldHJ5IHRvIG1ha2Ugc3VyZSB3ZSdyZSBhY3RpdmVseSBwcm9jZXNzaW5nIHRoZSBxdWV1ZVxuICByZXRyeSgpXG59XG5cbmZ1bmN0aW9uIHJldHJ5ICgpIHtcbiAgLy8gY2xlYXIgdGhlIHRpbWVyIGFuZCByZW1vdmUgaXQgdG8gaGVscCBwcmV2ZW50IHVuaW50ZW5kZWQgY29uY3VycmVuY3lcbiAgY2xlYXJUaW1lb3V0KHJldHJ5VGltZXIpXG4gIHJldHJ5VGltZXIgPSB1bmRlZmluZWRcblxuICBpZiAoZnNbZ3JhY2VmdWxRdWV1ZV0ubGVuZ3RoID09PSAwKVxuICAgIHJldHVyblxuXG4gIHZhciBlbGVtID0gZnNbZ3JhY2VmdWxRdWV1ZV0uc2hpZnQoKVxuICB2YXIgZm4gPSBlbGVtWzBdXG4gIHZhciBhcmdzID0gZWxlbVsxXVxuICAvLyB0aGVzZSBpdGVtcyBtYXkgYmUgdW5zZXQgaWYgdGhleSB3ZXJlIGFkZGVkIGJ5IGFuIG9sZGVyIGdyYWNlZnVsLWZzXG4gIHZhciBlcnIgPSBlbGVtWzJdXG4gIHZhciBzdGFydFRpbWUgPSBlbGVtWzNdXG4gIHZhciBsYXN0VGltZSA9IGVsZW1bNF1cblxuICAvLyBpZiB3ZSBkb24ndCBoYXZlIGEgc3RhcnRUaW1lIHdlIGhhdmUgbm8gd2F5IG9mIGtub3dpbmcgaWYgd2UndmUgd2FpdGVkXG4gIC8vIGxvbmcgZW5vdWdoLCBzbyBnbyBhaGVhZCBhbmQgcmV0cnkgdGhpcyBpdGVtIG5vd1xuICBpZiAoc3RhcnRUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICBkZWJ1ZygnUkVUUlknLCBmbi5uYW1lLCBhcmdzKVxuICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpXG4gIH0gZWxzZSBpZiAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA+PSA2MDAwMCkge1xuICAgIC8vIGl0J3MgYmVlbiBtb3JlIHRoYW4gNjAgc2Vjb25kcyB0b3RhbCwgYmFpbCBub3dcbiAgICBkZWJ1ZygnVElNRU9VVCcsIGZuLm5hbWUsIGFyZ3MpXG4gICAgdmFyIGNiID0gYXJncy5wb3AoKVxuICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYi5jYWxsKG51bGwsIGVycilcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgYW1vdW50IG9mIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBhdHRlbXB0IGFuZCByaWdodCBub3dcbiAgICB2YXIgc2luY2VBdHRlbXB0ID0gRGF0ZS5ub3coKSAtIGxhc3RUaW1lXG4gICAgLy8gdGhlIGFtb3VudCBvZiB0aW1lIGJldHdlZW4gd2hlbiB3ZSBmaXJzdCB0cmllZCwgYW5kIHdoZW4gd2UgbGFzdCB0cmllZFxuICAgIC8vIHJvdW5kZWQgdXAgdG8gYXQgbGVhc3QgMVxuICAgIHZhciBzaW5jZVN0YXJ0ID0gTWF0aC5tYXgobGFzdFRpbWUgLSBzdGFydFRpbWUsIDEpXG4gICAgLy8gYmFja29mZi4gd2FpdCBsb25nZXIgdGhhbiB0aGUgdG90YWwgdGltZSB3ZSd2ZSBiZWVuIHJldHJ5aW5nLCBidXQgb25seVxuICAgIC8vIHVwIHRvIGEgbWF4aW11bSBvZiAxMDBtc1xuICAgIHZhciBkZXNpcmVkRGVsYXkgPSBNYXRoLm1pbihzaW5jZVN0YXJ0ICogMS4yLCAxMDApXG4gICAgLy8gaXQncyBiZWVuIGxvbmcgZW5vdWdoIHNpbmNlIHRoZSBsYXN0IHJldHJ5LCBkbyBpdCBhZ2FpblxuICAgIGlmIChzaW5jZUF0dGVtcHQgPj0gZGVzaXJlZERlbGF5KSB7XG4gICAgICBkZWJ1ZygnUkVUUlknLCBmbi5uYW1lLCBhcmdzKVxuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoW3N0YXJ0VGltZV0pKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiB3ZSBjYW4ndCBkbyB0aGlzIGpvYiB5ZXQsIHB1c2ggaXQgdG8gdGhlIGVuZCBvZiB0aGUgcXVldWVcbiAgICAgIC8vIGFuZCBsZXQgdGhlIG5leHQgaXRlcmF0aW9uIGNoZWNrIGFnYWluXG4gICAgICBmc1tncmFjZWZ1bFF1ZXVlXS5wdXNoKGVsZW0pXG4gICAgfVxuICB9XG5cbiAgLy8gc2NoZWR1bGUgb3VyIG5leHQgcnVuIGlmIG9uZSBpc24ndCBhbHJlYWR5IHNjaGVkdWxlZFxuICBpZiAocmV0cnlUaW1lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0cnlUaW1lciA9IHNldFRpbWVvdXQocmV0cnksIDApXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuLy8gVGhpcyBpcyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL25vcm1hbGl6ZS9telxuLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTYgSm9uYXRoYW4gT25nIG1lQGpvbmdsZWJlcnJ5LmNvbSBhbmQgQ29udHJpYnV0b3JzXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcblxuY29uc3QgYXBpID0gW1xuICAnYWNjZXNzJyxcbiAgJ2FwcGVuZEZpbGUnLFxuICAnY2htb2QnLFxuICAnY2hvd24nLFxuICAnY2xvc2UnLFxuICAnY29weUZpbGUnLFxuICAnZmNobW9kJyxcbiAgJ2ZjaG93bicsXG4gICdmZGF0YXN5bmMnLFxuICAnZnN0YXQnLFxuICAnZnN5bmMnLFxuICAnZnRydW5jYXRlJyxcbiAgJ2Z1dGltZXMnLFxuICAnbGNobW9kJyxcbiAgJ2xjaG93bicsXG4gICdsaW5rJyxcbiAgJ2xzdGF0JyxcbiAgJ21rZGlyJyxcbiAgJ21rZHRlbXAnLFxuICAnb3BlbicsXG4gICdvcGVuZGlyJyxcbiAgJ3JlYWRkaXInLFxuICAncmVhZEZpbGUnLFxuICAncmVhZGxpbmsnLFxuICAncmVhbHBhdGgnLFxuICAncmVuYW1lJyxcbiAgJ3JtJyxcbiAgJ3JtZGlyJyxcbiAgJ3N0YXQnLFxuICAnc3ltbGluaycsXG4gICd0cnVuY2F0ZScsXG4gICd1bmxpbmsnLFxuICAndXRpbWVzJyxcbiAgJ3dyaXRlRmlsZSdcbl0uZmlsdGVyKGtleSA9PiB7XG4gIC8vIFNvbWUgY29tbWFuZHMgYXJlIG5vdCBhdmFpbGFibGUgb24gc29tZSBzeXN0ZW1zLiBFeDpcbiAgLy8gZnMuY3Agd2FzIGFkZGVkIGluIE5vZGUuanMgdjE2LjcuMFxuICAvLyBmcy5sY2hvd24gaXMgbm90IGF2YWlsYWJsZSBvbiBhdCBsZWFzdCBzb21lIExpbnV4XG4gIHJldHVybiB0eXBlb2YgZnNba2V5XSA9PT0gJ2Z1bmN0aW9uJ1xufSlcblxuLy8gRXhwb3J0IGNsb25lZCBmczpcbk9iamVjdC5hc3NpZ24oZXhwb3J0cywgZnMpXG5cbi8vIFVuaXZlcnNhbGlmeSBhc3luYyBtZXRob2RzOlxuYXBpLmZvckVhY2gobWV0aG9kID0+IHtcbiAgZXhwb3J0c1ttZXRob2RdID0gdShmc1ttZXRob2RdKVxufSlcblxuLy8gV2UgZGlmZmVyIGZyb20gbXovZnMgaW4gdGhhdCB3ZSBzdGlsbCBzaGlwIHRoZSBvbGQsIGJyb2tlbiwgZnMuZXhpc3RzKClcbi8vIHNpbmNlIHdlIGFyZSBhIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIHRoZSBuYXRpdmUgbW9kdWxlXG5leHBvcnRzLmV4aXN0cyA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmcy5leGlzdHMoZmlsZW5hbWUsIGNhbGxiYWNrKVxuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICByZXR1cm4gZnMuZXhpc3RzKGZpbGVuYW1lLCByZXNvbHZlKVxuICB9KVxufVxuXG4vLyBmcy5yZWFkKCksIGZzLndyaXRlKCksIGZzLnJlYWR2KCksICYgZnMud3JpdGV2KCkgbmVlZCBzcGVjaWFsIHRyZWF0bWVudCBkdWUgdG8gbXVsdGlwbGUgY2FsbGJhY2sgYXJnc1xuXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZzLnJlYWQoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaylcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZzLnJlYWQoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCAoZXJyLCBieXRlc1JlYWQsIGJ1ZmZlcikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICByZXNvbHZlKHsgYnl0ZXNSZWFkLCBidWZmZXIgfSlcbiAgICB9KVxuICB9KVxufVxuXG4vLyBGdW5jdGlvbiBzaWduYXR1cmUgY2FuIGJlXG4vLyBmcy53cml0ZShmZCwgYnVmZmVyWywgb2Zmc2V0WywgbGVuZ3RoWywgcG9zaXRpb25dXV0sIGNhbGxiYWNrKVxuLy8gT1Jcbi8vIGZzLndyaXRlKGZkLCBzdHJpbmdbLCBwb3NpdGlvblssIGVuY29kaW5nXV0sIGNhbGxiYWNrKVxuLy8gV2UgbmVlZCB0byBoYW5kbGUgYm90aCBjYXNlcywgc28gd2UgdXNlIC4uLmFyZ3NcbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoZmQsIGJ1ZmZlciwgLi4uYXJncykge1xuICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmcy53cml0ZShmZCwgYnVmZmVyLCAuLi5hcmdzKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmcy53cml0ZShmZCwgYnVmZmVyLCAuLi5hcmdzLCAoZXJyLCBieXRlc1dyaXR0ZW4sIGJ1ZmZlcikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICByZXNvbHZlKHsgYnl0ZXNXcml0dGVuLCBidWZmZXIgfSlcbiAgICB9KVxuICB9KVxufVxuXG4vLyBGdW5jdGlvbiBzaWduYXR1cmUgaXNcbi8vIHMucmVhZHYoZmQsIGJ1ZmZlcnNbLCBwb3NpdGlvbl0sIGNhbGxiYWNrKVxuLy8gV2UgbmVlZCB0byBoYW5kbGUgdGhlIG9wdGlvbmFsIGFyZywgc28gd2UgdXNlIC4uLmFyZ3NcbmV4cG9ydHMucmVhZHYgPSBmdW5jdGlvbiAoZmQsIGJ1ZmZlcnMsIC4uLmFyZ3MpIHtcbiAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnMucmVhZHYoZmQsIGJ1ZmZlcnMsIC4uLmFyZ3MpXG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZzLnJlYWR2KGZkLCBidWZmZXJzLCAuLi5hcmdzLCAoZXJyLCBieXRlc1JlYWQsIGJ1ZmZlcnMpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgcmVzb2x2ZSh7IGJ5dGVzUmVhZCwgYnVmZmVycyB9KVxuICAgIH0pXG4gIH0pXG59XG5cbi8vIEZ1bmN0aW9uIHNpZ25hdHVyZSBpc1xuLy8gcy53cml0ZXYoZmQsIGJ1ZmZlcnNbLCBwb3NpdGlvbl0sIGNhbGxiYWNrKVxuLy8gV2UgbmVlZCB0byBoYW5kbGUgdGhlIG9wdGlvbmFsIGFyZywgc28gd2UgdXNlIC4uLmFyZ3NcbmV4cG9ydHMud3JpdGV2ID0gZnVuY3Rpb24gKGZkLCBidWZmZXJzLCAuLi5hcmdzKSB7XG4gIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZzLndyaXRldihmZCwgYnVmZmVycywgLi4uYXJncylcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnMud3JpdGV2KGZkLCBidWZmZXJzLCAuLi5hcmdzLCAoZXJyLCBieXRlc1dyaXR0ZW4sIGJ1ZmZlcnMpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgcmVzb2x2ZSh7IGJ5dGVzV3JpdHRlbiwgYnVmZmVycyB9KVxuICAgIH0pXG4gIH0pXG59XG5cbi8vIGZzLnJlYWxwYXRoLm5hdGl2ZSBzb21ldGltZXMgbm90IGF2YWlsYWJsZSBpZiBmcyBpcyBtb25rZXktcGF0Y2hlZFxuaWYgKHR5cGVvZiBmcy5yZWFscGF0aC5uYXRpdmUgPT09ICdmdW5jdGlvbicpIHtcbiAgZXhwb3J0cy5yZWFscGF0aC5uYXRpdmUgPSB1KGZzLnJlYWxwYXRoLm5hdGl2ZSlcbn0gZWxzZSB7XG4gIHByb2Nlc3MuZW1pdFdhcm5pbmcoXG4gICAgJ2ZzLnJlYWxwYXRoLm5hdGl2ZSBpcyBub3QgYSBmdW5jdGlvbi4gSXMgZnMgYmVpbmcgbW9ua2V5LXBhdGNoZWQ/JyxcbiAgICAnV2FybmluZycsICdmcy1leHRyYS1XQVJOMDAwMydcbiAgKVxufVxuIiwiLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvbWFrZS1kaXJcbi8vIENvcHlyaWdodCAoYykgU2luZHJlIFNvcmh1cyA8c2luZHJlc29yaHVzQGdtYWlsLmNvbT4gKHNpbmRyZXNvcmh1cy5jb20pXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbid1c2Ugc3RyaWN0J1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzg5ODdcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9saWJ1di9saWJ1di9wdWxsLzEwODhcbm1vZHVsZS5leHBvcnRzLmNoZWNrUGF0aCA9IGZ1bmN0aW9uIGNoZWNrUGF0aCAocHRoKSB7XG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgY29uc3QgcGF0aEhhc0ludmFsaWRXaW5DaGFyYWN0ZXJzID0gL1s8PjpcInw/Kl0vLnRlc3QocHRoLnJlcGxhY2UocGF0aC5wYXJzZShwdGgpLnJvb3QsICcnKSlcblxuICAgIGlmIChwYXRoSGFzSW52YWxpZFdpbkNoYXJhY3RlcnMpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBQYXRoIGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVyczogJHtwdGh9YClcbiAgICAgIGVycm9yLmNvZGUgPSAnRUlOVkFMJ1xuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5jb25zdCB7IGNoZWNrUGF0aCB9ID0gcmVxdWlyZSgnLi91dGlscycpXG5cbmNvbnN0IGdldE1vZGUgPSBvcHRpb25zID0+IHtcbiAgY29uc3QgZGVmYXVsdHMgPSB7IG1vZGU6IDBvNzc3IH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykgcmV0dXJuIG9wdGlvbnNcbiAgcmV0dXJuICh7IC4uLmRlZmF1bHRzLCAuLi5vcHRpb25zIH0pLm1vZGVcbn1cblxubW9kdWxlLmV4cG9ydHMubWFrZURpciA9IGFzeW5jIChkaXIsIG9wdGlvbnMpID0+IHtcbiAgY2hlY2tQYXRoKGRpcilcblxuICByZXR1cm4gZnMubWtkaXIoZGlyLCB7XG4gICAgbW9kZTogZ2V0TW9kZShvcHRpb25zKSxcbiAgICByZWN1cnNpdmU6IHRydWVcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMubWFrZURpclN5bmMgPSAoZGlyLCBvcHRpb25zKSA9PiB7XG4gIGNoZWNrUGF0aChkaXIpXG5cbiAgcmV0dXJuIGZzLm1rZGlyU3luYyhkaXIsIHtcbiAgICBtb2RlOiBnZXRNb2RlKG9wdGlvbnMpLFxuICAgIHJlY3Vyc2l2ZTogdHJ1ZVxuICB9KVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2VcbmNvbnN0IHsgbWFrZURpcjogX21ha2VEaXIsIG1ha2VEaXJTeW5jIH0gPSByZXF1aXJlKCcuL21ha2UtZGlyJylcbmNvbnN0IG1ha2VEaXIgPSB1KF9tYWtlRGlyKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWtkaXJzOiBtYWtlRGlyLFxuICBta2RpcnNTeW5jOiBtYWtlRGlyU3luYyxcbiAgLy8gYWxpYXNcbiAgbWtkaXJwOiBtYWtlRGlyLFxuICBta2RpcnBTeW5jOiBtYWtlRGlyU3luYyxcbiAgZW5zdXJlRGlyOiBtYWtlRGlyLFxuICBlbnN1cmVEaXJTeW5jOiBtYWtlRGlyU3luY1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2VcbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vZnMnKVxuXG5mdW5jdGlvbiBwYXRoRXhpc3RzIChwYXRoKSB7XG4gIHJldHVybiBmcy5hY2Nlc3MocGF0aCkudGhlbigoKSA9PiB0cnVlKS5jYXRjaCgoKSA9PiBmYWxzZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhdGhFeGlzdHM6IHUocGF0aEV4aXN0cyksXG4gIHBhdGhFeGlzdHNTeW5jOiBmcy5leGlzdHNTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2VcblxuYXN5bmMgZnVuY3Rpb24gdXRpbWVzTWlsbGlzIChwYXRoLCBhdGltZSwgbXRpbWUpIHtcbiAgLy8gaWYgKCFIQVNfTUlMTElTX1JFUykgcmV0dXJuIGZzLnV0aW1lcyhwYXRoLCBhdGltZSwgbXRpbWUsIGNhbGxiYWNrKVxuICBjb25zdCBmZCA9IGF3YWl0IGZzLm9wZW4ocGF0aCwgJ3IrJylcblxuICBsZXQgY2xvc2VFcnIgPSBudWxsXG5cbiAgdHJ5IHtcbiAgICBhd2FpdCBmcy5mdXRpbWVzKGZkLCBhdGltZSwgbXRpbWUpXG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGZzLmNsb3NlKGZkKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNsb3NlRXJyID0gZVxuICAgIH1cbiAgfVxuXG4gIGlmIChjbG9zZUVycikge1xuICAgIHRocm93IGNsb3NlRXJyXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRpbWVzTWlsbGlzU3luYyAocGF0aCwgYXRpbWUsIG10aW1lKSB7XG4gIGNvbnN0IGZkID0gZnMub3BlblN5bmMocGF0aCwgJ3IrJylcbiAgZnMuZnV0aW1lc1N5bmMoZmQsIGF0aW1lLCBtdGltZSlcbiAgcmV0dXJuIGZzLmNsb3NlU3luYyhmZClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHV0aW1lc01pbGxpczogdSh1dGltZXNNaWxsaXMpLFxuICB1dGltZXNNaWxsaXNTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2VcblxuZnVuY3Rpb24gZ2V0U3RhdHMgKHNyYywgZGVzdCwgb3B0cykge1xuICBjb25zdCBzdGF0RnVuYyA9IG9wdHMuZGVyZWZlcmVuY2VcbiAgICA/IChmaWxlKSA9PiBmcy5zdGF0KGZpbGUsIHsgYmlnaW50OiB0cnVlIH0pXG4gICAgOiAoZmlsZSkgPT4gZnMubHN0YXQoZmlsZSwgeyBiaWdpbnQ6IHRydWUgfSlcbiAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICBzdGF0RnVuYyhzcmMpLFxuICAgIHN0YXRGdW5jKGRlc3QpLmNhdGNoKGVyciA9PiB7XG4gICAgICBpZiAoZXJyLmNvZGUgPT09ICdFTk9FTlQnKSByZXR1cm4gbnVsbFxuICAgICAgdGhyb3cgZXJyXG4gICAgfSlcbiAgXSkudGhlbigoW3NyY1N0YXQsIGRlc3RTdGF0XSkgPT4gKHsgc3JjU3RhdCwgZGVzdFN0YXQgfSkpXG59XG5cbmZ1bmN0aW9uIGdldFN0YXRzU3luYyAoc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGxldCBkZXN0U3RhdFxuICBjb25zdCBzdGF0RnVuYyA9IG9wdHMuZGVyZWZlcmVuY2VcbiAgICA/IChmaWxlKSA9PiBmcy5zdGF0U3luYyhmaWxlLCB7IGJpZ2ludDogdHJ1ZSB9KVxuICAgIDogKGZpbGUpID0+IGZzLmxzdGF0U3luYyhmaWxlLCB7IGJpZ2ludDogdHJ1ZSB9KVxuICBjb25zdCBzcmNTdGF0ID0gc3RhdEZ1bmMoc3JjKVxuICB0cnkge1xuICAgIGRlc3RTdGF0ID0gc3RhdEZ1bmMoZGVzdClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykgcmV0dXJuIHsgc3JjU3RhdCwgZGVzdFN0YXQ6IG51bGwgfVxuICAgIHRocm93IGVyclxuICB9XG4gIHJldHVybiB7IHNyY1N0YXQsIGRlc3RTdGF0IH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gY2hlY2tQYXRocyAoc3JjLCBkZXN0LCBmdW5jTmFtZSwgb3B0cykge1xuICBjb25zdCB7IHNyY1N0YXQsIGRlc3RTdGF0IH0gPSBhd2FpdCBnZXRTdGF0cyhzcmMsIGRlc3QsIG9wdHMpXG4gIGlmIChkZXN0U3RhdCkge1xuICAgIGlmIChhcmVJZGVudGljYWwoc3JjU3RhdCwgZGVzdFN0YXQpKSB7XG4gICAgICBjb25zdCBzcmNCYXNlTmFtZSA9IHBhdGguYmFzZW5hbWUoc3JjKVxuICAgICAgY29uc3QgZGVzdEJhc2VOYW1lID0gcGF0aC5iYXNlbmFtZShkZXN0KVxuICAgICAgaWYgKGZ1bmNOYW1lID09PSAnbW92ZScgJiZcbiAgICAgICAgc3JjQmFzZU5hbWUgIT09IGRlc3RCYXNlTmFtZSAmJlxuICAgICAgICBzcmNCYXNlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBkZXN0QmFzZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICByZXR1cm4geyBzcmNTdGF0LCBkZXN0U3RhdCwgaXNDaGFuZ2luZ0Nhc2U6IHRydWUgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTb3VyY2UgYW5kIGRlc3RpbmF0aW9uIG11c3Qgbm90IGJlIHRoZSBzYW1lLicpXG4gICAgfVxuICAgIGlmIChzcmNTdGF0LmlzRGlyZWN0b3J5KCkgJiYgIWRlc3RTdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IG92ZXJ3cml0ZSBub24tZGlyZWN0b3J5ICcke2Rlc3R9JyB3aXRoIGRpcmVjdG9yeSAnJHtzcmN9Jy5gKVxuICAgIH1cbiAgICBpZiAoIXNyY1N0YXQuaXNEaXJlY3RvcnkoKSAmJiBkZXN0U3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBvdmVyd3JpdGUgZGlyZWN0b3J5ICcke2Rlc3R9JyB3aXRoIG5vbi1kaXJlY3RvcnkgJyR7c3JjfScuYClcbiAgICB9XG4gIH1cblxuICBpZiAoc3JjU3RhdC5pc0RpcmVjdG9yeSgpICYmIGlzU3JjU3ViZGlyKHNyYywgZGVzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKHNyYywgZGVzdCwgZnVuY05hbWUpKVxuICB9XG5cbiAgcmV0dXJuIHsgc3JjU3RhdCwgZGVzdFN0YXQgfVxufVxuXG5mdW5jdGlvbiBjaGVja1BhdGhzU3luYyAoc3JjLCBkZXN0LCBmdW5jTmFtZSwgb3B0cykge1xuICBjb25zdCB7IHNyY1N0YXQsIGRlc3RTdGF0IH0gPSBnZXRTdGF0c1N5bmMoc3JjLCBkZXN0LCBvcHRzKVxuXG4gIGlmIChkZXN0U3RhdCkge1xuICAgIGlmIChhcmVJZGVudGljYWwoc3JjU3RhdCwgZGVzdFN0YXQpKSB7XG4gICAgICBjb25zdCBzcmNCYXNlTmFtZSA9IHBhdGguYmFzZW5hbWUoc3JjKVxuICAgICAgY29uc3QgZGVzdEJhc2VOYW1lID0gcGF0aC5iYXNlbmFtZShkZXN0KVxuICAgICAgaWYgKGZ1bmNOYW1lID09PSAnbW92ZScgJiZcbiAgICAgICAgc3JjQmFzZU5hbWUgIT09IGRlc3RCYXNlTmFtZSAmJlxuICAgICAgICBzcmNCYXNlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBkZXN0QmFzZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICByZXR1cm4geyBzcmNTdGF0LCBkZXN0U3RhdCwgaXNDaGFuZ2luZ0Nhc2U6IHRydWUgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTb3VyY2UgYW5kIGRlc3RpbmF0aW9uIG11c3Qgbm90IGJlIHRoZSBzYW1lLicpXG4gICAgfVxuICAgIGlmIChzcmNTdGF0LmlzRGlyZWN0b3J5KCkgJiYgIWRlc3RTdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IG92ZXJ3cml0ZSBub24tZGlyZWN0b3J5ICcke2Rlc3R9JyB3aXRoIGRpcmVjdG9yeSAnJHtzcmN9Jy5gKVxuICAgIH1cbiAgICBpZiAoIXNyY1N0YXQuaXNEaXJlY3RvcnkoKSAmJiBkZXN0U3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBvdmVyd3JpdGUgZGlyZWN0b3J5ICcke2Rlc3R9JyB3aXRoIG5vbi1kaXJlY3RvcnkgJyR7c3JjfScuYClcbiAgICB9XG4gIH1cblxuICBpZiAoc3JjU3RhdC5pc0RpcmVjdG9yeSgpICYmIGlzU3JjU3ViZGlyKHNyYywgZGVzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKHNyYywgZGVzdCwgZnVuY05hbWUpKVxuICB9XG4gIHJldHVybiB7IHNyY1N0YXQsIGRlc3RTdGF0IH1cbn1cblxuLy8gcmVjdXJzaXZlbHkgY2hlY2sgaWYgZGVzdCBwYXJlbnQgaXMgYSBzdWJkaXJlY3Rvcnkgb2Ygc3JjLlxuLy8gSXQgd29ya3MgZm9yIGFsbCBmaWxlIHR5cGVzIGluY2x1ZGluZyBzeW1saW5rcyBzaW5jZSBpdFxuLy8gY2hlY2tzIHRoZSBzcmMgYW5kIGRlc3QgaW5vZGVzLiBJdCBzdGFydHMgZnJvbSB0aGUgZGVlcGVzdFxuLy8gcGFyZW50IGFuZCBzdG9wcyBvbmNlIGl0IHJlYWNoZXMgdGhlIHNyYyBwYXJlbnQgb3IgdGhlIHJvb3QgcGF0aC5cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrUGFyZW50UGF0aHMgKHNyYywgc3JjU3RhdCwgZGVzdCwgZnVuY05hbWUpIHtcbiAgY29uc3Qgc3JjUGFyZW50ID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShzcmMpKVxuICBjb25zdCBkZXN0UGFyZW50ID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShkZXN0KSlcbiAgaWYgKGRlc3RQYXJlbnQgPT09IHNyY1BhcmVudCB8fCBkZXN0UGFyZW50ID09PSBwYXRoLnBhcnNlKGRlc3RQYXJlbnQpLnJvb3QpIHJldHVyblxuXG4gIGxldCBkZXN0U3RhdFxuICB0cnkge1xuICAgIGRlc3RTdGF0ID0gYXdhaXQgZnMuc3RhdChkZXN0UGFyZW50LCB7IGJpZ2ludDogdHJ1ZSB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgPT09ICdFTk9FTlQnKSByZXR1cm5cbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIGlmIChhcmVJZGVudGljYWwoc3JjU3RhdCwgZGVzdFN0YXQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyhzcmMsIGRlc3QsIGZ1bmNOYW1lKSlcbiAgfVxuXG4gIHJldHVybiBjaGVja1BhcmVudFBhdGhzKHNyYywgc3JjU3RhdCwgZGVzdFBhcmVudCwgZnVuY05hbWUpXG59XG5cbmZ1bmN0aW9uIGNoZWNrUGFyZW50UGF0aHNTeW5jIChzcmMsIHNyY1N0YXQsIGRlc3QsIGZ1bmNOYW1lKSB7XG4gIGNvbnN0IHNyY1BhcmVudCA9IHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUoc3JjKSlcbiAgY29uc3QgZGVzdFBhcmVudCA9IHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUoZGVzdCkpXG4gIGlmIChkZXN0UGFyZW50ID09PSBzcmNQYXJlbnQgfHwgZGVzdFBhcmVudCA9PT0gcGF0aC5wYXJzZShkZXN0UGFyZW50KS5yb290KSByZXR1cm5cbiAgbGV0IGRlc3RTdGF0XG4gIHRyeSB7XG4gICAgZGVzdFN0YXQgPSBmcy5zdGF0U3luYyhkZXN0UGFyZW50LCB7IGJpZ2ludDogdHJ1ZSB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgPT09ICdFTk9FTlQnKSByZXR1cm5cbiAgICB0aHJvdyBlcnJcbiAgfVxuICBpZiAoYXJlSWRlbnRpY2FsKHNyY1N0YXQsIGRlc3RTdGF0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2coc3JjLCBkZXN0LCBmdW5jTmFtZSkpXG4gIH1cbiAgcmV0dXJuIGNoZWNrUGFyZW50UGF0aHNTeW5jKHNyYywgc3JjU3RhdCwgZGVzdFBhcmVudCwgZnVuY05hbWUpXG59XG5cbmZ1bmN0aW9uIGFyZUlkZW50aWNhbCAoc3JjU3RhdCwgZGVzdFN0YXQpIHtcbiAgcmV0dXJuIGRlc3RTdGF0LmlubyAmJiBkZXN0U3RhdC5kZXYgJiYgZGVzdFN0YXQuaW5vID09PSBzcmNTdGF0LmlubyAmJiBkZXN0U3RhdC5kZXYgPT09IHNyY1N0YXQuZGV2XG59XG5cbi8vIHJldHVybiB0cnVlIGlmIGRlc3QgaXMgYSBzdWJkaXIgb2Ygc3JjLCBvdGhlcndpc2UgZmFsc2UuXG4vLyBJdCBvbmx5IGNoZWNrcyB0aGUgcGF0aCBzdHJpbmdzLlxuZnVuY3Rpb24gaXNTcmNTdWJkaXIgKHNyYywgZGVzdCkge1xuICBjb25zdCBzcmNBcnIgPSBwYXRoLnJlc29sdmUoc3JjKS5zcGxpdChwYXRoLnNlcCkuZmlsdGVyKGkgPT4gaSlcbiAgY29uc3QgZGVzdEFyciA9IHBhdGgucmVzb2x2ZShkZXN0KS5zcGxpdChwYXRoLnNlcCkuZmlsdGVyKGkgPT4gaSlcbiAgcmV0dXJuIHNyY0Fyci5ldmVyeSgoY3VyLCBpKSA9PiBkZXN0QXJyW2ldID09PSBjdXIpXG59XG5cbmZ1bmN0aW9uIGVyck1zZyAoc3JjLCBkZXN0LCBmdW5jTmFtZSkge1xuICByZXR1cm4gYENhbm5vdCAke2Z1bmNOYW1lfSAnJHtzcmN9JyB0byBhIHN1YmRpcmVjdG9yeSBvZiBpdHNlbGYsICcke2Rlc3R9Jy5gXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBjaGVja1BhdGhzXG4gIGNoZWNrUGF0aHM6IHUoY2hlY2tQYXRocyksXG4gIGNoZWNrUGF0aHNTeW5jLFxuICAvLyBjaGVja1BhcmVudFxuICBjaGVja1BhcmVudFBhdGhzOiB1KGNoZWNrUGFyZW50UGF0aHMpLFxuICBjaGVja1BhcmVudFBhdGhzU3luYyxcbiAgLy8gTWlzY1xuICBpc1NyY1N1YmRpcixcbiAgYXJlSWRlbnRpY2FsXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCB7IG1rZGlycyB9ID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHsgcGF0aEV4aXN0cyB9ID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKVxuY29uc3QgeyB1dGltZXNNaWxsaXMgfSA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbWVzJylcbmNvbnN0IHN0YXQgPSByZXF1aXJlKCcuLi91dGlsL3N0YXQnKVxuXG5hc3luYyBmdW5jdGlvbiBjb3B5IChzcmMsIGRlc3QsIG9wdHMgPSB7fSkge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRzID0geyBmaWx0ZXI6IG9wdHMgfVxuICB9XG5cbiAgb3B0cy5jbG9iYmVyID0gJ2Nsb2JiZXInIGluIG9wdHMgPyAhIW9wdHMuY2xvYmJlciA6IHRydWUgLy8gZGVmYXVsdCB0byB0cnVlIGZvciBub3dcbiAgb3B0cy5vdmVyd3JpdGUgPSAnb3ZlcndyaXRlJyBpbiBvcHRzID8gISFvcHRzLm92ZXJ3cml0ZSA6IG9wdHMuY2xvYmJlciAvLyBvdmVyd3JpdGUgZmFsbHMgYmFjayB0byBjbG9iYmVyXG5cbiAgLy8gV2FybiBhYm91dCB1c2luZyBwcmVzZXJ2ZVRpbWVzdGFtcHMgb24gMzItYml0IG5vZGVcbiAgaWYgKG9wdHMucHJlc2VydmVUaW1lc3RhbXBzICYmIHByb2Nlc3MuYXJjaCA9PT0gJ2lhMzInKSB7XG4gICAgcHJvY2Vzcy5lbWl0V2FybmluZyhcbiAgICAgICdVc2luZyB0aGUgcHJlc2VydmVUaW1lc3RhbXBzIG9wdGlvbiBpbiAzMi1iaXQgbm9kZSBpcyBub3QgcmVjb21tZW5kZWQ7XFxuXFxuJyArXG4gICAgICAnXFx0c2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcHJpY2hhcmRzb24vbm9kZS1mcy1leHRyYS9pc3N1ZXMvMjY5JyxcbiAgICAgICdXYXJuaW5nJywgJ2ZzLWV4dHJhLVdBUk4wMDAxJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHsgc3JjU3RhdCwgZGVzdFN0YXQgfSA9IGF3YWl0IHN0YXQuY2hlY2tQYXRocyhzcmMsIGRlc3QsICdjb3B5Jywgb3B0cylcblxuICBhd2FpdCBzdGF0LmNoZWNrUGFyZW50UGF0aHMoc3JjLCBzcmNTdGF0LCBkZXN0LCAnY29weScpXG5cbiAgY29uc3QgaW5jbHVkZSA9IGF3YWl0IHJ1bkZpbHRlcihzcmMsIGRlc3QsIG9wdHMpXG5cbiAgaWYgKCFpbmNsdWRlKSByZXR1cm5cblxuICAvLyBjaGVjayBpZiB0aGUgcGFyZW50IG9mIGRlc3QgZXhpc3RzLCBhbmQgY3JlYXRlIGl0IGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgY29uc3QgZGVzdFBhcmVudCA9IHBhdGguZGlybmFtZShkZXN0KVxuICBjb25zdCBkaXJFeGlzdHMgPSBhd2FpdCBwYXRoRXhpc3RzKGRlc3RQYXJlbnQpXG4gIGlmICghZGlyRXhpc3RzKSB7XG4gICAgYXdhaXQgbWtkaXJzKGRlc3RQYXJlbnQpXG4gIH1cblxuICBhd2FpdCBnZXRTdGF0c0FuZFBlcmZvcm1Db3B5KGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJ1bkZpbHRlciAoc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmICghb3B0cy5maWx0ZXIpIHJldHVybiB0cnVlXG4gIHJldHVybiBvcHRzLmZpbHRlcihzcmMsIGRlc3QpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFN0YXRzQW5kUGVyZm9ybUNvcHkgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgY29uc3Qgc3RhdEZuID0gb3B0cy5kZXJlZmVyZW5jZSA/IGZzLnN0YXQgOiBmcy5sc3RhdFxuICBjb25zdCBzcmNTdGF0ID0gYXdhaXQgc3RhdEZuKHNyYylcblxuICBpZiAoc3JjU3RhdC5pc0RpcmVjdG9yeSgpKSByZXR1cm4gb25EaXIoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcblxuICBpZiAoXG4gICAgc3JjU3RhdC5pc0ZpbGUoKSB8fFxuICAgIHNyY1N0YXQuaXNDaGFyYWN0ZXJEZXZpY2UoKSB8fFxuICAgIHNyY1N0YXQuaXNCbG9ja0RldmljZSgpXG4gICkgcmV0dXJuIG9uRmlsZShzcmNTdGF0LCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxuXG4gIGlmIChzcmNTdGF0LmlzU3ltYm9saWNMaW5rKCkpIHJldHVybiBvbkxpbmsoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcbiAgaWYgKHNyY1N0YXQuaXNTb2NrZXQoKSkgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29weSBhIHNvY2tldCBmaWxlOiAke3NyY31gKVxuICBpZiAoc3JjU3RhdC5pc0ZJRk8oKSkgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29weSBhIEZJRk8gcGlwZTogJHtzcmN9YClcbiAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGZpbGU6ICR7c3JjfWApXG59XG5cbmFzeW5jIGZ1bmN0aW9uIG9uRmlsZSAoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBpZiAoIWRlc3RTdGF0KSByZXR1cm4gY29weUZpbGUoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxuXG4gIGlmIChvcHRzLm92ZXJ3cml0ZSkge1xuICAgIGF3YWl0IGZzLnVubGluayhkZXN0KVxuICAgIHJldHVybiBjb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIH1cbiAgaWYgKG9wdHMuZXJyb3JPbkV4aXN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAnJHtkZXN0fScgYWxyZWFkeSBleGlzdHNgKVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvcHlGaWxlIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgYXdhaXQgZnMuY29weUZpbGUoc3JjLCBkZXN0KVxuICBpZiAob3B0cy5wcmVzZXJ2ZVRpbWVzdGFtcHMpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGZpbGUgaXMgd3JpdGFibGUgYmVmb3JlIHNldHRpbmcgdGhlIHRpbWVzdGFtcFxuICAgIC8vIG90aGVyd2lzZSBvcGVuIGZhaWxzIHdpdGggRVBFUk0gd2hlbiBpbnZva2VkIHdpdGggJ3IrJ1xuICAgIC8vICh0aHJvdWdoIHV0aW1lcyBjYWxsKVxuICAgIGlmIChmaWxlSXNOb3RXcml0YWJsZShzcmNTdGF0Lm1vZGUpKSB7XG4gICAgICBhd2FpdCBtYWtlRmlsZVdyaXRhYmxlKGRlc3QsIHNyY1N0YXQubW9kZSlcbiAgICB9XG5cbiAgICAvLyBTZXQgdGltZXN0YW1wcyBhbmQgbW9kZSBjb3JyZXNwb25kaW5nbHlcblxuICAgIC8vIE5vdGUgdGhhdCBUaGUgaW5pdGlhbCBzcmNTdGF0LmF0aW1lIGNhbm5vdCBiZSB0cnVzdGVkXG4gICAgLy8gYmVjYXVzZSBpdCBpcyBtb2RpZmllZCBieSB0aGUgcmVhZCgyKSBzeXN0ZW0gY2FsbFxuICAgIC8vIChTZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sI2ZzX3N0YXRfdGltZV92YWx1ZXMpXG4gICAgY29uc3QgdXBkYXRlZFNyY1N0YXQgPSBhd2FpdCBmcy5zdGF0KHNyYylcbiAgICBhd2FpdCB1dGltZXNNaWxsaXMoZGVzdCwgdXBkYXRlZFNyY1N0YXQuYXRpbWUsIHVwZGF0ZWRTcmNTdGF0Lm10aW1lKVxuICB9XG5cbiAgcmV0dXJuIGZzLmNobW9kKGRlc3QsIHNyY1N0YXQubW9kZSlcbn1cblxuZnVuY3Rpb24gZmlsZUlzTm90V3JpdGFibGUgKHNyY01vZGUpIHtcbiAgcmV0dXJuIChzcmNNb2RlICYgMG8yMDApID09PSAwXG59XG5cbmZ1bmN0aW9uIG1ha2VGaWxlV3JpdGFibGUgKGRlc3QsIHNyY01vZGUpIHtcbiAgcmV0dXJuIGZzLmNobW9kKGRlc3QsIHNyY01vZGUgfCAwbzIwMClcbn1cblxuYXN5bmMgZnVuY3Rpb24gb25EaXIgKHNyY1N0YXQsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgLy8gdGhlIGRlc3QgZGlyZWN0b3J5IG1pZ2h0IG5vdCBleGlzdCwgY3JlYXRlIGl0XG4gIGlmICghZGVzdFN0YXQpIHtcbiAgICBhd2FpdCBmcy5ta2RpcihkZXN0KVxuICB9XG5cbiAgY29uc3QgaXRlbXMgPSBhd2FpdCBmcy5yZWFkZGlyKHNyYylcblxuICAvLyBsb29wIHRocm91Z2ggdGhlIGZpbGVzIGluIHRoZSBjdXJyZW50IGRpcmVjdG9yeSB0byBjb3B5IGV2ZXJ5dGhpbmdcbiAgYXdhaXQgUHJvbWlzZS5hbGwoaXRlbXMubWFwKGFzeW5jIGl0ZW0gPT4ge1xuICAgIGNvbnN0IHNyY0l0ZW0gPSBwYXRoLmpvaW4oc3JjLCBpdGVtKVxuICAgIGNvbnN0IGRlc3RJdGVtID0gcGF0aC5qb2luKGRlc3QsIGl0ZW0pXG5cbiAgICAvLyBza2lwIHRoZSBpdGVtIGlmIGl0IGlzIG1hdGNoZXMgYnkgdGhlIGZpbHRlciBmdW5jdGlvblxuICAgIGNvbnN0IGluY2x1ZGUgPSBhd2FpdCBydW5GaWx0ZXIoc3JjSXRlbSwgZGVzdEl0ZW0sIG9wdHMpXG4gICAgaWYgKCFpbmNsdWRlKSByZXR1cm5cblxuICAgIGNvbnN0IHsgZGVzdFN0YXQgfSA9IGF3YWl0IHN0YXQuY2hlY2tQYXRocyhzcmNJdGVtLCBkZXN0SXRlbSwgJ2NvcHknLCBvcHRzKVxuXG4gICAgLy8gSWYgdGhlIGl0ZW0gaXMgYSBjb3B5YWJsZSBmaWxlLCBgZ2V0U3RhdHNBbmRQZXJmb3JtQ29weWAgd2lsbCBjb3B5IGl0XG4gICAgLy8gSWYgdGhlIGl0ZW0gaXMgYSBkaXJlY3RvcnksIGBnZXRTdGF0c0FuZFBlcmZvcm1Db3B5YCB3aWxsIGNhbGwgYG9uRGlyYCByZWN1cnNpdmVseVxuICAgIHJldHVybiBnZXRTdGF0c0FuZFBlcmZvcm1Db3B5KGRlc3RTdGF0LCBzcmNJdGVtLCBkZXN0SXRlbSwgb3B0cylcbiAgfSkpXG5cbiAgaWYgKCFkZXN0U3RhdCkge1xuICAgIGF3YWl0IGZzLmNobW9kKGRlc3QsIHNyY1N0YXQubW9kZSlcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBvbkxpbmsgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgbGV0IHJlc29sdmVkU3JjID0gYXdhaXQgZnMucmVhZGxpbmsoc3JjKVxuICBpZiAob3B0cy5kZXJlZmVyZW5jZSkge1xuICAgIHJlc29sdmVkU3JjID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIHJlc29sdmVkU3JjKVxuICB9XG4gIGlmICghZGVzdFN0YXQpIHtcbiAgICByZXR1cm4gZnMuc3ltbGluayhyZXNvbHZlZFNyYywgZGVzdClcbiAgfVxuXG4gIGxldCByZXNvbHZlZERlc3QgPSBudWxsXG4gIHRyeSB7XG4gICAgcmVzb2x2ZWREZXN0ID0gYXdhaXQgZnMucmVhZGxpbmsoZGVzdClcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGRlc3QgZXhpc3RzIGFuZCBpcyBhIHJlZ3VsYXIgZmlsZSBvciBkaXJlY3RvcnksXG4gICAgLy8gV2luZG93cyBtYXkgdGhyb3cgVU5LTk9XTiBlcnJvci4gSWYgZGVzdCBhbHJlYWR5IGV4aXN0cyxcbiAgICAvLyBmcyB0aHJvd3MgZXJyb3IgYW55d2F5LCBzbyBubyBuZWVkIHRvIGd1YXJkIGFnYWluc3QgaXQgaGVyZS5cbiAgICBpZiAoZS5jb2RlID09PSAnRUlOVkFMJyB8fCBlLmNvZGUgPT09ICdVTktOT1dOJykgcmV0dXJuIGZzLnN5bWxpbmsocmVzb2x2ZWRTcmMsIGRlc3QpXG4gICAgdGhyb3cgZVxuICB9XG4gIGlmIChvcHRzLmRlcmVmZXJlbmNlKSB7XG4gICAgcmVzb2x2ZWREZXN0ID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIHJlc29sdmVkRGVzdClcbiAgfVxuICBpZiAoc3RhdC5pc1NyY1N1YmRpcihyZXNvbHZlZFNyYywgcmVzb2x2ZWREZXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvcHkgJyR7cmVzb2x2ZWRTcmN9JyB0byBhIHN1YmRpcmVjdG9yeSBvZiBpdHNlbGYsICcke3Jlc29sdmVkRGVzdH0nLmApXG4gIH1cblxuICAvLyBkbyBub3QgY29weSBpZiBzcmMgaXMgYSBzdWJkaXIgb2YgZGVzdCBzaW5jZSB1bmxpbmtpbmdcbiAgLy8gZGVzdCBpbiB0aGlzIGNhc2Ugd291bGQgcmVzdWx0IGluIHJlbW92aW5nIHNyYyBjb250ZW50c1xuICAvLyBhbmQgdGhlcmVmb3JlIGEgYnJva2VuIHN5bWxpbmsgd291bGQgYmUgY3JlYXRlZC5cbiAgaWYgKHN0YXQuaXNTcmNTdWJkaXIocmVzb2x2ZWREZXN0LCByZXNvbHZlZFNyYykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBvdmVyd3JpdGUgJyR7cmVzb2x2ZWREZXN0fScgd2l0aCAnJHtyZXNvbHZlZFNyY30nLmApXG4gIH1cblxuICAvLyBjb3B5IHRoZSBsaW5rXG4gIGF3YWl0IGZzLnVubGluayhkZXN0KVxuICByZXR1cm4gZnMuc3ltbGluayhyZXNvbHZlZFNyYywgZGVzdClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBta2RpcnNTeW5jID0gcmVxdWlyZSgnLi4vbWtkaXJzJykubWtkaXJzU3luY1xuY29uc3QgdXRpbWVzTWlsbGlzU3luYyA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbWVzJykudXRpbWVzTWlsbGlzU3luY1xuY29uc3Qgc3RhdCA9IHJlcXVpcmUoJy4uL3V0aWwvc3RhdCcpXG5cbmZ1bmN0aW9uIGNvcHlTeW5jIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0cyA9IHsgZmlsdGVyOiBvcHRzIH1cbiAgfVxuXG4gIG9wdHMgPSBvcHRzIHx8IHt9XG4gIG9wdHMuY2xvYmJlciA9ICdjbG9iYmVyJyBpbiBvcHRzID8gISFvcHRzLmNsb2JiZXIgOiB0cnVlIC8vIGRlZmF1bHQgdG8gdHJ1ZSBmb3Igbm93XG4gIG9wdHMub3ZlcndyaXRlID0gJ292ZXJ3cml0ZScgaW4gb3B0cyA/ICEhb3B0cy5vdmVyd3JpdGUgOiBvcHRzLmNsb2JiZXIgLy8gb3ZlcndyaXRlIGZhbGxzIGJhY2sgdG8gY2xvYmJlclxuXG4gIC8vIFdhcm4gYWJvdXQgdXNpbmcgcHJlc2VydmVUaW1lc3RhbXBzIG9uIDMyLWJpdCBub2RlXG4gIGlmIChvcHRzLnByZXNlcnZlVGltZXN0YW1wcyAmJiBwcm9jZXNzLmFyY2ggPT09ICdpYTMyJykge1xuICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoXG4gICAgICAnVXNpbmcgdGhlIHByZXNlcnZlVGltZXN0YW1wcyBvcHRpb24gaW4gMzItYml0IG5vZGUgaXMgbm90IHJlY29tbWVuZGVkO1xcblxcbicgK1xuICAgICAgJ1xcdHNlZSBodHRwczovL2dpdGh1Yi5jb20vanByaWNoYXJkc29uL25vZGUtZnMtZXh0cmEvaXNzdWVzLzI2OScsXG4gICAgICAnV2FybmluZycsICdmcy1leHRyYS1XQVJOMDAwMidcbiAgICApXG4gIH1cblxuICBjb25zdCB7IHNyY1N0YXQsIGRlc3RTdGF0IH0gPSBzdGF0LmNoZWNrUGF0aHNTeW5jKHNyYywgZGVzdCwgJ2NvcHknLCBvcHRzKVxuICBzdGF0LmNoZWNrUGFyZW50UGF0aHNTeW5jKHNyYywgc3JjU3RhdCwgZGVzdCwgJ2NvcHknKVxuICBpZiAob3B0cy5maWx0ZXIgJiYgIW9wdHMuZmlsdGVyKHNyYywgZGVzdCkpIHJldHVyblxuICBjb25zdCBkZXN0UGFyZW50ID0gcGF0aC5kaXJuYW1lKGRlc3QpXG4gIGlmICghZnMuZXhpc3RzU3luYyhkZXN0UGFyZW50KSkgbWtkaXJzU3luYyhkZXN0UGFyZW50KVxuICByZXR1cm4gZ2V0U3RhdHMoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdHMgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgY29uc3Qgc3RhdFN5bmMgPSBvcHRzLmRlcmVmZXJlbmNlID8gZnMuc3RhdFN5bmMgOiBmcy5sc3RhdFN5bmNcbiAgY29uc3Qgc3JjU3RhdCA9IHN0YXRTeW5jKHNyYylcblxuICBpZiAoc3JjU3RhdC5pc0RpcmVjdG9yeSgpKSByZXR1cm4gb25EaXIoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcbiAgZWxzZSBpZiAoc3JjU3RhdC5pc0ZpbGUoKSB8fFxuICAgICAgICAgICBzcmNTdGF0LmlzQ2hhcmFjdGVyRGV2aWNlKCkgfHxcbiAgICAgICAgICAgc3JjU3RhdC5pc0Jsb2NrRGV2aWNlKCkpIHJldHVybiBvbkZpbGUoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcbiAgZWxzZSBpZiAoc3JjU3RhdC5pc1N5bWJvbGljTGluaygpKSByZXR1cm4gb25MaW5rKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIGVsc2UgaWYgKHNyY1N0YXQuaXNTb2NrZXQoKSkgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29weSBhIHNvY2tldCBmaWxlOiAke3NyY31gKVxuICBlbHNlIGlmIChzcmNTdGF0LmlzRklGTygpKSB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb3B5IGEgRklGTyBwaXBlOiAke3NyY31gKVxuICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZmlsZTogJHtzcmN9YClcbn1cblxuZnVuY3Rpb24gb25GaWxlIChzcmNTdGF0LCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmICghZGVzdFN0YXQpIHJldHVybiBjb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIHJldHVybiBtYXlDb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG59XG5cbmZ1bmN0aW9uIG1heUNvcHlGaWxlIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgaWYgKG9wdHMub3ZlcndyaXRlKSB7XG4gICAgZnMudW5saW5rU3luYyhkZXN0KVxuICAgIHJldHVybiBjb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIH0gZWxzZSBpZiAob3B0cy5lcnJvck9uRXhpc3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCcke2Rlc3R9JyBhbHJlYWR5IGV4aXN0c2ApXG4gIH1cbn1cblxuZnVuY3Rpb24gY29weUZpbGUgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBmcy5jb3B5RmlsZVN5bmMoc3JjLCBkZXN0KVxuICBpZiAob3B0cy5wcmVzZXJ2ZVRpbWVzdGFtcHMpIGhhbmRsZVRpbWVzdGFtcHMoc3JjU3RhdC5tb2RlLCBzcmMsIGRlc3QpXG4gIHJldHVybiBzZXREZXN0TW9kZShkZXN0LCBzcmNTdGF0Lm1vZGUpXG59XG5cbmZ1bmN0aW9uIGhhbmRsZVRpbWVzdGFtcHMgKHNyY01vZGUsIHNyYywgZGVzdCkge1xuICAvLyBNYWtlIHN1cmUgdGhlIGZpbGUgaXMgd3JpdGFibGUgYmVmb3JlIHNldHRpbmcgdGhlIHRpbWVzdGFtcFxuICAvLyBvdGhlcndpc2Ugb3BlbiBmYWlscyB3aXRoIEVQRVJNIHdoZW4gaW52b2tlZCB3aXRoICdyKydcbiAgLy8gKHRocm91Z2ggdXRpbWVzIGNhbGwpXG4gIGlmIChmaWxlSXNOb3RXcml0YWJsZShzcmNNb2RlKSkgbWFrZUZpbGVXcml0YWJsZShkZXN0LCBzcmNNb2RlKVxuICByZXR1cm4gc2V0RGVzdFRpbWVzdGFtcHMoc3JjLCBkZXN0KVxufVxuXG5mdW5jdGlvbiBmaWxlSXNOb3RXcml0YWJsZSAoc3JjTW9kZSkge1xuICByZXR1cm4gKHNyY01vZGUgJiAwbzIwMCkgPT09IDBcbn1cblxuZnVuY3Rpb24gbWFrZUZpbGVXcml0YWJsZSAoZGVzdCwgc3JjTW9kZSkge1xuICByZXR1cm4gc2V0RGVzdE1vZGUoZGVzdCwgc3JjTW9kZSB8IDBvMjAwKVxufVxuXG5mdW5jdGlvbiBzZXREZXN0TW9kZSAoZGVzdCwgc3JjTW9kZSkge1xuICByZXR1cm4gZnMuY2htb2RTeW5jKGRlc3QsIHNyY01vZGUpXG59XG5cbmZ1bmN0aW9uIHNldERlc3RUaW1lc3RhbXBzIChzcmMsIGRlc3QpIHtcbiAgLy8gVGhlIGluaXRpYWwgc3JjU3RhdC5hdGltZSBjYW5ub3QgYmUgdHJ1c3RlZFxuICAvLyBiZWNhdXNlIGl0IGlzIG1vZGlmaWVkIGJ5IHRoZSByZWFkKDIpIHN5c3RlbSBjYWxsXG4gIC8vIChTZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sI2ZzX3N0YXRfdGltZV92YWx1ZXMpXG4gIGNvbnN0IHVwZGF0ZWRTcmNTdGF0ID0gZnMuc3RhdFN5bmMoc3JjKVxuICByZXR1cm4gdXRpbWVzTWlsbGlzU3luYyhkZXN0LCB1cGRhdGVkU3JjU3RhdC5hdGltZSwgdXBkYXRlZFNyY1N0YXQubXRpbWUpXG59XG5cbmZ1bmN0aW9uIG9uRGlyIChzcmNTdGF0LCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmICghZGVzdFN0YXQpIHJldHVybiBta0RpckFuZENvcHkoc3JjU3RhdC5tb2RlLCBzcmMsIGRlc3QsIG9wdHMpXG4gIHJldHVybiBjb3B5RGlyKHNyYywgZGVzdCwgb3B0cylcbn1cblxuZnVuY3Rpb24gbWtEaXJBbmRDb3B5IChzcmNNb2RlLCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgZnMubWtkaXJTeW5jKGRlc3QpXG4gIGNvcHlEaXIoc3JjLCBkZXN0LCBvcHRzKVxuICByZXR1cm4gc2V0RGVzdE1vZGUoZGVzdCwgc3JjTW9kZSlcbn1cblxuZnVuY3Rpb24gY29weURpciAoc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGZzLnJlYWRkaXJTeW5jKHNyYykuZm9yRWFjaChpdGVtID0+IGNvcHlEaXJJdGVtKGl0ZW0sIHNyYywgZGVzdCwgb3B0cykpXG59XG5cbmZ1bmN0aW9uIGNvcHlEaXJJdGVtIChpdGVtLCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgY29uc3Qgc3JjSXRlbSA9IHBhdGguam9pbihzcmMsIGl0ZW0pXG4gIGNvbnN0IGRlc3RJdGVtID0gcGF0aC5qb2luKGRlc3QsIGl0ZW0pXG4gIGlmIChvcHRzLmZpbHRlciAmJiAhb3B0cy5maWx0ZXIoc3JjSXRlbSwgZGVzdEl0ZW0pKSByZXR1cm5cbiAgY29uc3QgeyBkZXN0U3RhdCB9ID0gc3RhdC5jaGVja1BhdGhzU3luYyhzcmNJdGVtLCBkZXN0SXRlbSwgJ2NvcHknLCBvcHRzKVxuICByZXR1cm4gZ2V0U3RhdHMoZGVzdFN0YXQsIHNyY0l0ZW0sIGRlc3RJdGVtLCBvcHRzKVxufVxuXG5mdW5jdGlvbiBvbkxpbmsgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgbGV0IHJlc29sdmVkU3JjID0gZnMucmVhZGxpbmtTeW5jKHNyYylcbiAgaWYgKG9wdHMuZGVyZWZlcmVuY2UpIHtcbiAgICByZXNvbHZlZFNyYyA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCByZXNvbHZlZFNyYylcbiAgfVxuXG4gIGlmICghZGVzdFN0YXQpIHtcbiAgICByZXR1cm4gZnMuc3ltbGlua1N5bmMocmVzb2x2ZWRTcmMsIGRlc3QpXG4gIH0gZWxzZSB7XG4gICAgbGV0IHJlc29sdmVkRGVzdFxuICAgIHRyeSB7XG4gICAgICByZXNvbHZlZERlc3QgPSBmcy5yZWFkbGlua1N5bmMoZGVzdClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIGRlc3QgZXhpc3RzIGFuZCBpcyBhIHJlZ3VsYXIgZmlsZSBvciBkaXJlY3RvcnksXG4gICAgICAvLyBXaW5kb3dzIG1heSB0aHJvdyBVTktOT1dOIGVycm9yLiBJZiBkZXN0IGFscmVhZHkgZXhpc3RzLFxuICAgICAgLy8gZnMgdGhyb3dzIGVycm9yIGFueXdheSwgc28gbm8gbmVlZCB0byBndWFyZCBhZ2FpbnN0IGl0IGhlcmUuXG4gICAgICBpZiAoZXJyLmNvZGUgPT09ICdFSU5WQUwnIHx8IGVyci5jb2RlID09PSAnVU5LTk9XTicpIHJldHVybiBmcy5zeW1saW5rU3luYyhyZXNvbHZlZFNyYywgZGVzdClcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgICBpZiAob3B0cy5kZXJlZmVyZW5jZSkge1xuICAgICAgcmVzb2x2ZWREZXN0ID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIHJlc29sdmVkRGVzdClcbiAgICB9XG4gICAgaWYgKHN0YXQuaXNTcmNTdWJkaXIocmVzb2x2ZWRTcmMsIHJlc29sdmVkRGVzdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvcHkgJyR7cmVzb2x2ZWRTcmN9JyB0byBhIHN1YmRpcmVjdG9yeSBvZiBpdHNlbGYsICcke3Jlc29sdmVkRGVzdH0nLmApXG4gICAgfVxuXG4gICAgLy8gcHJldmVudCBjb3B5IGlmIHNyYyBpcyBhIHN1YmRpciBvZiBkZXN0IHNpbmNlIHVubGlua2luZ1xuICAgIC8vIGRlc3QgaW4gdGhpcyBjYXNlIHdvdWxkIHJlc3VsdCBpbiByZW1vdmluZyBzcmMgY29udGVudHNcbiAgICAvLyBhbmQgdGhlcmVmb3JlIGEgYnJva2VuIHN5bWxpbmsgd291bGQgYmUgY3JlYXRlZC5cbiAgICBpZiAoc3RhdC5pc1NyY1N1YmRpcihyZXNvbHZlZERlc3QsIHJlc29sdmVkU3JjKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgb3ZlcndyaXRlICcke3Jlc29sdmVkRGVzdH0nIHdpdGggJyR7cmVzb2x2ZWRTcmN9Jy5gKVxuICAgIH1cbiAgICByZXR1cm4gY29weUxpbmsocmVzb2x2ZWRTcmMsIGRlc3QpXG4gIH1cbn1cblxuZnVuY3Rpb24gY29weUxpbmsgKHJlc29sdmVkU3JjLCBkZXN0KSB7XG4gIGZzLnVubGlua1N5bmMoZGVzdClcbiAgcmV0dXJuIGZzLnN5bWxpbmtTeW5jKHJlc29sdmVkU3JjLCBkZXN0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW5jXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21Qcm9taXNlXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29weTogdShyZXF1aXJlKCcuL2NvcHknKSksXG4gIGNvcHlTeW5jOiByZXF1aXJlKCcuL2NvcHktc3luYycpXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5cbmZ1bmN0aW9uIHJlbW92ZSAocGF0aCwgY2FsbGJhY2spIHtcbiAgZnMucm0ocGF0aCwgeyByZWN1cnNpdmU6IHRydWUsIGZvcmNlOiB0cnVlIH0sIGNhbGxiYWNrKVxufVxuXG5mdW5jdGlvbiByZW1vdmVTeW5jIChwYXRoKSB7XG4gIGZzLnJtU3luYyhwYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlbW92ZTogdShyZW1vdmUpLFxuICByZW1vdmVTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21Qcm9taXNlXG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL2ZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHJlbW92ZSA9IHJlcXVpcmUoJy4uL3JlbW92ZScpXG5cbmNvbnN0IGVtcHR5RGlyID0gdShhc3luYyBmdW5jdGlvbiBlbXB0eURpciAoZGlyKSB7XG4gIGxldCBpdGVtc1xuICB0cnkge1xuICAgIGl0ZW1zID0gYXdhaXQgZnMucmVhZGRpcihkaXIpXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBta2Rpci5ta2RpcnMoZGlyKVxuICB9XG5cbiAgcmV0dXJuIFByb21pc2UuYWxsKGl0ZW1zLm1hcChpdGVtID0+IHJlbW92ZS5yZW1vdmUocGF0aC5qb2luKGRpciwgaXRlbSkpKSlcbn0pXG5cbmZ1bmN0aW9uIGVtcHR5RGlyU3luYyAoZGlyKSB7XG4gIGxldCBpdGVtc1xuICB0cnkge1xuICAgIGl0ZW1zID0gZnMucmVhZGRpclN5bmMoZGlyKVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbWtkaXIubWtkaXJzU3luYyhkaXIpXG4gIH1cblxuICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgIGl0ZW0gPSBwYXRoLmpvaW4oZGlyLCBpdGVtKVxuICAgIHJlbW92ZS5yZW1vdmVTeW5jKGl0ZW0pXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlbXB0eURpclN5bmMsXG4gIGVtcHR5ZGlyU3luYzogZW1wdHlEaXJTeW5jLFxuICBlbXB0eURpcixcbiAgZW1wdHlkaXI6IGVtcHR5RGlyXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21Qcm9taXNlXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL2ZzJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlRmlsZSAoZmlsZSkge1xuICBsZXQgc3RhdHNcbiAgdHJ5IHtcbiAgICBzdGF0cyA9IGF3YWl0IGZzLnN0YXQoZmlsZSlcbiAgfSBjYXRjaCB7IH1cbiAgaWYgKHN0YXRzICYmIHN0YXRzLmlzRmlsZSgpKSByZXR1cm5cblxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZmlsZSlcblxuICBsZXQgZGlyU3RhdHMgPSBudWxsXG4gIHRyeSB7XG4gICAgZGlyU3RhdHMgPSBhd2FpdCBmcy5zdGF0KGRpcilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gaWYgdGhlIGRpcmVjdG9yeSBkb2Vzbid0IGV4aXN0LCBtYWtlIGl0XG4gICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgYXdhaXQgbWtkaXIubWtkaXJzKGRpcilcbiAgICAgIGF3YWl0IGZzLndyaXRlRmlsZShmaWxlLCAnJylcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyU3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShmaWxlLCAnJylcbiAgfSBlbHNlIHtcbiAgICAvLyBwYXJlbnQgaXMgbm90IGEgZGlyZWN0b3J5XG4gICAgLy8gVGhpcyBpcyBqdXN0IHRvIGNhdXNlIGFuIGludGVybmFsIEVOT1RESVIgZXJyb3IgdG8gYmUgdGhyb3duXG4gICAgYXdhaXQgZnMucmVhZGRpcihkaXIpXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRmlsZVN5bmMgKGZpbGUpIHtcbiAgbGV0IHN0YXRzXG4gIHRyeSB7XG4gICAgc3RhdHMgPSBmcy5zdGF0U3luYyhmaWxlKVxuICB9IGNhdGNoIHsgfVxuICBpZiAoc3RhdHMgJiYgc3RhdHMuaXNGaWxlKCkpIHJldHVyblxuXG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShmaWxlKVxuICB0cnkge1xuICAgIGlmICghZnMuc3RhdFN5bmMoZGlyKS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAvLyBwYXJlbnQgaXMgbm90IGEgZGlyZWN0b3J5XG4gICAgICAvLyBUaGlzIGlzIGp1c3QgdG8gY2F1c2UgYW4gaW50ZXJuYWwgRU5PVERJUiBlcnJvciB0byBiZSB0aHJvd25cbiAgICAgIGZzLnJlYWRkaXJTeW5jKGRpcilcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIElmIHRoZSBzdGF0IGNhbGwgYWJvdmUgZmFpbGVkIGJlY2F1c2UgdGhlIGRpcmVjdG9yeSBkb2Vzbid0IGV4aXN0LCBjcmVhdGUgaXRcbiAgICBpZiAoZXJyICYmIGVyci5jb2RlID09PSAnRU5PRU5UJykgbWtkaXIubWtkaXJzU3luYyhkaXIpXG4gICAgZWxzZSB0aHJvdyBlcnJcbiAgfVxuXG4gIGZzLndyaXRlRmlsZVN5bmMoZmlsZSwgJycpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVGaWxlOiB1KGNyZWF0ZUZpbGUpLFxuICBjcmVhdGVGaWxlU3luY1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tUHJvbWlzZVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5jb25zdCBta2RpciA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5jb25zdCB7IHBhdGhFeGlzdHMgfSA9IHJlcXVpcmUoJy4uL3BhdGgtZXhpc3RzJylcbmNvbnN0IHsgYXJlSWRlbnRpY2FsIH0gPSByZXF1aXJlKCcuLi91dGlsL3N0YXQnKVxuXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVMaW5rIChzcmNwYXRoLCBkc3RwYXRoKSB7XG4gIGxldCBkc3RTdGF0XG4gIHRyeSB7XG4gICAgZHN0U3RhdCA9IGF3YWl0IGZzLmxzdGF0KGRzdHBhdGgpXG4gIH0gY2F0Y2gge1xuICAgIC8vIGlnbm9yZSBlcnJvclxuICB9XG5cbiAgbGV0IHNyY1N0YXRcbiAgdHJ5IHtcbiAgICBzcmNTdGF0ID0gYXdhaXQgZnMubHN0YXQoc3JjcGF0aClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLm1lc3NhZ2UgPSBlcnIubWVzc2FnZS5yZXBsYWNlKCdsc3RhdCcsICdlbnN1cmVMaW5rJylcbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIGlmIChkc3RTdGF0ICYmIGFyZUlkZW50aWNhbChzcmNTdGF0LCBkc3RTdGF0KSkgcmV0dXJuXG5cbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGRzdHBhdGgpXG5cbiAgY29uc3QgZGlyRXhpc3RzID0gYXdhaXQgcGF0aEV4aXN0cyhkaXIpXG5cbiAgaWYgKCFkaXJFeGlzdHMpIHtcbiAgICBhd2FpdCBta2Rpci5ta2RpcnMoZGlyKVxuICB9XG5cbiAgYXdhaXQgZnMubGluayhzcmNwYXRoLCBkc3RwYXRoKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rU3luYyAoc3JjcGF0aCwgZHN0cGF0aCkge1xuICBsZXQgZHN0U3RhdFxuICB0cnkge1xuICAgIGRzdFN0YXQgPSBmcy5sc3RhdFN5bmMoZHN0cGF0aClcbiAgfSBjYXRjaCB7fVxuXG4gIHRyeSB7XG4gICAgY29uc3Qgc3JjU3RhdCA9IGZzLmxzdGF0U3luYyhzcmNwYXRoKVxuICAgIGlmIChkc3RTdGF0ICYmIGFyZUlkZW50aWNhbChzcmNTdGF0LCBkc3RTdGF0KSkgcmV0dXJuXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5tZXNzYWdlID0gZXJyLm1lc3NhZ2UucmVwbGFjZSgnbHN0YXQnLCAnZW5zdXJlTGluaycpXG4gICAgdGhyb3cgZXJyXG4gIH1cblxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgY29uc3QgZGlyRXhpc3RzID0gZnMuZXhpc3RzU3luYyhkaXIpXG4gIGlmIChkaXJFeGlzdHMpIHJldHVybiBmcy5saW5rU3luYyhzcmNwYXRoLCBkc3RwYXRoKVxuICBta2Rpci5ta2RpcnNTeW5jKGRpcilcblxuICByZXR1cm4gZnMubGlua1N5bmMoc3JjcGF0aCwgZHN0cGF0aClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZUxpbms6IHUoY3JlYXRlTGluayksXG4gIGNyZWF0ZUxpbmtTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5jb25zdCB7IHBhdGhFeGlzdHMgfSA9IHJlcXVpcmUoJy4uL3BhdGgtZXhpc3RzJylcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21Qcm9taXNlXG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCByZXR1cm5zIHR3byB0eXBlcyBvZiBwYXRocywgb25lIHJlbGF0aXZlIHRvIHN5bWxpbmssIGFuZCBvbmVcbiAqIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LiBDaGVja3MgaWYgcGF0aCBpcyBhYnNvbHV0ZSBvclxuICogcmVsYXRpdmUuIElmIHRoZSBwYXRoIGlzIHJlbGF0aXZlLCB0aGlzIGZ1bmN0aW9uIGNoZWNrcyBpZiB0aGUgcGF0aCBpc1xuICogcmVsYXRpdmUgdG8gc3ltbGluayBvciByZWxhdGl2ZSB0byBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LiBUaGlzIGlzIGFuXG4gKiBpbml0aWF0aXZlIHRvIGZpbmQgYSBzbWFydGVyIGBzcmNwYXRoYCB0byBzdXBwbHkgd2hlbiBidWlsZGluZyBzeW1saW5rcy5cbiAqIFRoaXMgYWxsb3dzIHlvdSB0byBkZXRlcm1pbmUgd2hpY2ggcGF0aCB0byB1c2Ugb3V0IG9mIG9uZSBvZiB0aHJlZSBwb3NzaWJsZVxuICogdHlwZXMgb2Ygc291cmNlIHBhdGhzLiBUaGUgZmlyc3QgaXMgYW4gYWJzb2x1dGUgcGF0aC4gVGhpcyBpcyBkZXRlY3RlZCBieVxuICogYHBhdGguaXNBYnNvbHV0ZSgpYC4gV2hlbiBhbiBhYnNvbHV0ZSBwYXRoIGlzIHByb3ZpZGVkLCBpdCBpcyBjaGVja2VkIHRvXG4gKiBzZWUgaWYgaXQgZXhpc3RzLiBJZiBpdCBkb2VzIGl0J3MgdXNlZCwgaWYgbm90IGFuIGVycm9yIGlzIHJldHVybmVkXG4gKiAoY2FsbGJhY2spLyB0aHJvd24gKHN5bmMpLiBUaGUgb3RoZXIgdHdvIG9wdGlvbnMgZm9yIGBzcmNwYXRoYCBhcmUgYVxuICogcmVsYXRpdmUgdXJsLiBCeSBkZWZhdWx0IE5vZGUncyBgZnMuc3ltbGlua2Agd29ya3MgYnkgY3JlYXRpbmcgYSBzeW1saW5rXG4gKiB1c2luZyBgZHN0cGF0aGAgYW5kIGV4cGVjdHMgdGhlIGBzcmNwYXRoYCB0byBiZSByZWxhdGl2ZSB0byB0aGUgbmV3bHlcbiAqIGNyZWF0ZWQgc3ltbGluay4gSWYgeW91IHByb3ZpZGUgYSBgc3JjcGF0aGAgdGhhdCBkb2VzIG5vdCBleGlzdCBvbiB0aGUgZmlsZVxuICogc3lzdGVtIGl0IHJlc3VsdHMgaW4gYSBicm9rZW4gc3ltbGluay4gVG8gbWluaW1pemUgdGhpcywgdGhlIGZ1bmN0aW9uXG4gKiBjaGVja3MgdG8gc2VlIGlmIHRoZSAncmVsYXRpdmUgdG8gc3ltbGluaycgc291cmNlIGZpbGUgZXhpc3RzLCBhbmQgaWYgaXRcbiAqIGRvZXMgaXQgd2lsbCB1c2UgaXQuIElmIGl0IGRvZXMgbm90LCBpdCBjaGVja3MgaWYgdGhlcmUncyBhIGZpbGUgdGhhdFxuICogZXhpc3RzIHRoYXQgaXMgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnksIGlmIGRvZXMgaXRzIHVzZWQuXG4gKiBUaGlzIHByZXNlcnZlcyB0aGUgZXhwZWN0YXRpb25zIG9mIHRoZSBvcmlnaW5hbCBmcy5zeW1saW5rIHNwZWMgYW5kIGFkZHNcbiAqIHRoZSBhYmlsaXR5IHRvIHBhc3MgaW4gYHJlbGF0aXZlIHRvIGN1cnJlbnQgd29ya2luZyBkaXJlY290cnlgIHBhdGhzLlxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIHN5bWxpbmtQYXRocyAoc3JjcGF0aCwgZHN0cGF0aCkge1xuICBpZiAocGF0aC5pc0Fic29sdXRlKHNyY3BhdGgpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGZzLmxzdGF0KHNyY3BhdGgpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBlcnIubWVzc2FnZSA9IGVyci5tZXNzYWdlLnJlcGxhY2UoJ2xzdGF0JywgJ2Vuc3VyZVN5bWxpbmsnKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvQ3dkOiBzcmNwYXRoLFxuICAgICAgdG9Ec3Q6IHNyY3BhdGhcbiAgICB9XG4gIH1cblxuICBjb25zdCBkc3RkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgY29uc3QgcmVsYXRpdmVUb0RzdCA9IHBhdGguam9pbihkc3RkaXIsIHNyY3BhdGgpXG5cbiAgY29uc3QgZXhpc3RzID0gYXdhaXQgcGF0aEV4aXN0cyhyZWxhdGl2ZVRvRHN0KVxuICBpZiAoZXhpc3RzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvQ3dkOiByZWxhdGl2ZVRvRHN0LFxuICAgICAgdG9Ec3Q6IHNyY3BhdGhcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIGF3YWl0IGZzLmxzdGF0KHNyY3BhdGgpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5tZXNzYWdlID0gZXJyLm1lc3NhZ2UucmVwbGFjZSgnbHN0YXQnLCAnZW5zdXJlU3ltbGluaycpXG4gICAgdGhyb3cgZXJyXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvQ3dkOiBzcmNwYXRoLFxuICAgIHRvRHN0OiBwYXRoLnJlbGF0aXZlKGRzdGRpciwgc3JjcGF0aClcbiAgfVxufVxuXG5mdW5jdGlvbiBzeW1saW5rUGF0aHNTeW5jIChzcmNwYXRoLCBkc3RwYXRoKSB7XG4gIGlmIChwYXRoLmlzQWJzb2x1dGUoc3JjcGF0aCkpIHtcbiAgICBjb25zdCBleGlzdHMgPSBmcy5leGlzdHNTeW5jKHNyY3BhdGgpXG4gICAgaWYgKCFleGlzdHMpIHRocm93IG5ldyBFcnJvcignYWJzb2x1dGUgc3JjcGF0aCBkb2VzIG5vdCBleGlzdCcpXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvQ3dkOiBzcmNwYXRoLFxuICAgICAgdG9Ec3Q6IHNyY3BhdGhcbiAgICB9XG4gIH1cblxuICBjb25zdCBkc3RkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgY29uc3QgcmVsYXRpdmVUb0RzdCA9IHBhdGguam9pbihkc3RkaXIsIHNyY3BhdGgpXG4gIGNvbnN0IGV4aXN0cyA9IGZzLmV4aXN0c1N5bmMocmVsYXRpdmVUb0RzdClcbiAgaWYgKGV4aXN0cykge1xuICAgIHJldHVybiB7XG4gICAgICB0b0N3ZDogcmVsYXRpdmVUb0RzdCxcbiAgICAgIHRvRHN0OiBzcmNwYXRoXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3JjRXhpc3RzID0gZnMuZXhpc3RzU3luYyhzcmNwYXRoKVxuICBpZiAoIXNyY0V4aXN0cykgdGhyb3cgbmV3IEVycm9yKCdyZWxhdGl2ZSBzcmNwYXRoIGRvZXMgbm90IGV4aXN0JylcbiAgcmV0dXJuIHtcbiAgICB0b0N3ZDogc3JjcGF0aCxcbiAgICB0b0RzdDogcGF0aC5yZWxhdGl2ZShkc3RkaXIsIHNyY3BhdGgpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN5bWxpbmtQYXRoczogdShzeW1saW5rUGF0aHMpLFxuICBzeW1saW5rUGF0aHNTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2VcblxuYXN5bmMgZnVuY3Rpb24gc3ltbGlua1R5cGUgKHNyY3BhdGgsIHR5cGUpIHtcbiAgaWYgKHR5cGUpIHJldHVybiB0eXBlXG5cbiAgbGV0IHN0YXRzXG4gIHRyeSB7XG4gICAgc3RhdHMgPSBhd2FpdCBmcy5sc3RhdChzcmNwYXRoKVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gJ2ZpbGUnXG4gIH1cblxuICByZXR1cm4gKHN0YXRzICYmIHN0YXRzLmlzRGlyZWN0b3J5KCkpID8gJ2RpcicgOiAnZmlsZSdcbn1cblxuZnVuY3Rpb24gc3ltbGlua1R5cGVTeW5jIChzcmNwYXRoLCB0eXBlKSB7XG4gIGlmICh0eXBlKSByZXR1cm4gdHlwZVxuXG4gIGxldCBzdGF0c1xuICB0cnkge1xuICAgIHN0YXRzID0gZnMubHN0YXRTeW5jKHNyY3BhdGgpXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAnZmlsZSdcbiAgfVxuICByZXR1cm4gKHN0YXRzICYmIHN0YXRzLmlzRGlyZWN0b3J5KCkpID8gJ2RpcicgOiAnZmlsZSdcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN5bWxpbmtUeXBlOiB1KHN5bWxpbmtUeXBlKSxcbiAgc3ltbGlua1R5cGVTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21Qcm9taXNlXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL2ZzJylcblxuY29uc3QgeyBta2RpcnMsIG1rZGlyc1N5bmMgfSA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5cbmNvbnN0IHsgc3ltbGlua1BhdGhzLCBzeW1saW5rUGF0aHNTeW5jIH0gPSByZXF1aXJlKCcuL3N5bWxpbmstcGF0aHMnKVxuY29uc3QgeyBzeW1saW5rVHlwZSwgc3ltbGlua1R5cGVTeW5jIH0gPSByZXF1aXJlKCcuL3N5bWxpbmstdHlwZScpXG5cbmNvbnN0IHsgcGF0aEV4aXN0cyB9ID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKVxuXG5jb25zdCB7IGFyZUlkZW50aWNhbCB9ID0gcmVxdWlyZSgnLi4vdXRpbC9zdGF0JylcblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlU3ltbGluayAoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSkge1xuICBsZXQgc3RhdHNcbiAgdHJ5IHtcbiAgICBzdGF0cyA9IGF3YWl0IGZzLmxzdGF0KGRzdHBhdGgpXG4gIH0gY2F0Y2ggeyB9XG5cbiAgaWYgKHN0YXRzICYmIHN0YXRzLmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICBjb25zdCBbc3JjU3RhdCwgZHN0U3RhdF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICBmcy5zdGF0KHNyY3BhdGgpLFxuICAgICAgZnMuc3RhdChkc3RwYXRoKVxuICAgIF0pXG5cbiAgICBpZiAoYXJlSWRlbnRpY2FsKHNyY1N0YXQsIGRzdFN0YXQpKSByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHJlbGF0aXZlID0gYXdhaXQgc3ltbGlua1BhdGhzKHNyY3BhdGgsIGRzdHBhdGgpXG4gIHNyY3BhdGggPSByZWxhdGl2ZS50b0RzdFxuICBjb25zdCB0b1R5cGUgPSBhd2FpdCBzeW1saW5rVHlwZShyZWxhdGl2ZS50b0N3ZCwgdHlwZSlcbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGRzdHBhdGgpXG5cbiAgaWYgKCEoYXdhaXQgcGF0aEV4aXN0cyhkaXIpKSkge1xuICAgIGF3YWl0IG1rZGlycyhkaXIpXG4gIH1cblxuICByZXR1cm4gZnMuc3ltbGluayhzcmNwYXRoLCBkc3RwYXRoLCB0b1R5cGUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN5bWxpbmtTeW5jIChzcmNwYXRoLCBkc3RwYXRoLCB0eXBlKSB7XG4gIGxldCBzdGF0c1xuICB0cnkge1xuICAgIHN0YXRzID0gZnMubHN0YXRTeW5jKGRzdHBhdGgpXG4gIH0gY2F0Y2ggeyB9XG4gIGlmIChzdGF0cyAmJiBzdGF0cy5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgY29uc3Qgc3JjU3RhdCA9IGZzLnN0YXRTeW5jKHNyY3BhdGgpXG4gICAgY29uc3QgZHN0U3RhdCA9IGZzLnN0YXRTeW5jKGRzdHBhdGgpXG4gICAgaWYgKGFyZUlkZW50aWNhbChzcmNTdGF0LCBkc3RTdGF0KSkgcmV0dXJuXG4gIH1cblxuICBjb25zdCByZWxhdGl2ZSA9IHN5bWxpbmtQYXRoc1N5bmMoc3JjcGF0aCwgZHN0cGF0aClcbiAgc3JjcGF0aCA9IHJlbGF0aXZlLnRvRHN0XG4gIHR5cGUgPSBzeW1saW5rVHlwZVN5bmMocmVsYXRpdmUudG9Dd2QsIHR5cGUpXG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShkc3RwYXRoKVxuICBjb25zdCBleGlzdHMgPSBmcy5leGlzdHNTeW5jKGRpcilcbiAgaWYgKGV4aXN0cykgcmV0dXJuIGZzLnN5bWxpbmtTeW5jKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUpXG4gIG1rZGlyc1N5bmMoZGlyKVxuICByZXR1cm4gZnMuc3ltbGlua1N5bmMoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZVN5bWxpbms6IHUoY3JlYXRlU3ltbGluayksXG4gIGNyZWF0ZVN5bWxpbmtTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBjcmVhdGVGaWxlLCBjcmVhdGVGaWxlU3luYyB9ID0gcmVxdWlyZSgnLi9maWxlJylcbmNvbnN0IHsgY3JlYXRlTGluaywgY3JlYXRlTGlua1N5bmMgfSA9IHJlcXVpcmUoJy4vbGluaycpXG5jb25zdCB7IGNyZWF0ZVN5bWxpbmssIGNyZWF0ZVN5bWxpbmtTeW5jIH0gPSByZXF1aXJlKCcuL3N5bWxpbmsnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gZmlsZVxuICBjcmVhdGVGaWxlLFxuICBjcmVhdGVGaWxlU3luYyxcbiAgZW5zdXJlRmlsZTogY3JlYXRlRmlsZSxcbiAgZW5zdXJlRmlsZVN5bmM6IGNyZWF0ZUZpbGVTeW5jLFxuICAvLyBsaW5rXG4gIGNyZWF0ZUxpbmssXG4gIGNyZWF0ZUxpbmtTeW5jLFxuICBlbnN1cmVMaW5rOiBjcmVhdGVMaW5rLFxuICBlbnN1cmVMaW5rU3luYzogY3JlYXRlTGlua1N5bmMsXG4gIC8vIHN5bWxpbmtcbiAgY3JlYXRlU3ltbGluayxcbiAgY3JlYXRlU3ltbGlua1N5bmMsXG4gIGVuc3VyZVN5bWxpbms6IGNyZWF0ZVN5bWxpbmssXG4gIGVuc3VyZVN5bWxpbmtTeW5jOiBjcmVhdGVTeW1saW5rU3luY1xufVxuIiwiZnVuY3Rpb24gc3RyaW5naWZ5IChvYmosIHsgRU9MID0gJ1xcbicsIGZpbmFsRU9MID0gdHJ1ZSwgcmVwbGFjZXIgPSBudWxsLCBzcGFjZXMgfSA9IHt9KSB7XG4gIGNvbnN0IEVPRiA9IGZpbmFsRU9MID8gRU9MIDogJydcbiAgY29uc3Qgc3RyID0gSlNPTi5zdHJpbmdpZnkob2JqLCByZXBsYWNlciwgc3BhY2VzKVxuXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxuL2csIEVPTCkgKyBFT0Zcbn1cblxuZnVuY3Rpb24gc3RyaXBCb20gKGNvbnRlbnQpIHtcbiAgLy8gd2UgZG8gdGhpcyBiZWNhdXNlIEpTT04ucGFyc2Ugd291bGQgY29udmVydCBpdCB0byBhIHV0Zjggc3RyaW5nIGlmIGVuY29kaW5nIHdhc24ndCBzcGVjaWZpZWRcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjb250ZW50KSkgY29udGVudCA9IGNvbnRlbnQudG9TdHJpbmcoJ3V0ZjgnKVxuICByZXR1cm4gY29udGVudC5yZXBsYWNlKC9eXFx1RkVGRi8sICcnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgc3RyaW5naWZ5LCBzdHJpcEJvbSB9XG4iLCJsZXQgX2ZzXG50cnkge1xuICBfZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG59IGNhdGNoIChfKSB7XG4gIF9mcyA9IHJlcXVpcmUoJ2ZzJylcbn1cbmNvbnN0IHVuaXZlcnNhbGlmeSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpXG5jb25zdCB7IHN0cmluZ2lmeSwgc3RyaXBCb20gfSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuXG5hc3luYyBmdW5jdGlvbiBfcmVhZEZpbGUgKGZpbGUsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHsgZW5jb2Rpbmc6IG9wdGlvbnMgfVxuICB9XG5cbiAgY29uc3QgZnMgPSBvcHRpb25zLmZzIHx8IF9mc1xuXG4gIGNvbnN0IHNob3VsZFRocm93ID0gJ3Rocm93cycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudGhyb3dzIDogdHJ1ZVxuXG4gIGxldCBkYXRhID0gYXdhaXQgdW5pdmVyc2FsaWZ5LmZyb21DYWxsYmFjayhmcy5yZWFkRmlsZSkoZmlsZSwgb3B0aW9ucylcblxuICBkYXRhID0gc3RyaXBCb20oZGF0YSlcblxuICBsZXQgb2JqXG4gIHRyeSB7XG4gICAgb2JqID0gSlNPTi5wYXJzZShkYXRhLCBvcHRpb25zID8gb3B0aW9ucy5yZXZpdmVyIDogbnVsbClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHNob3VsZFRocm93KSB7XG4gICAgICBlcnIubWVzc2FnZSA9IGAke2ZpbGV9OiAke2Vyci5tZXNzYWdlfWBcbiAgICAgIHRocm93IGVyclxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmpcbn1cblxuY29uc3QgcmVhZEZpbGUgPSB1bml2ZXJzYWxpZnkuZnJvbVByb21pc2UoX3JlYWRGaWxlKVxuXG5mdW5jdGlvbiByZWFkRmlsZVN5bmMgKGZpbGUsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHsgZW5jb2Rpbmc6IG9wdGlvbnMgfVxuICB9XG5cbiAgY29uc3QgZnMgPSBvcHRpb25zLmZzIHx8IF9mc1xuXG4gIGNvbnN0IHNob3VsZFRocm93ID0gJ3Rocm93cycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudGhyb3dzIDogdHJ1ZVxuXG4gIHRyeSB7XG4gICAgbGV0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZSwgb3B0aW9ucylcbiAgICBjb250ZW50ID0gc3RyaXBCb20oY29udGVudClcbiAgICByZXR1cm4gSlNPTi5wYXJzZShjb250ZW50LCBvcHRpb25zLnJldml2ZXIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgZXJyLm1lc3NhZ2UgPSBgJHtmaWxlfTogJHtlcnIubWVzc2FnZX1gXG4gICAgICB0aHJvdyBlcnJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gX3dyaXRlRmlsZSAoZmlsZSwgb2JqLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgZnMgPSBvcHRpb25zLmZzIHx8IF9mc1xuXG4gIGNvbnN0IHN0ciA9IHN0cmluZ2lmeShvYmosIG9wdGlvbnMpXG5cbiAgYXdhaXQgdW5pdmVyc2FsaWZ5LmZyb21DYWxsYmFjayhmcy53cml0ZUZpbGUpKGZpbGUsIHN0ciwgb3B0aW9ucylcbn1cblxuY29uc3Qgd3JpdGVGaWxlID0gdW5pdmVyc2FsaWZ5LmZyb21Qcm9taXNlKF93cml0ZUZpbGUpXG5cbmZ1bmN0aW9uIHdyaXRlRmlsZVN5bmMgKGZpbGUsIG9iaiwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGZzID0gb3B0aW9ucy5mcyB8fCBfZnNcblxuICBjb25zdCBzdHIgPSBzdHJpbmdpZnkob2JqLCBvcHRpb25zKVxuICAvLyBub3Qgc3VyZSBpZiBmcy53cml0ZUZpbGVTeW5jIHJldHVybnMgYW55dGhpbmcsIGJ1dCBqdXN0IGluIGNhc2VcbiAgcmV0dXJuIGZzLndyaXRlRmlsZVN5bmMoZmlsZSwgc3RyLCBvcHRpb25zKVxufVxuXG5jb25zdCBqc29uZmlsZSA9IHtcbiAgcmVhZEZpbGUsXG4gIHJlYWRGaWxlU3luYyxcbiAgd3JpdGVGaWxlLFxuICB3cml0ZUZpbGVTeW5jXG59XG5cbm1vZHVsZS5leHBvcnRzID0ganNvbmZpbGVcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBqc29uRmlsZSA9IHJlcXVpcmUoJ2pzb25maWxlJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGpzb25maWxlIGV4cG9ydHNcbiAgcmVhZEpzb246IGpzb25GaWxlLnJlYWRGaWxlLFxuICByZWFkSnNvblN5bmM6IGpzb25GaWxlLnJlYWRGaWxlU3luYyxcbiAgd3JpdGVKc29uOiBqc29uRmlsZS53cml0ZUZpbGUsXG4gIHdyaXRlSnNvblN5bmM6IGpzb25GaWxlLndyaXRlRmlsZVN5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2VcbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgbWtkaXIgPSByZXF1aXJlKCcuLi9ta2RpcnMnKVxuY29uc3QgcGF0aEV4aXN0cyA9IHJlcXVpcmUoJy4uL3BhdGgtZXhpc3RzJykucGF0aEV4aXN0c1xuXG5hc3luYyBmdW5jdGlvbiBvdXRwdXRGaWxlIChmaWxlLCBkYXRhLCBlbmNvZGluZyA9ICd1dGYtOCcpIHtcbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGUpXG5cbiAgaWYgKCEoYXdhaXQgcGF0aEV4aXN0cyhkaXIpKSkge1xuICAgIGF3YWl0IG1rZGlyLm1rZGlycyhkaXIpXG4gIH1cblxuICByZXR1cm4gZnMud3JpdGVGaWxlKGZpbGUsIGRhdGEsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBvdXRwdXRGaWxlU3luYyAoZmlsZSwgLi4uYXJncykge1xuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZmlsZSlcbiAgaWYgKCFmcy5leGlzdHNTeW5jKGRpcikpIHtcbiAgICBta2Rpci5ta2RpcnNTeW5jKGRpcilcbiAgfVxuXG4gIGZzLndyaXRlRmlsZVN5bmMoZmlsZSwgLi4uYXJncylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG91dHB1dEZpbGU6IHUob3V0cHV0RmlsZSksXG4gIG91dHB1dEZpbGVTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBzdHJpbmdpZnkgfSA9IHJlcXVpcmUoJ2pzb25maWxlL3V0aWxzJylcbmNvbnN0IHsgb3V0cHV0RmlsZSB9ID0gcmVxdWlyZSgnLi4vb3V0cHV0LWZpbGUnKVxuXG5hc3luYyBmdW5jdGlvbiBvdXRwdXRKc29uIChmaWxlLCBkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qgc3RyID0gc3RyaW5naWZ5KGRhdGEsIG9wdGlvbnMpXG5cbiAgYXdhaXQgb3V0cHV0RmlsZShmaWxlLCBzdHIsIG9wdGlvbnMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3V0cHV0SnNvblxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgc3RyaW5naWZ5IH0gPSByZXF1aXJlKCdqc29uZmlsZS91dGlscycpXG5jb25zdCB7IG91dHB1dEZpbGVTeW5jIH0gPSByZXF1aXJlKCcuLi9vdXRwdXQtZmlsZScpXG5cbmZ1bmN0aW9uIG91dHB1dEpzb25TeW5jIChmaWxlLCBkYXRhLCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0ciA9IHN0cmluZ2lmeShkYXRhLCBvcHRpb25zKVxuXG4gIG91dHB1dEZpbGVTeW5jKGZpbGUsIHN0ciwgb3B0aW9ucylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdXRwdXRKc29uU3luY1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tUHJvbWlzZVxuY29uc3QganNvbkZpbGUgPSByZXF1aXJlKCcuL2pzb25maWxlJylcblxuanNvbkZpbGUub3V0cHV0SnNvbiA9IHUocmVxdWlyZSgnLi9vdXRwdXQtanNvbicpKVxuanNvbkZpbGUub3V0cHV0SnNvblN5bmMgPSByZXF1aXJlKCcuL291dHB1dC1qc29uLXN5bmMnKVxuLy8gYWxpYXNlc1xuanNvbkZpbGUub3V0cHV0SlNPTiA9IGpzb25GaWxlLm91dHB1dEpzb25cbmpzb25GaWxlLm91dHB1dEpTT05TeW5jID0ganNvbkZpbGUub3V0cHV0SnNvblN5bmNcbmpzb25GaWxlLndyaXRlSlNPTiA9IGpzb25GaWxlLndyaXRlSnNvblxuanNvbkZpbGUud3JpdGVKU09OU3luYyA9IGpzb25GaWxlLndyaXRlSnNvblN5bmNcbmpzb25GaWxlLnJlYWRKU09OID0ganNvbkZpbGUucmVhZEpzb25cbmpzb25GaWxlLnJlYWRKU09OU3luYyA9IGpzb25GaWxlLnJlYWRKc29uU3luY1xuXG5tb2R1bGUuZXhwb3J0cyA9IGpzb25GaWxlXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCB7IGNvcHkgfSA9IHJlcXVpcmUoJy4uL2NvcHknKVxuY29uc3QgeyByZW1vdmUgfSA9IHJlcXVpcmUoJy4uL3JlbW92ZScpXG5jb25zdCB7IG1rZGlycCB9ID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHsgcGF0aEV4aXN0cyB9ID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKVxuY29uc3Qgc3RhdCA9IHJlcXVpcmUoJy4uL3V0aWwvc3RhdCcpXG5cbmFzeW5jIGZ1bmN0aW9uIG1vdmUgKHNyYywgZGVzdCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IG92ZXJ3cml0ZSA9IG9wdHMub3ZlcndyaXRlIHx8IG9wdHMuY2xvYmJlciB8fCBmYWxzZVxuXG4gIGNvbnN0IHsgc3JjU3RhdCwgaXNDaGFuZ2luZ0Nhc2UgPSBmYWxzZSB9ID0gYXdhaXQgc3RhdC5jaGVja1BhdGhzKHNyYywgZGVzdCwgJ21vdmUnLCBvcHRzKVxuXG4gIGF3YWl0IHN0YXQuY2hlY2tQYXJlbnRQYXRocyhzcmMsIHNyY1N0YXQsIGRlc3QsICdtb3ZlJylcblxuICAvLyBJZiB0aGUgcGFyZW50IG9mIGRlc3QgaXMgbm90IHJvb3QsIG1ha2Ugc3VyZSBpdCBleGlzdHMgYmVmb3JlIHByb2NlZWRpbmdcbiAgY29uc3QgZGVzdFBhcmVudCA9IHBhdGguZGlybmFtZShkZXN0KVxuICBjb25zdCBwYXJzZWRQYXJlbnRQYXRoID0gcGF0aC5wYXJzZShkZXN0UGFyZW50KVxuICBpZiAocGFyc2VkUGFyZW50UGF0aC5yb290ICE9PSBkZXN0UGFyZW50KSB7XG4gICAgYXdhaXQgbWtkaXJwKGRlc3RQYXJlbnQpXG4gIH1cblxuICByZXR1cm4gZG9SZW5hbWUoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGlzQ2hhbmdpbmdDYXNlKVxufVxuXG5hc3luYyBmdW5jdGlvbiBkb1JlbmFtZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGlzQ2hhbmdpbmdDYXNlKSB7XG4gIGlmICghaXNDaGFuZ2luZ0Nhc2UpIHtcbiAgICBpZiAob3ZlcndyaXRlKSB7XG4gICAgICBhd2FpdCByZW1vdmUoZGVzdClcbiAgICB9IGVsc2UgaWYgKGF3YWl0IHBhdGhFeGlzdHMoZGVzdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZGVzdCBhbHJlYWR5IGV4aXN0cy4nKVxuICAgIH1cbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVHJ5IHcvIHJlbmFtZSBmaXJzdCwgYW5kIHRyeSBjb3B5ICsgcmVtb3ZlIGlmIEVYREVWXG4gICAgYXdhaXQgZnMucmVuYW1lKHNyYywgZGVzdClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlICE9PSAnRVhERVYnKSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gICAgYXdhaXQgbW92ZUFjcm9zc0RldmljZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSlcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBtb3ZlQWNyb3NzRGV2aWNlIChzcmMsIGRlc3QsIG92ZXJ3cml0ZSkge1xuICBjb25zdCBvcHRzID0ge1xuICAgIG92ZXJ3cml0ZSxcbiAgICBlcnJvck9uRXhpc3Q6IHRydWUsXG4gICAgcHJlc2VydmVUaW1lc3RhbXBzOiB0cnVlXG4gIH1cblxuICBhd2FpdCBjb3B5KHNyYywgZGVzdCwgb3B0cylcbiAgcmV0dXJuIHJlbW92ZShzcmMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbW92ZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgY29weVN5bmMgPSByZXF1aXJlKCcuLi9jb3B5JykuY29weVN5bmNcbmNvbnN0IHJlbW92ZVN5bmMgPSByZXF1aXJlKCcuLi9yZW1vdmUnKS5yZW1vdmVTeW5jXG5jb25zdCBta2RpcnBTeW5jID0gcmVxdWlyZSgnLi4vbWtkaXJzJykubWtkaXJwU3luY1xuY29uc3Qgc3RhdCA9IHJlcXVpcmUoJy4uL3V0aWwvc3RhdCcpXG5cbmZ1bmN0aW9uIG1vdmVTeW5jIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge31cbiAgY29uc3Qgb3ZlcndyaXRlID0gb3B0cy5vdmVyd3JpdGUgfHwgb3B0cy5jbG9iYmVyIHx8IGZhbHNlXG5cbiAgY29uc3QgeyBzcmNTdGF0LCBpc0NoYW5naW5nQ2FzZSA9IGZhbHNlIH0gPSBzdGF0LmNoZWNrUGF0aHNTeW5jKHNyYywgZGVzdCwgJ21vdmUnLCBvcHRzKVxuICBzdGF0LmNoZWNrUGFyZW50UGF0aHNTeW5jKHNyYywgc3JjU3RhdCwgZGVzdCwgJ21vdmUnKVxuICBpZiAoIWlzUGFyZW50Um9vdChkZXN0KSkgbWtkaXJwU3luYyhwYXRoLmRpcm5hbWUoZGVzdCkpXG4gIHJldHVybiBkb1JlbmFtZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgaXNDaGFuZ2luZ0Nhc2UpXG59XG5cbmZ1bmN0aW9uIGlzUGFyZW50Um9vdCAoZGVzdCkge1xuICBjb25zdCBwYXJlbnQgPSBwYXRoLmRpcm5hbWUoZGVzdClcbiAgY29uc3QgcGFyc2VkUGF0aCA9IHBhdGgucGFyc2UocGFyZW50KVxuICByZXR1cm4gcGFyc2VkUGF0aC5yb290ID09PSBwYXJlbnRcbn1cblxuZnVuY3Rpb24gZG9SZW5hbWUgKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBpc0NoYW5naW5nQ2FzZSkge1xuICBpZiAoaXNDaGFuZ2luZ0Nhc2UpIHJldHVybiByZW5hbWUoc3JjLCBkZXN0LCBvdmVyd3JpdGUpXG4gIGlmIChvdmVyd3JpdGUpIHtcbiAgICByZW1vdmVTeW5jKGRlc3QpXG4gICAgcmV0dXJuIHJlbmFtZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSlcbiAgfVxuICBpZiAoZnMuZXhpc3RzU3luYyhkZXN0KSkgdGhyb3cgbmV3IEVycm9yKCdkZXN0IGFscmVhZHkgZXhpc3RzLicpXG4gIHJldHVybiByZW5hbWUoc3JjLCBkZXN0LCBvdmVyd3JpdGUpXG59XG5cbmZ1bmN0aW9uIHJlbmFtZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUpIHtcbiAgdHJ5IHtcbiAgICBmcy5yZW5hbWVTeW5jKHNyYywgZGVzdClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlICE9PSAnRVhERVYnKSB0aHJvdyBlcnJcbiAgICByZXR1cm4gbW92ZUFjcm9zc0RldmljZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBtb3ZlQWNyb3NzRGV2aWNlIChzcmMsIGRlc3QsIG92ZXJ3cml0ZSkge1xuICBjb25zdCBvcHRzID0ge1xuICAgIG92ZXJ3cml0ZSxcbiAgICBlcnJvck9uRXhpc3Q6IHRydWUsXG4gICAgcHJlc2VydmVUaW1lc3RhbXBzOiB0cnVlXG4gIH1cbiAgY29weVN5bmMoc3JjLCBkZXN0LCBvcHRzKVxuICByZXR1cm4gcmVtb3ZlU3luYyhzcmMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbW92ZVN5bmNcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2Vcbm1vZHVsZS5leHBvcnRzID0ge1xuICBtb3ZlOiB1KHJlcXVpcmUoJy4vbW92ZScpKSxcbiAgbW92ZVN5bmM6IHJlcXVpcmUoJy4vbW92ZS1zeW5jJylcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gRXhwb3J0IHByb21pc2VpZmllZCBncmFjZWZ1bC1mczpcbiAgLi4ucmVxdWlyZSgnLi9mcycpLFxuICAvLyBFeHBvcnQgZXh0cmEgbWV0aG9kczpcbiAgLi4ucmVxdWlyZSgnLi9jb3B5JyksXG4gIC4uLnJlcXVpcmUoJy4vZW1wdHknKSxcbiAgLi4ucmVxdWlyZSgnLi9lbnN1cmUnKSxcbiAgLi4ucmVxdWlyZSgnLi9qc29uJyksXG4gIC4uLnJlcXVpcmUoJy4vbWtkaXJzJyksXG4gIC4uLnJlcXVpcmUoJy4vbW92ZScpLFxuICAuLi5yZXF1aXJlKCcuL291dHB1dC1maWxlJyksXG4gIC4uLnJlcXVpcmUoJy4vcGF0aC1leGlzdHMnKSxcbiAgLi4ucmVxdWlyZSgnLi9yZW1vdmUnKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbHVlID0+IHtcblx0Y29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblx0cmV0dXJuIHZhbHVlICE9PSBudWxsICYmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBpc09iaiA9IHJlcXVpcmUoJ2lzLW9iaicpO1xuXG5jb25zdCBkaXNhbGxvd2VkS2V5cyA9IG5ldyBTZXQoW1xuXHQnX19wcm90b19fJyxcblx0J3Byb3RvdHlwZScsXG5cdCdjb25zdHJ1Y3Rvcidcbl0pO1xuXG5jb25zdCBpc1ZhbGlkUGF0aCA9IHBhdGhTZWdtZW50cyA9PiAhcGF0aFNlZ21lbnRzLnNvbWUoc2VnbWVudCA9PiBkaXNhbGxvd2VkS2V5cy5oYXMoc2VnbWVudCkpO1xuXG5mdW5jdGlvbiBnZXRQYXRoU2VnbWVudHMocGF0aCkge1xuXHRjb25zdCBwYXRoQXJyYXkgPSBwYXRoLnNwbGl0KCcuJyk7XG5cdGNvbnN0IHBhcnRzID0gW107XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoQXJyYXkubGVuZ3RoOyBpKyspIHtcblx0XHRsZXQgcCA9IHBhdGhBcnJheVtpXTtcblxuXHRcdHdoaWxlIChwW3AubGVuZ3RoIC0gMV0gPT09ICdcXFxcJyAmJiBwYXRoQXJyYXlbaSArIDFdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHAgPSBwLnNsaWNlKDAsIC0xKSArICcuJztcblx0XHRcdHAgKz0gcGF0aEFycmF5WysraV07XG5cdFx0fVxuXG5cdFx0cGFydHMucHVzaChwKTtcblx0fVxuXG5cdGlmICghaXNWYWxpZFBhdGgocGFydHMpKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cblx0cmV0dXJuIHBhcnRzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Z2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcblx0XHRpZiAoIWlzT2JqKG9iamVjdCkgfHwgdHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IG9iamVjdCA6IHZhbHVlO1xuXHRcdH1cblxuXHRcdGNvbnN0IHBhdGhBcnJheSA9IGdldFBhdGhTZWdtZW50cyhwYXRoKTtcblx0XHRpZiAocGF0aEFycmF5Lmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aEFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRvYmplY3QgPSBvYmplY3RbcGF0aEFycmF5W2ldXTtcblxuXHRcdFx0aWYgKG9iamVjdCA9PT0gdW5kZWZpbmVkIHx8IG9iamVjdCA9PT0gbnVsbCkge1xuXHRcdFx0XHQvLyBgb2JqZWN0YCBpcyBlaXRoZXIgYHVuZGVmaW5lZGAgb3IgYG51bGxgIHNvIHdlIHdhbnQgdG8gc3RvcCB0aGUgbG9vcCwgYW5kXG5cdFx0XHRcdC8vIGlmIHRoaXMgaXMgbm90IHRoZSBsYXN0IGJpdCBvZiB0aGUgcGF0aCwgYW5kXG5cdFx0XHRcdC8vIGlmIGl0IGRpZCd0IHJldHVybiBgdW5kZWZpbmVkYFxuXHRcdFx0XHQvLyBpdCB3b3VsZCByZXR1cm4gYG51bGxgIGlmIGBvYmplY3RgIGlzIGBudWxsYFxuXHRcdFx0XHQvLyBidXQgd2Ugd2FudCBgZ2V0KHtmb286IG51bGx9LCAnZm9vLmJhcicpYCB0byBlcXVhbCBgdW5kZWZpbmVkYCwgb3IgdGhlIHN1cHBsaWVkIHZhbHVlLCBub3QgYG51bGxgXG5cdFx0XHRcdGlmIChpICE9PSBwYXRoQXJyYXkubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmplY3QgPT09IHVuZGVmaW5lZCA/IHZhbHVlIDogb2JqZWN0O1xuXHR9LFxuXG5cdHNldChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG5cdFx0aWYgKCFpc09iaihvYmplY3QpIHx8IHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIG9iamVjdDtcblx0XHR9XG5cblx0XHRjb25zdCByb290ID0gb2JqZWN0O1xuXHRcdGNvbnN0IHBhdGhBcnJheSA9IGdldFBhdGhTZWdtZW50cyhwYXRoKTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aEFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBwID0gcGF0aEFycmF5W2ldO1xuXG5cdFx0XHRpZiAoIWlzT2JqKG9iamVjdFtwXSkpIHtcblx0XHRcdFx0b2JqZWN0W3BdID0ge307XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpID09PSBwYXRoQXJyYXkubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRvYmplY3RbcF0gPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0b2JqZWN0ID0gb2JqZWN0W3BdO1xuXHRcdH1cblxuXHRcdHJldHVybiByb290O1xuXHR9LFxuXG5cdGRlbGV0ZShvYmplY3QsIHBhdGgpIHtcblx0XHRpZiAoIWlzT2JqKG9iamVjdCkgfHwgdHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Y29uc3QgcGF0aEFycmF5ID0gZ2V0UGF0aFNlZ21lbnRzKHBhdGgpO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoQXJyYXkubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IHAgPSBwYXRoQXJyYXlbaV07XG5cblx0XHRcdGlmIChpID09PSBwYXRoQXJyYXkubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRkZWxldGUgb2JqZWN0W3BdO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0b2JqZWN0ID0gb2JqZWN0W3BdO1xuXG5cdFx0XHRpZiAoIWlzT2JqKG9iamVjdCkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRoYXMob2JqZWN0LCBwYXRoKSB7XG5cdFx0aWYgKCFpc09iaihvYmplY3QpIHx8IHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGNvbnN0IHBhdGhBcnJheSA9IGdldFBhdGhTZWdtZW50cyhwYXRoKTtcblx0XHRpZiAocGF0aEFycmF5Lmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL25vLWZvci1sb29wXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoQXJyYXkubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChpc09iaihvYmplY3QpKSB7XG5cdFx0XHRcdGlmICghKHBhdGhBcnJheVtpXSBpbiBvYmplY3QpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0b2JqZWN0ID0gb2JqZWN0W3BhdGhBcnJheVtpXV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnAgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG5cdGZzLmFjY2VzcyhmcCwgZXJyID0+IHtcblx0XHRyZXNvbHZlKCFlcnIpO1xuXHR9KTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cy5zeW5jID0gZnAgPT4ge1xuXHR0cnkge1xuXHRcdGZzLmFjY2Vzc1N5bmMoZnApO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHBUcnkgPSAoZm4sIC4uLmFyZ3VtZW50c18pID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuXHRyZXNvbHZlKGZuKC4uLmFyZ3VtZW50c18pKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBUcnk7XG4vLyBUT0RPOiByZW1vdmUgdGhpcyBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gcFRyeTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHBUcnkgPSByZXF1aXJlKCdwLXRyeScpO1xuXG5jb25zdCBwTGltaXQgPSBjb25jdXJyZW5jeSA9PiB7XG5cdGlmICghKChOdW1iZXIuaXNJbnRlZ2VyKGNvbmN1cnJlbmN5KSB8fCBjb25jdXJyZW5jeSA9PT0gSW5maW5pdHkpICYmIGNvbmN1cnJlbmN5ID4gMCkpIHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYGNvbmN1cnJlbmN5YCB0byBiZSBhIG51bWJlciBmcm9tIDEgYW5kIHVwJykpO1xuXHR9XG5cblx0Y29uc3QgcXVldWUgPSBbXTtcblx0bGV0IGFjdGl2ZUNvdW50ID0gMDtcblxuXHRjb25zdCBuZXh0ID0gKCkgPT4ge1xuXHRcdGFjdGl2ZUNvdW50LS07XG5cblx0XHRpZiAocXVldWUubGVuZ3RoID4gMCkge1xuXHRcdFx0cXVldWUuc2hpZnQoKSgpO1xuXHRcdH1cblx0fTtcblxuXHRjb25zdCBydW4gPSAoZm4sIHJlc29sdmUsIC4uLmFyZ3MpID0+IHtcblx0XHRhY3RpdmVDb3VudCsrO1xuXG5cdFx0Y29uc3QgcmVzdWx0ID0gcFRyeShmbiwgLi4uYXJncyk7XG5cblx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cblx0XHRyZXN1bHQudGhlbihuZXh0LCBuZXh0KTtcblx0fTtcblxuXHRjb25zdCBlbnF1ZXVlID0gKGZuLCByZXNvbHZlLCAuLi5hcmdzKSA9PiB7XG5cdFx0aWYgKGFjdGl2ZUNvdW50IDwgY29uY3VycmVuY3kpIHtcblx0XHRcdHJ1bihmbiwgcmVzb2x2ZSwgLi4uYXJncyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHF1ZXVlLnB1c2gocnVuLmJpbmQobnVsbCwgZm4sIHJlc29sdmUsIC4uLmFyZ3MpKTtcblx0XHR9XG5cdH07XG5cblx0Y29uc3QgZ2VuZXJhdG9yID0gKGZuLCAuLi5hcmdzKSA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IGVucXVldWUoZm4sIHJlc29sdmUsIC4uLmFyZ3MpKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZ2VuZXJhdG9yLCB7XG5cdFx0YWN0aXZlQ291bnQ6IHtcblx0XHRcdGdldDogKCkgPT4gYWN0aXZlQ291bnRcblx0XHR9LFxuXHRcdHBlbmRpbmdDb3VudDoge1xuXHRcdFx0Z2V0OiAoKSA9PiBxdWV1ZS5sZW5ndGhcblx0XHR9LFxuXHRcdGNsZWFyUXVldWU6IHtcblx0XHRcdHZhbHVlOiAoKSA9PiB7XG5cdFx0XHRcdHF1ZXVlLmxlbmd0aCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gZ2VuZXJhdG9yO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBwTGltaXQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gcExpbWl0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcExpbWl0ID0gcmVxdWlyZSgncC1saW1pdCcpO1xuXG5jbGFzcyBFbmRFcnJvciBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IodmFsdWUpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0fVxufVxuXG4vLyBUaGUgaW5wdXQgY2FuIGFsc28gYmUgYSBwcm9taXNlLCBzbyB3ZSBgUHJvbWlzZS5yZXNvbHZlKClgIGl0XG5jb25zdCB0ZXN0RWxlbWVudCA9IChlbCwgdGVzdGVyKSA9PiBQcm9taXNlLnJlc29sdmUoZWwpLnRoZW4odGVzdGVyKTtcblxuLy8gVGhlIGlucHV0IGNhbiBhbHNvIGJlIGEgcHJvbWlzZSwgc28gd2UgYFByb21pc2UuYWxsKClgIHRoZW0gYm90aFxuY29uc3QgZmluZGVyID0gZWwgPT4gUHJvbWlzZS5hbGwoZWwpLnRoZW4odmFsID0+IHZhbFsxXSA9PT0gdHJ1ZSAmJiBQcm9taXNlLnJlamVjdChuZXcgRW5kRXJyb3IodmFsWzBdKSkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChpdGVyYWJsZSwgdGVzdGVyLCBvcHRzKSA9PiB7XG5cdG9wdHMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRjb25jdXJyZW5jeTogSW5maW5pdHksXG5cdFx0cHJlc2VydmVPcmRlcjogdHJ1ZVxuXHR9LCBvcHRzKTtcblxuXHRjb25zdCBsaW1pdCA9IHBMaW1pdChvcHRzLmNvbmN1cnJlbmN5KTtcblxuXHQvLyBTdGFydCBhbGwgdGhlIHByb21pc2VzIGNvbmN1cnJlbnRseSB3aXRoIG9wdGlvbmFsIGxpbWl0XG5cdGNvbnN0IGl0ZW1zID0gWy4uLml0ZXJhYmxlXS5tYXAoZWwgPT4gW2VsLCBsaW1pdCh0ZXN0RWxlbWVudCwgZWwsIHRlc3RlcildKTtcblxuXHQvLyBDaGVjayB0aGUgcHJvbWlzZXMgZWl0aGVyIHNlcmlhbGx5IG9yIGNvbmN1cnJlbnRseVxuXHRjb25zdCBjaGVja0xpbWl0ID0gcExpbWl0KG9wdHMucHJlc2VydmVPcmRlciA/IDEgOiBJbmZpbml0eSk7XG5cblx0cmV0dXJuIFByb21pc2UuYWxsKGl0ZW1zLm1hcChlbCA9PiBjaGVja0xpbWl0KGZpbmRlciwgZWwpKSlcblx0XHQudGhlbigoKSA9PiB7fSlcblx0XHQuY2F0Y2goZXJyID0+IGVyciBpbnN0YW5jZW9mIEVuZEVycm9yID8gZXJyLnZhbHVlIDogUHJvbWlzZS5yZWplY3QoZXJyKSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCdwYXRoLWV4aXN0cycpO1xuY29uc3QgcExvY2F0ZSA9IHJlcXVpcmUoJ3AtbG9jYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGl0ZXJhYmxlLCBvcHRpb25zKSA9PiB7XG5cdG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRjd2Q6IHByb2Nlc3MuY3dkKClcblx0fSwgb3B0aW9ucyk7XG5cblx0cmV0dXJuIHBMb2NhdGUoaXRlcmFibGUsIGVsID0+IHBhdGhFeGlzdHMocGF0aC5yZXNvbHZlKG9wdGlvbnMuY3dkLCBlbCkpLCBvcHRpb25zKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnN5bmMgPSAoaXRlcmFibGUsIG9wdGlvbnMpID0+IHtcblx0b3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdGN3ZDogcHJvY2Vzcy5jd2QoKVxuXHR9LCBvcHRpb25zKTtcblxuXHRmb3IgKGNvbnN0IGVsIG9mIGl0ZXJhYmxlKSB7XG5cdFx0aWYgKHBhdGhFeGlzdHMuc3luYyhwYXRoLnJlc29sdmUob3B0aW9ucy5jd2QsIGVsKSkpIHtcblx0XHRcdHJldHVybiBlbDtcblx0XHR9XG5cdH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgbG9jYXRlUGF0aCA9IHJlcXVpcmUoJ2xvY2F0ZS1wYXRoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZpbGVuYW1lLCBvcHRzID0ge30pID0+IHtcblx0Y29uc3Qgc3RhcnREaXIgPSBwYXRoLnJlc29sdmUob3B0cy5jd2QgfHwgJycpO1xuXHRjb25zdCB7cm9vdH0gPSBwYXRoLnBhcnNlKHN0YXJ0RGlyKTtcblxuXHRjb25zdCBmaWxlbmFtZXMgPSBbXS5jb25jYXQoZmlsZW5hbWUpO1xuXG5cdHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcblx0XHQoZnVuY3Rpb24gZmluZChkaXIpIHtcblx0XHRcdGxvY2F0ZVBhdGgoZmlsZW5hbWVzLCB7Y3dkOiBkaXJ9KS50aGVuKGZpbGUgPT4ge1xuXHRcdFx0XHRpZiAoZmlsZSkge1xuXHRcdFx0XHRcdHJlc29sdmUocGF0aC5qb2luKGRpciwgZmlsZSkpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGRpciA9PT0gcm9vdCkge1xuXHRcdFx0XHRcdHJlc29sdmUobnVsbCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZmluZChwYXRoLmRpcm5hbWUoZGlyKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pKHN0YXJ0RGlyKTtcblx0fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5zeW5jID0gKGZpbGVuYW1lLCBvcHRzID0ge30pID0+IHtcblx0bGV0IGRpciA9IHBhdGgucmVzb2x2ZShvcHRzLmN3ZCB8fCAnJyk7XG5cdGNvbnN0IHtyb290fSA9IHBhdGgucGFyc2UoZGlyKTtcblxuXHRjb25zdCBmaWxlbmFtZXMgPSBbXS5jb25jYXQoZmlsZW5hbWUpO1xuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cblx0d2hpbGUgKHRydWUpIHtcblx0XHRjb25zdCBmaWxlID0gbG9jYXRlUGF0aC5zeW5jKGZpbGVuYW1lcywge2N3ZDogZGlyfSk7XG5cblx0XHRpZiAoZmlsZSkge1xuXHRcdFx0cmV0dXJuIHBhdGguam9pbihkaXIsIGZpbGUpO1xuXHRcdH1cblxuXHRcdGlmIChkaXIgPT09IHJvb3QpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGRpciA9IHBhdGguZGlybmFtZShkaXIpO1xuXHR9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgZmluZFVwID0gcmVxdWlyZSgnZmluZC11cCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzeW5jICh7Y3dkfSA9IHt9KSA9PiBmaW5kVXAoJ3BhY2thZ2UuanNvbicsIHtjd2R9KTtcbm1vZHVsZS5leHBvcnRzLnN5bmMgPSAoe2N3ZH0gPSB7fSkgPT4gZmluZFVwLnN5bmMoJ3BhY2thZ2UuanNvbicsIHtjd2R9KTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5cbmNvbnN0IGhvbWVkaXIgPSBvcy5ob21lZGlyKCk7XG5jb25zdCB0bXBkaXIgPSBvcy50bXBkaXIoKTtcbmNvbnN0IHtlbnZ9ID0gcHJvY2VzcztcblxuY29uc3QgbWFjb3MgPSBuYW1lID0+IHtcblx0Y29uc3QgbGlicmFyeSA9IHBhdGguam9pbihob21lZGlyLCAnTGlicmFyeScpO1xuXG5cdHJldHVybiB7XG5cdFx0ZGF0YTogcGF0aC5qb2luKGxpYnJhcnksICdBcHBsaWNhdGlvbiBTdXBwb3J0JywgbmFtZSksXG5cdFx0Y29uZmlnOiBwYXRoLmpvaW4obGlicmFyeSwgJ1ByZWZlcmVuY2VzJywgbmFtZSksXG5cdFx0Y2FjaGU6IHBhdGguam9pbihsaWJyYXJ5LCAnQ2FjaGVzJywgbmFtZSksXG5cdFx0bG9nOiBwYXRoLmpvaW4obGlicmFyeSwgJ0xvZ3MnLCBuYW1lKSxcblx0XHR0ZW1wOiBwYXRoLmpvaW4odG1wZGlyLCBuYW1lKVxuXHR9O1xufTtcblxuY29uc3Qgd2luZG93cyA9IG5hbWUgPT4ge1xuXHRjb25zdCBhcHBEYXRhID0gZW52LkFQUERBVEEgfHwgcGF0aC5qb2luKGhvbWVkaXIsICdBcHBEYXRhJywgJ1JvYW1pbmcnKTtcblx0Y29uc3QgbG9jYWxBcHBEYXRhID0gZW52LkxPQ0FMQVBQREFUQSB8fCBwYXRoLmpvaW4oaG9tZWRpciwgJ0FwcERhdGEnLCAnTG9jYWwnKTtcblxuXHRyZXR1cm4ge1xuXHRcdC8vIERhdGEvY29uZmlnL2NhY2hlL2xvZyBhcmUgaW52ZW50ZWQgYnkgbWUgYXMgV2luZG93cyBpc24ndCBvcGluaW9uYXRlZCBhYm91dCB0aGlzXG5cdFx0ZGF0YTogcGF0aC5qb2luKGxvY2FsQXBwRGF0YSwgbmFtZSwgJ0RhdGEnKSxcblx0XHRjb25maWc6IHBhdGguam9pbihhcHBEYXRhLCBuYW1lLCAnQ29uZmlnJyksXG5cdFx0Y2FjaGU6IHBhdGguam9pbihsb2NhbEFwcERhdGEsIG5hbWUsICdDYWNoZScpLFxuXHRcdGxvZzogcGF0aC5qb2luKGxvY2FsQXBwRGF0YSwgbmFtZSwgJ0xvZycpLFxuXHRcdHRlbXA6IHBhdGguam9pbih0bXBkaXIsIG5hbWUpXG5cdH07XG59O1xuXG4vLyBodHRwczovL3NwZWNpZmljYXRpb25zLmZyZWVkZXNrdG9wLm9yZy9iYXNlZGlyLXNwZWMvYmFzZWRpci1zcGVjLWxhdGVzdC5odG1sXG5jb25zdCBsaW51eCA9IG5hbWUgPT4ge1xuXHRjb25zdCB1c2VybmFtZSA9IHBhdGguYmFzZW5hbWUoaG9tZWRpcik7XG5cblx0cmV0dXJuIHtcblx0XHRkYXRhOiBwYXRoLmpvaW4oZW52LlhER19EQVRBX0hPTUUgfHwgcGF0aC5qb2luKGhvbWVkaXIsICcubG9jYWwnLCAnc2hhcmUnKSwgbmFtZSksXG5cdFx0Y29uZmlnOiBwYXRoLmpvaW4oZW52LlhER19DT05GSUdfSE9NRSB8fCBwYXRoLmpvaW4oaG9tZWRpciwgJy5jb25maWcnKSwgbmFtZSksXG5cdFx0Y2FjaGU6IHBhdGguam9pbihlbnYuWERHX0NBQ0hFX0hPTUUgfHwgcGF0aC5qb2luKGhvbWVkaXIsICcuY2FjaGUnKSwgbmFtZSksXG5cdFx0Ly8gaHR0cHM6Ly93aWtpLmRlYmlhbi5vcmcvWERHQmFzZURpcmVjdG9yeVNwZWNpZmljYXRpb24jc3RhdGVcblx0XHRsb2c6IHBhdGguam9pbihlbnYuWERHX1NUQVRFX0hPTUUgfHwgcGF0aC5qb2luKGhvbWVkaXIsICcubG9jYWwnLCAnc3RhdGUnKSwgbmFtZSksXG5cdFx0dGVtcDogcGF0aC5qb2luKHRtcGRpciwgdXNlcm5hbWUsIG5hbWUpXG5cdH07XG59O1xuXG5jb25zdCBlbnZQYXRocyA9IChuYW1lLCBvcHRpb25zKSA9PiB7XG5cdGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBuYW1lfWApO1xuXHR9XG5cblx0b3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe3N1ZmZpeDogJ25vZGVqcyd9LCBvcHRpb25zKTtcblxuXHRpZiAob3B0aW9ucy5zdWZmaXgpIHtcblx0XHQvLyBBZGQgc3VmZml4IHRvIHByZXZlbnQgcG9zc2libGUgY29uZmxpY3Qgd2l0aCBuYXRpdmUgYXBwc1xuXHRcdG5hbWUgKz0gYC0ke29wdGlvbnMuc3VmZml4fWA7XG5cdH1cblxuXHRpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicpIHtcblx0XHRyZXR1cm4gbWFjb3MobmFtZSk7XG5cdH1cblxuXHRpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuXHRcdHJldHVybiB3aW5kb3dzKG5hbWUpO1xuXHR9XG5cblx0cmV0dXJuIGxpbnV4KG5hbWUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbnZQYXRocztcbi8vIFRPRE86IFJlbW92ZSB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZW52UGF0aHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIENPTlNUUyAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OT09QID0gZXhwb3J0cy5MSU1JVF9GSUxFU19ERVNDUklQVE9SUyA9IGV4cG9ydHMuTElNSVRfQkFTRU5BTUVfTEVOR1RIID0gZXhwb3J0cy5JU19VU0VSX1JPT1QgPSBleHBvcnRzLklTX1BPU0lYID0gZXhwb3J0cy5ERUZBVUxUX1RJTUVPVVRfU1lOQyA9IGV4cG9ydHMuREVGQVVMVF9USU1FT1VUX0FTWU5DID0gZXhwb3J0cy5ERUZBVUxUX1dSSVRFX09QVElPTlMgPSBleHBvcnRzLkRFRkFVTFRfUkVBRF9PUFRJT05TID0gZXhwb3J0cy5ERUZBVUxUX0ZPTERFUl9NT0RFID0gZXhwb3J0cy5ERUZBVUxUX0ZJTEVfTU9ERSA9IGV4cG9ydHMuREVGQVVMVF9FTkNPRElORyA9IHZvaWQgMDtcbmNvbnN0IERFRkFVTFRfRU5DT0RJTkcgPSAndXRmOCc7XG5leHBvcnRzLkRFRkFVTFRfRU5DT0RJTkcgPSBERUZBVUxUX0VOQ09ESU5HO1xuY29uc3QgREVGQVVMVF9GSUxFX01PREUgPSAwbzY2NjtcbmV4cG9ydHMuREVGQVVMVF9GSUxFX01PREUgPSBERUZBVUxUX0ZJTEVfTU9ERTtcbmNvbnN0IERFRkFVTFRfRk9MREVSX01PREUgPSAwbzc3NztcbmV4cG9ydHMuREVGQVVMVF9GT0xERVJfTU9ERSA9IERFRkFVTFRfRk9MREVSX01PREU7XG5jb25zdCBERUZBVUxUX1JFQURfT1BUSU9OUyA9IHt9O1xuZXhwb3J0cy5ERUZBVUxUX1JFQURfT1BUSU9OUyA9IERFRkFVTFRfUkVBRF9PUFRJT05TO1xuY29uc3QgREVGQVVMVF9XUklURV9PUFRJT05TID0ge307XG5leHBvcnRzLkRFRkFVTFRfV1JJVEVfT1BUSU9OUyA9IERFRkFVTFRfV1JJVEVfT1BUSU9OUztcbmNvbnN0IERFRkFVTFRfVElNRU9VVF9BU1lOQyA9IDUwMDA7XG5leHBvcnRzLkRFRkFVTFRfVElNRU9VVF9BU1lOQyA9IERFRkFVTFRfVElNRU9VVF9BU1lOQztcbmNvbnN0IERFRkFVTFRfVElNRU9VVF9TWU5DID0gMTAwO1xuZXhwb3J0cy5ERUZBVUxUX1RJTUVPVVRfU1lOQyA9IERFRkFVTFRfVElNRU9VVF9TWU5DO1xuY29uc3QgSVNfUE9TSVggPSAhIXByb2Nlc3MuZ2V0dWlkO1xuZXhwb3J0cy5JU19QT1NJWCA9IElTX1BPU0lYO1xuY29uc3QgSVNfVVNFUl9ST09UID0gcHJvY2Vzcy5nZXR1aWQgPyAhcHJvY2Vzcy5nZXR1aWQoKSA6IGZhbHNlO1xuZXhwb3J0cy5JU19VU0VSX1JPT1QgPSBJU19VU0VSX1JPT1Q7XG5jb25zdCBMSU1JVF9CQVNFTkFNRV9MRU5HVEggPSAxMjg7IC8vVE9ETzogZmV0Y2ggdGhlIHJlYWwgbGltaXQgZnJvbSB0aGUgZmlsZXN5c3RlbSAvL1RPRE86IGZldGNoIHRoZSB3aG9sZS1wYXRoIGxlbmd0aCBsaW1pdCB0b29cbmV4cG9ydHMuTElNSVRfQkFTRU5BTUVfTEVOR1RIID0gTElNSVRfQkFTRU5BTUVfTEVOR1RIO1xuY29uc3QgTElNSVRfRklMRVNfREVTQ1JJUFRPUlMgPSAxMDAwMDsgLy9UT0RPOiBmZXRjaCB0aGUgcmVhbCBsaW1pdCBmcm9tIHRoZSBmaWxlc3lzdGVtXG5leHBvcnRzLkxJTUlUX0ZJTEVTX0RFU0NSSVBUT1JTID0gTElNSVRfRklMRVNfREVTQ1JJUFRPUlM7XG5jb25zdCBOT09QID0gKCkgPT4geyB9O1xuZXhwb3J0cy5OT09QID0gTk9PUDtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogSU1QT1JUICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmF0dGVtcHRpZnlTeW5jID0gZXhwb3J0cy5hdHRlbXB0aWZ5QXN5bmMgPSB2b2lkIDA7XG5jb25zdCBjb25zdHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdHNcIik7XG4vKiBBVFRFTVBUSUZZICovXG4vL1RPRE86IE1heWJlIHB1Ymxpc2ggdGhpcyBhcyBhIHN0YW5kYWxvbmUgcGFja2FnZVxuLy9GSVhNRTogVGhlIHR5cGUgY2FzdGluZ3MgaGVyZSBhcmVuJ3QgZXhhY3RseSBjb3JyZWN0XG5jb25zdCBhdHRlbXB0aWZ5QXN5bmMgPSAoZm4sIG9uRXJyb3IgPSBjb25zdHNfMS5OT09QKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKS5jYXRjaChvbkVycm9yKTtcbiAgICB9O1xufTtcbmV4cG9ydHMuYXR0ZW1wdGlmeUFzeW5jID0gYXR0ZW1wdGlmeUFzeW5jO1xuY29uc3QgYXR0ZW1wdGlmeVN5bmMgPSAoZm4sIG9uRXJyb3IgPSBjb25zdHNfMS5OT09QKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gb25FcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmV4cG9ydHMuYXR0ZW1wdGlmeVN5bmMgPSBhdHRlbXB0aWZ5U3luYztcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogSU1QT1JUICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb25zdHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdHNcIik7XG4vKiBGUyBIQU5ETEVSUyAqL1xuY29uc3QgSGFuZGxlcnMgPSB7XG4gICAgaXNDaGFuZ2VFcnJvck9rOiAoZXJyb3IpID0+IHtcbiAgICAgICAgY29uc3QgeyBjb2RlIH0gPSBlcnJvcjtcbiAgICAgICAgaWYgKGNvZGUgPT09ICdFTk9TWVMnKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICghY29uc3RzXzEuSVNfVVNFUl9ST09UICYmIChjb2RlID09PSAnRUlOVkFMJyB8fCBjb2RlID09PSAnRVBFUk0nKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBpc1JldHJpYWJsZUVycm9yOiAoZXJyb3IpID0+IHtcbiAgICAgICAgY29uc3QgeyBjb2RlIH0gPSBlcnJvcjtcbiAgICAgICAgaWYgKGNvZGUgPT09ICdFTUZJTEUnIHx8IGNvZGUgPT09ICdFTkZJTEUnIHx8IGNvZGUgPT09ICdFQUdBSU4nIHx8IGNvZGUgPT09ICdFQlVTWScgfHwgY29kZSA9PT0gJ0VBQ0NFU1MnIHx8IGNvZGUgPT09ICdFQUNDUycgfHwgY29kZSA9PT0gJ0VQRVJNJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBvbkNoYW5nZUVycm9yOiAoZXJyb3IpID0+IHtcbiAgICAgICAgaWYgKEhhbmRsZXJzLmlzQ2hhbmdlRXJyb3JPayhlcnJvcikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn07XG4vKiBFWFBPUlQgKi9cbmV4cG9ydHMuZGVmYXVsdCA9IEhhbmRsZXJzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBJTVBPUlQgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbnN0c18xID0gcmVxdWlyZShcIi4uL2NvbnN0c1wiKTtcbi8qIFJFVFJZSUZZIFFVRVVFICovXG5jb25zdCBSZXRyeWZ5UXVldWUgPSB7XG4gICAgaW50ZXJ2YWw6IDI1LFxuICAgIGludGVydmFsSWQ6IHVuZGVmaW5lZCxcbiAgICBsaW1pdDogY29uc3RzXzEuTElNSVRfRklMRVNfREVTQ1JJUFRPUlMsXG4gICAgcXVldWVBY3RpdmU6IG5ldyBTZXQoKSxcbiAgICBxdWV1ZVdhaXRpbmc6IG5ldyBTZXQoKSxcbiAgICBpbml0OiAoKSA9PiB7XG4gICAgICAgIGlmIChSZXRyeWZ5UXVldWUuaW50ZXJ2YWxJZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgUmV0cnlmeVF1ZXVlLmludGVydmFsSWQgPSBzZXRJbnRlcnZhbChSZXRyeWZ5UXVldWUudGljaywgUmV0cnlmeVF1ZXVlLmludGVydmFsKTtcbiAgICB9LFxuICAgIHJlc2V0OiAoKSA9PiB7XG4gICAgICAgIGlmICghUmV0cnlmeVF1ZXVlLmludGVydmFsSWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoUmV0cnlmeVF1ZXVlLmludGVydmFsSWQpO1xuICAgICAgICBkZWxldGUgUmV0cnlmeVF1ZXVlLmludGVydmFsSWQ7XG4gICAgfSxcbiAgICBhZGQ6IChmbikgPT4ge1xuICAgICAgICBSZXRyeWZ5UXVldWUucXVldWVXYWl0aW5nLmFkZChmbik7XG4gICAgICAgIGlmIChSZXRyeWZ5UXVldWUucXVldWVBY3RpdmUuc2l6ZSA8IChSZXRyeWZ5UXVldWUubGltaXQgLyAyKSkgeyAvLyBBY3RpdmUgcXVldWUgbm90IHVuZGVyIHByZWFzc3VyZSwgZXhlY3V0aW5nIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBSZXRyeWZ5UXVldWUudGljaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgUmV0cnlmeVF1ZXVlLmluaXQoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlOiAoZm4pID0+IHtcbiAgICAgICAgUmV0cnlmeVF1ZXVlLnF1ZXVlV2FpdGluZy5kZWxldGUoZm4pO1xuICAgICAgICBSZXRyeWZ5UXVldWUucXVldWVBY3RpdmUuZGVsZXRlKGZuKTtcbiAgICB9LFxuICAgIHNjaGVkdWxlOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiBSZXRyeWZ5UXVldWUucmVtb3ZlKHJlc29sdmVyKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gKCkgPT4gcmVzb2x2ZShjbGVhbnVwKTtcbiAgICAgICAgICAgIFJldHJ5ZnlRdWV1ZS5hZGQocmVzb2x2ZXIpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIHRpY2s6ICgpID0+IHtcbiAgICAgICAgaWYgKFJldHJ5ZnlRdWV1ZS5xdWV1ZUFjdGl2ZS5zaXplID49IFJldHJ5ZnlRdWV1ZS5saW1pdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFSZXRyeWZ5UXVldWUucXVldWVXYWl0aW5nLnNpemUpXG4gICAgICAgICAgICByZXR1cm4gUmV0cnlmeVF1ZXVlLnJlc2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgZm4gb2YgUmV0cnlmeVF1ZXVlLnF1ZXVlV2FpdGluZykge1xuICAgICAgICAgICAgaWYgKFJldHJ5ZnlRdWV1ZS5xdWV1ZUFjdGl2ZS5zaXplID49IFJldHJ5ZnlRdWV1ZS5saW1pdClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIFJldHJ5ZnlRdWV1ZS5xdWV1ZVdhaXRpbmcuZGVsZXRlKGZuKTtcbiAgICAgICAgICAgIFJldHJ5ZnlRdWV1ZS5xdWV1ZUFjdGl2ZS5hZGQoZm4pO1xuICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKiBFWFBPUlQgKi9cbmV4cG9ydHMuZGVmYXVsdCA9IFJldHJ5ZnlRdWV1ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogSU1QT1JUICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJldHJ5aWZ5U3luYyA9IGV4cG9ydHMucmV0cnlpZnlBc3luYyA9IHZvaWQgMDtcbmNvbnN0IHJldHJ5aWZ5X3F1ZXVlXzEgPSByZXF1aXJlKFwiLi9yZXRyeWlmeV9xdWV1ZVwiKTtcbi8qIFJFVFJZSUZZICovXG5jb25zdCByZXRyeWlmeUFzeW5jID0gKGZuLCBpc1JldHJpYWJsZUVycm9yKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0aW1lc3RhbXApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGF0dGVtcHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0cnlpZnlfcXVldWVfMS5kZWZhdWx0LnNjaGVkdWxlKCkudGhlbihjbGVhbnVwID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0sIGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSA+PSB0aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmV0cmlhYmxlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWxheSA9IE1hdGgucm91bmQoMTAwICsgKDQwMCAqIE1hdGgucmFuZG9tKCkpKSwgZGVsYXlQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsYXlQcm9taXNlLnRoZW4oKCkgPT4gYXR0ZW1wdC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfTtcbn07XG5leHBvcnRzLnJldHJ5aWZ5QXN5bmMgPSByZXRyeWlmeUFzeW5jO1xuY29uc3QgcmV0cnlpZnlTeW5jID0gKGZuLCBpc1JldHJpYWJsZUVycm9yKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0aW1lc3RhbXApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGF0dGVtcHQoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSA+IHRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmV0cmlhYmxlRXJyb3IoZXJyb3IpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0ZW1wdC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbn07XG5leHBvcnRzLnJldHJ5aWZ5U3luYyA9IHJldHJ5aWZ5U3luYztcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogSU1QT1JUICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY29uc3QgYXR0ZW1wdGlmeV8xID0gcmVxdWlyZShcIi4vYXR0ZW1wdGlmeVwiKTtcbmNvbnN0IGZzX2hhbmRsZXJzXzEgPSByZXF1aXJlKFwiLi9mc19oYW5kbGVyc1wiKTtcbmNvbnN0IHJldHJ5aWZ5XzEgPSByZXF1aXJlKFwiLi9yZXRyeWlmeVwiKTtcbi8qIEZTICovXG5jb25zdCBGUyA9IHtcbiAgICBjaG1vZEF0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5jaG1vZCksIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5vbkNoYW5nZUVycm9yKSxcbiAgICBjaG93bkF0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5jaG93biksIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5vbkNoYW5nZUVycm9yKSxcbiAgICBjbG9zZUF0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5jbG9zZSkpLFxuICAgIGZzeW5jQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLmZzeW5jKSksXG4gICAgbWtkaXJBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMubWtkaXIpKSxcbiAgICByZWFscGF0aEF0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5yZWFscGF0aCkpLFxuICAgIHN0YXRBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMuc3RhdCkpLFxuICAgIHVubGlua0F0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy51bmxpbmspKSxcbiAgICBjbG9zZVJldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5jbG9zZSksIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICBmc3luY1JldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5mc3luYyksIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICBvcGVuUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLm9wZW4pLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgcmVhZEZpbGVSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMucmVhZEZpbGUpLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgcmVuYW1lUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLnJlbmFtZSksIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICBzdGF0UmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLnN0YXQpLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgd3JpdGVSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMud3JpdGUpLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgY2htb2RTeW5jQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlTeW5jKGZzLmNobW9kU3luYywgZnNfaGFuZGxlcnNfMS5kZWZhdWx0Lm9uQ2hhbmdlRXJyb3IpLFxuICAgIGNob3duU3luY0F0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5U3luYyhmcy5jaG93blN5bmMsIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5vbkNoYW5nZUVycm9yKSxcbiAgICBjbG9zZVN5bmNBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeVN5bmMoZnMuY2xvc2VTeW5jKSxcbiAgICBta2RpclN5bmNBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeVN5bmMoZnMubWtkaXJTeW5jKSxcbiAgICByZWFscGF0aFN5bmNBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeVN5bmMoZnMucmVhbHBhdGhTeW5jKSxcbiAgICBzdGF0U3luY0F0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5U3luYyhmcy5zdGF0U3luYyksXG4gICAgdW5saW5rU3luY0F0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5U3luYyhmcy51bmxpbmtTeW5jKSxcbiAgICBjbG9zZVN5bmNSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeVN5bmMoZnMuY2xvc2VTeW5jLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgZnN5bmNTeW5jUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlTeW5jKGZzLmZzeW5jU3luYywgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIG9wZW5TeW5jUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlTeW5jKGZzLm9wZW5TeW5jLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgcmVhZEZpbGVTeW5jUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlTeW5jKGZzLnJlYWRGaWxlU3luYywgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIHJlbmFtZVN5bmNSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeVN5bmMoZnMucmVuYW1lU3luYywgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIHN0YXRTeW5jUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlTeW5jKGZzLnN0YXRTeW5jLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgd3JpdGVTeW5jUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlTeW5jKGZzLndyaXRlU3luYywgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpXG59O1xuLyogRVhQT1JUICovXG5leHBvcnRzLmRlZmF1bHQgPSBGUztcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogTEFORyAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTGFuZyA9IHtcbiAgICBpc0Z1bmN0aW9uOiAoeCkgPT4ge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG4gICAgfSxcbiAgICBpc1N0cmluZzogKHgpID0+IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnc3RyaW5nJztcbiAgICB9LFxuICAgIGlzVW5kZWZpbmVkOiAoeCkgPT4ge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09ICd1bmRlZmluZWQnO1xuICAgIH1cbn07XG4vKiBFWFBPUlQgKi9cbmV4cG9ydHMuZGVmYXVsdCA9IExhbmc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIElNUE9SVCAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyogVkFSSUFCTEVTICovXG5jb25zdCBRdWV1ZXMgPSB7fTtcbi8qIFNDSEVEVUxFUiAqL1xuLy9UT0RPOiBNYXliZSBwdWJsaXNoIHRoaXMgYXMgYSBzdGFuZGFsb25lIHBhY2thZ2VcbmNvbnN0IFNjaGVkdWxlciA9IHtcbiAgICBuZXh0OiAoaWQpID0+IHtcbiAgICAgICAgY29uc3QgcXVldWUgPSBRdWV1ZXNbaWRdO1xuICAgICAgICBpZiAoIXF1ZXVlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICBjb25zdCBqb2IgPSBxdWV1ZVswXTtcbiAgICAgICAgaWYgKGpvYikge1xuICAgICAgICAgICAgam9iKCgpID0+IFNjaGVkdWxlci5uZXh0KGlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgUXVldWVzW2lkXTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2NoZWR1bGU6IChpZCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBsZXQgcXVldWUgPSBRdWV1ZXNbaWRdO1xuICAgICAgICAgICAgaWYgKCFxdWV1ZSlcbiAgICAgICAgICAgICAgICBxdWV1ZSA9IFF1ZXVlc1tpZF0gPSBbXTtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2gocmVzb2x2ZSk7XG4gICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICByZXNvbHZlKCgpID0+IFNjaGVkdWxlci5uZXh0KGlkKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4vKiBFWFBPUlQgKi9cbmV4cG9ydHMuZGVmYXVsdCA9IFNjaGVkdWxlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogSU1QT1JUICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBjb25zdHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdHNcIik7XG5jb25zdCBmc18xID0gcmVxdWlyZShcIi4vZnNcIik7XG4vKiBURU1QICovXG4vL1RPRE86IE1heWJlIHB1Ymxpc2ggdGhpcyBhcyBhIHN0YW5kYWxvbmUgcGFja2FnZVxuY29uc3QgVGVtcCA9IHtcbiAgICBzdG9yZToge30sXG4gICAgY3JlYXRlOiAoZmlsZVBhdGgpID0+IHtcbiAgICAgICAgY29uc3QgcmFuZG9tbmVzcyA9IGAwMDAwMDAke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDE2Nzc3MjE1KS50b1N0cmluZygxNil9YC5zbGljZSgtNiksIC8vIDYgcmFuZG9tLWVub3VnaCBoZXggY2hhcmFjdGVyc1xuICAgICAgICB0aW1lc3RhbXAgPSBEYXRlLm5vdygpLnRvU3RyaW5nKCkuc2xpY2UoLTEwKSwgLy8gMTAgcHJlY2lzZSB0aW1lc3RhbXAgZGlnaXRzXG4gICAgICAgIHByZWZpeCA9ICd0bXAtJywgc3VmZml4ID0gYC4ke3ByZWZpeH0ke3RpbWVzdGFtcH0ke3JhbmRvbW5lc3N9YCwgdGVtcFBhdGggPSBgJHtmaWxlUGF0aH0ke3N1ZmZpeH1gO1xuICAgICAgICByZXR1cm4gdGVtcFBhdGg7XG4gICAgfSxcbiAgICBnZXQ6IChmaWxlUGF0aCwgY3JlYXRvciwgcHVyZ2UgPSB0cnVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRlbXBQYXRoID0gVGVtcC50cnVuY2F0ZShjcmVhdG9yKGZpbGVQYXRoKSk7XG4gICAgICAgIGlmICh0ZW1wUGF0aCBpbiBUZW1wLnN0b3JlKVxuICAgICAgICAgICAgcmV0dXJuIFRlbXAuZ2V0KGZpbGVQYXRoLCBjcmVhdG9yLCBwdXJnZSk7IC8vIENvbGxpc2lvbiBmb3VuZCwgdHJ5IGFnYWluXG4gICAgICAgIFRlbXAuc3RvcmVbdGVtcFBhdGhdID0gcHVyZ2U7XG4gICAgICAgIGNvbnN0IGRpc3Bvc2VyID0gKCkgPT4gZGVsZXRlIFRlbXAuc3RvcmVbdGVtcFBhdGhdO1xuICAgICAgICByZXR1cm4gW3RlbXBQYXRoLCBkaXNwb3Nlcl07XG4gICAgfSxcbiAgICBwdXJnZTogKGZpbGVQYXRoKSA9PiB7XG4gICAgICAgIGlmICghVGVtcC5zdG9yZVtmaWxlUGF0aF0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRlbGV0ZSBUZW1wLnN0b3JlW2ZpbGVQYXRoXTtcbiAgICAgICAgZnNfMS5kZWZhdWx0LnVubGlua0F0dGVtcHQoZmlsZVBhdGgpO1xuICAgIH0sXG4gICAgcHVyZ2VTeW5jOiAoZmlsZVBhdGgpID0+IHtcbiAgICAgICAgaWYgKCFUZW1wLnN0b3JlW2ZpbGVQYXRoXSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZGVsZXRlIFRlbXAuc3RvcmVbZmlsZVBhdGhdO1xuICAgICAgICBmc18xLmRlZmF1bHQudW5saW5rU3luY0F0dGVtcHQoZmlsZVBhdGgpO1xuICAgIH0sXG4gICAgcHVyZ2VTeW5jQWxsOiAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZmlsZVBhdGggaW4gVGVtcC5zdG9yZSkge1xuICAgICAgICAgICAgVGVtcC5wdXJnZVN5bmMoZmlsZVBhdGgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB0cnVuY2F0ZTogKGZpbGVQYXRoKSA9PiB7XG4gICAgICAgIGNvbnN0IGJhc2VuYW1lID0gcGF0aC5iYXNlbmFtZShmaWxlUGF0aCk7XG4gICAgICAgIGlmIChiYXNlbmFtZS5sZW5ndGggPD0gY29uc3RzXzEuTElNSVRfQkFTRU5BTUVfTEVOR1RIKVxuICAgICAgICAgICAgcmV0dXJuIGZpbGVQYXRoOyAvL0ZJWE1FOiBSb3VnaCBhbmQgcXVpY2sgYXR0ZW1wdCBhdCBkZXRlY3Rpbmcgb2sgbGVuZ3Roc1xuICAgICAgICBjb25zdCB0cnVuY2FibGUgPSAvXihcXC4/KSguKj8pKCg/OlxcLlteLl0rKT8oPzpcXC50bXAtXFxkezEwfVthLWYwLTldezZ9KT8pJC8uZXhlYyhiYXNlbmFtZSk7XG4gICAgICAgIGlmICghdHJ1bmNhYmxlKVxuICAgICAgICAgICAgcmV0dXJuIGZpbGVQYXRoOyAvL0ZJWE1FOiBObyB0cnVuY2FibGUgcGFydCBkZXRlY3RlZCwgY2FuJ3QgcmVhbGx5IGRvIG11Y2ggd2l0aG91dCBhbHNvIGNoYW5naW5nIHRoZSBwYXJlbnQgcGF0aCwgd2hpY2ggaXMgdW5zYWZlLCBob3BpbmcgZm9yIHRoZSBiZXN0IGhlcmVcbiAgICAgICAgY29uc3QgdHJ1bmNhdGlvbkxlbmd0aCA9IGJhc2VuYW1lLmxlbmd0aCAtIGNvbnN0c18xLkxJTUlUX0JBU0VOQU1FX0xFTkdUSDtcbiAgICAgICAgcmV0dXJuIGAke2ZpbGVQYXRoLnNsaWNlKDAsIC1iYXNlbmFtZS5sZW5ndGgpfSR7dHJ1bmNhYmxlWzFdfSR7dHJ1bmNhYmxlWzJdLnNsaWNlKDAsIC10cnVuY2F0aW9uTGVuZ3RoKX0ke3RydW5jYWJsZVszXX1gOyAvL0ZJWE1FOiBUaGUgdHJ1bmNhYmxlIHBhcnQgbWlnaHQgYmUgc2hvcnRlciB0aGFuIG5lZWRlZCBoZXJlXG4gICAgfVxufTtcbi8qIElOSVQgKi9cbnByb2Nlc3Mub24oJ2V4aXQnLCBUZW1wLnB1cmdlU3luY0FsbCk7IC8vIEVuc3VyaW5nIHB1cmdlYWJsZSB0ZW1wIGZpbGVzIGFyZSBwdXJnZWQgb24gZXhpdFxuLyogRVhQT1JUICovXG5leHBvcnRzLmRlZmF1bHQgPSBUZW1wO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBJTVBPUlQgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMud3JpdGVGaWxlU3luYyA9IGV4cG9ydHMud3JpdGVGaWxlID0gZXhwb3J0cy5yZWFkRmlsZVN5bmMgPSBleHBvcnRzLnJlYWRGaWxlID0gdm9pZCAwO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgY29uc3RzXzEgPSByZXF1aXJlKFwiLi9jb25zdHNcIik7XG5jb25zdCBmc18xID0gcmVxdWlyZShcIi4vdXRpbHMvZnNcIik7XG5jb25zdCBsYW5nXzEgPSByZXF1aXJlKFwiLi91dGlscy9sYW5nXCIpO1xuY29uc3Qgc2NoZWR1bGVyXzEgPSByZXF1aXJlKFwiLi91dGlscy9zY2hlZHVsZXJcIik7XG5jb25zdCB0ZW1wXzEgPSByZXF1aXJlKFwiLi91dGlscy90ZW1wXCIpO1xuZnVuY3Rpb24gcmVhZEZpbGUoZmlsZVBhdGgsIG9wdGlvbnMgPSBjb25zdHNfMS5ERUZBVUxUX1JFQURfT1BUSU9OUykge1xuICAgIHZhciBfYTtcbiAgICBpZiAobGFuZ18xLmRlZmF1bHQuaXNTdHJpbmcob3B0aW9ucykpXG4gICAgICAgIHJldHVybiByZWFkRmlsZShmaWxlUGF0aCwgeyBlbmNvZGluZzogb3B0aW9ucyB9KTtcbiAgICBjb25zdCB0aW1lb3V0ID0gRGF0ZS5ub3coKSArICgoX2EgPSBvcHRpb25zLnRpbWVvdXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbnN0c18xLkRFRkFVTFRfVElNRU9VVF9BU1lOQyk7XG4gICAgcmV0dXJuIGZzXzEuZGVmYXVsdC5yZWFkRmlsZVJldHJ5KHRpbWVvdXQpKGZpbGVQYXRoLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMucmVhZEZpbGUgPSByZWFkRmlsZTtcbjtcbmZ1bmN0aW9uIHJlYWRGaWxlU3luYyhmaWxlUGF0aCwgb3B0aW9ucyA9IGNvbnN0c18xLkRFRkFVTFRfUkVBRF9PUFRJT05TKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChsYW5nXzEuZGVmYXVsdC5pc1N0cmluZyhvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIHJlYWRGaWxlU3luYyhmaWxlUGF0aCwgeyBlbmNvZGluZzogb3B0aW9ucyB9KTtcbiAgICBjb25zdCB0aW1lb3V0ID0gRGF0ZS5ub3coKSArICgoX2EgPSBvcHRpb25zLnRpbWVvdXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbnN0c18xLkRFRkFVTFRfVElNRU9VVF9TWU5DKTtcbiAgICByZXR1cm4gZnNfMS5kZWZhdWx0LnJlYWRGaWxlU3luY1JldHJ5KHRpbWVvdXQpKGZpbGVQYXRoLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMucmVhZEZpbGVTeW5jID0gcmVhZEZpbGVTeW5jO1xuO1xuY29uc3Qgd3JpdGVGaWxlID0gKGZpbGVQYXRoLCBkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICAgIGlmIChsYW5nXzEuZGVmYXVsdC5pc0Z1bmN0aW9uKG9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gd3JpdGVGaWxlKGZpbGVQYXRoLCBkYXRhLCBjb25zdHNfMS5ERUZBVUxUX1dSSVRFX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHByb21pc2UgPSB3cml0ZUZpbGVBc3luYyhmaWxlUGF0aCwgZGF0YSwgb3B0aW9ucyk7XG4gICAgaWYgKGNhbGxiYWNrKVxuICAgICAgICBwcm9taXNlLnRoZW4oY2FsbGJhY2ssIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn07XG5leHBvcnRzLndyaXRlRmlsZSA9IHdyaXRlRmlsZTtcbmNvbnN0IHdyaXRlRmlsZUFzeW5jID0gYXN5bmMgKGZpbGVQYXRoLCBkYXRhLCBvcHRpb25zID0gY29uc3RzXzEuREVGQVVMVF9XUklURV9PUFRJT05TKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChsYW5nXzEuZGVmYXVsdC5pc1N0cmluZyhvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIHdyaXRlRmlsZUFzeW5jKGZpbGVQYXRoLCBkYXRhLCB7IGVuY29kaW5nOiBvcHRpb25zIH0pO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBEYXRlLm5vdygpICsgKChfYSA9IG9wdGlvbnMudGltZW91dCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29uc3RzXzEuREVGQVVMVF9USU1FT1VUX0FTWU5DKTtcbiAgICBsZXQgc2NoZWR1bGVyQ3VzdG9tRGlzcG9zZXIgPSBudWxsLCBzY2hlZHVsZXJEaXNwb3NlciA9IG51bGwsIHRlbXBEaXNwb3NlciA9IG51bGwsIHRlbXBQYXRoID0gbnVsbCwgZmQgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChvcHRpb25zLnNjaGVkdWxlKVxuICAgICAgICAgICAgc2NoZWR1bGVyQ3VzdG9tRGlzcG9zZXIgPSBhd2FpdCBvcHRpb25zLnNjaGVkdWxlKGZpbGVQYXRoKTtcbiAgICAgICAgc2NoZWR1bGVyRGlzcG9zZXIgPSBhd2FpdCBzY2hlZHVsZXJfMS5kZWZhdWx0LnNjaGVkdWxlKGZpbGVQYXRoKTtcbiAgICAgICAgZmlsZVBhdGggPSBhd2FpdCBmc18xLmRlZmF1bHQucmVhbHBhdGhBdHRlbXB0KGZpbGVQYXRoKSB8fCBmaWxlUGF0aDtcbiAgICAgICAgW3RlbXBQYXRoLCB0ZW1wRGlzcG9zZXJdID0gdGVtcF8xLmRlZmF1bHQuZ2V0KGZpbGVQYXRoLCBvcHRpb25zLnRtcENyZWF0ZSB8fCB0ZW1wXzEuZGVmYXVsdC5jcmVhdGUsICEob3B0aW9ucy50bXBQdXJnZSA9PT0gZmFsc2UpKTtcbiAgICAgICAgY29uc3QgdXNlU3RhdENob3duID0gY29uc3RzXzEuSVNfUE9TSVggJiYgbGFuZ18xLmRlZmF1bHQuaXNVbmRlZmluZWQob3B0aW9ucy5jaG93biksIHVzZVN0YXRNb2RlID0gbGFuZ18xLmRlZmF1bHQuaXNVbmRlZmluZWQob3B0aW9ucy5tb2RlKTtcbiAgICAgICAgaWYgKHVzZVN0YXRDaG93biB8fCB1c2VTdGF0TW9kZSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdCA9IGF3YWl0IGZzXzEuZGVmYXVsdC5zdGF0QXR0ZW1wdChmaWxlUGF0aCk7XG4gICAgICAgICAgICBpZiAoc3RhdCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgICAgICBpZiAodXNlU3RhdENob3duKVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNob3duID0geyB1aWQ6IHN0YXQudWlkLCBnaWQ6IHN0YXQuZ2lkIH07XG4gICAgICAgICAgICAgICAgaWYgKHVzZVN0YXRNb2RlKVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm1vZGUgPSBzdGF0Lm1vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IHBhdGguZGlybmFtZShmaWxlUGF0aCk7XG4gICAgICAgIGF3YWl0IGZzXzEuZGVmYXVsdC5ta2RpckF0dGVtcHQocGFyZW50UGF0aCwge1xuICAgICAgICAgICAgbW9kZTogY29uc3RzXzEuREVGQVVMVF9GT0xERVJfTU9ERSxcbiAgICAgICAgICAgIHJlY3Vyc2l2ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgZmQgPSBhd2FpdCBmc18xLmRlZmF1bHQub3BlblJldHJ5KHRpbWVvdXQpKHRlbXBQYXRoLCAndycsIG9wdGlvbnMubW9kZSB8fCBjb25zdHNfMS5ERUZBVUxUX0ZJTEVfTU9ERSk7XG4gICAgICAgIGlmIChvcHRpb25zLnRtcENyZWF0ZWQpXG4gICAgICAgICAgICBvcHRpb25zLnRtcENyZWF0ZWQodGVtcFBhdGgpO1xuICAgICAgICBpZiAobGFuZ18xLmRlZmF1bHQuaXNTdHJpbmcoZGF0YSkpIHtcbiAgICAgICAgICAgIGF3YWl0IGZzXzEuZGVmYXVsdC53cml0ZVJldHJ5KHRpbWVvdXQpKGZkLCBkYXRhLCAwLCBvcHRpb25zLmVuY29kaW5nIHx8IGNvbnN0c18xLkRFRkFVTFRfRU5DT0RJTkcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFsYW5nXzEuZGVmYXVsdC5pc1VuZGVmaW5lZChkYXRhKSkge1xuICAgICAgICAgICAgYXdhaXQgZnNfMS5kZWZhdWx0LndyaXRlUmV0cnkodGltZW91dCkoZmQsIGRhdGEsIDAsIGRhdGEubGVuZ3RoLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5mc3luYyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZzeW5jV2FpdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBmc18xLmRlZmF1bHQuZnN5bmNSZXRyeSh0aW1lb3V0KShmZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmc18xLmRlZmF1bHQuZnN5bmNBdHRlbXB0KGZkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBmc18xLmRlZmF1bHQuY2xvc2VSZXRyeSh0aW1lb3V0KShmZCk7XG4gICAgICAgIGZkID0gbnVsbDtcbiAgICAgICAgaWYgKG9wdGlvbnMuY2hvd24pXG4gICAgICAgICAgICBhd2FpdCBmc18xLmRlZmF1bHQuY2hvd25BdHRlbXB0KHRlbXBQYXRoLCBvcHRpb25zLmNob3duLnVpZCwgb3B0aW9ucy5jaG93bi5naWQpO1xuICAgICAgICBpZiAob3B0aW9ucy5tb2RlKVxuICAgICAgICAgICAgYXdhaXQgZnNfMS5kZWZhdWx0LmNobW9kQXR0ZW1wdCh0ZW1wUGF0aCwgb3B0aW9ucy5tb2RlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGZzXzEuZGVmYXVsdC5yZW5hbWVSZXRyeSh0aW1lb3V0KSh0ZW1wUGF0aCwgZmlsZVBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgIT09ICdFTkFNRVRPT0xPTkcnKVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgYXdhaXQgZnNfMS5kZWZhdWx0LnJlbmFtZVJldHJ5KHRpbWVvdXQpKHRlbXBQYXRoLCB0ZW1wXzEuZGVmYXVsdC50cnVuY2F0ZShmaWxlUGF0aCkpO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBEaXNwb3NlcigpO1xuICAgICAgICB0ZW1wUGF0aCA9IG51bGw7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBpZiAoZmQpXG4gICAgICAgICAgICBhd2FpdCBmc18xLmRlZmF1bHQuY2xvc2VBdHRlbXB0KGZkKTtcbiAgICAgICAgaWYgKHRlbXBQYXRoKVxuICAgICAgICAgICAgdGVtcF8xLmRlZmF1bHQucHVyZ2UodGVtcFBhdGgpO1xuICAgICAgICBpZiAoc2NoZWR1bGVyQ3VzdG9tRGlzcG9zZXIpXG4gICAgICAgICAgICBzY2hlZHVsZXJDdXN0b21EaXNwb3NlcigpO1xuICAgICAgICBpZiAoc2NoZWR1bGVyRGlzcG9zZXIpXG4gICAgICAgICAgICBzY2hlZHVsZXJEaXNwb3NlcigpO1xuICAgIH1cbn07XG5jb25zdCB3cml0ZUZpbGVTeW5jID0gKGZpbGVQYXRoLCBkYXRhLCBvcHRpb25zID0gY29uc3RzXzEuREVGQVVMVF9XUklURV9PUFRJT05TKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChsYW5nXzEuZGVmYXVsdC5pc1N0cmluZyhvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIHdyaXRlRmlsZVN5bmMoZmlsZVBhdGgsIGRhdGEsIHsgZW5jb2Rpbmc6IG9wdGlvbnMgfSk7XG4gICAgY29uc3QgdGltZW91dCA9IERhdGUubm93KCkgKyAoKF9hID0gb3B0aW9ucy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb25zdHNfMS5ERUZBVUxUX1RJTUVPVVRfU1lOQyk7XG4gICAgbGV0IHRlbXBEaXNwb3NlciA9IG51bGwsIHRlbXBQYXRoID0gbnVsbCwgZmQgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICAgIGZpbGVQYXRoID0gZnNfMS5kZWZhdWx0LnJlYWxwYXRoU3luY0F0dGVtcHQoZmlsZVBhdGgpIHx8IGZpbGVQYXRoO1xuICAgICAgICBbdGVtcFBhdGgsIHRlbXBEaXNwb3Nlcl0gPSB0ZW1wXzEuZGVmYXVsdC5nZXQoZmlsZVBhdGgsIG9wdGlvbnMudG1wQ3JlYXRlIHx8IHRlbXBfMS5kZWZhdWx0LmNyZWF0ZSwgIShvcHRpb25zLnRtcFB1cmdlID09PSBmYWxzZSkpO1xuICAgICAgICBjb25zdCB1c2VTdGF0Q2hvd24gPSBjb25zdHNfMS5JU19QT1NJWCAmJiBsYW5nXzEuZGVmYXVsdC5pc1VuZGVmaW5lZChvcHRpb25zLmNob3duKSwgdXNlU3RhdE1vZGUgPSBsYW5nXzEuZGVmYXVsdC5pc1VuZGVmaW5lZChvcHRpb25zLm1vZGUpO1xuICAgICAgICBpZiAodXNlU3RhdENob3duIHx8IHVzZVN0YXRNb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ID0gZnNfMS5kZWZhdWx0LnN0YXRTeW5jQXR0ZW1wdChmaWxlUGF0aCk7XG4gICAgICAgICAgICBpZiAoc3RhdCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgICAgICBpZiAodXNlU3RhdENob3duKVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNob3duID0geyB1aWQ6IHN0YXQudWlkLCBnaWQ6IHN0YXQuZ2lkIH07XG4gICAgICAgICAgICAgICAgaWYgKHVzZVN0YXRNb2RlKVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm1vZGUgPSBzdGF0Lm1vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IHBhdGguZGlybmFtZShmaWxlUGF0aCk7XG4gICAgICAgIGZzXzEuZGVmYXVsdC5ta2RpclN5bmNBdHRlbXB0KHBhcmVudFBhdGgsIHtcbiAgICAgICAgICAgIG1vZGU6IGNvbnN0c18xLkRFRkFVTFRfRk9MREVSX01PREUsXG4gICAgICAgICAgICByZWN1cnNpdmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGZkID0gZnNfMS5kZWZhdWx0Lm9wZW5TeW5jUmV0cnkodGltZW91dCkodGVtcFBhdGgsICd3Jywgb3B0aW9ucy5tb2RlIHx8IGNvbnN0c18xLkRFRkFVTFRfRklMRV9NT0RFKTtcbiAgICAgICAgaWYgKG9wdGlvbnMudG1wQ3JlYXRlZClcbiAgICAgICAgICAgIG9wdGlvbnMudG1wQ3JlYXRlZCh0ZW1wUGF0aCk7XG4gICAgICAgIGlmIChsYW5nXzEuZGVmYXVsdC5pc1N0cmluZyhkYXRhKSkge1xuICAgICAgICAgICAgZnNfMS5kZWZhdWx0LndyaXRlU3luY1JldHJ5KHRpbWVvdXQpKGZkLCBkYXRhLCAwLCBvcHRpb25zLmVuY29kaW5nIHx8IGNvbnN0c18xLkRFRkFVTFRfRU5DT0RJTkcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFsYW5nXzEuZGVmYXVsdC5pc1VuZGVmaW5lZChkYXRhKSkge1xuICAgICAgICAgICAgZnNfMS5kZWZhdWx0LndyaXRlU3luY1JldHJ5KHRpbWVvdXQpKGZkLCBkYXRhLCAwLCBkYXRhLmxlbmd0aCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZnN5bmMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5mc3luY1dhaXQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZnNfMS5kZWZhdWx0LmZzeW5jU3luY1JldHJ5KHRpbWVvdXQpKGZkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZzXzEuZGVmYXVsdC5mc3luY0F0dGVtcHQoZmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZzXzEuZGVmYXVsdC5jbG9zZVN5bmNSZXRyeSh0aW1lb3V0KShmZCk7XG4gICAgICAgIGZkID0gbnVsbDtcbiAgICAgICAgaWYgKG9wdGlvbnMuY2hvd24pXG4gICAgICAgICAgICBmc18xLmRlZmF1bHQuY2hvd25TeW5jQXR0ZW1wdCh0ZW1wUGF0aCwgb3B0aW9ucy5jaG93bi51aWQsIG9wdGlvbnMuY2hvd24uZ2lkKTtcbiAgICAgICAgaWYgKG9wdGlvbnMubW9kZSlcbiAgICAgICAgICAgIGZzXzEuZGVmYXVsdC5jaG1vZFN5bmNBdHRlbXB0KHRlbXBQYXRoLCBvcHRpb25zLm1vZGUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZnNfMS5kZWZhdWx0LnJlbmFtZVN5bmNSZXRyeSh0aW1lb3V0KSh0ZW1wUGF0aCwgZmlsZVBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgIT09ICdFTkFNRVRPT0xPTkcnKVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgZnNfMS5kZWZhdWx0LnJlbmFtZVN5bmNSZXRyeSh0aW1lb3V0KSh0ZW1wUGF0aCwgdGVtcF8xLmRlZmF1bHQudHJ1bmNhdGUoZmlsZVBhdGgpKTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wRGlzcG9zZXIoKTtcbiAgICAgICAgdGVtcFBhdGggPSBudWxsO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGZkKVxuICAgICAgICAgICAgZnNfMS5kZWZhdWx0LmNsb3NlU3luY0F0dGVtcHQoZmQpO1xuICAgICAgICBpZiAodGVtcFBhdGgpXG4gICAgICAgICAgICB0ZW1wXzEuZGVmYXVsdC5wdXJnZSh0ZW1wUGF0aCk7XG4gICAgfVxufTtcbmV4cG9ydHMud3JpdGVGaWxlU3luYyA9IHdyaXRlRmlsZVN5bmM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVnZXhwQ29kZSA9IGV4cG9ydHMuZ2V0UHJvcGVydHkgPSBleHBvcnRzLnNhZmVTdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyQ29uY2F0ID0gZXhwb3J0cy5hZGRDb2RlQXJnID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLl8gPSBleHBvcnRzLm5pbCA9IGV4cG9ydHMuX0NvZGUgPSBleHBvcnRzLk5hbWUgPSBleHBvcnRzLklERU5USUZJRVIgPSBleHBvcnRzLl9Db2RlT3JOYW1lID0gdm9pZCAwO1xuY2xhc3MgX0NvZGVPck5hbWUge1xufVxuZXhwb3J0cy5fQ29kZU9yTmFtZSA9IF9Db2RlT3JOYW1lO1xuZXhwb3J0cy5JREVOVElGSUVSID0gL15bYS16JF9dW2EteiRfMC05XSokL2k7XG5jbGFzcyBOYW1lIGV4dGVuZHMgX0NvZGVPck5hbWUge1xuICAgIGNvbnN0cnVjdG9yKHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKCFleHBvcnRzLklERU5USUZJRVIudGVzdChzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvZGVHZW46IG5hbWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcIik7XG4gICAgICAgIHRoaXMuc3RyID0gcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cjtcbiAgICB9XG4gICAgZW1wdHlTdHIoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4geyBbdGhpcy5zdHJdOiAxIH07XG4gICAgfVxufVxuZXhwb3J0cy5OYW1lID0gTmFtZTtcbmNsYXNzIF9Db2RlIGV4dGVuZHMgX0NvZGVPck5hbWUge1xuICAgIGNvbnN0cnVjdG9yKGNvZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5faXRlbXMgPSB0eXBlb2YgY29kZSA9PT0gXCJzdHJpbmdcIiA/IFtjb2RlXSA6IGNvZGU7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHI7XG4gICAgfVxuICAgIGVtcHR5U3RyKCkge1xuICAgICAgICBpZiAodGhpcy5faXRlbXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW1zWzBdO1xuICAgICAgICByZXR1cm4gaXRlbSA9PT0gXCJcIiB8fCBpdGVtID09PSAnXCJcIic7XG4gICAgfVxuICAgIGdldCBzdHIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLl9zdHIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICh0aGlzLl9zdHIgPSB0aGlzLl9pdGVtcy5yZWR1Y2UoKHMsIGMpID0+IGAke3N9JHtjfWAsIFwiXCIpKSk7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuX25hbWVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAodGhpcy5fbmFtZXMgPSB0aGlzLl9pdGVtcy5yZWR1Y2UoKG5hbWVzLCBjKSA9PiB7XG4gICAgICAgICAgICBpZiAoYyBpbnN0YW5jZW9mIE5hbWUpXG4gICAgICAgICAgICAgICAgbmFtZXNbYy5zdHJdID0gKG5hbWVzW2Muc3RyXSB8fCAwKSArIDE7XG4gICAgICAgICAgICByZXR1cm4gbmFtZXM7XG4gICAgICAgIH0sIHt9KSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuX0NvZGUgPSBfQ29kZTtcbmV4cG9ydHMubmlsID0gbmV3IF9Db2RlKFwiXCIpO1xuZnVuY3Rpb24gXyhzdHJzLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgY29kZSA9IFtzdHJzWzBdXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgICBhZGRDb2RlQXJnKGNvZGUsIGFyZ3NbaV0pO1xuICAgICAgICBjb2RlLnB1c2goc3Ryc1srK2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfQ29kZShjb2RlKTtcbn1cbmV4cG9ydHMuXyA9IF87XG5jb25zdCBwbHVzID0gbmV3IF9Db2RlKFwiK1wiKTtcbmZ1bmN0aW9uIHN0cihzdHJzLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgZXhwciA9IFtzYWZlU3RyaW5naWZ5KHN0cnNbMF0pXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgICBleHByLnB1c2gocGx1cyk7XG4gICAgICAgIGFkZENvZGVBcmcoZXhwciwgYXJnc1tpXSk7XG4gICAgICAgIGV4cHIucHVzaChwbHVzLCBzYWZlU3RyaW5naWZ5KHN0cnNbKytpXSkpO1xuICAgIH1cbiAgICBvcHRpbWl6ZShleHByKTtcbiAgICByZXR1cm4gbmV3IF9Db2RlKGV4cHIpO1xufVxuZXhwb3J0cy5zdHIgPSBzdHI7XG5mdW5jdGlvbiBhZGRDb2RlQXJnKGNvZGUsIGFyZykge1xuICAgIGlmIChhcmcgaW5zdGFuY2VvZiBfQ29kZSlcbiAgICAgICAgY29kZS5wdXNoKC4uLmFyZy5faXRlbXMpO1xuICAgIGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIE5hbWUpXG4gICAgICAgIGNvZGUucHVzaChhcmcpO1xuICAgIGVsc2VcbiAgICAgICAgY29kZS5wdXNoKGludGVycG9sYXRlKGFyZykpO1xufVxuZXhwb3J0cy5hZGRDb2RlQXJnID0gYWRkQ29kZUFyZztcbmZ1bmN0aW9uIG9wdGltaXplKGV4cHIpIHtcbiAgICBsZXQgaSA9IDE7XG4gICAgd2hpbGUgKGkgPCBleHByLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgaWYgKGV4cHJbaV0gPT09IHBsdXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG1lcmdlRXhwckl0ZW1zKGV4cHJbaSAtIDFdLCBleHByW2kgKyAxXSk7XG4gICAgICAgICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBleHByLnNwbGljZShpIC0gMSwgMywgcmVzKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cHJbaSsrXSA9IFwiK1wiO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG59XG5mdW5jdGlvbiBtZXJnZUV4cHJJdGVtcyhhLCBiKSB7XG4gICAgaWYgKGIgPT09ICdcIlwiJylcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgaWYgKGEgPT09ICdcIlwiJylcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBOYW1lIHx8IGFbYS5sZW5ndGggLSAxXSAhPT0gJ1wiJylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByZXR1cm4gYCR7YS5zbGljZSgwLCAtMSl9JHtifVwiYDtcbiAgICAgICAgaWYgKGJbMF0gPT09ICdcIicpXG4gICAgICAgICAgICByZXR1cm4gYS5zbGljZSgwLCAtMSkgKyBiLnNsaWNlKDEpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYiA9PSBcInN0cmluZ1wiICYmIGJbMF0gPT09ICdcIicgJiYgIShhIGluc3RhbmNlb2YgTmFtZSkpXG4gICAgICAgIHJldHVybiBgXCIke2F9JHtiLnNsaWNlKDEpfWA7XG4gICAgcmV0dXJuO1xufVxuZnVuY3Rpb24gc3RyQ29uY2F0KGMxLCBjMikge1xuICAgIHJldHVybiBjMi5lbXB0eVN0cigpID8gYzEgOiBjMS5lbXB0eVN0cigpID8gYzIgOiBzdHIgYCR7YzF9JHtjMn1gO1xufVxuZXhwb3J0cy5zdHJDb25jYXQgPSBzdHJDb25jYXQ7XG4vLyBUT0RPIGRvIG5vdCBhbGxvdyBhcnJheXMgaGVyZVxuZnVuY3Rpb24gaW50ZXJwb2xhdGUoeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PSBcIm51bWJlclwiIHx8IHR5cGVvZiB4ID09IFwiYm9vbGVhblwiIHx8IHggPT09IG51bGxcbiAgICAgICAgPyB4XG4gICAgICAgIDogc2FmZVN0cmluZ2lmeShBcnJheS5pc0FycmF5KHgpID8geC5qb2luKFwiLFwiKSA6IHgpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KHgpIHtcbiAgICByZXR1cm4gbmV3IF9Db2RlKHNhZmVTdHJpbmdpZnkoeCkpO1xufVxuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5mdW5jdGlvbiBzYWZlU3RyaW5naWZ5KHgpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeClcbiAgICAgICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgXCJcXFxcdTIwMjhcIilcbiAgICAgICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgXCJcXFxcdTIwMjlcIik7XG59XG5leHBvcnRzLnNhZmVTdHJpbmdpZnkgPSBzYWZlU3RyaW5naWZ5O1xuZnVuY3Rpb24gZ2V0UHJvcGVydHkoa2V5KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiAmJiBleHBvcnRzLklERU5USUZJRVIudGVzdChrZXkpID8gbmV3IF9Db2RlKGAuJHtrZXl9YCkgOiBfIGBbJHtrZXl9XWA7XG59XG5leHBvcnRzLmdldFByb3BlcnR5ID0gZ2V0UHJvcGVydHk7XG5mdW5jdGlvbiByZWdleHBDb2RlKHJ4KSB7XG4gICAgcmV0dXJuIG5ldyBfQ29kZShyeC50b1N0cmluZygpKTtcbn1cbmV4cG9ydHMucmVnZXhwQ29kZSA9IHJlZ2V4cENvZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WYWx1ZVNjb3BlID0gZXhwb3J0cy5WYWx1ZVNjb3BlTmFtZSA9IGV4cG9ydHMuU2NvcGUgPSBleHBvcnRzLnZhcktpbmRzID0gZXhwb3J0cy5Vc2VkVmFsdWVTdGF0ZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuL2NvZGVcIik7XG5jbGFzcyBWYWx1ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgc3VwZXIoYENvZGVHZW46IFwiY29kZVwiIGZvciAke25hbWV9IG5vdCBkZWZpbmVkYCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBuYW1lLnZhbHVlO1xuICAgIH1cbn1cbnZhciBVc2VkVmFsdWVTdGF0ZTtcbihmdW5jdGlvbiAoVXNlZFZhbHVlU3RhdGUpIHtcbiAgICBVc2VkVmFsdWVTdGF0ZVtVc2VkVmFsdWVTdGF0ZVtcIlN0YXJ0ZWRcIl0gPSAwXSA9IFwiU3RhcnRlZFwiO1xuICAgIFVzZWRWYWx1ZVN0YXRlW1VzZWRWYWx1ZVN0YXRlW1wiQ29tcGxldGVkXCJdID0gMV0gPSBcIkNvbXBsZXRlZFwiO1xufSkoVXNlZFZhbHVlU3RhdGUgPSBleHBvcnRzLlVzZWRWYWx1ZVN0YXRlIHx8IChleHBvcnRzLlVzZWRWYWx1ZVN0YXRlID0ge30pKTtcbmV4cG9ydHMudmFyS2luZHMgPSB7XG4gICAgY29uc3Q6IG5ldyBjb2RlXzEuTmFtZShcImNvbnN0XCIpLFxuICAgIGxldDogbmV3IGNvZGVfMS5OYW1lKFwibGV0XCIpLFxuICAgIHZhcjogbmV3IGNvZGVfMS5OYW1lKFwidmFyXCIpLFxufTtcbmNsYXNzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHByZWZpeGVzLCBwYXJlbnQgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMuX25hbWVzID0ge307XG4gICAgICAgIHRoaXMuX3ByZWZpeGVzID0gcHJlZml4ZXM7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgdG9OYW1lKG5hbWVPclByZWZpeCkge1xuICAgICAgICByZXR1cm4gbmFtZU9yUHJlZml4IGluc3RhbmNlb2YgY29kZV8xLk5hbWUgPyBuYW1lT3JQcmVmaXggOiB0aGlzLm5hbWUobmFtZU9yUHJlZml4KTtcbiAgICB9XG4gICAgbmFtZShwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjb2RlXzEuTmFtZSh0aGlzLl9uZXdOYW1lKHByZWZpeCkpO1xuICAgIH1cbiAgICBfbmV3TmFtZShwcmVmaXgpIHtcbiAgICAgICAgY29uc3QgbmcgPSB0aGlzLl9uYW1lc1twcmVmaXhdIHx8IHRoaXMuX25hbWVHcm91cChwcmVmaXgpO1xuICAgICAgICByZXR1cm4gYCR7cHJlZml4fSR7bmcuaW5kZXgrK31gO1xuICAgIH1cbiAgICBfbmFtZUdyb3VwKHByZWZpeCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoKChfYiA9IChfYSA9IHRoaXMuX3BhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9wcmVmaXhlcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhhcyhwcmVmaXgpKSB8fCAodGhpcy5fcHJlZml4ZXMgJiYgIXRoaXMuX3ByZWZpeGVzLmhhcyhwcmVmaXgpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBwcmVmaXggXCIke3ByZWZpeH1cIiBpcyBub3QgYWxsb3dlZCBpbiB0aGlzIHNjb3BlYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLl9uYW1lc1twcmVmaXhdID0geyBwcmVmaXgsIGluZGV4OiAwIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuU2NvcGUgPSBTY29wZTtcbmNsYXNzIFZhbHVlU2NvcGVOYW1lIGV4dGVuZHMgY29kZV8xLk5hbWUge1xuICAgIGNvbnN0cnVjdG9yKHByZWZpeCwgbmFtZVN0cikge1xuICAgICAgICBzdXBlcihuYW1lU3RyKTtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgfVxuICAgIHNldFZhbHVlKHZhbHVlLCB7IHByb3BlcnR5LCBpdGVtSW5kZXggfSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc2NvcGVQYXRoID0gY29kZV8xLl8gYC4ke25ldyBjb2RlXzEuTmFtZShwcm9wZXJ0eSl9WyR7aXRlbUluZGV4fV1gO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFsdWVTY29wZU5hbWUgPSBWYWx1ZVNjb3BlTmFtZTtcbmNvbnN0IGxpbmUgPSBjb2RlXzEuXyBgXFxuYDtcbmNsYXNzIFZhbHVlU2NvcGUgZXh0ZW5kcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0ge307XG4gICAgICAgIHRoaXMuX3Njb3BlID0gb3B0cy5zY29wZTtcbiAgICAgICAgdGhpcy5vcHRzID0geyAuLi5vcHRzLCBfbjogb3B0cy5saW5lcyA/IGxpbmUgOiBjb2RlXzEubmlsIH07XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njb3BlO1xuICAgIH1cbiAgICBuYW1lKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlU2NvcGVOYW1lKHByZWZpeCwgdGhpcy5fbmV3TmFtZShwcmVmaXgpKTtcbiAgICB9XG4gICAgdmFsdWUobmFtZU9yUHJlZml4LCB2YWx1ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh2YWx1ZS5yZWYgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvZGVHZW46IHJlZiBtdXN0IGJlIHBhc3NlZCBpbiB2YWx1ZVwiKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4IH0gPSBuYW1lO1xuICAgICAgICBjb25zdCB2YWx1ZUtleSA9IChfYSA9IHZhbHVlLmtleSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFsdWUucmVmO1xuICAgICAgICBsZXQgdnMgPSB0aGlzLl92YWx1ZXNbcHJlZml4XTtcbiAgICAgICAgaWYgKHZzKSB7XG4gICAgICAgICAgICBjb25zdCBfbmFtZSA9IHZzLmdldCh2YWx1ZUtleSk7XG4gICAgICAgICAgICBpZiAoX25hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdnMgPSB0aGlzLl92YWx1ZXNbcHJlZml4XSA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICB2cy5zZXQodmFsdWVLZXksIG5hbWUpO1xuICAgICAgICBjb25zdCBzID0gdGhpcy5fc2NvcGVbcHJlZml4XSB8fCAodGhpcy5fc2NvcGVbcHJlZml4XSA9IFtdKTtcbiAgICAgICAgY29uc3QgaXRlbUluZGV4ID0gcy5sZW5ndGg7XG4gICAgICAgIHNbaXRlbUluZGV4XSA9IHZhbHVlLnJlZjtcbiAgICAgICAgbmFtZS5zZXRWYWx1ZSh2YWx1ZSwgeyBwcm9wZXJ0eTogcHJlZml4LCBpdGVtSW5kZXggfSk7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICBnZXRWYWx1ZShwcmVmaXgsIGtleU9yUmVmKSB7XG4gICAgICAgIGNvbnN0IHZzID0gdGhpcy5fdmFsdWVzW3ByZWZpeF07XG4gICAgICAgIGlmICghdnMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiB2cy5nZXQoa2V5T3JSZWYpO1xuICAgIH1cbiAgICBzY29wZVJlZnMoc2NvcGVOYW1lLCB2YWx1ZXMgPSB0aGlzLl92YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZHVjZVZhbHVlcyh2YWx1ZXMsIChuYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAobmFtZS5zY29wZVBhdGggPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IG5hbWUgXCIke25hbWV9XCIgaGFzIG5vIHZhbHVlYCk7XG4gICAgICAgICAgICByZXR1cm4gY29kZV8xLl8gYCR7c2NvcGVOYW1lfSR7bmFtZS5zY29wZVBhdGh9YDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNjb3BlQ29kZSh2YWx1ZXMgPSB0aGlzLl92YWx1ZXMsIHVzZWRWYWx1ZXMsIGdldENvZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZHVjZVZhbHVlcyh2YWx1ZXMsIChuYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAobmFtZS52YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogbmFtZSBcIiR7bmFtZX1cIiBoYXMgbm8gdmFsdWVgKTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lLnZhbHVlLmNvZGU7XG4gICAgICAgIH0sIHVzZWRWYWx1ZXMsIGdldENvZGUpO1xuICAgIH1cbiAgICBfcmVkdWNlVmFsdWVzKHZhbHVlcywgdmFsdWVDb2RlLCB1c2VkVmFsdWVzID0ge30sIGdldENvZGUpIHtcbiAgICAgICAgbGV0IGNvZGUgPSBjb2RlXzEubmlsO1xuICAgICAgICBmb3IgKGNvbnN0IHByZWZpeCBpbiB2YWx1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZzID0gdmFsdWVzW3ByZWZpeF07XG4gICAgICAgICAgICBpZiAoIXZzKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgbmFtZVNldCA9ICh1c2VkVmFsdWVzW3ByZWZpeF0gPSB1c2VkVmFsdWVzW3ByZWZpeF0gfHwgbmV3IE1hcCgpKTtcbiAgICAgICAgICAgIHZzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZVNldC5oYXMobmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBuYW1lU2V0LnNldChuYW1lLCBVc2VkVmFsdWVTdGF0ZS5TdGFydGVkKTtcbiAgICAgICAgICAgICAgICBsZXQgYyA9IHZhbHVlQ29kZShuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWYgPSB0aGlzLm9wdHMuZXM1ID8gZXhwb3J0cy52YXJLaW5kcy52YXIgOiBleHBvcnRzLnZhcktpbmRzLmNvbnN0O1xuICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29kZV8xLl8gYCR7Y29kZX0ke2RlZn0gJHtuYW1lfSA9ICR7Y307JHt0aGlzLm9wdHMuX259YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKGMgPSBnZXRDb2RlID09PSBudWxsIHx8IGdldENvZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdldENvZGUobmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlXzEuXyBgJHtjb2RlfSR7Y30ke3RoaXMub3B0cy5fbn1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5hbWVTZXQuc2V0KG5hbWUsIFVzZWRWYWx1ZVN0YXRlLkNvbXBsZXRlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG59XG5leHBvcnRzLlZhbHVlU2NvcGUgPSBWYWx1ZVNjb3BlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NvcGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm9yID0gZXhwb3J0cy5hbmQgPSBleHBvcnRzLm5vdCA9IGV4cG9ydHMuQ29kZUdlbiA9IGV4cG9ydHMub3BlcmF0b3JzID0gZXhwb3J0cy52YXJLaW5kcyA9IGV4cG9ydHMuVmFsdWVTY29wZU5hbWUgPSBleHBvcnRzLlZhbHVlU2NvcGUgPSBleHBvcnRzLlNjb3BlID0gZXhwb3J0cy5OYW1lID0gZXhwb3J0cy5yZWdleHBDb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLmdldFByb3BlcnR5ID0gZXhwb3J0cy5uaWwgPSBleHBvcnRzLnN0ckNvbmNhdCA9IGV4cG9ydHMuc3RyID0gZXhwb3J0cy5fID0gdm9pZCAwO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4vY29kZVwiKTtcbmNvbnN0IHNjb3BlXzEgPSByZXF1aXJlKFwiLi9zY29wZVwiKTtcbnZhciBjb2RlXzIgPSByZXF1aXJlKFwiLi9jb2RlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLl87IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5zdHI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJDb25jYXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5zdHJDb25jYXQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuaWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5uaWw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRQcm9wZXJ0eVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLmdldFByb3BlcnR5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5naWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuc3RyaW5naWZ5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVnZXhwQ29kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLnJlZ2V4cENvZGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOYW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuTmFtZTsgfSB9KTtcbnZhciBzY29wZV8yID0gcmVxdWlyZShcIi4vc2NvcGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTY29wZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NvcGVfMi5TY29wZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZhbHVlU2NvcGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjb3BlXzIuVmFsdWVTY29wZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZhbHVlU2NvcGVOYW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY29wZV8yLlZhbHVlU2NvcGVOYW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmFyS2luZHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjb3BlXzIudmFyS2luZHM7IH0gfSk7XG5leHBvcnRzLm9wZXJhdG9ycyA9IHtcbiAgICBHVDogbmV3IGNvZGVfMS5fQ29kZShcIj5cIiksXG4gICAgR1RFOiBuZXcgY29kZV8xLl9Db2RlKFwiPj1cIiksXG4gICAgTFQ6IG5ldyBjb2RlXzEuX0NvZGUoXCI8XCIpLFxuICAgIExURTogbmV3IGNvZGVfMS5fQ29kZShcIjw9XCIpLFxuICAgIEVROiBuZXcgY29kZV8xLl9Db2RlKFwiPT09XCIpLFxuICAgIE5FUTogbmV3IGNvZGVfMS5fQ29kZShcIiE9PVwiKSxcbiAgICBOT1Q6IG5ldyBjb2RlXzEuX0NvZGUoXCIhXCIpLFxuICAgIE9SOiBuZXcgY29kZV8xLl9Db2RlKFwifHxcIiksXG4gICAgQU5EOiBuZXcgY29kZV8xLl9Db2RlKFwiJiZcIiksXG4gICAgQUREOiBuZXcgY29kZV8xLl9Db2RlKFwiK1wiKSxcbn07XG5jbGFzcyBOb2RlIHtcbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhfbmFtZXMsIF9jb25zdGFudHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuY2xhc3MgRGVmIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IodmFyS2luZCwgbmFtZSwgcmhzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudmFyS2luZCA9IHZhcktpbmQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucmhzID0gcmhzO1xuICAgIH1cbiAgICByZW5kZXIoeyBlczUsIF9uIH0pIHtcbiAgICAgICAgY29uc3QgdmFyS2luZCA9IGVzNSA/IHNjb3BlXzEudmFyS2luZHMudmFyIDogdGhpcy52YXJLaW5kO1xuICAgICAgICBjb25zdCByaHMgPSB0aGlzLnJocyA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IGAgPSAke3RoaXMucmhzfWA7XG4gICAgICAgIHJldHVybiBgJHt2YXJLaW5kfSAke3RoaXMubmFtZX0ke3Joc307YCArIF9uO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgaWYgKCFuYW1lc1t0aGlzLm5hbWUuc3RyXSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMucmhzKVxuICAgICAgICAgICAgdGhpcy5yaHMgPSBvcHRpbWl6ZUV4cHIodGhpcy5yaHMsIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yaHMgaW5zdGFuY2VvZiBjb2RlXzEuX0NvZGVPck5hbWUgPyB0aGlzLnJocy5uYW1lcyA6IHt9O1xuICAgIH1cbn1cbmNsYXNzIEFzc2lnbiBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGxocywgcmhzLCBzaWRlRWZmZWN0cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxocyA9IGxocztcbiAgICAgICAgdGhpcy5yaHMgPSByaHM7XG4gICAgICAgIHRoaXMuc2lkZUVmZmVjdHMgPSBzaWRlRWZmZWN0cztcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5saHN9ID0gJHt0aGlzLnJoc307YCArIF9uO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgaWYgKHRoaXMubGhzIGluc3RhbmNlb2YgY29kZV8xLk5hbWUgJiYgIW5hbWVzW3RoaXMubGhzLnN0cl0gJiYgIXRoaXMuc2lkZUVmZmVjdHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucmhzID0gb3B0aW1pemVFeHByKHRoaXMucmhzLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSB0aGlzLmxocyBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lID8ge30gOiB7IC4uLnRoaXMubGhzLm5hbWVzIH07XG4gICAgICAgIHJldHVybiBhZGRFeHByTmFtZXMobmFtZXMsIHRoaXMucmhzKTtcbiAgICB9XG59XG5jbGFzcyBBc3NpZ25PcCBleHRlbmRzIEFzc2lnbiB7XG4gICAgY29uc3RydWN0b3IobGhzLCBvcCwgcmhzLCBzaWRlRWZmZWN0cykge1xuICAgICAgICBzdXBlcihsaHMsIHJocywgc2lkZUVmZmVjdHMpO1xuICAgICAgICB0aGlzLm9wID0gb3A7XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubGhzfSAke3RoaXMub3B9PSAke3RoaXMucmhzfTtgICsgX247XG4gICAgfVxufVxuY2xhc3MgTGFiZWwgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihsYWJlbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIHRoaXMubmFtZXMgPSB7fTtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5sYWJlbH06YCArIF9uO1xuICAgIH1cbn1cbmNsYXNzIEJyZWFrIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IobGFiZWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgICB0aGlzLm5hbWVzID0ge307XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLmxhYmVsID8gYCAke3RoaXMubGFiZWx9YCA6IFwiXCI7XG4gICAgICAgIHJldHVybiBgYnJlYWske2xhYmVsfTtgICsgX247XG4gICAgfVxufVxuY2xhc3MgVGhyb3cgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGB0aHJvdyAke3RoaXMuZXJyb3J9O2AgKyBfbjtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvci5uYW1lcztcbiAgICB9XG59XG5jbGFzcyBBbnlDb2RlIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29kZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvZGV9O2AgKyBfbjtcbiAgICB9XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29kZX1gID8gdGhpcyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIHRoaXMuY29kZSA9IG9wdGltaXplRXhwcih0aGlzLmNvZGUsIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2RlIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlT3JOYW1lID8gdGhpcy5jb2RlLm5hbWVzIDoge307XG4gICAgfVxufVxuY2xhc3MgUGFyZW50Tm9kZSBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKG5vZGVzID0gW10pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5yZWR1Y2UoKGNvZGUsIG4pID0+IGNvZGUgKyBuLnJlbmRlcihvcHRzKSwgXCJcIik7XG4gICAgfVxuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIGNvbnN0IHsgbm9kZXMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gbm9kZXNbaV0ub3B0aW1pemVOb2RlcygpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobikpXG4gICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEsIC4uLm4pO1xuICAgICAgICAgICAgZWxzZSBpZiAobilcbiAgICAgICAgICAgICAgICBub2Rlc1tpXSA9IG47XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2Rlcy5sZW5ndGggPiAwID8gdGhpcyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGNvbnN0IHsgbm9kZXMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAvLyBpdGVyYXRpbmcgYmFja3dhcmRzIGltcHJvdmVzIDEtcGFzcyBvcHRpbWl6YXRpb25cbiAgICAgICAgICAgIGNvbnN0IG4gPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChuLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBzdWJ0cmFjdE5hbWVzKG5hbWVzLCBuLm5hbWVzKTtcbiAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXMubGVuZ3RoID4gMCA/IHRoaXMgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXMucmVkdWNlKChuYW1lcywgbikgPT4gYWRkTmFtZXMobmFtZXMsIG4ubmFtZXMpLCB7fSk7XG4gICAgfVxufVxuY2xhc3MgQmxvY2tOb2RlIGV4dGVuZHMgUGFyZW50Tm9kZSB7XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIFwie1wiICsgb3B0cy5fbiArIHN1cGVyLnJlbmRlcihvcHRzKSArIFwifVwiICsgb3B0cy5fbjtcbiAgICB9XG59XG5jbGFzcyBSb290IGV4dGVuZHMgUGFyZW50Tm9kZSB7XG59XG5jbGFzcyBFbHNlIGV4dGVuZHMgQmxvY2tOb2RlIHtcbn1cbkVsc2Uua2luZCA9IFwiZWxzZVwiO1xuY2xhc3MgSWYgZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbmRpdGlvbiwgbm9kZXMpIHtcbiAgICAgICAgc3VwZXIobm9kZXMpO1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgbGV0IGNvZGUgPSBgaWYoJHt0aGlzLmNvbmRpdGlvbn0pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICAgICAgaWYgKHRoaXMuZWxzZSlcbiAgICAgICAgICAgIGNvZGUgKz0gXCJlbHNlIFwiICsgdGhpcy5lbHNlLnJlbmRlcihvcHRzKTtcbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIHN1cGVyLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgY29uc3QgY29uZCA9IHRoaXMuY29uZGl0aW9uO1xuICAgICAgICBpZiAoY29uZCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVzOyAvLyBlbHNlIGlzIGlnbm9yZWQgaGVyZVxuICAgICAgICBsZXQgZSA9IHRoaXMuZWxzZTtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5zID0gZS5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgICAgICBlID0gdGhpcy5lbHNlID0gQXJyYXkuaXNBcnJheShucykgPyBuZXcgRWxzZShucykgOiBucztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgaWYgKGNvbmQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgSWYgPyBlIDogZS5ub2RlcztcbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBuZXcgSWYobm90KGNvbmQpLCBlIGluc3RhbmNlb2YgSWYgPyBbZV0gOiBlLm5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZCA9PT0gZmFsc2UgfHwgIXRoaXMubm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZWxzZSA9IChfYSA9IHRoaXMuZWxzZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIGlmICghKHN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykgfHwgdGhpcy5lbHNlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBvcHRpbWl6ZUV4cHIodGhpcy5jb25kaXRpb24sIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IHN1cGVyLm5hbWVzO1xuICAgICAgICBhZGRFeHByTmFtZXMobmFtZXMsIHRoaXMuY29uZGl0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMuZWxzZSlcbiAgICAgICAgICAgIGFkZE5hbWVzKG5hbWVzLCB0aGlzLmVsc2UubmFtZXMpO1xuICAgICAgICByZXR1cm4gbmFtZXM7XG4gICAgfVxufVxuSWYua2luZCA9IFwiaWZcIjtcbmNsYXNzIEZvciBleHRlbmRzIEJsb2NrTm9kZSB7XG59XG5Gb3Iua2luZCA9IFwiZm9yXCI7XG5jbGFzcyBGb3JMb29wIGV4dGVuZHMgRm9yIHtcbiAgICBjb25zdHJ1Y3RvcihpdGVyYXRpb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pdGVyYXRpb24gPSBpdGVyYXRpb247XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBgZm9yKCR7dGhpcy5pdGVyYXRpb259KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBpZiAoIXN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuaXRlcmF0aW9uID0gb3B0aW1pemVFeHByKHRoaXMuaXRlcmF0aW9uLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIGFkZE5hbWVzKHN1cGVyLm5hbWVzLCB0aGlzLml0ZXJhdGlvbi5uYW1lcyk7XG4gICAgfVxufVxuY2xhc3MgRm9yUmFuZ2UgZXh0ZW5kcyBGb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhcktpbmQsIG5hbWUsIGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudmFyS2luZCA9IHZhcktpbmQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgY29uc3QgdmFyS2luZCA9IG9wdHMuZXM1ID8gc2NvcGVfMS52YXJLaW5kcy52YXIgOiB0aGlzLnZhcktpbmQ7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgZnJvbSwgdG8gfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBgZm9yKCR7dmFyS2luZH0gJHtuYW1lfT0ke2Zyb219OyAke25hbWV9PCR7dG99OyAke25hbWV9KyspYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IGFkZEV4cHJOYW1lcyhzdXBlci5uYW1lcywgdGhpcy5mcm9tKTtcbiAgICAgICAgcmV0dXJuIGFkZEV4cHJOYW1lcyhuYW1lcywgdGhpcy50byk7XG4gICAgfVxufVxuY2xhc3MgRm9ySXRlciBleHRlbmRzIEZvciB7XG4gICAgY29uc3RydWN0b3IobG9vcCwgdmFyS2luZCwgbmFtZSwgaXRlcmFibGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sb29wID0gbG9vcDtcbiAgICAgICAgdGhpcy52YXJLaW5kID0gdmFyS2luZDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5pdGVyYWJsZSA9IGl0ZXJhYmxlO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gYGZvcigke3RoaXMudmFyS2luZH0gJHt0aGlzLm5hbWV9ICR7dGhpcy5sb29wfSAke3RoaXMuaXRlcmFibGV9KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBpZiAoIXN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuaXRlcmFibGUgPSBvcHRpbWl6ZUV4cHIodGhpcy5pdGVyYWJsZSwgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiBhZGROYW1lcyhzdXBlci5uYW1lcywgdGhpcy5pdGVyYWJsZS5uYW1lcyk7XG4gICAgfVxufVxuY2xhc3MgRnVuYyBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgYXJncywgYXN5bmMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgdGhpcy5hc3luYyA9IGFzeW5jO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICBjb25zdCBfYXN5bmMgPSB0aGlzLmFzeW5jID8gXCJhc3luYyBcIiA6IFwiXCI7XG4gICAgICAgIHJldHVybiBgJHtfYXN5bmN9ZnVuY3Rpb24gJHt0aGlzLm5hbWV9KCR7dGhpcy5hcmdzfSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbn1cbkZ1bmMua2luZCA9IFwiZnVuY1wiO1xuY2xhc3MgUmV0dXJuIGV4dGVuZHMgUGFyZW50Tm9kZSB7XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIFwicmV0dXJuIFwiICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbn1cblJldHVybi5raW5kID0gXCJyZXR1cm5cIjtcbmNsYXNzIFRyeSBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgbGV0IGNvZGUgPSBcInRyeVwiICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgICAgICBpZiAodGhpcy5jYXRjaClcbiAgICAgICAgICAgIGNvZGUgKz0gdGhpcy5jYXRjaC5yZW5kZXIob3B0cyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmFsbHkpXG4gICAgICAgICAgICBjb2RlICs9IHRoaXMuZmluYWxseS5yZW5kZXIob3B0cyk7XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBzdXBlci5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgIChfYSA9IHRoaXMuY2F0Y2gpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgIChfYiA9IHRoaXMuZmluYWxseSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICAoX2EgPSB0aGlzLmNhdGNoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgKF9iID0gdGhpcy5maW5hbGx5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBzdXBlci5uYW1lcztcbiAgICAgICAgaWYgKHRoaXMuY2F0Y2gpXG4gICAgICAgICAgICBhZGROYW1lcyhuYW1lcywgdGhpcy5jYXRjaC5uYW1lcyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmFsbHkpXG4gICAgICAgICAgICBhZGROYW1lcyhuYW1lcywgdGhpcy5maW5hbGx5Lm5hbWVzKTtcbiAgICAgICAgcmV0dXJuIG5hbWVzO1xuICAgIH1cbn1cbmNsYXNzIENhdGNoIGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBgY2F0Y2goJHt0aGlzLmVycm9yfSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbn1cbkNhdGNoLmtpbmQgPSBcImNhdGNoXCI7XG5jbGFzcyBGaW5hbGx5IGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gXCJmaW5hbGx5XCIgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxufVxuRmluYWxseS5raW5kID0gXCJmaW5hbGx5XCI7XG5jbGFzcyBDb2RlR2VuIHtcbiAgICBjb25zdHJ1Y3RvcihleHRTY29wZSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IHt9O1xuICAgICAgICB0aGlzLl9ibG9ja1N0YXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLl9jb25zdGFudHMgPSB7fTtcbiAgICAgICAgdGhpcy5vcHRzID0geyAuLi5vcHRzLCBfbjogb3B0cy5saW5lcyA/IFwiXFxuXCIgOiBcIlwiIH07XG4gICAgICAgIHRoaXMuX2V4dFNjb3BlID0gZXh0U2NvcGU7XG4gICAgICAgIHRoaXMuX3Njb3BlID0gbmV3IHNjb3BlXzEuU2NvcGUoeyBwYXJlbnQ6IGV4dFNjb3BlIH0pO1xuICAgICAgICB0aGlzLl9ub2RlcyA9IFtuZXcgUm9vdCgpXTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290LnJlbmRlcih0aGlzLm9wdHMpO1xuICAgIH1cbiAgICAvLyByZXR1cm5zIHVuaXF1ZSBuYW1lIGluIHRoZSBpbnRlcm5hbCBzY29wZVxuICAgIG5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY29wZS5uYW1lKHByZWZpeCk7XG4gICAgfVxuICAgIC8vIHJlc2VydmVzIHVuaXF1ZSBuYW1lIGluIHRoZSBleHRlcm5hbCBzY29wZVxuICAgIHNjb3BlTmFtZShwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLm5hbWUocHJlZml4KTtcbiAgICB9XG4gICAgLy8gcmVzZXJ2ZXMgdW5pcXVlIG5hbWUgaW4gdGhlIGV4dGVybmFsIHNjb3BlIGFuZCBhc3NpZ25zIHZhbHVlIHRvIGl0XG4gICAgc2NvcGVWYWx1ZShwcmVmaXhPck5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9leHRTY29wZS52YWx1ZShwcmVmaXhPck5hbWUsIHZhbHVlKTtcbiAgICAgICAgY29uc3QgdnMgPSB0aGlzLl92YWx1ZXNbbmFtZS5wcmVmaXhdIHx8ICh0aGlzLl92YWx1ZXNbbmFtZS5wcmVmaXhdID0gbmV3IFNldCgpKTtcbiAgICAgICAgdnMuYWRkKG5hbWUpO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgZ2V0U2NvcGVWYWx1ZShwcmVmaXgsIGtleU9yUmVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5nZXRWYWx1ZShwcmVmaXgsIGtleU9yUmVmKTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIGNvZGUgdGhhdCBhc3NpZ25zIHZhbHVlcyBpbiB0aGUgZXh0ZXJuYWwgc2NvcGUgdG8gdGhlIG5hbWVzIHRoYXQgYXJlIHVzZWQgaW50ZXJuYWxseVxuICAgIC8vIChzYW1lIG5hbWVzIHRoYXQgd2VyZSByZXR1cm5lZCBieSBnZW4uc2NvcGVOYW1lIG9yIGdlbi5zY29wZVZhbHVlKVxuICAgIHNjb3BlUmVmcyhzY29wZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLnNjb3BlUmVmcyhzY29wZU5hbWUsIHRoaXMuX3ZhbHVlcyk7XG4gICAgfVxuICAgIHNjb3BlQ29kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLnNjb3BlQ29kZSh0aGlzLl92YWx1ZXMpO1xuICAgIH1cbiAgICBfZGVmKHZhcktpbmQsIG5hbWVPclByZWZpeCwgcmhzLCBjb25zdGFudCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIGlmIChyaHMgIT09IHVuZGVmaW5lZCAmJiBjb25zdGFudClcbiAgICAgICAgICAgIHRoaXMuX2NvbnN0YW50c1tuYW1lLnN0cl0gPSByaHM7XG4gICAgICAgIHRoaXMuX2xlYWZOb2RlKG5ldyBEZWYodmFyS2luZCwgbmFtZSwgcmhzKSk7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICAvLyBgY29uc3RgIGRlY2xhcmF0aW9uIChgdmFyYCBpbiBlczUgbW9kZSlcbiAgICBjb25zdChuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYoc2NvcGVfMS52YXJLaW5kcy5jb25zdCwgbmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCk7XG4gICAgfVxuICAgIC8vIGBsZXRgIGRlY2xhcmF0aW9uIHdpdGggb3B0aW9uYWwgYXNzaWdubWVudCAoYHZhcmAgaW4gZXM1IG1vZGUpXG4gICAgbGV0KG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZihzY29wZV8xLnZhcktpbmRzLmxldCwgbmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCk7XG4gICAgfVxuICAgIC8vIGB2YXJgIGRlY2xhcmF0aW9uIHdpdGggb3B0aW9uYWwgYXNzaWdubWVudFxuICAgIHZhcihuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYoc2NvcGVfMS52YXJLaW5kcy52YXIsIG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpO1xuICAgIH1cbiAgICAvLyBhc3NpZ25tZW50IGNvZGVcbiAgICBhc3NpZ24obGhzLCByaHMsIHNpZGVFZmZlY3RzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgQXNzaWduKGxocywgcmhzLCBzaWRlRWZmZWN0cykpO1xuICAgIH1cbiAgICAvLyBgKz1gIGNvZGVcbiAgICBhZGQobGhzLCByaHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBBc3NpZ25PcChsaHMsIGV4cG9ydHMub3BlcmF0b3JzLkFERCwgcmhzKSk7XG4gICAgfVxuICAgIC8vIGFwcGVuZHMgcGFzc2VkIFNhZmVFeHByIHRvIGNvZGUgb3IgZXhlY3V0ZXMgQmxvY2tcbiAgICBjb2RlKGMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIGMoKTtcbiAgICAgICAgZWxzZSBpZiAoYyAhPT0gY29kZV8xLm5pbClcbiAgICAgICAgICAgIHRoaXMuX2xlYWZOb2RlKG5ldyBBbnlDb2RlKGMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIHJldHVybnMgY29kZSBmb3Igb2JqZWN0IGxpdGVyYWwgZm9yIHRoZSBwYXNzZWQgYXJndW1lbnQgbGlzdCBvZiBrZXktdmFsdWUgcGFpcnNcbiAgICBvYmplY3QoLi4ua2V5VmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBbXCJ7XCJdO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBrZXlWYWx1ZXMpIHtcbiAgICAgICAgICAgIGlmIChjb2RlLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgY29kZS5wdXNoKFwiLFwiKTtcbiAgICAgICAgICAgIGNvZGUucHVzaChrZXkpO1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gdmFsdWUgfHwgdGhpcy5vcHRzLmVzNSkge1xuICAgICAgICAgICAgICAgIGNvZGUucHVzaChcIjpcIik7XG4gICAgICAgICAgICAgICAgY29kZV8xLmFkZENvZGVBcmcoY29kZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvZGUucHVzaChcIn1cIik7XG4gICAgICAgIHJldHVybiBuZXcgY29kZV8xLl9Db2RlKGNvZGUpO1xuICAgIH1cbiAgICAvLyBgaWZgIGNsYXVzZSAob3Igc3RhdGVtZW50IGlmIGB0aGVuQm9keWAgYW5kLCBvcHRpb25hbGx5LCBgZWxzZUJvZHlgIGFyZSBwYXNzZWQpXG4gICAgaWYoY29uZGl0aW9uLCB0aGVuQm9keSwgZWxzZUJvZHkpIHtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5ldyBJZihjb25kaXRpb24pKTtcbiAgICAgICAgaWYgKHRoZW5Cb2R5ICYmIGVsc2VCb2R5KSB7XG4gICAgICAgICAgICB0aGlzLmNvZGUodGhlbkJvZHkpLmVsc2UoKS5jb2RlKGVsc2VCb2R5KS5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoZW5Cb2R5KSB7XG4gICAgICAgICAgICB0aGlzLmNvZGUodGhlbkJvZHkpLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxzZUJvZHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJlbHNlXCIgYm9keSB3aXRob3V0IFwidGhlblwiIGJvZHknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gYGVsc2UgaWZgIGNsYXVzZSAtIGludmFsaWQgd2l0aG91dCBgaWZgIG9yIGFmdGVyIGBlbHNlYCBjbGF1c2VzXG4gICAgZWxzZUlmKGNvbmRpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxzZU5vZGUobmV3IElmKGNvbmRpdGlvbikpO1xuICAgIH1cbiAgICAvLyBgZWxzZWAgY2xhdXNlIC0gb25seSB2YWxpZCBhZnRlciBgaWZgIG9yIGBlbHNlIGlmYCBjbGF1c2VzXG4gICAgZWxzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vsc2VOb2RlKG5ldyBFbHNlKCkpO1xuICAgIH1cbiAgICAvLyBlbmQgYGlmYCBzdGF0ZW1lbnQgKG5lZWRlZCBpZiBnZW4uaWYgd2FzIHVzZWQgb25seSB3aXRoIGNvbmRpdGlvbilcbiAgICBlbmRJZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShJZiwgRWxzZSk7XG4gICAgfVxuICAgIF9mb3Iobm9kZSwgZm9yQm9keSkge1xuICAgICAgICB0aGlzLl9ibG9ja05vZGUobm9kZSk7XG4gICAgICAgIGlmIChmb3JCb2R5KVxuICAgICAgICAgICAgdGhpcy5jb2RlKGZvckJvZHkpLmVuZEZvcigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gYSBnZW5lcmljIGBmb3JgIGNsYXVzZSAob3Igc3RhdGVtZW50IGlmIGBmb3JCb2R5YCBpcyBwYXNzZWQpXG4gICAgZm9yKGl0ZXJhdGlvbiwgZm9yQm9keSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JMb29wKGl0ZXJhdGlvbiksIGZvckJvZHkpO1xuICAgIH1cbiAgICAvLyBgZm9yYCBzdGF0ZW1lbnQgZm9yIGEgcmFuZ2Ugb2YgdmFsdWVzXG4gICAgZm9yUmFuZ2UobmFtZU9yUHJlZml4LCBmcm9tLCB0bywgZm9yQm9keSwgdmFyS2luZCA9IHRoaXMub3B0cy5lczUgPyBzY29wZV8xLnZhcktpbmRzLnZhciA6IHNjb3BlXzEudmFyS2luZHMubGV0KSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9yUmFuZ2UodmFyS2luZCwgbmFtZSwgZnJvbSwgdG8pLCAoKSA9PiBmb3JCb2R5KG5hbWUpKTtcbiAgICB9XG4gICAgLy8gYGZvci1vZmAgc3RhdGVtZW50IChpbiBlczUgbW9kZSByZXBsYWNlIHdpdGggYSBub3JtYWwgZm9yIGxvb3ApXG4gICAgZm9yT2YobmFtZU9yUHJlZml4LCBpdGVyYWJsZSwgZm9yQm9keSwgdmFyS2luZCA9IHNjb3BlXzEudmFyS2luZHMuY29uc3QpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX3Njb3BlLnRvTmFtZShuYW1lT3JQcmVmaXgpO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmVzNSkge1xuICAgICAgICAgICAgY29uc3QgYXJyID0gaXRlcmFibGUgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSA/IGl0ZXJhYmxlIDogdGhpcy52YXIoXCJfYXJyXCIsIGl0ZXJhYmxlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvclJhbmdlKFwiX2lcIiwgMCwgY29kZV8xLl8gYCR7YXJyfS5sZW5ndGhgLCAoaSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudmFyKG5hbWUsIGNvZGVfMS5fIGAke2Fycn1bJHtpfV1gKTtcbiAgICAgICAgICAgICAgICBmb3JCb2R5KG5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9ySXRlcihcIm9mXCIsIHZhcktpbmQsIG5hbWUsIGl0ZXJhYmxlKSwgKCkgPT4gZm9yQm9keShuYW1lKSk7XG4gICAgfVxuICAgIC8vIGBmb3ItaW5gIHN0YXRlbWVudC5cbiAgICAvLyBXaXRoIG9wdGlvbiBgb3duUHJvcGVydGllc2AgcmVwbGFjZWQgd2l0aCBhIGBmb3Itb2ZgIGxvb3AgZm9yIG9iamVjdCBrZXlzXG4gICAgZm9ySW4obmFtZU9yUHJlZml4LCBvYmosIGZvckJvZHksIHZhcktpbmQgPSB0aGlzLm9wdHMuZXM1ID8gc2NvcGVfMS52YXJLaW5kcy52YXIgOiBzY29wZV8xLnZhcktpbmRzLmNvbnN0KSB7XG4gICAgICAgIGlmICh0aGlzLm9wdHMub3duUHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9yT2YobmFtZU9yUHJlZml4LCBjb2RlXzEuXyBgT2JqZWN0LmtleXMoJHtvYmp9KWAsIGZvckJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9ySXRlcihcImluXCIsIHZhcktpbmQsIG5hbWUsIG9iaiksICgpID0+IGZvckJvZHkobmFtZSkpO1xuICAgIH1cbiAgICAvLyBlbmQgYGZvcmAgbG9vcFxuICAgIGVuZEZvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShGb3IpO1xuICAgIH1cbiAgICAvLyBgbGFiZWxgIHN0YXRlbWVudFxuICAgIGxhYmVsKGxhYmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgTGFiZWwobGFiZWwpKTtcbiAgICB9XG4gICAgLy8gYGJyZWFrYCBzdGF0ZW1lbnRcbiAgICBicmVhayhsYWJlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IEJyZWFrKGxhYmVsKSk7XG4gICAgfVxuICAgIC8vIGByZXR1cm5gIHN0YXRlbWVudFxuICAgIHJldHVybih2YWx1ZSkge1xuICAgICAgICBjb25zdCBub2RlID0gbmV3IFJldHVybigpO1xuICAgICAgICB0aGlzLl9ibG9ja05vZGUobm9kZSk7XG4gICAgICAgIHRoaXMuY29kZSh2YWx1ZSk7XG4gICAgICAgIGlmIChub2RlLm5vZGVzLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJyZXR1cm5cIiBzaG91bGQgaGF2ZSBvbmUgbm9kZScpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKFJldHVybik7XG4gICAgfVxuICAgIC8vIGB0cnlgIHN0YXRlbWVudFxuICAgIHRyeSh0cnlCb2R5LCBjYXRjaENvZGUsIGZpbmFsbHlDb2RlKSB7XG4gICAgICAgIGlmICghY2F0Y2hDb2RlICYmICFmaW5hbGx5Q29kZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJ0cnlcIiB3aXRob3V0IFwiY2F0Y2hcIiBhbmQgXCJmaW5hbGx5XCInKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBUcnkoKTtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5vZGUpO1xuICAgICAgICB0aGlzLmNvZGUodHJ5Qm9keSk7XG4gICAgICAgIGlmIChjYXRjaENvZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5uYW1lKFwiZVwiKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJOb2RlID0gbm9kZS5jYXRjaCA9IG5ldyBDYXRjaChlcnJvcik7XG4gICAgICAgICAgICBjYXRjaENvZGUoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaW5hbGx5Q29kZSkge1xuICAgICAgICAgICAgdGhpcy5fY3Vyck5vZGUgPSBub2RlLmZpbmFsbHkgPSBuZXcgRmluYWxseSgpO1xuICAgICAgICAgICAgdGhpcy5jb2RlKGZpbmFsbHlDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKENhdGNoLCBGaW5hbGx5KTtcbiAgICB9XG4gICAgLy8gYHRocm93YCBzdGF0ZW1lbnRcbiAgICB0aHJvdyhlcnJvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IFRocm93KGVycm9yKSk7XG4gICAgfVxuICAgIC8vIHN0YXJ0IHNlbGYtYmFsYW5jaW5nIGJsb2NrXG4gICAgYmxvY2soYm9keSwgbm9kZUNvdW50KSB7XG4gICAgICAgIHRoaXMuX2Jsb2NrU3RhcnRzLnB1c2godGhpcy5fbm9kZXMubGVuZ3RoKTtcbiAgICAgICAgaWYgKGJvZHkpXG4gICAgICAgICAgICB0aGlzLmNvZGUoYm9keSkuZW5kQmxvY2sobm9kZUNvdW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGVuZCB0aGUgY3VycmVudCBzZWxmLWJhbGFuY2luZyBibG9ja1xuICAgIGVuZEJsb2NrKG5vZGVDb3VudCkge1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLl9ibG9ja1N0YXJ0cy5wb3AoKTtcbiAgICAgICAgaWYgKGxlbiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogbm90IGluIHNlbGYtYmFsYW5jaW5nIGJsb2NrXCIpO1xuICAgICAgICBjb25zdCB0b0Nsb3NlID0gdGhpcy5fbm9kZXMubGVuZ3RoIC0gbGVuO1xuICAgICAgICBpZiAodG9DbG9zZSA8IDAgfHwgKG5vZGVDb3VudCAhPT0gdW5kZWZpbmVkICYmIHRvQ2xvc2UgIT09IG5vZGVDb3VudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogd3JvbmcgbnVtYmVyIG9mIG5vZGVzOiAke3RvQ2xvc2V9IHZzICR7bm9kZUNvdW50fSBleHBlY3RlZGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25vZGVzLmxlbmd0aCA9IGxlbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGBmdW5jdGlvbmAgaGVhZGluZyAob3IgZGVmaW5pdGlvbiBpZiBmdW5jQm9keSBpcyBwYXNzZWQpXG4gICAgZnVuYyhuYW1lLCBhcmdzID0gY29kZV8xLm5pbCwgYXN5bmMsIGZ1bmNCb2R5KSB7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShuZXcgRnVuYyhuYW1lLCBhcmdzLCBhc3luYykpO1xuICAgICAgICBpZiAoZnVuY0JvZHkpXG4gICAgICAgICAgICB0aGlzLmNvZGUoZnVuY0JvZHkpLmVuZEZ1bmMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGVuZCBmdW5jdGlvbiBkZWZpbml0aW9uXG4gICAgZW5kRnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShGdW5jKTtcbiAgICB9XG4gICAgb3B0aW1pemUobiA9IDEpIHtcbiAgICAgICAgd2hpbGUgKG4tLSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3Qub3B0aW1pemVOb2RlcygpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdC5vcHRpbWl6ZU5hbWVzKHRoaXMuX3Jvb3QubmFtZXMsIHRoaXMuX2NvbnN0YW50cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2xlYWZOb2RlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5fY3Vyck5vZGUubm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIF9ibG9ja05vZGUobm9kZSkge1xuICAgICAgICB0aGlzLl9jdXJyTm9kZS5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB0aGlzLl9ub2Rlcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgICBfZW5kQmxvY2tOb2RlKE4xLCBOMikge1xuICAgICAgICBjb25zdCBuID0gdGhpcy5fY3Vyck5vZGU7XG4gICAgICAgIGlmIChuIGluc3RhbmNlb2YgTjEgfHwgKE4yICYmIG4gaW5zdGFuY2VvZiBOMikpIHtcbiAgICAgICAgICAgIHRoaXMuX25vZGVzLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBub3QgaW4gYmxvY2sgXCIke04yID8gYCR7TjEua2luZH0vJHtOMi5raW5kfWAgOiBOMS5raW5kfVwiYCk7XG4gICAgfVxuICAgIF9lbHNlTm9kZShub2RlKSB7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLl9jdXJyTm9kZTtcbiAgICAgICAgaWYgKCEobiBpbnN0YW5jZW9mIElmKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlR2VuOiBcImVsc2VcIiB3aXRob3V0IFwiaWZcIicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnJOb2RlID0gbi5lbHNlID0gbm9kZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBfcm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vZGVzWzBdO1xuICAgIH1cbiAgICBnZXQgX2N1cnJOb2RlKCkge1xuICAgICAgICBjb25zdCBucyA9IHRoaXMuX25vZGVzO1xuICAgICAgICByZXR1cm4gbnNbbnMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHNldCBfY3Vyck5vZGUobm9kZSkge1xuICAgICAgICBjb25zdCBucyA9IHRoaXMuX25vZGVzO1xuICAgICAgICBuc1tucy5sZW5ndGggLSAxXSA9IG5vZGU7XG4gICAgfVxufVxuZXhwb3J0cy5Db2RlR2VuID0gQ29kZUdlbjtcbmZ1bmN0aW9uIGFkZE5hbWVzKG5hbWVzLCBmcm9tKSB7XG4gICAgZm9yIChjb25zdCBuIGluIGZyb20pXG4gICAgICAgIG5hbWVzW25dID0gKG5hbWVzW25dIHx8IDApICsgKGZyb21bbl0gfHwgMCk7XG4gICAgcmV0dXJuIG5hbWVzO1xufVxuZnVuY3Rpb24gYWRkRXhwck5hbWVzKG5hbWVzLCBmcm9tKSB7XG4gICAgcmV0dXJuIGZyb20gaW5zdGFuY2VvZiBjb2RlXzEuX0NvZGVPck5hbWUgPyBhZGROYW1lcyhuYW1lcywgZnJvbS5uYW1lcykgOiBuYW1lcztcbn1cbmZ1bmN0aW9uIG9wdGltaXplRXhwcihleHByLCBuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSlcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VOYW1lKGV4cHIpO1xuICAgIGlmICghY2FuT3B0aW1pemUoZXhwcikpXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIHJldHVybiBuZXcgY29kZV8xLl9Db2RlKGV4cHIuX2l0ZW1zLnJlZHVjZSgoaXRlbXMsIGMpID0+IHtcbiAgICAgICAgaWYgKGMgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSlcbiAgICAgICAgICAgIGMgPSByZXBsYWNlTmFtZShjKTtcbiAgICAgICAgaWYgKGMgaW5zdGFuY2VvZiBjb2RlXzEuX0NvZGUpXG4gICAgICAgICAgICBpdGVtcy5wdXNoKC4uLmMuX2l0ZW1zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgaXRlbXMucHVzaChjKTtcbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0sIFtdKSk7XG4gICAgZnVuY3Rpb24gcmVwbGFjZU5hbWUobikge1xuICAgICAgICBjb25zdCBjID0gY29uc3RhbnRzW24uc3RyXTtcbiAgICAgICAgaWYgKGMgPT09IHVuZGVmaW5lZCB8fCBuYW1lc1tuLnN0cl0gIT09IDEpXG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgZGVsZXRlIG5hbWVzW24uc3RyXTtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbk9wdGltaXplKGUpIHtcbiAgICAgICAgcmV0dXJuIChlIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlICYmXG4gICAgICAgICAgICBlLl9pdGVtcy5zb21lKChjKSA9PiBjIGluc3RhbmNlb2YgY29kZV8xLk5hbWUgJiYgbmFtZXNbYy5zdHJdID09PSAxICYmIGNvbnN0YW50c1tjLnN0cl0gIT09IHVuZGVmaW5lZCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN1YnRyYWN0TmFtZXMobmFtZXMsIGZyb20pIHtcbiAgICBmb3IgKGNvbnN0IG4gaW4gZnJvbSlcbiAgICAgICAgbmFtZXNbbl0gPSAobmFtZXNbbl0gfHwgMCkgLSAoZnJvbVtuXSB8fCAwKTtcbn1cbmZ1bmN0aW9uIG5vdCh4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09IFwiYm9vbGVhblwiIHx8IHR5cGVvZiB4ID09IFwibnVtYmVyXCIgfHwgeCA9PT0gbnVsbCA/ICF4IDogY29kZV8xLl8gYCEke3Bhcih4KX1gO1xufVxuZXhwb3J0cy5ub3QgPSBub3Q7XG5jb25zdCBhbmRDb2RlID0gbWFwcGVuZChleHBvcnRzLm9wZXJhdG9ycy5BTkQpO1xuLy8gYm9vbGVhbiBBTkQgKCYmKSBleHByZXNzaW9uIHdpdGggdGhlIHBhc3NlZCBhcmd1bWVudHNcbmZ1bmN0aW9uIGFuZCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGFyZ3MucmVkdWNlKGFuZENvZGUpO1xufVxuZXhwb3J0cy5hbmQgPSBhbmQ7XG5jb25zdCBvckNvZGUgPSBtYXBwZW5kKGV4cG9ydHMub3BlcmF0b3JzLk9SKTtcbi8vIGJvb2xlYW4gT1IgKHx8KSBleHByZXNzaW9uIHdpdGggdGhlIHBhc3NlZCBhcmd1bWVudHNcbmZ1bmN0aW9uIG9yKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gYXJncy5yZWR1Y2Uob3JDb2RlKTtcbn1cbmV4cG9ydHMub3IgPSBvcjtcbmZ1bmN0aW9uIG1hcHBlbmQob3ApIHtcbiAgICByZXR1cm4gKHgsIHkpID0+ICh4ID09PSBjb2RlXzEubmlsID8geSA6IHkgPT09IGNvZGVfMS5uaWwgPyB4IDogY29kZV8xLl8gYCR7cGFyKHgpfSAke29wfSAke3Bhcih5KX1gKTtcbn1cbmZ1bmN0aW9uIHBhcih4KSB7XG4gICAgcmV0dXJuIHggaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSA/IHggOiBjb2RlXzEuXyBgKCR7eH0pYDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jaGVja1N0cmljdE1vZGUgPSBleHBvcnRzLmdldEVycm9yUGF0aCA9IGV4cG9ydHMuVHlwZSA9IGV4cG9ydHMudXNlRnVuYyA9IGV4cG9ydHMuc2V0RXZhbHVhdGVkID0gZXhwb3J0cy5ldmFsdWF0ZWRQcm9wc1RvTmFtZSA9IGV4cG9ydHMubWVyZ2VFdmFsdWF0ZWQgPSBleHBvcnRzLmVhY2hJdGVtID0gZXhwb3J0cy51bmVzY2FwZUpzb25Qb2ludGVyID0gZXhwb3J0cy5lc2NhcGVKc29uUG9pbnRlciA9IGV4cG9ydHMuZXNjYXBlRnJhZ21lbnQgPSBleHBvcnRzLnVuZXNjYXBlRnJhZ21lbnQgPSBleHBvcnRzLnNjaGVtYVJlZk9yVmFsID0gZXhwb3J0cy5zY2hlbWFIYXNSdWxlc0J1dFJlZiA9IGV4cG9ydHMuc2NoZW1hSGFzUnVsZXMgPSBleHBvcnRzLmNoZWNrVW5rbm93blJ1bGVzID0gZXhwb3J0cy5hbHdheXNWYWxpZFNjaGVtYSA9IGV4cG9ydHMudG9IYXNoID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4vY29kZWdlblwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW4vY29kZVwiKTtcbi8vIFRPRE8gcmVmYWN0b3IgdG8gdXNlIFNldFxuZnVuY3Rpb24gdG9IYXNoKGFycikge1xuICAgIGNvbnN0IGhhc2ggPSB7fTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKVxuICAgICAgICBoYXNoW2l0ZW1dID0gdHJ1ZTtcbiAgICByZXR1cm4gaGFzaDtcbn1cbmV4cG9ydHMudG9IYXNoID0gdG9IYXNoO1xuZnVuY3Rpb24gYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIGlmIChPYmplY3Qua2V5cyhzY2hlbWEpLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2hlY2tVbmtub3duUnVsZXMoaXQsIHNjaGVtYSk7XG4gICAgcmV0dXJuICFzY2hlbWFIYXNSdWxlcyhzY2hlbWEsIGl0LnNlbGYuUlVMRVMuYWxsKTtcbn1cbmV4cG9ydHMuYWx3YXlzVmFsaWRTY2hlbWEgPSBhbHdheXNWYWxpZFNjaGVtYTtcbmZ1bmN0aW9uIGNoZWNrVW5rbm93blJ1bGVzKGl0LCBzY2hlbWEgPSBpdC5zY2hlbWEpIHtcbiAgICBjb25zdCB7IG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgIGlmICghb3B0cy5zdHJpY3RTY2hlbWEpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBydWxlcyA9IHNlbGYuUlVMRVMua2V5d29yZHM7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGlmICghcnVsZXNba2V5XSlcbiAgICAgICAgICAgIGNoZWNrU3RyaWN0TW9kZShpdCwgYHVua25vd24ga2V5d29yZDogXCIke2tleX1cImApO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tVbmtub3duUnVsZXMgPSBjaGVja1Vua25vd25SdWxlcztcbmZ1bmN0aW9uIHNjaGVtYUhhc1J1bGVzKHNjaGVtYSwgcnVsZXMpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuICFzY2hlbWE7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKVxuICAgICAgICBpZiAocnVsZXNba2V5XSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuc2NoZW1hSGFzUnVsZXMgPSBzY2hlbWFIYXNSdWxlcztcbmZ1bmN0aW9uIHNjaGVtYUhhc1J1bGVzQnV0UmVmKHNjaGVtYSwgUlVMRVMpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuICFzY2hlbWE7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKVxuICAgICAgICBpZiAoa2V5ICE9PSBcIiRyZWZcIiAmJiBSVUxFUy5hbGxba2V5XSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuc2NoZW1hSGFzUnVsZXNCdXRSZWYgPSBzY2hlbWFIYXNSdWxlc0J1dFJlZjtcbmZ1bmN0aW9uIHNjaGVtYVJlZk9yVmFsKHsgdG9wU2NoZW1hUmVmLCBzY2hlbWFQYXRoIH0sIHNjaGVtYSwga2V5d29yZCwgJGRhdGEpIHtcbiAgICBpZiAoISRkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLl8gYCR7c2NoZW1hfWA7XG4gICAgfVxuICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgJHt0b3BTY2hlbWFSZWZ9JHtzY2hlbWFQYXRofSR7Y29kZWdlbl8xLmdldFByb3BlcnR5KGtleXdvcmQpfWA7XG59XG5leHBvcnRzLnNjaGVtYVJlZk9yVmFsID0gc2NoZW1hUmVmT3JWYWw7XG5mdW5jdGlvbiB1bmVzY2FwZUZyYWdtZW50KHN0cikge1xuICAgIHJldHVybiB1bmVzY2FwZUpzb25Qb2ludGVyKGRlY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbn1cbmV4cG9ydHMudW5lc2NhcGVGcmFnbWVudCA9IHVuZXNjYXBlRnJhZ21lbnQ7XG5mdW5jdGlvbiBlc2NhcGVGcmFnbWVudChzdHIpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGVzY2FwZUpzb25Qb2ludGVyKHN0cikpO1xufVxuZXhwb3J0cy5lc2NhcGVGcmFnbWVudCA9IGVzY2FwZUZyYWdtZW50O1xuZnVuY3Rpb24gZXNjYXBlSnNvblBvaW50ZXIoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgPT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIGAke3N0cn1gO1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcLy9nLCBcIn4xXCIpO1xufVxuZXhwb3J0cy5lc2NhcGVKc29uUG9pbnRlciA9IGVzY2FwZUpzb25Qb2ludGVyO1xuZnVuY3Rpb24gdW5lc2NhcGVKc29uUG9pbnRlcihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL34xL2csIFwiL1wiKS5yZXBsYWNlKC9+MC9nLCBcIn5cIik7XG59XG5leHBvcnRzLnVuZXNjYXBlSnNvblBvaW50ZXIgPSB1bmVzY2FwZUpzb25Qb2ludGVyO1xuZnVuY3Rpb24gZWFjaEl0ZW0oeHMsIGYpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh4cykpIHtcbiAgICAgICAgZm9yIChjb25zdCB4IG9mIHhzKVxuICAgICAgICAgICAgZih4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGYoeHMpO1xuICAgIH1cbn1cbmV4cG9ydHMuZWFjaEl0ZW0gPSBlYWNoSXRlbTtcbmZ1bmN0aW9uIG1ha2VNZXJnZUV2YWx1YXRlZCh7IG1lcmdlTmFtZXMsIG1lcmdlVG9OYW1lLCBtZXJnZVZhbHVlcywgcmVzdWx0VG9OYW1lLCB9KSB7XG4gICAgcmV0dXJuIChnZW4sIGZyb20sIHRvLCB0b05hbWUpID0+IHtcbiAgICAgICAgY29uc3QgcmVzID0gdG8gPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBmcm9tXG4gICAgICAgICAgICA6IHRvIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWVcbiAgICAgICAgICAgICAgICA/IChmcm9tIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUgPyBtZXJnZU5hbWVzKGdlbiwgZnJvbSwgdG8pIDogbWVyZ2VUb05hbWUoZ2VuLCBmcm9tLCB0byksIHRvKVxuICAgICAgICAgICAgICAgIDogZnJvbSBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lXG4gICAgICAgICAgICAgICAgICAgID8gKG1lcmdlVG9OYW1lKGdlbiwgdG8sIGZyb20pLCBmcm9tKVxuICAgICAgICAgICAgICAgICAgICA6IG1lcmdlVmFsdWVzKGZyb20sIHRvKTtcbiAgICAgICAgcmV0dXJuIHRvTmFtZSA9PT0gY29kZWdlbl8xLk5hbWUgJiYgIShyZXMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSkgPyByZXN1bHRUb05hbWUoZ2VuLCByZXMpIDogcmVzO1xuICAgIH07XG59XG5leHBvcnRzLm1lcmdlRXZhbHVhdGVkID0ge1xuICAgIHByb3BzOiBtYWtlTWVyZ2VFdmFsdWF0ZWQoe1xuICAgICAgICBtZXJnZU5hbWVzOiAoZ2VuLCBmcm9tLCB0bykgPT4gZ2VuLmlmKGNvZGVnZW5fMS5fIGAke3RvfSAhPT0gdHJ1ZSAmJiAke2Zyb219ICE9PSB1bmRlZmluZWRgLCAoKSA9PiB7XG4gICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7ZnJvbX0gPT09IHRydWVgLCAoKSA9PiBnZW4uYXNzaWduKHRvLCB0cnVlKSwgKCkgPT4gZ2VuLmFzc2lnbih0bywgY29kZWdlbl8xLl8gYCR7dG99IHx8IHt9YCkuY29kZShjb2RlZ2VuXzEuXyBgT2JqZWN0LmFzc2lnbigke3RvfSwgJHtmcm9tfSlgKSk7XG4gICAgICAgIH0pLFxuICAgICAgICBtZXJnZVRvTmFtZTogKGdlbiwgZnJvbSwgdG8pID0+IGdlbi5pZihjb2RlZ2VuXzEuXyBgJHt0b30gIT09IHRydWVgLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZnJvbSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odG8sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih0bywgY29kZWdlbl8xLl8gYCR7dG99IHx8IHt9YCk7XG4gICAgICAgICAgICAgICAgc2V0RXZhbHVhdGVkKGdlbiwgdG8sIGZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgbWVyZ2VWYWx1ZXM6IChmcm9tLCB0bykgPT4gKGZyb20gPT09IHRydWUgPyB0cnVlIDogeyAuLi5mcm9tLCAuLi50byB9KSxcbiAgICAgICAgcmVzdWx0VG9OYW1lOiBldmFsdWF0ZWRQcm9wc1RvTmFtZSxcbiAgICB9KSxcbiAgICBpdGVtczogbWFrZU1lcmdlRXZhbHVhdGVkKHtcbiAgICAgICAgbWVyZ2VOYW1lczogKGdlbiwgZnJvbSwgdG8pID0+IGdlbi5pZihjb2RlZ2VuXzEuXyBgJHt0b30gIT09IHRydWUgJiYgJHtmcm9tfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4gZ2VuLmFzc2lnbih0bywgY29kZWdlbl8xLl8gYCR7ZnJvbX0gPT09IHRydWUgPyB0cnVlIDogJHt0b30gPiAke2Zyb219ID8gJHt0b30gOiAke2Zyb219YCkpLFxuICAgICAgICBtZXJnZVRvTmFtZTogKGdlbiwgZnJvbSwgdG8pID0+IGdlbi5pZihjb2RlZ2VuXzEuXyBgJHt0b30gIT09IHRydWVgLCAoKSA9PiBnZW4uYXNzaWduKHRvLCBmcm9tID09PSB0cnVlID8gdHJ1ZSA6IGNvZGVnZW5fMS5fIGAke3RvfSA+ICR7ZnJvbX0gPyAke3RvfSA6ICR7ZnJvbX1gKSksXG4gICAgICAgIG1lcmdlVmFsdWVzOiAoZnJvbSwgdG8pID0+IChmcm9tID09PSB0cnVlID8gdHJ1ZSA6IE1hdGgubWF4KGZyb20sIHRvKSksXG4gICAgICAgIHJlc3VsdFRvTmFtZTogKGdlbiwgaXRlbXMpID0+IGdlbi52YXIoXCJpdGVtc1wiLCBpdGVtcyksXG4gICAgfSksXG59O1xuZnVuY3Rpb24gZXZhbHVhdGVkUHJvcHNUb05hbWUoZ2VuLCBwcykge1xuICAgIGlmIChwcyA9PT0gdHJ1ZSlcbiAgICAgICAgcmV0dXJuIGdlbi52YXIoXCJwcm9wc1wiLCB0cnVlKTtcbiAgICBjb25zdCBwcm9wcyA9IGdlbi52YXIoXCJwcm9wc1wiLCBjb2RlZ2VuXzEuXyBge31gKTtcbiAgICBpZiAocHMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgc2V0RXZhbHVhdGVkKGdlbiwgcHJvcHMsIHBzKTtcbiAgICByZXR1cm4gcHJvcHM7XG59XG5leHBvcnRzLmV2YWx1YXRlZFByb3BzVG9OYW1lID0gZXZhbHVhdGVkUHJvcHNUb05hbWU7XG5mdW5jdGlvbiBzZXRFdmFsdWF0ZWQoZ2VuLCBwcm9wcywgcHMpIHtcbiAgICBPYmplY3Qua2V5cyhwcykuZm9yRWFjaCgocCkgPT4gZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHtwcm9wc30ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eShwKX1gLCB0cnVlKSk7XG59XG5leHBvcnRzLnNldEV2YWx1YXRlZCA9IHNldEV2YWx1YXRlZDtcbmNvbnN0IHNuaXBwZXRzID0ge307XG5mdW5jdGlvbiB1c2VGdW5jKGdlbiwgZikge1xuICAgIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcImZ1bmNcIiwge1xuICAgICAgICByZWY6IGYsXG4gICAgICAgIGNvZGU6IHNuaXBwZXRzW2YuY29kZV0gfHwgKHNuaXBwZXRzW2YuY29kZV0gPSBuZXcgY29kZV8xLl9Db2RlKGYuY29kZSkpLFxuICAgIH0pO1xufVxuZXhwb3J0cy51c2VGdW5jID0gdXNlRnVuYztcbnZhciBUeXBlO1xuKGZ1bmN0aW9uIChUeXBlKSB7XG4gICAgVHlwZVtUeXBlW1wiTnVtXCJdID0gMF0gPSBcIk51bVwiO1xuICAgIFR5cGVbVHlwZVtcIlN0clwiXSA9IDFdID0gXCJTdHJcIjtcbn0pKFR5cGUgPSBleHBvcnRzLlR5cGUgfHwgKGV4cG9ydHMuVHlwZSA9IHt9KSk7XG5mdW5jdGlvbiBnZXRFcnJvclBhdGgoZGF0YVByb3AsIGRhdGFQcm9wVHlwZSwganNQcm9wZXJ0eVN5bnRheCkge1xuICAgIC8vIGxldCBwYXRoXG4gICAgaWYgKGRhdGFQcm9wIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpIHtcbiAgICAgICAgY29uc3QgaXNOdW1iZXIgPSBkYXRhUHJvcFR5cGUgPT09IFR5cGUuTnVtO1xuICAgICAgICByZXR1cm4ganNQcm9wZXJ0eVN5bnRheFxuICAgICAgICAgICAgPyBpc051bWJlclxuICAgICAgICAgICAgICAgID8gY29kZWdlbl8xLl8gYFwiW1wiICsgJHtkYXRhUHJvcH0gKyBcIl1cImBcbiAgICAgICAgICAgICAgICA6IGNvZGVnZW5fMS5fIGBcIlsnXCIgKyAke2RhdGFQcm9wfSArIFwiJ11cImBcbiAgICAgICAgICAgIDogaXNOdW1iZXJcbiAgICAgICAgICAgICAgICA/IGNvZGVnZW5fMS5fIGBcIi9cIiArICR7ZGF0YVByb3B9YFxuICAgICAgICAgICAgICAgIDogY29kZWdlbl8xLl8gYFwiL1wiICsgJHtkYXRhUHJvcH0ucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcXFwvL2csIFwifjFcIilgOyAvLyBUT0RPIG1heWJlIHVzZSBnbG9iYWwgZXNjYXBlUG9pbnRlclxuICAgIH1cbiAgICByZXR1cm4ganNQcm9wZXJ0eVN5bnRheCA/IGNvZGVnZW5fMS5nZXRQcm9wZXJ0eShkYXRhUHJvcCkudG9TdHJpbmcoKSA6IFwiL1wiICsgZXNjYXBlSnNvblBvaW50ZXIoZGF0YVByb3ApO1xufVxuZXhwb3J0cy5nZXRFcnJvclBhdGggPSBnZXRFcnJvclBhdGg7XG5mdW5jdGlvbiBjaGVja1N0cmljdE1vZGUoaXQsIG1zZywgbW9kZSA9IGl0Lm9wdHMuc3RyaWN0U2NoZW1hKSB7XG4gICAgaWYgKCFtb2RlKVxuICAgICAgICByZXR1cm47XG4gICAgbXNnID0gYHN0cmljdCBtb2RlOiAke21zZ31gO1xuICAgIGlmIChtb2RlID09PSB0cnVlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICBpdC5zZWxmLmxvZ2dlci53YXJuKG1zZyk7XG59XG5leHBvcnRzLmNoZWNrU3RyaWN0TW9kZSA9IGNoZWNrU3RyaWN0TW9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXMgPSB7XG4gICAgLy8gdmFsaWRhdGlvbiBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICBkYXRhOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJkYXRhXCIpLFxuICAgIC8vIGFyZ3MgcGFzc2VkIGZyb20gcmVmZXJlbmNpbmcgc2NoZW1hXG4gICAgdmFsQ3h0OiBuZXcgY29kZWdlbl8xLk5hbWUoXCJ2YWxDeHRcIiksXG4gICAgaW5zdGFuY2VQYXRoOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJpbnN0YW5jZVBhdGhcIiksXG4gICAgcGFyZW50RGF0YTogbmV3IGNvZGVnZW5fMS5OYW1lKFwicGFyZW50RGF0YVwiKSxcbiAgICBwYXJlbnREYXRhUHJvcGVydHk6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmVudERhdGFQcm9wZXJ0eVwiKSxcbiAgICByb290RGF0YTogbmV3IGNvZGVnZW5fMS5OYW1lKFwicm9vdERhdGFcIiksXG4gICAgZHluYW1pY0FuY2hvcnM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImR5bmFtaWNBbmNob3JzXCIpLFxuICAgIC8vIGZ1bmN0aW9uIHNjb3BlZCB2YXJpYWJsZXNcbiAgICB2RXJyb3JzOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJ2RXJyb3JzXCIpLFxuICAgIGVycm9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwiZXJyb3JzXCIpLFxuICAgIHRoaXM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInRoaXNcIiksXG4gICAgLy8gXCJnbG9iYWxzXCJcbiAgICBzZWxmOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJzZWxmXCIpLFxuICAgIHNjb3BlOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJzY29wZVwiKSxcbiAgICAvLyBKVEQgc2VyaWFsaXplL3BhcnNlIG5hbWUgZm9yIEpTT04gc3RyaW5nIGFuZCBwb3NpdGlvblxuICAgIGpzb246IG5ldyBjb2RlZ2VuXzEuTmFtZShcImpzb25cIiksXG4gICAganNvblBvczogbmV3IGNvZGVnZW5fMS5OYW1lKFwianNvblBvc1wiKSxcbiAgICBqc29uTGVuOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJqc29uTGVuXCIpLFxuICAgIGpzb25QYXJ0OiBuZXcgY29kZWdlbl8xLk5hbWUoXCJqc29uUGFydFwiKSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBuYW1lcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hbWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHRlbmRFcnJvcnMgPSBleHBvcnRzLnJlc2V0RXJyb3JzQ291bnQgPSBleHBvcnRzLnJlcG9ydEV4dHJhRXJyb3IgPSBleHBvcnRzLnJlcG9ydEVycm9yID0gZXhwb3J0cy5rZXl3b3JkJERhdGFFcnJvciA9IGV4cG9ydHMua2V5d29yZEVycm9yID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4vY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4vbmFtZXNcIik7XG5leHBvcnRzLmtleXdvcmRFcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBrZXl3b3JkIH0pID0+IGNvZGVnZW5fMS5zdHIgYG11c3QgcGFzcyBcIiR7a2V5d29yZH1cIiBrZXl3b3JkIHZhbGlkYXRpb25gLFxufTtcbmV4cG9ydHMua2V5d29yZCREYXRhRXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsga2V5d29yZCwgc2NoZW1hVHlwZSB9KSA9PiBzY2hlbWFUeXBlXG4gICAgICAgID8gY29kZWdlbl8xLnN0ciBgXCIke2tleXdvcmR9XCIga2V5d29yZCBtdXN0IGJlICR7c2NoZW1hVHlwZX0gKCRkYXRhKWBcbiAgICAgICAgOiBjb2RlZ2VuXzEuc3RyIGBcIiR7a2V5d29yZH1cIiBrZXl3b3JkIGlzIGludmFsaWQgKCRkYXRhKWAsXG59O1xuZnVuY3Rpb24gcmVwb3J0RXJyb3IoY3h0LCBlcnJvciA9IGV4cG9ydHMua2V5d29yZEVycm9yLCBlcnJvclBhdGhzLCBvdmVycmlkZUFsbEVycm9ycykge1xuICAgIGNvbnN0IHsgaXQgfSA9IGN4dDtcbiAgICBjb25zdCB7IGdlbiwgY29tcG9zaXRlUnVsZSwgYWxsRXJyb3JzIH0gPSBpdDtcbiAgICBjb25zdCBlcnJPYmogPSBlcnJvck9iamVjdENvZGUoY3h0LCBlcnJvciwgZXJyb3JQYXRocyk7XG4gICAgaWYgKG92ZXJyaWRlQWxsRXJyb3JzICE9PSBudWxsICYmIG92ZXJyaWRlQWxsRXJyb3JzICE9PSB2b2lkIDAgPyBvdmVycmlkZUFsbEVycm9ycyA6IChjb21wb3NpdGVSdWxlIHx8IGFsbEVycm9ycykpIHtcbiAgICAgICAgYWRkRXJyb3IoZ2VuLCBlcnJPYmopO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuRXJyb3JzKGl0LCBjb2RlZ2VuXzEuXyBgWyR7ZXJyT2JqfV1gKTtcbiAgICB9XG59XG5leHBvcnRzLnJlcG9ydEVycm9yID0gcmVwb3J0RXJyb3I7XG5mdW5jdGlvbiByZXBvcnRFeHRyYUVycm9yKGN4dCwgZXJyb3IgPSBleHBvcnRzLmtleXdvcmRFcnJvciwgZXJyb3JQYXRocykge1xuICAgIGNvbnN0IHsgaXQgfSA9IGN4dDtcbiAgICBjb25zdCB7IGdlbiwgY29tcG9zaXRlUnVsZSwgYWxsRXJyb3JzIH0gPSBpdDtcbiAgICBjb25zdCBlcnJPYmogPSBlcnJvck9iamVjdENvZGUoY3h0LCBlcnJvciwgZXJyb3JQYXRocyk7XG4gICAgYWRkRXJyb3IoZ2VuLCBlcnJPYmopO1xuICAgIGlmICghKGNvbXBvc2l0ZVJ1bGUgfHwgYWxsRXJyb3JzKSkge1xuICAgICAgICByZXR1cm5FcnJvcnMoaXQsIG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzKTtcbiAgICB9XG59XG5leHBvcnRzLnJlcG9ydEV4dHJhRXJyb3IgPSByZXBvcnRFeHRyYUVycm9yO1xuZnVuY3Rpb24gcmVzZXRFcnJvcnNDb3VudChnZW4sIGVycnNDb3VudCkge1xuICAgIGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LmVycm9ycywgZXJyc0NvdW50KTtcbiAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9ICE9PSBudWxsYCwgKCkgPT4gZ2VuLmlmKGVycnNDb3VudCwgKCkgPT4gZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30ubGVuZ3RoYCwgZXJyc0NvdW50KSwgKCkgPT4gZ2VuLmFzc2lnbihuYW1lc18xLmRlZmF1bHQudkVycm9ycywgbnVsbCkpKTtcbn1cbmV4cG9ydHMucmVzZXRFcnJvcnNDb3VudCA9IHJlc2V0RXJyb3JzQ291bnQ7XG5mdW5jdGlvbiBleHRlbmRFcnJvcnMoeyBnZW4sIGtleXdvcmQsIHNjaGVtYVZhbHVlLCBkYXRhLCBlcnJzQ291bnQsIGl0LCB9KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGVycnNDb3VudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgY29uc3QgZXJyID0gZ2VuLm5hbWUoXCJlcnJcIik7XG4gICAgZ2VuLmZvclJhbmdlKFwiaVwiLCBlcnJzQ291bnQsIG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsIChpKSA9PiB7XG4gICAgICAgIGdlbi5jb25zdChlcnIsIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfVske2l9XWApO1xuICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7ZXJyfS5pbnN0YW5jZVBhdGggPT09IHVuZGVmaW5lZGAsICgpID0+IGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7ZXJyfS5pbnN0YW5jZVBhdGhgLCBjb2RlZ2VuXzEuc3RyQ29uY2F0KG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsIGl0LmVycm9yUGF0aCkpKTtcbiAgICAgICAgZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHtlcnJ9LnNjaGVtYVBhdGhgLCBjb2RlZ2VuXzEuc3RyIGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gKTtcbiAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHtlcnJ9LnNjaGVtYWAsIHNjaGVtYVZhbHVlKTtcbiAgICAgICAgICAgIGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7ZXJyfS5kYXRhYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuZXh0ZW5kRXJyb3JzID0gZXh0ZW5kRXJyb3JzO1xuZnVuY3Rpb24gYWRkRXJyb3IoZ2VuLCBlcnJPYmopIHtcbiAgICBjb25zdCBlcnIgPSBnZW4uY29uc3QoXCJlcnJcIiwgZXJyT2JqKTtcbiAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9ID09PSBudWxsYCwgKCkgPT4gZ2VuLmFzc2lnbihuYW1lc18xLmRlZmF1bHQudkVycm9ycywgY29kZWdlbl8xLl8gYFske2Vycn1dYCksIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5wdXNoKCR7ZXJyfSlgKTtcbiAgICBnZW4uY29kZShjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfSsrYCk7XG59XG5mdW5jdGlvbiByZXR1cm5FcnJvcnMoaXQsIGVycnMpIHtcbiAgICBjb25zdCB7IGdlbiwgdmFsaWRhdGVOYW1lLCBzY2hlbWFFbnYgfSA9IGl0O1xuICAgIGlmIChzY2hlbWFFbnYuJGFzeW5jKSB7XG4gICAgICAgIGdlbi50aHJvdyhjb2RlZ2VuXzEuXyBgbmV3ICR7aXQuVmFsaWRhdGlvbkVycm9yfSgke2VycnN9KWApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIGVycnMpO1xuICAgICAgICBnZW4ucmV0dXJuKGZhbHNlKTtcbiAgICB9XG59XG5jb25zdCBFID0ge1xuICAgIGtleXdvcmQ6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImtleXdvcmRcIiksXG4gICAgc2NoZW1hUGF0aDogbmV3IGNvZGVnZW5fMS5OYW1lKFwic2NoZW1hUGF0aFwiKSxcbiAgICBwYXJhbXM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmFtc1wiKSxcbiAgICBwcm9wZXJ0eU5hbWU6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInByb3BlcnR5TmFtZVwiKSxcbiAgICBtZXNzYWdlOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJtZXNzYWdlXCIpLFxuICAgIHNjaGVtYTogbmV3IGNvZGVnZW5fMS5OYW1lKFwic2NoZW1hXCIpLFxuICAgIHBhcmVudFNjaGVtYTogbmV3IGNvZGVnZW5fMS5OYW1lKFwicGFyZW50U2NoZW1hXCIpLFxufTtcbmZ1bmN0aW9uIGVycm9yT2JqZWN0Q29kZShjeHQsIGVycm9yLCBlcnJvclBhdGhzKSB7XG4gICAgY29uc3QgeyBjcmVhdGVFcnJvcnMgfSA9IGN4dC5pdDtcbiAgICBpZiAoY3JlYXRlRXJyb3JzID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5fIGB7fWA7XG4gICAgcmV0dXJuIGVycm9yT2JqZWN0KGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpO1xufVxuZnVuY3Rpb24gZXJyb3JPYmplY3QoY3h0LCBlcnJvciwgZXJyb3JQYXRocyA9IHt9KSB7XG4gICAgY29uc3QgeyBnZW4sIGl0IH0gPSBjeHQ7XG4gICAgY29uc3Qga2V5VmFsdWVzID0gW1xuICAgICAgICBlcnJvckluc3RhbmNlUGF0aChpdCwgZXJyb3JQYXRocyksXG4gICAgICAgIGVycm9yU2NoZW1hUGF0aChjeHQsIGVycm9yUGF0aHMpLFxuICAgIF07XG4gICAgZXh0cmFFcnJvclByb3BzKGN4dCwgZXJyb3IsIGtleVZhbHVlcyk7XG4gICAgcmV0dXJuIGdlbi5vYmplY3QoLi4ua2V5VmFsdWVzKTtcbn1cbmZ1bmN0aW9uIGVycm9ySW5zdGFuY2VQYXRoKHsgZXJyb3JQYXRoIH0sIHsgaW5zdGFuY2VQYXRoIH0pIHtcbiAgICBjb25zdCBpbnN0UGF0aCA9IGluc3RhbmNlUGF0aFxuICAgICAgICA/IGNvZGVnZW5fMS5zdHIgYCR7ZXJyb3JQYXRofSR7dXRpbF8xLmdldEVycm9yUGF0aChpbnN0YW5jZVBhdGgsIHV0aWxfMS5UeXBlLlN0cil9YFxuICAgICAgICA6IGVycm9yUGF0aDtcbiAgICByZXR1cm4gW25hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsIGNvZGVnZW5fMS5zdHJDb25jYXQobmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgaW5zdFBhdGgpXTtcbn1cbmZ1bmN0aW9uIGVycm9yU2NoZW1hUGF0aCh7IGtleXdvcmQsIGl0OiB7IGVyclNjaGVtYVBhdGggfSB9LCB7IHNjaGVtYVBhdGgsIHBhcmVudFNjaGVtYSB9KSB7XG4gICAgbGV0IHNjaFBhdGggPSBwYXJlbnRTY2hlbWEgPyBlcnJTY2hlbWFQYXRoIDogY29kZWdlbl8xLnN0ciBgJHtlcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9YDtcbiAgICBpZiAoc2NoZW1hUGF0aCkge1xuICAgICAgICBzY2hQYXRoID0gY29kZWdlbl8xLnN0ciBgJHtzY2hQYXRofSR7dXRpbF8xLmdldEVycm9yUGF0aChzY2hlbWFQYXRoLCB1dGlsXzEuVHlwZS5TdHIpfWA7XG4gICAgfVxuICAgIHJldHVybiBbRS5zY2hlbWFQYXRoLCBzY2hQYXRoXTtcbn1cbmZ1bmN0aW9uIGV4dHJhRXJyb3JQcm9wcyhjeHQsIHsgcGFyYW1zLCBtZXNzYWdlIH0sIGtleVZhbHVlcykge1xuICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hVmFsdWUsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgeyBvcHRzLCBwcm9wZXJ0eU5hbWUsIHRvcFNjaGVtYVJlZiwgc2NoZW1hUGF0aCB9ID0gaXQ7XG4gICAga2V5VmFsdWVzLnB1c2goW0Uua2V5d29yZCwga2V5d29yZF0sIFtFLnBhcmFtcywgdHlwZW9mIHBhcmFtcyA9PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMoY3h0KSA6IHBhcmFtcyB8fCBjb2RlZ2VuXzEuXyBge31gXSk7XG4gICAgaWYgKG9wdHMubWVzc2FnZXMpIHtcbiAgICAgICAga2V5VmFsdWVzLnB1c2goW0UubWVzc2FnZSwgdHlwZW9mIG1lc3NhZ2UgPT0gXCJmdW5jdGlvblwiID8gbWVzc2FnZShjeHQpIDogbWVzc2FnZV0pO1xuICAgIH1cbiAgICBpZiAob3B0cy52ZXJib3NlKSB7XG4gICAgICAgIGtleVZhbHVlcy5wdXNoKFtFLnNjaGVtYSwgc2NoZW1hVmFsdWVdLCBbRS5wYXJlbnRTY2hlbWEsIGNvZGVnZW5fMS5fIGAke3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9YF0sIFtuYW1lc18xLmRlZmF1bHQuZGF0YSwgZGF0YV0pO1xuICAgIH1cbiAgICBpZiAocHJvcGVydHlOYW1lKVxuICAgICAgICBrZXlWYWx1ZXMucHVzaChbRS5wcm9wZXJ0eU5hbWUsIHByb3BlcnR5TmFtZV0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ib29sT3JFbXB0eVNjaGVtYSA9IGV4cG9ydHMudG9wQm9vbE9yRW1wdHlTY2hlbWEgPSB2b2lkIDA7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vbmFtZXNcIik7XG5jb25zdCBib29sRXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJib29sZWFuIHNjaGVtYSBpcyBmYWxzZVwiLFxufTtcbmZ1bmN0aW9uIHRvcEJvb2xPckVtcHR5U2NoZW1hKGl0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgdmFsaWRhdGVOYW1lIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICBmYWxzZVNjaGVtYUVycm9yKGl0LCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBzY2hlbWEuJGFzeW5jID09PSB0cnVlKSB7XG4gICAgICAgIGdlbi5yZXR1cm4obmFtZXNfMS5kZWZhdWx0LmRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIG51bGwpO1xuICAgICAgICBnZW4ucmV0dXJuKHRydWUpO1xuICAgIH1cbn1cbmV4cG9ydHMudG9wQm9vbE9yRW1wdHlTY2hlbWEgPSB0b3BCb29sT3JFbXB0eVNjaGVtYTtcbmZ1bmN0aW9uIGJvb2xPckVtcHR5U2NoZW1hKGl0LCB2YWxpZCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEgfSA9IGl0O1xuICAgIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgIGdlbi52YXIodmFsaWQsIGZhbHNlKTsgLy8gVE9ETyB2YXJcbiAgICAgICAgZmFsc2VTY2hlbWFFcnJvcihpdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW4udmFyKHZhbGlkLCB0cnVlKTsgLy8gVE9ETyB2YXJcbiAgICB9XG59XG5leHBvcnRzLmJvb2xPckVtcHR5U2NoZW1hID0gYm9vbE9yRW1wdHlTY2hlbWE7XG5mdW5jdGlvbiBmYWxzZVNjaGVtYUVycm9yKGl0LCBvdmVycmlkZUFsbEVycm9ycykge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhIH0gPSBpdDtcbiAgICAvLyBUT0RPIG1heWJlIHNvbWUgb3RoZXIgaW50ZXJmYWNlIHNob3VsZCBiZSB1c2VkIGZvciBub24ta2V5d29yZCB2YWxpZGF0aW9uIGVycm9ycy4uLlxuICAgIGNvbnN0IGN4dCA9IHtcbiAgICAgICAgZ2VuLFxuICAgICAgICBrZXl3b3JkOiBcImZhbHNlIHNjaGVtYVwiLFxuICAgICAgICBkYXRhLFxuICAgICAgICBzY2hlbWE6IGZhbHNlLFxuICAgICAgICBzY2hlbWFDb2RlOiBmYWxzZSxcbiAgICAgICAgc2NoZW1hVmFsdWU6IGZhbHNlLFxuICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICBpdCxcbiAgICB9O1xuICAgIGVycm9yc18xLnJlcG9ydEVycm9yKGN4dCwgYm9vbEVycm9yLCB1bmRlZmluZWQsIG92ZXJyaWRlQWxsRXJyb3JzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvb2xTY2hlbWEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFJ1bGVzID0gZXhwb3J0cy5pc0pTT05UeXBlID0gdm9pZCAwO1xuY29uc3QgX2pzb25UeXBlcyA9IFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImludGVnZXJcIiwgXCJib29sZWFuXCIsIFwibnVsbFwiLCBcIm9iamVjdFwiLCBcImFycmF5XCJdO1xuY29uc3QganNvblR5cGVzID0gbmV3IFNldChfanNvblR5cGVzKTtcbmZ1bmN0aW9uIGlzSlNPTlR5cGUoeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PSBcInN0cmluZ1wiICYmIGpzb25UeXBlcy5oYXMoeCk7XG59XG5leHBvcnRzLmlzSlNPTlR5cGUgPSBpc0pTT05UeXBlO1xuZnVuY3Rpb24gZ2V0UnVsZXMoKSB7XG4gICAgY29uc3QgZ3JvdXBzID0ge1xuICAgICAgICBudW1iZXI6IHsgdHlwZTogXCJudW1iZXJcIiwgcnVsZXM6IFtdIH0sXG4gICAgICAgIHN0cmluZzogeyB0eXBlOiBcInN0cmluZ1wiLCBydWxlczogW10gfSxcbiAgICAgICAgYXJyYXk6IHsgdHlwZTogXCJhcnJheVwiLCBydWxlczogW10gfSxcbiAgICAgICAgb2JqZWN0OiB7IHR5cGU6IFwib2JqZWN0XCIsIHJ1bGVzOiBbXSB9LFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZXM6IHsgLi4uZ3JvdXBzLCBpbnRlZ2VyOiB0cnVlLCBib29sZWFuOiB0cnVlLCBudWxsOiB0cnVlIH0sXG4gICAgICAgIHJ1bGVzOiBbeyBydWxlczogW10gfSwgZ3JvdXBzLm51bWJlciwgZ3JvdXBzLnN0cmluZywgZ3JvdXBzLmFycmF5LCBncm91cHMub2JqZWN0XSxcbiAgICAgICAgcG9zdDogeyBydWxlczogW10gfSxcbiAgICAgICAgYWxsOiB7fSxcbiAgICAgICAga2V5d29yZHM6IHt9LFxuICAgIH07XG59XG5leHBvcnRzLmdldFJ1bGVzID0gZ2V0UnVsZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ydWxlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hvdWxkVXNlUnVsZSA9IGV4cG9ydHMuc2hvdWxkVXNlR3JvdXAgPSBleHBvcnRzLnNjaGVtYUhhc1J1bGVzRm9yVHlwZSA9IHZvaWQgMDtcbmZ1bmN0aW9uIHNjaGVtYUhhc1J1bGVzRm9yVHlwZSh7IHNjaGVtYSwgc2VsZiB9LCB0eXBlKSB7XG4gICAgY29uc3QgZ3JvdXAgPSBzZWxmLlJVTEVTLnR5cGVzW3R5cGVdO1xuICAgIHJldHVybiBncm91cCAmJiBncm91cCAhPT0gdHJ1ZSAmJiBzaG91bGRVc2VHcm91cChzY2hlbWEsIGdyb3VwKTtcbn1cbmV4cG9ydHMuc2NoZW1hSGFzUnVsZXNGb3JUeXBlID0gc2NoZW1hSGFzUnVsZXNGb3JUeXBlO1xuZnVuY3Rpb24gc2hvdWxkVXNlR3JvdXAoc2NoZW1hLCBncm91cCkge1xuICAgIHJldHVybiBncm91cC5ydWxlcy5zb21lKChydWxlKSA9PiBzaG91bGRVc2VSdWxlKHNjaGVtYSwgcnVsZSkpO1xufVxuZXhwb3J0cy5zaG91bGRVc2VHcm91cCA9IHNob3VsZFVzZUdyb3VwO1xuZnVuY3Rpb24gc2hvdWxkVXNlUnVsZShzY2hlbWEsIHJ1bGUpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChzY2hlbWFbcnVsZS5rZXl3b3JkXSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICgoX2EgPSBydWxlLmRlZmluaXRpb24uaW1wbGVtZW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvbWUoKGt3ZCkgPT4gc2NoZW1hW2t3ZF0gIT09IHVuZGVmaW5lZCkpKTtcbn1cbmV4cG9ydHMuc2hvdWxkVXNlUnVsZSA9IHNob3VsZFVzZVJ1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHBsaWNhYmlsaXR5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXBvcnRUeXBlRXJyb3IgPSBleHBvcnRzLmNoZWNrRGF0YVR5cGVzID0gZXhwb3J0cy5jaGVja0RhdGFUeXBlID0gZXhwb3J0cy5jb2VyY2VBbmRDaGVja0RhdGFUeXBlID0gZXhwb3J0cy5nZXRKU09OVHlwZXMgPSBleHBvcnRzLmdldFNjaGVtYVR5cGVzID0gZXhwb3J0cy5EYXRhVHlwZSA9IHZvaWQgMDtcbmNvbnN0IHJ1bGVzXzEgPSByZXF1aXJlKFwiLi4vcnVsZXNcIik7XG5jb25zdCBhcHBsaWNhYmlsaXR5XzEgPSByZXF1aXJlKFwiLi9hcHBsaWNhYmlsaXR5XCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBEYXRhVHlwZTtcbihmdW5jdGlvbiAoRGF0YVR5cGUpIHtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIkNvcnJlY3RcIl0gPSAwXSA9IFwiQ29ycmVjdFwiO1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wiV3JvbmdcIl0gPSAxXSA9IFwiV3JvbmdcIjtcbn0pKERhdGFUeXBlID0gZXhwb3J0cy5EYXRhVHlwZSB8fCAoZXhwb3J0cy5EYXRhVHlwZSA9IHt9KSk7XG5mdW5jdGlvbiBnZXRTY2hlbWFUeXBlcyhzY2hlbWEpIHtcbiAgICBjb25zdCB0eXBlcyA9IGdldEpTT05UeXBlcyhzY2hlbWEudHlwZSk7XG4gICAgY29uc3QgaGFzTnVsbCA9IHR5cGVzLmluY2x1ZGVzKFwibnVsbFwiKTtcbiAgICBpZiAoaGFzTnVsbCkge1xuICAgICAgICBpZiAoc2NoZW1hLm51bGxhYmxlID09PSBmYWxzZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInR5cGU6IG51bGwgY29udHJhZGljdHMgbnVsbGFibGU6IGZhbHNlXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCF0eXBlcy5sZW5ndGggJiYgc2NoZW1hLm51bGxhYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJudWxsYWJsZVwiIGNhbm5vdCBiZSB1c2VkIHdpdGhvdXQgXCJ0eXBlXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLm51bGxhYmxlID09PSB0cnVlKVxuICAgICAgICAgICAgdHlwZXMucHVzaChcIm51bGxcIik7XG4gICAgfVxuICAgIHJldHVybiB0eXBlcztcbn1cbmV4cG9ydHMuZ2V0U2NoZW1hVHlwZXMgPSBnZXRTY2hlbWFUeXBlcztcbmZ1bmN0aW9uIGdldEpTT05UeXBlcyh0cykge1xuICAgIGNvbnN0IHR5cGVzID0gQXJyYXkuaXNBcnJheSh0cykgPyB0cyA6IHRzID8gW3RzXSA6IFtdO1xuICAgIGlmICh0eXBlcy5ldmVyeShydWxlc18xLmlzSlNPTlR5cGUpKVxuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZSBtdXN0IGJlIEpTT05UeXBlIG9yIEpTT05UeXBlW106IFwiICsgdHlwZXMuam9pbihcIixcIikpO1xufVxuZXhwb3J0cy5nZXRKU09OVHlwZXMgPSBnZXRKU09OVHlwZXM7XG5mdW5jdGlvbiBjb2VyY2VBbmRDaGVja0RhdGFUeXBlKGl0LCB0eXBlcykge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBvcHRzIH0gPSBpdDtcbiAgICBjb25zdCBjb2VyY2VUbyA9IGNvZXJjZVRvVHlwZXModHlwZXMsIG9wdHMuY29lcmNlVHlwZXMpO1xuICAgIGNvbnN0IGNoZWNrVHlwZXMgPSB0eXBlcy5sZW5ndGggPiAwICYmXG4gICAgICAgICEoY29lcmNlVG8ubGVuZ3RoID09PSAwICYmIHR5cGVzLmxlbmd0aCA9PT0gMSAmJiBhcHBsaWNhYmlsaXR5XzEuc2NoZW1hSGFzUnVsZXNGb3JUeXBlKGl0LCB0eXBlc1swXSkpO1xuICAgIGlmIChjaGVja1R5cGVzKSB7XG4gICAgICAgIGNvbnN0IHdyb25nVHlwZSA9IGNoZWNrRGF0YVR5cGVzKHR5cGVzLCBkYXRhLCBvcHRzLnN0cmljdE51bWJlcnMsIERhdGFUeXBlLldyb25nKTtcbiAgICAgICAgZ2VuLmlmKHdyb25nVHlwZSwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvZXJjZVRvLmxlbmd0aClcbiAgICAgICAgICAgICAgICBjb2VyY2VEYXRhKGl0LCB0eXBlcywgY29lcmNlVG8pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlcG9ydFR5cGVFcnJvcihpdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hlY2tUeXBlcztcbn1cbmV4cG9ydHMuY29lcmNlQW5kQ2hlY2tEYXRhVHlwZSA9IGNvZXJjZUFuZENoZWNrRGF0YVR5cGU7XG5jb25zdCBDT0VSQ0lCTEUgPSBuZXcgU2V0KFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImludGVnZXJcIiwgXCJib29sZWFuXCIsIFwibnVsbFwiXSk7XG5mdW5jdGlvbiBjb2VyY2VUb1R5cGVzKHR5cGVzLCBjb2VyY2VUeXBlcykge1xuICAgIHJldHVybiBjb2VyY2VUeXBlc1xuICAgICAgICA/IHR5cGVzLmZpbHRlcigodCkgPT4gQ09FUkNJQkxFLmhhcyh0KSB8fCAoY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIiAmJiB0ID09PSBcImFycmF5XCIpKVxuICAgICAgICA6IFtdO1xufVxuZnVuY3Rpb24gY29lcmNlRGF0YShpdCwgdHlwZXMsIGNvZXJjZVRvKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIG9wdHMgfSA9IGl0O1xuICAgIGNvbnN0IGRhdGFUeXBlID0gZ2VuLmxldChcImRhdGFUeXBlXCIsIGNvZGVnZW5fMS5fIGB0eXBlb2YgJHtkYXRhfWApO1xuICAgIGNvbnN0IGNvZXJjZWQgPSBnZW4ubGV0KFwiY29lcmNlZFwiLCBjb2RlZ2VuXzEuXyBgdW5kZWZpbmVkYCk7XG4gICAgaWYgKG9wdHMuY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIikge1xuICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7ZGF0YVR5cGV9ID09ICdvYmplY3QnICYmIEFycmF5LmlzQXJyYXkoJHtkYXRhfSkgJiYgJHtkYXRhfS5sZW5ndGggPT0gMWAsICgpID0+IGdlblxuICAgICAgICAgICAgLmFzc2lnbihkYXRhLCBjb2RlZ2VuXzEuXyBgJHtkYXRhfVswXWApXG4gICAgICAgICAgICAuYXNzaWduKGRhdGFUeXBlLCBjb2RlZ2VuXzEuXyBgdHlwZW9mICR7ZGF0YX1gKVxuICAgICAgICAgICAgLmlmKGNoZWNrRGF0YVR5cGVzKHR5cGVzLCBkYXRhLCBvcHRzLnN0cmljdE51bWJlcnMpLCAoKSA9PiBnZW4uYXNzaWduKGNvZXJjZWQsIGRhdGEpKSk7XG4gICAgfVxuICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtjb2VyY2VkfSAhPT0gdW5kZWZpbmVkYCk7XG4gICAgZm9yIChjb25zdCB0IG9mIGNvZXJjZVRvKSB7XG4gICAgICAgIGlmIChDT0VSQ0lCTEUuaGFzKHQpIHx8ICh0ID09PSBcImFycmF5XCIgJiYgb3B0cy5jb2VyY2VUeXBlcyA9PT0gXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgY29lcmNlU3BlY2lmaWNUeXBlKHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdlbi5lbHNlKCk7XG4gICAgcmVwb3J0VHlwZUVycm9yKGl0KTtcbiAgICBnZW4uZW5kSWYoKTtcbiAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7Y29lcmNlZH0gIT09IHVuZGVmaW5lZGAsICgpID0+IHtcbiAgICAgICAgZ2VuLmFzc2lnbihkYXRhLCBjb2VyY2VkKTtcbiAgICAgICAgYXNzaWduUGFyZW50RGF0YShpdCwgY29lcmNlZCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gY29lcmNlU3BlY2lmaWNUeXBlKHQpIHtcbiAgICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoY29kZWdlbl8xLl8gYCR7ZGF0YVR5cGV9ID09IFwibnVtYmVyXCIgfHwgJHtkYXRhVHlwZX0gPT0gXCJib29sZWFuXCJgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIGNvZGVnZW5fMS5fIGBcIlwiICsgJHtkYXRhfWApXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoY29kZWdlbl8xLl8gYCR7ZGF0YX0gPT09IG51bGxgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIGNvZGVnZW5fMS5fIGBcIlwiYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKGNvZGVnZW5fMS5fIGAke2RhdGFUeXBlfSA9PSBcImJvb2xlYW5cIiB8fCAke2RhdGF9ID09PSBudWxsXG4gICAgICAgICAgICAgIHx8ICgke2RhdGFUeXBlfSA9PSBcInN0cmluZ1wiICYmICR7ZGF0YX0gJiYgJHtkYXRhfSA9PSArJHtkYXRhfSlgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIGNvZGVnZW5fMS5fIGArJHtkYXRhfWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJpbnRlZ2VyXCI6XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoY29kZWdlbl8xLl8gYCR7ZGF0YVR5cGV9ID09PSBcImJvb2xlYW5cIiB8fCAke2RhdGF9ID09PSBudWxsXG4gICAgICAgICAgICAgIHx8ICgke2RhdGFUeXBlfSA9PT0gXCJzdHJpbmdcIiAmJiAke2RhdGF9ICYmICR7ZGF0YX0gPT0gKyR7ZGF0YX0gJiYgISgke2RhdGF9ICUgMSkpYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBjb2RlZ2VuXzEuXyBgKyR7ZGF0YX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKGNvZGVnZW5fMS5fIGAke2RhdGF9ID09PSBcImZhbHNlXCIgfHwgJHtkYXRhfSA9PT0gMCB8fCAke2RhdGF9ID09PSBudWxsYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZihjb2RlZ2VuXzEuXyBgJHtkYXRhfSA9PT0gXCJ0cnVlXCIgfHwgJHtkYXRhfSA9PT0gMWApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcIm51bGxcIjpcbiAgICAgICAgICAgICAgICBnZW4uZWxzZUlmKGNvZGVnZW5fMS5fIGAke2RhdGF9ID09PSBcIlwiIHx8ICR7ZGF0YX0gPT09IDAgfHwgJHtkYXRhfSA9PT0gZmFsc2VgKTtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKGNvZXJjZWQsIG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKGNvZGVnZW5fMS5fIGAke2RhdGFUeXBlfSA9PT0gXCJzdHJpbmdcIiB8fCAke2RhdGFUeXBlfSA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgICB8fCAke2RhdGFUeXBlfSA9PT0gXCJib29sZWFuXCIgfHwgJHtkYXRhfSA9PT0gbnVsbGApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgY29kZWdlbl8xLl8gYFske2RhdGF9XWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzaWduUGFyZW50RGF0YSh7IGdlbiwgcGFyZW50RGF0YSwgcGFyZW50RGF0YVByb3BlcnR5IH0sIGV4cHIpIHtcbiAgICAvLyBUT0RPIHVzZSBnZW4ucHJvcGVydHlcbiAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7cGFyZW50RGF0YX0gIT09IHVuZGVmaW5lZGAsICgpID0+IGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7cGFyZW50RGF0YX1bJHtwYXJlbnREYXRhUHJvcGVydHl9XWAsIGV4cHIpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrRGF0YVR5cGUoZGF0YVR5cGUsIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QgPSBEYXRhVHlwZS5Db3JyZWN0KSB7XG4gICAgY29uc3QgRVEgPSBjb3JyZWN0ID09PSBEYXRhVHlwZS5Db3JyZWN0ID8gY29kZWdlbl8xLm9wZXJhdG9ycy5FUSA6IGNvZGVnZW5fMS5vcGVyYXRvcnMuTkVRO1xuICAgIGxldCBjb25kO1xuICAgIHN3aXRjaCAoZGF0YVR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm51bGxcIjpcbiAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgJHtkYXRhfSAke0VRfSBudWxsYDtcbiAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICBjb25kID0gY29kZWdlbl8xLl8gYEFycmF5LmlzQXJyYXkoJHtkYXRhfSlgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIGNvbmQgPSBjb2RlZ2VuXzEuXyBgJHtkYXRhfSAmJiB0eXBlb2YgJHtkYXRhfSA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KCR7ZGF0YX0pYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW50ZWdlclwiOlxuICAgICAgICAgICAgY29uZCA9IG51bUNvbmQoY29kZWdlbl8xLl8gYCEoJHtkYXRhfSAlIDEpICYmICFpc05hTigke2RhdGF9KWApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGNvbmQgPSBudW1Db25kKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgdHlwZW9mICR7ZGF0YX0gJHtFUX0gJHtkYXRhVHlwZX1gO1xuICAgIH1cbiAgICByZXR1cm4gY29ycmVjdCA9PT0gRGF0YVR5cGUuQ29ycmVjdCA/IGNvbmQgOiBjb2RlZ2VuXzEubm90KGNvbmQpO1xuICAgIGZ1bmN0aW9uIG51bUNvbmQoX2NvbmQgPSBjb2RlZ2VuXzEubmlsKSB7XG4gICAgICAgIHJldHVybiBjb2RlZ2VuXzEuYW5kKGNvZGVnZW5fMS5fIGB0eXBlb2YgJHtkYXRhfSA9PSBcIm51bWJlclwiYCwgX2NvbmQsIHN0cmljdE51bXMgPyBjb2RlZ2VuXzEuXyBgaXNGaW5pdGUoJHtkYXRhfSlgIDogY29kZWdlbl8xLm5pbCk7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja0RhdGFUeXBlID0gY2hlY2tEYXRhVHlwZTtcbmZ1bmN0aW9uIGNoZWNrRGF0YVR5cGVzKGRhdGFUeXBlcywgZGF0YSwgc3RyaWN0TnVtcywgY29ycmVjdCkge1xuICAgIGlmIChkYXRhVHlwZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBjaGVja0RhdGFUeXBlKGRhdGFUeXBlc1swXSwgZGF0YSwgc3RyaWN0TnVtcywgY29ycmVjdCk7XG4gICAgfVxuICAgIGxldCBjb25kO1xuICAgIGNvbnN0IHR5cGVzID0gdXRpbF8xLnRvSGFzaChkYXRhVHlwZXMpO1xuICAgIGlmICh0eXBlcy5hcnJheSAmJiB0eXBlcy5vYmplY3QpIHtcbiAgICAgICAgY29uc3Qgbm90T2JqID0gY29kZWdlbl8xLl8gYHR5cGVvZiAke2RhdGF9ICE9IFwib2JqZWN0XCJgO1xuICAgICAgICBjb25kID0gdHlwZXMubnVsbCA/IG5vdE9iaiA6IGNvZGVnZW5fMS5fIGAhJHtkYXRhfSB8fCAke25vdE9ian1gO1xuICAgICAgICBkZWxldGUgdHlwZXMubnVsbDtcbiAgICAgICAgZGVsZXRlIHR5cGVzLmFycmF5O1xuICAgICAgICBkZWxldGUgdHlwZXMub2JqZWN0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uZCA9IGNvZGVnZW5fMS5uaWw7XG4gICAgfVxuICAgIGlmICh0eXBlcy5udW1iZXIpXG4gICAgICAgIGRlbGV0ZSB0eXBlcy5pbnRlZ2VyO1xuICAgIGZvciAoY29uc3QgdCBpbiB0eXBlcylcbiAgICAgICAgY29uZCA9IGNvZGVnZW5fMS5hbmQoY29uZCwgY2hlY2tEYXRhVHlwZSh0LCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0KSk7XG4gICAgcmV0dXJuIGNvbmQ7XG59XG5leHBvcnRzLmNoZWNrRGF0YVR5cGVzID0gY2hlY2tEYXRhVHlwZXM7XG5jb25zdCB0eXBlRXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgc2NoZW1hIH0pID0+IGBtdXN0IGJlICR7c2NoZW1hfWAsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWEsIHNjaGVtYVZhbHVlIH0pID0+IHR5cGVvZiBzY2hlbWEgPT0gXCJzdHJpbmdcIiA/IGNvZGVnZW5fMS5fIGB7dHlwZTogJHtzY2hlbWF9fWAgOiBjb2RlZ2VuXzEuXyBge3R5cGU6ICR7c2NoZW1hVmFsdWV9fWAsXG59O1xuZnVuY3Rpb24gcmVwb3J0VHlwZUVycm9yKGl0KSB7XG4gICAgY29uc3QgY3h0ID0gZ2V0VHlwZUVycm9yQ29udGV4dChpdCk7XG4gICAgZXJyb3JzXzEucmVwb3J0RXJyb3IoY3h0LCB0eXBlRXJyb3IpO1xufVxuZXhwb3J0cy5yZXBvcnRUeXBlRXJyb3IgPSByZXBvcnRUeXBlRXJyb3I7XG5mdW5jdGlvbiBnZXRUeXBlRXJyb3JDb250ZXh0KGl0KSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIHNjaGVtYSB9ID0gaXQ7XG4gICAgY29uc3Qgc2NoZW1hQ29kZSA9IHV0aWxfMS5zY2hlbWFSZWZPclZhbChpdCwgc2NoZW1hLCBcInR5cGVcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2VuLFxuICAgICAgICBrZXl3b3JkOiBcInR5cGVcIixcbiAgICAgICAgZGF0YSxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWEudHlwZSxcbiAgICAgICAgc2NoZW1hQ29kZSxcbiAgICAgICAgc2NoZW1hVmFsdWU6IHNjaGVtYUNvZGUsXG4gICAgICAgIHBhcmVudFNjaGVtYTogc2NoZW1hLFxuICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICBpdCxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YVR5cGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzc2lnbkRlZmF1bHRzID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmZ1bmN0aW9uIGFzc2lnbkRlZmF1bHRzKGl0LCB0eSkge1xuICAgIGNvbnN0IHsgcHJvcGVydGllcywgaXRlbXMgfSA9IGl0LnNjaGVtYTtcbiAgICBpZiAodHkgPT09IFwib2JqZWN0XCIgJiYgcHJvcGVydGllcykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBhc3NpZ25EZWZhdWx0KGl0LCBrZXksIHByb3BlcnRpZXNba2V5XS5kZWZhdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eSA9PT0gXCJhcnJheVwiICYmIEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgIGl0ZW1zLmZvckVhY2goKHNjaCwgaSkgPT4gYXNzaWduRGVmYXVsdChpdCwgaSwgc2NoLmRlZmF1bHQpKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2lnbkRlZmF1bHRzID0gYXNzaWduRGVmYXVsdHM7XG5mdW5jdGlvbiBhc3NpZ25EZWZhdWx0KGl0LCBwcm9wLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBjb25zdCB7IGdlbiwgY29tcG9zaXRlUnVsZSwgZGF0YSwgb3B0cyB9ID0gaXQ7XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgY2hpbGREYXRhID0gY29kZWdlbl8xLl8gYCR7ZGF0YX0ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eShwcm9wKX1gO1xuICAgIGlmIChjb21wb3NpdGVSdWxlKSB7XG4gICAgICAgIHV0aWxfMS5jaGVja1N0cmljdE1vZGUoaXQsIGBkZWZhdWx0IGlzIGlnbm9yZWQgZm9yOiAke2NoaWxkRGF0YX1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY29uZGl0aW9uID0gY29kZWdlbl8xLl8gYCR7Y2hpbGREYXRhfSA9PT0gdW5kZWZpbmVkYDtcbiAgICBpZiAob3B0cy51c2VEZWZhdWx0cyA9PT0gXCJlbXB0eVwiKSB7XG4gICAgICAgIGNvbmRpdGlvbiA9IGNvZGVnZW5fMS5fIGAke2NvbmRpdGlvbn0gfHwgJHtjaGlsZERhdGF9ID09PSBudWxsIHx8ICR7Y2hpbGREYXRhfSA9PT0gXCJcImA7XG4gICAgfVxuICAgIC8vIGAke2NoaWxkRGF0YX0gPT09IHVuZGVmaW5lZGAgK1xuICAgIC8vIChvcHRzLnVzZURlZmF1bHRzID09PSBcImVtcHR5XCIgPyBgIHx8ICR7Y2hpbGREYXRhfSA9PT0gbnVsbCB8fCAke2NoaWxkRGF0YX0gPT09IFwiXCJgIDogXCJcIilcbiAgICBnZW4uaWYoY29uZGl0aW9uLCBjb2RlZ2VuXzEuXyBgJHtjaGlsZERhdGF9ID0gJHtjb2RlZ2VuXzEuc3RyaW5naWZ5KGRlZmF1bHRWYWx1ZSl9YCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVVbmlvbiA9IGV4cG9ydHMudmFsaWRhdGVBcnJheSA9IGV4cG9ydHMudXNlUGF0dGVybiA9IGV4cG9ydHMuY2FsbFZhbGlkYXRlQ29kZSA9IGV4cG9ydHMuc2NoZW1hUHJvcGVydGllcyA9IGV4cG9ydHMuYWxsU2NoZW1hUHJvcGVydGllcyA9IGV4cG9ydHMubm9Qcm9wZXJ0eUluRGF0YSA9IGV4cG9ydHMucHJvcGVydHlJbkRhdGEgPSBleHBvcnRzLmlzT3duUHJvcGVydHkgPSBleHBvcnRzLmhhc1Byb3BGdW5jID0gZXhwb3J0cy5yZXBvcnRNaXNzaW5nUHJvcCA9IGV4cG9ydHMuY2hlY2tNaXNzaW5nUHJvcCA9IGV4cG9ydHMuY2hlY2tSZXBvcnRNaXNzaW5nUHJvcCA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21waWxlL25hbWVzXCIpO1xuZnVuY3Rpb24gY2hlY2tSZXBvcnRNaXNzaW5nUHJvcChjeHQsIHByb3ApIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICBnZW4uaWYobm9Qcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3AsIGl0Lm9wdHMub3duUHJvcGVydGllcyksICgpID0+IHtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7IG1pc3NpbmdQcm9wZXJ0eTogY29kZWdlbl8xLl8gYCR7cHJvcH1gIH0sIHRydWUpO1xuICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY2hlY2tSZXBvcnRNaXNzaW5nUHJvcCA9IGNoZWNrUmVwb3J0TWlzc2luZ1Byb3A7XG5mdW5jdGlvbiBjaGVja01pc3NpbmdQcm9wKHsgZ2VuLCBkYXRhLCBpdDogeyBvcHRzIH0gfSwgcHJvcGVydGllcywgbWlzc2luZykge1xuICAgIHJldHVybiBjb2RlZ2VuXzEub3IoLi4ucHJvcGVydGllcy5tYXAoKHByb3ApID0+IGNvZGVnZW5fMS5hbmQobm9Qcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3AsIG9wdHMub3duUHJvcGVydGllcyksIGNvZGVnZW5fMS5fIGAke21pc3Npbmd9ID0gJHtwcm9wfWApKSk7XG59XG5leHBvcnRzLmNoZWNrTWlzc2luZ1Byb3AgPSBjaGVja01pc3NpbmdQcm9wO1xuZnVuY3Rpb24gcmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBtaXNzaW5nKSB7XG4gICAgY3h0LnNldFBhcmFtcyh7IG1pc3NpbmdQcm9wZXJ0eTogbWlzc2luZyB9LCB0cnVlKTtcbiAgICBjeHQuZXJyb3IoKTtcbn1cbmV4cG9ydHMucmVwb3J0TWlzc2luZ1Byb3AgPSByZXBvcnRNaXNzaW5nUHJvcDtcbmZ1bmN0aW9uIGhhc1Byb3BGdW5jKGdlbikge1xuICAgIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcImZ1bmNcIiwge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICAgIHJlZjogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICAgY29kZTogY29kZWdlbl8xLl8gYE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlgLFxuICAgIH0pO1xufVxuZXhwb3J0cy5oYXNQcm9wRnVuYyA9IGhhc1Byb3BGdW5jO1xuZnVuY3Rpb24gaXNPd25Qcm9wZXJ0eShnZW4sIGRhdGEsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIGNvZGVnZW5fMS5fIGAke2hhc1Byb3BGdW5jKGdlbil9LmNhbGwoJHtkYXRhfSwgJHtwcm9wZXJ0eX0pYDtcbn1cbmV4cG9ydHMuaXNPd25Qcm9wZXJ0eSA9IGlzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBwcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3BlcnR5LCBvd25Qcm9wZXJ0aWVzKSB7XG4gICAgY29uc3QgY29uZCA9IGNvZGVnZW5fMS5fIGAke2RhdGF9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkocHJvcGVydHkpfSAhPT0gdW5kZWZpbmVkYDtcbiAgICByZXR1cm4gb3duUHJvcGVydGllcyA/IGNvZGVnZW5fMS5fIGAke2NvbmR9ICYmICR7aXNPd25Qcm9wZXJ0eShnZW4sIGRhdGEsIHByb3BlcnR5KX1gIDogY29uZDtcbn1cbmV4cG9ydHMucHJvcGVydHlJbkRhdGEgPSBwcm9wZXJ0eUluRGF0YTtcbmZ1bmN0aW9uIG5vUHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wZXJ0eSwgb3duUHJvcGVydGllcykge1xuICAgIGNvbnN0IGNvbmQgPSBjb2RlZ2VuXzEuXyBgJHtkYXRhfSR7Y29kZWdlbl8xLmdldFByb3BlcnR5KHByb3BlcnR5KX0gPT09IHVuZGVmaW5lZGA7XG4gICAgcmV0dXJuIG93blByb3BlcnRpZXMgPyBjb2RlZ2VuXzEub3IoY29uZCwgY29kZWdlbl8xLm5vdChpc093blByb3BlcnR5KGdlbiwgZGF0YSwgcHJvcGVydHkpKSkgOiBjb25kO1xufVxuZXhwb3J0cy5ub1Byb3BlcnR5SW5EYXRhID0gbm9Qcm9wZXJ0eUluRGF0YTtcbmZ1bmN0aW9uIGFsbFNjaGVtYVByb3BlcnRpZXMoc2NoZW1hTWFwKSB7XG4gICAgcmV0dXJuIHNjaGVtYU1hcCA/IE9iamVjdC5rZXlzKHNjaGVtYU1hcCkuZmlsdGVyKChwKSA9PiBwICE9PSBcIl9fcHJvdG9fX1wiKSA6IFtdO1xufVxuZXhwb3J0cy5hbGxTY2hlbWFQcm9wZXJ0aWVzID0gYWxsU2NoZW1hUHJvcGVydGllcztcbmZ1bmN0aW9uIHNjaGVtYVByb3BlcnRpZXMoaXQsIHNjaGVtYU1hcCkge1xuICAgIHJldHVybiBhbGxTY2hlbWFQcm9wZXJ0aWVzKHNjaGVtYU1hcCkuZmlsdGVyKChwKSA9PiAhdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWFNYXBbcF0pKTtcbn1cbmV4cG9ydHMuc2NoZW1hUHJvcGVydGllcyA9IHNjaGVtYVByb3BlcnRpZXM7XG5mdW5jdGlvbiBjYWxsVmFsaWRhdGVDb2RlKHsgc2NoZW1hQ29kZSwgZGF0YSwgaXQ6IHsgZ2VuLCB0b3BTY2hlbWFSZWYsIHNjaGVtYVBhdGgsIGVycm9yUGF0aCB9LCBpdCB9LCBmdW5jLCBjb250ZXh0LCBwYXNzU2NoZW1hKSB7XG4gICAgY29uc3QgZGF0YUFuZFNjaGVtYSA9IHBhc3NTY2hlbWEgPyBjb2RlZ2VuXzEuXyBgJHtzY2hlbWFDb2RlfSwgJHtkYXRhfSwgJHt0b3BTY2hlbWFSZWZ9JHtzY2hlbWFQYXRofWAgOiBkYXRhO1xuICAgIGNvbnN0IHZhbEN4dCA9IFtcbiAgICAgICAgW25hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsIGNvZGVnZW5fMS5zdHJDb25jYXQobmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgZXJyb3JQYXRoKV0sXG4gICAgICAgIFtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YSwgaXQucGFyZW50RGF0YV0sXG4gICAgICAgIFtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5LCBpdC5wYXJlbnREYXRhUHJvcGVydHldLFxuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhLCBuYW1lc18xLmRlZmF1bHQucm9vdERhdGFdLFxuICAgIF07XG4gICAgaWYgKGl0Lm9wdHMuZHluYW1pY1JlZilcbiAgICAgICAgdmFsQ3h0LnB1c2goW25hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9ycywgbmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzXSk7XG4gICAgY29uc3QgYXJncyA9IGNvZGVnZW5fMS5fIGAke2RhdGFBbmRTY2hlbWF9LCAke2dlbi5vYmplY3QoLi4udmFsQ3h0KX1gO1xuICAgIHJldHVybiBjb250ZXh0ICE9PSBjb2RlZ2VuXzEubmlsID8gY29kZWdlbl8xLl8gYCR7ZnVuY30uY2FsbCgke2NvbnRleHR9LCAke2FyZ3N9KWAgOiBjb2RlZ2VuXzEuXyBgJHtmdW5jfSgke2FyZ3N9KWA7XG59XG5leHBvcnRzLmNhbGxWYWxpZGF0ZUNvZGUgPSBjYWxsVmFsaWRhdGVDb2RlO1xuZnVuY3Rpb24gdXNlUGF0dGVybih7IGdlbiwgaXQ6IHsgb3B0cyB9IH0sIHBhdHRlcm4pIHtcbiAgICBjb25zdCB1ID0gb3B0cy51bmljb2RlUmVnRXhwID8gXCJ1XCIgOiBcIlwiO1xuICAgIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcInBhdHRlcm5cIiwge1xuICAgICAgICBrZXk6IHBhdHRlcm4sXG4gICAgICAgIHJlZjogbmV3IFJlZ0V4cChwYXR0ZXJuLCB1KSxcbiAgICAgICAgY29kZTogY29kZWdlbl8xLl8gYG5ldyBSZWdFeHAoJHtwYXR0ZXJufSwgJHt1fSlgLFxuICAgIH0pO1xufVxuZXhwb3J0cy51c2VQYXR0ZXJuID0gdXNlUGF0dGVybjtcbmZ1bmN0aW9uIHZhbGlkYXRlQXJyYXkoY3h0KSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGlmIChpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRBcnIgPSBnZW4ubGV0KFwidmFsaWRcIiwgdHJ1ZSk7XG4gICAgICAgIHZhbGlkYXRlSXRlbXMoKCkgPT4gZ2VuLmFzc2lnbih2YWxpZEFyciwgZmFsc2UpKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkQXJyO1xuICAgIH1cbiAgICBnZW4udmFyKHZhbGlkLCB0cnVlKTtcbiAgICB2YWxpZGF0ZUl0ZW1zKCgpID0+IGdlbi5icmVhaygpKTtcbiAgICByZXR1cm4gdmFsaWQ7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyhub3RWYWxpZCkge1xuICAgICAgICBjb25zdCBsZW4gPSBnZW4uY29uc3QoXCJsZW5cIiwgY29kZWdlbl8xLl8gYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgICAgIGdlbi5mb3JSYW5nZShcImlcIiwgMCwgbGVuLCAoaSkgPT4ge1xuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcDogaSxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IHV0aWxfMS5UeXBlLk51bSxcbiAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEubm90KHZhbGlkKSwgbm90VmFsaWQpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlQXJyYXkgPSB2YWxpZGF0ZUFycmF5O1xuZnVuY3Rpb24gdmFsaWRhdGVVbmlvbihjeHQpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgY29uc3QgYWx3YXlzVmFsaWQgPSBzY2hlbWEuc29tZSgoc2NoKSA9PiB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaCkpO1xuICAgIGlmIChhbHdheXNWYWxpZCAmJiAhaXQub3B0cy51bmV2YWx1YXRlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIGZhbHNlKTtcbiAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgIGdlbi5ibG9jaygoKSA9PiBzY2hlbWEuZm9yRWFjaCgoX3NjaCwgaSkgPT4ge1xuICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgfSwgc2NoVmFsaWQpO1xuICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBjb2RlZ2VuXzEuXyBgJHt2YWxpZH0gfHwgJHtzY2hWYWxpZH1gKTtcbiAgICAgICAgY29uc3QgbWVyZ2VkID0gY3h0Lm1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoQ3h0LCBzY2hWYWxpZCk7XG4gICAgICAgIC8vIGNhbiBzaG9ydC1jaXJjdWl0IGlmIGB1bmV2YWx1YXRlZFByb3BlcnRpZXMvSXRlbXNgIG5vdCBzdXBwb3J0ZWQgKG9wdHMudW5ldmFsdWF0ZWQgIT09IHRydWUpXG4gICAgICAgIC8vIG9yIGlmIGFsbCBwcm9wZXJ0aWVzIGFuZCBpdGVtcyB3ZXJlIGV2YWx1YXRlZCAoaXQucHJvcHMgPT09IHRydWUgJiYgaXQuaXRlbXMgPT09IHRydWUpXG4gICAgICAgIGlmICghbWVyZ2VkKVxuICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5ub3QodmFsaWQpKTtcbiAgICB9KSk7XG4gICAgY3h0LnJlc3VsdCh2YWxpZCwgKCkgPT4gY3h0LnJlc2V0KCksICgpID0+IGN4dC5lcnJvcih0cnVlKSk7XG59XG5leHBvcnRzLnZhbGlkYXRlVW5pb24gPSB2YWxpZGF0ZVVuaW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVLZXl3b3JkVXNhZ2UgPSBleHBvcnRzLnZhbGlkU2NoZW1hVHlwZSA9IGV4cG9ydHMuZnVuY0tleXdvcmRDb2RlID0gZXhwb3J0cy5tYWNyb0tleXdvcmRDb2RlID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uL25hbWVzXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uLy4uL3ZvY2FidWxhcmllcy9jb2RlXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuZnVuY3Rpb24gbWFjcm9LZXl3b3JkQ29kZShjeHQsIGRlZikge1xuICAgIGNvbnN0IHsgZ2VuLCBrZXl3b3JkLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCBtYWNyb1NjaGVtYSA9IGRlZi5tYWNyby5jYWxsKGl0LnNlbGYsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCk7XG4gICAgY29uc3Qgc2NoZW1hUmVmID0gdXNlS2V5d29yZChnZW4sIGtleXdvcmQsIG1hY3JvU2NoZW1hKTtcbiAgICBpZiAoaXQub3B0cy52YWxpZGF0ZVNjaGVtYSAhPT0gZmFsc2UpXG4gICAgICAgIGl0LnNlbGYudmFsaWRhdGVTY2hlbWEobWFjcm9TY2hlbWEsIHRydWUpO1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgc2NoZW1hOiBtYWNyb1NjaGVtYSxcbiAgICAgICAgc2NoZW1hUGF0aDogY29kZWdlbl8xLm5pbCxcbiAgICAgICAgZXJyU2NoZW1hUGF0aDogYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWAsXG4gICAgICAgIHRvcFNjaGVtYVJlZjogc2NoZW1hUmVmLFxuICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgIH0sIHZhbGlkKTtcbiAgICBjeHQucGFzcyh2YWxpZCwgKCkgPT4gY3h0LmVycm9yKHRydWUpKTtcbn1cbmV4cG9ydHMubWFjcm9LZXl3b3JkQ29kZSA9IG1hY3JvS2V5d29yZENvZGU7XG5mdW5jdGlvbiBmdW5jS2V5d29yZENvZGUoY3h0LCBkZWYpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBnZW4sIGtleXdvcmQsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCAkZGF0YSwgaXQgfSA9IGN4dDtcbiAgICBjaGVja0FzeW5jS2V5d29yZChpdCwgZGVmKTtcbiAgICBjb25zdCB2YWxpZGF0ZSA9ICEkZGF0YSAmJiBkZWYuY29tcGlsZSA/IGRlZi5jb21waWxlLmNhbGwoaXQuc2VsZiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0KSA6IGRlZi52YWxpZGF0ZTtcbiAgICBjb25zdCB2YWxpZGF0ZVJlZiA9IHVzZUtleXdvcmQoZ2VuLCBrZXl3b3JkLCB2YWxpZGF0ZSk7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIik7XG4gICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsIHZhbGlkYXRlS2V5d29yZCk7XG4gICAgY3h0Lm9rKChfYSA9IGRlZi52YWxpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFsaWQpO1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlS2V5d29yZCgpIHtcbiAgICAgICAgaWYgKGRlZi5lcnJvcnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBhc3NpZ25WYWxpZCgpO1xuICAgICAgICAgICAgaWYgKGRlZi5tb2RpZnlpbmcpXG4gICAgICAgICAgICAgICAgbW9kaWZ5RGF0YShjeHQpO1xuICAgICAgICAgICAgcmVwb3J0RXJycygoKSA9PiBjeHQuZXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBydWxlRXJycyA9IGRlZi5hc3luYyA/IHZhbGlkYXRlQXN5bmMoKSA6IHZhbGlkYXRlU3luYygpO1xuICAgICAgICAgICAgaWYgKGRlZi5tb2RpZnlpbmcpXG4gICAgICAgICAgICAgICAgbW9kaWZ5RGF0YShjeHQpO1xuICAgICAgICAgICAgcmVwb3J0RXJycygoKSA9PiBhZGRFcnJzKGN4dCwgcnVsZUVycnMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUFzeW5jKCkge1xuICAgICAgICBjb25zdCBydWxlRXJycyA9IGdlbi5sZXQoXCJydWxlRXJyc1wiLCBudWxsKTtcbiAgICAgICAgZ2VuLnRyeSgoKSA9PiBhc3NpZ25WYWxpZChjb2RlZ2VuXzEuXyBgYXdhaXQgYCksIChlKSA9PiBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuaWYoY29kZWdlbl8xLl8gYCR7ZX0gaW5zdGFuY2VvZiAke2l0LlZhbGlkYXRpb25FcnJvcn1gLCAoKSA9PiBnZW4uYXNzaWduKHJ1bGVFcnJzLCBjb2RlZ2VuXzEuXyBgJHtlfS5lcnJvcnNgKSwgKCkgPT4gZ2VuLnRocm93KGUpKSk7XG4gICAgICAgIHJldHVybiBydWxlRXJycztcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVTeW5jKCkge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZUVycnMgPSBjb2RlZ2VuXzEuXyBgJHt2YWxpZGF0ZVJlZn0uZXJyb3JzYDtcbiAgICAgICAgZ2VuLmFzc2lnbih2YWxpZGF0ZUVycnMsIG51bGwpO1xuICAgICAgICBhc3NpZ25WYWxpZChjb2RlZ2VuXzEubmlsKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlRXJycztcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzaWduVmFsaWQoX2F3YWl0ID0gZGVmLmFzeW5jID8gY29kZWdlbl8xLl8gYGF3YWl0IGAgOiBjb2RlZ2VuXzEubmlsKSB7XG4gICAgICAgIGNvbnN0IHBhc3NDeHQgPSBpdC5vcHRzLnBhc3NDb250ZXh0ID8gbmFtZXNfMS5kZWZhdWx0LnRoaXMgOiBuYW1lc18xLmRlZmF1bHQuc2VsZjtcbiAgICAgICAgY29uc3QgcGFzc1NjaGVtYSA9ICEoKFwiY29tcGlsZVwiIGluIGRlZiAmJiAhJGRhdGEpIHx8IGRlZi5zY2hlbWEgPT09IGZhbHNlKTtcbiAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgY29kZWdlbl8xLl8gYCR7X2F3YWl0fSR7Y29kZV8xLmNhbGxWYWxpZGF0ZUNvZGUoY3h0LCB2YWxpZGF0ZVJlZiwgcGFzc0N4dCwgcGFzc1NjaGVtYSl9YCwgZGVmLm1vZGlmeWluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcG9ydEVycnMoZXJyb3JzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5ub3QoKF9hID0gZGVmLnZhbGlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2YWxpZCksIGVycm9ycyk7XG4gICAgfVxufVxuZXhwb3J0cy5mdW5jS2V5d29yZENvZGUgPSBmdW5jS2V5d29yZENvZGU7XG5mdW5jdGlvbiBtb2RpZnlEYXRhKGN4dCkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgIGdlbi5pZihpdC5wYXJlbnREYXRhLCAoKSA9PiBnZW4uYXNzaWduKGRhdGEsIGNvZGVnZW5fMS5fIGAke2l0LnBhcmVudERhdGF9WyR7aXQucGFyZW50RGF0YVByb3BlcnR5fV1gKSk7XG59XG5mdW5jdGlvbiBhZGRFcnJzKGN4dCwgZXJycykge1xuICAgIGNvbnN0IHsgZ2VuIH0gPSBjeHQ7XG4gICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGBBcnJheS5pc0FycmF5KCR7ZXJyc30pYCwgKCkgPT4ge1xuICAgICAgICBnZW5cbiAgICAgICAgICAgIC5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfSA9PT0gbnVsbCA/ICR7ZXJyc30gOiAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5jb25jYXQoJHtlcnJzfSlgKVxuICAgICAgICAgICAgLmFzc2lnbihuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30ubGVuZ3RoYCk7XG4gICAgICAgIGVycm9yc18xLmV4dGVuZEVycm9ycyhjeHQpO1xuICAgIH0sICgpID0+IGN4dC5lcnJvcigpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrQXN5bmNLZXl3b3JkKHsgc2NoZW1hRW52IH0sIGRlZikge1xuICAgIGlmIChkZWYuYXN5bmMgJiYgIXNjaGVtYUVudi4kYXN5bmMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIGtleXdvcmQgaW4gc3luYyBzY2hlbWFcIik7XG59XG5mdW5jdGlvbiB1c2VLZXl3b3JkKGdlbiwga2V5d29yZCwgcmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGtleXdvcmQgXCIke2tleXdvcmR9XCIgZmFpbGVkIHRvIGNvbXBpbGVgKTtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJrZXl3b3JkXCIsIHR5cGVvZiByZXN1bHQgPT0gXCJmdW5jdGlvblwiID8geyByZWY6IHJlc3VsdCB9IDogeyByZWY6IHJlc3VsdCwgY29kZTogY29kZWdlbl8xLnN0cmluZ2lmeShyZXN1bHQpIH0pO1xufVxuZnVuY3Rpb24gdmFsaWRTY2hlbWFUeXBlKHNjaGVtYSwgc2NoZW1hVHlwZSwgYWxsb3dVbmRlZmluZWQgPSBmYWxzZSkge1xuICAgIC8vIFRPRE8gYWRkIHRlc3RzXG4gICAgcmV0dXJuICghc2NoZW1hVHlwZS5sZW5ndGggfHxcbiAgICAgICAgc2NoZW1hVHlwZS5zb21lKChzdCkgPT4gc3QgPT09IFwiYXJyYXlcIlxuICAgICAgICAgICAgPyBBcnJheS5pc0FycmF5KHNjaGVtYSlcbiAgICAgICAgICAgIDogc3QgPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgICAgICA/IHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoc2NoZW1hKVxuICAgICAgICAgICAgICAgIDogdHlwZW9mIHNjaGVtYSA9PSBzdCB8fCAoYWxsb3dVbmRlZmluZWQgJiYgdHlwZW9mIHNjaGVtYSA9PSBcInVuZGVmaW5lZFwiKSkpO1xufVxuZXhwb3J0cy52YWxpZFNjaGVtYVR5cGUgPSB2YWxpZFNjaGVtYVR5cGU7XG5mdW5jdGlvbiB2YWxpZGF0ZUtleXdvcmRVc2FnZSh7IHNjaGVtYSwgb3B0cywgc2VsZiwgZXJyU2NoZW1hUGF0aCB9LCBkZWYsIGtleXdvcmQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZWYua2V5d29yZCkgPyAhZGVmLmtleXdvcmQuaW5jbHVkZXMoa2V5d29yZCkgOiBkZWYua2V5d29yZCAhPT0ga2V5d29yZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgfVxuICAgIGNvbnN0IGRlcHMgPSBkZWYuZGVwZW5kZW5jaWVzO1xuICAgIGlmIChkZXBzID09PSBudWxsIHx8IGRlcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlcHMuc29tZSgoa3dkKSA9PiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNjaGVtYSwga3dkKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXJlbnQgc2NoZW1hIG11c3QgaGF2ZSBkZXBlbmRlbmNpZXMgb2YgJHtrZXl3b3JkfTogJHtkZXBzLmpvaW4oXCIsXCIpfWApO1xuICAgIH1cbiAgICBpZiAoZGVmLnZhbGlkYXRlU2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZGVmLnZhbGlkYXRlU2NoZW1hKHNjaGVtYVtrZXl3b3JkXSk7XG4gICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBrZXl3b3JkIFwiJHtrZXl3b3JkfVwiIHZhbHVlIGlzIGludmFsaWQgYXQgcGF0aCBcIiR7ZXJyU2NoZW1hUGF0aH1cIjogYCArXG4gICAgICAgICAgICAgICAgc2VsZi5lcnJvcnNUZXh0KGRlZi52YWxpZGF0ZVNjaGVtYS5lcnJvcnMpO1xuICAgICAgICAgICAgaWYgKG9wdHMudmFsaWRhdGVTY2hlbWEgPT09IFwibG9nXCIpXG4gICAgICAgICAgICAgICAgc2VsZi5sb2dnZXIuZXJyb3IobXNnKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVLZXl3b3JkVXNhZ2UgPSB2YWxpZGF0ZUtleXdvcmRVc2FnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleXdvcmQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4dGVuZFN1YnNjaGVtYU1vZGUgPSBleHBvcnRzLmV4dGVuZFN1YnNjaGVtYURhdGEgPSBleHBvcnRzLmdldFN1YnNjaGVtYSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5mdW5jdGlvbiBnZXRTdWJzY2hlbWEoaXQsIHsga2V5d29yZCwgc2NoZW1hUHJvcCwgc2NoZW1hLCBzY2hlbWFQYXRoLCBlcnJTY2hlbWFQYXRoLCB0b3BTY2hlbWFSZWYgfSkge1xuICAgIGlmIChrZXl3b3JkICE9PSB1bmRlZmluZWQgJiYgc2NoZW1hICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdib3RoIFwia2V5d29yZFwiIGFuZCBcInNjaGVtYVwiIHBhc3NlZCwgb25seSBvbmUgYWxsb3dlZCcpO1xuICAgIH1cbiAgICBpZiAoa2V5d29yZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHNjaCA9IGl0LnNjaGVtYVtrZXl3b3JkXTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYVByb3AgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBzY2gsXG4gICAgICAgICAgICAgICAgc2NoZW1hUGF0aDogY29kZWdlbl8xLl8gYCR7aXQuc2NoZW1hUGF0aH0ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eShrZXl3b3JkKX1gLFxuICAgICAgICAgICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBzY2hbc2NoZW1hUHJvcF0sXG4gICAgICAgICAgICAgICAgc2NoZW1hUGF0aDogY29kZWdlbl8xLl8gYCR7aXQuc2NoZW1hUGF0aH0ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eShrZXl3b3JkKX0ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eShzY2hlbWFQcm9wKX1gLFxuICAgICAgICAgICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH0vJHt1dGlsXzEuZXNjYXBlRnJhZ21lbnQoc2NoZW1hUHJvcCl9YCxcbiAgICAgICAgICAgIH07XG4gICAgfVxuICAgIGlmIChzY2hlbWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoc2NoZW1hUGF0aCA9PT0gdW5kZWZpbmVkIHx8IGVyclNjaGVtYVBhdGggPT09IHVuZGVmaW5lZCB8fCB0b3BTY2hlbWFSZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInNjaGVtYVBhdGhcIiwgXCJlcnJTY2hlbWFQYXRoXCIgYW5kIFwidG9wU2NoZW1hUmVmXCIgYXJlIHJlcXVpcmVkIHdpdGggXCJzY2hlbWFcIicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICBzY2hlbWFQYXRoLFxuICAgICAgICAgICAgdG9wU2NoZW1hUmVmLFxuICAgICAgICAgICAgZXJyU2NoZW1hUGF0aCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdlaXRoZXIgXCJrZXl3b3JkXCIgb3IgXCJzY2hlbWFcIiBtdXN0IGJlIHBhc3NlZCcpO1xufVxuZXhwb3J0cy5nZXRTdWJzY2hlbWEgPSBnZXRTdWJzY2hlbWE7XG5mdW5jdGlvbiBleHRlbmRTdWJzY2hlbWFEYXRhKHN1YnNjaGVtYSwgaXQsIHsgZGF0YVByb3AsIGRhdGFQcm9wVHlwZTogZHBUeXBlLCBkYXRhLCBkYXRhVHlwZXMsIHByb3BlcnR5TmFtZSB9KSB7XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCAmJiBkYXRhUHJvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYm90aCBcImRhdGFcIiBhbmQgXCJkYXRhUHJvcFwiIHBhc3NlZCwgb25seSBvbmUgYWxsb3dlZCcpO1xuICAgIH1cbiAgICBjb25zdCB7IGdlbiB9ID0gaXQ7XG4gICAgaWYgKGRhdGFQcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgeyBlcnJvclBhdGgsIGRhdGFQYXRoQXJyLCBvcHRzIH0gPSBpdDtcbiAgICAgICAgY29uc3QgbmV4dERhdGEgPSBnZW4ubGV0KFwiZGF0YVwiLCBjb2RlZ2VuXzEuXyBgJHtpdC5kYXRhfSR7Y29kZWdlbl8xLmdldFByb3BlcnR5KGRhdGFQcm9wKX1gLCB0cnVlKTtcbiAgICAgICAgZGF0YUNvbnRleHRQcm9wcyhuZXh0RGF0YSk7XG4gICAgICAgIHN1YnNjaGVtYS5lcnJvclBhdGggPSBjb2RlZ2VuXzEuc3RyIGAke2Vycm9yUGF0aH0ke3V0aWxfMS5nZXRFcnJvclBhdGgoZGF0YVByb3AsIGRwVHlwZSwgb3B0cy5qc1Byb3BlcnR5U3ludGF4KX1gO1xuICAgICAgICBzdWJzY2hlbWEucGFyZW50RGF0YVByb3BlcnR5ID0gY29kZWdlbl8xLl8gYCR7ZGF0YVByb3B9YDtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFQYXRoQXJyID0gWy4uLmRhdGFQYXRoQXJyLCBzdWJzY2hlbWEucGFyZW50RGF0YVByb3BlcnR5XTtcbiAgICB9XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBuZXh0RGF0YSA9IGRhdGEgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSA/IGRhdGEgOiBnZW4ubGV0KFwiZGF0YVwiLCBkYXRhLCB0cnVlKTsgLy8gcmVwbGFjZWFibGUgaWYgdXNlZCBvbmNlP1xuICAgICAgICBkYXRhQ29udGV4dFByb3BzKG5leHREYXRhKTtcbiAgICAgICAgaWYgKHByb3BlcnR5TmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgc3Vic2NoZW1hLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcbiAgICAgICAgLy8gVE9ETyBzb21ldGhpbmcgaXMgcG9zc2libHkgd3JvbmcgaGVyZSB3aXRoIG5vdCBjaGFuZ2luZyBwYXJlbnREYXRhUHJvcGVydHkgYW5kIG5vdCBhcHBlbmRpbmcgZGF0YVBhdGhBcnJcbiAgICB9XG4gICAgaWYgKGRhdGFUeXBlcylcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFUeXBlcyA9IGRhdGFUeXBlcztcbiAgICBmdW5jdGlvbiBkYXRhQ29udGV4dFByb3BzKF9uZXh0RGF0YSkge1xuICAgICAgICBzdWJzY2hlbWEuZGF0YSA9IF9uZXh0RGF0YTtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFMZXZlbCA9IGl0LmRhdGFMZXZlbCArIDE7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhVHlwZXMgPSBbXTtcbiAgICAgICAgaXQuZGVmaW5lZFByb3BlcnRpZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHN1YnNjaGVtYS5wYXJlbnREYXRhID0gaXQuZGF0YTtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFOYW1lcyA9IFsuLi5pdC5kYXRhTmFtZXMsIF9uZXh0RGF0YV07XG4gICAgfVxufVxuZXhwb3J0cy5leHRlbmRTdWJzY2hlbWFEYXRhID0gZXh0ZW5kU3Vic2NoZW1hRGF0YTtcbmZ1bmN0aW9uIGV4dGVuZFN1YnNjaGVtYU1vZGUoc3Vic2NoZW1hLCB7IGp0ZERpc2NyaW1pbmF0b3IsIGp0ZE1ldGFkYXRhLCBjb21wb3NpdGVSdWxlLCBjcmVhdGVFcnJvcnMsIGFsbEVycm9ycyB9KSB7XG4gICAgaWYgKGNvbXBvc2l0ZVJ1bGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgc3Vic2NoZW1hLmNvbXBvc2l0ZVJ1bGUgPSBjb21wb3NpdGVSdWxlO1xuICAgIGlmIChjcmVhdGVFcnJvcnMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgc3Vic2NoZW1hLmNyZWF0ZUVycm9ycyA9IGNyZWF0ZUVycm9ycztcbiAgICBpZiAoYWxsRXJyb3JzICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHN1YnNjaGVtYS5hbGxFcnJvcnMgPSBhbGxFcnJvcnM7XG4gICAgc3Vic2NoZW1hLmp0ZERpc2NyaW1pbmF0b3IgPSBqdGREaXNjcmltaW5hdG9yOyAvLyBub3QgaW5oZXJpdGVkXG4gICAgc3Vic2NoZW1hLmp0ZE1ldGFkYXRhID0ganRkTWV0YWRhdGE7IC8vIG5vdCBpbmhlcml0ZWRcbn1cbmV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hTW9kZSA9IGV4dGVuZFN1YnNjaGVtYU1vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY2hlbWEuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBkbyBub3QgZWRpdCAuanMgZmlsZXMgZGlyZWN0bHkgLSBlZGl0IHNyYy9pbmRleC5qc3RcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0Jykge1xuICAgIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgbGVuZ3RoLCBpLCBrZXlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG5cblxuICAgIGlmIChhLmNvbnN0cnVjdG9yID09PSBSZWdFeHApIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcbiAgICBpZiAoYS52YWx1ZU9mICE9PSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YpIHJldHVybiBhLnZhbHVlT2YoKSA9PT0gYi52YWx1ZU9mKCk7XG4gICAgaWYgKGEudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoIWVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gdHJ1ZSBpZiBib3RoIE5hTiwgZmFsc2Ugb3RoZXJ3aXNlXG4gIHJldHVybiBhIT09YSAmJiBiIT09Yjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0cmF2ZXJzZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNjaGVtYSwgb3B0cywgY2IpIHtcbiAgLy8gTGVnYWN5IHN1cHBvcnQgZm9yIHYwLjMuMSBhbmQgZWFybGllci5cbiAgaWYgKHR5cGVvZiBvcHRzID09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgY2IgPSBvcHRzLmNiIHx8IGNiO1xuICB2YXIgcHJlID0gKHR5cGVvZiBjYiA9PSAnZnVuY3Rpb24nKSA/IGNiIDogY2IucHJlIHx8IGZ1bmN0aW9uKCkge307XG4gIHZhciBwb3N0ID0gY2IucG9zdCB8fCBmdW5jdGlvbigpIHt9O1xuXG4gIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaGVtYSwgJycsIHNjaGVtYSk7XG59O1xuXG5cbnRyYXZlcnNlLmtleXdvcmRzID0ge1xuICBhZGRpdGlvbmFsSXRlbXM6IHRydWUsXG4gIGl0ZW1zOiB0cnVlLFxuICBjb250YWluczogdHJ1ZSxcbiAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHRydWUsXG4gIHByb3BlcnR5TmFtZXM6IHRydWUsXG4gIG5vdDogdHJ1ZSxcbiAgaWY6IHRydWUsXG4gIHRoZW46IHRydWUsXG4gIGVsc2U6IHRydWVcbn07XG5cbnRyYXZlcnNlLmFycmF5S2V5d29yZHMgPSB7XG4gIGl0ZW1zOiB0cnVlLFxuICBhbGxPZjogdHJ1ZSxcbiAgYW55T2Y6IHRydWUsXG4gIG9uZU9mOiB0cnVlXG59O1xuXG50cmF2ZXJzZS5wcm9wc0tleXdvcmRzID0ge1xuICAkZGVmczogdHJ1ZSxcbiAgZGVmaW5pdGlvbnM6IHRydWUsXG4gIHByb3BlcnRpZXM6IHRydWUsXG4gIHBhdHRlcm5Qcm9wZXJ0aWVzOiB0cnVlLFxuICBkZXBlbmRlbmNpZXM6IHRydWVcbn07XG5cbnRyYXZlcnNlLnNraXBLZXl3b3JkcyA9IHtcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgZW51bTogdHJ1ZSxcbiAgY29uc3Q6IHRydWUsXG4gIHJlcXVpcmVkOiB0cnVlLFxuICBtYXhpbXVtOiB0cnVlLFxuICBtaW5pbXVtOiB0cnVlLFxuICBleGNsdXNpdmVNYXhpbXVtOiB0cnVlLFxuICBleGNsdXNpdmVNaW5pbXVtOiB0cnVlLFxuICBtdWx0aXBsZU9mOiB0cnVlLFxuICBtYXhMZW5ndGg6IHRydWUsXG4gIG1pbkxlbmd0aDogdHJ1ZSxcbiAgcGF0dGVybjogdHJ1ZSxcbiAgZm9ybWF0OiB0cnVlLFxuICBtYXhJdGVtczogdHJ1ZSxcbiAgbWluSXRlbXM6IHRydWUsXG4gIHVuaXF1ZUl0ZW1zOiB0cnVlLFxuICBtYXhQcm9wZXJ0aWVzOiB0cnVlLFxuICBtaW5Qcm9wZXJ0aWVzOiB0cnVlXG59O1xuXG5cbmZ1bmN0aW9uIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCkge1xuICBpZiAoc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgIHByZShzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpO1xuICAgIGZvciAodmFyIGtleSBpbiBzY2hlbWEpIHtcbiAgICAgIHZhciBzY2ggPSBzY2hlbWFba2V5XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaCkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0cmF2ZXJzZS5hcnJheUtleXdvcmRzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNjaC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaFtpXSwganNvblB0ciArICcvJyArIGtleSArICcvJyArIGksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hLCBpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gdHJhdmVyc2UucHJvcHNLZXl3b3Jkcykge1xuICAgICAgICBpZiAoc2NoICYmIHR5cGVvZiBzY2ggPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNjaClcbiAgICAgICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaFtwcm9wXSwganNvblB0ciArICcvJyArIGtleSArICcvJyArIGVzY2FwZUpzb25QdHIocHJvcCksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hLCBwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gdHJhdmVyc2Uua2V5d29yZHMgfHwgKG9wdHMuYWxsS2V5cyAmJiAhKGtleSBpbiB0cmF2ZXJzZS5za2lwS2V5d29yZHMpKSkge1xuICAgICAgICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2gsIGpzb25QdHIgKyAnLycgKyBrZXksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9zdChzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZXNjYXBlSnNvblB0cihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKTtcbn1cbiIsIi8qKiBAbGljZW5zZSBVUkkuanMgdjQuNC4xIChjKSAyMDExIEdhcnkgQ291cnQuIExpY2Vuc2U6IGh0dHA6Ly9naXRodWIuY29tL2dhcnljb3VydC91cmktanMgKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5VUkkgPSBnbG9iYWwuVVJJIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBtZXJnZSgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc2V0cyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBzZXRzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGlmIChzZXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc2V0c1swXSA9IHNldHNbMF0uc2xpY2UoMCwgLTEpO1xuICAgICAgICB2YXIgeGwgPSBzZXRzLmxlbmd0aCAtIDE7XG4gICAgICAgIGZvciAodmFyIHggPSAxOyB4IDwgeGw7ICsreCkge1xuICAgICAgICAgICAgc2V0c1t4XSA9IHNldHNbeF0uc2xpY2UoMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHNldHNbeGxdID0gc2V0c1t4bF0uc2xpY2UoMSk7XG4gICAgICAgIHJldHVybiBzZXRzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZXRzWzBdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN1YmV4cChzdHIpIHtcbiAgICByZXR1cm4gXCIoPzpcIiArIHN0ciArIFwiKVwiO1xufVxuZnVuY3Rpb24gdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gbyA9PT0gdW5kZWZpbmVkID8gXCJ1bmRlZmluZWRcIiA6IG8gPT09IG51bGwgPyBcIm51bGxcIiA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zcGxpdChcIiBcIikucG9wKCkuc3BsaXQoXCJdXCIpLnNoaWZ0KCkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHRvVXBwZXJDYXNlKHN0cikge1xuICAgIHJldHVybiBzdHIudG9VcHBlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gdW5kZWZpbmVkICYmIG9iaiAhPT0gbnVsbCA/IG9iaiBpbnN0YW5jZW9mIEFycmF5ID8gb2JqIDogdHlwZW9mIG9iai5sZW5ndGggIT09IFwibnVtYmVyXCIgfHwgb2JqLnNwbGl0IHx8IG9iai5zZXRJbnRlcnZhbCB8fCBvYmouY2FsbCA/IFtvYmpdIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqKSA6IFtdO1xufVxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7XG4gICAgdmFyIG9iaiA9IHRhcmdldDtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gYnVpbGRFeHBzKGlzSVJJKSB7XG4gICAgdmFyIEFMUEhBJCQgPSBcIltBLVphLXpdXCIsXG4gICAgICAgIENSJCA9IFwiW1xcXFx4MERdXCIsXG4gICAgICAgIERJR0lUJCQgPSBcIlswLTldXCIsXG4gICAgICAgIERRVU9URSQkID0gXCJbXFxcXHgyMl1cIixcbiAgICAgICAgSEVYRElHJCQgPSBtZXJnZShESUdJVCQkLCBcIltBLUZhLWZdXCIpLFxuICAgICAgICAvL2Nhc2UtaW5zZW5zaXRpdmVcbiAgICBMRiQkID0gXCJbXFxcXHgwQV1cIixcbiAgICAgICAgU1AkJCA9IFwiW1xcXFx4MjBdXCIsXG4gICAgICAgIFBDVF9FTkNPREVEJCA9IHN1YmV4cChzdWJleHAoXCIlW0VGZWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVbODlBLUZhLWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpKSxcbiAgICAgICAgLy9leHBhbmRlZFxuICAgIEdFTl9ERUxJTVMkJCA9IFwiW1xcXFw6XFxcXC9cXFxcP1xcXFwjXFxcXFtcXFxcXVxcXFxAXVwiLFxuICAgICAgICBTVUJfREVMSU1TJCQgPSBcIltcXFxcIVxcXFwkXFxcXCZcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcO1xcXFw9XVwiLFxuICAgICAgICBSRVNFUlZFRCQkID0gbWVyZ2UoR0VOX0RFTElNUyQkLCBTVUJfREVMSU1TJCQpLFxuICAgICAgICBVQ1NDSEFSJCQgPSBpc0lSSSA/IFwiW1xcXFx4QTAtXFxcXHUyMDBEXFxcXHUyMDEwLVxcXFx1MjAyOVxcXFx1MjAyRi1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl1cIiA6IFwiW11cIixcbiAgICAgICAgLy9zdWJzZXQsIGV4Y2x1ZGVzIGJpZGkgY29udHJvbCBjaGFyYWN0ZXJzXG4gICAgSVBSSVZBVEUkJCA9IGlzSVJJID8gXCJbXFxcXHVFMDAwLVxcXFx1RjhGRl1cIiA6IFwiW11cIixcbiAgICAgICAgLy9zdWJzZXRcbiAgICBVTlJFU0VSVkVEJCQgPSBtZXJnZShBTFBIQSQkLCBESUdJVCQkLCBcIltcXFxcLVxcXFwuXFxcXF9cXFxcfl1cIiwgVUNTQ0hBUiQkKSxcbiAgICAgICAgU0NIRU1FJCA9IHN1YmV4cChBTFBIQSQkICsgbWVyZ2UoQUxQSEEkJCwgRElHSVQkJCwgXCJbXFxcXCtcXFxcLVxcXFwuXVwiKSArIFwiKlwiKSxcbiAgICAgICAgVVNFUklORk8kID0gc3ViZXhwKHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOl1cIikpICsgXCIqXCIpLFxuICAgICAgICBERUNfT0NURVQkID0gc3ViZXhwKHN1YmV4cChcIjI1WzAtNV1cIikgKyBcInxcIiArIHN1YmV4cChcIjJbMC00XVwiICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIjFcIiArIERJR0lUJCQgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiWzEtOV1cIiArIERJR0lUJCQpICsgXCJ8XCIgKyBESUdJVCQkKSxcbiAgICAgICAgREVDX09DVEVUX1JFTEFYRUQkID0gc3ViZXhwKHN1YmV4cChcIjI1WzAtNV1cIikgKyBcInxcIiArIHN1YmV4cChcIjJbMC00XVwiICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIjFcIiArIERJR0lUJCQgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiMD9bMS05XVwiICsgRElHSVQkJCkgKyBcInwwPzA/XCIgKyBESUdJVCQkKSxcbiAgICAgICAgLy9yZWxheGVkIHBhcnNpbmcgcnVsZXNcbiAgICBJUFY0QUREUkVTUyQgPSBzdWJleHAoREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkKSxcbiAgICAgICAgSDE2JCA9IHN1YmV4cChIRVhESUckJCArIFwiezEsNH1cIiksXG4gICAgICAgIExTMzIkID0gc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiICsgSDE2JCkgKyBcInxcIiArIElQVjRBRERSRVNTJCksXG4gICAgICAgIElQVjZBRERSRVNTMSQgPSBzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7Nn1cIiArIExTMzIkKSxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICA2KCBoMTYgXCI6XCIgKSBsczMyXG4gICAgSVBWNkFERFJFU1MyJCA9IHN1YmV4cChcIlxcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezV9XCIgKyBMUzMyJCksXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgIFwiOjpcIiA1KCBoMTYgXCI6XCIgKSBsczMyXG4gICAgSVBWNkFERFJFU1MzJCA9IHN1YmV4cChzdWJleHAoSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcIns0fVwiICsgTFMzMiQpLFxuICAgICAgICAvL1sgICAgICAgICAgICAgICBoMTYgXSBcIjo6XCIgNCggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTNCQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsMX1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7M31cIiArIExTMzIkKSxcbiAgICAgICAgLy9bICoxKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgMyggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTNSQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsMn1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7Mn1cIiArIExTMzIkKSxcbiAgICAgICAgLy9bICoyKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgMiggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTNiQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsM31cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgSDE2JCArIFwiXFxcXDpcIiArIExTMzIkKSxcbiAgICAgICAgLy9bICozKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgaDE2IFwiOlwiICAgbHMzMlxuICAgIElQVjZBRERSRVNTNyQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsNH1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgTFMzMiQpLFxuICAgICAgICAvL1sgKjQoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICAgICAgICAgICAgbHMzMlxuICAgIElQVjZBRERSRVNTOCQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsNX1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgSDE2JCksXG4gICAgICAgIC8vWyAqNSggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgICAgICAgICAgICBoMTZcbiAgICBJUFY2QUREUkVTUzkkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDZ9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiksXG4gICAgICAgIC8vWyAqNiggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiXG4gICAgSVBWNkFERFJFU1MkID0gc3ViZXhwKFtJUFY2QUREUkVTUzEkLCBJUFY2QUREUkVTUzIkLCBJUFY2QUREUkVTUzMkLCBJUFY2QUREUkVTUzQkLCBJUFY2QUREUkVTUzUkLCBJUFY2QUREUkVTUzYkLCBJUFY2QUREUkVTUzckLCBJUFY2QUREUkVTUzgkLCBJUFY2QUREUkVTUzkkXS5qb2luKFwifFwiKSksXG4gICAgICAgIFpPTkVJRCQgPSBzdWJleHAoc3ViZXhwKFVOUkVTRVJWRUQkJCArIFwifFwiICsgUENUX0VOQ09ERUQkKSArIFwiK1wiKSxcbiAgICAgICAgLy9SRkMgNjg3NFxuICAgIElQVjZBRERSWiQgPSBzdWJleHAoSVBWNkFERFJFU1MkICsgXCJcXFxcJTI1XCIgKyBaT05FSUQkKSxcbiAgICAgICAgLy9SRkMgNjg3NFxuICAgIElQVjZBRERSWl9SRUxBWEVEJCA9IHN1YmV4cChJUFY2QUREUkVTUyQgKyBzdWJleHAoXCJcXFxcJTI1fFxcXFwlKD8hXCIgKyBIRVhESUckJCArIFwiezJ9KVwiKSArIFpPTkVJRCQpLFxuICAgICAgICAvL1JGQyA2ODc0LCB3aXRoIHJlbGF4ZWQgcGFyc2luZyBydWxlc1xuICAgIElQVkZVVFVSRSQgPSBzdWJleHAoXCJbdlZdXCIgKyBIRVhESUckJCArIFwiK1xcXFwuXCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpdXCIpICsgXCIrXCIpLFxuICAgICAgICBJUF9MSVRFUkFMJCA9IHN1YmV4cChcIlxcXFxbXCIgKyBzdWJleHAoSVBWNkFERFJaX1JFTEFYRUQkICsgXCJ8XCIgKyBJUFY2QUREUkVTUyQgKyBcInxcIiArIElQVkZVVFVSRSQpICsgXCJcXFxcXVwiKSxcbiAgICAgICAgLy9SRkMgNjg3NFxuICAgIFJFR19OQU1FJCA9IHN1YmV4cChzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCkpICsgXCIqXCIpLFxuICAgICAgICBIT1NUJCA9IHN1YmV4cChJUF9MSVRFUkFMJCArIFwifFwiICsgSVBWNEFERFJFU1MkICsgXCIoPyFcIiArIFJFR19OQU1FJCArIFwiKVwiICsgXCJ8XCIgKyBSRUdfTkFNRSQpLFxuICAgICAgICBQT1JUJCA9IHN1YmV4cChESUdJVCQkICsgXCIqXCIpLFxuICAgICAgICBBVVRIT1JJVFkkID0gc3ViZXhwKHN1YmV4cChVU0VSSU5GTyQgKyBcIkBcIikgKyBcIj9cIiArIEhPU1QkICsgc3ViZXhwKFwiXFxcXDpcIiArIFBPUlQkKSArIFwiP1wiKSxcbiAgICAgICAgUENIQVIkID0gc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBdXCIpKSxcbiAgICAgICAgU0VHTUVOVCQgPSBzdWJleHAoUENIQVIkICsgXCIqXCIpLFxuICAgICAgICBTRUdNRU5UX05aJCA9IHN1YmV4cChQQ0hBUiQgKyBcIitcIiksXG4gICAgICAgIFNFR01FTlRfTlpfTkMkID0gc3ViZXhwKHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcQF1cIikpICsgXCIrXCIpLFxuICAgICAgICBQQVRIX0FCRU1QVFkkID0gc3ViZXhwKHN1YmV4cChcIlxcXFwvXCIgKyBTRUdNRU5UJCkgKyBcIipcIiksXG4gICAgICAgIFBBVEhfQUJTT0xVVEUkID0gc3ViZXhwKFwiXFxcXC9cIiArIHN1YmV4cChTRUdNRU5UX05aJCArIFBBVEhfQUJFTVBUWSQpICsgXCI/XCIpLFxuICAgICAgICAvL3NpbXBsaWZpZWRcbiAgICBQQVRIX05PU0NIRU1FJCA9IHN1YmV4cChTRUdNRU5UX05aX05DJCArIFBBVEhfQUJFTVBUWSQpLFxuICAgICAgICAvL3NpbXBsaWZpZWRcbiAgICBQQVRIX1JPT1RMRVNTJCA9IHN1YmV4cChTRUdNRU5UX05aJCArIFBBVEhfQUJFTVBUWSQpLFxuICAgICAgICAvL3NpbXBsaWZpZWRcbiAgICBQQVRIX0VNUFRZJCA9IFwiKD8hXCIgKyBQQ0hBUiQgKyBcIilcIixcbiAgICAgICAgUEFUSCQgPSBzdWJleHAoUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfTk9TQ0hFTUUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuICAgICAgICBRVUVSWSQgPSBzdWJleHAoc3ViZXhwKFBDSEFSJCArIFwifFwiICsgbWVyZ2UoXCJbXFxcXC9cXFxcP11cIiwgSVBSSVZBVEUkJCkpICsgXCIqXCIpLFxuICAgICAgICBGUkFHTUVOVCQgPSBzdWJleHAoc3ViZXhwKFBDSEFSJCArIFwifFtcXFxcL1xcXFw/XVwiKSArIFwiKlwiKSxcbiAgICAgICAgSElFUl9QQVJUJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvXCIgKyBBVVRIT1JJVFkkICsgUEFUSF9BQkVNUFRZJCkgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuICAgICAgICBVUkkkID0gc3ViZXhwKFNDSEVNRSQgKyBcIlxcXFw6XCIgKyBISUVSX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjXCIgKyBGUkFHTUVOVCQpICsgXCI/XCIpLFxuICAgICAgICBSRUxBVElWRV9QQVJUJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvXCIgKyBBVVRIT1JJVFkkICsgUEFUSF9BQkVNUFRZJCkgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuICAgICAgICBSRUxBVElWRSQgPSBzdWJleHAoUkVMQVRJVkVfUEFSVCQgKyBzdWJleHAoXCJcXFxcP1wiICsgUVVFUlkkKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCNcIiArIEZSQUdNRU5UJCkgKyBcIj9cIiksXG4gICAgICAgIFVSSV9SRUZFUkVOQ0UkID0gc3ViZXhwKFVSSSQgKyBcInxcIiArIFJFTEFUSVZFJCksXG4gICAgICAgIEFCU09MVVRFX1VSSSQgPSBzdWJleHAoU0NIRU1FJCArIFwiXFxcXDpcIiArIEhJRVJfUEFSVCQgKyBzdWJleHAoXCJcXFxcP1wiICsgUVVFUlkkKSArIFwiP1wiKSxcbiAgICAgICAgR0VORVJJQ19SRUYkID0gXCJeKFwiICsgU0NIRU1FJCArIFwiKVxcXFw6XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjKFwiICsgRlJBR01FTlQkICsgXCIpXCIpICsgXCI/JFwiLFxuICAgICAgICBSRUxBVElWRV9SRUYkID0gXCJeKCl7MH1cIiArIHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvKFwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/KVwiKSArIFwiPyhcIiArIFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9FTVBUWSQgKyBcIilcIikgKyBzdWJleHAoXCJcXFxcPyhcIiArIFFVRVJZJCArIFwiKVwiKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCMoXCIgKyBGUkFHTUVOVCQgKyBcIilcIikgKyBcIj8kXCIsXG4gICAgICAgIEFCU09MVVRFX1JFRiQgPSBcIl4oXCIgKyBTQ0hFTUUkICsgXCIpXFxcXDpcIiArIHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvKFwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/KVwiKSArIFwiPyhcIiArIFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQgKyBcIilcIikgKyBzdWJleHAoXCJcXFxcPyhcIiArIFFVRVJZJCArIFwiKVwiKSArIFwiPyRcIixcbiAgICAgICAgU0FNRURPQ19SRUYkID0gXCJeXCIgKyBzdWJleHAoXCJcXFxcIyhcIiArIEZSQUdNRU5UJCArIFwiKVwiKSArIFwiPyRcIixcbiAgICAgICAgQVVUSE9SSVRZX1JFRiQgPSBcIl5cIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPyRcIjtcbiAgICByZXR1cm4ge1xuICAgICAgICBOT1RfU0NIRU1FOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIEFMUEhBJCQsIERJR0lUJCQsIFwiW1xcXFwrXFxcXC1cXFxcLl1cIiksIFwiZ1wiKSxcbiAgICAgICAgTk9UX1VTRVJJTkZPOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFw6XVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX0hPU1Q6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXFtcXFxcXVxcXFw6XVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX1BBVEg6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXC9cXFxcOlxcXFxAXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX1BBVEhfTk9TQ0hFTUU6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXC9cXFxcQF1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9RVUVSWTogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOlxcXFxAXFxcXC9cXFxcP11cIiwgSVBSSVZBVEUkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX0ZSQUdNRU5UOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJV1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBcXFxcL1xcXFw/XVwiKSwgXCJnXCIpLFxuICAgICAgICBFU0NBUEU6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIFVOUkVTRVJWRUQ6IG5ldyBSZWdFeHAoVU5SRVNFUlZFRCQkLCBcImdcIiksXG4gICAgICAgIE9USEVSX0NIQVJTOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJV1cIiwgVU5SRVNFUlZFRCQkLCBSRVNFUlZFRCQkKSwgXCJnXCIpLFxuICAgICAgICBQQ1RfRU5DT0RFRDogbmV3IFJlZ0V4cChQQ1RfRU5DT0RFRCQsIFwiZ1wiKSxcbiAgICAgICAgSVBWNEFERFJFU1M6IG5ldyBSZWdFeHAoXCJeKFwiICsgSVBWNEFERFJFU1MkICsgXCIpJFwiKSxcbiAgICAgICAgSVBWNkFERFJFU1M6IG5ldyBSZWdFeHAoXCJeXFxcXFs/KFwiICsgSVBWNkFERFJFU1MkICsgXCIpXCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXCUyNXxcXFxcJSg/IVwiICsgSEVYRElHJCQgKyBcInsyfSlcIikgKyBcIihcIiArIFpPTkVJRCQgKyBcIilcIikgKyBcIj9cXFxcXT8kXCIpIC8vUkZDIDY4NzQsIHdpdGggcmVsYXhlZCBwYXJzaW5nIHJ1bGVzXG4gICAgfTtcbn1cbnZhciBVUklfUFJPVE9DT0wgPSBidWlsZEV4cHMoZmFsc2UpO1xuXG52YXIgSVJJX1BST1RPQ09MID0gYnVpbGRFeHBzKHRydWUpO1xuXG52YXIgc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHtcbiAgICAgIHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICAgIH1cbiAgfTtcbn0oKTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIHRvQ29uc3VtYWJsZUFycmF5ID0gZnVuY3Rpb24gKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgIHJldHVybiBhcnIyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGFycik7XG4gIH1cbn07XG5cbi8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblxudmFyIG1heEludCA9IDIxNDc0ODM2NDc7IC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuLyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xudmFyIGJhc2UgPSAzNjtcbnZhciB0TWluID0gMTtcbnZhciB0TWF4ID0gMjY7XG52YXIgc2tldyA9IDM4O1xudmFyIGRhbXAgPSA3MDA7XG52YXIgaW5pdGlhbEJpYXMgPSA3MjtcbnZhciBpbml0aWFsTiA9IDEyODsgLy8gMHg4MFxudmFyIGRlbGltaXRlciA9ICctJzsgLy8gJ1xceDJEJ1xuXG4vKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xudmFyIHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vO1xudmFyIHJlZ2V4Tm9uQVNDSUkgPSAvW15cXDAtXFx4N0VdLzsgLy8gbm9uLUFTQ0lJIGNoYXJzXG52YXIgcmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZzsgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG4vKiogRXJyb3IgbWVzc2FnZXMgKi9cbnZhciBlcnJvcnMgPSB7XG5cdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG59O1xuXG4vKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG52YXIgYmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZXJyb3IkMSh0eXBlKSB7XG5cdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG59XG5cbi8qKlxuICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuICogaXRlbS5cbiAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHR2YXIgcmVzdWx0ID0gW107XG5cdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcbiAqIGFkZHJlc3Nlcy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG4gKiBjaGFyYWN0ZXIuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuICogZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHR2YXIgcmVzdWx0ID0gJyc7XG5cdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdH1cblx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcbiAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuICogbWF0Y2hpbmcgVVRGLTE2LlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG4gKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBkZWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG4gKi9cbmZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdHZhciBvdXRwdXQgPSBbXTtcblx0dmFyIGNvdW50ZXIgPSAwO1xuXHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHR2YXIgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdC8vIEl0J3MgYSBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXIuXG5cdFx0XHR2YXIgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7XG5cdFx0XHRcdC8vIExvdyBzdXJyb2dhdGUuXG5cdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJdCdzIGFuIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZVxuXHRcdFx0XHQvLyBuZXh0IGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpci5cblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG4gKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBlbmNvZGVcbiAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG4gKi9cbnZhciB1Y3MyZW5jb2RlID0gZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQuYXBwbHkoU3RyaW5nLCB0b0NvbnN1bWFibGVBcnJheShhcnJheSkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG4gKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cbiAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcbiAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuICovXG52YXIgYmFzaWNUb0RpZ2l0ID0gZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRpZiAoY29kZVBvaW50IC0gMHgzMCA8IDB4MEEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHgxNjtcblx0fVxuXHRpZiAoY29kZVBvaW50IC0gMHg0MSA8IDB4MUEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHg0MTtcblx0fVxuXHRpZiAoY29kZVBvaW50IC0gMHg2MSA8IDB4MUEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHg2MTtcblx0fVxuXHRyZXR1cm4gYmFzZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG4gKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG4gKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cbiAqL1xudmFyIGRpZ2l0VG9CYXNpYyA9IGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcbn07XG5cbi8qKlxuICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgYWRhcHQgPSBmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0dmFyIGsgPSAwO1xuXHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdGZvciAoOyAvKiBubyBpbml0aWFsaXphdGlvbiAqL2RlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHR9XG5cdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuICogc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICovXG52YXIgZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdC8vIERvbid0IHVzZSBVQ1MtMi5cblx0dmFyIG91dHB1dCA9IFtdO1xuXHR2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cdHZhciBpID0gMDtcblx0dmFyIG4gPSBpbml0aWFsTjtcblx0dmFyIGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0dmFyIGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdGJhc2ljID0gMDtcblx0fVxuXG5cdGZvciAodmFyIGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdGVycm9yJDEoJ25vdC1iYXNpYycpO1xuXHRcdH1cblx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0fVxuXG5cdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRmb3IgKHZhciBpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7KSAvKiBubyBmaW5hbCBleHByZXNzaW9uICove1xuXG5cdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHR2YXIgb2xkaSA9IGk7XG5cdFx0Zm9yICh2YXIgdyA9IDEsIGsgPSBiYXNlOzsgLyogbm8gY29uZGl0aW9uICovayArPSBiYXNlKSB7XG5cblx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRlcnJvciQxKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRlcnJvciQxKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdHZhciB0ID0gayA8PSBiaWFzID8gdE1pbiA6IGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXM7XG5cblx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdGVycm9yJDEoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblx0XHR9XG5cblx0XHR2YXIgb3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHR9XG5cblx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdGkgJT0gb3V0O1xuXG5cdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dC5cblx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cdH1cblxuXHRyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQuYXBwbHkoU3RyaW5nLCBvdXRwdXQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICovXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdHZhciBvdXRwdXQgPSBbXTtcblxuXHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBhbiBhcnJheSBvZiBVbmljb2RlIGNvZGUgcG9pbnRzLlxuXHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdC8vIENhY2hlIHRoZSBsZW5ndGguXG5cdHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZS5cblx0dmFyIG4gPSBpbml0aWFsTjtcblx0dmFyIGRlbHRhID0gMDtcblx0dmFyIGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzLlxuXHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG5cdHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuXHR2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cblx0dHJ5IHtcblx0XHRmb3IgKHZhciBfaXRlcmF0b3IgPSBpbnB1dFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcblx0XHRcdHZhciBfY3VycmVudFZhbHVlMiA9IF9zdGVwLnZhbHVlO1xuXG5cdFx0XHRpZiAoX2N1cnJlbnRWYWx1ZTIgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShfY3VycmVudFZhbHVlMikpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0X2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuXHRcdF9pdGVyYXRvckVycm9yID0gZXJyO1xuXHR9IGZpbmFsbHkge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuXHRcdFx0XHRfaXRlcmF0b3IucmV0dXJuKCk7XG5cdFx0XHR9XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuXHRcdFx0XHR0aHJvdyBfaXRlcmF0b3JFcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2YXIgYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXHR2YXIgaGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aDtcblxuXHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIHdpdGggYSBkZWxpbWl0ZXIgdW5sZXNzIGl0J3MgZW1wdHkuXG5cdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdH1cblxuXHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHR2YXIgbSA9IG1heEludDtcblx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuXHRcdHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcblx0XHR2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGZvciAodmFyIF9pdGVyYXRvcjIgPSBpbnB1dFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuXHRcdFx0XHR2YXIgY3VycmVudFZhbHVlID0gX3N0ZXAyLnZhbHVlO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvdy5cblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG5cdFx0XHRfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcblx0XHRcdFx0XHRfaXRlcmF0b3IyLnJldHVybigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG5cdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHR9XG5cblx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdG4gPSBtO1xuXG5cdFx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTtcblx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IzID0gZmFsc2U7XG5cdFx0dmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuXHRcdHRyeSB7XG5cdFx0XHRmb3IgKHZhciBfaXRlcmF0b3IzID0gaW5wdXRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHtcblx0XHRcdFx0dmFyIF9jdXJyZW50VmFsdWUgPSBfc3RlcDMudmFsdWU7XG5cblx0XHRcdFx0aWYgKF9jdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvciQxKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChfY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cblx0XHRcdFx0XHR2YXIgcSA9IGRlbHRhO1xuXHRcdFx0XHRcdGZvciAodmFyIGsgPSBiYXNlOzsgLyogbm8gY29uZGl0aW9uICovayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR2YXIgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiBrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFyIHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdHZhciBiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpKTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7XG5cdFx0XHRfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4pIHtcblx0XHRcdFx0XHRfaXRlcmF0b3IzLnJldHVybigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG5cdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3IzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0KytkZWx0YTtcblx0XHQrK247XG5cdH1cblx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG4gKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuICogY29udmVydCB0byBVbmljb2RlLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG4gKiBzdHJpbmcuXG4gKi9cbnZhciB0b1VuaWNvZGUgPSBmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24gKHN0cmluZykge1xuXHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKSA/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSkgOiBzdHJpbmc7XG5cdH0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cbiAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG4gKiBBU0NJSS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcbiAqIFVuaWNvZGUgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuICogZW1haWwgYWRkcmVzcy5cbiAqL1xudmFyIHRvQVNDSUkgPSBmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uIChzdHJpbmcpIHtcblx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZykgPyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKSA6IHN0cmluZztcblx0fSk7XG59O1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xudmFyIHB1bnljb2RlID0ge1xuXHQvKipcbiAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG4gICogQG1lbWJlck9mIHB1bnljb2RlXG4gICogQHR5cGUgU3RyaW5nXG4gICovXG5cdCd2ZXJzaW9uJzogJzIuMS4wJyxcblx0LyoqXG4gICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcbiAgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuICAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuICAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICAqIEB0eXBlIE9iamVjdFxuICAqL1xuXHQndWNzMic6IHtcblx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHR9LFxuXHQnZGVjb2RlJzogZGVjb2RlLFxuXHQnZW5jb2RlJzogZW5jb2RlLFxuXHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcbn07XG5cbi8qKlxuICogVVJJLmpzXG4gKlxuICogQGZpbGVvdmVydmlldyBBbiBSRkMgMzk4NiBjb21wbGlhbnQsIHNjaGVtZSBleHRlbmRhYmxlIFVSSSBwYXJzaW5nL3ZhbGlkYXRpbmcvcmVzb2x2aW5nIGxpYnJhcnkgZm9yIEphdmFTY3JpcHQuXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86Z2FyeS5jb3VydEBnbWFpbC5jb21cIj5HYXJ5IENvdXJ0PC9hPlxuICogQHNlZSBodHRwOi8vZ2l0aHViLmNvbS9nYXJ5Y291cnQvdXJpLWpzXG4gKi9cbi8qKlxuICogQ29weXJpZ2h0IDIwMTEgR2FyeSBDb3VydC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmVcbiAqIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mXG4gKiAgICAgICBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3RcbiAqICAgICAgIG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gKiAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBHQVJZIENPVVJUIGBgQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRFxuICogV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEdBUlkgQ09VUlQgT1JcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SXG4gKiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG4gKiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUZcbiAqIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICpcbiAqIFRoZSB2aWV3cyBhbmQgY29uY2x1c2lvbnMgY29udGFpbmVkIGluIHRoZSBzb2Z0d2FyZSBhbmQgZG9jdW1lbnRhdGlvbiBhcmUgdGhvc2Ugb2YgdGhlXG4gKiBhdXRob3JzIGFuZCBzaG91bGQgbm90IGJlIGludGVycHJldGVkIGFzIHJlcHJlc2VudGluZyBvZmZpY2lhbCBwb2xpY2llcywgZWl0aGVyIGV4cHJlc3NlZFxuICogb3IgaW1wbGllZCwgb2YgR2FyeSBDb3VydC5cbiAqL1xudmFyIFNDSEVNRVMgPSB7fTtcbmZ1bmN0aW9uIHBjdEVuY0NoYXIoY2hyKSB7XG4gICAgdmFyIGMgPSBjaHIuY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgZSA9IHZvaWQgMDtcbiAgICBpZiAoYyA8IDE2KSBlID0gXCIlMFwiICsgYy50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtlbHNlIGlmIChjIDwgMTI4KSBlID0gXCIlXCIgKyBjLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO2Vsc2UgaWYgKGMgPCAyMDQ4KSBlID0gXCIlXCIgKyAoYyA+PiA2IHwgMTkyKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArIFwiJVwiICsgKGMgJiA2MyB8IDEyOCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7ZWxzZSBlID0gXCIlXCIgKyAoYyA+PiAxMiB8IDIyNCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBcIiVcIiArIChjID4+IDYgJiA2MyB8IDEyOCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBcIiVcIiArIChjICYgNjMgfCAxMjgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBlO1xufVxuZnVuY3Rpb24gcGN0RGVjQ2hhcnMoc3RyKSB7XG4gICAgdmFyIG5ld1N0ciA9IFwiXCI7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBpbCA9IHN0ci5sZW5ndGg7XG4gICAgd2hpbGUgKGkgPCBpbCkge1xuICAgICAgICB2YXIgYyA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDEsIDIpLCAxNik7XG4gICAgICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICAgICAgICBuZXdTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgfSBlbHNlIGlmIChjID49IDE5NCAmJiBjIDwgMjI0KSB7XG4gICAgICAgICAgICBpZiAoaWwgLSBpID49IDYpIHtcbiAgICAgICAgICAgICAgICB2YXIgYzIgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyA0LCAyKSwgMTYpO1xuICAgICAgICAgICAgICAgIG5ld1N0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMzEpIDw8IDYgfCBjMiAmIDYzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U3RyICs9IHN0ci5zdWJzdHIoaSwgNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpICs9IDY7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA+PSAyMjQpIHtcbiAgICAgICAgICAgIGlmIChpbCAtIGkgPj0gOSkge1xuICAgICAgICAgICAgICAgIHZhciBfYyA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDQsIDIpLCAxNik7XG4gICAgICAgICAgICAgICAgdmFyIGMzID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgNywgMiksIDE2KTtcbiAgICAgICAgICAgICAgICBuZXdTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDE1KSA8PCAxMiB8IChfYyAmIDYzKSA8PCA2IHwgYzMgJiA2Myk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSArPSA5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3U3RyICs9IHN0ci5zdWJzdHIoaSwgMyk7XG4gICAgICAgICAgICBpICs9IDM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld1N0cjtcbn1cbmZ1bmN0aW9uIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBwcm90b2NvbCkge1xuICAgIGZ1bmN0aW9uIGRlY29kZVVucmVzZXJ2ZWQoc3RyKSB7XG4gICAgICAgIHZhciBkZWNTdHIgPSBwY3REZWNDaGFycyhzdHIpO1xuICAgICAgICByZXR1cm4gIWRlY1N0ci5tYXRjaChwcm90b2NvbC5VTlJFU0VSVkVEKSA/IHN0ciA6IGRlY1N0cjtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMuc2NoZW1lKSBjb21wb25lbnRzLnNjaGVtZSA9IFN0cmluZyhjb21wb25lbnRzLnNjaGVtZSkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKHByb3RvY29sLk5PVF9TQ0hFTUUsIFwiXCIpO1xuICAgIGlmIChjb21wb25lbnRzLnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMudXNlcmluZm8gPSBTdHJpbmcoY29tcG9uZW50cy51c2VyaW5mbykucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShwcm90b2NvbC5OT1RfVVNFUklORk8sIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICBpZiAoY29tcG9uZW50cy5ob3N0ICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMuaG9zdCA9IFN0cmluZyhjb21wb25lbnRzLmhvc3QpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShwcm90b2NvbC5OT1RfSE9TVCwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgIGlmIChjb21wb25lbnRzLnBhdGggIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5wYXRoID0gU3RyaW5nKGNvbXBvbmVudHMucGF0aCkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShjb21wb25lbnRzLnNjaGVtZSA/IHByb3RvY29sLk5PVF9QQVRIIDogcHJvdG9jb2wuTk9UX1BBVEhfTk9TQ0hFTUUsIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICBpZiAoY29tcG9uZW50cy5xdWVyeSAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLnF1ZXJ5ID0gU3RyaW5nKGNvbXBvbmVudHMucXVlcnkpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UocHJvdG9jb2wuTk9UX1FVRVJZLCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG4gICAgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5mcmFnbWVudCA9IFN0cmluZyhjb21wb25lbnRzLmZyYWdtZW50KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKHByb3RvY29sLk5PVF9GUkFHTUVOVCwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgIHJldHVybiBjb21wb25lbnRzO1xufVxuXG5mdW5jdGlvbiBfc3RyaXBMZWFkaW5nWmVyb3Moc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eMCooLiopLywgXCIkMVwiKSB8fCBcIjBcIjtcbn1cbmZ1bmN0aW9uIF9ub3JtYWxpemVJUHY0KGhvc3QsIHByb3RvY29sKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBob3N0Lm1hdGNoKHByb3RvY29sLklQVjRBRERSRVNTKSB8fCBbXTtcblxuICAgIHZhciBfbWF0Y2hlcyA9IHNsaWNlZFRvQXJyYXkobWF0Y2hlcywgMiksXG4gICAgICAgIGFkZHJlc3MgPSBfbWF0Y2hlc1sxXTtcblxuICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBhZGRyZXNzLnNwbGl0KFwiLlwiKS5tYXAoX3N0cmlwTGVhZGluZ1plcm9zKS5qb2luKFwiLlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaG9zdDtcbiAgICB9XG59XG5mdW5jdGlvbiBfbm9ybWFsaXplSVB2Nihob3N0LCBwcm90b2NvbCkge1xuICAgIHZhciBtYXRjaGVzID0gaG9zdC5tYXRjaChwcm90b2NvbC5JUFY2QUREUkVTUykgfHwgW107XG5cbiAgICB2YXIgX21hdGNoZXMyID0gc2xpY2VkVG9BcnJheShtYXRjaGVzLCAzKSxcbiAgICAgICAgYWRkcmVzcyA9IF9tYXRjaGVzMlsxXSxcbiAgICAgICAgem9uZSA9IF9tYXRjaGVzMlsyXTtcblxuICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgIHZhciBfYWRkcmVzcyR0b0xvd2VyQ2FzZSQgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkuc3BsaXQoJzo6JykucmV2ZXJzZSgpLFxuICAgICAgICAgICAgX2FkZHJlc3MkdG9Mb3dlckNhc2UkMiA9IHNsaWNlZFRvQXJyYXkoX2FkZHJlc3MkdG9Mb3dlckNhc2UkLCAyKSxcbiAgICAgICAgICAgIGxhc3QgPSBfYWRkcmVzcyR0b0xvd2VyQ2FzZSQyWzBdLFxuICAgICAgICAgICAgZmlyc3QgPSBfYWRkcmVzcyR0b0xvd2VyQ2FzZSQyWzFdO1xuXG4gICAgICAgIHZhciBmaXJzdEZpZWxkcyA9IGZpcnN0ID8gZmlyc3Quc3BsaXQoXCI6XCIpLm1hcChfc3RyaXBMZWFkaW5nWmVyb3MpIDogW107XG4gICAgICAgIHZhciBsYXN0RmllbGRzID0gbGFzdC5zcGxpdChcIjpcIikubWFwKF9zdHJpcExlYWRpbmdaZXJvcyk7XG4gICAgICAgIHZhciBpc0xhc3RGaWVsZElQdjRBZGRyZXNzID0gcHJvdG9jb2wuSVBWNEFERFJFU1MudGVzdChsYXN0RmllbGRzW2xhc3RGaWVsZHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICB2YXIgZmllbGRDb3VudCA9IGlzTGFzdEZpZWxkSVB2NEFkZHJlc3MgPyA3IDogODtcbiAgICAgICAgdmFyIGxhc3RGaWVsZHNTdGFydCA9IGxhc3RGaWVsZHMubGVuZ3RoIC0gZmllbGRDb3VudDtcbiAgICAgICAgdmFyIGZpZWxkcyA9IEFycmF5KGZpZWxkQ291bnQpO1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGZpZWxkQ291bnQ7ICsreCkge1xuICAgICAgICAgICAgZmllbGRzW3hdID0gZmlyc3RGaWVsZHNbeF0gfHwgbGFzdEZpZWxkc1tsYXN0RmllbGRzU3RhcnQgKyB4XSB8fCAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMYXN0RmllbGRJUHY0QWRkcmVzcykge1xuICAgICAgICAgICAgZmllbGRzW2ZpZWxkQ291bnQgLSAxXSA9IF9ub3JtYWxpemVJUHY0KGZpZWxkc1tmaWVsZENvdW50IC0gMV0sIHByb3RvY29sKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWxsWmVyb0ZpZWxkcyA9IGZpZWxkcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZmllbGQsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWZpZWxkIHx8IGZpZWxkID09PSBcIjBcIikge1xuICAgICAgICAgICAgICAgIHZhciBsYXN0TG9uZ2VzdCA9IGFjY1thY2MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RMb25nZXN0ICYmIGxhc3RMb25nZXN0LmluZGV4ICsgbGFzdExvbmdlc3QubGVuZ3RoID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0TG9uZ2VzdC5sZW5ndGgrKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhY2MucHVzaCh7IGluZGV4OiBpbmRleCwgbGVuZ3RoOiAxIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgdmFyIGxvbmdlc3RaZXJvRmllbGRzID0gYWxsWmVyb0ZpZWxkcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfSlbMF07XG4gICAgICAgIHZhciBuZXdIb3N0ID0gdm9pZCAwO1xuICAgICAgICBpZiAobG9uZ2VzdFplcm9GaWVsZHMgJiYgbG9uZ2VzdFplcm9GaWVsZHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIG5ld0ZpcnN0ID0gZmllbGRzLnNsaWNlKDAsIGxvbmdlc3RaZXJvRmllbGRzLmluZGV4KTtcbiAgICAgICAgICAgIHZhciBuZXdMYXN0ID0gZmllbGRzLnNsaWNlKGxvbmdlc3RaZXJvRmllbGRzLmluZGV4ICsgbG9uZ2VzdFplcm9GaWVsZHMubGVuZ3RoKTtcbiAgICAgICAgICAgIG5ld0hvc3QgPSBuZXdGaXJzdC5qb2luKFwiOlwiKSArIFwiOjpcIiArIG5ld0xhc3Quam9pbihcIjpcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdIb3N0ID0gZmllbGRzLmpvaW4oXCI6XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh6b25lKSB7XG4gICAgICAgICAgICBuZXdIb3N0ICs9IFwiJVwiICsgem9uZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3SG9zdDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaG9zdDtcbiAgICB9XG59XG52YXIgVVJJX1BBUlNFID0gL14oPzooW146XFwvPyNdKyk6KT8oPzpcXC9cXC8oKD86KFteXFwvPyNAXSopQCk/KFxcW1teXFwvPyNcXF1dK1xcXXxbXlxcLz8jOl0qKSg/OlxcOihcXGQqKSk/KSk/KFtePyNdKikoPzpcXD8oW14jXSopKT8oPzojKCg/Oi58XFxufFxccikqKSk/L2k7XG52YXIgTk9fTUFUQ0hfSVNfVU5ERUZJTkVEID0gXCJcIi5tYXRjaCgvKCl7MH0vKVsxXSA9PT0gdW5kZWZpbmVkO1xuZnVuY3Rpb24gcGFyc2UodXJpU3RyaW5nKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgdmFyIGNvbXBvbmVudHMgPSB7fTtcbiAgICB2YXIgcHJvdG9jb2wgPSBvcHRpb25zLmlyaSAhPT0gZmFsc2UgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0w7XG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlID09PSBcInN1ZmZpeFwiKSB1cmlTdHJpbmcgPSAob3B0aW9ucy5zY2hlbWUgPyBvcHRpb25zLnNjaGVtZSArIFwiOlwiIDogXCJcIikgKyBcIi8vXCIgKyB1cmlTdHJpbmc7XG4gICAgdmFyIG1hdGNoZXMgPSB1cmlTdHJpbmcubWF0Y2goVVJJX1BBUlNFKTtcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICBpZiAoTk9fTUFUQ0hfSVNfVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAvL3N0b3JlIGVhY2ggY29tcG9uZW50XG4gICAgICAgICAgICBjb21wb25lbnRzLnNjaGVtZSA9IG1hdGNoZXNbMV07XG4gICAgICAgICAgICBjb21wb25lbnRzLnVzZXJpbmZvID0gbWF0Y2hlc1szXTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9IG1hdGNoZXNbNF07XG4gICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSBtYXRjaGVzWzZdIHx8IFwiXCI7XG4gICAgICAgICAgICBjb21wb25lbnRzLnF1ZXJ5ID0gbWF0Y2hlc1s3XTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZnJhZ21lbnQgPSBtYXRjaGVzWzhdO1xuICAgICAgICAgICAgLy9maXggcG9ydCBudW1iZXJcbiAgICAgICAgICAgIGlmIChpc05hTihjb21wb25lbnRzLnBvcnQpKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gbWF0Y2hlc1s1XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vSUUgRklYIGZvciBpbXByb3BlciBSZWdFeHAgbWF0Y2hpbmdcbiAgICAgICAgICAgIC8vc3RvcmUgZWFjaCBjb21wb25lbnRcbiAgICAgICAgICAgIGNvbXBvbmVudHMuc2NoZW1lID0gbWF0Y2hlc1sxXSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLnVzZXJpbmZvID0gdXJpU3RyaW5nLmluZGV4T2YoXCJAXCIpICE9PSAtMSA/IG1hdGNoZXNbM10gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLmhvc3QgPSB1cmlTdHJpbmcuaW5kZXhPZihcIi8vXCIpICE9PSAtMSA/IG1hdGNoZXNbNF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSBtYXRjaGVzWzZdIHx8IFwiXCI7XG4gICAgICAgICAgICBjb21wb25lbnRzLnF1ZXJ5ID0gdXJpU3RyaW5nLmluZGV4T2YoXCI/XCIpICE9PSAtMSA/IG1hdGNoZXNbN10gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLmZyYWdtZW50ID0gdXJpU3RyaW5nLmluZGV4T2YoXCIjXCIpICE9PSAtMSA/IG1hdGNoZXNbOF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvL2ZpeCBwb3J0IG51bWJlclxuICAgICAgICAgICAgaWYgKGlzTmFOKGNvbXBvbmVudHMucG9ydCkpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSB1cmlTdHJpbmcubWF0Y2goL1xcL1xcLyg/Oi58XFxuKSpcXDooPzpcXC98XFw/fFxcI3wkKS8pID8gbWF0Y2hlc1s0XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcG9uZW50cy5ob3N0KSB7XG4gICAgICAgICAgICAvL25vcm1hbGl6ZSBJUCBob3N0c1xuICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gX25vcm1hbGl6ZUlQdjYoX25vcm1hbGl6ZUlQdjQoY29tcG9uZW50cy5ob3N0LCBwcm90b2NvbCksIHByb3RvY29sKTtcbiAgICAgICAgfVxuICAgICAgICAvL2RldGVybWluZSByZWZlcmVuY2UgdHlwZVxuICAgICAgICBpZiAoY29tcG9uZW50cy5zY2hlbWUgPT09IHVuZGVmaW5lZCAmJiBjb21wb25lbnRzLnVzZXJpbmZvID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy5ob3N0ID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy5wb3J0ID09PSB1bmRlZmluZWQgJiYgIWNvbXBvbmVudHMucGF0aCAmJiBjb21wb25lbnRzLnF1ZXJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJzYW1lLWRvY3VtZW50XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG9uZW50cy5zY2hlbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5yZWZlcmVuY2UgPSBcInJlbGF0aXZlXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG9uZW50cy5mcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJ1cmlcIjtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciByZWZlcmVuY2UgZXJyb3JzXG4gICAgICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gXCJzdWZmaXhcIiAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gY29tcG9uZW50cy5yZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiVVJJIGlzIG5vdCBhIFwiICsgb3B0aW9ucy5yZWZlcmVuY2UgKyBcIiByZWZlcmVuY2UuXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy9maW5kIHNjaGVtZSBoYW5kbGVyXG4gICAgICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1sob3B0aW9ucy5zY2hlbWUgfHwgY29tcG9uZW50cy5zY2hlbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIC8vY2hlY2sgaWYgc2NoZW1lIGNhbid0IGhhbmRsZSBJUklzXG4gICAgICAgIGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIudW5pY29kZVN1cHBvcnQpKSB7XG4gICAgICAgICAgICAvL2lmIGhvc3QgY29tcG9uZW50IGlzIGEgZG9tYWluIG5hbWVcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRzLmhvc3QgJiYgKG9wdGlvbnMuZG9tYWluSG9zdCB8fCBzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuZG9tYWluSG9zdCkpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgVW5pY29kZSBJRE4gLT4gQVNDSUkgSUROXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gcHVueWNvZGUudG9BU0NJSShjb21wb25lbnRzLmhvc3QucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgcGN0RGVjQ2hhcnMpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gQVNDSUkgdmlhIHB1bnljb2RlOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9jb252ZXJ0IElSSSAtPiBVUklcbiAgICAgICAgICAgIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBVUklfUFJPVE9DT0wpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9ub3JtYWxpemUgZW5jb2RpbmdzXG4gICAgICAgICAgICBfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgcHJvdG9jb2wpO1xuICAgICAgICB9XG4gICAgICAgIC8vcGVyZm9ybSBzY2hlbWUgc3BlY2lmaWMgcGFyc2luZ1xuICAgICAgICBpZiAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLnBhcnNlKSB7XG4gICAgICAgICAgICBzY2hlbWVIYW5kbGVyLnBhcnNlKGNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUkkgY2FuIG5vdCBiZSBwYXJzZWQuXCI7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnRzO1xufVxuXG5mdW5jdGlvbiBfcmVjb21wb3NlQXV0aG9yaXR5KGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgcHJvdG9jb2wgPSBvcHRpb25zLmlyaSAhPT0gZmFsc2UgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0w7XG4gICAgdmFyIHVyaVRva2VucyA9IFtdO1xuICAgIGlmIChjb21wb25lbnRzLnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy51c2VyaW5mbyk7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiQFwiKTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vbm9ybWFsaXplIElQIGhvc3RzLCBhZGQgYnJhY2tldHMgYW5kIGVzY2FwZSB6b25lIHNlcGFyYXRvciBmb3IgSVB2NlxuICAgICAgICB1cmlUb2tlbnMucHVzaChfbm9ybWFsaXplSVB2Nihfbm9ybWFsaXplSVB2NChTdHJpbmcoY29tcG9uZW50cy5ob3N0KSwgcHJvdG9jb2wpLCBwcm90b2NvbCkucmVwbGFjZShwcm90b2NvbC5JUFY2QUREUkVTUywgZnVuY3Rpb24gKF8sICQxLCAkMikge1xuICAgICAgICAgICAgcmV0dXJuIFwiW1wiICsgJDEgKyAoJDIgPyBcIiUyNVwiICsgJDIgOiBcIlwiKSArIFwiXVwiO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29tcG9uZW50cy5wb3J0ID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBjb21wb25lbnRzLnBvcnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goXCI6XCIpO1xuICAgICAgICB1cmlUb2tlbnMucHVzaChTdHJpbmcoY29tcG9uZW50cy5wb3J0KSk7XG4gICAgfVxuICAgIHJldHVybiB1cmlUb2tlbnMubGVuZ3RoID8gdXJpVG9rZW5zLmpvaW4oXCJcIikgOiB1bmRlZmluZWQ7XG59XG5cbnZhciBSRFMxID0gL15cXC5cXC4/XFwvLztcbnZhciBSRFMyID0gL15cXC9cXC4oXFwvfCQpLztcbnZhciBSRFMzID0gL15cXC9cXC5cXC4oXFwvfCQpLztcbnZhciBSRFM1ID0gL15cXC8/KD86LnxcXG4pKj8oPz1cXC98JCkvO1xuZnVuY3Rpb24gcmVtb3ZlRG90U2VnbWVudHMoaW5wdXQpIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgd2hpbGUgKGlucHV0Lmxlbmd0aCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goUkRTMSkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMxLCBcIlwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5tYXRjaChSRFMyKSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzIsIFwiL1wiKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5tYXRjaChSRFMzKSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzMsIFwiL1wiKTtcbiAgICAgICAgICAgIG91dHB1dC5wb3AoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gXCIuXCIgfHwgaW5wdXQgPT09IFwiLi5cIikge1xuICAgICAgICAgICAgaW5wdXQgPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGltID0gaW5wdXQubWF0Y2goUkRTNSk7XG4gICAgICAgICAgICBpZiAoaW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IGltWzBdO1xuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2Uocy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGRvdCBzZWdtZW50IGNvbmRpdGlvblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oXCJcIik7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShjb21wb25lbnRzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgdmFyIHByb3RvY29sID0gb3B0aW9ucy5pcmkgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0w7XG4gICAgdmFyIHVyaVRva2VucyA9IFtdO1xuICAgIC8vZmluZCBzY2hlbWUgaGFuZGxlclxuICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1sob3B0aW9ucy5zY2hlbWUgfHwgY29tcG9uZW50cy5zY2hlbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKV07XG4gICAgLy9wZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBzZXJpYWxpemF0aW9uXG4gICAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUpIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKGNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgIGlmIChjb21wb25lbnRzLmhvc3QpIHtcbiAgICAgICAgLy9pZiBob3N0IGNvbXBvbmVudCBpcyBhbiBJUHY2IGFkZHJlc3NcbiAgICAgICAgaWYgKHByb3RvY29sLklQVjZBRERSRVNTLnRlc3QoY29tcG9uZW50cy5ob3N0KSkge31cbiAgICAgICAgLy9UT0RPOiBub3JtYWxpemUgSVB2NiBhZGRyZXNzIGFzIHBlciBSRkMgNTk1MlxuXG4gICAgICAgIC8vaWYgaG9zdCBjb21wb25lbnQgaXMgYSBkb21haW4gbmFtZVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmRvbWFpbkhvc3QgfHwgc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLmRvbWFpbkhvc3QpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgSUROIHZpYSBwdW55Y29kZVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9ICFvcHRpb25zLmlyaSA/IHB1bnljb2RlLnRvQVNDSUkoY29tcG9uZW50cy5ob3N0LnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHBjdERlY0NoYXJzKS50b0xvd2VyQ2FzZSgpKSA6IHB1bnljb2RlLnRvVW5pY29kZShjb21wb25lbnRzLmhvc3QpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gXCIgKyAoIW9wdGlvbnMuaXJpID8gXCJBU0NJSVwiIDogXCJVbmljb2RlXCIpICsgXCIgdmlhIHB1bnljb2RlOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIH1cbiAgICAvL25vcm1hbGl6ZSBlbmNvZGluZ1xuICAgIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBwcm90b2NvbCk7XG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiICYmIGNvbXBvbmVudHMuc2NoZW1lKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMuc2NoZW1lKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goXCI6XCIpO1xuICAgIH1cbiAgICB2YXIgYXV0aG9yaXR5ID0gX3JlY29tcG9zZUF1dGhvcml0eShjb21wb25lbnRzLCBvcHRpb25zKTtcbiAgICBpZiAoYXV0aG9yaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiKSB7XG4gICAgICAgICAgICB1cmlUb2tlbnMucHVzaChcIi8vXCIpO1xuICAgICAgICB9XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGF1dGhvcml0eSk7XG4gICAgICAgIGlmIChjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5wYXRoLmNoYXJBdCgwKSAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgIHVyaVRva2Vucy5wdXNoKFwiL1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tcG9uZW50cy5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHMgPSBjb21wb25lbnRzLnBhdGg7XG4gICAgICAgIGlmICghb3B0aW9ucy5hYnNvbHV0ZVBhdGggJiYgKCFzY2hlbWVIYW5kbGVyIHx8ICFzY2hlbWVIYW5kbGVyLmFic29sdXRlUGF0aCkpIHtcbiAgICAgICAgICAgIHMgPSByZW1vdmVEb3RTZWdtZW50cyhzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXV0aG9yaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoL15cXC9cXC8vLCBcIi8lMkZcIik7IC8vZG9uJ3QgYWxsb3cgdGhlIHBhdGggdG8gc3RhcnQgd2l0aCBcIi8vXCJcbiAgICAgICAgfVxuICAgICAgICB1cmlUb2tlbnMucHVzaChzKTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cmlUb2tlbnMucHVzaChcIj9cIik7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMucXVlcnkpO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50cy5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiI1wiKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5mcmFnbWVudCk7XG4gICAgfVxuICAgIHJldHVybiB1cmlUb2tlbnMuam9pbihcIlwiKTsgLy9tZXJnZSB0b2tlbnMgaW50byBhIHN0cmluZ1xufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50cyhiYXNlLCByZWxhdGl2ZSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgc2tpcE5vcm1hbGl6YXRpb24gPSBhcmd1bWVudHNbM107XG5cbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgaWYgKCFza2lwTm9ybWFsaXphdGlvbikge1xuICAgICAgICBiYXNlID0gcGFyc2Uoc2VyaWFsaXplKGJhc2UsIG9wdGlvbnMpLCBvcHRpb25zKTsgLy9ub3JtYWxpemUgYmFzZSBjb21wb25lbnRzXG4gICAgICAgIHJlbGF0aXZlID0gcGFyc2Uoc2VyaWFsaXplKHJlbGF0aXZlLCBvcHRpb25zKSwgb3B0aW9ucyk7IC8vbm9ybWFsaXplIHJlbGF0aXZlIGNvbXBvbmVudHNcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKCFvcHRpb25zLnRvbGVyYW50ICYmIHJlbGF0aXZlLnNjaGVtZSkge1xuICAgICAgICB0YXJnZXQuc2NoZW1lID0gcmVsYXRpdmUuc2NoZW1lO1xuICAgICAgICAvL3RhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgICAgIHRhcmdldC51c2VyaW5mbyA9IHJlbGF0aXZlLnVzZXJpbmZvO1xuICAgICAgICB0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoIHx8IFwiXCIpO1xuICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVsYXRpdmUudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvL3RhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgICAgICAgICB0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mbztcbiAgICAgICAgICAgIHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCBcIlwiKTtcbiAgICAgICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGg7XG4gICAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gYmFzZS5xdWVyeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5wYXRoLmNoYXJBdCgwKSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGJhc2UudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCBiYXNlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCBiYXNlLnBvcnQgIT09IHVuZGVmaW5lZCkgJiYgIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBcIi9cIiArIHJlbGF0aXZlLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZWxhdGl2ZS5wYXRoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGguc2xpY2UoMCwgYmFzZS5wYXRoLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpICsgcmVsYXRpdmUucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHRhcmdldC5wYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3RhcmdldC5hdXRob3JpdHkgPSBiYXNlLmF1dGhvcml0eTtcbiAgICAgICAgICAgIHRhcmdldC51c2VyaW5mbyA9IGJhc2UudXNlcmluZm87XG4gICAgICAgICAgICB0YXJnZXQuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgIHRhcmdldC5wb3J0ID0gYmFzZS5wb3J0O1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5zY2hlbWUgPSBiYXNlLnNjaGVtZTtcbiAgICB9XG4gICAgdGFyZ2V0LmZyYWdtZW50ID0gcmVsYXRpdmUuZnJhZ21lbnQ7XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShiYXNlVVJJLCByZWxhdGl2ZVVSSSwgb3B0aW9ucykge1xuICAgIHZhciBzY2hlbWVsZXNzT3B0aW9ucyA9IGFzc2lnbih7IHNjaGVtZTogJ251bGwnIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBzZXJpYWxpemUocmVzb2x2ZUNvbXBvbmVudHMocGFyc2UoYmFzZVVSSSwgc2NoZW1lbGVzc09wdGlvbnMpLCBwYXJzZShyZWxhdGl2ZVVSSSwgc2NoZW1lbGVzc09wdGlvbnMpLCBzY2hlbWVsZXNzT3B0aW9ucywgdHJ1ZSksIHNjaGVtZWxlc3NPcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplKHVyaSwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdXJpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHVyaSA9IHNlcmlhbGl6ZShwYXJzZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVPZih1cmkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHVyaSA9IHBhcnNlKHNlcmlhbGl6ZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHVyaTtcbn1cblxuZnVuY3Rpb24gZXF1YWwodXJpQSwgdXJpQiwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdXJpQSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB1cmlBID0gc2VyaWFsaXplKHBhcnNlKHVyaUEsIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVPZih1cmlBKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB1cmlBID0gc2VyaWFsaXplKHVyaUEsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHVyaUIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdXJpQiA9IHNlcmlhbGl6ZShwYXJzZSh1cmlCLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0eXBlT2YodXJpQikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdXJpQiA9IHNlcmlhbGl6ZSh1cmlCLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHVyaUEgPT09IHVyaUI7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUNvbXBvbmVudChzdHIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gc3RyICYmIHN0ci50b1N0cmluZygpLnJlcGxhY2UoIW9wdGlvbnMgfHwgIW9wdGlvbnMuaXJpID8gVVJJX1BST1RPQ09MLkVTQ0FQRSA6IElSSV9QUk9UT0NPTC5FU0NBUEUsIHBjdEVuY0NoYXIpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZUNvbXBvbmVudChzdHIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gc3RyICYmIHN0ci50b1N0cmluZygpLnJlcGxhY2UoIW9wdGlvbnMgfHwgIW9wdGlvbnMuaXJpID8gVVJJX1BST1RPQ09MLlBDVF9FTkNPREVEIDogSVJJX1BST1RPQ09MLlBDVF9FTkNPREVELCBwY3REZWNDaGFycyk7XG59XG5cbnZhciBoYW5kbGVyID0ge1xuICAgIHNjaGVtZTogXCJodHRwXCIsXG4gICAgZG9tYWluSG9zdDogdHJ1ZSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICAvL3JlcG9ydCBtaXNzaW5nIGhvc3RcbiAgICAgICAgaWYgKCFjb21wb25lbnRzLmhvc3QpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSFRUUCBVUklzIG11c3QgaGF2ZSBhIGhvc3QuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBzZWN1cmUgPSBTdHJpbmcoY29tcG9uZW50cy5zY2hlbWUpLnRvTG93ZXJDYXNlKCkgPT09IFwiaHR0cHNcIjtcbiAgICAgICAgLy9ub3JtYWxpemUgdGhlIGRlZmF1bHQgcG9ydFxuICAgICAgICBpZiAoY29tcG9uZW50cy5wb3J0ID09PSAoc2VjdXJlID8gNDQzIDogODApIHx8IGNvbXBvbmVudHMucG9ydCA9PT0gXCJcIikge1xuICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vbm9ybWFsaXplIHRoZSBlbXB0eSBwYXRoXG4gICAgICAgIGlmICghY29tcG9uZW50cy5wYXRoKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSBcIi9cIjtcbiAgICAgICAgfVxuICAgICAgICAvL05PVEU6IFdlIGRvIG5vdCBwYXJzZSBxdWVyeSBzdHJpbmdzIGZvciBIVFRQIFVSSXNcbiAgICAgICAgLy9hcyBXV1cgRm9ybSBVcmwgRW5jb2RlZCBxdWVyeSBzdHJpbmdzIGFyZSBwYXJ0IG9mIHRoZSBIVE1MNCsgc3BlYyxcbiAgICAgICAgLy9hbmQgbm90IHRoZSBIVFRQIHNwZWMuXG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbn07XG5cbnZhciBoYW5kbGVyJDEgPSB7XG4gICAgc2NoZW1lOiBcImh0dHBzXCIsXG4gICAgZG9tYWluSG9zdDogaGFuZGxlci5kb21haW5Ib3N0LFxuICAgIHBhcnNlOiBoYW5kbGVyLnBhcnNlLFxuICAgIHNlcmlhbGl6ZTogaGFuZGxlci5zZXJpYWxpemVcbn07XG5cbmZ1bmN0aW9uIGlzU2VjdXJlKHdzQ29tcG9uZW50cykge1xuICAgIHJldHVybiB0eXBlb2Ygd3NDb21wb25lbnRzLnNlY3VyZSA9PT0gJ2Jvb2xlYW4nID8gd3NDb21wb25lbnRzLnNlY3VyZSA6IFN0cmluZyh3c0NvbXBvbmVudHMuc2NoZW1lKS50b0xvd2VyQ2FzZSgpID09PSBcIndzc1wiO1xufVxuLy9SRkMgNjQ1NVxudmFyIGhhbmRsZXIkMiA9IHtcbiAgICBzY2hlbWU6IFwid3NcIixcbiAgICBkb21haW5Ib3N0OiB0cnVlLFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB3c0NvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgICAgICAvL2luZGljYXRlIGlmIHRoZSBzZWN1cmUgZmxhZyBpcyBzZXRcbiAgICAgICAgd3NDb21wb25lbnRzLnNlY3VyZSA9IGlzU2VjdXJlKHdzQ29tcG9uZW50cyk7XG4gICAgICAgIC8vY29uc3RydWN0IHJlc291Y2UgbmFtZVxuICAgICAgICB3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lID0gKHdzQ29tcG9uZW50cy5wYXRoIHx8ICcvJykgKyAod3NDb21wb25lbnRzLnF1ZXJ5ID8gJz8nICsgd3NDb21wb25lbnRzLnF1ZXJ5IDogJycpO1xuICAgICAgICB3c0NvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgd3NDb21wb25lbnRzLnF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gd3NDb21wb25lbnRzO1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUod3NDb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIC8vbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcbiAgICAgICAgaWYgKHdzQ29tcG9uZW50cy5wb3J0ID09PSAoaXNTZWN1cmUod3NDb21wb25lbnRzKSA/IDQ0MyA6IDgwKSB8fCB3c0NvbXBvbmVudHMucG9ydCA9PT0gXCJcIikge1xuICAgICAgICAgICAgd3NDb21wb25lbnRzLnBvcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9lbnN1cmUgc2NoZW1lIG1hdGNoZXMgc2VjdXJlIGZsYWdcbiAgICAgICAgaWYgKHR5cGVvZiB3c0NvbXBvbmVudHMuc2VjdXJlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5zY2hlbWUgPSB3c0NvbXBvbmVudHMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuICAgICAgICAgICAgd3NDb21wb25lbnRzLnNlY3VyZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvL3JlY29uc3RydWN0IHBhdGggZnJvbSByZXNvdXJjZSBuYW1lXG4gICAgICAgIGlmICh3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lKSB7XG4gICAgICAgICAgICB2YXIgX3dzQ29tcG9uZW50cyRyZXNvdXJjID0gd3NDb21wb25lbnRzLnJlc291cmNlTmFtZS5zcGxpdCgnPycpLFxuICAgICAgICAgICAgICAgIF93c0NvbXBvbmVudHMkcmVzb3VyYzIgPSBzbGljZWRUb0FycmF5KF93c0NvbXBvbmVudHMkcmVzb3VyYywgMiksXG4gICAgICAgICAgICAgICAgcGF0aCA9IF93c0NvbXBvbmVudHMkcmVzb3VyYzJbMF0sXG4gICAgICAgICAgICAgICAgcXVlcnkgPSBfd3NDb21wb25lbnRzJHJlc291cmMyWzFdO1xuXG4gICAgICAgICAgICB3c0NvbXBvbmVudHMucGF0aCA9IHBhdGggJiYgcGF0aCAhPT0gJy8nID8gcGF0aCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgd3NDb21wb25lbnRzLnJlc291cmNlTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvL2ZvcmJpZCBmcmFnbWVudCBjb21wb25lbnRcbiAgICAgICAgd3NDb21wb25lbnRzLmZyYWdtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gd3NDb21wb25lbnRzO1xuICAgIH1cbn07XG5cbnZhciBoYW5kbGVyJDMgPSB7XG4gICAgc2NoZW1lOiBcIndzc1wiLFxuICAgIGRvbWFpbkhvc3Q6IGhhbmRsZXIkMi5kb21haW5Ib3N0LFxuICAgIHBhcnNlOiBoYW5kbGVyJDIucGFyc2UsXG4gICAgc2VyaWFsaXplOiBoYW5kbGVyJDIuc2VyaWFsaXplXG59O1xuXG52YXIgTyA9IHt9O1xudmFyIGlzSVJJID0gdHJ1ZTtcbi8vUkZDIDM5ODZcbnZhciBVTlJFU0VSVkVEJCQgPSBcIltBLVphLXowLTlcXFxcLVxcXFwuXFxcXF9cXFxcflwiICsgKGlzSVJJID8gXCJcXFxceEEwLVxcXFx1MjAwRFxcXFx1MjAxMC1cXFxcdTIwMjlcXFxcdTIwMkYtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZcIiA6IFwiXCIpICsgXCJdXCI7XG52YXIgSEVYRElHJCQgPSBcIlswLTlBLUZhLWZdXCI7IC8vY2FzZS1pbnNlbnNpdGl2ZVxudmFyIFBDVF9FTkNPREVEJCA9IHN1YmV4cChzdWJleHAoXCIlW0VGZWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVbODlBLUZhLWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpKTsgLy9leHBhbmRlZFxuLy9SRkMgNTMyMiwgZXhjZXB0IHRoZXNlIHN5bWJvbHMgYXMgcGVyIFJGQyA2MDY4OiBAIDogLyA/ICMgWyBdICYgOyA9XG4vL2NvbnN0IEFURVhUJCQgPSBcIltBLVphLXowLTlcXFxcIVxcXFwjXFxcXCRcXFxcJVxcXFwmXFxcXCdcXFxcKlxcXFwrXFxcXC1cXFxcL1xcXFw9XFxcXD9cXFxcXlxcXFxfXFxcXGBcXFxce1xcXFx8XFxcXH1cXFxcfl1cIjtcbi8vY29uc3QgV1NQJCQgPSBcIltcXFxceDIwXFxcXHgwOV1cIjtcbi8vY29uc3QgT0JTX1FURVhUJCQgPSBcIltcXFxceDAxLVxcXFx4MDhcXFxceDBCXFxcXHgwQ1xcXFx4MEUtXFxcXHgxRlxcXFx4N0ZdXCI7ICAvLyglZDEtOCAvICVkMTEtMTIgLyAlZDE0LTMxIC8gJWQxMjcpXG4vL2NvbnN0IFFURVhUJCQgPSBtZXJnZShcIltcXFxceDIxXFxcXHgyMy1cXFxceDVCXFxcXHg1RC1cXFxceDdFXVwiLCBPQlNfUVRFWFQkJCk7ICAvLyVkMzMgLyAlZDM1LTkxIC8gJWQ5My0xMjYgLyBvYnMtcXRleHRcbi8vY29uc3QgVkNIQVIkJCA9IFwiW1xcXFx4MjEtXFxcXHg3RV1cIjtcbi8vY29uc3QgV1NQJCQgPSBcIltcXFxceDIwXFxcXHgwOV1cIjtcbi8vY29uc3QgT0JTX1FQJCA9IHN1YmV4cChcIlxcXFxcXFxcXCIgKyBtZXJnZShcIltcXFxceDAwXFxcXHgwRFxcXFx4MEFdXCIsIE9CU19RVEVYVCQkKSk7ICAvLyVkMCAvIENSIC8gTEYgLyBvYnMtcXRleHRcbi8vY29uc3QgRldTJCA9IHN1YmV4cChzdWJleHAoV1NQJCQgKyBcIipcIiArIFwiXFxcXHgwRFxcXFx4MEFcIikgKyBcIj9cIiArIFdTUCQkICsgXCIrXCIpO1xuLy9jb25zdCBRVU9URURfUEFJUiQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXFxcXFxcIiArIHN1YmV4cChWQ0hBUiQkICsgXCJ8XCIgKyBXU1AkJCkpICsgXCJ8XCIgKyBPQlNfUVAkKTtcbi8vY29uc3QgUVVPVEVEX1NUUklORyQgPSBzdWJleHAoJ1xcXFxcIicgKyBzdWJleHAoRldTJCArIFwiP1wiICsgUUNPTlRFTlQkKSArIFwiKlwiICsgRldTJCArIFwiP1wiICsgJ1xcXFxcIicpO1xudmFyIEFURVhUJCQgPSBcIltBLVphLXowLTlcXFxcIVxcXFwkXFxcXCVcXFxcJ1xcXFwqXFxcXCtcXFxcLVxcXFxeXFxcXF9cXFxcYFxcXFx7XFxcXHxcXFxcfVxcXFx+XVwiO1xudmFyIFFURVhUJCQgPSBcIltcXFxcIVxcXFwkXFxcXCVcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcLVxcXFwuMC05XFxcXDxcXFxcPkEtWlxcXFx4NUUtXFxcXHg3RV1cIjtcbnZhciBWQ0hBUiQkID0gbWVyZ2UoUVRFWFQkJCwgXCJbXFxcXFxcXCJcXFxcXFxcXF1cIik7XG52YXIgU09NRV9ERUxJTVMkJCA9IFwiW1xcXFwhXFxcXCRcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcO1xcXFw6XFxcXEBdXCI7XG52YXIgVU5SRVNFUlZFRCA9IG5ldyBSZWdFeHAoVU5SRVNFUlZFRCQkLCBcImdcIik7XG52YXIgUENUX0VOQ09ERUQgPSBuZXcgUmVnRXhwKFBDVF9FTkNPREVEJCwgXCJnXCIpO1xudmFyIE5PVF9MT0NBTF9QQVJUID0gbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBBVEVYVCQkLCBcIltcXFxcLl1cIiwgJ1tcXFxcXCJdJywgVkNIQVIkJCksIFwiZ1wiKTtcbnZhciBOT1RfSEZOQU1FID0gbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBVTlJFU0VSVkVEJCQsIFNPTUVfREVMSU1TJCQpLCBcImdcIik7XG52YXIgTk9UX0hGVkFMVUUgPSBOT1RfSEZOQU1FO1xuZnVuY3Rpb24gZGVjb2RlVW5yZXNlcnZlZChzdHIpIHtcbiAgICB2YXIgZGVjU3RyID0gcGN0RGVjQ2hhcnMoc3RyKTtcbiAgICByZXR1cm4gIWRlY1N0ci5tYXRjaChVTlJFU0VSVkVEKSA/IHN0ciA6IGRlY1N0cjtcbn1cbnZhciBoYW5kbGVyJDQgPSB7XG4gICAgc2NoZW1lOiBcIm1haWx0b1wiLFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSQkMShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBtYWlsdG9Db21wb25lbnRzID0gY29tcG9uZW50cztcbiAgICAgICAgdmFyIHRvID0gbWFpbHRvQ29tcG9uZW50cy50byA9IG1haWx0b0NvbXBvbmVudHMucGF0aCA/IG1haWx0b0NvbXBvbmVudHMucGF0aC5zcGxpdChcIixcIikgOiBbXTtcbiAgICAgICAgbWFpbHRvQ29tcG9uZW50cy5wYXRoID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFpbHRvQ29tcG9uZW50cy5xdWVyeSkge1xuICAgICAgICAgICAgdmFyIHVua25vd25IZWFkZXJzID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgdmFyIGhmaWVsZHMgPSBtYWlsdG9Db21wb25lbnRzLnF1ZXJ5LnNwbGl0KFwiJlwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwLCB4bCA9IGhmaWVsZHMubGVuZ3RoOyB4IDwgeGw7ICsreCkge1xuICAgICAgICAgICAgICAgIHZhciBoZmllbGQgPSBoZmllbGRzW3hdLnNwbGl0KFwiPVwiKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGhmaWVsZFswXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG9cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b0FkZHJzID0gaGZpZWxkWzFdLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF94ID0gMCwgX3hsID0gdG9BZGRycy5sZW5ndGg7IF94IDwgX3hsOyArK194KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8ucHVzaCh0b0FkZHJzW194XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1YmplY3RcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haWx0b0NvbXBvbmVudHMuc3ViamVjdCA9IHVuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFsxXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haWx0b0NvbXBvbmVudHMuYm9keSA9IHVuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFsxXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVua25vd25IZWFkZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzBdLCBvcHRpb25zKV0gPSB1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVua25vd25IZWFkZXJzKSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIG1haWx0b0NvbXBvbmVudHMucXVlcnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAodmFyIF94MiA9IDAsIF94bDIgPSB0by5sZW5ndGg7IF94MiA8IF94bDI7ICsrX3gyKSB7XG4gICAgICAgICAgICB2YXIgYWRkciA9IHRvW194Ml0uc3BsaXQoXCJAXCIpO1xuICAgICAgICAgICAgYWRkclswXSA9IHVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMF0pO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnVuaWNvZGVTdXBwb3J0KSB7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IFVuaWNvZGUgSUROIC0+IEFTQ0lJIElETlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJbMV0gPSBwdW55Y29kZS50b0FTQ0lJKHVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMV0sIG9wdGlvbnMpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbHRvQ29tcG9uZW50cy5lcnJvciA9IG1haWx0b0NvbXBvbmVudHMuZXJyb3IgfHwgXCJFbWFpbCBhZGRyZXNzJ3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gQVNDSUkgdmlhIHB1bnljb2RlOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRyWzFdID0gdW5lc2NhcGVDb21wb25lbnQoYWRkclsxXSwgb3B0aW9ucykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvW194Ml0gPSBhZGRyLmpvaW4oXCJAXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWlsdG9Db21wb25lbnRzO1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUkJDEobWFpbHRvQ29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgY29tcG9uZW50cyA9IG1haWx0b0NvbXBvbmVudHM7XG4gICAgICAgIHZhciB0byA9IHRvQXJyYXkobWFpbHRvQ29tcG9uZW50cy50byk7XG4gICAgICAgIGlmICh0bykge1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDAsIHhsID0gdG8ubGVuZ3RoOyB4IDwgeGw7ICsreCkge1xuICAgICAgICAgICAgICAgIHZhciB0b0FkZHIgPSBTdHJpbmcodG9beF0pO1xuICAgICAgICAgICAgICAgIHZhciBhdElkeCA9IHRvQWRkci5sYXN0SW5kZXhPZihcIkBcIik7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsUGFydCA9IHRvQWRkci5zbGljZSgwLCBhdElkeCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpLnJlcGxhY2UoTk9UX0xPQ0FMX1BBUlQsIHBjdEVuY0NoYXIpO1xuICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSB0b0FkZHIuc2xpY2UoYXRJZHggKyAxKTtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgSUROIHZpYSBwdW55Y29kZVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbiA9ICFvcHRpb25zLmlyaSA/IHB1bnljb2RlLnRvQVNDSUkodW5lc2NhcGVDb21wb25lbnQoZG9tYWluLCBvcHRpb25zKS50b0xvd2VyQ2FzZSgpKSA6IHB1bnljb2RlLnRvVW5pY29kZShkb21haW4pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJFbWFpbCBhZGRyZXNzJ3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gXCIgKyAoIW9wdGlvbnMuaXJpID8gXCJBU0NJSVwiIDogXCJVbmljb2RlXCIpICsgXCIgdmlhIHB1bnljb2RlOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvW3hdID0gbG9jYWxQYXJ0ICsgXCJAXCIgKyBkb21haW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSB0by5qb2luKFwiLFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVhZGVycyA9IG1haWx0b0NvbXBvbmVudHMuaGVhZGVycyA9IG1haWx0b0NvbXBvbmVudHMuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgaWYgKG1haWx0b0NvbXBvbmVudHMuc3ViamVjdCkgaGVhZGVyc1tcInN1YmplY3RcIl0gPSBtYWlsdG9Db21wb25lbnRzLnN1YmplY3Q7XG4gICAgICAgIGlmIChtYWlsdG9Db21wb25lbnRzLmJvZHkpIGhlYWRlcnNbXCJib2R5XCJdID0gbWFpbHRvQ29tcG9uZW50cy5ib2R5O1xuICAgICAgICB2YXIgZmllbGRzID0gW107XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gaGVhZGVycykge1xuICAgICAgICAgICAgaWYgKGhlYWRlcnNbbmFtZV0gIT09IE9bbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChuYW1lLnJlcGxhY2UoUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKS5yZXBsYWNlKE5PVF9IRk5BTUUsIHBjdEVuY0NoYXIpICsgXCI9XCIgKyBoZWFkZXJzW25hbWVdLnJlcGxhY2UoUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKS5yZXBsYWNlKE5PVF9IRlZBTFVFLCBwY3RFbmNDaGFyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucXVlcnkgPSBmaWVsZHMuam9pbihcIiZcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgfVxufTtcblxudmFyIFVSTl9QQVJTRSA9IC9eKFteXFw6XSspXFw6KC4qKS87XG4vL1JGQyAyMTQxXG52YXIgaGFuZGxlciQ1ID0ge1xuICAgIHNjaGVtZTogXCJ1cm5cIixcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UkJDEoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IGNvbXBvbmVudHMucGF0aCAmJiBjb21wb25lbnRzLnBhdGgubWF0Y2goVVJOX1BBUlNFKTtcbiAgICAgICAgdmFyIHVybkNvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgdmFyIHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudHMuc2NoZW1lIHx8IFwidXJuXCI7XG4gICAgICAgICAgICB2YXIgbmlkID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIG5zcyA9IG1hdGNoZXNbMl07XG4gICAgICAgICAgICB2YXIgdXJuU2NoZW1lID0gc2NoZW1lICsgXCI6XCIgKyAob3B0aW9ucy5uaWQgfHwgbmlkKTtcbiAgICAgICAgICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1t1cm5TY2hlbWVdO1xuICAgICAgICAgICAgdXJuQ29tcG9uZW50cy5uaWQgPSBuaWQ7XG4gICAgICAgICAgICB1cm5Db21wb25lbnRzLm5zcyA9IG5zcztcbiAgICAgICAgICAgIHVybkNvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChzY2hlbWVIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdXJuQ29tcG9uZW50cyA9IHNjaGVtZUhhbmRsZXIucGFyc2UodXJuQ29tcG9uZW50cywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cm5Db21wb25lbnRzLmVycm9yID0gdXJuQ29tcG9uZW50cy5lcnJvciB8fCBcIlVSTiBjYW4gbm90IGJlIHBhcnNlZC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJuQ29tcG9uZW50cztcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplJCQxKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudHMuc2NoZW1lIHx8IFwidXJuXCI7XG4gICAgICAgIHZhciBuaWQgPSB1cm5Db21wb25lbnRzLm5pZDtcbiAgICAgICAgdmFyIHVyblNjaGVtZSA9IHNjaGVtZSArIFwiOlwiICsgKG9wdGlvbnMubmlkIHx8IG5pZCk7XG4gICAgICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1t1cm5TY2hlbWVdO1xuICAgICAgICBpZiAoc2NoZW1lSGFuZGxlcikge1xuICAgICAgICAgICAgdXJuQ29tcG9uZW50cyA9IHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cmlDb21wb25lbnRzID0gdXJuQ29tcG9uZW50cztcbiAgICAgICAgdmFyIG5zcyA9IHVybkNvbXBvbmVudHMubnNzO1xuICAgICAgICB1cmlDb21wb25lbnRzLnBhdGggPSAobmlkIHx8IG9wdGlvbnMubmlkKSArIFwiOlwiICsgbnNzO1xuICAgICAgICByZXR1cm4gdXJpQ29tcG9uZW50cztcbiAgICB9XG59O1xuXG52YXIgVVVJRCA9IC9eWzAtOUEtRmEtZl17OH0oPzpcXC1bMC05QS1GYS1mXXs0fSl7M31cXC1bMC05QS1GYS1mXXsxMn0kLztcbi8vUkZDIDQxMjJcbnZhciBoYW5kbGVyJDYgPSB7XG4gICAgc2NoZW1lOiBcInVybjp1dWlkXCIsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHV1aWRDb21wb25lbnRzID0gdXJuQ29tcG9uZW50cztcbiAgICAgICAgdXVpZENvbXBvbmVudHMudXVpZCA9IHV1aWRDb21wb25lbnRzLm5zcztcbiAgICAgICAgdXVpZENvbXBvbmVudHMubnNzID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgKCF1dWlkQ29tcG9uZW50cy51dWlkIHx8ICF1dWlkQ29tcG9uZW50cy51dWlkLm1hdGNoKFVVSUQpKSkge1xuICAgICAgICAgICAgdXVpZENvbXBvbmVudHMuZXJyb3IgPSB1dWlkQ29tcG9uZW50cy5lcnJvciB8fCBcIlVVSUQgaXMgbm90IHZhbGlkLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dWlkQ29tcG9uZW50cztcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplKHV1aWRDb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB1cm5Db21wb25lbnRzID0gdXVpZENvbXBvbmVudHM7XG4gICAgICAgIC8vbm9ybWFsaXplIFVVSURcbiAgICAgICAgdXJuQ29tcG9uZW50cy5uc3MgPSAodXVpZENvbXBvbmVudHMudXVpZCB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gdXJuQ29tcG9uZW50cztcbiAgICB9XG59O1xuXG5TQ0hFTUVTW2hhbmRsZXIuc2NoZW1lXSA9IGhhbmRsZXI7XG5TQ0hFTUVTW2hhbmRsZXIkMS5zY2hlbWVdID0gaGFuZGxlciQxO1xuU0NIRU1FU1toYW5kbGVyJDIuc2NoZW1lXSA9IGhhbmRsZXIkMjtcblNDSEVNRVNbaGFuZGxlciQzLnNjaGVtZV0gPSBoYW5kbGVyJDM7XG5TQ0hFTUVTW2hhbmRsZXIkNC5zY2hlbWVdID0gaGFuZGxlciQ0O1xuU0NIRU1FU1toYW5kbGVyJDUuc2NoZW1lXSA9IGhhbmRsZXIkNTtcblNDSEVNRVNbaGFuZGxlciQ2LnNjaGVtZV0gPSBoYW5kbGVyJDY7XG5cbmV4cG9ydHMuU0NIRU1FUyA9IFNDSEVNRVM7XG5leHBvcnRzLnBjdEVuY0NoYXIgPSBwY3RFbmNDaGFyO1xuZXhwb3J0cy5wY3REZWNDaGFycyA9IHBjdERlY0NoYXJzO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5yZW1vdmVEb3RTZWdtZW50cyA9IHJlbW92ZURvdFNlZ21lbnRzO1xuZXhwb3J0cy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG5leHBvcnRzLnJlc29sdmVDb21wb25lbnRzID0gcmVzb2x2ZUNvbXBvbmVudHM7XG5leHBvcnRzLnJlc29sdmUgPSByZXNvbHZlO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5leHBvcnRzLmVxdWFsID0gZXF1YWw7XG5leHBvcnRzLmVzY2FwZUNvbXBvbmVudCA9IGVzY2FwZUNvbXBvbmVudDtcbmV4cG9ydHMudW5lc2NhcGVDb21wb25lbnQgPSB1bmVzY2FwZUNvbXBvbmVudDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVyaS5hbGwuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0U2NoZW1hUmVmcyA9IGV4cG9ydHMucmVzb2x2ZVVybCA9IGV4cG9ydHMubm9ybWFsaXplSWQgPSBleHBvcnRzLl9nZXRGdWxsUGF0aCA9IGV4cG9ydHMuZ2V0RnVsbFBhdGggPSBleHBvcnRzLmlubGluZVJlZiA9IHZvaWQgMDtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCBlcXVhbCA9IHJlcXVpcmUoXCJmYXN0LWRlZXAtZXF1YWxcIik7XG5jb25zdCB0cmF2ZXJzZSA9IHJlcXVpcmUoXCJqc29uLXNjaGVtYS10cmF2ZXJzZVwiKTtcbmNvbnN0IFVSSSA9IHJlcXVpcmUoXCJ1cmktanNcIik7XG4vLyBUT0RPIHJlZmFjdG9yIHRvIHVzZSBrZXl3b3JkIGRlZmluaXRpb25zXG5jb25zdCBTSU1QTEVfSU5MSU5FRCA9IG5ldyBTZXQoW1xuICAgIFwidHlwZVwiLFxuICAgIFwiZm9ybWF0XCIsXG4gICAgXCJwYXR0ZXJuXCIsXG4gICAgXCJtYXhMZW5ndGhcIixcbiAgICBcIm1pbkxlbmd0aFwiLFxuICAgIFwibWF4UHJvcGVydGllc1wiLFxuICAgIFwibWluUHJvcGVydGllc1wiLFxuICAgIFwibWF4SXRlbXNcIixcbiAgICBcIm1pbkl0ZW1zXCIsXG4gICAgXCJtYXhpbXVtXCIsXG4gICAgXCJtaW5pbXVtXCIsXG4gICAgXCJ1bmlxdWVJdGVtc1wiLFxuICAgIFwibXVsdGlwbGVPZlwiLFxuICAgIFwicmVxdWlyZWRcIixcbiAgICBcImVudW1cIixcbiAgICBcImNvbnN0XCIsXG5dKTtcbmZ1bmN0aW9uIGlubGluZVJlZihzY2hlbWEsIGxpbWl0ID0gdHJ1ZSkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAobGltaXQgPT09IHRydWUpXG4gICAgICAgIHJldHVybiAhaGFzUmVmKHNjaGVtYSk7XG4gICAgaWYgKCFsaW1pdClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBjb3VudEtleXMoc2NoZW1hKSA8PSBsaW1pdDtcbn1cbmV4cG9ydHMuaW5saW5lUmVmID0gaW5saW5lUmVmO1xuY29uc3QgUkVGX0tFWVdPUkRTID0gbmV3IFNldChbXG4gICAgXCIkcmVmXCIsXG4gICAgXCIkcmVjdXJzaXZlUmVmXCIsXG4gICAgXCIkcmVjdXJzaXZlQW5jaG9yXCIsXG4gICAgXCIkZHluYW1pY1JlZlwiLFxuICAgIFwiJGR5bmFtaWNBbmNob3JcIixcbl0pO1xuZnVuY3Rpb24gaGFzUmVmKHNjaGVtYSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBpZiAoUkVGX0tFWVdPUkRTLmhhcyhrZXkpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnN0IHNjaCA9IHNjaGVtYVtrZXldO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2gpICYmIHNjaC5zb21lKGhhc1JlZikpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2ggPT0gXCJvYmplY3RcIiAmJiBoYXNSZWYoc2NoKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjb3VudEtleXMoc2NoZW1hKSB7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCIkcmVmXCIpXG4gICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICAgIGlmIChTSU1QTEVfSU5MSU5FRC5oYXMoa2V5KSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYVtrZXldID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHV0aWxfMS5lYWNoSXRlbShzY2hlbWFba2V5XSwgKHNjaCkgPT4gKGNvdW50ICs9IGNvdW50S2V5cyhzY2gpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50ID09PSBJbmZpbml0eSlcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xufVxuZnVuY3Rpb24gZ2V0RnVsbFBhdGgoaWQgPSBcIlwiLCBub3JtYWxpemUpIHtcbiAgICBpZiAobm9ybWFsaXplICE9PSBmYWxzZSlcbiAgICAgICAgaWQgPSBub3JtYWxpemVJZChpZCk7XG4gICAgY29uc3QgcCA9IFVSSS5wYXJzZShpZCk7XG4gICAgcmV0dXJuIF9nZXRGdWxsUGF0aChwKTtcbn1cbmV4cG9ydHMuZ2V0RnVsbFBhdGggPSBnZXRGdWxsUGF0aDtcbmZ1bmN0aW9uIF9nZXRGdWxsUGF0aChwKSB7XG4gICAgcmV0dXJuIFVSSS5zZXJpYWxpemUocCkuc3BsaXQoXCIjXCIpWzBdICsgXCIjXCI7XG59XG5leHBvcnRzLl9nZXRGdWxsUGF0aCA9IF9nZXRGdWxsUGF0aDtcbmNvbnN0IFRSQUlMSU5HX1NMQVNIX0hBU0ggPSAvI1xcLz8kLztcbmZ1bmN0aW9uIG5vcm1hbGl6ZUlkKGlkKSB7XG4gICAgcmV0dXJuIGlkID8gaWQucmVwbGFjZShUUkFJTElOR19TTEFTSF9IQVNILCBcIlwiKSA6IFwiXCI7XG59XG5leHBvcnRzLm5vcm1hbGl6ZUlkID0gbm9ybWFsaXplSWQ7XG5mdW5jdGlvbiByZXNvbHZlVXJsKGJhc2VJZCwgaWQpIHtcbiAgICBpZCA9IG5vcm1hbGl6ZUlkKGlkKTtcbiAgICByZXR1cm4gVVJJLnJlc29sdmUoYmFzZUlkLCBpZCk7XG59XG5leHBvcnRzLnJlc29sdmVVcmwgPSByZXNvbHZlVXJsO1xuY29uc3QgQU5DSE9SID0gL15bYS16X11bLWEtejAtOS5fXSokL2k7XG5mdW5jdGlvbiBnZXRTY2hlbWFSZWZzKHNjaGVtYSkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4ge307XG4gICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgIGNvbnN0IHNjaElkID0gbm9ybWFsaXplSWQoc2NoZW1hW3NjaGVtYUlkXSk7XG4gICAgY29uc3QgYmFzZUlkcyA9IHsgXCJcIjogc2NoSWQgfTtcbiAgICBjb25zdCBwYXRoUHJlZml4ID0gZ2V0RnVsbFBhdGgoc2NoSWQsIGZhbHNlKTtcbiAgICBjb25zdCBsb2NhbFJlZnMgPSB7fTtcbiAgICBjb25zdCBzY2hlbWFSZWZzID0gbmV3IFNldCgpO1xuICAgIHRyYXZlcnNlKHNjaGVtYSwgeyBhbGxLZXlzOiB0cnVlIH0sIChzY2gsIGpzb25QdHIsIF8sIHBhcmVudEpzb25QdHIpID0+IHtcbiAgICAgICAgaWYgKHBhcmVudEpzb25QdHIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoUHJlZml4ICsganNvblB0cjtcbiAgICAgICAgbGV0IGJhc2VJZCA9IGJhc2VJZHNbcGFyZW50SnNvblB0cl07XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoW3NjaGVtYUlkXSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgYmFzZUlkID0gYWRkUmVmLmNhbGwodGhpcywgc2NoW3NjaGVtYUlkXSk7XG4gICAgICAgIGFkZEFuY2hvci5jYWxsKHRoaXMsIHNjaC4kYW5jaG9yKTtcbiAgICAgICAgYWRkQW5jaG9yLmNhbGwodGhpcywgc2NoLiRkeW5hbWljQW5jaG9yKTtcbiAgICAgICAgYmFzZUlkc1tqc29uUHRyXSA9IGJhc2VJZDtcbiAgICAgICAgZnVuY3Rpb24gYWRkUmVmKHJlZikge1xuICAgICAgICAgICAgcmVmID0gbm9ybWFsaXplSWQoYmFzZUlkID8gVVJJLnJlc29sdmUoYmFzZUlkLCByZWYpIDogcmVmKTtcbiAgICAgICAgICAgIGlmIChzY2hlbWFSZWZzLmhhcyhyZWYpKVxuICAgICAgICAgICAgICAgIHRocm93IGFtYmlndW9zKHJlZik7XG4gICAgICAgICAgICBzY2hlbWFSZWZzLmFkZChyZWYpO1xuICAgICAgICAgICAgbGV0IHNjaE9yUmVmID0gdGhpcy5yZWZzW3JlZl07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaE9yUmVmID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgc2NoT3JSZWYgPSB0aGlzLnJlZnNbc2NoT3JSZWZdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hPclJlZiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tBbWJpZ3Vvc1JlZihzY2gsIHNjaE9yUmVmLnNjaGVtYSwgcmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlZiAhPT0gbm9ybWFsaXplSWQoZnVsbFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZlswXSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tBbWJpZ3Vvc1JlZihzY2gsIGxvY2FsUmVmc1tyZWZdLCByZWYpO1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFJlZnNbcmVmXSA9IHNjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmc1tyZWZdID0gZnVsbFBhdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlZjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRBbmNob3IoYW5jaG9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFuY2hvciA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBTkNIT1IudGVzdChhbmNob3IpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgYW5jaG9yIFwiJHthbmNob3J9XCJgKTtcbiAgICAgICAgICAgICAgICBhZGRSZWYuY2FsbCh0aGlzLCBgIyR7YW5jaG9yfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGxvY2FsUmVmcztcbiAgICBmdW5jdGlvbiBjaGVja0FtYmlndW9zUmVmKHNjaDEsIHNjaDIsIHJlZikge1xuICAgICAgICBpZiAoc2NoMiAhPT0gdW5kZWZpbmVkICYmICFlcXVhbChzY2gxLCBzY2gyKSlcbiAgICAgICAgICAgIHRocm93IGFtYmlndW9zKHJlZik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFtYmlndW9zKHJlZikge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKGByZWZlcmVuY2UgXCIke3JlZn1cIiByZXNvbHZlcyB0byBtb3JlIHRoYW4gb25lIHNjaGVtYWApO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0U2NoZW1hUmVmcyA9IGdldFNjaGVtYVJlZnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXREYXRhID0gZXhwb3J0cy5LZXl3b3JkQ3h0ID0gZXhwb3J0cy52YWxpZGF0ZUZ1bmN0aW9uQ29kZSA9IHZvaWQgMDtcbmNvbnN0IGJvb2xTY2hlbWFfMSA9IHJlcXVpcmUoXCIuL2Jvb2xTY2hlbWFcIik7XG5jb25zdCBkYXRhVHlwZV8xID0gcmVxdWlyZShcIi4vZGF0YVR5cGVcIik7XG5jb25zdCBhcHBsaWNhYmlsaXR5XzEgPSByZXF1aXJlKFwiLi9hcHBsaWNhYmlsaXR5XCIpO1xuY29uc3QgZGF0YVR5cGVfMiA9IHJlcXVpcmUoXCIuL2RhdGFUeXBlXCIpO1xuY29uc3QgZGVmYXVsdHNfMSA9IHJlcXVpcmUoXCIuL2RlZmF1bHRzXCIpO1xuY29uc3Qga2V5d29yZF8xID0gcmVxdWlyZShcIi4va2V5d29yZFwiKTtcbmNvbnN0IHN1YnNjaGVtYV8xID0gcmVxdWlyZShcIi4vc3Vic2NoZW1hXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uL25hbWVzXCIpO1xuY29uc3QgcmVzb2x2ZV8xID0gcmVxdWlyZShcIi4uL3Jlc29sdmVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbi8vIHNjaGVtYSBjb21waWxhdGlvbiAtIGdlbmVyYXRlcyB2YWxpZGF0aW9uIGZ1bmN0aW9uLCBzdWJzY2hlbWFDb2RlIChiZWxvdykgaXMgdXNlZCBmb3Igc3Vic2NoZW1hc1xuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvZGUoaXQpIHtcbiAgICBpZiAoaXNTY2hlbWFPYmooaXQpKSB7XG4gICAgICAgIGNoZWNrS2V5d29yZHMoaXQpO1xuICAgICAgICBpZiAoc2NoZW1hQ3h0SGFzUnVsZXMoaXQpKSB7XG4gICAgICAgICAgICB0b3BTY2hlbWFPYmpDb2RlKGl0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YWxpZGF0ZUZ1bmN0aW9uKGl0LCAoKSA9PiBib29sU2NoZW1hXzEudG9wQm9vbE9yRW1wdHlTY2hlbWEoaXQpKTtcbn1cbmV4cG9ydHMudmFsaWRhdGVGdW5jdGlvbkNvZGUgPSB2YWxpZGF0ZUZ1bmN0aW9uQ29kZTtcbmZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb24oeyBnZW4sIHZhbGlkYXRlTmFtZSwgc2NoZW1hLCBzY2hlbWFFbnYsIG9wdHMgfSwgYm9keSkge1xuICAgIGlmIChvcHRzLmNvZGUuZXM1KSB7XG4gICAgICAgIGdlbi5mdW5jKHZhbGlkYXRlTmFtZSwgY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LmRhdGF9LCAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9YCwgc2NoZW1hRW52LiRhc3luYywgKCkgPT4ge1xuICAgICAgICAgICAgZ2VuLmNvZGUoY29kZWdlbl8xLl8gYFwidXNlIHN0cmljdFwiOyAke2Z1bmNTb3VyY2VVcmwoc2NoZW1hLCBvcHRzKX1gKTtcbiAgICAgICAgICAgIGRlc3RydWN0dXJlVmFsQ3h0RVM1KGdlbiwgb3B0cyk7XG4gICAgICAgICAgICBnZW4uY29kZShib2R5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW4uZnVuYyh2YWxpZGF0ZU5hbWUsIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC5kYXRhfSwgJHtkZXN0cnVjdHVyZVZhbEN4dChvcHRzKX1gLCBzY2hlbWFFbnYuJGFzeW5jLCAoKSA9PiBnZW4uY29kZShmdW5jU291cmNlVXJsKHNjaGVtYSwgb3B0cykpLmNvZGUoYm9keSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlc3RydWN0dXJlVmFsQ3h0KG9wdHMpIHtcbiAgICByZXR1cm4gY29kZWdlbl8xLl8gYHske25hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGh9PVwiXCIsICR7bmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGF9LCAke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHl9LCAke25hbWVzXzEuZGVmYXVsdC5yb290RGF0YX09JHtuYW1lc18xLmRlZmF1bHQuZGF0YX0ke29wdHMuZHluYW1pY1JlZiA/IGNvZGVnZW5fMS5fIGAsICR7bmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzfT17fWAgOiBjb2RlZ2VuXzEubmlsfX09e31gO1xufVxuZnVuY3Rpb24gZGVzdHJ1Y3R1cmVWYWxDeHRFUzUoZ2VuLCBvcHRzKSB7XG4gICAgZ2VuLmlmKG5hbWVzXzEuZGVmYXVsdC52YWxDeHQsICgpID0+IHtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fS4ke25hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGh9YCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGEsIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGF9YCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSwgY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5fWApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5yb290RGF0YSwgY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQucm9vdERhdGF9YCk7XG4gICAgICAgIGlmIChvcHRzLmR5bmFtaWNSZWYpXG4gICAgICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9ycywgY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnN9YCk7XG4gICAgfSwgKCkgPT4ge1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsIGNvZGVnZW5fMS5fIGBcIlwiYCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGEsIGNvZGVnZW5fMS5fIGB1bmRlZmluZWRgKTtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5LCBjb2RlZ2VuXzEuXyBgdW5kZWZpbmVkYCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhLCBuYW1lc18xLmRlZmF1bHQuZGF0YSk7XG4gICAgICAgIGlmIChvcHRzLmR5bmFtaWNSZWYpXG4gICAgICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9ycywgY29kZWdlbl8xLl8gYHt9YCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB0b3BTY2hlbWFPYmpDb2RlKGl0KSB7XG4gICAgY29uc3QgeyBzY2hlbWEsIG9wdHMsIGdlbiB9ID0gaXQ7XG4gICAgdmFsaWRhdGVGdW5jdGlvbihpdCwgKCkgPT4ge1xuICAgICAgICBpZiAob3B0cy4kY29tbWVudCAmJiBzY2hlbWEuJGNvbW1lbnQpXG4gICAgICAgICAgICBjb21tZW50S2V5d29yZChpdCk7XG4gICAgICAgIGNoZWNrTm9EZWZhdWx0KGl0KTtcbiAgICAgICAgZ2VuLmxldChuYW1lc18xLmRlZmF1bHQudkVycm9ycywgbnVsbCk7XG4gICAgICAgIGdlbi5sZXQobmFtZXNfMS5kZWZhdWx0LmVycm9ycywgMCk7XG4gICAgICAgIGlmIChvcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICAgICAgcmVzZXRFdmFsdWF0ZWQoaXQpO1xuICAgICAgICB0eXBlQW5kS2V5d29yZHMoaXQpO1xuICAgICAgICByZXR1cm5SZXN1bHRzKGl0KTtcbiAgICB9KTtcbiAgICByZXR1cm47XG59XG5mdW5jdGlvbiByZXNldEV2YWx1YXRlZChpdCkge1xuICAgIC8vIFRPRE8gbWF5YmUgc29tZSBob29rIHRvIGV4ZWN1dGUgaXQgaW4gdGhlIGVuZCB0byBjaGVjayB3aGV0aGVyIHByb3BzL2l0ZW1zIGFyZSBOYW1lLCBhcyBpbiBhc3NpZ25FdmFsdWF0ZWRcbiAgICBjb25zdCB7IGdlbiwgdmFsaWRhdGVOYW1lIH0gPSBpdDtcbiAgICBpdC5ldmFsdWF0ZWQgPSBnZW4uY29uc3QoXCJldmFsdWF0ZWRcIiwgY29kZWdlbl8xLl8gYCR7dmFsaWRhdGVOYW1lfS5ldmFsdWF0ZWRgKTtcbiAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7aXQuZXZhbHVhdGVkfS5keW5hbWljUHJvcHNgLCAoKSA9PiBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke2l0LmV2YWx1YXRlZH0ucHJvcHNgLCBjb2RlZ2VuXzEuXyBgdW5kZWZpbmVkYCkpO1xuICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtpdC5ldmFsdWF0ZWR9LmR5bmFtaWNJdGVtc2AsICgpID0+IGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7aXQuZXZhbHVhdGVkfS5pdGVtc2AsIGNvZGVnZW5fMS5fIGB1bmRlZmluZWRgKSk7XG59XG5mdW5jdGlvbiBmdW5jU291cmNlVXJsKHNjaGVtYSwgb3B0cykge1xuICAgIGNvbnN0IHNjaElkID0gdHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmIHNjaGVtYVtvcHRzLnNjaGVtYUlkXTtcbiAgICByZXR1cm4gc2NoSWQgJiYgKG9wdHMuY29kZS5zb3VyY2UgfHwgb3B0cy5jb2RlLnByb2Nlc3MpID8gY29kZWdlbl8xLl8gYC8qIyBzb3VyY2VVUkw9JHtzY2hJZH0gKi9gIDogY29kZWdlbl8xLm5pbDtcbn1cbi8vIHNjaGVtYSBjb21waWxhdGlvbiAtIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCByZWN1cnNpdmVseSB0byBnZW5lcmF0ZSBjb2RlIGZvciBzdWItc2NoZW1hc1xuZnVuY3Rpb24gc3Vic2NoZW1hQ29kZShpdCwgdmFsaWQpIHtcbiAgICBpZiAoaXNTY2hlbWFPYmooaXQpKSB7XG4gICAgICAgIGNoZWNrS2V5d29yZHMoaXQpO1xuICAgICAgICBpZiAoc2NoZW1hQ3h0SGFzUnVsZXMoaXQpKSB7XG4gICAgICAgICAgICBzdWJTY2hlbWFPYmpDb2RlKGl0LCB2YWxpZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgYm9vbFNjaGVtYV8xLmJvb2xPckVtcHR5U2NoZW1hKGl0LCB2YWxpZCk7XG59XG5mdW5jdGlvbiBzY2hlbWFDeHRIYXNSdWxlcyh7IHNjaGVtYSwgc2VsZiB9KSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiAhc2NoZW1hO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSlcbiAgICAgICAgaWYgKHNlbGYuUlVMRVMuYWxsW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1NjaGVtYU9iaihpdCkge1xuICAgIHJldHVybiB0eXBlb2YgaXQuc2NoZW1hICE9IFwiYm9vbGVhblwiO1xufVxuZnVuY3Rpb24gc3ViU2NoZW1hT2JqQ29kZShpdCwgdmFsaWQpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgZ2VuLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAob3B0cy4kY29tbWVudCAmJiBzY2hlbWEuJGNvbW1lbnQpXG4gICAgICAgIGNvbW1lbnRLZXl3b3JkKGl0KTtcbiAgICB1cGRhdGVDb250ZXh0KGl0KTtcbiAgICBjaGVja0FzeW5jU2NoZW1hKGl0KTtcbiAgICBjb25zdCBlcnJzQ291bnQgPSBnZW4uY29uc3QoXCJfZXJyc1wiLCBuYW1lc18xLmRlZmF1bHQuZXJyb3JzKTtcbiAgICB0eXBlQW5kS2V5d29yZHMoaXQsIGVycnNDb3VudCk7XG4gICAgLy8gVE9ETyB2YXJcbiAgICBnZW4udmFyKHZhbGlkLCBjb2RlZ2VuXzEuXyBgJHtlcnJzQ291bnR9ID09PSAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9YCk7XG59XG5mdW5jdGlvbiBjaGVja0tleXdvcmRzKGl0KSB7XG4gICAgdXRpbF8xLmNoZWNrVW5rbm93blJ1bGVzKGl0KTtcbiAgICBjaGVja1JlZnNBbmRLZXl3b3JkcyhpdCk7XG59XG5mdW5jdGlvbiB0eXBlQW5kS2V5d29yZHMoaXQsIGVycnNDb3VudCkge1xuICAgIGlmIChpdC5vcHRzLmp0ZClcbiAgICAgICAgcmV0dXJuIHNjaGVtYUtleXdvcmRzKGl0LCBbXSwgZmFsc2UsIGVycnNDb3VudCk7XG4gICAgY29uc3QgdHlwZXMgPSBkYXRhVHlwZV8xLmdldFNjaGVtYVR5cGVzKGl0LnNjaGVtYSk7XG4gICAgY29uc3QgY2hlY2tlZFR5cGVzID0gZGF0YVR5cGVfMS5jb2VyY2VBbmRDaGVja0RhdGFUeXBlKGl0LCB0eXBlcyk7XG4gICAgc2NoZW1hS2V5d29yZHMoaXQsIHR5cGVzLCAhY2hlY2tlZFR5cGVzLCBlcnJzQ291bnQpO1xufVxuZnVuY3Rpb24gY2hlY2tSZWZzQW5kS2V5d29yZHMoaXQpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgZXJyU2NoZW1hUGF0aCwgb3B0cywgc2VsZiB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYS4kcmVmICYmIG9wdHMuaWdub3JlS2V5d29yZHNXaXRoUmVmICYmIHV0aWxfMS5zY2hlbWFIYXNSdWxlc0J1dFJlZihzY2hlbWEsIHNlbGYuUlVMRVMpKSB7XG4gICAgICAgIHNlbGYubG9nZ2VyLndhcm4oYCRyZWY6IGtleXdvcmRzIGlnbm9yZWQgaW4gc2NoZW1hIGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCJgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja05vRGVmYXVsdChpdCkge1xuICAgIGNvbnN0IHsgc2NoZW1hLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hLmRlZmF1bHQgIT09IHVuZGVmaW5lZCAmJiBvcHRzLnVzZURlZmF1bHRzICYmIG9wdHMuc3RyaWN0U2NoZW1hKSB7XG4gICAgICAgIHV0aWxfMS5jaGVja1N0cmljdE1vZGUoaXQsIFwiZGVmYXVsdCBpcyBpZ25vcmVkIGluIHRoZSBzY2hlbWEgcm9vdFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0KGl0KSB7XG4gICAgY29uc3Qgc2NoSWQgPSBpdC5zY2hlbWFbaXQub3B0cy5zY2hlbWFJZF07XG4gICAgaWYgKHNjaElkKVxuICAgICAgICBpdC5iYXNlSWQgPSByZXNvbHZlXzEucmVzb2x2ZVVybChpdC5iYXNlSWQsIHNjaElkKTtcbn1cbmZ1bmN0aW9uIGNoZWNrQXN5bmNTY2hlbWEoaXQpIHtcbiAgICBpZiAoaXQuc2NoZW1hLiRhc3luYyAmJiAhaXQuc2NoZW1hRW52LiRhc3luYylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMgc2NoZW1hIGluIHN5bmMgc2NoZW1hXCIpO1xufVxuZnVuY3Rpb24gY29tbWVudEtleXdvcmQoeyBnZW4sIHNjaGVtYUVudiwgc2NoZW1hLCBlcnJTY2hlbWFQYXRoLCBvcHRzIH0pIHtcbiAgICBjb25zdCBtc2cgPSBzY2hlbWEuJGNvbW1lbnQ7XG4gICAgaWYgKG9wdHMuJGNvbW1lbnQgPT09IHRydWUpIHtcbiAgICAgICAgZ2VuLmNvZGUoY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnNlbGZ9LmxvZ2dlci5sb2coJHttc2d9KWApO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb3B0cy4kY29tbWVudCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hUGF0aCA9IGNvZGVnZW5fMS5zdHIgYCR7ZXJyU2NoZW1hUGF0aH0vJGNvbW1lbnRgO1xuICAgICAgICBjb25zdCByb290TmFtZSA9IGdlbi5zY29wZVZhbHVlKFwicm9vdFwiLCB7IHJlZjogc2NoZW1hRW52LnJvb3QgfSk7XG4gICAgICAgIGdlbi5jb2RlKGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC5zZWxmfS5vcHRzLiRjb21tZW50KCR7bXNnfSwgJHtzY2hlbWFQYXRofSwgJHtyb290TmFtZX0uc2NoZW1hKWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJldHVyblJlc3VsdHMoaXQpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hRW52LCB2YWxpZGF0ZU5hbWUsIFZhbGlkYXRpb25FcnJvciwgb3B0cyB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYUVudi4kYXN5bmMpIHtcbiAgICAgICAgLy8gVE9ETyBhc3NpZ24gdW5ldmFsdWF0ZWRcbiAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9ID09PSAwYCwgKCkgPT4gZ2VuLnJldHVybihuYW1lc18xLmRlZmF1bHQuZGF0YSksICgpID0+IGdlbi50aHJvdyhjb2RlZ2VuXzEuXyBgbmV3ICR7VmFsaWRhdGlvbkVycm9yfSgke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfSlgKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke3ZhbGlkYXRlTmFtZX0uZXJyb3JzYCwgbmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMpO1xuICAgICAgICBpZiAob3B0cy51bmV2YWx1YXRlZClcbiAgICAgICAgICAgIGFzc2lnbkV2YWx1YXRlZChpdCk7XG4gICAgICAgIGdlbi5yZXR1cm4oY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc30gPT09IDBgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NpZ25FdmFsdWF0ZWQoeyBnZW4sIGV2YWx1YXRlZCwgcHJvcHMsIGl0ZW1zIH0pIHtcbiAgICBpZiAocHJvcHMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSlcbiAgICAgICAgZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHtldmFsdWF0ZWR9LnByb3BzYCwgcHJvcHMpO1xuICAgIGlmIChpdGVtcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKVxuICAgICAgICBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke2V2YWx1YXRlZH0uaXRlbXNgLCBpdGVtcyk7XG59XG5mdW5jdGlvbiBzY2hlbWFLZXl3b3JkcyhpdCwgdHlwZXMsIHR5cGVFcnJvcnMsIGVycnNDb3VudCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGRhdGEsIGFsbEVycm9ycywgb3B0cywgc2VsZiB9ID0gaXQ7XG4gICAgY29uc3QgeyBSVUxFUyB9ID0gc2VsZjtcbiAgICBpZiAoc2NoZW1hLiRyZWYgJiYgKG9wdHMuaWdub3JlS2V5d29yZHNXaXRoUmVmIHx8ICF1dGlsXzEuc2NoZW1hSGFzUnVsZXNCdXRSZWYoc2NoZW1hLCBSVUxFUykpKSB7XG4gICAgICAgIGdlbi5ibG9jaygoKSA9PiBrZXl3b3JkQ29kZShpdCwgXCIkcmVmXCIsIFJVTEVTLmFsbC4kcmVmLmRlZmluaXRpb24pKTsgLy8gVE9ETyB0eXBlY2FzdFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghb3B0cy5qdGQpXG4gICAgICAgIGNoZWNrU3RyaWN0VHlwZXMoaXQsIHR5cGVzKTtcbiAgICBnZW4uYmxvY2soKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIFJVTEVTLnJ1bGVzKVxuICAgICAgICAgICAgZ3JvdXBLZXl3b3Jkcyhncm91cCk7XG4gICAgICAgIGdyb3VwS2V5d29yZHMoUlVMRVMucG9zdCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gZ3JvdXBLZXl3b3Jkcyhncm91cCkge1xuICAgICAgICBpZiAoIWFwcGxpY2FiaWxpdHlfMS5zaG91bGRVc2VHcm91cChzY2hlbWEsIGdyb3VwKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGdyb3VwLnR5cGUpIHtcbiAgICAgICAgICAgIGdlbi5pZihkYXRhVHlwZV8yLmNoZWNrRGF0YVR5cGUoZ3JvdXAudHlwZSwgZGF0YSwgb3B0cy5zdHJpY3ROdW1iZXJzKSk7XG4gICAgICAgICAgICBpdGVyYXRlS2V5d29yZHMoaXQsIGdyb3VwKTtcbiAgICAgICAgICAgIGlmICh0eXBlcy5sZW5ndGggPT09IDEgJiYgdHlwZXNbMF0gPT09IGdyb3VwLnR5cGUgJiYgdHlwZUVycm9ycykge1xuICAgICAgICAgICAgICAgIGdlbi5lbHNlKCk7XG4gICAgICAgICAgICAgICAgZGF0YVR5cGVfMi5yZXBvcnRUeXBlRXJyb3IoaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVyYXRlS2V5d29yZHMoaXQsIGdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIG1ha2UgaXQgXCJva1wiIGNhbGw/XG4gICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9ID09PSAke2VycnNDb3VudCB8fCAwfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGl0ZXJhdGVLZXl3b3JkcyhpdCwgZ3JvdXApIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBvcHRzOiB7IHVzZURlZmF1bHRzIH0sIH0gPSBpdDtcbiAgICBpZiAodXNlRGVmYXVsdHMpXG4gICAgICAgIGRlZmF1bHRzXzEuYXNzaWduRGVmYXVsdHMoaXQsIGdyb3VwLnR5cGUpO1xuICAgIGdlbi5ibG9jaygoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgcnVsZSBvZiBncm91cC5ydWxlcykge1xuICAgICAgICAgICAgaWYgKGFwcGxpY2FiaWxpdHlfMS5zaG91bGRVc2VSdWxlKHNjaGVtYSwgcnVsZSkpIHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkQ29kZShpdCwgcnVsZS5rZXl3b3JkLCBydWxlLmRlZmluaXRpb24sIGdyb3VwLnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjaGVja1N0cmljdFR5cGVzKGl0LCB0eXBlcykge1xuICAgIGlmIChpdC5zY2hlbWFFbnYubWV0YSB8fCAhaXQub3B0cy5zdHJpY3RUeXBlcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGNoZWNrQ29udGV4dFR5cGVzKGl0LCB0eXBlcyk7XG4gICAgaWYgKCFpdC5vcHRzLmFsbG93VW5pb25UeXBlcylcbiAgICAgICAgY2hlY2tNdWx0aXBsZVR5cGVzKGl0LCB0eXBlcyk7XG4gICAgY2hlY2tLZXl3b3JkVHlwZXMoaXQsIGl0LmRhdGFUeXBlcyk7XG59XG5mdW5jdGlvbiBjaGVja0NvbnRleHRUeXBlcyhpdCwgdHlwZXMpIHtcbiAgICBpZiAoIXR5cGVzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghaXQuZGF0YVR5cGVzLmxlbmd0aCkge1xuICAgICAgICBpdC5kYXRhVHlwZXMgPSB0eXBlcztcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0eXBlcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgIGlmICghaW5jbHVkZXNUeXBlKGl0LmRhdGFUeXBlcywgdCkpIHtcbiAgICAgICAgICAgIHN0cmljdFR5cGVzRXJyb3IoaXQsIGB0eXBlIFwiJHt0fVwiIG5vdCBhbGxvd2VkIGJ5IGNvbnRleHQgXCIke2l0LmRhdGFUeXBlcy5qb2luKFwiLFwiKX1cImApO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaXQuZGF0YVR5cGVzID0gaXQuZGF0YVR5cGVzLmZpbHRlcigodCkgPT4gaW5jbHVkZXNUeXBlKHR5cGVzLCB0KSk7XG59XG5mdW5jdGlvbiBjaGVja011bHRpcGxlVHlwZXMoaXQsIHRzKSB7XG4gICAgaWYgKHRzLmxlbmd0aCA+IDEgJiYgISh0cy5sZW5ndGggPT09IDIgJiYgdHMuaW5jbHVkZXMoXCJudWxsXCIpKSkge1xuICAgICAgICBzdHJpY3RUeXBlc0Vycm9yKGl0LCBcInVzZSBhbGxvd1VuaW9uVHlwZXMgdG8gYWxsb3cgdW5pb24gdHlwZSBrZXl3b3JkXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrS2V5d29yZFR5cGVzKGl0LCB0cykge1xuICAgIGNvbnN0IHJ1bGVzID0gaXQuc2VsZi5SVUxFUy5hbGw7XG4gICAgZm9yIChjb25zdCBrZXl3b3JkIGluIHJ1bGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSBydWxlc1trZXl3b3JkXTtcbiAgICAgICAgaWYgKHR5cGVvZiBydWxlID09IFwib2JqZWN0XCIgJiYgYXBwbGljYWJpbGl0eV8xLnNob3VsZFVzZVJ1bGUoaXQuc2NoZW1hLCBydWxlKSkge1xuICAgICAgICAgICAgY29uc3QgeyB0eXBlIH0gPSBydWxlLmRlZmluaXRpb247XG4gICAgICAgICAgICBpZiAodHlwZS5sZW5ndGggJiYgIXR5cGUuc29tZSgodCkgPT4gaGFzQXBwbGljYWJsZVR5cGUodHMsIHQpKSkge1xuICAgICAgICAgICAgICAgIHN0cmljdFR5cGVzRXJyb3IoaXQsIGBtaXNzaW5nIHR5cGUgXCIke3R5cGUuam9pbihcIixcIil9XCIgZm9yIGtleXdvcmQgXCIke2tleXdvcmR9XCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGhhc0FwcGxpY2FibGVUeXBlKHNjaFRzLCBrd2RUKSB7XG4gICAgcmV0dXJuIHNjaFRzLmluY2x1ZGVzKGt3ZFQpIHx8IChrd2RUID09PSBcIm51bWJlclwiICYmIHNjaFRzLmluY2x1ZGVzKFwiaW50ZWdlclwiKSk7XG59XG5mdW5jdGlvbiBpbmNsdWRlc1R5cGUodHMsIHQpIHtcbiAgICByZXR1cm4gdHMuaW5jbHVkZXModCkgfHwgKHQgPT09IFwiaW50ZWdlclwiICYmIHRzLmluY2x1ZGVzKFwibnVtYmVyXCIpKTtcbn1cbmZ1bmN0aW9uIHN0cmljdFR5cGVzRXJyb3IoaXQsIG1zZykge1xuICAgIGNvbnN0IHNjaGVtYVBhdGggPSBpdC5zY2hlbWFFbnYuYmFzZUlkICsgaXQuZXJyU2NoZW1hUGF0aDtcbiAgICBtc2cgKz0gYCBhdCBcIiR7c2NoZW1hUGF0aH1cIiAoc3RyaWN0VHlwZXMpYDtcbiAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCBtc2csIGl0Lm9wdHMuc3RyaWN0VHlwZXMpO1xufVxuY2xhc3MgS2V5d29yZEN4dCB7XG4gICAgY29uc3RydWN0b3IoaXQsIGRlZiwga2V5d29yZCkge1xuICAgICAgICBrZXl3b3JkXzEudmFsaWRhdGVLZXl3b3JkVXNhZ2UoaXQsIGRlZiwga2V5d29yZCk7XG4gICAgICAgIHRoaXMuZ2VuID0gaXQuZ2VuO1xuICAgICAgICB0aGlzLmFsbEVycm9ycyA9IGl0LmFsbEVycm9ycztcbiAgICAgICAgdGhpcy5rZXl3b3JkID0ga2V5d29yZDtcbiAgICAgICAgdGhpcy5kYXRhID0gaXQuZGF0YTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBpdC5zY2hlbWFba2V5d29yZF07XG4gICAgICAgIHRoaXMuJGRhdGEgPSBkZWYuJGRhdGEgJiYgaXQub3B0cy4kZGF0YSAmJiB0aGlzLnNjaGVtYSAmJiB0aGlzLnNjaGVtYS4kZGF0YTtcbiAgICAgICAgdGhpcy5zY2hlbWFWYWx1ZSA9IHV0aWxfMS5zY2hlbWFSZWZPclZhbChpdCwgdGhpcy5zY2hlbWEsIGtleXdvcmQsIHRoaXMuJGRhdGEpO1xuICAgICAgICB0aGlzLnNjaGVtYVR5cGUgPSBkZWYuc2NoZW1hVHlwZTtcbiAgICAgICAgdGhpcy5wYXJlbnRTY2hlbWEgPSBpdC5zY2hlbWE7XG4gICAgICAgIHRoaXMucGFyYW1zID0ge307XG4gICAgICAgIHRoaXMuaXQgPSBpdDtcbiAgICAgICAgdGhpcy5kZWYgPSBkZWY7XG4gICAgICAgIGlmICh0aGlzLiRkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVtYUNvZGUgPSBpdC5nZW4uY29uc3QoXCJ2U2NoZW1hXCIsIGdldERhdGEodGhpcy4kZGF0YSwgaXQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hQ29kZSA9IHRoaXMuc2NoZW1hVmFsdWU7XG4gICAgICAgICAgICBpZiAoIWtleXdvcmRfMS52YWxpZFNjaGVtYVR5cGUodGhpcy5zY2hlbWEsIGRlZi5zY2hlbWFUeXBlLCBkZWYuYWxsb3dVbmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2tleXdvcmR9IHZhbHVlIG11c3QgYmUgJHtKU09OLnN0cmluZ2lmeShkZWYuc2NoZW1hVHlwZSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiY29kZVwiIGluIGRlZiA/IGRlZi50cmFja0Vycm9ycyA6IGRlZi5lcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLmVycnNDb3VudCA9IGl0Lmdlbi5jb25zdChcIl9lcnJzXCIsIG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VsdChjb25kaXRpb24sIHN1Y2Nlc3NBY3Rpb24sIGZhaWxBY3Rpb24pIHtcbiAgICAgICAgdGhpcy5mYWlsUmVzdWx0KGNvZGVnZW5fMS5ub3QoY29uZGl0aW9uKSwgc3VjY2Vzc0FjdGlvbiwgZmFpbEFjdGlvbik7XG4gICAgfVxuICAgIGZhaWxSZXN1bHQoY29uZGl0aW9uLCBzdWNjZXNzQWN0aW9uLCBmYWlsQWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZ2VuLmlmKGNvbmRpdGlvbik7XG4gICAgICAgIGlmIChmYWlsQWN0aW9uKVxuICAgICAgICAgICAgZmFpbEFjdGlvbigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmVycm9yKCk7XG4gICAgICAgIGlmIChzdWNjZXNzQWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmdlbi5lbHNlKCk7XG4gICAgICAgICAgICBzdWNjZXNzQWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5nZW4uZW5kSWYoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbEVycm9ycylcbiAgICAgICAgICAgICAgICB0aGlzLmdlbi5lbmRJZigpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuLmVsc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXNzKGNvbmRpdGlvbiwgZmFpbEFjdGlvbikge1xuICAgICAgICB0aGlzLmZhaWxSZXN1bHQoY29kZWdlbl8xLm5vdChjb25kaXRpb24pLCB1bmRlZmluZWQsIGZhaWxBY3Rpb24pO1xuICAgIH1cbiAgICBmYWlsKGNvbmRpdGlvbikge1xuICAgICAgICBpZiAoY29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5nZW4uaWYoZmFsc2UpOyAvLyB0aGlzIGJyYW5jaCB3aWxsIGJlIHJlbW92ZWQgYnkgZ2VuLm9wdGltaXplXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZW4uaWYoY29uZGl0aW9uKTtcbiAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgICBpZiAodGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICB0aGlzLmdlbi5lbmRJZigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmdlbi5lbHNlKCk7XG4gICAgfVxuICAgIGZhaWwkZGF0YShjb25kaXRpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLiRkYXRhKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbChjb25kaXRpb24pO1xuICAgICAgICBjb25zdCB7IHNjaGVtYUNvZGUgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZmFpbChjb2RlZ2VuXzEuXyBgJHtzY2hlbWFDb2RlfSAhPT0gdW5kZWZpbmVkICYmICgke2NvZGVnZW5fMS5vcih0aGlzLmludmFsaWQkZGF0YSgpLCBjb25kaXRpb24pfSlgKTtcbiAgICB9XG4gICAgZXJyb3IoYXBwZW5kLCBlcnJvclBhcmFtcywgZXJyb3JQYXRocykge1xuICAgICAgICBpZiAoZXJyb3JQYXJhbXMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UGFyYW1zKGVycm9yUGFyYW1zKTtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKGFwcGVuZCwgZXJyb3JQYXRocyk7XG4gICAgICAgICAgICB0aGlzLnNldFBhcmFtcyh7fSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZXJyb3IoYXBwZW5kLCBlcnJvclBhdGhzKTtcbiAgICB9XG4gICAgX2Vycm9yKGFwcGVuZCwgZXJyb3JQYXRocykge1xuICAgICAgICA7XG4gICAgICAgIChhcHBlbmQgPyBlcnJvcnNfMS5yZXBvcnRFeHRyYUVycm9yIDogZXJyb3JzXzEucmVwb3J0RXJyb3IpKHRoaXMsIHRoaXMuZGVmLmVycm9yLCBlcnJvclBhdGhzKTtcbiAgICB9XG4gICAgJGRhdGFFcnJvcigpIHtcbiAgICAgICAgZXJyb3JzXzEucmVwb3J0RXJyb3IodGhpcywgdGhpcy5kZWYuJGRhdGFFcnJvciB8fCBlcnJvcnNfMS5rZXl3b3JkJERhdGFFcnJvcik7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5lcnJzQ291bnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWRkIFwidHJhY2tFcnJvcnNcIiB0byBrZXl3b3JkIGRlZmluaXRpb24nKTtcbiAgICAgICAgZXJyb3JzXzEucmVzZXRFcnJvcnNDb3VudCh0aGlzLmdlbiwgdGhpcy5lcnJzQ291bnQpO1xuICAgIH1cbiAgICBvayhjb25kKSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICB0aGlzLmdlbi5pZihjb25kKTtcbiAgICB9XG4gICAgc2V0UGFyYW1zKG9iaiwgYXNzaWduKSB7XG4gICAgICAgIGlmIChhc3NpZ24pXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMucGFyYW1zLCBvYmopO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnBhcmFtcyA9IG9iajtcbiAgICB9XG4gICAgYmxvY2skZGF0YSh2YWxpZCwgY29kZUJsb2NrLCAkZGF0YVZhbGlkID0gY29kZWdlbl8xLm5pbCkge1xuICAgICAgICB0aGlzLmdlbi5ibG9jaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrJGRhdGEodmFsaWQsICRkYXRhVmFsaWQpO1xuICAgICAgICAgICAgY29kZUJsb2NrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjaGVjayRkYXRhKHZhbGlkID0gY29kZWdlbl8xLm5pbCwgJGRhdGFWYWxpZCA9IGNvZGVnZW5fMS5uaWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRkYXRhKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hQ29kZSwgc2NoZW1hVHlwZSwgZGVmIH0gPSB0aGlzO1xuICAgICAgICBnZW4uaWYoY29kZWdlbl8xLm9yKGNvZGVnZW5fMS5fIGAke3NjaGVtYUNvZGV9ID09PSB1bmRlZmluZWRgLCAkZGF0YVZhbGlkKSk7XG4gICAgICAgIGlmICh2YWxpZCAhPT0gY29kZWdlbl8xLm5pbClcbiAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICBpZiAoc2NoZW1hVHlwZS5sZW5ndGggfHwgZGVmLnZhbGlkYXRlU2NoZW1hKSB7XG4gICAgICAgICAgICBnZW4uZWxzZUlmKHRoaXMuaW52YWxpZCRkYXRhKCkpO1xuICAgICAgICAgICAgdGhpcy4kZGF0YUVycm9yKCk7XG4gICAgICAgICAgICBpZiAodmFsaWQgIT09IGNvZGVnZW5fMS5uaWwpXG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGdlbi5lbHNlKCk7XG4gICAgfVxuICAgIGludmFsaWQkZGF0YSgpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYUNvZGUsIHNjaGVtYVR5cGUsIGRlZiwgaXQgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBjb2RlZ2VuXzEub3Iod3JvbmckRGF0YVR5cGUoKSwgaW52YWxpZCREYXRhU2NoZW1hKCkpO1xuICAgICAgICBmdW5jdGlvbiB3cm9uZyREYXRhVHlwZSgpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWFUeXBlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICghKHNjaGVtYUNvZGUgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdCA9IEFycmF5LmlzQXJyYXkoc2NoZW1hVHlwZSkgPyBzY2hlbWFUeXBlIDogW3NjaGVtYVR5cGVdO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgJHtkYXRhVHlwZV8yLmNoZWNrRGF0YVR5cGVzKHN0LCBzY2hlbWFDb2RlLCBpdC5vcHRzLnN0cmljdE51bWJlcnMsIGRhdGFUeXBlXzIuRGF0YVR5cGUuV3JvbmcpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLm5pbDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbnZhbGlkJERhdGFTY2hlbWEoKSB7XG4gICAgICAgICAgICBpZiAoZGVmLnZhbGlkYXRlU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVTY2hlbWFSZWYgPSBnZW4uc2NvcGVWYWx1ZShcInZhbGlkYXRlJGRhdGFcIiwgeyByZWY6IGRlZi52YWxpZGF0ZVNjaGVtYSB9KTsgLy8gVE9ETyB2YWx1ZS5jb2RlIGZvciBzdGFuZGFsb25lXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5fIGAhJHt2YWxpZGF0ZVNjaGVtYVJlZn0oJHtzY2hlbWFDb2RlfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5uaWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Vic2NoZW1hKGFwcGwsIHZhbGlkKSB7XG4gICAgICAgIGNvbnN0IHN1YnNjaGVtYSA9IHN1YnNjaGVtYV8xLmdldFN1YnNjaGVtYSh0aGlzLml0LCBhcHBsKTtcbiAgICAgICAgc3Vic2NoZW1hXzEuZXh0ZW5kU3Vic2NoZW1hRGF0YShzdWJzY2hlbWEsIHRoaXMuaXQsIGFwcGwpO1xuICAgICAgICBzdWJzY2hlbWFfMS5leHRlbmRTdWJzY2hlbWFNb2RlKHN1YnNjaGVtYSwgYXBwbCk7XG4gICAgICAgIGNvbnN0IG5leHRDb250ZXh0ID0geyAuLi50aGlzLml0LCAuLi5zdWJzY2hlbWEsIGl0ZW1zOiB1bmRlZmluZWQsIHByb3BzOiB1bmRlZmluZWQgfTtcbiAgICAgICAgc3Vic2NoZW1hQ29kZShuZXh0Q29udGV4dCwgdmFsaWQpO1xuICAgICAgICByZXR1cm4gbmV4dENvbnRleHQ7XG4gICAgfVxuICAgIG1lcmdlRXZhbHVhdGVkKHNjaGVtYUN4dCwgdG9OYW1lKSB7XG4gICAgICAgIGNvbnN0IHsgaXQsIGdlbiB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFpdC5vcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoaXQucHJvcHMgIT09IHRydWUgJiYgc2NoZW1hQ3h0LnByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgc2NoZW1hQ3h0LnByb3BzLCBpdC5wcm9wcywgdG9OYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQuaXRlbXMgIT09IHRydWUgJiYgc2NoZW1hQ3h0Lml0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgc2NoZW1hQ3h0Lml0ZW1zLCBpdC5pdGVtcywgdG9OYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtZXJnZVZhbGlkRXZhbHVhdGVkKHNjaGVtYUN4dCwgdmFsaWQpIHtcbiAgICAgICAgY29uc3QgeyBpdCwgZ2VuIH0gPSB0aGlzO1xuICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiAoaXQucHJvcHMgIT09IHRydWUgfHwgaXQuaXRlbXMgIT09IHRydWUpKSB7XG4gICAgICAgICAgICBnZW4uaWYodmFsaWQsICgpID0+IHRoaXMubWVyZ2VFdmFsdWF0ZWQoc2NoZW1hQ3h0LCBjb2RlZ2VuXzEuTmFtZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLktleXdvcmRDeHQgPSBLZXl3b3JkQ3h0O1xuZnVuY3Rpb24ga2V5d29yZENvZGUoaXQsIGtleXdvcmQsIGRlZiwgcnVsZVR5cGUpIHtcbiAgICBjb25zdCBjeHQgPSBuZXcgS2V5d29yZEN4dChpdCwgZGVmLCBrZXl3b3JkKTtcbiAgICBpZiAoXCJjb2RlXCIgaW4gZGVmKSB7XG4gICAgICAgIGRlZi5jb2RlKGN4dCwgcnVsZVR5cGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjeHQuJGRhdGEgJiYgZGVmLnZhbGlkYXRlKSB7XG4gICAgICAgIGtleXdvcmRfMS5mdW5jS2V5d29yZENvZGUoY3h0LCBkZWYpO1xuICAgIH1cbiAgICBlbHNlIGlmIChcIm1hY3JvXCIgaW4gZGVmKSB7XG4gICAgICAgIGtleXdvcmRfMS5tYWNyb0tleXdvcmRDb2RlKGN4dCwgZGVmKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVmLmNvbXBpbGUgfHwgZGVmLnZhbGlkYXRlKSB7XG4gICAgICAgIGtleXdvcmRfMS5mdW5jS2V5d29yZENvZGUoY3h0LCBkZWYpO1xuICAgIH1cbn1cbmNvbnN0IEpTT05fUE9JTlRFUiA9IC9eXFwvKD86W15+XXx+MHx+MSkqJC87XG5jb25zdCBSRUxBVElWRV9KU09OX1BPSU5URVIgPSAvXihbMC05XSspKCN8XFwvKD86W15+XXx+MHx+MSkqKT8kLztcbmZ1bmN0aW9uIGdldERhdGEoJGRhdGEsIHsgZGF0YUxldmVsLCBkYXRhTmFtZXMsIGRhdGFQYXRoQXJyIH0pIHtcbiAgICBsZXQganNvblBvaW50ZXI7XG4gICAgbGV0IGRhdGE7XG4gICAgaWYgKCRkYXRhID09PSBcIlwiKVxuICAgICAgICByZXR1cm4gbmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhO1xuICAgIGlmICgkZGF0YVswXSA9PT0gXCIvXCIpIHtcbiAgICAgICAgaWYgKCFKU09OX1BPSU5URVIudGVzdCgkZGF0YSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSlNPTi1wb2ludGVyOiAkeyRkYXRhfWApO1xuICAgICAgICBqc29uUG9pbnRlciA9ICRkYXRhO1xuICAgICAgICBkYXRhID0gbmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IFJFTEFUSVZFX0pTT05fUE9JTlRFUi5leGVjKCRkYXRhKTtcbiAgICAgICAgaWYgKCFtYXRjaGVzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEpTT04tcG9pbnRlcjogJHskZGF0YX1gKTtcbiAgICAgICAgY29uc3QgdXAgPSArbWF0Y2hlc1sxXTtcbiAgICAgICAganNvblBvaW50ZXIgPSBtYXRjaGVzWzJdO1xuICAgICAgICBpZiAoanNvblBvaW50ZXIgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICBpZiAodXAgPj0gZGF0YUxldmVsKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyhcInByb3BlcnR5L2luZGV4XCIsIHVwKSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVBhdGhBcnJbZGF0YUxldmVsIC0gdXBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cCA+IGRhdGFMZXZlbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyhcImRhdGFcIiwgdXApKTtcbiAgICAgICAgZGF0YSA9IGRhdGFOYW1lc1tkYXRhTGV2ZWwgLSB1cF07XG4gICAgICAgIGlmICghanNvblBvaW50ZXIpXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgbGV0IGV4cHIgPSBkYXRhO1xuICAgIGNvbnN0IHNlZ21lbnRzID0ganNvblBvaW50ZXIuc3BsaXQoXCIvXCIpO1xuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICAgICAgZGF0YSA9IGNvZGVnZW5fMS5fIGAke2RhdGF9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkodXRpbF8xLnVuZXNjYXBlSnNvblBvaW50ZXIoc2VnbWVudCkpfWA7XG4gICAgICAgICAgICBleHByID0gY29kZWdlbl8xLl8gYCR7ZXhwcn0gJiYgJHtkYXRhfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4cHI7XG4gICAgZnVuY3Rpb24gZXJyb3JNc2cocG9pbnRlclR5cGUsIHVwKSB7XG4gICAgICAgIHJldHVybiBgQ2Fubm90IGFjY2VzcyAke3BvaW50ZXJUeXBlfSAke3VwfSBsZXZlbHMgdXAsIGN1cnJlbnQgbGV2ZWwgaXMgJHtkYXRhTGV2ZWx9YDtcbiAgICB9XG59XG5leHBvcnRzLmdldERhdGEgPSBnZXREYXRhO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZXJyb3JzKSB7XG4gICAgICAgIHN1cGVyKFwidmFsaWRhdGlvbiBmYWlsZWRcIik7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aGlzLmFqdiA9IHRoaXMudmFsaWRhdGlvbiA9IHRydWU7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gVmFsaWRhdGlvbkVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdGlvbl9lcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJlc29sdmVfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVcIik7XG5jbGFzcyBNaXNzaW5nUmVmRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoYmFzZUlkLCByZWYsIG1zZykge1xuICAgICAgICBzdXBlcihtc2cgfHwgYGNhbid0IHJlc29sdmUgcmVmZXJlbmNlICR7cmVmfSBmcm9tIGlkICR7YmFzZUlkfWApO1xuICAgICAgICB0aGlzLm1pc3NpbmdSZWYgPSByZXNvbHZlXzEucmVzb2x2ZVVybChiYXNlSWQsIHJlZik7XG4gICAgICAgIHRoaXMubWlzc2luZ1NjaGVtYSA9IHJlc29sdmVfMS5ub3JtYWxpemVJZChyZXNvbHZlXzEuZ2V0RnVsbFBhdGgodGhpcy5taXNzaW5nUmVmKSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gTWlzc2luZ1JlZkVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmX2Vycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXNvbHZlU2NoZW1hID0gZXhwb3J0cy5nZXRDb21waWxpbmdTY2hlbWEgPSBleHBvcnRzLnJlc29sdmVSZWYgPSBleHBvcnRzLmNvbXBpbGVTY2hlbWEgPSBleHBvcnRzLlNjaGVtYUVudiA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW5cIik7XG5jb25zdCB2YWxpZGF0aW9uX2Vycm9yXzEgPSByZXF1aXJlKFwiLi4vcnVudGltZS92YWxpZGF0aW9uX2Vycm9yXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuL25hbWVzXCIpO1xuY29uc3QgcmVzb2x2ZV8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCB2YWxpZGF0ZV8xID0gcmVxdWlyZShcIi4vdmFsaWRhdGVcIik7XG5jb25zdCBVUkkgPSByZXF1aXJlKFwidXJpLWpzXCIpO1xuY2xhc3MgU2NoZW1hRW52IHtcbiAgICBjb25zdHJ1Y3RvcihlbnYpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnJlZnMgPSB7fTtcbiAgICAgICAgdGhpcy5keW5hbWljQW5jaG9ycyA9IHt9O1xuICAgICAgICBsZXQgc2NoZW1hO1xuICAgICAgICBpZiAodHlwZW9mIGVudi5zY2hlbWEgPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHNjaGVtYSA9IGVudi5zY2hlbWE7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gZW52LnNjaGVtYTtcbiAgICAgICAgdGhpcy5zY2hlbWFJZCA9IGVudi5zY2hlbWFJZDtcbiAgICAgICAgdGhpcy5yb290ID0gZW52LnJvb3QgfHwgdGhpcztcbiAgICAgICAgdGhpcy5iYXNlSWQgPSAoX2EgPSBlbnYuYmFzZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiByZXNvbHZlXzEubm9ybWFsaXplSWQoc2NoZW1hID09PSBudWxsIHx8IHNjaGVtYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoZW1hW2Vudi5zY2hlbWFJZCB8fCBcIiRpZFwiXSk7XG4gICAgICAgIHRoaXMuc2NoZW1hUGF0aCA9IGVudi5zY2hlbWFQYXRoO1xuICAgICAgICB0aGlzLmxvY2FsUmVmcyA9IGVudi5sb2NhbFJlZnM7XG4gICAgICAgIHRoaXMubWV0YSA9IGVudi5tZXRhO1xuICAgICAgICB0aGlzLiRhc3luYyA9IHNjaGVtYSA9PT0gbnVsbCB8fCBzY2hlbWEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaGVtYS4kYXN5bmM7XG4gICAgICAgIHRoaXMucmVmcyA9IHt9O1xuICAgIH1cbn1cbmV4cG9ydHMuU2NoZW1hRW52ID0gU2NoZW1hRW52O1xuLy8gbGV0IGNvZGVTaXplID0gMFxuLy8gbGV0IG5vZGVDb3VudCA9IDBcbi8vIENvbXBpbGVzIHNjaGVtYSBpbiBTY2hlbWFFbnZcbmZ1bmN0aW9uIGNvbXBpbGVTY2hlbWEoc2NoKSB7XG4gICAgLy8gVE9ETyByZWZhY3RvciAtIHJlbW92ZSBjb21waWxhdGlvbnNcbiAgICBjb25zdCBfc2NoID0gZ2V0Q29tcGlsaW5nU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbiAgICBpZiAoX3NjaClcbiAgICAgICAgcmV0dXJuIF9zY2g7XG4gICAgY29uc3Qgcm9vdElkID0gcmVzb2x2ZV8xLmdldEZ1bGxQYXRoKHNjaC5yb290LmJhc2VJZCk7IC8vIFRPRE8gaWYgZ2V0RnVsbFBhdGggcmVtb3ZlZCAxIHRlc3RzIGZhaWxzXG4gICAgY29uc3QgeyBlczUsIGxpbmVzIH0gPSB0aGlzLm9wdHMuY29kZTtcbiAgICBjb25zdCB7IG93blByb3BlcnRpZXMgfSA9IHRoaXMub3B0cztcbiAgICBjb25zdCBnZW4gPSBuZXcgY29kZWdlbl8xLkNvZGVHZW4odGhpcy5zY29wZSwgeyBlczUsIGxpbmVzLCBvd25Qcm9wZXJ0aWVzIH0pO1xuICAgIGxldCBfVmFsaWRhdGlvbkVycm9yO1xuICAgIGlmIChzY2guJGFzeW5jKSB7XG4gICAgICAgIF9WYWxpZGF0aW9uRXJyb3IgPSBnZW4uc2NvcGVWYWx1ZShcIkVycm9yXCIsIHtcbiAgICAgICAgICAgIHJlZjogdmFsaWRhdGlvbl9lcnJvcl8xLmRlZmF1bHQsXG4gICAgICAgICAgICBjb2RlOiBjb2RlZ2VuXzEuXyBgcmVxdWlyZShcImFqdi9kaXN0L3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiKS5kZWZhdWx0YCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkYXRlTmFtZSA9IGdlbi5zY29wZU5hbWUoXCJ2YWxpZGF0ZVwiKTtcbiAgICBzY2gudmFsaWRhdGVOYW1lID0gdmFsaWRhdGVOYW1lO1xuICAgIGNvbnN0IHNjaGVtYUN4dCA9IHtcbiAgICAgICAgZ2VuLFxuICAgICAgICBhbGxFcnJvcnM6IHRoaXMub3B0cy5hbGxFcnJvcnMsXG4gICAgICAgIGRhdGE6IG5hbWVzXzEuZGVmYXVsdC5kYXRhLFxuICAgICAgICBwYXJlbnREYXRhOiBuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YSxcbiAgICAgICAgcGFyZW50RGF0YVByb3BlcnR5OiBuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5LFxuICAgICAgICBkYXRhTmFtZXM6IFtuYW1lc18xLmRlZmF1bHQuZGF0YV0sXG4gICAgICAgIGRhdGFQYXRoQXJyOiBbY29kZWdlbl8xLm5pbF0sXG4gICAgICAgIGRhdGFMZXZlbDogMCxcbiAgICAgICAgZGF0YVR5cGVzOiBbXSxcbiAgICAgICAgZGVmaW5lZFByb3BlcnRpZXM6IG5ldyBTZXQoKSxcbiAgICAgICAgdG9wU2NoZW1hUmVmOiBnZW4uc2NvcGVWYWx1ZShcInNjaGVtYVwiLCB0aGlzLm9wdHMuY29kZS5zb3VyY2UgPT09IHRydWVcbiAgICAgICAgICAgID8geyByZWY6IHNjaC5zY2hlbWEsIGNvZGU6IGNvZGVnZW5fMS5zdHJpbmdpZnkoc2NoLnNjaGVtYSkgfVxuICAgICAgICAgICAgOiB7IHJlZjogc2NoLnNjaGVtYSB9KSxcbiAgICAgICAgdmFsaWRhdGVOYW1lLFxuICAgICAgICBWYWxpZGF0aW9uRXJyb3I6IF9WYWxpZGF0aW9uRXJyb3IsXG4gICAgICAgIHNjaGVtYTogc2NoLnNjaGVtYSxcbiAgICAgICAgc2NoZW1hRW52OiBzY2gsXG4gICAgICAgIHJvb3RJZCxcbiAgICAgICAgYmFzZUlkOiBzY2guYmFzZUlkIHx8IHJvb3RJZCxcbiAgICAgICAgc2NoZW1hUGF0aDogY29kZWdlbl8xLm5pbCxcbiAgICAgICAgZXJyU2NoZW1hUGF0aDogc2NoLnNjaGVtYVBhdGggfHwgKHRoaXMub3B0cy5qdGQgPyBcIlwiIDogXCIjXCIpLFxuICAgICAgICBlcnJvclBhdGg6IGNvZGVnZW5fMS5fIGBcIlwiYCxcbiAgICAgICAgb3B0czogdGhpcy5vcHRzLFxuICAgICAgICBzZWxmOiB0aGlzLFxuICAgIH07XG4gICAgbGV0IHNvdXJjZUNvZGU7XG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fY29tcGlsYXRpb25zLmFkZChzY2gpO1xuICAgICAgICB2YWxpZGF0ZV8xLnZhbGlkYXRlRnVuY3Rpb25Db2RlKHNjaGVtYUN4dCk7XG4gICAgICAgIGdlbi5vcHRpbWl6ZSh0aGlzLm9wdHMuY29kZS5vcHRpbWl6ZSk7XG4gICAgICAgIC8vIGdlbi5vcHRpbWl6ZSgxKVxuICAgICAgICBjb25zdCB2YWxpZGF0ZUNvZGUgPSBnZW4udG9TdHJpbmcoKTtcbiAgICAgICAgc291cmNlQ29kZSA9IGAke2dlbi5zY29wZVJlZnMobmFtZXNfMS5kZWZhdWx0LnNjb3BlKX1yZXR1cm4gJHt2YWxpZGF0ZUNvZGV9YDtcbiAgICAgICAgLy8gY29uc29sZS5sb2coKGNvZGVTaXplICs9IHNvdXJjZUNvZGUubGVuZ3RoKSwgKG5vZGVDb3VudCArPSBnZW4ubm9kZUNvdW50KSlcbiAgICAgICAgaWYgKHRoaXMub3B0cy5jb2RlLnByb2Nlc3MpXG4gICAgICAgICAgICBzb3VyY2VDb2RlID0gdGhpcy5vcHRzLmNvZGUucHJvY2Vzcyhzb3VyY2VDb2RlLCBzY2gpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlxcblxcblxcbiAqKiogXFxuXCIsIHNvdXJjZUNvZGUpXG4gICAgICAgIGNvbnN0IG1ha2VWYWxpZGF0ZSA9IG5ldyBGdW5jdGlvbihgJHtuYW1lc18xLmRlZmF1bHQuc2VsZn1gLCBgJHtuYW1lc18xLmRlZmF1bHQuc2NvcGV9YCwgc291cmNlQ29kZSk7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlID0gbWFrZVZhbGlkYXRlKHRoaXMsIHRoaXMuc2NvcGUuZ2V0KCkpO1xuICAgICAgICB0aGlzLnNjb3BlLnZhbHVlKHZhbGlkYXRlTmFtZSwgeyByZWY6IHZhbGlkYXRlIH0pO1xuICAgICAgICB2YWxpZGF0ZS5lcnJvcnMgPSBudWxsO1xuICAgICAgICB2YWxpZGF0ZS5zY2hlbWEgPSBzY2guc2NoZW1hO1xuICAgICAgICB2YWxpZGF0ZS5zY2hlbWFFbnYgPSBzY2g7XG4gICAgICAgIGlmIChzY2guJGFzeW5jKVxuICAgICAgICAgICAgdmFsaWRhdGUuJGFzeW5jID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5jb2RlLnNvdXJjZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFsaWRhdGUuc291cmNlID0geyB2YWxpZGF0ZU5hbWUsIHZhbGlkYXRlQ29kZSwgc2NvcGVWYWx1ZXM6IGdlbi5fdmFsdWVzIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0cy51bmV2YWx1YXRlZCkge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wcywgaXRlbXMgfSA9IHNjaGVtYUN4dDtcbiAgICAgICAgICAgIHZhbGlkYXRlLmV2YWx1YXRlZCA9IHtcbiAgICAgICAgICAgICAgICBwcm9wczogcHJvcHMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSA/IHVuZGVmaW5lZCA6IHByb3BzLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBpdGVtcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lID8gdW5kZWZpbmVkIDogaXRlbXMsXG4gICAgICAgICAgICAgICAgZHluYW1pY1Byb3BzOiBwcm9wcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lLFxuICAgICAgICAgICAgICAgIGR5bmFtaWNJdGVtczogaXRlbXMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodmFsaWRhdGUuc291cmNlKVxuICAgICAgICAgICAgICAgIHZhbGlkYXRlLnNvdXJjZS5ldmFsdWF0ZWQgPSBjb2RlZ2VuXzEuc3RyaW5naWZ5KHZhbGlkYXRlLmV2YWx1YXRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgc2NoLnZhbGlkYXRlID0gdmFsaWRhdGU7XG4gICAgICAgIHJldHVybiBzY2g7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGRlbGV0ZSBzY2gudmFsaWRhdGU7XG4gICAgICAgIGRlbGV0ZSBzY2gudmFsaWRhdGVOYW1lO1xuICAgICAgICBpZiAoc291cmNlQ29kZSlcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiRXJyb3IgY29tcGlsaW5nIHNjaGVtYSwgZnVuY3Rpb24gY29kZTpcIiwgc291cmNlQ29kZSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiXFxuXFxuXFxuICoqKiBcXG5cIiwgc291cmNlQ29kZSwgdGhpcy5vcHRzKVxuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5fY29tcGlsYXRpb25zLmRlbGV0ZShzY2gpO1xuICAgIH1cbn1cbmV4cG9ydHMuY29tcGlsZVNjaGVtYSA9IGNvbXBpbGVTY2hlbWE7XG5mdW5jdGlvbiByZXNvbHZlUmVmKHJvb3QsIGJhc2VJZCwgcmVmKSB7XG4gICAgdmFyIF9hO1xuICAgIHJlZiA9IHJlc29sdmVfMS5yZXNvbHZlVXJsKGJhc2VJZCwgcmVmKTtcbiAgICBjb25zdCBzY2hPckZ1bmMgPSByb290LnJlZnNbcmVmXTtcbiAgICBpZiAoc2NoT3JGdW5jKVxuICAgICAgICByZXR1cm4gc2NoT3JGdW5jO1xuICAgIGxldCBfc2NoID0gcmVzb2x2ZS5jYWxsKHRoaXMsIHJvb3QsIHJlZik7XG4gICAgaWYgKF9zY2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSAoX2EgPSByb290LmxvY2FsUmVmcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3JlZl07IC8vIFRPRE8gbWF5YmUgbG9jYWxSZWZzIHNob3VsZCBob2xkIFNjaGVtYUVudlxuICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIGlmIChzY2hlbWEpXG4gICAgICAgICAgICBfc2NoID0gbmV3IFNjaGVtYUVudih7IHNjaGVtYSwgc2NoZW1hSWQsIHJvb3QsIGJhc2VJZCB9KTtcbiAgICB9XG4gICAgaWYgKF9zY2ggPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIHJldHVybiAocm9vdC5yZWZzW3JlZl0gPSBpbmxpbmVPckNvbXBpbGUuY2FsbCh0aGlzLCBfc2NoKSk7XG59XG5leHBvcnRzLnJlc29sdmVSZWYgPSByZXNvbHZlUmVmO1xuZnVuY3Rpb24gaW5saW5lT3JDb21waWxlKHNjaCkge1xuICAgIGlmIChyZXNvbHZlXzEuaW5saW5lUmVmKHNjaC5zY2hlbWEsIHRoaXMub3B0cy5pbmxpbmVSZWZzKSlcbiAgICAgICAgcmV0dXJuIHNjaC5zY2hlbWE7XG4gICAgcmV0dXJuIHNjaC52YWxpZGF0ZSA/IHNjaCA6IGNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2gpO1xufVxuLy8gSW5kZXggb2Ygc2NoZW1hIGNvbXBpbGF0aW9uIGluIHRoZSBjdXJyZW50bHkgY29tcGlsZWQgbGlzdFxuZnVuY3Rpb24gZ2V0Q29tcGlsaW5nU2NoZW1hKHNjaEVudikge1xuICAgIGZvciAoY29uc3Qgc2NoIG9mIHRoaXMuX2NvbXBpbGF0aW9ucykge1xuICAgICAgICBpZiAoc2FtZVNjaGVtYUVudihzY2gsIHNjaEVudikpXG4gICAgICAgICAgICByZXR1cm4gc2NoO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0Q29tcGlsaW5nU2NoZW1hID0gZ2V0Q29tcGlsaW5nU2NoZW1hO1xuZnVuY3Rpb24gc2FtZVNjaGVtYUVudihzMSwgczIpIHtcbiAgICByZXR1cm4gczEuc2NoZW1hID09PSBzMi5zY2hlbWEgJiYgczEucm9vdCA9PT0gczIucm9vdCAmJiBzMS5iYXNlSWQgPT09IHMyLmJhc2VJZDtcbn1cbi8vIHJlc29sdmUgYW5kIGNvbXBpbGUgdGhlIHJlZmVyZW5jZXMgKCRyZWYpXG4vLyBUT0RPIHJldHVybnMgQW55U2NoZW1hT2JqZWN0IChpZiB0aGUgc2NoZW1hIGNhbiBiZSBpbmxpbmVkKSBvciB2YWxpZGF0aW9uIGZ1bmN0aW9uXG5mdW5jdGlvbiByZXNvbHZlKHJvb3QsIC8vIGluZm9ybWF0aW9uIGFib3V0IHRoZSByb290IHNjaGVtYSBmb3IgdGhlIGN1cnJlbnQgc2NoZW1hXG5yZWYgLy8gcmVmZXJlbmNlIHRvIHJlc29sdmVcbikge1xuICAgIGxldCBzY2g7XG4gICAgd2hpbGUgKHR5cGVvZiAoc2NoID0gdGhpcy5yZWZzW3JlZl0pID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJlZiA9IHNjaDtcbiAgICByZXR1cm4gc2NoIHx8IHRoaXMuc2NoZW1hc1tyZWZdIHx8IHJlc29sdmVTY2hlbWEuY2FsbCh0aGlzLCByb290LCByZWYpO1xufVxuLy8gUmVzb2x2ZSBzY2hlbWEsIGl0cyByb290IGFuZCBiYXNlSWRcbmZ1bmN0aW9uIHJlc29sdmVTY2hlbWEocm9vdCwgLy8gcm9vdCBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHNjaGVtYSwgcmVmcyBUT0RPIGJlbG93IFNjaGVtYUVudiBpcyBhc3NpZ25lZCB0byBpdFxucmVmIC8vIHJlZmVyZW5jZSB0byByZXNvbHZlXG4pIHtcbiAgICBjb25zdCBwID0gVVJJLnBhcnNlKHJlZik7XG4gICAgY29uc3QgcmVmUGF0aCA9IHJlc29sdmVfMS5fZ2V0RnVsbFBhdGgocCk7XG4gICAgbGV0IGJhc2VJZCA9IHJlc29sdmVfMS5nZXRGdWxsUGF0aChyb290LmJhc2VJZCk7XG4gICAgLy8gVE9ETyBgT2JqZWN0LmtleXMocm9vdC5zY2hlbWEpLmxlbmd0aCA+IDBgIHNob3VsZCBub3QgYmUgbmVlZGVkIC0gYnV0IHJlbW92aW5nIGJyZWFrcyAyIHRlc3RzXG4gICAgaWYgKE9iamVjdC5rZXlzKHJvb3Quc2NoZW1hKS5sZW5ndGggPiAwICYmIHJlZlBhdGggPT09IGJhc2VJZCkge1xuICAgICAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCByb290KTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSByZXNvbHZlXzEubm9ybWFsaXplSWQocmVmUGF0aCk7XG4gICAgY29uc3Qgc2NoT3JSZWYgPSB0aGlzLnJlZnNbaWRdIHx8IHRoaXMuc2NoZW1hc1tpZF07XG4gICAgaWYgKHR5cGVvZiBzY2hPclJlZiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IHNjaCA9IHJlc29sdmVTY2hlbWEuY2FsbCh0aGlzLCByb290LCBzY2hPclJlZik7XG4gICAgICAgIGlmICh0eXBlb2YgKHNjaCA9PT0gbnVsbCB8fCBzY2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaC5zY2hlbWEpICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCBzY2gpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChzY2hPclJlZiA9PT0gbnVsbCB8fCBzY2hPclJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoT3JSZWYuc2NoZW1hKSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghc2NoT3JSZWYudmFsaWRhdGUpXG4gICAgICAgIGNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2hPclJlZik7XG4gICAgaWYgKGlkID09PSByZXNvbHZlXzEubm9ybWFsaXplSWQocmVmKSkge1xuICAgICAgICBjb25zdCB7IHNjaGVtYSB9ID0gc2NoT3JSZWY7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgY29uc3Qgc2NoSWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICBpZiAoc2NoSWQpXG4gICAgICAgICAgICBiYXNlSWQgPSByZXNvbHZlXzEucmVzb2x2ZVVybChiYXNlSWQsIHNjaElkKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTY2hlbWFFbnYoeyBzY2hlbWEsIHNjaGVtYUlkLCByb290LCBiYXNlSWQgfSk7XG4gICAgfVxuICAgIHJldHVybiBnZXRKc29uUG9pbnRlci5jYWxsKHRoaXMsIHAsIHNjaE9yUmVmKTtcbn1cbmV4cG9ydHMucmVzb2x2ZVNjaGVtYSA9IHJlc29sdmVTY2hlbWE7XG5jb25zdCBQUkVWRU5UX1NDT1BFX0NIQU5HRSA9IG5ldyBTZXQoW1xuICAgIFwicHJvcGVydGllc1wiLFxuICAgIFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgICBcImVudW1cIixcbiAgICBcImRlcGVuZGVuY2llc1wiLFxuICAgIFwiZGVmaW5pdGlvbnNcIixcbl0pO1xuZnVuY3Rpb24gZ2V0SnNvblBvaW50ZXIocGFyc2VkUmVmLCB7IGJhc2VJZCwgc2NoZW1hLCByb290IH0pIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCgoX2EgPSBwYXJzZWRSZWYuZnJhZ21lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgIT09IFwiL1wiKVxuICAgICAgICByZXR1cm47XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnNlZFJlZi5mcmFnbWVudC5zbGljZSgxKS5zcGxpdChcIi9cIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNjaGVtYSA9IHNjaGVtYVt1dGlsXzEudW5lc2NhcGVGcmFnbWVudChwYXJ0KV07XG4gICAgICAgIGlmIChzY2hlbWEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gVE9ETyBQUkVWRU5UX1NDT1BFX0NIQU5HRSBjb3VsZCBiZSBkZWZpbmVkIGluIGtleXdvcmQgZGVmP1xuICAgICAgICBjb25zdCBzY2hJZCA9IHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBzY2hlbWFbdGhpcy5vcHRzLnNjaGVtYUlkXTtcbiAgICAgICAgaWYgKCFQUkVWRU5UX1NDT1BFX0NIQU5HRS5oYXMocGFydCkgJiYgc2NoSWQpIHtcbiAgICAgICAgICAgIGJhc2VJZCA9IHJlc29sdmVfMS5yZXNvbHZlVXJsKGJhc2VJZCwgc2NoSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBlbnY7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgIT0gXCJib29sZWFuXCIgJiYgc2NoZW1hLiRyZWYgJiYgIXV0aWxfMS5zY2hlbWFIYXNSdWxlc0J1dFJlZihzY2hlbWEsIHRoaXMuUlVMRVMpKSB7XG4gICAgICAgIGNvbnN0ICRyZWYgPSByZXNvbHZlXzEucmVzb2x2ZVVybChiYXNlSWQsIHNjaGVtYS4kcmVmKTtcbiAgICAgICAgZW52ID0gcmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsICRyZWYpO1xuICAgIH1cbiAgICAvLyBldmVuIHRob3VnaCByZXNvbHV0aW9uIGZhaWxlZCB3ZSBuZWVkIHRvIHJldHVybiBTY2hlbWFFbnYgdG8gdGhyb3cgZXhjZXB0aW9uXG4gICAgLy8gc28gdGhhdCBjb21waWxlQXN5bmMgbG9hZHMgbWlzc2luZyBzY2hlbWEuXG4gICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgIGVudiA9IGVudiB8fCBuZXcgU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkIH0pO1xuICAgIGlmIChlbnYuc2NoZW1hICE9PSBlbnYucm9vdC5zY2hlbWEpXG4gICAgICAgIHJldHVybiBlbnY7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db2RlR2VuID0gZXhwb3J0cy5OYW1lID0gZXhwb3J0cy5uaWwgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyID0gZXhwb3J0cy5fID0gZXhwb3J0cy5LZXl3b3JkQ3h0ID0gdm9pZCAwO1xudmFyIHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3ZhbGlkYXRlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiS2V5d29yZEN4dFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdGVfMS5LZXl3b3JkQ3h0OyB9IH0pO1xudmFyIGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvY29kZWdlblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5fOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5naWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyaW5naWZ5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmlsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEubmlsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLk5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb2RlR2VuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuQ29kZUdlbjsgfSB9KTtcbmNvbnN0IHZhbGlkYXRpb25fZXJyb3JfMSA9IHJlcXVpcmUoXCIuL3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiKTtcbmNvbnN0IHJlZl9lcnJvcl8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9yZWZfZXJyb3JcIik7XG5jb25zdCBydWxlc18xID0gcmVxdWlyZShcIi4vY29tcGlsZS9ydWxlc1wiKTtcbmNvbnN0IGNvbXBpbGVfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGVcIik7XG5jb25zdCBjb2RlZ2VuXzIgPSByZXF1aXJlKFwiLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCByZXNvbHZlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3Jlc29sdmVcIik7XG5jb25zdCBkYXRhVHlwZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS92YWxpZGF0ZS9kYXRhVHlwZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0ICRkYXRhUmVmU2NoZW1hID0gcmVxdWlyZShcIi4vcmVmcy9kYXRhLmpzb25cIik7XG5jb25zdCBNRVRBX0lHTk9SRV9PUFRJT05TID0gW1wicmVtb3ZlQWRkaXRpb25hbFwiLCBcInVzZURlZmF1bHRzXCIsIFwiY29lcmNlVHlwZXNcIl07XG5jb25zdCBFWFRfU0NPUEVfTkFNRVMgPSBuZXcgU2V0KFtcbiAgICBcInZhbGlkYXRlXCIsXG4gICAgXCJzZXJpYWxpemVcIixcbiAgICBcInBhcnNlXCIsXG4gICAgXCJ3cmFwcGVyXCIsXG4gICAgXCJyb290XCIsXG4gICAgXCJzY2hlbWFcIixcbiAgICBcImtleXdvcmRcIixcbiAgICBcInBhdHRlcm5cIixcbiAgICBcImZvcm1hdHNcIixcbiAgICBcInZhbGlkYXRlJGRhdGFcIixcbiAgICBcImZ1bmNcIixcbiAgICBcIm9ialwiLFxuICAgIFwiRXJyb3JcIixcbl0pO1xuY29uc3QgcmVtb3ZlZE9wdGlvbnMgPSB7XG4gICAgZXJyb3JEYXRhUGF0aDogXCJcIixcbiAgICBmb3JtYXQ6IFwiYHZhbGlkYXRlRm9ybWF0czogZmFsc2VgIGNhbiBiZSB1c2VkIGluc3RlYWQuXCIsXG4gICAgbnVsbGFibGU6ICdcIm51bGxhYmxlXCIga2V5d29yZCBpcyBzdXBwb3J0ZWQgYnkgZGVmYXVsdC4nLFxuICAgIGpzb25Qb2ludGVyczogXCJEZXByZWNhdGVkIGpzUHJvcGVydHlTeW50YXggY2FuIGJlIHVzZWQgaW5zdGVhZC5cIixcbiAgICBleHRlbmRSZWZzOiBcIkRlcHJlY2F0ZWQgaWdub3JlS2V5d29yZHNXaXRoUmVmIGNhbiBiZSB1c2VkIGluc3RlYWQuXCIsXG4gICAgbWlzc2luZ1JlZnM6IFwiUGFzcyBlbXB0eSBzY2hlbWEgd2l0aCAkaWQgdGhhdCBzaG91bGQgYmUgaWdub3JlZCB0byBhanYuYWRkU2NoZW1hLlwiLFxuICAgIHByb2Nlc3NDb2RlOiBcIlVzZSBvcHRpb24gYGNvZGU6IHtwcm9jZXNzOiAoY29kZSwgc2NoZW1hRW52OiBvYmplY3QpID0+IHN0cmluZ31gXCIsXG4gICAgc291cmNlQ29kZTogXCJVc2Ugb3B0aW9uIGBjb2RlOiB7c291cmNlOiB0cnVlfWBcIixcbiAgICBzdHJpY3REZWZhdWx0czogXCJJdCBpcyBkZWZhdWx0IG5vdywgc2VlIG9wdGlvbiBgc3RyaWN0YC5cIixcbiAgICBzdHJpY3RLZXl3b3JkczogXCJJdCBpcyBkZWZhdWx0IG5vdywgc2VlIG9wdGlvbiBgc3RyaWN0YC5cIixcbiAgICB1bmlxdWVJdGVtczogJ1widW5pcXVlSXRlbXNcIiBrZXl3b3JkIGlzIGFsd2F5cyB2YWxpZGF0ZWQuJyxcbiAgICB1bmtub3duRm9ybWF0czogXCJEaXNhYmxlIHN0cmljdCBtb2RlIG9yIHBhc3MgYHRydWVgIHRvIGBhanYuYWRkRm9ybWF0YCAob3IgYGZvcm1hdHNgIG9wdGlvbikuXCIsXG4gICAgY2FjaGU6IFwiTWFwIGlzIHVzZWQgYXMgY2FjaGUsIHNjaGVtYSBvYmplY3QgYXMga2V5LlwiLFxuICAgIHNlcmlhbGl6ZTogXCJNYXAgaXMgdXNlZCBhcyBjYWNoZSwgc2NoZW1hIG9iamVjdCBhcyBrZXkuXCIsXG4gICAgYWp2RXJyb3JzOiBcIkl0IGlzIGRlZmF1bHQgbm93LlwiLFxufTtcbmNvbnN0IGRlcHJlY2F0ZWRPcHRpb25zID0ge1xuICAgIGlnbm9yZUtleXdvcmRzV2l0aFJlZjogXCJcIixcbiAgICBqc1Byb3BlcnR5U3ludGF4OiBcIlwiLFxuICAgIHVuaWNvZGU6ICdcIm1pbkxlbmd0aFwiL1wibWF4TGVuZ3RoXCIgYWNjb3VudCBmb3IgdW5pY29kZSBjaGFyYWN0ZXJzIGJ5IGRlZmF1bHQuJyxcbn07XG5jb25zdCBNQVhfRVhQUkVTU0lPTiA9IDIwMDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiByZXF1aXJlZE9wdGlvbnMobykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tLCBfbywgX3AsIF9xLCBfciwgX3MsIF90LCBfdSwgX3YsIF93LCBfeDtcbiAgICBjb25zdCBzID0gby5zdHJpY3Q7XG4gICAgY29uc3QgX29wdHogPSAoX2EgPSBvLmNvZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpbWl6ZTtcbiAgICBjb25zdCBvcHRpbWl6ZSA9IF9vcHR6ID09PSB0cnVlIHx8IF9vcHR6ID09PSB1bmRlZmluZWQgPyAxIDogX29wdHogfHwgMDtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdHJpY3RTY2hlbWE6IChfYyA9IChfYiA9IG8uc3RyaWN0U2NoZW1hKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB0cnVlLFxuICAgICAgICBzdHJpY3ROdW1iZXJzOiAoX2UgPSAoX2QgPSBvLnN0cmljdE51bWJlcnMpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHMpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHRydWUsXG4gICAgICAgIHN0cmljdFR5cGVzOiAoX2cgPSAoX2YgPSBvLnN0cmljdFR5cGVzKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBzKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBcImxvZ1wiLFxuICAgICAgICBzdHJpY3RUdXBsZXM6IChfaiA9IChfaCA9IG8uc3RyaWN0VHVwbGVzKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiBzKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiBcImxvZ1wiLFxuICAgICAgICBzdHJpY3RSZXF1aXJlZDogKF9sID0gKF9rID0gby5zdHJpY3RSZXF1aXJlZCkgIT09IG51bGwgJiYgX2sgIT09IHZvaWQgMCA/IF9rIDogcykgIT09IG51bGwgJiYgX2wgIT09IHZvaWQgMCA/IF9sIDogZmFsc2UsXG4gICAgICAgIGNvZGU6IG8uY29kZSA/IHsgLi4uby5jb2RlLCBvcHRpbWl6ZSB9IDogeyBvcHRpbWl6ZSB9LFxuICAgICAgICBsb29wUmVxdWlyZWQ6IChfbSA9IG8ubG9vcFJlcXVpcmVkKSAhPT0gbnVsbCAmJiBfbSAhPT0gdm9pZCAwID8gX20gOiBNQVhfRVhQUkVTU0lPTixcbiAgICAgICAgbG9vcEVudW06IChfbyA9IG8ubG9vcEVudW0pICE9PSBudWxsICYmIF9vICE9PSB2b2lkIDAgPyBfbyA6IE1BWF9FWFBSRVNTSU9OLFxuICAgICAgICBtZXRhOiAoX3AgPSBvLm1ldGEpICE9PSBudWxsICYmIF9wICE9PSB2b2lkIDAgPyBfcCA6IHRydWUsXG4gICAgICAgIG1lc3NhZ2VzOiAoX3EgPSBvLm1lc3NhZ2VzKSAhPT0gbnVsbCAmJiBfcSAhPT0gdm9pZCAwID8gX3EgOiB0cnVlLFxuICAgICAgICBpbmxpbmVSZWZzOiAoX3IgPSBvLmlubGluZVJlZnMpICE9PSBudWxsICYmIF9yICE9PSB2b2lkIDAgPyBfciA6IHRydWUsXG4gICAgICAgIHNjaGVtYUlkOiAoX3MgPSBvLnNjaGVtYUlkKSAhPT0gbnVsbCAmJiBfcyAhPT0gdm9pZCAwID8gX3MgOiBcIiRpZFwiLFxuICAgICAgICBhZGRVc2VkU2NoZW1hOiAoX3QgPSBvLmFkZFVzZWRTY2hlbWEpICE9PSBudWxsICYmIF90ICE9PSB2b2lkIDAgPyBfdCA6IHRydWUsXG4gICAgICAgIHZhbGlkYXRlU2NoZW1hOiAoX3UgPSBvLnZhbGlkYXRlU2NoZW1hKSAhPT0gbnVsbCAmJiBfdSAhPT0gdm9pZCAwID8gX3UgOiB0cnVlLFxuICAgICAgICB2YWxpZGF0ZUZvcm1hdHM6IChfdiA9IG8udmFsaWRhdGVGb3JtYXRzKSAhPT0gbnVsbCAmJiBfdiAhPT0gdm9pZCAwID8gX3YgOiB0cnVlLFxuICAgICAgICB1bmljb2RlUmVnRXhwOiAoX3cgPSBvLnVuaWNvZGVSZWdFeHApICE9PSBudWxsICYmIF93ICE9PSB2b2lkIDAgPyBfdyA6IHRydWUsXG4gICAgICAgIGludDMycmFuZ2U6IChfeCA9IG8uaW50MzJyYW5nZSkgIT09IG51bGwgJiYgX3ggIT09IHZvaWQgMCA/IF94IDogdHJ1ZSxcbiAgICB9O1xufVxuY2xhc3MgQWp2IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICAgICAgdGhpcy5zY2hlbWFzID0ge307XG4gICAgICAgIHRoaXMucmVmcyA9IHt9O1xuICAgICAgICB0aGlzLmZvcm1hdHMgPSB7fTtcbiAgICAgICAgdGhpcy5fY29tcGlsYXRpb25zID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl9sb2FkaW5nID0ge307XG4gICAgICAgIHRoaXMuX2NhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICBvcHRzID0gdGhpcy5vcHRzID0geyAuLi5vcHRzLCAuLi5yZXF1aXJlZE9wdGlvbnMob3B0cykgfTtcbiAgICAgICAgY29uc3QgeyBlczUsIGxpbmVzIH0gPSB0aGlzLm9wdHMuY29kZTtcbiAgICAgICAgdGhpcy5zY29wZSA9IG5ldyBjb2RlZ2VuXzIuVmFsdWVTY29wZSh7IHNjb3BlOiB7fSwgcHJlZml4ZXM6IEVYVF9TQ09QRV9OQU1FUywgZXM1LCBsaW5lcyB9KTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBnZXRMb2dnZXIob3B0cy5sb2dnZXIpO1xuICAgICAgICBjb25zdCBmb3JtYXRPcHQgPSBvcHRzLnZhbGlkYXRlRm9ybWF0cztcbiAgICAgICAgb3B0cy52YWxpZGF0ZUZvcm1hdHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5SVUxFUyA9IHJ1bGVzXzEuZ2V0UnVsZXMoKTtcbiAgICAgICAgY2hlY2tPcHRpb25zLmNhbGwodGhpcywgcmVtb3ZlZE9wdGlvbnMsIG9wdHMsIFwiTk9UIFNVUFBPUlRFRFwiKTtcbiAgICAgICAgY2hlY2tPcHRpb25zLmNhbGwodGhpcywgZGVwcmVjYXRlZE9wdGlvbnMsIG9wdHMsIFwiREVQUkVDQVRFRFwiLCBcIndhcm5cIik7XG4gICAgICAgIHRoaXMuX21ldGFPcHRzID0gZ2V0TWV0YVNjaGVtYU9wdGlvbnMuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKG9wdHMuZm9ybWF0cylcbiAgICAgICAgICAgIGFkZEluaXRpYWxGb3JtYXRzLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX2FkZFZvY2FidWxhcmllcygpO1xuICAgICAgICB0aGlzLl9hZGREZWZhdWx0TWV0YVNjaGVtYSgpO1xuICAgICAgICBpZiAob3B0cy5rZXl3b3JkcylcbiAgICAgICAgICAgIGFkZEluaXRpYWxLZXl3b3Jkcy5jYWxsKHRoaXMsIG9wdHMua2V5d29yZHMpO1xuICAgICAgICBpZiAodHlwZW9mIG9wdHMubWV0YSA9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgdGhpcy5hZGRNZXRhU2NoZW1hKG9wdHMubWV0YSk7XG4gICAgICAgIGFkZEluaXRpYWxTY2hlbWFzLmNhbGwodGhpcyk7XG4gICAgICAgIG9wdHMudmFsaWRhdGVGb3JtYXRzID0gZm9ybWF0T3B0O1xuICAgIH1cbiAgICBfYWRkVm9jYWJ1bGFyaWVzKCkge1xuICAgICAgICB0aGlzLmFkZEtleXdvcmQoXCIkYXN5bmNcIik7XG4gICAgfVxuICAgIF9hZGREZWZhdWx0TWV0YVNjaGVtYSgpIHtcbiAgICAgICAgY29uc3QgeyAkZGF0YSwgbWV0YSwgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgbGV0IF9kYXRhUmVmU2NoZW1hID0gJGRhdGFSZWZTY2hlbWE7XG4gICAgICAgIGlmIChzY2hlbWFJZCA9PT0gXCJpZFwiKSB7XG4gICAgICAgICAgICBfZGF0YVJlZlNjaGVtYSA9IHsgLi4uJGRhdGFSZWZTY2hlbWEgfTtcbiAgICAgICAgICAgIF9kYXRhUmVmU2NoZW1hLmlkID0gX2RhdGFSZWZTY2hlbWEuJGlkO1xuICAgICAgICAgICAgZGVsZXRlIF9kYXRhUmVmU2NoZW1hLiRpZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YSAmJiAkZGF0YSlcbiAgICAgICAgICAgIHRoaXMuYWRkTWV0YVNjaGVtYShfZGF0YVJlZlNjaGVtYSwgX2RhdGFSZWZTY2hlbWFbc2NoZW1hSWRdLCBmYWxzZSk7XG4gICAgfVxuICAgIGRlZmF1bHRNZXRhKCkge1xuICAgICAgICBjb25zdCB7IG1ldGEsIHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIHJldHVybiAodGhpcy5vcHRzLmRlZmF1bHRNZXRhID0gdHlwZW9mIG1ldGEgPT0gXCJvYmplY3RcIiA/IG1ldGFbc2NoZW1hSWRdIHx8IG1ldGEgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICB2YWxpZGF0ZShzY2hlbWFLZXlSZWYsIC8vIGtleSwgcmVmIG9yIHNjaGVtYSBvYmplY3RcbiAgICBkYXRhIC8vIHRvIGJlIHZhbGlkYXRlZFxuICAgICkge1xuICAgICAgICBsZXQgdjtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWFLZXlSZWYgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdiA9IHRoaXMuZ2V0U2NoZW1hKHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICBpZiAoIXYpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBzY2hlbWEgd2l0aCBrZXkgb3IgcmVmIFwiJHtzY2hlbWFLZXlSZWZ9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLmNvbXBpbGUoc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZCA9IHYoZGF0YSk7XG4gICAgICAgIGlmICghKFwiJGFzeW5jXCIgaW4gdikpXG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IHYuZXJyb3JzO1xuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfVxuICAgIGNvbXBpbGUoc2NoZW1hLCBfbWV0YSkge1xuICAgICAgICBjb25zdCBzY2ggPSB0aGlzLl9hZGRTY2hlbWEoc2NoZW1hLCBfbWV0YSk7XG4gICAgICAgIHJldHVybiAoc2NoLnZhbGlkYXRlIHx8IHRoaXMuX2NvbXBpbGVTY2hlbWFFbnYoc2NoKSk7XG4gICAgfVxuICAgIGNvbXBpbGVBc3luYyhzY2hlbWEsIG1ldGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdHMubG9hZFNjaGVtYSAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9wdGlvbnMubG9hZFNjaGVtYSBzaG91bGQgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGxvYWRTY2hlbWEgfSA9IHRoaXMub3B0cztcbiAgICAgICAgcmV0dXJuIHJ1bkNvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHNjaGVtYSwgbWV0YSk7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHJ1bkNvbXBpbGVBc3luYyhfc2NoZW1hLCBfbWV0YSkge1xuICAgICAgICAgICAgYXdhaXQgbG9hZE1ldGFTY2hlbWEuY2FsbCh0aGlzLCBfc2NoZW1hLiRzY2hlbWEpO1xuICAgICAgICAgICAgY29uc3Qgc2NoID0gdGhpcy5fYWRkU2NoZW1hKF9zY2hlbWEsIF9tZXRhKTtcbiAgICAgICAgICAgIHJldHVybiBzY2gudmFsaWRhdGUgfHwgX2NvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHNjaCk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gbG9hZE1ldGFTY2hlbWEoJHJlZikge1xuICAgICAgICAgICAgaWYgKCRyZWYgJiYgIXRoaXMuZ2V0U2NoZW1hKCRyZWYpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcnVuQ29tcGlsZUFzeW5jLmNhbGwodGhpcywgeyAkcmVmIH0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIF9jb21waWxlQXN5bmMoc2NoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiByZWZfZXJyb3JfMS5kZWZhdWx0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICBjaGVja0xvYWRlZC5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGxvYWRNaXNzaW5nU2NoZW1hLmNhbGwodGhpcywgZS5taXNzaW5nU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHNjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tMb2FkZWQoeyBtaXNzaW5nU2NoZW1hOiByZWYsIG1pc3NpbmdSZWYgfSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVmc1tyZWZdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbnlTY2hlbWEgJHtyZWZ9IGlzIGxvYWRlZCBidXQgJHttaXNzaW5nUmVmfSBjYW5ub3QgYmUgcmVzb2x2ZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBsb2FkTWlzc2luZ1NjaGVtYShyZWYpIHtcbiAgICAgICAgICAgIGNvbnN0IF9zY2hlbWEgPSBhd2FpdCBfbG9hZFNjaGVtYS5jYWxsKHRoaXMsIHJlZik7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVmc1tyZWZdKVxuICAgICAgICAgICAgICAgIGF3YWl0IGxvYWRNZXRhU2NoZW1hLmNhbGwodGhpcywgX3NjaGVtYS4kc2NoZW1hKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWZzW3JlZl0pXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWEoX3NjaGVtYSwgcmVmLCBtZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBfbG9hZFNjaGVtYShyZWYpIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLl9sb2FkaW5nW3JlZl07XG4gICAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0ICh0aGlzLl9sb2FkaW5nW3JlZl0gPSBsb2FkU2NoZW1hKHJlZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xvYWRpbmdbcmVmXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBZGRzIHNjaGVtYSB0byB0aGUgaW5zdGFuY2VcbiAgICBhZGRTY2hlbWEoc2NoZW1hLCAvLyBJZiBhcnJheSBpcyBwYXNzZWQsIGBrZXlgIHdpbGwgYmUgaWdub3JlZFxuICAgIGtleSwgLy8gT3B0aW9uYWwgc2NoZW1hIGtleS4gQ2FuIGJlIHBhc3NlZCB0byBgdmFsaWRhdGVgIG1ldGhvZCBpbnN0ZWFkIG9mIHNjaGVtYSBvYmplY3Qgb3IgaWQvcmVmLiBPbmUgc2NoZW1hIHBlciBpbnN0YW5jZSBjYW4gaGF2ZSBlbXB0eSBgaWRgIGFuZCBga2V5YC5cbiAgICBfbWV0YSwgLy8gdHJ1ZSBpZiBzY2hlbWEgaXMgYSBtZXRhLXNjaGVtYS4gVXNlZCBpbnRlcm5hbGx5LCBhZGRNZXRhU2NoZW1hIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gICAgX3ZhbGlkYXRlU2NoZW1hID0gdGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hIC8vIGZhbHNlIHRvIHNraXAgc2NoZW1hIHZhbGlkYXRpb24uIFVzZWQgaW50ZXJuYWxseSwgb3B0aW9uIHZhbGlkYXRlU2NoZW1hIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gICAgKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2NoIG9mIHNjaGVtYSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNjaGVtYShzY2gsIHVuZGVmaW5lZCwgX21ldGEsIF92YWxpZGF0ZVNjaGVtYSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgICAgICBpZCA9IHNjaGVtYVtzY2hlbWFJZF07XG4gICAgICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgaWQgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2NoZW1hICR7c2NoZW1hSWR9IG11c3QgYmUgc3RyaW5nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKGtleSB8fCBpZCk7XG4gICAgICAgIHRoaXMuX2NoZWNrVW5pcXVlKGtleSk7XG4gICAgICAgIHRoaXMuc2NoZW1hc1trZXldID0gdGhpcy5fYWRkU2NoZW1hKHNjaGVtYSwgX21ldGEsIGtleSwgX3ZhbGlkYXRlU2NoZW1hLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEFkZCBzY2hlbWEgdGhhdCB3aWxsIGJlIHVzZWQgdG8gdmFsaWRhdGUgb3RoZXIgc2NoZW1hc1xuICAgIC8vIG9wdGlvbnMgaW4gTUVUQV9JR05PUkVfT1BUSU9OUyBhcmUgYWx3YXkgc2V0IHRvIGZhbHNlXG4gICAgYWRkTWV0YVNjaGVtYShzY2hlbWEsIGtleSwgLy8gc2NoZW1hIGtleVxuICAgIF92YWxpZGF0ZVNjaGVtYSA9IHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSAvLyBmYWxzZSB0byBza2lwIHNjaGVtYSB2YWxpZGF0aW9uLCBjYW4gYmUgdXNlZCB0byBvdmVycmlkZSB2YWxpZGF0ZVNjaGVtYSBvcHRpb24gZm9yIG1ldGEtc2NoZW1hXG4gICAgKSB7XG4gICAgICAgIHRoaXMuYWRkU2NoZW1hKHNjaGVtYSwga2V5LCB0cnVlLCBfdmFsaWRhdGVTY2hlbWEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gIFZhbGlkYXRlIHNjaGVtYSBhZ2FpbnN0IGl0cyBtZXRhLXNjaGVtYVxuICAgIHZhbGlkYXRlU2NoZW1hKHNjaGVtYSwgdGhyb3dPckxvZ0Vycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCAkc2NoZW1hO1xuICAgICAgICAkc2NoZW1hID0gc2NoZW1hLiRzY2hlbWE7XG4gICAgICAgIGlmICgkc2NoZW1hICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mICRzY2hlbWEgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJHNjaGVtYSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgICRzY2hlbWEgPSAkc2NoZW1hIHx8IHRoaXMub3B0cy5kZWZhdWx0TWV0YSB8fCB0aGlzLmRlZmF1bHRNZXRhKCk7XG4gICAgICAgIGlmICghJHNjaGVtYSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIm1ldGEtc2NoZW1hIG5vdCBhdmFpbGFibGVcIik7XG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZCA9IHRoaXMudmFsaWRhdGUoJHNjaGVtYSwgc2NoZW1hKTtcbiAgICAgICAgaWYgKCF2YWxpZCAmJiB0aHJvd09yTG9nRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBcInNjaGVtYSBpcyBpbnZhbGlkOiBcIiArIHRoaXMuZXJyb3JzVGV4dCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSA9PT0gXCJsb2dcIilcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cbiAgICAvLyBHZXQgY29tcGlsZWQgc2NoZW1hIGJ5IGBrZXlgIG9yIGByZWZgLlxuICAgIC8vIChga2V5YCB0aGF0IHdhcyBwYXNzZWQgdG8gYGFkZFNjaGVtYWAgb3IgZnVsbCBzY2hlbWEgcmVmZXJlbmNlIC0gYHNjaGVtYS4kaWRgIG9yIHJlc29sdmVkIGlkKVxuICAgIGdldFNjaGVtYShrZXlSZWYpIHtcbiAgICAgICAgbGV0IHNjaDtcbiAgICAgICAgd2hpbGUgKHR5cGVvZiAoc2NoID0gZ2V0U2NoRW52LmNhbGwodGhpcywga2V5UmVmKSkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGtleVJlZiA9IHNjaDtcbiAgICAgICAgaWYgKHNjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgICAgICBjb25zdCByb290ID0gbmV3IGNvbXBpbGVfMS5TY2hlbWFFbnYoeyBzY2hlbWE6IHt9LCBzY2hlbWFJZCB9KTtcbiAgICAgICAgICAgIHNjaCA9IGNvbXBpbGVfMS5yZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwga2V5UmVmKTtcbiAgICAgICAgICAgIGlmICghc2NoKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMucmVmc1trZXlSZWZdID0gc2NoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoc2NoLnZhbGlkYXRlIHx8IHRoaXMuX2NvbXBpbGVTY2hlbWFFbnYoc2NoKSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBjYWNoZWQgc2NoZW1hKHMpLlxuICAgIC8vIElmIG5vIHBhcmFtZXRlciBpcyBwYXNzZWQgYWxsIHNjaGVtYXMgYnV0IG1ldGEtc2NoZW1hcyBhcmUgcmVtb3ZlZC5cbiAgICAvLyBJZiBSZWdFeHAgaXMgcGFzc2VkIGFsbCBzY2hlbWFzIHdpdGgga2V5L2lkIG1hdGNoaW5nIHBhdHRlcm4gYnV0IG1ldGEtc2NoZW1hcyBhcmUgcmVtb3ZlZC5cbiAgICAvLyBFdmVuIGlmIHNjaGVtYSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIHNjaGVtYXMgaXQgc3RpbGwgY2FuIGJlIHJlbW92ZWQgYXMgb3RoZXIgc2NoZW1hcyBoYXZlIGxvY2FsIHJlZmVyZW5jZXMuXG4gICAgcmVtb3ZlU2NoZW1hKHNjaGVtYUtleVJlZikge1xuICAgICAgICBpZiAoc2NoZW1hS2V5UmVmIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMuc2NoZW1hcywgc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5yZWZzLCBzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0eXBlb2Ygc2NoZW1hS2V5UmVmKSB7XG4gICAgICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnNjaGVtYXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5yZWZzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoID0gZ2V0U2NoRW52LmNhbGwodGhpcywgc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaCA9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5kZWxldGUoc2NoLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2NoZW1hc1tzY2hlbWFLZXlSZWZdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlZnNbc2NoZW1hS2V5UmVmXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gc2NoZW1hS2V5UmVmO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmRlbGV0ZShjYWNoZUtleSk7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gc2NoZW1hS2V5UmVmW3RoaXMub3B0cy5zY2hlbWFJZF07XG4gICAgICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkID0gcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2NoZW1hc1tpZF07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlZnNbaWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2LnJlbW92ZVNjaGVtYTogaW52YWxpZCBwYXJhbWV0ZXJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWRkIFwidm9jYWJ1bGFyeVwiIC0gYSBjb2xsZWN0aW9uIG9mIGtleXdvcmRzXG4gICAgYWRkVm9jYWJ1bGFyeShkZWZpbml0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IGRlZiBvZiBkZWZpbml0aW9ucylcbiAgICAgICAgICAgIHRoaXMuYWRkS2V5d29yZChkZWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkS2V5d29yZChrd2RPckRlZiwgZGVmIC8vIGRlcHJlY2F0ZWRcbiAgICApIHtcbiAgICAgICAgbGV0IGtleXdvcmQ7XG4gICAgICAgIGlmICh0eXBlb2Yga3dkT3JEZWYgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAga2V5d29yZCA9IGt3ZE9yRGVmO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWYgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJ0aGVzZSBwYXJhbWV0ZXJzIGFyZSBkZXByZWNhdGVkLCBzZWUgZG9jcyBmb3IgYWRkS2V5d29yZFwiKTtcbiAgICAgICAgICAgICAgICBkZWYua2V5d29yZCA9IGtleXdvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGt3ZE9yRGVmID09IFwib2JqZWN0XCIgJiYgZGVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlZiA9IGt3ZE9yRGVmO1xuICAgICAgICAgICAga2V5d29yZCA9IGRlZi5rZXl3b3JkO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5d29yZCkgJiYgIWtleXdvcmQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWRkS2V5d29yZHM6IGtleXdvcmQgbXVzdCBiZSBzdHJpbmcgb3Igbm9uLWVtcHR5IGFycmF5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhZGRLZXl3b3JkcyBwYXJhbWV0ZXJzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrS2V5d29yZC5jYWxsKHRoaXMsIGtleXdvcmQsIGRlZik7XG4gICAgICAgIGlmICghZGVmKSB7XG4gICAgICAgICAgICB1dGlsXzEuZWFjaEl0ZW0oa2V5d29yZCwgKGt3ZCkgPT4gYWRkUnVsZS5jYWxsKHRoaXMsIGt3ZCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAga2V5d29yZE1ldGFzY2hlbWEuY2FsbCh0aGlzLCBkZWYpO1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgLi4uZGVmLFxuICAgICAgICAgICAgdHlwZTogZGF0YVR5cGVfMS5nZXRKU09OVHlwZXMoZGVmLnR5cGUpLFxuICAgICAgICAgICAgc2NoZW1hVHlwZTogZGF0YVR5cGVfMS5nZXRKU09OVHlwZXMoZGVmLnNjaGVtYVR5cGUpLFxuICAgICAgICB9O1xuICAgICAgICB1dGlsXzEuZWFjaEl0ZW0oa2V5d29yZCwgZGVmaW5pdGlvbi50eXBlLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgPyAoaykgPT4gYWRkUnVsZS5jYWxsKHRoaXMsIGssIGRlZmluaXRpb24pXG4gICAgICAgICAgICA6IChrKSA9PiBkZWZpbml0aW9uLnR5cGUuZm9yRWFjaCgodCkgPT4gYWRkUnVsZS5jYWxsKHRoaXMsIGssIGRlZmluaXRpb24sIHQpKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRLZXl3b3JkKGtleXdvcmQpIHtcbiAgICAgICAgY29uc3QgcnVsZSA9IHRoaXMuUlVMRVMuYWxsW2tleXdvcmRdO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHJ1bGUgPT0gXCJvYmplY3RcIiA/IHJ1bGUuZGVmaW5pdGlvbiA6ICEhcnVsZTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGtleXdvcmRcbiAgICByZW1vdmVLZXl3b3JkKGtleXdvcmQpIHtcbiAgICAgICAgLy8gVE9ETyByZXR1cm4gdHlwZSBzaG91bGQgYmUgQWp2XG4gICAgICAgIGNvbnN0IHsgUlVMRVMgfSA9IHRoaXM7XG4gICAgICAgIGRlbGV0ZSBSVUxFUy5rZXl3b3Jkc1trZXl3b3JkXTtcbiAgICAgICAgZGVsZXRlIFJVTEVTLmFsbFtrZXl3b3JkXTtcbiAgICAgICAgZm9yIChjb25zdCBncm91cCBvZiBSVUxFUy5ydWxlcykge1xuICAgICAgICAgICAgY29uc3QgaSA9IGdyb3VwLnJ1bGVzLmZpbmRJbmRleCgocnVsZSkgPT4gcnVsZS5rZXl3b3JkID09PSBrZXl3b3JkKTtcbiAgICAgICAgICAgIGlmIChpID49IDApXG4gICAgICAgICAgICAgICAgZ3JvdXAucnVsZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBBZGQgZm9ybWF0XG4gICAgYWRkRm9ybWF0KG5hbWUsIGZvcm1hdCkge1xuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgZm9ybWF0ID0gbmV3IFJlZ0V4cChmb3JtYXQpO1xuICAgICAgICB0aGlzLmZvcm1hdHNbbmFtZV0gPSBmb3JtYXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBlcnJvcnNUZXh0KGVycm9ycyA9IHRoaXMuZXJyb3JzLCAvLyBvcHRpb25hbCBhcnJheSBvZiB2YWxpZGF0aW9uIGVycm9yc1xuICAgIHsgc2VwYXJhdG9yID0gXCIsIFwiLCBkYXRhVmFyID0gXCJkYXRhXCIgfSA9IHt9IC8vIG9wdGlvbmFsIG9wdGlvbnMgd2l0aCBwcm9wZXJ0aWVzIGBzZXBhcmF0b3JgIGFuZCBgZGF0YVZhcmBcbiAgICApIHtcbiAgICAgICAgaWYgKCFlcnJvcnMgfHwgZXJyb3JzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBcIk5vIGVycm9yc1wiO1xuICAgICAgICByZXR1cm4gZXJyb3JzXG4gICAgICAgICAgICAubWFwKChlKSA9PiBgJHtkYXRhVmFyfSR7ZS5pbnN0YW5jZVBhdGh9ICR7ZS5tZXNzYWdlfWApXG4gICAgICAgICAgICAucmVkdWNlKCh0ZXh0LCBtc2cpID0+IHRleHQgKyBzZXBhcmF0b3IgKyBtc2cpO1xuICAgIH1cbiAgICAkZGF0YU1ldGFTY2hlbWEobWV0YVNjaGVtYSwga2V5d29yZHNKc29uUG9pbnRlcnMpIHtcbiAgICAgICAgY29uc3QgcnVsZXMgPSB0aGlzLlJVTEVTLmFsbDtcbiAgICAgICAgbWV0YVNjaGVtYSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobWV0YVNjaGVtYSkpO1xuICAgICAgICBmb3IgKGNvbnN0IGpzb25Qb2ludGVyIG9mIGtleXdvcmRzSnNvblBvaW50ZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50cyA9IGpzb25Qb2ludGVyLnNwbGl0KFwiL1wiKS5zbGljZSgxKTsgLy8gZmlyc3Qgc2VnbWVudCBpcyBhbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgIGxldCBrZXl3b3JkcyA9IG1ldGFTY2hlbWE7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNlZyBvZiBzZWdtZW50cylcbiAgICAgICAgICAgICAgICBrZXl3b3JkcyA9IGtleXdvcmRzW3NlZ107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBydWxlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBydWxlc1trZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcnVsZSAhPSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7ICRkYXRhIH0gPSBydWxlLmRlZmluaXRpb247XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0ga2V5d29yZHNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoJGRhdGEgJiYgc2NoZW1hKVxuICAgICAgICAgICAgICAgICAgICBrZXl3b3Jkc1trZXldID0gc2NoZW1hT3JEYXRhKHNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGFTY2hlbWE7XG4gICAgfVxuICAgIF9yZW1vdmVBbGxTY2hlbWFzKHNjaGVtYXMsIHJlZ2V4KSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5UmVmIGluIHNjaGVtYXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaCA9IHNjaGVtYXNba2V5UmVmXTtcbiAgICAgICAgICAgIGlmICghcmVnZXggfHwgcmVnZXgudGVzdChrZXlSZWYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2ggPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hc1trZXlSZWZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2ggJiYgIXNjaC5tZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmRlbGV0ZShzY2guc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYXNba2V5UmVmXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2FkZFNjaGVtYShzY2hlbWEsIG1ldGEsIGJhc2VJZCwgdmFsaWRhdGVTY2hlbWEgPSB0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEsIGFkZFNjaGVtYSA9IHRoaXMub3B0cy5hZGRVc2VkU2NoZW1hKSB7XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZCA9IHNjaGVtYVtzY2hlbWFJZF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLmp0ZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgbXVzdCBiZSBvYmplY3RcIik7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hICE9IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNjaGVtYSBtdXN0IGJlIG9iamVjdCBvciBib29sZWFuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzY2ggPSB0aGlzLl9jYWNoZS5nZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKHNjaCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHNjaDtcbiAgICAgICAgY29uc3QgbG9jYWxSZWZzID0gcmVzb2x2ZV8xLmdldFNjaGVtYVJlZnMuY2FsbCh0aGlzLCBzY2hlbWEpO1xuICAgICAgICBiYXNlSWQgPSByZXNvbHZlXzEubm9ybWFsaXplSWQoaWQgfHwgYmFzZUlkKTtcbiAgICAgICAgc2NoID0gbmV3IGNvbXBpbGVfMS5TY2hlbWFFbnYoeyBzY2hlbWEsIHNjaGVtYUlkLCBtZXRhLCBiYXNlSWQsIGxvY2FsUmVmcyB9KTtcbiAgICAgICAgdGhpcy5fY2FjaGUuc2V0KHNjaC5zY2hlbWEsIHNjaCk7XG4gICAgICAgIGlmIChhZGRTY2hlbWEgJiYgIWJhc2VJZC5zdGFydHNXaXRoKFwiI1wiKSkge1xuICAgICAgICAgICAgLy8gVE9ETyBhdG0gaXQgaXMgYWxsb3dlZCB0byBvdmVyd3JpdGUgc2NoZW1hcyB3aXRob3V0IGlkIChpbnN0ZWFkIG9mIG5vdCBhZGRpbmcgdGhlbSlcbiAgICAgICAgICAgIGlmIChiYXNlSWQpXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tVbmlxdWUoYmFzZUlkKTtcbiAgICAgICAgICAgIHRoaXMucmVmc1tiYXNlSWRdID0gc2NoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWxpZGF0ZVNjaGVtYSlcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVTY2hlbWEoc2NoZW1hLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHNjaDtcbiAgICB9XG4gICAgX2NoZWNrVW5pcXVlKGlkKSB7XG4gICAgICAgIGlmICh0aGlzLnNjaGVtYXNbaWRdIHx8IHRoaXMucmVmc1tpZF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2NoZW1hIHdpdGgga2V5IG9yIGlkIFwiJHtpZH1cIiBhbHJlYWR5IGV4aXN0c2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jb21waWxlU2NoZW1hRW52KHNjaCkge1xuICAgICAgICBpZiAoc2NoLm1ldGEpXG4gICAgICAgICAgICB0aGlzLl9jb21waWxlTWV0YVNjaGVtYShzY2gpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjb21waWxlXzEuY29tcGlsZVNjaGVtYS5jYWxsKHRoaXMsIHNjaCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXNjaC52YWxpZGF0ZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICAgICAgcmV0dXJuIHNjaC52YWxpZGF0ZTtcbiAgICB9XG4gICAgX2NvbXBpbGVNZXRhU2NoZW1hKHNjaCkge1xuICAgICAgICBjb25zdCBjdXJyZW50T3B0cyA9IHRoaXMub3B0cztcbiAgICAgICAgdGhpcy5vcHRzID0gdGhpcy5fbWV0YU9wdHM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb21waWxlXzEuY29tcGlsZVNjaGVtYS5jYWxsKHRoaXMsIHNjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLm9wdHMgPSBjdXJyZW50T3B0cztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEFqdjtcbkFqdi5WYWxpZGF0aW9uRXJyb3IgPSB2YWxpZGF0aW9uX2Vycm9yXzEuZGVmYXVsdDtcbkFqdi5NaXNzaW5nUmVmRXJyb3IgPSByZWZfZXJyb3JfMS5kZWZhdWx0O1xuZnVuY3Rpb24gY2hlY2tPcHRpb25zKGNoZWNrT3B0cywgb3B0aW9ucywgbXNnLCBsb2cgPSBcImVycm9yXCIpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGVja09wdHMpIHtcbiAgICAgICAgY29uc3Qgb3B0ID0ga2V5O1xuICAgICAgICBpZiAob3B0IGluIG9wdGlvbnMpXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcltsb2ddKGAke21zZ306IG9wdGlvbiAke2tleX0uICR7Y2hlY2tPcHRzW29wdF19YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U2NoRW52KGtleVJlZikge1xuICAgIGtleVJlZiA9IHJlc29sdmVfMS5ub3JtYWxpemVJZChrZXlSZWYpOyAvLyBUT0RPIHRlc3RzIGZhaWwgd2l0aG91dCB0aGlzIGxpbmVcbiAgICByZXR1cm4gdGhpcy5zY2hlbWFzW2tleVJlZl0gfHwgdGhpcy5yZWZzW2tleVJlZl07XG59XG5mdW5jdGlvbiBhZGRJbml0aWFsU2NoZW1hcygpIHtcbiAgICBjb25zdCBvcHRzU2NoZW1hcyA9IHRoaXMub3B0cy5zY2hlbWFzO1xuICAgIGlmICghb3B0c1NjaGVtYXMpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRzU2NoZW1hcykpXG4gICAgICAgIHRoaXMuYWRkU2NoZW1hKG9wdHNTY2hlbWFzKTtcbiAgICBlbHNlXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wdHNTY2hlbWFzKVxuICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWEob3B0c1NjaGVtYXNba2V5XSwga2V5KTtcbn1cbmZ1bmN0aW9uIGFkZEluaXRpYWxGb3JtYXRzKCkge1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLm9wdHMuZm9ybWF0cykge1xuICAgICAgICBjb25zdCBmb3JtYXQgPSB0aGlzLm9wdHMuZm9ybWF0c1tuYW1lXTtcbiAgICAgICAgaWYgKGZvcm1hdClcbiAgICAgICAgICAgIHRoaXMuYWRkRm9ybWF0KG5hbWUsIGZvcm1hdCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkSW5pdGlhbEtleXdvcmRzKGRlZnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZWZzKSkge1xuICAgICAgICB0aGlzLmFkZFZvY2FidWxhcnkoZGVmcyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIud2FybihcImtleXdvcmRzIG9wdGlvbiBhcyBtYXAgaXMgZGVwcmVjYXRlZCwgcGFzcyBhcnJheVwiKTtcbiAgICBmb3IgKGNvbnN0IGtleXdvcmQgaW4gZGVmcykge1xuICAgICAgICBjb25zdCBkZWYgPSBkZWZzW2tleXdvcmRdO1xuICAgICAgICBpZiAoIWRlZi5rZXl3b3JkKVxuICAgICAgICAgICAgZGVmLmtleXdvcmQgPSBrZXl3b3JkO1xuICAgICAgICB0aGlzLmFkZEtleXdvcmQoZGVmKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRNZXRhU2NoZW1hT3B0aW9ucygpIHtcbiAgICBjb25zdCBtZXRhT3B0cyA9IHsgLi4udGhpcy5vcHRzIH07XG4gICAgZm9yIChjb25zdCBvcHQgb2YgTUVUQV9JR05PUkVfT1BUSU9OUylcbiAgICAgICAgZGVsZXRlIG1ldGFPcHRzW29wdF07XG4gICAgcmV0dXJuIG1ldGFPcHRzO1xufVxuY29uc3Qgbm9Mb2dzID0geyBsb2coKSB7IH0sIHdhcm4oKSB7IH0sIGVycm9yKCkgeyB9IH07XG5mdW5jdGlvbiBnZXRMb2dnZXIobG9nZ2VyKSB7XG4gICAgaWYgKGxvZ2dlciA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybiBub0xvZ3M7XG4gICAgaWYgKGxvZ2dlciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gY29uc29sZTtcbiAgICBpZiAobG9nZ2VyLmxvZyAmJiBsb2dnZXIud2FybiAmJiBsb2dnZXIuZXJyb3IpXG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibG9nZ2VyIG11c3QgaW1wbGVtZW50IGxvZywgd2FybiBhbmQgZXJyb3IgbWV0aG9kc1wiKTtcbn1cbmNvbnN0IEtFWVdPUkRfTkFNRSA9IC9eW2Etel8kXVthLXowLTlfJDotXSokL2k7XG5mdW5jdGlvbiBjaGVja0tleXdvcmQoa2V5d29yZCwgZGVmKSB7XG4gICAgY29uc3QgeyBSVUxFUyB9ID0gdGhpcztcbiAgICB1dGlsXzEuZWFjaEl0ZW0oa2V5d29yZCwgKGt3ZCkgPT4ge1xuICAgICAgICBpZiAoUlVMRVMua2V5d29yZHNba3dkXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5d29yZCAke2t3ZH0gaXMgYWxyZWFkeSBkZWZpbmVkYCk7XG4gICAgICAgIGlmICghS0VZV09SRF9OQU1FLnRlc3Qoa3dkKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5d29yZCAke2t3ZH0gaGFzIGludmFsaWQgbmFtZWApO1xuICAgIH0pO1xuICAgIGlmICghZGVmKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGRlZi4kZGF0YSAmJiAhKFwiY29kZVwiIGluIGRlZiB8fCBcInZhbGlkYXRlXCIgaW4gZGVmKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyRkYXRhIGtleXdvcmQgbXVzdCBoYXZlIFwiY29kZVwiIG9yIFwidmFsaWRhdGVcIiBmdW5jdGlvbicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZFJ1bGUoa2V5d29yZCwgZGVmaW5pdGlvbiwgZGF0YVR5cGUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcG9zdCA9IGRlZmluaXRpb24gPT09IG51bGwgfHwgZGVmaW5pdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVmaW5pdGlvbi5wb3N0O1xuICAgIGlmIChkYXRhVHlwZSAmJiBwb3N0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tleXdvcmQgd2l0aCBcInBvc3RcIiBmbGFnIGNhbm5vdCBoYXZlIFwidHlwZVwiJyk7XG4gICAgY29uc3QgeyBSVUxFUyB9ID0gdGhpcztcbiAgICBsZXQgcnVsZUdyb3VwID0gcG9zdCA/IFJVTEVTLnBvc3QgOiBSVUxFUy5ydWxlcy5maW5kKCh7IHR5cGU6IHQgfSkgPT4gdCA9PT0gZGF0YVR5cGUpO1xuICAgIGlmICghcnVsZUdyb3VwKSB7XG4gICAgICAgIHJ1bGVHcm91cCA9IHsgdHlwZTogZGF0YVR5cGUsIHJ1bGVzOiBbXSB9O1xuICAgICAgICBSVUxFUy5ydWxlcy5wdXNoKHJ1bGVHcm91cCk7XG4gICAgfVxuICAgIFJVTEVTLmtleXdvcmRzW2tleXdvcmRdID0gdHJ1ZTtcbiAgICBpZiAoIWRlZmluaXRpb24pXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBydWxlID0ge1xuICAgICAgICBrZXl3b3JkLFxuICAgICAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgICAgICAuLi5kZWZpbml0aW9uLFxuICAgICAgICAgICAgdHlwZTogZGF0YVR5cGVfMS5nZXRKU09OVHlwZXMoZGVmaW5pdGlvbi50eXBlKSxcbiAgICAgICAgICAgIHNjaGVtYVR5cGU6IGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKGRlZmluaXRpb24uc2NoZW1hVHlwZSksXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBpZiAoZGVmaW5pdGlvbi5iZWZvcmUpXG4gICAgICAgIGFkZEJlZm9yZVJ1bGUuY2FsbCh0aGlzLCBydWxlR3JvdXAsIHJ1bGUsIGRlZmluaXRpb24uYmVmb3JlKTtcbiAgICBlbHNlXG4gICAgICAgIHJ1bGVHcm91cC5ydWxlcy5wdXNoKHJ1bGUpO1xuICAgIFJVTEVTLmFsbFtrZXl3b3JkXSA9IHJ1bGU7XG4gICAgKF9hID0gZGVmaW5pdGlvbi5pbXBsZW1lbnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCgoa3dkKSA9PiB0aGlzLmFkZEtleXdvcmQoa3dkKSk7XG59XG5mdW5jdGlvbiBhZGRCZWZvcmVSdWxlKHJ1bGVHcm91cCwgcnVsZSwgYmVmb3JlKSB7XG4gICAgY29uc3QgaSA9IHJ1bGVHcm91cC5ydWxlcy5maW5kSW5kZXgoKF9ydWxlKSA9PiBfcnVsZS5rZXl3b3JkID09PSBiZWZvcmUpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgICAgcnVsZUdyb3VwLnJ1bGVzLnNwbGljZShpLCAwLCBydWxlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJ1bGVHcm91cC5ydWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBydWxlICR7YmVmb3JlfSBpcyBub3QgZGVmaW5lZGApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGtleXdvcmRNZXRhc2NoZW1hKGRlZikge1xuICAgIGxldCB7IG1ldGFTY2hlbWEgfSA9IGRlZjtcbiAgICBpZiAobWV0YVNjaGVtYSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGRlZi4kZGF0YSAmJiB0aGlzLm9wdHMuJGRhdGEpXG4gICAgICAgIG1ldGFTY2hlbWEgPSBzY2hlbWFPckRhdGEobWV0YVNjaGVtYSk7XG4gICAgZGVmLnZhbGlkYXRlU2NoZW1hID0gdGhpcy5jb21waWxlKG1ldGFTY2hlbWEsIHRydWUpO1xufVxuY29uc3QgJGRhdGFSZWYgPSB7XG4gICAgJHJlZjogXCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vYWp2LXZhbGlkYXRvci9hanYvbWFzdGVyL2xpYi9yZWZzL2RhdGEuanNvbiNcIixcbn07XG5mdW5jdGlvbiBzY2hlbWFPckRhdGEoc2NoZW1hKSB7XG4gICAgcmV0dXJuIHsgYW55T2Y6IFtzY2hlbWEsICRkYXRhUmVmXSB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29yZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImlkXCIsXG4gICAgY29kZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOT1QgU1VQUE9SVEVEOiBrZXl3b3JkIFwiaWRcIiwgdXNlIFwiJGlkXCIgZm9yIHNjaGVtYSBJRCcpO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNhbGxSZWYgPSBleHBvcnRzLmdldFZhbGlkYXRlID0gdm9pZCAwO1xuY29uc3QgcmVmX2Vycm9yXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9yZWZfZXJyb3JcIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvbmFtZXNcIik7XG5jb25zdCBjb21waWxlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCIkcmVmXCIsXG4gICAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hOiAkcmVmLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IGJhc2VJZCwgc2NoZW1hRW52OiBlbnYsIHZhbGlkYXRlTmFtZSwgb3B0cywgc2VsZiB9ID0gaXQ7XG4gICAgICAgIGNvbnN0IHsgcm9vdCB9ID0gZW52O1xuICAgICAgICBpZiAoKCRyZWYgPT09IFwiI1wiIHx8ICRyZWYgPT09IFwiIy9cIikgJiYgYmFzZUlkID09PSByb290LmJhc2VJZClcbiAgICAgICAgICAgIHJldHVybiBjYWxsUm9vdFJlZigpO1xuICAgICAgICBjb25zdCBzY2hPckVudiA9IGNvbXBpbGVfMS5yZXNvbHZlUmVmLmNhbGwoc2VsZiwgcm9vdCwgYmFzZUlkLCAkcmVmKTtcbiAgICAgICAgaWYgKHNjaE9yRW52ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgcmVmX2Vycm9yXzEuZGVmYXVsdChiYXNlSWQsICRyZWYpO1xuICAgICAgICBpZiAoc2NoT3JFbnYgaW5zdGFuY2VvZiBjb21waWxlXzEuU2NoZW1hRW52KVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxWYWxpZGF0ZShzY2hPckVudik7XG4gICAgICAgIHJldHVybiBpbmxpbmVSZWZTY2hlbWEoc2NoT3JFbnYpO1xuICAgICAgICBmdW5jdGlvbiBjYWxsUm9vdFJlZigpIHtcbiAgICAgICAgICAgIGlmIChlbnYgPT09IHJvb3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxSZWYoY3h0LCB2YWxpZGF0ZU5hbWUsIGVudiwgZW52LiRhc3luYyk7XG4gICAgICAgICAgICBjb25zdCByb290TmFtZSA9IGdlbi5zY29wZVZhbHVlKFwicm9vdFwiLCB7IHJlZjogcm9vdCB9KTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsUmVmKGN4dCwgY29kZWdlbl8xLl8gYCR7cm9vdE5hbWV9LnZhbGlkYXRlYCwgcm9vdCwgcm9vdC4kYXN5bmMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhbGxWYWxpZGF0ZShzY2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBnZXRWYWxpZGF0ZShjeHQsIHNjaCk7XG4gICAgICAgICAgICBjYWxsUmVmKGN4dCwgdiwgc2NoLCBzY2guJGFzeW5jKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbmxpbmVSZWZTY2hlbWEoc2NoKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hOYW1lID0gZ2VuLnNjb3BlVmFsdWUoXCJzY2hlbWFcIiwgb3B0cy5jb2RlLnNvdXJjZSA9PT0gdHJ1ZSA/IHsgcmVmOiBzY2gsIGNvZGU6IGNvZGVnZW5fMS5zdHJpbmdpZnkoc2NoKSB9IDogeyByZWY6IHNjaCB9KTtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlczogW10sXG4gICAgICAgICAgICAgICAgc2NoZW1hUGF0aDogY29kZWdlbl8xLm5pbCxcbiAgICAgICAgICAgICAgICB0b3BTY2hlbWFSZWY6IHNjaE5hbWUsXG4gICAgICAgICAgICAgICAgZXJyU2NoZW1hUGF0aDogJHJlZixcbiAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQpO1xuICAgICAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZnVuY3Rpb24gZ2V0VmFsaWRhdGUoY3h0LCBzY2gpIHtcbiAgICBjb25zdCB7IGdlbiB9ID0gY3h0O1xuICAgIHJldHVybiBzY2gudmFsaWRhdGVcbiAgICAgICAgPyBnZW4uc2NvcGVWYWx1ZShcInZhbGlkYXRlXCIsIHsgcmVmOiBzY2gudmFsaWRhdGUgfSlcbiAgICAgICAgOiBjb2RlZ2VuXzEuXyBgJHtnZW4uc2NvcGVWYWx1ZShcIndyYXBwZXJcIiwgeyByZWY6IHNjaCB9KX0udmFsaWRhdGVgO1xufVxuZXhwb3J0cy5nZXRWYWxpZGF0ZSA9IGdldFZhbGlkYXRlO1xuZnVuY3Rpb24gY2FsbFJlZihjeHQsIHYsIHNjaCwgJGFzeW5jKSB7XG4gICAgY29uc3QgeyBnZW4sIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgeyBhbGxFcnJvcnMsIHNjaGVtYUVudjogZW52LCBvcHRzIH0gPSBpdDtcbiAgICBjb25zdCBwYXNzQ3h0ID0gb3B0cy5wYXNzQ29udGV4dCA/IG5hbWVzXzEuZGVmYXVsdC50aGlzIDogY29kZWdlbl8xLm5pbDtcbiAgICBpZiAoJGFzeW5jKVxuICAgICAgICBjYWxsQXN5bmNSZWYoKTtcbiAgICBlbHNlXG4gICAgICAgIGNhbGxTeW5jUmVmKCk7XG4gICAgZnVuY3Rpb24gY2FsbEFzeW5jUmVmKCkge1xuICAgICAgICBpZiAoIWVudi4kYXN5bmMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBzY2hlbWEgcmVmZXJlbmNlZCBieSBzeW5jIHNjaGVtYVwiKTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIik7XG4gICAgICAgIGdlbi50cnkoKCkgPT4ge1xuICAgICAgICAgICAgZ2VuLmNvZGUoY29kZWdlbl8xLl8gYGF3YWl0ICR7Y29kZV8xLmNhbGxWYWxpZGF0ZUNvZGUoY3h0LCB2LCBwYXNzQ3h0KX1gKTtcbiAgICAgICAgICAgIGFkZEV2YWx1YXRlZEZyb20odik7IC8vIFRPRE8gd2lsbCBub3Qgd29yayB3aXRoIGFzeW5jLCBpdCBoYXMgdG8gYmUgcmV0dXJuZWQgd2l0aCB0aGUgcmVzdWx0XG4gICAgICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgfSwgKGUpID0+IHtcbiAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgISgke2V9IGluc3RhbmNlb2YgJHtpdC5WYWxpZGF0aW9uRXJyb3J9KWAsICgpID0+IGdlbi50aHJvdyhlKSk7XG4gICAgICAgICAgICBhZGRFcnJvcnNGcm9tKGUpO1xuICAgICAgICAgICAgaWYgKCFhbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FsbFN5bmNSZWYoKSB7XG4gICAgICAgIGN4dC5yZXN1bHQoY29kZV8xLmNhbGxWYWxpZGF0ZUNvZGUoY3h0LCB2LCBwYXNzQ3h0KSwgKCkgPT4gYWRkRXZhbHVhdGVkRnJvbSh2KSwgKCkgPT4gYWRkRXJyb3JzRnJvbSh2KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZEVycm9yc0Zyb20oc291cmNlKSB7XG4gICAgICAgIGNvbnN0IGVycnMgPSBjb2RlZ2VuXzEuXyBgJHtzb3VyY2V9LmVycm9yc2A7XG4gICAgICAgIGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfSA9PT0gbnVsbCA/ICR7ZXJyc30gOiAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5jb25jYXQoJHtlcnJzfSlgKTsgLy8gVE9ETyB0YWdnZWRcbiAgICAgICAgZ2VuLmFzc2lnbihuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30ubGVuZ3RoYCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZEV2YWx1YXRlZEZyb20oc291cmNlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFpdC5vcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBzY2hFdmFsdWF0ZWQgPSAoX2EgPSBzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2gudmFsaWRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ldmFsdWF0ZWQ7XG4gICAgICAgIC8vIFRPRE8gcmVmYWN0b3JcbiAgICAgICAgaWYgKGl0LnByb3BzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoc2NoRXZhbHVhdGVkICYmICFzY2hFdmFsdWF0ZWQuZHluYW1pY1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaEV2YWx1YXRlZC5wcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgc2NoRXZhbHVhdGVkLnByb3BzLCBpdC5wcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBnZW4udmFyKFwicHJvcHNcIiwgY29kZWdlbl8xLl8gYCR7c291cmNlfS5ldmFsdWF0ZWQucHJvcHNgKTtcbiAgICAgICAgICAgICAgICBpdC5wcm9wcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5wcm9wcyhnZW4sIHByb3BzLCBpdC5wcm9wcywgY29kZWdlbl8xLk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5pdGVtcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHNjaEV2YWx1YXRlZCAmJiAhc2NoRXZhbHVhdGVkLmR5bmFtaWNJdGVtcykge1xuICAgICAgICAgICAgICAgIGlmIChzY2hFdmFsdWF0ZWQuaXRlbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpdC5pdGVtcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5pdGVtcyhnZW4sIHNjaEV2YWx1YXRlZC5pdGVtcywgaXQuaXRlbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gZ2VuLnZhcihcIml0ZW1zXCIsIGNvZGVnZW5fMS5fIGAke3NvdXJjZX0uZXZhbHVhdGVkLml0ZW1zYCk7XG4gICAgICAgICAgICAgICAgaXQuaXRlbXMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBpdGVtcywgaXQuaXRlbXMsIGNvZGVnZW5fMS5OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuY2FsbFJlZiA9IGNhbGxSZWY7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBpZF8xID0gcmVxdWlyZShcIi4vaWRcIik7XG5jb25zdCByZWZfMSA9IHJlcXVpcmUoXCIuL3JlZlwiKTtcbmNvbnN0IGNvcmUgPSBbXG4gICAgXCIkc2NoZW1hXCIsXG4gICAgXCIkaWRcIixcbiAgICBcIiRkZWZzXCIsXG4gICAgXCIkdm9jYWJ1bGFyeVwiLFxuICAgIHsga2V5d29yZDogXCIkY29tbWVudFwiIH0sXG4gICAgXCJkZWZpbml0aW9uc1wiLFxuICAgIGlkXzEuZGVmYXVsdCxcbiAgICByZWZfMS5kZWZhdWx0LFxuXTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBvcHMgPSBjb2RlZ2VuXzEub3BlcmF0b3JzO1xuY29uc3QgS1dEcyA9IHtcbiAgICBtYXhpbXVtOiB7IG9rU3RyOiBcIjw9XCIsIG9rOiBvcHMuTFRFLCBmYWlsOiBvcHMuR1QgfSxcbiAgICBtaW5pbXVtOiB7IG9rU3RyOiBcIj49XCIsIG9rOiBvcHMuR1RFLCBmYWlsOiBvcHMuTFQgfSxcbiAgICBleGNsdXNpdmVNYXhpbXVtOiB7IG9rU3RyOiBcIjxcIiwgb2s6IG9wcy5MVCwgZmFpbDogb3BzLkdURSB9LFxuICAgIGV4Y2x1c2l2ZU1pbmltdW06IHsgb2tTdHI6IFwiPlwiLCBvazogb3BzLkdULCBmYWlsOiBvcHMuTFRFIH0sXG59O1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBtdXN0IGJlICR7S1dEc1trZXl3b3JkXS5va1N0cn0gJHtzY2hlbWFDb2RlfWAsXG4gICAgcGFyYW1zOiAoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pID0+IGNvZGVnZW5fMS5fIGB7Y29tcGFyaXNvbjogJHtLV0RzW2tleXdvcmRdLm9rU3RyfSwgbGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogT2JqZWN0LmtleXMoS1dEcyksXG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSB9ID0gY3h0O1xuICAgICAgICBjeHQuZmFpbCRkYXRhKGNvZGVnZW5fMS5fIGAke2RhdGF9ICR7S1dEc1trZXl3b3JkXS5mYWlsfSAke3NjaGVtYUNvZGV9IHx8IGlzTmFOKCR7ZGF0YX0pYCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW1pdE51bWJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBzY2hlbWFDb2RlIH0pID0+IGNvZGVnZW5fMS5zdHIgYG11c3QgYmUgbXVsdGlwbGUgb2YgJHtzY2hlbWFDb2RlfWAsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+IGNvZGVnZW5fMS5fIGB7bXVsdGlwbGVPZjogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIm11bHRpcGxlT2ZcIixcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIC8vIGNvbnN0IGJkdCA9IGJhZCREYXRhVHlwZShzY2hlbWFDb2RlLCA8c3RyaW5nPmRlZi5zY2hlbWFUeXBlLCAkZGF0YSlcbiAgICAgICAgY29uc3QgcHJlYyA9IGl0Lm9wdHMubXVsdGlwbGVPZlByZWNpc2lvbjtcbiAgICAgICAgY29uc3QgcmVzID0gZ2VuLmxldChcInJlc1wiKTtcbiAgICAgICAgY29uc3QgaW52YWxpZCA9IHByZWNcbiAgICAgICAgICAgID8gY29kZWdlbl8xLl8gYE1hdGguYWJzKE1hdGgucm91bmQoJHtyZXN9KSAtICR7cmVzfSkgPiAxZS0ke3ByZWN9YFxuICAgICAgICAgICAgOiBjb2RlZ2VuXzEuXyBgJHtyZXN9ICE9PSBwYXJzZUludCgke3Jlc30pYDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YShjb2RlZ2VuXzEuXyBgKCR7c2NoZW1hQ29kZX0gPT09IDAgfHwgKCR7cmVzfSA9ICR7ZGF0YX0vJHtzY2hlbWFDb2RlfSwgJHtpbnZhbGlkfSkpYCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aXBsZU9mLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmdcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXN0aWVqcy9wdW55Y29kZS5qcyAtIHB1bnljb2RlLnVjczIuZGVjb2RlXG5mdW5jdGlvbiB1Y3MybGVuZ3RoKHN0cikge1xuICAgIGNvbnN0IGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgbGV0IHZhbHVlO1xuICAgIHdoaWxlIChwb3MgPCBsZW4pIHtcbiAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgIHZhbHVlID0gc3RyLmNoYXJDb2RlQXQocG9zKyspO1xuICAgICAgICBpZiAodmFsdWUgPj0gMHhkODAwICYmIHZhbHVlIDw9IDB4ZGJmZiAmJiBwb3MgPCBsZW4pIHtcbiAgICAgICAgICAgIC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuICAgICAgICAgICAgdmFsdWUgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKCh2YWx1ZSAmIDB4ZmMwMCkgPT09IDB4ZGMwMClcbiAgICAgICAgICAgICAgICBwb3MrKzsgLy8gbG93IHN1cnJvZ2F0ZVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZW5ndGg7XG59XG5leHBvcnRzLmRlZmF1bHQgPSB1Y3MybGVuZ3RoO1xudWNzMmxlbmd0aC5jb2RlID0gJ3JlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL3VjczJsZW5ndGhcIikuZGVmYXVsdCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11Y3MybGVuZ3RoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCB1Y3MybGVuZ3RoXzEgPSByZXF1aXJlKFwiLi4vLi4vcnVudGltZS91Y3MybGVuZ3RoXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZSh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkge1xuICAgICAgICBjb25zdCBjb21wID0ga2V5d29yZCA9PT0gXCJtYXhMZW5ndGhcIiA/IFwibW9yZVwiIDogXCJmZXdlclwiO1xuICAgICAgICByZXR1cm4gY29kZWdlbl8xLnN0ciBgbXVzdCBOT1QgaGF2ZSAke2NvbXB9IHRoYW4gJHtzY2hlbWFDb2RlfSBjaGFyYWN0ZXJzYDtcbiAgICB9LFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuXyBge2xpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFtcIm1heExlbmd0aFwiLCBcIm1pbkxlbmd0aFwiXSxcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4TGVuZ3RoXCIgPyBjb2RlZ2VuXzEub3BlcmF0b3JzLkdUIDogY29kZWdlbl8xLm9wZXJhdG9ycy5MVDtcbiAgICAgICAgY29uc3QgbGVuID0gaXQub3B0cy51bmljb2RlID09PSBmYWxzZSA/IGNvZGVnZW5fMS5fIGAke2RhdGF9Lmxlbmd0aGAgOiBjb2RlZ2VuXzEuXyBgJHt1dGlsXzEudXNlRnVuYyhjeHQuZ2VuLCB1Y3MybGVuZ3RoXzEuZGVmYXVsdCl9KCR7ZGF0YX0pYDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YShjb2RlZ2VuXzEuXyBgJHtsZW59ICR7b3B9ICR7c2NoZW1hQ29kZX1gKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0TGVuZ3RoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBtdXN0IG1hdGNoIHBhdHRlcm4gXCIke3NjaGVtYUNvZGV9XCJgLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuXyBge3BhdHRlcm46ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJwYXR0ZXJuXCIsXG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLy8gVE9ETyByZWdleHAgc2hvdWxkIGJlIHdyYXBwZWQgaW4gdHJ5L2NhdGNoc1xuICAgICAgICBjb25zdCB1ID0gaXQub3B0cy51bmljb2RlUmVnRXhwID8gXCJ1XCIgOiBcIlwiO1xuICAgICAgICBjb25zdCByZWdFeHAgPSAkZGF0YSA/IGNvZGVnZW5fMS5fIGAobmV3IFJlZ0V4cCgke3NjaGVtYUNvZGV9LCAke3V9KSlgIDogY29kZV8xLnVzZVBhdHRlcm4oY3h0LCBzY2hlbWEpO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKGNvZGVnZW5fMS5fIGAhJHtyZWdFeHB9LnRlc3QoJHtkYXRhfSlgKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdHRlcm4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZSh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkge1xuICAgICAgICBjb25zdCBjb21wID0ga2V5d29yZCA9PT0gXCJtYXhQcm9wZXJ0aWVzXCIgPyBcIm1vcmVcIiA6IFwiZmV3ZXJcIjtcbiAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5zdHIgYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gaXRlbXNgO1xuICAgIH0sXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+IGNvZGVnZW5fMS5fIGB7bGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogW1wibWF4UHJvcGVydGllc1wiLCBcIm1pblByb3BlcnRpZXNcIl0sXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSB9ID0gY3h0O1xuICAgICAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4UHJvcGVydGllc1wiID8gY29kZWdlbl8xLm9wZXJhdG9ycy5HVCA6IGNvZGVnZW5fMS5vcGVyYXRvcnMuTFQ7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoY29kZWdlbl8xLl8gYE9iamVjdC5rZXlzKCR7ZGF0YX0pLmxlbmd0aCAke29wfSAke3NjaGVtYUNvZGV9YCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW1pdFByb3BlcnRpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eSB9IH0pID0+IGNvZGVnZW5fMS5zdHIgYG11c3QgaGF2ZSByZXF1aXJlZCBwcm9wZXJ0eSAnJHttaXNzaW5nUHJvcGVydHl9J2AsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5IH0gfSkgPT4gY29kZWdlbl8xLl8gYHttaXNzaW5nUHJvcGVydHk6ICR7bWlzc2luZ1Byb3BlcnR5fX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInJlcXVpcmVkXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgc2NoZW1hQ29kZSwgZGF0YSwgJGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgb3B0cyB9ID0gaXQ7XG4gICAgICAgIGlmICghJGRhdGEgJiYgc2NoZW1hLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdXNlTG9vcCA9IHNjaGVtYS5sZW5ndGggPj0gb3B0cy5sb29wUmVxdWlyZWQ7XG4gICAgICAgIGlmIChpdC5hbGxFcnJvcnMpXG4gICAgICAgICAgICBhbGxFcnJvcnNNb2RlKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGV4aXRPbkVycm9yTW9kZSgpO1xuICAgICAgICBpZiAob3B0cy5zdHJpY3RSZXF1aXJlZCkge1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBjeHQucGFyZW50U2NoZW1hLnByb3BlcnRpZXM7XG4gICAgICAgICAgICBjb25zdCB7IGRlZmluZWRQcm9wZXJ0aWVzIH0gPSBjeHQuaXQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlcXVpcmVkS2V5IG9mIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGlmICgocHJvcHMgPT09IG51bGwgfHwgcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BzW3JlcXVpcmVkS2V5XSkgPT09IHVuZGVmaW5lZCAmJiAhZGVmaW5lZFByb3BlcnRpZXMuaGFzKHJlcXVpcmVkS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWFQYXRoID0gaXQuc2NoZW1hRW52LmJhc2VJZCArIGl0LmVyclNjaGVtYVBhdGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IGByZXF1aXJlZCBwcm9wZXJ0eSBcIiR7cmVxdWlyZWRLZXl9XCIgaXMgbm90IGRlZmluZWQgYXQgXCIke3NjaGVtYVBhdGh9XCIgKHN0cmljdFJlcXVpcmVkKWA7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5jaGVja1N0cmljdE1vZGUoaXQsIG1zZywgaXQub3B0cy5zdHJpY3RSZXF1aXJlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFsbEVycm9yc01vZGUoKSB7XG4gICAgICAgICAgICBpZiAodXNlTG9vcCB8fCAkZGF0YSkge1xuICAgICAgICAgICAgICAgIGN4dC5ibG9jayRkYXRhKGNvZGVnZW5fMS5uaWwsIGxvb3BBbGxSZXF1aXJlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2Ygc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGVfMS5jaGVja1JlcG9ydE1pc3NpbmdQcm9wKGN4dCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGV4aXRPbkVycm9yTW9kZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pc3NpbmcgPSBnZW4ubGV0KFwibWlzc2luZ1wiKTtcbiAgICAgICAgICAgIGlmICh1c2VMb29wIHx8ICRkYXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsICgpID0+IGxvb3BVbnRpbE1pc3NpbmcobWlzc2luZywgdmFsaWQpKTtcbiAgICAgICAgICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVfMS5jaGVja01pc3NpbmdQcm9wKGN4dCwgc2NoZW1hLCBtaXNzaW5nKSk7XG4gICAgICAgICAgICAgICAgY29kZV8xLnJlcG9ydE1pc3NpbmdQcm9wKGN4dCwgbWlzc2luZyk7XG4gICAgICAgICAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb29wQWxsUmVxdWlyZWQoKSB7XG4gICAgICAgICAgICBnZW4uZm9yT2YoXCJwcm9wXCIsIHNjaGVtYUNvZGUsIChwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IG1pc3NpbmdQcm9wZXJ0eTogcHJvcCB9KTtcbiAgICAgICAgICAgICAgICBnZW4uaWYoY29kZV8xLm5vUHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBvcHRzLm93blByb3BlcnRpZXMpLCAoKSA9PiBjeHQuZXJyb3IoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb29wVW50aWxNaXNzaW5nKG1pc3NpbmcsIHZhbGlkKSB7XG4gICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgbWlzc2luZ1Byb3BlcnR5OiBtaXNzaW5nIH0pO1xuICAgICAgICAgICAgZ2VuLmZvck9mKG1pc3NpbmcsIHNjaGVtYUNvZGUsICgpID0+IHtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBjb2RlXzEucHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBtaXNzaW5nLCBvcHRzLm93blByb3BlcnRpZXMpKTtcbiAgICAgICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLm5vdCh2YWxpZCksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5icmVhaygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgY29kZWdlbl8xLm5pbCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcXVpcmVkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2UoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pIHtcbiAgICAgICAgY29uc3QgY29tcCA9IGtleXdvcmQgPT09IFwibWF4SXRlbXNcIiA/IFwibW9yZVwiIDogXCJmZXdlclwiO1xuICAgICAgICByZXR1cm4gY29kZWdlbl8xLnN0ciBgbXVzdCBOT1QgaGF2ZSAke2NvbXB9IHRoYW4gJHtzY2hlbWFDb2RlfSBpdGVtc2A7XG4gICAgfSxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLl8gYHtsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBbXCJtYXhJdGVtc1wiLCBcIm1pbkl0ZW1zXCJdLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSB9ID0gY3h0O1xuICAgICAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4SXRlbXNcIiA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuR1QgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLkxUO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKGNvZGVnZW5fMS5fIGAke2RhdGF9Lmxlbmd0aCAke29wfSAke3NjaGVtYUNvZGV9YCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW1pdEl0ZW1zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Fqdi12YWxpZGF0b3IvYWp2L2lzc3Vlcy84ODlcbmNvbnN0IGVxdWFsID0gcmVxdWlyZShcImZhc3QtZGVlcC1lcXVhbFwiKTtcbmVxdWFsLmNvZGUgPSAncmVxdWlyZShcImFqdi9kaXN0L3J1bnRpbWUvZXF1YWxcIikuZGVmYXVsdCc7XG5leHBvcnRzLmRlZmF1bHQgPSBlcXVhbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVxdWFsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZGF0YVR5cGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlL2RhdGFUeXBlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcXVhbF8xID0gcmVxdWlyZShcIi4uLy4uL3J1bnRpbWUvZXF1YWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgaSwgaiB9IH0pID0+IGNvZGVnZW5fMS5zdHIgYG11c3QgTk9UIGhhdmUgZHVwbGljYXRlIGl0ZW1zIChpdGVtcyAjIyAke2p9IGFuZCAke2l9IGFyZSBpZGVudGljYWwpYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBpLCBqIH0gfSkgPT4gY29kZWdlbl8xLl8gYHtpOiAke2l9LCBqOiAke2p9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwidW5pcXVlSXRlbXNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogXCJib29sZWFuXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKCEkZGF0YSAmJiAhc2NoZW1hKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiKTtcbiAgICAgICAgY29uc3QgaXRlbVR5cGVzID0gcGFyZW50U2NoZW1hLml0ZW1zID8gZGF0YVR5cGVfMS5nZXRTY2hlbWFUeXBlcyhwYXJlbnRTY2hlbWEuaXRlbXMpIDogW107XG4gICAgICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCB2YWxpZGF0ZVVuaXF1ZUl0ZW1zLCBjb2RlZ2VuXzEuXyBgJHtzY2hlbWFDb2RlfSA9PT0gZmFsc2VgKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVVbmlxdWVJdGVtcygpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBnZW4ubGV0KFwiaVwiLCBjb2RlZ2VuXzEuXyBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICAgICAgICAgIGNvbnN0IGogPSBnZW4ubGV0KFwialwiKTtcbiAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBpLCBqIH0pO1xuICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7aX0gPiAxYCwgKCkgPT4gKGNhbk9wdGltaXplKCkgPyBsb29wTiA6IGxvb3BOMikoaSwgaikpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhbk9wdGltaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1UeXBlcy5sZW5ndGggPiAwICYmICFpdGVtVHlwZXMuc29tZSgodCkgPT4gdCA9PT0gXCJvYmplY3RcIiB8fCB0ID09PSBcImFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BOKGksIGopIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBnZW4ubmFtZShcIml0ZW1cIik7XG4gICAgICAgICAgICBjb25zdCB3cm9uZ1R5cGUgPSBkYXRhVHlwZV8xLmNoZWNrRGF0YVR5cGVzKGl0ZW1UeXBlcywgaXRlbSwgaXQub3B0cy5zdHJpY3ROdW1iZXJzLCBkYXRhVHlwZV8xLkRhdGFUeXBlLldyb25nKTtcbiAgICAgICAgICAgIGNvbnN0IGluZGljZXMgPSBnZW4uY29uc3QoXCJpbmRpY2VzXCIsIGNvZGVnZW5fMS5fIGB7fWApO1xuICAgICAgICAgICAgZ2VuLmZvcihjb2RlZ2VuXzEuXyBgOyR7aX0tLTtgLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZ2VuLmxldChpdGVtLCBjb2RlZ2VuXzEuXyBgJHtkYXRhfVske2l9XWApO1xuICAgICAgICAgICAgICAgIGdlbi5pZih3cm9uZ1R5cGUsIGNvZGVnZW5fMS5fIGBjb250aW51ZWApO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtVHlwZXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGB0eXBlb2YgJHtpdGVtfSA9PSBcInN0cmluZ1wiYCwgY29kZWdlbl8xLl8gYCR7aXRlbX0gKz0gXCJfXCJgKTtcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmlmKGNvZGVnZW5fMS5fIGB0eXBlb2YgJHtpbmRpY2VzfVske2l0ZW19XSA9PSBcIm51bWJlclwiYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKGosIGNvZGVnZW5fMS5fIGAke2luZGljZXN9WyR7aXRlbX1dYCk7XG4gICAgICAgICAgICAgICAgICAgIGN4dC5lcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuYnJlYWsoKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY29kZShjb2RlZ2VuXzEuXyBgJHtpbmRpY2VzfVske2l0ZW19XSA9ICR7aX1gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BOMihpLCBqKSB7XG4gICAgICAgICAgICBjb25zdCBlcWwgPSB1dGlsXzEudXNlRnVuYyhnZW4sIGVxdWFsXzEuZGVmYXVsdCk7XG4gICAgICAgICAgICBjb25zdCBvdXRlciA9IGdlbi5uYW1lKFwib3V0ZXJcIik7XG4gICAgICAgICAgICBnZW4ubGFiZWwob3V0ZXIpLmZvcihjb2RlZ2VuXzEuXyBgOyR7aX0tLTtgLCAoKSA9PiBnZW4uZm9yKGNvZGVnZW5fMS5fIGAke2p9ID0gJHtpfTsgJHtqfS0tO2AsICgpID0+IGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtlcWx9KCR7ZGF0YX1bJHtpfV0sICR7ZGF0YX1bJHtqfV0pYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGN4dC5lcnJvcigpO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhayhvdXRlcik7XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmlxdWVJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXF1YWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL2VxdWFsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IGJlIGVxdWFsIHRvIGNvbnN0YW50XCIsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+IGNvZGVnZW5fMS5fIGB7YWxsb3dlZFZhbHVlOiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiY29uc3RcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYUNvZGUsIHNjaGVtYSB9ID0gY3h0O1xuICAgICAgICBpZiAoJGRhdGEgfHwgKHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICBjeHQuZmFpbCRkYXRhKGNvZGVnZW5fMS5fIGAhJHt1dGlsXzEudXNlRnVuYyhnZW4sIGVxdWFsXzEuZGVmYXVsdCl9KCR7ZGF0YX0sICR7c2NoZW1hQ29kZX0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjeHQuZmFpbChjb2RlZ2VuXzEuXyBgJHtzY2hlbWF9ICE9PSAke2RhdGF9YCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcXVhbF8xID0gcmVxdWlyZShcIi4uLy4uL3J1bnRpbWUvZXF1YWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiBcIm11c3QgYmUgZXF1YWwgdG8gb25lIG9mIHRoZSBhbGxvd2VkIHZhbHVlc1wiLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuXyBge2FsbG93ZWRWYWx1ZXM6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJlbnVtXCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoISRkYXRhICYmIHNjaGVtYS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbnVtIG11c3QgaGF2ZSBub24tZW1wdHkgYXJyYXlcIik7XG4gICAgICAgIGNvbnN0IHVzZUxvb3AgPSBzY2hlbWEubGVuZ3RoID49IGl0Lm9wdHMubG9vcEVudW07XG4gICAgICAgIGNvbnN0IGVxbCA9IHV0aWxfMS51c2VGdW5jKGdlbiwgZXF1YWxfMS5kZWZhdWx0KTtcbiAgICAgICAgbGV0IHZhbGlkO1xuICAgICAgICBpZiAodXNlTG9vcCB8fCAkZGF0YSkge1xuICAgICAgICAgICAgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIik7XG4gICAgICAgICAgICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgbG9vcEVudW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgICAgICBjb25zdCB2U2NoZW1hID0gZ2VuLmNvbnN0KFwidlNjaGVtYVwiLCBzY2hlbWFDb2RlKTtcbiAgICAgICAgICAgIHZhbGlkID0gY29kZWdlbl8xLm9yKC4uLnNjaGVtYS5tYXAoKF94LCBpKSA9PiBlcXVhbENvZGUodlNjaGVtYSwgaSkpKTtcbiAgICAgICAgfVxuICAgICAgICBjeHQucGFzcyh2YWxpZCk7XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BFbnVtKCkge1xuICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpO1xuICAgICAgICAgICAgZ2VuLmZvck9mKFwidlwiLCBzY2hlbWFDb2RlLCAodikgPT4gZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2VxbH0oJHtkYXRhfSwgJHt2fSlgLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKS5icmVhaygpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZXF1YWxDb2RlKHZTY2hlbWEsIGkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaCA9IHNjaGVtYVtpXTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygc2NoID09PSBcIm9iamVjdFwiICYmIHNjaCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gY29kZWdlbl8xLl8gYCR7ZXFsfSgke2RhdGF9LCAke3ZTY2hlbWF9WyR7aX1dKWBcbiAgICAgICAgICAgICAgICA6IGNvZGVnZW5fMS5fIGAke2RhdGF9ID09PSAke3NjaH1gO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnVtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgbGltaXROdW1iZXJfMSA9IHJlcXVpcmUoXCIuL2xpbWl0TnVtYmVyXCIpO1xuY29uc3QgbXVsdGlwbGVPZl8xID0gcmVxdWlyZShcIi4vbXVsdGlwbGVPZlwiKTtcbmNvbnN0IGxpbWl0TGVuZ3RoXzEgPSByZXF1aXJlKFwiLi9saW1pdExlbmd0aFwiKTtcbmNvbnN0IHBhdHRlcm5fMSA9IHJlcXVpcmUoXCIuL3BhdHRlcm5cIik7XG5jb25zdCBsaW1pdFByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL2xpbWl0UHJvcGVydGllc1wiKTtcbmNvbnN0IHJlcXVpcmVkXzEgPSByZXF1aXJlKFwiLi9yZXF1aXJlZFwiKTtcbmNvbnN0IGxpbWl0SXRlbXNfMSA9IHJlcXVpcmUoXCIuL2xpbWl0SXRlbXNcIik7XG5jb25zdCB1bmlxdWVJdGVtc18xID0gcmVxdWlyZShcIi4vdW5pcXVlSXRlbXNcIik7XG5jb25zdCBjb25zdF8xID0gcmVxdWlyZShcIi4vY29uc3RcIik7XG5jb25zdCBlbnVtXzEgPSByZXF1aXJlKFwiLi9lbnVtXCIpO1xuY29uc3QgdmFsaWRhdGlvbiA9IFtcbiAgICAvLyBudW1iZXJcbiAgICBsaW1pdE51bWJlcl8xLmRlZmF1bHQsXG4gICAgbXVsdGlwbGVPZl8xLmRlZmF1bHQsXG4gICAgLy8gc3RyaW5nXG4gICAgbGltaXRMZW5ndGhfMS5kZWZhdWx0LFxuICAgIHBhdHRlcm5fMS5kZWZhdWx0LFxuICAgIC8vIG9iamVjdFxuICAgIGxpbWl0UHJvcGVydGllc18xLmRlZmF1bHQsXG4gICAgcmVxdWlyZWRfMS5kZWZhdWx0LFxuICAgIC8vIGFycmF5XG4gICAgbGltaXRJdGVtc18xLmRlZmF1bHQsXG4gICAgdW5pcXVlSXRlbXNfMS5kZWZhdWx0LFxuICAgIC8vIGFueVxuICAgIHsga2V5d29yZDogXCJ0eXBlXCIsIHNjaGVtYVR5cGU6IFtcInN0cmluZ1wiLCBcImFycmF5XCJdIH0sXG4gICAgeyBrZXl3b3JkOiBcIm51bGxhYmxlXCIsIHNjaGVtYVR5cGU6IFwiYm9vbGVhblwiIH0sXG4gICAgY29uc3RfMS5kZWZhdWx0LFxuICAgIGVudW1fMS5kZWZhdWx0LFxuXTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZhbGlkYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBsZW4gfSB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBtdXN0IE5PVCBoYXZlIG1vcmUgdGhhbiAke2xlbn0gaXRlbXNgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IGxlbiB9IH0pID0+IGNvZGVnZW5fMS5fIGB7bGltaXQ6ICR7bGVufX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImFkZGl0aW9uYWxJdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJib29sZWFuXCIsIFwib2JqZWN0XCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IGl0ZW1zIH0gPSBwYXJlbnRTY2hlbWE7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgICAgIHV0aWxfMS5jaGVja1N0cmljdE1vZGUoaXQsICdcImFkZGl0aW9uYWxJdGVtc1wiIGlzIGlnbm9yZWQgd2hlbiBcIml0ZW1zXCIgaXMgbm90IGFuIGFycmF5IG9mIHNjaGVtYXMnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyhjeHQsIGl0ZW1zKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zKGN4dCwgaXRlbXMpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBkYXRhLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgIGl0Lml0ZW1zID0gdHJ1ZTtcbiAgICBjb25zdCBsZW4gPSBnZW4uY29uc3QoXCJsZW5cIiwgY29kZWdlbl8xLl8gYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7IGxlbjogaXRlbXMubGVuZ3RoIH0pO1xuICAgICAgICBjeHQucGFzcyhjb2RlZ2VuXzEuXyBgJHtsZW59IDw9ICR7aXRlbXMubGVuZ3RofWApO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgIXV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSkge1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi52YXIoXCJ2YWxpZFwiLCBjb2RlZ2VuXzEuXyBgJHtsZW59IDw9ICR7aXRlbXMubGVuZ3RofWApOyAvLyBUT0RPIHZhclxuICAgICAgICBnZW4uaWYoY29kZWdlbl8xLm5vdCh2YWxpZCksICgpID0+IHZhbGlkYXRlSXRlbXModmFsaWQpKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyh2YWxpZCkge1xuICAgICAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIGl0ZW1zLmxlbmd0aCwgbGVuLCAoaSkgPT4ge1xuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQsIGRhdGFQcm9wOiBpLCBkYXRhUHJvcFR5cGU6IHV0aWxfMS5UeXBlLk51bSB9LCB2YWxpZCk7XG4gICAgICAgICAgICBpZiAoIWl0LmFsbEVycm9ycylcbiAgICAgICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLm5vdCh2YWxpZCksICgpID0+IGdlbi5icmVhaygpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyA9IHZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkaXRpb25hbEl0ZW1zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZVR1cGxlID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIml0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImFycmF5XCIsIFwiYm9vbGVhblwiXSxcbiAgICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IHNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZVR1cGxlKGN4dCwgXCJhZGRpdGlvbmFsSXRlbXNcIiwgc2NoZW1hKTtcbiAgICAgICAgaXQuaXRlbXMgPSB0cnVlO1xuICAgICAgICBpZiAodXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjeHQub2soY29kZV8xLnZhbGlkYXRlQXJyYXkoY3h0KSk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZVR1cGxlKGN4dCwgZXh0cmFJdGVtcywgc2NoQXJyID0gY3h0LnNjaGVtYSkge1xuICAgIGNvbnN0IHsgZ2VuLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgY2hlY2tTdHJpY3RUdXBsZShwYXJlbnRTY2hlbWEpO1xuICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIHNjaEFyci5sZW5ndGggJiYgaXQuaXRlbXMgIT09IHRydWUpIHtcbiAgICAgICAgaXQuaXRlbXMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBzY2hBcnIubGVuZ3RoLCBpdC5pdGVtcyk7XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICBjb25zdCBsZW4gPSBnZW4uY29uc3QoXCJsZW5cIiwgY29kZWdlbl8xLl8gYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgc2NoQXJyLmZvckVhY2goKHNjaCwgaSkgPT4ge1xuICAgICAgICBpZiAodXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2gpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7bGVufSA+ICR7aX1gLCAoKSA9PiBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgICAgZGF0YVByb3A6IGksXG4gICAgICAgIH0sIHZhbGlkKSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gY2hlY2tTdHJpY3RUdXBsZShzY2gpIHtcbiAgICAgICAgY29uc3QgeyBvcHRzLCBlcnJTY2hlbWFQYXRoIH0gPSBpdDtcbiAgICAgICAgY29uc3QgbCA9IHNjaEFyci5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGZ1bGxUdXBsZSA9IGwgPT09IHNjaC5taW5JdGVtcyAmJiAobCA9PT0gc2NoLm1heEl0ZW1zIHx8IHNjaFtleHRyYUl0ZW1zXSA9PT0gZmFsc2UpO1xuICAgICAgICBpZiAob3B0cy5zdHJpY3RUdXBsZXMgJiYgIWZ1bGxUdXBsZSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYFwiJHtrZXl3b3JkfVwiIGlzICR7bH0tdHVwbGUsIGJ1dCBtaW5JdGVtcyBvciBtYXhJdGVtcy8ke2V4dHJhSXRlbXN9IGFyZSBub3Qgc3BlY2lmaWVkIG9yIGRpZmZlcmVudCBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiYDtcbiAgICAgICAgICAgIHV0aWxfMS5jaGVja1N0cmljdE1vZGUoaXQsIG1zZywgb3B0cy5zdHJpY3RUdXBsZXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVR1cGxlID0gdmFsaWRhdGVUdXBsZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWl0ZW1zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgaXRlbXNfMSA9IHJlcXVpcmUoXCIuL2l0ZW1zXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicHJlZml4SXRlbXNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogW1wiYXJyYXlcIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgY29kZTogKGN4dCkgPT4gaXRlbXNfMS52YWxpZGF0ZVR1cGxlKGN4dCwgXCJpdGVtc1wiKSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVmaXhJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBhZGRpdGlvbmFsSXRlbXNfMSA9IHJlcXVpcmUoXCIuL2FkZGl0aW9uYWxJdGVtc1wiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBsZW4gfSB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBtdXN0IE5PVCBoYXZlIG1vcmUgdGhhbiAke2xlbn0gaXRlbXNgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IGxlbiB9IH0pID0+IGNvZGVnZW5fMS5fIGB7bGltaXQ6ICR7bGVufX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIml0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBwcmVmaXhJdGVtcyB9ID0gcGFyZW50U2NoZW1hO1xuICAgICAgICBpdC5pdGVtcyA9IHRydWU7XG4gICAgICAgIGlmICh1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChwcmVmaXhJdGVtcylcbiAgICAgICAgICAgIGFkZGl0aW9uYWxJdGVtc18xLnZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zKGN4dCwgcHJlZml4SXRlbXMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjeHQub2soY29kZV8xLnZhbGlkYXRlQXJyYXkoY3h0KSk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pdGVtczIwMjAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBtaW4sIG1heCB9IH0pID0+IG1heCA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gY29kZWdlbl8xLnN0ciBgbXVzdCBjb250YWluIGF0IGxlYXN0ICR7bWlufSB2YWxpZCBpdGVtKHMpYFxuICAgICAgICA6IGNvZGVnZW5fMS5zdHIgYG11c3QgY29udGFpbiBhdCBsZWFzdCAke21pbn0gYW5kIG5vIG1vcmUgdGhhbiAke21heH0gdmFsaWQgaXRlbShzKWAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgbWluLCBtYXggfSB9KSA9PiBtYXggPT09IHVuZGVmaW5lZCA/IGNvZGVnZW5fMS5fIGB7bWluQ29udGFpbnM6ICR7bWlufX1gIDogY29kZWdlbl8xLl8gYHttaW5Db250YWluczogJHttaW59LCBtYXhDb250YWluczogJHttYXh9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiY29udGFpbnNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGxldCBtaW47XG4gICAgICAgIGxldCBtYXg7XG4gICAgICAgIGNvbnN0IHsgbWluQ29udGFpbnMsIG1heENvbnRhaW5zIH0gPSBwYXJlbnRTY2hlbWE7XG4gICAgICAgIGlmIChpdC5vcHRzLm5leHQpIHtcbiAgICAgICAgICAgIG1pbiA9IG1pbkNvbnRhaW5zID09PSB1bmRlZmluZWQgPyAxIDogbWluQ29udGFpbnM7XG4gICAgICAgICAgICBtYXggPSBtYXhDb250YWlucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1pbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsIGNvZGVnZW5fMS5fIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHsgbWluLCBtYXggfSk7XG4gICAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCAmJiBtaW4gPT09IDApIHtcbiAgICAgICAgICAgIHV0aWxfMS5jaGVja1N0cmljdE1vZGUoaXQsIGBcIm1pbkNvbnRhaW5zXCIgPT0gMCB3aXRob3V0IFwibWF4Q29udGFpbnNcIjogXCJjb250YWluc1wiIGtleXdvcmQgaWdub3JlZGApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXggIT09IHVuZGVmaW5lZCAmJiBtaW4gPiBtYXgpIHtcbiAgICAgICAgICAgIHV0aWxfMS5jaGVja1N0cmljdE1vZGUoaXQsIGBcIm1pbkNvbnRhaW5zXCIgPiBcIm1heENvbnRhaW5zXCIgaXMgYWx3YXlzIGludmFsaWRgKTtcbiAgICAgICAgICAgIGN4dC5mYWlsKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSkge1xuICAgICAgICAgICAgbGV0IGNvbmQgPSBjb2RlZ2VuXzEuXyBgJHtsZW59ID49ICR7bWlufWA7XG4gICAgICAgICAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29uZCA9IGNvZGVnZW5fMS5fIGAke2NvbmR9ICYmICR7bGVufSA8PSAke21heH1gO1xuICAgICAgICAgICAgY3h0LnBhc3MoY29uZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaXQuaXRlbXMgPSB0cnVlO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCAmJiBtaW4gPT09IDEpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlSXRlbXModmFsaWQsICgpID0+IGdlbi5pZih2YWxpZCwgKCkgPT4gZ2VuLmJyZWFrKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdlbi5sZXQodmFsaWQsIGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIik7XG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IGdlbi5sZXQoXCJjb3VudFwiLCAwKTtcbiAgICAgICAgICAgIHZhbGlkYXRlSXRlbXMoc2NoVmFsaWQsICgpID0+IGdlbi5pZihzY2hWYWxpZCwgKCkgPT4gY2hlY2tMaW1pdHMoY291bnQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3h0LnJlc3VsdCh2YWxpZCwgKCkgPT4gY3h0LnJlc2V0KCkpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUl0ZW1zKF92YWxpZCwgYmxvY2spIHtcbiAgICAgICAgICAgIGdlbi5mb3JSYW5nZShcImlcIiwgMCwgbGVuLCAoaSkgPT4ge1xuICAgICAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcImNvbnRhaW5zXCIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBpLFxuICAgICAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IHV0aWxfMS5UeXBlLk51bSxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LCBfdmFsaWQpO1xuICAgICAgICAgICAgICAgIGJsb2NrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGVja0xpbWl0cyhjb3VudCkge1xuICAgICAgICAgICAgZ2VuLmNvZGUoY29kZWdlbl8xLl8gYCR7Y291bnR9KytgKTtcbiAgICAgICAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtjb3VudH0gPj0gJHttaW59YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkuYnJlYWsoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7Y291bnR9ID4gJHttYXh9YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmJyZWFrKCkpO1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2NvdW50fSA+PSAke21pbn1gLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRhaW5zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZVNjaGVtYURlcHMgPSBleHBvcnRzLnZhbGlkYXRlUHJvcGVydHlEZXBzID0gZXhwb3J0cy5lcnJvciA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5leHBvcnRzLmVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBwcm9wZXJ0eSwgZGVwc0NvdW50LCBkZXBzIH0gfSkgPT4ge1xuICAgICAgICBjb25zdCBwcm9wZXJ0eV9pZXMgPSBkZXBzQ291bnQgPT09IDEgPyBcInByb3BlcnR5XCIgOiBcInByb3BlcnRpZXNcIjtcbiAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5zdHIgYG11c3QgaGF2ZSAke3Byb3BlcnR5X2llc30gJHtkZXBzfSB3aGVuIHByb3BlcnR5ICR7cHJvcGVydHl9IGlzIHByZXNlbnRgO1xuICAgIH0sXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgcHJvcGVydHksIGRlcHNDb3VudCwgZGVwcywgbWlzc2luZ1Byb3BlcnR5IH0gfSkgPT4gY29kZWdlbl8xLl8gYHtwcm9wZXJ0eTogJHtwcm9wZXJ0eX0sXG4gICAgbWlzc2luZ1Byb3BlcnR5OiAke21pc3NpbmdQcm9wZXJ0eX0sXG4gICAgZGVwc0NvdW50OiAke2RlcHNDb3VudH0sXG4gICAgZGVwczogJHtkZXBzfX1gLCAvLyBUT0RPIGNoYW5nZSB0byByZWZlcmVuY2Vcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJkZXBlbmRlbmNpZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gICAgZXJyb3I6IGV4cG9ydHMuZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgW3Byb3BEZXBzLCBzY2hEZXBzXSA9IHNwbGl0RGVwZW5kZW5jaWVzKGN4dCk7XG4gICAgICAgIHZhbGlkYXRlUHJvcGVydHlEZXBzKGN4dCwgcHJvcERlcHMpO1xuICAgICAgICB2YWxpZGF0ZVNjaGVtYURlcHMoY3h0LCBzY2hEZXBzKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHNwbGl0RGVwZW5kZW5jaWVzKHsgc2NoZW1hIH0pIHtcbiAgICBjb25zdCBwcm9wZXJ0eURlcHMgPSB7fTtcbiAgICBjb25zdCBzY2hlbWFEZXBzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGlmIChrZXkgPT09IFwiX19wcm90b19fXCIpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgZGVwcyA9IEFycmF5LmlzQXJyYXkoc2NoZW1hW2tleV0pID8gcHJvcGVydHlEZXBzIDogc2NoZW1hRGVwcztcbiAgICAgICAgZGVwc1trZXldID0gc2NoZW1hW2tleV07XG4gICAgfVxuICAgIHJldHVybiBbcHJvcGVydHlEZXBzLCBzY2hlbWFEZXBzXTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHlEZXBzKGN4dCwgcHJvcGVydHlEZXBzID0gY3h0LnNjaGVtYSkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgIGlmIChPYmplY3Qua2V5cyhwcm9wZXJ0eURlcHMpLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG1pc3NpbmcgPSBnZW4ubGV0KFwibWlzc2luZ1wiKTtcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcGVydHlEZXBzKSB7XG4gICAgICAgIGNvbnN0IGRlcHMgPSBwcm9wZXJ0eURlcHNbcHJvcF07XG4gICAgICAgIGlmIChkZXBzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBoYXNQcm9wZXJ0eSA9IGNvZGVfMS5wcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3AsIGl0Lm9wdHMub3duUHJvcGVydGllcyk7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoe1xuICAgICAgICAgICAgcHJvcGVydHk6IHByb3AsXG4gICAgICAgICAgICBkZXBzQ291bnQ6IGRlcHMubGVuZ3RoLFxuICAgICAgICAgICAgZGVwczogZGVwcy5qb2luKFwiLCBcIiksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgICAgICBnZW4uaWYoaGFzUHJvcGVydHksICgpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlcFByb3Agb2YgZGVwcykge1xuICAgICAgICAgICAgICAgICAgICBjb2RlXzEuY2hlY2tSZXBvcnRNaXNzaW5nUHJvcChjeHQsIGRlcFByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2hhc1Byb3BlcnR5fSAmJiAoJHtjb2RlXzEuY2hlY2tNaXNzaW5nUHJvcChjeHQsIGRlcHMsIG1pc3NpbmcpfSlgKTtcbiAgICAgICAgICAgIGNvZGVfMS5yZXBvcnRNaXNzaW5nUHJvcChjeHQsIG1pc3NpbmcpO1xuICAgICAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVQcm9wZXJ0eURlcHMgPSB2YWxpZGF0ZVByb3BlcnR5RGVwcztcbmZ1bmN0aW9uIHZhbGlkYXRlU2NoZW1hRGVwcyhjeHQsIHNjaGVtYURlcHMgPSBjeHQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBzY2hlbWFEZXBzKSB7XG4gICAgICAgIGlmICh1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYURlcHNbcHJvcF0pKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGdlbi5pZihjb2RlXzEucHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHsga2V5d29yZCwgc2NoZW1hUHJvcDogcHJvcCB9LCB2YWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHZhbGlkKTtcbiAgICAgICAgfSwgKCkgPT4gZ2VuLnZhcih2YWxpZCwgdHJ1ZSkgLy8gVE9ETyB2YXJcbiAgICAgICAgKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlU2NoZW1hRGVwcyA9IHZhbGlkYXRlU2NoZW1hRGVwcztcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlcGVuZGVuY2llcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJwcm9wZXJ0eSBuYW1lIG11c3QgYmUgdmFsaWRcIixcbiAgICBwYXJhbXM6ICh7IHBhcmFtcyB9KSA9PiBjb2RlZ2VuXzEuXyBge3Byb3BlcnR5TmFtZTogJHtwYXJhbXMucHJvcGVydHlOYW1lfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInByb3BlcnR5TmFtZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBnZW4uZm9ySW4oXCJrZXlcIiwgZGF0YSwgKGtleSkgPT4ge1xuICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IHByb3BlcnR5TmFtZToga2V5IH0pO1xuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJwcm9wZXJ0eU5hbWVzXCIsXG4gICAgICAgICAgICAgICAgZGF0YToga2V5LFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlczogW1wic3RyaW5nXCJdLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZToga2V5LFxuICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLm5vdCh2YWxpZCksICgpID0+IHtcbiAgICAgICAgICAgICAgICBjeHQuZXJyb3IodHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpdC5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5icmVhaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcGVydHlOYW1lcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9uYW1lc1wiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiBcIm11c3QgTk9UIGhhdmUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXCIsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXMgfSkgPT4gY29kZWdlbl8xLl8gYHthZGRpdGlvbmFsUHJvcGVydHk6ICR7cGFyYW1zLmFkZGl0aW9uYWxQcm9wZXJ0eX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLFxuICAgIHR5cGU6IFtcIm9iamVjdFwiXSxcbiAgICBzY2hlbWFUeXBlOiBbXCJib29sZWFuXCIsIFwib2JqZWN0XCJdLFxuICAgIGFsbG93VW5kZWZpbmVkOiB0cnVlLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgZGF0YSwgZXJyc0NvdW50LCBpdCB9ID0gY3h0O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFlcnJzQ291bnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgIGNvbnN0IHsgYWxsRXJyb3JzLCBvcHRzIH0gPSBpdDtcbiAgICAgICAgaXQucHJvcHMgPSB0cnVlO1xuICAgICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsICE9PSBcImFsbFwiICYmIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgcHJvcHMgPSBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcyhwYXJlbnRTY2hlbWEucHJvcGVydGllcyk7XG4gICAgICAgIGNvbnN0IHBhdFByb3BzID0gY29kZV8xLmFsbFNjaGVtYVByb3BlcnRpZXMocGFyZW50U2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKTtcbiAgICAgICAgY2hlY2tBZGRpdGlvbmFsUHJvcGVydGllcygpO1xuICAgICAgICBjeHQub2soY29kZWdlbl8xLl8gYCR7ZXJyc0NvdW50fSA9PT0gJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfWApO1xuICAgICAgICBmdW5jdGlvbiBjaGVja0FkZGl0aW9uYWxQcm9wZXJ0aWVzKCkge1xuICAgICAgICAgICAgZ2VuLmZvckluKFwia2V5XCIsIGRhdGEsIChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BzLmxlbmd0aCAmJiAhcGF0UHJvcHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydHlDb2RlKGtleSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoaXNBZGRpdGlvbmFsKGtleSksICgpID0+IGFkZGl0aW9uYWxQcm9wZXJ0eUNvZGUoa2V5KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0FkZGl0aW9uYWwoa2V5KSB7XG4gICAgICAgICAgICBsZXQgZGVmaW5lZFByb3A7XG4gICAgICAgICAgICBpZiAocHJvcHMubGVuZ3RoID4gOCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gbWF5YmUgYW4gb3B0aW9uIGluc3RlYWQgb2YgaGFyZC1jb2RlZCA4P1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzU2NoZW1hID0gdXRpbF8xLnNjaGVtYVJlZk9yVmFsKGl0LCBwYXJlbnRTY2hlbWEucHJvcGVydGllcywgXCJwcm9wZXJ0aWVzXCIpO1xuICAgICAgICAgICAgICAgIGRlZmluZWRQcm9wID0gY29kZV8xLmlzT3duUHJvcGVydHkoZ2VuLCBwcm9wc1NjaGVtYSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlZmluZWRQcm9wID0gY29kZWdlbl8xLm9yKC4uLnByb3BzLm1hcCgocCkgPT4gY29kZWdlbl8xLl8gYCR7a2V5fSA9PT0gJHtwfWApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZmluZWRQcm9wID0gY29kZWdlbl8xLm5pbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRQcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9IGNvZGVnZW5fMS5vcihkZWZpbmVkUHJvcCwgLi4ucGF0UHJvcHMubWFwKChwKSA9PiBjb2RlZ2VuXzEuXyBgJHtjb2RlXzEudXNlUGF0dGVybihjeHQsIHApfS50ZXN0KCR7a2V5fSlgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLm5vdChkZWZpbmVkUHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVsZXRlQWRkaXRpb25hbChrZXkpIHtcbiAgICAgICAgICAgIGdlbi5jb2RlKGNvZGVnZW5fMS5fIGBkZWxldGUgJHtkYXRhfVske2tleX1dYCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkaXRpb25hbFByb3BlcnR5Q29kZShrZXkpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLnJlbW92ZUFkZGl0aW9uYWwgPT09IFwiYWxsXCIgfHwgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCAmJiBzY2hlbWEgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZUFkZGl0aW9uYWwoa2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBhZGRpdGlvbmFsUHJvcGVydHk6IGtleSB9KTtcbiAgICAgICAgICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmJyZWFrKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnJlbW92ZUFkZGl0aW9uYWwgPT09IFwiZmFpbGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5QWRkaXRpb25hbFNjaGVtYShrZXksIHZhbGlkLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEubm90KHZhbGlkKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3h0LnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVBZGRpdGlvbmFsKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlBZGRpdGlvbmFsU2NoZW1hKGtleSwgdmFsaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEubm90KHZhbGlkKSwgKCkgPT4gZ2VuLmJyZWFrKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcHBseUFkZGl0aW9uYWxTY2hlbWEoa2V5LCB2YWxpZCwgZXJyb3JzKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJzY2hlbWEgPSB7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBrZXksXG4gICAgICAgICAgICAgICAgZGF0YVByb3BUeXBlOiB1dGlsXzEuVHlwZS5TdHIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGVycm9ycyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHN1YnNjaGVtYSwge1xuICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhbGxFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYShzdWJzY2hlbWEsIHZhbGlkKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkaXRpb25hbFByb3BlcnRpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB2YWxpZGF0ZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBhZGRpdGlvbmFsUHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vYWRkaXRpb25hbFByb3BlcnRpZXNcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJwcm9wZXJ0aWVzXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKGl0Lm9wdHMucmVtb3ZlQWRkaXRpb25hbCA9PT0gXCJhbGxcIiAmJiBwYXJlbnRTY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXNfMS5kZWZhdWx0LmNvZGUobmV3IHZhbGlkYXRlXzEuS2V5d29yZEN4dChpdCwgYWRkaXRpb25hbFByb3BlcnRpZXNfMS5kZWZhdWx0LCBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbGxQcm9wcyA9IGNvZGVfMS5hbGxTY2hlbWFQcm9wZXJ0aWVzKHNjaGVtYSk7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBhbGxQcm9wcykge1xuICAgICAgICAgICAgaXQuZGVmaW5lZFByb3BlcnRpZXMuYWRkKHByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIGFsbFByb3BzLmxlbmd0aCAmJiBpdC5wcm9wcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgaXQucHJvcHMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCB1dGlsXzEudG9IYXNoKGFsbFByb3BzKSwgaXQucHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBhbGxQcm9wcy5maWx0ZXIoKHApID0+ICF1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYVtwXSkpO1xuICAgICAgICBpZiAocHJvcGVydGllcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChoYXNEZWZhdWx0KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgYXBwbHlQcm9wZXJ0eVNjaGVtYShwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlXzEucHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpKTtcbiAgICAgICAgICAgICAgICBhcHBseVByb3BlcnR5U2NoZW1hKHByb3ApO1xuICAgICAgICAgICAgICAgIGlmICghaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICBnZW4uZWxzZSgpLnZhcih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZ2VuLmVuZElmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjeHQuaXQuZGVmaW5lZFByb3BlcnRpZXMuYWRkKHByb3ApO1xuICAgICAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYXNEZWZhdWx0KHByb3ApIHtcbiAgICAgICAgICAgIHJldHVybiBpdC5vcHRzLnVzZURlZmF1bHRzICYmICFpdC5jb21wb3NpdGVSdWxlICYmIHNjaGVtYVtwcm9wXS5kZWZhdWx0ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXBwbHlQcm9wZXJ0eVNjaGVtYShwcm9wKSB7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcInByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICBzY2hlbWFQcm9wOiBwcm9wLFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBwcm9wLFxuICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wZXJ0aWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IHV0aWxfMiA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJwYXR0ZXJuUHJvcGVydGllc1wiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBkYXRhLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgb3B0cyB9ID0gaXQ7XG4gICAgICAgIGNvbnN0IHBhdHRlcm5zID0gY29kZV8xLmFsbFNjaGVtYVByb3BlcnRpZXMoc2NoZW1hKTtcbiAgICAgICAgY29uc3QgYWx3YXlzVmFsaWRQYXR0ZXJucyA9IHBhdHRlcm5zLmZpbHRlcigocCkgPT4gdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWFbcF0pKTtcbiAgICAgICAgaWYgKHBhdHRlcm5zLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgKGFsd2F5c1ZhbGlkUGF0dGVybnMubGVuZ3RoID09PSBwYXR0ZXJucy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAoIWl0Lm9wdHMudW5ldmFsdWF0ZWQgfHwgaXQucHJvcHMgPT09IHRydWUpKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoZWNrUHJvcGVydGllcyA9IG9wdHMuc3RyaWN0U2NoZW1hICYmICFvcHRzLmFsbG93TWF0Y2hpbmdQcm9wZXJ0aWVzICYmIHBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGlmIChpdC5wcm9wcyAhPT0gdHJ1ZSAmJiAhKGl0LnByb3BzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpKSB7XG4gICAgICAgICAgICBpdC5wcm9wcyA9IHV0aWxfMi5ldmFsdWF0ZWRQcm9wc1RvTmFtZShnZW4sIGl0LnByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSBpdDtcbiAgICAgICAgdmFsaWRhdGVQYXR0ZXJuUHJvcGVydGllcygpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZVBhdHRlcm5Qcm9wZXJ0aWVzKCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXQgb2YgcGF0dGVybnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tQcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgICAgICBjaGVja01hdGNoaW5nUHJvcGVydGllcyhwYXQpO1xuICAgICAgICAgICAgICAgIGlmIChpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHBhdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZW4udmFyKHZhbGlkLCB0cnVlKTsgLy8gVE9ETyB2YXJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHBhdCk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZih2YWxpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTWF0Y2hpbmdQcm9wZXJ0aWVzKHBhdCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIGNoZWNrUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGlmIChuZXcgUmVnRXhwKHBhdCkudGVzdChwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCBgcHJvcGVydHkgJHtwcm9wfSBtYXRjaGVzIHBhdHRlcm4gJHtwYXR9ICh1c2UgYWxsb3dNYXRjaGluZ1Byb3BlcnRpZXMpYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpIHtcbiAgICAgICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2NvZGVfMS51c2VQYXR0ZXJuKGN4dCwgcGF0KX0udGVzdCgke2tleX0pYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbHdheXNWYWxpZCA9IGFsd2F5c1ZhbGlkUGF0dGVybnMuaW5jbHVkZXMocGF0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbHdheXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5d29yZDogXCJwYXR0ZXJuUHJvcGVydGllc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYVByb3A6IHBhdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJvcDoga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogdXRpbF8yLlR5cGUuU3RyLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIHByb3BzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke3Byb3BzfVske2tleX1dYCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWFsd2F5c1ZhbGlkICYmICFpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbiBzaG9ydC1jaXJjdWl0IGlmIGB1bmV2YWx1YXRlZFByb3BlcnRpZXNgIGlzIG5vdCBzdXBwb3J0ZWQgKG9wdHMubmV4dCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBpZiBhbGwgcHJvcGVydGllcyB3ZXJlIGV2YWx1YXRlZCAocHJvcHMgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLm5vdCh2YWxpZCksICgpID0+IGdlbi5icmVhaygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdHRlcm5Qcm9wZXJ0aWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIm5vdFwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSkge1xuICAgICAgICAgICAgY3h0LmZhaWwoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAga2V5d29yZDogXCJub3RcIixcbiAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICBjcmVhdGVFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgYWxsRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICBjeHQuZmFpbFJlc3VsdCh2YWxpZCwgKCkgPT4gY3h0LnJlc2V0KCksICgpID0+IGN4dC5lcnJvcigpKTtcbiAgICB9LFxuICAgIGVycm9yOiB7IG1lc3NhZ2U6IFwibXVzdCBOT1QgYmUgdmFsaWRcIiB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYW55T2ZcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgY29kZTogY29kZV8xLnZhbGlkYXRlVW5pb24sXG4gICAgZXJyb3I6IHsgbWVzc2FnZTogXCJtdXN0IG1hdGNoIGEgc2NoZW1hIGluIGFueU9mXCIgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbnlPZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IG1hdGNoIGV4YWN0bHkgb25lIHNjaGVtYSBpbiBvbmVPZlwiLFxuICAgIHBhcmFtczogKHsgcGFyYW1zIH0pID0+IGNvZGVnZW5fMS5fIGB7cGFzc2luZ1NjaGVtYXM6ICR7cGFyYW1zLnBhc3Npbmd9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwib25lT2ZcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgIGlmIChpdC5vcHRzLmRpc2NyaW1pbmF0b3IgJiYgcGFyZW50U2NoZW1hLmRpc2NyaW1pbmF0b3IpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHNjaEFyciA9IHNjaGVtYTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgZmFsc2UpO1xuICAgICAgICBjb25zdCBwYXNzaW5nID0gZ2VuLmxldChcInBhc3NpbmdcIiwgbnVsbCk7XG4gICAgICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIik7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBwYXNzaW5nIH0pO1xuICAgICAgICAvLyBUT0RPIHBvc3NpYmx5IGZhaWwgc3RyYWlnaHQgYXdheSAod2l0aCB3YXJuaW5nIG9yIGV4Y2VwdGlvbikgaWYgdGhlcmUgYXJlIHR3byBlbXB0eSBhbHdheXMgdmFsaWQgc2NoZW1hc1xuICAgICAgICBnZW4uYmxvY2sodmFsaWRhdGVPbmVPZik7XG4gICAgICAgIGN4dC5yZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZU9uZU9mKCkge1xuICAgICAgICAgICAgc2NoQXJyLmZvckVhY2goKHNjaCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzY2hDeHQ7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoKSkge1xuICAgICAgICAgICAgICAgICAgICBnZW4udmFyKHNjaFZhbGlkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5d29yZDogXCJvbmVPZlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hUHJvcDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0sIHNjaFZhbGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAgICAgLmlmKGNvZGVnZW5fMS5fIGAke3NjaFZhbGlkfSAmJiAke3ZhbGlkfWApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXNzaWduKHZhbGlkLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hc3NpZ24ocGFzc2luZywgY29kZWdlbl8xLl8gYFske3Bhc3Npbmd9LCAke2l9XWApXG4gICAgICAgICAgICAgICAgICAgICAgICAuZWxzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZW4uaWYoc2NoVmFsaWQsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24ocGFzc2luZywgaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hDeHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0LCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b25lT2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYWxsT2ZcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIHNjaGVtYS5mb3JFYWNoKChzY2gsIGkpID0+IHtcbiAgICAgICAgICAgIGlmICh1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQ6IFwiYWxsT2ZcIiwgc2NoZW1hUHJvcDogaSB9LCB2YWxpZCk7XG4gICAgICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWxsT2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtcyB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBtdXN0IG1hdGNoIFwiJHtwYXJhbXMuaWZDbGF1c2V9XCIgc2NoZW1hYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtcyB9KSA9PiBjb2RlZ2VuXzEuXyBge2ZhaWxpbmdLZXl3b3JkOiAke3BhcmFtcy5pZkNsYXVzZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpZlwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKHBhcmVudFNjaGVtYS50aGVuID09PSB1bmRlZmluZWQgJiYgcGFyZW50U2NoZW1hLmVsc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZShpdCwgJ1wiaWZcIiB3aXRob3V0IFwidGhlblwiIGFuZCBcImVsc2VcIiBpcyBpZ25vcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzVGhlbiA9IGhhc1NjaGVtYShpdCwgXCJ0aGVuXCIpO1xuICAgICAgICBjb25zdCBoYXNFbHNlID0gaGFzU2NoZW1hKGl0LCBcImVsc2VcIik7XG4gICAgICAgIGlmICghaGFzVGhlbiAmJiAhaGFzRWxzZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIik7XG4gICAgICAgIHZhbGlkYXRlSWYoKTtcbiAgICAgICAgY3h0LnJlc2V0KCk7XG4gICAgICAgIGlmIChoYXNUaGVuICYmIGhhc0Vsc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGlmQ2xhdXNlID0gZ2VuLmxldChcImlmQ2xhdXNlXCIpO1xuICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IGlmQ2xhdXNlIH0pO1xuICAgICAgICAgICAgZ2VuLmlmKHNjaFZhbGlkLCB2YWxpZGF0ZUNsYXVzZShcInRoZW5cIiwgaWZDbGF1c2UpLCB2YWxpZGF0ZUNsYXVzZShcImVsc2VcIiwgaWZDbGF1c2UpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYXNUaGVuKSB7XG4gICAgICAgICAgICBnZW4uaWYoc2NoVmFsaWQsIHZhbGlkYXRlQ2xhdXNlKFwidGhlblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLm5vdChzY2hWYWxpZCksIHZhbGlkYXRlQ2xhdXNlKFwiZWxzZVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3h0LnBhc3ModmFsaWQsICgpID0+IGN4dC5lcnJvcih0cnVlKSk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlSWYoKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcImlmXCIsXG4gICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFsbEVycm9yczogZmFsc2UsXG4gICAgICAgICAgICB9LCBzY2hWYWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUNsYXVzZShrZXl3b3JkLCBpZkNsYXVzZSkge1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHsga2V5d29yZCB9LCBzY2hWYWxpZCk7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgICAgIGN4dC5tZXJnZVZhbGlkRXZhbHVhdGVkKHNjaEN4dCwgdmFsaWQpO1xuICAgICAgICAgICAgICAgIGlmIChpZkNsYXVzZSlcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihpZkNsYXVzZSwgY29kZWdlbl8xLl8gYCR7a2V5d29yZH1gKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBpZkNsYXVzZToga2V5d29yZCB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmZ1bmN0aW9uIGhhc1NjaGVtYShpdCwga2V5d29yZCkge1xuICAgIGNvbnN0IHNjaGVtYSA9IGl0LnNjaGVtYVtrZXl3b3JkXTtcbiAgICByZXR1cm4gc2NoZW1hICE9PSB1bmRlZmluZWQgJiYgIXV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlmLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBbXCJ0aGVuXCIsIFwiZWxzZVwiXSxcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIGNvZGUoeyBrZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGl0IH0pIHtcbiAgICAgICAgaWYgKHBhcmVudFNjaGVtYS5pZiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZShpdCwgYFwiJHtrZXl3b3JkfVwiIHdpdGhvdXQgXCJpZlwiIGlzIGlnbm9yZWRgKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRoZW5FbHNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYWRkaXRpb25hbEl0ZW1zXzEgPSByZXF1aXJlKFwiLi9hZGRpdGlvbmFsSXRlbXNcIik7XG5jb25zdCBwcmVmaXhJdGVtc18xID0gcmVxdWlyZShcIi4vcHJlZml4SXRlbXNcIik7XG5jb25zdCBpdGVtc18xID0gcmVxdWlyZShcIi4vaXRlbXNcIik7XG5jb25zdCBpdGVtczIwMjBfMSA9IHJlcXVpcmUoXCIuL2l0ZW1zMjAyMFwiKTtcbmNvbnN0IGNvbnRhaW5zXzEgPSByZXF1aXJlKFwiLi9jb250YWluc1wiKTtcbmNvbnN0IGRlcGVuZGVuY2llc18xID0gcmVxdWlyZShcIi4vZGVwZW5kZW5jaWVzXCIpO1xuY29uc3QgcHJvcGVydHlOYW1lc18xID0gcmVxdWlyZShcIi4vcHJvcGVydHlOYW1lc1wiKTtcbmNvbnN0IGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9hZGRpdGlvbmFsUHJvcGVydGllc1wiKTtcbmNvbnN0IHByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnRpZXNcIik7XG5jb25zdCBwYXR0ZXJuUHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vcGF0dGVyblByb3BlcnRpZXNcIik7XG5jb25zdCBub3RfMSA9IHJlcXVpcmUoXCIuL25vdFwiKTtcbmNvbnN0IGFueU9mXzEgPSByZXF1aXJlKFwiLi9hbnlPZlwiKTtcbmNvbnN0IG9uZU9mXzEgPSByZXF1aXJlKFwiLi9vbmVPZlwiKTtcbmNvbnN0IGFsbE9mXzEgPSByZXF1aXJlKFwiLi9hbGxPZlwiKTtcbmNvbnN0IGlmXzEgPSByZXF1aXJlKFwiLi9pZlwiKTtcbmNvbnN0IHRoZW5FbHNlXzEgPSByZXF1aXJlKFwiLi90aGVuRWxzZVwiKTtcbmZ1bmN0aW9uIGdldEFwcGxpY2F0b3IoZHJhZnQyMDIwID0gZmFsc2UpIHtcbiAgICBjb25zdCBhcHBsaWNhdG9yID0gW1xuICAgICAgICAvLyBhbnlcbiAgICAgICAgbm90XzEuZGVmYXVsdCxcbiAgICAgICAgYW55T2ZfMS5kZWZhdWx0LFxuICAgICAgICBvbmVPZl8xLmRlZmF1bHQsXG4gICAgICAgIGFsbE9mXzEuZGVmYXVsdCxcbiAgICAgICAgaWZfMS5kZWZhdWx0LFxuICAgICAgICB0aGVuRWxzZV8xLmRlZmF1bHQsXG4gICAgICAgIC8vIG9iamVjdFxuICAgICAgICBwcm9wZXJ0eU5hbWVzXzEuZGVmYXVsdCxcbiAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXNfMS5kZWZhdWx0LFxuICAgICAgICBkZXBlbmRlbmNpZXNfMS5kZWZhdWx0LFxuICAgICAgICBwcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICAgICAgcGF0dGVyblByb3BlcnRpZXNfMS5kZWZhdWx0LFxuICAgIF07XG4gICAgLy8gYXJyYXlcbiAgICBpZiAoZHJhZnQyMDIwKVxuICAgICAgICBhcHBsaWNhdG9yLnB1c2gocHJlZml4SXRlbXNfMS5kZWZhdWx0LCBpdGVtczIwMjBfMS5kZWZhdWx0KTtcbiAgICBlbHNlXG4gICAgICAgIGFwcGxpY2F0b3IucHVzaChhZGRpdGlvbmFsSXRlbXNfMS5kZWZhdWx0LCBpdGVtc18xLmRlZmF1bHQpO1xuICAgIGFwcGxpY2F0b3IucHVzaChjb250YWluc18xLmRlZmF1bHQpO1xuICAgIHJldHVybiBhcHBsaWNhdG9yO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0QXBwbGljYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLnN0ciBgbXVzdCBtYXRjaCBmb3JtYXQgXCIke3NjaGVtYUNvZGV9XCJgLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuXyBge2Zvcm1hdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImZvcm1hdFwiLFxuICAgIHR5cGU6IFtcIm51bWJlclwiLCBcInN0cmluZ1wiXSxcbiAgICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0LCBydWxlVHlwZSkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvcHRzLCBlcnJTY2hlbWFQYXRoLCBzY2hlbWFFbnYsIHNlbGYgfSA9IGl0O1xuICAgICAgICBpZiAoIW9wdHMudmFsaWRhdGVGb3JtYXRzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoJGRhdGEpXG4gICAgICAgICAgICB2YWxpZGF0ZSREYXRhRm9ybWF0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHZhbGlkYXRlRm9ybWF0KCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlJERhdGFGb3JtYXQoKSB7XG4gICAgICAgICAgICBjb25zdCBmbXRzID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAgICAgICAgICByZWY6IHNlbGYuZm9ybWF0cyxcbiAgICAgICAgICAgICAgICBjb2RlOiBvcHRzLmNvZGUuZm9ybWF0cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZkRlZiA9IGdlbi5jb25zdChcImZEZWZcIiwgY29kZWdlbl8xLl8gYCR7Zm10c31bJHtzY2hlbWFDb2RlfV1gKTtcbiAgICAgICAgICAgIGNvbnN0IGZUeXBlID0gZ2VuLmxldChcImZUeXBlXCIpO1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gZ2VuLmxldChcImZvcm1hdFwiKTtcbiAgICAgICAgICAgIC8vIFRPRE8gc2ltcGxpZnlcbiAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgdHlwZW9mICR7ZkRlZn0gPT0gXCJvYmplY3RcIiAmJiAhKCR7ZkRlZn0gaW5zdGFuY2VvZiBSZWdFeHApYCwgKCkgPT4gZ2VuLmFzc2lnbihmVHlwZSwgY29kZWdlbl8xLl8gYCR7ZkRlZn0udHlwZSB8fCBcInN0cmluZ1wiYCkuYXNzaWduKGZvcm1hdCwgY29kZWdlbl8xLl8gYCR7ZkRlZn0udmFsaWRhdGVgKSwgKCkgPT4gZ2VuLmFzc2lnbihmVHlwZSwgY29kZWdlbl8xLl8gYFwic3RyaW5nXCJgKS5hc3NpZ24oZm9ybWF0LCBmRGVmKSk7XG4gICAgICAgICAgICBjeHQuZmFpbCRkYXRhKGNvZGVnZW5fMS5vcih1bmtub3duRm10KCksIGludmFsaWRGbXQoKSkpO1xuICAgICAgICAgICAgZnVuY3Rpb24gdW5rbm93bkZtdCgpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5zdHJpY3RTY2hlbWEgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLm5pbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLl8gYCR7c2NoZW1hQ29kZX0gJiYgISR7Zm9ybWF0fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBpbnZhbGlkRm10KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxGb3JtYXQgPSBzY2hlbWFFbnYuJGFzeW5jXG4gICAgICAgICAgICAgICAgICAgID8gY29kZWdlbl8xLl8gYCgke2ZEZWZ9LmFzeW5jID8gYXdhaXQgJHtmb3JtYXR9KCR7ZGF0YX0pIDogJHtmb3JtYXR9KCR7ZGF0YX0pKWBcbiAgICAgICAgICAgICAgICAgICAgOiBjb2RlZ2VuXzEuXyBgJHtmb3JtYXR9KCR7ZGF0YX0pYDtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZERhdGEgPSBjb2RlZ2VuXzEuXyBgKHR5cGVvZiAke2Zvcm1hdH0gPT0gXCJmdW5jdGlvblwiID8gJHtjYWxsRm9ybWF0fSA6ICR7Zm9ybWF0fS50ZXN0KCR7ZGF0YX0pKWA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5fIGAke2Zvcm1hdH0gJiYgJHtmb3JtYXR9ICE9PSB0cnVlICYmICR7ZlR5cGV9ID09PSAke3J1bGVUeXBlfSAmJiAhJHt2YWxpZERhdGF9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdERlZiA9IHNlbGYuZm9ybWF0c1tzY2hlbWFdO1xuICAgICAgICAgICAgaWYgKCFmb3JtYXREZWYpIHtcbiAgICAgICAgICAgICAgICB1bmtub3duRm9ybWF0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdERlZiA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBbZm10VHlwZSwgZm9ybWF0LCBmbXRSZWZdID0gZ2V0Rm9ybWF0KGZvcm1hdERlZik7XG4gICAgICAgICAgICBpZiAoZm10VHlwZSA9PT0gcnVsZVR5cGUpXG4gICAgICAgICAgICAgICAgY3h0LnBhc3ModmFsaWRDb25kaXRpb24oKSk7XG4gICAgICAgICAgICBmdW5jdGlvbiB1bmtub3duRm9ybWF0KCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnN0cmljdFNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2dnZXIud2Fybih1bmtub3duTXNnKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih1bmtub3duTXNnKCkpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVua25vd25Nc2coKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgdW5rbm93biBmb3JtYXQgXCIke3NjaGVtYX1cIiBpZ25vcmVkIGluIHNjaGVtYSBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRGb3JtYXQoZm10RGVmKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGZtdERlZiBpbnN0YW5jZW9mIFJlZ0V4cFxuICAgICAgICAgICAgICAgICAgICA/IGNvZGVnZW5fMS5yZWdleHBDb2RlKGZtdERlZilcbiAgICAgICAgICAgICAgICAgICAgOiBvcHRzLmNvZGUuZm9ybWF0c1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb2RlZ2VuXzEuXyBgJHtvcHRzLmNvZGUuZm9ybWF0c30ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eShzY2hlbWEpfWBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZtdCA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7IGtleTogc2NoZW1hLCByZWY6IGZtdERlZiwgY29kZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZtdERlZiA9PSBcIm9iamVjdFwiICYmICEoZm10RGVmIGluc3RhbmNlb2YgUmVnRXhwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2ZtdERlZi50eXBlIHx8IFwic3RyaW5nXCIsIGZtdERlZi52YWxpZGF0ZSwgY29kZWdlbl8xLl8gYCR7Zm10fS52YWxpZGF0ZWBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1wic3RyaW5nXCIsIGZtdERlZiwgZm10XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHZhbGlkQ29uZGl0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm9ybWF0RGVmID09IFwib2JqZWN0XCIgJiYgIShmb3JtYXREZWYgaW5zdGFuY2VvZiBSZWdFeHApICYmIGZvcm1hdERlZi5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNjaGVtYUVudi4kYXN5bmMpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBmb3JtYXQgaW4gc3luYyBzY2hlbWFcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgYXdhaXQgJHtmbXRSZWZ9KCR7ZGF0YX0pYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBmb3JtYXQgPT0gXCJmdW5jdGlvblwiID8gY29kZWdlbl8xLl8gYCR7Zm10UmVmfSgke2RhdGF9KWAgOiBjb2RlZ2VuXzEuXyBgJHtmbXRSZWZ9LnRlc3QoJHtkYXRhfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBmb3JtYXRfMSA9IHJlcXVpcmUoXCIuL2Zvcm1hdFwiKTtcbmNvbnN0IGZvcm1hdCA9IFtmb3JtYXRfMS5kZWZhdWx0XTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZvcm1hdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb250ZW50Vm9jYWJ1bGFyeSA9IGV4cG9ydHMubWV0YWRhdGFWb2NhYnVsYXJ5ID0gdm9pZCAwO1xuZXhwb3J0cy5tZXRhZGF0YVZvY2FidWxhcnkgPSBbXG4gICAgXCJ0aXRsZVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIixcbiAgICBcImRlZmF1bHRcIixcbiAgICBcImRlcHJlY2F0ZWRcIixcbiAgICBcInJlYWRPbmx5XCIsXG4gICAgXCJ3cml0ZU9ubHlcIixcbiAgICBcImV4YW1wbGVzXCIsXG5dO1xuZXhwb3J0cy5jb250ZW50Vm9jYWJ1bGFyeSA9IFtcbiAgICBcImNvbnRlbnRNZWRpYVR5cGVcIixcbiAgICBcImNvbnRlbnRFbmNvZGluZ1wiLFxuICAgIFwiY29udGVudFNjaGVtYVwiLFxuXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldGFkYXRhLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbmNvbnN0IHZhbGlkYXRpb25fMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRpb25cIik7XG5jb25zdCBhcHBsaWNhdG9yXzEgPSByZXF1aXJlKFwiLi9hcHBsaWNhdG9yXCIpO1xuY29uc3QgZm9ybWF0XzEgPSByZXF1aXJlKFwiLi9mb3JtYXRcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBkcmFmdDdWb2NhYnVsYXJpZXMgPSBbXG4gICAgY29yZV8xLmRlZmF1bHQsXG4gICAgdmFsaWRhdGlvbl8xLmRlZmF1bHQsXG4gICAgYXBwbGljYXRvcl8xLmRlZmF1bHQoKSxcbiAgICBmb3JtYXRfMS5kZWZhdWx0LFxuICAgIG1ldGFkYXRhXzEubWV0YWRhdGFWb2NhYnVsYXJ5LFxuICAgIG1ldGFkYXRhXzEuY29udGVudFZvY2FidWxhcnksXG5dO1xuZXhwb3J0cy5kZWZhdWx0ID0gZHJhZnQ3Vm9jYWJ1bGFyaWVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHJhZnQ3LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EaXNjckVycm9yID0gdm9pZCAwO1xudmFyIERpc2NyRXJyb3I7XG4oZnVuY3Rpb24gKERpc2NyRXJyb3IpIHtcbiAgICBEaXNjckVycm9yW1wiVGFnXCJdID0gXCJ0YWdcIjtcbiAgICBEaXNjckVycm9yW1wiTWFwcGluZ1wiXSA9IFwibWFwcGluZ1wiO1xufSkoRGlzY3JFcnJvciA9IGV4cG9ydHMuRGlzY3JFcnJvciB8fCAoZXhwb3J0cy5EaXNjckVycm9yID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vZGlzY3JpbWluYXRvci90eXBlc1wiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBkaXNjckVycm9yLCB0YWdOYW1lIH0gfSkgPT4gZGlzY3JFcnJvciA9PT0gdHlwZXNfMS5EaXNjckVycm9yLlRhZ1xuICAgICAgICA/IGB0YWcgXCIke3RhZ05hbWV9XCIgbXVzdCBiZSBzdHJpbmdgXG4gICAgICAgIDogYHZhbHVlIG9mIHRhZyBcIiR7dGFnTmFtZX1cIiBtdXN0IGJlIGluIG9uZU9mYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBkaXNjckVycm9yLCB0YWcsIHRhZ05hbWUgfSB9KSA9PiBjb2RlZ2VuXzEuXyBge2Vycm9yOiAke2Rpc2NyRXJyb3J9LCB0YWc6ICR7dGFnTmFtZX0sIHRhZ1ZhbHVlOiAke3RhZ319YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJkaXNjcmltaW5hdG9yXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvbmVPZiB9ID0gcGFyZW50U2NoZW1hO1xuICAgICAgICBpZiAoIWl0Lm9wdHMuZGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgZGlzY3JpbWluYXRvciBvcHRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFnTmFtZSA9IHNjaGVtYS5wcm9wZXJ0eU5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgdGFnTmFtZSAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgcHJvcGVydHlOYW1lXCIpO1xuICAgICAgICBpZiAoc2NoZW1hLm1hcHBpbmcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiBtYXBwaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIGlmICghb25lT2YpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiByZXF1aXJlcyBvbmVPZiBrZXl3b3JkXCIpO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IHRhZyA9IGdlbi5jb25zdChcInRhZ1wiLCBjb2RlZ2VuXzEuXyBgJHtkYXRhfSR7Y29kZWdlbl8xLmdldFByb3BlcnR5KHRhZ05hbWUpfWApO1xuICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYHR5cGVvZiAke3RhZ30gPT0gXCJzdHJpbmdcImAsICgpID0+IHZhbGlkYXRlTWFwcGluZygpLCAoKSA9PiBjeHQuZXJyb3IoZmFsc2UsIHsgZGlzY3JFcnJvcjogdHlwZXNfMS5EaXNjckVycm9yLlRhZywgdGFnLCB0YWdOYW1lIH0pKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVNYXBwaW5nKCkge1xuICAgICAgICAgICAgY29uc3QgbWFwcGluZyA9IGdldE1hcHBpbmcoKTtcbiAgICAgICAgICAgIGdlbi5pZihmYWxzZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhZ1ZhbHVlIGluIG1hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICBnZW4uZWxzZUlmKGNvZGVnZW5fMS5fIGAke3RhZ30gPT09ICR7dGFnVmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgYXBwbHlUYWdTY2hlbWEobWFwcGluZ1t0YWdWYWx1ZV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbi5lbHNlKCk7XG4gICAgICAgICAgICBjeHQuZXJyb3IoZmFsc2UsIHsgZGlzY3JFcnJvcjogdHlwZXNfMS5EaXNjckVycm9yLk1hcHBpbmcsIHRhZywgdGFnTmFtZSB9KTtcbiAgICAgICAgICAgIGdlbi5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5VGFnU2NoZW1hKHNjaGVtYVByb3ApIHtcbiAgICAgICAgICAgIGNvbnN0IF92YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHsga2V5d29yZDogXCJvbmVPZlwiLCBzY2hlbWFQcm9wIH0sIF92YWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0LCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gX3ZhbGlkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldE1hcHBpbmcoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBvbmVPZk1hcHBpbmcgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHRvcFJlcXVpcmVkID0gaGFzUmVxdWlyZWQocGFyZW50U2NoZW1hKTtcbiAgICAgICAgICAgIGxldCB0YWdSZXF1aXJlZCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9uZU9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoID0gb25lT2ZbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcFNjaCA9IChfYSA9IHNjaC5wcm9wZXJ0aWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbdGFnTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wU2NoICE9IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBvbmVPZiBzY2hlbWFzIG11c3QgaGF2ZSBcInByb3BlcnRpZXMvJHt0YWdOYW1lfVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhZ1JlcXVpcmVkID0gdGFnUmVxdWlyZWQgJiYgKHRvcFJlcXVpcmVkIHx8IGhhc1JlcXVpcmVkKHNjaCkpO1xuICAgICAgICAgICAgICAgIGFkZE1hcHBpbmdzKHByb3BTY2gsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0YWdSZXF1aXJlZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IFwiJHt0YWdOYW1lfVwiIG11c3QgYmUgcmVxdWlyZWRgKTtcbiAgICAgICAgICAgIHJldHVybiBvbmVPZk1hcHBpbmc7XG4gICAgICAgICAgICBmdW5jdGlvbiBoYXNSZXF1aXJlZCh7IHJlcXVpcmVkIH0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShyZXF1aXJlZCkgJiYgcmVxdWlyZWQuaW5jbHVkZXModGFnTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRNYXBwaW5ncyhzY2gsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NoLmNvbnN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZE1hcHBpbmcoc2NoLmNvbnN0LCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoLmVudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0YWdWYWx1ZSBvZiBzY2guZW51bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTWFwcGluZyh0YWdWYWx1ZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogXCJwcm9wZXJ0aWVzLyR7dGFnTmFtZX1cIiBtdXN0IGhhdmUgXCJjb25zdFwiIG9yIFwiZW51bVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkTWFwcGluZyh0YWdWYWx1ZSwgaSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFnVmFsdWUgIT0gXCJzdHJpbmdcIiB8fCB0YWdWYWx1ZSBpbiBvbmVPZk1hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBcIiR7dGFnTmFtZX1cIiB2YWx1ZXMgbXVzdCBiZSB1bmlxdWUgc3RyaW5nc2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbmVPZk1hcHBpbmdbdGFnVmFsdWVdID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvZGVHZW4gPSBleHBvcnRzLk5hbWUgPSBleHBvcnRzLm5pbCA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLl8gPSBleHBvcnRzLktleXdvcmRDeHQgPSB2b2lkIDA7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuY29uc3QgZHJhZnQ3XzEgPSByZXF1aXJlKFwiLi92b2NhYnVsYXJpZXMvZHJhZnQ3XCIpO1xuY29uc3QgZGlzY3JpbWluYXRvcl8xID0gcmVxdWlyZShcIi4vdm9jYWJ1bGFyaWVzL2Rpc2NyaW1pbmF0b3JcIik7XG5jb25zdCBkcmFmdDdNZXRhU2NoZW1hID0gcmVxdWlyZShcIi4vcmVmcy9qc29uLXNjaGVtYS1kcmFmdC0wNy5qc29uXCIpO1xuY29uc3QgTUVUQV9TVVBQT1JUX0RBVEEgPSBbXCIvcHJvcGVydGllc1wiXTtcbmNvbnN0IE1FVEFfU0NIRU1BX0lEID0gXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYVwiO1xuY2xhc3MgQWp2IGV4dGVuZHMgY29yZV8xLmRlZmF1bHQge1xuICAgIF9hZGRWb2NhYnVsYXJpZXMoKSB7XG4gICAgICAgIHN1cGVyLl9hZGRWb2NhYnVsYXJpZXMoKTtcbiAgICAgICAgZHJhZnQ3XzEuZGVmYXVsdC5mb3JFYWNoKCh2KSA9PiB0aGlzLmFkZFZvY2FidWxhcnkodikpO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmRpc2NyaW1pbmF0b3IpXG4gICAgICAgICAgICB0aGlzLmFkZEtleXdvcmQoZGlzY3JpbWluYXRvcl8xLmRlZmF1bHQpO1xuICAgIH1cbiAgICBfYWRkRGVmYXVsdE1ldGFTY2hlbWEoKSB7XG4gICAgICAgIHN1cGVyLl9hZGREZWZhdWx0TWV0YVNjaGVtYSgpO1xuICAgICAgICBpZiAoIXRoaXMub3B0cy5tZXRhKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBtZXRhU2NoZW1hID0gdGhpcy5vcHRzLiRkYXRhXG4gICAgICAgICAgICA/IHRoaXMuJGRhdGFNZXRhU2NoZW1hKGRyYWZ0N01ldGFTY2hlbWEsIE1FVEFfU1VQUE9SVF9EQVRBKVxuICAgICAgICAgICAgOiBkcmFmdDdNZXRhU2NoZW1hO1xuICAgICAgICB0aGlzLmFkZE1ldGFTY2hlbWEobWV0YVNjaGVtYSwgTUVUQV9TQ0hFTUFfSUQsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5yZWZzW1wiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9zY2hlbWFcIl0gPSBNRVRBX1NDSEVNQV9JRDtcbiAgICB9XG4gICAgZGVmYXVsdE1ldGEoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5vcHRzLmRlZmF1bHRNZXRhID1cbiAgICAgICAgICAgIHN1cGVyLmRlZmF1bHRNZXRhKCkgfHwgKHRoaXMuZ2V0U2NoZW1hKE1FVEFfU0NIRU1BX0lEKSA/IE1FVEFfU0NIRU1BX0lEIDogdW5kZWZpbmVkKSk7XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQWp2O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQWp2O1xudmFyIHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3ZhbGlkYXRlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiS2V5d29yZEN4dFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdGVfMS5LZXl3b3JkQ3h0OyB9IH0pO1xudmFyIGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvY29kZWdlblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5fOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5naWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyaW5naWZ5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmlsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEubmlsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLk5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb2RlR2VuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuQ29kZUdlbjsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFqdi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZm9ybWF0TmFtZXMgPSBleHBvcnRzLmZhc3RGb3JtYXRzID0gZXhwb3J0cy5mdWxsRm9ybWF0cyA9IHZvaWQgMDtcbmZ1bmN0aW9uIGZtdERlZih2YWxpZGF0ZSwgY29tcGFyZSkge1xuICAgIHJldHVybiB7IHZhbGlkYXRlLCBjb21wYXJlIH07XG59XG5leHBvcnRzLmZ1bGxGb3JtYXRzID0ge1xuICAgIC8vIGRhdGU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICBkYXRlOiBmbXREZWYoZGF0ZSwgY29tcGFyZURhdGUpLFxuICAgIC8vIGRhdGUtdGltZTogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICAgIHRpbWU6IGZtdERlZih0aW1lLCBjb21wYXJlVGltZSksXG4gICAgXCJkYXRlLXRpbWVcIjogZm10RGVmKGRhdGVfdGltZSwgY29tcGFyZURhdGVUaW1lKSxcbiAgICAvLyBkdXJhdGlvbjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjYXBwZW5kaXgtQVxuICAgIGR1cmF0aW9uOiAvXlAoPyEkKSgoXFxkK1kpPyhcXGQrTSk/KFxcZCtEKT8oVCg/PVxcZCkoXFxkK0gpPyhcXGQrTSk/KFxcZCtTKT8pP3woXFxkK1cpPykkLyxcbiAgICB1cmksXG4gICAgXCJ1cmktcmVmZXJlbmNlXCI6IC9eKD86W2Etel1bYS16MC05K1xcLS5dKjopPyg/OlxcLz9cXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06XXwlWzAtOWEtZl17Mn0pKkApPyg/OlxcWyg/Oig/Oig/Oig/OlswLTlhLWZdezEsNH06KXs2fXw6Oig/OlswLTlhLWZdezEsNH06KXs1fXwoPzpbMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXs0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwxfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezN9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDJ9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7Mn18KD86KD86WzAtOWEtZl17MSw0fTopezAsM31bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH06fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDR9WzAtOWEtZl17MSw0fSk/OjopKD86WzAtOWEtZl17MSw0fTpbMC05YS1mXXsxLDR9fCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSl8KD86KD86WzAtOWEtZl17MSw0fTopezAsNX1bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH18KD86KD86WzAtOWEtZl17MSw0fTopezAsNn1bMC05YS1mXXsxLDR9KT86Oil8W1Z2XVswLTlhLWZdK1xcLlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdKylcXF18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pfCg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9XXwlWzAtOWEtZl17Mn0pKikoPzo6XFxkKik/KD86XFwvKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSopKnxcXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopP3woPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopPyg/OlxcPyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyg/OiMoPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8kL2ksXG4gICAgLy8gdXJpLXRlbXBsYXRlOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjU3MFxuICAgIFwidXJpLXRlbXBsYXRlXCI6IC9eKD86KD86W15cXHgwMC1cXHgyMFwiJzw+JVxcXFxeYHt8fV18JVswLTlhLWZdezJ9KXxcXHtbKyMuLzs/Jj0sIUB8XT8oPzpbYS16MC05X118JVswLTlhLWZdezJ9KSsoPzo6WzEtOV1bMC05XXswLDN9fFxcKik/KD86LCg/OlthLXowLTlfXXwlWzAtOWEtZl17Mn0pKyg/OjpbMS05XVswLTldezAsM318XFwqKT8pKlxcfSkqJC9pLFxuICAgIC8vIEZvciB0aGUgc291cmNlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9kcGVyaW5pLzcyOTI5NFxuICAgIC8vIEZvciB0ZXN0IGNhc2VzOiBodHRwczovL21hdGhpYXNieW5lbnMuYmUvZGVtby91cmwtcmVnZXhcbiAgICB1cmw6IC9eKD86aHR0cHM/fGZ0cCk6XFwvXFwvKD86XFxTKyg/OjpcXFMqKT9AKT8oPzooPyEoPzoxMHwxMjcpKD86XFwuXFxkezEsM30pezN9KSg/ISg/OjE2OVxcLjI1NHwxOTJcXC4xNjgpKD86XFwuXFxkezEsM30pezJ9KSg/ITE3MlxcLig/OjFbNi05XXwyXFxkfDNbMC0xXSkoPzpcXC5cXGR7MSwzfSl7Mn0pKD86WzEtOV1cXGQ/fDFcXGRcXGR8MlswMV1cXGR8MjJbMC0zXSkoPzpcXC4oPzoxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSl7Mn0oPzpcXC4oPzpbMS05XVxcZD98MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC00XSkpfCg/Oig/OlthLXowLTlcXHV7MDBhMX0tXFx1e2ZmZmZ9XSstKSpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rKSg/OlxcLig/OlthLXowLTlcXHV7MDBhMX0tXFx1e2ZmZmZ9XSstKSpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rKSooPzpcXC4oPzpbYS16XFx1ezAwYTF9LVxcdXtmZmZmfV17Mix9KSkpKD86OlxcZHsyLDV9KT8oPzpcXC9bXlxcc10qKT8kL2l1LFxuICAgIGVtYWlsOiAvXlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSsoPzpcXC5bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKSpAKD86W2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pP1xcLikrW2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pPyQvaSxcbiAgICBob3N0bmFtZTogL14oPz0uezEsMjUzfVxcLj8kKVthLXowLTldKD86W2EtejAtOS1dezAsNjF9W2EtejAtOV0pPyg/OlxcLlthLXowLTldKD86Wy0wLTlhLXpdezAsNjF9WzAtOWEtel0pPykqXFwuPyQvaSxcbiAgICAvLyBvcHRpbWl6ZWQgaHR0cHM6Ly93d3cuc2FmYXJpYm9va3NvbmxpbmUuY29tL2xpYnJhcnkvdmlldy9yZWd1bGFyLWV4cHJlc3Npb25zLWNvb2tib29rLzk3ODA1OTY4MDI4MzcvY2gwN3MxNi5odG1sXG4gICAgaXB2NDogL14oPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykkLyxcbiAgICBpcHY2OiAvXigoKFswLTlhLWZdezEsNH06KXs3fShbMC05YS1mXXsxLDR9fDopKXwoKFswLTlhLWZdezEsNH06KXs2fSg6WzAtOWEtZl17MSw0fXwoKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCgoWzAtOWEtZl17MSw0fTopezV9KCgoOlswLTlhLWZdezEsNH0pezEsMn0pfDooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCgoWzAtOWEtZl17MSw0fTopezR9KCgoOlswLTlhLWZdezEsNH0pezEsM30pfCgoOlswLTlhLWZdezEsNH0pPzooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXszfSgoKDpbMC05YS1mXXsxLDR9KXsxLDR9KXwoKDpbMC05YS1mXXsxLDR9KXswLDJ9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezJ9KCgoOlswLTlhLWZdezEsNH0pezEsNX0pfCgoOlswLTlhLWZdezEsNH0pezAsM306KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7MX0oKCg6WzAtOWEtZl17MSw0fSl7MSw2fSl8KCg6WzAtOWEtZl17MSw0fSl7MCw0fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoOigoKDpbMC05YS1mXXsxLDR9KXsxLDd9KXwoKDpbMC05YS1mXXsxLDR9KXswLDV9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpKSQvaSxcbiAgICByZWdleCxcbiAgICAvLyB1dWlkOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0MTIyXG4gICAgdXVpZDogL14oPzp1cm46dXVpZDopP1swLTlhLWZdezh9LSg/OlswLTlhLWZdezR9LSl7M31bMC05YS1mXXsxMn0kL2ksXG4gICAgLy8gSlNPTi1wb2ludGVyOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjkwMVxuICAgIC8vIHVyaSBmcmFnbWVudDogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjYXBwZW5kaXgtQVxuICAgIFwianNvbi1wb2ludGVyXCI6IC9eKD86XFwvKD86W15+L118fjB8fjEpKikqJC8sXG4gICAgXCJqc29uLXBvaW50ZXItdXJpLWZyYWdtZW50XCI6IC9eIyg/OlxcLyg/OlthLXowLTlfXFwtLiEkJicoKSorLDs6PUBdfCVbMC05YS1mXXsyfXx+MHx+MSkqKSokL2ksXG4gICAgLy8gcmVsYXRpdmUgSlNPTi1wb2ludGVyOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1sdWZmLXJlbGF0aXZlLWpzb24tcG9pbnRlci0wMFxuICAgIFwicmVsYXRpdmUtanNvbi1wb2ludGVyXCI6IC9eKD86MHxbMS05XVswLTldKikoPzojfCg/OlxcLyg/Oltefi9dfH4wfH4xKSopKikkLyxcbiAgICAvLyB0aGUgZm9sbG93aW5nIGZvcm1hdHMgYXJlIHVzZWQgYnkgdGhlIG9wZW5hcGkgc3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9zcGVjLm9wZW5hcGlzLm9yZy9vYXMvdjMuMC4wI2RhdGEtdHlwZXNcbiAgICAvLyBieXRlOiBodHRwczovL2dpdGh1Yi5jb20vbWlndWVsbW90YS9pcy1iYXNlNjRcbiAgICBieXRlLFxuICAgIC8vIHNpZ25lZCAzMiBiaXQgaW50ZWdlclxuICAgIGludDMyOiB7IHR5cGU6IFwibnVtYmVyXCIsIHZhbGlkYXRlOiB2YWxpZGF0ZUludDMyIH0sXG4gICAgLy8gc2lnbmVkIDY0IGJpdCBpbnRlZ2VyXG4gICAgaW50NjQ6IHsgdHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlSW50NjQgfSxcbiAgICAvLyBDLXR5cGUgZmxvYXRcbiAgICBmbG9hdDogeyB0eXBlOiBcIm51bWJlclwiLCB2YWxpZGF0ZTogdmFsaWRhdGVOdW1iZXIgfSxcbiAgICAvLyBDLXR5cGUgZG91YmxlXG4gICAgZG91YmxlOiB7IHR5cGU6IFwibnVtYmVyXCIsIHZhbGlkYXRlOiB2YWxpZGF0ZU51bWJlciB9LFxuICAgIC8vIGhpbnQgdG8gdGhlIFVJIHRvIGhpZGUgaW5wdXQgc3RyaW5nc1xuICAgIHBhc3N3b3JkOiB0cnVlLFxuICAgIC8vIHVuY2hlY2tlZCBzdHJpbmcgcGF5bG9hZFxuICAgIGJpbmFyeTogdHJ1ZSxcbn07XG5leHBvcnRzLmZhc3RGb3JtYXRzID0ge1xuICAgIC4uLmV4cG9ydHMuZnVsbEZvcm1hdHMsXG4gICAgZGF0ZTogZm10RGVmKC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkJC8sIGNvbXBhcmVEYXRlKSxcbiAgICB0aW1lOiBmbXREZWYoL14oPzpbMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZHwyMzo1OTo2MCkoPzpcXC5cXGQrKT8oPzp6fFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/KT8kL2ksIGNvbXBhcmVUaW1lKSxcbiAgICBcImRhdGUtdGltZVwiOiBmbXREZWYoL15cXGRcXGRcXGRcXGQtWzAtMV1cXGQtWzAtM11cXGRbdFxcc10oPzpbMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZHwyMzo1OTo2MCkoPzpcXC5cXGQrKT8oPzp6fFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/KSQvaSwgY29tcGFyZURhdGVUaW1lKSxcbiAgICAvLyB1cmk6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvaXMtbXktanNvbi12YWxpZC9ibG9iL21hc3Rlci9mb3JtYXRzLmpzXG4gICAgdXJpOiAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KSg/OlxcLz9cXC8pP1teXFxzXSokL2ksXG4gICAgXCJ1cmktcmVmZXJlbmNlXCI6IC9eKD86KD86W2Etel1bYS16MC05K1xcLS5dKjopP1xcLz9cXC8pPyg/OlteXFxcXFxccyNdW15cXHMjXSopPyg/OiNbXlxcXFxcXHNdKik/JC9pLFxuICAgIC8vIGVtYWlsIChzb3VyY2VzIGZyb20ganNlbiB2YWxpZGF0b3IpOlxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjAxMzIzL3VzaW5nLWEtcmVndWxhci1leHByZXNzaW9uLXRvLXZhbGlkYXRlLWFuLWVtYWlsLWFkZHJlc3MjYW5zd2VyLTg4MjkzNjNcbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9mb3Jtcy5odG1sI3ZhbGlkLWUtbWFpbC1hZGRyZXNzIChzZWFyY2ggZm9yICd3aWxmdWwgdmlvbGF0aW9uJylcbiAgICBlbWFpbDogL15bYS16MC05LiEjJCUmJyorLz0/Xl9ge3x9fi1dK0BbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8oPzpcXC5bYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8pKiQvaSxcbn07XG5leHBvcnRzLmZvcm1hdE5hbWVzID0gT2JqZWN0LmtleXMoZXhwb3J0cy5mdWxsRm9ybWF0cyk7XG5mdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNhcHBlbmRpeC1DXG4gICAgcmV0dXJuIHllYXIgJSA0ID09PSAwICYmICh5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApO1xufVxuY29uc3QgREFURSA9IC9eKFxcZFxcZFxcZFxcZCktKFxcZFxcZCktKFxcZFxcZCkkLztcbmNvbnN0IERBWVMgPSBbMCwgMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07XG5mdW5jdGlvbiBkYXRlKHN0cikge1xuICAgIC8vIGZ1bGwtZGF0ZSBmcm9tIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICBjb25zdCBtYXRjaGVzID0gREFURS5leGVjKHN0cik7XG4gICAgaWYgKCFtYXRjaGVzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgeWVhciA9ICttYXRjaGVzWzFdO1xuICAgIGNvbnN0IG1vbnRoID0gK21hdGNoZXNbMl07XG4gICAgY29uc3QgZGF5ID0gK21hdGNoZXNbM107XG4gICAgcmV0dXJuIChtb250aCA+PSAxICYmXG4gICAgICAgIG1vbnRoIDw9IDEyICYmXG4gICAgICAgIGRheSA+PSAxICYmXG4gICAgICAgIGRheSA8PSAobW9udGggPT09IDIgJiYgaXNMZWFwWWVhcih5ZWFyKSA/IDI5IDogREFZU1ttb250aF0pKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVEYXRlKGQxLCBkMikge1xuICAgIGlmICghKGQxICYmIGQyKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZiAoZDEgPiBkMilcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKGQxIDwgZDIpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICByZXR1cm4gMDtcbn1cbmNvbnN0IFRJTUUgPSAvXihcXGRcXGQpOihcXGRcXGQpOihcXGRcXGQpKFxcLlxcZCspPyh6fFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/KT8kL2k7XG5mdW5jdGlvbiB0aW1lKHN0ciwgd2l0aFRpbWVab25lKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IFRJTUUuZXhlYyhzdHIpO1xuICAgIGlmICghbWF0Y2hlcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGhvdXIgPSArbWF0Y2hlc1sxXTtcbiAgICBjb25zdCBtaW51dGUgPSArbWF0Y2hlc1syXTtcbiAgICBjb25zdCBzZWNvbmQgPSArbWF0Y2hlc1szXTtcbiAgICBjb25zdCB0aW1lWm9uZSA9IG1hdGNoZXNbNV07XG4gICAgcmV0dXJuICgoKGhvdXIgPD0gMjMgJiYgbWludXRlIDw9IDU5ICYmIHNlY29uZCA8PSA1OSkgfHxcbiAgICAgICAgKGhvdXIgPT09IDIzICYmIG1pbnV0ZSA9PT0gNTkgJiYgc2Vjb25kID09PSA2MCkpICYmXG4gICAgICAgICghd2l0aFRpbWVab25lIHx8IHRpbWVab25lICE9PSBcIlwiKSk7XG59XG5mdW5jdGlvbiBjb21wYXJlVGltZSh0MSwgdDIpIHtcbiAgICBpZiAoISh0MSAmJiB0MikpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgYTEgPSBUSU1FLmV4ZWModDEpO1xuICAgIGNvbnN0IGEyID0gVElNRS5leGVjKHQyKTtcbiAgICBpZiAoIShhMSAmJiBhMikpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgdDEgPSBhMVsxXSArIGExWzJdICsgYTFbM10gKyAoYTFbNF0gfHwgXCJcIik7XG4gICAgdDIgPSBhMlsxXSArIGEyWzJdICsgYTJbM10gKyAoYTJbNF0gfHwgXCJcIik7XG4gICAgaWYgKHQxID4gdDIpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmICh0MSA8IHQyKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgcmV0dXJuIDA7XG59XG5jb25zdCBEQVRFX1RJTUVfU0VQQVJBVE9SID0gL3R8XFxzL2k7XG5mdW5jdGlvbiBkYXRlX3RpbWUoc3RyKSB7XG4gICAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICAgIGNvbnN0IGRhdGVUaW1lID0gc3RyLnNwbGl0KERBVEVfVElNRV9TRVBBUkFUT1IpO1xuICAgIHJldHVybiBkYXRlVGltZS5sZW5ndGggPT09IDIgJiYgZGF0ZShkYXRlVGltZVswXSkgJiYgdGltZShkYXRlVGltZVsxXSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBjb21wYXJlRGF0ZVRpbWUoZHQxLCBkdDIpIHtcbiAgICBpZiAoIShkdDEgJiYgZHQyKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBbZDEsIHQxXSA9IGR0MS5zcGxpdChEQVRFX1RJTUVfU0VQQVJBVE9SKTtcbiAgICBjb25zdCBbZDIsIHQyXSA9IGR0Mi5zcGxpdChEQVRFX1RJTUVfU0VQQVJBVE9SKTtcbiAgICBjb25zdCByZXMgPSBjb21wYXJlRGF0ZShkMSwgZDIpO1xuICAgIGlmIChyZXMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzIHx8IGNvbXBhcmVUaW1lKHQxLCB0Mik7XG59XG5jb25zdCBOT1RfVVJJX0ZSQUdNRU5UID0gL1xcL3w6LztcbmNvbnN0IFVSSSA9IC9eKD86W2Etel1bYS16MC05K1xcLS5dKjopKD86XFwvP1xcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdfCVbMC05YS1mXXsyfSkqQCk/KD86XFxbKD86KD86KD86KD86WzAtOWEtZl17MSw0fTopezZ9fDo6KD86WzAtOWEtZl17MSw0fTopezV9fCg/OlswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDF9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7M318KD86KD86WzAtOWEtZl17MSw0fTopezAsMn1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXsyfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwzfVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fTp8KD86KD86WzAtOWEtZl17MSw0fTopezAsNH1bMC05YS1mXXsxLDR9KT86OikoPzpbMC05YS1mXXsxLDR9OlswLTlhLWZdezEsNH18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw1fVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw2fVswLTlhLWZdezEsNH0pPzo6KXxbVnZdWzAtOWEtZl0rXFwuW2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol0rKVxcXXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPyl8KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9XXwlWzAtOWEtZl17Mn0pKikoPzo6XFxkKik/KD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSp8XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopP3woPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKikoPzpcXD8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/KD86Iyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8kL2k7XG5mdW5jdGlvbiB1cmkoc3RyKSB7XG4gICAgLy8gaHR0cDovL2ptcndhcmUuY29tL2FydGljbGVzLzIwMDkvdXJpX3JlZ2V4cC9VUklfcmVnZXguaHRtbCArIG9wdGlvbmFsIHByb3RvY29sICsgcmVxdWlyZWQgXCIuXCJcbiAgICByZXR1cm4gTk9UX1VSSV9GUkFHTUVOVC50ZXN0KHN0cikgJiYgVVJJLnRlc3Qoc3RyKTtcbn1cbmNvbnN0IEJZVEUgPSAvXig/OltBLVphLXowLTkrL117NH0pKig/OltBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PSk/JC9nbTtcbmZ1bmN0aW9uIGJ5dGUoc3RyKSB7XG4gICAgQllURS5sYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiBCWVRFLnRlc3Qoc3RyKTtcbn1cbmNvbnN0IE1JTl9JTlQzMiA9IC0oMiAqKiAzMSk7XG5jb25zdCBNQVhfSU5UMzIgPSAyICoqIDMxIC0gMTtcbmZ1bmN0aW9uIHZhbGlkYXRlSW50MzIodmFsdWUpIHtcbiAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgJiYgdmFsdWUgPD0gTUFYX0lOVDMyICYmIHZhbHVlID49IE1JTl9JTlQzMjtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlSW50NjQodmFsdWUpIHtcbiAgICAvLyBKU09OIGFuZCBqYXZhc2NyaXB0IG1heCBJbnQgaXMgMioqNTMsIHNvIGFueSBpbnQgdGhhdCBwYXNzZXMgaXNJbnRlZ2VyIGlzIHZhbGlkIGZvciBJbnQ2NFxuICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyKCkge1xuICAgIHJldHVybiB0cnVlO1xufVxuY29uc3QgWl9BTkNIT1IgPSAvW15cXFxcXVxcXFxaLztcbmZ1bmN0aW9uIHJlZ2V4KHN0cikge1xuICAgIGlmIChaX0FOQ0hPUi50ZXN0KHN0cikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBuZXcgUmVnRXhwKHN0cik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZm9ybWF0TGltaXREZWZpbml0aW9uID0gdm9pZCAwO1xuY29uc3QgYWp2XzEgPSByZXF1aXJlKFwiYWp2XCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcImFqdi9kaXN0L2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IG9wcyA9IGNvZGVnZW5fMS5vcGVyYXRvcnM7XG5jb25zdCBLV0RzID0ge1xuICAgIGZvcm1hdE1heGltdW06IHsgb2tTdHI6IFwiPD1cIiwgb2s6IG9wcy5MVEUsIGZhaWw6IG9wcy5HVCB9LFxuICAgIGZvcm1hdE1pbmltdW06IHsgb2tTdHI6IFwiPj1cIiwgb2s6IG9wcy5HVEUsIGZhaWw6IG9wcy5MVCB9LFxuICAgIGZvcm1hdEV4Y2x1c2l2ZU1heGltdW06IHsgb2tTdHI6IFwiPFwiLCBvazogb3BzLkxULCBmYWlsOiBvcHMuR1RFIH0sXG4gICAgZm9ybWF0RXhjbHVzaXZlTWluaW11bTogeyBva1N0cjogXCI+XCIsIG9rOiBvcHMuR1QsIGZhaWw6IG9wcy5MVEUgfSxcbn07XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pID0+IGNvZGVnZW5fMS5zdHIgYHNob3VsZCBiZSAke0tXRHNba2V5d29yZF0ub2tTdHJ9ICR7c2NoZW1hQ29kZX1gLFxuICAgIHBhcmFtczogKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuXyBge2NvbXBhcmlzb246ICR7S1dEc1trZXl3b3JkXS5va1N0cn0sIGxpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuZXhwb3J0cy5mb3JtYXRMaW1pdERlZmluaXRpb24gPSB7XG4gICAga2V5d29yZDogT2JqZWN0LmtleXMoS1dEcyksXG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWFDb2RlLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgICAgICBpZiAoIW9wdHMudmFsaWRhdGVGb3JtYXRzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBmQ3h0ID0gbmV3IGFqdl8xLktleXdvcmRDeHQoaXQsIHNlbGYuUlVMRVMuYWxsLmZvcm1hdC5kZWZpbml0aW9uLCBcImZvcm1hdFwiKTtcbiAgICAgICAgaWYgKGZDeHQuJGRhdGEpXG4gICAgICAgICAgICB2YWxpZGF0ZSREYXRhRm9ybWF0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHZhbGlkYXRlRm9ybWF0KCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlJERhdGFGb3JtYXQoKSB7XG4gICAgICAgICAgICBjb25zdCBmbXRzID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAgICAgICAgICByZWY6IHNlbGYuZm9ybWF0cyxcbiAgICAgICAgICAgICAgICBjb2RlOiBvcHRzLmNvZGUuZm9ybWF0cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZm10ID0gZ2VuLmNvbnN0KFwiZm10XCIsIGNvZGVnZW5fMS5fIGAke2ZtdHN9WyR7ZkN4dC5zY2hlbWFDb2RlfV1gKTtcbiAgICAgICAgICAgIGN4dC5mYWlsJGRhdGEoY29kZWdlbl8xLm9yKGNvZGVnZW5fMS5fIGB0eXBlb2YgJHtmbXR9ICE9IFwib2JqZWN0XCJgLCBjb2RlZ2VuXzEuXyBgJHtmbXR9IGluc3RhbmNlb2YgUmVnRXhwYCwgY29kZWdlbl8xLl8gYHR5cGVvZiAke2ZtdH0uY29tcGFyZSAhPSBcImZ1bmN0aW9uXCJgLCBjb21wYXJlQ29kZShmbXQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoKSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXQgPSBmQ3h0LnNjaGVtYTtcbiAgICAgICAgICAgIGNvbnN0IGZtdERlZiA9IHNlbGYuZm9ybWF0c1tmb3JtYXRdO1xuICAgICAgICAgICAgaWYgKCFmbXREZWYgfHwgZm10RGVmID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm10RGVmICE9IFwib2JqZWN0XCIgfHxcbiAgICAgICAgICAgICAgICBmbXREZWYgaW5zdGFuY2VvZiBSZWdFeHAgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgZm10RGVmLmNvbXBhcmUgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7a2V5d29yZH1cIjogZm9ybWF0IFwiJHtmb3JtYXR9XCIgZG9lcyBub3QgZGVmaW5lIFwiY29tcGFyZVwiIGZ1bmN0aW9uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmbXQgPSBnZW4uc2NvcGVWYWx1ZShcImZvcm1hdHNcIiwge1xuICAgICAgICAgICAgICAgIGtleTogZm9ybWF0LFxuICAgICAgICAgICAgICAgIHJlZjogZm10RGVmLFxuICAgICAgICAgICAgICAgIGNvZGU6IG9wdHMuY29kZS5mb3JtYXRzID8gY29kZWdlbl8xLl8gYCR7b3B0cy5jb2RlLmZvcm1hdHN9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkoZm9ybWF0KX1gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjeHQuZmFpbCRkYXRhKGNvbXBhcmVDb2RlKGZtdCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvbXBhcmVDb2RlKGZtdCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5fIGAke2ZtdH0uY29tcGFyZSgke2RhdGF9LCAke3NjaGVtYUNvZGV9KSAke0tXRHNba2V5d29yZF0uZmFpbH0gMGA7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1wiZm9ybWF0XCJdLFxufTtcbmNvbnN0IGZvcm1hdExpbWl0UGx1Z2luID0gKGFqdikgPT4ge1xuICAgIGFqdi5hZGRLZXl3b3JkKGV4cG9ydHMuZm9ybWF0TGltaXREZWZpbml0aW9uKTtcbiAgICByZXR1cm4gYWp2O1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZvcm1hdExpbWl0UGx1Z2luO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBmb3JtYXRzXzEgPSByZXF1aXJlKFwiLi9mb3JtYXRzXCIpO1xuY29uc3QgbGltaXRfMSA9IHJlcXVpcmUoXCIuL2xpbWl0XCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcImFqdi9kaXN0L2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGZ1bGxOYW1lID0gbmV3IGNvZGVnZW5fMS5OYW1lKFwiZnVsbEZvcm1hdHNcIik7XG5jb25zdCBmYXN0TmFtZSA9IG5ldyBjb2RlZ2VuXzEuTmFtZShcImZhc3RGb3JtYXRzXCIpO1xuY29uc3QgZm9ybWF0c1BsdWdpbiA9IChhanYsIG9wdHMgPSB7IGtleXdvcmRzOiB0cnVlIH0pID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgICAgICBhZGRGb3JtYXRzKGFqdiwgb3B0cywgZm9ybWF0c18xLmZ1bGxGb3JtYXRzLCBmdWxsTmFtZSk7XG4gICAgICAgIHJldHVybiBhanY7XG4gICAgfVxuICAgIGNvbnN0IFtmb3JtYXRzLCBleHBvcnROYW1lXSA9IG9wdHMubW9kZSA9PT0gXCJmYXN0XCIgPyBbZm9ybWF0c18xLmZhc3RGb3JtYXRzLCBmYXN0TmFtZV0gOiBbZm9ybWF0c18xLmZ1bGxGb3JtYXRzLCBmdWxsTmFtZV07XG4gICAgY29uc3QgbGlzdCA9IG9wdHMuZm9ybWF0cyB8fCBmb3JtYXRzXzEuZm9ybWF0TmFtZXM7XG4gICAgYWRkRm9ybWF0cyhhanYsIGxpc3QsIGZvcm1hdHMsIGV4cG9ydE5hbWUpO1xuICAgIGlmIChvcHRzLmtleXdvcmRzKVxuICAgICAgICBsaW1pdF8xLmRlZmF1bHQoYWp2KTtcbiAgICByZXR1cm4gYWp2O1xufTtcbmZvcm1hdHNQbHVnaW4uZ2V0ID0gKG5hbWUsIG1vZGUgPSBcImZ1bGxcIikgPT4ge1xuICAgIGNvbnN0IGZvcm1hdHMgPSBtb2RlID09PSBcImZhc3RcIiA/IGZvcm1hdHNfMS5mYXN0Rm9ybWF0cyA6IGZvcm1hdHNfMS5mdWxsRm9ybWF0cztcbiAgICBjb25zdCBmID0gZm9ybWF0c1tuYW1lXTtcbiAgICBpZiAoIWYpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBmb3JtYXQgXCIke25hbWV9XCJgKTtcbiAgICByZXR1cm4gZjtcbn07XG5mdW5jdGlvbiBhZGRGb3JtYXRzKGFqdiwgbGlzdCwgZnMsIGV4cG9ydE5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIF9iO1xuICAgIChfYSA9IChfYiA9IGFqdi5vcHRzLmNvZGUpLmZvcm1hdHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYi5mb3JtYXRzID0gY29kZWdlbl8xLl8gYHJlcXVpcmUoXCJhanYtZm9ybWF0cy9kaXN0L2Zvcm1hdHNcIikuJHtleHBvcnROYW1lfWApO1xuICAgIGZvciAoY29uc3QgZiBvZiBsaXN0KVxuICAgICAgICBhanYuYWRkRm9ybWF0KGYsIGZzW2ZdKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZvcm1hdHNQbHVnaW47XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBmb3JtYXRzUGx1Z2luO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjb3B5UHJvcGVydHkgPSAodG8sIGZyb20sIHByb3BlcnR5LCBpZ25vcmVOb25Db25maWd1cmFibGUpID0+IHtcblx0Ly8gYEZ1bmN0aW9uI2xlbmd0aGAgc2hvdWxkIHJlZmxlY3QgdGhlIHBhcmFtZXRlcnMgb2YgYHRvYCBub3QgYGZyb21gIHNpbmNlIHdlIGtlZXAgaXRzIGJvZHkuXG5cdC8vIGBGdW5jdGlvbiNwcm90b3R5cGVgIGlzIG5vbi13cml0YWJsZSBhbmQgbm9uLWNvbmZpZ3VyYWJsZSBzbyBjYW4gbmV2ZXIgYmUgbW9kaWZpZWQuXG5cdGlmIChwcm9wZXJ0eSA9PT0gJ2xlbmd0aCcgfHwgcHJvcGVydHkgPT09ICdwcm90b3R5cGUnKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gYEZ1bmN0aW9uI2FyZ3VtZW50c2AgYW5kIGBGdW5jdGlvbiNjYWxsZXJgIHNob3VsZCBub3QgYmUgY29waWVkLiBUaGV5IHdlcmUgcmVwb3J0ZWQgdG8gYmUgcHJlc2VudCBpbiBgUmVmbGVjdC5vd25LZXlzYCBmb3Igc29tZSBkZXZpY2VzIGluIFJlYWN0IE5hdGl2ZSAoIzQxKSwgc28gd2UgZXhwbGljaXRseSBpZ25vcmUgdGhlbSBoZXJlLlxuXHRpZiAocHJvcGVydHkgPT09ICdhcmd1bWVudHMnIHx8IHByb3BlcnR5ID09PSAnY2FsbGVyJykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IHRvRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG8sIHByb3BlcnR5KTtcblx0Y29uc3QgZnJvbURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGZyb20sIHByb3BlcnR5KTtcblxuXHRpZiAoIWNhbkNvcHlQcm9wZXJ0eSh0b0Rlc2NyaXB0b3IsIGZyb21EZXNjcmlwdG9yKSAmJiBpZ25vcmVOb25Db25maWd1cmFibGUpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkodG8sIHByb3BlcnR5LCBmcm9tRGVzY3JpcHRvcik7XG59O1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5KClgIHRocm93cyBpZiB0aGUgcHJvcGVydHkgZXhpc3RzLCBpcyBub3QgY29uZmlndXJhYmxlIGFuZCBlaXRoZXI6XG4vLyAgLSBvbmUgaXRzIGRlc2NyaXB0b3JzIGlzIGNoYW5nZWRcbi8vICAtIGl0IGlzIG5vbi13cml0YWJsZSBhbmQgaXRzIHZhbHVlIGlzIGNoYW5nZWRcbmNvbnN0IGNhbkNvcHlQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0b0Rlc2NyaXB0b3IsIGZyb21EZXNjcmlwdG9yKSB7XG5cdHJldHVybiB0b0Rlc2NyaXB0b3IgPT09IHVuZGVmaW5lZCB8fCB0b0Rlc2NyaXB0b3IuY29uZmlndXJhYmxlIHx8IChcblx0XHR0b0Rlc2NyaXB0b3Iud3JpdGFibGUgPT09IGZyb21EZXNjcmlwdG9yLndyaXRhYmxlICYmXG5cdFx0dG9EZXNjcmlwdG9yLmVudW1lcmFibGUgPT09IGZyb21EZXNjcmlwdG9yLmVudW1lcmFibGUgJiZcblx0XHR0b0Rlc2NyaXB0b3IuY29uZmlndXJhYmxlID09PSBmcm9tRGVzY3JpcHRvci5jb25maWd1cmFibGUgJiZcblx0XHQodG9EZXNjcmlwdG9yLndyaXRhYmxlIHx8IHRvRGVzY3JpcHRvci52YWx1ZSA9PT0gZnJvbURlc2NyaXB0b3IudmFsdWUpXG5cdCk7XG59O1xuXG5jb25zdCBjaGFuZ2VQcm90b3R5cGUgPSAodG8sIGZyb20pID0+IHtcblx0Y29uc3QgZnJvbVByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihmcm9tKTtcblx0aWYgKGZyb21Qcm90b3R5cGUgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0bykpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRPYmplY3Quc2V0UHJvdG90eXBlT2YodG8sIGZyb21Qcm90b3R5cGUpO1xufTtcblxuY29uc3Qgd3JhcHBlZFRvU3RyaW5nID0gKHdpdGhOYW1lLCBmcm9tQm9keSkgPT4gYC8qIFdyYXBwZWQgJHt3aXRoTmFtZX0qL1xcbiR7ZnJvbUJvZHl9YDtcblxuY29uc3QgdG9TdHJpbmdEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihGdW5jdGlvbi5wcm90b3R5cGUsICd0b1N0cmluZycpO1xuY29uc3QgdG9TdHJpbmdOYW1lID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcsICduYW1lJyk7XG5cbi8vIFdlIGNhbGwgYGZyb20udG9TdHJpbmcoKWAgZWFybHkgKG5vdCBsYXppbHkpIHRvIGVuc3VyZSBgZnJvbWAgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuLy8gV2UgdXNlIGBiaW5kKClgIGluc3RlYWQgb2YgYSBjbG9zdXJlIGZvciB0aGUgc2FtZSByZWFzb24uXG4vLyBDYWxsaW5nIGBmcm9tLnRvU3RyaW5nKClgIGVhcmx5IGFsc28gYWxsb3dzIGNhY2hpbmcgaXQgaW4gY2FzZSBgdG8udG9TdHJpbmcoKWAgaXMgY2FsbGVkIHNldmVyYWwgdGltZXMuXG5jb25zdCBjaGFuZ2VUb1N0cmluZyA9ICh0bywgZnJvbSwgbmFtZSkgPT4ge1xuXHRjb25zdCB3aXRoTmFtZSA9IG5hbWUgPT09ICcnID8gJycgOiBgd2l0aCAke25hbWUudHJpbSgpfSgpIGA7XG5cdGNvbnN0IG5ld1RvU3RyaW5nID0gd3JhcHBlZFRvU3RyaW5nLmJpbmQobnVsbCwgd2l0aE5hbWUsIGZyb20udG9TdHJpbmcoKSk7XG5cdC8vIEVuc3VyZSBgdG8udG9TdHJpbmcudG9TdHJpbmdgIGlzIG5vbi1lbnVtZXJhYmxlIGFuZCBoYXMgdGhlIHNhbWUgYHNhbWVgXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdUb1N0cmluZywgJ25hbWUnLCB0b1N0cmluZ05hbWUpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkodG8sICd0b1N0cmluZycsIHsuLi50b1N0cmluZ0Rlc2NyaXB0b3IsIHZhbHVlOiBuZXdUb1N0cmluZ30pO1xufTtcblxuY29uc3QgbWltaWNGbiA9ICh0bywgZnJvbSwge2lnbm9yZU5vbkNvbmZpZ3VyYWJsZSA9IGZhbHNlfSA9IHt9KSA9PiB7XG5cdGNvbnN0IHtuYW1lfSA9IHRvO1xuXG5cdGZvciAoY29uc3QgcHJvcGVydHkgb2YgUmVmbGVjdC5vd25LZXlzKGZyb20pKSB7XG5cdFx0Y29weVByb3BlcnR5KHRvLCBmcm9tLCBwcm9wZXJ0eSwgaWdub3JlTm9uQ29uZmlndXJhYmxlKTtcblx0fVxuXG5cdGNoYW5nZVByb3RvdHlwZSh0bywgZnJvbSk7XG5cdGNoYW5nZVRvU3RyaW5nKHRvLCBmcm9tLCBuYW1lKTtcblxuXHRyZXR1cm4gdG87XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1pbWljRm47XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBtaW1pY0ZuID0gcmVxdWlyZSgnbWltaWMtZm4nKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoaW5wdXRGdW5jdGlvbiwgb3B0aW9ucyA9IHt9KSA9PiB7XG5cdGlmICh0eXBlb2YgaW5wdXRGdW5jdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIHRoZSBmaXJzdCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uLCBnb3QgXFxgJHt0eXBlb2YgaW5wdXRGdW5jdGlvbn1cXGBgKTtcblx0fVxuXG5cdGNvbnN0IHtcblx0XHR3YWl0ID0gMCxcblx0XHRiZWZvcmUgPSBmYWxzZSxcblx0XHRhZnRlciA9IHRydWVcblx0fSA9IG9wdGlvbnM7XG5cblx0aWYgKCFiZWZvcmUgJiYgIWFmdGVyKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdCb3RoIGBiZWZvcmVgIGFuZCBgYWZ0ZXJgIGFyZSBmYWxzZSwgZnVuY3Rpb24gd291bGRuXFwndCBiZSBjYWxsZWQuJyk7XG5cdH1cblxuXHRsZXQgdGltZW91dDtcblx0bGV0IHJlc3VsdDtcblxuXHRjb25zdCBkZWJvdW5jZWRGdW5jdGlvbiA9IGZ1bmN0aW9uICguLi5hcmd1bWVudHNfKSB7XG5cdFx0Y29uc3QgY29udGV4dCA9IHRoaXM7XG5cblx0XHRjb25zdCBsYXRlciA9ICgpID0+IHtcblx0XHRcdHRpbWVvdXQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmIChhZnRlcikge1xuXHRcdFx0XHRyZXN1bHQgPSBpbnB1dEZ1bmN0aW9uLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50c18pO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRjb25zdCBzaG91bGRDYWxsTm93ID0gYmVmb3JlICYmICF0aW1lb3V0O1xuXHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHR0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG5cblx0XHRpZiAoc2hvdWxkQ2FsbE5vdykge1xuXHRcdFx0cmVzdWx0ID0gaW5wdXRGdW5jdGlvbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHNfKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdG1pbWljRm4oZGVib3VuY2VkRnVuY3Rpb24sIGlucHV0RnVuY3Rpb24pO1xuXG5cdGRlYm91bmNlZEZ1bmN0aW9uLmNhbmNlbCA9ICgpID0+IHtcblx0XHRpZiAodGltZW91dCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHRcdFx0dGltZW91dCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIGRlYm91bmNlZEZ1bmN0aW9uO1xufTtcbiIsIi8vIE5vdGU6IHRoaXMgaXMgdGhlIHNlbXZlci5vcmcgdmVyc2lvbiBvZiB0aGUgc3BlYyB0aGF0IGl0IGltcGxlbWVudHNcbi8vIE5vdCBuZWNlc3NhcmlseSB0aGUgcGFja2FnZSB2ZXJzaW9uIG9mIHRoaXMgY29kZS5cbmNvbnN0IFNFTVZFUl9TUEVDX1ZFUlNJT04gPSAnMi4wLjAnXG5cbmNvbnN0IE1BWF9MRU5HVEggPSAyNTZcbmNvbnN0IE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyA5MDA3MTk5MjU0NzQwOTkxXG5cbi8vIE1heCBzYWZlIHNlZ21lbnQgbGVuZ3RoIGZvciBjb2VyY2lvbi5cbmNvbnN0IE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggPSAxNlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgU0VNVkVSX1NQRUNfVkVSU0lPTixcbiAgTUFYX0xFTkdUSCxcbiAgTUFYX1NBRkVfSU5URUdFUixcbiAgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSFxufVxuIiwiY29uc3QgZGVidWcgPSAoXG4gIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICBwcm9jZXNzLmVudiAmJlxuICBwcm9jZXNzLmVudi5OT0RFX0RFQlVHICYmXG4gIC9cXGJzZW12ZXJcXGIvaS50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcpXG4pID8gKC4uLmFyZ3MpID0+IGNvbnNvbGUuZXJyb3IoJ1NFTVZFUicsIC4uLmFyZ3MpXG4gIDogKCkgPT4ge31cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJ1Z1xuIiwiY29uc3QgeyBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4vZGVidWcnKVxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge31cblxuLy8gVGhlIGFjdHVhbCByZWdleHBzIGdvIG9uIGV4cG9ydHMucmVcbmNvbnN0IHJlID0gZXhwb3J0cy5yZSA9IFtdXG5jb25zdCBzcmMgPSBleHBvcnRzLnNyYyA9IFtdXG5jb25zdCB0ID0gZXhwb3J0cy50ID0ge31cbmxldCBSID0gMFxuXG5jb25zdCBjcmVhdGVUb2tlbiA9IChuYW1lLCB2YWx1ZSwgaXNHbG9iYWwpID0+IHtcbiAgY29uc3QgaW5kZXggPSBSKytcbiAgZGVidWcoaW5kZXgsIHZhbHVlKVxuICB0W25hbWVdID0gaW5kZXhcbiAgc3JjW2luZGV4XSA9IHZhbHVlXG4gIHJlW2luZGV4XSA9IG5ldyBSZWdFeHAodmFsdWUsIGlzR2xvYmFsID8gJ2cnIDogdW5kZWZpbmVkKVxufVxuXG4vLyBUaGUgZm9sbG93aW5nIFJlZ3VsYXIgRXhwcmVzc2lvbnMgY2FuIGJlIHVzZWQgZm9yIHRva2VuaXppbmcsXG4vLyB2YWxpZGF0aW5nLCBhbmQgcGFyc2luZyBTZW1WZXIgdmVyc2lvbiBzdHJpbmdzLlxuXG4vLyAjIyBOdW1lcmljIElkZW50aWZpZXJcbi8vIEEgc2luZ2xlIGAwYCwgb3IgYSBub24temVybyBkaWdpdCBmb2xsb3dlZCBieSB6ZXJvIG9yIG1vcmUgZGlnaXRzLlxuXG5jcmVhdGVUb2tlbignTlVNRVJJQ0lERU5USUZJRVInLCAnMHxbMS05XVxcXFxkKicpXG5jcmVhdGVUb2tlbignTlVNRVJJQ0lERU5USUZJRVJMT09TRScsICdbMC05XSsnKVxuXG4vLyAjIyBOb24tbnVtZXJpYyBJZGVudGlmaWVyXG4vLyBaZXJvIG9yIG1vcmUgZGlnaXRzLCBmb2xsb3dlZCBieSBhIGxldHRlciBvciBoeXBoZW4sIGFuZCB0aGVuIHplcm8gb3Jcbi8vIG1vcmUgbGV0dGVycywgZGlnaXRzLCBvciBoeXBoZW5zLlxuXG5jcmVhdGVUb2tlbignTk9OTlVNRVJJQ0lERU5USUZJRVInLCAnXFxcXGQqW2EtekEtWi1dW2EtekEtWjAtOS1dKicpXG5cbi8vICMjIE1haW4gVmVyc2lvblxuLy8gVGhyZWUgZG90LXNlcGFyYXRlZCBudW1lcmljIGlkZW50aWZpZXJzLlxuXG5jcmVhdGVUb2tlbignTUFJTlZFUlNJT04nLCBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pYClcblxuY3JlYXRlVG9rZW4oJ01BSU5WRVJTSU9OTE9PU0UnLCBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19KWApXG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb24gSWRlbnRpZmllclxuLy8gQSBudW1lcmljIGlkZW50aWZpZXIsIG9yIGEgbm9uLW51bWVyaWMgaWRlbnRpZmllci5cblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0VJREVOVElGSUVSJywgYCg/OiR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdXG59fCR7c3JjW3QuTk9OTlVNRVJJQ0lERU5USUZJRVJdfSlgKVxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRScsIGAoPzoke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdXG59fCR7c3JjW3QuTk9OTlVNRVJJQ0lERU5USUZJRVJdfSlgKVxuXG4vLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uXG4vLyBIeXBoZW4sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIGRvdC1zZXBhcmF0ZWQgcHJlLXJlbGVhc2UgdmVyc2lvblxuLy8gaWRlbnRpZmllcnMuXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFJywgYCg/Oi0oJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUl1cbn0oPzpcXFxcLiR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJdfSkqKSlgKVxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRUxPT1NFJywgYCg/Oi0/KCR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV1cbn0oPzpcXFxcLiR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV19KSopKWApXG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhIElkZW50aWZpZXJcbi8vIEFueSBjb21iaW5hdGlvbiBvZiBkaWdpdHMsIGxldHRlcnMsIG9yIGh5cGhlbnMuXG5cbmNyZWF0ZVRva2VuKCdCVUlMRElERU5USUZJRVInLCAnWzAtOUEtWmEtei1dKycpXG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhXG4vLyBQbHVzIHNpZ24sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIHBlcmlvZC1zZXBhcmF0ZWQgYnVpbGQgbWV0YWRhdGFcbi8vIGlkZW50aWZpZXJzLlxuXG5jcmVhdGVUb2tlbignQlVJTEQnLCBgKD86XFxcXCsoJHtzcmNbdC5CVUlMRElERU5USUZJRVJdXG59KD86XFxcXC4ke3NyY1t0LkJVSUxESURFTlRJRklFUl19KSopKWApXG5cbi8vICMjIEZ1bGwgVmVyc2lvbiBTdHJpbmdcbi8vIEEgbWFpbiB2ZXJzaW9uLCBmb2xsb3dlZCBvcHRpb25hbGx5IGJ5IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiBhbmRcbi8vIGJ1aWxkIG1ldGFkYXRhLlxuXG4vLyBOb3RlIHRoYXQgdGhlIG9ubHkgbWFqb3IsIG1pbm9yLCBwYXRjaCwgYW5kIHByZS1yZWxlYXNlIHNlY3Rpb25zIG9mXG4vLyB0aGUgdmVyc2lvbiBzdHJpbmcgYXJlIGNhcHR1cmluZyBncm91cHMuICBUaGUgYnVpbGQgbWV0YWRhdGEgaXMgbm90IGFcbi8vIGNhcHR1cmluZyBncm91cCwgYmVjYXVzZSBpdCBzaG91bGQgbm90IGV2ZXIgYmUgdXNlZCBpbiB2ZXJzaW9uXG4vLyBjb21wYXJpc29uLlxuXG5jcmVhdGVUb2tlbignRlVMTFBMQUlOJywgYHY/JHtzcmNbdC5NQUlOVkVSU0lPTl1cbn0ke3NyY1t0LlBSRVJFTEVBU0VdfT8ke1xuICBzcmNbdC5CVUlMRF19P2ApXG5cbmNyZWF0ZVRva2VuKCdGVUxMJywgYF4ke3NyY1t0LkZVTExQTEFJTl19JGApXG5cbi8vIGxpa2UgZnVsbCwgYnV0IGFsbG93cyB2MS4yLjMgYW5kID0xLjIuMywgd2hpY2ggcGVvcGxlIGRvIHNvbWV0aW1lcy5cbi8vIGFsc28sIDEuMC4wYWxwaGExIChwcmVyZWxlYXNlIHdpdGhvdXQgdGhlIGh5cGhlbikgd2hpY2ggaXMgcHJldHR5XG4vLyBjb21tb24gaW4gdGhlIG5wbSByZWdpc3RyeS5cbmNyZWF0ZVRva2VuKCdMT09TRVBMQUlOJywgYFt2PVxcXFxzXSoke3NyY1t0Lk1BSU5WRVJTSU9OTE9PU0VdXG59JHtzcmNbdC5QUkVSRUxFQVNFTE9PU0VdfT8ke1xuICBzcmNbdC5CVUlMRF19P2ApXG5cbmNyZWF0ZVRva2VuKCdMT09TRScsIGBeJHtzcmNbdC5MT09TRVBMQUlOXX0kYClcblxuY3JlYXRlVG9rZW4oJ0dUTFQnLCAnKCg/Ojx8Pik/PT8pJylcblxuLy8gU29tZXRoaW5nIGxpa2UgXCIyLipcIiBvciBcIjEuMi54XCIuXG4vLyBOb3RlIHRoYXQgXCJ4LnhcIiBpcyBhIHZhbGlkIHhSYW5nZSBpZGVudGlmZXIsIG1lYW5pbmcgXCJhbnkgdmVyc2lvblwiXG4vLyBPbmx5IHRoZSBmaXJzdCBpdGVtIGlzIHN0cmljdGx5IHJlcXVpcmVkLlxuY3JlYXRlVG9rZW4oJ1hSQU5HRUlERU5USUZJRVJMT09TRScsIGAke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfXx4fFh8XFxcXCpgKVxuY3JlYXRlVG9rZW4oJ1hSQU5HRUlERU5USUZJRVInLCBgJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19fHh8WHxcXFxcKmApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0VQTEFJTicsIGBbdj1cXFxcc10qKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJdfSlgICtcbiAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYCg/OiR7c3JjW3QuUFJFUkVMRUFTRV19KT8ke1xuICAgICAgICAgICAgICAgICAgICAgc3JjW3QuQlVJTERdfT9gICtcbiAgICAgICAgICAgICAgICAgICBgKT8pP2ApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0VQTEFJTkxPT1NFJywgYFt2PVxcXFxzXSooJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKD86JHtzcmNbdC5QUkVSRUxFQVNFTE9PU0VdfSk/JHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjW3QuQlVJTERdfT9gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGApPyk/YClcblxuY3JlYXRlVG9rZW4oJ1hSQU5HRScsIGBeJHtzcmNbdC5HVExUXX1cXFxccyoke3NyY1t0LlhSQU5HRVBMQUlOXX0kYClcbmNyZWF0ZVRva2VuKCdYUkFOR0VMT09TRScsIGBeJHtzcmNbdC5HVExUXX1cXFxccyoke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKVxuXG4vLyBDb2VyY2lvbi5cbi8vIEV4dHJhY3QgYW55dGhpbmcgdGhhdCBjb3VsZCBjb25jZWl2YWJseSBiZSBhIHBhcnQgb2YgYSB2YWxpZCBzZW12ZXJcbmNyZWF0ZVRva2VuKCdDT0VSQ0UnLCBgJHsnKF58W15cXFxcZF0pJyArXG4gICAgICAgICAgICAgICcoXFxcXGR7MSwnfSR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KWAgK1xuICAgICAgICAgICAgICBgKD86XFxcXC4oXFxcXGR7MSwke01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEh9fSkpP2AgK1xuICAgICAgICAgICAgICBgKD86XFxcXC4oXFxcXGR7MSwke01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEh9fSkpP2AgK1xuICAgICAgICAgICAgICBgKD86JHxbXlxcXFxkXSlgKVxuY3JlYXRlVG9rZW4oJ0NPRVJDRVJUTCcsIHNyY1t0LkNPRVJDRV0sIHRydWUpXG5cbi8vIFRpbGRlIHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJyZWFzb25hYmx5IGF0IG9yIGdyZWF0ZXIgdGhhblwiXG5jcmVhdGVUb2tlbignTE9ORVRJTERFJywgJyg/On4+PyknKVxuXG5jcmVhdGVUb2tlbignVElMREVUUklNJywgYChcXFxccyopJHtzcmNbdC5MT05FVElMREVdfVxcXFxzK2AsIHRydWUpXG5leHBvcnRzLnRpbGRlVHJpbVJlcGxhY2UgPSAnJDF+J1xuXG5jcmVhdGVUb2tlbignVElMREUnLCBgXiR7c3JjW3QuTE9ORVRJTERFXX0ke3NyY1t0LlhSQU5HRVBMQUlOXX0kYClcbmNyZWF0ZVRva2VuKCdUSUxERUxPT1NFJywgYF4ke3NyY1t0LkxPTkVUSUxERV19JHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQ2FyZXQgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcImF0IGxlYXN0IGFuZCBiYWNrd2FyZHMgY29tcGF0aWJsZSB3aXRoXCJcbmNyZWF0ZVRva2VuKCdMT05FQ0FSRVQnLCAnKD86XFxcXF4pJylcblxuY3JlYXRlVG9rZW4oJ0NBUkVUVFJJTScsIGAoXFxcXHMqKSR7c3JjW3QuTE9ORUNBUkVUXX1cXFxccytgLCB0cnVlKVxuZXhwb3J0cy5jYXJldFRyaW1SZXBsYWNlID0gJyQxXidcblxuY3JlYXRlVG9rZW4oJ0NBUkVUJywgYF4ke3NyY1t0LkxPTkVDQVJFVF19JHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignQ0FSRVRMT09TRScsIGBeJHtzcmNbdC5MT05FQ0FSRVRdfSR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19JGApXG5cbi8vIEEgc2ltcGxlIGd0L2x0L2VxIHRoaW5nLCBvciBqdXN0IFwiXCIgdG8gaW5kaWNhdGUgXCJhbnkgdmVyc2lvblwiXG5jcmVhdGVUb2tlbignQ09NUEFSQVRPUkxPT1NFJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKigke3NyY1t0LkxPT1NFUExBSU5dfSkkfF4kYClcbmNyZWF0ZVRva2VuKCdDT01QQVJBVE9SJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKigke3NyY1t0LkZVTExQTEFJTl19KSR8XiRgKVxuXG4vLyBBbiBleHByZXNzaW9uIHRvIHN0cmlwIGFueSB3aGl0ZXNwYWNlIGJldHdlZW4gdGhlIGd0bHQgYW5kIHRoZSB0aGluZ1xuLy8gaXQgbW9kaWZpZXMsIHNvIHRoYXQgYD4gMS4yLjNgID09PiBgPjEuMi4zYFxuY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1JUUklNJywgYChcXFxccyopJHtzcmNbdC5HVExUXVxufVxcXFxzKigke3NyY1t0LkxPT1NFUExBSU5dfXwke3NyY1t0LlhSQU5HRVBMQUlOXX0pYCwgdHJ1ZSlcbmV4cG9ydHMuY29tcGFyYXRvclRyaW1SZXBsYWNlID0gJyQxJDIkMydcblxuLy8gU29tZXRoaW5nIGxpa2UgYDEuMi4zIC0gMS4yLjRgXG4vLyBOb3RlIHRoYXQgdGhlc2UgYWxsIHVzZSB0aGUgbG9vc2UgZm9ybSwgYmVjYXVzZSB0aGV5J2xsIGJlXG4vLyBjaGVja2VkIGFnYWluc3QgZWl0aGVyIHRoZSBzdHJpY3Qgb3IgbG9vc2UgY29tcGFyYXRvciBmb3JtXG4vLyBsYXRlci5cbmNyZWF0ZVRva2VuKCdIWVBIRU5SQU5HRScsIGBeXFxcXHMqKCR7c3JjW3QuWFJBTkdFUExBSU5dfSlgICtcbiAgICAgICAgICAgICAgICAgICBgXFxcXHMrLVxcXFxzK2AgK1xuICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5YUkFOR0VQTEFJTl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGBcXFxccyokYClcblxuY3JlYXRlVG9rZW4oJ0hZUEhFTlJBTkdFTE9PU0UnLCBgXlxcXFxzKigke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcXFxccystXFxcXHMrYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYFxcXFxzKiRgKVxuXG4vLyBTdGFyIHJhbmdlcyBiYXNpY2FsbHkganVzdCBhbGxvdyBhbnl0aGluZyBhdCBhbGwuXG5jcmVhdGVUb2tlbignU1RBUicsICcoPHw+KT89P1xcXFxzKlxcXFwqJylcbi8vID49MC4wLjAgaXMgbGlrZSBhIHN0YXJcbmNyZWF0ZVRva2VuKCdHVEUwJywgJ15cXFxccyo+PVxcXFxzKjBcXC4wXFwuMFxcXFxzKiQnKVxuY3JlYXRlVG9rZW4oJ0dURTBQUkUnLCAnXlxcXFxzKj49XFxcXHMqMFxcLjBcXC4wLTBcXFxccyokJylcbiIsIi8vIHBhcnNlIG91dCBqdXN0IHRoZSBvcHRpb25zIHdlIGNhcmUgYWJvdXQgc28gd2UgYWx3YXlzIGdldCBhIGNvbnNpc3RlbnRcbi8vIG9iaiB3aXRoIGtleXMgaW4gYSBjb25zaXN0ZW50IG9yZGVyLlxuY29uc3Qgb3B0cyA9IFsnaW5jbHVkZVByZXJlbGVhc2UnLCAnbG9vc2UnLCAncnRsJ11cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IG9wdGlvbnMgPT5cbiAgIW9wdGlvbnMgPyB7fVxuICA6IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyA/IHsgbG9vc2U6IHRydWUgfVxuICA6IG9wdHMuZmlsdGVyKGsgPT4gb3B0aW9uc1trXSkucmVkdWNlKChvcHRpb25zLCBrKSA9PiB7XG4gICAgb3B0aW9uc1trXSA9IHRydWVcbiAgICByZXR1cm4gb3B0aW9uc1xuICB9LCB7fSlcbm1vZHVsZS5leHBvcnRzID0gcGFyc2VPcHRpb25zXG4iLCJjb25zdCBudW1lcmljID0gL15bMC05XSskL1xuY29uc3QgY29tcGFyZUlkZW50aWZpZXJzID0gKGEsIGIpID0+IHtcbiAgY29uc3QgYW51bSA9IG51bWVyaWMudGVzdChhKVxuICBjb25zdCBibnVtID0gbnVtZXJpYy50ZXN0KGIpXG5cbiAgaWYgKGFudW0gJiYgYm51bSkge1xuICAgIGEgPSArYVxuICAgIGIgPSArYlxuICB9XG5cbiAgcmV0dXJuIGEgPT09IGIgPyAwXG4gICAgOiAoYW51bSAmJiAhYm51bSkgPyAtMVxuICAgIDogKGJudW0gJiYgIWFudW0pID8gMVxuICAgIDogYSA8IGIgPyAtMVxuICAgIDogMVxufVxuXG5jb25zdCByY29tcGFyZUlkZW50aWZpZXJzID0gKGEsIGIpID0+IGNvbXBhcmVJZGVudGlmaWVycyhiLCBhKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29tcGFyZUlkZW50aWZpZXJzLFxuICByY29tcGFyZUlkZW50aWZpZXJzXG59XG4iLCJjb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IHsgTUFYX0xFTkdUSCwgTUFYX1NBRkVfSU5URUdFUiB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvY29uc3RhbnRzJylcbmNvbnN0IHsgcmUsIHQgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCB7IGNvbXBhcmVJZGVudGlmaWVycyB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaWRlbnRpZmllcnMnKVxuY2xhc3MgU2VtVmVyIHtcbiAgY29uc3RydWN0b3IgKHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgICAgaWYgKHZlcnNpb24ubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSAmJlxuICAgICAgICAgIHZlcnNpb24uaW5jbHVkZVByZXJlbGVhc2UgPT09ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgICAgICByZXR1cm4gdmVyc2lvblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmVyc2lvbiA9IHZlcnNpb24udmVyc2lvblxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFZlcnNpb246ICR7dmVyc2lvbn1gKVxuICAgIH1cblxuICAgIGlmICh2ZXJzaW9uLmxlbmd0aCA+IE1BWF9MRU5HVEgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIGB2ZXJzaW9uIGlzIGxvbmdlciB0aGFuICR7TUFYX0xFTkdUSH0gY2hhcmFjdGVyc2BcbiAgICAgIClcbiAgICB9XG5cbiAgICBkZWJ1ZygnU2VtVmVyJywgdmVyc2lvbiwgb3B0aW9ucylcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICAgIC8vIHRoaXMgaXNuJ3QgYWN0dWFsbHkgcmVsZXZhbnQgZm9yIHZlcnNpb25zLCBidXQga2VlcCBpdCBzbyB0aGF0IHdlXG4gICAgLy8gZG9uJ3QgcnVuIGludG8gdHJvdWJsZSBwYXNzaW5nIHRoaXMub3B0aW9ucyBhcm91bmQuXG4gICAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuXG4gICAgY29uc3QgbSA9IHZlcnNpb24udHJpbSgpLm1hdGNoKG9wdGlvbnMubG9vc2UgPyByZVt0LkxPT1NFXSA6IHJlW3QuRlVMTF0pXG5cbiAgICBpZiAoIW0pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgVmVyc2lvbjogJHt2ZXJzaW9ufWApXG4gICAgfVxuXG4gICAgdGhpcy5yYXcgPSB2ZXJzaW9uXG5cbiAgICAvLyB0aGVzZSBhcmUgYWN0dWFsbHkgbnVtYmVyc1xuICAgIHRoaXMubWFqb3IgPSArbVsxXVxuICAgIHRoaXMubWlub3IgPSArbVsyXVxuICAgIHRoaXMucGF0Y2ggPSArbVszXVxuXG4gICAgaWYgKHRoaXMubWFqb3IgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMubWFqb3IgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1ham9yIHZlcnNpb24nKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm1pbm9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1pbm9yIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtaW5vciB2ZXJzaW9uJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXRjaCA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5wYXRjaCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcGF0Y2ggdmVyc2lvbicpXG4gICAgfVxuXG4gICAgLy8gbnVtYmVyaWZ5IGFueSBwcmVyZWxlYXNlIG51bWVyaWMgaWRzXG4gICAgaWYgKCFtWzRdKSB7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBtWzRdLnNwbGl0KCcuJykubWFwKChpZCkgPT4ge1xuICAgICAgICBpZiAoL15bMC05XSskLy50ZXN0KGlkKSkge1xuICAgICAgICAgIGNvbnN0IG51bSA9ICtpZFxuICAgICAgICAgIGlmIChudW0gPj0gMCAmJiBudW0gPCBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLmJ1aWxkID0gbVs1XSA/IG1bNV0uc3BsaXQoJy4nKSA6IFtdXG4gICAgdGhpcy5mb3JtYXQoKVxuICB9XG5cbiAgZm9ybWF0ICgpIHtcbiAgICB0aGlzLnZlcnNpb24gPSBgJHt0aGlzLm1ham9yfS4ke3RoaXMubWlub3J9LiR7dGhpcy5wYXRjaH1gXG4gICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAgIHRoaXMudmVyc2lvbiArPSBgLSR7dGhpcy5wcmVyZWxlYXNlLmpvaW4oJy4nKX1gXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnZlcnNpb25cbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJzaW9uXG4gIH1cblxuICBjb21wYXJlIChvdGhlcikge1xuICAgIGRlYnVnKCdTZW1WZXIuY29tcGFyZScsIHRoaXMudmVyc2lvbiwgdGhpcy5vcHRpb25zLCBvdGhlcilcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3RoZXIgPT09ICdzdHJpbmcnICYmIG90aGVyID09PSB0aGlzLnZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH1cbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIGlmIChvdGhlci52ZXJzaW9uID09PSB0aGlzLnZlcnNpb24pIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZU1haW4ob3RoZXIpIHx8IHRoaXMuY29tcGFyZVByZShvdGhlcilcbiAgfVxuXG4gIGNvbXBhcmVNYWluIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1ham9yLCBvdGhlci5tYWpvcikgfHxcbiAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1pbm9yLCBvdGhlci5taW5vcikgfHxcbiAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLnBhdGNoLCBvdGhlci5wYXRjaClcbiAgICApXG4gIH1cblxuICBjb21wYXJlUHJlIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgLy8gTk9UIGhhdmluZyBhIHByZXJlbGVhc2UgaXMgPiBoYXZpbmcgb25lXG4gICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmIG90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH0gZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIGxldCBpID0gMFxuICAgIGRvIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLnByZXJlbGVhc2VbaV1cbiAgICAgIGNvbnN0IGIgPSBvdGhlci5wcmVyZWxlYXNlW2ldXG4gICAgICBkZWJ1ZygncHJlcmVsZWFzZSBjb21wYXJlJywgaSwgYSwgYilcbiAgICAgIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9IGVsc2UgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfSBlbHNlIGlmIChhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9IGVsc2UgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYilcbiAgICAgIH1cbiAgICB9IHdoaWxlICgrK2kpXG4gIH1cblxuICBjb21wYXJlQnVpbGQgKG90aGVyKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICBsZXQgaSA9IDBcbiAgICBkbyB7XG4gICAgICBjb25zdCBhID0gdGhpcy5idWlsZFtpXVxuICAgICAgY29uc3QgYiA9IG90aGVyLmJ1aWxkW2ldXG4gICAgICBkZWJ1ZygncHJlcmVsZWFzZSBjb21wYXJlJywgaSwgYSwgYilcbiAgICAgIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9IGVsc2UgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfSBlbHNlIGlmIChhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9IGVsc2UgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYilcbiAgICAgIH1cbiAgICB9IHdoaWxlICgrK2kpXG4gIH1cblxuICAvLyBwcmVtaW5vciB3aWxsIGJ1bXAgdGhlIHZlcnNpb24gdXAgdG8gdGhlIG5leHQgbWlub3IgcmVsZWFzZSwgYW5kIGltbWVkaWF0ZWx5XG4gIC8vIGRvd24gdG8gcHJlLXJlbGVhc2UuIHByZW1ham9yIGFuZCBwcmVwYXRjaCB3b3JrIHRoZSBzYW1lIHdheS5cbiAgaW5jIChyZWxlYXNlLCBpZGVudGlmaWVyKSB7XG4gICAgc3dpdGNoIChyZWxlYXNlKSB7XG4gICAgICBjYXNlICdwcmVtYWpvcic6XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMubWlub3IgPSAwXG4gICAgICAgIHRoaXMubWFqb3IrK1xuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3ByZW1pbm9yJzpcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5taW5vcisrXG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncHJlcGF0Y2gnOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGFscmVhZHkgYSBwcmVyZWxlYXNlLCBpdCB3aWxsIGJ1bXAgdG8gdGhlIG5leHQgdmVyc2lvblxuICAgICAgICAvLyBkcm9wIGFueSBwcmVyZWxlYXNlcyB0aGF0IG1pZ2h0IGFscmVhZHkgZXhpc3QsIHNpbmNlIHRoZXkgYXJlIG5vdFxuICAgICAgICAvLyByZWxldmFudCBhdCB0aGlzIHBvaW50LlxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyKVxuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgICAgYnJlYWtcbiAgICAgIC8vIElmIHRoZSBpbnB1dCBpcyBhIG5vbi1wcmVyZWxlYXNlIHZlcnNpb24sIHRoaXMgYWN0cyB0aGUgc2FtZSBhc1xuICAgICAgLy8gcHJlcGF0Y2guXG4gICAgICBjYXNlICdwcmVyZWxlYXNlJzpcbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdtYWpvcic6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmUtbWFqb3IgdmVyc2lvbiwgYnVtcCB1cCB0byB0aGUgc2FtZSBtYWpvciB2ZXJzaW9uLlxuICAgICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1ham9yLlxuICAgICAgICAvLyAxLjAuMC01IGJ1bXBzIHRvIDEuMC4wXG4gICAgICAgIC8vIDEuMS4wIGJ1bXBzIHRvIDIuMC4wXG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLm1pbm9yICE9PSAwIHx8XG4gICAgICAgICAgdGhpcy5wYXRjaCAhPT0gMCB8fFxuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5tYWpvcisrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5taW5vciA9IDBcbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ21pbm9yJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1taW5vciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1pbm9yIHZlcnNpb24uXG4gICAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWlub3IuXG4gICAgICAgIC8vIDEuMi4wLTUgYnVtcHMgdG8gMS4yLjBcbiAgICAgICAgLy8gMS4yLjEgYnVtcHMgdG8gMS4zLjBcbiAgICAgICAgaWYgKHRoaXMucGF0Y2ggIT09IDAgfHwgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMubWlub3IrK1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwYXRjaCc6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgbm90IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiwgaXQgd2lsbCBpbmNyZW1lbnQgdGhlIHBhdGNoLlxuICAgICAgICAvLyBJZiBpdCBpcyBhIHByZS1yZWxlYXNlIGl0IHdpbGwgYnVtcCB1cCB0byB0aGUgc2FtZSBwYXRjaCB2ZXJzaW9uLlxuICAgICAgICAvLyAxLjIuMC01IHBhdGNoZXMgdG8gMS4yLjBcbiAgICAgICAgLy8gMS4yLjAgcGF0Y2hlcyB0byAxLjIuMVxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMucGF0Y2grK1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICAgIGJyZWFrXG4gICAgICAvLyBUaGlzIHByb2JhYmx5IHNob3VsZG4ndCBiZSB1c2VkIHB1YmxpY2x5LlxuICAgICAgLy8gMS4wLjAgJ3ByZScgd291bGQgYmVjb21lIDEuMC4wLTAgd2hpY2ggaXMgdGhlIHdyb25nIGRpcmVjdGlvbi5cbiAgICAgIGNhc2UgJ3ByZSc6XG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gWzBdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGkgPSB0aGlzLnByZXJlbGVhc2UubGVuZ3RoXG4gICAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJlcmVsZWFzZVtpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlW2ldKytcbiAgICAgICAgICAgICAgaSA9IC0yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgLy8gZGlkbid0IGluY3JlbWVudCBhbnl0aGluZ1xuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLnB1c2goMClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkZW50aWZpZXIpIHtcbiAgICAgICAgICAvLyAxLjIuMC1iZXRhLjEgYnVtcHMgdG8gMS4yLjAtYmV0YS4yLFxuICAgICAgICAgIC8vIDEuMi4wLWJldGEuZm9vYmx6IG9yIDEuMi4wLWJldGEgYnVtcHMgdG8gMS4yLjAtYmV0YS4wXG4gICAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZVswXSA9PT0gaWRlbnRpZmllcikge1xuICAgICAgICAgICAgaWYgKGlzTmFOKHRoaXMucHJlcmVsZWFzZVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW2lkZW50aWZpZXIsIDBdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCAwXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVha1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5jcmVtZW50IGFyZ3VtZW50OiAke3JlbGVhc2V9YClcbiAgICB9XG4gICAgdGhpcy5mb3JtYXQoKVxuICAgIHRoaXMucmF3ID0gdGhpcy52ZXJzaW9uXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbVZlclxuIiwiY29uc3Qge01BWF9MRU5HVEh9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvY29uc3RhbnRzJylcbmNvbnN0IHsgcmUsIHQgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCBwYXJzZSA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucylcblxuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgIHJldHVybiB2ZXJzaW9uXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGlmICh2ZXJzaW9uLmxlbmd0aCA+IE1BWF9MRU5HVEgpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LkxPT1NFXSA6IHJlW3QuRlVMTF1cbiAgaWYgKCFyLnRlc3QodmVyc2lvbikpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZVxuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHZhbGlkID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgdiA9IHBhcnNlKHZlcnNpb24sIG9wdGlvbnMpXG4gIHJldHVybiB2ID8gdi52ZXJzaW9uIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZFxuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IGNsZWFuID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcyA9IHBhcnNlKHZlcnNpb24udHJpbSgpLnJlcGxhY2UoL15bPXZdKy8sICcnKSwgb3B0aW9ucylcbiAgcmV0dXJuIHMgPyBzLnZlcnNpb24gOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IGNsZWFuXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5cbmNvbnN0IGluYyA9ICh2ZXJzaW9uLCByZWxlYXNlLCBvcHRpb25zLCBpZGVudGlmaWVyKSA9PiB7XG4gIGlmICh0eXBlb2YgKG9wdGlvbnMpID09PSAnc3RyaW5nJykge1xuICAgIGlkZW50aWZpZXIgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZFxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKS5pbmMocmVsZWFzZSwgaWRlbnRpZmllcikudmVyc2lvblxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gaW5jXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBjb21wYXJlID0gKGEsIGIsIGxvb3NlKSA9PlxuICBuZXcgU2VtVmVyKGEsIGxvb3NlKS5jb21wYXJlKG5ldyBTZW1WZXIoYiwgbG9vc2UpKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZXEgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID09PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGVxXG4iLCJjb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgZXEgPSByZXF1aXJlKCcuL2VxJylcblxuY29uc3QgZGlmZiA9ICh2ZXJzaW9uMSwgdmVyc2lvbjIpID0+IHtcbiAgaWYgKGVxKHZlcnNpb24xLCB2ZXJzaW9uMikpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHYxID0gcGFyc2UodmVyc2lvbjEpXG4gICAgY29uc3QgdjIgPSBwYXJzZSh2ZXJzaW9uMilcbiAgICBjb25zdCBoYXNQcmUgPSB2MS5wcmVyZWxlYXNlLmxlbmd0aCB8fCB2Mi5wcmVyZWxlYXNlLmxlbmd0aFxuICAgIGNvbnN0IHByZWZpeCA9IGhhc1ByZSA/ICdwcmUnIDogJydcbiAgICBjb25zdCBkZWZhdWx0UmVzdWx0ID0gaGFzUHJlID8gJ3ByZXJlbGVhc2UnIDogJydcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2MSkge1xuICAgICAgaWYgKGtleSA9PT0gJ21ham9yJyB8fCBrZXkgPT09ICdtaW5vcicgfHwga2V5ID09PSAncGF0Y2gnKSB7XG4gICAgICAgIGlmICh2MVtrZXldICE9PSB2MltrZXldKSB7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeCArIGtleVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0UmVzdWx0IC8vIG1heSBiZSB1bmRlZmluZWRcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBkaWZmXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBtYWpvciA9IChhLCBsb29zZSkgPT4gbmV3IFNlbVZlcihhLCBsb29zZSkubWFqb3Jcbm1vZHVsZS5leHBvcnRzID0gbWFqb3JcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IG1pbm9yID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5taW5vclxubW9kdWxlLmV4cG9ydHMgPSBtaW5vclxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgcGF0Y2ggPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLnBhdGNoXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoXG4iLCJjb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgcHJlcmVsZWFzZSA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHBhcnNlZCA9IHBhcnNlKHZlcnNpb24sIG9wdGlvbnMpXG4gIHJldHVybiAocGFyc2VkICYmIHBhcnNlZC5wcmVyZWxlYXNlLmxlbmd0aCkgPyBwYXJzZWQucHJlcmVsZWFzZSA6IG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gcHJlcmVsZWFzZVxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCByY29tcGFyZSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShiLCBhLCBsb29zZSlcbm1vZHVsZS5leHBvcnRzID0gcmNvbXBhcmVcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgY29tcGFyZUxvb3NlID0gKGEsIGIpID0+IGNvbXBhcmUoYSwgYiwgdHJ1ZSlcbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZUxvb3NlXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBjb21wYXJlQnVpbGQgPSAoYSwgYiwgbG9vc2UpID0+IHtcbiAgY29uc3QgdmVyc2lvbkEgPSBuZXcgU2VtVmVyKGEsIGxvb3NlKVxuICBjb25zdCB2ZXJzaW9uQiA9IG5ldyBTZW1WZXIoYiwgbG9vc2UpXG4gIHJldHVybiB2ZXJzaW9uQS5jb21wYXJlKHZlcnNpb25CKSB8fCB2ZXJzaW9uQS5jb21wYXJlQnVpbGQodmVyc2lvbkIpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVCdWlsZFxuIiwiY29uc3QgY29tcGFyZUJ1aWxkID0gcmVxdWlyZSgnLi9jb21wYXJlLWJ1aWxkJylcbmNvbnN0IHNvcnQgPSAobGlzdCwgbG9vc2UpID0+IGxpc3Quc29ydCgoYSwgYikgPT4gY29tcGFyZUJ1aWxkKGEsIGIsIGxvb3NlKSlcbm1vZHVsZS5leHBvcnRzID0gc29ydFxuIiwiY29uc3QgY29tcGFyZUJ1aWxkID0gcmVxdWlyZSgnLi9jb21wYXJlLWJ1aWxkJylcbmNvbnN0IHJzb3J0ID0gKGxpc3QsIGxvb3NlKSA9PiBsaXN0LnNvcnQoKGEsIGIpID0+IGNvbXBhcmVCdWlsZChiLCBhLCBsb29zZSkpXG5tb2R1bGUuZXhwb3J0cyA9IHJzb3J0XG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGd0ID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+IDBcbm1vZHVsZS5leHBvcnRzID0gZ3RcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbHQgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpIDwgMFxubW9kdWxlLmV4cG9ydHMgPSBsdFxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBuZXEgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpICE9PSAwXG5tb2R1bGUuZXhwb3J0cyA9IG5lcVxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBndGUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID49IDBcbm1vZHVsZS5leHBvcnRzID0gZ3RlXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGx0ZSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPD0gMFxubW9kdWxlLmV4cG9ydHMgPSBsdGVcbiIsImNvbnN0IGVxID0gcmVxdWlyZSgnLi9lcScpXG5jb25zdCBuZXEgPSByZXF1aXJlKCcuL25lcScpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4vZ3QnKVxuY29uc3QgZ3RlID0gcmVxdWlyZSgnLi9ndGUnKVxuY29uc3QgbHQgPSByZXF1aXJlKCcuL2x0JylcbmNvbnN0IGx0ZSA9IHJlcXVpcmUoJy4vbHRlJylcblxuY29uc3QgY21wID0gKGEsIG9wLCBiLCBsb29zZSkgPT4ge1xuICBzd2l0Y2ggKG9wKSB7XG4gICAgY2FzZSAnPT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpXG4gICAgICAgIGEgPSBhLnZlcnNpb25cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpXG4gICAgICAgIGIgPSBiLnZlcnNpb25cbiAgICAgIHJldHVybiBhID09PSBiXG5cbiAgICBjYXNlICchPT0nOlxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JylcbiAgICAgICAgYSA9IGEudmVyc2lvblxuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0JylcbiAgICAgICAgYiA9IGIudmVyc2lvblxuICAgICAgcmV0dXJuIGEgIT09IGJcblxuICAgIGNhc2UgJyc6XG4gICAgY2FzZSAnPSc6XG4gICAgY2FzZSAnPT0nOlxuICAgICAgcmV0dXJuIGVxKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnIT0nOlxuICAgICAgcmV0dXJuIG5lcShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJz4nOlxuICAgICAgcmV0dXJuIGd0KGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPj0nOlxuICAgICAgcmV0dXJuIGd0ZShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJzwnOlxuICAgICAgcmV0dXJuIGx0KGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPD0nOlxuICAgICAgcmV0dXJuIGx0ZShhLCBiLCBsb29zZSlcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIG9wZXJhdG9yOiAke29wfWApXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gY21wXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3Qge3JlLCB0fSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcblxuY29uc3QgY29lcmNlID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICByZXR1cm4gdmVyc2lvblxuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnbnVtYmVyJykge1xuICAgIHZlcnNpb24gPSBTdHJpbmcodmVyc2lvbilcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICBsZXQgbWF0Y2ggPSBudWxsXG4gIGlmICghb3B0aW9ucy5ydGwpIHtcbiAgICBtYXRjaCA9IHZlcnNpb24ubWF0Y2gocmVbdC5DT0VSQ0VdKVxuICB9IGVsc2Uge1xuICAgIC8vIEZpbmQgdGhlIHJpZ2h0LW1vc3QgY29lcmNpYmxlIHN0cmluZyB0aGF0IGRvZXMgbm90IHNoYXJlXG4gICAgLy8gYSB0ZXJtaW51cyB3aXRoIGEgbW9yZSBsZWZ0LXdhcmQgY29lcmNpYmxlIHN0cmluZy5cbiAgICAvLyBFZywgJzEuMi4zLjQnIHdhbnRzIHRvIGNvZXJjZSAnMi4zLjQnLCBub3QgJzMuNCcgb3IgJzQnXG4gICAgLy9cbiAgICAvLyBXYWxrIHRocm91Z2ggdGhlIHN0cmluZyBjaGVja2luZyB3aXRoIGEgL2cgcmVnZXhwXG4gICAgLy8gTWFudWFsbHkgc2V0IHRoZSBpbmRleCBzbyBhcyB0byBwaWNrIHVwIG92ZXJsYXBwaW5nIG1hdGNoZXMuXG4gICAgLy8gU3RvcCB3aGVuIHdlIGdldCBhIG1hdGNoIHRoYXQgZW5kcyBhdCB0aGUgc3RyaW5nIGVuZCwgc2luY2Ugbm9cbiAgICAvLyBjb2VyY2libGUgc3RyaW5nIGNhbiBiZSBtb3JlIHJpZ2h0LXdhcmQgd2l0aG91dCB0aGUgc2FtZSB0ZXJtaW51cy5cbiAgICBsZXQgbmV4dFxuICAgIHdoaWxlICgobmV4dCA9IHJlW3QuQ09FUkNFUlRMXS5leGVjKHZlcnNpb24pKSAmJlxuICAgICAgICAoIW1hdGNoIHx8IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoICE9PSB2ZXJzaW9uLmxlbmd0aClcbiAgICApIHtcbiAgICAgIGlmICghbWF0Y2ggfHxcbiAgICAgICAgICAgIG5leHQuaW5kZXggKyBuZXh0WzBdLmxlbmd0aCAhPT0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpIHtcbiAgICAgICAgbWF0Y2ggPSBuZXh0XG4gICAgICB9XG4gICAgICByZVt0LkNPRVJDRVJUTF0ubGFzdEluZGV4ID0gbmV4dC5pbmRleCArIG5leHRbMV0ubGVuZ3RoICsgbmV4dFsyXS5sZW5ndGhcbiAgICB9XG4gICAgLy8gbGVhdmUgaXQgaW4gYSBjbGVhbiBzdGF0ZVxuICAgIHJlW3QuQ09FUkNFUlRMXS5sYXN0SW5kZXggPSAtMVxuICB9XG5cbiAgaWYgKG1hdGNoID09PSBudWxsKVxuICAgIHJldHVybiBudWxsXG5cbiAgcmV0dXJuIHBhcnNlKGAke21hdGNoWzJdfS4ke21hdGNoWzNdIHx8ICcwJ30uJHttYXRjaFs0XSB8fCAnMCd9YCwgb3B0aW9ucylcbn1cbm1vZHVsZS5leHBvcnRzID0gY29lcmNlXG4iLCIndXNlIHN0cmljdCdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFlhbGxpc3QpIHtcbiAgWWFsbGlzdC5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKiAoKSB7XG4gICAgZm9yIChsZXQgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXI7IHdhbGtlciA9IHdhbGtlci5uZXh0KSB7XG4gICAgICB5aWVsZCB3YWxrZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xubW9kdWxlLmV4cG9ydHMgPSBZYWxsaXN0XG5cbllhbGxpc3QuTm9kZSA9IE5vZGVcbllhbGxpc3QuY3JlYXRlID0gWWFsbGlzdFxuXG5mdW5jdGlvbiBZYWxsaXN0IChsaXN0KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIShzZWxmIGluc3RhbmNlb2YgWWFsbGlzdCkpIHtcbiAgICBzZWxmID0gbmV3IFlhbGxpc3QoKVxuICB9XG5cbiAgc2VsZi50YWlsID0gbnVsbFxuICBzZWxmLmhlYWQgPSBudWxsXG4gIHNlbGYubGVuZ3RoID0gMFxuXG4gIGlmIChsaXN0ICYmIHR5cGVvZiBsaXN0LmZvckVhY2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICBsaXN0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHNlbGYucHVzaChpdGVtKVxuICAgIH0pXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHNlbGYucHVzaChhcmd1bWVudHNbaV0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlbGZcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVtb3ZlTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlLmxpc3QgIT09IHRoaXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92aW5nIG5vZGUgd2hpY2ggZG9lcyBub3QgYmVsb25nIHRvIHRoaXMgbGlzdCcpXG4gIH1cblxuICB2YXIgbmV4dCA9IG5vZGUubmV4dFxuICB2YXIgcHJldiA9IG5vZGUucHJldlxuXG4gIGlmIChuZXh0KSB7XG4gICAgbmV4dC5wcmV2ID0gcHJldlxuICB9XG5cbiAgaWYgKHByZXYpIHtcbiAgICBwcmV2Lm5leHQgPSBuZXh0XG4gIH1cblxuICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkID0gbmV4dFxuICB9XG4gIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwgPSBwcmV2XG4gIH1cblxuICBub2RlLmxpc3QubGVuZ3RoLS1cbiAgbm9kZS5uZXh0ID0gbnVsbFxuICBub2RlLnByZXYgPSBudWxsXG4gIG5vZGUubGlzdCA9IG51bGxcblxuICByZXR1cm4gbmV4dFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS51bnNoaWZ0Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlID09PSB0aGlzLmhlYWQpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChub2RlLmxpc3QpIHtcbiAgICBub2RlLmxpc3QucmVtb3ZlTm9kZShub2RlKVxuICB9XG5cbiAgdmFyIGhlYWQgPSB0aGlzLmhlYWRcbiAgbm9kZS5saXN0ID0gdGhpc1xuICBub2RlLm5leHQgPSBoZWFkXG4gIGlmIChoZWFkKSB7XG4gICAgaGVhZC5wcmV2ID0gbm9kZVxuICB9XG5cbiAgdGhpcy5oZWFkID0gbm9kZVxuICBpZiAoIXRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbCA9IG5vZGVcbiAgfVxuICB0aGlzLmxlbmd0aCsrXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnB1c2hOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IHRoaXMudGFpbCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKG5vZGUubGlzdCkge1xuICAgIG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpXG4gIH1cblxuICB2YXIgdGFpbCA9IHRoaXMudGFpbFxuICBub2RlLmxpc3QgPSB0aGlzXG4gIG5vZGUucHJldiA9IHRhaWxcbiAgaWYgKHRhaWwpIHtcbiAgICB0YWlsLm5leHQgPSBub2RlXG4gIH1cblxuICB0aGlzLnRhaWwgPSBub2RlXG4gIGlmICghdGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkID0gbm9kZVxuICB9XG4gIHRoaXMubGVuZ3RoKytcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgcHVzaCh0aGlzLCBhcmd1bWVudHNbaV0pXG4gIH1cbiAgcmV0dXJuIHRoaXMubGVuZ3RoXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHVuc2hpZnQodGhpcywgYXJndW1lbnRzW2ldKVxuICB9XG4gIHJldHVybiB0aGlzLmxlbmd0aFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy50YWlsKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgdmFyIHJlcyA9IHRoaXMudGFpbC52YWx1ZVxuICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwucHJldlxuICBpZiAodGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsLm5leHQgPSBudWxsXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5oZWFkID0gbnVsbFxuICB9XG4gIHRoaXMubGVuZ3RoLS1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICB2YXIgcmVzID0gdGhpcy5oZWFkLnZhbHVlXG4gIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0XG4gIGlmICh0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQucHJldiA9IG51bGxcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRhaWwgPSBudWxsXG4gIH1cbiAgdGhpcy5sZW5ndGgtLVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLmhlYWQsIGkgPSAwOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgaSwgdGhpcylcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLmZvckVhY2hSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy50YWlsLCBpID0gdGhpcy5sZW5ndGggLSAxOyB3YWxrZXIgIT09IG51bGw7IGktLSkge1xuICAgIGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgaSwgdGhpcylcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChuKSB7XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgbjsgaSsrKSB7XG4gICAgLy8gYWJvcnQgb3V0IG9mIHRoZSBsaXN0IGVhcmx5IGlmIHdlIGhpdCBhIGN5Y2xlXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICBpZiAoaSA9PT0gbiAmJiB3YWxrZXIgIT09IG51bGwpIHtcbiAgICByZXR1cm4gd2Fsa2VyLnZhbHVlXG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZ2V0UmV2ZXJzZSA9IGZ1bmN0aW9uIChuKSB7XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgbjsgaSsrKSB7XG4gICAgLy8gYWJvcnQgb3V0IG9mIHRoZSBsaXN0IGVhcmx5IGlmIHdlIGhpdCBhIGN5Y2xlXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuICBpZiAoaSA9PT0gbiAmJiB3YWxrZXIgIT09IG51bGwpIHtcbiAgICByZXR1cm4gd2Fsa2VyLnZhbHVlXG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgdmFyIHJlcyA9IG5ldyBZYWxsaXN0KClcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgcmVzLnB1c2goZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCB0aGlzKSlcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUubWFwUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIHZhciByZXMgPSBuZXcgWWFsbGlzdCgpXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgIHJlcy5wdXNoKGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgdGhpcykpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChmbiwgaW5pdGlhbCkge1xuICB2YXIgYWNjXG4gIHZhciB3YWxrZXIgPSB0aGlzLmhlYWRcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgYWNjID0gaW5pdGlhbFxuICB9IGVsc2UgaWYgKHRoaXMuaGVhZCkge1xuICAgIHdhbGtlciA9IHRoaXMuaGVhZC5uZXh0XG4gICAgYWNjID0gdGhpcy5oZWFkLnZhbHVlXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGxpc3Qgd2l0aCBubyBpbml0aWFsIHZhbHVlJylcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGFjYyA9IGZuKGFjYywgd2Fsa2VyLnZhbHVlLCBpKVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cblxuICByZXR1cm4gYWNjXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJlZHVjZVJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIGluaXRpYWwpIHtcbiAgdmFyIGFjY1xuICB2YXIgd2Fsa2VyID0gdGhpcy50YWlsXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIGFjYyA9IGluaXRpYWxcbiAgfSBlbHNlIGlmICh0aGlzLnRhaWwpIHtcbiAgICB3YWxrZXIgPSB0aGlzLnRhaWwucHJldlxuICAgIGFjYyA9IHRoaXMudGFpbC52YWx1ZVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBsaXN0IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpXG4gIH1cblxuICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyB3YWxrZXIgIT09IG51bGw7IGktLSkge1xuICAgIGFjYyA9IGZuKGFjYywgd2Fsa2VyLnZhbHVlLCBpKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cblxuICByZXR1cm4gYWNjXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYXJyW2ldID0gd2Fsa2VyLnZhbHVlXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICByZXR1cm4gYXJyXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnRvQXJyYXlSZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGFycltpXSA9IHdhbGtlci52YWx1ZVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgcmV0dXJuIGFyclxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICB0byA9IHRvIHx8IHRoaXMubGVuZ3RoXG4gIGlmICh0byA8IDApIHtcbiAgICB0byArPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZyb20gPSBmcm9tIHx8IDBcbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSArPSB0aGlzLmxlbmd0aFxuICB9XG4gIHZhciByZXQgPSBuZXcgWWFsbGlzdCgpXG4gIGlmICh0byA8IGZyb20gfHwgdG8gPCAwKSB7XG4gICAgcmV0dXJuIHJldFxuICB9XG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gPSAwXG4gIH1cbiAgaWYgKHRvID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0byA9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBmcm9tOyBpKyspIHtcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIGZvciAoOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IHRvOyBpKyssIHdhbGtlciA9IHdhbGtlci5uZXh0KSB7XG4gICAgcmV0LnB1c2god2Fsa2VyLnZhbHVlKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2xpY2VSZXZlcnNlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gIHRvID0gdG8gfHwgdGhpcy5sZW5ndGhcbiAgaWYgKHRvIDwgMCkge1xuICAgIHRvICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZnJvbSA9IGZyb20gfHwgMFxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgdmFyIHJldCA9IG5ldyBZYWxsaXN0KClcbiAgaWYgKHRvIDwgZnJvbSB8fCB0byA8IDApIHtcbiAgICByZXR1cm4gcmV0XG4gIH1cbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSA9IDBcbiAgfVxuICBpZiAodG8gPiB0aGlzLmxlbmd0aCkge1xuICAgIHRvID0gdGhpcy5sZW5ndGhcbiAgfVxuICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGgsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPiB0bzsgaS0tKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuICBmb3IgKDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPiBmcm9tOyBpLS0sIHdhbGtlciA9IHdhbGtlci5wcmV2KSB7XG4gICAgcmV0LnB1c2god2Fsa2VyLnZhbHVlKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc3BsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBkZWxldGVDb3VudCwgLi4ubm9kZXMpIHtcbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICBzdGFydCA9IHRoaXMubGVuZ3RoIC0gMVxuICB9XG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IHRoaXMubGVuZ3RoICsgc3RhcnQ7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IHN0YXJ0OyBpKyspIHtcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG5cbiAgdmFyIHJldCA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyB3YWxrZXIgJiYgaSA8IGRlbGV0ZUNvdW50OyBpKyspIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpXG4gICAgd2Fsa2VyID0gdGhpcy5yZW1vdmVOb2RlKHdhbGtlcilcbiAgfVxuICBpZiAod2Fsa2VyID09PSBudWxsKSB7XG4gICAgd2Fsa2VyID0gdGhpcy50YWlsXG4gIH1cblxuICBpZiAod2Fsa2VyICE9PSB0aGlzLmhlYWQgJiYgd2Fsa2VyICE9PSB0aGlzLnRhaWwpIHtcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHdhbGtlciA9IGluc2VydCh0aGlzLCB3YWxrZXIsIG5vZGVzW2ldKVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoZWFkID0gdGhpcy5oZWFkXG4gIHZhciB0YWlsID0gdGhpcy50YWlsXG4gIGZvciAodmFyIHdhbGtlciA9IGhlYWQ7IHdhbGtlciAhPT0gbnVsbDsgd2Fsa2VyID0gd2Fsa2VyLnByZXYpIHtcbiAgICB2YXIgcCA9IHdhbGtlci5wcmV2XG4gICAgd2Fsa2VyLnByZXYgPSB3YWxrZXIubmV4dFxuICAgIHdhbGtlci5uZXh0ID0gcFxuICB9XG4gIHRoaXMuaGVhZCA9IHRhaWxcbiAgdGhpcy50YWlsID0gaGVhZFxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBpbnNlcnQgKHNlbGYsIG5vZGUsIHZhbHVlKSB7XG4gIHZhciBpbnNlcnRlZCA9IG5vZGUgPT09IHNlbGYuaGVhZCA/XG4gICAgbmV3IE5vZGUodmFsdWUsIG51bGwsIG5vZGUsIHNlbGYpIDpcbiAgICBuZXcgTm9kZSh2YWx1ZSwgbm9kZSwgbm9kZS5uZXh0LCBzZWxmKVxuXG4gIGlmIChpbnNlcnRlZC5uZXh0ID09PSBudWxsKSB7XG4gICAgc2VsZi50YWlsID0gaW5zZXJ0ZWRcbiAgfVxuICBpZiAoaW5zZXJ0ZWQucHJldiA9PT0gbnVsbCkge1xuICAgIHNlbGYuaGVhZCA9IGluc2VydGVkXG4gIH1cblxuICBzZWxmLmxlbmd0aCsrXG5cbiAgcmV0dXJuIGluc2VydGVkXG59XG5cbmZ1bmN0aW9uIHB1c2ggKHNlbGYsIGl0ZW0pIHtcbiAgc2VsZi50YWlsID0gbmV3IE5vZGUoaXRlbSwgc2VsZi50YWlsLCBudWxsLCBzZWxmKVxuICBpZiAoIXNlbGYuaGVhZCkge1xuICAgIHNlbGYuaGVhZCA9IHNlbGYudGFpbFxuICB9XG4gIHNlbGYubGVuZ3RoKytcbn1cblxuZnVuY3Rpb24gdW5zaGlmdCAoc2VsZiwgaXRlbSkge1xuICBzZWxmLmhlYWQgPSBuZXcgTm9kZShpdGVtLCBudWxsLCBzZWxmLmhlYWQsIHNlbGYpXG4gIGlmICghc2VsZi50YWlsKSB7XG4gICAgc2VsZi50YWlsID0gc2VsZi5oZWFkXG4gIH1cbiAgc2VsZi5sZW5ndGgrK1xufVxuXG5mdW5jdGlvbiBOb2RlICh2YWx1ZSwgcHJldiwgbmV4dCwgbGlzdCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTm9kZSkpIHtcbiAgICByZXR1cm4gbmV3IE5vZGUodmFsdWUsIHByZXYsIG5leHQsIGxpc3QpXG4gIH1cblxuICB0aGlzLmxpc3QgPSBsaXN0XG4gIHRoaXMudmFsdWUgPSB2YWx1ZVxuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5uZXh0ID0gdGhpc1xuICAgIHRoaXMucHJldiA9IHByZXZcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnByZXYgPSBudWxsXG4gIH1cblxuICBpZiAobmV4dCkge1xuICAgIG5leHQucHJldiA9IHRoaXNcbiAgICB0aGlzLm5leHQgPSBuZXh0XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5uZXh0ID0gbnVsbFxuICB9XG59XG5cbnRyeSB7XG4gIC8vIGFkZCBpZiBzdXBwb3J0IGZvciBTeW1ib2wuaXRlcmF0b3IgaXMgcHJlc2VudFxuICByZXF1aXJlKCcuL2l0ZXJhdG9yLmpzJykoWWFsbGlzdClcbn0gY2F0Y2ggKGVyKSB7fVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8vIEEgbGlua2VkIGxpc3QgdG8ga2VlcCB0cmFjayBvZiByZWNlbnRseS11c2VkLW5lc3NcbmNvbnN0IFlhbGxpc3QgPSByZXF1aXJlKCd5YWxsaXN0JylcblxuY29uc3QgTUFYID0gU3ltYm9sKCdtYXgnKVxuY29uc3QgTEVOR1RIID0gU3ltYm9sKCdsZW5ndGgnKVxuY29uc3QgTEVOR1RIX0NBTENVTEFUT1IgPSBTeW1ib2woJ2xlbmd0aENhbGN1bGF0b3InKVxuY29uc3QgQUxMT1dfU1RBTEUgPSBTeW1ib2woJ2FsbG93U3RhbGUnKVxuY29uc3QgTUFYX0FHRSA9IFN5bWJvbCgnbWF4QWdlJylcbmNvbnN0IERJU1BPU0UgPSBTeW1ib2woJ2Rpc3Bvc2UnKVxuY29uc3QgTk9fRElTUE9TRV9PTl9TRVQgPSBTeW1ib2woJ25vRGlzcG9zZU9uU2V0JylcbmNvbnN0IExSVV9MSVNUID0gU3ltYm9sKCdscnVMaXN0JylcbmNvbnN0IENBQ0hFID0gU3ltYm9sKCdjYWNoZScpXG5jb25zdCBVUERBVEVfQUdFX09OX0dFVCA9IFN5bWJvbCgndXBkYXRlQWdlT25HZXQnKVxuXG5jb25zdCBuYWl2ZUxlbmd0aCA9ICgpID0+IDFcblxuLy8gbHJ1TGlzdCBpcyBhIHlhbGxpc3Qgd2hlcmUgdGhlIGhlYWQgaXMgdGhlIHlvdW5nZXN0XG4vLyBpdGVtLCBhbmQgdGhlIHRhaWwgaXMgdGhlIG9sZGVzdC4gIHRoZSBsaXN0IGNvbnRhaW5zIHRoZSBIaXRcbi8vIG9iamVjdHMgYXMgdGhlIGVudHJpZXMuXG4vLyBFYWNoIEhpdCBvYmplY3QgaGFzIGEgcmVmZXJlbmNlIHRvIGl0cyBZYWxsaXN0Lk5vZGUuICBUaGlzXG4vLyBuZXZlciBjaGFuZ2VzLlxuLy9cbi8vIGNhY2hlIGlzIGEgTWFwIChvciBQc2V1ZG9NYXApIHRoYXQgbWF0Y2hlcyB0aGUga2V5cyB0b1xuLy8gdGhlIFlhbGxpc3QuTm9kZSBvYmplY3QuXG5jbGFzcyBMUlVDYWNoZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJylcbiAgICAgIG9wdGlvbnMgPSB7IG1heDogb3B0aW9ucyB9XG5cbiAgICBpZiAoIW9wdGlvbnMpXG4gICAgICBvcHRpb25zID0ge31cblxuICAgIGlmIChvcHRpb25zLm1heCAmJiAodHlwZW9mIG9wdGlvbnMubWF4ICE9PSAnbnVtYmVyJyB8fCBvcHRpb25zLm1heCA8IDApKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJylcbiAgICAvLyBLaW5kIG9mIHdlaXJkIHRvIGhhdmUgYSBkZWZhdWx0IG1heCBvZiBJbmZpbml0eSwgYnV0IG9oIHdlbGwuXG4gICAgY29uc3QgbWF4ID0gdGhpc1tNQVhdID0gb3B0aW9ucy5tYXggfHwgSW5maW5pdHlcblxuICAgIGNvbnN0IGxjID0gb3B0aW9ucy5sZW5ndGggfHwgbmFpdmVMZW5ndGhcbiAgICB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSA9ICh0eXBlb2YgbGMgIT09ICdmdW5jdGlvbicpID8gbmFpdmVMZW5ndGggOiBsY1xuICAgIHRoaXNbQUxMT1dfU1RBTEVdID0gb3B0aW9ucy5zdGFsZSB8fCBmYWxzZVxuICAgIGlmIChvcHRpb25zLm1heEFnZSAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhBZ2UgIT09ICdudW1iZXInKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4QWdlIG11c3QgYmUgYSBudW1iZXInKVxuICAgIHRoaXNbTUFYX0FHRV0gPSBvcHRpb25zLm1heEFnZSB8fCAwXG4gICAgdGhpc1tESVNQT1NFXSA9IG9wdGlvbnMuZGlzcG9zZVxuICAgIHRoaXNbTk9fRElTUE9TRV9PTl9TRVRdID0gb3B0aW9ucy5ub0Rpc3Bvc2VPblNldCB8fCBmYWxzZVxuICAgIHRoaXNbVVBEQVRFX0FHRV9PTl9HRVRdID0gb3B0aW9ucy51cGRhdGVBZ2VPbkdldCB8fCBmYWxzZVxuICAgIHRoaXMucmVzZXQoKVxuICB9XG5cbiAgLy8gcmVzaXplIHRoZSBjYWNoZSB3aGVuIHRoZSBtYXggY2hhbmdlcy5cbiAgc2V0IG1heCAobUwpIHtcbiAgICBpZiAodHlwZW9mIG1MICE9PSAnbnVtYmVyJyB8fCBtTCA8IDApXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXggbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKVxuXG4gICAgdGhpc1tNQVhdID0gbUwgfHwgSW5maW5pdHlcbiAgICB0cmltKHRoaXMpXG4gIH1cbiAgZ2V0IG1heCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTUFYXVxuICB9XG5cbiAgc2V0IGFsbG93U3RhbGUgKGFsbG93U3RhbGUpIHtcbiAgICB0aGlzW0FMTE9XX1NUQUxFXSA9ICEhYWxsb3dTdGFsZVxuICB9XG4gIGdldCBhbGxvd1N0YWxlICgpIHtcbiAgICByZXR1cm4gdGhpc1tBTExPV19TVEFMRV1cbiAgfVxuXG4gIHNldCBtYXhBZ2UgKG1BKSB7XG4gICAgaWYgKHR5cGVvZiBtQSAhPT0gJ251bWJlcicpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhBZ2UgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKVxuXG4gICAgdGhpc1tNQVhfQUdFXSA9IG1BXG4gICAgdHJpbSh0aGlzKVxuICB9XG4gIGdldCBtYXhBZ2UgKCkge1xuICAgIHJldHVybiB0aGlzW01BWF9BR0VdXG4gIH1cblxuICAvLyByZXNpemUgdGhlIGNhY2hlIHdoZW4gdGhlIGxlbmd0aENhbGN1bGF0b3IgY2hhbmdlcy5cbiAgc2V0IGxlbmd0aENhbGN1bGF0b3IgKGxDKSB7XG4gICAgaWYgKHR5cGVvZiBsQyAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIGxDID0gbmFpdmVMZW5ndGhcblxuICAgIGlmIChsQyAhPT0gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0pIHtcbiAgICAgIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdID0gbENcbiAgICAgIHRoaXNbTEVOR1RIXSA9IDBcbiAgICAgIHRoaXNbTFJVX0xJU1RdLmZvckVhY2goaGl0ID0+IHtcbiAgICAgICAgaGl0Lmxlbmd0aCA9IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKGhpdC52YWx1ZSwgaGl0LmtleSlcbiAgICAgICAgdGhpc1tMRU5HVEhdICs9IGhpdC5sZW5ndGhcbiAgICAgIH0pXG4gICAgfVxuICAgIHRyaW0odGhpcylcbiAgfVxuICBnZXQgbGVuZ3RoQ2FsY3VsYXRvciAoKSB7IHJldHVybiB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSB9XG5cbiAgZ2V0IGxlbmd0aCAoKSB7IHJldHVybiB0aGlzW0xFTkdUSF0gfVxuICBnZXQgaXRlbUNvdW50ICgpIHsgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLmxlbmd0aCB9XG5cbiAgcmZvckVhY2ggKGZuLCB0aGlzcCkge1xuICAgIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICAgIGZvciAobGV0IHdhbGtlciA9IHRoaXNbTFJVX0xJU1RdLnRhaWw7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICAgIGNvbnN0IHByZXYgPSB3YWxrZXIucHJldlxuICAgICAgZm9yRWFjaFN0ZXAodGhpcywgZm4sIHdhbGtlciwgdGhpc3ApXG4gICAgICB3YWxrZXIgPSBwcmV2XG4gICAgfVxuICB9XG5cbiAgZm9yRWFjaCAoZm4sIHRoaXNwKSB7XG4gICAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gICAgZm9yIChsZXQgd2Fsa2VyID0gdGhpc1tMUlVfTElTVF0uaGVhZDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgICAgY29uc3QgbmV4dCA9IHdhbGtlci5uZXh0XG4gICAgICBmb3JFYWNoU3RlcCh0aGlzLCBmbiwgd2Fsa2VyLCB0aGlzcClcbiAgICAgIHdhbGtlciA9IG5leHRcbiAgICB9XG4gIH1cblxuICBrZXlzICgpIHtcbiAgICByZXR1cm4gdGhpc1tMUlVfTElTVF0udG9BcnJheSgpLm1hcChrID0+IGsua2V5KVxuICB9XG5cbiAgdmFsdWVzICgpIHtcbiAgICByZXR1cm4gdGhpc1tMUlVfTElTVF0udG9BcnJheSgpLm1hcChrID0+IGsudmFsdWUpXG4gIH1cblxuICByZXNldCAoKSB7XG4gICAgaWYgKHRoaXNbRElTUE9TRV0gJiZcbiAgICAgICAgdGhpc1tMUlVfTElTVF0gJiZcbiAgICAgICAgdGhpc1tMUlVfTElTVF0ubGVuZ3RoKSB7XG4gICAgICB0aGlzW0xSVV9MSVNUXS5mb3JFYWNoKGhpdCA9PiB0aGlzW0RJU1BPU0VdKGhpdC5rZXksIGhpdC52YWx1ZSkpXG4gICAgfVxuXG4gICAgdGhpc1tDQUNIRV0gPSBuZXcgTWFwKCkgLy8gaGFzaCBvZiBpdGVtcyBieSBrZXlcbiAgICB0aGlzW0xSVV9MSVNUXSA9IG5ldyBZYWxsaXN0KCkgLy8gbGlzdCBvZiBpdGVtcyBpbiBvcmRlciBvZiB1c2UgcmVjZW5jeVxuICAgIHRoaXNbTEVOR1RIXSA9IDAgLy8gbGVuZ3RoIG9mIGl0ZW1zIGluIHRoZSBsaXN0XG4gIH1cblxuICBkdW1wICgpIHtcbiAgICByZXR1cm4gdGhpc1tMUlVfTElTVF0ubWFwKGhpdCA9PlxuICAgICAgaXNTdGFsZSh0aGlzLCBoaXQpID8gZmFsc2UgOiB7XG4gICAgICAgIGs6IGhpdC5rZXksXG4gICAgICAgIHY6IGhpdC52YWx1ZSxcbiAgICAgICAgZTogaGl0Lm5vdyArIChoaXQubWF4QWdlIHx8IDApXG4gICAgICB9KS50b0FycmF5KCkuZmlsdGVyKGggPT4gaClcbiAgfVxuXG4gIGR1bXBMcnUgKCkge1xuICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXVxuICB9XG5cbiAgc2V0IChrZXksIHZhbHVlLCBtYXhBZ2UpIHtcbiAgICBtYXhBZ2UgPSBtYXhBZ2UgfHwgdGhpc1tNQVhfQUdFXVxuXG4gICAgaWYgKG1heEFnZSAmJiB0eXBlb2YgbWF4QWdlICE9PSAnbnVtYmVyJylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heEFnZSBtdXN0IGJlIGEgbnVtYmVyJylcblxuICAgIGNvbnN0IG5vdyA9IG1heEFnZSA/IERhdGUubm93KCkgOiAwXG4gICAgY29uc3QgbGVuID0gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0odmFsdWUsIGtleSlcblxuICAgIGlmICh0aGlzW0NBQ0hFXS5oYXMoa2V5KSkge1xuICAgICAgaWYgKGxlbiA+IHRoaXNbTUFYXSkge1xuICAgICAgICBkZWwodGhpcywgdGhpc1tDQUNIRV0uZ2V0KGtleSkpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBub2RlID0gdGhpc1tDQUNIRV0uZ2V0KGtleSlcbiAgICAgIGNvbnN0IGl0ZW0gPSBub2RlLnZhbHVlXG5cbiAgICAgIC8vIGRpc3Bvc2Ugb2YgdGhlIG9sZCBvbmUgYmVmb3JlIG92ZXJ3cml0aW5nXG4gICAgICAvLyBzcGxpdCBvdXQgaW50byAyIGlmcyBmb3IgYmV0dGVyIGNvdmVyYWdlIHRyYWNraW5nXG4gICAgICBpZiAodGhpc1tESVNQT1NFXSkge1xuICAgICAgICBpZiAoIXRoaXNbTk9fRElTUE9TRV9PTl9TRVRdKVxuICAgICAgICAgIHRoaXNbRElTUE9TRV0oa2V5LCBpdGVtLnZhbHVlKVxuICAgICAgfVxuXG4gICAgICBpdGVtLm5vdyA9IG5vd1xuICAgICAgaXRlbS5tYXhBZ2UgPSBtYXhBZ2VcbiAgICAgIGl0ZW0udmFsdWUgPSB2YWx1ZVxuICAgICAgdGhpc1tMRU5HVEhdICs9IGxlbiAtIGl0ZW0ubGVuZ3RoXG4gICAgICBpdGVtLmxlbmd0aCA9IGxlblxuICAgICAgdGhpcy5nZXQoa2V5KVxuICAgICAgdHJpbSh0aGlzKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBjb25zdCBoaXQgPSBuZXcgRW50cnkoa2V5LCB2YWx1ZSwgbGVuLCBub3csIG1heEFnZSlcblxuICAgIC8vIG92ZXJzaXplZCBvYmplY3RzIGZhbGwgb3V0IG9mIGNhY2hlIGF1dG9tYXRpY2FsbHkuXG4gICAgaWYgKGhpdC5sZW5ndGggPiB0aGlzW01BWF0pIHtcbiAgICAgIGlmICh0aGlzW0RJU1BPU0VdKVxuICAgICAgICB0aGlzW0RJU1BPU0VdKGtleSwgdmFsdWUpXG5cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHRoaXNbTEVOR1RIXSArPSBoaXQubGVuZ3RoXG4gICAgdGhpc1tMUlVfTElTVF0udW5zaGlmdChoaXQpXG4gICAgdGhpc1tDQUNIRV0uc2V0KGtleSwgdGhpc1tMUlVfTElTVF0uaGVhZClcbiAgICB0cmltKHRoaXMpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGhhcyAoa2V5KSB7XG4gICAgaWYgKCF0aGlzW0NBQ0hFXS5oYXMoa2V5KSkgcmV0dXJuIGZhbHNlXG4gICAgY29uc3QgaGl0ID0gdGhpc1tDQUNIRV0uZ2V0KGtleSkudmFsdWVcbiAgICByZXR1cm4gIWlzU3RhbGUodGhpcywgaGl0KVxuICB9XG5cbiAgZ2V0IChrZXkpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgdHJ1ZSlcbiAgfVxuXG4gIHBlZWsgKGtleSkge1xuICAgIHJldHVybiBnZXQodGhpcywga2V5LCBmYWxzZSlcbiAgfVxuXG4gIHBvcCAoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXNbTFJVX0xJU1RdLnRhaWxcbiAgICBpZiAoIW5vZGUpXG4gICAgICByZXR1cm4gbnVsbFxuXG4gICAgZGVsKHRoaXMsIG5vZGUpXG4gICAgcmV0dXJuIG5vZGUudmFsdWVcbiAgfVxuXG4gIGRlbCAoa2V5KSB7XG4gICAgZGVsKHRoaXMsIHRoaXNbQ0FDSEVdLmdldChrZXkpKVxuICB9XG5cbiAgbG9hZCAoYXJyKSB7XG4gICAgLy8gcmVzZXQgdGhlIGNhY2hlXG4gICAgdGhpcy5yZXNldCgpXG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpXG4gICAgLy8gQSBwcmV2aW91cyBzZXJpYWxpemVkIGNhY2hlIGhhcyB0aGUgbW9zdCByZWNlbnQgaXRlbXMgZmlyc3RcbiAgICBmb3IgKGxldCBsID0gYXJyLmxlbmd0aCAtIDE7IGwgPj0gMDsgbC0tKSB7XG4gICAgICBjb25zdCBoaXQgPSBhcnJbbF1cbiAgICAgIGNvbnN0IGV4cGlyZXNBdCA9IGhpdC5lIHx8IDBcbiAgICAgIGlmIChleHBpcmVzQXQgPT09IDApXG4gICAgICAgIC8vIHRoZSBpdGVtIHdhcyBjcmVhdGVkIHdpdGhvdXQgZXhwaXJhdGlvbiBpbiBhIG5vbiBhZ2VkIGNhY2hlXG4gICAgICAgIHRoaXMuc2V0KGhpdC5rLCBoaXQudilcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBtYXhBZ2UgPSBleHBpcmVzQXQgLSBub3dcbiAgICAgICAgLy8gZG9udCBhZGQgYWxyZWFkeSBleHBpcmVkIGl0ZW1zXG4gICAgICAgIGlmIChtYXhBZ2UgPiAwKSB7XG4gICAgICAgICAgdGhpcy5zZXQoaGl0LmssIGhpdC52LCBtYXhBZ2UpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcnVuZSAoKSB7XG4gICAgdGhpc1tDQUNIRV0uZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gZ2V0KHRoaXMsIGtleSwgZmFsc2UpKVxuICB9XG59XG5cbmNvbnN0IGdldCA9IChzZWxmLCBrZXksIGRvVXNlKSA9PiB7XG4gIGNvbnN0IG5vZGUgPSBzZWxmW0NBQ0hFXS5nZXQoa2V5KVxuICBpZiAobm9kZSkge1xuICAgIGNvbnN0IGhpdCA9IG5vZGUudmFsdWVcbiAgICBpZiAoaXNTdGFsZShzZWxmLCBoaXQpKSB7XG4gICAgICBkZWwoc2VsZiwgbm9kZSlcbiAgICAgIGlmICghc2VsZltBTExPV19TVEFMRV0pXG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRvVXNlKSB7XG4gICAgICAgIGlmIChzZWxmW1VQREFURV9BR0VfT05fR0VUXSlcbiAgICAgICAgICBub2RlLnZhbHVlLm5vdyA9IERhdGUubm93KClcbiAgICAgICAgc2VsZltMUlVfTElTVF0udW5zaGlmdE5vZGUobm9kZSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhpdC52YWx1ZVxuICB9XG59XG5cbmNvbnN0IGlzU3RhbGUgPSAoc2VsZiwgaGl0KSA9PiB7XG4gIGlmICghaGl0IHx8ICghaGl0Lm1heEFnZSAmJiAhc2VsZltNQVhfQUdFXSkpXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSBoaXQubm93XG4gIHJldHVybiBoaXQubWF4QWdlID8gZGlmZiA+IGhpdC5tYXhBZ2VcbiAgICA6IHNlbGZbTUFYX0FHRV0gJiYgKGRpZmYgPiBzZWxmW01BWF9BR0VdKVxufVxuXG5jb25zdCB0cmltID0gc2VsZiA9PiB7XG4gIGlmIChzZWxmW0xFTkdUSF0gPiBzZWxmW01BWF0pIHtcbiAgICBmb3IgKGxldCB3YWxrZXIgPSBzZWxmW0xSVV9MSVNUXS50YWlsO1xuICAgICAgc2VsZltMRU5HVEhdID4gc2VsZltNQVhdICYmIHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICAgIC8vIFdlIGtub3cgdGhhdCB3ZSdyZSBhYm91dCB0byBkZWxldGUgdGhpcyBvbmUsIGFuZCBhbHNvXG4gICAgICAvLyB3aGF0IHRoZSBuZXh0IGxlYXN0IHJlY2VudGx5IHVzZWQga2V5IHdpbGwgYmUsIHNvIGp1c3RcbiAgICAgIC8vIGdvIGFoZWFkIGFuZCBzZXQgaXQgbm93LlxuICAgICAgY29uc3QgcHJldiA9IHdhbGtlci5wcmV2XG4gICAgICBkZWwoc2VsZiwgd2Fsa2VyKVxuICAgICAgd2Fsa2VyID0gcHJldlxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBkZWwgPSAoc2VsZiwgbm9kZSkgPT4ge1xuICBpZiAobm9kZSkge1xuICAgIGNvbnN0IGhpdCA9IG5vZGUudmFsdWVcbiAgICBpZiAoc2VsZltESVNQT1NFXSlcbiAgICAgIHNlbGZbRElTUE9TRV0oaGl0LmtleSwgaGl0LnZhbHVlKVxuXG4gICAgc2VsZltMRU5HVEhdIC09IGhpdC5sZW5ndGhcbiAgICBzZWxmW0NBQ0hFXS5kZWxldGUoaGl0LmtleSlcbiAgICBzZWxmW0xSVV9MSVNUXS5yZW1vdmVOb2RlKG5vZGUpXG4gIH1cbn1cblxuY2xhc3MgRW50cnkge1xuICBjb25zdHJ1Y3RvciAoa2V5LCB2YWx1ZSwgbGVuZ3RoLCBub3csIG1heEFnZSkge1xuICAgIHRoaXMua2V5ID0ga2V5XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGhcbiAgICB0aGlzLm5vdyA9IG5vd1xuICAgIHRoaXMubWF4QWdlID0gbWF4QWdlIHx8IDBcbiAgfVxufVxuXG5jb25zdCBmb3JFYWNoU3RlcCA9IChzZWxmLCBmbiwgbm9kZSwgdGhpc3ApID0+IHtcbiAgbGV0IGhpdCA9IG5vZGUudmFsdWVcbiAgaWYgKGlzU3RhbGUoc2VsZiwgaGl0KSkge1xuICAgIGRlbChzZWxmLCBub2RlKVxuICAgIGlmICghc2VsZltBTExPV19TVEFMRV0pXG4gICAgICBoaXQgPSB1bmRlZmluZWRcbiAgfVxuICBpZiAoaGl0KVxuICAgIGZuLmNhbGwodGhpc3AsIGhpdC52YWx1ZSwgaGl0LmtleSwgc2VsZilcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMUlVDYWNoZVxuIiwiLy8gaG9pc3RlZCBjbGFzcyBmb3IgY3ljbGljIGRlcGVuZGVuY3lcbmNsYXNzIFJhbmdlIHtcbiAgY29uc3RydWN0b3IgKHJhbmdlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgaWYgKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpIHtcbiAgICAgIGlmIChcbiAgICAgICAgcmFuZ2UubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSAmJlxuICAgICAgICByYW5nZS5pbmNsdWRlUHJlcmVsZWFzZSA9PT0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLnJhdywgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgICAvLyBqdXN0IHB1dCBpdCBpbiB0aGUgc2V0IGFuZCByZXR1cm5cbiAgICAgIHRoaXMucmF3ID0gcmFuZ2UudmFsdWVcbiAgICAgIHRoaXMuc2V0ID0gW1tyYW5nZV1dXG4gICAgICB0aGlzLmZvcm1hdCgpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG4gICAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuXG4gICAgLy8gRmlyc3QsIHNwbGl0IGJhc2VkIG9uIGJvb2xlYW4gb3IgfHxcbiAgICB0aGlzLnJhdyA9IHJhbmdlXG4gICAgdGhpcy5zZXQgPSByYW5nZVxuICAgICAgLnNwbGl0KC9cXHMqXFx8XFx8XFxzKi8pXG4gICAgICAvLyBtYXAgdGhlIHJhbmdlIHRvIGEgMmQgYXJyYXkgb2YgY29tcGFyYXRvcnNcbiAgICAgIC5tYXAocmFuZ2UgPT4gdGhpcy5wYXJzZVJhbmdlKHJhbmdlLnRyaW0oKSkpXG4gICAgICAvLyB0aHJvdyBvdXQgYW55IGNvbXBhcmF0b3IgbGlzdHMgdGhhdCBhcmUgZW1wdHlcbiAgICAgIC8vIHRoaXMgZ2VuZXJhbGx5IG1lYW5zIHRoYXQgaXQgd2FzIG5vdCBhIHZhbGlkIHJhbmdlLCB3aGljaCBpcyBhbGxvd2VkXG4gICAgICAvLyBpbiBsb29zZSBtb2RlLCBidXQgd2lsbCBzdGlsbCB0aHJvdyBpZiB0aGUgV0hPTEUgcmFuZ2UgaXMgaW52YWxpZC5cbiAgICAgIC5maWx0ZXIoYyA9PiBjLmxlbmd0aClcblxuICAgIGlmICghdGhpcy5zZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFNlbVZlciBSYW5nZTogJHtyYW5nZX1gKVxuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmUgYW55IHRoYXQgYXJlIG5vdCB0aGUgbnVsbCBzZXQsIHRocm93IG91dCBudWxsIHNldHMuXG4gICAgaWYgKHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIGtlZXAgdGhlIGZpcnN0IG9uZSwgaW4gY2FzZSB0aGV5J3JlIGFsbCBudWxsIHNldHNcbiAgICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5zZXRbMF1cbiAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXQuZmlsdGVyKGMgPT4gIWlzTnVsbFNldChjWzBdKSlcbiAgICAgIGlmICh0aGlzLnNldC5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMuc2V0ID0gW2ZpcnN0XVxuICAgICAgZWxzZSBpZiAodGhpcy5zZXQubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGFueSB0aGF0IGFyZSAqLCB0aGVuIHRoZSByYW5nZSBpcyBqdXN0ICpcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHRoaXMuc2V0KSB7XG4gICAgICAgICAgaWYgKGMubGVuZ3RoID09PSAxICYmIGlzQW55KGNbMF0pKSB7XG4gICAgICAgICAgICB0aGlzLnNldCA9IFtjXVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZvcm1hdCgpXG4gIH1cblxuICBmb3JtYXQgKCkge1xuICAgIHRoaXMucmFuZ2UgPSB0aGlzLnNldFxuICAgICAgLm1hcCgoY29tcHMpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbXBzLmpvaW4oJyAnKS50cmltKClcbiAgICAgIH0pXG4gICAgICAuam9pbignfHwnKVxuICAgICAgLnRyaW0oKVxuICAgIHJldHVybiB0aGlzLnJhbmdlXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2VcbiAgfVxuXG4gIHBhcnNlUmFuZ2UgKHJhbmdlKSB7XG4gICAgcmFuZ2UgPSByYW5nZS50cmltKClcblxuICAgIC8vIG1lbW9pemUgcmFuZ2UgcGFyc2luZyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgLy8gdGhpcyBpcyBhIHZlcnkgaG90IHBhdGgsIGFuZCBmdWxseSBkZXRlcm1pbmlzdGljLlxuICAgIGNvbnN0IG1lbW9PcHRzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zKS5qb2luKCcsJylcbiAgICBjb25zdCBtZW1vS2V5ID0gYHBhcnNlUmFuZ2U6JHttZW1vT3B0c306JHtyYW5nZX1gXG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KG1lbW9LZXkpXG4gICAgaWYgKGNhY2hlZClcbiAgICAgIHJldHVybiBjYWNoZWRcblxuICAgIGNvbnN0IGxvb3NlID0gdGhpcy5vcHRpb25zLmxvb3NlXG4gICAgLy8gYDEuMi4zIC0gMS4yLjRgID0+IGA+PTEuMi4zIDw9MS4yLjRgXG4gICAgY29uc3QgaHIgPSBsb29zZSA/IHJlW3QuSFlQSEVOUkFOR0VMT09TRV0gOiByZVt0LkhZUEhFTlJBTkdFXVxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShociwgaHlwaGVuUmVwbGFjZSh0aGlzLm9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpKVxuICAgIGRlYnVnKCdoeXBoZW4gcmVwbGFjZScsIHJhbmdlKVxuICAgIC8vIGA+IDEuMi4zIDwgMS4yLjVgID0+IGA+MS4yLjMgPDEuMi41YFxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LkNPTVBBUkFUT1JUUklNXSwgY29tcGFyYXRvclRyaW1SZXBsYWNlKVxuICAgIGRlYnVnKCdjb21wYXJhdG9yIHRyaW0nLCByYW5nZSwgcmVbdC5DT01QQVJBVE9SVFJJTV0pXG5cbiAgICAvLyBgfiAxLjIuM2AgPT4gYH4xLjIuM2BcbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5USUxERVRSSU1dLCB0aWxkZVRyaW1SZXBsYWNlKVxuXG4gICAgLy8gYF4gMS4yLjNgID0+IGBeMS4yLjNgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuQ0FSRVRUUklNXSwgY2FyZXRUcmltUmVwbGFjZSlcblxuICAgIC8vIG5vcm1hbGl6ZSBzcGFjZXNcbiAgICByYW5nZSA9IHJhbmdlLnNwbGl0KC9cXHMrLykuam9pbignICcpXG5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSB0cmltbWVkIGFuZFxuICAgIC8vIHJlYWR5IHRvIGJlIHNwbGl0IGludG8gY29tcGFyYXRvcnMuXG5cbiAgICBjb25zdCBjb21wUmUgPSBsb29zZSA/IHJlW3QuQ09NUEFSQVRPUkxPT1NFXSA6IHJlW3QuQ09NUEFSQVRPUl1cbiAgICBjb25zdCByYW5nZUxpc3QgPSByYW5nZVxuICAgICAgLnNwbGl0KCcgJylcbiAgICAgIC5tYXAoY29tcCA9PiBwYXJzZUNvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKSlcbiAgICAgIC5qb2luKCcgJylcbiAgICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgICAvLyA+PTAuMC4wIGlzIGVxdWl2YWxlbnQgdG8gKlxuICAgICAgLm1hcChjb21wID0+IHJlcGxhY2VHVEUwKGNvbXAsIHRoaXMub3B0aW9ucykpXG4gICAgICAvLyBpbiBsb29zZSBtb2RlLCB0aHJvdyBvdXQgYW55IHRoYXQgYXJlIG5vdCB2YWxpZCBjb21wYXJhdG9yc1xuICAgICAgLmZpbHRlcih0aGlzLm9wdGlvbnMubG9vc2UgPyBjb21wID0+ICEhY29tcC5tYXRjaChjb21wUmUpIDogKCkgPT4gdHJ1ZSlcbiAgICAgIC5tYXAoY29tcCA9PiBuZXcgQ29tcGFyYXRvcihjb21wLCB0aGlzLm9wdGlvbnMpKVxuXG4gICAgLy8gaWYgYW55IGNvbXBhcmF0b3JzIGFyZSB0aGUgbnVsbCBzZXQsIHRoZW4gcmVwbGFjZSB3aXRoIEpVU1QgbnVsbCBzZXRcbiAgICAvLyBpZiBtb3JlIHRoYW4gb25lIGNvbXBhcmF0b3IsIHJlbW92ZSBhbnkgKiBjb21wYXJhdG9yc1xuICAgIC8vIGFsc28sIGRvbid0IGluY2x1ZGUgdGhlIHNhbWUgY29tcGFyYXRvciBtb3JlIHRoYW4gb25jZVxuICAgIGNvbnN0IGwgPSByYW5nZUxpc3QubGVuZ3RoXG4gICAgY29uc3QgcmFuZ2VNYXAgPSBuZXcgTWFwKClcbiAgICBmb3IgKGNvbnN0IGNvbXAgb2YgcmFuZ2VMaXN0KSB7XG4gICAgICBpZiAoaXNOdWxsU2V0KGNvbXApKVxuICAgICAgICByZXR1cm4gW2NvbXBdXG4gICAgICByYW5nZU1hcC5zZXQoY29tcC52YWx1ZSwgY29tcClcbiAgICB9XG4gICAgaWYgKHJhbmdlTWFwLnNpemUgPiAxICYmIHJhbmdlTWFwLmhhcygnJykpXG4gICAgICByYW5nZU1hcC5kZWxldGUoJycpXG5cbiAgICBjb25zdCByZXN1bHQgPSBbLi4ucmFuZ2VNYXAudmFsdWVzKCldXG4gICAgY2FjaGUuc2V0KG1lbW9LZXksIHJlc3VsdClcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBpbnRlcnNlY3RzIChyYW5nZSwgb3B0aW9ucykge1xuICAgIGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIFJhbmdlIGlzIHJlcXVpcmVkJylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXQuc29tZSgodGhpc0NvbXBhcmF0b3JzKSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBpc1NhdGlzZmlhYmxlKHRoaXNDb21wYXJhdG9ycywgb3B0aW9ucykgJiZcbiAgICAgICAgcmFuZ2Uuc2V0LnNvbWUoKHJhbmdlQ29tcGFyYXRvcnMpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXNTYXRpc2ZpYWJsZShyYW5nZUNvbXBhcmF0b3JzLCBvcHRpb25zKSAmJlxuICAgICAgICAgICAgdGhpc0NvbXBhcmF0b3JzLmV2ZXJ5KCh0aGlzQ29tcGFyYXRvcikgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VDb21wYXJhdG9ycy5ldmVyeSgocmFuZ2VDb21wYXJhdG9yKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNDb21wYXJhdG9yLmludGVyc2VjdHMocmFuZ2VDb21wYXJhdG9yLCBvcHRpb25zKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfSlcbiAgfVxuXG4gIC8vIGlmIEFOWSBvZiB0aGUgc2V0cyBtYXRjaCBBTEwgb2YgaXRzIGNvbXBhcmF0b3JzLCB0aGVuIHBhc3NcbiAgdGVzdCAodmVyc2lvbikge1xuICAgIGlmICghdmVyc2lvbikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNldC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRlc3RTZXQodGhpcy5zZXRbaV0sIHZlcnNpb24sIHRoaXMub3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gUmFuZ2VcblxuY29uc3QgTFJVID0gcmVxdWlyZSgnbHJ1LWNhY2hlJylcbmNvbnN0IGNhY2hlID0gbmV3IExSVSh7IG1heDogMTAwMCB9KVxuXG5jb25zdCBwYXJzZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9wYXJzZS1vcHRpb25zJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuL2NvbXBhcmF0b3InKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuL3NlbXZlcicpXG5jb25zdCB7XG4gIHJlLFxuICB0LFxuICBjb21wYXJhdG9yVHJpbVJlcGxhY2UsXG4gIHRpbGRlVHJpbVJlcGxhY2UsXG4gIGNhcmV0VHJpbVJlcGxhY2Vcbn0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IGlzTnVsbFNldCA9IGMgPT4gYy52YWx1ZSA9PT0gJzwwLjAuMC0wJ1xuY29uc3QgaXNBbnkgPSBjID0+IGMudmFsdWUgPT09ICcnXG5cbi8vIHRha2UgYSBzZXQgb2YgY29tcGFyYXRvcnMgYW5kIGRldGVybWluZSB3aGV0aGVyIHRoZXJlXG4vLyBleGlzdHMgYSB2ZXJzaW9uIHdoaWNoIGNhbiBzYXRpc2Z5IGl0XG5jb25zdCBpc1NhdGlzZmlhYmxlID0gKGNvbXBhcmF0b3JzLCBvcHRpb25zKSA9PiB7XG4gIGxldCByZXN1bHQgPSB0cnVlXG4gIGNvbnN0IHJlbWFpbmluZ0NvbXBhcmF0b3JzID0gY29tcGFyYXRvcnMuc2xpY2UoKVxuICBsZXQgdGVzdENvbXBhcmF0b3IgPSByZW1haW5pbmdDb21wYXJhdG9ycy5wb3AoKVxuXG4gIHdoaWxlIChyZXN1bHQgJiYgcmVtYWluaW5nQ29tcGFyYXRvcnMubGVuZ3RoKSB7XG4gICAgcmVzdWx0ID0gcmVtYWluaW5nQ29tcGFyYXRvcnMuZXZlcnkoKG90aGVyQ29tcGFyYXRvcikgPT4ge1xuICAgICAgcmV0dXJuIHRlc3RDb21wYXJhdG9yLmludGVyc2VjdHMob3RoZXJDb21wYXJhdG9yLCBvcHRpb25zKVxuICAgIH0pXG5cbiAgICB0ZXN0Q29tcGFyYXRvciA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLnBvcCgpXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIGNvbXByaXNlZCBvZiB4cmFuZ2VzLCB0aWxkZXMsIHN0YXJzLCBhbmQgZ3RsdCdzIGF0IHRoaXMgcG9pbnQuXG4vLyBhbHJlYWR5IHJlcGxhY2VkIHRoZSBoeXBoZW4gcmFuZ2VzXG4vLyB0dXJuIGludG8gYSBzZXQgb2YgSlVTVCBjb21wYXJhdG9ycy5cbmNvbnN0IHBhcnNlQ29tcGFyYXRvciA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdjb21wJywgY29tcCwgb3B0aW9ucylcbiAgY29tcCA9IHJlcGxhY2VDYXJldHMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ2NhcmV0JywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VUaWxkZXMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3RpbGRlcycsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlWFJhbmdlcyhjb21wLCBvcHRpb25zKVxuICBkZWJ1ZygneHJhbmdlJywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VTdGFycyhjb21wLCBvcHRpb25zKVxuICBkZWJ1Zygnc3RhcnMnLCBjb21wKVxuICByZXR1cm4gY29tcFxufVxuXG5jb25zdCBpc1ggPSBpZCA9PiAhaWQgfHwgaWQudG9Mb3dlckNhc2UoKSA9PT0gJ3gnIHx8IGlkID09PSAnKidcblxuLy8gfiwgfj4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyB+MiwgfjIueCwgfjIueC54LCB+PjIsIH4+Mi54IH4+Mi54LnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIH4yLjAsIH4yLjAueCwgfj4yLjAsIH4+Mi4wLnggLS0+ID49Mi4wLjAgPDIuMS4wLTBcbi8vIH4xLjIsIH4xLjIueCwgfj4xLjIsIH4+MS4yLnggLS0+ID49MS4yLjAgPDEuMy4wLTBcbi8vIH4xLjIuMywgfj4xLjIuMyAtLT4gPj0xLjIuMyA8MS4zLjAtMFxuLy8gfjEuMi4wLCB+PjEuMi4wIC0tPiA+PTEuMi4wIDwxLjMuMC0wXG5jb25zdCByZXBsYWNlVGlsZGVzID0gKGNvbXAsIG9wdGlvbnMpID0+XG4gIGNvbXAudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKChjb21wKSA9PiB7XG4gICAgcmV0dXJuIHJlcGxhY2VUaWxkZShjb21wLCBvcHRpb25zKVxuICB9KS5qb2luKCcgJylcblxuY29uc3QgcmVwbGFjZVRpbGRlID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LlRJTERFTE9PU0VdIDogcmVbdC5USUxERV1cbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCAoXywgTSwgbSwgcCwgcHIpID0+IHtcbiAgICBkZWJ1ZygndGlsZGUnLCBjb21wLCBfLCBNLCBtLCBwLCBwcilcbiAgICBsZXQgcmV0XG5cbiAgICBpZiAoaXNYKE0pKSB7XG4gICAgICByZXQgPSAnJ1xuICAgIH0gZWxzZSBpZiAoaXNYKG0pKSB7XG4gICAgICByZXQgPSBgPj0ke019LjAuMCA8JHsrTSArIDF9LjAuMC0wYFxuICAgIH0gZWxzZSBpZiAoaXNYKHApKSB7XG4gICAgICAvLyB+MS4yID09ID49MS4yLjAgPDEuMy4wLTBcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wIDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgfSBlbHNlIGlmIChwcikge1xuICAgICAgZGVidWcoJ3JlcGxhY2VUaWxkZSBwcicsIHByKVxuICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwclxuICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB+MS4yLjMgPT0gPj0xLjIuMyA8MS4zLjAtMFxuICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH1cblxuICAgIGRlYnVnKCd0aWxkZSByZXR1cm4nLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG4vLyBeIC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gXjIsIF4yLngsIF4yLngueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuLy8gXjIuMCwgXjIuMC54IC0tPiA+PTIuMC4wIDwzLjAuMC0wXG4vLyBeMS4yLCBeMS4yLnggLS0+ID49MS4yLjAgPDIuMC4wLTBcbi8vIF4xLjIuMyAtLT4gPj0xLjIuMyA8Mi4wLjAtMFxuLy8gXjEuMi4wIC0tPiA+PTEuMi4wIDwyLjAuMC0wXG5jb25zdCByZXBsYWNlQ2FyZXRzID0gKGNvbXAsIG9wdGlvbnMpID0+XG4gIGNvbXAudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKChjb21wKSA9PiB7XG4gICAgcmV0dXJuIHJlcGxhY2VDYXJldChjb21wLCBvcHRpb25zKVxuICB9KS5qb2luKCcgJylcblxuY29uc3QgcmVwbGFjZUNhcmV0ID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ2NhcmV0JywgY29tcCwgb3B0aW9ucylcbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LkNBUkVUTE9PU0VdIDogcmVbdC5DQVJFVF1cbiAgY29uc3QgeiA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyAnLTAnIDogJydcbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCAoXywgTSwgbSwgcCwgcHIpID0+IHtcbiAgICBkZWJ1ZygnY2FyZXQnLCBjb21wLCBfLCBNLCBtLCBwLCBwcilcbiAgICBsZXQgcmV0XG5cbiAgICBpZiAoaXNYKE0pKSB7XG4gICAgICByZXQgPSAnJ1xuICAgIH0gZWxzZSBpZiAoaXNYKG0pKSB7XG4gICAgICByZXQgPSBgPj0ke019LjAuMCR7en0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKGlzWChwKSkge1xuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7en0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wJHt6fSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlQ2FyZXQgcHInLCBwcilcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgaWYgKG0gPT09ICcwJykge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgICB9IDwke019LiR7bX0uJHsrcCArIDF9LTBgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwclxuICAgICAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwclxuICAgICAgICB9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdubyBwcicpXG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwXG4gICAgICAgICAgfSR7en0gPCR7TX0uJHttfS4keytwICsgMX0tMGBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwXG4gICAgICAgICAgfSR7en0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICB9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVidWcoJ2NhcmV0IHJldHVybicsIHJldClcbiAgICByZXR1cm4gcmV0XG4gIH0pXG59XG5cbmNvbnN0IHJlcGxhY2VYUmFuZ2VzID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ3JlcGxhY2VYUmFuZ2VzJywgY29tcCwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAuc3BsaXQoL1xccysvKS5tYXAoKGNvbXApID0+IHtcbiAgICByZXR1cm4gcmVwbGFjZVhSYW5nZShjb21wLCBvcHRpb25zKVxuICB9KS5qb2luKCcgJylcbn1cblxuY29uc3QgcmVwbGFjZVhSYW5nZSA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGNvbXAgPSBjb21wLnRyaW0oKVxuICBjb25zdCByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuWFJBTkdFTE9PU0VdIDogcmVbdC5YUkFOR0VdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpID0+IHtcbiAgICBkZWJ1ZygneFJhbmdlJywgY29tcCwgcmV0LCBndGx0LCBNLCBtLCBwLCBwcilcbiAgICBjb25zdCB4TSA9IGlzWChNKVxuICAgIGNvbnN0IHhtID0geE0gfHwgaXNYKG0pXG4gICAgY29uc3QgeHAgPSB4bSB8fCBpc1gocClcbiAgICBjb25zdCBhbnlYID0geHBcblxuICAgIGlmIChndGx0ID09PSAnPScgJiYgYW55WCkge1xuICAgICAgZ3RsdCA9ICcnXG4gICAgfVxuXG4gICAgLy8gaWYgd2UncmUgaW5jbHVkaW5nIHByZXJlbGVhc2VzIGluIHRoZSBtYXRjaCwgdGhlbiB3ZSBuZWVkXG4gICAgLy8gdG8gZml4IHRoaXMgdG8gLTAsIHRoZSBsb3dlc3QgcG9zc2libGUgcHJlcmVsZWFzZSB2YWx1ZVxuICAgIHByID0gb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/ICctMCcgOiAnJ1xuXG4gICAgaWYgKHhNKSB7XG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nIHx8IGd0bHQgPT09ICc8Jykge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGFsbG93ZWRcbiAgICAgICAgcmV0ID0gJzwwLjAuMC0wJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBmb3JiaWRkZW5cbiAgICAgICAgcmV0ID0gJyonXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChndGx0ICYmIGFueVgpIHtcbiAgICAgIC8vIHdlIGtub3cgcGF0Y2ggaXMgYW4geCwgYmVjYXVzZSB3ZSBoYXZlIGFueSB4IGF0IGFsbC5cbiAgICAgIC8vIHJlcGxhY2UgWCB3aXRoIDBcbiAgICAgIGlmICh4bSkge1xuICAgICAgICBtID0gMFxuICAgICAgfVxuICAgICAgcCA9IDBcblxuICAgICAgaWYgKGd0bHQgPT09ICc+Jykge1xuICAgICAgICAvLyA+MSA9PiA+PTIuMC4wXG4gICAgICAgIC8vID4xLjIgPT4gPj0xLjMuMFxuICAgICAgICBndGx0ID0gJz49J1xuICAgICAgICBpZiAoeG0pIHtcbiAgICAgICAgICBNID0gK00gKyAxXG4gICAgICAgICAgbSA9IDBcbiAgICAgICAgICBwID0gMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSArbSArIDFcbiAgICAgICAgICBwID0gMFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGd0bHQgPT09ICc8PScpIHtcbiAgICAgICAgLy8gPD0wLjcueCBpcyBhY3R1YWxseSA8MC44LjAsIHNpbmNlIGFueSAwLjcueCBzaG91bGRcbiAgICAgICAgLy8gcGFzcy4gIFNpbWlsYXJseSwgPD03LnggaXMgYWN0dWFsbHkgPDguMC4wLCBldGMuXG4gICAgICAgIGd0bHQgPSAnPCdcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSArbSArIDFcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZ3RsdCA9PT0gJzwnKVxuICAgICAgICBwciA9ICctMCdcblxuICAgICAgcmV0ID0gYCR7Z3RsdCArIE19LiR7bX0uJHtwfSR7cHJ9YFxuICAgIH0gZWxzZSBpZiAoeG0pIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uMC4wJHtwcn0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKHhwKSB7XG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7cHJcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9XG5cbiAgICBkZWJ1ZygneFJhbmdlIHJldHVybicsIHJldClcblxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuLy8gQmVjYXVzZSAqIGlzIEFORC1lZCB3aXRoIGV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgY29tcGFyYXRvcixcbi8vIGFuZCAnJyBtZWFucyBcImFueSB2ZXJzaW9uXCIsIGp1c3QgcmVtb3ZlIHRoZSAqcyBlbnRpcmVseS5cbmNvbnN0IHJlcGxhY2VTdGFycyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlU3RhcnMnLCBjb21wLCBvcHRpb25zKVxuICAvLyBMb29zZW5lc3MgaXMgaWdub3JlZCBoZXJlLiAgc3RhciBpcyBhbHdheXMgYXMgbG9vc2UgYXMgaXQgZ2V0cyFcbiAgcmV0dXJuIGNvbXAudHJpbSgpLnJlcGxhY2UocmVbdC5TVEFSXSwgJycpXG59XG5cbmNvbnN0IHJlcGxhY2VHVEUwID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ3JlcGxhY2VHVEUwJywgY29tcCwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAudHJpbSgpXG4gICAgLnJlcGxhY2UocmVbb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/IHQuR1RFMFBSRSA6IHQuR1RFMF0sICcnKVxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHBhc3NlZCB0byBzdHJpbmcucmVwbGFjZShyZVt0LkhZUEhFTlJBTkdFXSlcbi8vIE0sIG0sIHBhdGNoLCBwcmVyZWxlYXNlLCBidWlsZFxuLy8gMS4yIC0gMy40LjUgPT4gPj0xLjIuMCA8PTMuNC41XG4vLyAxLjIuMyAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMC0wIEFueSAzLjQueCB3aWxsIGRvXG4vLyAxLjIgLSAzLjQgPT4gPj0xLjIuMCA8My41LjAtMFxuY29uc3QgaHlwaGVuUmVwbGFjZSA9IGluY1ByID0+ICgkMCxcbiAgZnJvbSwgZk0sIGZtLCBmcCwgZnByLCBmYixcbiAgdG8sIHRNLCB0bSwgdHAsIHRwciwgdGIpID0+IHtcbiAgaWYgKGlzWChmTSkpIHtcbiAgICBmcm9tID0gJydcbiAgfSBlbHNlIGlmIChpc1goZm0pKSB7XG4gICAgZnJvbSA9IGA+PSR7Zk19LjAuMCR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9IGVsc2UgaWYgKGlzWChmcCkpIHtcbiAgICBmcm9tID0gYD49JHtmTX0uJHtmbX0uMCR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9IGVsc2UgaWYgKGZwcikge1xuICAgIGZyb20gPSBgPj0ke2Zyb219YFxuICB9IGVsc2Uge1xuICAgIGZyb20gPSBgPj0ke2Zyb219JHtpbmNQciA/ICctMCcgOiAnJ31gXG4gIH1cblxuICBpZiAoaXNYKHRNKSkge1xuICAgIHRvID0gJydcbiAgfSBlbHNlIGlmIChpc1godG0pKSB7XG4gICAgdG8gPSBgPCR7K3RNICsgMX0uMC4wLTBgXG4gIH0gZWxzZSBpZiAoaXNYKHRwKSkge1xuICAgIHRvID0gYDwke3RNfS4keyt0bSArIDF9LjAtMGBcbiAgfSBlbHNlIGlmICh0cHIpIHtcbiAgICB0byA9IGA8PSR7dE19LiR7dG19LiR7dHB9LSR7dHByfWBcbiAgfSBlbHNlIGlmIChpbmNQcikge1xuICAgIHRvID0gYDwke3RNfS4ke3RtfS4keyt0cCArIDF9LTBgXG4gIH0gZWxzZSB7XG4gICAgdG8gPSBgPD0ke3RvfWBcbiAgfVxuXG4gIHJldHVybiAoYCR7ZnJvbX0gJHt0b31gKS50cmltKClcbn1cblxuY29uc3QgdGVzdFNldCA9IChzZXQsIHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXNldFtpXS50ZXN0KHZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBpZiAodmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgIC8vIEZpbmQgdGhlIHNldCBvZiB2ZXJzaW9ucyB0aGF0IGFyZSBhbGxvd2VkIHRvIGhhdmUgcHJlcmVsZWFzZXNcbiAgICAvLyBGb3IgZXhhbXBsZSwgXjEuMi4zLXByLjEgZGVzdWdhcnMgdG8gPj0xLjIuMy1wci4xIDwyLjAuMFxuICAgIC8vIFRoYXQgc2hvdWxkIGFsbG93IGAxLjIuMy1wci4yYCB0byBwYXNzLlxuICAgIC8vIEhvd2V2ZXIsIGAxLjIuNC1hbHBoYS5ub3RyZWFkeWAgc2hvdWxkIE5PVCBiZSBhbGxvd2VkLFxuICAgIC8vIGV2ZW4gdGhvdWdoIGl0J3Mgd2l0aGluIHRoZSByYW5nZSBzZXQgYnkgdGhlIGNvbXBhcmF0b3JzLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWJ1ZyhzZXRbaV0uc2VtdmVyKVxuICAgICAgaWYgKHNldFtpXS5zZW12ZXIgPT09IENvbXBhcmF0b3IuQU5ZKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBhbGxvd2VkID0gc2V0W2ldLnNlbXZlclxuICAgICAgICBpZiAoYWxsb3dlZC5tYWpvciA9PT0gdmVyc2lvbi5tYWpvciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5taW5vciA9PT0gdmVyc2lvbi5taW5vciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5wYXRjaCA9PT0gdmVyc2lvbi5wYXRjaCkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWZXJzaW9uIGhhcyBhIC1wcmUsIGJ1dCBpdCdzIG5vdCBvbmUgb2YgdGhlIG9uZXMgd2UgbGlrZS5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCJjb25zdCBBTlkgPSBTeW1ib2woJ1NlbVZlciBBTlknKVxuLy8gaG9pc3RlZCBjbGFzcyBmb3IgY3ljbGljIGRlcGVuZGVuY3lcbmNsYXNzIENvbXBhcmF0b3Ige1xuICBzdGF0aWMgZ2V0IEFOWSAoKSB7XG4gICAgcmV0dXJuIEFOWVxuICB9XG4gIGNvbnN0cnVjdG9yIChjb21wLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgaWYgKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgICBpZiAoY29tcC5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlKSB7XG4gICAgICAgIHJldHVybiBjb21wXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wID0gY29tcC52YWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGRlYnVnKCdjb21wYXJhdG9yJywgY29tcCwgb3B0aW9ucylcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICAgIHRoaXMucGFyc2UoY29tcClcblxuICAgIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICB0aGlzLnZhbHVlID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMub3BlcmF0b3IgKyB0aGlzLnNlbXZlci52ZXJzaW9uXG4gICAgfVxuXG4gICAgZGVidWcoJ2NvbXAnLCB0aGlzKVxuICB9XG5cbiAgcGFyc2UgKGNvbXApIHtcbiAgICBjb25zdCByID0gdGhpcy5vcHRpb25zLmxvb3NlID8gcmVbdC5DT01QQVJBVE9STE9PU0VdIDogcmVbdC5DT01QQVJBVE9SXVxuICAgIGNvbnN0IG0gPSBjb21wLm1hdGNoKHIpXG5cbiAgICBpZiAoIW0pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgY29tcGFyYXRvcjogJHtjb21wfWApXG4gICAgfVxuXG4gICAgdGhpcy5vcGVyYXRvciA9IG1bMV0gIT09IHVuZGVmaW5lZCA/IG1bMV0gOiAnJ1xuICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSAnPScpIHtcbiAgICAgIHRoaXMub3BlcmF0b3IgPSAnJ1xuICAgIH1cblxuICAgIC8vIGlmIGl0IGxpdGVyYWxseSBpcyBqdXN0ICc+JyBvciAnJyB0aGVuIGFsbG93IGFueXRoaW5nLlxuICAgIGlmICghbVsyXSkge1xuICAgICAgdGhpcy5zZW12ZXIgPSBBTllcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW12ZXIgPSBuZXcgU2VtVmVyKG1bMl0sIHRoaXMub3B0aW9ucy5sb29zZSlcbiAgICB9XG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVcbiAgfVxuXG4gIHRlc3QgKHZlcnNpb24pIHtcbiAgICBkZWJ1ZygnQ29tcGFyYXRvci50ZXN0JywgdmVyc2lvbiwgdGhpcy5vcHRpb25zLmxvb3NlKVxuXG4gICAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkgfHwgdmVyc2lvbiA9PT0gQU5ZKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMub3B0aW9ucylcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbXAodmVyc2lvbiwgdGhpcy5vcGVyYXRvciwgdGhpcy5zZW12ZXIsIHRoaXMub3B0aW9ucylcbiAgfVxuXG4gIGludGVyc2VjdHMgKGNvbXAsIG9wdGlvbnMpIHtcbiAgICBpZiAoIShjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgQ29tcGFyYXRvciBpcyByZXF1aXJlZCcpXG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgbG9vc2U6ICEhb3B0aW9ucyxcbiAgICAgICAgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgICBpZiAodGhpcy52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmFuZ2UoY29tcC52YWx1ZSwgb3B0aW9ucykudGVzdCh0aGlzLnZhbHVlKVxuICAgIH0gZWxzZSBpZiAoY29tcC5vcGVyYXRvciA9PT0gJycpIHtcbiAgICAgIGlmIChjb21wLnZhbHVlID09PSAnJykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYW5nZSh0aGlzLnZhbHVlLCBvcHRpb25zKS50ZXN0KGNvbXAuc2VtdmVyKVxuICAgIH1cblxuICAgIGNvbnN0IHNhbWVEaXJlY3Rpb25JbmNyZWFzaW5nID1cbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiZcbiAgICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc+JylcbiAgICBjb25zdCBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyA9XG4gICAgICAodGhpcy5vcGVyYXRvciA9PT0gJzw9JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPCcpICYmXG4gICAgICAoY29tcC5vcGVyYXRvciA9PT0gJzw9JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPCcpXG4gICAgY29uc3Qgc2FtZVNlbVZlciA9IHRoaXMuc2VtdmVyLnZlcnNpb24gPT09IGNvbXAuc2VtdmVyLnZlcnNpb25cbiAgICBjb25zdCBkaWZmZXJlbnREaXJlY3Rpb25zSW5jbHVzaXZlID1cbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8PScpICYmXG4gICAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPD0nKVxuICAgIGNvbnN0IG9wcG9zaXRlRGlyZWN0aW9uc0xlc3NUaGFuID1cbiAgICAgIGNtcCh0aGlzLnNlbXZlciwgJzwnLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiZcbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiZcbiAgICAgICAgKGNvbXAub3BlcmF0b3IgPT09ICc8PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzwnKVxuICAgIGNvbnN0IG9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuID1cbiAgICAgIGNtcCh0aGlzLnNlbXZlciwgJz4nLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiZcbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPD0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8JykgJiZcbiAgICAgICAgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJz4nKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIHNhbWVEaXJlY3Rpb25JbmNyZWFzaW5nIHx8XG4gICAgICBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyB8fFxuICAgICAgKHNhbWVTZW1WZXIgJiYgZGlmZmVyZW50RGlyZWN0aW9uc0luY2x1c2l2ZSkgfHxcbiAgICAgIG9wcG9zaXRlRGlyZWN0aW9uc0xlc3NUaGFuIHx8XG4gICAgICBvcHBvc2l0ZURpcmVjdGlvbnNHcmVhdGVyVGhhblxuICAgIClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBhcmF0b3JcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCB7cmUsIHR9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuY29uc3QgY21wID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NtcCcpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4vc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi9yYW5nZScpXG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3Qgc2F0aXNmaWVzID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIHRyeSB7XG4gICAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHJhbmdlLnRlc3QodmVyc2lvbilcbn1cbm1vZHVsZS5leHBvcnRzID0gc2F0aXNmaWVzXG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuXG4vLyBNb3N0bHkganVzdCBmb3IgdGVzdGluZyBhbmQgbGVnYWN5IEFQSSByZWFzb25zXG5jb25zdCB0b0NvbXBhcmF0b3JzID0gKHJhbmdlLCBvcHRpb25zKSA9PlxuICBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpLnNldFxuICAgIC5tYXAoY29tcCA9PiBjb21wLm1hcChjID0+IGMudmFsdWUpLmpvaW4oJyAnKS50cmltKCkuc3BsaXQoJyAnKSlcblxubW9kdWxlLmV4cG9ydHMgPSB0b0NvbXBhcmF0b3JzXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuXG5jb25zdCBtYXhTYXRpc2Z5aW5nID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBsZXQgbWF4ID0gbnVsbFxuICBsZXQgbWF4U1YgPSBudWxsXG4gIGxldCByYW5nZU9iaiA9IG51bGxcbiAgdHJ5IHtcbiAgICByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZlcnNpb25zLmZvckVhY2goKHYpID0+IHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkge1xuICAgICAgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtYXggfHwgbWF4U1YuY29tcGFyZSh2KSA9PT0gLTEpIHtcbiAgICAgICAgLy8gY29tcGFyZShtYXgsIHYsIHRydWUpXG4gICAgICAgIG1heCA9IHZcbiAgICAgICAgbWF4U1YgPSBuZXcgU2VtVmVyKG1heCwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBtYXhcbn1cbm1vZHVsZS5leHBvcnRzID0gbWF4U2F0aXNmeWluZ1xuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IG1pblNhdGlzZnlpbmcgPSAodmVyc2lvbnMsIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIGxldCBtaW4gPSBudWxsXG4gIGxldCBtaW5TViA9IG51bGxcbiAgbGV0IHJhbmdlT2JqID0gbnVsbFxuICB0cnkge1xuICAgIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmVyc2lvbnMuZm9yRWFjaCgodikgPT4ge1xuICAgIGlmIChyYW5nZU9iai50ZXN0KHYpKSB7XG4gICAgICAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgICBpZiAoIW1pbiB8fCBtaW5TVi5jb21wYXJlKHYpID09PSAxKSB7XG4gICAgICAgIC8vIGNvbXBhcmUobWluLCB2LCB0cnVlKVxuICAgICAgICBtaW4gPSB2XG4gICAgICAgIG1pblNWID0gbmV3IFNlbVZlcihtaW4sIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWluXG59XG5tb2R1bGUuZXhwb3J0cyA9IG1pblNhdGlzZnlpbmdcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9ndCcpXG5cbmNvbnN0IG1pblZlcnNpb24gPSAocmFuZ2UsIGxvb3NlKSA9PiB7XG4gIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSlcblxuICBsZXQgbWludmVyID0gbmV3IFNlbVZlcignMC4wLjAnKVxuICBpZiAocmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgbWludmVyID0gbmV3IFNlbVZlcignMC4wLjAtMCcpXG4gIGlmIChyYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICBtaW52ZXIgPSBudWxsXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV1cblxuICAgIGxldCBzZXRNaW4gPSBudWxsXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaCgoY29tcGFyYXRvcikgPT4ge1xuICAgICAgLy8gQ2xvbmUgdG8gYXZvaWQgbWFuaXB1bGF0aW5nIHRoZSBjb21wYXJhdG9yJ3Mgc2VtdmVyIG9iamVjdC5cbiAgICAgIGNvbnN0IGNvbXB2ZXIgPSBuZXcgU2VtVmVyKGNvbXBhcmF0b3Iuc2VtdmVyLnZlcnNpb24pXG4gICAgICBzd2l0Y2ggKGNvbXBhcmF0b3Iub3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgaWYgKGNvbXB2ZXIucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbXB2ZXIucGF0Y2grK1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wdmVyLnByZXJlbGVhc2UucHVzaCgwKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb21wdmVyLnJhdyA9IGNvbXB2ZXIuZm9ybWF0KClcbiAgICAgICAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICcnOlxuICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgaWYgKCFzZXRNaW4gfHwgZ3QoY29tcHZlciwgc2V0TWluKSkge1xuICAgICAgICAgICAgc2V0TWluID0gY29tcHZlclxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgIC8qIElnbm9yZSBtYXhpbXVtIHZlcnNpb25zICovXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgb3BlcmF0aW9uOiAke2NvbXBhcmF0b3Iub3BlcmF0b3J9YClcbiAgICAgIH1cbiAgICB9KVxuICAgIGlmIChzZXRNaW4gJiYgKCFtaW52ZXIgfHwgZ3QobWludmVyLCBzZXRNaW4pKSlcbiAgICAgIG1pbnZlciA9IHNldE1pblxuICB9XG5cbiAgaWYgKG1pbnZlciAmJiByYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBtaW5WZXJzaW9uXG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgdmFsaWRSYW5nZSA9IChyYW5nZSwgb3B0aW9ucykgPT4ge1xuICB0cnkge1xuICAgIC8vIFJldHVybiAnKicgaW5zdGVhZCBvZiAnJyBzbyB0aGF0IHRydXRoaW5lc3Mgd29ya3MuXG4gICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIGl0J3MgaW52YWxpZCBhbnl3YXlcbiAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKS5yYW5nZSB8fCAnKidcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkUmFuZ2VcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuLi9jbGFzc2VzL2NvbXBhcmF0b3InKVxuY29uc3Qge0FOWX0gPSBDb21wYXJhdG9yXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcycpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9ndCcpXG5jb25zdCBsdCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9sdCcpXG5jb25zdCBsdGUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvbHRlJylcbmNvbnN0IGd0ZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9ndGUnKVxuXG5jb25zdCBvdXRzaWRlID0gKHZlcnNpb24sIHJhbmdlLCBoaWxvLCBvcHRpb25zKSA9PiB7XG4gIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpXG4gIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuXG4gIGxldCBndGZuLCBsdGVmbiwgbHRmbiwgY29tcCwgZWNvbXBcbiAgc3dpdGNoIChoaWxvKSB7XG4gICAgY2FzZSAnPic6XG4gICAgICBndGZuID0gZ3RcbiAgICAgIGx0ZWZuID0gbHRlXG4gICAgICBsdGZuID0gbHRcbiAgICAgIGNvbXAgPSAnPidcbiAgICAgIGVjb21wID0gJz49J1xuICAgICAgYnJlYWtcbiAgICBjYXNlICc8JzpcbiAgICAgIGd0Zm4gPSBsdFxuICAgICAgbHRlZm4gPSBndGVcbiAgICAgIGx0Zm4gPSBndFxuICAgICAgY29tcCA9ICc8J1xuICAgICAgZWNvbXAgPSAnPD0nXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNdXN0IHByb3ZpZGUgYSBoaWxvIHZhbCBvZiBcIjxcIiBvciBcIj5cIicpXG4gIH1cblxuICAvLyBJZiBpdCBzYXRpc2ZpZXMgdGhlIHJhbmdlIGl0IGlzIG5vdCBvdXRzaWRlXG4gIGlmIChzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBGcm9tIG5vdyBvbiwgdmFyaWFibGUgdGVybXMgYXJlIGFzIGlmIHdlJ3JlIGluIFwiZ3RyXCIgbW9kZS5cbiAgLy8gYnV0IG5vdGUgdGhhdCBldmVyeXRoaW5nIGlzIGZsaXBwZWQgZm9yIHRoZSBcImx0clwiIGZ1bmN0aW9uLlxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV1cblxuICAgIGxldCBoaWdoID0gbnVsbFxuICAgIGxldCBsb3cgPSBudWxsXG5cbiAgICBjb21wYXJhdG9ycy5mb3JFYWNoKChjb21wYXJhdG9yKSA9PiB7XG4gICAgICBpZiAoY29tcGFyYXRvci5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgICBjb21wYXJhdG9yID0gbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKVxuICAgICAgfVxuICAgICAgaGlnaCA9IGhpZ2ggfHwgY29tcGFyYXRvclxuICAgICAgbG93ID0gbG93IHx8IGNvbXBhcmF0b3JcbiAgICAgIGlmIChndGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBoaWdoLnNlbXZlciwgb3B0aW9ucykpIHtcbiAgICAgICAgaGlnaCA9IGNvbXBhcmF0b3JcbiAgICAgIH0gZWxzZSBpZiAobHRmbihjb21wYXJhdG9yLnNlbXZlciwgbG93LnNlbXZlciwgb3B0aW9ucykpIHtcbiAgICAgICAgbG93ID0gY29tcGFyYXRvclxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBJZiB0aGUgZWRnZSB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGEgb3BlcmF0b3IgdGhlbiBvdXIgdmVyc2lvblxuICAgIC8vIGlzbid0IG91dHNpZGUgaXRcbiAgICBpZiAoaGlnaC5vcGVyYXRvciA9PT0gY29tcCB8fCBoaWdoLm9wZXJhdG9yID09PSBlY29tcCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGxvd2VzdCB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGFuIG9wZXJhdG9yIGFuZCBvdXIgdmVyc2lvblxuICAgIC8vIGlzIGxlc3MgdGhhbiBpdCB0aGVuIGl0IGlzbid0IGhpZ2hlciB0aGFuIHRoZSByYW5nZVxuICAgIGlmICgoIWxvdy5vcGVyYXRvciB8fCBsb3cub3BlcmF0b3IgPT09IGNvbXApICYmXG4gICAgICAgIGx0ZWZuKHZlcnNpb24sIGxvdy5zZW12ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2UgaWYgKGxvdy5vcGVyYXRvciA9PT0gZWNvbXAgJiYgbHRmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3V0c2lkZVxuIiwiLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlLlxuY29uc3Qgb3V0c2lkZSA9IHJlcXVpcmUoJy4vb3V0c2lkZScpXG5jb25zdCBndHIgPSAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpID0+IG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc+Jywgb3B0aW9ucylcbm1vZHVsZS5leHBvcnRzID0gZ3RyXG4iLCJjb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9vdXRzaWRlJylcbi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGxlc3MgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZVxuY29uc3QgbHRyID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPCcsIG9wdGlvbnMpXG5tb2R1bGUuZXhwb3J0cyA9IGx0clxuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IGludGVyc2VjdHMgPSAocjEsIHIyLCBvcHRpb25zKSA9PiB7XG4gIHIxID0gbmV3IFJhbmdlKHIxLCBvcHRpb25zKVxuICByMiA9IG5ldyBSYW5nZShyMiwgb3B0aW9ucylcbiAgcmV0dXJuIHIxLmludGVyc2VjdHMocjIpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGludGVyc2VjdHNcbiIsIi8vIGdpdmVuIGEgc2V0IG9mIHZlcnNpb25zIGFuZCBhIHJhbmdlLCBjcmVhdGUgYSBcInNpbXBsaWZpZWRcIiByYW5nZVxuLy8gdGhhdCBpbmNsdWRlcyB0aGUgc2FtZSB2ZXJzaW9ucyB0aGF0IHRoZSBvcmlnaW5hbCByYW5nZSBkb2VzXG4vLyBJZiB0aGUgb3JpZ2luYWwgcmFuZ2UgaXMgc2hvcnRlciB0aGFuIHRoZSBzaW1wbGlmaWVkIG9uZSwgcmV0dXJuIHRoYXQuXG5jb25zdCBzYXRpc2ZpZXMgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzJylcbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvY29tcGFyZS5qcycpXG5tb2R1bGUuZXhwb3J0cyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgc2V0ID0gW11cbiAgbGV0IG1pbiA9IG51bGxcbiAgbGV0IHByZXYgPSBudWxsXG4gIGNvbnN0IHYgPSB2ZXJzaW9ucy5zb3J0KChhLCBiKSA9PiBjb21wYXJlKGEsIGIsIG9wdGlvbnMpKVxuICBmb3IgKGNvbnN0IHZlcnNpb24gb2Ygdikge1xuICAgIGNvbnN0IGluY2x1ZGVkID0gc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKVxuICAgIGlmIChpbmNsdWRlZCkge1xuICAgICAgcHJldiA9IHZlcnNpb25cbiAgICAgIGlmICghbWluKVxuICAgICAgICBtaW4gPSB2ZXJzaW9uXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgIHNldC5wdXNoKFttaW4sIHByZXZdKVxuICAgICAgfVxuICAgICAgcHJldiA9IG51bGxcbiAgICAgIG1pbiA9IG51bGxcbiAgICB9XG4gIH1cbiAgaWYgKG1pbilcbiAgICBzZXQucHVzaChbbWluLCBudWxsXSlcblxuICBjb25zdCByYW5nZXMgPSBbXVxuICBmb3IgKGNvbnN0IFttaW4sIG1heF0gb2Ygc2V0KSB7XG4gICAgaWYgKG1pbiA9PT0gbWF4KVxuICAgICAgcmFuZ2VzLnB1c2gobWluKVxuICAgIGVsc2UgaWYgKCFtYXggJiYgbWluID09PSB2WzBdKVxuICAgICAgcmFuZ2VzLnB1c2goJyonKVxuICAgIGVsc2UgaWYgKCFtYXgpXG4gICAgICByYW5nZXMucHVzaChgPj0ke21pbn1gKVxuICAgIGVsc2UgaWYgKG1pbiA9PT0gdlswXSlcbiAgICAgIHJhbmdlcy5wdXNoKGA8PSR7bWF4fWApXG4gICAgZWxzZVxuICAgICAgcmFuZ2VzLnB1c2goYCR7bWlufSAtICR7bWF4fWApXG4gIH1cbiAgY29uc3Qgc2ltcGxpZmllZCA9IHJhbmdlcy5qb2luKCcgfHwgJylcbiAgY29uc3Qgb3JpZ2luYWwgPSB0eXBlb2YgcmFuZ2UucmF3ID09PSAnc3RyaW5nJyA/IHJhbmdlLnJhdyA6IFN0cmluZyhyYW5nZSlcbiAgcmV0dXJuIHNpbXBsaWZpZWQubGVuZ3RoIDwgb3JpZ2luYWwubGVuZ3RoID8gc2ltcGxpZmllZCA6IHJhbmdlXG59XG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UuanMnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvY29tcGFyYXRvci5qcycpXG5jb25zdCB7IEFOWSB9ID0gQ29tcGFyYXRvclxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcy5qcycpXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NvbXBhcmUuanMnKVxuXG4vLyBDb21wbGV4IHJhbmdlIGByMSB8fCByMiB8fCAuLi5gIGlzIGEgc3Vic2V0IG9mIGBSMSB8fCBSMiB8fCAuLi5gIGlmZjpcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgaXMgYSBudWxsIHNldCwgT1Jcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgd2hpY2ggaXMgbm90IGEgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2Zcbi8vICAgc29tZSBgUjEsIFIyLCAuLi5gXG4vL1xuLy8gU2ltcGxlIHJhbmdlIGBjMSBjMiAuLi5gIGlzIGEgc3Vic2V0IG9mIHNpbXBsZSByYW5nZSBgQzEgQzIgLi4uYCBpZmY6XG4vLyAtIElmIGMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBJZiBDIGlzIG9ubHkgdGhlIEFOWSBjb21wYXJhdG9yLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgaWYgaW4gcHJlcmVsZWFzZSBtb2RlLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBlbHNlIHJlcGxhY2UgYyB3aXRoIGBbPj0wLjAuMF1gXG4vLyAtIElmIEMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBpZiBpbiBwcmVyZWxlYXNlIG1vZGUsIHJldHVybiB0cnVlXG4vLyAgIC0gZWxzZSByZXBsYWNlIEMgd2l0aCBgWz49MC4wLjBdYFxuLy8gLSBMZXQgRVEgYmUgdGhlIHNldCBvZiA9IGNvbXBhcmF0b3JzIGluIGNcbi8vIC0gSWYgRVEgaXMgbW9yZSB0aGFuIG9uZSwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gLSBMZXQgR1QgYmUgdGhlIGhpZ2hlc3QgPiBvciA+PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gTGV0IExUIGJlIHRoZSBsb3dlc3QgPCBvciA8PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gSWYgR1QgYW5kIExULCBhbmQgR1Quc2VtdmVyID4gTFQuc2VtdmVyLCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAtIElmIGFueSBDIGlzIGEgPSByYW5nZSwgYW5kIEdUIG9yIExUIGFyZSBzZXQsIHJldHVybiBmYWxzZVxuLy8gLSBJZiBFUVxuLy8gICAtIElmIEdULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBHVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIExULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBMVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIEVRIHNhdGlzZmllcyBldmVyeSBDLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgcmV0dXJuIGZhbHNlXG4vLyAtIElmIEdUXG4vLyAgIC0gSWYgR1Quc2VtdmVyIGlzIGxvd2VyIHRoYW4gYW55ID4gb3IgPj0gY29tcCBpbiBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVCBpcyA+PSwgYW5kIEdULnNlbXZlciBkb2VzIG5vdCBzYXRpc2Z5IGV2ZXJ5IEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIEdULnNlbXZlciBoYXMgYSBwcmVyZWxlYXNlLCBhbmQgbm90IGluIHByZXJlbGVhc2UgbW9kZVxuLy8gICAgIC0gSWYgbm8gQyBoYXMgYSBwcmVyZWxlYXNlIGFuZCB0aGUgR1Quc2VtdmVyIHR1cGxlLCByZXR1cm4gZmFsc2Vcbi8vIC0gSWYgTFRcbi8vICAgLSBJZiBMVC5zZW12ZXIgaXMgZ3JlYXRlciB0aGFuIGFueSA8IG9yIDw9IGNvbXAgaW4gQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgTFQgaXMgPD0sIGFuZCBMVC5zZW12ZXIgZG9lcyBub3Qgc2F0aXNmeSBldmVyeSBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVC5zZW12ZXIgaGFzIGEgcHJlcmVsZWFzZSwgYW5kIG5vdCBpbiBwcmVyZWxlYXNlIG1vZGVcbi8vICAgICAtIElmIG5vIEMgaGFzIGEgcHJlcmVsZWFzZSBhbmQgdGhlIExULnNlbXZlciB0dXBsZSwgcmV0dXJuIGZhbHNlXG4vLyAtIEVsc2UgcmV0dXJuIHRydWVcblxuY29uc3Qgc3Vic2V0ID0gKHN1YiwgZG9tLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKHN1YiA9PT0gZG9tKVxuICAgIHJldHVybiB0cnVlXG5cbiAgc3ViID0gbmV3IFJhbmdlKHN1Yiwgb3B0aW9ucylcbiAgZG9tID0gbmV3IFJhbmdlKGRvbSwgb3B0aW9ucylcbiAgbGV0IHNhd05vbk51bGwgPSBmYWxzZVxuXG4gIE9VVEVSOiBmb3IgKGNvbnN0IHNpbXBsZVN1YiBvZiBzdWIuc2V0KSB7XG4gICAgZm9yIChjb25zdCBzaW1wbGVEb20gb2YgZG9tLnNldCkge1xuICAgICAgY29uc3QgaXNTdWIgPSBzaW1wbGVTdWJzZXQoc2ltcGxlU3ViLCBzaW1wbGVEb20sIG9wdGlvbnMpXG4gICAgICBzYXdOb25OdWxsID0gc2F3Tm9uTnVsbCB8fCBpc1N1YiAhPT0gbnVsbFxuICAgICAgaWYgKGlzU3ViKVxuICAgICAgICBjb250aW51ZSBPVVRFUlxuICAgIH1cbiAgICAvLyB0aGUgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2YgZXZlcnl0aGluZywgYnV0IG51bGwgc2ltcGxlIHJhbmdlcyBpblxuICAgIC8vIGEgY29tcGxleCByYW5nZSBzaG91bGQgYmUgaWdub3JlZC4gIHNvIGlmIHdlIHNhdyBhIG5vbi1udWxsIHJhbmdlLFxuICAgIC8vIHRoZW4gd2Uga25vdyB0aGlzIGlzbid0IGEgc3Vic2V0LCBidXQgaWYgRVZFUlkgc2ltcGxlIHJhbmdlIHdhcyBudWxsLFxuICAgIC8vIHRoZW4gaXQgaXMgYSBzdWJzZXQuXG4gICAgaWYgKHNhd05vbk51bGwpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5jb25zdCBzaW1wbGVTdWJzZXQgPSAoc3ViLCBkb20sIG9wdGlvbnMpID0+IHtcbiAgaWYgKHN1YiA9PT0gZG9tKVxuICAgIHJldHVybiB0cnVlXG5cbiAgaWYgKHN1Yi5sZW5ndGggPT09IDEgJiYgc3ViWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgaWYgKGRvbS5sZW5ndGggPT09IDEgJiYgZG9tWzBdLnNlbXZlciA9PT0gQU5ZKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICBlbHNlIGlmIChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKVxuICAgICAgc3ViID0gWyBuZXcgQ29tcGFyYXRvcignPj0wLjAuMC0wJykgXVxuICAgIGVsc2VcbiAgICAgIHN1YiA9IFsgbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKSBdXG4gIH1cblxuICBpZiAoZG9tLmxlbmd0aCA9PT0gMSAmJiBkb21bMF0uc2VtdmVyID09PSBBTlkpIHtcbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSlcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZWxzZVxuICAgICAgZG9tID0gWyBuZXcgQ29tcGFyYXRvcignPj0wLjAuMCcpIF1cbiAgfVxuXG4gIGNvbnN0IGVxU2V0ID0gbmV3IFNldCgpXG4gIGxldCBndCwgbHRcbiAgZm9yIChjb25zdCBjIG9mIHN1Yikge1xuICAgIGlmIChjLm9wZXJhdG9yID09PSAnPicgfHwgYy5vcGVyYXRvciA9PT0gJz49JylcbiAgICAgIGd0ID0gaGlnaGVyR1QoZ3QsIGMsIG9wdGlvbnMpXG4gICAgZWxzZSBpZiAoYy5vcGVyYXRvciA9PT0gJzwnIHx8IGMub3BlcmF0b3IgPT09ICc8PScpXG4gICAgICBsdCA9IGxvd2VyTFQobHQsIGMsIG9wdGlvbnMpXG4gICAgZWxzZVxuICAgICAgZXFTZXQuYWRkKGMuc2VtdmVyKVxuICB9XG5cbiAgaWYgKGVxU2V0LnNpemUgPiAxKVxuICAgIHJldHVybiBudWxsXG5cbiAgbGV0IGd0bHRDb21wXG4gIGlmIChndCAmJiBsdCkge1xuICAgIGd0bHRDb21wID0gY29tcGFyZShndC5zZW12ZXIsIGx0LnNlbXZlciwgb3B0aW9ucylcbiAgICBpZiAoZ3RsdENvbXAgPiAwKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICBlbHNlIGlmIChndGx0Q29tcCA9PT0gMCAmJiAoZ3Qub3BlcmF0b3IgIT09ICc+PScgfHwgbHQub3BlcmF0b3IgIT09ICc8PScpKVxuICAgICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIHdpbGwgaXRlcmF0ZSBvbmUgb3IgemVybyB0aW1lc1xuICBmb3IgKGNvbnN0IGVxIG9mIGVxU2V0KSB7XG4gICAgaWYgKGd0ICYmICFzYXRpc2ZpZXMoZXEsIFN0cmluZyhndCksIG9wdGlvbnMpKVxuICAgICAgcmV0dXJuIG51bGxcblxuICAgIGlmIChsdCAmJiAhc2F0aXNmaWVzKGVxLCBTdHJpbmcobHQpLCBvcHRpb25zKSlcbiAgICAgIHJldHVybiBudWxsXG5cbiAgICBmb3IgKGNvbnN0IGMgb2YgZG9tKSB7XG4gICAgICBpZiAoIXNhdGlzZmllcyhlcSwgU3RyaW5nKGMpLCBvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGxldCBoaWdoZXIsIGxvd2VyXG4gIGxldCBoYXNEb21MVCwgaGFzRG9tR1RcbiAgLy8gaWYgdGhlIHN1YnNldCBoYXMgYSBwcmVyZWxlYXNlLCB3ZSBuZWVkIGEgY29tcGFyYXRvciBpbiB0aGUgc3VwZXJzZXRcbiAgLy8gd2l0aCB0aGUgc2FtZSB0dXBsZSBhbmQgYSBwcmVyZWxlYXNlLCBvciBpdCdzIG5vdCBhIHN1YnNldFxuICBsZXQgbmVlZERvbUxUUHJlID0gbHQgJiZcbiAgICAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJlxuICAgIGx0LnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA/IGx0LnNlbXZlciA6IGZhbHNlXG4gIGxldCBuZWVkRG9tR1RQcmUgPSBndCAmJlxuICAgICFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgZ3Quc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID8gZ3Quc2VtdmVyIDogZmFsc2VcbiAgLy8gZXhjZXB0aW9uOiA8MS4yLjMtMCBpcyB0aGUgc2FtZSBhcyA8MS4yLjNcbiAgaWYgKG5lZWREb21MVFByZSAmJiBuZWVkRG9tTFRQcmUucHJlcmVsZWFzZS5sZW5ndGggPT09IDEgJiZcbiAgICAgIGx0Lm9wZXJhdG9yID09PSAnPCcgJiYgbmVlZERvbUxUUHJlLnByZXJlbGVhc2VbMF0gPT09IDApIHtcbiAgICBuZWVkRG9tTFRQcmUgPSBmYWxzZVxuICB9XG5cbiAgZm9yIChjb25zdCBjIG9mIGRvbSkge1xuICAgIGhhc0RvbUdUID0gaGFzRG9tR1QgfHwgYy5vcGVyYXRvciA9PT0gJz4nIHx8IGMub3BlcmF0b3IgPT09ICc+PSdcbiAgICBoYXNEb21MVCA9IGhhc0RvbUxUIHx8IGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nXG4gICAgaWYgKGd0KSB7XG4gICAgICBpZiAobmVlZERvbUdUUHJlKSB7XG4gICAgICAgIGlmIChjLnNlbXZlci5wcmVyZWxlYXNlICYmIGMuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICBjLnNlbXZlci5tYWpvciA9PT0gbmVlZERvbUdUUHJlLm1ham9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5taW5vciA9PT0gbmVlZERvbUdUUHJlLm1pbm9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5wYXRjaCA9PT0gbmVlZERvbUdUUHJlLnBhdGNoKSB7XG4gICAgICAgICAgbmVlZERvbUdUUHJlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGMub3BlcmF0b3IgPT09ICc+JyB8fCBjLm9wZXJhdG9yID09PSAnPj0nKSB7XG4gICAgICAgIGhpZ2hlciA9IGhpZ2hlckdUKGd0LCBjLCBvcHRpb25zKVxuICAgICAgICBpZiAoaGlnaGVyID09PSBjICYmIGhpZ2hlciAhPT0gZ3QpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9IGVsc2UgaWYgKGd0Lm9wZXJhdG9yID09PSAnPj0nICYmICFzYXRpc2ZpZXMoZ3Quc2VtdmVyLCBTdHJpbmcoYyksIG9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKGx0KSB7XG4gICAgICBpZiAobmVlZERvbUxUUHJlKSB7XG4gICAgICAgIGlmIChjLnNlbXZlci5wcmVyZWxlYXNlICYmIGMuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICBjLnNlbXZlci5tYWpvciA9PT0gbmVlZERvbUxUUHJlLm1ham9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5taW5vciA9PT0gbmVlZERvbUxUUHJlLm1pbm9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5wYXRjaCA9PT0gbmVlZERvbUxUUHJlLnBhdGNoKSB7XG4gICAgICAgICAgbmVlZERvbUxUUHJlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nKSB7XG4gICAgICAgIGxvd2VyID0gbG93ZXJMVChsdCwgYywgb3B0aW9ucylcbiAgICAgICAgaWYgKGxvd2VyID09PSBjICYmIGxvd2VyICE9PSBsdClcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0gZWxzZSBpZiAobHQub3BlcmF0b3IgPT09ICc8PScgJiYgIXNhdGlzZmllcyhsdC5zZW12ZXIsIFN0cmluZyhjKSwgb3B0aW9ucykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAoIWMub3BlcmF0b3IgJiYgKGx0IHx8IGd0KSAmJiBndGx0Q29tcCAhPT0gMClcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gaWYgdGhlcmUgd2FzIGEgPCBvciA+LCBhbmQgbm90aGluZyBpbiB0aGUgZG9tLCB0aGVuIG11c3QgYmUgZmFsc2VcbiAgLy8gVU5MRVNTIGl0IHdhcyBsaW1pdGVkIGJ5IGFub3RoZXIgcmFuZ2UgaW4gdGhlIG90aGVyIGRpcmVjdGlvbi5cbiAgLy8gRWcsID4xLjAuMCA8MS4wLjEgaXMgc3RpbGwgYSBzdWJzZXQgb2YgPDIuMC4wXG4gIGlmIChndCAmJiBoYXNEb21MVCAmJiAhbHQgJiYgZ3RsdENvbXAgIT09IDApXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgaWYgKGx0ICYmIGhhc0RvbUdUICYmICFndCAmJiBndGx0Q29tcCAhPT0gMClcbiAgICByZXR1cm4gZmFsc2VcblxuICAvLyB3ZSBuZWVkZWQgYSBwcmVyZWxlYXNlIHJhbmdlIGluIGEgc3BlY2lmaWMgdHVwbGUsIGJ1dCBkaWRuJ3QgZ2V0IG9uZVxuICAvLyB0aGVuIHRoaXMgaXNuJ3QgYSBzdWJzZXQuICBlZyA+PTEuMi4zLXByZSBpcyBub3QgYSBzdWJzZXQgb2YgPj0xLjAuMCxcbiAgLy8gYmVjYXVzZSBpdCBpbmNsdWRlcyBwcmVyZWxlYXNlcyBpbiB0aGUgMS4yLjMgdHVwbGVcbiAgaWYgKG5lZWREb21HVFByZSB8fCBuZWVkRG9tTFRQcmUpXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gPj0xLjIuMyBpcyBsb3dlciB0aGFuID4xLjIuM1xuY29uc3QgaGlnaGVyR1QgPSAoYSwgYiwgb3B0aW9ucykgPT4ge1xuICBpZiAoIWEpXG4gICAgcmV0dXJuIGJcbiAgY29uc3QgY29tcCA9IGNvbXBhcmUoYS5zZW12ZXIsIGIuc2VtdmVyLCBvcHRpb25zKVxuICByZXR1cm4gY29tcCA+IDAgPyBhXG4gICAgOiBjb21wIDwgMCA/IGJcbiAgICA6IGIub3BlcmF0b3IgPT09ICc+JyAmJiBhLm9wZXJhdG9yID09PSAnPj0nID8gYlxuICAgIDogYVxufVxuXG4vLyA8PTEuMi4zIGlzIGhpZ2hlciB0aGFuIDwxLjIuM1xuY29uc3QgbG93ZXJMVCA9IChhLCBiLCBvcHRpb25zKSA9PiB7XG4gIGlmICghYSlcbiAgICByZXR1cm4gYlxuICBjb25zdCBjb21wID0gY29tcGFyZShhLnNlbXZlciwgYi5zZW12ZXIsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wIDwgMCA/IGFcbiAgICA6IGNvbXAgPiAwID8gYlxuICAgIDogYi5vcGVyYXRvciA9PT0gJzwnICYmIGEub3BlcmF0b3IgPT09ICc8PScgPyBiXG4gICAgOiBhXG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3Vic2V0XG4iLCIvLyBqdXN0IHByZS1sb2FkIGFsbCB0aGUgc3R1ZmYgdGhhdCBpbmRleC5qcyBsYXppbHkgZXhwb3J0c1xuY29uc3QgaW50ZXJuYWxSZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvcmUnKVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlOiBpbnRlcm5hbFJlLnJlLFxuICBzcmM6IGludGVybmFsUmUuc3JjLFxuICB0b2tlbnM6IGludGVybmFsUmUudCxcbiAgU0VNVkVSX1NQRUNfVkVSU0lPTjogcmVxdWlyZSgnLi9pbnRlcm5hbC9jb25zdGFudHMnKS5TRU1WRVJfU1BFQ19WRVJTSU9OLFxuICBTZW1WZXI6IHJlcXVpcmUoJy4vY2xhc3Nlcy9zZW12ZXInKSxcbiAgY29tcGFyZUlkZW50aWZpZXJzOiByZXF1aXJlKCcuL2ludGVybmFsL2lkZW50aWZpZXJzJykuY29tcGFyZUlkZW50aWZpZXJzLFxuICByY29tcGFyZUlkZW50aWZpZXJzOiByZXF1aXJlKCcuL2ludGVybmFsL2lkZW50aWZpZXJzJykucmNvbXBhcmVJZGVudGlmaWVycyxcbiAgcGFyc2U6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3BhcnNlJyksXG4gIHZhbGlkOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy92YWxpZCcpLFxuICBjbGVhbjogcmVxdWlyZSgnLi9mdW5jdGlvbnMvY2xlYW4nKSxcbiAgaW5jOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9pbmMnKSxcbiAgZGlmZjogcmVxdWlyZSgnLi9mdW5jdGlvbnMvZGlmZicpLFxuICBtYWpvcjogcmVxdWlyZSgnLi9mdW5jdGlvbnMvbWFqb3InKSxcbiAgbWlub3I6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL21pbm9yJyksXG4gIHBhdGNoOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wYXRjaCcpLFxuICBwcmVyZWxlYXNlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wcmVyZWxlYXNlJyksXG4gIGNvbXBhcmU6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvbXBhcmUnKSxcbiAgcmNvbXBhcmU6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3Jjb21wYXJlJyksXG4gIGNvbXBhcmVMb29zZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29tcGFyZS1sb29zZScpLFxuICBjb21wYXJlQnVpbGQ6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvbXBhcmUtYnVpbGQnKSxcbiAgc29ydDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvc29ydCcpLFxuICByc29ydDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvcnNvcnQnKSxcbiAgZ3Q6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2d0JyksXG4gIGx0OiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9sdCcpLFxuICBlcTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvZXEnKSxcbiAgbmVxOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9uZXEnKSxcbiAgZ3RlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9ndGUnKSxcbiAgbHRlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9sdGUnKSxcbiAgY21wOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jbXAnKSxcbiAgY29lcmNlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb2VyY2UnKSxcbiAgQ29tcGFyYXRvcjogcmVxdWlyZSgnLi9jbGFzc2VzL2NvbXBhcmF0b3InKSxcbiAgUmFuZ2U6IHJlcXVpcmUoJy4vY2xhc3Nlcy9yYW5nZScpLFxuICBzYXRpc2ZpZXM6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3NhdGlzZmllcycpLFxuICB0b0NvbXBhcmF0b3JzOiByZXF1aXJlKCcuL3Jhbmdlcy90by1jb21wYXJhdG9ycycpLFxuICBtYXhTYXRpc2Z5aW5nOiByZXF1aXJlKCcuL3Jhbmdlcy9tYXgtc2F0aXNmeWluZycpLFxuICBtaW5TYXRpc2Z5aW5nOiByZXF1aXJlKCcuL3Jhbmdlcy9taW4tc2F0aXNmeWluZycpLFxuICBtaW5WZXJzaW9uOiByZXF1aXJlKCcuL3Jhbmdlcy9taW4tdmVyc2lvbicpLFxuICB2YWxpZFJhbmdlOiByZXF1aXJlKCcuL3Jhbmdlcy92YWxpZCcpLFxuICBvdXRzaWRlOiByZXF1aXJlKCcuL3Jhbmdlcy9vdXRzaWRlJyksXG4gIGd0cjogcmVxdWlyZSgnLi9yYW5nZXMvZ3RyJyksXG4gIGx0cjogcmVxdWlyZSgnLi9yYW5nZXMvbHRyJyksXG4gIGludGVyc2VjdHM6IHJlcXVpcmUoJy4vcmFuZ2VzL2ludGVyc2VjdHMnKSxcbiAgc2ltcGxpZnlSYW5nZTogcmVxdWlyZSgnLi9yYW5nZXMvc2ltcGxpZnknKSxcbiAgc3Vic2V0OiByZXF1aXJlKCcuL3Jhbmdlcy9zdWJzZXQnKSxcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgbWltaWNGbiA9ICh0bywgZnJvbSkgPT4ge1xuXHRmb3IgKGNvbnN0IHByb3Agb2YgUmVmbGVjdC5vd25LZXlzKGZyb20pKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCBwcm9wLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGZyb20sIHByb3ApKTtcblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWltaWNGbjtcbi8vIFRPRE86IFJlbW92ZSB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbWltaWNGbjtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IG1pbWljRm4gPSByZXF1aXJlKCdtaW1pYy1mbicpO1xuXG5jb25zdCBjYWxsZWRGdW5jdGlvbnMgPSBuZXcgV2Vha01hcCgpO1xuXG5jb25zdCBvbmV0aW1lID0gKGZ1bmN0aW9uXywgb3B0aW9ucyA9IHt9KSA9PiB7XG5cdGlmICh0eXBlb2YgZnVuY3Rpb25fICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBmdW5jdGlvbicpO1xuXHR9XG5cblx0bGV0IHJldHVyblZhbHVlO1xuXHRsZXQgY2FsbENvdW50ID0gMDtcblx0Y29uc3QgZnVuY3Rpb25OYW1lID0gZnVuY3Rpb25fLmRpc3BsYXlOYW1lIHx8IGZ1bmN0aW9uXy5uYW1lIHx8ICc8YW5vbnltb3VzPic7XG5cblx0Y29uc3Qgb25ldGltZSA9IGZ1bmN0aW9uICguLi5hcmd1bWVudHNfKSB7XG5cdFx0Y2FsbGVkRnVuY3Rpb25zLnNldChvbmV0aW1lLCArK2NhbGxDb3VudCk7XG5cblx0XHRpZiAoY2FsbENvdW50ID09PSAxKSB7XG5cdFx0XHRyZXR1cm5WYWx1ZSA9IGZ1bmN0aW9uXy5hcHBseSh0aGlzLCBhcmd1bWVudHNfKTtcblx0XHRcdGZ1bmN0aW9uXyA9IG51bGw7XG5cdFx0fSBlbHNlIGlmIChvcHRpb25zLnRocm93ID09PSB0cnVlKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEZ1bmN0aW9uIFxcYCR7ZnVuY3Rpb25OYW1lfVxcYCBjYW4gb25seSBiZSBjYWxsZWQgb25jZWApO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0fTtcblxuXHRtaW1pY0ZuKG9uZXRpbWUsIGZ1bmN0aW9uXyk7XG5cdGNhbGxlZEZ1bmN0aW9ucy5zZXQob25ldGltZSwgY2FsbENvdW50KTtcblxuXHRyZXR1cm4gb25ldGltZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gb25ldGltZTtcbi8vIFRPRE86IFJlbW92ZSB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gb25ldGltZTtcblxubW9kdWxlLmV4cG9ydHMuY2FsbENvdW50ID0gZnVuY3Rpb25fID0+IHtcblx0aWYgKCFjYWxsZWRGdW5jdGlvbnMuaGFzKGZ1bmN0aW9uXykpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYFRoZSBnaXZlbiBmdW5jdGlvbiBcXGAke2Z1bmN0aW9uXy5uYW1lfVxcYCBpcyBub3Qgd3JhcHBlZCBieSB0aGUgXFxgb25ldGltZVxcYCBwYWNrYWdlYCk7XG5cdH1cblxuXHRyZXR1cm4gY2FsbGVkRnVuY3Rpb25zLmdldChmdW5jdGlvbl8pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9hLCBfYjtcbnZhciBfQ29uZl92YWxpZGF0b3IsIF9Db25mX2VuY3J5cHRpb25LZXksIF9Db25mX29wdGlvbnMsIF9Db25mX2RlZmF1bHRWYWx1ZXM7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBkb3RQcm9wID0gcmVxdWlyZShcImRvdC1wcm9wXCIpO1xuY29uc3QgcGtnVXAgPSByZXF1aXJlKFwicGtnLXVwXCIpO1xuY29uc3QgZW52UGF0aHMgPSByZXF1aXJlKFwiZW52LXBhdGhzXCIpO1xuY29uc3QgYXRvbWljYWxseSA9IHJlcXVpcmUoXCJhdG9taWNhbGx5XCIpO1xuY29uc3QgYWp2XzEgPSByZXF1aXJlKFwiYWp2XCIpO1xuY29uc3QgYWp2X2Zvcm1hdHNfMSA9IHJlcXVpcmUoXCJhanYtZm9ybWF0c1wiKTtcbmNvbnN0IGRlYm91bmNlRm4gPSByZXF1aXJlKFwiZGVib3VuY2UtZm5cIik7XG5jb25zdCBzZW12ZXIgPSByZXF1aXJlKFwic2VtdmVyXCIpO1xuY29uc3Qgb25ldGltZSA9IHJlcXVpcmUoXCJvbmV0aW1lXCIpO1xuY29uc3QgZW5jcnlwdGlvbkFsZ29yaXRobSA9ICdhZXMtMjU2LWNiYyc7XG5jb25zdCBjcmVhdGVQbGFpbk9iamVjdCA9ICgpID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn07XG5jb25zdCBpc0V4aXN0ID0gKGRhdGEpID0+IHtcbiAgICByZXR1cm4gZGF0YSAhPT0gdW5kZWZpbmVkICYmIGRhdGEgIT09IG51bGw7XG59O1xubGV0IHBhcmVudERpciA9ICcnO1xudHJ5IHtcbiAgICAvLyBQcmV2ZW50IGNhY2hpbmcgb2YgdGhpcyBtb2R1bGUgc28gbW9kdWxlLnBhcmVudCBpcyBhbHdheXMgYWNjdXJhdGUuXG4gICAgLy8gTm90ZTogVGhpcyB0cmljayB3b24ndCB3b3JrIHdpdGggRVNNIG9yIGluc2lkZSBhIHdlYndvcmtlclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGVcbiAgICBkZWxldGUgcmVxdWlyZS5jYWNoZVtfX2ZpbGVuYW1lXTtcbiAgICBwYXJlbnREaXIgPSBwYXRoLmRpcm5hbWUoKF9iID0gKF9hID0gbW9kdWxlLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbGVuYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnLicpO1xufVxuY2F0Y2ggKF9jKSB7IH1cbmNvbnN0IGNoZWNrVmFsdWVUeXBlID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICBjb25zdCBub25Kc29uVHlwZXMgPSBuZXcgU2V0KFtcbiAgICAgICAgJ3VuZGVmaW5lZCcsXG4gICAgICAgICdzeW1ib2wnLFxuICAgICAgICAnZnVuY3Rpb24nXG4gICAgXSk7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBpZiAobm9uSnNvblR5cGVzLmhhcyh0eXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBTZXR0aW5nIGEgdmFsdWUgb2YgdHlwZSBcXGAke3R5cGV9XFxgIGZvciBrZXkgXFxgJHtrZXl9XFxgIGlzIG5vdCBhbGxvd2VkIGFzIGl0J3Mgbm90IHN1cHBvcnRlZCBieSBKU09OYCk7XG4gICAgfVxufTtcbmNvbnN0IElOVEVSTkFMX0tFWSA9ICdfX2ludGVybmFsX18nO1xuY29uc3QgTUlHUkFUSU9OX0tFWSA9IGAke0lOVEVSTkFMX0tFWX0ubWlncmF0aW9ucy52ZXJzaW9uYDtcbmNsYXNzIENvbmYge1xuICAgIGNvbnN0cnVjdG9yKHBhcnRpYWxPcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBfQ29uZl92YWxpZGF0b3Iuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Db25mX2VuY3J5cHRpb25LZXkuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Db25mX29wdGlvbnMuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Db25mX2RlZmF1bHRWYWx1ZXMuc2V0KHRoaXMsIHt9KTtcbiAgICAgICAgdGhpcy5fZGVzZXJpYWxpemUgPSB2YWx1ZSA9PiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgdGhpcy5fc2VyaWFsaXplID0gdmFsdWUgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIHVuZGVmaW5lZCwgJ1xcdCcpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgY29uZmlnTmFtZTogJ2NvbmZpZycsXG4gICAgICAgICAgICBmaWxlRXh0ZW5zaW9uOiAnanNvbicsXG4gICAgICAgICAgICBwcm9qZWN0U3VmZml4OiAnbm9kZWpzJyxcbiAgICAgICAgICAgIGNsZWFySW52YWxpZENvbmZpZzogZmFsc2UsXG4gICAgICAgICAgICBhY2Nlc3NQcm9wZXJ0aWVzQnlEb3ROb3RhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIC4uLnBhcnRpYWxPcHRpb25zXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGdldFBhY2thZ2VEYXRhID0gb25ldGltZSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYWNrYWdlUGF0aCA9IHBrZ1VwLnN5bmMoeyBjd2Q6IHBhcmVudERpciB9KTtcbiAgICAgICAgICAgIC8vIENhbid0IHVzZSBgcmVxdWlyZWAgYmVjYXVzZSBvZiBXZWJwYWNrIGJlaW5nIGFubm95aW5nOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay9pc3N1ZXMvMTk2XG4gICAgICAgICAgICBjb25zdCBwYWNrYWdlRGF0YSA9IHBhY2thZ2VQYXRoICYmIEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKHBhY2thZ2VQYXRoLCAndXRmOCcpKTtcbiAgICAgICAgICAgIHJldHVybiBwYWNrYWdlRGF0YSAhPT0gbnVsbCAmJiBwYWNrYWdlRGF0YSAhPT0gdm9pZCAwID8gcGFja2FnZURhdGEgOiB7fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghb3B0aW9ucy5jd2QpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wcm9qZWN0TmFtZSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucHJvamVjdE5hbWUgPSBnZXRQYWNrYWdlRGF0YSgpLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMucHJvamVjdE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3QgbmFtZSBjb3VsZCBub3QgYmUgaW5mZXJyZWQuIFBsZWFzZSBzcGVjaWZ5IHRoZSBgcHJvamVjdE5hbWVgIG9wdGlvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMuY3dkID0gZW52UGF0aHMob3B0aW9ucy5wcm9qZWN0TmFtZSwgeyBzdWZmaXg6IG9wdGlvbnMucHJvamVjdFN1ZmZpeCB9KS5jb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ29uZl9vcHRpb25zLCBvcHRpb25zLCBcImZcIik7XG4gICAgICAgIGlmIChvcHRpb25zLnNjaGVtYSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnNjaGVtYSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgYHNjaGVtYWAgb3B0aW9uIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWp2ID0gbmV3IGFqdl8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgICAgIGFsbEVycm9yczogdHJ1ZSxcbiAgICAgICAgICAgICAgICB1c2VEZWZhdWx0czogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhanZfZm9ybWF0c18xLmRlZmF1bHQoYWp2KTtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBvcHRpb25zLnNjaGVtYVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NvbmZfdmFsaWRhdG9yLCBhanYuY29tcGlsZShzY2hlbWEpLCBcImZcIik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zLnNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9kZWZhdWx0VmFsdWVzLCBcImZcIilba2V5XSA9IHZhbHVlLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Db25mX2RlZmF1bHRWYWx1ZXMsIHtcbiAgICAgICAgICAgICAgICAuLi5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX2RlZmF1bHRWYWx1ZXMsIFwiZlwiKSxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLmRlZmF1bHRzXG4gICAgICAgICAgICB9LCBcImZcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc2VyaWFsaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXJpYWxpemUgPSBvcHRpb25zLnNlcmlhbGl6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5kZXNlcmlhbGl6ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGVzZXJpYWxpemUgPSBvcHRpb25zLmRlc2VyaWFsaXplO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRzID0gbmV3IGV2ZW50c18xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Db25mX2VuY3J5cHRpb25LZXksIG9wdGlvbnMuZW5jcnlwdGlvbktleSwgXCJmXCIpO1xuICAgICAgICBjb25zdCBmaWxlRXh0ZW5zaW9uID0gb3B0aW9ucy5maWxlRXh0ZW5zaW9uID8gYC4ke29wdGlvbnMuZmlsZUV4dGVuc2lvbn1gIDogJyc7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGgucmVzb2x2ZShvcHRpb25zLmN3ZCwgYCR7KF9hID0gb3B0aW9ucy5jb25maWdOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnY29uZmlnJ30ke2ZpbGVFeHRlbnNpb259YCk7XG4gICAgICAgIGNvbnN0IGZpbGVTdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gT2JqZWN0LmFzc2lnbihjcmVhdGVQbGFpbk9iamVjdCgpLCBvcHRpb25zLmRlZmF1bHRzLCBmaWxlU3RvcmUpO1xuICAgICAgICB0aGlzLl92YWxpZGF0ZShzdG9yZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKGZpbGVTdG9yZSwgc3RvcmUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYikge1xuICAgICAgICAgICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLndhdGNoKSB7XG4gICAgICAgICAgICB0aGlzLl93YXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm1pZ3JhdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wcm9qZWN0VmVyc2lvbikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucHJvamVjdFZlcnNpb24gPSBnZXRQYWNrYWdlRGF0YSgpLnZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMucHJvamVjdFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3QgdmVyc2lvbiBjb3VsZCBub3QgYmUgaW5mZXJyZWQuIFBsZWFzZSBzcGVjaWZ5IHRoZSBgcHJvamVjdFZlcnNpb25gIG9wdGlvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21pZ3JhdGUob3B0aW9ucy5taWdyYXRpb25zLCBvcHRpb25zLnByb2plY3RWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfb3B0aW9ucywgXCJmXCIpLmFjY2Vzc1Byb3BlcnRpZXNCeURvdE5vdGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0KGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0b3JlIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ga2V5IGluIHN0b3JlID8gc3RvcmVba2V5XSA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBrZXkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBrZXlcXGAgdG8gYmUgb2YgdHlwZSBcXGBzdHJpbmdcXGAgb3IgXFxgb2JqZWN0XFxgLCBnb3QgJHt0eXBlb2Yga2V5fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnb2JqZWN0JyAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVc2UgYGRlbGV0ZSgpYCB0byBjbGVhciB2YWx1ZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY29udGFpbnNSZXNlcnZlZEtleShrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQbGVhc2UgZG9uJ3QgdXNlIHRoZSAke0lOVEVSTkFMX0tFWX0ga2V5LCBhcyBpdCdzIHVzZWQgdG8gbWFuYWdlIHRoaXMgbW9kdWxlIGludGVybmFsIG9wZXJhdGlvbnMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdG9yZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc2V0ID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNoZWNrVmFsdWVUeXBlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfb3B0aW9ucywgXCJmXCIpLmFjY2Vzc1Byb3BlcnRpZXNCeURvdE5vdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZG90UHJvcC5zZXQoc3RvcmUsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RvcmVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdCA9IGtleTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICBzZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayBpZiBhbiBpdGVtIGV4aXN0cy5cblxuICAgIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIGNoZWNrLlxuICAgICovXG4gICAgaGFzKGtleSkge1xuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9vcHRpb25zLCBcImZcIikuYWNjZXNzUHJvcGVydGllc0J5RG90Tm90YXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBkb3RQcm9wLmhhcyh0aGlzLnN0b3JlLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXkgaW4gdGhpcy5zdG9yZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVzZXQgaXRlbXMgdG8gdGhlaXIgZGVmYXVsdCB2YWx1ZXMsIGFzIGRlZmluZWQgYnkgdGhlIGBkZWZhdWx0c2Agb3IgYHNjaGVtYWAgb3B0aW9uLlxuXG4gICAgQHNlZSBgY2xlYXIoKWAgdG8gcmVzZXQgYWxsIGl0ZW1zLlxuXG4gICAgQHBhcmFtIGtleXMgLSBUaGUga2V5cyBvZiB0aGUgaXRlbXMgdG8gcmVzZXQuXG4gICAgKi9cbiAgICByZXNldCguLi5rZXlzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIGlmIChpc0V4aXN0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZGVmYXVsdFZhbHVlcywgXCJmXCIpW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX2RlZmF1bHRWYWx1ZXMsIFwiZlwiKVtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBEZWxldGUgYW4gaXRlbS5cblxuICAgIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIGRlbGV0ZS5cbiAgICAqL1xuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgY29uc3QgeyBzdG9yZSB9ID0gdGhpcztcbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfb3B0aW9ucywgXCJmXCIpLmFjY2Vzc1Byb3BlcnRpZXNCeURvdE5vdGF0aW9uKSB7XG4gICAgICAgICAgICBkb3RQcm9wLmRlbGV0ZShzdG9yZSwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGVcbiAgICAgICAgICAgIGRlbGV0ZSBzdG9yZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVsZXRlIGFsbCBpdGVtcy5cblxuICAgIFRoaXMgcmVzZXRzIGtub3duIGl0ZW1zIHRvIHRoZWlyIGRlZmF1bHQgdmFsdWVzLCBpZiBkZWZpbmVkIGJ5IHRoZSBgZGVmYXVsdHNgIG9yIGBzY2hlbWFgIG9wdGlvbi5cbiAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnN0b3JlID0gY3JlYXRlUGxhaW5PYmplY3QoKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9kZWZhdWx0VmFsdWVzLCBcImZcIikpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgV2F0Y2hlcyB0aGUgZ2l2ZW4gYGtleWAsIGNhbGxpbmcgYGNhbGxiYWNrYCBvbiBhbnkgY2hhbmdlcy5cblxuICAgIEBwYXJhbSBrZXkgLSBUaGUga2V5IHdvIHdhdGNoLlxuICAgIEBwYXJhbSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgb24gYW55IGNoYW5nZXMuIFdoZW4gYSBga2V5YCBpcyBmaXJzdCBzZXQgYG9sZFZhbHVlYCB3aWxsIGJlIGB1bmRlZmluZWRgLCBhbmQgd2hlbiBhIGtleSBpcyBkZWxldGVkIGBuZXdWYWx1ZWAgd2lsbCBiZSBgdW5kZWZpbmVkYC5cbiAgICBAcmV0dXJucyBBIGZ1bmN0aW9uLCB0aGF0IHdoZW4gY2FsbGVkLCB3aWxsIHVuc3Vic2NyaWJlLlxuICAgICovXG4gICAgb25EaWRDaGFuZ2Uoa2V5LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFxcYGtleVxcYCB0byBiZSBvZiB0eXBlIFxcYHN0cmluZ1xcYCwgZ290ICR7dHlwZW9mIGtleX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBjYWxsYmFja1xcYCB0byBiZSBvZiB0eXBlIFxcYGZ1bmN0aW9uXFxgLCBnb3QgJHt0eXBlb2YgY2FsbGJhY2t9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUNoYW5nZSgoKSA9PiB0aGlzLmdldChrZXkpLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgIFdhdGNoZXMgdGhlIHdob2xlIGNvbmZpZyBvYmplY3QsIGNhbGxpbmcgYGNhbGxiYWNrYCBvbiBhbnkgY2hhbmdlcy5cblxuICAgIEBwYXJhbSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgb24gYW55IGNoYW5nZXMuIFdoZW4gYSBga2V5YCBpcyBmaXJzdCBzZXQgYG9sZFZhbHVlYCB3aWxsIGJlIGB1bmRlZmluZWRgLCBhbmQgd2hlbiBhIGtleSBpcyBkZWxldGVkIGBuZXdWYWx1ZWAgd2lsbCBiZSBgdW5kZWZpbmVkYC5cbiAgICBAcmV0dXJucyBBIGZ1bmN0aW9uLCB0aGF0IHdoZW4gY2FsbGVkLCB3aWxsIHVuc3Vic2NyaWJlLlxuICAgICovXG4gICAgb25EaWRBbnlDaGFuZ2UoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgY2FsbGJhY2tcXGAgdG8gYmUgb2YgdHlwZSBcXGBmdW5jdGlvblxcYCwgZ290ICR7dHlwZW9mIGNhbGxiYWNrfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVDaGFuZ2UoKCkgPT4gdGhpcy5zdG9yZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc3RvcmUpLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0IHN0b3JlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGZzLnJlYWRGaWxlU3luYyh0aGlzLnBhdGgsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZW5jcnlwdGlvbktleSwgXCJmXCIpID8gbnVsbCA6ICd1dGY4Jyk7XG4gICAgICAgICAgICBjb25zdCBkYXRhU3RyaW5nID0gdGhpcy5fZW5jcnlwdERhdGEoZGF0YSk7XG4gICAgICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZWREYXRhID0gdGhpcy5fZGVzZXJpYWxpemUoZGF0YVN0cmluZyk7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0ZShkZXNlcmlhbGl6ZWREYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGNyZWF0ZVBsYWluT2JqZWN0KCksIGRlc2VyaWFsaXplZERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5zdXJlRGlyZWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVBsYWluT2JqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9vcHRpb25zLCBcImZcIikuY2xlYXJJbnZhbGlkQ29uZmlnICYmIGVycm9yLm5hbWUgPT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUGxhaW5PYmplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldCBzdG9yZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9lbnN1cmVEaXJlY3RvcnkoKTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGUodmFsdWUpO1xuICAgICAgICB0aGlzLl93cml0ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ2NoYW5nZScpO1xuICAgIH1cbiAgICAqWyhfQ29uZl92YWxpZGF0b3IgPSBuZXcgV2Vha01hcCgpLCBfQ29uZl9lbmNyeXB0aW9uS2V5ID0gbmV3IFdlYWtNYXAoKSwgX0NvbmZfb3B0aW9ucyA9IG5ldyBXZWFrTWFwKCksIF9Db25mX2RlZmF1bHRWYWx1ZXMgPSBuZXcgV2Vha01hcCgpLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5zdG9yZSkpIHtcbiAgICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZW5jcnlwdERhdGEoZGF0YSkge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZW5jcnlwdGlvbktleSwgXCJmXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBhbiBpbml0aWFsaXphdGlvbiB2ZWN0b3IgaGFzIGJlZW4gdXNlZCB0byBlbmNyeXB0IHRoZSBkYXRhXG4gICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBcImZcIikpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5zbGljZSgxNiwgMTcpLnRvU3RyaW5nKCkgPT09ICc6Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhbGl6YXRpb25WZWN0b3IgPSBkYXRhLnNsaWNlKDAsIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhc3N3b3JkID0gY3J5cHRvLnBia2RmMlN5bmMoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBcImZcIiksIGluaXRpYWxpemF0aW9uVmVjdG9yLnRvU3RyaW5nKCksIDEwMDAwLCAzMiwgJ3NoYTUxMicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihlbmNyeXB0aW9uQWxnb3JpdGhtLCBwYXNzd29yZCwgaW5pdGlhbGl6YXRpb25WZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IEJ1ZmZlci5jb25jYXQoW2RlY2lwaGVyLnVwZGF0ZShCdWZmZXIuZnJvbShkYXRhLnNsaWNlKDE3KSkpLCBkZWNpcGhlci5maW5hbCgpXSkudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyKGVuY3J5cHRpb25BbGdvcml0aG0sIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZW5jcnlwdGlvbktleSwgXCJmXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBCdWZmZXIuY29uY2F0KFtkZWNpcGhlci51cGRhdGUoQnVmZmVyLmZyb20oZGF0YSkpLCBkZWNpcGhlci5maW5hbCgpXSkudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYikgeyB9XG4gICAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIF9oYW5kbGVDaGFuZ2UoZ2V0dGVyLCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgY3VycmVudFZhbHVlID0gZ2V0dGVyKCk7XG4gICAgICAgIGNvbnN0IG9uQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGdldHRlcigpO1xuICAgICAgICAgICAgaWYgKHV0aWxfMS5pc0RlZXBTdHJpY3RFcXVhbChuZXdWYWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB0aGlzLmV2ZW50cy5yZW1vdmVMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIH1cbiAgICBfdmFsaWRhdGUoZGF0YSkge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfdmFsaWRhdG9yLCBcImZcIikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfdmFsaWRhdG9yLCBcImZcIikuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICAgICAgaWYgKHZhbGlkIHx8ICFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX3ZhbGlkYXRvciwgXCJmXCIpLmVycm9ycykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfdmFsaWRhdG9yLCBcImZcIikuZXJyb3JzXG4gICAgICAgICAgICAubWFwKCh7IGluc3RhbmNlUGF0aCwgbWVzc2FnZSA9ICcnIH0pID0+IGBcXGAke2luc3RhbmNlUGF0aC5zbGljZSgxKX1cXGAgJHttZXNzYWdlfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmZpZyBzY2hlbWEgdmlvbGF0aW9uOiAnICsgZXJyb3JzLmpvaW4oJzsgJykpO1xuICAgIH1cbiAgICBfZW5zdXJlRGlyZWN0b3J5KCkge1xuICAgICAgICAvLyBFbnN1cmUgdGhlIGRpcmVjdG9yeSBleGlzdHMgYXMgaXQgY291bGQgaGF2ZSBiZWVuIGRlbGV0ZWQgaW4gdGhlIG1lYW50aW1lLlxuICAgICAgICBmcy5ta2RpclN5bmMocGF0aC5kaXJuYW1lKHRoaXMucGF0aCksIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIH1cbiAgICBfd3JpdGUodmFsdWUpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLl9zZXJpYWxpemUodmFsdWUpO1xuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBcImZcIikpIHtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxpemF0aW9uVmVjdG9yID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KTtcbiAgICAgICAgICAgIGNvbnN0IHBhc3N3b3JkID0gY3J5cHRvLnBia2RmMlN5bmMoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBcImZcIiksIGluaXRpYWxpemF0aW9uVmVjdG9yLnRvU3RyaW5nKCksIDEwMDAwLCAzMiwgJ3NoYTUxMicpO1xuICAgICAgICAgICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KGVuY3J5cHRpb25BbGdvcml0aG0sIHBhc3N3b3JkLCBpbml0aWFsaXphdGlvblZlY3Rvcik7XG4gICAgICAgICAgICBkYXRhID0gQnVmZmVyLmNvbmNhdChbaW5pdGlhbGl6YXRpb25WZWN0b3IsIEJ1ZmZlci5mcm9tKCc6JyksIGNpcGhlci51cGRhdGUoQnVmZmVyLmZyb20oZGF0YSkpLCBjaXBoZXIuZmluYWwoKV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlbXBvcmFyeSB3b3JrYXJvdW5kIGZvciBDb25mIGJlaW5nIHBhY2thZ2VkIGluIGEgVWJ1bnR1IFNuYXAgYXBwLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9jb25mL3B1bGwvODJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52LlNOQVApIHtcbiAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmModGhpcy5wYXRoLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXRvbWljYWxseS53cml0ZUZpbGVTeW5jKHRoaXMucGF0aCwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBGaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvZWxlY3Ryb24tc3RvcmUvaXNzdWVzLzEwNlxuICAgICAgICAgICAgICAgIC8vIFNvbWV0aW1lcyBvbiBXaW5kb3dzLCB3ZSB3aWxsIGdldCBhbiBFWERFViBlcnJvciB3aGVuIGF0b21pYyB3cml0aW5nXG4gICAgICAgICAgICAgICAgLy8gKGV2ZW4gdGhvdWdoIHRvIHRoZSBzYW1lIGRpcmVjdG9yeSksIHNvIHdlIGZhbGwgYmFjayB0byBub24gYXRvbWljIHdyaXRlXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICdFWERFVicpIHtcbiAgICAgICAgICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyh0aGlzLnBhdGgsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF93YXRjaCgpIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlRGlyZWN0b3J5KCk7XG4gICAgICAgIGlmICghZnMuZXhpc3RzU3luYyh0aGlzLnBhdGgpKSB7XG4gICAgICAgICAgICB0aGlzLl93cml0ZShjcmVhdGVQbGFpbk9iamVjdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgICAgICAgICAgZnMud2F0Y2godGhpcy5wYXRoLCB7IHBlcnNpc3RlbnQ6IGZhbHNlIH0sIGRlYm91bmNlRm4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIE9uIExpbnV4IGFuZCBXaW5kb3dzLCB3cml0aW5nIHRvIHRoZSBjb25maWcgZmlsZSBlbWl0cyBhIGByZW5hbWVgIGV2ZW50LCBzbyB3ZSBza2lwIGNoZWNraW5nIHRoZSBldmVudCB0eXBlLlxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ2NoYW5nZScpO1xuICAgICAgICAgICAgfSwgeyB3YWl0OiAxMDAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnMud2F0Y2hGaWxlKHRoaXMucGF0aCwgeyBwZXJzaXN0ZW50OiBmYWxzZSB9LCBkZWJvdW5jZUZuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KCdjaGFuZ2UnKTtcbiAgICAgICAgICAgIH0sIHsgd2FpdDogNTAwMCB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX21pZ3JhdGUobWlncmF0aW9ucywgdmVyc2lvblRvTWlncmF0ZSkge1xuICAgICAgICBsZXQgcHJldmlvdXNNaWdyYXRlZFZlcnNpb24gPSB0aGlzLl9nZXQoTUlHUkFUSU9OX0tFWSwgJzAuMC4wJyk7XG4gICAgICAgIGNvbnN0IG5ld2VyVmVyc2lvbnMgPSBPYmplY3Qua2V5cyhtaWdyYXRpb25zKVxuICAgICAgICAgICAgLmZpbHRlcihjYW5kaWRhdGVWZXJzaW9uID0+IHRoaXMuX3Nob3VsZFBlcmZvcm1NaWdyYXRpb24oY2FuZGlkYXRlVmVyc2lvbiwgcHJldmlvdXNNaWdyYXRlZFZlcnNpb24sIHZlcnNpb25Ub01pZ3JhdGUpKTtcbiAgICAgICAgbGV0IHN0b3JlQmFja3VwID0geyAuLi50aGlzLnN0b3JlIH07XG4gICAgICAgIGZvciAoY29uc3QgdmVyc2lvbiBvZiBuZXdlclZlcnNpb25zKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pZ3JhdGlvbiA9IG1pZ3JhdGlvbnNbdmVyc2lvbl07XG4gICAgICAgICAgICAgICAgbWlncmF0aW9uKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldChNSUdSQVRJT05fS0VZLCB2ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c01pZ3JhdGVkVmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgICAgICAgc3RvcmVCYWNrdXAgPSB7IC4uLnRoaXMuc3RvcmUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZUJhY2t1cDtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyB0aGUgbWlncmF0aW9uISBDaGFuZ2VzIGFwcGxpZWQgdG8gdGhlIHN0b3JlIHVudGlsIHRoaXMgZmFpbGVkIG1pZ3JhdGlvbiB3aWxsIGJlIHJlc3RvcmVkLiAke2Vycm9yfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pc1ZlcnNpb25JblJhbmdlRm9ybWF0KHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uKSB8fCAhc2VtdmVyLmVxKHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uLCB2ZXJzaW9uVG9NaWdyYXRlKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0KE1JR1JBVElPTl9LRVksIHZlcnNpb25Ub01pZ3JhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jb250YWluc1Jlc2VydmVkS2V5KGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnNLZXkgPSBPYmplY3Qua2V5cyhrZXkpWzBdO1xuICAgICAgICAgICAgaWYgKGZpcnNLZXkgPT09IElOVEVSTkFMX0tFWSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX29wdGlvbnMsIFwiZlwiKS5hY2Nlc3NQcm9wZXJ0aWVzQnlEb3ROb3RhdGlvbikge1xuICAgICAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKGAke0lOVEVSTkFMX0tFWX0uYCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9pc1ZlcnNpb25JblJhbmdlRm9ybWF0KHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHNlbXZlci5jbGVhbih2ZXJzaW9uKSA9PT0gbnVsbDtcbiAgICB9XG4gICAgX3Nob3VsZFBlcmZvcm1NaWdyYXRpb24oY2FuZGlkYXRlVmVyc2lvbiwgcHJldmlvdXNNaWdyYXRlZFZlcnNpb24sIHZlcnNpb25Ub01pZ3JhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVmVyc2lvbkluUmFuZ2VGb3JtYXQoY2FuZGlkYXRlVmVyc2lvbikpIHtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c01pZ3JhdGVkVmVyc2lvbiAhPT0gJzAuMC4wJyAmJiBzZW12ZXIuc2F0aXNmaWVzKHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uLCBjYW5kaWRhdGVWZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZW12ZXIuc2F0aXNmaWVzKHZlcnNpb25Ub01pZ3JhdGUsIGNhbmRpZGF0ZVZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZW12ZXIubHRlKGNhbmRpZGF0ZVZlcnNpb24sIHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZW12ZXIuZ3QoY2FuZGlkYXRlVmVyc2lvbiwgdmVyc2lvblRvTWlncmF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX2dldChrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gZG90UHJvcC5nZXQodGhpcy5zdG9yZSwga2V5LCBkZWZhdWx0VmFsdWUpO1xuICAgIH1cbiAgICBfc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgeyBzdG9yZSB9ID0gdGhpcztcbiAgICAgICAgZG90UHJvcC5zZXQoc3RvcmUsIGtleSwgdmFsdWUpO1xuICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ29uZjtcbi8vIEZvciBDb21tb25KUyBkZWZhdWx0IGV4cG9ydCBzdXBwb3J0XG5tb2R1bGUuZXhwb3J0cyA9IENvbmY7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQ29uZjtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCB7YXBwLCBpcGNNYWluLCBpcGNSZW5kZXJlciwgc2hlbGx9ID0gcmVxdWlyZSgnZWxlY3Ryb24nKTtcbmNvbnN0IENvbmYgPSByZXF1aXJlKCdjb25mJyk7XG5cbmxldCBpc0luaXRpYWxpemVkID0gZmFsc2U7XG5cbi8vIFNldCB1cCB0aGUgYGlwY01haW5gIGhhbmRsZXIgZm9yIGNvbW11bmljYXRpb24gYmV0d2VlbiByZW5kZXJlciBhbmQgbWFpbiBwcm9jZXNzLlxuY29uc3QgaW5pdERhdGFMaXN0ZW5lciA9ICgpID0+IHtcblx0aWYgKCFpcGNNYWluIHx8ICFhcHApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0VsZWN0cm9uIFN0b3JlOiBZb3UgbmVlZCB0byBjYWxsIGAuaW5pdFJlbmRlcmVyKClgIGZyb20gdGhlIG1haW4gcHJvY2Vzcy4nKTtcblx0fVxuXG5cdGNvbnN0IGFwcERhdGEgPSB7XG5cdFx0ZGVmYXVsdEN3ZDogYXBwLmdldFBhdGgoJ3VzZXJEYXRhJyksXG5cdFx0YXBwVmVyc2lvbjogYXBwLmdldFZlcnNpb24oKVxuXHR9O1xuXG5cdGlmIChpc0luaXRpYWxpemVkKSB7XG5cdFx0cmV0dXJuIGFwcERhdGE7XG5cdH1cblxuXHRpcGNNYWluLm9uKCdlbGVjdHJvbi1zdG9yZS1nZXQtZGF0YScsIGV2ZW50ID0+IHtcblx0XHRldmVudC5yZXR1cm5WYWx1ZSA9IGFwcERhdGE7XG5cdH0pO1xuXG5cdGlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG5cdHJldHVybiBhcHBEYXRhO1xufTtcblxuY2xhc3MgRWxlY3Ryb25TdG9yZSBleHRlbmRzIENvbmYge1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0bGV0IGRlZmF1bHRDd2Q7XG5cdFx0bGV0IGFwcFZlcnNpb247XG5cblx0XHQvLyBJZiB3ZSBhcmUgaW4gdGhlIHJlbmRlcmVyIHByb2Nlc3MsIHdlIGNvbW11bmljYXRlIHdpdGggdGhlIG1haW4gcHJvY2Vzc1xuXHRcdC8vIHRvIGdldCB0aGUgcmVxdWlyZWQgZGF0YSBmb3IgdGhlIG1vZHVsZSBvdGhlcndpc2UsIHdlIHB1bGwgZnJvbSB0aGUgbWFpbiBwcm9jZXNzLlxuXHRcdGlmIChpcGNSZW5kZXJlcikge1xuXHRcdFx0Y29uc3QgYXBwRGF0YSA9IGlwY1JlbmRlcmVyLnNlbmRTeW5jKCdlbGVjdHJvbi1zdG9yZS1nZXQtZGF0YScpO1xuXG5cdFx0XHRpZiAoIWFwcERhdGEpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFbGVjdHJvbiBTdG9yZTogWW91IG5lZWQgdG8gY2FsbCBgLmluaXRSZW5kZXJlcigpYCBmcm9tIHRoZSBtYWluIHByb2Nlc3MuJyk7XG5cdFx0XHR9XG5cblx0XHRcdCh7ZGVmYXVsdEN3ZCwgYXBwVmVyc2lvbn0gPSBhcHBEYXRhKTtcblx0XHR9IGVsc2UgaWYgKGlwY01haW4gJiYgYXBwKSB7XG5cdFx0XHQoe2RlZmF1bHRDd2QsIGFwcFZlcnNpb259ID0gaW5pdERhdGFMaXN0ZW5lcigpKTtcblx0XHR9XG5cblx0XHRvcHRpb25zID0ge1xuXHRcdFx0bmFtZTogJ2NvbmZpZycsXG5cdFx0XHQuLi5vcHRpb25zXG5cdFx0fTtcblxuXHRcdGlmICghb3B0aW9ucy5wcm9qZWN0VmVyc2lvbikge1xuXHRcdFx0b3B0aW9ucy5wcm9qZWN0VmVyc2lvbiA9IGFwcFZlcnNpb247XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuY3dkKSB7XG5cdFx0XHRvcHRpb25zLmN3ZCA9IHBhdGguaXNBYnNvbHV0ZShvcHRpb25zLmN3ZCkgPyBvcHRpb25zLmN3ZCA6IHBhdGguam9pbihkZWZhdWx0Q3dkLCBvcHRpb25zLmN3ZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9wdGlvbnMuY3dkID0gZGVmYXVsdEN3ZDtcblx0XHR9XG5cblx0XHRvcHRpb25zLmNvbmZpZ05hbWUgPSBvcHRpb25zLm5hbWU7XG5cdFx0ZGVsZXRlIG9wdGlvbnMubmFtZTtcblxuXHRcdHN1cGVyKG9wdGlvbnMpO1xuXHR9XG5cblx0c3RhdGljIGluaXRSZW5kZXJlcigpIHtcblx0XHRpbml0RGF0YUxpc3RlbmVyKCk7XG5cdH1cblxuXHRvcGVuSW5FZGl0b3IoKSB7XG5cdFx0c2hlbGwub3BlblBhdGgodGhpcy5wYXRoKTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVsZWN0cm9uU3RvcmU7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1taXhlZC1zcGFjZXMtYW5kLXRhYnMgKi9cbmltcG9ydCBTdG9yZSBmcm9tICdlbGVjdHJvbi1zdG9yZSc7XG5cbmNvbnN0IHNjaGVtYSA9IHtcblx0bm90ZXM6IHtcblx0XHR0eXBlOiAnb2JqZWN0JyxcbiAgICBwYXR0ZXJuUHJvcGVydGllczoge1xuICAgICAgJ1tBLVphLXowLTlfLV0nOiB7XG4gICAgICBcdHR5cGU6ICdvYmplY3QnLFxuICAgICAgXHRwcm9wZXJ0aWVzOiB7XG4gICAgICBcdFx0aWQ6IHsgdHlwZTogJ3N0cmluZycsIGRlZmF1bHQ6ICcnIH0sXG4gICAgICBcdFx0dGl0bGU6IHsgdHlwZTogJ3N0cmluZycsIGRlZmF1bHQ6ICcnIH0sXG4gICAgICBcdFx0Y29udGVudDogeyB0eXBlOiAnb2JqZWN0JywgZGVmYXVsdDogeyB0eXBlOiAnZG9jJywgY29udGVudDogW10gfSB9LFxuICAgICAgXHRcdGxhYmVsczogeyB0eXBlOiAnYXJyYXknLCBkZWZhdWx0OiBbXSB9LFxuICAgICAgXHRcdGNyZWF0ZWRBdDogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogRGF0ZS5ub3coKSB9LFxuICAgICAgXHRcdHVwZGF0ZWRBdDogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogRGF0ZS5ub3coKSB9LFxuICAgICAgXHRcdGlzQm9va21hcmtlZDogeyB0eXBlOiAnYm9vbGVhbicsIGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICBcdFx0aXNBcmNoaXZlZDogeyB0eXBlOiAnYm9vbGVhbicsIGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgICAgbGFzdEN1cnNvclBvc2l0aW9uOiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAwIH0sXG4gICAgICBcdH0sXG4gICAgICB9LFxuICAgIH0sXG5cdH0sXG4gIGxhYmVsczoge1xuICAgIHR5cGU6ICdhcnJheScsXG4gIH0sXG59O1xuXG5jb25zdCBzdG9yZSA9IG5ldyBTdG9yZSh7XG5cdHNjaGVtYSxcbiAgZW5jcnlwdGlvbktleTogaW1wb3J0Lm1ldGEuZW52LlZJVEVfRU5DUllQVF9LRVksXG59KTtcblxuLy8gc3RvcmUub25EaWRDaGFuZ2UoJ25vdGVzJywgKHZhbHVlKSA9PiB7XG4vLyAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbi8vIH0pO1xuXG5leHBvcnQgZGVmYXVsdCBzdG9yZTtcbiIsImltcG9ydCBTdG9yZSBmcm9tICdlbGVjdHJvbi1zdG9yZSc7XG5pbXBvcnQgeyBhcHAgfSBmcm9tICdlbGVjdHJvbic7XG5cbmNvbnN0IHNjaGVtYSA9IHtcblx0ZGF0YURpcjoge1xuXHRcdHR5cGU6ICdzdHJpbmcnLFxuXHRcdGRlZmF1bHQ6IGFwcC5nZXRQYXRoKCd1c2VyRGF0YScpLFxuXHR9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgbmV3IFN0b3JlKHsgbmFtZTogJ3NldHRpbmdzJywgc2NoZW1hLCBlbmNyeXB0aW9uS2V5OiBwcm9jZXNzLmVudi5WSVRFX0VOQ1JZUFRfS0VZIH0pO1xuIiwiaW1wb3J0IGRhdGEgZnJvbSAnLi9tb2R1bGVzL2RhdGEuc3RvcmUnO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4vbW9kdWxlcy9zZXR0aW5ncy5zdG9yZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblx0ZGF0YSxcblx0c2V0dGluZ3MsXG59O1xuIiwiaW1wb3J0IHsgYXBwLCBCcm93c2VyV2luZG93LCBkaWFsb2csIHByb3RvY29sLCBuYXRpdmVUaGVtZSwgc2hlbGwgfSBmcm9tICdlbGVjdHJvbic7XG5pbXBvcnQgeyBpcGNNYWluIH0gZnJvbSAnZWxlY3Ryb24tYmV0dGVyLWlwYyc7XG5pbXBvcnQgeyBqb2luLCBub3JtYWxpemUgfSBmcm9tICdwYXRoJztcbmltcG9ydCB7IFVSTCB9IGZyb20gJ3VybCc7XG5pbXBvcnQgeyByZW1vdmUsIHJlYWRKc29uLCBlbnN1cmVEaXIsIGNvcHksIG91dHB1dEpzb24sIHBhdGhFeGlzdHNTeW5jIH0gZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHN0b3JlIGZyb20gJy4vc3RvcmUnO1xuXG5jb25zdCBpc1NpbmdsZUluc3RhbmNlID0gYXBwLnJlcXVlc3RTaW5nbGVJbnN0YW5jZUxvY2soKTtcblxuaWYgKCFpc1NpbmdsZUluc3RhbmNlKSB7XG4gIGFwcC5xdWl0KCk7XG4gIHByb2Nlc3MuZXhpdCgwKTtcbn1cblxuYXBwLmRpc2FibGVIYXJkd2FyZUFjY2VsZXJhdGlvbigpO1xuXG4vKipcbiAqIFdvcmthcm91bmQgZm9yIFR5cGVTY3JpcHQgYnVnXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvNDE0NjgjaXNzdWVjb21tZW50LTcyNzU0MzQwMFxuICovXG5jb25zdCBlbnYgPSBpbXBvcnQubWV0YS5lbnY7XG5cbmxldCBtYWluV2luZG93ID0gbnVsbDtcblxuY29uc3QgY3JlYXRlV2luZG93ID0gYXN5bmMgKCkgPT4ge1xuICBtYWluV2luZG93ID0gbmV3IEJyb3dzZXJXaW5kb3coe1xuICAgIHNob3c6IGZhbHNlLFxuICAgIHdpZHRoOiA5NTAsXG4gICAgaGVpZ2h0OiA2MDAsXG4gICAgd2ViUHJlZmVyZW5jZXM6IHtcbiAgICAgIHByZWxvYWQ6IGpvaW4oX19kaXJuYW1lLCAnLi4vLi4vcHJlbG9hZC9kaXN0L2luZGV4LmNqcycpLFxuICAgICAgY29udGV4dElzb2xhdGlvbjogZW52Lk1PREUgIT09ICd0ZXN0JyxcbiAgICAgIGVuYWJsZVJlbW90ZU1vZHVsZTogZW52Lk1PREUgPT09ICd0ZXN0JyxcbiAgICAgIG5vZGVJbnRlZ3JhdGlvbjogdHJ1ZSxcbiAgICB9LFxuICB9KTtcblxuICBtYWluV2luZG93LnNldE1lbnVCYXJWaXNpYmlsaXR5KGZhbHNlKTtcblxuICBtYWluV2luZG93Lm9uKCdyZWFkeS10by1zaG93JywgKCkgPT4ge1xuICAgIG1haW5XaW5kb3c/LnNob3coKTtcblxuICAgIGlmIChlbnYuTU9ERSA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgbWFpbldpbmRvdz8ud2ViQ29udGVudHMub3BlbkRldlRvb2xzKCk7XG4gICAgfVxuICB9KTtcblxuICBtYWluV2luZG93Py53ZWJDb250ZW50cy5vbignbmV3LXdpbmRvdycsIGZ1bmN0aW9uKGV2ZW50LCB1cmwpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgaWYgKHVybC5zdGFydHNXaXRoKCdub3RlOi8vJykpIHJldHVybjtcblxuICAgIHNoZWxsLm9wZW5FeHRlcm5hbCh1cmwpO1xuICB9KTtcblxuICBjb25zdCBwYWdlVXJsID0gZW52Lk1PREUgPT09ICdkZXZlbG9wbWVudCdcbiAgICA/IGVudi5WSVRFX0RFVl9TRVJWRVJfVVJMXG4gICAgOiBuZXcgVVJMKCcuLi9yZW5kZXJlci9kaXN0L2luZGV4Lmh0bWwnLCAnZmlsZTovLycgKyBfX2Rpcm5hbWUpLnRvU3RyaW5nKCk7XG5cbiAgYXdhaXQgbWFpbldpbmRvdy5sb2FkVVJMKHBhZ2VVcmwpO1xufTtcblxuYXBwLm9uKCdOU0FwcGxpY2F0aW9uRGVsZWdhdGUuYXBwbGljYXRpb25TdXBwb3J0c1NlY3VyZVJlc3RvcmFibGVTdGF0ZScsICgpID0+IHtcbiAgcmV0dXJuIHRydWU7XG59KTtcblxuYXBwLm9uKCdzZWNvbmQtaW5zdGFuY2UnLCAoKSA9PiB7XG4gIGlmIChtYWluV2luZG93KSB7XG4gICAgaWYgKG1haW5XaW5kb3cuaXNNaW5pbWl6ZWQoKSkgbWFpbldpbmRvdy5yZXN0b3JlKCk7XG4gICAgbWFpbldpbmRvdy5mb2N1cygpO1xuICB9XG59KTtcblxuYXBwLm9uKCd3aW5kb3ctYWxsLWNsb3NlZCcsICgpID0+IHtcbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gIT09ICdkYXJ3aW4nKSB7XG4gICAgYXBwLnF1aXQoKTtcbiAgfVxufSk7XG5cbmFwcC53aGVuUmVhZHkoKVxuICAudGhlbihhc3luYyAoKSA9PiB7XG4gICAgcHJvdG9jb2wucmVnaXN0ZXJGaWxlUHJvdG9jb2woJ2Fzc2V0cycsIChyZXF1ZXN0LCBjYWxsYmFjaykgPT4ge1xuICAgICAgY29uc3QgdXJsID0gcmVxdWVzdC51cmwuc3Vic3RyKDkpO1xuXG4gICAgICBjb25zdCBkaXIgPSBzdG9yZS5zZXR0aW5ncy5nZXQoJ2RhdGFEaXInKTtcbiAgICAgIGNvbnN0IGltZ1BhdGggPSBgJHtkaXJ9L25vdGVzLWFzc2V0cy8ke3VybH1gO1xuXG4gICAgICBjYWxsYmFjayh7IHBhdGg6IG5vcm1hbGl6ZShpbWdQYXRoKSB9KTtcbiAgICB9KTtcblxuICAgIGF3YWl0IGVuc3VyZURpcihqb2luKGFwcC5nZXRQYXRoKCd1c2VyRGF0YScpLCAnbm90ZXMtYXNzZXRzJykpO1xuICAgIGF3YWl0IGNyZWF0ZVdpbmRvdygpO1xuICB9KVxuICAuY2F0Y2goKGUpID0+IGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCBjcmVhdGUgd2luZG93OicsIGUpKTtcblxuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignYXBwOmluZm8nLCAoKSA9PiAoe1xuICBuYW1lOiBhcHAuZ2V0TmFtZSgpLFxuICB2ZXJzaW9uOiBhcHAuZ2V0VmVyc2lvbigpLFxufSkpO1xuXG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdkaWFsb2c6b3BlbicsIChwcm9wcykgPT4gZGlhbG9nLnNob3dPcGVuRGlhbG9nKHByb3BzKSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdkaWFsb2c6bWVzc2FnZScsIChwcm9wcykgPT4gZGlhbG9nLnNob3dNZXNzYWdlQm94KHByb3BzKSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdkaWFsb2c6c2F2ZScsIChwcm9wcykgPT4gZGlhbG9nLnNob3dTYXZlRGlhbG9nKHByb3BzKSk7XG5cbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2ZzOmNvcHknLCAoeyBwYXRoLCBkZXN0IH0pID0+IGNvcHkocGF0aCwgZGVzdCkpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignZnM6b3V0cHV0LWpzb24nLCAoeyBwYXRoLCBkYXRhIH0pID0+IG91dHB1dEpzb24ocGF0aCwgZGF0YSkpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignZnM6cmVhZC1qc29uJywgKHBhdGgpID0+IHJlYWRKc29uKHBhdGgpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2ZzOmVuc3VyZURpcicsIChwYXRoKSA9PiBlbnN1cmVEaXIocGF0aCkpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignZnM6cGF0aEV4aXN0cycsIChwYXRoKSA9PiBwYXRoRXhpc3RzU3luYyhwYXRoKSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdmczpyZW1vdmUnLCAocGF0aCkgPT4gcmVtb3ZlKHBhdGgpKTtcblxuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignaGVscGVyOnJlbGF1bmNoJywgKG9wdGlvbnMgPSB7fSkgPT4ge1xuICBhcHAucmVsYXVuY2goeyBhcmdzOiBwcm9jZXNzLmFyZ3Yuc2xpY2UoMSkuY29uY2F0KFsnLS1yZWxhdW5jaCddKSwgLi4ub3B0aW9ucyB9KTtcbiAgYXBwLmV4aXQoMCk7XG59KTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2hlbHBlcjpnZXQtcGF0aCcsIChuYW1lKSA9PiBhcHAuZ2V0UGF0aChuYW1lKSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdoZWxwZXI6aXMtZGFyay10aGVtZScsICgpID0+IG5hdGl2ZVRoZW1lLnNob3VsZFVzZURhcmtDb2xvcnMpO1xuXG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdzdG9yYWdlOnN0b3JlJywgKG5hbWUpID0+IHN0b3JlW25hbWVdPy5zdG9yZSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdzdG9yYWdlOnJlcGxhY2UnLCAoeyBuYW1lLCBkYXRhIH0pID0+IChzdG9yZVtuYW1lXS5zdG9yZSA9IGRhdGEpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ3N0b3JhZ2U6Z2V0JywgKHsgbmFtZSwga2V5LCBkZWYgfSkgPT4gc3RvcmVbbmFtZV0/LmdldChrZXksIGRlZikpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignc3RvcmFnZTpzZXQnLCAoeyBuYW1lLCBrZXksIHZhbHVlIH0pID0+IHN0b3JlW25hbWVdPy5zZXQoa2V5LCB2YWx1ZSkpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignc3RvcmFnZTpkZWxldGUnLCAoeyBuYW1lLCBrZXkgfSkgPT4gc3RvcmVbbmFtZV0/LmRlbGV0ZShrZXkpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ3N0b3JhZ2U6aGFzJywgKHsgbmFtZSwga2V5IH0pID0+IHN0b3JlW25hbWVdPy5oYXMoa2V5KSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdzdG9yYWdlOmNsZWFyJywgKG5hbWUpID0+IHN0b3JlW25hbWVdPy5jbGVhcigpKTtcbiJdLCJuYW1lcyI6WyJqc29uIiwidXRpbCIsImlkIiwicmVxdWlyZSQkMSIsInJlcXVpcmUkJDIiLCJpcGNNYWluIiwicmVzb2x2ZSIsIndpbmRvdyIsImVycm9yIiwiY2hhbm5lbCIsImRhdGEiLCJpcGNSZW5kZXJlciIsInJlcXVpcmUkJDAiLCJ1bml2ZXJzYWxpZnkiLCJjb25zdGFudHMiLCJwb2x5ZmlsbHMiLCJwYXRjaCIsImZzIiwicGF0aCIsImVyciIsImVycjIiLCJlciIsImVyMiIsImxlZ2FjeSIsInNlbGYiLCJjbG9uZSIsImNvcHkiLCJyZXF1aXJlJCQzIiwiZGVidWciLCJnbG9iYWwiLCJyZWFkRmlsZSIsIm9wdGlvbnMiLCJjYiIsIndyaXRlRmlsZSIsImNvcHlGaWxlIiwic3JjIiwiZGVzdCIsImZsYWdzIiwibW9kZSIsInUiLCJleHBvcnRzIiwiYnVmZmVyIiwiYnVmZmVycyIsInV0aWxzIiwiY2hlY2tQYXRoIiwiZGVmYXVsdHMiLCJtYWtlRGlyIiwibWtkaXJzIiwicGF0aEV4aXN0cyIsInV0aW1lc01pbGxpcyIsInV0aW1lc01pbGxpc1N5bmMiLCJnZXRTdGF0cyIsIm9wdHMiLCJmaWxlIiwiYXJlSWRlbnRpY2FsIiwic3RhdCIsInJlcXVpcmUkJDQiLCJyZXF1aXJlJCQ1Iiwib25EaXIiLCJvbkZpbGUiLCJvbkxpbmsiLCJmaWxlSXNOb3RXcml0YWJsZSIsIm1ha2VGaWxlV3JpdGFibGUiLCJpdGVtcyIsImRlc3RTdGF0IiwibWtkaXJzU3luYyIsImNvcHlTeW5jIiwicmVtb3ZlIiwicmVtb3ZlU3luYyIsIm1rZGlyIiwiZW1wdHlEaXIiLCJjcmVhdGVGaWxlIiwiY3JlYXRlRmlsZVN5bmMiLCJjcmVhdGVMaW5rIiwiY3JlYXRlTGlua1N5bmMiLCJzeW1saW5rUGF0aHMiLCJzeW1saW5rUGF0aHNTeW5jIiwiZXhpc3RzIiwic3ltbGlua1R5cGUiLCJ0eXBlIiwic3ltbGlua1R5cGVTeW5jIiwicmVxdWlyZSQkNiIsInJlcXVpcmUkJDciLCJjcmVhdGVTeW1saW5rIiwiY3JlYXRlU3ltbGlua1N5bmMiLCJzdHJpbmdpZnkiLCJzdHJpcEJvbSIsInJlYWRGaWxlU3luYyIsIndyaXRlRmlsZVN5bmMiLCJqc29uZmlsZSIsImpzb25GaWxlIiwib3V0cHV0RmlsZSIsIm91dHB1dEZpbGVTeW5jIiwibW92ZSIsImRvUmVuYW1lIiwibW92ZUFjcm9zc0RldmljZSIsInJlcXVpcmUkJDgiLCJyZXF1aXJlJCQ5IiwiaXNPYmoiLCJwYXRoRXhpc3RzTW9kdWxlIiwicFRyeSIsInBUcnlNb2R1bGUiLCJwTGltaXQiLCJlbnF1ZXVlIiwicExpbWl0TW9kdWxlIiwicExvY2F0ZSIsImxpbWl0IiwibG9jYXRlUGF0aE1vZHVsZSIsImZpbmRVcE1vZHVsZSIsInBrZ1VwTW9kdWxlIiwiY3dkIiwiZW52IiwiZW52UGF0aHNNb2R1bGUiLCJjb25zdHNfMSIsImNvZGUiLCJmc18xIiwidXRpbF8xIiwiZGlzdCIsIm5hbWVzIiwiY29kZV8xIiwiVXNlZFZhbHVlU3RhdGUiLCJkZWYiLCJOb2RlIiwibm90IiwiY29kZWdlbl8xIiwic2NoZW1hIiwicnVsZXMiLCJrZXl3b3JkIiwiVHlwZSIsIm5hbWVzXzEiLCJlcnJvcnNfMSIsInZhbGlkIiwiYXBwbGljYWJpbGl0eV8xIiwiRGF0YVR5cGUiLCJ0eXBlcyIsInQiLCJkYXRhVHlwZSIsInByb3BlcnRpZXMiLCJwYXR0ZXJuIiwidmFsaWRhdGUiLCJlcnJvcnMiLCJfYSIsInN1YnNjaGVtYSIsInRyYXZlcnNlIiwianNvblNjaGVtYVRyYXZlcnNlTW9kdWxlIiwidGhpcyIsInNvdXJjZSIsIkhFWERJRyQkIiwiUENUX0VOQ09ERUQkIiwiVU5SRVNFUlZFRCQkIiwiZXJyb3IkMSIsInVjczJlbmNvZGUiLCJiYXNpY1RvRGlnaXQiLCJkaWdpdFRvQmFzaWMiLCJhZGFwdCIsImRlY29kZSIsImVuY29kZSIsInRvVW5pY29kZSIsInRvQVNDSUkiLCJkZWNvZGVVbnJlc2VydmVkIiwicGFyc2UiLCJiYXNlIiwiZXF1YWwiLCJzZXJpYWxpemUiLCJVUkkiLCJyZWYiLCJkYXRhVHlwZV8xIiwicmVzb2x2ZV8xIiwicmVxdWlyZSQkMTAiLCJWYWxpZGF0aW9uRXJyb3IiLCJ2YWxpZGF0ZV8xIiwidmFsaWRhdGlvbl9lcnJvcl8xIiwicmVmX2Vycm9yXzEiLCJjb21waWxlXzEiLCIkc2NoZW1hIiwiZGVmaW5pdGlvbnMiLCJmb3JtYXQiLCJjb3JlXzEiLCJ1Y3MybGVuZ3RoXzEiLCJlcXVhbF8xIiwidmFsaWRhdGlvbl8xIiwiaXRlbXNfMSIsImFkZGl0aW9uYWxJdGVtc18xIiwicHJlZml4SXRlbXMiLCJhZGRpdGlvbmFsUHJvcGVydGllc18xIiwicmVxdWlyZSQkMTEiLCJyZXF1aXJlJCQxMiIsInJlcXVpcmUkJDEzIiwicmVxdWlyZSQkMTQiLCJyZXF1aXJlJCQxNSIsImFwcGxpY2F0b3IiLCJmb3JtYXRfMiIsImZvcm1hdF8xIiwib25lT2YiLCJyZXF1aXJlZCIsIm1vZHVsZSIsImNvbXBhcmUiLCJvcHMiLCJLV0RzIiwiYWp2IiwiZm9ybWF0cyIsIm1pbWljRm4iLCJNQVhfTEVOR1RIIiwiTUFYX1NBRkVfSU5URUdFUiIsIk1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEgiLCJyZSIsInBhcnNlT3B0aW9ucyIsImNvbXBhcmVJZGVudGlmaWVycyIsInNlbXZlciIsIlNlbVZlciIsImVxIiwiY29tcGFyZUJ1aWxkIiwiZ3QiLCJsdCIsIm5lcSIsImd0ZSIsImx0ZSIsIllhbGxpc3QiLCJkaWZmIiwiUmFuZ2UiLCJyYW5nZSIsIkNvbXBhcmF0b3IiLCJjb21wIiwiQU5ZIiwiY21wIiwic2F0aXNmaWVzIiwiY29tcGFyYXRvciIsIm91dHNpZGUiLCJtaW4iLCJyZXF1aXJlJCQxNiIsInJlcXVpcmUkJDE3IiwicmVxdWlyZSQkMTgiLCJyZXF1aXJlJCQxOSIsInJlcXVpcmUkJDIwIiwicmVxdWlyZSQkMjEiLCJyZXF1aXJlJCQyMiIsInJlcXVpcmUkJDIzIiwicmVxdWlyZSQkMjQiLCJyZXF1aXJlJCQyNSIsInJlcXVpcmUkJDI2IiwicmVxdWlyZSQkMjciLCJyZXF1aXJlJCQyOCIsInJlcXVpcmUkJDI5IiwicmVxdWlyZSQkMzAiLCJyZXF1aXJlJCQzMSIsInJlcXVpcmUkJDMyIiwicmVxdWlyZSQkMzMiLCJyZXF1aXJlJCQzNCIsInJlcXVpcmUkJDM1IiwicmVxdWlyZSQkMzYiLCJyZXF1aXJlJCQzNyIsInJlcXVpcmUkJDM4IiwicmVxdWlyZSQkMzkiLCJyZXF1aXJlJCQ0MCIsIm1pbWljRm5Nb2R1bGUiLCJvbmV0aW1lIiwib25ldGltZU1vZHVsZSIsImRvdFByb3AiLCJwa2dVcCIsImVudlBhdGhzIiwiZGVib3VuY2VGbiIsIkNvbmYiLCJzdG9yZSIsIl9iIiwia2V5IiwidmFsdWUiLCJkZWZpbmVfaW1wb3J0X21ldGFfZW52X2RlZmF1bHQiLCJhcHAiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFFQSxNQUFNLGlCQUFpQixNQUFNO0FBQUEsSUFDNUIsWUFBWSxTQUFTO0FBQ3BCLFlBQU0sU0FBUyxxQkFBcUIsT0FBTyxDQUFDO0FBQzVDLGFBQU8sZUFB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MSwyLDMsNCw1LDYsNyw4LDksMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsMjksMzAsMzEsMzIsMzMsMzQsMzUsMzYsMzcsMzgsMzksNDAsNDEsNDIsNDMsNDQsNDUsNDYsNDcsNDgsNDksNTAsNTEsNTIsNTMsNTQsNTUsNTYsNTcsNTgsNTksNjAsNjEsNjIsNjMsNjQsNjUsNjYsNjcsNjgsNjksNzAsNzEsNzIsNzMsNzQsNzUsNzYsNzcsNzgsNzksODAsODEsODIsODMsODQsODUsODYsODcsODgsODksOTAsOTEsOTIsOTMsOTQsOTUsOTYsOTcsOTgsOTksMTAwLDEwMSwxMDIsMTAzLDEwNCwxMDUsMTA2LDEwNywxMDgsMTA5LDExMCwxMTEsMTEyLDExMywxMTQsMTE1LDExNiwxMTcsMTE4LDExOSwxMjAsMTIxLDEyMiwxMjMsMTI0LDEyNSwxMjYsMTI3LDEyOCwxMjksMTMwLDEzMSwxMzIsMTMzLDEzNCwxMzUsMTM2LDEzNywxMzgsMTM5LDE0MCwxNDEsMTQyLDE0MywxNDQsMTQ1LDE0NiwxNDcsMTQ4LDE0OSwxNTAsMTUxLDE1MiwxNTMsMTU0LDE1NSwxNTYsMTU3LDE1OCwxNTksMTYwLDE2MSwxNjIsMTYzLDE2NCwxNjUsMTY2LDE2NywxNjgsMTY5LDE3MCwxNzEsMTcyLDE3MywxNzQsMTc1LDE3NiwxNzddfQ==
