"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source2, exclude) => {
  var target = {};
  for (var prop in source2)
    if (__hasOwnProp.call(source2, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source2[prop];
  if (source2 != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source2)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source2, prop))
        target[prop] = source2[prop];
    }
  return target;
};
var require$$1 = require("electron");
var require$$1$2 = require("path");
var require$$4 = require("url");
var require$$1$1 = require("fs");
var require$$0 = require("constants");
var require$$0$1 = require("stream");
var require$$2$1 = require("util");
var require$$2 = require("assert");
var require$$0$2 = require("events");
var require$$0$3 = require("crypto");
var require$$1$3 = require("string_decoder");
var require$$1$4 = require("os");
var require$$1$5 = require("child_process");
var require$$2$2 = require("zlib");
var require$$3$1 = require("http");
function _interopDefaultLegacy(e) {
  return e && typeof e === "object" && "default" in e ? e : { "default": e };
}
function _interopNamespace(e) {
  if (e && e.__esModule)
    return e;
  var n = { __proto__: null, [Symbol.toStringTag]: "Module" };
  if (e) {
    Object.keys(e).forEach(function(k) {
      if (k !== "default") {
        var d2 = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d2.get ? d2 : {
          enumerable: true,
          get: function() {
            return e[k];
          }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}
var require$$1__default = /* @__PURE__ */ _interopDefaultLegacy(require$$1);
var require$$1__default$2 = /* @__PURE__ */ _interopDefaultLegacy(require$$1$2);
var require$$4__default = /* @__PURE__ */ _interopDefaultLegacy(require$$4);
var require$$1__default$1 = /* @__PURE__ */ _interopDefaultLegacy(require$$1$1);
var require$$0__default = /* @__PURE__ */ _interopDefaultLegacy(require$$0);
var require$$0__default$1 = /* @__PURE__ */ _interopDefaultLegacy(require$$0$1);
var require$$2__default$1 = /* @__PURE__ */ _interopDefaultLegacy(require$$2$1);
var require$$2__default = /* @__PURE__ */ _interopDefaultLegacy(require$$2);
var require$$0__default$2 = /* @__PURE__ */ _interopDefaultLegacy(require$$0$2);
var require$$0__default$3 = /* @__PURE__ */ _interopDefaultLegacy(require$$0$3);
var require$$1__default$3 = /* @__PURE__ */ _interopDefaultLegacy(require$$1$3);
var require$$1__default$4 = /* @__PURE__ */ _interopDefaultLegacy(require$$1$4);
var require$$1__default$5 = /* @__PURE__ */ _interopDefaultLegacy(require$$1$5);
var require$$2__default$2 = /* @__PURE__ */ _interopDefaultLegacy(require$$2$2);
var require$$3__default = /* @__PURE__ */ _interopDefaultLegacy(require$$3$1);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
class NonError extends Error {
  constructor(message) {
    super(NonError._prepareSuperMessage(message));
    Object.defineProperty(this, "name", {
      value: "NonError",
      configurable: true,
      writable: true
    });
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, NonError);
    }
  }
  static _prepareSuperMessage(message) {
    try {
      return JSON.stringify(message);
    } catch {
      return String(message);
    }
  }
}
const commonProperties = [
  { property: "name", enumerable: false },
  { property: "message", enumerable: false },
  { property: "stack", enumerable: false },
  { property: "code", enumerable: true }
];
const isCalled = Symbol(".toJSON called");
const toJSON = (from) => {
  from[isCalled] = true;
  const json2 = from.toJSON();
  delete from[isCalled];
  return json2;
};
const destroyCircular = ({
  from,
  seen,
  to_,
  forceEnumerable,
  maxDepth,
  depth
}) => {
  const to = to_ || (Array.isArray(from) ? [] : {});
  seen.push(from);
  if (depth >= maxDepth) {
    return to;
  }
  if (typeof from.toJSON === "function" && from[isCalled] !== true) {
    return toJSON(from);
  }
  for (const [key, value] of Object.entries(from)) {
    if (typeof Buffer === "function" && Buffer.isBuffer(value)) {
      to[key] = "[object Buffer]";
      continue;
    }
    if (typeof value === "function") {
      continue;
    }
    if (!value || typeof value !== "object") {
      to[key] = value;
      continue;
    }
    if (!seen.includes(from[key])) {
      depth++;
      to[key] = destroyCircular({
        from: from[key],
        seen: seen.slice(),
        forceEnumerable,
        maxDepth,
        depth
      });
      continue;
    }
    to[key] = "[Circular]";
  }
  for (const { property, enumerable } of commonProperties) {
    if (typeof from[property] === "string") {
      Object.defineProperty(to, property, {
        value: from[property],
        enumerable: forceEnumerable ? true : enumerable,
        configurable: true,
        writable: true
      });
    }
  }
  return to;
};
const serializeError$2 = (value, options = {}) => {
  const { maxDepth = Number.POSITIVE_INFINITY } = options;
  if (typeof value === "object" && value !== null) {
    return destroyCircular({
      from: value,
      seen: [],
      forceEnumerable: true,
      maxDepth,
      depth: 0
    });
  }
  if (typeof value === "function") {
    return `[Function: ${value.name || "anonymous"}]`;
  }
  return value;
};
const deserializeError$2 = (value, options = {}) => {
  const { maxDepth = Number.POSITIVE_INFINITY } = options;
  if (value instanceof Error) {
    return value;
  }
  if (typeof value === "object" && value !== null && !Array.isArray(value)) {
    const newError = new Error();
    destroyCircular({
      from: value,
      seen: [],
      to_: newError,
      maxDepth,
      depth: 0
    });
    return newError;
  }
  return new NonError(value);
};
var serializeError_1 = {
  serializeError: serializeError$2,
  deserializeError: deserializeError$2
};
var util$7 = {};
const getUniqueId = () => `${Date.now()}-${Math.random()}`;
const getSendChannel = (channel) => `%better-ipc-send-channel-${channel}`;
const getRendererSendChannel = (channel) => `%better-ipc-send-channel-${channel}`;
util$7.currentWindowChannel = "%better-ipc-current-window";
util$7.getSendChannel = getSendChannel;
util$7.getRendererSendChannel = getRendererSendChannel;
util$7.getResponseChannels = (channel) => {
  const id2 = getUniqueId();
  return {
    sendChannel: getSendChannel(channel),
    dataChannel: `%better-ipc-response-data-channel-${channel}-${id2}`,
    errorChannel: `%better-ipc-response-error-channel-${channel}-${id2}`
  };
};
util$7.getRendererResponseChannels = (channel) => {
  const id2 = getUniqueId();
  return {
    sendChannel: getRendererSendChannel(channel),
    dataChannel: `%better-ipc-response-data-channel-${channel}-${id2}`,
    errorChannel: `%better-ipc-response-error-channel-${channel}-${id2}`
  };
};
const electron$1 = require$$1__default["default"];
const { serializeError: serializeError$1, deserializeError: deserializeError$1 } = serializeError_1;
const util$6 = util$7;
const { ipcRenderer: ipcRenderer$1 } = electron$1;
const ipc$1 = Object.create(ipcRenderer$1 || {});
ipc$1.callMain = (channel, data) => new Promise((resolve2, reject) => {
  const { sendChannel, dataChannel, errorChannel } = util$6.getResponseChannels(channel);
  const cleanup = () => {
    ipcRenderer$1.off(dataChannel, onData);
    ipcRenderer$1.off(errorChannel, onError);
  };
  const onData = (_event, result) => {
    cleanup();
    resolve2(result);
  };
  const onError = (_event, error2) => {
    cleanup();
    reject(deserializeError$1(error2));
  };
  ipcRenderer$1.once(dataChannel, onData);
  ipcRenderer$1.once(errorChannel, onError);
  const completeData = {
    dataChannel,
    errorChannel,
    userData: data
  };
  ipcRenderer$1.send(sendChannel, completeData);
});
ipc$1.answerMain = (channel, callback) => {
  const sendChannel = util$6.getRendererSendChannel(channel);
  const listener = async (_event, data) => {
    const { dataChannel, errorChannel, userData } = data;
    try {
      ipcRenderer$1.send(dataChannel, await callback(userData));
    } catch (error2) {
      ipcRenderer$1.send(errorChannel, serializeError$1(error2));
    }
  };
  ipcRenderer$1.on(sendChannel, listener);
  return () => {
    ipcRenderer$1.off(sendChannel, listener);
  };
};
const electron = require$$1__default["default"];
const { serializeError, deserializeError } = serializeError_1;
const util$5 = util$7;
const { ipcMain: ipcMain$2, BrowserWindow } = electron;
const ipc = Object.create(ipcMain$2 || {});
ipc.callRenderer = (browserWindow, channel, data) => new Promise((resolve2, reject) => {
  if (!browserWindow) {
    throw new Error("Browser window required");
  }
  const { sendChannel, dataChannel, errorChannel } = util$5.getRendererResponseChannels(channel);
  const cleanup = () => {
    ipcMain$2.off(dataChannel, onData);
    ipcMain$2.off(errorChannel, onError);
  };
  const onData = (event, result) => {
    const window2 = BrowserWindow.fromWebContents(event.sender);
    if (window2.id === browserWindow.id) {
      cleanup();
      resolve2(result);
    }
  };
  const onError = (event, error2) => {
    const window2 = BrowserWindow.fromWebContents(event.sender);
    if (window2.id === browserWindow.id) {
      cleanup();
      reject(deserializeError(error2));
    }
  };
  ipcMain$2.on(dataChannel, onData);
  ipcMain$2.on(errorChannel, onError);
  const completeData = {
    dataChannel,
    errorChannel,
    userData: data
  };
  if (browserWindow.webContents) {
    browserWindow.webContents.send(sendChannel, completeData);
  }
});
ipc.callFocusedRenderer = async (...args) => {
  const focusedWindow = BrowserWindow.getFocusedWindow();
  if (!focusedWindow) {
    throw new Error("No browser window in focus");
  }
  return ipc.callRenderer(focusedWindow, ...args);
};
ipc.answerRenderer = (browserWindowOrChannel, channelOrCallback, callbackOrNothing) => {
  let window2;
  let channel;
  let callback;
  if (callbackOrNothing === void 0) {
    channel = browserWindowOrChannel;
    callback = channelOrCallback;
  } else {
    window2 = browserWindowOrChannel;
    channel = channelOrCallback;
    callback = callbackOrNothing;
    if (!window2) {
      throw new Error("Browser window required");
    }
  }
  const sendChannel = util$5.getSendChannel(channel);
  const listener = async (event, data) => {
    const browserWindow = BrowserWindow.fromWebContents(event.sender);
    if (window2 && window2.id !== browserWindow.id) {
      return;
    }
    const send = (channel2, data2) => {
      if (!(browserWindow && browserWindow.isDestroyed())) {
        event.sender.send(channel2, data2);
      }
    };
    const { dataChannel, errorChannel, userData } = data;
    try {
      send(dataChannel, await callback(userData, browserWindow));
    } catch (error2) {
      send(errorChannel, serializeError(error2));
    }
  };
  ipcMain$2.on(sendChannel, listener);
  return () => {
    ipcMain$2.off(sendChannel, listener);
  };
};
ipc.sendToRenderers = (channel, data) => {
  for (const browserWindow of BrowserWindow.getAllWindows()) {
    if (browserWindow.webContents) {
      browserWindow.webContents.send(channel, data);
    }
  }
};
var main$2 = ipc;
var ipcMain$1;
if (process.type === "renderer")
  ;
else {
  ipcMain$1 = main$2;
}
var fs$D = {};
var universalify$1 = {};
universalify$1.fromCallback = function(fn) {
  return Object.defineProperty(function(...args) {
    if (typeof args[args.length - 1] === "function")
      fn.apply(this, args);
    else {
      return new Promise((resolve2, reject) => {
        fn.call(this, ...args, (err, res) => err != null ? reject(err) : resolve2(res));
      });
    }
  }, "name", { value: fn.name });
};
universalify$1.fromPromise = function(fn) {
  return Object.defineProperty(function(...args) {
    const cb = args[args.length - 1];
    if (typeof cb !== "function")
      return fn.apply(this, args);
    else
      fn.apply(this, args.slice(0, -1)).then((r) => cb(null, r), cb);
  }, "name", { value: fn.name });
};
var constants$3 = require$$0__default["default"];
var origCwd = process.cwd;
var cwd = null;
var platform = process.platform;
process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process);
  return cwd;
};
try {
  process.cwd();
} catch (er) {
}
if (typeof process.chdir === "function") {
  var chdir = process.chdir;
  process.chdir = function(d2) {
    cwd = null;
    chdir.call(process, d2);
  };
  if (Object.setPrototypeOf)
    Object.setPrototypeOf(process.chdir, chdir);
}
var polyfills$1 = patch$4;
function patch$4(fs2) {
  if (constants$3.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs2);
  }
  if (!fs2.lutimes) {
    patchLutimes(fs2);
  }
  fs2.chown = chownFix(fs2.chown);
  fs2.fchown = chownFix(fs2.fchown);
  fs2.lchown = chownFix(fs2.lchown);
  fs2.chmod = chmodFix(fs2.chmod);
  fs2.fchmod = chmodFix(fs2.fchmod);
  fs2.lchmod = chmodFix(fs2.lchmod);
  fs2.chownSync = chownFixSync(fs2.chownSync);
  fs2.fchownSync = chownFixSync(fs2.fchownSync);
  fs2.lchownSync = chownFixSync(fs2.lchownSync);
  fs2.chmodSync = chmodFixSync(fs2.chmodSync);
  fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
  fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
  fs2.stat = statFix(fs2.stat);
  fs2.fstat = statFix(fs2.fstat);
  fs2.lstat = statFix(fs2.lstat);
  fs2.statSync = statFixSync(fs2.statSync);
  fs2.fstatSync = statFixSync(fs2.fstatSync);
  fs2.lstatSync = statFixSync(fs2.lstatSync);
  if (!fs2.lchmod) {
    fs2.lchmod = function(path2, mode, cb) {
      if (cb)
        process.nextTick(cb);
    };
    fs2.lchmodSync = function() {
    };
  }
  if (!fs2.lchown) {
    fs2.lchown = function(path2, uid, gid, cb) {
      if (cb)
        process.nextTick(cb);
    };
    fs2.lchownSync = function() {
    };
  }
  if (platform === "win32") {
    fs2.rename = function(fs$rename) {
      return function(from, to, cb) {
        var start = Date.now();
        var backoff = 0;
        fs$rename(from, to, function CB(er) {
          if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
            setTimeout(function() {
              fs2.stat(to, function(stater, st) {
                if (stater && stater.code === "ENOENT")
                  fs$rename(from, to, CB);
                else
                  cb(er);
              });
            }, backoff);
            if (backoff < 100)
              backoff += 10;
            return;
          }
          if (cb)
            cb(er);
        });
      };
    }(fs2.rename);
  }
  fs2.read = function(fs$read) {
    function read(fd, buffer, offset, length, position, callback_) {
      var callback;
      if (callback_ && typeof callback_ === "function") {
        var eagCounter = 0;
        callback = function(er, _, __) {
          if (er && er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
          }
          callback_.apply(this, arguments);
        };
      }
      return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
    }
    if (Object.setPrototypeOf)
      Object.setPrototypeOf(read, fs$read);
    return read;
  }(fs2.read);
  fs2.readSync = function(fs$readSync) {
    return function(fd, buffer, offset, length, position) {
      var eagCounter = 0;
      while (true) {
        try {
          return fs$readSync.call(fs2, fd, buffer, offset, length, position);
        } catch (er) {
          if (er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            continue;
          }
          throw er;
        }
      }
    };
  }(fs2.readSync);
  function patchLchmod(fs3) {
    fs3.lchmod = function(path2, mode, callback) {
      fs3.open(path2, constants$3.O_WRONLY | constants$3.O_SYMLINK, mode, function(err, fd) {
        if (err) {
          if (callback)
            callback(err);
          return;
        }
        fs3.fchmod(fd, mode, function(err2) {
          fs3.close(fd, function(err22) {
            if (callback)
              callback(err2 || err22);
          });
        });
      });
    };
    fs3.lchmodSync = function(path2, mode) {
      var fd = fs3.openSync(path2, constants$3.O_WRONLY | constants$3.O_SYMLINK, mode);
      var threw = true;
      var ret;
      try {
        ret = fs3.fchmodSync(fd, mode);
        threw = false;
      } finally {
        if (threw) {
          try {
            fs3.closeSync(fd);
          } catch (er) {
          }
        } else {
          fs3.closeSync(fd);
        }
      }
      return ret;
    };
  }
  function patchLutimes(fs3) {
    if (constants$3.hasOwnProperty("O_SYMLINK")) {
      fs3.lutimes = function(path2, at, mt, cb) {
        fs3.open(path2, constants$3.O_SYMLINK, function(er, fd) {
          if (er) {
            if (cb)
              cb(er);
            return;
          }
          fs3.futimes(fd, at, mt, function(er2) {
            fs3.close(fd, function(er22) {
              if (cb)
                cb(er2 || er22);
            });
          });
        });
      };
      fs3.lutimesSync = function(path2, at, mt) {
        var fd = fs3.openSync(path2, constants$3.O_SYMLINK);
        var ret;
        var threw = true;
        try {
          ret = fs3.futimesSync(fd, at, mt);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs3.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs3.closeSync(fd);
          }
        }
        return ret;
      };
    } else {
      fs3.lutimes = function(_a, _b, _c, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs3.lutimesSync = function() {
      };
    }
  }
  function chmodFix(orig) {
    if (!orig)
      return orig;
    return function(target, mode, cb) {
      return orig.call(fs2, target, mode, function(er) {
        if (chownErOk(er))
          er = null;
        if (cb)
          cb.apply(this, arguments);
      });
    };
  }
  function chmodFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, mode) {
      try {
        return orig.call(fs2, target, mode);
      } catch (er) {
        if (!chownErOk(er))
          throw er;
      }
    };
  }
  function chownFix(orig) {
    if (!orig)
      return orig;
    return function(target, uid, gid, cb) {
      return orig.call(fs2, target, uid, gid, function(er) {
        if (chownErOk(er))
          er = null;
        if (cb)
          cb.apply(this, arguments);
      });
    };
  }
  function chownFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, uid, gid) {
      try {
        return orig.call(fs2, target, uid, gid);
      } catch (er) {
        if (!chownErOk(er))
          throw er;
      }
    };
  }
  function statFix(orig) {
    if (!orig)
      return orig;
    return function(target, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      function callback(er, stats) {
        if (stats) {
          if (stats.uid < 0)
            stats.uid += 4294967296;
          if (stats.gid < 0)
            stats.gid += 4294967296;
        }
        if (cb)
          cb.apply(this, arguments);
      }
      return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
    };
  }
  function statFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, options) {
      var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
      if (stats.uid < 0)
        stats.uid += 4294967296;
      if (stats.gid < 0)
        stats.gid += 4294967296;
      return stats;
    };
  }
  function chownErOk(er) {
    if (!er)
      return true;
    if (er.code === "ENOSYS")
      return true;
    var nonroot = !process.getuid || process.getuid() !== 0;
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true;
    }
    return false;
  }
}
var Stream = require$$0__default$1["default"].Stream;
var legacyStreams = legacy$1;
function legacy$1(fs2) {
  return {
    ReadStream,
    WriteStream
  };
  function ReadStream(path2, options) {
    if (!(this instanceof ReadStream))
      return new ReadStream(path2, options);
    Stream.call(this);
    var self2 = this;
    this.path = path2;
    this.fd = null;
    this.readable = true;
    this.paused = false;
    this.flags = "r";
    this.mode = 438;
    this.bufferSize = 64 * 1024;
    options = options || {};
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }
    if (this.encoding)
      this.setEncoding(this.encoding);
    if (this.start !== void 0) {
      if (typeof this.start !== "number") {
        throw TypeError("start must be a Number");
      }
      if (this.end === void 0) {
        this.end = Infinity;
      } else if (typeof this.end !== "number") {
        throw TypeError("end must be a Number");
      }
      if (this.start > this.end) {
        throw new Error("start must be <= end");
      }
      this.pos = this.start;
    }
    if (this.fd !== null) {
      process.nextTick(function() {
        self2._read();
      });
      return;
    }
    fs2.open(this.path, this.flags, this.mode, function(err, fd) {
      if (err) {
        self2.emit("error", err);
        self2.readable = false;
        return;
      }
      self2.fd = fd;
      self2.emit("open", fd);
      self2._read();
    });
  }
  function WriteStream(path2, options) {
    if (!(this instanceof WriteStream))
      return new WriteStream(path2, options);
    Stream.call(this);
    this.path = path2;
    this.fd = null;
    this.writable = true;
    this.flags = "w";
    this.encoding = "binary";
    this.mode = 438;
    this.bytesWritten = 0;
    options = options || {};
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }
    if (this.start !== void 0) {
      if (typeof this.start !== "number") {
        throw TypeError("start must be a Number");
      }
      if (this.start < 0) {
        throw new Error("start must be >= zero");
      }
      this.pos = this.start;
    }
    this.busy = false;
    this._queue = [];
    if (this.fd === null) {
      this._open = fs2.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
      this.flush();
    }
  }
}
var clone_1 = clone$1;
var getPrototypeOf = Object.getPrototypeOf || function(obj) {
  return obj.__proto__;
};
function clone$1(obj) {
  if (obj === null || typeof obj !== "object")
    return obj;
  if (obj instanceof Object)
    var copy2 = { __proto__: getPrototypeOf(obj) };
  else
    var copy2 = Object.create(null);
  Object.getOwnPropertyNames(obj).forEach(function(key) {
    Object.defineProperty(copy2, key, Object.getOwnPropertyDescriptor(obj, key));
  });
  return copy2;
}
var fs$C = require$$1__default$1["default"];
var polyfills = polyfills$1;
var legacy = legacyStreams;
var clone = clone_1;
var util$4 = require$$2__default$1["default"];
var gracefulQueue;
var previousSymbol;
if (typeof Symbol === "function" && typeof Symbol.for === "function") {
  gracefulQueue = Symbol.for("graceful-fs.queue");
  previousSymbol = Symbol.for("graceful-fs.previous");
} else {
  gracefulQueue = "___graceful-fs.queue";
  previousSymbol = "___graceful-fs.previous";
}
function noop() {
}
function publishQueue(context, queue2) {
  Object.defineProperty(context, gracefulQueue, {
    get: function() {
      return queue2;
    }
  });
}
var debug$9 = noop;
if (util$4.debuglog)
  debug$9 = util$4.debuglog("gfs4");
else if (/\bgfs4\b/i.test(""))
  debug$9 = function() {
    var m2 = util$4.format.apply(util$4, arguments);
    m2 = "GFS4: " + m2.split(/\n/).join("\nGFS4: ");
    console.error(m2);
  };
if (!fs$C[gracefulQueue]) {
  var queue = commonjsGlobal[gracefulQueue] || [];
  publishQueue(fs$C, queue);
  fs$C.close = function(fs$close) {
    function close(fd, cb) {
      return fs$close.call(fs$C, fd, function(err) {
        if (!err) {
          resetQueue();
        }
        if (typeof cb === "function")
          cb.apply(this, arguments);
      });
    }
    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    });
    return close;
  }(fs$C.close);
  fs$C.closeSync = function(fs$closeSync) {
    function closeSync(fd) {
      fs$closeSync.apply(fs$C, arguments);
      resetQueue();
    }
    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    });
    return closeSync;
  }(fs$C.closeSync);
  if (/\bgfs4\b/i.test("")) {
    process.on("exit", function() {
      debug$9(fs$C[gracefulQueue]);
      require$$2__default["default"].equal(fs$C[gracefulQueue].length, 0);
    });
  }
}
if (!commonjsGlobal[gracefulQueue]) {
  publishQueue(commonjsGlobal, fs$C[gracefulQueue]);
}
var gracefulFs = patch$3(clone(fs$C));
function patch$3(fs2) {
  polyfills(fs2);
  fs2.gracefulify = patch$3;
  fs2.createReadStream = createReadStream;
  fs2.createWriteStream = createWriteStream;
  var fs$readFile = fs2.readFile;
  fs2.readFile = readFile2;
  function readFile2(path2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$readFile(path2, options, cb);
    function go$readFile(path3, options2, cb2, startTime) {
      return fs$readFile(path3, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$readFile, [path3, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$writeFile = fs2.writeFile;
  fs2.writeFile = writeFile2;
  function writeFile2(path2, data, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$writeFile(path2, data, options, cb);
    function go$writeFile(path3, data2, options2, cb2, startTime) {
      return fs$writeFile(path3, data2, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$writeFile, [path3, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$appendFile = fs2.appendFile;
  if (fs$appendFile)
    fs2.appendFile = appendFile;
  function appendFile(path2, data, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$appendFile(path2, data, options, cb);
    function go$appendFile(path3, data2, options2, cb2, startTime) {
      return fs$appendFile(path3, data2, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$appendFile, [path3, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$copyFile = fs2.copyFile;
  if (fs$copyFile)
    fs2.copyFile = copyFile2;
  function copyFile2(src, dest, flags, cb) {
    if (typeof flags === "function") {
      cb = flags;
      flags = 0;
    }
    return go$copyFile(src, dest, flags, cb);
    function go$copyFile(src2, dest2, flags2, cb2, startTime) {
      return fs$copyFile(src2, dest2, flags2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$readdir = fs2.readdir;
  fs2.readdir = readdir;
  function readdir(path2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$readdir(path2, options, cb);
    function go$readdir(path3, options2, cb2, startTime) {
      return fs$readdir(path3, options2, function(err, files) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$readdir, [path3, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (files && files.sort)
            files.sort();
          if (typeof cb2 === "function")
            cb2.call(this, err, files);
        }
      });
    }
  }
  if (process.version.substr(0, 4) === "v0.8") {
    var legStreams = legacy(fs2);
    ReadStream = legStreams.ReadStream;
    WriteStream = legStreams.WriteStream;
  }
  var fs$ReadStream = fs2.ReadStream;
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype);
    ReadStream.prototype.open = ReadStream$open;
  }
  var fs$WriteStream = fs2.WriteStream;
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype);
    WriteStream.prototype.open = WriteStream$open;
  }
  Object.defineProperty(fs2, "ReadStream", {
    get: function() {
      return ReadStream;
    },
    set: function(val) {
      ReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(fs2, "WriteStream", {
    get: function() {
      return WriteStream;
    },
    set: function(val) {
      WriteStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileReadStream = ReadStream;
  Object.defineProperty(fs2, "FileReadStream", {
    get: function() {
      return FileReadStream;
    },
    set: function(val) {
      FileReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileWriteStream = WriteStream;
  Object.defineProperty(fs2, "FileWriteStream", {
    get: function() {
      return FileWriteStream;
    },
    set: function(val) {
      FileWriteStream = val;
    },
    enumerable: true,
    configurable: true
  });
  function ReadStream(path2, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this;
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
  }
  function ReadStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function(err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy();
        that.emit("error", err);
      } else {
        that.fd = fd;
        that.emit("open", fd);
        that.read();
      }
    });
  }
  function WriteStream(path2, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this;
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
  }
  function WriteStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function(err, fd) {
      if (err) {
        that.destroy();
        that.emit("error", err);
      } else {
        that.fd = fd;
        that.emit("open", fd);
      }
    });
  }
  function createReadStream(path2, options) {
    return new fs2.ReadStream(path2, options);
  }
  function createWriteStream(path2, options) {
    return new fs2.WriteStream(path2, options);
  }
  var fs$open = fs2.open;
  fs2.open = open;
  function open(path2, flags, mode, cb) {
    if (typeof mode === "function")
      cb = mode, mode = null;
    return go$open(path2, flags, mode, cb);
    function go$open(path3, flags2, mode2, cb2, startTime) {
      return fs$open(path3, flags2, mode2, function(err, fd) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$open, [path3, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  return fs2;
}
function enqueue(elem) {
  debug$9("ENQUEUE", elem[0].name, elem[1]);
  fs$C[gracefulQueue].push(elem);
  retry();
}
var retryTimer;
function resetQueue() {
  var now = Date.now();
  for (var i2 = 0; i2 < fs$C[gracefulQueue].length; ++i2) {
    if (fs$C[gracefulQueue][i2].length > 2) {
      fs$C[gracefulQueue][i2][3] = now;
      fs$C[gracefulQueue][i2][4] = now;
    }
  }
  retry();
}
function retry() {
  clearTimeout(retryTimer);
  retryTimer = void 0;
  if (fs$C[gracefulQueue].length === 0)
    return;
  var elem = fs$C[gracefulQueue].shift();
  var fn = elem[0];
  var args = elem[1];
  var err = elem[2];
  var startTime = elem[3];
  var lastTime = elem[4];
  if (startTime === void 0) {
    debug$9("RETRY", fn.name, args);
    fn.apply(null, args);
  } else if (Date.now() - startTime >= 6e4) {
    debug$9("TIMEOUT", fn.name, args);
    var cb = args.pop();
    if (typeof cb === "function")
      cb.call(null, err);
  } else {
    var sinceAttempt = Date.now() - lastTime;
    var sinceStart = Math.max(lastTime - startTime, 1);
    var desiredDelay = Math.min(sinceStart * 1.2, 100);
    if (sinceAttempt >= desiredDelay) {
      debug$9("RETRY", fn.name, args);
      fn.apply(null, args.concat([startTime]));
    } else {
      fs$C[gracefulQueue].push(elem);
    }
  }
  if (retryTimer === void 0) {
    retryTimer = setTimeout(retry, 0);
  }
}
(function(exports) {
  const u2 = universalify$1.fromCallback;
  const fs2 = gracefulFs;
  const api = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((key) => {
    return typeof fs2[key] === "function";
  });
  Object.assign(exports, fs2);
  api.forEach((method) => {
    exports[method] = u2(fs2[method]);
  });
  exports.realpath.native = u2(fs2.realpath.native);
  exports.exists = function(filename, callback) {
    if (typeof callback === "function") {
      return fs2.exists(filename, callback);
    }
    return new Promise((resolve2) => {
      return fs2.exists(filename, resolve2);
    });
  };
  exports.read = function(fd, buffer, offset, length, position, callback) {
    if (typeof callback === "function") {
      return fs2.read(fd, buffer, offset, length, position, callback);
    }
    return new Promise((resolve2, reject) => {
      fs2.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
        if (err)
          return reject(err);
        resolve2({ bytesRead, buffer: buffer2 });
      });
    });
  };
  exports.write = function(fd, buffer, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs2.write(fd, buffer, ...args);
    }
    return new Promise((resolve2, reject) => {
      fs2.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
        if (err)
          return reject(err);
        resolve2({ bytesWritten, buffer: buffer2 });
      });
    });
  };
  if (typeof fs2.writev === "function") {
    exports.writev = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs2.writev(fd, buffers, ...args);
      }
      return new Promise((resolve2, reject) => {
        fs2.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
          if (err)
            return reject(err);
          resolve2({ bytesWritten, buffers: buffers2 });
        });
      });
    };
  }
})(fs$D);
var makeDir$3 = {};
var utils$2 = {};
const path$C = require$$1__default$2["default"];
utils$2.checkPath = function checkPath2(pth) {
  if (process.platform === "win32") {
    const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path$C.parse(pth).root, ""));
    if (pathHasInvalidWinCharacters) {
      const error2 = new Error(`Path contains invalid characters: ${pth}`);
      error2.code = "EINVAL";
      throw error2;
    }
  }
};
const fs$B = fs$D;
const { checkPath: checkPath$1 } = utils$2;
const getMode$1 = (options) => {
  const defaults2 = { mode: 511 };
  if (typeof options === "number")
    return options;
  return __spreadValues(__spreadValues({}, defaults2), options).mode;
};
makeDir$3.makeDir = async (dir, options) => {
  checkPath$1(dir);
  return fs$B.mkdir(dir, {
    mode: getMode$1(options),
    recursive: true
  });
};
makeDir$3.makeDirSync = (dir, options) => {
  checkPath$1(dir);
  return fs$B.mkdirSync(dir, {
    mode: getMode$1(options),
    recursive: true
  });
};
const u$l = universalify$1.fromPromise;
const { makeDir: _makeDir$1, makeDirSync: makeDirSync$1 } = makeDir$3;
const makeDir$2 = u$l(_makeDir$1);
var mkdirs$5 = {
  mkdirs: makeDir$2,
  mkdirsSync: makeDirSync$1,
  mkdirp: makeDir$2,
  mkdirpSync: makeDirSync$1,
  ensureDir: makeDir$2,
  ensureDirSync: makeDirSync$1
};
const fs$A = gracefulFs;
function utimesMillis$3(path2, atime, mtime, callback) {
  fs$A.open(path2, "r+", (err, fd) => {
    if (err)
      return callback(err);
    fs$A.futimes(fd, atime, mtime, (futimesErr) => {
      fs$A.close(fd, (closeErr) => {
        if (callback)
          callback(futimesErr || closeErr);
      });
    });
  });
}
function utimesMillisSync$3(path2, atime, mtime) {
  const fd = fs$A.openSync(path2, "r+");
  fs$A.futimesSync(fd, atime, mtime);
  return fs$A.closeSync(fd);
}
var utimes$1 = {
  utimesMillis: utimesMillis$3,
  utimesMillisSync: utimesMillisSync$3
};
const fs$z = fs$D;
const path$B = require$$1__default$2["default"];
const util$3 = require$$2__default$1["default"];
function getStats$5(src, dest, opts2) {
  const statFunc = opts2.dereference ? (file2) => fs$z.stat(file2, { bigint: true }) : (file2) => fs$z.lstat(file2, { bigint: true });
  return Promise.all([
    statFunc(src),
    statFunc(dest).catch((err) => {
      if (err.code === "ENOENT")
        return null;
      throw err;
    })
  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
}
function getStatsSync$1(src, dest, opts2) {
  let destStat;
  const statFunc = opts2.dereference ? (file2) => fs$z.statSync(file2, { bigint: true }) : (file2) => fs$z.lstatSync(file2, { bigint: true });
  const srcStat = statFunc(src);
  try {
    destStat = statFunc(dest);
  } catch (err) {
    if (err.code === "ENOENT")
      return { srcStat, destStat: null };
    throw err;
  }
  return { srcStat, destStat };
}
function checkPaths$1(src, dest, funcName, opts2, cb) {
  util$3.callbackify(getStats$5)(src, dest, opts2, (err, stats) => {
    if (err)
      return cb(err);
    const { srcStat, destStat } = stats;
    if (destStat) {
      if (areIdentical$5(srcStat, destStat)) {
        const srcBaseName = path$B.basename(src);
        const destBaseName = path$B.basename(dest);
        if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
          return cb(null, { srcStat, destStat, isChangingCase: true });
        }
        return cb(new Error("Source and destination must not be the same."));
      }
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
      }
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`));
      }
    }
    if (srcStat.isDirectory() && isSrcSubdir$1(src, dest)) {
      return cb(new Error(errMsg$1(src, dest, funcName)));
    }
    return cb(null, { srcStat, destStat });
  });
}
function checkPathsSync$1(src, dest, funcName, opts2) {
  const { srcStat, destStat } = getStatsSync$1(src, dest, opts2);
  if (destStat) {
    if (areIdentical$5(srcStat, destStat)) {
      const srcBaseName = path$B.basename(src);
      const destBaseName = path$B.basename(dest);
      if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
        return { srcStat, destStat, isChangingCase: true };
      }
      throw new Error("Source and destination must not be the same.");
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
    }
  }
  if (srcStat.isDirectory() && isSrcSubdir$1(src, dest)) {
    throw new Error(errMsg$1(src, dest, funcName));
  }
  return { srcStat, destStat };
}
function checkParentPaths$1(src, srcStat, dest, funcName, cb) {
  const srcParent = path$B.resolve(path$B.dirname(src));
  const destParent = path$B.resolve(path$B.dirname(dest));
  if (destParent === srcParent || destParent === path$B.parse(destParent).root)
    return cb();
  fs$z.stat(destParent, { bigint: true }, (err, destStat) => {
    if (err) {
      if (err.code === "ENOENT")
        return cb();
      return cb(err);
    }
    if (areIdentical$5(srcStat, destStat)) {
      return cb(new Error(errMsg$1(src, dest, funcName)));
    }
    return checkParentPaths$1(src, srcStat, destParent, funcName, cb);
  });
}
function checkParentPathsSync$1(src, srcStat, dest, funcName) {
  const srcParent = path$B.resolve(path$B.dirname(src));
  const destParent = path$B.resolve(path$B.dirname(dest));
  if (destParent === srcParent || destParent === path$B.parse(destParent).root)
    return;
  let destStat;
  try {
    destStat = fs$z.statSync(destParent, { bigint: true });
  } catch (err) {
    if (err.code === "ENOENT")
      return;
    throw err;
  }
  if (areIdentical$5(srcStat, destStat)) {
    throw new Error(errMsg$1(src, dest, funcName));
  }
  return checkParentPathsSync$1(src, srcStat, destParent, funcName);
}
function areIdentical$5(srcStat, destStat) {
  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
}
function isSrcSubdir$1(src, dest) {
  const srcArr = path$B.resolve(src).split(path$B.sep).filter((i2) => i2);
  const destArr = path$B.resolve(dest).split(path$B.sep).filter((i2) => i2);
  return srcArr.reduce((acc, cur, i2) => acc && destArr[i2] === cur, true);
}
function errMsg$1(src, dest, funcName) {
  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
}
var stat$9 = {
  checkPaths: checkPaths$1,
  checkPathsSync: checkPathsSync$1,
  checkParentPaths: checkParentPaths$1,
  checkParentPathsSync: checkParentPathsSync$1,
  isSrcSubdir: isSrcSubdir$1,
  areIdentical: areIdentical$5
};
const fs$y = gracefulFs;
const path$A = require$$1__default$2["default"];
const mkdirsSync$3 = mkdirs$5.mkdirsSync;
const utimesMillisSync$2 = utimes$1.utimesMillisSync;
const stat$8 = stat$9;
function copySync$4(src, dest, opts2) {
  if (typeof opts2 === "function") {
    opts2 = { filter: opts2 };
  }
  opts2 = opts2 || {};
  opts2.clobber = "clobber" in opts2 ? !!opts2.clobber : true;
  opts2.overwrite = "overwrite" in opts2 ? !!opts2.overwrite : opts2.clobber;
  if (opts2.preserveTimestamps && process.arch === "ia32") {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
  }
  const { srcStat, destStat } = stat$8.checkPathsSync(src, dest, "copy", opts2);
  stat$8.checkParentPathsSync(src, srcStat, dest, "copy");
  return handleFilterAndCopy$1(destStat, src, dest, opts2);
}
function handleFilterAndCopy$1(destStat, src, dest, opts2) {
  if (opts2.filter && !opts2.filter(src, dest))
    return;
  const destParent = path$A.dirname(dest);
  if (!fs$y.existsSync(destParent))
    mkdirsSync$3(destParent);
  return getStats$4(destStat, src, dest, opts2);
}
function startCopy$3(destStat, src, dest, opts2) {
  if (opts2.filter && !opts2.filter(src, dest))
    return;
  return getStats$4(destStat, src, dest, opts2);
}
function getStats$4(destStat, src, dest, opts2) {
  const statSync = opts2.dereference ? fs$y.statSync : fs$y.lstatSync;
  const srcStat = statSync(src);
  if (srcStat.isDirectory())
    return onDir$3(srcStat, destStat, src, dest, opts2);
  else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
    return onFile$3(srcStat, destStat, src, dest, opts2);
  else if (srcStat.isSymbolicLink())
    return onLink$3(destStat, src, dest, opts2);
  else if (srcStat.isSocket())
    throw new Error(`Cannot copy a socket file: ${src}`);
  else if (srcStat.isFIFO())
    throw new Error(`Cannot copy a FIFO pipe: ${src}`);
  throw new Error(`Unknown file: ${src}`);
}
function onFile$3(srcStat, destStat, src, dest, opts2) {
  if (!destStat)
    return copyFile$3(srcStat, src, dest, opts2);
  return mayCopyFile$3(srcStat, src, dest, opts2);
}
function mayCopyFile$3(srcStat, src, dest, opts2) {
  if (opts2.overwrite) {
    fs$y.unlinkSync(dest);
    return copyFile$3(srcStat, src, dest, opts2);
  } else if (opts2.errorOnExist) {
    throw new Error(`'${dest}' already exists`);
  }
}
function copyFile$3(srcStat, src, dest, opts2) {
  fs$y.copyFileSync(src, dest);
  if (opts2.preserveTimestamps)
    handleTimestamps$1(srcStat.mode, src, dest);
  return setDestMode$3(dest, srcStat.mode);
}
function handleTimestamps$1(srcMode, src, dest) {
  if (fileIsNotWritable$3(srcMode))
    makeFileWritable$3(dest, srcMode);
  return setDestTimestamps$3(src, dest);
}
function fileIsNotWritable$3(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable$3(dest, srcMode) {
  return setDestMode$3(dest, srcMode | 128);
}
function setDestMode$3(dest, srcMode) {
  return fs$y.chmodSync(dest, srcMode);
}
function setDestTimestamps$3(src, dest) {
  const updatedSrcStat = fs$y.statSync(src);
  return utimesMillisSync$2(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
}
function onDir$3(srcStat, destStat, src, dest, opts2) {
  if (!destStat)
    return mkDirAndCopy$3(srcStat.mode, src, dest, opts2);
  return copyDir$3(src, dest, opts2);
}
function mkDirAndCopy$3(srcMode, src, dest, opts2) {
  fs$y.mkdirSync(dest);
  copyDir$3(src, dest, opts2);
  return setDestMode$3(dest, srcMode);
}
function copyDir$3(src, dest, opts2) {
  fs$y.readdirSync(src).forEach((item) => copyDirItem$3(item, src, dest, opts2));
}
function copyDirItem$3(item, src, dest, opts2) {
  const srcItem = path$A.join(src, item);
  const destItem = path$A.join(dest, item);
  const { destStat } = stat$8.checkPathsSync(srcItem, destItem, "copy", opts2);
  return startCopy$3(destStat, srcItem, destItem, opts2);
}
function onLink$3(destStat, src, dest, opts2) {
  let resolvedSrc = fs$y.readlinkSync(src);
  if (opts2.dereference) {
    resolvedSrc = path$A.resolve(process.cwd(), resolvedSrc);
  }
  if (!destStat) {
    return fs$y.symlinkSync(resolvedSrc, dest);
  } else {
    let resolvedDest;
    try {
      resolvedDest = fs$y.readlinkSync(dest);
    } catch (err) {
      if (err.code === "EINVAL" || err.code === "UNKNOWN")
        return fs$y.symlinkSync(resolvedSrc, dest);
      throw err;
    }
    if (opts2.dereference) {
      resolvedDest = path$A.resolve(process.cwd(), resolvedDest);
    }
    if (stat$8.isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
    }
    if (fs$y.statSync(dest).isDirectory() && stat$8.isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
    }
    return copyLink$3(resolvedSrc, dest);
  }
}
function copyLink$3(resolvedSrc, dest) {
  fs$y.unlinkSync(dest);
  return fs$y.symlinkSync(resolvedSrc, dest);
}
var copySync_1$1 = copySync$4;
var copySync$3 = {
  copySync: copySync_1$1
};
const u$k = universalify$1.fromPromise;
const fs$x = fs$D;
function pathExists$f(path2) {
  return fs$x.access(path2).then(() => true).catch(() => false);
}
var pathExists_1$1 = {
  pathExists: u$k(pathExists$f),
  pathExistsSync: fs$x.existsSync
};
const fs$w = gracefulFs;
const path$z = require$$1__default$2["default"];
const mkdirs$4 = mkdirs$5.mkdirs;
const pathExists$e = pathExists_1$1.pathExists;
const utimesMillis$2 = utimes$1.utimesMillis;
const stat$7 = stat$9;
function copy$5(src, dest, opts2, cb) {
  if (typeof opts2 === "function" && !cb) {
    cb = opts2;
    opts2 = {};
  } else if (typeof opts2 === "function") {
    opts2 = { filter: opts2 };
  }
  cb = cb || function() {
  };
  opts2 = opts2 || {};
  opts2.clobber = "clobber" in opts2 ? !!opts2.clobber : true;
  opts2.overwrite = "overwrite" in opts2 ? !!opts2.overwrite : opts2.clobber;
  if (opts2.preserveTimestamps && process.arch === "ia32") {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
  }
  stat$7.checkPaths(src, dest, "copy", opts2, (err, stats) => {
    if (err)
      return cb(err);
    const { srcStat, destStat } = stats;
    stat$7.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
      if (err2)
        return cb(err2);
      if (opts2.filter)
        return handleFilter$1(checkParentDir$1, destStat, src, dest, opts2, cb);
      return checkParentDir$1(destStat, src, dest, opts2, cb);
    });
  });
}
function checkParentDir$1(destStat, src, dest, opts2, cb) {
  const destParent = path$z.dirname(dest);
  pathExists$e(destParent, (err, dirExists) => {
    if (err)
      return cb(err);
    if (dirExists)
      return getStats$3(destStat, src, dest, opts2, cb);
    mkdirs$4(destParent, (err2) => {
      if (err2)
        return cb(err2);
      return getStats$3(destStat, src, dest, opts2, cb);
    });
  });
}
function handleFilter$1(onInclude, destStat, src, dest, opts2, cb) {
  Promise.resolve(opts2.filter(src, dest)).then((include) => {
    if (include)
      return onInclude(destStat, src, dest, opts2, cb);
    return cb();
  }, (error2) => cb(error2));
}
function startCopy$2(destStat, src, dest, opts2, cb) {
  if (opts2.filter)
    return handleFilter$1(getStats$3, destStat, src, dest, opts2, cb);
  return getStats$3(destStat, src, dest, opts2, cb);
}
function getStats$3(destStat, src, dest, opts2, cb) {
  const stat2 = opts2.dereference ? fs$w.stat : fs$w.lstat;
  stat2(src, (err, srcStat) => {
    if (err)
      return cb(err);
    if (srcStat.isDirectory())
      return onDir$2(srcStat, destStat, src, dest, opts2, cb);
    else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
      return onFile$2(srcStat, destStat, src, dest, opts2, cb);
    else if (srcStat.isSymbolicLink())
      return onLink$2(destStat, src, dest, opts2, cb);
    else if (srcStat.isSocket())
      return cb(new Error(`Cannot copy a socket file: ${src}`));
    else if (srcStat.isFIFO())
      return cb(new Error(`Cannot copy a FIFO pipe: ${src}`));
    return cb(new Error(`Unknown file: ${src}`));
  });
}
function onFile$2(srcStat, destStat, src, dest, opts2, cb) {
  if (!destStat)
    return copyFile$2(srcStat, src, dest, opts2, cb);
  return mayCopyFile$2(srcStat, src, dest, opts2, cb);
}
function mayCopyFile$2(srcStat, src, dest, opts2, cb) {
  if (opts2.overwrite) {
    fs$w.unlink(dest, (err) => {
      if (err)
        return cb(err);
      return copyFile$2(srcStat, src, dest, opts2, cb);
    });
  } else if (opts2.errorOnExist) {
    return cb(new Error(`'${dest}' already exists`));
  } else
    return cb();
}
function copyFile$2(srcStat, src, dest, opts2, cb) {
  fs$w.copyFile(src, dest, (err) => {
    if (err)
      return cb(err);
    if (opts2.preserveTimestamps)
      return handleTimestampsAndMode$1(srcStat.mode, src, dest, cb);
    return setDestMode$2(dest, srcStat.mode, cb);
  });
}
function handleTimestampsAndMode$1(srcMode, src, dest, cb) {
  if (fileIsNotWritable$2(srcMode)) {
    return makeFileWritable$2(dest, srcMode, (err) => {
      if (err)
        return cb(err);
      return setDestTimestampsAndMode$1(srcMode, src, dest, cb);
    });
  }
  return setDestTimestampsAndMode$1(srcMode, src, dest, cb);
}
function fileIsNotWritable$2(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable$2(dest, srcMode, cb) {
  return setDestMode$2(dest, srcMode | 128, cb);
}
function setDestTimestampsAndMode$1(srcMode, src, dest, cb) {
  setDestTimestamps$2(src, dest, (err) => {
    if (err)
      return cb(err);
    return setDestMode$2(dest, srcMode, cb);
  });
}
function setDestMode$2(dest, srcMode, cb) {
  return fs$w.chmod(dest, srcMode, cb);
}
function setDestTimestamps$2(src, dest, cb) {
  fs$w.stat(src, (err, updatedSrcStat) => {
    if (err)
      return cb(err);
    return utimesMillis$2(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
  });
}
function onDir$2(srcStat, destStat, src, dest, opts2, cb) {
  if (!destStat)
    return mkDirAndCopy$2(srcStat.mode, src, dest, opts2, cb);
  return copyDir$2(src, dest, opts2, cb);
}
function mkDirAndCopy$2(srcMode, src, dest, opts2, cb) {
  fs$w.mkdir(dest, (err) => {
    if (err)
      return cb(err);
    copyDir$2(src, dest, opts2, (err2) => {
      if (err2)
        return cb(err2);
      return setDestMode$2(dest, srcMode, cb);
    });
  });
}
function copyDir$2(src, dest, opts2, cb) {
  fs$w.readdir(src, (err, items2) => {
    if (err)
      return cb(err);
    return copyDirItems$1(items2, src, dest, opts2, cb);
  });
}
function copyDirItems$1(items2, src, dest, opts2, cb) {
  const item = items2.pop();
  if (!item)
    return cb();
  return copyDirItem$2(items2, item, src, dest, opts2, cb);
}
function copyDirItem$2(items2, item, src, dest, opts2, cb) {
  const srcItem = path$z.join(src, item);
  const destItem = path$z.join(dest, item);
  stat$7.checkPaths(srcItem, destItem, "copy", opts2, (err, stats) => {
    if (err)
      return cb(err);
    const { destStat } = stats;
    startCopy$2(destStat, srcItem, destItem, opts2, (err2) => {
      if (err2)
        return cb(err2);
      return copyDirItems$1(items2, src, dest, opts2, cb);
    });
  });
}
function onLink$2(destStat, src, dest, opts2, cb) {
  fs$w.readlink(src, (err, resolvedSrc) => {
    if (err)
      return cb(err);
    if (opts2.dereference) {
      resolvedSrc = path$z.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
      return fs$w.symlink(resolvedSrc, dest, cb);
    } else {
      fs$w.readlink(dest, (err2, resolvedDest) => {
        if (err2) {
          if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
            return fs$w.symlink(resolvedSrc, dest, cb);
          return cb(err2);
        }
        if (opts2.dereference) {
          resolvedDest = path$z.resolve(process.cwd(), resolvedDest);
        }
        if (stat$7.isSrcSubdir(resolvedSrc, resolvedDest)) {
          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
        }
        if (destStat.isDirectory() && stat$7.isSrcSubdir(resolvedDest, resolvedSrc)) {
          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
        }
        return copyLink$2(resolvedSrc, dest, cb);
      });
    }
  });
}
function copyLink$2(resolvedSrc, dest, cb) {
  fs$w.unlink(dest, (err) => {
    if (err)
      return cb(err);
    return fs$w.symlink(resolvedSrc, dest, cb);
  });
}
var copy_1$1 = copy$5;
const u$j = universalify$1.fromCallback;
var copy$4 = {
  copy: u$j(copy_1$1)
};
const fs$v = gracefulFs;
const path$y = require$$1__default$2["default"];
const assert$1 = require$$2__default["default"];
const isWindows$1 = process.platform === "win32";
function defaults$2(options) {
  const methods = [
    "unlink",
    "chmod",
    "stat",
    "lstat",
    "rmdir",
    "readdir"
  ];
  methods.forEach((m2) => {
    options[m2] = options[m2] || fs$v[m2];
    m2 = m2 + "Sync";
    options[m2] = options[m2] || fs$v[m2];
  });
  options.maxBusyTries = options.maxBusyTries || 3;
}
function rimraf$3(p, options, cb) {
  let busyTries = 0;
  if (typeof options === "function") {
    cb = options;
    options = {};
  }
  assert$1(p, "rimraf: missing path");
  assert$1.strictEqual(typeof p, "string", "rimraf: path should be a string");
  assert$1.strictEqual(typeof cb, "function", "rimraf: callback function required");
  assert$1(options, "rimraf: invalid options argument provided");
  assert$1.strictEqual(typeof options, "object", "rimraf: options should be object");
  defaults$2(options);
  rimraf_$1(p, options, function CB(er) {
    if (er) {
      if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
        busyTries++;
        const time = busyTries * 100;
        return setTimeout(() => rimraf_$1(p, options, CB), time);
      }
      if (er.code === "ENOENT")
        er = null;
    }
    cb(er);
  });
}
function rimraf_$1(p, options, cb) {
  assert$1(p);
  assert$1(options);
  assert$1(typeof cb === "function");
  options.lstat(p, (er, st) => {
    if (er && er.code === "ENOENT") {
      return cb(null);
    }
    if (er && er.code === "EPERM" && isWindows$1) {
      return fixWinEPERM$1(p, options, er, cb);
    }
    if (st && st.isDirectory()) {
      return rmdir$1(p, options, er, cb);
    }
    options.unlink(p, (er2) => {
      if (er2) {
        if (er2.code === "ENOENT") {
          return cb(null);
        }
        if (er2.code === "EPERM") {
          return isWindows$1 ? fixWinEPERM$1(p, options, er2, cb) : rmdir$1(p, options, er2, cb);
        }
        if (er2.code === "EISDIR") {
          return rmdir$1(p, options, er2, cb);
        }
      }
      return cb(er2);
    });
  });
}
function fixWinEPERM$1(p, options, er, cb) {
  assert$1(p);
  assert$1(options);
  assert$1(typeof cb === "function");
  options.chmod(p, 438, (er2) => {
    if (er2) {
      cb(er2.code === "ENOENT" ? null : er);
    } else {
      options.stat(p, (er3, stats) => {
        if (er3) {
          cb(er3.code === "ENOENT" ? null : er);
        } else if (stats.isDirectory()) {
          rmdir$1(p, options, er, cb);
        } else {
          options.unlink(p, cb);
        }
      });
    }
  });
}
function fixWinEPERMSync$1(p, options, er) {
  let stats;
  assert$1(p);
  assert$1(options);
  try {
    options.chmodSync(p, 438);
  } catch (er2) {
    if (er2.code === "ENOENT") {
      return;
    } else {
      throw er;
    }
  }
  try {
    stats = options.statSync(p);
  } catch (er3) {
    if (er3.code === "ENOENT") {
      return;
    } else {
      throw er;
    }
  }
  if (stats.isDirectory()) {
    rmdirSync$1(p, options, er);
  } else {
    options.unlinkSync(p);
  }
}
function rmdir$1(p, options, originalEr, cb) {
  assert$1(p);
  assert$1(options);
  assert$1(typeof cb === "function");
  options.rmdir(p, (er) => {
    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
      rmkids$1(p, options, cb);
    } else if (er && er.code === "ENOTDIR") {
      cb(originalEr);
    } else {
      cb(er);
    }
  });
}
function rmkids$1(p, options, cb) {
  assert$1(p);
  assert$1(options);
  assert$1(typeof cb === "function");
  options.readdir(p, (er, files) => {
    if (er)
      return cb(er);
    let n = files.length;
    let errState;
    if (n === 0)
      return options.rmdir(p, cb);
    files.forEach((f) => {
      rimraf$3(path$y.join(p, f), options, (er2) => {
        if (errState) {
          return;
        }
        if (er2)
          return cb(errState = er2);
        if (--n === 0) {
          options.rmdir(p, cb);
        }
      });
    });
  });
}
function rimrafSync$1(p, options) {
  let st;
  options = options || {};
  defaults$2(options);
  assert$1(p, "rimraf: missing path");
  assert$1.strictEqual(typeof p, "string", "rimraf: path should be a string");
  assert$1(options, "rimraf: missing options");
  assert$1.strictEqual(typeof options, "object", "rimraf: options should be object");
  try {
    st = options.lstatSync(p);
  } catch (er) {
    if (er.code === "ENOENT") {
      return;
    }
    if (er.code === "EPERM" && isWindows$1) {
      fixWinEPERMSync$1(p, options, er);
    }
  }
  try {
    if (st && st.isDirectory()) {
      rmdirSync$1(p, options, null);
    } else {
      options.unlinkSync(p);
    }
  } catch (er) {
    if (er.code === "ENOENT") {
      return;
    } else if (er.code === "EPERM") {
      return isWindows$1 ? fixWinEPERMSync$1(p, options, er) : rmdirSync$1(p, options, er);
    } else if (er.code !== "EISDIR") {
      throw er;
    }
    rmdirSync$1(p, options, er);
  }
}
function rmdirSync$1(p, options, originalEr) {
  assert$1(p);
  assert$1(options);
  try {
    options.rmdirSync(p);
  } catch (er) {
    if (er.code === "ENOTDIR") {
      throw originalEr;
    } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
      rmkidsSync$1(p, options);
    } else if (er.code !== "ENOENT") {
      throw er;
    }
  }
}
function rmkidsSync$1(p, options) {
  assert$1(p);
  assert$1(options);
  options.readdirSync(p).forEach((f) => rimrafSync$1(path$y.join(p, f), options));
  if (isWindows$1) {
    const startTime = Date.now();
    do {
      try {
        const ret = options.rmdirSync(p, options);
        return ret;
      } catch {
      }
    } while (Date.now() - startTime < 500);
  } else {
    const ret = options.rmdirSync(p, options);
    return ret;
  }
}
var rimraf_1$1 = rimraf$3;
rimraf$3.sync = rimrafSync$1;
const fs$u = gracefulFs;
const u$i = universalify$1.fromCallback;
const rimraf$2 = rimraf_1$1;
function remove$5(path2, callback) {
  if (fs$u.rm)
    return fs$u.rm(path2, { recursive: true, force: true }, callback);
  rimraf$2(path2, callback);
}
function removeSync$3(path2) {
  if (fs$u.rmSync)
    return fs$u.rmSync(path2, { recursive: true, force: true });
  rimraf$2.sync(path2);
}
var remove_1$1 = {
  remove: u$i(remove$5),
  removeSync: removeSync$3
};
const u$h = universalify$1.fromPromise;
const fs$t = fs$D;
const path$x = require$$1__default$2["default"];
const mkdir$7 = mkdirs$5;
const remove$4 = remove_1$1;
const emptyDir$1 = u$h(async function emptyDir2(dir) {
  let items2;
  try {
    items2 = await fs$t.readdir(dir);
  } catch {
    return mkdir$7.mkdirs(dir);
  }
  return Promise.all(items2.map((item) => remove$4.remove(path$x.join(dir, item))));
});
function emptyDirSync$1(dir) {
  let items2;
  try {
    items2 = fs$t.readdirSync(dir);
  } catch {
    return mkdir$7.mkdirsSync(dir);
  }
  items2.forEach((item) => {
    item = path$x.join(dir, item);
    remove$4.removeSync(item);
  });
}
var empty$1 = {
  emptyDirSync: emptyDirSync$1,
  emptydirSync: emptyDirSync$1,
  emptyDir: emptyDir$1,
  emptydir: emptyDir$1
};
const u$g = universalify$1.fromCallback;
const path$w = require$$1__default$2["default"];
const fs$s = gracefulFs;
const mkdir$6 = mkdirs$5;
function createFile$2(file2, callback) {
  function makeFile() {
    fs$s.writeFile(file2, "", (err) => {
      if (err)
        return callback(err);
      callback();
    });
  }
  fs$s.stat(file2, (err, stats) => {
    if (!err && stats.isFile())
      return callback();
    const dir = path$w.dirname(file2);
    fs$s.stat(dir, (err2, stats2) => {
      if (err2) {
        if (err2.code === "ENOENT") {
          return mkdir$6.mkdirs(dir, (err3) => {
            if (err3)
              return callback(err3);
            makeFile();
          });
        }
        return callback(err2);
      }
      if (stats2.isDirectory())
        makeFile();
      else {
        fs$s.readdir(dir, (err3) => {
          if (err3)
            return callback(err3);
        });
      }
    });
  });
}
function createFileSync$2(file2) {
  let stats;
  try {
    stats = fs$s.statSync(file2);
  } catch {
  }
  if (stats && stats.isFile())
    return;
  const dir = path$w.dirname(file2);
  try {
    if (!fs$s.statSync(dir).isDirectory()) {
      fs$s.readdirSync(dir);
    }
  } catch (err) {
    if (err && err.code === "ENOENT")
      mkdir$6.mkdirsSync(dir);
    else
      throw err;
  }
  fs$s.writeFileSync(file2, "");
}
var file$2 = {
  createFile: u$g(createFile$2),
  createFileSync: createFileSync$2
};
const u$f = universalify$1.fromCallback;
const path$v = require$$1__default$2["default"];
const fs$r = gracefulFs;
const mkdir$5 = mkdirs$5;
const pathExists$d = pathExists_1$1.pathExists;
const { areIdentical: areIdentical$4 } = stat$9;
function createLink$2(srcpath, dstpath, callback) {
  function makeLink(srcpath2, dstpath2) {
    fs$r.link(srcpath2, dstpath2, (err) => {
      if (err)
        return callback(err);
      callback(null);
    });
  }
  fs$r.lstat(dstpath, (_, dstStat) => {
    fs$r.lstat(srcpath, (err, srcStat) => {
      if (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        return callback(err);
      }
      if (dstStat && areIdentical$4(srcStat, dstStat))
        return callback(null);
      const dir = path$v.dirname(dstpath);
      pathExists$d(dir, (err2, dirExists) => {
        if (err2)
          return callback(err2);
        if (dirExists)
          return makeLink(srcpath, dstpath);
        mkdir$5.mkdirs(dir, (err3) => {
          if (err3)
            return callback(err3);
          makeLink(srcpath, dstpath);
        });
      });
    });
  });
}
function createLinkSync$2(srcpath, dstpath) {
  let dstStat;
  try {
    dstStat = fs$r.lstatSync(dstpath);
  } catch {
  }
  try {
    const srcStat = fs$r.lstatSync(srcpath);
    if (dstStat && areIdentical$4(srcStat, dstStat))
      return;
  } catch (err) {
    err.message = err.message.replace("lstat", "ensureLink");
    throw err;
  }
  const dir = path$v.dirname(dstpath);
  const dirExists = fs$r.existsSync(dir);
  if (dirExists)
    return fs$r.linkSync(srcpath, dstpath);
  mkdir$5.mkdirsSync(dir);
  return fs$r.linkSync(srcpath, dstpath);
}
var link$2 = {
  createLink: u$f(createLink$2),
  createLinkSync: createLinkSync$2
};
const path$u = require$$1__default$2["default"];
const fs$q = gracefulFs;
const pathExists$c = pathExists_1$1.pathExists;
function symlinkPaths$3(srcpath, dstpath, callback) {
  if (path$u.isAbsolute(srcpath)) {
    return fs$q.lstat(srcpath, (err) => {
      if (err) {
        err.message = err.message.replace("lstat", "ensureSymlink");
        return callback(err);
      }
      return callback(null, {
        toCwd: srcpath,
        toDst: srcpath
      });
    });
  } else {
    const dstdir = path$u.dirname(dstpath);
    const relativeToDst = path$u.join(dstdir, srcpath);
    return pathExists$c(relativeToDst, (err, exists) => {
      if (err)
        return callback(err);
      if (exists) {
        return callback(null, {
          toCwd: relativeToDst,
          toDst: srcpath
        });
      } else {
        return fs$q.lstat(srcpath, (err2) => {
          if (err2) {
            err2.message = err2.message.replace("lstat", "ensureSymlink");
            return callback(err2);
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: path$u.relative(dstdir, srcpath)
          });
        });
      }
    });
  }
}
function symlinkPathsSync$3(srcpath, dstpath) {
  let exists;
  if (path$u.isAbsolute(srcpath)) {
    exists = fs$q.existsSync(srcpath);
    if (!exists)
      throw new Error("absolute srcpath does not exist");
    return {
      toCwd: srcpath,
      toDst: srcpath
    };
  } else {
    const dstdir = path$u.dirname(dstpath);
    const relativeToDst = path$u.join(dstdir, srcpath);
    exists = fs$q.existsSync(relativeToDst);
    if (exists) {
      return {
        toCwd: relativeToDst,
        toDst: srcpath
      };
    } else {
      exists = fs$q.existsSync(srcpath);
      if (!exists)
        throw new Error("relative srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: path$u.relative(dstdir, srcpath)
      };
    }
  }
}
var symlinkPaths_1$1 = {
  symlinkPaths: symlinkPaths$3,
  symlinkPathsSync: symlinkPathsSync$3
};
const fs$p = gracefulFs;
function symlinkType$3(srcpath, type2, callback) {
  callback = typeof type2 === "function" ? type2 : callback;
  type2 = typeof type2 === "function" ? false : type2;
  if (type2)
    return callback(null, type2);
  fs$p.lstat(srcpath, (err, stats) => {
    if (err)
      return callback(null, "file");
    type2 = stats && stats.isDirectory() ? "dir" : "file";
    callback(null, type2);
  });
}
function symlinkTypeSync$3(srcpath, type2) {
  let stats;
  if (type2)
    return type2;
  try {
    stats = fs$p.lstatSync(srcpath);
  } catch {
    return "file";
  }
  return stats && stats.isDirectory() ? "dir" : "file";
}
var symlinkType_1$1 = {
  symlinkType: symlinkType$3,
  symlinkTypeSync: symlinkTypeSync$3
};
const u$e = universalify$1.fromCallback;
const path$t = require$$1__default$2["default"];
const fs$o = fs$D;
const _mkdirs$1 = mkdirs$5;
const mkdirs$3 = _mkdirs$1.mkdirs;
const mkdirsSync$2 = _mkdirs$1.mkdirsSync;
const _symlinkPaths$1 = symlinkPaths_1$1;
const symlinkPaths$2 = _symlinkPaths$1.symlinkPaths;
const symlinkPathsSync$2 = _symlinkPaths$1.symlinkPathsSync;
const _symlinkType$1 = symlinkType_1$1;
const symlinkType$2 = _symlinkType$1.symlinkType;
const symlinkTypeSync$2 = _symlinkType$1.symlinkTypeSync;
const pathExists$b = pathExists_1$1.pathExists;
const { areIdentical: areIdentical$3 } = stat$9;
function createSymlink$2(srcpath, dstpath, type2, callback) {
  callback = typeof type2 === "function" ? type2 : callback;
  type2 = typeof type2 === "function" ? false : type2;
  fs$o.lstat(dstpath, (err, stats) => {
    if (!err && stats.isSymbolicLink()) {
      Promise.all([
        fs$o.stat(srcpath),
        fs$o.stat(dstpath)
      ]).then(([srcStat, dstStat]) => {
        if (areIdentical$3(srcStat, dstStat))
          return callback(null);
        _createSymlink$1(srcpath, dstpath, type2, callback);
      });
    } else
      _createSymlink$1(srcpath, dstpath, type2, callback);
  });
}
function _createSymlink$1(srcpath, dstpath, type2, callback) {
  symlinkPaths$2(srcpath, dstpath, (err, relative) => {
    if (err)
      return callback(err);
    srcpath = relative.toDst;
    symlinkType$2(relative.toCwd, type2, (err2, type3) => {
      if (err2)
        return callback(err2);
      const dir = path$t.dirname(dstpath);
      pathExists$b(dir, (err3, dirExists) => {
        if (err3)
          return callback(err3);
        if (dirExists)
          return fs$o.symlink(srcpath, dstpath, type3, callback);
        mkdirs$3(dir, (err4) => {
          if (err4)
            return callback(err4);
          fs$o.symlink(srcpath, dstpath, type3, callback);
        });
      });
    });
  });
}
function createSymlinkSync$2(srcpath, dstpath, type2) {
  let stats;
  try {
    stats = fs$o.lstatSync(dstpath);
  } catch {
  }
  if (stats && stats.isSymbolicLink()) {
    const srcStat = fs$o.statSync(srcpath);
    const dstStat = fs$o.statSync(dstpath);
    if (areIdentical$3(srcStat, dstStat))
      return;
  }
  const relative = symlinkPathsSync$2(srcpath, dstpath);
  srcpath = relative.toDst;
  type2 = symlinkTypeSync$2(relative.toCwd, type2);
  const dir = path$t.dirname(dstpath);
  const exists = fs$o.existsSync(dir);
  if (exists)
    return fs$o.symlinkSync(srcpath, dstpath, type2);
  mkdirsSync$2(dir);
  return fs$o.symlinkSync(srcpath, dstpath, type2);
}
var symlink$2 = {
  createSymlink: u$e(createSymlink$2),
  createSymlinkSync: createSymlinkSync$2
};
const file$1 = file$2;
const link$1 = link$2;
const symlink$1 = symlink$2;
var ensure$1 = {
  createFile: file$1.createFile,
  createFileSync: file$1.createFileSync,
  ensureFile: file$1.createFile,
  ensureFileSync: file$1.createFileSync,
  createLink: link$1.createLink,
  createLinkSync: link$1.createLinkSync,
  ensureLink: link$1.createLink,
  ensureLinkSync: link$1.createLinkSync,
  createSymlink: symlink$1.createSymlink,
  createSymlinkSync: symlink$1.createSymlinkSync,
  ensureSymlink: symlink$1.createSymlink,
  ensureSymlinkSync: symlink$1.createSymlinkSync
};
function stringify$6(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
  const EOF = finalEOL ? EOL : "";
  const str2 = JSON.stringify(obj, replacer, spaces);
  return str2.replace(/\n/g, EOL) + EOF;
}
function stripBom$1(content) {
  if (Buffer.isBuffer(content))
    content = content.toString("utf8");
  return content.replace(/^\uFEFF/, "");
}
var utils$1 = { stringify: stringify$6, stripBom: stripBom$1 };
let _fs;
try {
  _fs = gracefulFs;
} catch (_) {
  _fs = require$$1__default$1["default"];
}
const universalify = universalify$1;
const { stringify: stringify$5, stripBom } = utils$1;
async function _readFile(file2, options = {}) {
  if (typeof options === "string") {
    options = { encoding: options };
  }
  const fs2 = options.fs || _fs;
  const shouldThrow = "throws" in options ? options.throws : true;
  let data = await universalify.fromCallback(fs2.readFile)(file2, options);
  data = stripBom(data);
  let obj;
  try {
    obj = JSON.parse(data, options ? options.reviver : null);
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file2}: ${err.message}`;
      throw err;
    } else {
      return null;
    }
  }
  return obj;
}
const readFile$1 = universalify.fromPromise(_readFile);
function readFileSync$1(file2, options = {}) {
  if (typeof options === "string") {
    options = { encoding: options };
  }
  const fs2 = options.fs || _fs;
  const shouldThrow = "throws" in options ? options.throws : true;
  try {
    let content = fs2.readFileSync(file2, options);
    content = stripBom(content);
    return JSON.parse(content, options.reviver);
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file2}: ${err.message}`;
      throw err;
    } else {
      return null;
    }
  }
}
async function _writeFile(file2, obj, options = {}) {
  const fs2 = options.fs || _fs;
  const str2 = stringify$5(obj, options);
  await universalify.fromCallback(fs2.writeFile)(file2, str2, options);
}
const writeFile$1 = universalify.fromPromise(_writeFile);
function writeFileSync$1(file2, obj, options = {}) {
  const fs2 = options.fs || _fs;
  const str2 = stringify$5(obj, options);
  return fs2.writeFileSync(file2, str2, options);
}
const jsonfile$2 = {
  readFile: readFile$1,
  readFileSync: readFileSync$1,
  writeFile: writeFile$1,
  writeFileSync: writeFileSync$1
};
var jsonfile_1 = jsonfile$2;
const jsonFile$3 = jsonfile_1;
var jsonfile$1 = {
  readJson: jsonFile$3.readFile,
  readJsonSync: jsonFile$3.readFileSync,
  writeJson: jsonFile$3.writeFile,
  writeJsonSync: jsonFile$3.writeFileSync
};
const u$d = universalify$1.fromCallback;
const fs$n = gracefulFs;
const path$s = require$$1__default$2["default"];
const mkdir$4 = mkdirs$5;
const pathExists$a = pathExists_1$1.pathExists;
function outputFile$3(file2, data, encoding, callback) {
  if (typeof encoding === "function") {
    callback = encoding;
    encoding = "utf8";
  }
  const dir = path$s.dirname(file2);
  pathExists$a(dir, (err, itDoes) => {
    if (err)
      return callback(err);
    if (itDoes)
      return fs$n.writeFile(file2, data, encoding, callback);
    mkdir$4.mkdirs(dir, (err2) => {
      if (err2)
        return callback(err2);
      fs$n.writeFile(file2, data, encoding, callback);
    });
  });
}
function outputFileSync$3(file2, ...args) {
  const dir = path$s.dirname(file2);
  if (fs$n.existsSync(dir)) {
    return fs$n.writeFileSync(file2, ...args);
  }
  mkdir$4.mkdirsSync(dir);
  fs$n.writeFileSync(file2, ...args);
}
var output = {
  outputFile: u$d(outputFile$3),
  outputFileSync: outputFileSync$3
};
const { stringify: stringify$4 } = utils$1;
const { outputFile: outputFile$2 } = output;
async function outputJson$1(file2, data, options = {}) {
  const str2 = stringify$4(data, options);
  await outputFile$2(file2, str2, options);
}
var outputJson_1$1 = outputJson$1;
const { stringify: stringify$3 } = utils$1;
const { outputFileSync: outputFileSync$2 } = output;
function outputJsonSync$1(file2, data, options) {
  const str2 = stringify$3(data, options);
  outputFileSync$2(file2, str2, options);
}
var outputJsonSync_1$1 = outputJsonSync$1;
const u$c = universalify$1.fromPromise;
const jsonFile$2 = jsonfile$1;
jsonFile$2.outputJson = u$c(outputJson_1$1);
jsonFile$2.outputJsonSync = outputJsonSync_1$1;
jsonFile$2.outputJSON = jsonFile$2.outputJson;
jsonFile$2.outputJSONSync = jsonFile$2.outputJsonSync;
jsonFile$2.writeJSON = jsonFile$2.writeJson;
jsonFile$2.writeJSONSync = jsonFile$2.writeJsonSync;
jsonFile$2.readJSON = jsonFile$2.readJson;
jsonFile$2.readJSONSync = jsonFile$2.readJsonSync;
var json$2 = jsonFile$2;
const fs$m = gracefulFs;
const path$r = require$$1__default$2["default"];
const copySync$2 = copySync$3.copySync;
const removeSync$2 = remove_1$1.removeSync;
const mkdirpSync$1 = mkdirs$5.mkdirpSync;
const stat$6 = stat$9;
function moveSync$2(src, dest, opts2) {
  opts2 = opts2 || {};
  const overwrite = opts2.overwrite || opts2.clobber || false;
  const { srcStat, isChangingCase = false } = stat$6.checkPathsSync(src, dest, "move", opts2);
  stat$6.checkParentPathsSync(src, srcStat, dest, "move");
  if (!isParentRoot$3(dest))
    mkdirpSync$1(path$r.dirname(dest));
  return doRename$3(src, dest, overwrite, isChangingCase);
}
function isParentRoot$3(dest) {
  const parent = path$r.dirname(dest);
  const parsedPath = path$r.parse(parent);
  return parsedPath.root === parent;
}
function doRename$3(src, dest, overwrite, isChangingCase) {
  if (isChangingCase)
    return rename$3(src, dest, overwrite);
  if (overwrite) {
    removeSync$2(dest);
    return rename$3(src, dest, overwrite);
  }
  if (fs$m.existsSync(dest))
    throw new Error("dest already exists.");
  return rename$3(src, dest, overwrite);
}
function rename$3(src, dest, overwrite) {
  try {
    fs$m.renameSync(src, dest);
  } catch (err) {
    if (err.code !== "EXDEV")
      throw err;
    return moveAcrossDevice$3(src, dest, overwrite);
  }
}
function moveAcrossDevice$3(src, dest, overwrite) {
  const opts2 = {
    overwrite,
    errorOnExist: true
  };
  copySync$2(src, dest, opts2);
  return removeSync$2(src);
}
var moveSync_1$1 = moveSync$2;
var moveSync$1 = {
  moveSync: moveSync_1$1
};
const fs$l = gracefulFs;
const path$q = require$$1__default$2["default"];
const copy$3 = copy$4.copy;
const remove$3 = remove_1$1.remove;
const mkdirp$1 = mkdirs$5.mkdirp;
const pathExists$9 = pathExists_1$1.pathExists;
const stat$5 = stat$9;
function move$3(src, dest, opts2, cb) {
  if (typeof opts2 === "function") {
    cb = opts2;
    opts2 = {};
  }
  const overwrite = opts2.overwrite || opts2.clobber || false;
  stat$5.checkPaths(src, dest, "move", opts2, (err, stats) => {
    if (err)
      return cb(err);
    const { srcStat, isChangingCase = false } = stats;
    stat$5.checkParentPaths(src, srcStat, dest, "move", (err2) => {
      if (err2)
        return cb(err2);
      if (isParentRoot$2(dest))
        return doRename$2(src, dest, overwrite, isChangingCase, cb);
      mkdirp$1(path$q.dirname(dest), (err3) => {
        if (err3)
          return cb(err3);
        return doRename$2(src, dest, overwrite, isChangingCase, cb);
      });
    });
  });
}
function isParentRoot$2(dest) {
  const parent = path$q.dirname(dest);
  const parsedPath = path$q.parse(parent);
  return parsedPath.root === parent;
}
function doRename$2(src, dest, overwrite, isChangingCase, cb) {
  if (isChangingCase)
    return rename$2(src, dest, overwrite, cb);
  if (overwrite) {
    return remove$3(dest, (err) => {
      if (err)
        return cb(err);
      return rename$2(src, dest, overwrite, cb);
    });
  }
  pathExists$9(dest, (err, destExists) => {
    if (err)
      return cb(err);
    if (destExists)
      return cb(new Error("dest already exists."));
    return rename$2(src, dest, overwrite, cb);
  });
}
function rename$2(src, dest, overwrite, cb) {
  fs$l.rename(src, dest, (err) => {
    if (!err)
      return cb();
    if (err.code !== "EXDEV")
      return cb(err);
    return moveAcrossDevice$2(src, dest, overwrite, cb);
  });
}
function moveAcrossDevice$2(src, dest, overwrite, cb) {
  const opts2 = {
    overwrite,
    errorOnExist: true
  };
  copy$3(src, dest, opts2, (err) => {
    if (err)
      return cb(err);
    return remove$3(src, cb);
  });
}
var move_1$1 = move$3;
const u$b = universalify$1.fromCallback;
var move$2 = {
  move: u$b(move_1$1)
};
var lib$1 = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, fs$D), copySync$3), copy$4), empty$1), ensure$1), json$2), mkdirs$5), moveSync$1), move$2), output), pathExists_1$1), remove_1$1);
var main$1 = {};
var out = {};
var CancellationToken$1 = {};
Object.defineProperty(CancellationToken$1, "__esModule", { value: true });
CancellationToken$1.CancellationError = CancellationToken$1.CancellationToken = void 0;
const events_1$1 = require$$0__default$2["default"];
class CancellationToken extends events_1$1.EventEmitter {
  constructor(parent) {
    super();
    this.parentCancelHandler = null;
    this._parent = null;
    this._cancelled = false;
    if (parent != null) {
      this.parent = parent;
    }
  }
  get cancelled() {
    return this._cancelled || this._parent != null && this._parent.cancelled;
  }
  set parent(value) {
    this.removeParentCancelHandler();
    this._parent = value;
    this.parentCancelHandler = () => this.cancel();
    this._parent.onCancel(this.parentCancelHandler);
  }
  cancel() {
    this._cancelled = true;
    this.emit("cancel");
  }
  onCancel(handler) {
    if (this.cancelled) {
      handler();
    } else {
      this.once("cancel", handler);
    }
  }
  createPromise(callback) {
    if (this.cancelled) {
      return Promise.reject(new CancellationError());
    }
    const finallyHandler = () => {
      if (cancelHandler != null) {
        try {
          this.removeListener("cancel", cancelHandler);
          cancelHandler = null;
        } catch (ignore) {
        }
      }
    };
    let cancelHandler = null;
    return new Promise((resolve2, reject) => {
      let addedCancelHandler = null;
      cancelHandler = () => {
        try {
          if (addedCancelHandler != null) {
            addedCancelHandler();
            addedCancelHandler = null;
          }
        } finally {
          reject(new CancellationError());
        }
      };
      if (this.cancelled) {
        cancelHandler();
        return;
      }
      this.onCancel(cancelHandler);
      callback(resolve2, reject, (callback2) => {
        addedCancelHandler = callback2;
      });
    }).then((it) => {
      finallyHandler();
      return it;
    }).catch((e) => {
      finallyHandler();
      throw e;
    });
  }
  removeParentCancelHandler() {
    const parent = this._parent;
    if (parent != null && this.parentCancelHandler != null) {
      parent.removeListener("cancel", this.parentCancelHandler);
      this.parentCancelHandler = null;
    }
  }
  dispose() {
    try {
      this.removeParentCancelHandler();
    } finally {
      this.removeAllListeners();
      this._parent = null;
    }
  }
}
CancellationToken$1.CancellationToken = CancellationToken;
class CancellationError extends Error {
  constructor() {
    super("cancelled");
  }
}
CancellationToken$1.CancellationError = CancellationError;
var httpExecutor = {};
var browser = { exports: {} };
var s = 1e3;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
var ms = function(val, options) {
  options = options || {};
  var type2 = typeof val;
  if (type2 === "string" && val.length > 0) {
    return parse$d(val);
  } else if (type2 === "number" && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
};
function parse$d(str2) {
  str2 = String(str2);
  if (str2.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str2);
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type2 = (match[2] || "ms").toLowerCase();
  switch (type2) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      return n * y;
    case "weeks":
    case "week":
    case "w":
      return n * w;
    case "days":
    case "day":
    case "d":
      return n * d;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      return n * h;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      return n * m;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      return n * s;
    case "milliseconds":
    case "millisecond":
    case "msecs":
    case "msec":
    case "ms":
      return n;
    default:
      return void 0;
  }
}
function fmtShort(ms2) {
  var msAbs = Math.abs(ms2);
  if (msAbs >= d) {
    return Math.round(ms2 / d) + "d";
  }
  if (msAbs >= h) {
    return Math.round(ms2 / h) + "h";
  }
  if (msAbs >= m) {
    return Math.round(ms2 / m) + "m";
  }
  if (msAbs >= s) {
    return Math.round(ms2 / s) + "s";
  }
  return ms2 + "ms";
}
function fmtLong(ms2) {
  var msAbs = Math.abs(ms2);
  if (msAbs >= d) {
    return plural(ms2, msAbs, d, "day");
  }
  if (msAbs >= h) {
    return plural(ms2, msAbs, h, "hour");
  }
  if (msAbs >= m) {
    return plural(ms2, msAbs, m, "minute");
  }
  if (msAbs >= s) {
    return plural(ms2, msAbs, s, "second");
  }
  return ms2 + " ms";
}
function plural(ms2, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
}
function setup(env2) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce2;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = ms;
  createDebug.destroy = destroy;
  Object.keys(env2).forEach((key) => {
    createDebug[key] = env2[key];
  });
  createDebug.names = [];
  createDebug.skips = [];
  createDebug.formatters = {};
  function selectColor(namespace) {
    let hash = 0;
    for (let i2 = 0; i2 < namespace.length; i2++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i2);
      hash |= 0;
    }
    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;
  function createDebug(namespace) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug2(...args) {
      if (!debug2.enabled) {
        return;
      }
      const self2 = debug2;
      const curr = Number(new Date());
      const ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
        if (match === "%%") {
          return "%";
        }
        index++;
        const formatter = createDebug.formatters[format2];
        if (typeof formatter === "function") {
          const val = args[index];
          match = formatter.call(self2, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      createDebug.formatArgs.call(self2, args);
      const logFn = self2.log || createDebug.log;
      logFn.apply(self2, args);
    }
    debug2.namespace = namespace;
    debug2.useColors = createDebug.useColors();
    debug2.color = createDebug.selectColor(namespace);
    debug2.extend = extend3;
    debug2.destroy = createDebug.destroy;
    Object.defineProperty(debug2, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      },
      set: (v) => {
        enableOverride = v;
      }
    });
    if (typeof createDebug.init === "function") {
      createDebug.init(debug2);
    }
    return debug2;
  }
  function extend3(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    let i2;
    const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    const len = split.length;
    for (i2 = 0; i2 < len; i2++) {
      if (!split[i2]) {
        continue;
      }
      namespaces = split[i2].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
      } else {
        createDebug.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    const namespaces = [
      ...createDebug.names.map(toNamespace),
      ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
    ].join(",");
    createDebug.enable("");
    return namespaces;
  }
  function enabled(name) {
    if (name[name.length - 1] === "*") {
      return true;
    }
    let i2;
    let len;
    for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
      if (createDebug.skips[i2].test(name)) {
        return false;
      }
    }
    for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
      if (createDebug.names[i2].test(name)) {
        return true;
      }
    }
    return false;
  }
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function coerce2(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }
  function destroy() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  createDebug.enable(createDebug.load());
  return createDebug;
}
var common$6 = setup;
(function(module, exports) {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load2;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error2) {
    }
  }
  function load2() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error2) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = {}.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error2) {
    }
  }
  module.exports = common$6(exports);
  const { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error2) {
      return "[UnexpectedJSONParseError]: " + error2.message;
    }
  };
})(browser, browser.exports);
var ProgressCallbackTransform$1 = {};
Object.defineProperty(ProgressCallbackTransform$1, "__esModule", { value: true });
ProgressCallbackTransform$1.ProgressCallbackTransform = void 0;
const stream_1$3 = require$$0__default$1["default"];
class ProgressCallbackTransform extends stream_1$3.Transform {
  constructor(total, cancellationToken, onProgress) {
    super();
    this.total = total;
    this.cancellationToken = cancellationToken;
    this.onProgress = onProgress;
    this.start = Date.now();
    this.transferred = 0;
    this.delta = 0;
    this.nextUpdate = this.start + 1e3;
  }
  _transform(chunk, encoding, callback) {
    if (this.cancellationToken.cancelled) {
      callback(new Error("cancelled"), null);
      return;
    }
    this.transferred += chunk.length;
    this.delta += chunk.length;
    const now = Date.now();
    if (now >= this.nextUpdate && this.transferred !== this.total) {
      this.nextUpdate = now + 1e3;
      this.onProgress({
        total: this.total,
        delta: this.delta,
        transferred: this.transferred,
        percent: this.transferred / this.total * 100,
        bytesPerSecond: Math.round(this.transferred / ((now - this.start) / 1e3))
      });
      this.delta = 0;
    }
    callback(null, chunk);
  }
  _flush(callback) {
    if (this.cancellationToken.cancelled) {
      callback(new Error("cancelled"));
      return;
    }
    this.onProgress({
      total: this.total,
      delta: this.delta,
      transferred: this.total,
      percent: 100,
      bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
    });
    this.delta = 0;
    callback(null);
  }
}
ProgressCallbackTransform$1.ProgressCallbackTransform = ProgressCallbackTransform;
Object.defineProperty(httpExecutor, "__esModule", { value: true });
httpExecutor.safeStringifyJson = httpExecutor.configureRequestOptions = httpExecutor.safeGetHeader = httpExecutor.DigestTransform = httpExecutor.configureRequestUrl = httpExecutor.configureRequestOptionsFromUrl = httpExecutor.HttpExecutor = httpExecutor.parseJson = httpExecutor.HttpError = httpExecutor.createHttpError = void 0;
const crypto_1$4 = require$$0__default$3["default"];
const debug_1$2 = browser.exports;
const fs_1$7 = require$$1__default$1["default"];
const stream_1$2 = require$$0__default$1["default"];
const url_1$5 = require$$4__default["default"];
const CancellationToken_1 = CancellationToken$1;
const index_1$2 = out;
const ProgressCallbackTransform_1 = ProgressCallbackTransform$1;
const debug$8 = (0, debug_1$2.default)("electron-builder");
function createHttpError(response, description2 = null) {
  return new HttpError(response.statusCode || -1, `${response.statusCode} ${response.statusMessage}` + (description2 == null ? "" : "\n" + JSON.stringify(description2, null, "  ")) + "\nHeaders: " + safeStringifyJson(response.headers), description2);
}
httpExecutor.createHttpError = createHttpError;
const HTTP_STATUS_CODES = new Map([
  [429, "Too many requests"],
  [400, "Bad request"],
  [403, "Forbidden"],
  [404, "Not found"],
  [405, "Method not allowed"],
  [406, "Not acceptable"],
  [408, "Request timeout"],
  [413, "Request entity too large"],
  [500, "Internal server error"],
  [502, "Bad gateway"],
  [503, "Service unavailable"],
  [504, "Gateway timeout"],
  [505, "HTTP version not supported"]
]);
class HttpError extends Error {
  constructor(statusCode, message = `HTTP error: ${HTTP_STATUS_CODES.get(statusCode) || statusCode}`, description2 = null) {
    super(message);
    this.statusCode = statusCode;
    this.description = description2;
    this.name = "HttpError";
    this.code = `HTTP_ERROR_${statusCode}`;
  }
  isServerError() {
    return this.statusCode >= 500 && this.statusCode <= 599;
  }
}
httpExecutor.HttpError = HttpError;
function parseJson(result) {
  return result.then((it) => it == null || it.length === 0 ? null : JSON.parse(it));
}
httpExecutor.parseJson = parseJson;
class HttpExecutor {
  constructor() {
    this.maxRedirects = 10;
  }
  request(options, cancellationToken = new CancellationToken_1.CancellationToken(), data) {
    configureRequestOptions(options);
    const json2 = data == null ? void 0 : JSON.stringify(data);
    const encodedData = json2 ? Buffer.from(json2) : void 0;
    if (encodedData != null) {
      debug$8(json2);
      const _a = options, { headers } = _a, opts2 = __objRest(_a, ["headers"]);
      options = __spreadValues({
        method: "post",
        headers: __spreadValues({
          "Content-Type": "application/json",
          "Content-Length": encodedData.length
        }, headers)
      }, opts2);
    }
    return this.doApiRequest(options, cancellationToken, (it) => it.end(encodedData));
  }
  doApiRequest(options, cancellationToken, requestProcessor, redirectCount = 0) {
    if (debug$8.enabled) {
      debug$8(`Request: ${safeStringifyJson(options)}`);
    }
    return cancellationToken.createPromise((resolve2, reject, onCancel) => {
      const request = this.createRequest(options, (response) => {
        try {
          this.handleResponse(response, options, cancellationToken, resolve2, reject, redirectCount, requestProcessor);
        } catch (e) {
          reject(e);
        }
      });
      this.addErrorAndTimeoutHandlers(request, reject, options.timeout);
      this.addRedirectHandlers(request, options, reject, redirectCount, (options2) => {
        this.doApiRequest(options2, cancellationToken, requestProcessor, redirectCount).then(resolve2).catch(reject);
      });
      requestProcessor(request, reject);
      onCancel(() => request.abort());
    });
  }
  addRedirectHandlers(request, options, reject, redirectCount, handler) {
  }
  addErrorAndTimeoutHandlers(request, reject, timeout = 60 * 1e3) {
    this.addTimeOutHandler(request, reject, timeout);
    request.on("error", reject);
    request.on("aborted", () => {
      reject(new Error("Request has been aborted by the server"));
    });
  }
  handleResponse(response, options, cancellationToken, resolve2, reject, redirectCount, requestProcessor) {
    var _a;
    if (debug$8.enabled) {
      debug$8(`Response: ${response.statusCode} ${response.statusMessage}, request options: ${safeStringifyJson(options)}`);
    }
    if (response.statusCode === 404) {
      reject(createHttpError(response, `method: ${options.method || "GET"} url: ${options.protocol || "https:"}//${options.hostname}${options.port ? `:${options.port}` : ""}${options.path}

Please double check that your authentication token is correct. Due to security reasons, actual status maybe not reported, but 404.
`));
      return;
    } else if (response.statusCode === 204) {
      resolve2();
      return;
    }
    const code2 = (_a = response.statusCode) !== null && _a !== void 0 ? _a : 0;
    const shouldRedirect = code2 >= 300 && code2 < 400;
    const redirectUrl = safeGetHeader(response, "location");
    if (shouldRedirect && redirectUrl != null) {
      if (redirectCount > this.maxRedirects) {
        reject(this.createMaxRedirectError());
        return;
      }
      this.doApiRequest(HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options), cancellationToken, requestProcessor, redirectCount).then(resolve2).catch(reject);
      return;
    }
    response.setEncoding("utf8");
    let data = "";
    response.on("error", reject);
    response.on("data", (chunk) => data += chunk);
    response.on("end", () => {
      try {
        if (response.statusCode != null && response.statusCode >= 400) {
          const contentType = safeGetHeader(response, "content-type");
          const isJson = contentType != null && (Array.isArray(contentType) ? contentType.find((it) => it.includes("json")) != null : contentType.includes("json"));
          reject(createHttpError(response, `method: ${options.method || "GET"} url: ${options.protocol || "https:"}//${options.hostname}${options.port ? `:${options.port}` : ""}${options.path}

          Data:
          ${isJson ? JSON.stringify(JSON.parse(data)) : data}
          `));
        } else {
          resolve2(data.length === 0 ? null : data);
        }
      } catch (e) {
        reject(e);
      }
    });
  }
  async downloadToBuffer(url, options) {
    return await options.cancellationToken.createPromise((resolve2, reject, onCancel) => {
      const responseChunks = [];
      const requestOptions = {
        headers: options.headers || void 0,
        redirect: "manual"
      };
      configureRequestUrl(url, requestOptions);
      configureRequestOptions(requestOptions);
      this.doDownload(requestOptions, {
        destination: null,
        options,
        onCancel,
        callback: (error2) => {
          if (error2 == null) {
            resolve2(Buffer.concat(responseChunks));
          } else {
            reject(error2);
          }
        },
        responseHandler: (response, callback) => {
          let receivedLength = 0;
          response.on("data", (chunk) => {
            receivedLength += chunk.length;
            if (receivedLength > 524288e3) {
              callback(new Error("Maximum allowed size is 500 MB"));
              return;
            }
            responseChunks.push(chunk);
          });
          response.on("end", () => {
            callback(null);
          });
        }
      }, 0);
    });
  }
  doDownload(requestOptions, options, redirectCount) {
    const request = this.createRequest(requestOptions, (response) => {
      if (response.statusCode >= 400) {
        options.callback(new Error(`Cannot download "${requestOptions.protocol || "https:"}//${requestOptions.hostname}${requestOptions.path}", status ${response.statusCode}: ${response.statusMessage}`));
        return;
      }
      response.on("error", options.callback);
      const redirectUrl = safeGetHeader(response, "location");
      if (redirectUrl != null) {
        if (redirectCount < this.maxRedirects) {
          this.doDownload(HttpExecutor.prepareRedirectUrlOptions(redirectUrl, requestOptions), options, redirectCount++);
        } else {
          options.callback(this.createMaxRedirectError());
        }
        return;
      }
      if (options.responseHandler == null) {
        configurePipes(options, response);
      } else {
        options.responseHandler(response, options.callback);
      }
    });
    this.addErrorAndTimeoutHandlers(request, options.callback, requestOptions.timeout);
    this.addRedirectHandlers(request, requestOptions, options.callback, redirectCount, (requestOptions2) => {
      this.doDownload(requestOptions2, options, redirectCount++);
    });
    request.end();
  }
  createMaxRedirectError() {
    return new Error(`Too many redirects (> ${this.maxRedirects})`);
  }
  addTimeOutHandler(request, callback, timeout) {
    request.on("socket", (socket) => {
      socket.setTimeout(timeout, () => {
        request.abort();
        callback(new Error("Request timed out"));
      });
    });
  }
  static prepareRedirectUrlOptions(redirectUrl, options) {
    const newOptions = configureRequestOptionsFromUrl(redirectUrl, __spreadValues({}, options));
    const headers = newOptions.headers;
    if (headers === null || headers === void 0 ? void 0 : headers.authorization) {
      const parsedNewUrl = new url_1$5.URL(redirectUrl);
      if (parsedNewUrl.hostname.endsWith(".amazonaws.com") || parsedNewUrl.searchParams.has("X-Amz-Credential")) {
        delete headers.authorization;
      }
    }
    return newOptions;
  }
  static retryOnServerError(task, maxRetries = 3) {
    for (let attemptNumber = 0; ; attemptNumber++) {
      try {
        return task();
      } catch (e) {
        if (attemptNumber < maxRetries && (e instanceof HttpError && e.isServerError() || e.code === "EPIPE")) {
          continue;
        }
        throw e;
      }
    }
  }
}
httpExecutor.HttpExecutor = HttpExecutor;
function configureRequestOptionsFromUrl(url, options) {
  const result = configureRequestOptions(options);
  configureRequestUrl(new url_1$5.URL(url), result);
  return result;
}
httpExecutor.configureRequestOptionsFromUrl = configureRequestOptionsFromUrl;
function configureRequestUrl(url, options) {
  options.protocol = url.protocol;
  options.hostname = url.hostname;
  if (url.port) {
    options.port = url.port;
  } else if (options.port) {
    delete options.port;
  }
  options.path = url.pathname + url.search;
}
httpExecutor.configureRequestUrl = configureRequestUrl;
class DigestTransform extends stream_1$2.Transform {
  constructor(expected, algorithm = "sha512", encoding = "base64") {
    super();
    this.expected = expected;
    this.algorithm = algorithm;
    this.encoding = encoding;
    this._actual = null;
    this.isValidateOnEnd = true;
    this.digester = (0, crypto_1$4.createHash)(algorithm);
  }
  get actual() {
    return this._actual;
  }
  _transform(chunk, encoding, callback) {
    this.digester.update(chunk);
    callback(null, chunk);
  }
  _flush(callback) {
    this._actual = this.digester.digest(this.encoding);
    if (this.isValidateOnEnd) {
      try {
        this.validate();
      } catch (e) {
        callback(e);
        return;
      }
    }
    callback(null);
  }
  validate() {
    if (this._actual == null) {
      throw (0, index_1$2.newError)("Not finished yet", "ERR_STREAM_NOT_FINISHED");
    }
    if (this._actual !== this.expected) {
      throw (0, index_1$2.newError)(`${this.algorithm} checksum mismatch, expected ${this.expected}, got ${this._actual}`, "ERR_CHECKSUM_MISMATCH");
    }
    return null;
  }
}
httpExecutor.DigestTransform = DigestTransform;
function checkSha2(sha2Header, sha2, callback) {
  if (sha2Header != null && sha2 != null && sha2Header !== sha2) {
    callback(new Error(`checksum mismatch: expected ${sha2} but got ${sha2Header} (X-Checksum-Sha2 header)`));
    return false;
  }
  return true;
}
function safeGetHeader(response, headerKey) {
  const value = response.headers[headerKey];
  if (value == null) {
    return null;
  } else if (Array.isArray(value)) {
    return value.length === 0 ? null : value[value.length - 1];
  } else {
    return value;
  }
}
httpExecutor.safeGetHeader = safeGetHeader;
function configurePipes(options, response) {
  if (!checkSha2(safeGetHeader(response, "X-Checksum-Sha2"), options.options.sha2, options.callback)) {
    return;
  }
  const streams = [];
  if (options.options.onProgress != null) {
    const contentLength = safeGetHeader(response, "content-length");
    if (contentLength != null) {
      streams.push(new ProgressCallbackTransform_1.ProgressCallbackTransform(parseInt(contentLength, 10), options.options.cancellationToken, options.options.onProgress));
    }
  }
  const sha512 = options.options.sha512;
  if (sha512 != null) {
    streams.push(new DigestTransform(sha512, "sha512", sha512.length === 128 && !sha512.includes("+") && !sha512.includes("Z") && !sha512.includes("=") ? "hex" : "base64"));
  } else if (options.options.sha2 != null) {
    streams.push(new DigestTransform(options.options.sha2, "sha256", "hex"));
  }
  const fileOut = (0, fs_1$7.createWriteStream)(options.destination);
  streams.push(fileOut);
  let lastStream = response;
  for (const stream of streams) {
    stream.on("error", (error2) => {
      fileOut.close();
      if (!options.options.cancellationToken.cancelled) {
        options.callback(error2);
      }
    });
    lastStream = lastStream.pipe(stream);
  }
  fileOut.on("finish", () => {
    fileOut.close(options.callback);
  });
}
function configureRequestOptions(options, token, method) {
  if (method != null) {
    options.method = method;
  }
  options.headers = __spreadValues({}, options.headers);
  const headers = options.headers;
  if (token != null) {
    headers.authorization = token.startsWith("Basic") || token.startsWith("Bearer") ? token : `token ${token}`;
  }
  if (headers["User-Agent"] == null) {
    headers["User-Agent"] = "electron-builder";
  }
  if (method == null || method === "GET" || headers["Cache-Control"] == null) {
    headers["Cache-Control"] = "no-cache";
  }
  if (options.protocol == null && process.versions.electron != null) {
    options.protocol = "https:";
  }
  return options;
}
httpExecutor.configureRequestOptions = configureRequestOptions;
function safeStringifyJson(data, skippedNames) {
  return JSON.stringify(data, (name, value) => {
    if (name.endsWith("Authorization") || name.endsWith("authorization") || name.endsWith("Password") || name.endsWith("PASSWORD") || name.endsWith("Token") || name.includes("password") || name.includes("token") || skippedNames != null && skippedNames.has(name)) {
      return "<stripped sensitive data>";
    }
    return value;
  }, 2);
}
httpExecutor.safeStringifyJson = safeStringifyJson;
var publishOptions = {};
Object.defineProperty(publishOptions, "__esModule", { value: true });
publishOptions.getS3LikeProviderBaseUrl = publishOptions.githubUrl = void 0;
function githubUrl(options, defaultHost = "github.com") {
  return `${options.protocol || "https"}://${options.host || defaultHost}`;
}
publishOptions.githubUrl = githubUrl;
function getS3LikeProviderBaseUrl(configuration) {
  const provider = configuration.provider;
  if (provider === "s3") {
    return s3Url(configuration);
  }
  if (provider === "spaces") {
    return spacesUrl(configuration);
  }
  throw new Error(`Not supported provider: ${provider}`);
}
publishOptions.getS3LikeProviderBaseUrl = getS3LikeProviderBaseUrl;
function s3Url(options) {
  let url;
  if (options.accelerate == true) {
    url = `https://${options.bucket}.s3-accelerate.amazonaws.com`;
  } else if (options.endpoint != null) {
    url = `${options.endpoint}/${options.bucket}`;
  } else if (options.bucket.includes(".")) {
    if (options.region == null) {
      throw new Error(`Bucket name "${options.bucket}" includes a dot, but S3 region is missing`);
    }
    if (options.region === "us-east-1") {
      url = `https://s3.amazonaws.com/${options.bucket}`;
    } else {
      url = `https://s3-${options.region}.amazonaws.com/${options.bucket}`;
    }
  } else if (options.region === "cn-north-1") {
    url = `https://${options.bucket}.s3.${options.region}.amazonaws.com.cn`;
  } else {
    url = `https://${options.bucket}.s3.amazonaws.com`;
  }
  return appendPath(url, options.path);
}
function appendPath(url, p) {
  if (p != null && p.length > 0) {
    if (!p.startsWith("/")) {
      url += "/";
    }
    url += p;
  }
  return url;
}
function spacesUrl(options) {
  if (options.name == null) {
    throw new Error(`name is missing`);
  }
  if (options.region == null) {
    throw new Error(`region is missing`);
  }
  return appendPath(`https://${options.name}.${options.region}.digitaloceanspaces.com`, options.path);
}
var rfc2253Parser = {};
Object.defineProperty(rfc2253Parser, "__esModule", { value: true });
rfc2253Parser.parseDn = void 0;
function parseDn(seq2) {
  let quoted = false;
  let key = null;
  let token = "";
  let nextNonSpace = 0;
  seq2 = seq2.trim();
  const result = new Map();
  for (let i2 = 0; i2 <= seq2.length; i2++) {
    if (i2 === seq2.length) {
      if (key !== null) {
        result.set(key, token);
      }
      break;
    }
    const ch = seq2[i2];
    if (quoted) {
      if (ch === '"') {
        quoted = false;
        continue;
      }
    } else {
      if (ch === '"') {
        quoted = true;
        continue;
      }
      if (ch === "\\") {
        i2++;
        const ord = parseInt(seq2.slice(i2, i2 + 2), 16);
        if (Number.isNaN(ord)) {
          token += seq2[i2];
        } else {
          i2++;
          token += String.fromCharCode(ord);
        }
        continue;
      }
      if (key === null && ch === "=") {
        key = token;
        token = "";
        continue;
      }
      if (ch === "," || ch === ";" || ch === "+") {
        if (key !== null) {
          result.set(key, token);
        }
        key = null;
        token = "";
        continue;
      }
    }
    if (ch === " " && !quoted) {
      if (token.length === 0) {
        continue;
      }
      if (i2 > nextNonSpace) {
        let j = i2;
        while (seq2[j] === " ") {
          j++;
        }
        nextNonSpace = j;
      }
      if (nextNonSpace >= seq2.length || seq2[nextNonSpace] === "," || seq2[nextNonSpace] === ";" || key === null && seq2[nextNonSpace] === "=" || key !== null && seq2[nextNonSpace] === "+") {
        i2 = nextNonSpace - 1;
        continue;
      }
    }
    token += ch;
  }
  return result;
}
rfc2253Parser.parseDn = parseDn;
var uuid = {};
Object.defineProperty(uuid, "__esModule", { value: true });
uuid.nil = uuid.UUID = void 0;
const crypto_1$3 = require$$0__default$3["default"];
const index_1$1 = out;
const invalidName = "options.name must be either a string or a Buffer";
const randomHost = (0, crypto_1$3.randomBytes)(16);
randomHost[0] = randomHost[0] | 1;
const hex2byte = {};
const byte2hex = [];
for (let i2 = 0; i2 < 256; i2++) {
  const hex = (i2 + 256).toString(16).substr(1);
  hex2byte[hex] = i2;
  byte2hex[i2] = hex;
}
class UUID {
  constructor(uuid2) {
    this.ascii = null;
    this.binary = null;
    const check = UUID.check(uuid2);
    if (!check) {
      throw new Error("not a UUID");
    }
    this.version = check.version;
    if (check.format === "ascii") {
      this.ascii = uuid2;
    } else {
      this.binary = uuid2;
    }
  }
  static v5(name, namespace) {
    return uuidNamed(name, "sha1", 80, namespace);
  }
  toString() {
    if (this.ascii == null) {
      this.ascii = stringify$2(this.binary);
    }
    return this.ascii;
  }
  inspect() {
    return `UUID v${this.version} ${this.toString()}`;
  }
  static check(uuid2, offset = 0) {
    if (typeof uuid2 === "string") {
      uuid2 = uuid2.toLowerCase();
      if (!/^[a-f0-9]{8}(-[a-f0-9]{4}){3}-([a-f0-9]{12})$/.test(uuid2)) {
        return false;
      }
      if (uuid2 === "00000000-0000-0000-0000-000000000000") {
        return { version: void 0, variant: "nil", format: "ascii" };
      }
      return {
        version: (hex2byte[uuid2[14] + uuid2[15]] & 240) >> 4,
        variant: getVariant((hex2byte[uuid2[19] + uuid2[20]] & 224) >> 5),
        format: "ascii"
      };
    }
    if (Buffer.isBuffer(uuid2)) {
      if (uuid2.length < offset + 16) {
        return false;
      }
      let i2 = 0;
      for (; i2 < 16; i2++) {
        if (uuid2[offset + i2] !== 0) {
          break;
        }
      }
      if (i2 === 16) {
        return { version: void 0, variant: "nil", format: "binary" };
      }
      return {
        version: (uuid2[offset + 6] & 240) >> 4,
        variant: getVariant((uuid2[offset + 8] & 224) >> 5),
        format: "binary"
      };
    }
    throw (0, index_1$1.newError)("Unknown type of uuid", "ERR_UNKNOWN_UUID_TYPE");
  }
  static parse(input) {
    const buffer = Buffer.allocUnsafe(16);
    let j = 0;
    for (let i2 = 0; i2 < 16; i2++) {
      buffer[i2] = hex2byte[input[j++] + input[j++]];
      if (i2 === 3 || i2 === 5 || i2 === 7 || i2 === 9) {
        j += 1;
      }
    }
    return buffer;
  }
}
uuid.UUID = UUID;
UUID.OID = UUID.parse("6ba7b812-9dad-11d1-80b4-00c04fd430c8");
function getVariant(bits) {
  switch (bits) {
    case 0:
    case 1:
    case 3:
      return "ncs";
    case 4:
    case 5:
      return "rfc4122";
    case 6:
      return "microsoft";
    default:
      return "future";
  }
}
var UuidEncoding;
(function(UuidEncoding2) {
  UuidEncoding2[UuidEncoding2["ASCII"] = 0] = "ASCII";
  UuidEncoding2[UuidEncoding2["BINARY"] = 1] = "BINARY";
  UuidEncoding2[UuidEncoding2["OBJECT"] = 2] = "OBJECT";
})(UuidEncoding || (UuidEncoding = {}));
function uuidNamed(name, hashMethod, version, namespace, encoding = UuidEncoding.ASCII) {
  const hash = (0, crypto_1$3.createHash)(hashMethod);
  const nameIsNotAString = typeof name !== "string";
  if (nameIsNotAString && !Buffer.isBuffer(name)) {
    throw (0, index_1$1.newError)(invalidName, "ERR_INVALID_UUID_NAME");
  }
  hash.update(namespace);
  hash.update(name);
  const buffer = hash.digest();
  let result;
  switch (encoding) {
    case UuidEncoding.BINARY:
      buffer[6] = buffer[6] & 15 | version;
      buffer[8] = buffer[8] & 63 | 128;
      result = buffer;
      break;
    case UuidEncoding.OBJECT:
      buffer[6] = buffer[6] & 15 | version;
      buffer[8] = buffer[8] & 63 | 128;
      result = new UUID(buffer);
      break;
    default:
      result = byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + "-" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + "-" + byte2hex[buffer[6] & 15 | version] + byte2hex[buffer[7]] + "-" + byte2hex[buffer[8] & 63 | 128] + byte2hex[buffer[9]] + "-" + byte2hex[buffer[10]] + byte2hex[buffer[11]] + byte2hex[buffer[12]] + byte2hex[buffer[13]] + byte2hex[buffer[14]] + byte2hex[buffer[15]];
      break;
  }
  return result;
}
function stringify$2(buffer) {
  return byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + "-" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + "-" + byte2hex[buffer[6]] + byte2hex[buffer[7]] + "-" + byte2hex[buffer[8]] + byte2hex[buffer[9]] + "-" + byte2hex[buffer[10]] + byte2hex[buffer[11]] + byte2hex[buffer[12]] + byte2hex[buffer[13]] + byte2hex[buffer[14]] + byte2hex[buffer[15]];
}
uuid.nil = new UUID("00000000-0000-0000-0000-000000000000");
var xml = {};
var sax$1 = {};
(function(exports) {
  (function(sax2) {
    sax2.parser = function(strict, opt) {
      return new SAXParser(strict, opt);
    };
    sax2.SAXParser = SAXParser;
    sax2.SAXStream = SAXStream;
    sax2.createStream = createStream;
    sax2.MAX_BUFFER_LENGTH = 64 * 1024;
    var buffers = [
      "comment",
      "sgmlDecl",
      "textNode",
      "tagName",
      "doctype",
      "procInstName",
      "procInstBody",
      "entity",
      "attribName",
      "attribValue",
      "cdata",
      "script"
    ];
    sax2.EVENTS = [
      "text",
      "processinginstruction",
      "sgmldeclaration",
      "doctype",
      "comment",
      "opentagstart",
      "attribute",
      "opentag",
      "closetag",
      "opencdata",
      "cdata",
      "closecdata",
      "error",
      "end",
      "ready",
      "script",
      "opennamespace",
      "closenamespace"
    ];
    function SAXParser(strict, opt) {
      if (!(this instanceof SAXParser)) {
        return new SAXParser(strict, opt);
      }
      var parser = this;
      clearBuffers(parser);
      parser.q = parser.c = "";
      parser.bufferCheckPosition = sax2.MAX_BUFFER_LENGTH;
      parser.opt = opt || {};
      parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
      parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
      parser.tags = [];
      parser.closed = parser.closedRoot = parser.sawRoot = false;
      parser.tag = parser.error = null;
      parser.strict = !!strict;
      parser.noscript = !!(strict || parser.opt.noscript);
      parser.state = S.BEGIN;
      parser.strictEntities = parser.opt.strictEntities;
      parser.ENTITIES = parser.strictEntities ? Object.create(sax2.XML_ENTITIES) : Object.create(sax2.ENTITIES);
      parser.attribList = [];
      if (parser.opt.xmlns) {
        parser.ns = Object.create(rootNS);
      }
      parser.trackPosition = parser.opt.position !== false;
      if (parser.trackPosition) {
        parser.position = parser.line = parser.column = 0;
      }
      emit(parser, "onready");
    }
    if (!Object.create) {
      Object.create = function(o) {
        function F() {
        }
        F.prototype = o;
        var newf = new F();
        return newf;
      };
    }
    if (!Object.keys) {
      Object.keys = function(o) {
        var a = [];
        for (var i2 in o)
          if (o.hasOwnProperty(i2))
            a.push(i2);
        return a;
      };
    }
    function checkBufferLength(parser) {
      var maxAllowed = Math.max(sax2.MAX_BUFFER_LENGTH, 10);
      var maxActual = 0;
      for (var i2 = 0, l = buffers.length; i2 < l; i2++) {
        var len = parser[buffers[i2]].length;
        if (len > maxAllowed) {
          switch (buffers[i2]) {
            case "textNode":
              closeText(parser);
              break;
            case "cdata":
              emitNode(parser, "oncdata", parser.cdata);
              parser.cdata = "";
              break;
            case "script":
              emitNode(parser, "onscript", parser.script);
              parser.script = "";
              break;
            default:
              error2(parser, "Max buffer length exceeded: " + buffers[i2]);
          }
        }
        maxActual = Math.max(maxActual, len);
      }
      var m2 = sax2.MAX_BUFFER_LENGTH - maxActual;
      parser.bufferCheckPosition = m2 + parser.position;
    }
    function clearBuffers(parser) {
      for (var i2 = 0, l = buffers.length; i2 < l; i2++) {
        parser[buffers[i2]] = "";
      }
    }
    function flushBuffers(parser) {
      closeText(parser);
      if (parser.cdata !== "") {
        emitNode(parser, "oncdata", parser.cdata);
        parser.cdata = "";
      }
      if (parser.script !== "") {
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
    }
    SAXParser.prototype = {
      end: function() {
        end(this);
      },
      write,
      resume: function() {
        this.error = null;
        return this;
      },
      close: function() {
        return this.write(null);
      },
      flush: function() {
        flushBuffers(this);
      }
    };
    var Stream2;
    try {
      Stream2 = require$$0__default$1["default"].Stream;
    } catch (ex) {
      Stream2 = function() {
      };
    }
    var streamWraps = sax2.EVENTS.filter(function(ev) {
      return ev !== "error" && ev !== "end";
    });
    function createStream(strict, opt) {
      return new SAXStream(strict, opt);
    }
    function SAXStream(strict, opt) {
      if (!(this instanceof SAXStream)) {
        return new SAXStream(strict, opt);
      }
      Stream2.apply(this);
      this._parser = new SAXParser(strict, opt);
      this.writable = true;
      this.readable = true;
      var me = this;
      this._parser.onend = function() {
        me.emit("end");
      };
      this._parser.onerror = function(er) {
        me.emit("error", er);
        me._parser.error = null;
      };
      this._decoder = null;
      streamWraps.forEach(function(ev) {
        Object.defineProperty(me, "on" + ev, {
          get: function() {
            return me._parser["on" + ev];
          },
          set: function(h2) {
            if (!h2) {
              me.removeAllListeners(ev);
              me._parser["on" + ev] = h2;
              return h2;
            }
            me.on(ev, h2);
          },
          enumerable: true,
          configurable: false
        });
      });
    }
    SAXStream.prototype = Object.create(Stream2.prototype, {
      constructor: {
        value: SAXStream
      }
    });
    SAXStream.prototype.write = function(data) {
      if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
        if (!this._decoder) {
          var SD = require$$1__default$3["default"].StringDecoder;
          this._decoder = new SD("utf8");
        }
        data = this._decoder.write(data);
      }
      this._parser.write(data.toString());
      this.emit("data", data);
      return true;
    };
    SAXStream.prototype.end = function(chunk) {
      if (chunk && chunk.length) {
        this.write(chunk);
      }
      this._parser.end();
      return true;
    };
    SAXStream.prototype.on = function(ev, handler) {
      var me = this;
      if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
        me._parser["on" + ev] = function() {
          var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          args.splice(0, 0, ev);
          me.emit.apply(me, args);
        };
      }
      return Stream2.prototype.on.call(me, ev, handler);
    };
    var CDATA = "[CDATA[";
    var DOCTYPE = "DOCTYPE";
    var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
    var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
    var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function isWhitespace2(c) {
      return c === " " || c === "\n" || c === "\r" || c === "	";
    }
    function isQuote(c) {
      return c === '"' || c === "'";
    }
    function isAttribEnd(c) {
      return c === ">" || isWhitespace2(c);
    }
    function isMatch(regex, c) {
      return regex.test(c);
    }
    function notMatch(regex, c) {
      return !isMatch(regex, c);
    }
    var S = 0;
    sax2.STATE = {
      BEGIN: S++,
      BEGIN_WHITESPACE: S++,
      TEXT: S++,
      TEXT_ENTITY: S++,
      OPEN_WAKA: S++,
      SGML_DECL: S++,
      SGML_DECL_QUOTED: S++,
      DOCTYPE: S++,
      DOCTYPE_QUOTED: S++,
      DOCTYPE_DTD: S++,
      DOCTYPE_DTD_QUOTED: S++,
      COMMENT_STARTING: S++,
      COMMENT: S++,
      COMMENT_ENDING: S++,
      COMMENT_ENDED: S++,
      CDATA: S++,
      CDATA_ENDING: S++,
      CDATA_ENDING_2: S++,
      PROC_INST: S++,
      PROC_INST_BODY: S++,
      PROC_INST_ENDING: S++,
      OPEN_TAG: S++,
      OPEN_TAG_SLASH: S++,
      ATTRIB: S++,
      ATTRIB_NAME: S++,
      ATTRIB_NAME_SAW_WHITE: S++,
      ATTRIB_VALUE: S++,
      ATTRIB_VALUE_QUOTED: S++,
      ATTRIB_VALUE_CLOSED: S++,
      ATTRIB_VALUE_UNQUOTED: S++,
      ATTRIB_VALUE_ENTITY_Q: S++,
      ATTRIB_VALUE_ENTITY_U: S++,
      CLOSE_TAG: S++,
      CLOSE_TAG_SAW_WHITE: S++,
      SCRIPT: S++,
      SCRIPT_ENDING: S++
    };
    sax2.XML_ENTITIES = {
      "amp": "&",
      "gt": ">",
      "lt": "<",
      "quot": '"',
      "apos": "'"
    };
    sax2.ENTITIES = {
      "amp": "&",
      "gt": ">",
      "lt": "<",
      "quot": '"',
      "apos": "'",
      "AElig": 198,
      "Aacute": 193,
      "Acirc": 194,
      "Agrave": 192,
      "Aring": 197,
      "Atilde": 195,
      "Auml": 196,
      "Ccedil": 199,
      "ETH": 208,
      "Eacute": 201,
      "Ecirc": 202,
      "Egrave": 200,
      "Euml": 203,
      "Iacute": 205,
      "Icirc": 206,
      "Igrave": 204,
      "Iuml": 207,
      "Ntilde": 209,
      "Oacute": 211,
      "Ocirc": 212,
      "Ograve": 210,
      "Oslash": 216,
      "Otilde": 213,
      "Ouml": 214,
      "THORN": 222,
      "Uacute": 218,
      "Ucirc": 219,
      "Ugrave": 217,
      "Uuml": 220,
      "Yacute": 221,
      "aacute": 225,
      "acirc": 226,
      "aelig": 230,
      "agrave": 224,
      "aring": 229,
      "atilde": 227,
      "auml": 228,
      "ccedil": 231,
      "eacute": 233,
      "ecirc": 234,
      "egrave": 232,
      "eth": 240,
      "euml": 235,
      "iacute": 237,
      "icirc": 238,
      "igrave": 236,
      "iuml": 239,
      "ntilde": 241,
      "oacute": 243,
      "ocirc": 244,
      "ograve": 242,
      "oslash": 248,
      "otilde": 245,
      "ouml": 246,
      "szlig": 223,
      "thorn": 254,
      "uacute": 250,
      "ucirc": 251,
      "ugrave": 249,
      "uuml": 252,
      "yacute": 253,
      "yuml": 255,
      "copy": 169,
      "reg": 174,
      "nbsp": 160,
      "iexcl": 161,
      "cent": 162,
      "pound": 163,
      "curren": 164,
      "yen": 165,
      "brvbar": 166,
      "sect": 167,
      "uml": 168,
      "ordf": 170,
      "laquo": 171,
      "not": 172,
      "shy": 173,
      "macr": 175,
      "deg": 176,
      "plusmn": 177,
      "sup1": 185,
      "sup2": 178,
      "sup3": 179,
      "acute": 180,
      "micro": 181,
      "para": 182,
      "middot": 183,
      "cedil": 184,
      "ordm": 186,
      "raquo": 187,
      "frac14": 188,
      "frac12": 189,
      "frac34": 190,
      "iquest": 191,
      "times": 215,
      "divide": 247,
      "OElig": 338,
      "oelig": 339,
      "Scaron": 352,
      "scaron": 353,
      "Yuml": 376,
      "fnof": 402,
      "circ": 710,
      "tilde": 732,
      "Alpha": 913,
      "Beta": 914,
      "Gamma": 915,
      "Delta": 916,
      "Epsilon": 917,
      "Zeta": 918,
      "Eta": 919,
      "Theta": 920,
      "Iota": 921,
      "Kappa": 922,
      "Lambda": 923,
      "Mu": 924,
      "Nu": 925,
      "Xi": 926,
      "Omicron": 927,
      "Pi": 928,
      "Rho": 929,
      "Sigma": 931,
      "Tau": 932,
      "Upsilon": 933,
      "Phi": 934,
      "Chi": 935,
      "Psi": 936,
      "Omega": 937,
      "alpha": 945,
      "beta": 946,
      "gamma": 947,
      "delta": 948,
      "epsilon": 949,
      "zeta": 950,
      "eta": 951,
      "theta": 952,
      "iota": 953,
      "kappa": 954,
      "lambda": 955,
      "mu": 956,
      "nu": 957,
      "xi": 958,
      "omicron": 959,
      "pi": 960,
      "rho": 961,
      "sigmaf": 962,
      "sigma": 963,
      "tau": 964,
      "upsilon": 965,
      "phi": 966,
      "chi": 967,
      "psi": 968,
      "omega": 969,
      "thetasym": 977,
      "upsih": 978,
      "piv": 982,
      "ensp": 8194,
      "emsp": 8195,
      "thinsp": 8201,
      "zwnj": 8204,
      "zwj": 8205,
      "lrm": 8206,
      "rlm": 8207,
      "ndash": 8211,
      "mdash": 8212,
      "lsquo": 8216,
      "rsquo": 8217,
      "sbquo": 8218,
      "ldquo": 8220,
      "rdquo": 8221,
      "bdquo": 8222,
      "dagger": 8224,
      "Dagger": 8225,
      "bull": 8226,
      "hellip": 8230,
      "permil": 8240,
      "prime": 8242,
      "Prime": 8243,
      "lsaquo": 8249,
      "rsaquo": 8250,
      "oline": 8254,
      "frasl": 8260,
      "euro": 8364,
      "image": 8465,
      "weierp": 8472,
      "real": 8476,
      "trade": 8482,
      "alefsym": 8501,
      "larr": 8592,
      "uarr": 8593,
      "rarr": 8594,
      "darr": 8595,
      "harr": 8596,
      "crarr": 8629,
      "lArr": 8656,
      "uArr": 8657,
      "rArr": 8658,
      "dArr": 8659,
      "hArr": 8660,
      "forall": 8704,
      "part": 8706,
      "exist": 8707,
      "empty": 8709,
      "nabla": 8711,
      "isin": 8712,
      "notin": 8713,
      "ni": 8715,
      "prod": 8719,
      "sum": 8721,
      "minus": 8722,
      "lowast": 8727,
      "radic": 8730,
      "prop": 8733,
      "infin": 8734,
      "ang": 8736,
      "and": 8743,
      "or": 8744,
      "cap": 8745,
      "cup": 8746,
      "int": 8747,
      "there4": 8756,
      "sim": 8764,
      "cong": 8773,
      "asymp": 8776,
      "ne": 8800,
      "equiv": 8801,
      "le": 8804,
      "ge": 8805,
      "sub": 8834,
      "sup": 8835,
      "nsub": 8836,
      "sube": 8838,
      "supe": 8839,
      "oplus": 8853,
      "otimes": 8855,
      "perp": 8869,
      "sdot": 8901,
      "lceil": 8968,
      "rceil": 8969,
      "lfloor": 8970,
      "rfloor": 8971,
      "lang": 9001,
      "rang": 9002,
      "loz": 9674,
      "spades": 9824,
      "clubs": 9827,
      "hearts": 9829,
      "diams": 9830
    };
    Object.keys(sax2.ENTITIES).forEach(function(key) {
      var e = sax2.ENTITIES[key];
      var s3 = typeof e === "number" ? String.fromCharCode(e) : e;
      sax2.ENTITIES[key] = s3;
    });
    for (var s2 in sax2.STATE) {
      sax2.STATE[sax2.STATE[s2]] = s2;
    }
    S = sax2.STATE;
    function emit(parser, event, data) {
      parser[event] && parser[event](data);
    }
    function emitNode(parser, nodeType, data) {
      if (parser.textNode)
        closeText(parser);
      emit(parser, nodeType, data);
    }
    function closeText(parser) {
      parser.textNode = textopts(parser.opt, parser.textNode);
      if (parser.textNode)
        emit(parser, "ontext", parser.textNode);
      parser.textNode = "";
    }
    function textopts(opt, text) {
      if (opt.trim)
        text = text.trim();
      if (opt.normalize)
        text = text.replace(/\s+/g, " ");
      return text;
    }
    function error2(parser, er) {
      closeText(parser);
      if (parser.trackPosition) {
        er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
      }
      er = new Error(er);
      parser.error = er;
      emit(parser, "onerror", er);
      return parser;
    }
    function end(parser) {
      if (parser.sawRoot && !parser.closedRoot)
        strictFail(parser, "Unclosed root tag");
      if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
        error2(parser, "Unexpected end");
      }
      closeText(parser);
      parser.c = "";
      parser.closed = true;
      emit(parser, "onend");
      SAXParser.call(parser, parser.strict, parser.opt);
      return parser;
    }
    function strictFail(parser, message) {
      if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
        throw new Error("bad call to strictFail");
      }
      if (parser.strict) {
        error2(parser, message);
      }
    }
    function newTag(parser) {
      if (!parser.strict)
        parser.tagName = parser.tagName[parser.looseCase]();
      var parent = parser.tags[parser.tags.length - 1] || parser;
      var tag = parser.tag = { name: parser.tagName, attributes: {} };
      if (parser.opt.xmlns) {
        tag.ns = parent.ns;
      }
      parser.attribList.length = 0;
      emitNode(parser, "onopentagstart", tag);
    }
    function qname(name, attribute) {
      var i2 = name.indexOf(":");
      var qualName = i2 < 0 ? ["", name] : name.split(":");
      var prefix = qualName[0];
      var local = qualName[1];
      if (attribute && name === "xmlns") {
        prefix = "xmlns";
        local = "";
      }
      return { prefix, local };
    }
    function attrib(parser) {
      if (!parser.strict) {
        parser.attribName = parser.attribName[parser.looseCase]();
      }
      if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
        parser.attribName = parser.attribValue = "";
        return;
      }
      if (parser.opt.xmlns) {
        var qn = qname(parser.attribName, true);
        var prefix = qn.prefix;
        var local = qn.local;
        if (prefix === "xmlns") {
          if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
            strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue);
          } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
            strictFail(parser, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue);
          } else {
            var tag = parser.tag;
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns === parent.ns) {
              tag.ns = Object.create(parent.ns);
            }
            tag.ns[local] = parser.attribValue;
          }
        }
        parser.attribList.push([parser.attribName, parser.attribValue]);
      } else {
        parser.tag.attributes[parser.attribName] = parser.attribValue;
        emitNode(parser, "onattribute", {
          name: parser.attribName,
          value: parser.attribValue
        });
      }
      parser.attribName = parser.attribValue = "";
    }
    function openTag(parser, selfClosing) {
      if (parser.opt.xmlns) {
        var tag = parser.tag;
        var qn = qname(parser.tagName);
        tag.prefix = qn.prefix;
        tag.local = qn.local;
        tag.uri = tag.ns[qn.prefix] || "";
        if (tag.prefix && !tag.uri) {
          strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
          tag.uri = qn.prefix;
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (tag.ns && parent.ns !== tag.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            emitNode(parser, "onopennamespace", {
              prefix: p,
              uri: tag.ns[p]
            });
          });
        }
        for (var i2 = 0, l = parser.attribList.length; i2 < l; i2++) {
          var nv = parser.attribList[i2];
          var name = nv[0];
          var value = nv[1];
          var qualName = qname(name, true);
          var prefix = qualName.prefix;
          var local = qualName.local;
          var uri = prefix === "" ? "" : tag.ns[prefix] || "";
          var a = {
            name,
            value,
            prefix,
            local,
            uri
          };
          if (prefix && prefix !== "xmlns" && !uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
            a.uri = prefix;
          }
          parser.tag.attributes[name] = a;
          emitNode(parser, "onattribute", a);
        }
        parser.attribList.length = 0;
      }
      parser.tag.isSelfClosing = !!selfClosing;
      parser.sawRoot = true;
      parser.tags.push(parser.tag);
      emitNode(parser, "onopentag", parser.tag);
      if (!selfClosing) {
        if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
          parser.state = S.SCRIPT;
        } else {
          parser.state = S.TEXT;
        }
        parser.tag = null;
        parser.tagName = "";
      }
      parser.attribName = parser.attribValue = "";
      parser.attribList.length = 0;
    }
    function closeTag(parser) {
      if (!parser.tagName) {
        strictFail(parser, "Weird empty close tag.");
        parser.textNode += "</>";
        parser.state = S.TEXT;
        return;
      }
      if (parser.script) {
        if (parser.tagName !== "script") {
          parser.script += "</" + parser.tagName + ">";
          parser.tagName = "";
          parser.state = S.SCRIPT;
          return;
        }
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
      var t2 = parser.tags.length;
      var tagName = parser.tagName;
      if (!parser.strict) {
        tagName = tagName[parser.looseCase]();
      }
      var closeTo = tagName;
      while (t2--) {
        var close = parser.tags[t2];
        if (close.name !== closeTo) {
          strictFail(parser, "Unexpected close tag");
        } else {
          break;
        }
      }
      if (t2 < 0) {
        strictFail(parser, "Unmatched closing tag: " + parser.tagName);
        parser.textNode += "</" + parser.tagName + ">";
        parser.state = S.TEXT;
        return;
      }
      parser.tagName = tagName;
      var s3 = parser.tags.length;
      while (s3-- > t2) {
        var tag = parser.tag = parser.tags.pop();
        parser.tagName = parser.tag.name;
        emitNode(parser, "onclosetag", parser.tagName);
        var x = {};
        for (var i2 in tag.ns) {
          x[i2] = tag.ns[i2];
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (parser.opt.xmlns && tag.ns !== parent.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            var n = tag.ns[p];
            emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
          });
        }
      }
      if (t2 === 0)
        parser.closedRoot = true;
      parser.tagName = parser.attribValue = parser.attribName = "";
      parser.attribList.length = 0;
      parser.state = S.TEXT;
    }
    function parseEntity(parser) {
      var entity = parser.entity;
      var entityLC = entity.toLowerCase();
      var num;
      var numStr = "";
      if (parser.ENTITIES[entity]) {
        return parser.ENTITIES[entity];
      }
      if (parser.ENTITIES[entityLC]) {
        return parser.ENTITIES[entityLC];
      }
      entity = entityLC;
      if (entity.charAt(0) === "#") {
        if (entity.charAt(1) === "x") {
          entity = entity.slice(2);
          num = parseInt(entity, 16);
          numStr = num.toString(16);
        } else {
          entity = entity.slice(1);
          num = parseInt(entity, 10);
          numStr = num.toString(10);
        }
      }
      entity = entity.replace(/^0+/, "");
      if (isNaN(num) || numStr.toLowerCase() !== entity) {
        strictFail(parser, "Invalid character entity");
        return "&" + parser.entity + ";";
      }
      return String.fromCodePoint(num);
    }
    function beginWhiteSpace(parser, c) {
      if (c === "<") {
        parser.state = S.OPEN_WAKA;
        parser.startTagPosition = parser.position;
      } else if (!isWhitespace2(c)) {
        strictFail(parser, "Non-whitespace before first tag.");
        parser.textNode = c;
        parser.state = S.TEXT;
      }
    }
    function charAt(chunk, i2) {
      var result = "";
      if (i2 < chunk.length) {
        result = chunk.charAt(i2);
      }
      return result;
    }
    function write(chunk) {
      var parser = this;
      if (this.error) {
        throw this.error;
      }
      if (parser.closed) {
        return error2(parser, "Cannot write after close. Assign an onready handler.");
      }
      if (chunk === null) {
        return end(parser);
      }
      if (typeof chunk === "object") {
        chunk = chunk.toString();
      }
      var i2 = 0;
      var c = "";
      while (true) {
        c = charAt(chunk, i2++);
        parser.c = c;
        if (!c) {
          break;
        }
        if (parser.trackPosition) {
          parser.position++;
          if (c === "\n") {
            parser.line++;
            parser.column = 0;
          } else {
            parser.column++;
          }
        }
        switch (parser.state) {
          case S.BEGIN:
            parser.state = S.BEGIN_WHITESPACE;
            if (c === "\uFEFF") {
              continue;
            }
            beginWhiteSpace(parser, c);
            continue;
          case S.BEGIN_WHITESPACE:
            beginWhiteSpace(parser, c);
            continue;
          case S.TEXT:
            if (parser.sawRoot && !parser.closedRoot) {
              var starti = i2 - 1;
              while (c && c !== "<" && c !== "&") {
                c = charAt(chunk, i2++);
                if (c && parser.trackPosition) {
                  parser.position++;
                  if (c === "\n") {
                    parser.line++;
                    parser.column = 0;
                  } else {
                    parser.column++;
                  }
                }
              }
              parser.textNode += chunk.substring(starti, i2 - 1);
            }
            if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
              parser.state = S.OPEN_WAKA;
              parser.startTagPosition = parser.position;
            } else {
              if (!isWhitespace2(c) && (!parser.sawRoot || parser.closedRoot)) {
                strictFail(parser, "Text data outside of root node.");
              }
              if (c === "&") {
                parser.state = S.TEXT_ENTITY;
              } else {
                parser.textNode += c;
              }
            }
            continue;
          case S.SCRIPT:
            if (c === "<") {
              parser.state = S.SCRIPT_ENDING;
            } else {
              parser.script += c;
            }
            continue;
          case S.SCRIPT_ENDING:
            if (c === "/") {
              parser.state = S.CLOSE_TAG;
            } else {
              parser.script += "<" + c;
              parser.state = S.SCRIPT;
            }
            continue;
          case S.OPEN_WAKA:
            if (c === "!") {
              parser.state = S.SGML_DECL;
              parser.sgmlDecl = "";
            } else if (isWhitespace2(c))
              ;
            else if (isMatch(nameStart, c)) {
              parser.state = S.OPEN_TAG;
              parser.tagName = c;
            } else if (c === "/") {
              parser.state = S.CLOSE_TAG;
              parser.tagName = "";
            } else if (c === "?") {
              parser.state = S.PROC_INST;
              parser.procInstName = parser.procInstBody = "";
            } else {
              strictFail(parser, "Unencoded <");
              if (parser.startTagPosition + 1 < parser.position) {
                var pad = parser.position - parser.startTagPosition;
                c = new Array(pad).join(" ") + c;
              }
              parser.textNode += "<" + c;
              parser.state = S.TEXT;
            }
            continue;
          case S.SGML_DECL:
            if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
              emitNode(parser, "onopencdata");
              parser.state = S.CDATA;
              parser.sgmlDecl = "";
              parser.cdata = "";
            } else if (parser.sgmlDecl + c === "--") {
              parser.state = S.COMMENT;
              parser.comment = "";
              parser.sgmlDecl = "";
            } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
              parser.state = S.DOCTYPE;
              if (parser.doctype || parser.sawRoot) {
                strictFail(parser, "Inappropriately located doctype declaration");
              }
              parser.doctype = "";
              parser.sgmlDecl = "";
            } else if (c === ">") {
              emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
              parser.sgmlDecl = "";
              parser.state = S.TEXT;
            } else if (isQuote(c)) {
              parser.state = S.SGML_DECL_QUOTED;
              parser.sgmlDecl += c;
            } else {
              parser.sgmlDecl += c;
            }
            continue;
          case S.SGML_DECL_QUOTED:
            if (c === parser.q) {
              parser.state = S.SGML_DECL;
              parser.q = "";
            }
            parser.sgmlDecl += c;
            continue;
          case S.DOCTYPE:
            if (c === ">") {
              parser.state = S.TEXT;
              emitNode(parser, "ondoctype", parser.doctype);
              parser.doctype = true;
            } else {
              parser.doctype += c;
              if (c === "[") {
                parser.state = S.DOCTYPE_DTD;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_QUOTED;
                parser.q = c;
              }
            }
            continue;
          case S.DOCTYPE_QUOTED:
            parser.doctype += c;
            if (c === parser.q) {
              parser.q = "";
              parser.state = S.DOCTYPE;
            }
            continue;
          case S.DOCTYPE_DTD:
            parser.doctype += c;
            if (c === "]") {
              parser.state = S.DOCTYPE;
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_DTD_QUOTED;
              parser.q = c;
            }
            continue;
          case S.DOCTYPE_DTD_QUOTED:
            parser.doctype += c;
            if (c === parser.q) {
              parser.state = S.DOCTYPE_DTD;
              parser.q = "";
            }
            continue;
          case S.COMMENT:
            if (c === "-") {
              parser.state = S.COMMENT_ENDING;
            } else {
              parser.comment += c;
            }
            continue;
          case S.COMMENT_ENDING:
            if (c === "-") {
              parser.state = S.COMMENT_ENDED;
              parser.comment = textopts(parser.opt, parser.comment);
              if (parser.comment) {
                emitNode(parser, "oncomment", parser.comment);
              }
              parser.comment = "";
            } else {
              parser.comment += "-" + c;
              parser.state = S.COMMENT;
            }
            continue;
          case S.COMMENT_ENDED:
            if (c !== ">") {
              strictFail(parser, "Malformed comment");
              parser.comment += "--" + c;
              parser.state = S.COMMENT;
            } else {
              parser.state = S.TEXT;
            }
            continue;
          case S.CDATA:
            if (c === "]") {
              parser.state = S.CDATA_ENDING;
            } else {
              parser.cdata += c;
            }
            continue;
          case S.CDATA_ENDING:
            if (c === "]") {
              parser.state = S.CDATA_ENDING_2;
            } else {
              parser.cdata += "]" + c;
              parser.state = S.CDATA;
            }
            continue;
          case S.CDATA_ENDING_2:
            if (c === ">") {
              if (parser.cdata) {
                emitNode(parser, "oncdata", parser.cdata);
              }
              emitNode(parser, "onclosecdata");
              parser.cdata = "";
              parser.state = S.TEXT;
            } else if (c === "]") {
              parser.cdata += "]";
            } else {
              parser.cdata += "]]" + c;
              parser.state = S.CDATA;
            }
            continue;
          case S.PROC_INST:
            if (c === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else if (isWhitespace2(c)) {
              parser.state = S.PROC_INST_BODY;
            } else {
              parser.procInstName += c;
            }
            continue;
          case S.PROC_INST_BODY:
            if (!parser.procInstBody && isWhitespace2(c)) {
              continue;
            } else if (c === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else {
              parser.procInstBody += c;
            }
            continue;
          case S.PROC_INST_ENDING:
            if (c === ">") {
              emitNode(parser, "onprocessinginstruction", {
                name: parser.procInstName,
                body: parser.procInstBody
              });
              parser.procInstName = parser.procInstBody = "";
              parser.state = S.TEXT;
            } else {
              parser.procInstBody += "?" + c;
              parser.state = S.PROC_INST_BODY;
            }
            continue;
          case S.OPEN_TAG:
            if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else {
              newTag(parser);
              if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else {
                if (!isWhitespace2(c)) {
                  strictFail(parser, "Invalid character in tag name");
                }
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.OPEN_TAG_SLASH:
            if (c === ">") {
              openTag(parser, true);
              closeTag(parser);
            } else {
              strictFail(parser, "Forward-slash in opening tag not followed by >");
              parser.state = S.ATTRIB;
            }
            continue;
          case S.ATTRIB:
            if (isWhitespace2(c)) {
              continue;
            } else if (c === ">") {
              openTag(parser);
            } else if (c === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_NAME:
            if (c === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (c === ">") {
              strictFail(parser, "Attribute without value");
              parser.attribValue = parser.attribName;
              attrib(parser);
              openTag(parser);
            } else if (isWhitespace2(c)) {
              parser.state = S.ATTRIB_NAME_SAW_WHITE;
            } else if (isMatch(nameBody, c)) {
              parser.attribName += c;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_NAME_SAW_WHITE:
            if (c === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (isWhitespace2(c)) {
              continue;
            } else {
              strictFail(parser, "Attribute without value");
              parser.tag.attributes[parser.attribName] = "";
              parser.attribValue = "";
              emitNode(parser, "onattribute", {
                name: parser.attribName,
                value: ""
              });
              parser.attribName = "";
              if (c === ">") {
                openTag(parser);
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.ATTRIB_VALUE:
            if (isWhitespace2(c)) {
              continue;
            } else if (isQuote(c)) {
              parser.q = c;
              parser.state = S.ATTRIB_VALUE_QUOTED;
            } else {
              strictFail(parser, "Unquoted attribute value");
              parser.state = S.ATTRIB_VALUE_UNQUOTED;
              parser.attribValue = c;
            }
            continue;
          case S.ATTRIB_VALUE_QUOTED:
            if (c !== parser.q) {
              if (c === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_Q;
              } else {
                parser.attribValue += c;
              }
              continue;
            }
            attrib(parser);
            parser.q = "";
            parser.state = S.ATTRIB_VALUE_CLOSED;
            continue;
          case S.ATTRIB_VALUE_CLOSED:
            if (isWhitespace2(c)) {
              parser.state = S.ATTRIB;
            } else if (c === ">") {
              openTag(parser);
            } else if (c === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              strictFail(parser, "No whitespace between attributes");
              parser.attribName = c;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_VALUE_UNQUOTED:
            if (!isAttribEnd(c)) {
              if (c === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_U;
              } else {
                parser.attribValue += c;
              }
              continue;
            }
            attrib(parser);
            if (c === ">") {
              openTag(parser);
            } else {
              parser.state = S.ATTRIB;
            }
            continue;
          case S.CLOSE_TAG:
            if (!parser.tagName) {
              if (isWhitespace2(c)) {
                continue;
              } else if (notMatch(nameStart, c)) {
                if (parser.script) {
                  parser.script += "</" + c;
                  parser.state = S.SCRIPT;
                } else {
                  strictFail(parser, "Invalid tagname in closing tag.");
                }
              } else {
                parser.tagName = c;
              }
            } else if (c === ">") {
              closeTag(parser);
            } else if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else if (parser.script) {
              parser.script += "</" + parser.tagName;
              parser.tagName = "";
              parser.state = S.SCRIPT;
            } else {
              if (!isWhitespace2(c)) {
                strictFail(parser, "Invalid tagname in closing tag");
              }
              parser.state = S.CLOSE_TAG_SAW_WHITE;
            }
            continue;
          case S.CLOSE_TAG_SAW_WHITE:
            if (isWhitespace2(c)) {
              continue;
            }
            if (c === ">") {
              closeTag(parser);
            } else {
              strictFail(parser, "Invalid characters in closing tag");
            }
            continue;
          case S.TEXT_ENTITY:
          case S.ATTRIB_VALUE_ENTITY_Q:
          case S.ATTRIB_VALUE_ENTITY_U:
            var returnState;
            var buffer;
            switch (parser.state) {
              case S.TEXT_ENTITY:
                returnState = S.TEXT;
                buffer = "textNode";
                break;
              case S.ATTRIB_VALUE_ENTITY_Q:
                returnState = S.ATTRIB_VALUE_QUOTED;
                buffer = "attribValue";
                break;
              case S.ATTRIB_VALUE_ENTITY_U:
                returnState = S.ATTRIB_VALUE_UNQUOTED;
                buffer = "attribValue";
                break;
            }
            if (c === ";") {
              parser[buffer] += parseEntity(parser);
              parser.entity = "";
              parser.state = returnState;
            } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
              parser.entity += c;
            } else {
              strictFail(parser, "Invalid character in entity name");
              parser[buffer] += "&" + parser.entity + c;
              parser.entity = "";
              parser.state = returnState;
            }
            continue;
          default:
            throw new Error(parser, "Unknown state: " + parser.state);
        }
      }
      if (parser.position >= parser.bufferCheckPosition) {
        checkBufferLength(parser);
      }
      return parser;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
    if (!String.fromCodePoint) {
      (function() {
        var stringFromCharCode = String.fromCharCode;
        var floor = Math.floor;
        var fromCodePoint = function() {
          var MAX_SIZE = 16384;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index = -1;
          var length = arguments.length;
          if (!length) {
            return "";
          }
          var result = "";
          while (++index < length) {
            var codePoint = Number(arguments[index]);
            if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint) {
              throw RangeError("Invalid code point: " + codePoint);
            }
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              highSurrogate = (codePoint >> 10) + 55296;
              lowSurrogate = codePoint % 1024 + 56320;
              codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index + 1 === length || codeUnits.length > MAX_SIZE) {
              result += stringFromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        };
        if (Object.defineProperty) {
          Object.defineProperty(String, "fromCodePoint", {
            value: fromCodePoint,
            configurable: true,
            writable: true
          });
        } else {
          String.fromCodePoint = fromCodePoint;
        }
      })();
    }
  })(exports);
})(sax$1);
Object.defineProperty(xml, "__esModule", { value: true });
xml.parseXml = xml.XElement = void 0;
const sax = sax$1;
const index_1 = out;
class XElement {
  constructor(name) {
    this.name = name;
    this.value = "";
    this.attributes = null;
    this.isCData = false;
    this.elements = null;
    if (!name) {
      throw (0, index_1.newError)("Element name cannot be empty", "ERR_XML_ELEMENT_NAME_EMPTY");
    }
    if (!isValidName(name)) {
      throw (0, index_1.newError)(`Invalid element name: ${name}`, "ERR_XML_ELEMENT_INVALID_NAME");
    }
  }
  attribute(name) {
    const result = this.attributes === null ? null : this.attributes[name];
    if (result == null) {
      throw (0, index_1.newError)(`No attribute "${name}"`, "ERR_XML_MISSED_ATTRIBUTE");
    }
    return result;
  }
  removeAttribute(name) {
    if (this.attributes !== null) {
      delete this.attributes[name];
    }
  }
  element(name, ignoreCase = false, errorIfMissed = null) {
    const result = this.elementOrNull(name, ignoreCase);
    if (result === null) {
      throw (0, index_1.newError)(errorIfMissed || `No element "${name}"`, "ERR_XML_MISSED_ELEMENT");
    }
    return result;
  }
  elementOrNull(name, ignoreCase = false) {
    if (this.elements === null) {
      return null;
    }
    for (const element of this.elements) {
      if (isNameEquals(element, name, ignoreCase)) {
        return element;
      }
    }
    return null;
  }
  getElements(name, ignoreCase = false) {
    if (this.elements === null) {
      return [];
    }
    return this.elements.filter((it) => isNameEquals(it, name, ignoreCase));
  }
  elementValueOrEmpty(name, ignoreCase = false) {
    const element = this.elementOrNull(name, ignoreCase);
    return element === null ? "" : element.value;
  }
}
xml.XElement = XElement;
const NAME_REG_EXP = new RegExp(/^[A-Za-z_][:A-Za-z0-9_-]*$/i);
function isValidName(name) {
  return NAME_REG_EXP.test(name);
}
function isNameEquals(element, name, ignoreCase) {
  const elementName = element.name;
  return elementName === name || ignoreCase === true && elementName.length === name.length && elementName.toLowerCase() === name.toLowerCase();
}
function parseXml(data) {
  let rootElement = null;
  const parser = sax.parser(true, {});
  const elements = [];
  parser.onopentag = (saxElement) => {
    const element = new XElement(saxElement.name);
    element.attributes = saxElement.attributes;
    if (rootElement === null) {
      rootElement = element;
    } else {
      const parent = elements[elements.length - 1];
      if (parent.elements == null) {
        parent.elements = [];
      }
      parent.elements.push(element);
    }
    elements.push(element);
  };
  parser.onclosetag = () => {
    elements.pop();
  };
  parser.ontext = (text) => {
    if (elements.length > 0) {
      elements[elements.length - 1].value = text;
    }
  };
  parser.oncdata = (cdata) => {
    const element = elements[elements.length - 1];
    element.value = cdata;
    element.isCData = true;
  };
  parser.onerror = (err) => {
    throw err;
  };
  parser.write(data);
  return rootElement;
}
xml.parseXml = parseXml;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.newError = exports.asArray = exports.CURRENT_APP_PACKAGE_FILE_NAME = exports.CURRENT_APP_INSTALLER_FILE_NAME = exports.XElement = exports.parseXml = exports.ProgressCallbackTransform = exports.UUID = exports.parseDn = exports.githubUrl = exports.getS3LikeProviderBaseUrl = exports.configureRequestUrl = exports.parseJson = exports.safeStringifyJson = exports.configureRequestOptionsFromUrl = exports.configureRequestOptions = exports.safeGetHeader = exports.DigestTransform = exports.HttpExecutor = exports.createHttpError = exports.HttpError = exports.CancellationError = exports.CancellationToken = void 0;
  var CancellationToken_12 = CancellationToken$1;
  Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
    return CancellationToken_12.CancellationToken;
  } });
  Object.defineProperty(exports, "CancellationError", { enumerable: true, get: function() {
    return CancellationToken_12.CancellationError;
  } });
  var httpExecutor_1 = httpExecutor;
  Object.defineProperty(exports, "HttpError", { enumerable: true, get: function() {
    return httpExecutor_1.HttpError;
  } });
  Object.defineProperty(exports, "createHttpError", { enumerable: true, get: function() {
    return httpExecutor_1.createHttpError;
  } });
  Object.defineProperty(exports, "HttpExecutor", { enumerable: true, get: function() {
    return httpExecutor_1.HttpExecutor;
  } });
  Object.defineProperty(exports, "DigestTransform", { enumerable: true, get: function() {
    return httpExecutor_1.DigestTransform;
  } });
  Object.defineProperty(exports, "safeGetHeader", { enumerable: true, get: function() {
    return httpExecutor_1.safeGetHeader;
  } });
  Object.defineProperty(exports, "configureRequestOptions", { enumerable: true, get: function() {
    return httpExecutor_1.configureRequestOptions;
  } });
  Object.defineProperty(exports, "configureRequestOptionsFromUrl", { enumerable: true, get: function() {
    return httpExecutor_1.configureRequestOptionsFromUrl;
  } });
  Object.defineProperty(exports, "safeStringifyJson", { enumerable: true, get: function() {
    return httpExecutor_1.safeStringifyJson;
  } });
  Object.defineProperty(exports, "parseJson", { enumerable: true, get: function() {
    return httpExecutor_1.parseJson;
  } });
  Object.defineProperty(exports, "configureRequestUrl", { enumerable: true, get: function() {
    return httpExecutor_1.configureRequestUrl;
  } });
  var publishOptions_1 = publishOptions;
  Object.defineProperty(exports, "getS3LikeProviderBaseUrl", { enumerable: true, get: function() {
    return publishOptions_1.getS3LikeProviderBaseUrl;
  } });
  Object.defineProperty(exports, "githubUrl", { enumerable: true, get: function() {
    return publishOptions_1.githubUrl;
  } });
  var rfc2253Parser_1 = rfc2253Parser;
  Object.defineProperty(exports, "parseDn", { enumerable: true, get: function() {
    return rfc2253Parser_1.parseDn;
  } });
  var uuid_1 = uuid;
  Object.defineProperty(exports, "UUID", { enumerable: true, get: function() {
    return uuid_1.UUID;
  } });
  var ProgressCallbackTransform_12 = ProgressCallbackTransform$1;
  Object.defineProperty(exports, "ProgressCallbackTransform", { enumerable: true, get: function() {
    return ProgressCallbackTransform_12.ProgressCallbackTransform;
  } });
  var xml_1 = xml;
  Object.defineProperty(exports, "parseXml", { enumerable: true, get: function() {
    return xml_1.parseXml;
  } });
  Object.defineProperty(exports, "XElement", { enumerable: true, get: function() {
    return xml_1.XElement;
  } });
  exports.CURRENT_APP_INSTALLER_FILE_NAME = "installer.exe";
  exports.CURRENT_APP_PACKAGE_FILE_NAME = "package.7z";
  function asArray(v) {
    if (v == null) {
      return [];
    } else if (Array.isArray(v)) {
      return v;
    } else {
      return [v];
    }
  }
  exports.asArray = asArray;
  function newError(message, code2) {
    const error2 = new Error(message);
    error2.code = code2;
    return error2;
  }
  exports.newError = newError;
})(out);
var fs$k = {};
(function(exports) {
  const u2 = universalify$1.fromCallback;
  const fs2 = gracefulFs;
  const api = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((key) => {
    return typeof fs2[key] === "function";
  });
  Object.assign(exports, fs2);
  api.forEach((method) => {
    exports[method] = u2(fs2[method]);
  });
  exports.exists = function(filename, callback) {
    if (typeof callback === "function") {
      return fs2.exists(filename, callback);
    }
    return new Promise((resolve2) => {
      return fs2.exists(filename, resolve2);
    });
  };
  exports.read = function(fd, buffer, offset, length, position, callback) {
    if (typeof callback === "function") {
      return fs2.read(fd, buffer, offset, length, position, callback);
    }
    return new Promise((resolve2, reject) => {
      fs2.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
        if (err)
          return reject(err);
        resolve2({ bytesRead, buffer: buffer2 });
      });
    });
  };
  exports.write = function(fd, buffer, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs2.write(fd, buffer, ...args);
    }
    return new Promise((resolve2, reject) => {
      fs2.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
        if (err)
          return reject(err);
        resolve2({ bytesWritten, buffer: buffer2 });
      });
    });
  };
  if (typeof fs2.writev === "function") {
    exports.writev = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs2.writev(fd, buffers, ...args);
      }
      return new Promise((resolve2, reject) => {
        fs2.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
          if (err)
            return reject(err);
          resolve2({ bytesWritten, buffers: buffers2 });
        });
      });
    };
  }
  if (typeof fs2.realpath.native === "function") {
    exports.realpath.native = u2(fs2.realpath.native);
  } else {
    process.emitWarning("fs.realpath.native is not a function. Is fs being monkey-patched?", "Warning", "fs-extra-WARN0003");
  }
})(fs$k);
var makeDir$1 = {};
var utils = {};
const path$p = require$$1__default$2["default"];
utils.checkPath = function checkPath3(pth) {
  if (process.platform === "win32") {
    const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path$p.parse(pth).root, ""));
    if (pathHasInvalidWinCharacters) {
      const error2 = new Error(`Path contains invalid characters: ${pth}`);
      error2.code = "EINVAL";
      throw error2;
    }
  }
};
const fs$j = fs$k;
const { checkPath } = utils;
const getMode = (options) => {
  const defaults2 = { mode: 511 };
  if (typeof options === "number")
    return options;
  return __spreadValues(__spreadValues({}, defaults2), options).mode;
};
makeDir$1.makeDir = async (dir, options) => {
  checkPath(dir);
  return fs$j.mkdir(dir, {
    mode: getMode(options),
    recursive: true
  });
};
makeDir$1.makeDirSync = (dir, options) => {
  checkPath(dir);
  return fs$j.mkdirSync(dir, {
    mode: getMode(options),
    recursive: true
  });
};
const u$a = universalify$1.fromPromise;
const { makeDir: _makeDir, makeDirSync } = makeDir$1;
const makeDir = u$a(_makeDir);
var mkdirs$2 = {
  mkdirs: makeDir,
  mkdirsSync: makeDirSync,
  mkdirp: makeDir,
  mkdirpSync: makeDirSync,
  ensureDir: makeDir,
  ensureDirSync: makeDirSync
};
const u$9 = universalify$1.fromPromise;
const fs$i = fs$k;
function pathExists$8(path2) {
  return fs$i.access(path2).then(() => true).catch(() => false);
}
var pathExists_1 = {
  pathExists: u$9(pathExists$8),
  pathExistsSync: fs$i.existsSync
};
const fs$h = gracefulFs;
function utimesMillis$1(path2, atime, mtime, callback) {
  fs$h.open(path2, "r+", (err, fd) => {
    if (err)
      return callback(err);
    fs$h.futimes(fd, atime, mtime, (futimesErr) => {
      fs$h.close(fd, (closeErr) => {
        if (callback)
          callback(futimesErr || closeErr);
      });
    });
  });
}
function utimesMillisSync$1(path2, atime, mtime) {
  const fd = fs$h.openSync(path2, "r+");
  fs$h.futimesSync(fd, atime, mtime);
  return fs$h.closeSync(fd);
}
var utimes = {
  utimesMillis: utimesMillis$1,
  utimesMillisSync: utimesMillisSync$1
};
const fs$g = fs$k;
const path$o = require$$1__default$2["default"];
const util$2 = require$$2__default$1["default"];
function getStats$2(src, dest, opts2) {
  const statFunc = opts2.dereference ? (file2) => fs$g.stat(file2, { bigint: true }) : (file2) => fs$g.lstat(file2, { bigint: true });
  return Promise.all([
    statFunc(src),
    statFunc(dest).catch((err) => {
      if (err.code === "ENOENT")
        return null;
      throw err;
    })
  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
}
function getStatsSync(src, dest, opts2) {
  let destStat;
  const statFunc = opts2.dereference ? (file2) => fs$g.statSync(file2, { bigint: true }) : (file2) => fs$g.lstatSync(file2, { bigint: true });
  const srcStat = statFunc(src);
  try {
    destStat = statFunc(dest);
  } catch (err) {
    if (err.code === "ENOENT")
      return { srcStat, destStat: null };
    throw err;
  }
  return { srcStat, destStat };
}
function checkPaths(src, dest, funcName, opts2, cb) {
  util$2.callbackify(getStats$2)(src, dest, opts2, (err, stats) => {
    if (err)
      return cb(err);
    const { srcStat, destStat } = stats;
    if (destStat) {
      if (areIdentical$2(srcStat, destStat)) {
        const srcBaseName = path$o.basename(src);
        const destBaseName = path$o.basename(dest);
        if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
          return cb(null, { srcStat, destStat, isChangingCase: true });
        }
        return cb(new Error("Source and destination must not be the same."));
      }
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
      }
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`));
      }
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      return cb(new Error(errMsg(src, dest, funcName)));
    }
    return cb(null, { srcStat, destStat });
  });
}
function checkPathsSync(src, dest, funcName, opts2) {
  const { srcStat, destStat } = getStatsSync(src, dest, opts2);
  if (destStat) {
    if (areIdentical$2(srcStat, destStat)) {
      const srcBaseName = path$o.basename(src);
      const destBaseName = path$o.basename(dest);
      if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
        return { srcStat, destStat, isChangingCase: true };
      }
      throw new Error("Source and destination must not be the same.");
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
    }
  }
  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new Error(errMsg(src, dest, funcName));
  }
  return { srcStat, destStat };
}
function checkParentPaths(src, srcStat, dest, funcName, cb) {
  const srcParent = path$o.resolve(path$o.dirname(src));
  const destParent = path$o.resolve(path$o.dirname(dest));
  if (destParent === srcParent || destParent === path$o.parse(destParent).root)
    return cb();
  fs$g.stat(destParent, { bigint: true }, (err, destStat) => {
    if (err) {
      if (err.code === "ENOENT")
        return cb();
      return cb(err);
    }
    if (areIdentical$2(srcStat, destStat)) {
      return cb(new Error(errMsg(src, dest, funcName)));
    }
    return checkParentPaths(src, srcStat, destParent, funcName, cb);
  });
}
function checkParentPathsSync(src, srcStat, dest, funcName) {
  const srcParent = path$o.resolve(path$o.dirname(src));
  const destParent = path$o.resolve(path$o.dirname(dest));
  if (destParent === srcParent || destParent === path$o.parse(destParent).root)
    return;
  let destStat;
  try {
    destStat = fs$g.statSync(destParent, { bigint: true });
  } catch (err) {
    if (err.code === "ENOENT")
      return;
    throw err;
  }
  if (areIdentical$2(srcStat, destStat)) {
    throw new Error(errMsg(src, dest, funcName));
  }
  return checkParentPathsSync(src, srcStat, destParent, funcName);
}
function areIdentical$2(srcStat, destStat) {
  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
}
function isSrcSubdir(src, dest) {
  const srcArr = path$o.resolve(src).split(path$o.sep).filter((i2) => i2);
  const destArr = path$o.resolve(dest).split(path$o.sep).filter((i2) => i2);
  return srcArr.reduce((acc, cur, i2) => acc && destArr[i2] === cur, true);
}
function errMsg(src, dest, funcName) {
  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
}
var stat$4 = {
  checkPaths,
  checkPathsSync,
  checkParentPaths,
  checkParentPathsSync,
  isSrcSubdir,
  areIdentical: areIdentical$2
};
const fs$f = gracefulFs;
const path$n = require$$1__default$2["default"];
const mkdirs$1 = mkdirs$2.mkdirs;
const pathExists$7 = pathExists_1.pathExists;
const utimesMillis = utimes.utimesMillis;
const stat$3 = stat$4;
function copy$2(src, dest, opts2, cb) {
  if (typeof opts2 === "function" && !cb) {
    cb = opts2;
    opts2 = {};
  } else if (typeof opts2 === "function") {
    opts2 = { filter: opts2 };
  }
  cb = cb || function() {
  };
  opts2 = opts2 || {};
  opts2.clobber = "clobber" in opts2 ? !!opts2.clobber : true;
  opts2.overwrite = "overwrite" in opts2 ? !!opts2.overwrite : opts2.clobber;
  if (opts2.preserveTimestamps && process.arch === "ia32") {
    process.emitWarning("Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269", "Warning", "fs-extra-WARN0001");
  }
  stat$3.checkPaths(src, dest, "copy", opts2, (err, stats) => {
    if (err)
      return cb(err);
    const { srcStat, destStat } = stats;
    stat$3.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
      if (err2)
        return cb(err2);
      if (opts2.filter)
        return handleFilter(checkParentDir, destStat, src, dest, opts2, cb);
      return checkParentDir(destStat, src, dest, opts2, cb);
    });
  });
}
function checkParentDir(destStat, src, dest, opts2, cb) {
  const destParent = path$n.dirname(dest);
  pathExists$7(destParent, (err, dirExists) => {
    if (err)
      return cb(err);
    if (dirExists)
      return getStats$1(destStat, src, dest, opts2, cb);
    mkdirs$1(destParent, (err2) => {
      if (err2)
        return cb(err2);
      return getStats$1(destStat, src, dest, opts2, cb);
    });
  });
}
function handleFilter(onInclude, destStat, src, dest, opts2, cb) {
  Promise.resolve(opts2.filter(src, dest)).then((include) => {
    if (include)
      return onInclude(destStat, src, dest, opts2, cb);
    return cb();
  }, (error2) => cb(error2));
}
function startCopy$1(destStat, src, dest, opts2, cb) {
  if (opts2.filter)
    return handleFilter(getStats$1, destStat, src, dest, opts2, cb);
  return getStats$1(destStat, src, dest, opts2, cb);
}
function getStats$1(destStat, src, dest, opts2, cb) {
  const stat2 = opts2.dereference ? fs$f.stat : fs$f.lstat;
  stat2(src, (err, srcStat) => {
    if (err)
      return cb(err);
    if (srcStat.isDirectory())
      return onDir$1(srcStat, destStat, src, dest, opts2, cb);
    else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
      return onFile$1(srcStat, destStat, src, dest, opts2, cb);
    else if (srcStat.isSymbolicLink())
      return onLink$1(destStat, src, dest, opts2, cb);
    else if (srcStat.isSocket())
      return cb(new Error(`Cannot copy a socket file: ${src}`));
    else if (srcStat.isFIFO())
      return cb(new Error(`Cannot copy a FIFO pipe: ${src}`));
    return cb(new Error(`Unknown file: ${src}`));
  });
}
function onFile$1(srcStat, destStat, src, dest, opts2, cb) {
  if (!destStat)
    return copyFile$1(srcStat, src, dest, opts2, cb);
  return mayCopyFile$1(srcStat, src, dest, opts2, cb);
}
function mayCopyFile$1(srcStat, src, dest, opts2, cb) {
  if (opts2.overwrite) {
    fs$f.unlink(dest, (err) => {
      if (err)
        return cb(err);
      return copyFile$1(srcStat, src, dest, opts2, cb);
    });
  } else if (opts2.errorOnExist) {
    return cb(new Error(`'${dest}' already exists`));
  } else
    return cb();
}
function copyFile$1(srcStat, src, dest, opts2, cb) {
  fs$f.copyFile(src, dest, (err) => {
    if (err)
      return cb(err);
    if (opts2.preserveTimestamps)
      return handleTimestampsAndMode(srcStat.mode, src, dest, cb);
    return setDestMode$1(dest, srcStat.mode, cb);
  });
}
function handleTimestampsAndMode(srcMode, src, dest, cb) {
  if (fileIsNotWritable$1(srcMode)) {
    return makeFileWritable$1(dest, srcMode, (err) => {
      if (err)
        return cb(err);
      return setDestTimestampsAndMode(srcMode, src, dest, cb);
    });
  }
  return setDestTimestampsAndMode(srcMode, src, dest, cb);
}
function fileIsNotWritable$1(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable$1(dest, srcMode, cb) {
  return setDestMode$1(dest, srcMode | 128, cb);
}
function setDestTimestampsAndMode(srcMode, src, dest, cb) {
  setDestTimestamps$1(src, dest, (err) => {
    if (err)
      return cb(err);
    return setDestMode$1(dest, srcMode, cb);
  });
}
function setDestMode$1(dest, srcMode, cb) {
  return fs$f.chmod(dest, srcMode, cb);
}
function setDestTimestamps$1(src, dest, cb) {
  fs$f.stat(src, (err, updatedSrcStat) => {
    if (err)
      return cb(err);
    return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
  });
}
function onDir$1(srcStat, destStat, src, dest, opts2, cb) {
  if (!destStat)
    return mkDirAndCopy$1(srcStat.mode, src, dest, opts2, cb);
  return copyDir$1(src, dest, opts2, cb);
}
function mkDirAndCopy$1(srcMode, src, dest, opts2, cb) {
  fs$f.mkdir(dest, (err) => {
    if (err)
      return cb(err);
    copyDir$1(src, dest, opts2, (err2) => {
      if (err2)
        return cb(err2);
      return setDestMode$1(dest, srcMode, cb);
    });
  });
}
function copyDir$1(src, dest, opts2, cb) {
  fs$f.readdir(src, (err, items2) => {
    if (err)
      return cb(err);
    return copyDirItems(items2, src, dest, opts2, cb);
  });
}
function copyDirItems(items2, src, dest, opts2, cb) {
  const item = items2.pop();
  if (!item)
    return cb();
  return copyDirItem$1(items2, item, src, dest, opts2, cb);
}
function copyDirItem$1(items2, item, src, dest, opts2, cb) {
  const srcItem = path$n.join(src, item);
  const destItem = path$n.join(dest, item);
  stat$3.checkPaths(srcItem, destItem, "copy", opts2, (err, stats) => {
    if (err)
      return cb(err);
    const { destStat } = stats;
    startCopy$1(destStat, srcItem, destItem, opts2, (err2) => {
      if (err2)
        return cb(err2);
      return copyDirItems(items2, src, dest, opts2, cb);
    });
  });
}
function onLink$1(destStat, src, dest, opts2, cb) {
  fs$f.readlink(src, (err, resolvedSrc) => {
    if (err)
      return cb(err);
    if (opts2.dereference) {
      resolvedSrc = path$n.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
      return fs$f.symlink(resolvedSrc, dest, cb);
    } else {
      fs$f.readlink(dest, (err2, resolvedDest) => {
        if (err2) {
          if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
            return fs$f.symlink(resolvedSrc, dest, cb);
          return cb(err2);
        }
        if (opts2.dereference) {
          resolvedDest = path$n.resolve(process.cwd(), resolvedDest);
        }
        if (stat$3.isSrcSubdir(resolvedSrc, resolvedDest)) {
          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
        }
        if (destStat.isDirectory() && stat$3.isSrcSubdir(resolvedDest, resolvedSrc)) {
          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
        }
        return copyLink$1(resolvedSrc, dest, cb);
      });
    }
  });
}
function copyLink$1(resolvedSrc, dest, cb) {
  fs$f.unlink(dest, (err) => {
    if (err)
      return cb(err);
    return fs$f.symlink(resolvedSrc, dest, cb);
  });
}
var copy_1 = copy$2;
const fs$e = gracefulFs;
const path$m = require$$1__default$2["default"];
const mkdirsSync$1 = mkdirs$2.mkdirsSync;
const utimesMillisSync = utimes.utimesMillisSync;
const stat$2 = stat$4;
function copySync$1(src, dest, opts2) {
  if (typeof opts2 === "function") {
    opts2 = { filter: opts2 };
  }
  opts2 = opts2 || {};
  opts2.clobber = "clobber" in opts2 ? !!opts2.clobber : true;
  opts2.overwrite = "overwrite" in opts2 ? !!opts2.overwrite : opts2.clobber;
  if (opts2.preserveTimestamps && process.arch === "ia32") {
    process.emitWarning("Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269", "Warning", "fs-extra-WARN0002");
  }
  const { srcStat, destStat } = stat$2.checkPathsSync(src, dest, "copy", opts2);
  stat$2.checkParentPathsSync(src, srcStat, dest, "copy");
  return handleFilterAndCopy(destStat, src, dest, opts2);
}
function handleFilterAndCopy(destStat, src, dest, opts2) {
  if (opts2.filter && !opts2.filter(src, dest))
    return;
  const destParent = path$m.dirname(dest);
  if (!fs$e.existsSync(destParent))
    mkdirsSync$1(destParent);
  return getStats(destStat, src, dest, opts2);
}
function startCopy(destStat, src, dest, opts2) {
  if (opts2.filter && !opts2.filter(src, dest))
    return;
  return getStats(destStat, src, dest, opts2);
}
function getStats(destStat, src, dest, opts2) {
  const statSync = opts2.dereference ? fs$e.statSync : fs$e.lstatSync;
  const srcStat = statSync(src);
  if (srcStat.isDirectory())
    return onDir(srcStat, destStat, src, dest, opts2);
  else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
    return onFile(srcStat, destStat, src, dest, opts2);
  else if (srcStat.isSymbolicLink())
    return onLink(destStat, src, dest, opts2);
  else if (srcStat.isSocket())
    throw new Error(`Cannot copy a socket file: ${src}`);
  else if (srcStat.isFIFO())
    throw new Error(`Cannot copy a FIFO pipe: ${src}`);
  throw new Error(`Unknown file: ${src}`);
}
function onFile(srcStat, destStat, src, dest, opts2) {
  if (!destStat)
    return copyFile(srcStat, src, dest, opts2);
  return mayCopyFile(srcStat, src, dest, opts2);
}
function mayCopyFile(srcStat, src, dest, opts2) {
  if (opts2.overwrite) {
    fs$e.unlinkSync(dest);
    return copyFile(srcStat, src, dest, opts2);
  } else if (opts2.errorOnExist) {
    throw new Error(`'${dest}' already exists`);
  }
}
function copyFile(srcStat, src, dest, opts2) {
  fs$e.copyFileSync(src, dest);
  if (opts2.preserveTimestamps)
    handleTimestamps(srcStat.mode, src, dest);
  return setDestMode(dest, srcStat.mode);
}
function handleTimestamps(srcMode, src, dest) {
  if (fileIsNotWritable(srcMode))
    makeFileWritable(dest, srcMode);
  return setDestTimestamps(src, dest);
}
function fileIsNotWritable(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable(dest, srcMode) {
  return setDestMode(dest, srcMode | 128);
}
function setDestMode(dest, srcMode) {
  return fs$e.chmodSync(dest, srcMode);
}
function setDestTimestamps(src, dest) {
  const updatedSrcStat = fs$e.statSync(src);
  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
}
function onDir(srcStat, destStat, src, dest, opts2) {
  if (!destStat)
    return mkDirAndCopy(srcStat.mode, src, dest, opts2);
  return copyDir(src, dest, opts2);
}
function mkDirAndCopy(srcMode, src, dest, opts2) {
  fs$e.mkdirSync(dest);
  copyDir(src, dest, opts2);
  return setDestMode(dest, srcMode);
}
function copyDir(src, dest, opts2) {
  fs$e.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts2));
}
function copyDirItem(item, src, dest, opts2) {
  const srcItem = path$m.join(src, item);
  const destItem = path$m.join(dest, item);
  const { destStat } = stat$2.checkPathsSync(srcItem, destItem, "copy", opts2);
  return startCopy(destStat, srcItem, destItem, opts2);
}
function onLink(destStat, src, dest, opts2) {
  let resolvedSrc = fs$e.readlinkSync(src);
  if (opts2.dereference) {
    resolvedSrc = path$m.resolve(process.cwd(), resolvedSrc);
  }
  if (!destStat) {
    return fs$e.symlinkSync(resolvedSrc, dest);
  } else {
    let resolvedDest;
    try {
      resolvedDest = fs$e.readlinkSync(dest);
    } catch (err) {
      if (err.code === "EINVAL" || err.code === "UNKNOWN")
        return fs$e.symlinkSync(resolvedSrc, dest);
      throw err;
    }
    if (opts2.dereference) {
      resolvedDest = path$m.resolve(process.cwd(), resolvedDest);
    }
    if (stat$2.isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
    }
    if (fs$e.statSync(dest).isDirectory() && stat$2.isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
    }
    return copyLink(resolvedSrc, dest);
  }
}
function copyLink(resolvedSrc, dest) {
  fs$e.unlinkSync(dest);
  return fs$e.symlinkSync(resolvedSrc, dest);
}
var copySync_1 = copySync$1;
const u$8 = universalify$1.fromCallback;
var copy$1 = {
  copy: u$8(copy_1),
  copySync: copySync_1
};
const fs$d = gracefulFs;
const path$l = require$$1__default$2["default"];
const assert = require$$2__default["default"];
const isWindows = process.platform === "win32";
function defaults$1(options) {
  const methods = [
    "unlink",
    "chmod",
    "stat",
    "lstat",
    "rmdir",
    "readdir"
  ];
  methods.forEach((m2) => {
    options[m2] = options[m2] || fs$d[m2];
    m2 = m2 + "Sync";
    options[m2] = options[m2] || fs$d[m2];
  });
  options.maxBusyTries = options.maxBusyTries || 3;
}
function rimraf$1(p, options, cb) {
  let busyTries = 0;
  if (typeof options === "function") {
    cb = options;
    options = {};
  }
  assert(p, "rimraf: missing path");
  assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
  assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
  assert(options, "rimraf: invalid options argument provided");
  assert.strictEqual(typeof options, "object", "rimraf: options should be object");
  defaults$1(options);
  rimraf_(p, options, function CB(er) {
    if (er) {
      if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
        busyTries++;
        const time = busyTries * 100;
        return setTimeout(() => rimraf_(p, options, CB), time);
      }
      if (er.code === "ENOENT")
        er = null;
    }
    cb(er);
  });
}
function rimraf_(p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.lstat(p, (er, st) => {
    if (er && er.code === "ENOENT") {
      return cb(null);
    }
    if (er && er.code === "EPERM" && isWindows) {
      return fixWinEPERM(p, options, er, cb);
    }
    if (st && st.isDirectory()) {
      return rmdir(p, options, er, cb);
    }
    options.unlink(p, (er2) => {
      if (er2) {
        if (er2.code === "ENOENT") {
          return cb(null);
        }
        if (er2.code === "EPERM") {
          return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
        }
        if (er2.code === "EISDIR") {
          return rmdir(p, options, er2, cb);
        }
      }
      return cb(er2);
    });
  });
}
function fixWinEPERM(p, options, er, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.chmod(p, 438, (er2) => {
    if (er2) {
      cb(er2.code === "ENOENT" ? null : er);
    } else {
      options.stat(p, (er3, stats) => {
        if (er3) {
          cb(er3.code === "ENOENT" ? null : er);
        } else if (stats.isDirectory()) {
          rmdir(p, options, er, cb);
        } else {
          options.unlink(p, cb);
        }
      });
    }
  });
}
function fixWinEPERMSync(p, options, er) {
  let stats;
  assert(p);
  assert(options);
  try {
    options.chmodSync(p, 438);
  } catch (er2) {
    if (er2.code === "ENOENT") {
      return;
    } else {
      throw er;
    }
  }
  try {
    stats = options.statSync(p);
  } catch (er3) {
    if (er3.code === "ENOENT") {
      return;
    } else {
      throw er;
    }
  }
  if (stats.isDirectory()) {
    rmdirSync(p, options, er);
  } else {
    options.unlinkSync(p);
  }
}
function rmdir(p, options, originalEr, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.rmdir(p, (er) => {
    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
      rmkids(p, options, cb);
    } else if (er && er.code === "ENOTDIR") {
      cb(originalEr);
    } else {
      cb(er);
    }
  });
}
function rmkids(p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.readdir(p, (er, files) => {
    if (er)
      return cb(er);
    let n = files.length;
    let errState;
    if (n === 0)
      return options.rmdir(p, cb);
    files.forEach((f) => {
      rimraf$1(path$l.join(p, f), options, (er2) => {
        if (errState) {
          return;
        }
        if (er2)
          return cb(errState = er2);
        if (--n === 0) {
          options.rmdir(p, cb);
        }
      });
    });
  });
}
function rimrafSync(p, options) {
  let st;
  options = options || {};
  defaults$1(options);
  assert(p, "rimraf: missing path");
  assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
  assert(options, "rimraf: missing options");
  assert.strictEqual(typeof options, "object", "rimraf: options should be object");
  try {
    st = options.lstatSync(p);
  } catch (er) {
    if (er.code === "ENOENT") {
      return;
    }
    if (er.code === "EPERM" && isWindows) {
      fixWinEPERMSync(p, options, er);
    }
  }
  try {
    if (st && st.isDirectory()) {
      rmdirSync(p, options, null);
    } else {
      options.unlinkSync(p);
    }
  } catch (er) {
    if (er.code === "ENOENT") {
      return;
    } else if (er.code === "EPERM") {
      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
    } else if (er.code !== "EISDIR") {
      throw er;
    }
    rmdirSync(p, options, er);
  }
}
function rmdirSync(p, options, originalEr) {
  assert(p);
  assert(options);
  try {
    options.rmdirSync(p);
  } catch (er) {
    if (er.code === "ENOTDIR") {
      throw originalEr;
    } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
      rmkidsSync(p, options);
    } else if (er.code !== "ENOENT") {
      throw er;
    }
  }
}
function rmkidsSync(p, options) {
  assert(p);
  assert(options);
  options.readdirSync(p).forEach((f) => rimrafSync(path$l.join(p, f), options));
  if (isWindows) {
    const startTime = Date.now();
    do {
      try {
        const ret = options.rmdirSync(p, options);
        return ret;
      } catch {
      }
    } while (Date.now() - startTime < 500);
  } else {
    const ret = options.rmdirSync(p, options);
    return ret;
  }
}
var rimraf_1 = rimraf$1;
rimraf$1.sync = rimrafSync;
const fs$c = gracefulFs;
const u$7 = universalify$1.fromCallback;
const rimraf = rimraf_1;
function remove$2(path2, callback) {
  if (fs$c.rm)
    return fs$c.rm(path2, { recursive: true, force: true }, callback);
  rimraf(path2, callback);
}
function removeSync$1(path2) {
  if (fs$c.rmSync)
    return fs$c.rmSync(path2, { recursive: true, force: true });
  rimraf.sync(path2);
}
var remove_1 = {
  remove: u$7(remove$2),
  removeSync: removeSync$1
};
const u$6 = universalify$1.fromPromise;
const fs$b = fs$k;
const path$k = require$$1__default$2["default"];
const mkdir$3 = mkdirs$2;
const remove$1 = remove_1;
const emptyDir = u$6(async function emptyDir3(dir) {
  let items2;
  try {
    items2 = await fs$b.readdir(dir);
  } catch {
    return mkdir$3.mkdirs(dir);
  }
  return Promise.all(items2.map((item) => remove$1.remove(path$k.join(dir, item))));
});
function emptyDirSync(dir) {
  let items2;
  try {
    items2 = fs$b.readdirSync(dir);
  } catch {
    return mkdir$3.mkdirsSync(dir);
  }
  items2.forEach((item) => {
    item = path$k.join(dir, item);
    remove$1.removeSync(item);
  });
}
var empty = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
};
const u$5 = universalify$1.fromCallback;
const path$j = require$$1__default$2["default"];
const fs$a = gracefulFs;
const mkdir$2 = mkdirs$2;
function createFile$1(file2, callback) {
  function makeFile() {
    fs$a.writeFile(file2, "", (err) => {
      if (err)
        return callback(err);
      callback();
    });
  }
  fs$a.stat(file2, (err, stats) => {
    if (!err && stats.isFile())
      return callback();
    const dir = path$j.dirname(file2);
    fs$a.stat(dir, (err2, stats2) => {
      if (err2) {
        if (err2.code === "ENOENT") {
          return mkdir$2.mkdirs(dir, (err3) => {
            if (err3)
              return callback(err3);
            makeFile();
          });
        }
        return callback(err2);
      }
      if (stats2.isDirectory())
        makeFile();
      else {
        fs$a.readdir(dir, (err3) => {
          if (err3)
            return callback(err3);
        });
      }
    });
  });
}
function createFileSync$1(file2) {
  let stats;
  try {
    stats = fs$a.statSync(file2);
  } catch {
  }
  if (stats && stats.isFile())
    return;
  const dir = path$j.dirname(file2);
  try {
    if (!fs$a.statSync(dir).isDirectory()) {
      fs$a.readdirSync(dir);
    }
  } catch (err) {
    if (err && err.code === "ENOENT")
      mkdir$2.mkdirsSync(dir);
    else
      throw err;
  }
  fs$a.writeFileSync(file2, "");
}
var file = {
  createFile: u$5(createFile$1),
  createFileSync: createFileSync$1
};
const u$4 = universalify$1.fromCallback;
const path$i = require$$1__default$2["default"];
const fs$9 = gracefulFs;
const mkdir$1 = mkdirs$2;
const pathExists$6 = pathExists_1.pathExists;
const { areIdentical: areIdentical$1 } = stat$4;
function createLink$1(srcpath, dstpath, callback) {
  function makeLink(srcpath2, dstpath2) {
    fs$9.link(srcpath2, dstpath2, (err) => {
      if (err)
        return callback(err);
      callback(null);
    });
  }
  fs$9.lstat(dstpath, (_, dstStat) => {
    fs$9.lstat(srcpath, (err, srcStat) => {
      if (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        return callback(err);
      }
      if (dstStat && areIdentical$1(srcStat, dstStat))
        return callback(null);
      const dir = path$i.dirname(dstpath);
      pathExists$6(dir, (err2, dirExists) => {
        if (err2)
          return callback(err2);
        if (dirExists)
          return makeLink(srcpath, dstpath);
        mkdir$1.mkdirs(dir, (err3) => {
          if (err3)
            return callback(err3);
          makeLink(srcpath, dstpath);
        });
      });
    });
  });
}
function createLinkSync$1(srcpath, dstpath) {
  let dstStat;
  try {
    dstStat = fs$9.lstatSync(dstpath);
  } catch {
  }
  try {
    const srcStat = fs$9.lstatSync(srcpath);
    if (dstStat && areIdentical$1(srcStat, dstStat))
      return;
  } catch (err) {
    err.message = err.message.replace("lstat", "ensureLink");
    throw err;
  }
  const dir = path$i.dirname(dstpath);
  const dirExists = fs$9.existsSync(dir);
  if (dirExists)
    return fs$9.linkSync(srcpath, dstpath);
  mkdir$1.mkdirsSync(dir);
  return fs$9.linkSync(srcpath, dstpath);
}
var link = {
  createLink: u$4(createLink$1),
  createLinkSync: createLinkSync$1
};
const path$h = require$$1__default$2["default"];
const fs$8 = gracefulFs;
const pathExists$5 = pathExists_1.pathExists;
function symlinkPaths$1(srcpath, dstpath, callback) {
  if (path$h.isAbsolute(srcpath)) {
    return fs$8.lstat(srcpath, (err) => {
      if (err) {
        err.message = err.message.replace("lstat", "ensureSymlink");
        return callback(err);
      }
      return callback(null, {
        toCwd: srcpath,
        toDst: srcpath
      });
    });
  } else {
    const dstdir = path$h.dirname(dstpath);
    const relativeToDst = path$h.join(dstdir, srcpath);
    return pathExists$5(relativeToDst, (err, exists) => {
      if (err)
        return callback(err);
      if (exists) {
        return callback(null, {
          toCwd: relativeToDst,
          toDst: srcpath
        });
      } else {
        return fs$8.lstat(srcpath, (err2) => {
          if (err2) {
            err2.message = err2.message.replace("lstat", "ensureSymlink");
            return callback(err2);
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: path$h.relative(dstdir, srcpath)
          });
        });
      }
    });
  }
}
function symlinkPathsSync$1(srcpath, dstpath) {
  let exists;
  if (path$h.isAbsolute(srcpath)) {
    exists = fs$8.existsSync(srcpath);
    if (!exists)
      throw new Error("absolute srcpath does not exist");
    return {
      toCwd: srcpath,
      toDst: srcpath
    };
  } else {
    const dstdir = path$h.dirname(dstpath);
    const relativeToDst = path$h.join(dstdir, srcpath);
    exists = fs$8.existsSync(relativeToDst);
    if (exists) {
      return {
        toCwd: relativeToDst,
        toDst: srcpath
      };
    } else {
      exists = fs$8.existsSync(srcpath);
      if (!exists)
        throw new Error("relative srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: path$h.relative(dstdir, srcpath)
      };
    }
  }
}
var symlinkPaths_1 = {
  symlinkPaths: symlinkPaths$1,
  symlinkPathsSync: symlinkPathsSync$1
};
const fs$7 = gracefulFs;
function symlinkType$1(srcpath, type2, callback) {
  callback = typeof type2 === "function" ? type2 : callback;
  type2 = typeof type2 === "function" ? false : type2;
  if (type2)
    return callback(null, type2);
  fs$7.lstat(srcpath, (err, stats) => {
    if (err)
      return callback(null, "file");
    type2 = stats && stats.isDirectory() ? "dir" : "file";
    callback(null, type2);
  });
}
function symlinkTypeSync$1(srcpath, type2) {
  let stats;
  if (type2)
    return type2;
  try {
    stats = fs$7.lstatSync(srcpath);
  } catch {
    return "file";
  }
  return stats && stats.isDirectory() ? "dir" : "file";
}
var symlinkType_1 = {
  symlinkType: symlinkType$1,
  symlinkTypeSync: symlinkTypeSync$1
};
const u$3 = universalify$1.fromCallback;
const path$g = require$$1__default$2["default"];
const fs$6 = fs$k;
const _mkdirs = mkdirs$2;
const mkdirs = _mkdirs.mkdirs;
const mkdirsSync = _mkdirs.mkdirsSync;
const _symlinkPaths = symlinkPaths_1;
const symlinkPaths = _symlinkPaths.symlinkPaths;
const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
const _symlinkType = symlinkType_1;
const symlinkType = _symlinkType.symlinkType;
const symlinkTypeSync = _symlinkType.symlinkTypeSync;
const pathExists$4 = pathExists_1.pathExists;
const { areIdentical } = stat$4;
function createSymlink$1(srcpath, dstpath, type2, callback) {
  callback = typeof type2 === "function" ? type2 : callback;
  type2 = typeof type2 === "function" ? false : type2;
  fs$6.lstat(dstpath, (err, stats) => {
    if (!err && stats.isSymbolicLink()) {
      Promise.all([
        fs$6.stat(srcpath),
        fs$6.stat(dstpath)
      ]).then(([srcStat, dstStat]) => {
        if (areIdentical(srcStat, dstStat))
          return callback(null);
        _createSymlink(srcpath, dstpath, type2, callback);
      });
    } else
      _createSymlink(srcpath, dstpath, type2, callback);
  });
}
function _createSymlink(srcpath, dstpath, type2, callback) {
  symlinkPaths(srcpath, dstpath, (err, relative) => {
    if (err)
      return callback(err);
    srcpath = relative.toDst;
    symlinkType(relative.toCwd, type2, (err2, type3) => {
      if (err2)
        return callback(err2);
      const dir = path$g.dirname(dstpath);
      pathExists$4(dir, (err3, dirExists) => {
        if (err3)
          return callback(err3);
        if (dirExists)
          return fs$6.symlink(srcpath, dstpath, type3, callback);
        mkdirs(dir, (err4) => {
          if (err4)
            return callback(err4);
          fs$6.symlink(srcpath, dstpath, type3, callback);
        });
      });
    });
  });
}
function createSymlinkSync$1(srcpath, dstpath, type2) {
  let stats;
  try {
    stats = fs$6.lstatSync(dstpath);
  } catch {
  }
  if (stats && stats.isSymbolicLink()) {
    const srcStat = fs$6.statSync(srcpath);
    const dstStat = fs$6.statSync(dstpath);
    if (areIdentical(srcStat, dstStat))
      return;
  }
  const relative = symlinkPathsSync(srcpath, dstpath);
  srcpath = relative.toDst;
  type2 = symlinkTypeSync(relative.toCwd, type2);
  const dir = path$g.dirname(dstpath);
  const exists = fs$6.existsSync(dir);
  if (exists)
    return fs$6.symlinkSync(srcpath, dstpath, type2);
  mkdirsSync(dir);
  return fs$6.symlinkSync(srcpath, dstpath, type2);
}
var symlink = {
  createSymlink: u$3(createSymlink$1),
  createSymlinkSync: createSymlinkSync$1
};
const { createFile, createFileSync } = file;
const { createLink, createLinkSync } = link;
const { createSymlink, createSymlinkSync } = symlink;
var ensure = {
  createFile,
  createFileSync,
  ensureFile: createFile,
  ensureFileSync: createFileSync,
  createLink,
  createLinkSync,
  ensureLink: createLink,
  ensureLinkSync: createLinkSync,
  createSymlink,
  createSymlinkSync,
  ensureSymlink: createSymlink,
  ensureSymlinkSync: createSymlinkSync
};
const jsonFile$1 = jsonfile_1;
var jsonfile = {
  readJson: jsonFile$1.readFile,
  readJsonSync: jsonFile$1.readFileSync,
  writeJson: jsonFile$1.writeFile,
  writeJsonSync: jsonFile$1.writeFileSync
};
const u$2 = universalify$1.fromCallback;
const fs$5 = gracefulFs;
const path$f = require$$1__default$2["default"];
const mkdir = mkdirs$2;
const pathExists$3 = pathExists_1.pathExists;
function outputFile$1(file2, data, encoding, callback) {
  if (typeof encoding === "function") {
    callback = encoding;
    encoding = "utf8";
  }
  const dir = path$f.dirname(file2);
  pathExists$3(dir, (err, itDoes) => {
    if (err)
      return callback(err);
    if (itDoes)
      return fs$5.writeFile(file2, data, encoding, callback);
    mkdir.mkdirs(dir, (err2) => {
      if (err2)
        return callback(err2);
      fs$5.writeFile(file2, data, encoding, callback);
    });
  });
}
function outputFileSync$1(file2, ...args) {
  const dir = path$f.dirname(file2);
  if (fs$5.existsSync(dir)) {
    return fs$5.writeFileSync(file2, ...args);
  }
  mkdir.mkdirsSync(dir);
  fs$5.writeFileSync(file2, ...args);
}
var outputFile_1 = {
  outputFile: u$2(outputFile$1),
  outputFileSync: outputFileSync$1
};
const { stringify: stringify$1 } = utils$1;
const { outputFile } = outputFile_1;
async function outputJson(file2, data, options = {}) {
  const str2 = stringify$1(data, options);
  await outputFile(file2, str2, options);
}
var outputJson_1 = outputJson;
const { stringify } = utils$1;
const { outputFileSync } = outputFile_1;
function outputJsonSync(file2, data, options) {
  const str2 = stringify(data, options);
  outputFileSync(file2, str2, options);
}
var outputJsonSync_1 = outputJsonSync;
const u$1 = universalify$1.fromPromise;
const jsonFile = jsonfile;
jsonFile.outputJson = u$1(outputJson_1);
jsonFile.outputJsonSync = outputJsonSync_1;
jsonFile.outputJSON = jsonFile.outputJson;
jsonFile.outputJSONSync = jsonFile.outputJsonSync;
jsonFile.writeJSON = jsonFile.writeJson;
jsonFile.writeJSONSync = jsonFile.writeJsonSync;
jsonFile.readJSON = jsonFile.readJson;
jsonFile.readJSONSync = jsonFile.readJsonSync;
var json$1 = jsonFile;
const fs$4 = gracefulFs;
const path$e = require$$1__default$2["default"];
const copy = copy$1.copy;
const remove = remove_1.remove;
const mkdirp = mkdirs$2.mkdirp;
const pathExists$2 = pathExists_1.pathExists;
const stat$1 = stat$4;
function move$1(src, dest, opts2, cb) {
  if (typeof opts2 === "function") {
    cb = opts2;
    opts2 = {};
  }
  opts2 = opts2 || {};
  const overwrite = opts2.overwrite || opts2.clobber || false;
  stat$1.checkPaths(src, dest, "move", opts2, (err, stats) => {
    if (err)
      return cb(err);
    const { srcStat, isChangingCase = false } = stats;
    stat$1.checkParentPaths(src, srcStat, dest, "move", (err2) => {
      if (err2)
        return cb(err2);
      if (isParentRoot$1(dest))
        return doRename$1(src, dest, overwrite, isChangingCase, cb);
      mkdirp(path$e.dirname(dest), (err3) => {
        if (err3)
          return cb(err3);
        return doRename$1(src, dest, overwrite, isChangingCase, cb);
      });
    });
  });
}
function isParentRoot$1(dest) {
  const parent = path$e.dirname(dest);
  const parsedPath = path$e.parse(parent);
  return parsedPath.root === parent;
}
function doRename$1(src, dest, overwrite, isChangingCase, cb) {
  if (isChangingCase)
    return rename$1(src, dest, overwrite, cb);
  if (overwrite) {
    return remove(dest, (err) => {
      if (err)
        return cb(err);
      return rename$1(src, dest, overwrite, cb);
    });
  }
  pathExists$2(dest, (err, destExists) => {
    if (err)
      return cb(err);
    if (destExists)
      return cb(new Error("dest already exists."));
    return rename$1(src, dest, overwrite, cb);
  });
}
function rename$1(src, dest, overwrite, cb) {
  fs$4.rename(src, dest, (err) => {
    if (!err)
      return cb();
    if (err.code !== "EXDEV")
      return cb(err);
    return moveAcrossDevice$1(src, dest, overwrite, cb);
  });
}
function moveAcrossDevice$1(src, dest, overwrite, cb) {
  const opts2 = {
    overwrite,
    errorOnExist: true
  };
  copy(src, dest, opts2, (err) => {
    if (err)
      return cb(err);
    return remove(src, cb);
  });
}
var move_1 = move$1;
const fs$3 = gracefulFs;
const path$d = require$$1__default$2["default"];
const copySync = copy$1.copySync;
const removeSync = remove_1.removeSync;
const mkdirpSync = mkdirs$2.mkdirpSync;
const stat = stat$4;
function moveSync(src, dest, opts2) {
  opts2 = opts2 || {};
  const overwrite = opts2.overwrite || opts2.clobber || false;
  const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, "move", opts2);
  stat.checkParentPathsSync(src, srcStat, dest, "move");
  if (!isParentRoot(dest))
    mkdirpSync(path$d.dirname(dest));
  return doRename(src, dest, overwrite, isChangingCase);
}
function isParentRoot(dest) {
  const parent = path$d.dirname(dest);
  const parsedPath = path$d.parse(parent);
  return parsedPath.root === parent;
}
function doRename(src, dest, overwrite, isChangingCase) {
  if (isChangingCase)
    return rename(src, dest, overwrite);
  if (overwrite) {
    removeSync(dest);
    return rename(src, dest, overwrite);
  }
  if (fs$3.existsSync(dest))
    throw new Error("dest already exists.");
  return rename(src, dest, overwrite);
}
function rename(src, dest, overwrite) {
  try {
    fs$3.renameSync(src, dest);
  } catch (err) {
    if (err.code !== "EXDEV")
      throw err;
    return moveAcrossDevice(src, dest, overwrite);
  }
}
function moveAcrossDevice(src, dest, overwrite) {
  const opts2 = {
    overwrite,
    errorOnExist: true
  };
  copySync(src, dest, opts2);
  return removeSync(src);
}
var moveSync_1 = moveSync;
const u = universalify$1.fromCallback;
var move = {
  move: u(move_1),
  moveSync: moveSync_1
};
var lib = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, fs$k), copy$1), empty), ensure), json$1), mkdirs$2), move), outputFile_1), pathExists_1), remove_1);
var AppUpdater$1 = {};
var jsYaml = {};
var loader$1 = {};
var common$5 = {};
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend(target, source2) {
  var index, length, key, sourceKeys;
  if (source2) {
    sourceKeys = Object.keys(source2);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source2[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
common$5.isNothing = isNothing;
common$5.isObject = isObject;
common$5.toArray = toArray;
common$5.repeat = repeat;
common$5.isNegativeZero = isNegativeZero;
common$5.extend = extend;
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark)
    return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$4(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$4.prototype = Object.create(Error.prototype);
YAMLException$4.prototype.constructor = YAMLException$4;
YAMLException$4.prototype.toString = function toString2(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$4;
var common$4 = common$5;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
  };
}
function padStart(string, max) {
  return common$4.repeat(" ", max - string.length) + string;
}
function makeSnippet$1(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer)
    return null;
  if (!options.maxLength)
    options.maxLength = 79;
  if (typeof options.indent !== "number")
    options.indent = 1;
  if (typeof options.linesBefore !== "number")
    options.linesBefore = 3;
  if (typeof options.linesAfter !== "number")
    options.linesAfter = 2;
  var re2 = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re2.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0)
    foundLineNo = lineStarts.length - 1;
  var result = "", i2, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i2 = 1; i2 <= options.linesBefore; i2++) {
    if (foundLineNo - i2 < 0)
      break;
    line = getLine(mark.buffer, lineStarts[foundLineNo - i2], lineEnds[foundLineNo - i2], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i2]), maxLineLength);
    result = common$4.repeat(" ", options.indent) + padStart((mark.line - i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common$4.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common$4.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i2 = 1; i2 <= options.linesAfter; i2++) {
    if (foundLineNo + i2 >= lineEnds.length)
      break;
    line = getLine(mark.buffer, lineStarts[foundLineNo + i2], lineEnds[foundLineNo + i2], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i2]), maxLineLength);
    result += common$4.repeat(" ", options.indent) + padStart((mark.line + i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet$1;
var YAMLException$3 = exception;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$e(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException$3('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException$3('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type$2 = Type$e;
var YAMLException$2 = exception;
var Type$d = type$2;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof Type$d) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit)
      implicit = implicit.concat(definition.implicit);
    if (definition.explicit)
      explicit = explicit.concat(definition.explicit);
  } else {
    throw new YAMLException$2("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type2) {
    if (!(type2 instanceof Type$d)) {
      throw new YAMLException$2("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type2.loadKind && type2.loadKind !== "scalar") {
      throw new YAMLException$2("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type2.multi) {
      throw new YAMLException$2("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type2) {
    if (!(type2 instanceof Type$d)) {
      throw new YAMLException$2("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema$2 = Schema$1;
var Type$c = type$2;
var str = new Type$c("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var Type$b = type$2;
var seq = new Type$b("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var Type$a = type$2;
var map = new Type$a("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var Schema = schema$2;
var failsafe = new Schema({
  explicit: [
    str,
    seq,
    map
  ]
});
var Type$9 = type$2;
function resolveYamlNull(data) {
  if (data === null)
    return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new Type$9("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
var Type$8 = type$2;
function resolveYamlBoolean(data) {
  if (data === null)
    return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new Type$8("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
var common$3 = common$5;
var Type$7 = type$2;
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null)
    return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max)
    return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max)
      return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_")
      continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o")
      return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common$3.isNegativeZero(object));
}
var int = new Type$7("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var common$2 = common$5;
var Type$6 = type$2;
var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
function resolveYamlFloat(data) {
  if (data === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common$2.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common$2.isNegativeZero(object));
}
var float = new Type$6("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core$3 = json;
var Type$5 = type$2;
var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null)
    match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null)
    throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new Type$5("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
var Type$4 = type$2;
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new Type$4("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var Type$3 = type$2;
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  var code2, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code2 = map2.indexOf(data.charAt(idx));
    if (code2 > 64)
      continue;
    if (code2 < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new Type$3("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var Type$2 = type$2;
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null)
    return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new Type$2("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var Type$1 = type$2;
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null)
    return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys = Object.keys(pair);
    if (keys.length !== 1)
      return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new Type$1("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var Type = type$2;
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null)
    return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new Type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core$3.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
var common$1 = common$5;
var YAMLException$1 = exception;
var makeSnippet = snippet;
var DEFAULT_SCHEMA$1 = _default;
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || DEFAULT_SCHEMA$1;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = makeSnippet(mark);
  return new YAMLException$1(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match, major2, minor2;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major2 = parseInt(match[1], 10);
    minor2 = parseInt(match[2], 10);
    if (major2 !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor2 < 2;
    if (minor2 !== 1 && minor2 !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source2, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common$1.isObject(source2)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source2);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source2[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common$1.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common$1.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common$1.repeat("\n", emptyLines);
      }
    } else {
      state.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = Object.create(null);
  state.anchorMap = Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll(input, iterator2, options) {
  if (iterator2 !== null && typeof iterator2 === "object" && typeof options === "undefined") {
    options = iterator2;
    iterator2 = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator2 !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator2(documents[index]);
  }
}
function load(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException$1("expected a single document in the stream, but found more");
}
loader$1.loadAll = loadAll;
loader$1.load = load;
var dumper$1 = {};
var common = common$5;
var YAMLException = exception;
var DEFAULT_SCHEMA = _default;
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null)
    return {};
  result = {};
  keys = Object.keys(map2);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1, QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || DEFAULT_SCHEMA;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n")
      result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (inblock ? cIsNsCharOrWhitespace : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar;
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i2;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
      char = codePointAt(string, i2);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
      char = codePointAt(string, i2);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i2;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new YAMLException("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ")
    return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
    char = codePointAt(string, i2);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i2];
      if (char >= 65536)
        result += string[i2 + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "")
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "")
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new YAMLException("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new YAMLException("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid)
        return false;
      throw new YAMLException("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(state.tag[0] === "!" ? state.tag.slice(1) : state.tag).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs)
    getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true))
    return state.dump + "\n";
  return "";
}
dumper$1.dump = dump;
var loader = loader$1;
var dumper = dumper$1;
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
jsYaml.Type = type$2;
jsYaml.Schema = schema$2;
jsYaml.FAILSAFE_SCHEMA = failsafe;
jsYaml.JSON_SCHEMA = json;
jsYaml.CORE_SCHEMA = core$3;
jsYaml.DEFAULT_SCHEMA = _default;
jsYaml.load = loader.load;
jsYaml.loadAll = loader.loadAll;
jsYaml.dump = dumper.dump;
jsYaml.YAMLException = exception;
jsYaml.types = {
  binary,
  float,
  map,
  null: _null,
  pairs,
  set,
  timestamp,
  bool,
  int,
  merge,
  omap,
  seq,
  str
};
jsYaml.safeLoad = renamed("safeLoad", "load");
jsYaml.safeLoadAll = renamed("safeLoadAll", "loadAll");
jsYaml.safeDump = renamed("safeDump", "dump");
var main = {};
Object.defineProperty(main, "__esModule", { value: true });
main.Lazy = void 0;
class Lazy {
  constructor(creator) {
    this._value = null;
    this.creator = creator;
  }
  get hasValue() {
    return this.creator == null;
  }
  get value() {
    if (this.creator == null) {
      return this._value;
    }
    const result = this.creator();
    this.value = result;
    return result;
  }
  set value(value) {
    this._value = value;
    this.creator = null;
  }
}
main.Lazy = Lazy;
var re$a = { exports: {} };
const SEMVER_SPEC_VERSION$1 = "2.0.0";
const MAX_LENGTH$4 = 256;
const MAX_SAFE_INTEGER$3 = Number.MAX_SAFE_INTEGER || 9007199254740991;
const MAX_SAFE_COMPONENT_LENGTH$1 = 16;
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH$4 - 6;
const RELEASE_TYPES = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var constants$2 = {
  MAX_LENGTH: MAX_LENGTH$4,
  MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH$1,
  MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$3,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION: SEMVER_SPEC_VERSION$1,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const debug$7 = typeof process === "object" && process.env && {}.NODE_DEBUG && /\bsemver\b/i.test({}.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
};
var debug_1$1 = debug$7;
(function(module, exports) {
  const { MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2, MAX_SAFE_BUILD_LENGTH: MAX_SAFE_BUILD_LENGTH2 } = constants$2;
  const debug2 = debug_1$1;
  exports = module.exports = {};
  const re2 = exports.re = [];
  const safeRe = exports.safeRe = [];
  const src = exports.src = [];
  const t2 = exports.t = {};
  let R = 0;
  const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  const safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_SAFE_COMPONENT_LENGTH2],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH2]
  ];
  const makeSafeRegex = (value) => {
    for (const [token, max] of safeRegexReplacements) {
      value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value;
  };
  const createToken = (name, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index = R++;
    debug2(name, index, value);
    t2[name] = index;
    src[index] = value;
    re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NUMERICIDENTIFIER]}|${src[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NUMERICIDENTIFIERLOOSE]}|${src[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`);
  createToken("FULL", `^${src[t2.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`);
  createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:$|[^\\d])`);
  createToken("COERCERTL", src[t2.COERCE], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(re$a, re$a.exports);
const looseOption = Object.freeze({ loose: true });
const emptyOpts = Object.freeze({});
const parseOptions$8 = (options) => {
  if (!options) {
    return emptyOpts;
  }
  if (typeof options !== "object") {
    return looseOption;
  }
  return options;
};
var parseOptions_1$1 = parseOptions$8;
const numeric$1 = /^[0-9]+$/;
const compareIdentifiers$3 = (a, b) => {
  const anum = numeric$1.test(a);
  const bnum = numeric$1.test(b);
  if (anum && bnum) {
    a = +a;
    b = +b;
  }
  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers$1 = (a, b) => compareIdentifiers$3(b, a);
var identifiers$2 = {
  compareIdentifiers: compareIdentifiers$3,
  rcompareIdentifiers: rcompareIdentifiers$1
};
const debug$6 = debug_1$1;
const { MAX_LENGTH: MAX_LENGTH$3, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$2 } = constants$2;
const { safeRe: re$9, t: t$8 } = re$a.exports;
const parseOptions$7 = parseOptions_1$1;
const { compareIdentifiers: compareIdentifiers$2 } = identifiers$2;
class SemVer$u {
  constructor(version, options) {
    options = parseOptions$7(options);
    if (version instanceof SemVer$u) {
      if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
    }
    if (version.length > MAX_LENGTH$3) {
      throw new TypeError(`version is longer than ${MAX_LENGTH$3} characters`);
    }
    debug$6("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    const m2 = version.trim().match(options.loose ? re$9[t$8.LOOSE] : re$9[t$8.FULL]);
    if (!m2) {
      throw new TypeError(`Invalid Version: ${version}`);
    }
    this.raw = version;
    this.major = +m2[1];
    this.minor = +m2[2];
    this.patch = +m2[3];
    if (this.major > MAX_SAFE_INTEGER$2 || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER$2 || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER$2 || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m2[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m2[4].split(".").map((id2) => {
        if (/^[0-9]+$/.test(id2)) {
          const num = +id2;
          if (num >= 0 && num < MAX_SAFE_INTEGER$2) {
            return num;
          }
        }
        return id2;
      });
    }
    this.build = m2[5] ? m2[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join(".")}`;
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug$6("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer$u)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer$u(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer$u)) {
      other = new SemVer$u(other, this.options);
    }
    return compareIdentifiers$2(this.major, other.major) || compareIdentifiers$2(this.minor, other.minor) || compareIdentifiers$2(this.patch, other.patch);
  }
  comparePre(other) {
    if (!(other instanceof SemVer$u)) {
      other = new SemVer$u(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    let i2 = 0;
    do {
      const a = this.prerelease[i2];
      const b = other.prerelease[i2];
      debug$6("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers$2(a, b);
      }
    } while (++i2);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer$u)) {
      other = new SemVer$u(other, this.options);
    }
    let i2 = 0;
    do {
      const a = this.build[i2];
      const b = other.build[i2];
      debug$6("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers$2(a, b);
      }
    } while (++i2);
  }
  inc(release, identifier, identifierBase) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier, identifierBase);
        this.inc("pre", identifier, identifierBase);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier, identifierBase);
        }
        this.inc("pre", identifier, identifierBase);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre": {
        const base = Number(identifierBase) ? 1 : 0;
        if (!identifier && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (this.prerelease.length === 0) {
          this.prerelease = [base];
        } else {
          let i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            if (identifier === this.prerelease.join(".") && identifierBase === false) {
              throw new Error("invalid increment argument: identifier already exists");
            }
            this.prerelease.push(base);
          }
        }
        if (identifier) {
          let prerelease2 = [identifier, base];
          if (identifierBase === false) {
            prerelease2 = [identifier];
          }
          if (compareIdentifiers$2(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease2;
            }
          } else {
            this.prerelease = prerelease2;
          }
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${release}`);
    }
    this.raw = this.format();
    if (this.build.length) {
      this.raw += `+${this.build.join(".")}`;
    }
    return this;
  }
}
var semver$4 = SemVer$u;
const SemVer$t = semver$4;
const parse$c = (version, options, throwErrors = false) => {
  if (version instanceof SemVer$t) {
    return version;
  }
  try {
    return new SemVer$t(version, options);
  } catch (er) {
    if (!throwErrors) {
      return null;
    }
    throw er;
  }
};
var parse_1$1 = parse$c;
const parse$b = parse_1$1;
const valid$4 = (version, options) => {
  const v = parse$b(version, options);
  return v ? v.version : null;
};
var valid_1$1 = valid$4;
const parse$a = parse_1$1;
const clean$2 = (version, options) => {
  const s2 = parse$a(version.trim().replace(/^[=v]+/, ""), options);
  return s2 ? s2.version : null;
};
var clean_1$1 = clean$2;
const SemVer$s = semver$4;
const inc$2 = (version, release, options, identifier, identifierBase) => {
  if (typeof options === "string") {
    identifierBase = identifier;
    identifier = options;
    options = void 0;
  }
  try {
    return new SemVer$s(version instanceof SemVer$s ? version.version : version, options).inc(release, identifier, identifierBase).version;
  } catch (er) {
    return null;
  }
};
var inc_1$1 = inc$2;
const parse$9 = parse_1$1;
const diff$2 = (version1, version2) => {
  const v1 = parse$9(version1, null, true);
  const v2 = parse$9(version2, null, true);
  const comparison = v1.compare(v2);
  if (comparison === 0) {
    return null;
  }
  const v1Higher = comparison > 0;
  const highVersion = v1Higher ? v1 : v2;
  const lowVersion = v1Higher ? v2 : v1;
  const highHasPre = !!highVersion.prerelease.length;
  const lowHasPre = !!lowVersion.prerelease.length;
  if (lowHasPre && !highHasPre) {
    if (!lowVersion.patch && !lowVersion.minor) {
      return "major";
    }
    if (highVersion.patch) {
      return "patch";
    }
    if (highVersion.minor) {
      return "minor";
    }
    return "major";
  }
  const prefix = highHasPre ? "pre" : "";
  if (v1.major !== v2.major) {
    return prefix + "major";
  }
  if (v1.minor !== v2.minor) {
    return prefix + "minor";
  }
  if (v1.patch !== v2.patch) {
    return prefix + "patch";
  }
  return "prerelease";
};
var diff_1$1 = diff$2;
const SemVer$r = semver$4;
const major$2 = (a, loose) => new SemVer$r(a, loose).major;
var major_1$1 = major$2;
const SemVer$q = semver$4;
const minor$2 = (a, loose) => new SemVer$q(a, loose).minor;
var minor_1$1 = minor$2;
const SemVer$p = semver$4;
const patch$2 = (a, loose) => new SemVer$p(a, loose).patch;
var patch_1$1 = patch$2;
const parse$8 = parse_1$1;
const prerelease$2 = (version, options) => {
  const parsed = parse$8(version, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
var prerelease_1$1 = prerelease$2;
const SemVer$o = semver$4;
const compare$m = (a, b, loose) => new SemVer$o(a, loose).compare(new SemVer$o(b, loose));
var compare_1$1 = compare$m;
const compare$l = compare_1$1;
const rcompare$2 = (a, b, loose) => compare$l(b, a, loose);
var rcompare_1$1 = rcompare$2;
const compare$k = compare_1$1;
const compareLoose$2 = (a, b) => compare$k(a, b, true);
var compareLoose_1$1 = compareLoose$2;
const SemVer$n = semver$4;
const compareBuild$6 = (a, b, loose) => {
  const versionA = new SemVer$n(a, loose);
  const versionB = new SemVer$n(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
var compareBuild_1$1 = compareBuild$6;
const compareBuild$5 = compareBuild_1$1;
const sort$2 = (list, loose) => list.sort((a, b) => compareBuild$5(a, b, loose));
var sort_1$1 = sort$2;
const compareBuild$4 = compareBuild_1$1;
const rsort$2 = (list, loose) => list.sort((a, b) => compareBuild$4(b, a, loose));
var rsort_1$1 = rsort$2;
const compare$j = compare_1$1;
const gt$8 = (a, b, loose) => compare$j(a, b, loose) > 0;
var gt_1$1 = gt$8;
const compare$i = compare_1$1;
const lt$6 = (a, b, loose) => compare$i(a, b, loose) < 0;
var lt_1$1 = lt$6;
const compare$h = compare_1$1;
const eq$5 = (a, b, loose) => compare$h(a, b, loose) === 0;
var eq_1$1 = eq$5;
const compare$g = compare_1$1;
const neq$4 = (a, b, loose) => compare$g(a, b, loose) !== 0;
var neq_1$1 = neq$4;
const compare$f = compare_1$1;
const gte$6 = (a, b, loose) => compare$f(a, b, loose) >= 0;
var gte_1$1 = gte$6;
const compare$e = compare_1$1;
const lte$6 = (a, b, loose) => compare$e(a, b, loose) <= 0;
var lte_1$1 = lte$6;
const eq$4 = eq_1$1;
const neq$3 = neq_1$1;
const gt$7 = gt_1$1;
const gte$5 = gte_1$1;
const lt$5 = lt_1$1;
const lte$5 = lte_1$1;
const cmp$4 = (a, op, b, loose) => {
  switch (op) {
    case "===":
      if (typeof a === "object") {
        a = a.version;
      }
      if (typeof b === "object") {
        b = b.version;
      }
      return a === b;
    case "!==":
      if (typeof a === "object") {
        a = a.version;
      }
      if (typeof b === "object") {
        b = b.version;
      }
      return a !== b;
    case "":
    case "=":
    case "==":
      return eq$4(a, b, loose);
    case "!=":
      return neq$3(a, b, loose);
    case ">":
      return gt$7(a, b, loose);
    case ">=":
      return gte$5(a, b, loose);
    case "<":
      return lt$5(a, b, loose);
    case "<=":
      return lte$5(a, b, loose);
    default:
      throw new TypeError(`Invalid operator: ${op}`);
  }
};
var cmp_1$1 = cmp$4;
const SemVer$m = semver$4;
const parse$7 = parse_1$1;
const { safeRe: re$8, t: t$7 } = re$a.exports;
const coerce$2 = (version, options) => {
  if (version instanceof SemVer$m) {
    return version;
  }
  if (typeof version === "number") {
    version = String(version);
  }
  if (typeof version !== "string") {
    return null;
  }
  options = options || {};
  let match = null;
  if (!options.rtl) {
    match = version.match(re$8[t$7.COERCE]);
  } else {
    let next;
    while ((next = re$8[t$7.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      re$8[t$7.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
    }
    re$8[t$7.COERCERTL].lastIndex = -1;
  }
  if (match === null) {
    return null;
  }
  return parse$7(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
};
var coerce_1$1 = coerce$2;
var iterator = function(Yallist2) {
  Yallist2.prototype[Symbol.iterator] = function* () {
    for (let walker = this.head; walker; walker = walker.next) {
      yield walker.value;
    }
  };
};
var yallist = Yallist$1;
Yallist$1.Node = Node;
Yallist$1.create = Yallist$1;
function Yallist$1(list) {
  var self2 = this;
  if (!(self2 instanceof Yallist$1)) {
    self2 = new Yallist$1();
  }
  self2.tail = null;
  self2.head = null;
  self2.length = 0;
  if (list && typeof list.forEach === "function") {
    list.forEach(function(item) {
      self2.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
      self2.push(arguments[i2]);
    }
  }
  return self2;
}
Yallist$1.prototype.removeNode = function(node) {
  if (node.list !== this) {
    throw new Error("removing node which does not belong to this list");
  }
  var next = node.next;
  var prev = node.prev;
  if (next) {
    next.prev = prev;
  }
  if (prev) {
    prev.next = next;
  }
  if (node === this.head) {
    this.head = next;
  }
  if (node === this.tail) {
    this.tail = prev;
  }
  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;
  return next;
};
Yallist$1.prototype.unshiftNode = function(node) {
  if (node === this.head) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var head = this.head;
  node.list = this;
  node.next = head;
  if (head) {
    head.prev = node;
  }
  this.head = node;
  if (!this.tail) {
    this.tail = node;
  }
  this.length++;
};
Yallist$1.prototype.pushNode = function(node) {
  if (node === this.tail) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var tail = this.tail;
  node.list = this;
  node.prev = tail;
  if (tail) {
    tail.next = node;
  }
  this.tail = node;
  if (!this.head) {
    this.head = node;
  }
  this.length++;
};
Yallist$1.prototype.push = function() {
  for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
    push(this, arguments[i2]);
  }
  return this.length;
};
Yallist$1.prototype.unshift = function() {
  for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
    unshift(this, arguments[i2]);
  }
  return this.length;
};
Yallist$1.prototype.pop = function() {
  if (!this.tail) {
    return void 0;
  }
  var res = this.tail.value;
  this.tail = this.tail.prev;
  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.shift = function() {
  if (!this.head) {
    return void 0;
  }
  var res = this.head.value;
  this.head = this.head.next;
  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.forEach = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.head, i2 = 0; walker !== null; i2++) {
    fn.call(thisp, walker.value, i2, this);
    walker = walker.next;
  }
};
Yallist$1.prototype.forEachReverse = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.tail, i2 = this.length - 1; walker !== null; i2--) {
    fn.call(thisp, walker.value, i2, this);
    walker = walker.prev;
  }
};
Yallist$1.prototype.get = function(n) {
  for (var i2 = 0, walker = this.head; walker !== null && i2 < n; i2++) {
    walker = walker.next;
  }
  if (i2 === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.getReverse = function(n) {
  for (var i2 = 0, walker = this.tail; walker !== null && i2 < n; i2++) {
    walker = walker.prev;
  }
  if (i2 === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.map = function(fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.head; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }
  return res;
};
Yallist$1.prototype.mapReverse = function(fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.tail; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }
  return res;
};
Yallist$1.prototype.reduce = function(fn, initial) {
  var acc;
  var walker = this.head;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i2 = 0; walker !== null; i2++) {
    acc = fn(acc, walker.value, i2);
    walker = walker.next;
  }
  return acc;
};
Yallist$1.prototype.reduceReverse = function(fn, initial) {
  var acc;
  var walker = this.tail;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i2 = this.length - 1; walker !== null; i2--) {
    acc = fn(acc, walker.value, i2);
    walker = walker.prev;
  }
  return acc;
};
Yallist$1.prototype.toArray = function() {
  var arr = new Array(this.length);
  for (var i2 = 0, walker = this.head; walker !== null; i2++) {
    arr[i2] = walker.value;
    walker = walker.next;
  }
  return arr;
};
Yallist$1.prototype.toArrayReverse = function() {
  var arr = new Array(this.length);
  for (var i2 = 0, walker = this.tail; walker !== null; i2++) {
    arr[i2] = walker.value;
    walker = walker.prev;
  }
  return arr;
};
Yallist$1.prototype.slice = function(from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i2 = 0, walker = this.head; walker !== null && i2 < from; i2++) {
    walker = walker.next;
  }
  for (; walker !== null && i2 < to; i2++, walker = walker.next) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.sliceReverse = function(from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i2 = this.length, walker = this.tail; walker !== null && i2 > to; i2--) {
    walker = walker.prev;
  }
  for (; walker !== null && i2 > from; i2--, walker = walker.prev) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.splice = function(start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1;
  }
  if (start < 0) {
    start = this.length + start;
  }
  for (var i2 = 0, walker = this.head; walker !== null && i2 < start; i2++) {
    walker = walker.next;
  }
  var ret = [];
  for (var i2 = 0; walker && i2 < deleteCount; i2++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }
  if (walker === null) {
    walker = this.tail;
  }
  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }
  for (var i2 = 0; i2 < nodes.length; i2++) {
    walker = insert(this, walker, nodes[i2]);
  }
  return ret;
};
Yallist$1.prototype.reverse = function() {
  var head = this.head;
  var tail = this.tail;
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }
  this.head = tail;
  this.tail = head;
  return this;
};
function insert(self2, node, value) {
  var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
  if (inserted.next === null) {
    self2.tail = inserted;
  }
  if (inserted.prev === null) {
    self2.head = inserted;
  }
  self2.length++;
  return inserted;
}
function push(self2, item) {
  self2.tail = new Node(item, self2.tail, null, self2);
  if (!self2.head) {
    self2.head = self2.tail;
  }
  self2.length++;
}
function unshift(self2, item) {
  self2.head = new Node(item, null, self2.head, self2);
  if (!self2.tail) {
    self2.tail = self2.head;
  }
  self2.length++;
}
function Node(value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list);
  }
  this.list = list;
  this.value = value;
  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }
  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}
try {
  iterator(Yallist$1);
} catch (er) {
}
const Yallist = yallist;
const MAX = Symbol("max");
const LENGTH = Symbol("length");
const LENGTH_CALCULATOR = Symbol("lengthCalculator");
const ALLOW_STALE = Symbol("allowStale");
const MAX_AGE = Symbol("maxAge");
const DISPOSE = Symbol("dispose");
const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
const LRU_LIST = Symbol("lruList");
const CACHE = Symbol("cache");
const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
const naiveLength = () => 1;
class LRUCache {
  constructor(options) {
    if (typeof options === "number")
      options = { max: options };
    if (!options)
      options = {};
    if (options.max && (typeof options.max !== "number" || options.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[MAX] = options.max || Infinity;
    const lc = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  }
  set max(mL) {
    if (typeof mL !== "number" || mL < 0)
      throw new TypeError("max must be a non-negative number");
    this[MAX] = mL || Infinity;
    trim(this);
  }
  get max() {
    return this[MAX];
  }
  set allowStale(allowStale) {
    this[ALLOW_STALE] = !!allowStale;
  }
  get allowStale() {
    return this[ALLOW_STALE];
  }
  set maxAge(mA) {
    if (typeof mA !== "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[MAX_AGE] = mA;
    trim(this);
  }
  get maxAge() {
    return this[MAX_AGE];
  }
  set lengthCalculator(lC) {
    if (typeof lC !== "function")
      lC = naiveLength;
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC;
      this[LENGTH] = 0;
      this[LRU_LIST].forEach((hit) => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
        this[LENGTH] += hit.length;
      });
    }
    trim(this);
  }
  get lengthCalculator() {
    return this[LENGTH_CALCULATOR];
  }
  get length() {
    return this[LENGTH];
  }
  get itemCount() {
    return this[LRU_LIST].length;
  }
  rforEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].tail; walker !== null; ) {
      const prev = walker.prev;
      forEachStep(this, fn, walker, thisp);
      walker = prev;
    }
  }
  forEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].head; walker !== null; ) {
      const next = walker.next;
      forEachStep(this, fn, walker, thisp);
      walker = next;
    }
  }
  keys() {
    return this[LRU_LIST].toArray().map((k) => k.key);
  }
  values() {
    return this[LRU_LIST].toArray().map((k) => k.value);
  }
  reset() {
    if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
      this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
    }
    this[CACHE] = new Map();
    this[LRU_LIST] = new Yallist();
    this[LENGTH] = 0;
  }
  dump() {
    return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
      k: hit.key,
      v: hit.value,
      e: hit.now + (hit.maxAge || 0)
    }).toArray().filter((h2) => h2);
  }
  dumpLru() {
    return this[LRU_LIST];
  }
  set(key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE];
    if (maxAge && typeof maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    const now = maxAge ? Date.now() : 0;
    const len = this[LENGTH_CALCULATOR](value, key);
    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key));
        return false;
      }
      const node = this[CACHE].get(key);
      const item = node.value;
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value);
      }
      item.now = now;
      item.maxAge = maxAge;
      item.value = value;
      this[LENGTH] += len - item.length;
      item.length = len;
      this.get(key);
      trim(this);
      return true;
    }
    const hit = new Entry(key, value, len, now, maxAge);
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value);
      return false;
    }
    this[LENGTH] += hit.length;
    this[LRU_LIST].unshift(hit);
    this[CACHE].set(key, this[LRU_LIST].head);
    trim(this);
    return true;
  }
  has(key) {
    if (!this[CACHE].has(key))
      return false;
    const hit = this[CACHE].get(key).value;
    return !isStale(this, hit);
  }
  get(key) {
    return get(this, key, true);
  }
  peek(key) {
    return get(this, key, false);
  }
  pop() {
    const node = this[LRU_LIST].tail;
    if (!node)
      return null;
    del(this, node);
    return node.value;
  }
  del(key) {
    del(this, this[CACHE].get(key));
  }
  load(arr) {
    this.reset();
    const now = Date.now();
    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l];
      const expiresAt = hit.e || 0;
      if (expiresAt === 0)
        this.set(hit.k, hit.v);
      else {
        const maxAge = expiresAt - now;
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge);
        }
      }
    }
  }
  prune() {
    this[CACHE].forEach((value, key) => get(this, key, false));
  }
}
const get = (self2, key, doUse) => {
  const node = self2[CACHE].get(key);
  if (node) {
    const hit = node.value;
    if (isStale(self2, hit)) {
      del(self2, node);
      if (!self2[ALLOW_STALE])
        return void 0;
    } else {
      if (doUse) {
        if (self2[UPDATE_AGE_ON_GET])
          node.value.now = Date.now();
        self2[LRU_LIST].unshiftNode(node);
      }
    }
    return hit.value;
  }
};
const isStale = (self2, hit) => {
  if (!hit || !hit.maxAge && !self2[MAX_AGE])
    return false;
  const diff2 = Date.now() - hit.now;
  return hit.maxAge ? diff2 > hit.maxAge : self2[MAX_AGE] && diff2 > self2[MAX_AGE];
};
const trim = (self2) => {
  if (self2[LENGTH] > self2[MAX]) {
    for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
      const prev = walker.prev;
      del(self2, walker);
      walker = prev;
    }
  }
};
const del = (self2, node) => {
  if (node) {
    const hit = node.value;
    if (self2[DISPOSE])
      self2[DISPOSE](hit.key, hit.value);
    self2[LENGTH] -= hit.length;
    self2[CACHE].delete(hit.key);
    self2[LRU_LIST].removeNode(node);
  }
};
class Entry {
  constructor(key, value, length, now, maxAge) {
    this.key = key;
    this.value = value;
    this.length = length;
    this.now = now;
    this.maxAge = maxAge || 0;
  }
}
const forEachStep = (self2, fn, node, thisp) => {
  let hit = node.value;
  if (isStale(self2, hit)) {
    del(self2, node);
    if (!self2[ALLOW_STALE])
      hit = void 0;
  }
  if (hit)
    fn.call(thisp, hit.value, hit.key, self2);
};
var lruCache = LRUCache;
class Range$m {
  constructor(range2, options) {
    options = parseOptions$6(options);
    if (range2 instanceof Range$m) {
      if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
        return range2;
      } else {
        return new Range$m(range2.raw, options);
      }
    }
    if (range2 instanceof Comparator$8) {
      this.raw = range2.value;
      this.set = [[range2]];
      this.format();
      return this;
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range2.trim().split(/\s+/).join(" ");
    this.set = this.raw.split("||").map((r) => this.parseRange(r)).filter((c) => c.length);
    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
    }
    if (this.set.length > 1) {
      const first = this.set[0];
      this.set = this.set.filter((c) => !isNullSet$1(c[0]));
      if (this.set.length === 0) {
        this.set = [first];
      } else if (this.set.length > 1) {
        for (const c of this.set) {
          if (c.length === 1 && isAny$1(c[0])) {
            this.set = [c];
            break;
          }
        }
      }
    }
    this.format();
  }
  format() {
    this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
    return this.range;
  }
  toString() {
    return this.range;
  }
  parseRange(range2) {
    const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
    const memoKey = memoOpts + ":" + range2;
    const cached = cache$1.get(memoKey);
    if (cached) {
      return cached;
    }
    const loose = this.options.loose;
    const hr = loose ? re$7[t$6.HYPHENRANGELOOSE] : re$7[t$6.HYPHENRANGE];
    range2 = range2.replace(hr, hyphenReplace$1(this.options.includePrerelease));
    debug$5("hyphen replace", range2);
    range2 = range2.replace(re$7[t$6.COMPARATORTRIM], comparatorTrimReplace$1);
    debug$5("comparator trim", range2);
    range2 = range2.replace(re$7[t$6.TILDETRIM], tildeTrimReplace$1);
    debug$5("tilde trim", range2);
    range2 = range2.replace(re$7[t$6.CARETTRIM], caretTrimReplace$1);
    debug$5("caret trim", range2);
    let rangeList = range2.split(" ").map((comp) => parseComparator$1(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0$1(comp, this.options));
    if (loose) {
      rangeList = rangeList.filter((comp) => {
        debug$5("loose invalid filter", comp, this.options);
        return !!comp.match(re$7[t$6.COMPARATORLOOSE]);
      });
    }
    debug$5("range list", rangeList);
    const rangeMap = new Map();
    const comparators = rangeList.map((comp) => new Comparator$8(comp, this.options));
    for (const comp of comparators) {
      if (isNullSet$1(comp)) {
        return [comp];
      }
      rangeMap.set(comp.value, comp);
    }
    if (rangeMap.size > 1 && rangeMap.has("")) {
      rangeMap.delete("");
    }
    const result = [...rangeMap.values()];
    cache$1.set(memoKey, result);
    return result;
  }
  intersects(range2, options) {
    if (!(range2 instanceof Range$m)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some((thisComparators) => {
      return isSatisfiable$1(thisComparators, options) && range2.set.some((rangeComparators) => {
        return isSatisfiable$1(rangeComparators, options) && thisComparators.every((thisComparator) => {
          return rangeComparators.every((rangeComparator) => {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  }
  test(version) {
    if (!version) {
      return false;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer$l(version, this.options);
      } catch (er) {
        return false;
      }
    }
    for (let i2 = 0; i2 < this.set.length; i2++) {
      if (testSet$1(this.set[i2], version, this.options)) {
        return true;
      }
    }
    return false;
  }
}
var range$1 = Range$m;
const LRU$1 = lruCache;
const cache$1 = new LRU$1({ max: 1e3 });
const parseOptions$6 = parseOptions_1$1;
const Comparator$8 = comparator$1;
const debug$5 = debug_1$1;
const SemVer$l = semver$4;
const {
  safeRe: re$7,
  t: t$6,
  comparatorTrimReplace: comparatorTrimReplace$1,
  tildeTrimReplace: tildeTrimReplace$1,
  caretTrimReplace: caretTrimReplace$1
} = re$a.exports;
const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = constants$2;
const isNullSet$1 = (c) => c.value === "<0.0.0-0";
const isAny$1 = (c) => c.value === "";
const isSatisfiable$1 = (comparators, options) => {
  let result = true;
  const remainingComparators = comparators.slice();
  let testComparator = remainingComparators.pop();
  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options);
    });
    testComparator = remainingComparators.pop();
  }
  return result;
};
const parseComparator$1 = (comp, options) => {
  debug$5("comp", comp, options);
  comp = replaceCarets$1(comp, options);
  debug$5("caret", comp);
  comp = replaceTildes$1(comp, options);
  debug$5("tildes", comp);
  comp = replaceXRanges$1(comp, options);
  debug$5("xrange", comp);
  comp = replaceStars$1(comp, options);
  debug$5("stars", comp);
  return comp;
};
const isX$1 = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
const replaceTildes$1 = (comp, options) => {
  return comp.trim().split(/\s+/).map((c) => replaceTilde$1(c, options)).join(" ");
};
const replaceTilde$1 = (comp, options) => {
  const r = options.loose ? re$7[t$6.TILDELOOSE] : re$7[t$6.TILDE];
  return comp.replace(r, (_, M, m2, p, pr) => {
    debug$5("tilde", comp, _, M, m2, p, pr);
    let ret;
    if (isX$1(M)) {
      ret = "";
    } else if (isX$1(m2)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
    } else if (isX$1(p)) {
      ret = `>=${M}.${m2}.0 <${M}.${+m2 + 1}.0-0`;
    } else if (pr) {
      debug$5("replaceTilde pr", pr);
      ret = `>=${M}.${m2}.${p}-${pr} <${M}.${+m2 + 1}.0-0`;
    } else {
      ret = `>=${M}.${m2}.${p} <${M}.${+m2 + 1}.0-0`;
    }
    debug$5("tilde return", ret);
    return ret;
  });
};
const replaceCarets$1 = (comp, options) => {
  return comp.trim().split(/\s+/).map((c) => replaceCaret$1(c, options)).join(" ");
};
const replaceCaret$1 = (comp, options) => {
  debug$5("caret", comp, options);
  const r = options.loose ? re$7[t$6.CARETLOOSE] : re$7[t$6.CARET];
  const z = options.includePrerelease ? "-0" : "";
  return comp.replace(r, (_, M, m2, p, pr) => {
    debug$5("caret", comp, _, M, m2, p, pr);
    let ret;
    if (isX$1(M)) {
      ret = "";
    } else if (isX$1(m2)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
    } else if (isX$1(p)) {
      if (M === "0") {
        ret = `>=${M}.${m2}.0${z} <${M}.${+m2 + 1}.0-0`;
      } else {
        ret = `>=${M}.${m2}.0${z} <${+M + 1}.0.0-0`;
      }
    } else if (pr) {
      debug$5("replaceCaret pr", pr);
      if (M === "0") {
        if (m2 === "0") {
          ret = `>=${M}.${m2}.${p}-${pr} <${M}.${m2}.${+p + 1}-0`;
        } else {
          ret = `>=${M}.${m2}.${p}-${pr} <${M}.${+m2 + 1}.0-0`;
        }
      } else {
        ret = `>=${M}.${m2}.${p}-${pr} <${+M + 1}.0.0-0`;
      }
    } else {
      debug$5("no pr");
      if (M === "0") {
        if (m2 === "0") {
          ret = `>=${M}.${m2}.${p}${z} <${M}.${m2}.${+p + 1}-0`;
        } else {
          ret = `>=${M}.${m2}.${p}${z} <${M}.${+m2 + 1}.0-0`;
        }
      } else {
        ret = `>=${M}.${m2}.${p} <${+M + 1}.0.0-0`;
      }
    }
    debug$5("caret return", ret);
    return ret;
  });
};
const replaceXRanges$1 = (comp, options) => {
  debug$5("replaceXRanges", comp, options);
  return comp.split(/\s+/).map((c) => replaceXRange$1(c, options)).join(" ");
};
const replaceXRange$1 = (comp, options) => {
  comp = comp.trim();
  const r = options.loose ? re$7[t$6.XRANGELOOSE] : re$7[t$6.XRANGE];
  return comp.replace(r, (ret, gtlt, M, m2, p, pr) => {
    debug$5("xRange", comp, ret, gtlt, M, m2, p, pr);
    const xM = isX$1(M);
    const xm = xM || isX$1(m2);
    const xp = xm || isX$1(p);
    const anyX = xp;
    if (gtlt === "=" && anyX) {
      gtlt = "";
    }
    pr = options.includePrerelease ? "-0" : "";
    if (xM) {
      if (gtlt === ">" || gtlt === "<") {
        ret = "<0.0.0-0";
      } else {
        ret = "*";
      }
    } else if (gtlt && anyX) {
      if (xm) {
        m2 = 0;
      }
      p = 0;
      if (gtlt === ">") {
        gtlt = ">=";
        if (xm) {
          M = +M + 1;
          m2 = 0;
          p = 0;
        } else {
          m2 = +m2 + 1;
          p = 0;
        }
      } else if (gtlt === "<=") {
        gtlt = "<";
        if (xm) {
          M = +M + 1;
        } else {
          m2 = +m2 + 1;
        }
      }
      if (gtlt === "<") {
        pr = "-0";
      }
      ret = `${gtlt + M}.${m2}.${p}${pr}`;
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
    } else if (xp) {
      ret = `>=${M}.${m2}.0${pr} <${M}.${+m2 + 1}.0-0`;
    }
    debug$5("xRange return", ret);
    return ret;
  });
};
const replaceStars$1 = (comp, options) => {
  debug$5("replaceStars", comp, options);
  return comp.trim().replace(re$7[t$6.STAR], "");
};
const replaceGTE0$1 = (comp, options) => {
  debug$5("replaceGTE0", comp, options);
  return comp.trim().replace(re$7[options.includePrerelease ? t$6.GTE0PRE : t$6.GTE0], "");
};
const hyphenReplace$1 = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
  if (isX$1(fM)) {
    from = "";
  } else if (isX$1(fm)) {
    from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
  } else if (isX$1(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
  } else if (fpr) {
    from = `>=${from}`;
  } else {
    from = `>=${from}${incPr ? "-0" : ""}`;
  }
  if (isX$1(tM)) {
    to = "";
  } else if (isX$1(tm)) {
    to = `<${+tM + 1}.0.0-0`;
  } else if (isX$1(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`;
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`;
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`;
  } else {
    to = `<=${to}`;
  }
  return `${from} ${to}`.trim();
};
const testSet$1 = (set2, version, options) => {
  for (let i2 = 0; i2 < set2.length; i2++) {
    if (!set2[i2].test(version)) {
      return false;
    }
  }
  if (version.prerelease.length && !options.includePrerelease) {
    for (let i2 = 0; i2 < set2.length; i2++) {
      debug$5(set2[i2].semver);
      if (set2[i2].semver === Comparator$8.ANY) {
        continue;
      }
      if (set2[i2].semver.prerelease.length > 0) {
        const allowed = set2[i2].semver;
        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
          return true;
        }
      }
    }
    return false;
  }
  return true;
};
const ANY$5 = Symbol("SemVer ANY");
class Comparator$7 {
  static get ANY() {
    return ANY$5;
  }
  constructor(comp, options) {
    options = parseOptions$5(options);
    if (comp instanceof Comparator$7) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    comp = comp.trim().split(/\s+/).join(" ");
    debug$4("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY$5) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug$4("comp", this);
  }
  parse(comp) {
    const r = this.options.loose ? re$6[t$5.COMPARATORLOOSE] : re$6[t$5.COMPARATOR];
    const m2 = comp.match(r);
    if (!m2) {
      throw new TypeError(`Invalid comparator: ${comp}`);
    }
    this.operator = m2[1] !== void 0 ? m2[1] : "";
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m2[2]) {
      this.semver = ANY$5;
    } else {
      this.semver = new SemVer$k(m2[2], this.options.loose);
    }
  }
  toString() {
    return this.value;
  }
  test(version) {
    debug$4("Comparator.test", version, this.options.loose);
    if (this.semver === ANY$5 || version === ANY$5) {
      return true;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer$k(version, this.options);
      } catch (er) {
        return false;
      }
    }
    return cmp$3(version, this.operator, this.semver, this.options);
  }
  intersects(comp, options) {
    if (!(comp instanceof Comparator$7)) {
      throw new TypeError("a Comparator is required");
    }
    if (this.operator === "") {
      if (this.value === "") {
        return true;
      }
      return new Range$l(comp.value, options).test(this.value);
    } else if (comp.operator === "") {
      if (comp.value === "") {
        return true;
      }
      return new Range$l(this.value, options).test(comp.semver);
    }
    options = parseOptions$5(options);
    if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
      return false;
    }
    if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
      return false;
    }
    if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
      return true;
    }
    if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
      return true;
    }
    if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
      return true;
    }
    if (cmp$3(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
      return true;
    }
    if (cmp$3(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
      return true;
    }
    return false;
  }
}
var comparator$1 = Comparator$7;
const parseOptions$5 = parseOptions_1$1;
const { safeRe: re$6, t: t$5 } = re$a.exports;
const cmp$3 = cmp_1$1;
const debug$4 = debug_1$1;
const SemVer$k = semver$4;
const Range$l = range$1;
const Range$k = range$1;
const satisfies$8 = (version, range2, options) => {
  try {
    range2 = new Range$k(range2, options);
  } catch (er) {
    return false;
  }
  return range2.test(version);
};
var satisfies_1$1 = satisfies$8;
const Range$j = range$1;
const toComparators$2 = (range2, options) => new Range$j(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
var toComparators_1$1 = toComparators$2;
const SemVer$j = semver$4;
const Range$i = range$1;
const maxSatisfying$2 = (versions, range2, options) => {
  let max = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$i(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!max || maxSV.compare(v) === -1) {
        max = v;
        maxSV = new SemVer$j(max, options);
      }
    }
  });
  return max;
};
var maxSatisfying_1$1 = maxSatisfying$2;
const SemVer$i = semver$4;
const Range$h = range$1;
const minSatisfying$2 = (versions, range2, options) => {
  let min = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$h(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!min || minSV.compare(v) === 1) {
        min = v;
        minSV = new SemVer$i(min, options);
      }
    }
  });
  return min;
};
var minSatisfying_1$1 = minSatisfying$2;
const SemVer$h = semver$4;
const Range$g = range$1;
const gt$6 = gt_1$1;
const minVersion$2 = (range2, loose) => {
  range2 = new Range$g(range2, loose);
  let minver = new SemVer$h("0.0.0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = new SemVer$h("0.0.0-0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = null;
  for (let i2 = 0; i2 < range2.set.length; ++i2) {
    const comparators = range2.set[i2];
    let setMin = null;
    comparators.forEach((comparator2) => {
      const compver = new SemVer$h(comparator2.semver.version);
      switch (comparator2.operator) {
        case ">":
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
        case "":
        case ">=":
          if (!setMin || gt$6(compver, setMin)) {
            setMin = compver;
          }
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${comparator2.operator}`);
      }
    });
    if (setMin && (!minver || gt$6(minver, setMin))) {
      minver = setMin;
    }
  }
  if (minver && range2.test(minver)) {
    return minver;
  }
  return null;
};
var minVersion_1$1 = minVersion$2;
const Range$f = range$1;
const validRange$2 = (range2, options) => {
  try {
    return new Range$f(range2, options).range || "*";
  } catch (er) {
    return null;
  }
};
var valid$3 = validRange$2;
const SemVer$g = semver$4;
const Comparator$6 = comparator$1;
const { ANY: ANY$4 } = Comparator$6;
const Range$e = range$1;
const satisfies$7 = satisfies_1$1;
const gt$5 = gt_1$1;
const lt$4 = lt_1$1;
const lte$4 = lte_1$1;
const gte$4 = gte_1$1;
const outside$6 = (version, range2, hilo, options) => {
  version = new SemVer$g(version, options);
  range2 = new Range$e(range2, options);
  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case ">":
      gtfn = gt$5;
      ltefn = lte$4;
      ltfn = lt$4;
      comp = ">";
      ecomp = ">=";
      break;
    case "<":
      gtfn = lt$4;
      ltefn = gte$4;
      ltfn = gt$5;
      comp = "<";
      ecomp = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (satisfies$7(version, range2, options)) {
    return false;
  }
  for (let i2 = 0; i2 < range2.set.length; ++i2) {
    const comparators = range2.set[i2];
    let high = null;
    let low = null;
    comparators.forEach((comparator2) => {
      if (comparator2.semver === ANY$4) {
        comparator2 = new Comparator$6(">=0.0.0");
      }
      high = high || comparator2;
      low = low || comparator2;
      if (gtfn(comparator2.semver, high.semver, options)) {
        high = comparator2;
      } else if (ltfn(comparator2.semver, low.semver, options)) {
        low = comparator2;
      }
    });
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }
    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }
  return true;
};
var outside_1$1 = outside$6;
const outside$5 = outside_1$1;
const gtr$2 = (version, range2, options) => outside$5(version, range2, ">", options);
var gtr_1$1 = gtr$2;
const outside$4 = outside_1$1;
const ltr$2 = (version, range2, options) => outside$4(version, range2, "<", options);
var ltr_1$1 = ltr$2;
const Range$d = range$1;
const intersects$2 = (r1, r2, options) => {
  r1 = new Range$d(r1, options);
  r2 = new Range$d(r2, options);
  return r1.intersects(r2, options);
};
var intersects_1$1 = intersects$2;
const satisfies$6 = satisfies_1$1;
const compare$d = compare_1$1;
var simplify$1 = (versions, range2, options) => {
  const set2 = [];
  let first = null;
  let prev = null;
  const v = versions.sort((a, b) => compare$d(a, b, options));
  for (const version of v) {
    const included = satisfies$6(version, range2, options);
    if (included) {
      prev = version;
      if (!first) {
        first = version;
      }
    } else {
      if (prev) {
        set2.push([first, prev]);
      }
      prev = null;
      first = null;
    }
  }
  if (first) {
    set2.push([first, null]);
  }
  const ranges = [];
  for (const [min, max] of set2) {
    if (min === max) {
      ranges.push(min);
    } else if (!max && min === v[0]) {
      ranges.push("*");
    } else if (!max) {
      ranges.push(`>=${min}`);
    } else if (min === v[0]) {
      ranges.push(`<=${max}`);
    } else {
      ranges.push(`${min} - ${max}`);
    }
  }
  const simplified = ranges.join(" || ");
  const original = typeof range2.raw === "string" ? range2.raw : String(range2);
  return simplified.length < original.length ? simplified : range2;
};
const Range$c = range$1;
const Comparator$5 = comparator$1;
const { ANY: ANY$3 } = Comparator$5;
const satisfies$5 = satisfies_1$1;
const compare$c = compare_1$1;
const subset$2 = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true;
  }
  sub = new Range$c(sub, options);
  dom = new Range$c(dom, options);
  let sawNonNull = false;
  OUTER:
    for (const simpleSub of sub.set) {
      for (const simpleDom of dom.set) {
        const isSub = simpleSubset$1(simpleSub, simpleDom, options);
        sawNonNull = sawNonNull || isSub !== null;
        if (isSub) {
          continue OUTER;
        }
      }
      if (sawNonNull) {
        return false;
      }
    }
  return true;
};
const minimumVersionWithPreRelease = [new Comparator$5(">=0.0.0-0")];
const minimumVersion = [new Comparator$5(">=0.0.0")];
const simpleSubset$1 = (sub, dom, options) => {
  if (sub === dom) {
    return true;
  }
  if (sub.length === 1 && sub[0].semver === ANY$3) {
    if (dom.length === 1 && dom[0].semver === ANY$3) {
      return true;
    } else if (options.includePrerelease) {
      sub = minimumVersionWithPreRelease;
    } else {
      sub = minimumVersion;
    }
  }
  if (dom.length === 1 && dom[0].semver === ANY$3) {
    if (options.includePrerelease) {
      return true;
    } else {
      dom = minimumVersion;
    }
  }
  const eqSet = new Set();
  let gt2, lt2;
  for (const c of sub) {
    if (c.operator === ">" || c.operator === ">=") {
      gt2 = higherGT$1(gt2, c, options);
    } else if (c.operator === "<" || c.operator === "<=") {
      lt2 = lowerLT$1(lt2, c, options);
    } else {
      eqSet.add(c.semver);
    }
  }
  if (eqSet.size > 1) {
    return null;
  }
  let gtltComp;
  if (gt2 && lt2) {
    gtltComp = compare$c(gt2.semver, lt2.semver, options);
    if (gtltComp > 0) {
      return null;
    } else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<=")) {
      return null;
    }
  }
  for (const eq2 of eqSet) {
    if (gt2 && !satisfies$5(eq2, String(gt2), options)) {
      return null;
    }
    if (lt2 && !satisfies$5(eq2, String(lt2), options)) {
      return null;
    }
    for (const c of dom) {
      if (!satisfies$5(eq2, String(c), options)) {
        return false;
      }
    }
    return true;
  }
  let higher, lower;
  let hasDomLT, hasDomGT;
  let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
  let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }
  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
    hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
    if (gt2) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false;
        }
      }
      if (c.operator === ">" || c.operator === ">=") {
        higher = higherGT$1(gt2, c, options);
        if (higher === c && higher !== gt2) {
          return false;
        }
      } else if (gt2.operator === ">=" && !satisfies$5(gt2.semver, String(c), options)) {
        return false;
      }
    }
    if (lt2) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false;
        }
      }
      if (c.operator === "<" || c.operator === "<=") {
        lower = lowerLT$1(lt2, c, options);
        if (lower === c && lower !== lt2) {
          return false;
        }
      } else if (lt2.operator === "<=" && !satisfies$5(lt2.semver, String(c), options)) {
        return false;
      }
    }
    if (!c.operator && (lt2 || gt2) && gtltComp !== 0) {
      return false;
    }
  }
  if (gt2 && hasDomLT && !lt2 && gtltComp !== 0) {
    return false;
  }
  if (lt2 && hasDomGT && !gt2 && gtltComp !== 0) {
    return false;
  }
  if (needDomGTPre || needDomLTPre) {
    return false;
  }
  return true;
};
const higherGT$1 = (a, b, options) => {
  if (!a) {
    return b;
  }
  const comp = compare$c(a.semver, b.semver, options);
  return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
};
const lowerLT$1 = (a, b, options) => {
  if (!a) {
    return b;
  }
  const comp = compare$c(a.semver, b.semver, options);
  return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
};
var subset_1$1 = subset$2;
const internalRe$1 = re$a.exports;
const constants$1 = constants$2;
const SemVer$f = semver$4;
const identifiers$1 = identifiers$2;
const parse$6 = parse_1$1;
const valid$2 = valid_1$1;
const clean$1 = clean_1$1;
const inc$1 = inc_1$1;
const diff$1 = diff_1$1;
const major$1 = major_1$1;
const minor$1 = minor_1$1;
const patch$1 = patch_1$1;
const prerelease$1 = prerelease_1$1;
const compare$b = compare_1$1;
const rcompare$1 = rcompare_1$1;
const compareLoose$1 = compareLoose_1$1;
const compareBuild$3 = compareBuild_1$1;
const sort$1 = sort_1$1;
const rsort$1 = rsort_1$1;
const gt$4 = gt_1$1;
const lt$3 = lt_1$1;
const eq$3 = eq_1$1;
const neq$2 = neq_1$1;
const gte$3 = gte_1$1;
const lte$3 = lte_1$1;
const cmp$2 = cmp_1$1;
const coerce$1 = coerce_1$1;
const Comparator$4 = comparator$1;
const Range$b = range$1;
const satisfies$4 = satisfies_1$1;
const toComparators$1 = toComparators_1$1;
const maxSatisfying$1 = maxSatisfying_1$1;
const minSatisfying$1 = minSatisfying_1$1;
const minVersion$1 = minVersion_1$1;
const validRange$1 = valid$3;
const outside$3 = outside_1$1;
const gtr$1 = gtr_1$1;
const ltr$1 = ltr_1$1;
const intersects$1 = intersects_1$1;
const simplifyRange = simplify$1;
const subset$1 = subset_1$1;
var semver$3 = {
  parse: parse$6,
  valid: valid$2,
  clean: clean$1,
  inc: inc$1,
  diff: diff$1,
  major: major$1,
  minor: minor$1,
  patch: patch$1,
  prerelease: prerelease$1,
  compare: compare$b,
  rcompare: rcompare$1,
  compareLoose: compareLoose$1,
  compareBuild: compareBuild$3,
  sort: sort$1,
  rsort: rsort$1,
  gt: gt$4,
  lt: lt$3,
  eq: eq$3,
  neq: neq$2,
  gte: gte$3,
  lte: lte$3,
  cmp: cmp$2,
  coerce: coerce$1,
  Comparator: Comparator$4,
  Range: Range$b,
  satisfies: satisfies$4,
  toComparators: toComparators$1,
  maxSatisfying: maxSatisfying$1,
  minSatisfying: minSatisfying$1,
  minVersion: minVersion$1,
  validRange: validRange$1,
  outside: outside$3,
  gtr: gtr$1,
  ltr: ltr$1,
  intersects: intersects$1,
  simplifyRange,
  subset: subset$1,
  SemVer: SemVer$f,
  re: internalRe$1.re,
  src: internalRe$1.src,
  tokens: internalRe$1.t,
  SEMVER_SPEC_VERSION: constants$1.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants$1.RELEASE_TYPES,
  compareIdentifiers: identifiers$1.compareIdentifiers,
  rcompareIdentifiers: identifiers$1.rcompareIdentifiers
};
var DownloadedUpdateHelper$1 = {};
var lodash_isequal = { exports: {} };
(function(module, exports) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag2 = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil = function() {
    try {
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  function arrayFilter(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  function arraySome(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  function cacheHas(cache2, key) {
    return cache2.has(key);
  }
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function mapToArray(map2) {
    var index = -1, result = Array(map2.size);
    map2.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  function setToArray(set2) {
    var index = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto2 = Object.prototype;
  var coreJsData = root2["__core-js_shared__"];
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto2.hasOwnProperty;
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var nativeObjectToString = objectProto2.toString;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Buffer2 = moduleExports ? root2.Buffer : void 0, Symbol2 = root2.Symbol, Uint8Array2 = root2.Uint8Array, propertyIsEnumerable = objectProto2.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
  var DataView = getNative(root2, "DataView"), Map2 = getNative(root2, "Map"), Promise2 = getNative(root2, "Promise"), Set2 = getNative(root2, "Set"), WeakMap2 = getNative(root2, "WeakMap"), nativeCreate = getNative(Object, "create");
  var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
  var symbolProto2 = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
  function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : void 0;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
  }
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  function mapCacheDelete(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function SetCache(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache();
    while (++index < length) {
      this.add(values[index]);
    }
  }
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs2 = data.__data__;
      if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
        pairs2.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs2);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq2(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
  }
  function baseIsArguments(value) {
    return isObjectLike2(value) && baseGetTag(value) == argsTag;
  }
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }
  function baseIsNative(value) {
    if (!isObject2(value) || isMasked(value)) {
      return false;
    }
    var pattern2 = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern2.test(toSource(value));
  }
  function baseIsTypedArray(value) {
    return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
    stack.set(array, other);
    stack.set(other, array);
    while (++index < arrLength) {
      var arrValue = array[index], othValue = other[index];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
  }
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq2(+object, +other);
      case errorTag:
        return object.name == other.name && object.message == other.message;
      case regexpTag:
      case stringTag:
        return object == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object);
        return result;
      case symbolTag2:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }
  function getMapData(map2, key) {
    var data = map2.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };
  var getTag = baseGetTag;
  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER2 : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isKeyable(value) {
    var type2 = typeof value;
    return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
    return value === proto;
  }
  function objectToString2(value) {
    return nativeObjectToString.call(value);
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike2(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  var isArray = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  var isBuffer = nativeIsBuffer || stubFalse;
  function isEqual2(value, other) {
    return baseIsEqual(value, other);
  }
  function isFunction(value) {
    if (!isObject2(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  function isObject2(value) {
    var type2 = typeof value;
    return value != null && (type2 == "object" || type2 == "function");
  }
  function isObjectLike2(value) {
    return value != null && typeof value == "object";
  }
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function stubArray() {
    return [];
  }
  function stubFalse() {
    return false;
  }
  module.exports = isEqual2;
})(lodash_isequal, lodash_isequal.exports);
Object.defineProperty(DownloadedUpdateHelper$1, "__esModule", { value: true });
DownloadedUpdateHelper$1.createTempUpdateFile = DownloadedUpdateHelper$1.DownloadedUpdateHelper = void 0;
const crypto_1$2 = require$$0__default$3["default"];
const fs_1$6 = require$$1__default$1["default"];
const isEqual = lodash_isequal.exports;
const fs_extra_1$6 = lib;
const path$c = require$$1__default$2["default"];
class DownloadedUpdateHelper {
  constructor(cacheDir) {
    this.cacheDir = cacheDir;
    this._file = null;
    this._packageFile = null;
    this.versionInfo = null;
    this.fileInfo = null;
    this._downloadedFileInfo = null;
  }
  get downloadedFileInfo() {
    return this._downloadedFileInfo;
  }
  get file() {
    return this._file;
  }
  get packageFile() {
    return this._packageFile;
  }
  get cacheDirForPendingUpdate() {
    return path$c.join(this.cacheDir, "pending");
  }
  async validateDownloadedPath(updateFile, updateInfo, fileInfo, logger) {
    if (this.versionInfo != null && this.file === updateFile && this.fileInfo != null) {
      if (isEqual(this.versionInfo, updateInfo) && isEqual(this.fileInfo.info, fileInfo.info) && await (0, fs_extra_1$6.pathExists)(updateFile)) {
        return updateFile;
      } else {
        return null;
      }
    }
    const cachedUpdateFile = await this.getValidCachedUpdateFile(fileInfo, logger);
    if (cachedUpdateFile === null) {
      return null;
    }
    logger.info(`Update has already been downloaded to ${updateFile}).`);
    this._file = cachedUpdateFile;
    return cachedUpdateFile;
  }
  async setDownloadedFile(downloadedFile, packageFile, versionInfo, fileInfo, updateFileName, isSaveCache) {
    this._file = downloadedFile;
    this._packageFile = packageFile;
    this.versionInfo = versionInfo;
    this.fileInfo = fileInfo;
    this._downloadedFileInfo = {
      fileName: updateFileName,
      sha512: fileInfo.info.sha512,
      isAdminRightsRequired: fileInfo.info.isAdminRightsRequired === true
    };
    if (isSaveCache) {
      await (0, fs_extra_1$6.outputJson)(this.getUpdateInfoFile(), this._downloadedFileInfo);
    }
  }
  async clear() {
    this._file = null;
    this._packageFile = null;
    this.versionInfo = null;
    this.fileInfo = null;
    await this.cleanCacheDirForPendingUpdate();
  }
  async cleanCacheDirForPendingUpdate() {
    try {
      await (0, fs_extra_1$6.emptyDir)(this.cacheDirForPendingUpdate);
    } catch (ignore) {
    }
  }
  async getValidCachedUpdateFile(fileInfo, logger) {
    var _a;
    const updateInfoFilePath = this.getUpdateInfoFile();
    const doesUpdateInfoFileExist = await (0, fs_extra_1$6.pathExists)(updateInfoFilePath);
    if (!doesUpdateInfoFileExist) {
      return null;
    }
    let cachedInfo;
    try {
      cachedInfo = await (0, fs_extra_1$6.readJson)(updateInfoFilePath);
    } catch (error2) {
      let message = `No cached update info available`;
      if (error2.code !== "ENOENT") {
        await this.cleanCacheDirForPendingUpdate();
        message += ` (error on read: ${error2.message})`;
      }
      logger.info(message);
      return null;
    }
    const isCachedInfoFileNameValid = (_a = (cachedInfo === null || cachedInfo === void 0 ? void 0 : cachedInfo.fileName) !== null) !== null && _a !== void 0 ? _a : false;
    if (!isCachedInfoFileNameValid) {
      logger.warn(`Cached update info is corrupted: no fileName, directory for cached update will be cleaned`);
      await this.cleanCacheDirForPendingUpdate();
      return null;
    }
    if (fileInfo.info.sha512 !== cachedInfo.sha512) {
      logger.info(`Cached update sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${cachedInfo.sha512}, expected: ${fileInfo.info.sha512}. Directory for cached update will be cleaned`);
      await this.cleanCacheDirForPendingUpdate();
      return null;
    }
    const updateFile = path$c.join(this.cacheDirForPendingUpdate, cachedInfo.fileName);
    if (!await (0, fs_extra_1$6.pathExists)(updateFile)) {
      logger.info("Cached update file doesn't exist");
      return null;
    }
    const sha512 = await hashFile(updateFile);
    if (fileInfo.info.sha512 !== sha512) {
      logger.warn(`Sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${sha512}, expected: ${fileInfo.info.sha512}`);
      await this.cleanCacheDirForPendingUpdate();
      return null;
    }
    this._downloadedFileInfo = cachedInfo;
    return updateFile;
  }
  getUpdateInfoFile() {
    return path$c.join(this.cacheDirForPendingUpdate, "update-info.json");
  }
}
DownloadedUpdateHelper$1.DownloadedUpdateHelper = DownloadedUpdateHelper;
function hashFile(file2, algorithm = "sha512", encoding = "base64", options) {
  return new Promise((resolve2, reject) => {
    const hash = (0, crypto_1$2.createHash)(algorithm);
    hash.on("error", reject).setEncoding(encoding);
    (0, fs_1$6.createReadStream)(file2, __spreadProps(__spreadValues({}, options), { highWaterMark: 1024 * 1024 })).on("error", reject).on("end", () => {
      hash.end();
      resolve2(hash.read());
    }).pipe(hash, { end: false });
  });
}
async function createTempUpdateFile(name, cacheDir, log) {
  let nameCounter = 0;
  let result = path$c.join(cacheDir, name);
  for (let i2 = 0; i2 < 3; i2++) {
    try {
      await (0, fs_extra_1$6.unlink)(result);
      return result;
    } catch (e) {
      if (e.code === "ENOENT") {
        return result;
      }
      log.warn(`Error on remove temp update file: ${e}`);
      result = path$c.join(cacheDir, `${nameCounter++}-${name}`);
    }
  }
  return result;
}
DownloadedUpdateHelper$1.createTempUpdateFile = createTempUpdateFile;
var ElectronAppAdapter$1 = {};
var AppAdapter = {};
Object.defineProperty(AppAdapter, "__esModule", { value: true });
AppAdapter.getAppCacheDir = void 0;
const path$b = require$$1__default$2["default"];
const os_1 = require$$1__default$4["default"];
function getAppCacheDir() {
  const homedir2 = (0, os_1.homedir)();
  let result;
  if (process.platform === "win32") {
    result = process.env["LOCALAPPDATA"] || path$b.join(homedir2, "AppData", "Local");
  } else if (process.platform === "darwin") {
    result = path$b.join(homedir2, "Library", "Caches");
  } else {
    result = process.env["XDG_CACHE_HOME"] || path$b.join(homedir2, ".cache");
  }
  return result;
}
AppAdapter.getAppCacheDir = getAppCacheDir;
Object.defineProperty(ElectronAppAdapter$1, "__esModule", { value: true });
ElectronAppAdapter$1.ElectronAppAdapter = void 0;
const path$a = require$$1__default$2["default"];
const AppAdapter_1 = AppAdapter;
class ElectronAppAdapter {
  constructor(app2 = require$$1__default["default"].app) {
    this.app = app2;
  }
  whenReady() {
    return this.app.whenReady();
  }
  get version() {
    return this.app.getVersion();
  }
  get name() {
    return this.app.getName();
  }
  get isPackaged() {
    return this.app.isPackaged === true;
  }
  get appUpdateConfigPath() {
    return this.isPackaged ? path$a.join(process.resourcesPath, "app-update.yml") : path$a.join(this.app.getAppPath(), "dev-app-update.yml");
  }
  get userDataPath() {
    return this.app.getPath("userData");
  }
  get baseCachePath() {
    return (0, AppAdapter_1.getAppCacheDir)();
  }
  quit() {
    this.app.quit();
  }
  onQuit(handler) {
    this.app.once("quit", (_, exitCode) => handler(exitCode));
  }
}
ElectronAppAdapter$1.ElectronAppAdapter = ElectronAppAdapter;
var electronHttpExecutor = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ElectronHttpExecutor = exports.getNetSession = exports.NET_SESSION_NAME = void 0;
  const builder_util_runtime_12 = out;
  exports.NET_SESSION_NAME = "electron-updater";
  function getNetSession() {
    return require$$1__default["default"].session.fromPartition(exports.NET_SESSION_NAME, {
      cache: false
    });
  }
  exports.getNetSession = getNetSession;
  class ElectronHttpExecutor extends builder_util_runtime_12.HttpExecutor {
    constructor(proxyLoginCallback) {
      super();
      this.proxyLoginCallback = proxyLoginCallback;
      this.cachedSession = null;
    }
    async download(url, destination, options) {
      return await options.cancellationToken.createPromise((resolve2, reject, onCancel) => {
        const requestOptions = {
          headers: options.headers || void 0,
          redirect: "manual"
        };
        (0, builder_util_runtime_12.configureRequestUrl)(url, requestOptions);
        (0, builder_util_runtime_12.configureRequestOptions)(requestOptions);
        this.doDownload(requestOptions, {
          destination,
          options,
          onCancel,
          callback: (error2) => {
            if (error2 == null) {
              resolve2(destination);
            } else {
              reject(error2);
            }
          },
          responseHandler: null
        }, 0);
      });
    }
    createRequest(options, callback) {
      if (options.headers && options.headers.Host) {
        options.host = options.headers.Host;
        delete options.headers.Host;
      }
      if (this.cachedSession == null) {
        this.cachedSession = getNetSession();
      }
      const request = require$$1__default["default"].net.request(__spreadProps(__spreadValues({}, options), {
        session: this.cachedSession
      }));
      request.on("response", callback);
      if (this.proxyLoginCallback != null) {
        request.on("login", this.proxyLoginCallback);
      }
      return request;
    }
    addRedirectHandlers(request, options, reject, redirectCount, handler) {
      request.on("redirect", (statusCode, method, redirectUrl) => {
        request.abort();
        if (redirectCount > this.maxRedirects) {
          reject(this.createMaxRedirectError());
        } else {
          handler(builder_util_runtime_12.HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options));
        }
      });
    }
  }
  exports.ElectronHttpExecutor = ElectronHttpExecutor;
})(electronHttpExecutor);
var GenericProvider$1 = {};
var util$1 = {};
var INFINITY = 1 / 0;
var symbolTag = "[object Symbol]";
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
var objectProto = Object.prototype;
var objectToString = objectProto.toString;
var Symbol$1 = root.Symbol;
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function isObjectLike(value) {
  return !!value && typeof value == "object";
}
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function escapeRegExp$1(string) {
  string = toString(string);
  return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
}
var lodash_escaperegexp = escapeRegExp$1;
Object.defineProperty(util$1, "__esModule", { value: true });
util$1.blockmapFiles = util$1.getChannelFilename = util$1.newUrlFromBase = util$1.newBaseUrl = void 0;
const url_1$4 = require$$4__default["default"];
const escapeRegExp = lodash_escaperegexp;
function newBaseUrl(url) {
  const result = new url_1$4.URL(url);
  if (!result.pathname.endsWith("/")) {
    result.pathname += "/";
  }
  return result;
}
util$1.newBaseUrl = newBaseUrl;
function newUrlFromBase(pathname, baseUrl, addRandomQueryToAvoidCaching = false) {
  const result = new url_1$4.URL(pathname, baseUrl);
  const search = baseUrl.search;
  if (search != null && search.length !== 0) {
    result.search = search;
  } else if (addRandomQueryToAvoidCaching) {
    result.search = `noCache=${Date.now().toString(32)}`;
  }
  return result;
}
util$1.newUrlFromBase = newUrlFromBase;
function getChannelFilename(channel) {
  return `${channel}.yml`;
}
util$1.getChannelFilename = getChannelFilename;
function blockmapFiles(baseUrl, oldVersion, newVersion) {
  const newBlockMapUrl = newUrlFromBase(`${baseUrl.pathname}.blockmap`, baseUrl);
  const oldBlockMapUrl = newUrlFromBase(`${baseUrl.pathname.replace(new RegExp(escapeRegExp(newVersion), "g"), oldVersion)}.blockmap`, baseUrl);
  return [oldBlockMapUrl, newBlockMapUrl];
}
util$1.blockmapFiles = blockmapFiles;
var Provider$1 = {};
Object.defineProperty(Provider$1, "__esModule", { value: true });
Provider$1.resolveFiles = Provider$1.getFileList = Provider$1.parseUpdateInfo = Provider$1.findFile = Provider$1.Provider = void 0;
const builder_util_runtime_1$e = out;
const js_yaml_1$2 = jsYaml;
const util_1$w = util$1;
class Provider {
  constructor(runtimeOptions) {
    this.runtimeOptions = runtimeOptions;
    this.requestHeaders = null;
    this.executor = runtimeOptions.executor;
  }
  get isUseMultipleRangeRequest() {
    return this.runtimeOptions.isUseMultipleRangeRequest !== false;
  }
  getChannelFilePrefix() {
    if (this.runtimeOptions.platform === "linux") {
      const arch = process.env["TEST_UPDATER_ARCH"] || process.arch;
      const archSuffix = arch === "x64" ? "" : `-${arch}`;
      return "-linux" + archSuffix;
    } else {
      return this.runtimeOptions.platform === "darwin" ? "-mac" : "";
    }
  }
  getDefaultChannelName() {
    return this.getCustomChannelName("latest");
  }
  getCustomChannelName(channel) {
    return `${channel}${this.getChannelFilePrefix()}`;
  }
  get fileExtraDownloadHeaders() {
    return null;
  }
  setRequestHeaders(value) {
    this.requestHeaders = value;
  }
  httpRequest(url, headers, cancellationToken) {
    return this.executor.request(this.createRequestOptions(url, headers), cancellationToken);
  }
  createRequestOptions(url, headers) {
    const result = {};
    if (this.requestHeaders == null) {
      if (headers != null) {
        result.headers = headers;
      }
    } else {
      result.headers = headers == null ? this.requestHeaders : __spreadValues(__spreadValues({}, this.requestHeaders), headers);
    }
    (0, builder_util_runtime_1$e.configureRequestUrl)(url, result);
    return result;
  }
}
Provider$1.Provider = Provider;
function findFile(files, extension, not2) {
  if (files.length === 0) {
    throw (0, builder_util_runtime_1$e.newError)("No files provided", "ERR_UPDATER_NO_FILES_PROVIDED");
  }
  const result = files.find((it) => it.url.pathname.toLowerCase().endsWith(`.${extension}`));
  if (result != null) {
    return result;
  } else if (not2 == null) {
    return files[0];
  } else {
    return files.find((fileInfo) => !not2.some((ext) => fileInfo.url.pathname.toLowerCase().endsWith(`.${ext}`)));
  }
}
Provider$1.findFile = findFile;
function parseUpdateInfo(rawData, channelFile, channelFileUrl) {
  if (rawData == null) {
    throw (0, builder_util_runtime_1$e.newError)(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): rawData: null`, "ERR_UPDATER_INVALID_UPDATE_INFO");
  }
  let result;
  try {
    result = (0, js_yaml_1$2.load)(rawData);
  } catch (e) {
    throw (0, builder_util_runtime_1$e.newError)(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}, rawData: ${rawData}`, "ERR_UPDATER_INVALID_UPDATE_INFO");
  }
  return result;
}
Provider$1.parseUpdateInfo = parseUpdateInfo;
function getFileList(updateInfo) {
  const files = updateInfo.files;
  if (files != null && files.length > 0) {
    return files;
  }
  if (updateInfo.path != null) {
    return [
      {
        url: updateInfo.path,
        sha2: updateInfo.sha2,
        sha512: updateInfo.sha512
      }
    ];
  } else {
    throw (0, builder_util_runtime_1$e.newError)(`No files provided: ${(0, builder_util_runtime_1$e.safeStringifyJson)(updateInfo)}`, "ERR_UPDATER_NO_FILES_PROVIDED");
  }
}
Provider$1.getFileList = getFileList;
function resolveFiles(updateInfo, baseUrl, pathTransformer = (p) => p) {
  const files = getFileList(updateInfo);
  const result = files.map((fileInfo) => {
    if (fileInfo.sha2 == null && fileInfo.sha512 == null) {
      throw (0, builder_util_runtime_1$e.newError)(`Update info doesn't contain nor sha256 neither sha512 checksum: ${(0, builder_util_runtime_1$e.safeStringifyJson)(fileInfo)}`, "ERR_UPDATER_NO_CHECKSUM");
    }
    return {
      url: (0, util_1$w.newUrlFromBase)(pathTransformer(fileInfo.url), baseUrl),
      info: fileInfo
    };
  });
  const packages = updateInfo.packages;
  const packageInfo = packages == null ? null : packages[process.arch] || packages.ia32;
  if (packageInfo != null) {
    result[0].packageInfo = __spreadProps(__spreadValues({}, packageInfo), {
      path: (0, util_1$w.newUrlFromBase)(pathTransformer(packageInfo.path), baseUrl).href
    });
  }
  return result;
}
Provider$1.resolveFiles = resolveFiles;
Object.defineProperty(GenericProvider$1, "__esModule", { value: true });
GenericProvider$1.GenericProvider = void 0;
const builder_util_runtime_1$d = out;
const util_1$v = util$1;
const Provider_1$9 = Provider$1;
class GenericProvider extends Provider_1$9.Provider {
  constructor(configuration, updater, runtimeOptions) {
    super(runtimeOptions);
    this.configuration = configuration;
    this.updater = updater;
    this.baseUrl = (0, util_1$v.newBaseUrl)(this.configuration.url);
  }
  get channel() {
    const result = this.updater.channel || this.configuration.channel;
    return result == null ? this.getDefaultChannelName() : this.getCustomChannelName(result);
  }
  async getLatestVersion() {
    const channelFile = (0, util_1$v.getChannelFilename)(this.channel);
    const channelUrl = (0, util_1$v.newUrlFromBase)(channelFile, this.baseUrl, this.updater.isAddNoCacheQuery);
    for (let attemptNumber = 0; ; attemptNumber++) {
      try {
        return (0, Provider_1$9.parseUpdateInfo)(await this.httpRequest(channelUrl), channelFile, channelUrl);
      } catch (e) {
        if (e instanceof builder_util_runtime_1$d.HttpError && e.statusCode === 404) {
          throw (0, builder_util_runtime_1$d.newError)(`Cannot find channel "${channelFile}" update info: ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
        } else if (e.code === "ECONNREFUSED") {
          if (attemptNumber < 3) {
            await new Promise((resolve2, reject) => {
              try {
                setTimeout(resolve2, 1e3 * attemptNumber);
              } catch (e2) {
                reject(e2);
              }
            });
            continue;
          }
        }
        throw e;
      }
    }
  }
  resolveFiles(updateInfo) {
    return (0, Provider_1$9.resolveFiles)(updateInfo, this.baseUrl);
  }
}
GenericProvider$1.GenericProvider = GenericProvider;
var providerFactory = {};
var BitbucketProvider$1 = {};
Object.defineProperty(BitbucketProvider$1, "__esModule", { value: true });
BitbucketProvider$1.BitbucketProvider = void 0;
const builder_util_runtime_1$c = out;
const util_1$u = util$1;
const Provider_1$8 = Provider$1;
class BitbucketProvider extends Provider_1$8.Provider {
  constructor(configuration, updater, runtimeOptions) {
    super(__spreadProps(__spreadValues({}, runtimeOptions), {
      isUseMultipleRangeRequest: false
    }));
    this.configuration = configuration;
    this.updater = updater;
    const { owner, slug } = configuration;
    this.baseUrl = (0, util_1$u.newBaseUrl)(`https://api.bitbucket.org/2.0/repositories/${owner}/${slug}/downloads`);
  }
  get channel() {
    return this.updater.channel || this.configuration.channel || "latest";
  }
  async getLatestVersion() {
    const cancellationToken = new builder_util_runtime_1$c.CancellationToken();
    const channelFile = (0, util_1$u.getChannelFilename)(this.getCustomChannelName(this.channel));
    const channelUrl = (0, util_1$u.newUrlFromBase)(channelFile, this.baseUrl, this.updater.isAddNoCacheQuery);
    try {
      const updateInfo = await this.httpRequest(channelUrl, void 0, cancellationToken);
      return (0, Provider_1$8.parseUpdateInfo)(updateInfo, channelFile, channelUrl);
    } catch (e) {
      throw (0, builder_util_runtime_1$c.newError)(`Unable to find latest version on ${this.toString()}, please ensure release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  resolveFiles(updateInfo) {
    return (0, Provider_1$8.resolveFiles)(updateInfo, this.baseUrl);
  }
  toString() {
    const { owner, slug } = this.configuration;
    return `Bitbucket (owner: ${owner}, slug: ${slug}, channel: ${this.channel})`;
  }
}
BitbucketProvider$1.BitbucketProvider = BitbucketProvider;
var GitHubProvider$1 = {};
Object.defineProperty(GitHubProvider$1, "__esModule", { value: true });
GitHubProvider$1.computeReleaseNotes = GitHubProvider$1.GitHubProvider = GitHubProvider$1.BaseGitHubProvider = void 0;
const builder_util_runtime_1$b = out;
const semver$2 = semver$3;
const url_1$3 = require$$4__default["default"];
const util_1$t = util$1;
const Provider_1$7 = Provider$1;
const hrefRegExp = /\/tag\/([^/]+)$/;
class BaseGitHubProvider extends Provider_1$7.Provider {
  constructor(options, defaultHost, runtimeOptions) {
    super(__spreadProps(__spreadValues({}, runtimeOptions), {
      isUseMultipleRangeRequest: false
    }));
    this.options = options;
    this.baseUrl = (0, util_1$t.newBaseUrl)((0, builder_util_runtime_1$b.githubUrl)(options, defaultHost));
    const apiHost = defaultHost === "github.com" ? "api.github.com" : defaultHost;
    this.baseApiUrl = (0, util_1$t.newBaseUrl)((0, builder_util_runtime_1$b.githubUrl)(options, apiHost));
  }
  computeGithubBasePath(result) {
    const host = this.options.host;
    return host && !["github.com", "api.github.com"].includes(host) ? `/api/v3${result}` : result;
  }
}
GitHubProvider$1.BaseGitHubProvider = BaseGitHubProvider;
class GitHubProvider extends BaseGitHubProvider {
  constructor(options, updater, runtimeOptions) {
    super(options, "github.com", runtimeOptions);
    this.options = options;
    this.updater = updater;
  }
  async getLatestVersion() {
    var _a, _b, _c, _d;
    const cancellationToken = new builder_util_runtime_1$b.CancellationToken();
    const feedXml = await this.httpRequest((0, util_1$t.newUrlFromBase)(`${this.basePath}.atom`, this.baseUrl), {
      accept: "application/xml, application/atom+xml, text/xml, */*"
    }, cancellationToken);
    const feed = (0, builder_util_runtime_1$b.parseXml)(feedXml);
    let latestRelease = feed.element("entry", false, `No published versions on GitHub`);
    let tag = null;
    try {
      if (this.updater.allowPrerelease) {
        const currentChannel = ((_a = this.updater) === null || _a === void 0 ? void 0 : _a.channel) || ((_b = semver$2.prerelease(this.updater.currentVersion)) === null || _b === void 0 ? void 0 : _b[0]) || null;
        if (currentChannel === null) {
          tag = hrefRegExp.exec(latestRelease.element("link").attribute("href"))[1];
        } else {
          for (const element of feed.getElements("entry")) {
            const hrefElement = hrefRegExp.exec(element.element("link").attribute("href"));
            if (hrefElement === null)
              continue;
            const hrefTag = hrefElement[1];
            const hrefChannel = ((_c = semver$2.prerelease(hrefTag)) === null || _c === void 0 ? void 0 : _c[0]) || null;
            const shouldFetchVersion = !currentChannel || ["alpha", "beta"].includes(currentChannel);
            const isCustomChannel = !["alpha", "beta"].includes(String(hrefChannel));
            const channelMismatch = currentChannel === "beta" && hrefChannel === "alpha";
            if (shouldFetchVersion && !isCustomChannel && !channelMismatch) {
              tag = hrefTag;
              break;
            }
            const isNextPreRelease = hrefChannel && hrefChannel === currentChannel;
            if (isNextPreRelease) {
              tag = hrefTag;
              break;
            }
          }
        }
      } else {
        tag = await this.getLatestTagName(cancellationToken);
        for (const element of feed.getElements("entry")) {
          if (hrefRegExp.exec(element.element("link").attribute("href"))[1] === tag) {
            latestRelease = element;
            break;
          }
        }
      }
    } catch (e) {
      throw (0, builder_util_runtime_1$b.newError)(`Cannot parse releases feed: ${e.stack || e.message},
XML:
${feedXml}`, "ERR_UPDATER_INVALID_RELEASE_FEED");
    }
    if (tag == null) {
      throw (0, builder_util_runtime_1$b.newError)(`No published versions on GitHub`, "ERR_UPDATER_NO_PUBLISHED_VERSIONS");
    }
    let rawData;
    let channelFile = "";
    let channelFileUrl = "";
    const fetchData = async (channelName) => {
      channelFile = (0, util_1$t.getChannelFilename)(channelName);
      channelFileUrl = (0, util_1$t.newUrlFromBase)(this.getBaseDownloadPath(String(tag), channelFile), this.baseUrl);
      const requestOptions = this.createRequestOptions(channelFileUrl);
      try {
        return await this.executor.request(requestOptions, cancellationToken);
      } catch (e) {
        if (e instanceof builder_util_runtime_1$b.HttpError && e.statusCode === 404) {
          throw (0, builder_util_runtime_1$b.newError)(`Cannot find ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
        }
        throw e;
      }
    };
    try {
      const channel = this.updater.allowPrerelease ? this.getCustomChannelName(String(((_d = semver$2.prerelease(tag)) === null || _d === void 0 ? void 0 : _d[0]) || "latest")) : this.getDefaultChannelName();
      rawData = await fetchData(channel);
    } catch (e) {
      if (this.updater.allowPrerelease) {
        rawData = await fetchData(this.getDefaultChannelName());
      } else {
        throw e;
      }
    }
    const result = (0, Provider_1$7.parseUpdateInfo)(rawData, channelFile, channelFileUrl);
    if (result.releaseName == null) {
      result.releaseName = latestRelease.elementValueOrEmpty("title");
    }
    if (result.releaseNotes == null) {
      result.releaseNotes = computeReleaseNotes(this.updater.currentVersion, this.updater.fullChangelog, feed, latestRelease);
    }
    return __spreadValues({
      tag
    }, result);
  }
  async getLatestTagName(cancellationToken) {
    const options = this.options;
    const url = options.host == null || options.host === "github.com" ? (0, util_1$t.newUrlFromBase)(`${this.basePath}/latest`, this.baseUrl) : new url_1$3.URL(`${this.computeGithubBasePath(`/repos/${options.owner}/${options.repo}/releases`)}/latest`, this.baseApiUrl);
    try {
      const rawData = await this.httpRequest(url, { Accept: "application/json" }, cancellationToken);
      if (rawData == null) {
        return null;
      }
      const releaseInfo = JSON.parse(rawData);
      return releaseInfo.tag_name;
    } catch (e) {
      throw (0, builder_util_runtime_1$b.newError)(`Unable to find latest version on GitHub (${url}), please ensure a production release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  get basePath() {
    return `/${this.options.owner}/${this.options.repo}/releases`;
  }
  resolveFiles(updateInfo) {
    return (0, Provider_1$7.resolveFiles)(updateInfo, this.baseUrl, (p) => this.getBaseDownloadPath(updateInfo.tag, p.replace(/ /g, "-")));
  }
  getBaseDownloadPath(tag, fileName) {
    return `${this.basePath}/download/${tag}/${fileName}`;
  }
}
GitHubProvider$1.GitHubProvider = GitHubProvider;
function getNoteValue(parent) {
  const result = parent.elementValueOrEmpty("content");
  return result === "No content." ? "" : result;
}
function computeReleaseNotes(currentVersion, isFullChangelog, feed, latestRelease) {
  if (!isFullChangelog) {
    return getNoteValue(latestRelease);
  }
  const releaseNotes = [];
  for (const release of feed.getElements("entry")) {
    const versionRelease = /\/tag\/v?([^/]+)$/.exec(release.element("link").attribute("href"))[1];
    if (semver$2.lt(currentVersion, versionRelease)) {
      releaseNotes.push({
        version: versionRelease,
        note: getNoteValue(release)
      });
    }
  }
  return releaseNotes.sort((a, b) => semver$2.rcompare(a.version, b.version));
}
GitHubProvider$1.computeReleaseNotes = computeReleaseNotes;
var KeygenProvider$1 = {};
Object.defineProperty(KeygenProvider$1, "__esModule", { value: true });
KeygenProvider$1.KeygenProvider = void 0;
const builder_util_runtime_1$a = out;
const util_1$s = util$1;
const Provider_1$6 = Provider$1;
class KeygenProvider extends Provider_1$6.Provider {
  constructor(configuration, updater, runtimeOptions) {
    super(__spreadProps(__spreadValues({}, runtimeOptions), {
      isUseMultipleRangeRequest: false
    }));
    this.configuration = configuration;
    this.updater = updater;
    this.baseUrl = (0, util_1$s.newBaseUrl)(`https://api.keygen.sh/v1/accounts/${this.configuration.account}/artifacts?product=${this.configuration.product}`);
  }
  get channel() {
    return this.updater.channel || this.configuration.channel || "stable";
  }
  async getLatestVersion() {
    const cancellationToken = new builder_util_runtime_1$a.CancellationToken();
    const channelFile = (0, util_1$s.getChannelFilename)(this.getCustomChannelName(this.channel));
    const channelUrl = (0, util_1$s.newUrlFromBase)(channelFile, this.baseUrl, this.updater.isAddNoCacheQuery);
    try {
      const updateInfo = await this.httpRequest(channelUrl, {
        Accept: "application/vnd.api+json",
        "Keygen-Version": "1.1"
      }, cancellationToken);
      return (0, Provider_1$6.parseUpdateInfo)(updateInfo, channelFile, channelUrl);
    } catch (e) {
      throw (0, builder_util_runtime_1$a.newError)(`Unable to find latest version on ${this.toString()}, please ensure release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  resolveFiles(updateInfo) {
    return (0, Provider_1$6.resolveFiles)(updateInfo, this.baseUrl);
  }
  toString() {
    const { account, product, platform: platform2 } = this.configuration;
    return `Keygen (account: ${account}, product: ${product}, platform: ${platform2}, channel: ${this.channel})`;
  }
}
KeygenProvider$1.KeygenProvider = KeygenProvider;
var PrivateGitHubProvider$1 = {};
Object.defineProperty(PrivateGitHubProvider$1, "__esModule", { value: true });
PrivateGitHubProvider$1.PrivateGitHubProvider = void 0;
const builder_util_runtime_1$9 = out;
const js_yaml_1$1 = jsYaml;
const path$9 = require$$1__default$2["default"];
const url_1$2 = require$$4__default["default"];
const util_1$r = util$1;
const GitHubProvider_1$1 = GitHubProvider$1;
const Provider_1$5 = Provider$1;
class PrivateGitHubProvider extends GitHubProvider_1$1.BaseGitHubProvider {
  constructor(options, updater, token, runtimeOptions) {
    super(options, "api.github.com", runtimeOptions);
    this.updater = updater;
    this.token = token;
  }
  createRequestOptions(url, headers) {
    const result = super.createRequestOptions(url, headers);
    result.redirect = "manual";
    return result;
  }
  async getLatestVersion() {
    const cancellationToken = new builder_util_runtime_1$9.CancellationToken();
    const channelFile = (0, util_1$r.getChannelFilename)(this.getDefaultChannelName());
    const releaseInfo = await this.getLatestVersionInfo(cancellationToken);
    const asset = releaseInfo.assets.find((it) => it.name === channelFile);
    if (asset == null) {
      throw (0, builder_util_runtime_1$9.newError)(`Cannot find ${channelFile} in the release ${releaseInfo.html_url || releaseInfo.name}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
    }
    const url = new url_1$2.URL(asset.url);
    let result;
    try {
      result = (0, js_yaml_1$1.load)(await this.httpRequest(url, this.configureHeaders("application/octet-stream"), cancellationToken));
    } catch (e) {
      if (e instanceof builder_util_runtime_1$9.HttpError && e.statusCode === 404) {
        throw (0, builder_util_runtime_1$9.newError)(`Cannot find ${channelFile} in the latest release artifacts (${url}): ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
      }
      throw e;
    }
    result.assets = releaseInfo.assets;
    return result;
  }
  get fileExtraDownloadHeaders() {
    return this.configureHeaders("application/octet-stream");
  }
  configureHeaders(accept) {
    return {
      accept,
      authorization: `token ${this.token}`
    };
  }
  async getLatestVersionInfo(cancellationToken) {
    const allowPrerelease = this.updater.allowPrerelease;
    let basePath = this.basePath;
    if (!allowPrerelease) {
      basePath = `${basePath}/latest`;
    }
    const url = (0, util_1$r.newUrlFromBase)(basePath, this.baseUrl);
    try {
      const version = JSON.parse(await this.httpRequest(url, this.configureHeaders("application/vnd.github.v3+json"), cancellationToken));
      if (allowPrerelease) {
        return version.find((it) => it.prerelease) || version[0];
      } else {
        return version;
      }
    } catch (e) {
      throw (0, builder_util_runtime_1$9.newError)(`Unable to find latest version on GitHub (${url}), please ensure a production release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  get basePath() {
    return this.computeGithubBasePath(`/repos/${this.options.owner}/${this.options.repo}/releases`);
  }
  resolveFiles(updateInfo) {
    return (0, Provider_1$5.getFileList)(updateInfo).map((it) => {
      const name = path$9.posix.basename(it.url).replace(/ /g, "-");
      const asset = updateInfo.assets.find((it2) => it2 != null && it2.name === name);
      if (asset == null) {
        throw (0, builder_util_runtime_1$9.newError)(`Cannot find asset "${name}" in: ${JSON.stringify(updateInfo.assets, null, 2)}`, "ERR_UPDATER_ASSET_NOT_FOUND");
      }
      return {
        url: new url_1$2.URL(asset.url),
        info: it
      };
    });
  }
}
PrivateGitHubProvider$1.PrivateGitHubProvider = PrivateGitHubProvider;
Object.defineProperty(providerFactory, "__esModule", { value: true });
providerFactory.createClient = providerFactory.isUrlProbablySupportMultiRangeRequests = void 0;
const builder_util_runtime_1$8 = out;
const BitbucketProvider_1 = BitbucketProvider$1;
const GenericProvider_1$1 = GenericProvider$1;
const GitHubProvider_1 = GitHubProvider$1;
const KeygenProvider_1 = KeygenProvider$1;
const PrivateGitHubProvider_1 = PrivateGitHubProvider$1;
function isUrlProbablySupportMultiRangeRequests(url) {
  return !url.includes("s3.amazonaws.com");
}
providerFactory.isUrlProbablySupportMultiRangeRequests = isUrlProbablySupportMultiRangeRequests;
function createClient(data, updater, runtimeOptions) {
  if (typeof data === "string") {
    throw (0, builder_util_runtime_1$8.newError)("Please pass PublishConfiguration object", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
  }
  const provider = data.provider;
  switch (provider) {
    case "github": {
      const githubOptions = data;
      const token = (githubOptions.private ? process.env["GH_TOKEN"] || process.env["GITHUB_TOKEN"] : null) || githubOptions.token;
      if (token == null) {
        return new GitHubProvider_1.GitHubProvider(githubOptions, updater, runtimeOptions);
      } else {
        return new PrivateGitHubProvider_1.PrivateGitHubProvider(githubOptions, updater, token, runtimeOptions);
      }
    }
    case "bitbucket":
      return new BitbucketProvider_1.BitbucketProvider(data, updater, runtimeOptions);
    case "keygen":
      return new KeygenProvider_1.KeygenProvider(data, updater, runtimeOptions);
    case "s3":
    case "spaces":
      return new GenericProvider_1$1.GenericProvider({
        provider: "generic",
        url: (0, builder_util_runtime_1$8.getS3LikeProviderBaseUrl)(data),
        channel: data.channel || null
      }, updater, __spreadProps(__spreadValues({}, runtimeOptions), {
        isUseMultipleRangeRequest: false
      }));
    case "generic": {
      const options = data;
      return new GenericProvider_1$1.GenericProvider(options, updater, __spreadProps(__spreadValues({}, runtimeOptions), {
        isUseMultipleRangeRequest: options.useMultipleRangeRequest !== false && isUrlProbablySupportMultiRangeRequests(options.url)
      }));
    }
    case "custom": {
      const options = data;
      const constructor = options.updateProvider;
      if (!constructor) {
        throw (0, builder_util_runtime_1$8.newError)("Custom provider not specified", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
      }
      return new constructor(options, updater, runtimeOptions);
    }
    default:
      throw (0, builder_util_runtime_1$8.newError)(`Unsupported provider: ${provider}`, "ERR_UPDATER_UNSUPPORTED_PROVIDER");
  }
}
providerFactory.createClient = createClient;
Object.defineProperty(AppUpdater$1, "__esModule", { value: true });
AppUpdater$1.NoOpLogger = AppUpdater$1.AppUpdater = void 0;
const builder_util_runtime_1$7 = out;
const crypto_1$1 = require$$0__default$3["default"];
const events_1 = require$$0__default$2["default"];
const fs_extra_1$5 = lib;
const js_yaml_1 = jsYaml;
const lazy_val_1 = main;
const path$8 = require$$1__default$2["default"];
const semver_1 = semver$3;
const DownloadedUpdateHelper_1 = DownloadedUpdateHelper$1;
const ElectronAppAdapter_1 = ElectronAppAdapter$1;
const electronHttpExecutor_1 = electronHttpExecutor;
const GenericProvider_1 = GenericProvider$1;
const main_1$4 = main$1;
const providerFactory_1 = providerFactory;
class AppUpdater extends events_1.EventEmitter {
  constructor(options, app2) {
    super();
    this.autoDownload = true;
    this.autoInstallOnAppQuit = true;
    this.autoRunAppAfterInstall = true;
    this.allowPrerelease = false;
    this.fullChangelog = false;
    this.allowDowngrade = false;
    this.disableWebInstaller = false;
    this.forceDevUpdateConfig = false;
    this._channel = null;
    this.downloadedUpdateHelper = null;
    this.requestHeaders = null;
    this._logger = console;
    this.signals = new main_1$4.UpdaterSignal(this);
    this._appUpdateConfigPath = null;
    this.clientPromise = null;
    this.stagingUserIdPromise = new lazy_val_1.Lazy(() => this.getOrCreateStagingUserId());
    this.configOnDisk = new lazy_val_1.Lazy(() => this.loadUpdateConfig());
    this.checkForUpdatesPromise = null;
    this.updateInfoAndProvider = null;
    this._testOnlyOptions = null;
    this.on("error", (error2) => {
      this._logger.error(`Error: ${error2.stack || error2.message}`);
    });
    if (app2 == null) {
      this.app = new ElectronAppAdapter_1.ElectronAppAdapter();
      this.httpExecutor = new electronHttpExecutor_1.ElectronHttpExecutor((authInfo, callback) => this.emit("login", authInfo, callback));
    } else {
      this.app = app2;
      this.httpExecutor = null;
    }
    const currentVersionString = this.app.version;
    const currentVersion = (0, semver_1.parse)(currentVersionString);
    if (currentVersion == null) {
      throw (0, builder_util_runtime_1$7.newError)(`App version is not a valid semver version: "${currentVersionString}"`, "ERR_UPDATER_INVALID_VERSION");
    }
    this.currentVersion = currentVersion;
    this.allowPrerelease = hasPrereleaseComponents(currentVersion);
    if (options != null) {
      this.setFeedURL(options);
      if (typeof options !== "string" && options.requestHeaders) {
        this.requestHeaders = options.requestHeaders;
      }
    }
  }
  get channel() {
    return this._channel;
  }
  set channel(value) {
    if (this._channel != null) {
      if (typeof value !== "string") {
        throw (0, builder_util_runtime_1$7.newError)(`Channel must be a string, but got: ${value}`, "ERR_UPDATER_INVALID_CHANNEL");
      } else if (value.length === 0) {
        throw (0, builder_util_runtime_1$7.newError)(`Channel must be not an empty string`, "ERR_UPDATER_INVALID_CHANNEL");
      }
    }
    this._channel = value;
    this.allowDowngrade = true;
  }
  addAuthHeader(token) {
    this.requestHeaders = Object.assign({}, this.requestHeaders, {
      authorization: token
    });
  }
  get netSession() {
    return (0, electronHttpExecutor_1.getNetSession)();
  }
  get logger() {
    return this._logger;
  }
  set logger(value) {
    this._logger = value == null ? new NoOpLogger() : value;
  }
  set updateConfigPath(value) {
    this.clientPromise = null;
    this._appUpdateConfigPath = value;
    this.configOnDisk = new lazy_val_1.Lazy(() => this.loadUpdateConfig());
  }
  getFeedURL() {
    return "Deprecated. Do not use it.";
  }
  setFeedURL(options) {
    const runtimeOptions = this.createProviderRuntimeOptions();
    let provider;
    if (typeof options === "string") {
      provider = new GenericProvider_1.GenericProvider({ provider: "generic", url: options }, this, __spreadProps(__spreadValues({}, runtimeOptions), {
        isUseMultipleRangeRequest: (0, providerFactory_1.isUrlProbablySupportMultiRangeRequests)(options)
      }));
    } else {
      provider = (0, providerFactory_1.createClient)(options, this, runtimeOptions);
    }
    this.clientPromise = Promise.resolve(provider);
  }
  checkForUpdates() {
    if (!this.isUpdaterActive()) {
      return Promise.resolve(null);
    }
    let checkForUpdatesPromise = this.checkForUpdatesPromise;
    if (checkForUpdatesPromise != null) {
      this._logger.info("Checking for update (already in progress)");
      return checkForUpdatesPromise;
    }
    const nullizePromise = () => this.checkForUpdatesPromise = null;
    this._logger.info("Checking for update");
    checkForUpdatesPromise = this.doCheckForUpdates().then((it) => {
      nullizePromise();
      return it;
    }).catch((e) => {
      nullizePromise();
      this.emit("error", e, `Cannot check for updates: ${(e.stack || e).toString()}`);
      throw e;
    });
    this.checkForUpdatesPromise = checkForUpdatesPromise;
    return checkForUpdatesPromise;
  }
  isUpdaterActive() {
    const isEnabled = this.app.isPackaged || this.forceDevUpdateConfig;
    if (!isEnabled) {
      this._logger.info("Skip checkForUpdates because application is not packed and dev update config is not forced");
      return false;
    }
    return true;
  }
  checkForUpdatesAndNotify(downloadNotification) {
    return this.checkForUpdates().then((it) => {
      if (!(it === null || it === void 0 ? void 0 : it.downloadPromise)) {
        if (this._logger.debug != null) {
          this._logger.debug("checkForUpdatesAndNotify called, downloadPromise is null");
        }
        return it;
      }
      void it.downloadPromise.then(() => {
        const notificationContent = AppUpdater.formatDownloadNotification(it.updateInfo.version, this.app.name, downloadNotification);
        new require$$1__default["default"].Notification(notificationContent).show();
      });
      return it;
    });
  }
  static formatDownloadNotification(version, appName, downloadNotification) {
    if (downloadNotification == null) {
      downloadNotification = {
        title: "A new update is ready to install",
        body: `{appName} version {version} has been downloaded and will be automatically installed on exit`
      };
    }
    downloadNotification = {
      title: downloadNotification.title.replace("{appName}", appName).replace("{version}", version),
      body: downloadNotification.body.replace("{appName}", appName).replace("{version}", version)
    };
    return downloadNotification;
  }
  async isStagingMatch(updateInfo) {
    const rawStagingPercentage = updateInfo.stagingPercentage;
    let stagingPercentage = rawStagingPercentage;
    if (stagingPercentage == null) {
      return true;
    }
    stagingPercentage = parseInt(stagingPercentage, 10);
    if (isNaN(stagingPercentage)) {
      this._logger.warn(`Staging percentage is NaN: ${rawStagingPercentage}`);
      return true;
    }
    stagingPercentage = stagingPercentage / 100;
    const stagingUserId = await this.stagingUserIdPromise.value;
    const val = builder_util_runtime_1$7.UUID.parse(stagingUserId).readUInt32BE(12);
    const percentage = val / 4294967295;
    this._logger.info(`Staging percentage: ${stagingPercentage}, percentage: ${percentage}, user id: ${stagingUserId}`);
    return percentage < stagingPercentage;
  }
  computeFinalHeaders(headers) {
    if (this.requestHeaders != null) {
      Object.assign(headers, this.requestHeaders);
    }
    return headers;
  }
  async isUpdateAvailable(updateInfo) {
    const latestVersion = (0, semver_1.parse)(updateInfo.version);
    if (latestVersion == null) {
      throw (0, builder_util_runtime_1$7.newError)(`This file could not be downloaded, or the latest version (from update server) does not have a valid semver version: "${updateInfo.version}"`, "ERR_UPDATER_INVALID_VERSION");
    }
    const currentVersion = this.currentVersion;
    if ((0, semver_1.eq)(latestVersion, currentVersion)) {
      return false;
    }
    const isStagingMatch = await this.isStagingMatch(updateInfo);
    if (!isStagingMatch) {
      return false;
    }
    const isLatestVersionNewer = (0, semver_1.gt)(latestVersion, currentVersion);
    const isLatestVersionOlder = (0, semver_1.lt)(latestVersion, currentVersion);
    if (isLatestVersionNewer) {
      return true;
    }
    return this.allowDowngrade && isLatestVersionOlder;
  }
  async getUpdateInfoAndProvider() {
    await this.app.whenReady();
    if (this.clientPromise == null) {
      this.clientPromise = this.configOnDisk.value.then((it) => (0, providerFactory_1.createClient)(it, this, this.createProviderRuntimeOptions()));
    }
    const client = await this.clientPromise;
    const stagingUserId = await this.stagingUserIdPromise.value;
    client.setRequestHeaders(this.computeFinalHeaders({ "x-user-staging-id": stagingUserId }));
    return {
      info: await client.getLatestVersion(),
      provider: client
    };
  }
  createProviderRuntimeOptions() {
    return {
      isUseMultipleRangeRequest: true,
      platform: this._testOnlyOptions == null ? process.platform : this._testOnlyOptions.platform,
      executor: this.httpExecutor
    };
  }
  async doCheckForUpdates() {
    this.emit("checking-for-update");
    const result = await this.getUpdateInfoAndProvider();
    const updateInfo = result.info;
    if (!await this.isUpdateAvailable(updateInfo)) {
      this._logger.info(`Update for version ${this.currentVersion} is not available (latest version: ${updateInfo.version}, downgrade is ${this.allowDowngrade ? "allowed" : "disallowed"}).`);
      this.emit("update-not-available", updateInfo);
      return {
        versionInfo: updateInfo,
        updateInfo
      };
    }
    this.updateInfoAndProvider = result;
    this.onUpdateAvailable(updateInfo);
    const cancellationToken = new builder_util_runtime_1$7.CancellationToken();
    return {
      versionInfo: updateInfo,
      updateInfo,
      cancellationToken,
      downloadPromise: this.autoDownload ? this.downloadUpdate(cancellationToken) : null
    };
  }
  onUpdateAvailable(updateInfo) {
    this._logger.info(`Found version ${updateInfo.version} (url: ${(0, builder_util_runtime_1$7.asArray)(updateInfo.files).map((it) => it.url).join(", ")})`);
    this.emit("update-available", updateInfo);
  }
  downloadUpdate(cancellationToken = new builder_util_runtime_1$7.CancellationToken()) {
    const updateInfoAndProvider = this.updateInfoAndProvider;
    if (updateInfoAndProvider == null) {
      const error2 = new Error("Please check update first");
      this.dispatchError(error2);
      return Promise.reject(error2);
    }
    this._logger.info(`Downloading update from ${(0, builder_util_runtime_1$7.asArray)(updateInfoAndProvider.info.files).map((it) => it.url).join(", ")}`);
    const errorHandler = (e) => {
      if (!(e instanceof builder_util_runtime_1$7.CancellationError)) {
        try {
          this.dispatchError(e);
        } catch (nestedError) {
          this._logger.warn(`Cannot dispatch error event: ${nestedError.stack || nestedError}`);
        }
      }
      return e;
    };
    try {
      return this.doDownloadUpdate({
        updateInfoAndProvider,
        requestHeaders: this.computeRequestHeaders(updateInfoAndProvider.provider),
        cancellationToken,
        disableWebInstaller: this.disableWebInstaller
      }).catch((e) => {
        throw errorHandler(e);
      });
    } catch (e) {
      return Promise.reject(errorHandler(e));
    }
  }
  dispatchError(e) {
    this.emit("error", e, (e.stack || e).toString());
  }
  dispatchUpdateDownloaded(event) {
    this.emit(main_1$4.UPDATE_DOWNLOADED, event);
  }
  async loadUpdateConfig() {
    if (this._appUpdateConfigPath == null) {
      this._appUpdateConfigPath = this.app.appUpdateConfigPath;
    }
    return (0, js_yaml_1.load)(await (0, fs_extra_1$5.readFile)(this._appUpdateConfigPath, "utf-8"));
  }
  computeRequestHeaders(provider) {
    const fileExtraDownloadHeaders = provider.fileExtraDownloadHeaders;
    if (fileExtraDownloadHeaders != null) {
      const requestHeaders = this.requestHeaders;
      return requestHeaders == null ? fileExtraDownloadHeaders : __spreadValues(__spreadValues({}, fileExtraDownloadHeaders), requestHeaders);
    }
    return this.computeFinalHeaders({ accept: "*/*" });
  }
  async getOrCreateStagingUserId() {
    const file2 = path$8.join(this.app.userDataPath, ".updaterId");
    try {
      const id3 = await (0, fs_extra_1$5.readFile)(file2, "utf-8");
      if (builder_util_runtime_1$7.UUID.check(id3)) {
        return id3;
      } else {
        this._logger.warn(`Staging user id file exists, but content was invalid: ${id3}`);
      }
    } catch (e) {
      if (e.code !== "ENOENT") {
        this._logger.warn(`Couldn't read staging user ID, creating a blank one: ${e}`);
      }
    }
    const id2 = builder_util_runtime_1$7.UUID.v5((0, crypto_1$1.randomBytes)(4096), builder_util_runtime_1$7.UUID.OID);
    this._logger.info(`Generated new staging user ID: ${id2}`);
    try {
      await (0, fs_extra_1$5.outputFile)(file2, id2);
    } catch (e) {
      this._logger.warn(`Couldn't write out staging user ID: ${e}`);
    }
    return id2;
  }
  get isAddNoCacheQuery() {
    const headers = this.requestHeaders;
    if (headers == null) {
      return true;
    }
    for (const headerName of Object.keys(headers)) {
      const s2 = headerName.toLowerCase();
      if (s2 === "authorization" || s2 === "private-token") {
        return false;
      }
    }
    return true;
  }
  async getOrCreateDownloadHelper() {
    let result = this.downloadedUpdateHelper;
    if (result == null) {
      const dirName = (await this.configOnDisk.value).updaterCacheDirName;
      const logger = this._logger;
      if (dirName == null) {
        logger.error("updaterCacheDirName is not specified in app-update.yml Was app build using at least electron-builder 20.34.0?");
      }
      const cacheDir = path$8.join(this.app.baseCachePath, dirName || this.app.name);
      if (logger.debug != null) {
        logger.debug(`updater cache dir: ${cacheDir}`);
      }
      result = new DownloadedUpdateHelper_1.DownloadedUpdateHelper(cacheDir);
      this.downloadedUpdateHelper = result;
    }
    return result;
  }
  async executeDownload(taskOptions) {
    const fileInfo = taskOptions.fileInfo;
    const downloadOptions = {
      headers: taskOptions.downloadUpdateOptions.requestHeaders,
      cancellationToken: taskOptions.downloadUpdateOptions.cancellationToken,
      sha2: fileInfo.info.sha2,
      sha512: fileInfo.info.sha512
    };
    if (this.listenerCount(main_1$4.DOWNLOAD_PROGRESS) > 0) {
      downloadOptions.onProgress = (it) => this.emit(main_1$4.DOWNLOAD_PROGRESS, it);
    }
    const updateInfo = taskOptions.downloadUpdateOptions.updateInfoAndProvider.info;
    const version = updateInfo.version;
    const packageInfo = fileInfo.packageInfo;
    function getCacheUpdateFileName() {
      const urlPath = decodeURIComponent(taskOptions.fileInfo.url.pathname);
      if (urlPath.endsWith(`.${taskOptions.fileExtension}`)) {
        return path$8.basename(urlPath);
      } else {
        return taskOptions.fileInfo.info.url;
      }
    }
    const downloadedUpdateHelper = await this.getOrCreateDownloadHelper();
    const cacheDir = downloadedUpdateHelper.cacheDirForPendingUpdate;
    await (0, fs_extra_1$5.mkdir)(cacheDir, { recursive: true });
    const updateFileName = getCacheUpdateFileName();
    let updateFile = path$8.join(cacheDir, updateFileName);
    const packageFile = packageInfo == null ? null : path$8.join(cacheDir, `package-${version}${path$8.extname(packageInfo.path) || ".7z"}`);
    const done = async (isSaveCache) => {
      await downloadedUpdateHelper.setDownloadedFile(updateFile, packageFile, updateInfo, fileInfo, updateFileName, isSaveCache);
      await taskOptions.done(__spreadProps(__spreadValues({}, updateInfo), {
        downloadedFile: updateFile
      }));
      return packageFile == null ? [updateFile] : [updateFile, packageFile];
    };
    const log = this._logger;
    const cachedUpdateFile = await downloadedUpdateHelper.validateDownloadedPath(updateFile, updateInfo, fileInfo, log);
    if (cachedUpdateFile != null) {
      updateFile = cachedUpdateFile;
      return await done(false);
    }
    const removeFileIfAny = async () => {
      await downloadedUpdateHelper.clear().catch(() => {
      });
      return await (0, fs_extra_1$5.unlink)(updateFile).catch(() => {
      });
    };
    const tempUpdateFile = await (0, DownloadedUpdateHelper_1.createTempUpdateFile)(`temp-${updateFileName}`, cacheDir, log);
    try {
      await taskOptions.task(tempUpdateFile, downloadOptions, packageFile, removeFileIfAny);
      await (0, fs_extra_1$5.rename)(tempUpdateFile, updateFile);
    } catch (e) {
      await removeFileIfAny();
      if (e instanceof builder_util_runtime_1$7.CancellationError) {
        log.info("cancelled");
        this.emit("update-cancelled", updateInfo);
      }
      throw e;
    }
    log.info(`New version ${version} has been downloaded to ${updateFile}`);
    return await done(true);
  }
}
AppUpdater$1.AppUpdater = AppUpdater;
function hasPrereleaseComponents(version) {
  const versionPrereleaseComponent = (0, semver_1.prerelease)(version);
  return versionPrereleaseComponent != null && versionPrereleaseComponent.length > 0;
}
class NoOpLogger {
  info(message) {
  }
  warn(message) {
  }
  error(message) {
  }
}
AppUpdater$1.NoOpLogger = NoOpLogger;
var AppImageUpdater$1 = {};
var BaseUpdater$1 = {};
Object.defineProperty(BaseUpdater$1, "__esModule", { value: true });
BaseUpdater$1.BaseUpdater = void 0;
const child_process_1$3 = require$$1__default$5["default"];
const AppUpdater_1$1 = AppUpdater$1;
class BaseUpdater extends AppUpdater_1$1.AppUpdater {
  constructor(options, app2) {
    super(options, app2);
    this.quitAndInstallCalled = false;
    this.quitHandlerAdded = false;
  }
  quitAndInstall(isSilent = false, isForceRunAfter = false) {
    this._logger.info(`Install on explicit quitAndInstall`);
    const isInstalled = this.install(isSilent, isSilent ? isForceRunAfter : this.autoRunAppAfterInstall);
    if (isInstalled) {
      setImmediate(() => {
        require$$1__default["default"].autoUpdater.emit("before-quit-for-update");
        this.app.quit();
      });
    } else {
      this.quitAndInstallCalled = false;
    }
  }
  executeDownload(taskOptions) {
    return super.executeDownload(__spreadProps(__spreadValues({}, taskOptions), {
      done: (event) => {
        this.dispatchUpdateDownloaded(event);
        this.addQuitHandler();
        return Promise.resolve();
      }
    }));
  }
  install(isSilent = false, isForceRunAfter = false) {
    if (this.quitAndInstallCalled) {
      this._logger.warn("install call ignored: quitAndInstallCalled is set to true");
      return false;
    }
    const downloadedUpdateHelper = this.downloadedUpdateHelper;
    const installerPath = downloadedUpdateHelper == null ? null : downloadedUpdateHelper.file;
    const downloadedFileInfo = downloadedUpdateHelper == null ? null : downloadedUpdateHelper.downloadedFileInfo;
    if (installerPath == null || downloadedFileInfo == null) {
      this.dispatchError(new Error("No valid update available, can't quit and install"));
      return false;
    }
    this.quitAndInstallCalled = true;
    try {
      this._logger.info(`Install: isSilent: ${isSilent}, isForceRunAfter: ${isForceRunAfter}`);
      return this.doInstall({
        installerPath,
        isSilent,
        isForceRunAfter,
        isAdminRightsRequired: downloadedFileInfo.isAdminRightsRequired
      });
    } catch (e) {
      this.dispatchError(e);
      return false;
    }
  }
  addQuitHandler() {
    if (this.quitHandlerAdded || !this.autoInstallOnAppQuit) {
      return;
    }
    this.quitHandlerAdded = true;
    this.app.onQuit((exitCode) => {
      if (this.quitAndInstallCalled) {
        this._logger.info("Update installer has already been triggered. Quitting application.");
        return;
      }
      if (!this.autoInstallOnAppQuit) {
        this._logger.info("Update will not be installed on quit because autoInstallOnAppQuit is set to false.");
        return;
      }
      if (exitCode !== 0) {
        this._logger.info(`Update will be not installed on quit because application is quitting with exit code ${exitCode}`);
        return;
      }
      this._logger.info("Auto install update on quit");
      this.install(true, false);
    });
  }
  wrapSudo() {
    const { name } = this.app;
    const installComment = `"${name} would like to update"`;
    const sudo = this.spawnSyncLog("which gksudo || which kdesudo || which pkexec || which beesu");
    const command = [sudo];
    if (/kdesudo/i.test(sudo)) {
      command.push("--comment", installComment);
      command.push("-c");
    } else if (/gksudo/i.test(sudo)) {
      command.push("--message", installComment);
    } else if (/pkexec/i.test(sudo)) {
      command.push("--disable-internal-agent");
    }
    return command.join(" ");
  }
  spawnSyncLog(cmd, args = [], env2 = {}) {
    this._logger.info(`Executing: ${cmd} with args: ${args}`);
    const response = (0, child_process_1$3.spawnSync)(cmd, args, {
      stdio: "inherit",
      env: __spreadValues(__spreadValues({}, process.env), env2),
      encoding: "utf-8",
      shell: true
    });
    return response.stdout.trim();
  }
  async spawnLog(cmd, args = [], env2 = void 0, stdio = "ignore") {
    this._logger.info(`Executing: ${cmd} with args: ${args}`);
    return new Promise((resolve2, reject) => {
      try {
        const params = { stdio, env: env2, detached: true };
        const p = (0, child_process_1$3.spawn)(cmd, args, params);
        p.on("error", (error2) => {
          reject(error2);
        });
        p.unref();
        if (p.pid !== void 0) {
          resolve2(true);
        }
      } catch (error2) {
        reject(error2);
      }
    });
  }
}
BaseUpdater$1.BaseUpdater = BaseUpdater;
var FileWithEmbeddedBlockMapDifferentialDownloader$1 = {};
var DifferentialDownloader$1 = {};
var DataSplitter$1 = {};
var downloadPlanBuilder = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.computeOperations = exports.OperationKind = void 0;
  var OperationKind2;
  (function(OperationKind3) {
    OperationKind3[OperationKind3["COPY"] = 0] = "COPY";
    OperationKind3[OperationKind3["DOWNLOAD"] = 1] = "DOWNLOAD";
  })(OperationKind2 = exports.OperationKind || (exports.OperationKind = {}));
  function computeOperations(oldBlockMap, newBlockMap, logger) {
    const nameToOldBlocks = buildBlockFileMap(oldBlockMap.files);
    const nameToNewBlocks = buildBlockFileMap(newBlockMap.files);
    let lastOperation = null;
    const blockMapFile = newBlockMap.files[0];
    const operations = [];
    const name = blockMapFile.name;
    const oldEntry = nameToOldBlocks.get(name);
    if (oldEntry == null) {
      throw new Error(`no file ${name} in old blockmap`);
    }
    const newFile = nameToNewBlocks.get(name);
    let changedBlockCount = 0;
    const { checksumToOffset: checksumToOldOffset, checksumToOldSize } = buildChecksumMap(nameToOldBlocks.get(name), oldEntry.offset, logger);
    let newOffset = blockMapFile.offset;
    for (let i2 = 0; i2 < newFile.checksums.length; newOffset += newFile.sizes[i2], i2++) {
      const blockSize = newFile.sizes[i2];
      const checksum = newFile.checksums[i2];
      let oldOffset = checksumToOldOffset.get(checksum);
      if (oldOffset != null && checksumToOldSize.get(checksum) !== blockSize) {
        logger.warn(`Checksum ("${checksum}") matches, but size differs (old: ${checksumToOldSize.get(checksum)}, new: ${blockSize})`);
        oldOffset = void 0;
      }
      if (oldOffset === void 0) {
        changedBlockCount++;
        if (lastOperation != null && lastOperation.kind === OperationKind2.DOWNLOAD && lastOperation.end === newOffset) {
          lastOperation.end += blockSize;
        } else {
          lastOperation = {
            kind: OperationKind2.DOWNLOAD,
            start: newOffset,
            end: newOffset + blockSize
          };
          validateAndAdd(lastOperation, operations, checksum, i2);
        }
      } else {
        if (lastOperation != null && lastOperation.kind === OperationKind2.COPY && lastOperation.end === oldOffset) {
          lastOperation.end += blockSize;
        } else {
          lastOperation = {
            kind: OperationKind2.COPY,
            start: oldOffset,
            end: oldOffset + blockSize
          };
          validateAndAdd(lastOperation, operations, checksum, i2);
        }
      }
    }
    if (changedBlockCount > 0) {
      logger.info(`File${blockMapFile.name === "file" ? "" : " " + blockMapFile.name} has ${changedBlockCount} changed blocks`);
    }
    return operations;
  }
  exports.computeOperations = computeOperations;
  const isValidateOperationRange = process.env["DIFFERENTIAL_DOWNLOAD_PLAN_BUILDER_VALIDATE_RANGES"] === "true";
  function validateAndAdd(operation, operations, checksum, index) {
    if (isValidateOperationRange && operations.length !== 0) {
      const lastOperation = operations[operations.length - 1];
      if (lastOperation.kind === operation.kind && operation.start < lastOperation.end && operation.start > lastOperation.start) {
        const min = [lastOperation.start, lastOperation.end, operation.start, operation.end].reduce((p, v) => p < v ? p : v);
        throw new Error(`operation (block index: ${index}, checksum: ${checksum}, kind: ${OperationKind2[operation.kind]}) overlaps previous operation (checksum: ${checksum}):
abs: ${lastOperation.start} until ${lastOperation.end} and ${operation.start} until ${operation.end}
rel: ${lastOperation.start - min} until ${lastOperation.end - min} and ${operation.start - min} until ${operation.end - min}`);
      }
    }
    operations.push(operation);
  }
  function buildChecksumMap(file2, fileOffset, logger) {
    const checksumToOffset = new Map();
    const checksumToSize = new Map();
    let offset = fileOffset;
    for (let i2 = 0; i2 < file2.checksums.length; i2++) {
      const checksum = file2.checksums[i2];
      const size = file2.sizes[i2];
      const existing = checksumToSize.get(checksum);
      if (existing === void 0) {
        checksumToOffset.set(checksum, offset);
        checksumToSize.set(checksum, size);
      } else if (logger.debug != null) {
        const sizeExplanation = existing === size ? "(same size)" : `(size: ${existing}, this size: ${size})`;
        logger.debug(`${checksum} duplicated in blockmap ${sizeExplanation}, it doesn't lead to broken differential downloader, just corresponding block will be skipped)`);
      }
      offset += size;
    }
    return { checksumToOffset, checksumToOldSize: checksumToSize };
  }
  function buildBlockFileMap(list) {
    const result = new Map();
    for (const item of list) {
      result.set(item.name, item);
    }
    return result;
  }
})(downloadPlanBuilder);
Object.defineProperty(DataSplitter$1, "__esModule", { value: true });
DataSplitter$1.DataSplitter = DataSplitter$1.copyData = void 0;
const builder_util_runtime_1$6 = out;
const fs_1$5 = require$$1__default$1["default"];
const stream_1$1 = require$$0__default$1["default"];
const downloadPlanBuilder_1$2 = downloadPlanBuilder;
const DOUBLE_CRLF = Buffer.from("\r\n\r\n");
var ReadState;
(function(ReadState2) {
  ReadState2[ReadState2["INIT"] = 0] = "INIT";
  ReadState2[ReadState2["HEADER"] = 1] = "HEADER";
  ReadState2[ReadState2["BODY"] = 2] = "BODY";
})(ReadState || (ReadState = {}));
function copyData(task, out2, oldFileFd, reject, resolve2) {
  const readStream = (0, fs_1$5.createReadStream)("", {
    fd: oldFileFd,
    autoClose: false,
    start: task.start,
    end: task.end - 1
  });
  readStream.on("error", reject);
  readStream.once("end", resolve2);
  readStream.pipe(out2, {
    end: false
  });
}
DataSplitter$1.copyData = copyData;
class DataSplitter extends stream_1$1.Writable {
  constructor(out2, options, partIndexToTaskIndex, boundary, partIndexToLength, finishHandler) {
    super();
    this.out = out2;
    this.options = options;
    this.partIndexToTaskIndex = partIndexToTaskIndex;
    this.partIndexToLength = partIndexToLength;
    this.finishHandler = finishHandler;
    this.partIndex = -1;
    this.headerListBuffer = null;
    this.readState = ReadState.INIT;
    this.ignoreByteCount = 0;
    this.remainingPartDataCount = 0;
    this.actualPartLength = 0;
    this.boundaryLength = boundary.length + 4;
    this.ignoreByteCount = this.boundaryLength - 2;
  }
  get isFinished() {
    return this.partIndex === this.partIndexToLength.length;
  }
  _write(data, encoding, callback) {
    if (this.isFinished) {
      console.error(`Trailing ignored data: ${data.length} bytes`);
      return;
    }
    this.handleData(data).then(callback).catch(callback);
  }
  async handleData(chunk) {
    let start = 0;
    if (this.ignoreByteCount !== 0 && this.remainingPartDataCount !== 0) {
      throw (0, builder_util_runtime_1$6.newError)("Internal error", "ERR_DATA_SPLITTER_BYTE_COUNT_MISMATCH");
    }
    if (this.ignoreByteCount > 0) {
      const toIgnore = Math.min(this.ignoreByteCount, chunk.length);
      this.ignoreByteCount -= toIgnore;
      start = toIgnore;
    } else if (this.remainingPartDataCount > 0) {
      const toRead = Math.min(this.remainingPartDataCount, chunk.length);
      this.remainingPartDataCount -= toRead;
      await this.processPartData(chunk, 0, toRead);
      start = toRead;
    }
    if (start === chunk.length) {
      return;
    }
    if (this.readState === ReadState.HEADER) {
      const headerListEnd = this.searchHeaderListEnd(chunk, start);
      if (headerListEnd === -1) {
        return;
      }
      start = headerListEnd;
      this.readState = ReadState.BODY;
      this.headerListBuffer = null;
    }
    while (true) {
      if (this.readState === ReadState.BODY) {
        this.readState = ReadState.INIT;
      } else {
        this.partIndex++;
        let taskIndex = this.partIndexToTaskIndex.get(this.partIndex);
        if (taskIndex == null) {
          if (this.isFinished) {
            taskIndex = this.options.end;
          } else {
            throw (0, builder_util_runtime_1$6.newError)("taskIndex is null", "ERR_DATA_SPLITTER_TASK_INDEX_IS_NULL");
          }
        }
        const prevTaskIndex = this.partIndex === 0 ? this.options.start : this.partIndexToTaskIndex.get(this.partIndex - 1) + 1;
        if (prevTaskIndex < taskIndex) {
          await this.copyExistingData(prevTaskIndex, taskIndex);
        } else if (prevTaskIndex > taskIndex) {
          throw (0, builder_util_runtime_1$6.newError)("prevTaskIndex must be < taskIndex", "ERR_DATA_SPLITTER_TASK_INDEX_ASSERT_FAILED");
        }
        if (this.isFinished) {
          this.onPartEnd();
          this.finishHandler();
          return;
        }
        start = this.searchHeaderListEnd(chunk, start);
        if (start === -1) {
          this.readState = ReadState.HEADER;
          return;
        }
      }
      const partLength = this.partIndexToLength[this.partIndex];
      const end = start + partLength;
      const effectiveEnd = Math.min(end, chunk.length);
      await this.processPartStarted(chunk, start, effectiveEnd);
      this.remainingPartDataCount = partLength - (effectiveEnd - start);
      if (this.remainingPartDataCount > 0) {
        return;
      }
      start = end + this.boundaryLength;
      if (start >= chunk.length) {
        this.ignoreByteCount = this.boundaryLength - (chunk.length - end);
        return;
      }
    }
  }
  copyExistingData(index, end) {
    return new Promise((resolve2, reject) => {
      const w2 = () => {
        if (index === end) {
          resolve2();
          return;
        }
        const task = this.options.tasks[index];
        if (task.kind !== downloadPlanBuilder_1$2.OperationKind.COPY) {
          reject(new Error("Task kind must be COPY"));
          return;
        }
        copyData(task, this.out, this.options.oldFileFd, reject, () => {
          index++;
          w2();
        });
      };
      w2();
    });
  }
  searchHeaderListEnd(chunk, readOffset) {
    const headerListEnd = chunk.indexOf(DOUBLE_CRLF, readOffset);
    if (headerListEnd !== -1) {
      return headerListEnd + DOUBLE_CRLF.length;
    }
    const partialChunk = readOffset === 0 ? chunk : chunk.slice(readOffset);
    if (this.headerListBuffer == null) {
      this.headerListBuffer = partialChunk;
    } else {
      this.headerListBuffer = Buffer.concat([this.headerListBuffer, partialChunk]);
    }
    return -1;
  }
  onPartEnd() {
    const expectedLength = this.partIndexToLength[this.partIndex - 1];
    if (this.actualPartLength !== expectedLength) {
      throw (0, builder_util_runtime_1$6.newError)(`Expected length: ${expectedLength} differs from actual: ${this.actualPartLength}`, "ERR_DATA_SPLITTER_LENGTH_MISMATCH");
    }
    this.actualPartLength = 0;
  }
  processPartStarted(data, start, end) {
    if (this.partIndex !== 0) {
      this.onPartEnd();
    }
    return this.processPartData(data, start, end);
  }
  processPartData(data, start, end) {
    this.actualPartLength += end - start;
    const out2 = this.out;
    if (out2.write(start === 0 && data.length === end ? data : data.slice(start, end))) {
      return Promise.resolve();
    } else {
      return new Promise((resolve2, reject) => {
        out2.on("error", reject);
        out2.once("drain", () => {
          out2.removeListener("error", reject);
          resolve2();
        });
      });
    }
  }
}
DataSplitter$1.DataSplitter = DataSplitter;
var multipleRangeDownloader = {};
Object.defineProperty(multipleRangeDownloader, "__esModule", { value: true });
multipleRangeDownloader.checkIsRangesSupported = multipleRangeDownloader.executeTasksUsingMultipleRangeRequests = void 0;
const builder_util_runtime_1$5 = out;
const DataSplitter_1$1 = DataSplitter$1;
const downloadPlanBuilder_1$1 = downloadPlanBuilder;
function executeTasksUsingMultipleRangeRequests(differentialDownloader, tasks, out2, oldFileFd, reject) {
  const w2 = (taskOffset) => {
    if (taskOffset >= tasks.length) {
      if (differentialDownloader.fileMetadataBuffer != null) {
        out2.write(differentialDownloader.fileMetadataBuffer);
      }
      out2.end();
      return;
    }
    const nextOffset = taskOffset + 1e3;
    doExecuteTasks(differentialDownloader, {
      tasks,
      start: taskOffset,
      end: Math.min(tasks.length, nextOffset),
      oldFileFd
    }, out2, () => w2(nextOffset), reject);
  };
  return w2;
}
multipleRangeDownloader.executeTasksUsingMultipleRangeRequests = executeTasksUsingMultipleRangeRequests;
function doExecuteTasks(differentialDownloader, options, out2, resolve2, reject) {
  let ranges = "bytes=";
  let partCount = 0;
  const partIndexToTaskIndex = new Map();
  const partIndexToLength = [];
  for (let i2 = options.start; i2 < options.end; i2++) {
    const task = options.tasks[i2];
    if (task.kind === downloadPlanBuilder_1$1.OperationKind.DOWNLOAD) {
      ranges += `${task.start}-${task.end - 1}, `;
      partIndexToTaskIndex.set(partCount, i2);
      partCount++;
      partIndexToLength.push(task.end - task.start);
    }
  }
  if (partCount <= 1) {
    const w2 = (index) => {
      if (index >= options.end) {
        resolve2();
        return;
      }
      const task = options.tasks[index++];
      if (task.kind === downloadPlanBuilder_1$1.OperationKind.COPY) {
        (0, DataSplitter_1$1.copyData)(task, out2, options.oldFileFd, reject, () => w2(index));
      } else {
        const requestOptions2 = differentialDownloader.createRequestOptions();
        requestOptions2.headers.Range = `bytes=${task.start}-${task.end - 1}`;
        const request2 = differentialDownloader.httpExecutor.createRequest(requestOptions2, (response) => {
          if (!checkIsRangesSupported(response, reject)) {
            return;
          }
          response.pipe(out2, {
            end: false
          });
          response.once("end", () => w2(index));
        });
        differentialDownloader.httpExecutor.addErrorAndTimeoutHandlers(request2, reject);
        request2.end();
      }
    };
    w2(options.start);
    return;
  }
  const requestOptions = differentialDownloader.createRequestOptions();
  requestOptions.headers.Range = ranges.substring(0, ranges.length - 2);
  const request = differentialDownloader.httpExecutor.createRequest(requestOptions, (response) => {
    if (!checkIsRangesSupported(response, reject)) {
      return;
    }
    const contentType = (0, builder_util_runtime_1$5.safeGetHeader)(response, "content-type");
    const m2 = /^multipart\/.+?(?:; boundary=(?:(?:"(.+)")|(?:([^\s]+))))$/i.exec(contentType);
    if (m2 == null) {
      reject(new Error(`Content-Type "multipart/byteranges" is expected, but got "${contentType}"`));
      return;
    }
    const dicer = new DataSplitter_1$1.DataSplitter(out2, options, partIndexToTaskIndex, m2[1] || m2[2], partIndexToLength, resolve2);
    dicer.on("error", reject);
    response.pipe(dicer);
    response.on("end", () => {
      setTimeout(() => {
        request.abort();
        reject(new Error("Response ends without calling any handlers"));
      }, 1e4);
    });
  });
  differentialDownloader.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
  request.end();
}
function checkIsRangesSupported(response, reject) {
  if (response.statusCode >= 400) {
    reject((0, builder_util_runtime_1$5.createHttpError)(response));
    return false;
  }
  if (response.statusCode !== 206) {
    const acceptRanges = (0, builder_util_runtime_1$5.safeGetHeader)(response, "accept-ranges");
    if (acceptRanges == null || acceptRanges === "none") {
      reject(new Error(`Server doesn't support Accept-Ranges (response code ${response.statusCode})`));
      return false;
    }
  }
  return true;
}
multipleRangeDownloader.checkIsRangesSupported = checkIsRangesSupported;
var ProgressDifferentialDownloadCallbackTransform$1 = {};
Object.defineProperty(ProgressDifferentialDownloadCallbackTransform$1, "__esModule", { value: true });
ProgressDifferentialDownloadCallbackTransform$1.ProgressDifferentialDownloadCallbackTransform = void 0;
const stream_1 = require$$0__default$1["default"];
var OperationKind;
(function(OperationKind2) {
  OperationKind2[OperationKind2["COPY"] = 0] = "COPY";
  OperationKind2[OperationKind2["DOWNLOAD"] = 1] = "DOWNLOAD";
})(OperationKind || (OperationKind = {}));
class ProgressDifferentialDownloadCallbackTransform extends stream_1.Transform {
  constructor(progressDifferentialDownloadInfo, cancellationToken, onProgress) {
    super();
    this.progressDifferentialDownloadInfo = progressDifferentialDownloadInfo;
    this.cancellationToken = cancellationToken;
    this.onProgress = onProgress;
    this.start = Date.now();
    this.transferred = 0;
    this.delta = 0;
    this.expectedBytes = 0;
    this.index = 0;
    this.operationType = OperationKind.COPY;
    this.nextUpdate = this.start + 1e3;
  }
  _transform(chunk, encoding, callback) {
    if (this.cancellationToken.cancelled) {
      callback(new Error("cancelled"), null);
      return;
    }
    if (this.operationType == OperationKind.COPY) {
      callback(null, chunk);
      return;
    }
    this.transferred += chunk.length;
    this.delta += chunk.length;
    const now = Date.now();
    if (now >= this.nextUpdate && this.transferred !== this.expectedBytes && this.transferred !== this.progressDifferentialDownloadInfo.grandTotal) {
      this.nextUpdate = now + 1e3;
      this.onProgress({
        total: this.progressDifferentialDownloadInfo.grandTotal,
        delta: this.delta,
        transferred: this.transferred,
        percent: this.transferred / this.progressDifferentialDownloadInfo.grandTotal * 100,
        bytesPerSecond: Math.round(this.transferred / ((now - this.start) / 1e3))
      });
      this.delta = 0;
    }
    callback(null, chunk);
  }
  beginFileCopy() {
    this.operationType = OperationKind.COPY;
  }
  beginRangeDownload() {
    this.operationType = OperationKind.DOWNLOAD;
    this.expectedBytes += this.progressDifferentialDownloadInfo.expectedByteCounts[this.index++];
  }
  endRangeDownload() {
    if (this.transferred !== this.progressDifferentialDownloadInfo.grandTotal) {
      this.onProgress({
        total: this.progressDifferentialDownloadInfo.grandTotal,
        delta: this.delta,
        transferred: this.transferred,
        percent: this.transferred / this.progressDifferentialDownloadInfo.grandTotal * 100,
        bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
      });
    }
  }
  _flush(callback) {
    if (this.cancellationToken.cancelled) {
      callback(new Error("cancelled"));
      return;
    }
    this.onProgress({
      total: this.progressDifferentialDownloadInfo.grandTotal,
      delta: this.delta,
      transferred: this.transferred,
      percent: 100,
      bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
    });
    this.delta = 0;
    this.transferred = 0;
    callback(null);
  }
}
ProgressDifferentialDownloadCallbackTransform$1.ProgressDifferentialDownloadCallbackTransform = ProgressDifferentialDownloadCallbackTransform;
Object.defineProperty(DifferentialDownloader$1, "__esModule", { value: true });
DifferentialDownloader$1.DifferentialDownloader = void 0;
const builder_util_runtime_1$4 = out;
const fs_extra_1$4 = lib;
const fs_1$4 = require$$1__default$1["default"];
const DataSplitter_1 = DataSplitter$1;
const url_1$1 = require$$4__default["default"];
const downloadPlanBuilder_1 = downloadPlanBuilder;
const multipleRangeDownloader_1 = multipleRangeDownloader;
const ProgressDifferentialDownloadCallbackTransform_1 = ProgressDifferentialDownloadCallbackTransform$1;
class DifferentialDownloader {
  constructor(blockAwareFileInfo, httpExecutor2, options) {
    this.blockAwareFileInfo = blockAwareFileInfo;
    this.httpExecutor = httpExecutor2;
    this.options = options;
    this.fileMetadataBuffer = null;
    this.logger = options.logger;
  }
  createRequestOptions() {
    const result = {
      headers: __spreadProps(__spreadValues({}, this.options.requestHeaders), {
        accept: "*/*"
      })
    };
    (0, builder_util_runtime_1$4.configureRequestUrl)(this.options.newUrl, result);
    (0, builder_util_runtime_1$4.configureRequestOptions)(result);
    return result;
  }
  doDownload(oldBlockMap, newBlockMap) {
    if (oldBlockMap.version !== newBlockMap.version) {
      throw new Error(`version is different (${oldBlockMap.version} - ${newBlockMap.version}), full download is required`);
    }
    const logger = this.logger;
    const operations = (0, downloadPlanBuilder_1.computeOperations)(oldBlockMap, newBlockMap, logger);
    if (logger.debug != null) {
      logger.debug(JSON.stringify(operations, null, 2));
    }
    let downloadSize = 0;
    let copySize = 0;
    for (const operation of operations) {
      const length = operation.end - operation.start;
      if (operation.kind === downloadPlanBuilder_1.OperationKind.DOWNLOAD) {
        downloadSize += length;
      } else {
        copySize += length;
      }
    }
    const newSize = this.blockAwareFileInfo.size;
    if (downloadSize + copySize + (this.fileMetadataBuffer == null ? 0 : this.fileMetadataBuffer.length) !== newSize) {
      throw new Error(`Internal error, size mismatch: downloadSize: ${downloadSize}, copySize: ${copySize}, newSize: ${newSize}`);
    }
    logger.info(`Full: ${formatBytes(newSize)}, To download: ${formatBytes(downloadSize)} (${Math.round(downloadSize / (newSize / 100))}%)`);
    return this.downloadFile(operations);
  }
  downloadFile(tasks) {
    const fdList = [];
    const closeFiles = () => {
      return Promise.all(fdList.map((openedFile) => {
        return (0, fs_extra_1$4.close)(openedFile.descriptor).catch((e) => {
          this.logger.error(`cannot close file "${openedFile.path}": ${e}`);
        });
      }));
    };
    return this.doDownloadFile(tasks, fdList).then(closeFiles).catch((e) => {
      return closeFiles().catch((closeFilesError) => {
        try {
          this.logger.error(`cannot close files: ${closeFilesError}`);
        } catch (errorOnLog) {
          try {
            console.error(errorOnLog);
          } catch (ignored) {
          }
        }
        throw e;
      }).then(() => {
        throw e;
      });
    });
  }
  async doDownloadFile(tasks, fdList) {
    const oldFileFd = await (0, fs_extra_1$4.open)(this.options.oldFile, "r");
    fdList.push({ descriptor: oldFileFd, path: this.options.oldFile });
    const newFileFd = await (0, fs_extra_1$4.open)(this.options.newFile, "w");
    fdList.push({ descriptor: newFileFd, path: this.options.newFile });
    const fileOut = (0, fs_1$4.createWriteStream)(this.options.newFile, { fd: newFileFd });
    await new Promise((resolve2, reject) => {
      const streams = [];
      let downloadInfoTransform = void 0;
      if (!this.options.isUseMultipleRangeRequest && this.options.onProgress) {
        const expectedByteCounts = [];
        let grandTotalBytes = 0;
        for (const task of tasks) {
          if (task.kind === downloadPlanBuilder_1.OperationKind.DOWNLOAD) {
            expectedByteCounts.push(task.end - task.start);
            grandTotalBytes += task.end - task.start;
          }
        }
        const progressDifferentialDownloadInfo = {
          expectedByteCounts,
          grandTotal: grandTotalBytes
        };
        downloadInfoTransform = new ProgressDifferentialDownloadCallbackTransform_1.ProgressDifferentialDownloadCallbackTransform(progressDifferentialDownloadInfo, this.options.cancellationToken, this.options.onProgress);
        streams.push(downloadInfoTransform);
      }
      const digestTransform = new builder_util_runtime_1$4.DigestTransform(this.blockAwareFileInfo.sha512);
      digestTransform.isValidateOnEnd = false;
      streams.push(digestTransform);
      fileOut.on("finish", () => {
        fileOut.close(() => {
          fdList.splice(1, 1);
          try {
            digestTransform.validate();
          } catch (e) {
            reject(e);
            return;
          }
          resolve2(void 0);
        });
      });
      streams.push(fileOut);
      let lastStream = null;
      for (const stream of streams) {
        stream.on("error", reject);
        if (lastStream == null) {
          lastStream = stream;
        } else {
          lastStream = lastStream.pipe(stream);
        }
      }
      const firstStream = streams[0];
      let w2;
      if (this.options.isUseMultipleRangeRequest) {
        w2 = (0, multipleRangeDownloader_1.executeTasksUsingMultipleRangeRequests)(this, tasks, firstStream, oldFileFd, reject);
        w2(0);
        return;
      }
      let downloadOperationCount = 0;
      let actualUrl = null;
      this.logger.info(`Differential download: ${this.options.newUrl}`);
      const requestOptions = this.createRequestOptions();
      requestOptions.redirect = "manual";
      w2 = (index) => {
        var _a, _b;
        if (index >= tasks.length) {
          if (this.fileMetadataBuffer != null) {
            firstStream.write(this.fileMetadataBuffer);
          }
          firstStream.end();
          return;
        }
        const operation = tasks[index++];
        if (operation.kind === downloadPlanBuilder_1.OperationKind.COPY) {
          if (downloadInfoTransform) {
            downloadInfoTransform.beginFileCopy();
          }
          (0, DataSplitter_1.copyData)(operation, firstStream, oldFileFd, reject, () => w2(index));
          return;
        }
        const range2 = `bytes=${operation.start}-${operation.end - 1}`;
        requestOptions.headers.range = range2;
        (_b = (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, `download range: ${range2}`);
        if (downloadInfoTransform) {
          downloadInfoTransform.beginRangeDownload();
        }
        const request = this.httpExecutor.createRequest(requestOptions, (response) => {
          response.on("error", reject);
          response.on("abort", () => {
            reject(new Error("response has been aborted by the server"));
          });
          if (response.statusCode >= 400) {
            reject((0, builder_util_runtime_1$4.createHttpError)(response));
          }
          response.pipe(firstStream, {
            end: false
          });
          response.once("end", () => {
            if (downloadInfoTransform) {
              downloadInfoTransform.endRangeDownload();
            }
            if (++downloadOperationCount === 100) {
              downloadOperationCount = 0;
              setTimeout(() => w2(index), 1e3);
            } else {
              w2(index);
            }
          });
        });
        request.on("redirect", (statusCode, method, redirectUrl) => {
          this.logger.info(`Redirect to ${removeQuery(redirectUrl)}`);
          actualUrl = redirectUrl;
          (0, builder_util_runtime_1$4.configureRequestUrl)(new url_1$1.URL(actualUrl), requestOptions);
          request.followRedirect();
        });
        this.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
        request.end();
      };
      w2(0);
    });
  }
  async readRemoteBytes(start, endInclusive) {
    const buffer = Buffer.allocUnsafe(endInclusive + 1 - start);
    const requestOptions = this.createRequestOptions();
    requestOptions.headers.range = `bytes=${start}-${endInclusive}`;
    let position = 0;
    await this.request(requestOptions, (chunk) => {
      chunk.copy(buffer, position);
      position += chunk.length;
    });
    if (position !== buffer.length) {
      throw new Error(`Received data length ${position} is not equal to expected ${buffer.length}`);
    }
    return buffer;
  }
  request(requestOptions, dataHandler) {
    return new Promise((resolve2, reject) => {
      const request = this.httpExecutor.createRequest(requestOptions, (response) => {
        if (!(0, multipleRangeDownloader_1.checkIsRangesSupported)(response, reject)) {
          return;
        }
        response.on("data", dataHandler);
        response.on("end", () => resolve2());
      });
      this.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
      request.end();
    });
  }
}
DifferentialDownloader$1.DifferentialDownloader = DifferentialDownloader;
function formatBytes(value, symbol = " KB") {
  return new Intl.NumberFormat("en").format((value / 1024).toFixed(2)) + symbol;
}
function removeQuery(url) {
  const index = url.indexOf("?");
  return index < 0 ? url : url.substring(0, index);
}
Object.defineProperty(FileWithEmbeddedBlockMapDifferentialDownloader$1, "__esModule", { value: true });
FileWithEmbeddedBlockMapDifferentialDownloader$1.FileWithEmbeddedBlockMapDifferentialDownloader = void 0;
const fs_extra_1$3 = lib;
const DifferentialDownloader_1$1 = DifferentialDownloader$1;
const zlib_1$1 = require$$2__default$2["default"];
class FileWithEmbeddedBlockMapDifferentialDownloader extends DifferentialDownloader_1$1.DifferentialDownloader {
  async download() {
    const packageInfo = this.blockAwareFileInfo;
    const fileSize = packageInfo.size;
    const offset = fileSize - (packageInfo.blockMapSize + 4);
    this.fileMetadataBuffer = await this.readRemoteBytes(offset, fileSize - 1);
    const newBlockMap = readBlockMap(this.fileMetadataBuffer.slice(0, this.fileMetadataBuffer.length - 4));
    await this.doDownload(await readEmbeddedBlockMapData(this.options.oldFile), newBlockMap);
  }
}
FileWithEmbeddedBlockMapDifferentialDownloader$1.FileWithEmbeddedBlockMapDifferentialDownloader = FileWithEmbeddedBlockMapDifferentialDownloader;
function readBlockMap(data) {
  return JSON.parse((0, zlib_1$1.inflateRawSync)(data).toString());
}
async function readEmbeddedBlockMapData(file2) {
  const fd = await (0, fs_extra_1$3.open)(file2, "r");
  try {
    const fileSize = (await (0, fs_extra_1$3.fstat)(fd)).size;
    const sizeBuffer = Buffer.allocUnsafe(4);
    await (0, fs_extra_1$3.read)(fd, sizeBuffer, 0, sizeBuffer.length, fileSize - sizeBuffer.length);
    const dataBuffer = Buffer.allocUnsafe(sizeBuffer.readUInt32BE(0));
    await (0, fs_extra_1$3.read)(fd, dataBuffer, 0, dataBuffer.length, fileSize - sizeBuffer.length - dataBuffer.length);
    await (0, fs_extra_1$3.close)(fd);
    return readBlockMap(dataBuffer);
  } catch (e) {
    await (0, fs_extra_1$3.close)(fd);
    throw e;
  }
}
Object.defineProperty(AppImageUpdater$1, "__esModule", { value: true });
AppImageUpdater$1.AppImageUpdater = void 0;
const builder_util_runtime_1$3 = out;
const child_process_1$2 = require$$1__default$5["default"];
const fs_extra_1$2 = lib;
const fs_1$3 = require$$1__default$1["default"];
const path$7 = require$$1__default$2["default"];
const BaseUpdater_1$3 = BaseUpdater$1;
const FileWithEmbeddedBlockMapDifferentialDownloader_1$1 = FileWithEmbeddedBlockMapDifferentialDownloader$1;
const main_1$3 = main$1;
const Provider_1$4 = Provider$1;
class AppImageUpdater extends BaseUpdater_1$3.BaseUpdater {
  constructor(options, app2) {
    super(options, app2);
  }
  isUpdaterActive() {
    if (process.env["APPIMAGE"] == null) {
      if (process.env["SNAP"] == null) {
        this._logger.warn("APPIMAGE env is not defined, current application is not an AppImage");
      } else {
        this._logger.info("SNAP env is defined, updater is disabled");
      }
      return false;
    }
    return super.isUpdaterActive();
  }
  doDownloadUpdate(downloadUpdateOptions) {
    const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
    const fileInfo = (0, Provider_1$4.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "AppImage", ["rpm", "deb"]);
    return this.executeDownload({
      fileExtension: "AppImage",
      fileInfo,
      downloadUpdateOptions,
      task: async (updateFile, downloadOptions) => {
        const oldFile = process.env["APPIMAGE"];
        if (oldFile == null) {
          throw (0, builder_util_runtime_1$3.newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
        }
        let isDownloadFull = false;
        try {
          const downloadOptions2 = {
            newUrl: fileInfo.url,
            oldFile,
            logger: this._logger,
            newFile: updateFile,
            isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,
            requestHeaders: downloadUpdateOptions.requestHeaders,
            cancellationToken: downloadUpdateOptions.cancellationToken
          };
          if (this.listenerCount(main_1$3.DOWNLOAD_PROGRESS) > 0) {
            downloadOptions2.onProgress = (it) => this.emit(main_1$3.DOWNLOAD_PROGRESS, it);
          }
          await new FileWithEmbeddedBlockMapDifferentialDownloader_1$1.FileWithEmbeddedBlockMapDifferentialDownloader(fileInfo.info, this.httpExecutor, downloadOptions2).download();
        } catch (e) {
          this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
          isDownloadFull = process.platform === "linux";
        }
        if (isDownloadFull) {
          await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions);
        }
        await (0, fs_extra_1$2.chmod)(updateFile, 493);
      }
    });
  }
  doInstall(options) {
    const appImageFile = process.env["APPIMAGE"];
    if (appImageFile == null) {
      throw (0, builder_util_runtime_1$3.newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
    }
    (0, fs_1$3.unlinkSync)(appImageFile);
    let destination;
    const existingBaseName = path$7.basename(appImageFile);
    if (path$7.basename(options.installerPath) === existingBaseName || !/\d+\.\d+\.\d+/.test(existingBaseName)) {
      destination = appImageFile;
    } else {
      destination = path$7.join(path$7.dirname(appImageFile), path$7.basename(options.installerPath));
    }
    (0, child_process_1$2.execFileSync)("mv", ["-f", options.installerPath, destination]);
    if (destination !== appImageFile) {
      this.emit("appimage-filename-updated", destination);
    }
    const env2 = __spreadProps(__spreadValues({}, process.env), {
      APPIMAGE_SILENT_INSTALL: "true"
    });
    if (options.isForceRunAfter) {
      this.spawnLog(destination, [], env2);
    } else {
      env2.APPIMAGE_EXIT_AFTER_INSTALL = "true";
      (0, child_process_1$2.execFileSync)(destination, [], { env: env2 });
    }
    return true;
  }
}
AppImageUpdater$1.AppImageUpdater = AppImageUpdater;
var DebUpdater$1 = {};
Object.defineProperty(DebUpdater$1, "__esModule", { value: true });
DebUpdater$1.DebUpdater = void 0;
const BaseUpdater_1$2 = BaseUpdater$1;
const main_1$2 = main$1;
const Provider_1$3 = Provider$1;
class DebUpdater extends BaseUpdater_1$2.BaseUpdater {
  constructor(options, app2) {
    super(options, app2);
  }
  doDownloadUpdate(downloadUpdateOptions) {
    const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
    const fileInfo = (0, Provider_1$3.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "deb", ["AppImage", "rpm"]);
    return this.executeDownload({
      fileExtension: "deb",
      fileInfo,
      downloadUpdateOptions,
      task: async (updateFile, downloadOptions) => {
        if (this.listenerCount(main_1$2.DOWNLOAD_PROGRESS) > 0) {
          downloadOptions.onProgress = (it) => this.emit(main_1$2.DOWNLOAD_PROGRESS, it);
        }
        await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions);
      }
    });
  }
  doInstall(options) {
    const sudo = this.wrapSudo();
    const wrapper = /pkexec/i.test(sudo) ? "" : `"`;
    const cmd = ["dpkg", "-i", options.installerPath, "||", "apt-get", "install", "-f", "-y"];
    this.spawnSyncLog(sudo, [`${wrapper}/bin/bash`, "-c", `'${cmd.join(" ")}'${wrapper}`]);
    return true;
  }
}
DebUpdater$1.DebUpdater = DebUpdater;
var RpmUpdater$1 = {};
Object.defineProperty(RpmUpdater$1, "__esModule", { value: true });
RpmUpdater$1.RpmUpdater = void 0;
const BaseUpdater_1$1 = BaseUpdater$1;
const main_1$1 = main$1;
const Provider_1$2 = Provider$1;
class RpmUpdater extends BaseUpdater_1$1.BaseUpdater {
  constructor(options, app2) {
    super(options, app2);
  }
  doDownloadUpdate(downloadUpdateOptions) {
    const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
    const fileInfo = (0, Provider_1$2.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "rpm", ["AppImage", "deb"]);
    return this.executeDownload({
      fileExtension: "rpm",
      fileInfo,
      downloadUpdateOptions,
      task: async (updateFile, downloadOptions) => {
        if (this.listenerCount(main_1$1.DOWNLOAD_PROGRESS) > 0) {
          downloadOptions.onProgress = (it) => this.emit(main_1$1.DOWNLOAD_PROGRESS, it);
        }
        await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions);
      }
    });
  }
  doInstall(options) {
    const upgradePath = options.installerPath;
    const sudo = this.wrapSudo();
    const wrapper = /pkexec/i.test(sudo) ? "" : `"`;
    const packageManager = this.spawnSyncLog("which zypper");
    let cmd;
    if (!packageManager) {
      const packageManager2 = this.spawnSyncLog("which dnf || which yum");
      cmd = [packageManager2, "-y", "remove", `'${this.app.name}'`, ";", packageManager2, "-y", "install", upgradePath];
    } else {
      cmd = [
        packageManager,
        "remove",
        "-y",
        `'${this.app.name}'`,
        ";",
        packageManager,
        "clean",
        "--all",
        ";",
        packageManager,
        "--no-refresh",
        "install",
        "--allow-unsigned-rpm",
        "-y",
        "-f",
        upgradePath
      ];
    }
    this.spawnSyncLog(sudo, [`${wrapper}/bin/bash`, "-c", `'${cmd.join(" ")}'${wrapper}`]);
    return true;
  }
}
RpmUpdater$1.RpmUpdater = RpmUpdater;
var MacUpdater$1 = {};
Object.defineProperty(MacUpdater$1, "__esModule", { value: true });
MacUpdater$1.MacUpdater = void 0;
const builder_util_runtime_1$2 = out;
const fs_extra_1$1 = lib;
const fs_1$2 = require$$1__default$1["default"];
const http_1 = require$$3__default["default"];
const AppUpdater_1 = AppUpdater$1;
const Provider_1$1 = Provider$1;
const child_process_1$1 = require$$1__default$5["default"];
const crypto_1 = require$$0__default$3["default"];
class MacUpdater extends AppUpdater_1.AppUpdater {
  constructor(options, app2) {
    super(options, app2);
    this.nativeUpdater = require$$1__default["default"].autoUpdater;
    this.squirrelDownloadedUpdate = false;
    this.nativeUpdater.on("error", (it) => {
      this._logger.warn(it);
      this.emit("error", it);
    });
    this.nativeUpdater.on("update-downloaded", () => {
      this.squirrelDownloadedUpdate = true;
    });
  }
  debug(message) {
    if (this._logger.debug != null) {
      this._logger.debug(message);
    }
  }
  async doDownloadUpdate(downloadUpdateOptions) {
    let files = downloadUpdateOptions.updateInfoAndProvider.provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info);
    const log = this._logger;
    const sysctlRosettaInfoKey = "sysctl.proc_translated";
    let isRosetta = false;
    try {
      this.debug("Checking for macOS Rosetta environment");
      const result = (0, child_process_1$1.execFileSync)("sysctl", [sysctlRosettaInfoKey], { encoding: "utf8" });
      isRosetta = result.includes(`${sysctlRosettaInfoKey}: 1`);
      log.info(`Checked for macOS Rosetta environment (isRosetta=${isRosetta})`);
    } catch (e) {
      log.warn(`sysctl shell command to check for macOS Rosetta environment failed: ${e}`);
    }
    let isArm64Mac = false;
    try {
      this.debug("Checking for arm64 in uname");
      const result = (0, child_process_1$1.execFileSync)("uname", ["-a"], { encoding: "utf8" });
      const isArm = result.includes("ARM");
      log.info(`Checked 'uname -a': arm64=${isArm}`);
      isArm64Mac = isArm64Mac || isArm;
    } catch (e) {
      log.warn(`uname shell command to check for arm64 failed: ${e}`);
    }
    isArm64Mac = isArm64Mac || process.arch === "arm64" || isRosetta;
    const isArm64 = (file2) => {
      var _a;
      return file2.url.pathname.includes("arm64") || ((_a = file2.info.url) === null || _a === void 0 ? void 0 : _a.includes("arm64"));
    };
    if (isArm64Mac && files.some(isArm64)) {
      files = files.filter((file2) => isArm64Mac === isArm64(file2));
    } else {
      files = files.filter((file2) => !isArm64(file2));
    }
    const zipFileInfo = (0, Provider_1$1.findFile)(files, "zip", ["pkg", "dmg"]);
    if (zipFileInfo == null) {
      throw (0, builder_util_runtime_1$2.newError)(`ZIP file not provided: ${(0, builder_util_runtime_1$2.safeStringifyJson)(files)}`, "ERR_UPDATER_ZIP_FILE_NOT_FOUND");
    }
    return this.executeDownload({
      fileExtension: "zip",
      fileInfo: zipFileInfo,
      downloadUpdateOptions,
      task: (destinationFile, downloadOptions) => {
        return this.httpExecutor.download(zipFileInfo.url, destinationFile, downloadOptions);
      },
      done: (event) => this.updateDownloaded(zipFileInfo, event)
    });
  }
  async updateDownloaded(zipFileInfo, event) {
    var _a, _b;
    const downloadedFile = event.downloadedFile;
    const updateFileSize = (_a = zipFileInfo.info.size) !== null && _a !== void 0 ? _a : (await (0, fs_extra_1$1.stat)(downloadedFile)).size;
    const log = this._logger;
    const logContext = `fileToProxy=${zipFileInfo.url.href}`;
    this.debug(`Creating proxy server for native Squirrel.Mac (${logContext})`);
    (_b = this.server) === null || _b === void 0 ? void 0 : _b.close();
    this.server = (0, http_1.createServer)();
    this.debug(`Proxy server for native Squirrel.Mac is created (${logContext})`);
    this.server.on("close", () => {
      log.info(`Proxy server for native Squirrel.Mac is closed (${logContext})`);
    });
    const getServerUrl = (s2) => {
      const address = s2.address();
      if (typeof address === "string") {
        return address;
      }
      return `http://127.0.0.1:${address === null || address === void 0 ? void 0 : address.port}`;
    };
    return await new Promise((resolve2, reject) => {
      const pass = (0, crypto_1.randomBytes)(64).toString("base64").replace(/\//g, "_").replace(/\+/g, "-");
      const authInfo = Buffer.from(`autoupdater:${pass}`, "ascii");
      const fileUrl = `/${(0, crypto_1.randomBytes)(64).toString("hex")}.zip`;
      this.server.on("request", (request, response) => {
        const requestUrl = request.url;
        log.info(`${requestUrl} requested`);
        if (requestUrl === "/") {
          if (!request.headers.authorization || request.headers.authorization.indexOf("Basic ") === -1) {
            response.statusCode = 401;
            response.statusMessage = "Invalid Authentication Credentials";
            response.end();
            log.warn("No authenthication info");
            return;
          }
          const base64Credentials = request.headers.authorization.split(" ")[1];
          const credentials = Buffer.from(base64Credentials, "base64").toString("ascii");
          const [username, password] = credentials.split(":");
          if (username !== "autoupdater" || password !== pass) {
            response.statusCode = 401;
            response.statusMessage = "Invalid Authentication Credentials";
            response.end();
            log.warn("Invalid authenthication credentials");
            return;
          }
          const data = Buffer.from(`{ "url": "${getServerUrl(this.server)}${fileUrl}" }`);
          response.writeHead(200, { "Content-Type": "application/json", "Content-Length": data.length });
          response.end(data);
          return;
        }
        if (!requestUrl.startsWith(fileUrl)) {
          log.warn(`${requestUrl} requested, but not supported`);
          response.writeHead(404);
          response.end();
          return;
        }
        log.info(`${fileUrl} requested by Squirrel.Mac, pipe ${downloadedFile}`);
        let errorOccurred = false;
        response.on("finish", () => {
          if (!errorOccurred) {
            this.nativeUpdater.removeListener("error", reject);
            resolve2([]);
          }
        });
        const readStream = (0, fs_1$2.createReadStream)(downloadedFile);
        readStream.on("error", (error2) => {
          try {
            response.end();
          } catch (e) {
            log.warn(`cannot end response: ${e}`);
          }
          errorOccurred = true;
          this.nativeUpdater.removeListener("error", reject);
          reject(new Error(`Cannot pipe "${downloadedFile}": ${error2}`));
        });
        response.writeHead(200, {
          "Content-Type": "application/zip",
          "Content-Length": updateFileSize
        });
        readStream.pipe(response);
      });
      this.debug(`Proxy server for native Squirrel.Mac is starting to listen (${logContext})`);
      this.server.listen(0, "127.0.0.1", () => {
        this.debug(`Proxy server for native Squirrel.Mac is listening (address=${getServerUrl(this.server)}, ${logContext})`);
        this.nativeUpdater.setFeedURL({
          url: getServerUrl(this.server),
          headers: {
            "Cache-Control": "no-cache",
            Authorization: `Basic ${authInfo.toString("base64")}`
          }
        });
        this.dispatchUpdateDownloaded(event);
        if (this.autoInstallOnAppQuit) {
          this.nativeUpdater.once("error", reject);
          this.nativeUpdater.checkForUpdates();
        } else {
          resolve2([]);
        }
      });
    });
  }
  quitAndInstall() {
    var _a;
    if (this.squirrelDownloadedUpdate) {
      this.nativeUpdater.quitAndInstall();
      (_a = this.server) === null || _a === void 0 ? void 0 : _a.close();
    } else {
      this.nativeUpdater.on("update-downloaded", () => {
        var _a2;
        this.nativeUpdater.quitAndInstall();
        (_a2 = this.server) === null || _a2 === void 0 ? void 0 : _a2.close();
      });
      if (!this.autoInstallOnAppQuit) {
        this.nativeUpdater.checkForUpdates();
      }
    }
  }
}
MacUpdater$1.MacUpdater = MacUpdater;
var NsisUpdater$1 = {};
var GenericDifferentialDownloader$1 = {};
Object.defineProperty(GenericDifferentialDownloader$1, "__esModule", { value: true });
GenericDifferentialDownloader$1.GenericDifferentialDownloader = void 0;
const DifferentialDownloader_1 = DifferentialDownloader$1;
class GenericDifferentialDownloader extends DifferentialDownloader_1.DifferentialDownloader {
  download(oldBlockMap, newBlockMap) {
    return this.doDownload(oldBlockMap, newBlockMap);
  }
}
GenericDifferentialDownloader$1.GenericDifferentialDownloader = GenericDifferentialDownloader;
var windowsExecutableCodeSignatureVerifier = {};
Object.defineProperty(windowsExecutableCodeSignatureVerifier, "__esModule", { value: true });
windowsExecutableCodeSignatureVerifier.verifySignature = void 0;
const builder_util_runtime_1$1 = out;
const child_process_1 = require$$1__default$5["default"];
const os$1 = require$$1__default$4["default"];
function verifySignature(publisherNames, unescapedTempUpdateFile, logger) {
  return new Promise((resolve2, reject) => {
    const tempUpdateFile = unescapedTempUpdateFile.replace(/'/g, "''");
    (0, child_process_1.execFile)("chcp 65001 >NUL & powershell.exe", ["-NoProfile", "-NonInteractive", "-InputFormat", "None", "-Command", `"Get-AuthenticodeSignature -LiteralPath '${tempUpdateFile}' | ConvertTo-Json -Compress"`], {
      shell: true,
      timeout: 20 * 1e3
    }, (error2, stdout, stderr) => {
      try {
        if (error2 != null || stderr) {
          handleError(logger, error2, stderr, reject);
          resolve2(null);
          return;
        }
        const data = parseOut(stdout);
        if (data.Status === 0) {
          const subject = (0, builder_util_runtime_1$1.parseDn)(data.SignerCertificate.Subject);
          let match = false;
          for (const name of publisherNames) {
            const dn = (0, builder_util_runtime_1$1.parseDn)(name);
            if (dn.size) {
              const allKeys = Array.from(dn.keys());
              match = allKeys.every((key) => {
                return dn.get(key) === subject.get(key);
              });
            } else if (name === subject.get("CN")) {
              logger.warn(`Signature validated using only CN ${name}. Please add your full Distinguished Name (DN) to publisherNames configuration`);
              match = true;
            }
            if (match) {
              resolve2(null);
              return;
            }
          }
        }
        const result = `publisherNames: ${publisherNames.join(" | ")}, raw info: ` + JSON.stringify(data, (name, value) => name === "RawData" ? void 0 : value, 2);
        logger.warn(`Sign verification failed, installer signed with incorrect certificate: ${result}`);
        resolve2(result);
      } catch (e) {
        handleError(logger, e, null, reject);
        resolve2(null);
        return;
      }
    });
  });
}
windowsExecutableCodeSignatureVerifier.verifySignature = verifySignature;
function parseOut(out2) {
  const data = JSON.parse(out2);
  delete data.PrivateKey;
  delete data.IsOSBinary;
  delete data.SignatureType;
  const signerCertificate = data.SignerCertificate;
  if (signerCertificate != null) {
    delete signerCertificate.Archived;
    delete signerCertificate.Extensions;
    delete signerCertificate.Handle;
    delete signerCertificate.HasPrivateKey;
    delete signerCertificate.SubjectName;
  }
  delete data.Path;
  return data;
}
function handleError(logger, error2, stderr, reject) {
  if (isOldWin6()) {
    logger.warn(`Cannot execute Get-AuthenticodeSignature: ${error2 || stderr}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
    return;
  }
  try {
    (0, child_process_1.execFileSync)("powershell.exe", ["-NoProfile", "-NonInteractive", "-Command", "ConvertTo-Json test"], { timeout: 10 * 1e3 });
  } catch (testError) {
    logger.warn(`Cannot execute ConvertTo-Json: ${testError.message}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
    return;
  }
  if (error2 != null) {
    reject(error2);
  }
  if (stderr) {
    reject(new Error(`Cannot execute Get-AuthenticodeSignature, stderr: ${stderr}. Failing signature validation due to unknown stderr.`));
  }
}
function isOldWin6() {
  const winVersion = os$1.release();
  return winVersion.startsWith("6.") && !winVersion.startsWith("6.3");
}
Object.defineProperty(NsisUpdater$1, "__esModule", { value: true });
NsisUpdater$1.NsisUpdater = void 0;
const builder_util_runtime_1 = out;
const path$6 = require$$1__default$2["default"];
const BaseUpdater_1 = BaseUpdater$1;
const FileWithEmbeddedBlockMapDifferentialDownloader_1 = FileWithEmbeddedBlockMapDifferentialDownloader$1;
const GenericDifferentialDownloader_1 = GenericDifferentialDownloader$1;
const main_1 = main$1;
const util_1$q = util$1;
const Provider_1 = Provider$1;
const fs_extra_1 = lib;
const windowsExecutableCodeSignatureVerifier_1 = windowsExecutableCodeSignatureVerifier;
const url_1 = require$$4__default["default"];
const zlib_1 = require$$2__default$2["default"];
class NsisUpdater extends BaseUpdater_1.BaseUpdater {
  constructor(options, app2) {
    super(options, app2);
    this._verifyUpdateCodeSignature = (publisherNames, unescapedTempUpdateFile) => (0, windowsExecutableCodeSignatureVerifier_1.verifySignature)(publisherNames, unescapedTempUpdateFile, this._logger);
  }
  get verifyUpdateCodeSignature() {
    return this._verifyUpdateCodeSignature;
  }
  set verifyUpdateCodeSignature(value) {
    if (value) {
      this._verifyUpdateCodeSignature = value;
    }
  }
  doDownloadUpdate(downloadUpdateOptions) {
    const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
    const fileInfo = (0, Provider_1.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "exe");
    return this.executeDownload({
      fileExtension: "exe",
      downloadUpdateOptions,
      fileInfo,
      task: async (destinationFile, downloadOptions, packageFile, removeTempDirIfAny) => {
        const packageInfo = fileInfo.packageInfo;
        const isWebInstaller = packageInfo != null && packageFile != null;
        if (isWebInstaller && downloadUpdateOptions.disableWebInstaller) {
          throw (0, builder_util_runtime_1.newError)(`Unable to download new version ${downloadUpdateOptions.updateInfoAndProvider.info.version}. Web Installers are disabled`, "ERR_UPDATER_WEB_INSTALLER_DISABLED");
        }
        if (!isWebInstaller && !downloadUpdateOptions.disableWebInstaller) {
          this._logger.warn("disableWebInstaller is set to false, you should set it to true if you do not plan on using a web installer. This will default to true in a future version.");
        }
        if (isWebInstaller || await this.differentialDownloadInstaller(fileInfo, downloadUpdateOptions, destinationFile, provider)) {
          await this.httpExecutor.download(fileInfo.url, destinationFile, downloadOptions);
        }
        const signatureVerificationStatus = await this.verifySignature(destinationFile);
        if (signatureVerificationStatus != null) {
          await removeTempDirIfAny();
          throw (0, builder_util_runtime_1.newError)(`New version ${downloadUpdateOptions.updateInfoAndProvider.info.version} is not signed by the application owner: ${signatureVerificationStatus}`, "ERR_UPDATER_INVALID_SIGNATURE");
        }
        if (isWebInstaller) {
          if (await this.differentialDownloadWebPackage(downloadUpdateOptions, packageInfo, packageFile, provider)) {
            try {
              await this.httpExecutor.download(new url_1.URL(packageInfo.path), packageFile, {
                headers: downloadUpdateOptions.requestHeaders,
                cancellationToken: downloadUpdateOptions.cancellationToken,
                sha512: packageInfo.sha512
              });
            } catch (e) {
              try {
                await (0, fs_extra_1.unlink)(packageFile);
              } catch (ignored) {
              }
              throw e;
            }
          }
        }
      }
    });
  }
  async verifySignature(tempUpdateFile) {
    let publisherName;
    try {
      publisherName = (await this.configOnDisk.value).publisherName;
      if (publisherName == null) {
        return null;
      }
    } catch (e) {
      if (e.code === "ENOENT") {
        return null;
      }
      throw e;
    }
    return await this._verifyUpdateCodeSignature(Array.isArray(publisherName) ? publisherName : [publisherName], tempUpdateFile);
  }
  doInstall(options) {
    const args = ["--updated"];
    if (options.isSilent) {
      args.push("/S");
    }
    if (options.isForceRunAfter) {
      args.push("--force-run");
    }
    if (this.installDirectory) {
      args.push(`/D=${this.installDirectory}`);
    }
    const packagePath = this.downloadedUpdateHelper == null ? null : this.downloadedUpdateHelper.packageFile;
    if (packagePath != null) {
      args.push(`--package-file=${packagePath}`);
    }
    const callUsingElevation = () => {
      this.spawnLog(path$6.join(process.resourcesPath, "elevate.exe"), [options.installerPath].concat(args)).catch((e) => this.dispatchError(e));
    };
    if (options.isAdminRightsRequired) {
      this._logger.info("isAdminRightsRequired is set to true, run installer using elevate.exe");
      callUsingElevation();
      return true;
    }
    this.spawnLog(options.installerPath, args).catch((e) => {
      const errorCode = e.code;
      this._logger.info(`Cannot run installer: error code: ${errorCode}, error message: "${e.message}", will be executed again using elevate if EACCES"`);
      if (errorCode === "UNKNOWN" || errorCode === "EACCES") {
        callUsingElevation();
      } else {
        this.dispatchError(e);
      }
    });
    return true;
  }
  async differentialDownloadInstaller(fileInfo, downloadUpdateOptions, installerPath, provider) {
    try {
      if (this._testOnlyOptions != null && !this._testOnlyOptions.isUseDifferentialDownload) {
        return true;
      }
      const blockmapFileUrls = (0, util_1$q.blockmapFiles)(fileInfo.url, this.app.version, downloadUpdateOptions.updateInfoAndProvider.info.version);
      this._logger.info(`Download block maps (old: "${blockmapFileUrls[0]}", new: ${blockmapFileUrls[1]})`);
      const downloadBlockMap = async (url) => {
        const data = await this.httpExecutor.downloadToBuffer(url, {
          headers: downloadUpdateOptions.requestHeaders,
          cancellationToken: downloadUpdateOptions.cancellationToken
        });
        if (data == null || data.length === 0) {
          throw new Error(`Blockmap "${url.href}" is empty`);
        }
        try {
          return JSON.parse((0, zlib_1.gunzipSync)(data).toString());
        } catch (e) {
          throw new Error(`Cannot parse blockmap "${url.href}", error: ${e}`);
        }
      };
      const downloadOptions = {
        newUrl: fileInfo.url,
        oldFile: path$6.join(this.downloadedUpdateHelper.cacheDir, builder_util_runtime_1.CURRENT_APP_INSTALLER_FILE_NAME),
        logger: this._logger,
        newFile: installerPath,
        isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,
        requestHeaders: downloadUpdateOptions.requestHeaders,
        cancellationToken: downloadUpdateOptions.cancellationToken
      };
      if (this.listenerCount(main_1.DOWNLOAD_PROGRESS) > 0) {
        downloadOptions.onProgress = (it) => this.emit(main_1.DOWNLOAD_PROGRESS, it);
      }
      const blockMapDataList = await Promise.all(blockmapFileUrls.map((u2) => downloadBlockMap(u2)));
      await new GenericDifferentialDownloader_1.GenericDifferentialDownloader(fileInfo.info, this.httpExecutor, downloadOptions).download(blockMapDataList[0], blockMapDataList[1]);
      return false;
    } catch (e) {
      this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
      if (this._testOnlyOptions != null) {
        throw e;
      }
      return true;
    }
  }
  async differentialDownloadWebPackage(downloadUpdateOptions, packageInfo, packagePath, provider) {
    if (packageInfo.blockMapSize == null) {
      return true;
    }
    try {
      const downloadOptions = {
        newUrl: new url_1.URL(packageInfo.path),
        oldFile: path$6.join(this.downloadedUpdateHelper.cacheDir, builder_util_runtime_1.CURRENT_APP_PACKAGE_FILE_NAME),
        logger: this._logger,
        newFile: packagePath,
        requestHeaders: this.requestHeaders,
        isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,
        cancellationToken: downloadUpdateOptions.cancellationToken
      };
      if (this.listenerCount(main_1.DOWNLOAD_PROGRESS) > 0) {
        downloadOptions.onProgress = (it) => this.emit(main_1.DOWNLOAD_PROGRESS, it);
      }
      await new FileWithEmbeddedBlockMapDifferentialDownloader_1.FileWithEmbeddedBlockMapDifferentialDownloader(packageInfo, this.httpExecutor, downloadOptions).download();
    } catch (e) {
      this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
      return process.platform === "win32";
    }
    return false;
  }
}
NsisUpdater$1.NsisUpdater = NsisUpdater;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UpdaterSignal = exports.UPDATE_DOWNLOADED = exports.DOWNLOAD_PROGRESS = exports.NsisUpdater = exports.MacUpdater = exports.RpmUpdater = exports.DebUpdater = exports.AppImageUpdater = exports.Provider = exports.CancellationToken = exports.NoOpLogger = exports.AppUpdater = void 0;
  const builder_util_runtime_12 = out;
  Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
    return builder_util_runtime_12.CancellationToken;
  } });
  const fs_extra_12 = lib;
  const path2 = require$$1__default$2["default"];
  var AppUpdater_12 = AppUpdater$1;
  Object.defineProperty(exports, "AppUpdater", { enumerable: true, get: function() {
    return AppUpdater_12.AppUpdater;
  } });
  Object.defineProperty(exports, "NoOpLogger", { enumerable: true, get: function() {
    return AppUpdater_12.NoOpLogger;
  } });
  var Provider_12 = Provider$1;
  Object.defineProperty(exports, "Provider", { enumerable: true, get: function() {
    return Provider_12.Provider;
  } });
  var AppImageUpdater_1 = AppImageUpdater$1;
  Object.defineProperty(exports, "AppImageUpdater", { enumerable: true, get: function() {
    return AppImageUpdater_1.AppImageUpdater;
  } });
  var DebUpdater_1 = DebUpdater$1;
  Object.defineProperty(exports, "DebUpdater", { enumerable: true, get: function() {
    return DebUpdater_1.DebUpdater;
  } });
  var RpmUpdater_1 = RpmUpdater$1;
  Object.defineProperty(exports, "RpmUpdater", { enumerable: true, get: function() {
    return RpmUpdater_1.RpmUpdater;
  } });
  var MacUpdater_1 = MacUpdater$1;
  Object.defineProperty(exports, "MacUpdater", { enumerable: true, get: function() {
    return MacUpdater_1.MacUpdater;
  } });
  var NsisUpdater_1 = NsisUpdater$1;
  Object.defineProperty(exports, "NsisUpdater", { enumerable: true, get: function() {
    return NsisUpdater_1.NsisUpdater;
  } });
  let _autoUpdater;
  function doLoadAutoUpdater() {
    if (process.platform === "win32") {
      _autoUpdater = new NsisUpdater$1.NsisUpdater();
    } else if (process.platform === "darwin") {
      _autoUpdater = new MacUpdater$1.MacUpdater();
    } else {
      _autoUpdater = new AppImageUpdater$1.AppImageUpdater();
      try {
        const identity = path2.join(process.resourcesPath, "package-type");
        if (!(0, fs_extra_12.existsSync)(identity)) {
          return _autoUpdater;
        }
        console.info("Checking for beta autoupdate feature for deb/rpm distributions");
        const fileType = (0, fs_extra_12.readFileSync)(identity).toString().trim();
        console.info("Found package-type:", fileType);
        switch (fileType) {
          case "deb":
            _autoUpdater = new DebUpdater$1.DebUpdater();
            break;
          case "rpm":
            _autoUpdater = new RpmUpdater$1.RpmUpdater();
            break;
          default:
            break;
        }
      } catch (error2) {
        console.warn("Unable to detect 'package-type' for autoUpdater (beta rpm/deb support). If you'd like to expand support, please consider contributing to electron-builder", error2.message);
      }
    }
    return _autoUpdater;
  }
  Object.defineProperty(exports, "autoUpdater", {
    enumerable: true,
    get: () => {
      return _autoUpdater || doLoadAutoUpdater();
    }
  });
  exports.DOWNLOAD_PROGRESS = "download-progress";
  exports.UPDATE_DOWNLOADED = "update-downloaded";
  class UpdaterSignal {
    constructor(emitter) {
      this.emitter = emitter;
    }
    login(handler) {
      addHandler(this.emitter, "login", handler);
    }
    progress(handler) {
      addHandler(this.emitter, exports.DOWNLOAD_PROGRESS, handler);
    }
    updateDownloaded(handler) {
      addHandler(this.emitter, exports.UPDATE_DOWNLOADED, handler);
    }
    updateCancelled(handler) {
      addHandler(this.emitter, "update-cancelled", handler);
    }
  }
  exports.UpdaterSignal = UpdaterSignal;
  function addHandler(emitter, event, handler) {
    {
      emitter.on(event, handler);
    }
  }
})(main$1);
var source = { exports: {} };
var isObj$1 = (value) => {
  const type2 = typeof value;
  return value !== null && (type2 === "object" || type2 === "function");
};
const isObj = isObj$1;
const disallowedKeys = new Set([
  "__proto__",
  "prototype",
  "constructor"
]);
const isValidPath = (pathSegments) => !pathSegments.some((segment) => disallowedKeys.has(segment));
function getPathSegments(path2) {
  const pathArray = path2.split(".");
  const parts = [];
  for (let i2 = 0; i2 < pathArray.length; i2++) {
    let p = pathArray[i2];
    while (p[p.length - 1] === "\\" && pathArray[i2 + 1] !== void 0) {
      p = p.slice(0, -1) + ".";
      p += pathArray[++i2];
    }
    parts.push(p);
  }
  if (!isValidPath(parts)) {
    return [];
  }
  return parts;
}
var dotProp = {
  get(object, path2, value) {
    if (!isObj(object) || typeof path2 !== "string") {
      return value === void 0 ? object : value;
    }
    const pathArray = getPathSegments(path2);
    if (pathArray.length === 0) {
      return;
    }
    for (let i2 = 0; i2 < pathArray.length; i2++) {
      object = object[pathArray[i2]];
      if (object === void 0 || object === null) {
        if (i2 !== pathArray.length - 1) {
          return value;
        }
        break;
      }
    }
    return object === void 0 ? value : object;
  },
  set(object, path2, value) {
    if (!isObj(object) || typeof path2 !== "string") {
      return object;
    }
    const root2 = object;
    const pathArray = getPathSegments(path2);
    for (let i2 = 0; i2 < pathArray.length; i2++) {
      const p = pathArray[i2];
      if (!isObj(object[p])) {
        object[p] = {};
      }
      if (i2 === pathArray.length - 1) {
        object[p] = value;
      }
      object = object[p];
    }
    return root2;
  },
  delete(object, path2) {
    if (!isObj(object) || typeof path2 !== "string") {
      return false;
    }
    const pathArray = getPathSegments(path2);
    for (let i2 = 0; i2 < pathArray.length; i2++) {
      const p = pathArray[i2];
      if (i2 === pathArray.length - 1) {
        delete object[p];
        return true;
      }
      object = object[p];
      if (!isObj(object)) {
        return false;
      }
    }
  },
  has(object, path2) {
    if (!isObj(object) || typeof path2 !== "string") {
      return false;
    }
    const pathArray = getPathSegments(path2);
    if (pathArray.length === 0) {
      return false;
    }
    for (let i2 = 0; i2 < pathArray.length; i2++) {
      if (isObj(object)) {
        if (!(pathArray[i2] in object)) {
          return false;
        }
        object = object[pathArray[i2]];
      } else {
        return false;
      }
    }
    return true;
  }
};
var pkgUp = { exports: {} };
var findUp$1 = { exports: {} };
var locatePath$1 = { exports: {} };
var pathExists$1 = { exports: {} };
const fs$2 = require$$1__default$1["default"];
pathExists$1.exports = (fp) => new Promise((resolve2) => {
  fs$2.access(fp, (err) => {
    resolve2(!err);
  });
});
pathExists$1.exports.sync = (fp) => {
  try {
    fs$2.accessSync(fp);
    return true;
  } catch (err) {
    return false;
  }
};
var pLimit$2 = { exports: {} };
var pTry$2 = { exports: {} };
const pTry$1 = (fn, ...arguments_) => new Promise((resolve2) => {
  resolve2(fn(...arguments_));
});
pTry$2.exports = pTry$1;
pTry$2.exports.default = pTry$1;
const pTry = pTry$2.exports;
const pLimit$1 = (concurrency) => {
  if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
    return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
  }
  const queue2 = [];
  let activeCount = 0;
  const next = () => {
    activeCount--;
    if (queue2.length > 0) {
      queue2.shift()();
    }
  };
  const run = (fn, resolve2, ...args) => {
    activeCount++;
    const result = pTry(fn, ...args);
    resolve2(result);
    result.then(next, next);
  };
  const enqueue2 = (fn, resolve2, ...args) => {
    if (activeCount < concurrency) {
      run(fn, resolve2, ...args);
    } else {
      queue2.push(run.bind(null, fn, resolve2, ...args));
    }
  };
  const generator = (fn, ...args) => new Promise((resolve2) => enqueue2(fn, resolve2, ...args));
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue2.length
    },
    clearQueue: {
      value: () => {
        queue2.length = 0;
      }
    }
  });
  return generator;
};
pLimit$2.exports = pLimit$1;
pLimit$2.exports.default = pLimit$1;
const pLimit = pLimit$2.exports;
class EndError extends Error {
  constructor(value) {
    super();
    this.value = value;
  }
}
const testElement = (el, tester) => Promise.resolve(el).then(tester);
const finder = (el) => Promise.all(el).then((val) => val[1] === true && Promise.reject(new EndError(val[0])));
var pLocate$1 = (iterable, tester, opts2) => {
  opts2 = Object.assign({
    concurrency: Infinity,
    preserveOrder: true
  }, opts2);
  const limit2 = pLimit(opts2.concurrency);
  const items2 = [...iterable].map((el) => [el, limit2(testElement, el, tester)]);
  const checkLimit = pLimit(opts2.preserveOrder ? 1 : Infinity);
  return Promise.all(items2.map((el) => checkLimit(finder, el))).then(() => {
  }).catch((err) => err instanceof EndError ? err.value : Promise.reject(err));
};
const path$5 = require$$1__default$2["default"];
const pathExists = pathExists$1.exports;
const pLocate = pLocate$1;
locatePath$1.exports = (iterable, options) => {
  options = Object.assign({
    cwd: process.cwd()
  }, options);
  return pLocate(iterable, (el) => pathExists(path$5.resolve(options.cwd, el)), options);
};
locatePath$1.exports.sync = (iterable, options) => {
  options = Object.assign({
    cwd: process.cwd()
  }, options);
  for (const el of iterable) {
    if (pathExists.sync(path$5.resolve(options.cwd, el))) {
      return el;
    }
  }
};
const path$4 = require$$1__default$2["default"];
const locatePath = locatePath$1.exports;
findUp$1.exports = (filename, opts2 = {}) => {
  const startDir = path$4.resolve(opts2.cwd || "");
  const { root: root2 } = path$4.parse(startDir);
  const filenames = [].concat(filename);
  return new Promise((resolve2) => {
    (function find(dir) {
      locatePath(filenames, { cwd: dir }).then((file2) => {
        if (file2) {
          resolve2(path$4.join(dir, file2));
        } else if (dir === root2) {
          resolve2(null);
        } else {
          find(path$4.dirname(dir));
        }
      });
    })(startDir);
  });
};
findUp$1.exports.sync = (filename, opts2 = {}) => {
  let dir = path$4.resolve(opts2.cwd || "");
  const { root: root2 } = path$4.parse(dir);
  const filenames = [].concat(filename);
  while (true) {
    const file2 = locatePath.sync(filenames, { cwd: dir });
    if (file2) {
      return path$4.join(dir, file2);
    }
    if (dir === root2) {
      return null;
    }
    dir = path$4.dirname(dir);
  }
};
const findUp = findUp$1.exports;
pkgUp.exports = async ({ cwd: cwd2 } = {}) => findUp("package.json", { cwd: cwd2 });
pkgUp.exports.sync = ({ cwd: cwd2 } = {}) => findUp.sync("package.json", { cwd: cwd2 });
var envPaths$1 = { exports: {} };
const path$3 = require$$1__default$2["default"];
const os = require$$1__default$4["default"];
const homedir = os.homedir();
const tmpdir = os.tmpdir();
const { env: env$1 } = process;
const macos = (name) => {
  const library = path$3.join(homedir, "Library");
  return {
    data: path$3.join(library, "Application Support", name),
    config: path$3.join(library, "Preferences", name),
    cache: path$3.join(library, "Caches", name),
    log: path$3.join(library, "Logs", name),
    temp: path$3.join(tmpdir, name)
  };
};
const windows = (name) => {
  const appData = env$1.APPDATA || path$3.join(homedir, "AppData", "Roaming");
  const localAppData = env$1.LOCALAPPDATA || path$3.join(homedir, "AppData", "Local");
  return {
    data: path$3.join(localAppData, name, "Data"),
    config: path$3.join(appData, name, "Config"),
    cache: path$3.join(localAppData, name, "Cache"),
    log: path$3.join(localAppData, name, "Log"),
    temp: path$3.join(tmpdir, name)
  };
};
const linux = (name) => {
  const username = path$3.basename(homedir);
  return {
    data: path$3.join(env$1.XDG_DATA_HOME || path$3.join(homedir, ".local", "share"), name),
    config: path$3.join(env$1.XDG_CONFIG_HOME || path$3.join(homedir, ".config"), name),
    cache: path$3.join(env$1.XDG_CACHE_HOME || path$3.join(homedir, ".cache"), name),
    log: path$3.join(env$1.XDG_STATE_HOME || path$3.join(homedir, ".local", "state"), name),
    temp: path$3.join(tmpdir, username, name)
  };
};
const envPaths = (name, options) => {
  if (typeof name !== "string") {
    throw new TypeError(`Expected string, got ${typeof name}`);
  }
  options = Object.assign({ suffix: "nodejs" }, options);
  if (options.suffix) {
    name += `-${options.suffix}`;
  }
  if (process.platform === "darwin") {
    return macos(name);
  }
  if (process.platform === "win32") {
    return windows(name);
  }
  return linux(name);
};
envPaths$1.exports = envPaths;
envPaths$1.exports.default = envPaths;
var dist$1 = {};
var consts = {};
Object.defineProperty(consts, "__esModule", { value: true });
consts.NOOP = consts.LIMIT_FILES_DESCRIPTORS = consts.LIMIT_BASENAME_LENGTH = consts.IS_USER_ROOT = consts.IS_POSIX = consts.DEFAULT_TIMEOUT_SYNC = consts.DEFAULT_TIMEOUT_ASYNC = consts.DEFAULT_WRITE_OPTIONS = consts.DEFAULT_READ_OPTIONS = consts.DEFAULT_FOLDER_MODE = consts.DEFAULT_FILE_MODE = consts.DEFAULT_ENCODING = void 0;
const DEFAULT_ENCODING = "utf8";
consts.DEFAULT_ENCODING = DEFAULT_ENCODING;
const DEFAULT_FILE_MODE = 438;
consts.DEFAULT_FILE_MODE = DEFAULT_FILE_MODE;
const DEFAULT_FOLDER_MODE = 511;
consts.DEFAULT_FOLDER_MODE = DEFAULT_FOLDER_MODE;
const DEFAULT_READ_OPTIONS = {};
consts.DEFAULT_READ_OPTIONS = DEFAULT_READ_OPTIONS;
const DEFAULT_WRITE_OPTIONS = {};
consts.DEFAULT_WRITE_OPTIONS = DEFAULT_WRITE_OPTIONS;
const DEFAULT_TIMEOUT_ASYNC = 5e3;
consts.DEFAULT_TIMEOUT_ASYNC = DEFAULT_TIMEOUT_ASYNC;
const DEFAULT_TIMEOUT_SYNC = 100;
consts.DEFAULT_TIMEOUT_SYNC = DEFAULT_TIMEOUT_SYNC;
const IS_POSIX = !!process.getuid;
consts.IS_POSIX = IS_POSIX;
const IS_USER_ROOT = process.getuid ? !process.getuid() : false;
consts.IS_USER_ROOT = IS_USER_ROOT;
const LIMIT_BASENAME_LENGTH = 128;
consts.LIMIT_BASENAME_LENGTH = LIMIT_BASENAME_LENGTH;
const LIMIT_FILES_DESCRIPTORS = 1e4;
consts.LIMIT_FILES_DESCRIPTORS = LIMIT_FILES_DESCRIPTORS;
const NOOP = () => {
};
consts.NOOP = NOOP;
var fs$1 = {};
var attemptify = {};
Object.defineProperty(attemptify, "__esModule", { value: true });
attemptify.attemptifySync = attemptify.attemptifyAsync = void 0;
const consts_1$4 = consts;
const attemptifyAsync = (fn, onError = consts_1$4.NOOP) => {
  return function() {
    return fn.apply(void 0, arguments).catch(onError);
  };
};
attemptify.attemptifyAsync = attemptifyAsync;
const attemptifySync = (fn, onError = consts_1$4.NOOP) => {
  return function() {
    try {
      return fn.apply(void 0, arguments);
    } catch (error2) {
      return onError(error2);
    }
  };
};
attemptify.attemptifySync = attemptifySync;
var fs_handlers = {};
Object.defineProperty(fs_handlers, "__esModule", { value: true });
const consts_1$3 = consts;
const Handlers = {
  isChangeErrorOk: (error2) => {
    const { code: code2 } = error2;
    if (code2 === "ENOSYS")
      return true;
    if (!consts_1$3.IS_USER_ROOT && (code2 === "EINVAL" || code2 === "EPERM"))
      return true;
    return false;
  },
  isRetriableError: (error2) => {
    const { code: code2 } = error2;
    if (code2 === "EMFILE" || code2 === "ENFILE" || code2 === "EAGAIN" || code2 === "EBUSY" || code2 === "EACCESS" || code2 === "EACCS" || code2 === "EPERM")
      return true;
    return false;
  },
  onChangeError: (error2) => {
    if (Handlers.isChangeErrorOk(error2))
      return;
    throw error2;
  }
};
fs_handlers.default = Handlers;
var retryify = {};
var retryify_queue = {};
Object.defineProperty(retryify_queue, "__esModule", { value: true });
const consts_1$2 = consts;
const RetryfyQueue = {
  interval: 25,
  intervalId: void 0,
  limit: consts_1$2.LIMIT_FILES_DESCRIPTORS,
  queueActive: new Set(),
  queueWaiting: new Set(),
  init: () => {
    if (RetryfyQueue.intervalId)
      return;
    RetryfyQueue.intervalId = setInterval(RetryfyQueue.tick, RetryfyQueue.interval);
  },
  reset: () => {
    if (!RetryfyQueue.intervalId)
      return;
    clearInterval(RetryfyQueue.intervalId);
    delete RetryfyQueue.intervalId;
  },
  add: (fn) => {
    RetryfyQueue.queueWaiting.add(fn);
    if (RetryfyQueue.queueActive.size < RetryfyQueue.limit / 2) {
      RetryfyQueue.tick();
    } else {
      RetryfyQueue.init();
    }
  },
  remove: (fn) => {
    RetryfyQueue.queueWaiting.delete(fn);
    RetryfyQueue.queueActive.delete(fn);
  },
  schedule: () => {
    return new Promise((resolve2) => {
      const cleanup = () => RetryfyQueue.remove(resolver);
      const resolver = () => resolve2(cleanup);
      RetryfyQueue.add(resolver);
    });
  },
  tick: () => {
    if (RetryfyQueue.queueActive.size >= RetryfyQueue.limit)
      return;
    if (!RetryfyQueue.queueWaiting.size)
      return RetryfyQueue.reset();
    for (const fn of RetryfyQueue.queueWaiting) {
      if (RetryfyQueue.queueActive.size >= RetryfyQueue.limit)
        break;
      RetryfyQueue.queueWaiting.delete(fn);
      RetryfyQueue.queueActive.add(fn);
      fn();
    }
  }
};
retryify_queue.default = RetryfyQueue;
Object.defineProperty(retryify, "__esModule", { value: true });
retryify.retryifySync = retryify.retryifyAsync = void 0;
const retryify_queue_1 = retryify_queue;
const retryifyAsync = (fn, isRetriableError) => {
  return function(timestamp2) {
    return function attempt() {
      return retryify_queue_1.default.schedule().then((cleanup) => {
        return fn.apply(void 0, arguments).then((result) => {
          cleanup();
          return result;
        }, (error2) => {
          cleanup();
          if (Date.now() >= timestamp2)
            throw error2;
          if (isRetriableError(error2)) {
            const delay = Math.round(100 + 400 * Math.random()), delayPromise = new Promise((resolve2) => setTimeout(resolve2, delay));
            return delayPromise.then(() => attempt.apply(void 0, arguments));
          }
          throw error2;
        });
      });
    };
  };
};
retryify.retryifyAsync = retryifyAsync;
const retryifySync = (fn, isRetriableError) => {
  return function(timestamp2) {
    return function attempt() {
      try {
        return fn.apply(void 0, arguments);
      } catch (error2) {
        if (Date.now() > timestamp2)
          throw error2;
        if (isRetriableError(error2))
          return attempt.apply(void 0, arguments);
        throw error2;
      }
    };
  };
};
retryify.retryifySync = retryifySync;
Object.defineProperty(fs$1, "__esModule", { value: true });
const fs = require$$1__default$1["default"];
const util_1$p = require$$2__default$1["default"];
const attemptify_1 = attemptify;
const fs_handlers_1 = fs_handlers;
const retryify_1 = retryify;
const FS = {
  chmodAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.chmod), fs_handlers_1.default.onChangeError),
  chownAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.chown), fs_handlers_1.default.onChangeError),
  closeAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.close)),
  fsyncAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.fsync)),
  mkdirAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.mkdir)),
  realpathAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.realpath)),
  statAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.stat)),
  unlinkAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.unlink)),
  closeRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.close), fs_handlers_1.default.isRetriableError),
  fsyncRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.fsync), fs_handlers_1.default.isRetriableError),
  openRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.open), fs_handlers_1.default.isRetriableError),
  readFileRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.readFile), fs_handlers_1.default.isRetriableError),
  renameRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.rename), fs_handlers_1.default.isRetriableError),
  statRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.stat), fs_handlers_1.default.isRetriableError),
  writeRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.write), fs_handlers_1.default.isRetriableError),
  chmodSyncAttempt: attemptify_1.attemptifySync(fs.chmodSync, fs_handlers_1.default.onChangeError),
  chownSyncAttempt: attemptify_1.attemptifySync(fs.chownSync, fs_handlers_1.default.onChangeError),
  closeSyncAttempt: attemptify_1.attemptifySync(fs.closeSync),
  mkdirSyncAttempt: attemptify_1.attemptifySync(fs.mkdirSync),
  realpathSyncAttempt: attemptify_1.attemptifySync(fs.realpathSync),
  statSyncAttempt: attemptify_1.attemptifySync(fs.statSync),
  unlinkSyncAttempt: attemptify_1.attemptifySync(fs.unlinkSync),
  closeSyncRetry: retryify_1.retryifySync(fs.closeSync, fs_handlers_1.default.isRetriableError),
  fsyncSyncRetry: retryify_1.retryifySync(fs.fsyncSync, fs_handlers_1.default.isRetriableError),
  openSyncRetry: retryify_1.retryifySync(fs.openSync, fs_handlers_1.default.isRetriableError),
  readFileSyncRetry: retryify_1.retryifySync(fs.readFileSync, fs_handlers_1.default.isRetriableError),
  renameSyncRetry: retryify_1.retryifySync(fs.renameSync, fs_handlers_1.default.isRetriableError),
  statSyncRetry: retryify_1.retryifySync(fs.statSync, fs_handlers_1.default.isRetriableError),
  writeSyncRetry: retryify_1.retryifySync(fs.writeSync, fs_handlers_1.default.isRetriableError)
};
fs$1.default = FS;
var lang = {};
Object.defineProperty(lang, "__esModule", { value: true });
const Lang = {
  isFunction: (x) => {
    return typeof x === "function";
  },
  isString: (x) => {
    return typeof x === "string";
  },
  isUndefined: (x) => {
    return typeof x === "undefined";
  }
};
lang.default = Lang;
var scheduler = {};
Object.defineProperty(scheduler, "__esModule", { value: true });
const Queues = {};
const Scheduler = {
  next: (id2) => {
    const queue2 = Queues[id2];
    if (!queue2)
      return;
    queue2.shift();
    const job = queue2[0];
    if (job) {
      job(() => Scheduler.next(id2));
    } else {
      delete Queues[id2];
    }
  },
  schedule: (id2) => {
    return new Promise((resolve2) => {
      let queue2 = Queues[id2];
      if (!queue2)
        queue2 = Queues[id2] = [];
      queue2.push(resolve2);
      if (queue2.length > 1)
        return;
      resolve2(() => Scheduler.next(id2));
    });
  }
};
scheduler.default = Scheduler;
var temp = {};
Object.defineProperty(temp, "__esModule", { value: true });
const path$2 = require$$1__default$2["default"];
const consts_1$1 = consts;
const fs_1$1 = fs$1;
const Temp = {
  store: {},
  create: (filePath) => {
    const randomness = `000000${Math.floor(Math.random() * 16777215).toString(16)}`.slice(-6), timestamp2 = Date.now().toString().slice(-10), prefix = "tmp-", suffix = `.${prefix}${timestamp2}${randomness}`, tempPath = `${filePath}${suffix}`;
    return tempPath;
  },
  get: (filePath, creator, purge = true) => {
    const tempPath = Temp.truncate(creator(filePath));
    if (tempPath in Temp.store)
      return Temp.get(filePath, creator, purge);
    Temp.store[tempPath] = purge;
    const disposer = () => delete Temp.store[tempPath];
    return [tempPath, disposer];
  },
  purge: (filePath) => {
    if (!Temp.store[filePath])
      return;
    delete Temp.store[filePath];
    fs_1$1.default.unlinkAttempt(filePath);
  },
  purgeSync: (filePath) => {
    if (!Temp.store[filePath])
      return;
    delete Temp.store[filePath];
    fs_1$1.default.unlinkSyncAttempt(filePath);
  },
  purgeSyncAll: () => {
    for (const filePath in Temp.store) {
      Temp.purgeSync(filePath);
    }
  },
  truncate: (filePath) => {
    const basename = path$2.basename(filePath);
    if (basename.length <= consts_1$1.LIMIT_BASENAME_LENGTH)
      return filePath;
    const truncable = /^(\.?)(.*?)((?:\.[^.]+)?(?:\.tmp-\d{10}[a-f0-9]{6})?)$/.exec(basename);
    if (!truncable)
      return filePath;
    const truncationLength = basename.length - consts_1$1.LIMIT_BASENAME_LENGTH;
    return `${filePath.slice(0, -basename.length)}${truncable[1]}${truncable[2].slice(0, -truncationLength)}${truncable[3]}`;
  }
};
process.on("exit", Temp.purgeSyncAll);
temp.default = Temp;
Object.defineProperty(dist$1, "__esModule", { value: true });
dist$1.writeFileSync = dist$1.writeFile = dist$1.readFileSync = dist$1.readFile = void 0;
const path$1 = require$$1__default$2["default"];
const consts_1 = consts;
const fs_1 = fs$1;
const lang_1 = lang;
const scheduler_1 = scheduler;
const temp_1 = temp;
function readFile(filePath, options = consts_1.DEFAULT_READ_OPTIONS) {
  var _a;
  if (lang_1.default.isString(options))
    return readFile(filePath, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_ASYNC);
  return fs_1.default.readFileRetry(timeout)(filePath, options);
}
dist$1.readFile = readFile;
function readFileSync(filePath, options = consts_1.DEFAULT_READ_OPTIONS) {
  var _a;
  if (lang_1.default.isString(options))
    return readFileSync(filePath, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_SYNC);
  return fs_1.default.readFileSyncRetry(timeout)(filePath, options);
}
dist$1.readFileSync = readFileSync;
const writeFile = (filePath, data, options, callback) => {
  if (lang_1.default.isFunction(options))
    return writeFile(filePath, data, consts_1.DEFAULT_WRITE_OPTIONS, options);
  const promise = writeFileAsync(filePath, data, options);
  if (callback)
    promise.then(callback, callback);
  return promise;
};
dist$1.writeFile = writeFile;
const writeFileAsync = async (filePath, data, options = consts_1.DEFAULT_WRITE_OPTIONS) => {
  var _a;
  if (lang_1.default.isString(options))
    return writeFileAsync(filePath, data, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_ASYNC);
  let schedulerCustomDisposer = null, schedulerDisposer = null, tempDisposer = null, tempPath = null, fd = null;
  try {
    if (options.schedule)
      schedulerCustomDisposer = await options.schedule(filePath);
    schedulerDisposer = await scheduler_1.default.schedule(filePath);
    filePath = await fs_1.default.realpathAttempt(filePath) || filePath;
    [tempPath, tempDisposer] = temp_1.default.get(filePath, options.tmpCreate || temp_1.default.create, !(options.tmpPurge === false));
    const useStatChown = consts_1.IS_POSIX && lang_1.default.isUndefined(options.chown), useStatMode = lang_1.default.isUndefined(options.mode);
    if (useStatChown || useStatMode) {
      const stat2 = await fs_1.default.statAttempt(filePath);
      if (stat2) {
        options = __spreadValues({}, options);
        if (useStatChown)
          options.chown = { uid: stat2.uid, gid: stat2.gid };
        if (useStatMode)
          options.mode = stat2.mode;
      }
    }
    const parentPath = path$1.dirname(filePath);
    await fs_1.default.mkdirAttempt(parentPath, {
      mode: consts_1.DEFAULT_FOLDER_MODE,
      recursive: true
    });
    fd = await fs_1.default.openRetry(timeout)(tempPath, "w", options.mode || consts_1.DEFAULT_FILE_MODE);
    if (options.tmpCreated)
      options.tmpCreated(tempPath);
    if (lang_1.default.isString(data)) {
      await fs_1.default.writeRetry(timeout)(fd, data, 0, options.encoding || consts_1.DEFAULT_ENCODING);
    } else if (!lang_1.default.isUndefined(data)) {
      await fs_1.default.writeRetry(timeout)(fd, data, 0, data.length, 0);
    }
    if (options.fsync !== false) {
      if (options.fsyncWait !== false) {
        await fs_1.default.fsyncRetry(timeout)(fd);
      } else {
        fs_1.default.fsyncAttempt(fd);
      }
    }
    await fs_1.default.closeRetry(timeout)(fd);
    fd = null;
    if (options.chown)
      await fs_1.default.chownAttempt(tempPath, options.chown.uid, options.chown.gid);
    if (options.mode)
      await fs_1.default.chmodAttempt(tempPath, options.mode);
    try {
      await fs_1.default.renameRetry(timeout)(tempPath, filePath);
    } catch (error2) {
      if (error2.code !== "ENAMETOOLONG")
        throw error2;
      await fs_1.default.renameRetry(timeout)(tempPath, temp_1.default.truncate(filePath));
    }
    tempDisposer();
    tempPath = null;
  } finally {
    if (fd)
      await fs_1.default.closeAttempt(fd);
    if (tempPath)
      temp_1.default.purge(tempPath);
    if (schedulerCustomDisposer)
      schedulerCustomDisposer();
    if (schedulerDisposer)
      schedulerDisposer();
  }
};
const writeFileSync = (filePath, data, options = consts_1.DEFAULT_WRITE_OPTIONS) => {
  var _a;
  if (lang_1.default.isString(options))
    return writeFileSync(filePath, data, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_SYNC);
  let tempDisposer = null, tempPath = null, fd = null;
  try {
    filePath = fs_1.default.realpathSyncAttempt(filePath) || filePath;
    [tempPath, tempDisposer] = temp_1.default.get(filePath, options.tmpCreate || temp_1.default.create, !(options.tmpPurge === false));
    const useStatChown = consts_1.IS_POSIX && lang_1.default.isUndefined(options.chown), useStatMode = lang_1.default.isUndefined(options.mode);
    if (useStatChown || useStatMode) {
      const stat2 = fs_1.default.statSyncAttempt(filePath);
      if (stat2) {
        options = __spreadValues({}, options);
        if (useStatChown)
          options.chown = { uid: stat2.uid, gid: stat2.gid };
        if (useStatMode)
          options.mode = stat2.mode;
      }
    }
    const parentPath = path$1.dirname(filePath);
    fs_1.default.mkdirSyncAttempt(parentPath, {
      mode: consts_1.DEFAULT_FOLDER_MODE,
      recursive: true
    });
    fd = fs_1.default.openSyncRetry(timeout)(tempPath, "w", options.mode || consts_1.DEFAULT_FILE_MODE);
    if (options.tmpCreated)
      options.tmpCreated(tempPath);
    if (lang_1.default.isString(data)) {
      fs_1.default.writeSyncRetry(timeout)(fd, data, 0, options.encoding || consts_1.DEFAULT_ENCODING);
    } else if (!lang_1.default.isUndefined(data)) {
      fs_1.default.writeSyncRetry(timeout)(fd, data, 0, data.length, 0);
    }
    if (options.fsync !== false) {
      if (options.fsyncWait !== false) {
        fs_1.default.fsyncSyncRetry(timeout)(fd);
      } else {
        fs_1.default.fsyncAttempt(fd);
      }
    }
    fs_1.default.closeSyncRetry(timeout)(fd);
    fd = null;
    if (options.chown)
      fs_1.default.chownSyncAttempt(tempPath, options.chown.uid, options.chown.gid);
    if (options.mode)
      fs_1.default.chmodSyncAttempt(tempPath, options.mode);
    try {
      fs_1.default.renameSyncRetry(timeout)(tempPath, filePath);
    } catch (error2) {
      if (error2.code !== "ENAMETOOLONG")
        throw error2;
      fs_1.default.renameSyncRetry(timeout)(tempPath, temp_1.default.truncate(filePath));
    }
    tempDisposer();
    tempPath = null;
  } finally {
    if (fd)
      fs_1.default.closeSyncAttempt(fd);
    if (tempPath)
      temp_1.default.purge(tempPath);
  }
};
dist$1.writeFileSync = writeFileSync;
var ajv = { exports: {} };
var core$2 = {};
var validate = {};
var boolSchema = {};
var errors = {};
var codegen = {};
var code$1 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.regexpCode = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
  class _CodeOrName {
  }
  exports._CodeOrName = _CodeOrName;
  exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class Name extends _CodeOrName {
    constructor(s2) {
      super();
      if (!exports.IDENTIFIER.test(s2))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = s2;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  exports.Name = Name;
  class _Code extends _CodeOrName {
    constructor(code2) {
      super();
      this._items = typeof code2 === "string" ? [code2] : code2;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return false;
      const item = this._items[0];
      return item === "" || item === '""';
    }
    get str() {
      var _a;
      return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s2, c) => `${s2}${c}`, "");
    }
    get names() {
      var _a;
      return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names2, c) => {
        if (c instanceof Name)
          names2[c.str] = (names2[c.str] || 0) + 1;
        return names2;
      }, {});
    }
  }
  exports._Code = _Code;
  exports.nil = new _Code("");
  function _(strs, ...args) {
    const code2 = [strs[0]];
    let i2 = 0;
    while (i2 < args.length) {
      addCodeArg(code2, args[i2]);
      code2.push(strs[++i2]);
    }
    return new _Code(code2);
  }
  exports._ = _;
  const plus = new _Code("+");
  function str2(strs, ...args) {
    const expr = [safeStringify(strs[0])];
    let i2 = 0;
    while (i2 < args.length) {
      expr.push(plus);
      addCodeArg(expr, args[i2]);
      expr.push(plus, safeStringify(strs[++i2]));
    }
    optimize(expr);
    return new _Code(expr);
  }
  exports.str = str2;
  function addCodeArg(code2, arg) {
    if (arg instanceof _Code)
      code2.push(...arg._items);
    else if (arg instanceof Name)
      code2.push(arg);
    else
      code2.push(interpolate(arg));
  }
  exports.addCodeArg = addCodeArg;
  function optimize(expr) {
    let i2 = 1;
    while (i2 < expr.length - 1) {
      if (expr[i2] === plus) {
        const res = mergeExprItems(expr[i2 - 1], expr[i2 + 1]);
        if (res !== void 0) {
          expr.splice(i2 - 1, 3, res);
          continue;
        }
        expr[i2++] = "+";
      }
      i2++;
    }
  }
  function mergeExprItems(a, b) {
    if (b === '""')
      return a;
    if (a === '""')
      return b;
    if (typeof a == "string") {
      if (b instanceof Name || a[a.length - 1] !== '"')
        return;
      if (typeof b != "string")
        return `${a.slice(0, -1)}${b}"`;
      if (b[0] === '"')
        return a.slice(0, -1) + b.slice(1);
      return;
    }
    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
      return `"${a}${b.slice(1)}`;
    return;
  }
  function strConcat(c1, c2) {
    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str2`${c1}${c2}`;
  }
  exports.strConcat = strConcat;
  function interpolate(x) {
    return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
  }
  function stringify2(x) {
    return new _Code(safeStringify(x));
  }
  exports.stringify = stringify2;
  function safeStringify(x) {
    return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  exports.safeStringify = safeStringify;
  function getProperty(key) {
    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
  }
  exports.getProperty = getProperty;
  function regexpCode(rx) {
    return new _Code(rx.toString());
  }
  exports.regexpCode = regexpCode;
})(code$1);
var scope = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
  const code_12 = code$1;
  class ValueError extends Error {
    constructor(name) {
      super(`CodeGen: "code" for ${name} not defined`);
      this.value = name.value;
    }
  }
  var UsedValueState;
  (function(UsedValueState2) {
    UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
    UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
  })(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));
  exports.varKinds = {
    const: new code_12.Name("const"),
    let: new code_12.Name("let"),
    var: new code_12.Name("var")
  };
  class Scope {
    constructor({ prefixes, parent } = {}) {
      this._names = {};
      this._prefixes = prefixes;
      this._parent = parent;
    }
    toName(nameOrPrefix) {
      return nameOrPrefix instanceof code_12.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix) {
      return new code_12.Name(this._newName(prefix));
    }
    _newName(prefix) {
      const ng = this._names[prefix] || this._nameGroup(prefix);
      return `${prefix}${ng.index++}`;
    }
    _nameGroup(prefix) {
      var _a, _b;
      if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
        throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
      }
      return this._names[prefix] = { prefix, index: 0 };
    }
  }
  exports.Scope = Scope;
  class ValueScopeName extends code_12.Name {
    constructor(prefix, nameStr) {
      super(nameStr);
      this.prefix = prefix;
    }
    setValue(value, { property, itemIndex }) {
      this.value = value;
      this.scopePath = code_12._`.${new code_12.Name(property)}[${itemIndex}]`;
    }
  }
  exports.ValueScopeName = ValueScopeName;
  const line = code_12._`\n`;
  class ValueScope extends Scope {
    constructor(opts2) {
      super(opts2);
      this._values = {};
      this._scope = opts2.scope;
      this.opts = __spreadProps(__spreadValues({}, opts2), { _n: opts2.lines ? line : code_12.nil });
    }
    get() {
      return this._scope;
    }
    name(prefix) {
      return new ValueScopeName(prefix, this._newName(prefix));
    }
    value(nameOrPrefix, value) {
      var _a;
      if (value.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const name = this.toName(nameOrPrefix);
      const { prefix } = name;
      const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
      let vs = this._values[prefix];
      if (vs) {
        const _name = vs.get(valueKey);
        if (_name)
          return _name;
      } else {
        vs = this._values[prefix] = new Map();
      }
      vs.set(valueKey, name);
      const s2 = this._scope[prefix] || (this._scope[prefix] = []);
      const itemIndex = s2.length;
      s2[itemIndex] = value.ref;
      name.setValue(value, { property: prefix, itemIndex });
      return name;
    }
    getValue(prefix, keyOrRef) {
      const vs = this._values[prefix];
      if (!vs)
        return;
      return vs.get(keyOrRef);
    }
    scopeRefs(scopeName, values = this._values) {
      return this._reduceValues(values, (name) => {
        if (name.scopePath === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return code_12._`${scopeName}${name.scopePath}`;
      });
    }
    scopeCode(values = this._values, usedValues, getCode) {
      return this._reduceValues(values, (name) => {
        if (name.value === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return name.value.code;
      }, usedValues, getCode);
    }
    _reduceValues(values, valueCode, usedValues = {}, getCode) {
      let code2 = code_12.nil;
      for (const prefix in values) {
        const vs = values[prefix];
        if (!vs)
          continue;
        const nameSet = usedValues[prefix] = usedValues[prefix] || new Map();
        vs.forEach((name) => {
          if (nameSet.has(name))
            return;
          nameSet.set(name, UsedValueState.Started);
          let c = valueCode(name);
          if (c) {
            const def2 = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
            code2 = code_12._`${code2}${def2} ${name} = ${c};${this.opts._n}`;
          } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
            code2 = code_12._`${code2}${c}${this.opts._n}`;
          } else {
            throw new ValueError(name);
          }
          nameSet.set(name, UsedValueState.Completed);
        });
      }
      return code2;
    }
  }
  exports.ValueScope = ValueScope;
})(scope);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
  const code_12 = code$1;
  const scope_1 = scope;
  var code_2 = code$1;
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return code_2._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return code_2.str;
  } });
  Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
    return code_2.strConcat;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return code_2.nil;
  } });
  Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
    return code_2.getProperty;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return code_2.stringify;
  } });
  Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
    return code_2.regexpCode;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return code_2.Name;
  } });
  var scope_2 = scope;
  Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
    return scope_2.Scope;
  } });
  Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
    return scope_2.ValueScope;
  } });
  Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
    return scope_2.ValueScopeName;
  } });
  Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
    return scope_2.varKinds;
  } });
  exports.operators = {
    GT: new code_12._Code(">"),
    GTE: new code_12._Code(">="),
    LT: new code_12._Code("<"),
    LTE: new code_12._Code("<="),
    EQ: new code_12._Code("==="),
    NEQ: new code_12._Code("!=="),
    NOT: new code_12._Code("!"),
    OR: new code_12._Code("||"),
    AND: new code_12._Code("&&"),
    ADD: new code_12._Code("+")
  };
  class Node2 {
    optimizeNodes() {
      return this;
    }
    optimizeNames(_names, _constants) {
      return this;
    }
  }
  class Def extends Node2 {
    constructor(varKind, name, rhs) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.rhs = rhs;
    }
    render({ es5, _n }) {
      const varKind = es5 ? scope_1.varKinds.var : this.varKind;
      const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${varKind} ${this.name}${rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (!names2[this.name.str])
        return;
      if (this.rhs)
        this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      return this.rhs instanceof code_12._CodeOrName ? this.rhs.names : {};
    }
  }
  class Assign extends Node2 {
    constructor(lhs, rhs, sideEffects) {
      super();
      this.lhs = lhs;
      this.rhs = rhs;
      this.sideEffects = sideEffects;
    }
    render({ _n }) {
      return `${this.lhs} = ${this.rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (this.lhs instanceof code_12.Name && !names2[this.lhs.str] && !this.sideEffects)
        return;
      this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      const names2 = this.lhs instanceof code_12.Name ? {} : __spreadValues({}, this.lhs.names);
      return addExprNames(names2, this.rhs);
    }
  }
  class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
      super(lhs, rhs, sideEffects);
      this.op = op;
    }
    render({ _n }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
    }
  }
  class Label extends Node2 {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      return `${this.label}:` + _n;
    }
  }
  class Break extends Node2 {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      const label = this.label ? ` ${this.label}` : "";
      return `break${label};` + _n;
    }
  }
  class Throw extends Node2 {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render({ _n }) {
      return `throw ${this.error};` + _n;
    }
    get names() {
      return this.error.names;
    }
  }
  class AnyCode extends Node2 {
    constructor(code2) {
      super();
      this.code = code2;
    }
    render({ _n }) {
      return `${this.code};` + _n;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      this.code = optimizeExpr(this.code, names2, constants2);
      return this;
    }
    get names() {
      return this.code instanceof code_12._CodeOrName ? this.code.names : {};
    }
  }
  class ParentNode extends Node2 {
    constructor(nodes = []) {
      super();
      this.nodes = nodes;
    }
    render(opts2) {
      return this.nodes.reduce((code2, n) => code2 + n.render(opts2), "");
    }
    optimizeNodes() {
      const { nodes } = this;
      let i2 = nodes.length;
      while (i2--) {
        const n = nodes[i2].optimizeNodes();
        if (Array.isArray(n))
          nodes.splice(i2, 1, ...n);
        else if (n)
          nodes[i2] = n;
        else
          nodes.splice(i2, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      const { nodes } = this;
      let i2 = nodes.length;
      while (i2--) {
        const n = nodes[i2];
        if (n.optimizeNames(names2, constants2))
          continue;
        subtractNames(names2, n.names);
        nodes.splice(i2, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((names2, n) => addNames(names2, n.names), {});
    }
  }
  class BlockNode extends ParentNode {
    render(opts2) {
      return "{" + opts2._n + super.render(opts2) + "}" + opts2._n;
    }
  }
  class Root extends ParentNode {
  }
  class Else extends BlockNode {
  }
  Else.kind = "else";
  class If extends BlockNode {
    constructor(condition, nodes) {
      super(nodes);
      this.condition = condition;
    }
    render(opts2) {
      let code2 = `if(${this.condition})` + super.render(opts2);
      if (this.else)
        code2 += "else " + this.else.render(opts2);
      return code2;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const cond = this.condition;
      if (cond === true)
        return this.nodes;
      let e = this.else;
      if (e) {
        const ns = e.optimizeNodes();
        e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
      }
      if (e) {
        if (cond === false)
          return e instanceof If ? e : e.nodes;
        if (this.nodes.length)
          return this;
        return new If(not2(cond), e instanceof If ? [e] : e.nodes);
      }
      if (cond === false || !this.nodes.length)
        return void 0;
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a;
      this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants2);
      if (!(super.optimizeNames(names2, constants2) || this.else))
        return;
      this.condition = optimizeExpr(this.condition, names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      addExprNames(names2, this.condition);
      if (this.else)
        addNames(names2, this.else.names);
      return names2;
    }
  }
  If.kind = "if";
  class For extends BlockNode {
  }
  For.kind = "for";
  class ForLoop extends For {
    constructor(iteration) {
      super();
      this.iteration = iteration;
    }
    render(opts2) {
      return `for(${this.iteration})` + super.render(opts2);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iteration = optimizeExpr(this.iteration, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iteration.names);
    }
  }
  class ForRange extends For {
    constructor(varKind, name, from, to) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.from = from;
      this.to = to;
    }
    render(opts2) {
      const varKind = opts2.es5 ? scope_1.varKinds.var : this.varKind;
      const { name, from, to } = this;
      return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts2);
    }
    get names() {
      const names2 = addExprNames(super.names, this.from);
      return addExprNames(names2, this.to);
    }
  }
  class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
      super();
      this.loop = loop;
      this.varKind = varKind;
      this.name = name;
      this.iterable = iterable;
    }
    render(opts2) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts2);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iterable = optimizeExpr(this.iterable, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iterable.names);
    }
  }
  class Func extends BlockNode {
    constructor(name, args, async) {
      super();
      this.name = name;
      this.args = args;
      this.async = async;
    }
    render(opts2) {
      const _async = this.async ? "async " : "";
      return `${_async}function ${this.name}(${this.args})` + super.render(opts2);
    }
  }
  Func.kind = "func";
  class Return extends ParentNode {
    render(opts2) {
      return "return " + super.render(opts2);
    }
  }
  Return.kind = "return";
  class Try extends BlockNode {
    render(opts2) {
      let code2 = "try" + super.render(opts2);
      if (this.catch)
        code2 += this.catch.render(opts2);
      if (this.finally)
        code2 += this.finally.render(opts2);
      return code2;
    }
    optimizeNodes() {
      var _a, _b;
      super.optimizeNodes();
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a, _b;
      super.optimizeNames(names2, constants2);
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants2);
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      if (this.catch)
        addNames(names2, this.catch.names);
      if (this.finally)
        addNames(names2, this.finally.names);
      return names2;
    }
  }
  class Catch extends BlockNode {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render(opts2) {
      return `catch(${this.error})` + super.render(opts2);
    }
  }
  Catch.kind = "catch";
  class Finally extends BlockNode {
    render(opts2) {
      return "finally" + super.render(opts2);
    }
  }
  Finally.kind = "finally";
  class CodeGen {
    constructor(extScope, opts2 = {}) {
      this._values = {};
      this._blockStarts = [];
      this._constants = {};
      this.opts = __spreadProps(__spreadValues({}, opts2), { _n: opts2.lines ? "\n" : "" });
      this._extScope = extScope;
      this._scope = new scope_1.Scope({ parent: extScope });
      this._nodes = [new Root()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    name(prefix) {
      return this._scope.name(prefix);
    }
    scopeName(prefix) {
      return this._extScope.name(prefix);
    }
    scopeValue(prefixOrName, value) {
      const name = this._extScope.value(prefixOrName, value);
      const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
      vs.add(name);
      return name;
    }
    getScopeValue(prefix, keyOrRef) {
      return this._extScope.getValue(prefix, keyOrRef);
    }
    scopeRefs(scopeName) {
      return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant) {
      const name = this._scope.toName(nameOrPrefix);
      if (rhs !== void 0 && constant)
        this._constants[name.str] = rhs;
      this._leafNode(new Def(varKind, name, rhs));
      return name;
    }
    const(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    let(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    var(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    assign(lhs, rhs, sideEffects) {
      return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    add(lhs, rhs) {
      return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
    }
    code(c) {
      if (typeof c == "function")
        c();
      else if (c !== code_12.nil)
        this._leafNode(new AnyCode(c));
      return this;
    }
    object(...keyValues) {
      const code2 = ["{"];
      for (const [key, value] of keyValues) {
        if (code2.length > 1)
          code2.push(",");
        code2.push(key);
        if (key !== value || this.opts.es5) {
          code2.push(":");
          code_12.addCodeArg(code2, value);
        }
      }
      code2.push("}");
      return new code_12._Code(code2);
    }
    if(condition, thenBody, elseBody) {
      this._blockNode(new If(condition));
      if (thenBody && elseBody) {
        this.code(thenBody).else().code(elseBody).endIf();
      } else if (thenBody) {
        this.code(thenBody).endIf();
      } else if (elseBody) {
        throw new Error('CodeGen: "else" body without "then" body');
      }
      return this;
    }
    elseIf(condition) {
      return this._elseNode(new If(condition));
    }
    else() {
      return this._elseNode(new Else());
    }
    endIf() {
      return this._endBlockNode(If, Else);
    }
    _for(node, forBody) {
      this._blockNode(node);
      if (forBody)
        this.code(forBody).endFor();
      return this;
    }
    for(iteration, forBody) {
      return this._for(new ForLoop(iteration), forBody);
    }
    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
    }
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
      const name = this._scope.toName(nameOrPrefix);
      if (this.opts.es5) {
        const arr = iterable instanceof code_12.Name ? iterable : this.var("_arr", iterable);
        return this.forRange("_i", 0, code_12._`${arr}.length`, (i2) => {
          this.var(name, code_12._`${arr}[${i2}]`);
          forBody(name);
        });
      }
      return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    }
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
      if (this.opts.ownProperties) {
        return this.forOf(nameOrPrefix, code_12._`Object.keys(${obj})`, forBody);
      }
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    }
    endFor() {
      return this._endBlockNode(For);
    }
    label(label) {
      return this._leafNode(new Label(label));
    }
    break(label) {
      return this._leafNode(new Break(label));
    }
    return(value) {
      const node = new Return();
      this._blockNode(node);
      this.code(value);
      if (node.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(Return);
    }
    try(tryBody, catchCode, finallyCode) {
      if (!catchCode && !finallyCode)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const node = new Try();
      this._blockNode(node);
      this.code(tryBody);
      if (catchCode) {
        const error2 = this.name("e");
        this._currNode = node.catch = new Catch(error2);
        catchCode(error2);
      }
      if (finallyCode) {
        this._currNode = node.finally = new Finally();
        this.code(finallyCode);
      }
      return this._endBlockNode(Catch, Finally);
    }
    throw(error2) {
      return this._leafNode(new Throw(error2));
    }
    block(body, nodeCount) {
      this._blockStarts.push(this._nodes.length);
      if (body)
        this.code(body).endBlock(nodeCount);
      return this;
    }
    endBlock(nodeCount) {
      const len = this._blockStarts.pop();
      if (len === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const toClose = this._nodes.length - len;
      if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
        throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
      }
      this._nodes.length = len;
      return this;
    }
    func(name, args = code_12.nil, async, funcBody) {
      this._blockNode(new Func(name, args, async));
      if (funcBody)
        this.code(funcBody).endFunc();
      return this;
    }
    endFunc() {
      return this._endBlockNode(Func);
    }
    optimize(n = 1) {
      while (n-- > 0) {
        this._root.optimizeNodes();
        this._root.optimizeNames(this._root.names, this._constants);
      }
    }
    _leafNode(node) {
      this._currNode.nodes.push(node);
      return this;
    }
    _blockNode(node) {
      this._currNode.nodes.push(node);
      this._nodes.push(node);
    }
    _endBlockNode(N1, N2) {
      const n = this._currNode;
      if (n instanceof N1 || N2 && n instanceof N2) {
        this._nodes.pop();
        return this;
      }
      throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
    }
    _elseNode(node) {
      const n = this._currNode;
      if (!(n instanceof If)) {
        throw new Error('CodeGen: "else" without "if"');
      }
      this._currNode = n.else = node;
      return this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const ns = this._nodes;
      return ns[ns.length - 1];
    }
    set _currNode(node) {
      const ns = this._nodes;
      ns[ns.length - 1] = node;
    }
  }
  exports.CodeGen = CodeGen;
  function addNames(names2, from) {
    for (const n in from)
      names2[n] = (names2[n] || 0) + (from[n] || 0);
    return names2;
  }
  function addExprNames(names2, from) {
    return from instanceof code_12._CodeOrName ? addNames(names2, from.names) : names2;
  }
  function optimizeExpr(expr, names2, constants2) {
    if (expr instanceof code_12.Name)
      return replaceName(expr);
    if (!canOptimize(expr))
      return expr;
    return new code_12._Code(expr._items.reduce((items2, c) => {
      if (c instanceof code_12.Name)
        c = replaceName(c);
      if (c instanceof code_12._Code)
        items2.push(...c._items);
      else
        items2.push(c);
      return items2;
    }, []));
    function replaceName(n) {
      const c = constants2[n.str];
      if (c === void 0 || names2[n.str] !== 1)
        return n;
      delete names2[n.str];
      return c;
    }
    function canOptimize(e) {
      return e instanceof code_12._Code && e._items.some((c) => c instanceof code_12.Name && names2[c.str] === 1 && constants2[c.str] !== void 0);
    }
  }
  function subtractNames(names2, from) {
    for (const n in from)
      names2[n] = (names2[n] || 0) - (from[n] || 0);
  }
  function not2(x) {
    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : code_12._`!${par(x)}`;
  }
  exports.not = not2;
  const andCode = mappend(exports.operators.AND);
  function and(...args) {
    return args.reduce(andCode);
  }
  exports.and = and;
  const orCode = mappend(exports.operators.OR);
  function or(...args) {
    return args.reduce(orCode);
  }
  exports.or = or;
  function mappend(op) {
    return (x, y2) => x === code_12.nil ? y2 : y2 === code_12.nil ? x : code_12._`${par(x)} ${op} ${par(y2)}`;
  }
  function par(x) {
    return x instanceof code_12.Name ? x : code_12._`(${x})`;
  }
})(codegen);
var util = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
  const codegen_12 = codegen;
  const code_12 = code$1;
  function toHash(arr) {
    const hash = {};
    for (const item of arr)
      hash[item] = true;
    return hash;
  }
  exports.toHash = toHash;
  function alwaysValidSchema(it, schema2) {
    if (typeof schema2 == "boolean")
      return schema2;
    if (Object.keys(schema2).length === 0)
      return true;
    checkUnknownRules(it, schema2);
    return !schemaHasRules(schema2, it.self.RULES.all);
  }
  exports.alwaysValidSchema = alwaysValidSchema;
  function checkUnknownRules(it, schema2 = it.schema) {
    const { opts: opts2, self: self2 } = it;
    if (!opts2.strictSchema)
      return;
    if (typeof schema2 === "boolean")
      return;
    const rules2 = self2.RULES.keywords;
    for (const key in schema2) {
      if (!rules2[key])
        checkStrictMode(it, `unknown keyword: "${key}"`);
    }
  }
  exports.checkUnknownRules = checkUnknownRules;
  function schemaHasRules(schema2, rules2) {
    if (typeof schema2 == "boolean")
      return !schema2;
    for (const key in schema2)
      if (rules2[key])
        return true;
    return false;
  }
  exports.schemaHasRules = schemaHasRules;
  function schemaHasRulesButRef(schema2, RULES) {
    if (typeof schema2 == "boolean")
      return !schema2;
    for (const key in schema2)
      if (key !== "$ref" && RULES.all[key])
        return true;
    return false;
  }
  exports.schemaHasRulesButRef = schemaHasRulesButRef;
  function schemaRefOrVal({ topSchemaRef, schemaPath }, schema2, keyword2, $data) {
    if (!$data) {
      if (typeof schema2 == "number" || typeof schema2 == "boolean")
        return schema2;
      if (typeof schema2 == "string")
        return codegen_12._`${schema2}`;
    }
    return codegen_12._`${topSchemaRef}${schemaPath}${codegen_12.getProperty(keyword2)}`;
  }
  exports.schemaRefOrVal = schemaRefOrVal;
  function unescapeFragment(str2) {
    return unescapeJsonPointer(decodeURIComponent(str2));
  }
  exports.unescapeFragment = unescapeFragment;
  function escapeFragment(str2) {
    return encodeURIComponent(escapeJsonPointer(str2));
  }
  exports.escapeFragment = escapeFragment;
  function escapeJsonPointer(str2) {
    if (typeof str2 == "number")
      return `${str2}`;
    return str2.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  exports.escapeJsonPointer = escapeJsonPointer;
  function unescapeJsonPointer(str2) {
    return str2.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  exports.unescapeJsonPointer = unescapeJsonPointer;
  function eachItem(xs, f) {
    if (Array.isArray(xs)) {
      for (const x of xs)
        f(x);
    } else {
      f(xs);
    }
  }
  exports.eachItem = eachItem;
  function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
    return (gen, from, to, toName) => {
      const res = to === void 0 ? from : to instanceof codegen_12.Name ? (from instanceof codegen_12.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_12.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
      return toName === codegen_12.Name && !(res instanceof codegen_12.Name) ? resultToName(gen, res) : res;
    };
  }
  exports.mergeEvaluated = {
    props: makeMergeEvaluated({
      mergeNames: (gen, from, to) => gen.if(codegen_12._`${to} !== true && ${from} !== undefined`, () => {
        gen.if(codegen_12._`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, codegen_12._`${to} || {}`).code(codegen_12._`Object.assign(${to}, ${from})`));
      }),
      mergeToName: (gen, from, to) => gen.if(codegen_12._`${to} !== true`, () => {
        if (from === true) {
          gen.assign(to, true);
        } else {
          gen.assign(to, codegen_12._`${to} || {}`);
          setEvaluated(gen, to, from);
        }
      }),
      mergeValues: (from, to) => from === true ? true : __spreadValues(__spreadValues({}, from), to),
      resultToName: evaluatedPropsToName
    }),
    items: makeMergeEvaluated({
      mergeNames: (gen, from, to) => gen.if(codegen_12._`${to} !== true && ${from} !== undefined`, () => gen.assign(to, codegen_12._`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
      mergeToName: (gen, from, to) => gen.if(codegen_12._`${to} !== true`, () => gen.assign(to, from === true ? true : codegen_12._`${to} > ${from} ? ${to} : ${from}`)),
      mergeValues: (from, to) => from === true ? true : Math.max(from, to),
      resultToName: (gen, items2) => gen.var("items", items2)
    })
  };
  function evaluatedPropsToName(gen, ps) {
    if (ps === true)
      return gen.var("props", true);
    const props = gen.var("props", codegen_12._`{}`);
    if (ps !== void 0)
      setEvaluated(gen, props, ps);
    return props;
  }
  exports.evaluatedPropsToName = evaluatedPropsToName;
  function setEvaluated(gen, props, ps) {
    Object.keys(ps).forEach((p) => gen.assign(codegen_12._`${props}${codegen_12.getProperty(p)}`, true));
  }
  exports.setEvaluated = setEvaluated;
  const snippets = {};
  function useFunc(gen, f) {
    return gen.scopeValue("func", {
      ref: f,
      code: snippets[f.code] || (snippets[f.code] = new code_12._Code(f.code))
    });
  }
  exports.useFunc = useFunc;
  var Type2;
  (function(Type3) {
    Type3[Type3["Num"] = 0] = "Num";
    Type3[Type3["Str"] = 1] = "Str";
  })(Type2 = exports.Type || (exports.Type = {}));
  function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
    if (dataProp instanceof codegen_12.Name) {
      const isNumber = dataPropType === Type2.Num;
      return jsPropertySyntax ? isNumber ? codegen_12._`"[" + ${dataProp} + "]"` : codegen_12._`"['" + ${dataProp} + "']"` : isNumber ? codegen_12._`"/" + ${dataProp}` : codegen_12._`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return jsPropertySyntax ? codegen_12.getProperty(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
  }
  exports.getErrorPath = getErrorPath;
  function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
    if (!mode)
      return;
    msg = `strict mode: ${msg}`;
    if (mode === true)
      throw new Error(msg);
    it.self.logger.warn(msg);
  }
  exports.checkStrictMode = checkStrictMode;
})(util);
var names$1 = {};
Object.defineProperty(names$1, "__esModule", { value: true });
const codegen_1$t = codegen;
const names = {
  data: new codegen_1$t.Name("data"),
  valCxt: new codegen_1$t.Name("valCxt"),
  instancePath: new codegen_1$t.Name("instancePath"),
  parentData: new codegen_1$t.Name("parentData"),
  parentDataProperty: new codegen_1$t.Name("parentDataProperty"),
  rootData: new codegen_1$t.Name("rootData"),
  dynamicAnchors: new codegen_1$t.Name("dynamicAnchors"),
  vErrors: new codegen_1$t.Name("vErrors"),
  errors: new codegen_1$t.Name("errors"),
  this: new codegen_1$t.Name("this"),
  self: new codegen_1$t.Name("self"),
  scope: new codegen_1$t.Name("scope"),
  json: new codegen_1$t.Name("json"),
  jsonPos: new codegen_1$t.Name("jsonPos"),
  jsonLen: new codegen_1$t.Name("jsonLen"),
  jsonPart: new codegen_1$t.Name("jsonPart")
};
names$1.default = names;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
  const codegen_12 = codegen;
  const util_12 = util;
  const names_12 = names$1;
  exports.keywordError = {
    message: ({ keyword: keyword2 }) => codegen_12.str`must pass "${keyword2}" keyword validation`
  };
  exports.keyword$DataError = {
    message: ({ keyword: keyword2, schemaType }) => schemaType ? codegen_12.str`"${keyword2}" keyword must be ${schemaType} ($data)` : codegen_12.str`"${keyword2}" keyword is invalid ($data)`
  };
  function reportError(cxt, error2 = exports.keywordError, errorPaths, overrideAllErrors) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
      addError(gen, errObj);
    } else {
      returnErrors(it, codegen_12._`[${errObj}]`);
    }
  }
  exports.reportError = reportError;
  function reportExtraError(cxt, error2 = exports.keywordError, errorPaths) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
      returnErrors(it, names_12.default.vErrors);
    }
  }
  exports.reportExtraError = reportExtraError;
  function resetErrorsCount(gen, errsCount) {
    gen.assign(names_12.default.errors, errsCount);
    gen.if(codegen_12._`${names_12.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign(codegen_12._`${names_12.default.vErrors}.length`, errsCount), () => gen.assign(names_12.default.vErrors, null)));
  }
  exports.resetErrorsCount = resetErrorsCount;
  function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it }) {
    if (errsCount === void 0)
      throw new Error("ajv implementation error");
    const err = gen.name("err");
    gen.forRange("i", errsCount, names_12.default.errors, (i2) => {
      gen.const(err, codegen_12._`${names_12.default.vErrors}[${i2}]`);
      gen.if(codegen_12._`${err}.instancePath === undefined`, () => gen.assign(codegen_12._`${err}.instancePath`, codegen_12.strConcat(names_12.default.instancePath, it.errorPath)));
      gen.assign(codegen_12._`${err}.schemaPath`, codegen_12.str`${it.errSchemaPath}/${keyword2}`);
      if (it.opts.verbose) {
        gen.assign(codegen_12._`${err}.schema`, schemaValue);
        gen.assign(codegen_12._`${err}.data`, data);
      }
    });
  }
  exports.extendErrors = extendErrors;
  function addError(gen, errObj) {
    const err = gen.const("err", errObj);
    gen.if(codegen_12._`${names_12.default.vErrors} === null`, () => gen.assign(names_12.default.vErrors, codegen_12._`[${err}]`), codegen_12._`${names_12.default.vErrors}.push(${err})`);
    gen.code(codegen_12._`${names_12.default.errors}++`);
  }
  function returnErrors(it, errs) {
    const { gen, validateName, schemaEnv } = it;
    if (schemaEnv.$async) {
      gen.throw(codegen_12._`new ${it.ValidationError}(${errs})`);
    } else {
      gen.assign(codegen_12._`${validateName}.errors`, errs);
      gen.return(false);
    }
  }
  const E = {
    keyword: new codegen_12.Name("keyword"),
    schemaPath: new codegen_12.Name("schemaPath"),
    params: new codegen_12.Name("params"),
    propertyName: new codegen_12.Name("propertyName"),
    message: new codegen_12.Name("message"),
    schema: new codegen_12.Name("schema"),
    parentSchema: new codegen_12.Name("parentSchema")
  };
  function errorObjectCode(cxt, error2, errorPaths) {
    const { createErrors } = cxt.it;
    if (createErrors === false)
      return codegen_12._`{}`;
    return errorObject(cxt, error2, errorPaths);
  }
  function errorObject(cxt, error2, errorPaths = {}) {
    const { gen, it } = cxt;
    const keyValues = [
      errorInstancePath(it, errorPaths),
      errorSchemaPath(cxt, errorPaths)
    ];
    extraErrorProps(cxt, error2, keyValues);
    return gen.object(...keyValues);
  }
  function errorInstancePath({ errorPath }, { instancePath }) {
    const instPath = instancePath ? codegen_12.str`${errorPath}${util_12.getErrorPath(instancePath, util_12.Type.Str)}` : errorPath;
    return [names_12.default.instancePath, codegen_12.strConcat(names_12.default.instancePath, instPath)];
  }
  function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
    let schPath = parentSchema ? errSchemaPath : codegen_12.str`${errSchemaPath}/${keyword2}`;
    if (schemaPath) {
      schPath = codegen_12.str`${schPath}${util_12.getErrorPath(schemaPath, util_12.Type.Str)}`;
    }
    return [E.schemaPath, schPath];
  }
  function extraErrorProps(cxt, { params, message }, keyValues) {
    const { keyword: keyword2, data, schemaValue, it } = cxt;
    const { opts: opts2, propertyName, topSchemaRef, schemaPath } = it;
    keyValues.push([E.keyword, keyword2], [E.params, typeof params == "function" ? params(cxt) : params || codegen_12._`{}`]);
    if (opts2.messages) {
      keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts2.verbose) {
      keyValues.push([E.schema, schemaValue], [E.parentSchema, codegen_12._`${topSchemaRef}${schemaPath}`], [names_12.default.data, data]);
    }
    if (propertyName)
      keyValues.push([E.propertyName, propertyName]);
  }
})(errors);
Object.defineProperty(boolSchema, "__esModule", { value: true });
boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
const errors_1$2 = errors;
const codegen_1$s = codegen;
const names_1$6 = names$1;
const boolError = {
  message: "boolean schema is false"
};
function topBoolOrEmptySchema(it) {
  const { gen, schema: schema2, validateName } = it;
  if (schema2 === false) {
    falseSchemaError(it, false);
  } else if (typeof schema2 == "object" && schema2.$async === true) {
    gen.return(names_1$6.default.data);
  } else {
    gen.assign(codegen_1$s._`${validateName}.errors`, null);
    gen.return(true);
  }
}
boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
function boolOrEmptySchema(it, valid2) {
  const { gen, schema: schema2 } = it;
  if (schema2 === false) {
    gen.var(valid2, false);
    falseSchemaError(it);
  } else {
    gen.var(valid2, true);
  }
}
boolSchema.boolOrEmptySchema = boolOrEmptySchema;
function falseSchemaError(it, overrideAllErrors) {
  const { gen, data } = it;
  const cxt = {
    gen,
    keyword: "false schema",
    data,
    schema: false,
    schemaCode: false,
    schemaValue: false,
    params: {},
    it
  };
  errors_1$2.reportError(cxt, boolError, void 0, overrideAllErrors);
}
var dataType = {};
var rules = {};
Object.defineProperty(rules, "__esModule", { value: true });
rules.getRules = rules.isJSONType = void 0;
const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
const jsonTypes = new Set(_jsonTypes);
function isJSONType(x) {
  return typeof x == "string" && jsonTypes.has(x);
}
rules.isJSONType = isJSONType;
function getRules() {
  const groups = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: __spreadProps(__spreadValues({}, groups), { integer: true, boolean: true, null: true }),
    rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
rules.getRules = getRules;
var applicability = {};
Object.defineProperty(applicability, "__esModule", { value: true });
applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
function schemaHasRulesForType({ schema: schema2, self: self2 }, type2) {
  const group = self2.RULES.types[type2];
  return group && group !== true && shouldUseGroup(schema2, group);
}
applicability.schemaHasRulesForType = schemaHasRulesForType;
function shouldUseGroup(schema2, group) {
  return group.rules.some((rule) => shouldUseRule(schema2, rule));
}
applicability.shouldUseGroup = shouldUseGroup;
function shouldUseRule(schema2, rule) {
  var _a;
  return schema2[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema2[kwd] !== void 0));
}
applicability.shouldUseRule = shouldUseRule;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
  const rules_1 = rules;
  const applicability_12 = applicability;
  const errors_12 = errors;
  const codegen_12 = codegen;
  const util_12 = util;
  var DataType;
  (function(DataType2) {
    DataType2[DataType2["Correct"] = 0] = "Correct";
    DataType2[DataType2["Wrong"] = 1] = "Wrong";
  })(DataType = exports.DataType || (exports.DataType = {}));
  function getSchemaTypes(schema2) {
    const types2 = getJSONTypes(schema2.type);
    const hasNull = types2.includes("null");
    if (hasNull) {
      if (schema2.nullable === false)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!types2.length && schema2.nullable !== void 0) {
        throw new Error('"nullable" cannot be used without "type"');
      }
      if (schema2.nullable === true)
        types2.push("null");
    }
    return types2;
  }
  exports.getSchemaTypes = getSchemaTypes;
  function getJSONTypes(ts) {
    const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
    if (types2.every(rules_1.isJSONType))
      return types2;
    throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
  }
  exports.getJSONTypes = getJSONTypes;
  function coerceAndCheckDataType(it, types2) {
    const { gen, data, opts: opts2 } = it;
    const coerceTo = coerceToTypes(types2, opts2.coerceTypes);
    const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && applicability_12.schemaHasRulesForType(it, types2[0]));
    if (checkTypes) {
      const wrongType = checkDataTypes(types2, data, opts2.strictNumbers, DataType.Wrong);
      gen.if(wrongType, () => {
        if (coerceTo.length)
          coerceData(it, types2, coerceTo);
        else
          reportTypeError(it);
      });
    }
    return checkTypes;
  }
  exports.coerceAndCheckDataType = coerceAndCheckDataType;
  const COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
  function coerceToTypes(types2, coerceTypes) {
    return coerceTypes ? types2.filter((t2) => COERCIBLE.has(t2) || coerceTypes === "array" && t2 === "array") : [];
  }
  function coerceData(it, types2, coerceTo) {
    const { gen, data, opts: opts2 } = it;
    const dataType2 = gen.let("dataType", codegen_12._`typeof ${data}`);
    const coerced = gen.let("coerced", codegen_12._`undefined`);
    if (opts2.coerceTypes === "array") {
      gen.if(codegen_12._`${dataType2} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, codegen_12._`${data}[0]`).assign(dataType2, codegen_12._`typeof ${data}`).if(checkDataTypes(types2, data, opts2.strictNumbers), () => gen.assign(coerced, data)));
    }
    gen.if(codegen_12._`${coerced} !== undefined`);
    for (const t2 of coerceTo) {
      if (COERCIBLE.has(t2) || t2 === "array" && opts2.coerceTypes === "array") {
        coerceSpecificType(t2);
      }
    }
    gen.else();
    reportTypeError(it);
    gen.endIf();
    gen.if(codegen_12._`${coerced} !== undefined`, () => {
      gen.assign(data, coerced);
      assignParentData(it, coerced);
    });
    function coerceSpecificType(t2) {
      switch (t2) {
        case "string":
          gen.elseIf(codegen_12._`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, codegen_12._`"" + ${data}`).elseIf(codegen_12._`${data} === null`).assign(coerced, codegen_12._`""`);
          return;
        case "number":
          gen.elseIf(codegen_12._`${dataType2} == "boolean" || ${data} === null
              || (${dataType2} == "string" && ${data} && ${data} == +${data})`).assign(coerced, codegen_12._`+${data}`);
          return;
        case "integer":
          gen.elseIf(codegen_12._`${dataType2} === "boolean" || ${data} === null
              || (${dataType2} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, codegen_12._`+${data}`);
          return;
        case "boolean":
          gen.elseIf(codegen_12._`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf(codegen_12._`${data} === "true" || ${data} === 1`).assign(coerced, true);
          return;
        case "null":
          gen.elseIf(codegen_12._`${data} === "" || ${data} === 0 || ${data} === false`);
          gen.assign(coerced, null);
          return;
        case "array":
          gen.elseIf(codegen_12._`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data} === null`).assign(coerced, codegen_12._`[${data}]`);
      }
    }
  }
  function assignParentData({ gen, parentData, parentDataProperty }, expr) {
    gen.if(codegen_12._`${parentData} !== undefined`, () => gen.assign(codegen_12._`${parentData}[${parentDataProperty}]`, expr));
  }
  function checkDataType(dataType2, data, strictNums, correct = DataType.Correct) {
    const EQ = correct === DataType.Correct ? codegen_12.operators.EQ : codegen_12.operators.NEQ;
    let cond;
    switch (dataType2) {
      case "null":
        return codegen_12._`${data} ${EQ} null`;
      case "array":
        cond = codegen_12._`Array.isArray(${data})`;
        break;
      case "object":
        cond = codegen_12._`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
        break;
      case "integer":
        cond = numCond(codegen_12._`!(${data} % 1) && !isNaN(${data})`);
        break;
      case "number":
        cond = numCond();
        break;
      default:
        return codegen_12._`typeof ${data} ${EQ} ${dataType2}`;
    }
    return correct === DataType.Correct ? cond : codegen_12.not(cond);
    function numCond(_cond = codegen_12.nil) {
      return codegen_12.and(codegen_12._`typeof ${data} == "number"`, _cond, strictNums ? codegen_12._`isFinite(${data})` : codegen_12.nil);
    }
  }
  exports.checkDataType = checkDataType;
  function checkDataTypes(dataTypes, data, strictNums, correct) {
    if (dataTypes.length === 1) {
      return checkDataType(dataTypes[0], data, strictNums, correct);
    }
    let cond;
    const types2 = util_12.toHash(dataTypes);
    if (types2.array && types2.object) {
      const notObj = codegen_12._`typeof ${data} != "object"`;
      cond = types2.null ? notObj : codegen_12._`!${data} || ${notObj}`;
      delete types2.null;
      delete types2.array;
      delete types2.object;
    } else {
      cond = codegen_12.nil;
    }
    if (types2.number)
      delete types2.integer;
    for (const t2 in types2)
      cond = codegen_12.and(cond, checkDataType(t2, data, strictNums, correct));
    return cond;
  }
  exports.checkDataTypes = checkDataTypes;
  const typeError = {
    message: ({ schema: schema2 }) => `must be ${schema2}`,
    params: ({ schema: schema2, schemaValue }) => typeof schema2 == "string" ? codegen_12._`{type: ${schema2}}` : codegen_12._`{type: ${schemaValue}}`
  };
  function reportTypeError(it) {
    const cxt = getTypeErrorContext(it);
    errors_12.reportError(cxt, typeError);
  }
  exports.reportTypeError = reportTypeError;
  function getTypeErrorContext(it) {
    const { gen, data, schema: schema2 } = it;
    const schemaCode = util_12.schemaRefOrVal(it, schema2, "type");
    return {
      gen,
      keyword: "type",
      data,
      schema: schema2.type,
      schemaCode,
      schemaValue: schemaCode,
      parentSchema: schema2,
      params: {},
      it
    };
  }
})(dataType);
var defaults = {};
Object.defineProperty(defaults, "__esModule", { value: true });
defaults.assignDefaults = void 0;
const codegen_1$r = codegen;
const util_1$o = util;
function assignDefaults(it, ty) {
  const { properties: properties2, items: items2 } = it.schema;
  if (ty === "object" && properties2) {
    for (const key in properties2) {
      assignDefault(it, key, properties2[key].default);
    }
  } else if (ty === "array" && Array.isArray(items2)) {
    items2.forEach((sch, i2) => assignDefault(it, i2, sch.default));
  }
}
defaults.assignDefaults = assignDefaults;
function assignDefault(it, prop, defaultValue) {
  const { gen, compositeRule, data, opts: opts2 } = it;
  if (defaultValue === void 0)
    return;
  const childData = codegen_1$r._`${data}${codegen_1$r.getProperty(prop)}`;
  if (compositeRule) {
    util_1$o.checkStrictMode(it, `default is ignored for: ${childData}`);
    return;
  }
  let condition = codegen_1$r._`${childData} === undefined`;
  if (opts2.useDefaults === "empty") {
    condition = codegen_1$r._`${condition} || ${childData} === null || ${childData} === ""`;
  }
  gen.if(condition, codegen_1$r._`${childData} = ${codegen_1$r.stringify(defaultValue)}`);
}
var keyword = {};
var code = {};
Object.defineProperty(code, "__esModule", { value: true });
code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
const codegen_1$q = codegen;
const util_1$n = util;
const names_1$5 = names$1;
function checkReportMissingProp(cxt, prop) {
  const { gen, data, it } = cxt;
  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
    cxt.setParams({ missingProperty: codegen_1$q._`${prop}` }, true);
    cxt.error();
  });
}
code.checkReportMissingProp = checkReportMissingProp;
function checkMissingProp({ gen, data, it: { opts: opts2 } }, properties2, missing) {
  return codegen_1$q.or(...properties2.map((prop) => codegen_1$q.and(noPropertyInData(gen, data, prop, opts2.ownProperties), codegen_1$q._`${missing} = ${prop}`)));
}
code.checkMissingProp = checkMissingProp;
function reportMissingProp(cxt, missing) {
  cxt.setParams({ missingProperty: missing }, true);
  cxt.error();
}
code.reportMissingProp = reportMissingProp;
function hasPropFunc(gen) {
  return gen.scopeValue("func", {
    ref: Object.prototype.hasOwnProperty,
    code: codegen_1$q._`Object.prototype.hasOwnProperty`
  });
}
code.hasPropFunc = hasPropFunc;
function isOwnProperty(gen, data, property) {
  return codegen_1$q._`${hasPropFunc(gen)}.call(${data}, ${property})`;
}
code.isOwnProperty = isOwnProperty;
function propertyInData(gen, data, property, ownProperties) {
  const cond = codegen_1$q._`${data}${codegen_1$q.getProperty(property)} !== undefined`;
  return ownProperties ? codegen_1$q._`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
}
code.propertyInData = propertyInData;
function noPropertyInData(gen, data, property, ownProperties) {
  const cond = codegen_1$q._`${data}${codegen_1$q.getProperty(property)} === undefined`;
  return ownProperties ? codegen_1$q.or(cond, codegen_1$q.not(isOwnProperty(gen, data, property))) : cond;
}
code.noPropertyInData = noPropertyInData;
function allSchemaProperties(schemaMap) {
  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
}
code.allSchemaProperties = allSchemaProperties;
function schemaProperties(it, schemaMap) {
  return allSchemaProperties(schemaMap).filter((p) => !util_1$n.alwaysValidSchema(it, schemaMap[p]));
}
code.schemaProperties = schemaProperties;
function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
  const dataAndSchema = passSchema ? codegen_1$q._`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
  const valCxt = [
    [names_1$5.default.instancePath, codegen_1$q.strConcat(names_1$5.default.instancePath, errorPath)],
    [names_1$5.default.parentData, it.parentData],
    [names_1$5.default.parentDataProperty, it.parentDataProperty],
    [names_1$5.default.rootData, names_1$5.default.rootData]
  ];
  if (it.opts.dynamicRef)
    valCxt.push([names_1$5.default.dynamicAnchors, names_1$5.default.dynamicAnchors]);
  const args = codegen_1$q._`${dataAndSchema}, ${gen.object(...valCxt)}`;
  return context !== codegen_1$q.nil ? codegen_1$q._`${func}.call(${context}, ${args})` : codegen_1$q._`${func}(${args})`;
}
code.callValidateCode = callValidateCode;
function usePattern({ gen, it: { opts: opts2 } }, pattern2) {
  const u2 = opts2.unicodeRegExp ? "u" : "";
  return gen.scopeValue("pattern", {
    key: pattern2,
    ref: new RegExp(pattern2, u2),
    code: codegen_1$q._`new RegExp(${pattern2}, ${u2})`
  });
}
code.usePattern = usePattern;
function validateArray(cxt) {
  const { gen, data, keyword: keyword2, it } = cxt;
  const valid2 = gen.name("valid");
  if (it.allErrors) {
    const validArr = gen.let("valid", true);
    validateItems(() => gen.assign(validArr, false));
    return validArr;
  }
  gen.var(valid2, true);
  validateItems(() => gen.break());
  return valid2;
  function validateItems(notValid) {
    const len = gen.const("len", codegen_1$q._`${data}.length`);
    gen.forRange("i", 0, len, (i2) => {
      cxt.subschema({
        keyword: keyword2,
        dataProp: i2,
        dataPropType: util_1$n.Type.Num
      }, valid2);
      gen.if(codegen_1$q.not(valid2), notValid);
    });
  }
}
code.validateArray = validateArray;
function validateUnion(cxt) {
  const { gen, schema: schema2, keyword: keyword2, it } = cxt;
  if (!Array.isArray(schema2))
    throw new Error("ajv implementation error");
  const alwaysValid = schema2.some((sch) => util_1$n.alwaysValidSchema(it, sch));
  if (alwaysValid && !it.opts.unevaluated)
    return;
  const valid2 = gen.let("valid", false);
  const schValid = gen.name("_valid");
  gen.block(() => schema2.forEach((_sch, i2) => {
    const schCxt = cxt.subschema({
      keyword: keyword2,
      schemaProp: i2,
      compositeRule: true
    }, schValid);
    gen.assign(valid2, codegen_1$q._`${valid2} || ${schValid}`);
    const merged = cxt.mergeValidEvaluated(schCxt, schValid);
    if (!merged)
      gen.if(codegen_1$q.not(valid2));
  }));
  cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
}
code.validateUnion = validateUnion;
Object.defineProperty(keyword, "__esModule", { value: true });
keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
const codegen_1$p = codegen;
const names_1$4 = names$1;
const code_1$9 = code;
const errors_1$1 = errors;
function macroKeywordCode(cxt, def2) {
  const { gen, keyword: keyword2, schema: schema2, parentSchema, it } = cxt;
  const macroSchema = def2.macro.call(it.self, schema2, parentSchema, it);
  const schemaRef = useKeyword(gen, keyword2, macroSchema);
  if (it.opts.validateSchema !== false)
    it.self.validateSchema(macroSchema, true);
  const valid2 = gen.name("valid");
  cxt.subschema({
    schema: macroSchema,
    schemaPath: codegen_1$p.nil,
    errSchemaPath: `${it.errSchemaPath}/${keyword2}`,
    topSchemaRef: schemaRef,
    compositeRule: true
  }, valid2);
  cxt.pass(valid2, () => cxt.error(true));
}
keyword.macroKeywordCode = macroKeywordCode;
function funcKeywordCode(cxt, def2) {
  var _a;
  const { gen, keyword: keyword2, schema: schema2, parentSchema, $data, it } = cxt;
  checkAsyncKeyword(it, def2);
  const validate2 = !$data && def2.compile ? def2.compile.call(it.self, schema2, parentSchema, it) : def2.validate;
  const validateRef = useKeyword(gen, keyword2, validate2);
  const valid2 = gen.let("valid");
  cxt.block$data(valid2, validateKeyword);
  cxt.ok((_a = def2.valid) !== null && _a !== void 0 ? _a : valid2);
  function validateKeyword() {
    if (def2.errors === false) {
      assignValid();
      if (def2.modifying)
        modifyData(cxt);
      reportErrs(() => cxt.error());
    } else {
      const ruleErrs = def2.async ? validateAsync() : validateSync();
      if (def2.modifying)
        modifyData(cxt);
      reportErrs(() => addErrs(cxt, ruleErrs));
    }
  }
  function validateAsync() {
    const ruleErrs = gen.let("ruleErrs", null);
    gen.try(() => assignValid(codegen_1$p._`await `), (e) => gen.assign(valid2, false).if(codegen_1$p._`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, codegen_1$p._`${e}.errors`), () => gen.throw(e)));
    return ruleErrs;
  }
  function validateSync() {
    const validateErrs = codegen_1$p._`${validateRef}.errors`;
    gen.assign(validateErrs, null);
    assignValid(codegen_1$p.nil);
    return validateErrs;
  }
  function assignValid(_await = def2.async ? codegen_1$p._`await ` : codegen_1$p.nil) {
    const passCxt = it.opts.passContext ? names_1$4.default.this : names_1$4.default.self;
    const passSchema = !("compile" in def2 && !$data || def2.schema === false);
    gen.assign(valid2, codegen_1$p._`${_await}${code_1$9.callValidateCode(cxt, validateRef, passCxt, passSchema)}`, def2.modifying);
  }
  function reportErrs(errors2) {
    var _a2;
    gen.if(codegen_1$p.not((_a2 = def2.valid) !== null && _a2 !== void 0 ? _a2 : valid2), errors2);
  }
}
keyword.funcKeywordCode = funcKeywordCode;
function modifyData(cxt) {
  const { gen, data, it } = cxt;
  gen.if(it.parentData, () => gen.assign(data, codegen_1$p._`${it.parentData}[${it.parentDataProperty}]`));
}
function addErrs(cxt, errs) {
  const { gen } = cxt;
  gen.if(codegen_1$p._`Array.isArray(${errs})`, () => {
    gen.assign(names_1$4.default.vErrors, codegen_1$p._`${names_1$4.default.vErrors} === null ? ${errs} : ${names_1$4.default.vErrors}.concat(${errs})`).assign(names_1$4.default.errors, codegen_1$p._`${names_1$4.default.vErrors}.length`);
    errors_1$1.extendErrors(cxt);
  }, () => cxt.error());
}
function checkAsyncKeyword({ schemaEnv }, def2) {
  if (def2.async && !schemaEnv.$async)
    throw new Error("async keyword in sync schema");
}
function useKeyword(gen, keyword2, result) {
  if (result === void 0)
    throw new Error(`keyword "${keyword2}" failed to compile`);
  return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: codegen_1$p.stringify(result) });
}
function validSchemaType(schema2, schemaType, allowUndefined = false) {
  return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema2) : st === "object" ? schema2 && typeof schema2 == "object" && !Array.isArray(schema2) : typeof schema2 == st || allowUndefined && typeof schema2 == "undefined");
}
keyword.validSchemaType = validSchemaType;
function validateKeywordUsage({ schema: schema2, opts: opts2, self: self2, errSchemaPath }, def2, keyword2) {
  if (Array.isArray(def2.keyword) ? !def2.keyword.includes(keyword2) : def2.keyword !== keyword2) {
    throw new Error("ajv implementation error");
  }
  const deps = def2.dependencies;
  if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema2, kwd))) {
    throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
  }
  if (def2.validateSchema) {
    const valid2 = def2.validateSchema(schema2[keyword2]);
    if (!valid2) {
      const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def2.validateSchema.errors);
      if (opts2.validateSchema === "log")
        self2.logger.error(msg);
      else
        throw new Error(msg);
    }
  }
}
keyword.validateKeywordUsage = validateKeywordUsage;
var subschema = {};
Object.defineProperty(subschema, "__esModule", { value: true });
subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
const codegen_1$o = codegen;
const util_1$m = util;
function getSubschema(it, { keyword: keyword2, schemaProp, schema: schema2, schemaPath, errSchemaPath, topSchemaRef }) {
  if (keyword2 !== void 0 && schema2 !== void 0) {
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  }
  if (keyword2 !== void 0) {
    const sch = it.schema[keyword2];
    return schemaProp === void 0 ? {
      schema: sch,
      schemaPath: codegen_1$o._`${it.schemaPath}${codegen_1$o.getProperty(keyword2)}`,
      errSchemaPath: `${it.errSchemaPath}/${keyword2}`
    } : {
      schema: sch[schemaProp],
      schemaPath: codegen_1$o._`${it.schemaPath}${codegen_1$o.getProperty(keyword2)}${codegen_1$o.getProperty(schemaProp)}`,
      errSchemaPath: `${it.errSchemaPath}/${keyword2}/${util_1$m.escapeFragment(schemaProp)}`
    };
  }
  if (schema2 !== void 0) {
    if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    }
    return {
      schema: schema2,
      schemaPath,
      topSchemaRef,
      errSchemaPath
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
subschema.getSubschema = getSubschema;
function extendSubschemaData(subschema2, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
  if (data !== void 0 && dataProp !== void 0) {
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  }
  const { gen } = it;
  if (dataProp !== void 0) {
    const { errorPath, dataPathArr, opts: opts2 } = it;
    const nextData = gen.let("data", codegen_1$o._`${it.data}${codegen_1$o.getProperty(dataProp)}`, true);
    dataContextProps(nextData);
    subschema2.errorPath = codegen_1$o.str`${errorPath}${util_1$m.getErrorPath(dataProp, dpType, opts2.jsPropertySyntax)}`;
    subschema2.parentDataProperty = codegen_1$o._`${dataProp}`;
    subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
  }
  if (data !== void 0) {
    const nextData = data instanceof codegen_1$o.Name ? data : gen.let("data", data, true);
    dataContextProps(nextData);
    if (propertyName !== void 0)
      subschema2.propertyName = propertyName;
  }
  if (dataTypes)
    subschema2.dataTypes = dataTypes;
  function dataContextProps(_nextData) {
    subschema2.data = _nextData;
    subschema2.dataLevel = it.dataLevel + 1;
    subschema2.dataTypes = [];
    it.definedProperties = new Set();
    subschema2.parentData = it.data;
    subschema2.dataNames = [...it.dataNames, _nextData];
  }
}
subschema.extendSubschemaData = extendSubschemaData;
function extendSubschemaMode(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
  if (compositeRule !== void 0)
    subschema2.compositeRule = compositeRule;
  if (createErrors !== void 0)
    subschema2.createErrors = createErrors;
  if (allErrors !== void 0)
    subschema2.allErrors = allErrors;
  subschema2.jtdDiscriminator = jtdDiscriminator;
  subschema2.jtdMetadata = jtdMetadata;
}
subschema.extendSubschemaMode = extendSubschemaMode;
var resolve$1 = {};
var fastDeepEqual = function equal2(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    if (a.constructor !== b.constructor)
      return false;
    var length, i2, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i2 = length; i2-- !== 0; )
        if (!equal2(a[i2], b[i2]))
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i2 = length; i2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys[i2]))
        return false;
    for (i2 = length; i2-- !== 0; ) {
      var key = keys[i2];
      if (!equal2(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
};
var jsonSchemaTraverse = { exports: {} };
var traverse$1 = jsonSchemaTraverse.exports = function(schema2, opts2, cb) {
  if (typeof opts2 == "function") {
    cb = opts2;
    opts2 = {};
  }
  cb = opts2.cb || cb;
  var pre = typeof cb == "function" ? cb : cb.pre || function() {
  };
  var post = cb.post || function() {
  };
  _traverse(opts2, pre, post, schema2, "", schema2);
};
traverse$1.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true,
  if: true,
  then: true,
  else: true
};
traverse$1.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};
traverse$1.propsKeywords = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};
traverse$1.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};
function _traverse(opts2, pre, post, schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema2 && typeof schema2 == "object" && !Array.isArray(schema2)) {
    pre(schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema2) {
      var sch = schema2[key];
      if (Array.isArray(sch)) {
        if (key in traverse$1.arrayKeywords) {
          for (var i2 = 0; i2 < sch.length; i2++)
            _traverse(opts2, pre, post, sch[i2], jsonPtr + "/" + key + "/" + i2, rootSchema, jsonPtr, key, schema2, i2);
        }
      } else if (key in traverse$1.propsKeywords) {
        if (sch && typeof sch == "object") {
          for (var prop in sch)
            _traverse(opts2, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema2, prop);
        }
      } else if (key in traverse$1.keywords || opts2.allKeys && !(key in traverse$1.skipKeywords)) {
        _traverse(opts2, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema2);
      }
    }
    post(schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}
function escapeJsonPtr(str2) {
  return str2.replace(/~/g, "~0").replace(/\//g, "~1");
}
var uri_all = { exports: {} };
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function(module, exports) {
  (function(global2, factory) {
    factory(exports);
  })(commonjsGlobal, function(exports2) {
    function merge2() {
      for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
        sets[_key] = arguments[_key];
      }
      if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
          sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join("");
      } else {
        return sets[0];
      }
    }
    function subexp(str2) {
      return "(?:" + str2 + ")";
    }
    function typeOf(o) {
      return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
    }
    function toUpperCase(str2) {
      return str2.toUpperCase();
    }
    function toArray2(obj) {
      return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
    }
    function assign(target, source2) {
      var obj = target;
      if (source2) {
        for (var key in source2) {
          obj[key] = source2[key];
        }
      }
      return obj;
    }
    function buildExps(isIRI) {
      var ALPHA$$ = "[A-Za-z]", DIGIT$$ = "[0-9]", HEXDIG$$2 = merge2(DIGIT$$, "[A-Fa-f]"), PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge2(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge2(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$);
      subexp(ALPHA$$ + merge2(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*");
      subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*");
      var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+");
      subexp("[vV]" + HEXDIG$$2 + "+\\." + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+");
      subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$)) + "*");
      var PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]"));
      subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+");
      subexp(subexp(PCHAR$ + "|" + merge2("[\\/\\?]", IPRIVATE$$)) + "*");
      return {
        NOT_SCHEME: new RegExp(merge2("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge2("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge2("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge2("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge2("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge2("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge2("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(merge2("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
        OTHER_CHARS: new RegExp(merge2("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
      };
    }
    var URI_PROTOCOL = buildExps(false);
    var IRI_PROTOCOL = buildExps(true);
    var slicedToArray = function() {
      function sliceIterator(arr, i2) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i2 && _arr.length === i2)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"])
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i2) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i2);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    var toConsumableArray = function(arr) {
      if (Array.isArray(arr)) {
        for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++)
          arr2[i2] = arr[i2];
        return arr2;
      } else {
        return Array.from(arr);
      }
    };
    var maxInt = 2147483647;
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter = "-";
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7E]/;
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    var errors2 = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    function error$12(type2) {
      throw new RangeError(errors2[type2]);
    }
    function map2(array, fn) {
      var result = [];
      var length = array.length;
      while (length--) {
        result[length] = fn(array[length]);
      }
      return result;
    }
    function mapDomain(string, fn) {
      var parts = string.split("@");
      var result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string = parts[1];
      }
      string = string.replace(regexSeparators, ".");
      var labels = string.split(".");
      var encoded = map2(labels, fn).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      var output2 = [];
      var counter = 0;
      var length = string.length;
      while (counter < length) {
        var value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          var extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output2.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output2.push(value);
            counter--;
          }
        } else {
          output2.push(value);
        }
      }
      return output2;
    }
    var ucs2encode = function ucs2encode2(array) {
      return String.fromCodePoint.apply(String, toConsumableArray(array));
    };
    var basicToDigit = function basicToDigit2(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    };
    var digitToBasic = function digitToBasic2(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    var adapt = function adapt2(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var decode = function decode2(input) {
      var output2 = [];
      var inputLength = input.length;
      var i2 = 0;
      var n = initialN;
      var bias = initialBias;
      var basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (var j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error$12("not-basic");
        }
        output2.push(input.charCodeAt(j));
      }
      for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        var oldi = i2;
        for (var w2 = 1, k = base; ; k += base) {
          if (index >= inputLength) {
            error$12("invalid-input");
          }
          var digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base || digit > floor((maxInt - i2) / w2)) {
            error$12("overflow");
          }
          i2 += digit * w2;
          var t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t2) {
            break;
          }
          var baseMinusT = base - t2;
          if (w2 > floor(maxInt / baseMinusT)) {
            error$12("overflow");
          }
          w2 *= baseMinusT;
        }
        var out2 = output2.length + 1;
        bias = adapt(i2 - oldi, out2, oldi == 0);
        if (floor(i2 / out2) > maxInt - n) {
          error$12("overflow");
        }
        n += floor(i2 / out2);
        i2 %= out2;
        output2.splice(i2++, 0, n);
      }
      return String.fromCodePoint.apply(String, output2);
    };
    var encode = function encode2(input) {
      var output2 = [];
      input = ucs2decode(input);
      var inputLength = input.length;
      var n = initialN;
      var delta = 0;
      var bias = initialBias;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _currentValue2 = _step.value;
          if (_currentValue2 < 128) {
            output2.push(stringFromCharCode(_currentValue2));
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      var basicLength = output2.length;
      var handledCPCount = basicLength;
      if (basicLength) {
        output2.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        var m2 = maxInt;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = void 0;
        try {
          for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var currentValue = _step2.value;
            if (currentValue >= n && currentValue < m2) {
              m2 = currentValue;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
        var handledCPCountPlusOne = handledCPCount + 1;
        if (m2 - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error$12("overflow");
        }
        delta += (m2 - n) * handledCPCountPlusOne;
        n = m2;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = void 0;
        try {
          for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _currentValue = _step3.value;
            if (_currentValue < n && ++delta > maxInt) {
              error$12("overflow");
            }
            if (_currentValue == n) {
              var q = delta;
              for (var k = base; ; k += base) {
                var t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t2) {
                  break;
                }
                var qMinusT = q - t2;
                var baseMinusT = base - t2;
                output2.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
                q = floor(qMinusT / baseMinusT);
              }
              output2.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
        ++delta;
        ++n;
      }
      return output2.join("");
    };
    var toUnicode = function toUnicode2(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    var toASCII = function toASCII2(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    var punycode = {
      "version": "2.1.0",
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode,
      "encode": encode,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    var SCHEMES = {};
    function pctEncChar(chr) {
      var c = chr.charCodeAt(0);
      var e = void 0;
      if (c < 16)
        e = "%0" + c.toString(16).toUpperCase();
      else if (c < 128)
        e = "%" + c.toString(16).toUpperCase();
      else if (c < 2048)
        e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      else
        e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      return e;
    }
    function pctDecChars(str2) {
      var newStr = "";
      var i2 = 0;
      var il = str2.length;
      while (i2 < il) {
        var c = parseInt(str2.substr(i2 + 1, 2), 16);
        if (c < 128) {
          newStr += String.fromCharCode(c);
          i2 += 3;
        } else if (c >= 194 && c < 224) {
          if (il - i2 >= 6) {
            var c2 = parseInt(str2.substr(i2 + 4, 2), 16);
            newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
          } else {
            newStr += str2.substr(i2, 6);
          }
          i2 += 6;
        } else if (c >= 224) {
          if (il - i2 >= 9) {
            var _c = parseInt(str2.substr(i2 + 4, 2), 16);
            var c3 = parseInt(str2.substr(i2 + 7, 2), 16);
            newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
          } else {
            newStr += str2.substr(i2, 9);
          }
          i2 += 9;
        } else {
          newStr += str2.substr(i2, 3);
          i2 += 3;
        }
      }
      return newStr;
    }
    function _normalizeComponentEncoding(components, protocol) {
      function decodeUnreserved2(str2) {
        var decStr = pctDecChars(str2);
        return !decStr.match(protocol.UNRESERVED) ? str2 : decStr;
      }
      if (components.scheme)
        components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
      if (components.userinfo !== void 0)
        components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.host !== void 0)
        components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.path !== void 0)
        components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.query !== void 0)
        components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.fragment !== void 0)
        components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      return components;
    }
    function _stripLeadingZeros(str2) {
      return str2.replace(/^0*(.*)/, "$1") || "0";
    }
    function _normalizeIPv4(host, protocol) {
      var matches = host.match(protocol.IPV4ADDRESS) || [];
      var _matches = slicedToArray(matches, 2), address = _matches[1];
      if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
      } else {
        return host;
      }
    }
    function _normalizeIPv6(host, protocol) {
      var matches = host.match(protocol.IPV6ADDRESS) || [];
      var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
      if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
          fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
        }
        if (isLastFieldIPv4Address) {
          fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function(acc, field, index) {
          if (!field || field === "0") {
            var lastLongest = acc[acc.length - 1];
            if (lastLongest && lastLongest.index + lastLongest.length === index) {
              lastLongest.length++;
            } else {
              acc.push({ index, length: 1 });
            }
          }
          return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function(a, b) {
          return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
          var newFirst = fields.slice(0, longestZeroFields.index);
          var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
          newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
          newHost = fields.join(":");
        }
        if (zone) {
          newHost += "%" + zone;
        }
        return newHost;
      } else {
        return host;
      }
    }
    var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
    var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
    function parse2(uriString) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var components = {};
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      if (options.reference === "suffix")
        uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
      var matches = uriString.match(URI_PARSE);
      if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
          components.scheme = matches[1];
          components.userinfo = matches[3];
          components.host = matches[4];
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = matches[7];
          components.fragment = matches[8];
          if (isNaN(components.port)) {
            components.port = matches[5];
          }
        } else {
          components.scheme = matches[1] || void 0;
          components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
          components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
          components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
          if (isNaN(components.port)) {
            components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
          }
        }
        if (components.host) {
          components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
          components.reference = "same-document";
        } else if (components.scheme === void 0) {
          components.reference = "relative";
        } else if (components.fragment === void 0) {
          components.reference = "absolute";
        } else {
          components.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
          components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
            try {
              components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
            }
          }
          _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
          _normalizeComponentEncoding(components, protocol);
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(components, options);
        }
      } else {
        components.error = components.error || "URI can not be parsed.";
      }
      return components;
    }
    function _recomposeAuthority(components, options) {
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
          return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    var RDS1 = /^\.\.?\//;
    var RDS2 = /^\/\.(\/|$)/;
    var RDS3 = /^\/\.\.(\/|$)/;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
    function removeDotSegments(input) {
      var output2 = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output2.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          var im = input.match(RDS5);
          if (im) {
            var s2 = im[0];
            input = input.slice(s2.length);
            output2.push(s2);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output2.join("");
    }
    function serialize(components) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize)
        schemeHandler.serialize(components, options);
      if (components.host) {
        if (protocol.IPV6ADDRESS.test(components.host))
          ;
        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
          try {
            components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
          } catch (e) {
            components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
          }
        }
      }
      _normalizeComponentEncoding(components, protocol);
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
      }
      var authority = _recomposeAuthority(components, options);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        var s2 = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s2 = removeDotSegments(s2);
        }
        if (authority === void 0) {
          s2 = s2.replace(/^\/\//, "/%2F");
        }
        uriTokens.push(s2);
      }
      if (components.query !== void 0) {
        uriTokens.push("?");
        uriTokens.push(components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
      }
      return uriTokens.join("");
    }
    function resolveComponents(base2, relative) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var skipNormalization = arguments[3];
      var target = {};
      if (!skipNormalization) {
        base2 = parse2(serialize(base2, options), options);
        relative = parse2(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base2.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base2.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                target.path = "/" + relative.path;
              } else if (!base2.path) {
                target.path = relative.path;
              } else {
                target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base2.userinfo;
          target.host = base2.host;
          target.port = base2.port;
        }
        target.scheme = base2.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function resolve2(baseURI, relativeURI, options) {
      var schemelessOptions = assign({ scheme: "null" }, options);
      return serialize(resolveComponents(parse2(baseURI, schemelessOptions), parse2(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
    }
    function normalize(uri, options) {
      if (typeof uri === "string") {
        uri = serialize(parse2(uri, options), options);
      } else if (typeOf(uri) === "object") {
        uri = parse2(serialize(uri, options), options);
      }
      return uri;
    }
    function equal3(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = serialize(parse2(uriA, options), options);
      } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
      }
      if (typeof uriB === "string") {
        uriB = serialize(parse2(uriB, options), options);
      } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
      }
      return uriA === uriB;
    }
    function escapeComponent(str2, options) {
      return str2 && str2.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
    }
    function unescapeComponent(str2, options) {
      return str2 && str2.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
    }
    var handler = {
      scheme: "http",
      domainHost: true,
      parse: function parse3(components, options) {
        if (!components.host) {
          components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
      },
      serialize: function serialize2(components, options) {
        var secure = String(components.scheme).toLowerCase() === "https";
        if (components.port === (secure ? 443 : 80) || components.port === "") {
          components.port = void 0;
        }
        if (!components.path) {
          components.path = "/";
        }
        return components;
      }
    };
    var handler$1 = {
      scheme: "https",
      domainHost: handler.domainHost,
      parse: handler.parse,
      serialize: handler.serialize
    };
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    var handler$2 = {
      scheme: "ws",
      domainHost: true,
      parse: function parse3(components, options) {
        var wsComponents = components;
        wsComponents.secure = isSecure(wsComponents);
        wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
        wsComponents.path = void 0;
        wsComponents.query = void 0;
        return wsComponents;
      },
      serialize: function serialize2(wsComponents, options) {
        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
          wsComponents.port = void 0;
        }
        if (typeof wsComponents.secure === "boolean") {
          wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
          wsComponents.secure = void 0;
        }
        if (wsComponents.resourceName) {
          var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path2 = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
          wsComponents.path = path2 && path2 !== "/" ? path2 : void 0;
          wsComponents.query = query;
          wsComponents.resourceName = void 0;
        }
        wsComponents.fragment = void 0;
        return wsComponents;
      }
    };
    var handler$3 = {
      scheme: "wss",
      domainHost: handler$2.domainHost,
      parse: handler$2.parse,
      serialize: handler$2.serialize
    };
    var O = {};
    var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]";
    var HEXDIG$$ = "[0-9A-Fa-f]";
    var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
    var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
    var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
    var VCHAR$$ = merge2(QTEXT$$, '[\\"\\\\]');
    var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
    var UNRESERVED = new RegExp(UNRESERVED$$, "g");
    var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
    var NOT_LOCAL_PART = new RegExp(merge2("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
    var NOT_HFNAME = new RegExp(merge2("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
    var NOT_HFVALUE = NOT_HFNAME;
    function decodeUnreserved(str2) {
      var decStr = pctDecChars(str2);
      return !decStr.match(UNRESERVED) ? str2 : decStr;
    }
    var handler$4 = {
      scheme: "mailto",
      parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = void 0;
        if (mailtoComponents.query) {
          var unknownHeaders = false;
          var headers = {};
          var hfields = mailtoComponents.query.split("&");
          for (var x = 0, xl = hfields.length; x < xl; ++x) {
            var hfield = hfields[x].split("=");
            switch (hfield[0]) {
              case "to":
                var toAddrs = hfield[1].split(",");
                for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                  to.push(toAddrs[_x]);
                }
                break;
              case "subject":
                mailtoComponents.subject = unescapeComponent(hfield[1], options);
                break;
              case "body":
                mailtoComponents.body = unescapeComponent(hfield[1], options);
                break;
              default:
                unknownHeaders = true;
                headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                break;
            }
          }
          if (unknownHeaders)
            mailtoComponents.headers = headers;
        }
        mailtoComponents.query = void 0;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
          var addr = to[_x2].split("@");
          addr[0] = unescapeComponent(addr[0]);
          if (!options.unicodeSupport) {
            try {
              addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
            } catch (e) {
              mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
            }
          } else {
            addr[1] = unescapeComponent(addr[1], options).toLowerCase();
          }
          to[_x2] = addr.join("@");
        }
        return mailtoComponents;
      },
      serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray2(mailtoComponents.to);
        if (to) {
          for (var x = 0, xl = to.length; x < xl; ++x) {
            var toAddr = String(to[x]);
            var atIdx = toAddr.lastIndexOf("@");
            var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
            var domain = toAddr.slice(atIdx + 1);
            try {
              domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
            } catch (e) {
              components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
            to[x] = localPart + "@" + domain;
          }
          components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject)
          headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body)
          headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
          if (headers[name] !== O[name]) {
            fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
          }
        }
        if (fields.length) {
          components.query = fields.join("&");
        }
        return components;
      }
    };
    var URN_PARSE = /^([^\:]+)\:(.*)/;
    var handler$5 = {
      scheme: "urn",
      parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = matches[1].toLowerCase();
          var nss = matches[2];
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          urnComponents.nid = nid;
          urnComponents.nss = nss;
          urnComponents.path = void 0;
          if (schemeHandler) {
            urnComponents = schemeHandler.parse(urnComponents, options);
          }
        } else {
          urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
      },
      serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
          urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
      }
    };
    var UUID2 = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
    var handler$6 = {
      scheme: "urn:uuid",
      parse: function parse3(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = void 0;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID2))) {
          uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
      },
      serialize: function serialize2(uuidComponents, options) {
        var urnComponents = uuidComponents;
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
      }
    };
    SCHEMES[handler.scheme] = handler;
    SCHEMES[handler$1.scheme] = handler$1;
    SCHEMES[handler$2.scheme] = handler$2;
    SCHEMES[handler$3.scheme] = handler$3;
    SCHEMES[handler$4.scheme] = handler$4;
    SCHEMES[handler$5.scheme] = handler$5;
    SCHEMES[handler$6.scheme] = handler$6;
    exports2.SCHEMES = SCHEMES;
    exports2.pctEncChar = pctEncChar;
    exports2.pctDecChars = pctDecChars;
    exports2.parse = parse2;
    exports2.removeDotSegments = removeDotSegments;
    exports2.serialize = serialize;
    exports2.resolveComponents = resolveComponents;
    exports2.resolve = resolve2;
    exports2.normalize = normalize;
    exports2.equal = equal3;
    exports2.escapeComponent = escapeComponent;
    exports2.unescapeComponent = unescapeComponent;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
})(uri_all, uri_all.exports);
Object.defineProperty(resolve$1, "__esModule", { value: true });
resolve$1.getSchemaRefs = resolve$1.resolveUrl = resolve$1.normalizeId = resolve$1._getFullPath = resolve$1.getFullPath = resolve$1.inlineRef = void 0;
const util_1$l = util;
const equal$2 = fastDeepEqual;
const traverse = jsonSchemaTraverse.exports;
const URI$1 = uri_all.exports;
const SIMPLE_INLINED = new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function inlineRef(schema2, limit2 = true) {
  if (typeof schema2 == "boolean")
    return true;
  if (limit2 === true)
    return !hasRef(schema2);
  if (!limit2)
    return false;
  return countKeys(schema2) <= limit2;
}
resolve$1.inlineRef = inlineRef;
const REF_KEYWORDS = new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function hasRef(schema2) {
  for (const key in schema2) {
    if (REF_KEYWORDS.has(key))
      return true;
    const sch = schema2[key];
    if (Array.isArray(sch) && sch.some(hasRef))
      return true;
    if (typeof sch == "object" && hasRef(sch))
      return true;
  }
  return false;
}
function countKeys(schema2) {
  let count = 0;
  for (const key in schema2) {
    if (key === "$ref")
      return Infinity;
    count++;
    if (SIMPLE_INLINED.has(key))
      continue;
    if (typeof schema2[key] == "object") {
      util_1$l.eachItem(schema2[key], (sch) => count += countKeys(sch));
    }
    if (count === Infinity)
      return Infinity;
  }
  return count;
}
function getFullPath(id2 = "", normalize) {
  if (normalize !== false)
    id2 = normalizeId(id2);
  const p = URI$1.parse(id2);
  return _getFullPath(p);
}
resolve$1.getFullPath = getFullPath;
function _getFullPath(p) {
  return URI$1.serialize(p).split("#")[0] + "#";
}
resolve$1._getFullPath = _getFullPath;
const TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id2) {
  return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
}
resolve$1.normalizeId = normalizeId;
function resolveUrl(baseId, id2) {
  id2 = normalizeId(id2);
  return URI$1.resolve(baseId, id2);
}
resolve$1.resolveUrl = resolveUrl;
const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
function getSchemaRefs(schema2) {
  if (typeof schema2 == "boolean")
    return {};
  const { schemaId } = this.opts;
  const schId = normalizeId(schema2[schemaId]);
  const baseIds = { "": schId };
  const pathPrefix = getFullPath(schId, false);
  const localRefs = {};
  const schemaRefs = new Set();
  traverse(schema2, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
    if (parentJsonPtr === void 0)
      return;
    const fullPath = pathPrefix + jsonPtr;
    let baseId = baseIds[parentJsonPtr];
    if (typeof sch[schemaId] == "string")
      baseId = addRef.call(this, sch[schemaId]);
    addAnchor.call(this, sch.$anchor);
    addAnchor.call(this, sch.$dynamicAnchor);
    baseIds[jsonPtr] = baseId;
    function addRef(ref2) {
      ref2 = normalizeId(baseId ? URI$1.resolve(baseId, ref2) : ref2);
      if (schemaRefs.has(ref2))
        throw ambiguos(ref2);
      schemaRefs.add(ref2);
      let schOrRef = this.refs[ref2];
      if (typeof schOrRef == "string")
        schOrRef = this.refs[schOrRef];
      if (typeof schOrRef == "object") {
        checkAmbiguosRef(sch, schOrRef.schema, ref2);
      } else if (ref2 !== normalizeId(fullPath)) {
        if (ref2[0] === "#") {
          checkAmbiguosRef(sch, localRefs[ref2], ref2);
          localRefs[ref2] = sch;
        } else {
          this.refs[ref2] = fullPath;
        }
      }
      return ref2;
    }
    function addAnchor(anchor) {
      if (typeof anchor == "string") {
        if (!ANCHOR.test(anchor))
          throw new Error(`invalid anchor "${anchor}"`);
        addRef.call(this, `#${anchor}`);
      }
    }
  });
  return localRefs;
  function checkAmbiguosRef(sch1, sch2, ref2) {
    if (sch2 !== void 0 && !equal$2(sch1, sch2))
      throw ambiguos(ref2);
  }
  function ambiguos(ref2) {
    return new Error(`reference "${ref2}" resolves to more than one schema`);
  }
}
resolve$1.getSchemaRefs = getSchemaRefs;
Object.defineProperty(validate, "__esModule", { value: true });
validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
const boolSchema_1 = boolSchema;
const dataType_1$1 = dataType;
const applicability_1 = applicability;
const dataType_2 = dataType;
const defaults_1 = defaults;
const keyword_1 = keyword;
const subschema_1 = subschema;
const codegen_1$n = codegen;
const names_1$3 = names$1;
const resolve_1$2 = resolve$1;
const util_1$k = util;
const errors_1 = errors;
function validateFunctionCode(it) {
  if (isSchemaObj(it)) {
    checkKeywords(it);
    if (schemaCxtHasRules(it)) {
      topSchemaObjCode(it);
      return;
    }
  }
  validateFunction(it, () => boolSchema_1.topBoolOrEmptySchema(it));
}
validate.validateFunctionCode = validateFunctionCode;
function validateFunction({ gen, validateName, schema: schema2, schemaEnv, opts: opts2 }, body) {
  if (opts2.code.es5) {
    gen.func(validateName, codegen_1$n._`${names_1$3.default.data}, ${names_1$3.default.valCxt}`, schemaEnv.$async, () => {
      gen.code(codegen_1$n._`"use strict"; ${funcSourceUrl(schema2, opts2)}`);
      destructureValCxtES5(gen, opts2);
      gen.code(body);
    });
  } else {
    gen.func(validateName, codegen_1$n._`${names_1$3.default.data}, ${destructureValCxt(opts2)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema2, opts2)).code(body));
  }
}
function destructureValCxt(opts2) {
  return codegen_1$n._`{${names_1$3.default.instancePath}="", ${names_1$3.default.parentData}, ${names_1$3.default.parentDataProperty}, ${names_1$3.default.rootData}=${names_1$3.default.data}${opts2.dynamicRef ? codegen_1$n._`, ${names_1$3.default.dynamicAnchors}={}` : codegen_1$n.nil}}={}`;
}
function destructureValCxtES5(gen, opts2) {
  gen.if(names_1$3.default.valCxt, () => {
    gen.var(names_1$3.default.instancePath, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.instancePath}`);
    gen.var(names_1$3.default.parentData, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.parentData}`);
    gen.var(names_1$3.default.parentDataProperty, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.parentDataProperty}`);
    gen.var(names_1$3.default.rootData, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.rootData}`);
    if (opts2.dynamicRef)
      gen.var(names_1$3.default.dynamicAnchors, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.dynamicAnchors}`);
  }, () => {
    gen.var(names_1$3.default.instancePath, codegen_1$n._`""`);
    gen.var(names_1$3.default.parentData, codegen_1$n._`undefined`);
    gen.var(names_1$3.default.parentDataProperty, codegen_1$n._`undefined`);
    gen.var(names_1$3.default.rootData, names_1$3.default.data);
    if (opts2.dynamicRef)
      gen.var(names_1$3.default.dynamicAnchors, codegen_1$n._`{}`);
  });
}
function topSchemaObjCode(it) {
  const { schema: schema2, opts: opts2, gen } = it;
  validateFunction(it, () => {
    if (opts2.$comment && schema2.$comment)
      commentKeyword(it);
    checkNoDefault(it);
    gen.let(names_1$3.default.vErrors, null);
    gen.let(names_1$3.default.errors, 0);
    if (opts2.unevaluated)
      resetEvaluated(it);
    typeAndKeywords(it);
    returnResults(it);
  });
  return;
}
function resetEvaluated(it) {
  const { gen, validateName } = it;
  it.evaluated = gen.const("evaluated", codegen_1$n._`${validateName}.evaluated`);
  gen.if(codegen_1$n._`${it.evaluated}.dynamicProps`, () => gen.assign(codegen_1$n._`${it.evaluated}.props`, codegen_1$n._`undefined`));
  gen.if(codegen_1$n._`${it.evaluated}.dynamicItems`, () => gen.assign(codegen_1$n._`${it.evaluated}.items`, codegen_1$n._`undefined`));
}
function funcSourceUrl(schema2, opts2) {
  const schId = typeof schema2 == "object" && schema2[opts2.schemaId];
  return schId && (opts2.code.source || opts2.code.process) ? codegen_1$n._`/*# sourceURL=${schId} */` : codegen_1$n.nil;
}
function subschemaCode(it, valid2) {
  if (isSchemaObj(it)) {
    checkKeywords(it);
    if (schemaCxtHasRules(it)) {
      subSchemaObjCode(it, valid2);
      return;
    }
  }
  boolSchema_1.boolOrEmptySchema(it, valid2);
}
function schemaCxtHasRules({ schema: schema2, self: self2 }) {
  if (typeof schema2 == "boolean")
    return !schema2;
  for (const key in schema2)
    if (self2.RULES.all[key])
      return true;
  return false;
}
function isSchemaObj(it) {
  return typeof it.schema != "boolean";
}
function subSchemaObjCode(it, valid2) {
  const { schema: schema2, gen, opts: opts2 } = it;
  if (opts2.$comment && schema2.$comment)
    commentKeyword(it);
  updateContext(it);
  checkAsyncSchema(it);
  const errsCount = gen.const("_errs", names_1$3.default.errors);
  typeAndKeywords(it, errsCount);
  gen.var(valid2, codegen_1$n._`${errsCount} === ${names_1$3.default.errors}`);
}
function checkKeywords(it) {
  util_1$k.checkUnknownRules(it);
  checkRefsAndKeywords(it);
}
function typeAndKeywords(it, errsCount) {
  if (it.opts.jtd)
    return schemaKeywords(it, [], false, errsCount);
  const types2 = dataType_1$1.getSchemaTypes(it.schema);
  const checkedTypes = dataType_1$1.coerceAndCheckDataType(it, types2);
  schemaKeywords(it, types2, !checkedTypes, errsCount);
}
function checkRefsAndKeywords(it) {
  const { schema: schema2, errSchemaPath, opts: opts2, self: self2 } = it;
  if (schema2.$ref && opts2.ignoreKeywordsWithRef && util_1$k.schemaHasRulesButRef(schema2, self2.RULES)) {
    self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
  }
}
function checkNoDefault(it) {
  const { schema: schema2, opts: opts2 } = it;
  if (schema2.default !== void 0 && opts2.useDefaults && opts2.strictSchema) {
    util_1$k.checkStrictMode(it, "default is ignored in the schema root");
  }
}
function updateContext(it) {
  const schId = it.schema[it.opts.schemaId];
  if (schId)
    it.baseId = resolve_1$2.resolveUrl(it.baseId, schId);
}
function checkAsyncSchema(it) {
  if (it.schema.$async && !it.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function commentKeyword({ gen, schemaEnv, schema: schema2, errSchemaPath, opts: opts2 }) {
  const msg = schema2.$comment;
  if (opts2.$comment === true) {
    gen.code(codegen_1$n._`${names_1$3.default.self}.logger.log(${msg})`);
  } else if (typeof opts2.$comment == "function") {
    const schemaPath = codegen_1$n.str`${errSchemaPath}/$comment`;
    const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
    gen.code(codegen_1$n._`${names_1$3.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
  }
}
function returnResults(it) {
  const { gen, schemaEnv, validateName, ValidationError: ValidationError2, opts: opts2 } = it;
  if (schemaEnv.$async) {
    gen.if(codegen_1$n._`${names_1$3.default.errors} === 0`, () => gen.return(names_1$3.default.data), () => gen.throw(codegen_1$n._`new ${ValidationError2}(${names_1$3.default.vErrors})`));
  } else {
    gen.assign(codegen_1$n._`${validateName}.errors`, names_1$3.default.vErrors);
    if (opts2.unevaluated)
      assignEvaluated(it);
    gen.return(codegen_1$n._`${names_1$3.default.errors} === 0`);
  }
}
function assignEvaluated({ gen, evaluated, props, items: items2 }) {
  if (props instanceof codegen_1$n.Name)
    gen.assign(codegen_1$n._`${evaluated}.props`, props);
  if (items2 instanceof codegen_1$n.Name)
    gen.assign(codegen_1$n._`${evaluated}.items`, items2);
}
function schemaKeywords(it, types2, typeErrors, errsCount) {
  const { gen, schema: schema2, data, allErrors, opts: opts2, self: self2 } = it;
  const { RULES } = self2;
  if (schema2.$ref && (opts2.ignoreKeywordsWithRef || !util_1$k.schemaHasRulesButRef(schema2, RULES))) {
    gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
    return;
  }
  if (!opts2.jtd)
    checkStrictTypes(it, types2);
  gen.block(() => {
    for (const group of RULES.rules)
      groupKeywords(group);
    groupKeywords(RULES.post);
  });
  function groupKeywords(group) {
    if (!applicability_1.shouldUseGroup(schema2, group))
      return;
    if (group.type) {
      gen.if(dataType_2.checkDataType(group.type, data, opts2.strictNumbers));
      iterateKeywords(it, group);
      if (types2.length === 1 && types2[0] === group.type && typeErrors) {
        gen.else();
        dataType_2.reportTypeError(it);
      }
      gen.endIf();
    } else {
      iterateKeywords(it, group);
    }
    if (!allErrors)
      gen.if(codegen_1$n._`${names_1$3.default.errors} === ${errsCount || 0}`);
  }
}
function iterateKeywords(it, group) {
  const { gen, schema: schema2, opts: { useDefaults } } = it;
  if (useDefaults)
    defaults_1.assignDefaults(it, group.type);
  gen.block(() => {
    for (const rule of group.rules) {
      if (applicability_1.shouldUseRule(schema2, rule)) {
        keywordCode(it, rule.keyword, rule.definition, group.type);
      }
    }
  });
}
function checkStrictTypes(it, types2) {
  if (it.schemaEnv.meta || !it.opts.strictTypes)
    return;
  checkContextTypes(it, types2);
  if (!it.opts.allowUnionTypes)
    checkMultipleTypes(it, types2);
  checkKeywordTypes(it, it.dataTypes);
}
function checkContextTypes(it, types2) {
  if (!types2.length)
    return;
  if (!it.dataTypes.length) {
    it.dataTypes = types2;
    return;
  }
  types2.forEach((t2) => {
    if (!includesType(it.dataTypes, t2)) {
      strictTypesError(it, `type "${t2}" not allowed by context "${it.dataTypes.join(",")}"`);
    }
  });
  it.dataTypes = it.dataTypes.filter((t2) => includesType(types2, t2));
}
function checkMultipleTypes(it, ts) {
  if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
    strictTypesError(it, "use allowUnionTypes to allow union type keyword");
  }
}
function checkKeywordTypes(it, ts) {
  const rules2 = it.self.RULES.all;
  for (const keyword2 in rules2) {
    const rule = rules2[keyword2];
    if (typeof rule == "object" && applicability_1.shouldUseRule(it.schema, rule)) {
      const { type: type2 } = rule.definition;
      if (type2.length && !type2.some((t2) => hasApplicableType(ts, t2))) {
        strictTypesError(it, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
      }
    }
  }
}
function hasApplicableType(schTs, kwdT) {
  return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
}
function includesType(ts, t2) {
  return ts.includes(t2) || t2 === "integer" && ts.includes("number");
}
function strictTypesError(it, msg) {
  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
  msg += ` at "${schemaPath}" (strictTypes)`;
  util_1$k.checkStrictMode(it, msg, it.opts.strictTypes);
}
class KeywordCxt {
  constructor(it, def2, keyword2) {
    keyword_1.validateKeywordUsage(it, def2, keyword2);
    this.gen = it.gen;
    this.allErrors = it.allErrors;
    this.keyword = keyword2;
    this.data = it.data;
    this.schema = it.schema[keyword2];
    this.$data = def2.$data && it.opts.$data && this.schema && this.schema.$data;
    this.schemaValue = util_1$k.schemaRefOrVal(it, this.schema, keyword2, this.$data);
    this.schemaType = def2.schemaType;
    this.parentSchema = it.schema;
    this.params = {};
    this.it = it;
    this.def = def2;
    if (this.$data) {
      this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
    } else {
      this.schemaCode = this.schemaValue;
      if (!keyword_1.validSchemaType(this.schema, def2.schemaType, def2.allowUndefined)) {
        throw new Error(`${keyword2} value must be ${JSON.stringify(def2.schemaType)}`);
      }
    }
    if ("code" in def2 ? def2.trackErrors : def2.errors !== false) {
      this.errsCount = it.gen.const("_errs", names_1$3.default.errors);
    }
  }
  result(condition, successAction, failAction) {
    this.failResult(codegen_1$n.not(condition), successAction, failAction);
  }
  failResult(condition, successAction, failAction) {
    this.gen.if(condition);
    if (failAction)
      failAction();
    else
      this.error();
    if (successAction) {
      this.gen.else();
      successAction();
      if (this.allErrors)
        this.gen.endIf();
    } else {
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
  }
  pass(condition, failAction) {
    this.failResult(codegen_1$n.not(condition), void 0, failAction);
  }
  fail(condition) {
    if (condition === void 0) {
      this.error();
      if (!this.allErrors)
        this.gen.if(false);
      return;
    }
    this.gen.if(condition);
    this.error();
    if (this.allErrors)
      this.gen.endIf();
    else
      this.gen.else();
  }
  fail$data(condition) {
    if (!this.$data)
      return this.fail(condition);
    const { schemaCode } = this;
    this.fail(codegen_1$n._`${schemaCode} !== undefined && (${codegen_1$n.or(this.invalid$data(), condition)})`);
  }
  error(append, errorParams, errorPaths) {
    if (errorParams) {
      this.setParams(errorParams);
      this._error(append, errorPaths);
      this.setParams({});
      return;
    }
    this._error(append, errorPaths);
  }
  _error(append, errorPaths) {
    (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
  }
  $dataError() {
    errors_1.reportError(this, this.def.$dataError || errors_1.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    errors_1.resetErrorsCount(this.gen, this.errsCount);
  }
  ok(cond) {
    if (!this.allErrors)
      this.gen.if(cond);
  }
  setParams(obj, assign) {
    if (assign)
      Object.assign(this.params, obj);
    else
      this.params = obj;
  }
  block$data(valid2, codeBlock, $dataValid = codegen_1$n.nil) {
    this.gen.block(() => {
      this.check$data(valid2, $dataValid);
      codeBlock();
    });
  }
  check$data(valid2 = codegen_1$n.nil, $dataValid = codegen_1$n.nil) {
    if (!this.$data)
      return;
    const { gen, schemaCode, schemaType, def: def2 } = this;
    gen.if(codegen_1$n.or(codegen_1$n._`${schemaCode} === undefined`, $dataValid));
    if (valid2 !== codegen_1$n.nil)
      gen.assign(valid2, true);
    if (schemaType.length || def2.validateSchema) {
      gen.elseIf(this.invalid$data());
      this.$dataError();
      if (valid2 !== codegen_1$n.nil)
        gen.assign(valid2, false);
    }
    gen.else();
  }
  invalid$data() {
    const { gen, schemaCode, schemaType, def: def2, it } = this;
    return codegen_1$n.or(wrong$DataType(), invalid$DataSchema());
    function wrong$DataType() {
      if (schemaType.length) {
        if (!(schemaCode instanceof codegen_1$n.Name))
          throw new Error("ajv implementation error");
        const st = Array.isArray(schemaType) ? schemaType : [schemaType];
        return codegen_1$n._`${dataType_2.checkDataTypes(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
      }
      return codegen_1$n.nil;
    }
    function invalid$DataSchema() {
      if (def2.validateSchema) {
        const validateSchemaRef = gen.scopeValue("validate$data", { ref: def2.validateSchema });
        return codegen_1$n._`!${validateSchemaRef}(${schemaCode})`;
      }
      return codegen_1$n.nil;
    }
  }
  subschema(appl, valid2) {
    const subschema2 = subschema_1.getSubschema(this.it, appl);
    subschema_1.extendSubschemaData(subschema2, this.it, appl);
    subschema_1.extendSubschemaMode(subschema2, appl);
    const nextContext = __spreadProps(__spreadValues(__spreadValues({}, this.it), subschema2), { items: void 0, props: void 0 });
    subschemaCode(nextContext, valid2);
    return nextContext;
  }
  mergeEvaluated(schemaCxt, toName) {
    const { it, gen } = this;
    if (!it.opts.unevaluated)
      return;
    if (it.props !== true && schemaCxt.props !== void 0) {
      it.props = util_1$k.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
    }
    if (it.items !== true && schemaCxt.items !== void 0) {
      it.items = util_1$k.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
    }
  }
  mergeValidEvaluated(schemaCxt, valid2) {
    const { it, gen } = this;
    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
      gen.if(valid2, () => this.mergeEvaluated(schemaCxt, codegen_1$n.Name));
      return true;
    }
  }
}
validate.KeywordCxt = KeywordCxt;
function keywordCode(it, keyword2, def2, ruleType) {
  const cxt = new KeywordCxt(it, def2, keyword2);
  if ("code" in def2) {
    def2.code(cxt, ruleType);
  } else if (cxt.$data && def2.validate) {
    keyword_1.funcKeywordCode(cxt, def2);
  } else if ("macro" in def2) {
    keyword_1.macroKeywordCode(cxt, def2);
  } else if (def2.compile || def2.validate) {
    keyword_1.funcKeywordCode(cxt, def2);
  }
}
const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, { dataLevel, dataNames, dataPathArr }) {
  let jsonPointer;
  let data;
  if ($data === "")
    return names_1$3.default.rootData;
  if ($data[0] === "/") {
    if (!JSON_POINTER.test($data))
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    jsonPointer = $data;
    data = names_1$3.default.rootData;
  } else {
    const matches = RELATIVE_JSON_POINTER.exec($data);
    if (!matches)
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    const up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer === "#") {
      if (up >= dataLevel)
        throw new Error(errorMsg("property/index", up));
      return dataPathArr[dataLevel - up];
    }
    if (up > dataLevel)
      throw new Error(errorMsg("data", up));
    data = dataNames[dataLevel - up];
    if (!jsonPointer)
      return data;
  }
  let expr = data;
  const segments = jsonPointer.split("/");
  for (const segment of segments) {
    if (segment) {
      data = codegen_1$n._`${data}${codegen_1$n.getProperty(util_1$k.unescapeJsonPointer(segment))}`;
      expr = codegen_1$n._`${expr} && ${data}`;
    }
  }
  return expr;
  function errorMsg(pointerType, up) {
    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
  }
}
validate.getData = getData;
var validation_error = {};
Object.defineProperty(validation_error, "__esModule", { value: true });
class ValidationError extends Error {
  constructor(errors2) {
    super("validation failed");
    this.errors = errors2;
    this.ajv = this.validation = true;
  }
}
validation_error.default = ValidationError;
var ref_error = {};
Object.defineProperty(ref_error, "__esModule", { value: true });
const resolve_1$1 = resolve$1;
class MissingRefError extends Error {
  constructor(baseId, ref2, msg) {
    super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
    this.missingRef = resolve_1$1.resolveUrl(baseId, ref2);
    this.missingSchema = resolve_1$1.normalizeId(resolve_1$1.getFullPath(this.missingRef));
  }
}
ref_error.default = MissingRefError;
var compile = {};
Object.defineProperty(compile, "__esModule", { value: true });
compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
const codegen_1$m = codegen;
const validation_error_1 = validation_error;
const names_1$2 = names$1;
const resolve_1 = resolve$1;
const util_1$j = util;
const validate_1$1 = validate;
const URI = uri_all.exports;
class SchemaEnv {
  constructor(env2) {
    var _a;
    this.refs = {};
    this.dynamicAnchors = {};
    let schema2;
    if (typeof env2.schema == "object")
      schema2 = env2.schema;
    this.schema = env2.schema;
    this.schemaId = env2.schemaId;
    this.root = env2.root || this;
    this.baseId = (_a = env2.baseId) !== null && _a !== void 0 ? _a : resolve_1.normalizeId(schema2 === null || schema2 === void 0 ? void 0 : schema2[env2.schemaId || "$id"]);
    this.schemaPath = env2.schemaPath;
    this.localRefs = env2.localRefs;
    this.meta = env2.meta;
    this.$async = schema2 === null || schema2 === void 0 ? void 0 : schema2.$async;
    this.refs = {};
  }
}
compile.SchemaEnv = SchemaEnv;
function compileSchema(sch) {
  const _sch = getCompilingSchema.call(this, sch);
  if (_sch)
    return _sch;
  const rootId = resolve_1.getFullPath(sch.root.baseId);
  const { es5, lines } = this.opts.code;
  const { ownProperties } = this.opts;
  const gen = new codegen_1$m.CodeGen(this.scope, { es5, lines, ownProperties });
  let _ValidationError;
  if (sch.$async) {
    _ValidationError = gen.scopeValue("Error", {
      ref: validation_error_1.default,
      code: codegen_1$m._`require("ajv/dist/runtime/validation_error").default`
    });
  }
  const validateName = gen.scopeName("validate");
  sch.validateName = validateName;
  const schemaCxt = {
    gen,
    allErrors: this.opts.allErrors,
    data: names_1$2.default.data,
    parentData: names_1$2.default.parentData,
    parentDataProperty: names_1$2.default.parentDataProperty,
    dataNames: [names_1$2.default.data],
    dataPathArr: [codegen_1$m.nil],
    dataLevel: 0,
    dataTypes: [],
    definedProperties: new Set(),
    topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: codegen_1$m.stringify(sch.schema) } : { ref: sch.schema }),
    validateName,
    ValidationError: _ValidationError,
    schema: sch.schema,
    schemaEnv: sch,
    rootId,
    baseId: sch.baseId || rootId,
    schemaPath: codegen_1$m.nil,
    errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: codegen_1$m._`""`,
    opts: this.opts,
    self: this
  };
  let sourceCode;
  try {
    this._compilations.add(sch);
    validate_1$1.validateFunctionCode(schemaCxt);
    gen.optimize(this.opts.code.optimize);
    const validateCode = gen.toString();
    sourceCode = `${gen.scopeRefs(names_1$2.default.scope)}return ${validateCode}`;
    if (this.opts.code.process)
      sourceCode = this.opts.code.process(sourceCode, sch);
    const makeValidate = new Function(`${names_1$2.default.self}`, `${names_1$2.default.scope}`, sourceCode);
    const validate2 = makeValidate(this, this.scope.get());
    this.scope.value(validateName, { ref: validate2 });
    validate2.errors = null;
    validate2.schema = sch.schema;
    validate2.schemaEnv = sch;
    if (sch.$async)
      validate2.$async = true;
    if (this.opts.code.source === true) {
      validate2.source = { validateName, validateCode, scopeValues: gen._values };
    }
    if (this.opts.unevaluated) {
      const { props, items: items2 } = schemaCxt;
      validate2.evaluated = {
        props: props instanceof codegen_1$m.Name ? void 0 : props,
        items: items2 instanceof codegen_1$m.Name ? void 0 : items2,
        dynamicProps: props instanceof codegen_1$m.Name,
        dynamicItems: items2 instanceof codegen_1$m.Name
      };
      if (validate2.source)
        validate2.source.evaluated = codegen_1$m.stringify(validate2.evaluated);
    }
    sch.validate = validate2;
    return sch;
  } catch (e) {
    delete sch.validate;
    delete sch.validateName;
    if (sourceCode)
      this.logger.error("Error compiling schema, function code:", sourceCode);
    throw e;
  } finally {
    this._compilations.delete(sch);
  }
}
compile.compileSchema = compileSchema;
function resolveRef(root2, baseId, ref2) {
  var _a;
  ref2 = resolve_1.resolveUrl(baseId, ref2);
  const schOrFunc = root2.refs[ref2];
  if (schOrFunc)
    return schOrFunc;
  let _sch = resolve.call(this, root2, ref2);
  if (_sch === void 0) {
    const schema2 = (_a = root2.localRefs) === null || _a === void 0 ? void 0 : _a[ref2];
    const { schemaId } = this.opts;
    if (schema2)
      _sch = new SchemaEnv({ schema: schema2, schemaId, root: root2, baseId });
  }
  if (_sch === void 0)
    return;
  return root2.refs[ref2] = inlineOrCompile.call(this, _sch);
}
compile.resolveRef = resolveRef;
function inlineOrCompile(sch) {
  if (resolve_1.inlineRef(sch.schema, this.opts.inlineRefs))
    return sch.schema;
  return sch.validate ? sch : compileSchema.call(this, sch);
}
function getCompilingSchema(schEnv) {
  for (const sch of this._compilations) {
    if (sameSchemaEnv(sch, schEnv))
      return sch;
  }
}
compile.getCompilingSchema = getCompilingSchema;
function sameSchemaEnv(s1, s2) {
  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
}
function resolve(root2, ref2) {
  let sch;
  while (typeof (sch = this.refs[ref2]) == "string")
    ref2 = sch;
  return sch || this.schemas[ref2] || resolveSchema.call(this, root2, ref2);
}
function resolveSchema(root2, ref2) {
  const p = URI.parse(ref2);
  const refPath = resolve_1._getFullPath(p);
  let baseId = resolve_1.getFullPath(root2.baseId);
  if (Object.keys(root2.schema).length > 0 && refPath === baseId) {
    return getJsonPointer.call(this, p, root2);
  }
  const id2 = resolve_1.normalizeId(refPath);
  const schOrRef = this.refs[id2] || this.schemas[id2];
  if (typeof schOrRef == "string") {
    const sch = resolveSchema.call(this, root2, schOrRef);
    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
      return;
    return getJsonPointer.call(this, p, sch);
  }
  if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
    return;
  if (!schOrRef.validate)
    compileSchema.call(this, schOrRef);
  if (id2 === resolve_1.normalizeId(ref2)) {
    const { schema: schema2 } = schOrRef;
    const { schemaId } = this.opts;
    const schId = schema2[schemaId];
    if (schId)
      baseId = resolve_1.resolveUrl(baseId, schId);
    return new SchemaEnv({ schema: schema2, schemaId, root: root2, baseId });
  }
  return getJsonPointer.call(this, p, schOrRef);
}
compile.resolveSchema = resolveSchema;
const PREVENT_SCOPE_CHANGE = new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function getJsonPointer(parsedRef, { baseId, schema: schema2, root: root2 }) {
  var _a;
  if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
    return;
  for (const part of parsedRef.fragment.slice(1).split("/")) {
    if (typeof schema2 == "boolean")
      return;
    schema2 = schema2[util_1$j.unescapeFragment(part)];
    if (schema2 === void 0)
      return;
    const schId = typeof schema2 == "object" && schema2[this.opts.schemaId];
    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
      baseId = resolve_1.resolveUrl(baseId, schId);
    }
  }
  let env2;
  if (typeof schema2 != "boolean" && schema2.$ref && !util_1$j.schemaHasRulesButRef(schema2, this.RULES)) {
    const $ref = resolve_1.resolveUrl(baseId, schema2.$ref);
    env2 = resolveSchema.call(this, root2, $ref);
  }
  const { schemaId } = this.opts;
  env2 = env2 || new SchemaEnv({ schema: schema2, schemaId, root: root2, baseId });
  if (env2.schema !== env2.root.schema)
    return env2;
  return void 0;
}
const $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
const type$1 = "object";
const required$1 = [
  "$data"
];
const properties$2 = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
};
const additionalProperties$1 = false;
var require$$9 = {
  $id: $id$1,
  description,
  type: type$1,
  required: required$1,
  properties: properties$2,
  additionalProperties: additionalProperties$1
};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
  var validate_12 = validate;
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  const validation_error_12 = validation_error;
  const ref_error_12 = ref_error;
  const rules_1 = rules;
  const compile_12 = compile;
  const codegen_2 = codegen;
  const resolve_12 = resolve$1;
  const dataType_12 = dataType;
  const util_12 = util;
  const $dataRefSchema = require$$9;
  const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
  const EXT_SCOPE_NAMES = new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]);
  const removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  };
  const deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  };
  const MAX_EXPRESSION = 200;
  function requiredOptions(o) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
    const s2 = o.strict;
    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
    const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
    return {
      strictSchema: (_c = (_b = o.strictSchema) !== null && _b !== void 0 ? _b : s2) !== null && _c !== void 0 ? _c : true,
      strictNumbers: (_e = (_d = o.strictNumbers) !== null && _d !== void 0 ? _d : s2) !== null && _e !== void 0 ? _e : true,
      strictTypes: (_g = (_f = o.strictTypes) !== null && _f !== void 0 ? _f : s2) !== null && _g !== void 0 ? _g : "log",
      strictTuples: (_j = (_h = o.strictTuples) !== null && _h !== void 0 ? _h : s2) !== null && _j !== void 0 ? _j : "log",
      strictRequired: (_l = (_k = o.strictRequired) !== null && _k !== void 0 ? _k : s2) !== null && _l !== void 0 ? _l : false,
      code: o.code ? __spreadProps(__spreadValues({}, o.code), { optimize }) : { optimize },
      loopRequired: (_m = o.loopRequired) !== null && _m !== void 0 ? _m : MAX_EXPRESSION,
      loopEnum: (_o = o.loopEnum) !== null && _o !== void 0 ? _o : MAX_EXPRESSION,
      meta: (_p = o.meta) !== null && _p !== void 0 ? _p : true,
      messages: (_q = o.messages) !== null && _q !== void 0 ? _q : true,
      inlineRefs: (_r = o.inlineRefs) !== null && _r !== void 0 ? _r : true,
      schemaId: (_s = o.schemaId) !== null && _s !== void 0 ? _s : "$id",
      addUsedSchema: (_t = o.addUsedSchema) !== null && _t !== void 0 ? _t : true,
      validateSchema: (_u = o.validateSchema) !== null && _u !== void 0 ? _u : true,
      validateFormats: (_v = o.validateFormats) !== null && _v !== void 0 ? _v : true,
      unicodeRegExp: (_w = o.unicodeRegExp) !== null && _w !== void 0 ? _w : true,
      int32range: (_x = o.int32range) !== null && _x !== void 0 ? _x : true
    };
  }
  class Ajv {
    constructor(opts2 = {}) {
      this.schemas = {};
      this.refs = {};
      this.formats = {};
      this._compilations = new Set();
      this._loading = {};
      this._cache = new Map();
      opts2 = this.opts = __spreadValues(__spreadValues({}, opts2), requiredOptions(opts2));
      const { es5, lines } = this.opts.code;
      this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
      this.logger = getLogger(opts2.logger);
      const formatOpt = opts2.validateFormats;
      opts2.validateFormats = false;
      this.RULES = rules_1.getRules();
      checkOptions.call(this, removedOptions, opts2, "NOT SUPPORTED");
      checkOptions.call(this, deprecatedOptions, opts2, "DEPRECATED", "warn");
      this._metaOpts = getMetaSchemaOptions.call(this);
      if (opts2.formats)
        addInitialFormats.call(this);
      this._addVocabularies();
      this._addDefaultMetaSchema();
      if (opts2.keywords)
        addInitialKeywords.call(this, opts2.keywords);
      if (typeof opts2.meta == "object")
        this.addMetaSchema(opts2.meta);
      addInitialSchemas.call(this);
      opts2.validateFormats = formatOpt;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data, meta, schemaId } = this.opts;
      let _dataRefSchema = $dataRefSchema;
      if (schemaId === "id") {
        _dataRefSchema = __spreadValues({}, $dataRefSchema);
        _dataRefSchema.id = _dataRefSchema.$id;
        delete _dataRefSchema.$id;
      }
      if (meta && $data)
        this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
      const { meta, schemaId } = this.opts;
      return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
    }
    validate(schemaKeyRef, data) {
      let v;
      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v)
          throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
      } else {
        v = this.compile(schemaKeyRef);
      }
      const valid2 = v(data);
      if (!("$async" in v))
        this.errors = v.errors;
      return valid2;
    }
    compile(schema2, _meta) {
      const sch = this._addSchema(schema2, _meta);
      return sch.validate || this._compileSchemaEnv(sch);
    }
    compileAsync(schema2, meta) {
      if (typeof this.opts.loadSchema != "function") {
        throw new Error("options.loadSchema should be a function");
      }
      const { loadSchema } = this.opts;
      return runCompileAsync.call(this, schema2, meta);
      async function runCompileAsync(_schema, _meta) {
        await loadMetaSchema.call(this, _schema.$schema);
        const sch = this._addSchema(_schema, _meta);
        return sch.validate || _compileAsync.call(this, sch);
      }
      async function loadMetaSchema($ref) {
        if ($ref && !this.getSchema($ref)) {
          await runCompileAsync.call(this, { $ref }, true);
        }
      }
      async function _compileAsync(sch) {
        try {
          return this._compileSchemaEnv(sch);
        } catch (e) {
          if (!(e instanceof ref_error_12.default))
            throw e;
          checkLoaded.call(this, e);
          await loadMissingSchema.call(this, e.missingSchema);
          return _compileAsync.call(this, sch);
        }
      }
      function checkLoaded({ missingSchema: ref2, missingRef }) {
        if (this.refs[ref2]) {
          throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
        }
      }
      async function loadMissingSchema(ref2) {
        const _schema = await _loadSchema.call(this, ref2);
        if (!this.refs[ref2])
          await loadMetaSchema.call(this, _schema.$schema);
        if (!this.refs[ref2])
          this.addSchema(_schema, ref2, meta);
      }
      async function _loadSchema(ref2) {
        const p = this._loading[ref2];
        if (p)
          return p;
        try {
          return await (this._loading[ref2] = loadSchema(ref2));
        } finally {
          delete this._loading[ref2];
        }
      }
    }
    addSchema(schema2, key, _meta, _validateSchema = this.opts.validateSchema) {
      if (Array.isArray(schema2)) {
        for (const sch of schema2)
          this.addSchema(sch, void 0, _meta, _validateSchema);
        return this;
      }
      let id2;
      if (typeof schema2 === "object") {
        const { schemaId } = this.opts;
        id2 = schema2[schemaId];
        if (id2 !== void 0 && typeof id2 != "string") {
          throw new Error(`schema ${schemaId} must be string`);
        }
      }
      key = resolve_12.normalizeId(key || id2);
      this._checkUnique(key);
      this.schemas[key] = this._addSchema(schema2, _meta, key, _validateSchema, true);
      return this;
    }
    addMetaSchema(schema2, key, _validateSchema = this.opts.validateSchema) {
      this.addSchema(schema2, key, true, _validateSchema);
      return this;
    }
    validateSchema(schema2, throwOrLogError) {
      if (typeof schema2 == "boolean")
        return true;
      let $schema2;
      $schema2 = schema2.$schema;
      if ($schema2 !== void 0 && typeof $schema2 != "string") {
        throw new Error("$schema must be a string");
      }
      $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
      if (!$schema2) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      const valid2 = this.validate($schema2, schema2);
      if (!valid2 && throwOrLogError) {
        const message = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid2;
    }
    getSchema(keyRef) {
      let sch;
      while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
        keyRef = sch;
      if (sch === void 0) {
        const { schemaId } = this.opts;
        const root2 = new compile_12.SchemaEnv({ schema: {}, schemaId });
        sch = compile_12.resolveSchema.call(this, root2, keyRef);
        if (!sch)
          return;
        this.refs[keyRef] = sch;
      }
      return sch.validate || this._compileSchemaEnv(sch);
    }
    removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        this._removeAllSchemas(this.schemas, schemaKeyRef);
        this._removeAllSchemas(this.refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          this._removeAllSchemas(this.schemas);
          this._removeAllSchemas(this.refs);
          this._cache.clear();
          return this;
        case "string": {
          const sch = getSchEnv.call(this, schemaKeyRef);
          if (typeof sch == "object")
            this._cache.delete(sch.schema);
          delete this.schemas[schemaKeyRef];
          delete this.refs[schemaKeyRef];
          return this;
        }
        case "object": {
          const cacheKey = schemaKeyRef;
          this._cache.delete(cacheKey);
          let id2 = schemaKeyRef[this.opts.schemaId];
          if (id2) {
            id2 = resolve_12.normalizeId(id2);
            delete this.schemas[id2];
            delete this.refs[id2];
          }
          return this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    addVocabulary(definitions2) {
      for (const def2 of definitions2)
        this.addKeyword(def2);
      return this;
    }
    addKeyword(kwdOrDef, def2) {
      let keyword2;
      if (typeof kwdOrDef == "string") {
        keyword2 = kwdOrDef;
        if (typeof def2 == "object") {
          this.logger.warn("these parameters are deprecated, see docs for addKeyword");
          def2.keyword = keyword2;
        }
      } else if (typeof kwdOrDef == "object" && def2 === void 0) {
        def2 = kwdOrDef;
        keyword2 = def2.keyword;
        if (Array.isArray(keyword2) && !keyword2.length) {
          throw new Error("addKeywords: keyword must be string or non-empty array");
        }
      } else {
        throw new Error("invalid addKeywords parameters");
      }
      checkKeyword.call(this, keyword2, def2);
      if (!def2) {
        util_12.eachItem(keyword2, (kwd) => addRule.call(this, kwd));
        return this;
      }
      keywordMetaschema.call(this, def2);
      const definition = __spreadProps(__spreadValues({}, def2), {
        type: dataType_12.getJSONTypes(def2.type),
        schemaType: dataType_12.getJSONTypes(def2.schemaType)
      });
      util_12.eachItem(keyword2, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t2) => addRule.call(this, k, definition, t2)));
      return this;
    }
    getKeyword(keyword2) {
      const rule = this.RULES.all[keyword2];
      return typeof rule == "object" ? rule.definition : !!rule;
    }
    removeKeyword(keyword2) {
      const { RULES } = this;
      delete RULES.keywords[keyword2];
      delete RULES.all[keyword2];
      for (const group of RULES.rules) {
        const i2 = group.rules.findIndex((rule) => rule.keyword === keyword2);
        if (i2 >= 0)
          group.rules.splice(i2, 1);
      }
      return this;
    }
    addFormat(name, format2) {
      if (typeof format2 == "string")
        format2 = new RegExp(format2);
      this.formats[name] = format2;
      return this;
    }
    errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
      if (!errors2 || errors2.length === 0)
        return "No errors";
      return errors2.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
      const rules2 = this.RULES.all;
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      for (const jsonPointer of keywordsJsonPointers) {
        const segments = jsonPointer.split("/").slice(1);
        let keywords = metaSchema;
        for (const seg of segments)
          keywords = keywords[seg];
        for (const key in rules2) {
          const rule = rules2[key];
          if (typeof rule != "object")
            continue;
          const { $data } = rule.definition;
          const schema2 = keywords[key];
          if ($data && schema2)
            keywords[key] = schemaOrData(schema2);
        }
      }
      return metaSchema;
    }
    _removeAllSchemas(schemas, regex) {
      for (const keyRef in schemas) {
        const sch = schemas[keyRef];
        if (!regex || regex.test(keyRef)) {
          if (typeof sch == "string") {
            delete schemas[keyRef];
          } else if (sch && !sch.meta) {
            this._cache.delete(sch.schema);
            delete schemas[keyRef];
          }
        }
      }
    }
    _addSchema(schema2, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
      let id2;
      const { schemaId } = this.opts;
      if (typeof schema2 == "object") {
        id2 = schema2[schemaId];
      } else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        else if (typeof schema2 != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let sch = this._cache.get(schema2);
      if (sch !== void 0)
        return sch;
      const localRefs = resolve_12.getSchemaRefs.call(this, schema2);
      baseId = resolve_12.normalizeId(id2 || baseId);
      sch = new compile_12.SchemaEnv({ schema: schema2, schemaId, meta, baseId, localRefs });
      this._cache.set(sch.schema, sch);
      if (addSchema && !baseId.startsWith("#")) {
        if (baseId)
          this._checkUnique(baseId);
        this.refs[baseId] = sch;
      }
      if (validateSchema)
        this.validateSchema(schema2, true);
      return sch;
    }
    _checkUnique(id2) {
      if (this.schemas[id2] || this.refs[id2]) {
        throw new Error(`schema with key or id "${id2}" already exists`);
      }
    }
    _compileSchemaEnv(sch) {
      if (sch.meta)
        this._compileMetaSchema(sch);
      else
        compile_12.compileSchema.call(this, sch);
      if (!sch.validate)
        throw new Error("ajv implementation error");
      return sch.validate;
    }
    _compileMetaSchema(sch) {
      const currentOpts = this.opts;
      this.opts = this._metaOpts;
      try {
        compile_12.compileSchema.call(this, sch);
      } finally {
        this.opts = currentOpts;
      }
    }
  }
  exports.default = Ajv;
  Ajv.ValidationError = validation_error_12.default;
  Ajv.MissingRefError = ref_error_12.default;
  function checkOptions(checkOpts, options, msg, log = "error") {
    for (const key in checkOpts) {
      const opt = key;
      if (opt in options)
        this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
    }
  }
  function getSchEnv(keyRef) {
    keyRef = resolve_12.normalizeId(keyRef);
    return this.schemas[keyRef] || this.refs[keyRef];
  }
  function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
      return;
    if (Array.isArray(optsSchemas))
      this.addSchema(optsSchemas);
    else
      for (const key in optsSchemas)
        this.addSchema(optsSchemas[key], key);
  }
  function addInitialFormats() {
    for (const name in this.opts.formats) {
      const format2 = this.opts.formats[name];
      if (format2)
        this.addFormat(name, format2);
    }
  }
  function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
      this.addVocabulary(defs);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword2 in defs) {
      const def2 = defs[keyword2];
      if (!def2.keyword)
        def2.keyword = keyword2;
      this.addKeyword(def2);
    }
  }
  function getMetaSchemaOptions() {
    const metaOpts = __spreadValues({}, this.opts);
    for (const opt of META_IGNORE_OPTIONS)
      delete metaOpts[opt];
    return metaOpts;
  }
  const noLogs = { log() {
  }, warn() {
  }, error() {
  } };
  function getLogger(logger) {
    if (logger === false)
      return noLogs;
    if (logger === void 0)
      return console;
    if (logger.log && logger.warn && logger.error)
      return logger;
    throw new Error("logger must implement log, warn and error methods");
  }
  const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
  function checkKeyword(keyword2, def2) {
    const { RULES } = this;
    util_12.eachItem(keyword2, (kwd) => {
      if (RULES.keywords[kwd])
        throw new Error(`Keyword ${kwd} is already defined`);
      if (!KEYWORD_NAME.test(kwd))
        throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def2)
      return;
    if (def2.$data && !("code" in def2 || "validate" in def2)) {
      throw new Error('$data keyword must have "code" or "validate" function');
    }
  }
  function addRule(keyword2, definition, dataType2) {
    var _a;
    const post = definition === null || definition === void 0 ? void 0 : definition.post;
    if (dataType2 && post)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t2 }) => t2 === dataType2);
    if (!ruleGroup) {
      ruleGroup = { type: dataType2, rules: [] };
      RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword2] = true;
    if (!definition)
      return;
    const rule = {
      keyword: keyword2,
      definition: __spreadProps(__spreadValues({}, definition), {
        type: dataType_12.getJSONTypes(definition.type),
        schemaType: dataType_12.getJSONTypes(definition.schemaType)
      })
    };
    if (definition.before)
      addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
      ruleGroup.rules.push(rule);
    RULES.all[keyword2] = rule;
    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
  }
  function addBeforeRule(ruleGroup, rule, before) {
    const i2 = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i2 >= 0) {
      ruleGroup.rules.splice(i2, 0, rule);
    } else {
      ruleGroup.rules.push(rule);
      this.logger.warn(`rule ${before} is not defined`);
    }
  }
  function keywordMetaschema(def2) {
    let { metaSchema } = def2;
    if (metaSchema === void 0)
      return;
    if (def2.$data && this.opts.$data)
      metaSchema = schemaOrData(metaSchema);
    def2.validateSchema = this.compile(metaSchema, true);
  }
  const $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function schemaOrData(schema2) {
    return { anyOf: [schema2, $dataRef] };
  }
})(core$2);
var draft7 = {};
var core$1 = {};
var id = {};
Object.defineProperty(id, "__esModule", { value: true });
const def$s = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
id.default = def$s;
var ref = {};
Object.defineProperty(ref, "__esModule", { value: true });
ref.callRef = ref.getValidate = void 0;
const ref_error_1 = ref_error;
const code_1$8 = code;
const codegen_1$l = codegen;
const names_1$1 = names$1;
const compile_1 = compile;
const util_1$i = util;
const def$r = {
  keyword: "$ref",
  schemaType: "string",
  code(cxt) {
    const { gen, schema: $ref, it } = cxt;
    const { baseId, schemaEnv: env2, validateName, opts: opts2, self: self2 } = it;
    const { root: root2 } = env2;
    if (($ref === "#" || $ref === "#/") && baseId === root2.baseId)
      return callRootRef();
    const schOrEnv = compile_1.resolveRef.call(self2, root2, baseId, $ref);
    if (schOrEnv === void 0)
      throw new ref_error_1.default(baseId, $ref);
    if (schOrEnv instanceof compile_1.SchemaEnv)
      return callValidate(schOrEnv);
    return inlineRefSchema(schOrEnv);
    function callRootRef() {
      if (env2 === root2)
        return callRef(cxt, validateName, env2, env2.$async);
      const rootName = gen.scopeValue("root", { ref: root2 });
      return callRef(cxt, codegen_1$l._`${rootName}.validate`, root2, root2.$async);
    }
    function callValidate(sch) {
      const v = getValidate(cxt, sch);
      callRef(cxt, v, sch, sch.$async);
    }
    function inlineRefSchema(sch) {
      const schName = gen.scopeValue("schema", opts2.code.source === true ? { ref: sch, code: codegen_1$l.stringify(sch) } : { ref: sch });
      const valid2 = gen.name("valid");
      const schCxt = cxt.subschema({
        schema: sch,
        dataTypes: [],
        schemaPath: codegen_1$l.nil,
        topSchemaRef: schName,
        errSchemaPath: $ref
      }, valid2);
      cxt.mergeEvaluated(schCxt);
      cxt.ok(valid2);
    }
  }
};
function getValidate(cxt, sch) {
  const { gen } = cxt;
  return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : codegen_1$l._`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
}
ref.getValidate = getValidate;
function callRef(cxt, v, sch, $async) {
  const { gen, it } = cxt;
  const { allErrors, schemaEnv: env2, opts: opts2 } = it;
  const passCxt = opts2.passContext ? names_1$1.default.this : codegen_1$l.nil;
  if ($async)
    callAsyncRef();
  else
    callSyncRef();
  function callAsyncRef() {
    if (!env2.$async)
      throw new Error("async schema referenced by sync schema");
    const valid2 = gen.let("valid");
    gen.try(() => {
      gen.code(codegen_1$l._`await ${code_1$8.callValidateCode(cxt, v, passCxt)}`);
      addEvaluatedFrom(v);
      if (!allErrors)
        gen.assign(valid2, true);
    }, (e) => {
      gen.if(codegen_1$l._`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
      addErrorsFrom(e);
      if (!allErrors)
        gen.assign(valid2, false);
    });
    cxt.ok(valid2);
  }
  function callSyncRef() {
    cxt.result(code_1$8.callValidateCode(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
  }
  function addErrorsFrom(source2) {
    const errs = codegen_1$l._`${source2}.errors`;
    gen.assign(names_1$1.default.vErrors, codegen_1$l._`${names_1$1.default.vErrors} === null ? ${errs} : ${names_1$1.default.vErrors}.concat(${errs})`);
    gen.assign(names_1$1.default.errors, codegen_1$l._`${names_1$1.default.vErrors}.length`);
  }
  function addEvaluatedFrom(source2) {
    var _a;
    if (!it.opts.unevaluated)
      return;
    const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
    if (it.props !== true) {
      if (schEvaluated && !schEvaluated.dynamicProps) {
        if (schEvaluated.props !== void 0) {
          it.props = util_1$i.mergeEvaluated.props(gen, schEvaluated.props, it.props);
        }
      } else {
        const props = gen.var("props", codegen_1$l._`${source2}.evaluated.props`);
        it.props = util_1$i.mergeEvaluated.props(gen, props, it.props, codegen_1$l.Name);
      }
    }
    if (it.items !== true) {
      if (schEvaluated && !schEvaluated.dynamicItems) {
        if (schEvaluated.items !== void 0) {
          it.items = util_1$i.mergeEvaluated.items(gen, schEvaluated.items, it.items);
        }
      } else {
        const items2 = gen.var("items", codegen_1$l._`${source2}.evaluated.items`);
        it.items = util_1$i.mergeEvaluated.items(gen, items2, it.items, codegen_1$l.Name);
      }
    }
  }
}
ref.callRef = callRef;
ref.default = def$r;
Object.defineProperty(core$1, "__esModule", { value: true });
const id_1 = id;
const ref_1 = ref;
const core = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  id_1.default,
  ref_1.default
];
core$1.default = core;
var validation$1 = {};
var limitNumber = {};
Object.defineProperty(limitNumber, "__esModule", { value: true });
const codegen_1$k = codegen;
const ops = codegen_1$k.operators;
const KWDs = {
  maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
  minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
  exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
  exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
};
const error$i = {
  message: ({ keyword: keyword2, schemaCode }) => codegen_1$k.str`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
  params: ({ keyword: keyword2, schemaCode }) => codegen_1$k._`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
};
const def$q = {
  keyword: Object.keys(KWDs),
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$i,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    cxt.fail$data(codegen_1$k._`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
  }
};
limitNumber.default = def$q;
var multipleOf = {};
Object.defineProperty(multipleOf, "__esModule", { value: true });
const codegen_1$j = codegen;
const error$h = {
  message: ({ schemaCode }) => codegen_1$j.str`must be multiple of ${schemaCode}`,
  params: ({ schemaCode }) => codegen_1$j._`{multipleOf: ${schemaCode}}`
};
const def$p = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$h,
  code(cxt) {
    const { gen, data, schemaCode, it } = cxt;
    const prec = it.opts.multipleOfPrecision;
    const res = gen.let("res");
    const invalid = prec ? codegen_1$j._`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : codegen_1$j._`${res} !== parseInt(${res})`;
    cxt.fail$data(codegen_1$j._`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
  }
};
multipleOf.default = def$p;
var limitLength = {};
var ucs2length$1 = {};
Object.defineProperty(ucs2length$1, "__esModule", { value: true });
function ucs2length(str2) {
  const len = str2.length;
  let length = 0;
  let pos = 0;
  let value;
  while (pos < len) {
    length++;
    value = str2.charCodeAt(pos++);
    if (value >= 55296 && value <= 56319 && pos < len) {
      value = str2.charCodeAt(pos);
      if ((value & 64512) === 56320)
        pos++;
    }
  }
  return length;
}
ucs2length$1.default = ucs2length;
ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(limitLength, "__esModule", { value: true });
const codegen_1$i = codegen;
const util_1$h = util;
const ucs2length_1 = ucs2length$1;
const error$g = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxLength" ? "more" : "fewer";
    return codegen_1$i.str`must NOT have ${comp} than ${schemaCode} characters`;
  },
  params: ({ schemaCode }) => codegen_1$i._`{limit: ${schemaCode}}`
};
const def$o = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: true,
  error: error$g,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode, it } = cxt;
    const op = keyword2 === "maxLength" ? codegen_1$i.operators.GT : codegen_1$i.operators.LT;
    const len = it.opts.unicode === false ? codegen_1$i._`${data}.length` : codegen_1$i._`${util_1$h.useFunc(cxt.gen, ucs2length_1.default)}(${data})`;
    cxt.fail$data(codegen_1$i._`${len} ${op} ${schemaCode}`);
  }
};
limitLength.default = def$o;
var pattern = {};
Object.defineProperty(pattern, "__esModule", { value: true });
const code_1$7 = code;
const codegen_1$h = codegen;
const error$f = {
  message: ({ schemaCode }) => codegen_1$h.str`must match pattern "${schemaCode}"`,
  params: ({ schemaCode }) => codegen_1$h._`{pattern: ${schemaCode}}`
};
const def$n = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: true,
  error: error$f,
  code(cxt) {
    const { data, $data, schema: schema2, schemaCode, it } = cxt;
    const u2 = it.opts.unicodeRegExp ? "u" : "";
    const regExp = $data ? codegen_1$h._`(new RegExp(${schemaCode}, ${u2}))` : code_1$7.usePattern(cxt, schema2);
    cxt.fail$data(codegen_1$h._`!${regExp}.test(${data})`);
  }
};
pattern.default = def$n;
var limitProperties = {};
Object.defineProperty(limitProperties, "__esModule", { value: true });
const codegen_1$g = codegen;
const error$e = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxProperties" ? "more" : "fewer";
    return codegen_1$g.str`must NOT have ${comp} than ${schemaCode} items`;
  },
  params: ({ schemaCode }) => codegen_1$g._`{limit: ${schemaCode}}`
};
const def$m = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: true,
  error: error$e,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxProperties" ? codegen_1$g.operators.GT : codegen_1$g.operators.LT;
    cxt.fail$data(codegen_1$g._`Object.keys(${data}).length ${op} ${schemaCode}`);
  }
};
limitProperties.default = def$m;
var required = {};
Object.defineProperty(required, "__esModule", { value: true });
const code_1$6 = code;
const codegen_1$f = codegen;
const util_1$g = util;
const error$d = {
  message: ({ params: { missingProperty } }) => codegen_1$f.str`must have required property '${missingProperty}'`,
  params: ({ params: { missingProperty } }) => codegen_1$f._`{missingProperty: ${missingProperty}}`
};
const def$l = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: true,
  error: error$d,
  code(cxt) {
    const { gen, schema: schema2, schemaCode, data, $data, it } = cxt;
    const { opts: opts2 } = it;
    if (!$data && schema2.length === 0)
      return;
    const useLoop = schema2.length >= opts2.loopRequired;
    if (it.allErrors)
      allErrorsMode();
    else
      exitOnErrorMode();
    if (opts2.strictRequired) {
      const props = cxt.parentSchema.properties;
      const { definedProperties } = cxt.it;
      for (const requiredKey of schema2) {
        if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
          const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
          util_1$g.checkStrictMode(it, msg, it.opts.strictRequired);
        }
      }
    }
    function allErrorsMode() {
      if (useLoop || $data) {
        cxt.block$data(codegen_1$f.nil, loopAllRequired);
      } else {
        for (const prop of schema2) {
          code_1$6.checkReportMissingProp(cxt, prop);
        }
      }
    }
    function exitOnErrorMode() {
      const missing = gen.let("missing");
      if (useLoop || $data) {
        const valid2 = gen.let("valid", true);
        cxt.block$data(valid2, () => loopUntilMissing(missing, valid2));
        cxt.ok(valid2);
      } else {
        gen.if(code_1$6.checkMissingProp(cxt, schema2, missing));
        code_1$6.reportMissingProp(cxt, missing);
        gen.else();
      }
    }
    function loopAllRequired() {
      gen.forOf("prop", schemaCode, (prop) => {
        cxt.setParams({ missingProperty: prop });
        gen.if(code_1$6.noPropertyInData(gen, data, prop, opts2.ownProperties), () => cxt.error());
      });
    }
    function loopUntilMissing(missing, valid2) {
      cxt.setParams({ missingProperty: missing });
      gen.forOf(missing, schemaCode, () => {
        gen.assign(valid2, code_1$6.propertyInData(gen, data, missing, opts2.ownProperties));
        gen.if(codegen_1$f.not(valid2), () => {
          cxt.error();
          gen.break();
        });
      }, codegen_1$f.nil);
    }
  }
};
required.default = def$l;
var limitItems = {};
Object.defineProperty(limitItems, "__esModule", { value: true });
const codegen_1$e = codegen;
const error$c = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxItems" ? "more" : "fewer";
    return codegen_1$e.str`must NOT have ${comp} than ${schemaCode} items`;
  },
  params: ({ schemaCode }) => codegen_1$e._`{limit: ${schemaCode}}`
};
const def$k = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: true,
  error: error$c,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxItems" ? codegen_1$e.operators.GT : codegen_1$e.operators.LT;
    cxt.fail$data(codegen_1$e._`${data}.length ${op} ${schemaCode}`);
  }
};
limitItems.default = def$k;
var uniqueItems = {};
var equal$1 = {};
Object.defineProperty(equal$1, "__esModule", { value: true });
const equal = fastDeepEqual;
equal.code = 'require("ajv/dist/runtime/equal").default';
equal$1.default = equal;
Object.defineProperty(uniqueItems, "__esModule", { value: true });
const dataType_1 = dataType;
const codegen_1$d = codegen;
const util_1$f = util;
const equal_1$2 = equal$1;
const error$b = {
  message: ({ params: { i: i2, j } }) => codegen_1$d.str`must NOT have duplicate items (items ## ${j} and ${i2} are identical)`,
  params: ({ params: { i: i2, j } }) => codegen_1$d._`{i: ${i2}, j: ${j}}`
};
const def$j = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: true,
  error: error$b,
  code(cxt) {
    const { gen, data, $data, schema: schema2, parentSchema, schemaCode, it } = cxt;
    if (!$data && !schema2)
      return;
    const valid2 = gen.let("valid");
    const itemTypes = parentSchema.items ? dataType_1.getSchemaTypes(parentSchema.items) : [];
    cxt.block$data(valid2, validateUniqueItems, codegen_1$d._`${schemaCode} === false`);
    cxt.ok(valid2);
    function validateUniqueItems() {
      const i2 = gen.let("i", codegen_1$d._`${data}.length`);
      const j = gen.let("j");
      cxt.setParams({ i: i2, j });
      gen.assign(valid2, true);
      gen.if(codegen_1$d._`${i2} > 1`, () => (canOptimize() ? loopN : loopN2)(i2, j));
    }
    function canOptimize() {
      return itemTypes.length > 0 && !itemTypes.some((t2) => t2 === "object" || t2 === "array");
    }
    function loopN(i2, j) {
      const item = gen.name("item");
      const wrongType = dataType_1.checkDataTypes(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
      const indices = gen.const("indices", codegen_1$d._`{}`);
      gen.for(codegen_1$d._`;${i2}--;`, () => {
        gen.let(item, codegen_1$d._`${data}[${i2}]`);
        gen.if(wrongType, codegen_1$d._`continue`);
        if (itemTypes.length > 1)
          gen.if(codegen_1$d._`typeof ${item} == "string"`, codegen_1$d._`${item} += "_"`);
        gen.if(codegen_1$d._`typeof ${indices}[${item}] == "number"`, () => {
          gen.assign(j, codegen_1$d._`${indices}[${item}]`);
          cxt.error();
          gen.assign(valid2, false).break();
        }).code(codegen_1$d._`${indices}[${item}] = ${i2}`);
      });
    }
    function loopN2(i2, j) {
      const eql = util_1$f.useFunc(gen, equal_1$2.default);
      const outer = gen.name("outer");
      gen.label(outer).for(codegen_1$d._`;${i2}--;`, () => gen.for(codegen_1$d._`${j} = ${i2}; ${j}--;`, () => gen.if(codegen_1$d._`${eql}(${data}[${i2}], ${data}[${j}])`, () => {
        cxt.error();
        gen.assign(valid2, false).break(outer);
      })));
    }
  }
};
uniqueItems.default = def$j;
var _const = {};
Object.defineProperty(_const, "__esModule", { value: true });
const codegen_1$c = codegen;
const util_1$e = util;
const equal_1$1 = equal$1;
const error$a = {
  message: "must be equal to constant",
  params: ({ schemaCode }) => codegen_1$c._`{allowedValue: ${schemaCode}}`
};
const def$i = {
  keyword: "const",
  $data: true,
  error: error$a,
  code(cxt) {
    const { gen, data, $data, schemaCode, schema: schema2 } = cxt;
    if ($data || schema2 && typeof schema2 == "object") {
      cxt.fail$data(codegen_1$c._`!${util_1$e.useFunc(gen, equal_1$1.default)}(${data}, ${schemaCode})`);
    } else {
      cxt.fail(codegen_1$c._`${schema2} !== ${data}`);
    }
  }
};
_const.default = def$i;
var _enum = {};
Object.defineProperty(_enum, "__esModule", { value: true });
const codegen_1$b = codegen;
const util_1$d = util;
const equal_1 = equal$1;
const error$9 = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode }) => codegen_1$b._`{allowedValues: ${schemaCode}}`
};
const def$h = {
  keyword: "enum",
  schemaType: "array",
  $data: true,
  error: error$9,
  code(cxt) {
    const { gen, data, $data, schema: schema2, schemaCode, it } = cxt;
    if (!$data && schema2.length === 0)
      throw new Error("enum must have non-empty array");
    const useLoop = schema2.length >= it.opts.loopEnum;
    const eql = util_1$d.useFunc(gen, equal_1.default);
    let valid2;
    if (useLoop || $data) {
      valid2 = gen.let("valid");
      cxt.block$data(valid2, loopEnum);
    } else {
      if (!Array.isArray(schema2))
        throw new Error("ajv implementation error");
      const vSchema = gen.const("vSchema", schemaCode);
      valid2 = codegen_1$b.or(...schema2.map((_x, i2) => equalCode(vSchema, i2)));
    }
    cxt.pass(valid2);
    function loopEnum() {
      gen.assign(valid2, false);
      gen.forOf("v", schemaCode, (v) => gen.if(codegen_1$b._`${eql}(${data}, ${v})`, () => gen.assign(valid2, true).break()));
    }
    function equalCode(vSchema, i2) {
      const sch = schema2[i2];
      return typeof sch === "object" && sch !== null ? codegen_1$b._`${eql}(${data}, ${vSchema}[${i2}])` : codegen_1$b._`${data} === ${sch}`;
    }
  }
};
_enum.default = def$h;
Object.defineProperty(validation$1, "__esModule", { value: true });
const limitNumber_1 = limitNumber;
const multipleOf_1 = multipleOf;
const limitLength_1 = limitLength;
const pattern_1 = pattern;
const limitProperties_1 = limitProperties;
const required_1 = required;
const limitItems_1 = limitItems;
const uniqueItems_1 = uniqueItems;
const const_1 = _const;
const enum_1 = _enum;
const validation = [
  limitNumber_1.default,
  multipleOf_1.default,
  limitLength_1.default,
  pattern_1.default,
  limitProperties_1.default,
  required_1.default,
  limitItems_1.default,
  uniqueItems_1.default,
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  const_1.default,
  enum_1.default
];
validation$1.default = validation;
var applicator = {};
var additionalItems = {};
Object.defineProperty(additionalItems, "__esModule", { value: true });
additionalItems.validateAdditionalItems = void 0;
const codegen_1$a = codegen;
const util_1$c = util;
const error$8 = {
  message: ({ params: { len } }) => codegen_1$a.str`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => codegen_1$a._`{limit: ${len}}`
};
const def$g = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: error$8,
  code(cxt) {
    const { parentSchema, it } = cxt;
    const { items: items2 } = parentSchema;
    if (!Array.isArray(items2)) {
      util_1$c.checkStrictMode(it, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    validateAdditionalItems(cxt, items2);
  }
};
function validateAdditionalItems(cxt, items2) {
  const { gen, schema: schema2, data, keyword: keyword2, it } = cxt;
  it.items = true;
  const len = gen.const("len", codegen_1$a._`${data}.length`);
  if (schema2 === false) {
    cxt.setParams({ len: items2.length });
    cxt.pass(codegen_1$a._`${len} <= ${items2.length}`);
  } else if (typeof schema2 == "object" && !util_1$c.alwaysValidSchema(it, schema2)) {
    const valid2 = gen.var("valid", codegen_1$a._`${len} <= ${items2.length}`);
    gen.if(codegen_1$a.not(valid2), () => validateItems(valid2));
    cxt.ok(valid2);
  }
  function validateItems(valid2) {
    gen.forRange("i", items2.length, len, (i2) => {
      cxt.subschema({ keyword: keyword2, dataProp: i2, dataPropType: util_1$c.Type.Num }, valid2);
      if (!it.allErrors)
        gen.if(codegen_1$a.not(valid2), () => gen.break());
    });
  }
}
additionalItems.validateAdditionalItems = validateAdditionalItems;
additionalItems.default = def$g;
var prefixItems = {};
var items = {};
Object.defineProperty(items, "__esModule", { value: true });
items.validateTuple = void 0;
const codegen_1$9 = codegen;
const util_1$b = util;
const code_1$5 = code;
const def$f = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(cxt) {
    const { schema: schema2, it } = cxt;
    if (Array.isArray(schema2))
      return validateTuple(cxt, "additionalItems", schema2);
    it.items = true;
    if (util_1$b.alwaysValidSchema(it, schema2))
      return;
    cxt.ok(code_1$5.validateArray(cxt));
  }
};
function validateTuple(cxt, extraItems, schArr = cxt.schema) {
  const { gen, parentSchema, data, keyword: keyword2, it } = cxt;
  checkStrictTuple(parentSchema);
  if (it.opts.unevaluated && schArr.length && it.items !== true) {
    it.items = util_1$b.mergeEvaluated.items(gen, schArr.length, it.items);
  }
  const valid2 = gen.name("valid");
  const len = gen.const("len", codegen_1$9._`${data}.length`);
  schArr.forEach((sch, i2) => {
    if (util_1$b.alwaysValidSchema(it, sch))
      return;
    gen.if(codegen_1$9._`${len} > ${i2}`, () => cxt.subschema({
      keyword: keyword2,
      schemaProp: i2,
      dataProp: i2
    }, valid2));
    cxt.ok(valid2);
  });
  function checkStrictTuple(sch) {
    const { opts: opts2, errSchemaPath } = it;
    const l = schArr.length;
    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
    if (opts2.strictTuples && !fullTuple) {
      const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
      util_1$b.checkStrictMode(it, msg, opts2.strictTuples);
    }
  }
}
items.validateTuple = validateTuple;
items.default = def$f;
Object.defineProperty(prefixItems, "__esModule", { value: true });
const items_1$1 = items;
const def$e = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (cxt) => items_1$1.validateTuple(cxt, "items")
};
prefixItems.default = def$e;
var items2020 = {};
Object.defineProperty(items2020, "__esModule", { value: true });
const codegen_1$8 = codegen;
const util_1$a = util;
const code_1$4 = code;
const additionalItems_1$1 = additionalItems;
const error$7 = {
  message: ({ params: { len } }) => codegen_1$8.str`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => codegen_1$8._`{limit: ${len}}`
};
const def$d = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: error$7,
  code(cxt) {
    const { schema: schema2, parentSchema, it } = cxt;
    const { prefixItems: prefixItems2 } = parentSchema;
    it.items = true;
    if (util_1$a.alwaysValidSchema(it, schema2))
      return;
    if (prefixItems2)
      additionalItems_1$1.validateAdditionalItems(cxt, prefixItems2);
    else
      cxt.ok(code_1$4.validateArray(cxt));
  }
};
items2020.default = def$d;
var contains = {};
Object.defineProperty(contains, "__esModule", { value: true });
const codegen_1$7 = codegen;
const util_1$9 = util;
const error$6 = {
  message: ({ params: { min, max } }) => max === void 0 ? codegen_1$7.str`must contain at least ${min} valid item(s)` : codegen_1$7.str`must contain at least ${min} and no more than ${max} valid item(s)`,
  params: ({ params: { min, max } }) => max === void 0 ? codegen_1$7._`{minContains: ${min}}` : codegen_1$7._`{minContains: ${min}, maxContains: ${max}}`
};
const def$c = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: true,
  error: error$6,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, it } = cxt;
    let min;
    let max;
    const { minContains, maxContains } = parentSchema;
    if (it.opts.next) {
      min = minContains === void 0 ? 1 : minContains;
      max = maxContains;
    } else {
      min = 1;
    }
    const len = gen.const("len", codegen_1$7._`${data}.length`);
    cxt.setParams({ min, max });
    if (max === void 0 && min === 0) {
      util_1$9.checkStrictMode(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
      return;
    }
    if (max !== void 0 && min > max) {
      util_1$9.checkStrictMode(it, `"minContains" > "maxContains" is always invalid`);
      cxt.fail();
      return;
    }
    if (util_1$9.alwaysValidSchema(it, schema2)) {
      let cond = codegen_1$7._`${len} >= ${min}`;
      if (max !== void 0)
        cond = codegen_1$7._`${cond} && ${len} <= ${max}`;
      cxt.pass(cond);
      return;
    }
    it.items = true;
    const valid2 = gen.name("valid");
    if (max === void 0 && min === 1) {
      validateItems(valid2, () => gen.if(valid2, () => gen.break()));
    } else {
      gen.let(valid2, false);
      const schValid = gen.name("_valid");
      const count = gen.let("count", 0);
      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
    }
    cxt.result(valid2, () => cxt.reset());
    function validateItems(_valid, block) {
      gen.forRange("i", 0, len, (i2) => {
        cxt.subschema({
          keyword: "contains",
          dataProp: i2,
          dataPropType: util_1$9.Type.Num,
          compositeRule: true
        }, _valid);
        block();
      });
    }
    function checkLimits(count) {
      gen.code(codegen_1$7._`${count}++`);
      if (max === void 0) {
        gen.if(codegen_1$7._`${count} >= ${min}`, () => gen.assign(valid2, true).break());
      } else {
        gen.if(codegen_1$7._`${count} > ${max}`, () => gen.assign(valid2, false).break());
        if (min === 1)
          gen.assign(valid2, true);
        else
          gen.if(codegen_1$7._`${count} >= ${min}`, () => gen.assign(valid2, true));
      }
    }
  }
};
contains.default = def$c;
var dependencies = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
  const codegen_12 = codegen;
  const util_12 = util;
  const code_12 = code;
  exports.error = {
    message: ({ params: { property, depsCount, deps } }) => {
      const property_ies = depsCount === 1 ? "property" : "properties";
      return codegen_12.str`must have ${property_ies} ${deps} when property ${property} is present`;
    },
    params: ({ params: { property, depsCount, deps, missingProperty } }) => codegen_12._`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
  };
  const def2 = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports.error,
    code(cxt) {
      const [propDeps, schDeps] = splitDependencies(cxt);
      validatePropertyDeps(cxt, propDeps);
      validateSchemaDeps(cxt, schDeps);
    }
  };
  function splitDependencies({ schema: schema2 }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key in schema2) {
      if (key === "__proto__")
        continue;
      const deps = Array.isArray(schema2[key]) ? propertyDeps : schemaDeps;
      deps[key] = schema2[key];
    }
    return [propertyDeps, schemaDeps];
  }
  function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
    const { gen, data, it } = cxt;
    if (Object.keys(propertyDeps).length === 0)
      return;
    const missing = gen.let("missing");
    for (const prop in propertyDeps) {
      const deps = propertyDeps[prop];
      if (deps.length === 0)
        continue;
      const hasProperty = code_12.propertyInData(gen, data, prop, it.opts.ownProperties);
      cxt.setParams({
        property: prop,
        depsCount: deps.length,
        deps: deps.join(", ")
      });
      if (it.allErrors) {
        gen.if(hasProperty, () => {
          for (const depProp of deps) {
            code_12.checkReportMissingProp(cxt, depProp);
          }
        });
      } else {
        gen.if(codegen_12._`${hasProperty} && (${code_12.checkMissingProp(cxt, deps, missing)})`);
        code_12.reportMissingProp(cxt, missing);
        gen.else();
      }
    }
  }
  exports.validatePropertyDeps = validatePropertyDeps;
  function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
    const { gen, data, keyword: keyword2, it } = cxt;
    const valid2 = gen.name("valid");
    for (const prop in schemaDeps) {
      if (util_12.alwaysValidSchema(it, schemaDeps[prop]))
        continue;
      gen.if(code_12.propertyInData(gen, data, prop, it.opts.ownProperties), () => {
        const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid2);
        cxt.mergeValidEvaluated(schCxt, valid2);
      }, () => gen.var(valid2, true));
      cxt.ok(valid2);
    }
  }
  exports.validateSchemaDeps = validateSchemaDeps;
  exports.default = def2;
})(dependencies);
var propertyNames = {};
Object.defineProperty(propertyNames, "__esModule", { value: true });
const codegen_1$6 = codegen;
const util_1$8 = util;
const error$5 = {
  message: "property name must be valid",
  params: ({ params }) => codegen_1$6._`{propertyName: ${params.propertyName}}`
};
const def$b = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: error$5,
  code(cxt) {
    const { gen, schema: schema2, data, it } = cxt;
    if (util_1$8.alwaysValidSchema(it, schema2))
      return;
    const valid2 = gen.name("valid");
    gen.forIn("key", data, (key) => {
      cxt.setParams({ propertyName: key });
      cxt.subschema({
        keyword: "propertyNames",
        data: key,
        dataTypes: ["string"],
        propertyName: key,
        compositeRule: true
      }, valid2);
      gen.if(codegen_1$6.not(valid2), () => {
        cxt.error(true);
        if (!it.allErrors)
          gen.break();
      });
    });
    cxt.ok(valid2);
  }
};
propertyNames.default = def$b;
var additionalProperties = {};
Object.defineProperty(additionalProperties, "__esModule", { value: true });
const code_1$3 = code;
const codegen_1$5 = codegen;
const names_1 = names$1;
const util_1$7 = util;
const error$4 = {
  message: "must NOT have additional properties",
  params: ({ params }) => codegen_1$5._`{additionalProperty: ${params.additionalProperty}}`
};
const def$a = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: true,
  trackErrors: true,
  error: error$4,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, errsCount, it } = cxt;
    if (!errsCount)
      throw new Error("ajv implementation error");
    const { allErrors, opts: opts2 } = it;
    it.props = true;
    if (opts2.removeAdditional !== "all" && util_1$7.alwaysValidSchema(it, schema2))
      return;
    const props = code_1$3.allSchemaProperties(parentSchema.properties);
    const patProps = code_1$3.allSchemaProperties(parentSchema.patternProperties);
    checkAdditionalProperties();
    cxt.ok(codegen_1$5._`${errsCount} === ${names_1.default.errors}`);
    function checkAdditionalProperties() {
      gen.forIn("key", data, (key) => {
        if (!props.length && !patProps.length)
          additionalPropertyCode(key);
        else
          gen.if(isAdditional(key), () => additionalPropertyCode(key));
      });
    }
    function isAdditional(key) {
      let definedProp;
      if (props.length > 8) {
        const propsSchema = util_1$7.schemaRefOrVal(it, parentSchema.properties, "properties");
        definedProp = code_1$3.isOwnProperty(gen, propsSchema, key);
      } else if (props.length) {
        definedProp = codegen_1$5.or(...props.map((p) => codegen_1$5._`${key} === ${p}`));
      } else {
        definedProp = codegen_1$5.nil;
      }
      if (patProps.length) {
        definedProp = codegen_1$5.or(definedProp, ...patProps.map((p) => codegen_1$5._`${code_1$3.usePattern(cxt, p)}.test(${key})`));
      }
      return codegen_1$5.not(definedProp);
    }
    function deleteAdditional(key) {
      gen.code(codegen_1$5._`delete ${data}[${key}]`);
    }
    function additionalPropertyCode(key) {
      if (opts2.removeAdditional === "all" || opts2.removeAdditional && schema2 === false) {
        deleteAdditional(key);
        return;
      }
      if (schema2 === false) {
        cxt.setParams({ additionalProperty: key });
        cxt.error();
        if (!allErrors)
          gen.break();
        return;
      }
      if (typeof schema2 == "object" && !util_1$7.alwaysValidSchema(it, schema2)) {
        const valid2 = gen.name("valid");
        if (opts2.removeAdditional === "failing") {
          applyAdditionalSchema(key, valid2, false);
          gen.if(codegen_1$5.not(valid2), () => {
            cxt.reset();
            deleteAdditional(key);
          });
        } else {
          applyAdditionalSchema(key, valid2);
          if (!allErrors)
            gen.if(codegen_1$5.not(valid2), () => gen.break());
        }
      }
    }
    function applyAdditionalSchema(key, valid2, errors2) {
      const subschema2 = {
        keyword: "additionalProperties",
        dataProp: key,
        dataPropType: util_1$7.Type.Str
      };
      if (errors2 === false) {
        Object.assign(subschema2, {
          compositeRule: true,
          createErrors: false,
          allErrors: false
        });
      }
      cxt.subschema(subschema2, valid2);
    }
  }
};
additionalProperties.default = def$a;
var properties$1 = {};
Object.defineProperty(properties$1, "__esModule", { value: true });
const validate_1 = validate;
const code_1$2 = code;
const util_1$6 = util;
const additionalProperties_1$1 = additionalProperties;
const def$9 = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, it } = cxt;
    if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
      additionalProperties_1$1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1$1.default, "additionalProperties"));
    }
    const allProps = code_1$2.allSchemaProperties(schema2);
    for (const prop of allProps) {
      it.definedProperties.add(prop);
    }
    if (it.opts.unevaluated && allProps.length && it.props !== true) {
      it.props = util_1$6.mergeEvaluated.props(gen, util_1$6.toHash(allProps), it.props);
    }
    const properties2 = allProps.filter((p) => !util_1$6.alwaysValidSchema(it, schema2[p]));
    if (properties2.length === 0)
      return;
    const valid2 = gen.name("valid");
    for (const prop of properties2) {
      if (hasDefault(prop)) {
        applyPropertySchema(prop);
      } else {
        gen.if(code_1$2.propertyInData(gen, data, prop, it.opts.ownProperties));
        applyPropertySchema(prop);
        if (!it.allErrors)
          gen.else().var(valid2, true);
        gen.endIf();
      }
      cxt.it.definedProperties.add(prop);
      cxt.ok(valid2);
    }
    function hasDefault(prop) {
      return it.opts.useDefaults && !it.compositeRule && schema2[prop].default !== void 0;
    }
    function applyPropertySchema(prop) {
      cxt.subschema({
        keyword: "properties",
        schemaProp: prop,
        dataProp: prop
      }, valid2);
    }
  }
};
properties$1.default = def$9;
var patternProperties = {};
Object.defineProperty(patternProperties, "__esModule", { value: true });
const code_1$1 = code;
const codegen_1$4 = codegen;
const util_1$5 = util;
const util_2 = util;
const def$8 = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema: schema2, data, parentSchema, it } = cxt;
    const { opts: opts2 } = it;
    const patterns = code_1$1.allSchemaProperties(schema2);
    const alwaysValidPatterns = patterns.filter((p) => util_1$5.alwaysValidSchema(it, schema2[p]));
    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
      return;
    }
    const checkProperties = opts2.strictSchema && !opts2.allowMatchingProperties && parentSchema.properties;
    const valid2 = gen.name("valid");
    if (it.props !== true && !(it.props instanceof codegen_1$4.Name)) {
      it.props = util_2.evaluatedPropsToName(gen, it.props);
    }
    const { props } = it;
    validatePatternProperties();
    function validatePatternProperties() {
      for (const pat of patterns) {
        if (checkProperties)
          checkMatchingProperties(pat);
        if (it.allErrors) {
          validateProperties(pat);
        } else {
          gen.var(valid2, true);
          validateProperties(pat);
          gen.if(valid2);
        }
      }
    }
    function checkMatchingProperties(pat) {
      for (const prop in checkProperties) {
        if (new RegExp(pat).test(prop)) {
          util_1$5.checkStrictMode(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
        }
      }
    }
    function validateProperties(pat) {
      gen.forIn("key", data, (key) => {
        gen.if(codegen_1$4._`${code_1$1.usePattern(cxt, pat)}.test(${key})`, () => {
          const alwaysValid = alwaysValidPatterns.includes(pat);
          if (!alwaysValid) {
            cxt.subschema({
              keyword: "patternProperties",
              schemaProp: pat,
              dataProp: key,
              dataPropType: util_2.Type.Str
            }, valid2);
          }
          if (it.opts.unevaluated && props !== true) {
            gen.assign(codegen_1$4._`${props}[${key}]`, true);
          } else if (!alwaysValid && !it.allErrors) {
            gen.if(codegen_1$4.not(valid2), () => gen.break());
          }
        });
      });
    }
  }
};
patternProperties.default = def$8;
var not = {};
Object.defineProperty(not, "__esModule", { value: true });
const util_1$4 = util;
const def$7 = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  code(cxt) {
    const { gen, schema: schema2, it } = cxt;
    if (util_1$4.alwaysValidSchema(it, schema2)) {
      cxt.fail();
      return;
    }
    const valid2 = gen.name("valid");
    cxt.subschema({
      keyword: "not",
      compositeRule: true,
      createErrors: false,
      allErrors: false
    }, valid2);
    cxt.failResult(valid2, () => cxt.reset(), () => cxt.error());
  },
  error: { message: "must NOT be valid" }
};
not.default = def$7;
var anyOf = {};
Object.defineProperty(anyOf, "__esModule", { value: true });
const code_1 = code;
const def$6 = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: true,
  code: code_1.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
anyOf.default = def$6;
var oneOf = {};
Object.defineProperty(oneOf, "__esModule", { value: true });
const codegen_1$3 = codegen;
const util_1$3 = util;
const error$3 = {
  message: "must match exactly one schema in oneOf",
  params: ({ params }) => codegen_1$3._`{passingSchemas: ${params.passing}}`
};
const def$5 = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: true,
  error: error$3,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, it } = cxt;
    if (!Array.isArray(schema2))
      throw new Error("ajv implementation error");
    if (it.opts.discriminator && parentSchema.discriminator)
      return;
    const schArr = schema2;
    const valid2 = gen.let("valid", false);
    const passing = gen.let("passing", null);
    const schValid = gen.name("_valid");
    cxt.setParams({ passing });
    gen.block(validateOneOf);
    cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
    function validateOneOf() {
      schArr.forEach((sch, i2) => {
        let schCxt;
        if (util_1$3.alwaysValidSchema(it, sch)) {
          gen.var(schValid, true);
        } else {
          schCxt = cxt.subschema({
            keyword: "oneOf",
            schemaProp: i2,
            compositeRule: true
          }, schValid);
        }
        if (i2 > 0) {
          gen.if(codegen_1$3._`${schValid} && ${valid2}`).assign(valid2, false).assign(passing, codegen_1$3._`[${passing}, ${i2}]`).else();
        }
        gen.if(schValid, () => {
          gen.assign(valid2, true);
          gen.assign(passing, i2);
          if (schCxt)
            cxt.mergeEvaluated(schCxt, codegen_1$3.Name);
        });
      });
    }
  }
};
oneOf.default = def$5;
var allOf = {};
Object.defineProperty(allOf, "__esModule", { value: true });
const util_1$2 = util;
const def$4 = {
  keyword: "allOf",
  schemaType: "array",
  code(cxt) {
    const { gen, schema: schema2, it } = cxt;
    if (!Array.isArray(schema2))
      throw new Error("ajv implementation error");
    const valid2 = gen.name("valid");
    schema2.forEach((sch, i2) => {
      if (util_1$2.alwaysValidSchema(it, sch))
        return;
      const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i2 }, valid2);
      cxt.ok(valid2);
      cxt.mergeEvaluated(schCxt);
    });
  }
};
allOf.default = def$4;
var _if = {};
Object.defineProperty(_if, "__esModule", { value: true });
const codegen_1$2 = codegen;
const util_1$1 = util;
const error$2 = {
  message: ({ params }) => codegen_1$2.str`must match "${params.ifClause}" schema`,
  params: ({ params }) => codegen_1$2._`{failingKeyword: ${params.ifClause}}`
};
const def$3 = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  error: error$2,
  code(cxt) {
    const { gen, parentSchema, it } = cxt;
    if (parentSchema.then === void 0 && parentSchema.else === void 0) {
      util_1$1.checkStrictMode(it, '"if" without "then" and "else" is ignored');
    }
    const hasThen = hasSchema(it, "then");
    const hasElse = hasSchema(it, "else");
    if (!hasThen && !hasElse)
      return;
    const valid2 = gen.let("valid", true);
    const schValid = gen.name("_valid");
    validateIf();
    cxt.reset();
    if (hasThen && hasElse) {
      const ifClause = gen.let("ifClause");
      cxt.setParams({ ifClause });
      gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
    } else if (hasThen) {
      gen.if(schValid, validateClause("then"));
    } else {
      gen.if(codegen_1$2.not(schValid), validateClause("else"));
    }
    cxt.pass(valid2, () => cxt.error(true));
    function validateIf() {
      const schCxt = cxt.subschema({
        keyword: "if",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, schValid);
      cxt.mergeEvaluated(schCxt);
    }
    function validateClause(keyword2, ifClause) {
      return () => {
        const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
        gen.assign(valid2, schValid);
        cxt.mergeValidEvaluated(schCxt, valid2);
        if (ifClause)
          gen.assign(ifClause, codegen_1$2._`${keyword2}`);
        else
          cxt.setParams({ ifClause: keyword2 });
      };
    }
  }
};
function hasSchema(it, keyword2) {
  const schema2 = it.schema[keyword2];
  return schema2 !== void 0 && !util_1$1.alwaysValidSchema(it, schema2);
}
_if.default = def$3;
var thenElse = {};
Object.defineProperty(thenElse, "__esModule", { value: true });
const util_1 = util;
const def$2 = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: keyword2, parentSchema, it }) {
    if (parentSchema.if === void 0)
      util_1.checkStrictMode(it, `"${keyword2}" without "if" is ignored`);
  }
};
thenElse.default = def$2;
Object.defineProperty(applicator, "__esModule", { value: true });
const additionalItems_1 = additionalItems;
const prefixItems_1 = prefixItems;
const items_1 = items;
const items2020_1 = items2020;
const contains_1 = contains;
const dependencies_1 = dependencies;
const propertyNames_1 = propertyNames;
const additionalProperties_1 = additionalProperties;
const properties_1 = properties$1;
const patternProperties_1 = patternProperties;
const not_1 = not;
const anyOf_1 = anyOf;
const oneOf_1 = oneOf;
const allOf_1 = allOf;
const if_1 = _if;
const thenElse_1 = thenElse;
function getApplicator(draft2020 = false) {
  const applicator2 = [
    not_1.default,
    anyOf_1.default,
    oneOf_1.default,
    allOf_1.default,
    if_1.default,
    thenElse_1.default,
    propertyNames_1.default,
    additionalProperties_1.default,
    dependencies_1.default,
    properties_1.default,
    patternProperties_1.default
  ];
  if (draft2020)
    applicator2.push(prefixItems_1.default, items2020_1.default);
  else
    applicator2.push(additionalItems_1.default, items_1.default);
  applicator2.push(contains_1.default);
  return applicator2;
}
applicator.default = getApplicator;
var format$2 = {};
var format$1 = {};
Object.defineProperty(format$1, "__esModule", { value: true });
const codegen_1$1 = codegen;
const error$1 = {
  message: ({ schemaCode }) => codegen_1$1.str`must match format "${schemaCode}"`,
  params: ({ schemaCode }) => codegen_1$1._`{format: ${schemaCode}}`
};
const def$1 = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: true,
  error: error$1,
  code(cxt, ruleType) {
    const { gen, data, $data, schema: schema2, schemaCode, it } = cxt;
    const { opts: opts2, errSchemaPath, schemaEnv, self: self2 } = it;
    if (!opts2.validateFormats)
      return;
    if ($data)
      validate$DataFormat();
    else
      validateFormat();
    function validate$DataFormat() {
      const fmts = gen.scopeValue("formats", {
        ref: self2.formats,
        code: opts2.code.formats
      });
      const fDef = gen.const("fDef", codegen_1$1._`${fmts}[${schemaCode}]`);
      const fType = gen.let("fType");
      const format2 = gen.let("format");
      gen.if(codegen_1$1._`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, codegen_1$1._`${fDef}.type || "string"`).assign(format2, codegen_1$1._`${fDef}.validate`), () => gen.assign(fType, codegen_1$1._`"string"`).assign(format2, fDef));
      cxt.fail$data(codegen_1$1.or(unknownFmt(), invalidFmt()));
      function unknownFmt() {
        if (opts2.strictSchema === false)
          return codegen_1$1.nil;
        return codegen_1$1._`${schemaCode} && !${format2}`;
      }
      function invalidFmt() {
        const callFormat = schemaEnv.$async ? codegen_1$1._`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : codegen_1$1._`${format2}(${data})`;
        const validData = codegen_1$1._`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
        return codegen_1$1._`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
      }
    }
    function validateFormat() {
      const formatDef = self2.formats[schema2];
      if (!formatDef) {
        unknownFormat();
        return;
      }
      if (formatDef === true)
        return;
      const [fmtType, format2, fmtRef] = getFormat(formatDef);
      if (fmtType === ruleType)
        cxt.pass(validCondition());
      function unknownFormat() {
        if (opts2.strictSchema === false) {
          self2.logger.warn(unknownMsg());
          return;
        }
        throw new Error(unknownMsg());
        function unknownMsg() {
          return `unknown format "${schema2}" ignored in schema at path "${errSchemaPath}"`;
        }
      }
      function getFormat(fmtDef) {
        const code2 = fmtDef instanceof RegExp ? codegen_1$1.regexpCode(fmtDef) : opts2.code.formats ? codegen_1$1._`${opts2.code.formats}${codegen_1$1.getProperty(schema2)}` : void 0;
        const fmt = gen.scopeValue("formats", { key: schema2, ref: fmtDef, code: code2 });
        if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
          return [fmtDef.type || "string", fmtDef.validate, codegen_1$1._`${fmt}.validate`];
        }
        return ["string", fmtDef, fmt];
      }
      function validCondition() {
        if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
          if (!schemaEnv.$async)
            throw new Error("async format in sync schema");
          return codegen_1$1._`await ${fmtRef}(${data})`;
        }
        return typeof format2 == "function" ? codegen_1$1._`${fmtRef}(${data})` : codegen_1$1._`${fmtRef}.test(${data})`;
      }
    }
  }
};
format$1.default = def$1;
Object.defineProperty(format$2, "__esModule", { value: true });
const format_1$1 = format$1;
const format = [format_1$1.default];
format$2.default = format;
var metadata = {};
Object.defineProperty(metadata, "__esModule", { value: true });
metadata.contentVocabulary = metadata.metadataVocabulary = void 0;
metadata.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
metadata.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(draft7, "__esModule", { value: true });
const core_1 = core$1;
const validation_1 = validation$1;
const applicator_1 = applicator;
const format_1 = format$2;
const metadata_1 = metadata;
const draft7Vocabularies = [
  core_1.default,
  validation_1.default,
  applicator_1.default(),
  format_1.default,
  metadata_1.metadataVocabulary,
  metadata_1.contentVocabulary
];
draft7.default = draft7Vocabularies;
var discriminator = {};
var types = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiscrError = void 0;
  (function(DiscrError) {
    DiscrError["Tag"] = "tag";
    DiscrError["Mapping"] = "mapping";
  })(exports.DiscrError || (exports.DiscrError = {}));
})(types);
Object.defineProperty(discriminator, "__esModule", { value: true });
const codegen_1 = codegen;
const types_1 = types;
const error = {
  message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
  params: ({ params: { discrError, tag, tagName } }) => codegen_1._`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
};
const def = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error,
  code(cxt) {
    const { gen, data, schema: schema2, parentSchema, it } = cxt;
    const { oneOf: oneOf2 } = parentSchema;
    if (!it.opts.discriminator) {
      throw new Error("discriminator: requires discriminator option");
    }
    const tagName = schema2.propertyName;
    if (typeof tagName != "string")
      throw new Error("discriminator: requires propertyName");
    if (schema2.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!oneOf2)
      throw new Error("discriminator: requires oneOf keyword");
    const valid2 = gen.let("valid", false);
    const tag = gen.const("tag", codegen_1._`${data}${codegen_1.getProperty(tagName)}`);
    gen.if(codegen_1._`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
    cxt.ok(valid2);
    function validateMapping() {
      const mapping = getMapping();
      gen.if(false);
      for (const tagValue in mapping) {
        gen.elseIf(codegen_1._`${tag} === ${tagValue}`);
        gen.assign(valid2, applyTagSchema(mapping[tagValue]));
      }
      gen.else();
      cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
      gen.endIf();
    }
    function applyTagSchema(schemaProp) {
      const _valid = gen.name("valid");
      const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
      cxt.mergeEvaluated(schCxt, codegen_1.Name);
      return _valid;
    }
    function getMapping() {
      var _a;
      const oneOfMapping = {};
      const topRequired = hasRequired(parentSchema);
      let tagRequired = true;
      for (let i2 = 0; i2 < oneOf2.length; i2++) {
        const sch = oneOf2[i2];
        const propSch = (_a = sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
        if (typeof propSch != "object") {
          throw new Error(`discriminator: oneOf schemas must have "properties/${tagName}"`);
        }
        tagRequired = tagRequired && (topRequired || hasRequired(sch));
        addMappings(propSch, i2);
      }
      if (!tagRequired)
        throw new Error(`discriminator: "${tagName}" must be required`);
      return oneOfMapping;
      function hasRequired({ required: required2 }) {
        return Array.isArray(required2) && required2.includes(tagName);
      }
      function addMappings(sch, i2) {
        if (sch.const) {
          addMapping(sch.const, i2);
        } else if (sch.enum) {
          for (const tagValue of sch.enum) {
            addMapping(tagValue, i2);
          }
        } else {
          throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
        }
      }
      function addMapping(tagValue, i2) {
        if (typeof tagValue != "string" || tagValue in oneOfMapping) {
          throw new Error(`discriminator: "${tagName}" values must be unique strings`);
        }
        oneOfMapping[tagValue] = i2;
      }
    }
  }
};
discriminator.default = def;
const $schema = "http://json-schema.org/draft-07/schema#";
const $id = "http://json-schema.org/draft-07/schema#";
const title = "Core schema meta-schema";
const definitions = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        "default": 0
      }
    ]
  },
  simpleTypes: {
    "enum": [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: true,
    "default": []
  }
};
const type = [
  "object",
  "boolean"
];
const properties = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  "default": true,
  readOnly: {
    type: "boolean",
    "default": false
  },
  examples: {
    type: "array",
    items: true
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    "default": true
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    "default": false
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    "default": {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  "const": true,
  "enum": {
    type: "array",
    items: true,
    minItems: 1,
    uniqueItems: true
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: true
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  "if": {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  "else": {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
};
var require$$3 = {
  $schema,
  $id,
  title,
  definitions,
  type,
  properties,
  "default": true
};
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
  const core_12 = core$2;
  const draft7_1 = draft7;
  const discriminator_1 = discriminator;
  const draft7MetaSchema = require$$3;
  const META_SUPPORT_DATA = ["/properties"];
  const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
  class Ajv extends core_12.default {
    _addVocabularies() {
      super._addVocabularies();
      draft7_1.default.forEach((v) => this.addVocabulary(v));
      if (this.opts.discriminator)
        this.addKeyword(discriminator_1.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      if (!this.opts.meta)
        return;
      const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
      this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
      this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
    }
  }
  module.exports = exports = Ajv;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = Ajv;
  var validate_12 = validate;
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
})(ajv, ajv.exports);
var dist = { exports: {} };
var formats = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
  function fmtDef(validate2, compare2) {
    return { validate: validate2, compare: compare2 };
  }
  exports.fullFormats = {
    date: fmtDef(date, compareDate),
    time: fmtDef(time, compareTime),
    "date-time": fmtDef(date_time, compareDateTime),
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex,
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    byte,
    int32: { type: "number", validate: validateInt32 },
    int64: { type: "number", validate: validateInt64 },
    float: { type: "number", validate: validateNumber },
    double: { type: "number", validate: validateNumber },
    password: true,
    binary: true
  };
  exports.fastFormats = __spreadProps(__spreadValues({}, exports.fullFormats), {
    date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
    time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
    "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
  });
  exports.formatNames = Object.keys(exports.fullFormats);
  function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function date(str2) {
    const matches = DATE.exec(str2);
    if (!matches)
      return false;
    const year = +matches[1];
    const month = +matches[2];
    const day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
  }
  function compareDate(d1, d2) {
    if (!(d1 && d2))
      return void 0;
    if (d1 > d2)
      return 1;
    if (d1 < d2)
      return -1;
    return 0;
  }
  const TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
  function time(str2, withTimeZone) {
    const matches = TIME.exec(str2);
    if (!matches)
      return false;
    const hour = +matches[1];
    const minute = +matches[2];
    const second = +matches[3];
    const timeZone = matches[5];
    return (hour <= 23 && minute <= 59 && second <= 59 || hour === 23 && minute === 59 && second === 60) && (!withTimeZone || timeZone !== "");
  }
  function compareTime(t1, t2) {
    if (!(t1 && t2))
      return void 0;
    const a1 = TIME.exec(t1);
    const a2 = TIME.exec(t2);
    if (!(a1 && a2))
      return void 0;
    t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
    t2 = a2[1] + a2[2] + a2[3] + (a2[4] || "");
    if (t1 > t2)
      return 1;
    if (t1 < t2)
      return -1;
    return 0;
  }
  const DATE_TIME_SEPARATOR = /t|\s/i;
  function date_time(str2) {
    const dateTime = str2.split(DATE_TIME_SEPARATOR);
    return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true);
  }
  function compareDateTime(dt1, dt2) {
    if (!(dt1 && dt2))
      return void 0;
    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
    const res = compareDate(d1, d2);
    if (res === void 0)
      return void 0;
    return res || compareTime(t1, t2);
  }
  const NOT_URI_FRAGMENT = /\/|:/;
  const URI2 = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function uri(str2) {
    return NOT_URI_FRAGMENT.test(str2) && URI2.test(str2);
  }
  const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function byte(str2) {
    BYTE.lastIndex = 0;
    return BYTE.test(str2);
  }
  const MIN_INT32 = -(2 ** 31);
  const MAX_INT32 = 2 ** 31 - 1;
  function validateInt32(value) {
    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
  }
  function validateInt64(value) {
    return Number.isInteger(value);
  }
  function validateNumber() {
    return true;
  }
  const Z_ANCHOR = /[^\\]\\Z/;
  function regex(str2) {
    if (Z_ANCHOR.test(str2))
      return false;
    try {
      new RegExp(str2);
      return true;
    } catch (e) {
      return false;
    }
  }
})(formats);
var limit = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatLimitDefinition = void 0;
  const ajv_1 = ajv.exports;
  const codegen_12 = codegen;
  const ops2 = codegen_12.operators;
  const KWDs2 = {
    formatMaximum: { okStr: "<=", ok: ops2.LTE, fail: ops2.GT },
    formatMinimum: { okStr: ">=", ok: ops2.GTE, fail: ops2.LT },
    formatExclusiveMaximum: { okStr: "<", ok: ops2.LT, fail: ops2.GTE },
    formatExclusiveMinimum: { okStr: ">", ok: ops2.GT, fail: ops2.LTE }
  };
  const error2 = {
    message: ({ keyword: keyword2, schemaCode }) => codegen_12.str`should be ${KWDs2[keyword2].okStr} ${schemaCode}`,
    params: ({ keyword: keyword2, schemaCode }) => codegen_12._`{comparison: ${KWDs2[keyword2].okStr}, limit: ${schemaCode}}`
  };
  exports.formatLimitDefinition = {
    keyword: Object.keys(KWDs2),
    type: "string",
    schemaType: "string",
    $data: true,
    error: error2,
    code(cxt) {
      const { gen, data, schemaCode, keyword: keyword2, it } = cxt;
      const { opts: opts2, self: self2 } = it;
      if (!opts2.validateFormats)
        return;
      const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
      if (fCxt.$data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen.scopeValue("formats", {
          ref: self2.formats,
          code: opts2.code.formats
        });
        const fmt = gen.const("fmt", codegen_12._`${fmts}[${fCxt.schemaCode}]`);
        cxt.fail$data(codegen_12.or(codegen_12._`typeof ${fmt} != "object"`, codegen_12._`${fmt} instanceof RegExp`, codegen_12._`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
      }
      function validateFormat() {
        const format2 = fCxt.schema;
        const fmtDef = self2.formats[format2];
        if (!fmtDef || fmtDef === true)
          return;
        if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
          throw new Error(`"${keyword2}": format "${format2}" does not define "compare" function`);
        }
        const fmt = gen.scopeValue("formats", {
          key: format2,
          ref: fmtDef,
          code: opts2.code.formats ? codegen_12._`${opts2.code.formats}${codegen_12.getProperty(format2)}` : void 0
        });
        cxt.fail$data(compareCode(fmt));
      }
      function compareCode(fmt) {
        return codegen_12._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs2[keyword2].fail} 0`;
      }
    },
    dependencies: ["format"]
  };
  const formatLimitPlugin = (ajv2) => {
    ajv2.addKeyword(exports.formatLimitDefinition);
    return ajv2;
  };
  exports.default = formatLimitPlugin;
})(limit);
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const formats_1 = formats;
  const limit_1 = limit;
  const codegen_12 = codegen;
  const fullName = new codegen_12.Name("fullFormats");
  const fastName = new codegen_12.Name("fastFormats");
  const formatsPlugin = (ajv2, opts2 = { keywords: true }) => {
    if (Array.isArray(opts2)) {
      addFormats(ajv2, opts2, formats_1.fullFormats, fullName);
      return ajv2;
    }
    const [formats2, exportName] = opts2.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
    const list = opts2.formats || formats_1.formatNames;
    addFormats(ajv2, list, formats2, exportName);
    if (opts2.keywords)
      limit_1.default(ajv2);
    return ajv2;
  };
  formatsPlugin.get = (name, mode = "full") => {
    const formats2 = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
    const f = formats2[name];
    if (!f)
      throw new Error(`Unknown format "${name}"`);
    return f;
  };
  function addFormats(ajv2, list, fs2, exportName) {
    var _a;
    var _b;
    (_a = (_b = ajv2.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = codegen_12._`require("ajv-formats/dist/formats").${exportName}`;
    for (const f of list)
      ajv2.addFormat(f, fs2[f]);
  }
  module.exports = exports = formatsPlugin;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = formatsPlugin;
})(dist, dist.exports);
const copyProperty = (to, from, property, ignoreNonConfigurable) => {
  if (property === "length" || property === "prototype") {
    return;
  }
  if (property === "arguments" || property === "caller") {
    return;
  }
  const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
  const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
    return;
  }
  Object.defineProperty(to, property, fromDescriptor);
};
const canCopyProperty = function(toDescriptor, fromDescriptor) {
  return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
};
const changePrototype = (to, from) => {
  const fromPrototype = Object.getPrototypeOf(from);
  if (fromPrototype === Object.getPrototypeOf(to)) {
    return;
  }
  Object.setPrototypeOf(to, fromPrototype);
};
const wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
const toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
const toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
const changeToString = (to, from, name) => {
  const withName = name === "" ? "" : `with ${name.trim()}() `;
  const newToString = wrappedToString.bind(null, withName, from.toString());
  Object.defineProperty(newToString, "name", toStringName);
  Object.defineProperty(to, "toString", __spreadProps(__spreadValues({}, toStringDescriptor), { value: newToString }));
};
const mimicFn$4 = (to, from, { ignoreNonConfigurable = false } = {}) => {
  const { name } = to;
  for (const property of Reflect.ownKeys(from)) {
    copyProperty(to, from, property, ignoreNonConfigurable);
  }
  changePrototype(to, from);
  changeToString(to, from, name);
  return to;
};
var mimicFn_1 = mimicFn$4;
const mimicFn$3 = mimicFn_1;
var debounceFn = (inputFunction, options = {}) => {
  if (typeof inputFunction !== "function") {
    throw new TypeError(`Expected the first argument to be a function, got \`${typeof inputFunction}\``);
  }
  const {
    wait = 0,
    before = false,
    after = true
  } = options;
  if (!before && !after) {
    throw new Error("Both `before` and `after` are false, function wouldn't be called.");
  }
  let timeout;
  let result;
  const debouncedFunction = function(...arguments_) {
    const context = this;
    const later = () => {
      timeout = void 0;
      if (after) {
        result = inputFunction.apply(context, arguments_);
      }
    };
    const shouldCallNow = before && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (shouldCallNow) {
      result = inputFunction.apply(context, arguments_);
    }
    return result;
  };
  mimicFn$3(debouncedFunction, inputFunction);
  debouncedFunction.cancel = () => {
    if (timeout) {
      clearTimeout(timeout);
      timeout = void 0;
    }
  };
  return debouncedFunction;
};
var re$5 = { exports: {} };
const SEMVER_SPEC_VERSION = "2.0.0";
const MAX_LENGTH$2 = 256;
const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;
const MAX_SAFE_COMPONENT_LENGTH = 16;
var constants = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH: MAX_LENGTH$2,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  MAX_SAFE_COMPONENT_LENGTH
};
const debug$3 = typeof process === "object" && process.env && {}.NODE_DEBUG && /\bsemver\b/i.test({}.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
};
var debug_1 = debug$3;
(function(module, exports) {
  const { MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2 } = constants;
  const debug2 = debug_1;
  exports = module.exports = {};
  const re2 = exports.re = [];
  const src = exports.src = [];
  const t2 = exports.t = {};
  let R = 0;
  const createToken = (name, value, isGlobal) => {
    const index = R++;
    debug2(index, value);
    t2[name] = index;
    src[index] = value;
    re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
  createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
  createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NUMERICIDENTIFIER]}|${src[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NUMERICIDENTIFIERLOOSE]}|${src[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
  createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`);
  createToken("FULL", `^${src[t2.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`);
  createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:$|[^\\d])`);
  createToken("COERCERTL", src[t2.COERCE], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
})(re$5, re$5.exports);
const opts = ["includePrerelease", "loose", "rtl"];
const parseOptions$4 = (options) => !options ? {} : typeof options !== "object" ? { loose: true } : opts.filter((k) => options[k]).reduce((options2, k) => {
  options2[k] = true;
  return options2;
}, {});
var parseOptions_1 = parseOptions$4;
const numeric = /^[0-9]+$/;
const compareIdentifiers$1 = (a, b) => {
  const anum = numeric.test(a);
  const bnum = numeric.test(b);
  if (anum && bnum) {
    a = +a;
    b = +b;
  }
  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);
var identifiers = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
const debug$2 = debug_1;
const { MAX_LENGTH: MAX_LENGTH$1, MAX_SAFE_INTEGER } = constants;
const { re: re$4, t: t$4 } = re$5.exports;
const parseOptions$3 = parseOptions_1;
const { compareIdentifiers } = identifiers;
class SemVer$e {
  constructor(version, options) {
    options = parseOptions$3(options);
    if (version instanceof SemVer$e) {
      if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError(`Invalid Version: ${version}`);
    }
    if (version.length > MAX_LENGTH$1) {
      throw new TypeError(`version is longer than ${MAX_LENGTH$1} characters`);
    }
    debug$2("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    const m2 = version.trim().match(options.loose ? re$4[t$4.LOOSE] : re$4[t$4.FULL]);
    if (!m2) {
      throw new TypeError(`Invalid Version: ${version}`);
    }
    this.raw = version;
    this.major = +m2[1];
    this.minor = +m2[2];
    this.patch = +m2[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m2[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m2[4].split(".").map((id2) => {
        if (/^[0-9]+$/.test(id2)) {
          const num = +id2;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id2;
      });
    }
    this.build = m2[5] ? m2[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join(".")}`;
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug$2("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer$e)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer$e(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer$e)) {
      other = new SemVer$e(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  }
  comparePre(other) {
    if (!(other instanceof SemVer$e)) {
      other = new SemVer$e(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    let i2 = 0;
    do {
      const a = this.prerelease[i2];
      const b = other.prerelease[i2];
      debug$2("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer$e)) {
      other = new SemVer$e(other, this.options);
    }
    let i2 = 0;
    do {
      const a = this.build[i2];
      const b = other.build[i2];
      debug$2("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  }
  inc(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          let i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error(`invalid increment argument: ${release}`);
    }
    this.format();
    this.raw = this.version;
    return this;
  }
}
var semver$1 = SemVer$e;
const { MAX_LENGTH } = constants;
const { re: re$3, t: t$3 } = re$5.exports;
const SemVer$d = semver$1;
const parseOptions$2 = parseOptions_1;
const parse$5 = (version, options) => {
  options = parseOptions$2(options);
  if (version instanceof SemVer$d) {
    return version;
  }
  if (typeof version !== "string") {
    return null;
  }
  if (version.length > MAX_LENGTH) {
    return null;
  }
  const r = options.loose ? re$3[t$3.LOOSE] : re$3[t$3.FULL];
  if (!r.test(version)) {
    return null;
  }
  try {
    return new SemVer$d(version, options);
  } catch (er) {
    return null;
  }
};
var parse_1 = parse$5;
const parse$4 = parse_1;
const valid$1 = (version, options) => {
  const v = parse$4(version, options);
  return v ? v.version : null;
};
var valid_1 = valid$1;
const parse$3 = parse_1;
const clean = (version, options) => {
  const s2 = parse$3(version.trim().replace(/^[=v]+/, ""), options);
  return s2 ? s2.version : null;
};
var clean_1 = clean;
const SemVer$c = semver$1;
const inc = (version, release, options, identifier) => {
  if (typeof options === "string") {
    identifier = options;
    options = void 0;
  }
  try {
    return new SemVer$c(version, options).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
};
var inc_1 = inc;
const SemVer$b = semver$1;
const compare$a = (a, b, loose) => new SemVer$b(a, loose).compare(new SemVer$b(b, loose));
var compare_1 = compare$a;
const compare$9 = compare_1;
const eq$2 = (a, b, loose) => compare$9(a, b, loose) === 0;
var eq_1 = eq$2;
const parse$2 = parse_1;
const eq$1 = eq_1;
const diff = (version1, version2) => {
  if (eq$1(version1, version2)) {
    return null;
  } else {
    const v1 = parse$2(version1);
    const v2 = parse$2(version2);
    const hasPre = v1.prerelease.length || v2.prerelease.length;
    const prefix = hasPre ? "pre" : "";
    const defaultResult = hasPre ? "prerelease" : "";
    for (const key in v1) {
      if (key === "major" || key === "minor" || key === "patch") {
        if (v1[key] !== v2[key]) {
          return prefix + key;
        }
      }
    }
    return defaultResult;
  }
};
var diff_1 = diff;
const SemVer$a = semver$1;
const major = (a, loose) => new SemVer$a(a, loose).major;
var major_1 = major;
const SemVer$9 = semver$1;
const minor = (a, loose) => new SemVer$9(a, loose).minor;
var minor_1 = minor;
const SemVer$8 = semver$1;
const patch = (a, loose) => new SemVer$8(a, loose).patch;
var patch_1 = patch;
const parse$1 = parse_1;
const prerelease = (version, options) => {
  const parsed = parse$1(version, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
var prerelease_1 = prerelease;
const compare$8 = compare_1;
const rcompare = (a, b, loose) => compare$8(b, a, loose);
var rcompare_1 = rcompare;
const compare$7 = compare_1;
const compareLoose = (a, b) => compare$7(a, b, true);
var compareLoose_1 = compareLoose;
const SemVer$7 = semver$1;
const compareBuild$2 = (a, b, loose) => {
  const versionA = new SemVer$7(a, loose);
  const versionB = new SemVer$7(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
var compareBuild_1 = compareBuild$2;
const compareBuild$1 = compareBuild_1;
const sort = (list, loose) => list.sort((a, b) => compareBuild$1(a, b, loose));
var sort_1 = sort;
const compareBuild = compareBuild_1;
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
var rsort_1 = rsort;
const compare$6 = compare_1;
const gt$3 = (a, b, loose) => compare$6(a, b, loose) > 0;
var gt_1 = gt$3;
const compare$5 = compare_1;
const lt$2 = (a, b, loose) => compare$5(a, b, loose) < 0;
var lt_1 = lt$2;
const compare$4 = compare_1;
const neq$1 = (a, b, loose) => compare$4(a, b, loose) !== 0;
var neq_1 = neq$1;
const compare$3 = compare_1;
const gte$2 = (a, b, loose) => compare$3(a, b, loose) >= 0;
var gte_1 = gte$2;
const compare$2 = compare_1;
const lte$2 = (a, b, loose) => compare$2(a, b, loose) <= 0;
var lte_1 = lte$2;
const eq = eq_1;
const neq = neq_1;
const gt$2 = gt_1;
const gte$1 = gte_1;
const lt$1 = lt_1;
const lte$1 = lte_1;
const cmp$1 = (a, op, b, loose) => {
  switch (op) {
    case "===":
      if (typeof a === "object")
        a = a.version;
      if (typeof b === "object")
        b = b.version;
      return a === b;
    case "!==":
      if (typeof a === "object")
        a = a.version;
      if (typeof b === "object")
        b = b.version;
      return a !== b;
    case "":
    case "=":
    case "==":
      return eq(a, b, loose);
    case "!=":
      return neq(a, b, loose);
    case ">":
      return gt$2(a, b, loose);
    case ">=":
      return gte$1(a, b, loose);
    case "<":
      return lt$1(a, b, loose);
    case "<=":
      return lte$1(a, b, loose);
    default:
      throw new TypeError(`Invalid operator: ${op}`);
  }
};
var cmp_1 = cmp$1;
const SemVer$6 = semver$1;
const parse = parse_1;
const { re: re$2, t: t$2 } = re$5.exports;
const coerce = (version, options) => {
  if (version instanceof SemVer$6) {
    return version;
  }
  if (typeof version === "number") {
    version = String(version);
  }
  if (typeof version !== "string") {
    return null;
  }
  options = options || {};
  let match = null;
  if (!options.rtl) {
    match = version.match(re$2[t$2.COERCE]);
  } else {
    let next;
    while ((next = re$2[t$2.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      re$2[t$2.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
    }
    re$2[t$2.COERCERTL].lastIndex = -1;
  }
  if (match === null)
    return null;
  return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
};
var coerce_1 = coerce;
class Range$a {
  constructor(range2, options) {
    options = parseOptions$1(options);
    if (range2 instanceof Range$a) {
      if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
        return range2;
      } else {
        return new Range$a(range2.raw, options);
      }
    }
    if (range2 instanceof Comparator$3) {
      this.raw = range2.value;
      this.set = [[range2]];
      this.format();
      return this;
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range2;
    this.set = range2.split(/\s*\|\|\s*/).map((range3) => this.parseRange(range3.trim())).filter((c) => c.length);
    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${range2}`);
    }
    if (this.set.length > 1) {
      const first = this.set[0];
      this.set = this.set.filter((c) => !isNullSet(c[0]));
      if (this.set.length === 0)
        this.set = [first];
      else if (this.set.length > 1) {
        for (const c of this.set) {
          if (c.length === 1 && isAny(c[0])) {
            this.set = [c];
            break;
          }
        }
      }
    }
    this.format();
  }
  format() {
    this.range = this.set.map((comps) => {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  }
  toString() {
    return this.range;
  }
  parseRange(range2) {
    range2 = range2.trim();
    const memoOpts = Object.keys(this.options).join(",");
    const memoKey = `parseRange:${memoOpts}:${range2}`;
    const cached = cache.get(memoKey);
    if (cached)
      return cached;
    const loose = this.options.loose;
    const hr = loose ? re$1[t$1.HYPHENRANGELOOSE] : re$1[t$1.HYPHENRANGE];
    range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
    debug$1("hyphen replace", range2);
    range2 = range2.replace(re$1[t$1.COMPARATORTRIM], comparatorTrimReplace);
    debug$1("comparator trim", range2, re$1[t$1.COMPARATORTRIM]);
    range2 = range2.replace(re$1[t$1.TILDETRIM], tildeTrimReplace);
    range2 = range2.replace(re$1[t$1.CARETTRIM], caretTrimReplace);
    range2 = range2.split(/\s+/).join(" ");
    const compRe = loose ? re$1[t$1.COMPARATORLOOSE] : re$1[t$1.COMPARATOR];
    const rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator$3(comp, this.options));
    rangeList.length;
    const rangeMap = new Map();
    for (const comp of rangeList) {
      if (isNullSet(comp))
        return [comp];
      rangeMap.set(comp.value, comp);
    }
    if (rangeMap.size > 1 && rangeMap.has(""))
      rangeMap.delete("");
    const result = [...rangeMap.values()];
    cache.set(memoKey, result);
    return result;
  }
  intersects(range2, options) {
    if (!(range2 instanceof Range$a)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some((thisComparators) => {
      return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
        return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
          return rangeComparators.every((rangeComparator) => {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  }
  test(version) {
    if (!version) {
      return false;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer$5(version, this.options);
      } catch (er) {
        return false;
      }
    }
    for (let i2 = 0; i2 < this.set.length; i2++) {
      if (testSet(this.set[i2], version, this.options)) {
        return true;
      }
    }
    return false;
  }
}
var range = Range$a;
const LRU = lruCache;
const cache = new LRU({ max: 1e3 });
const parseOptions$1 = parseOptions_1;
const Comparator$3 = comparator;
const debug$1 = debug_1;
const SemVer$5 = semver$1;
const {
  re: re$1,
  t: t$1,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace
} = re$5.exports;
const isNullSet = (c) => c.value === "<0.0.0-0";
const isAny = (c) => c.value === "";
const isSatisfiable = (comparators, options) => {
  let result = true;
  const remainingComparators = comparators.slice();
  let testComparator = remainingComparators.pop();
  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options);
    });
    testComparator = remainingComparators.pop();
  }
  return result;
};
const parseComparator = (comp, options) => {
  debug$1("comp", comp, options);
  comp = replaceCarets(comp, options);
  debug$1("caret", comp);
  comp = replaceTildes(comp, options);
  debug$1("tildes", comp);
  comp = replaceXRanges(comp, options);
  debug$1("xrange", comp);
  comp = replaceStars(comp, options);
  debug$1("stars", comp);
  return comp;
};
const isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
const replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
  return replaceTilde(comp2, options);
}).join(" ");
const replaceTilde = (comp, options) => {
  const r = options.loose ? re$1[t$1.TILDELOOSE] : re$1[t$1.TILDE];
  return comp.replace(r, (_, M, m2, p, pr) => {
    debug$1("tilde", comp, _, M, m2, p, pr);
    let ret;
    if (isX(M)) {
      ret = "";
    } else if (isX(m2)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
    } else if (isX(p)) {
      ret = `>=${M}.${m2}.0 <${M}.${+m2 + 1}.0-0`;
    } else if (pr) {
      debug$1("replaceTilde pr", pr);
      ret = `>=${M}.${m2}.${p}-${pr} <${M}.${+m2 + 1}.0-0`;
    } else {
      ret = `>=${M}.${m2}.${p} <${M}.${+m2 + 1}.0-0`;
    }
    debug$1("tilde return", ret);
    return ret;
  });
};
const replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
  return replaceCaret(comp2, options);
}).join(" ");
const replaceCaret = (comp, options) => {
  debug$1("caret", comp, options);
  const r = options.loose ? re$1[t$1.CARETLOOSE] : re$1[t$1.CARET];
  const z = options.includePrerelease ? "-0" : "";
  return comp.replace(r, (_, M, m2, p, pr) => {
    debug$1("caret", comp, _, M, m2, p, pr);
    let ret;
    if (isX(M)) {
      ret = "";
    } else if (isX(m2)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
    } else if (isX(p)) {
      if (M === "0") {
        ret = `>=${M}.${m2}.0${z} <${M}.${+m2 + 1}.0-0`;
      } else {
        ret = `>=${M}.${m2}.0${z} <${+M + 1}.0.0-0`;
      }
    } else if (pr) {
      debug$1("replaceCaret pr", pr);
      if (M === "0") {
        if (m2 === "0") {
          ret = `>=${M}.${m2}.${p}-${pr} <${M}.${m2}.${+p + 1}-0`;
        } else {
          ret = `>=${M}.${m2}.${p}-${pr} <${M}.${+m2 + 1}.0-0`;
        }
      } else {
        ret = `>=${M}.${m2}.${p}-${pr} <${+M + 1}.0.0-0`;
      }
    } else {
      debug$1("no pr");
      if (M === "0") {
        if (m2 === "0") {
          ret = `>=${M}.${m2}.${p}${z} <${M}.${m2}.${+p + 1}-0`;
        } else {
          ret = `>=${M}.${m2}.${p}${z} <${M}.${+m2 + 1}.0-0`;
        }
      } else {
        ret = `>=${M}.${m2}.${p} <${+M + 1}.0.0-0`;
      }
    }
    debug$1("caret return", ret);
    return ret;
  });
};
const replaceXRanges = (comp, options) => {
  debug$1("replaceXRanges", comp, options);
  return comp.split(/\s+/).map((comp2) => {
    return replaceXRange(comp2, options);
  }).join(" ");
};
const replaceXRange = (comp, options) => {
  comp = comp.trim();
  const r = options.loose ? re$1[t$1.XRANGELOOSE] : re$1[t$1.XRANGE];
  return comp.replace(r, (ret, gtlt, M, m2, p, pr) => {
    debug$1("xRange", comp, ret, gtlt, M, m2, p, pr);
    const xM = isX(M);
    const xm = xM || isX(m2);
    const xp = xm || isX(p);
    const anyX = xp;
    if (gtlt === "=" && anyX) {
      gtlt = "";
    }
    pr = options.includePrerelease ? "-0" : "";
    if (xM) {
      if (gtlt === ">" || gtlt === "<") {
        ret = "<0.0.0-0";
      } else {
        ret = "*";
      }
    } else if (gtlt && anyX) {
      if (xm) {
        m2 = 0;
      }
      p = 0;
      if (gtlt === ">") {
        gtlt = ">=";
        if (xm) {
          M = +M + 1;
          m2 = 0;
          p = 0;
        } else {
          m2 = +m2 + 1;
          p = 0;
        }
      } else if (gtlt === "<=") {
        gtlt = "<";
        if (xm) {
          M = +M + 1;
        } else {
          m2 = +m2 + 1;
        }
      }
      if (gtlt === "<")
        pr = "-0";
      ret = `${gtlt + M}.${m2}.${p}${pr}`;
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
    } else if (xp) {
      ret = `>=${M}.${m2}.0${pr} <${M}.${+m2 + 1}.0-0`;
    }
    debug$1("xRange return", ret);
    return ret;
  });
};
const replaceStars = (comp, options) => {
  debug$1("replaceStars", comp, options);
  return comp.trim().replace(re$1[t$1.STAR], "");
};
const replaceGTE0 = (comp, options) => {
  debug$1("replaceGTE0", comp, options);
  return comp.trim().replace(re$1[options.includePrerelease ? t$1.GTE0PRE : t$1.GTE0], "");
};
const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
  if (isX(fM)) {
    from = "";
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
  } else if (fpr) {
    from = `>=${from}`;
  } else {
    from = `>=${from}${incPr ? "-0" : ""}`;
  }
  if (isX(tM)) {
    to = "";
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`;
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`;
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`;
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`;
  } else {
    to = `<=${to}`;
  }
  return `${from} ${to}`.trim();
};
const testSet = (set2, version, options) => {
  for (let i2 = 0; i2 < set2.length; i2++) {
    if (!set2[i2].test(version)) {
      return false;
    }
  }
  if (version.prerelease.length && !options.includePrerelease) {
    for (let i2 = 0; i2 < set2.length; i2++) {
      debug$1(set2[i2].semver);
      if (set2[i2].semver === Comparator$3.ANY) {
        continue;
      }
      if (set2[i2].semver.prerelease.length > 0) {
        const allowed = set2[i2].semver;
        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
          return true;
        }
      }
    }
    return false;
  }
  return true;
};
const ANY$2 = Symbol("SemVer ANY");
class Comparator$2 {
  static get ANY() {
    return ANY$2;
  }
  constructor(comp, options) {
    options = parseOptions(options);
    if (comp instanceof Comparator$2) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    debug("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY$2) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug("comp", this);
  }
  parse(comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
    const m2 = comp.match(r);
    if (!m2) {
      throw new TypeError(`Invalid comparator: ${comp}`);
    }
    this.operator = m2[1] !== void 0 ? m2[1] : "";
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m2[2]) {
      this.semver = ANY$2;
    } else {
      this.semver = new SemVer$4(m2[2], this.options.loose);
    }
  }
  toString() {
    return this.value;
  }
  test(version) {
    debug("Comparator.test", version, this.options.loose);
    if (this.semver === ANY$2 || version === ANY$2) {
      return true;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer$4(version, this.options);
      } catch (er) {
        return false;
      }
    }
    return cmp(version, this.operator, this.semver, this.options);
  }
  intersects(comp, options) {
    if (!(comp instanceof Comparator$2)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (this.operator === "") {
      if (this.value === "") {
        return true;
      }
      return new Range$9(comp.value, options).test(this.value);
    } else if (comp.operator === "") {
      if (comp.value === "") {
        return true;
      }
      return new Range$9(this.value, options).test(comp.semver);
    }
    const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    const sameSemVer = this.semver.version === comp.semver.version;
    const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
    const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  }
}
var comparator = Comparator$2;
const parseOptions = parseOptions_1;
const { re, t } = re$5.exports;
const cmp = cmp_1;
const debug = debug_1;
const SemVer$4 = semver$1;
const Range$9 = range;
const Range$8 = range;
const satisfies$3 = (version, range2, options) => {
  try {
    range2 = new Range$8(range2, options);
  } catch (er) {
    return false;
  }
  return range2.test(version);
};
var satisfies_1 = satisfies$3;
const Range$7 = range;
const toComparators = (range2, options) => new Range$7(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
var toComparators_1 = toComparators;
const SemVer$3 = semver$1;
const Range$6 = range;
const maxSatisfying = (versions, range2, options) => {
  let max = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$6(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!max || maxSV.compare(v) === -1) {
        max = v;
        maxSV = new SemVer$3(max, options);
      }
    }
  });
  return max;
};
var maxSatisfying_1 = maxSatisfying;
const SemVer$2 = semver$1;
const Range$5 = range;
const minSatisfying = (versions, range2, options) => {
  let min = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$5(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!min || minSV.compare(v) === 1) {
        min = v;
        minSV = new SemVer$2(min, options);
      }
    }
  });
  return min;
};
var minSatisfying_1 = minSatisfying;
const SemVer$1 = semver$1;
const Range$4 = range;
const gt$1 = gt_1;
const minVersion = (range2, loose) => {
  range2 = new Range$4(range2, loose);
  let minver = new SemVer$1("0.0.0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = new SemVer$1("0.0.0-0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = null;
  for (let i2 = 0; i2 < range2.set.length; ++i2) {
    const comparators = range2.set[i2];
    let setMin = null;
    comparators.forEach((comparator2) => {
      const compver = new SemVer$1(comparator2.semver.version);
      switch (comparator2.operator) {
        case ">":
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
        case "":
        case ">=":
          if (!setMin || gt$1(compver, setMin)) {
            setMin = compver;
          }
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${comparator2.operator}`);
      }
    });
    if (setMin && (!minver || gt$1(minver, setMin)))
      minver = setMin;
  }
  if (minver && range2.test(minver)) {
    return minver;
  }
  return null;
};
var minVersion_1 = minVersion;
const Range$3 = range;
const validRange = (range2, options) => {
  try {
    return new Range$3(range2, options).range || "*";
  } catch (er) {
    return null;
  }
};
var valid = validRange;
const SemVer = semver$1;
const Comparator$1 = comparator;
const { ANY: ANY$1 } = Comparator$1;
const Range$2 = range;
const satisfies$2 = satisfies_1;
const gt = gt_1;
const lt = lt_1;
const lte = lte_1;
const gte = gte_1;
const outside$2 = (version, range2, hilo, options) => {
  version = new SemVer(version, options);
  range2 = new Range$2(range2, options);
  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case ">":
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = ">";
      ecomp = ">=";
      break;
    case "<":
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = "<";
      ecomp = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (satisfies$2(version, range2, options)) {
    return false;
  }
  for (let i2 = 0; i2 < range2.set.length; ++i2) {
    const comparators = range2.set[i2];
    let high = null;
    let low = null;
    comparators.forEach((comparator2) => {
      if (comparator2.semver === ANY$1) {
        comparator2 = new Comparator$1(">=0.0.0");
      }
      high = high || comparator2;
      low = low || comparator2;
      if (gtfn(comparator2.semver, high.semver, options)) {
        high = comparator2;
      } else if (ltfn(comparator2.semver, low.semver, options)) {
        low = comparator2;
      }
    });
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }
    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }
  return true;
};
var outside_1 = outside$2;
const outside$1 = outside_1;
const gtr = (version, range2, options) => outside$1(version, range2, ">", options);
var gtr_1 = gtr;
const outside = outside_1;
const ltr = (version, range2, options) => outside(version, range2, "<", options);
var ltr_1 = ltr;
const Range$1 = range;
const intersects = (r1, r2, options) => {
  r1 = new Range$1(r1, options);
  r2 = new Range$1(r2, options);
  return r1.intersects(r2);
};
var intersects_1 = intersects;
const satisfies$1 = satisfies_1;
const compare$1 = compare_1;
var simplify = (versions, range2, options) => {
  const set2 = [];
  let min = null;
  let prev = null;
  const v = versions.sort((a, b) => compare$1(a, b, options));
  for (const version of v) {
    const included = satisfies$1(version, range2, options);
    if (included) {
      prev = version;
      if (!min)
        min = version;
    } else {
      if (prev) {
        set2.push([min, prev]);
      }
      prev = null;
      min = null;
    }
  }
  if (min)
    set2.push([min, null]);
  const ranges = [];
  for (const [min2, max] of set2) {
    if (min2 === max)
      ranges.push(min2);
    else if (!max && min2 === v[0])
      ranges.push("*");
    else if (!max)
      ranges.push(`>=${min2}`);
    else if (min2 === v[0])
      ranges.push(`<=${max}`);
    else
      ranges.push(`${min2} - ${max}`);
  }
  const simplified = ranges.join(" || ");
  const original = typeof range2.raw === "string" ? range2.raw : String(range2);
  return simplified.length < original.length ? simplified : range2;
};
const Range = range;
const Comparator = comparator;
const { ANY } = Comparator;
const satisfies = satisfies_1;
const compare = compare_1;
const subset = (sub, dom, options = {}) => {
  if (sub === dom)
    return true;
  sub = new Range(sub, options);
  dom = new Range(dom, options);
  let sawNonNull = false;
  OUTER:
    for (const simpleSub of sub.set) {
      for (const simpleDom of dom.set) {
        const isSub = simpleSubset(simpleSub, simpleDom, options);
        sawNonNull = sawNonNull || isSub !== null;
        if (isSub)
          continue OUTER;
      }
      if (sawNonNull)
        return false;
    }
  return true;
};
const simpleSubset = (sub, dom, options) => {
  if (sub === dom)
    return true;
  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY)
      return true;
    else if (options.includePrerelease)
      sub = [new Comparator(">=0.0.0-0")];
    else
      sub = [new Comparator(">=0.0.0")];
  }
  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease)
      return true;
    else
      dom = [new Comparator(">=0.0.0")];
  }
  const eqSet = new Set();
  let gt2, lt2;
  for (const c of sub) {
    if (c.operator === ">" || c.operator === ">=")
      gt2 = higherGT(gt2, c, options);
    else if (c.operator === "<" || c.operator === "<=")
      lt2 = lowerLT(lt2, c, options);
    else
      eqSet.add(c.semver);
  }
  if (eqSet.size > 1)
    return null;
  let gtltComp;
  if (gt2 && lt2) {
    gtltComp = compare(gt2.semver, lt2.semver, options);
    if (gtltComp > 0)
      return null;
    else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<="))
      return null;
  }
  for (const eq2 of eqSet) {
    if (gt2 && !satisfies(eq2, String(gt2), options))
      return null;
    if (lt2 && !satisfies(eq2, String(lt2), options))
      return null;
    for (const c of dom) {
      if (!satisfies(eq2, String(c), options))
        return false;
    }
    return true;
  }
  let higher, lower;
  let hasDomLT, hasDomGT;
  let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
  let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }
  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
    hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
    if (gt2) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false;
        }
      }
      if (c.operator === ">" || c.operator === ">=") {
        higher = higherGT(gt2, c, options);
        if (higher === c && higher !== gt2)
          return false;
      } else if (gt2.operator === ">=" && !satisfies(gt2.semver, String(c), options))
        return false;
    }
    if (lt2) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false;
        }
      }
      if (c.operator === "<" || c.operator === "<=") {
        lower = lowerLT(lt2, c, options);
        if (lower === c && lower !== lt2)
          return false;
      } else if (lt2.operator === "<=" && !satisfies(lt2.semver, String(c), options))
        return false;
    }
    if (!c.operator && (lt2 || gt2) && gtltComp !== 0)
      return false;
  }
  if (gt2 && hasDomLT && !lt2 && gtltComp !== 0)
    return false;
  if (lt2 && hasDomGT && !gt2 && gtltComp !== 0)
    return false;
  if (needDomGTPre || needDomLTPre)
    return false;
  return true;
};
const higherGT = (a, b, options) => {
  if (!a)
    return b;
  const comp = compare(a.semver, b.semver, options);
  return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
};
const lowerLT = (a, b, options) => {
  if (!a)
    return b;
  const comp = compare(a.semver, b.semver, options);
  return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
};
var subset_1 = subset;
const internalRe = re$5.exports;
var semver = {
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  SemVer: semver$1,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers,
  parse: parse_1,
  valid: valid_1,
  clean: clean_1,
  inc: inc_1,
  diff: diff_1,
  major: major_1,
  minor: minor_1,
  patch: patch_1,
  prerelease: prerelease_1,
  compare: compare_1,
  rcompare: rcompare_1,
  compareLoose: compareLoose_1,
  compareBuild: compareBuild_1,
  sort: sort_1,
  rsort: rsort_1,
  gt: gt_1,
  lt: lt_1,
  eq: eq_1,
  neq: neq_1,
  gte: gte_1,
  lte: lte_1,
  cmp: cmp_1,
  coerce: coerce_1,
  Comparator: comparator,
  Range: range,
  satisfies: satisfies_1,
  toComparators: toComparators_1,
  maxSatisfying: maxSatisfying_1,
  minSatisfying: minSatisfying_1,
  minVersion: minVersion_1,
  validRange: valid,
  outside: outside_1,
  gtr: gtr_1,
  ltr: ltr_1,
  intersects: intersects_1,
  simplifyRange: simplify,
  subset: subset_1
};
var onetime$1 = { exports: {} };
var mimicFn$2 = { exports: {} };
const mimicFn$1 = (to, from) => {
  for (const prop of Reflect.ownKeys(from)) {
    Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
  }
  return to;
};
mimicFn$2.exports = mimicFn$1;
mimicFn$2.exports.default = mimicFn$1;
const mimicFn = mimicFn$2.exports;
const calledFunctions = new WeakMap();
const onetime = (function_, options = {}) => {
  if (typeof function_ !== "function") {
    throw new TypeError("Expected a function");
  }
  let returnValue;
  let callCount = 0;
  const functionName = function_.displayName || function_.name || "<anonymous>";
  const onetime2 = function(...arguments_) {
    calledFunctions.set(onetime2, ++callCount);
    if (callCount === 1) {
      returnValue = function_.apply(this, arguments_);
      function_ = null;
    } else if (options.throw === true) {
      throw new Error(`Function \`${functionName}\` can only be called once`);
    }
    return returnValue;
  };
  mimicFn(onetime2, function_);
  calledFunctions.set(onetime2, callCount);
  return onetime2;
};
onetime$1.exports = onetime;
onetime$1.exports.default = onetime;
onetime$1.exports.callCount = (function_) => {
  if (!calledFunctions.has(function_)) {
    throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
  }
  return calledFunctions.get(function_);
};
(function(module, exports) {
  var __classPrivateFieldSet = commonjsGlobal && commonjsGlobal.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = commonjsGlobal && commonjsGlobal.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _a, _b;
  var _Conf_validator, _Conf_encryptionKey, _Conf_options, _Conf_defaultValues;
  Object.defineProperty(exports, "__esModule", { value: true });
  const util_12 = require$$2__default$1["default"];
  const fs2 = require$$1__default$1["default"];
  const path2 = require$$1__default$2["default"];
  const crypto = require$$0__default$3["default"];
  const assert2 = require$$2__default["default"];
  const events_12 = require$$0__default$2["default"];
  const dotProp$1 = dotProp;
  const pkgUp$1 = pkgUp.exports;
  const envPaths2 = envPaths$1.exports;
  const atomically = dist$1;
  const ajv_1 = ajv.exports;
  const ajv_formats_1 = dist.exports;
  const debounceFn$1 = debounceFn;
  const semver$12 = semver;
  const onetime2 = onetime$1.exports;
  const encryptionAlgorithm = "aes-256-cbc";
  const createPlainObject = () => {
    return Object.create(null);
  };
  const isExist = (data) => {
    return data !== void 0 && data !== null;
  };
  let parentDir = "";
  try {
    delete require.cache[__filename];
    parentDir = path2.dirname((_b = (_a = module.parent) === null || _a === void 0 ? void 0 : _a.filename) !== null && _b !== void 0 ? _b : ".");
  } catch (_c) {
  }
  const checkValueType = (key, value) => {
    const nonJsonTypes = new Set([
      "undefined",
      "symbol",
      "function"
    ]);
    const type2 = typeof value;
    if (nonJsonTypes.has(type2)) {
      throw new TypeError(`Setting a value of type \`${type2}\` for key \`${key}\` is not allowed as it's not supported by JSON`);
    }
  };
  const INTERNAL_KEY = "__internal__";
  const MIGRATION_KEY = `${INTERNAL_KEY}.migrations.version`;
  class Conf2 {
    constructor(partialOptions = {}) {
      var _a2;
      _Conf_validator.set(this, void 0);
      _Conf_encryptionKey.set(this, void 0);
      _Conf_options.set(this, void 0);
      _Conf_defaultValues.set(this, {});
      this._deserialize = (value) => JSON.parse(value);
      this._serialize = (value) => JSON.stringify(value, void 0, "	");
      const options = __spreadValues({
        configName: "config",
        fileExtension: "json",
        projectSuffix: "nodejs",
        clearInvalidConfig: false,
        accessPropertiesByDotNotation: true
      }, partialOptions);
      const getPackageData = onetime2(() => {
        const packagePath = pkgUp$1.sync({ cwd: parentDir });
        const packageData = packagePath && JSON.parse(fs2.readFileSync(packagePath, "utf8"));
        return packageData !== null && packageData !== void 0 ? packageData : {};
      });
      if (!options.cwd) {
        if (!options.projectName) {
          options.projectName = getPackageData().name;
        }
        if (!options.projectName) {
          throw new Error("Project name could not be inferred. Please specify the `projectName` option.");
        }
        options.cwd = envPaths2(options.projectName, { suffix: options.projectSuffix }).config;
      }
      __classPrivateFieldSet(this, _Conf_options, options, "f");
      if (options.schema) {
        if (typeof options.schema !== "object") {
          throw new TypeError("The `schema` option must be an object.");
        }
        const ajv2 = new ajv_1.default({
          allErrors: true,
          useDefaults: true
        });
        ajv_formats_1.default(ajv2);
        const schema2 = {
          type: "object",
          properties: options.schema
        };
        __classPrivateFieldSet(this, _Conf_validator, ajv2.compile(schema2), "f");
        for (const [key, value] of Object.entries(options.schema)) {
          if (value === null || value === void 0 ? void 0 : value.default) {
            __classPrivateFieldGet(this, _Conf_defaultValues, "f")[key] = value.default;
          }
        }
      }
      if (options.defaults) {
        __classPrivateFieldSet(this, _Conf_defaultValues, __spreadValues(__spreadValues({}, __classPrivateFieldGet(this, _Conf_defaultValues, "f")), options.defaults), "f");
      }
      if (options.serialize) {
        this._serialize = options.serialize;
      }
      if (options.deserialize) {
        this._deserialize = options.deserialize;
      }
      this.events = new events_12.EventEmitter();
      __classPrivateFieldSet(this, _Conf_encryptionKey, options.encryptionKey, "f");
      const fileExtension = options.fileExtension ? `.${options.fileExtension}` : "";
      this.path = path2.resolve(options.cwd, `${(_a2 = options.configName) !== null && _a2 !== void 0 ? _a2 : "config"}${fileExtension}`);
      const fileStore = this.store;
      const store2 = Object.assign(createPlainObject(), options.defaults, fileStore);
      this._validate(store2);
      try {
        assert2.deepEqual(fileStore, store2);
      } catch (_b2) {
        this.store = store2;
      }
      if (options.watch) {
        this._watch();
      }
      if (options.migrations) {
        if (!options.projectVersion) {
          options.projectVersion = getPackageData().version;
        }
        if (!options.projectVersion) {
          throw new Error("Project version could not be inferred. Please specify the `projectVersion` option.");
        }
        this._migrate(options.migrations, options.projectVersion);
      }
    }
    get(key, defaultValue) {
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        return this._get(key, defaultValue);
      }
      const { store: store2 } = this;
      return key in store2 ? store2[key] : defaultValue;
    }
    set(key, value) {
      if (typeof key !== "string" && typeof key !== "object") {
        throw new TypeError(`Expected \`key\` to be of type \`string\` or \`object\`, got ${typeof key}`);
      }
      if (typeof key !== "object" && value === void 0) {
        throw new TypeError("Use `delete()` to clear values");
      }
      if (this._containsReservedKey(key)) {
        throw new TypeError(`Please don't use the ${INTERNAL_KEY} key, as it's used to manage this module internal operations.`);
      }
      const { store: store2 } = this;
      const set2 = (key2, value2) => {
        checkValueType(key2, value2);
        if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
          dotProp$1.set(store2, key2, value2);
        } else {
          store2[key2] = value2;
        }
      };
      if (typeof key === "object") {
        const object = key;
        for (const [key2, value2] of Object.entries(object)) {
          set2(key2, value2);
        }
      } else {
        set2(key, value);
      }
      this.store = store2;
    }
    has(key) {
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        return dotProp$1.has(this.store, key);
      }
      return key in this.store;
    }
    reset(...keys) {
      for (const key of keys) {
        if (isExist(__classPrivateFieldGet(this, _Conf_defaultValues, "f")[key])) {
          this.set(key, __classPrivateFieldGet(this, _Conf_defaultValues, "f")[key]);
        }
      }
    }
    delete(key) {
      const { store: store2 } = this;
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        dotProp$1.delete(store2, key);
      } else {
        delete store2[key];
      }
      this.store = store2;
    }
    clear() {
      this.store = createPlainObject();
      for (const key of Object.keys(__classPrivateFieldGet(this, _Conf_defaultValues, "f"))) {
        this.reset(key);
      }
    }
    onDidChange(key, callback) {
      if (typeof key !== "string") {
        throw new TypeError(`Expected \`key\` to be of type \`string\`, got ${typeof key}`);
      }
      if (typeof callback !== "function") {
        throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof callback}`);
      }
      return this._handleChange(() => this.get(key), callback);
    }
    onDidAnyChange(callback) {
      if (typeof callback !== "function") {
        throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof callback}`);
      }
      return this._handleChange(() => this.store, callback);
    }
    get size() {
      return Object.keys(this.store).length;
    }
    get store() {
      try {
        const data = fs2.readFileSync(this.path, __classPrivateFieldGet(this, _Conf_encryptionKey, "f") ? null : "utf8");
        const dataString = this._encryptData(data);
        const deserializedData = this._deserialize(dataString);
        this._validate(deserializedData);
        return Object.assign(createPlainObject(), deserializedData);
      } catch (error2) {
        if (error2.code === "ENOENT") {
          this._ensureDirectory();
          return createPlainObject();
        }
        if (__classPrivateFieldGet(this, _Conf_options, "f").clearInvalidConfig && error2.name === "SyntaxError") {
          return createPlainObject();
        }
        throw error2;
      }
    }
    set store(value) {
      this._ensureDirectory();
      this._validate(value);
      this._write(value);
      this.events.emit("change");
    }
    *[(_Conf_validator = new WeakMap(), _Conf_encryptionKey = new WeakMap(), _Conf_options = new WeakMap(), _Conf_defaultValues = new WeakMap(), Symbol.iterator)]() {
      for (const [key, value] of Object.entries(this.store)) {
        yield [key, value];
      }
    }
    _encryptData(data) {
      if (!__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
        return data.toString();
      }
      try {
        if (__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
          try {
            if (data.slice(16, 17).toString() === ":") {
              const initializationVector = data.slice(0, 16);
              const password = crypto.pbkdf2Sync(__classPrivateFieldGet(this, _Conf_encryptionKey, "f"), initializationVector.toString(), 1e4, 32, "sha512");
              const decipher = crypto.createDecipheriv(encryptionAlgorithm, password, initializationVector);
              data = Buffer.concat([decipher.update(Buffer.from(data.slice(17))), decipher.final()]).toString("utf8");
            } else {
              const decipher = crypto.createDecipher(encryptionAlgorithm, __classPrivateFieldGet(this, _Conf_encryptionKey, "f"));
              data = Buffer.concat([decipher.update(Buffer.from(data)), decipher.final()]).toString("utf8");
            }
          } catch (_a2) {
          }
        }
      } catch (_b2) {
      }
      return data.toString();
    }
    _handleChange(getter, callback) {
      let currentValue = getter();
      const onChange = () => {
        const oldValue = currentValue;
        const newValue = getter();
        if (util_12.isDeepStrictEqual(newValue, oldValue)) {
          return;
        }
        currentValue = newValue;
        callback.call(this, newValue, oldValue);
      };
      this.events.on("change", onChange);
      return () => this.events.removeListener("change", onChange);
    }
    _validate(data) {
      if (!__classPrivateFieldGet(this, _Conf_validator, "f")) {
        return;
      }
      const valid2 = __classPrivateFieldGet(this, _Conf_validator, "f").call(this, data);
      if (valid2 || !__classPrivateFieldGet(this, _Conf_validator, "f").errors) {
        return;
      }
      const errors2 = __classPrivateFieldGet(this, _Conf_validator, "f").errors.map(({ instancePath, message = "" }) => `\`${instancePath.slice(1)}\` ${message}`);
      throw new Error("Config schema violation: " + errors2.join("; "));
    }
    _ensureDirectory() {
      fs2.mkdirSync(path2.dirname(this.path), { recursive: true });
    }
    _write(value) {
      let data = this._serialize(value);
      if (__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
        const initializationVector = crypto.randomBytes(16);
        const password = crypto.pbkdf2Sync(__classPrivateFieldGet(this, _Conf_encryptionKey, "f"), initializationVector.toString(), 1e4, 32, "sha512");
        const cipher = crypto.createCipheriv(encryptionAlgorithm, password, initializationVector);
        data = Buffer.concat([initializationVector, Buffer.from(":"), cipher.update(Buffer.from(data)), cipher.final()]);
      }
      {
        try {
          atomically.writeFileSync(this.path, data);
        } catch (error2) {
          if (error2.code === "EXDEV") {
            fs2.writeFileSync(this.path, data);
            return;
          }
          throw error2;
        }
      }
    }
    _watch() {
      this._ensureDirectory();
      if (!fs2.existsSync(this.path)) {
        this._write(createPlainObject());
      }
      if (process.platform === "win32") {
        fs2.watch(this.path, { persistent: false }, debounceFn$1(() => {
          this.events.emit("change");
        }, { wait: 100 }));
      } else {
        fs2.watchFile(this.path, { persistent: false }, debounceFn$1(() => {
          this.events.emit("change");
        }, { wait: 5e3 }));
      }
    }
    _migrate(migrations, versionToMigrate) {
      let previousMigratedVersion = this._get(MIGRATION_KEY, "0.0.0");
      const newerVersions = Object.keys(migrations).filter((candidateVersion) => this._shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate));
      let storeBackup = __spreadValues({}, this.store);
      for (const version of newerVersions) {
        try {
          const migration = migrations[version];
          migration(this);
          this._set(MIGRATION_KEY, version);
          previousMigratedVersion = version;
          storeBackup = __spreadValues({}, this.store);
        } catch (error2) {
          this.store = storeBackup;
          throw new Error(`Something went wrong during the migration! Changes applied to the store until this failed migration will be restored. ${error2}`);
        }
      }
      if (this._isVersionInRangeFormat(previousMigratedVersion) || !semver$12.eq(previousMigratedVersion, versionToMigrate)) {
        this._set(MIGRATION_KEY, versionToMigrate);
      }
    }
    _containsReservedKey(key) {
      if (typeof key === "object") {
        const firsKey = Object.keys(key)[0];
        if (firsKey === INTERNAL_KEY) {
          return true;
        }
      }
      if (typeof key !== "string") {
        return false;
      }
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        if (key.startsWith(`${INTERNAL_KEY}.`)) {
          return true;
        }
        return false;
      }
      return false;
    }
    _isVersionInRangeFormat(version) {
      return semver$12.clean(version) === null;
    }
    _shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate) {
      if (this._isVersionInRangeFormat(candidateVersion)) {
        if (previousMigratedVersion !== "0.0.0" && semver$12.satisfies(previousMigratedVersion, candidateVersion)) {
          return false;
        }
        return semver$12.satisfies(versionToMigrate, candidateVersion);
      }
      if (semver$12.lte(candidateVersion, previousMigratedVersion)) {
        return false;
      }
      if (semver$12.gt(candidateVersion, versionToMigrate)) {
        return false;
      }
      return true;
    }
    _get(key, defaultValue) {
      return dotProp$1.get(this.store, key, defaultValue);
    }
    _set(key, value) {
      const { store: store2 } = this;
      dotProp$1.set(store2, key, value);
      this.store = store2;
    }
  }
  exports.default = Conf2;
  module.exports = Conf2;
  module.exports.default = Conf2;
})(source, source.exports);
const path = require$$1__default$2["default"];
const { app, ipcMain, ipcRenderer, shell } = require$$1__default["default"];
const Conf = source.exports;
let isInitialized = false;
const initDataListener = () => {
  if (!ipcMain || !app) {
    throw new Error("Electron Store: You need to call `.initRenderer()` from the main process.");
  }
  const appData = {
    defaultCwd: app.getPath("userData"),
    appVersion: app.getVersion()
  };
  if (isInitialized) {
    return appData;
  }
  ipcMain.on("electron-store-get-data", (event) => {
    event.returnValue = appData;
  });
  isInitialized = true;
  return appData;
};
class ElectronStore extends Conf {
  constructor(options) {
    let defaultCwd;
    let appVersion;
    if (ipcRenderer) {
      const appData = ipcRenderer.sendSync("electron-store-get-data");
      if (!appData) {
        throw new Error("Electron Store: You need to call `.initRenderer()` from the main process.");
      }
      ({ defaultCwd, appVersion } = appData);
    } else if (ipcMain && app) {
      ({ defaultCwd, appVersion } = initDataListener());
    }
    options = __spreadValues({
      name: "config"
    }, options);
    if (!options.projectVersion) {
      options.projectVersion = appVersion;
    }
    if (options.cwd) {
      options.cwd = path.isAbsolute(options.cwd) ? options.cwd : path.join(defaultCwd, options.cwd);
    } else {
      options.cwd = defaultCwd;
    }
    options.configName = options.name;
    delete options.name;
    super(options);
  }
  static initRenderer() {
    initDataListener();
  }
  openInEditor() {
    shell.openPath(this.path);
  }
}
var electronStore = ElectronStore;
const schema$1 = {
  notes: {
    type: "object",
    patternProperties: {
      "[A-Za-z0-9_-]": {
        type: "object",
        properties: {
          id: { type: "string", default: "" },
          title: { type: "string", default: "" },
          content: { type: "object", default: { type: "doc", content: [] } },
          labels: { type: "array", default: [] },
          createdAt: { type: "number", default: Date.now() },
          updatedAt: { type: "number", default: Date.now() },
          isBookmarked: { type: "boolean", default: false },
          isArchived: { type: "boolean", default: false },
          lastCursorPosition: { type: "number", default: 0 }
        }
      }
    }
  },
  labels: {
    type: "array"
  }
};
const store$1 = new electronStore({
  schema: schema$1,
  encryptionKey: {}.VITE_ENCRYPT_KEY
});
const schema = {
  dataDir: {
    type: "string",
    default: require$$1.app.getPath("userData")
  }
};
var settings = new electronStore({ name: "settings", schema, encryptionKey: {}.VITE_ENCRYPT_KEY });
var store = {
  data: store$1,
  settings
};
const isSingleInstance = require$$1.app.requestSingleInstanceLock();
if (!isSingleInstance) {
  require$$1.app.quit();
  process.exit(0);
}
require$$1.app.disableHardwareAcceleration();
const env = { "VITE_DEV_SERVER_URL": "http://localhost:3000/", "BASE_URL": "/", "MODE": "development", "DEV": true, "PROD": false };
{
  require$$1.app.whenReady().then(() => Promise.resolve().then(function() {
    return /* @__PURE__ */ _interopNamespace(require("electron-devtools-installer"));
  })).then(({ default: installExtension, VUEJS3_DEVTOOLS }) => installExtension(VUEJS3_DEVTOOLS, {
    loadExtensionOptions: {
      allowFileAccess: true
    }
  })).catch((e) => console.error("Failed install extension:", e));
}
let mainWindow = null;
const createWindow = async () => {
  mainWindow = new require$$1.BrowserWindow({
    show: false,
    width: 950,
    height: 600,
    webPreferences: {
      preload: require$$1$2.join(__dirname, "../../preload/dist/index.cjs"),
      contextIsolation: env.MODE !== "test",
      enableRemoteModule: env.MODE === "test"
    }
  });
  mainWindow.setMenuBarVisibility(false);
  mainWindow.on("ready-to-show", () => {
    mainWindow == null ? void 0 : mainWindow.show();
    {
      mainWindow == null ? void 0 : mainWindow.webContents.openDevTools();
    }
  });
  mainWindow == null ? void 0 : mainWindow.webContents.on("new-window", function(event, url) {
    event.preventDefault();
    if (url.startsWith("note://"))
      return;
    require$$1.shell.openExternal(url);
  });
  const pageUrl = env.VITE_DEV_SERVER_URL;
  await mainWindow.loadURL(pageUrl);
};
require$$1.app.on("second-instance", () => {
  if (mainWindow) {
    if (mainWindow.isMinimized())
      mainWindow.restore();
    mainWindow.focus();
  }
});
require$$1.app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    require$$1.app.quit();
  }
});
require$$1.app.whenReady().then(async () => {
  require$$1.protocol.registerFileProtocol("assets", (request, callback) => {
    const url = request.url.substr(9);
    const dir = store.settings.get("dataDir");
    const imgPath = `${dir}/notes-assets/${url}`;
    callback({ path: require$$1$2.normalize(imgPath) });
  });
  await lib$1.ensureDir(require$$1$2.join(require$$1.app.getPath("userData"), "notes-assets"));
  await createWindow();
}).catch((e) => console.error("Failed create window:", e));
ipcMain$1.answerRenderer("app:info", () => ({
  name: require$$1.app.getName(),
  version: require$$1.app.getVersion()
}));
ipcMain$1.answerRenderer("dialog:open", (props) => require$$1.dialog.showOpenDialog(props));
ipcMain$1.answerRenderer("dialog:message", (props) => require$$1.dialog.showMessageBox(props));
ipcMain$1.answerRenderer("dialog:save", (props) => require$$1.dialog.showSaveDialog(props));
ipcMain$1.answerRenderer("fs:copy", ({ path: path2, dest }) => lib$1.copy(path2, dest));
ipcMain$1.answerRenderer("fs:output-json", ({ path: path2, data }) => lib$1.outputJson(path2, data));
ipcMain$1.answerRenderer("fs:read-json", (path2) => lib$1.readJson(path2));
ipcMain$1.answerRenderer("fs:ensureDir", (path2) => lib$1.ensureDir(path2));
ipcMain$1.answerRenderer("fs:pathExists", (path2) => lib$1.pathExistsSync(path2));
ipcMain$1.answerRenderer("fs:remove", (path2) => lib$1.remove(path2));
ipcMain$1.answerRenderer("helper:relaunch", (options = {}) => {
  require$$1.app.relaunch(__spreadValues({ args: process.argv.slice(1).concat(["--relaunch"]) }, options));
  require$$1.app.exit(0);
});
ipcMain$1.answerRenderer("helper:get-path", (name) => require$$1.app.getPath(name));
ipcMain$1.answerRenderer("helper:is-dark-theme", () => require$$1.nativeTheme.shouldUseDarkColors);
ipcMain$1.answerRenderer("storage:store", (name) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.store;
});
ipcMain$1.answerRenderer("storage:replace", ({ name, data }) => store[name].store = data);
ipcMain$1.answerRenderer("storage:get", ({ name, key, def: def2 }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.get(key, def2);
});
ipcMain$1.answerRenderer("storage:set", ({ name, key, value }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.set(key, value);
});
ipcMain$1.answerRenderer("storage:delete", ({ name, key }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.delete(key);
});
ipcMain$1.answerRenderer("storage:has", ({ name, key }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.has(key);
});
ipcMain$1.answerRenderer("storage:clear", (name) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.clear();
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguY2pzIiwic291cmNlcyI6WyIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VyaWFsaXplLWVycm9yL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWJldHRlci1pcGMvc291cmNlL3V0aWwuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tYmV0dGVyLWlwYy9zb3VyY2UvcmVuZGVyZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tYmV0dGVyLWlwYy9zb3VyY2UvbWFpbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1iZXR0ZXItaXBjL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3VuaXZlcnNhbGlmeS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9wb2x5ZmlsbHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvbGVnYWN5LXN0cmVhbXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvY2xvbmUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvZ3JhY2VmdWwtZnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2ZzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9ta2RpcnMvdXRpbHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21rZGlycy9tYWtlLWRpci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvbWtkaXJzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi91dGlsL3V0aW1lcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvdXRpbC9zdGF0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5LXN5bmMvY29weS1zeW5jLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5LXN5bmMvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3BhdGgtZXhpc3RzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5L2NvcHkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2NvcHkvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3JlbW92ZS9yaW1yYWYuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3JlbW92ZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW1wdHkvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9maWxlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvbGluay5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL3N5bWxpbmstcGF0aHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9zeW1saW5rLXR5cGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9zeW1saW5rLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanNvbmZpbGUvdXRpbHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanNvbmZpbGUvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2pzb24vanNvbmZpbGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL291dHB1dC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvanNvbi9vdXRwdXQtanNvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvanNvbi9vdXRwdXQtanNvbi1zeW5jLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9qc29uL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9tb3ZlLXN5bmMvbW92ZS1zeW5jLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9tb3ZlLXN5bmMvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21vdmUvbW92ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvbW92ZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L0NhbmNlbGxhdGlvblRva2VuLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQvUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQvaHR0cEV4ZWN1dG9yLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL291dC9wdWJsaXNoT3B0aW9ucy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQvcmZjMjI1M1BhcnNlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQvdXVpZC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXgvbGliL3NheC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQveG1sLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL291dC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZnMvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21rZGlycy91dGlscy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvbWtkaXJzL21ha2UtZGlyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9ta2RpcnMvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3BhdGgtZXhpc3RzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi91dGlsL3V0aW1lcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvdXRpbC9zdGF0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5L2NvcHkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2NvcHkvY29weS1zeW5jLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5L2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9yZW1vdmUvcmltcmFmLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9yZW1vdmUvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2VtcHR5L2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvZmlsZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL2xpbmsuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9zeW1saW5rLXBhdGhzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvc3ltbGluay10eXBlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvc3ltbGluay5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9qc29uL2pzb25maWxlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9vdXRwdXQtZmlsZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvanNvbi9vdXRwdXQtanNvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvanNvbi9vdXRwdXQtanNvbi1zeW5jLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9qc29uL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9tb3ZlL21vdmUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21vdmUvbW92ZS1zeW5jLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9tb3ZlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9jb21tb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvZXhjZXB0aW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3NuaXBwZXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvdHlwZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9zY2hlbWEuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvdHlwZS9zdHIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvdHlwZS9zZXEuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvdHlwZS9tYXAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvc2NoZW1hL2ZhaWxzYWZlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3R5cGUvbnVsbC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi90eXBlL2Jvb2wuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvdHlwZS9pbnQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvdHlwZS9mbG9hdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9zY2hlbWEvanNvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9zY2hlbWEvY29yZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi90eXBlL3RpbWVzdGFtcC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi90eXBlL21lcmdlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3R5cGUvYmluYXJ5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3R5cGUvb21hcC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi90eXBlL3BhaXJzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3R5cGUvc2V0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3NjaGVtYS9kZWZhdWx0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2xvYWRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9kdW1wZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYXp5LXZhbC9vdXQvbWFpbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvY29uc3RhbnRzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9kZWJ1Zy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvcmUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL3BhcnNlLW9wdGlvbnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2lkZW50aWZpZXJzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL3NlbXZlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3BhcnNlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvdmFsaWQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jbGVhbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2luYy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2RpZmYuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9tYWpvci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL21pbm9yLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcGF0Y2guanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wcmVyZWxlYXNlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3Jjb21wYXJlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS1sb29zZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUtYnVpbGQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zb3J0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcnNvcnQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9ndC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZXEuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9uZXEuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9ndGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9sdGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jbXAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb2VyY2UuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMveWFsbGlzdC9pdGVyYXRvci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy95YWxsaXN0L3lhbGxpc3QuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbHJ1LWNhY2hlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL3JhbmdlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL2NvbXBhcmF0b3IuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zYXRpc2ZpZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy90by1jb21wYXJhdG9ycy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21heC1zYXRpc2Z5aW5nLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWluLXNhdGlzZnlpbmcuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9taW4tdmVyc2lvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3ZhbGlkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvb3V0c2lkZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2d0ci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2x0ci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2ludGVyc2VjdHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zaW1wbGlmeS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3N1YnNldC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLmlzZXF1YWwvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvRG93bmxvYWRlZFVwZGF0ZUhlbHBlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9BcHBBZGFwdGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L0VsZWN0cm9uQXBwQWRhcHRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9lbGVjdHJvbkh0dHBFeGVjdXRvci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2guZXNjYXBlcmVnZXhwL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L3V0aWwuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvcHJvdmlkZXJzL1Byb3ZpZGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L3Byb3ZpZGVycy9HZW5lcmljUHJvdmlkZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvcHJvdmlkZXJzL0JpdGJ1Y2tldFByb3ZpZGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L3Byb3ZpZGVycy9HaXRIdWJQcm92aWRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9wcm92aWRlcnMvS2V5Z2VuUHJvdmlkZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvcHJvdmlkZXJzL1ByaXZhdGVHaXRIdWJQcm92aWRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9wcm92aWRlckZhY3RvcnkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvQXBwVXBkYXRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9CYXNlVXBkYXRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9kaWZmZXJlbnRpYWxEb3dubG9hZGVyL2Rvd25sb2FkUGxhbkJ1aWxkZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvZGlmZmVyZW50aWFsRG93bmxvYWRlci9EYXRhU3BsaXR0ZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvZGlmZmVyZW50aWFsRG93bmxvYWRlci9tdWx0aXBsZVJhbmdlRG93bmxvYWRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9kaWZmZXJlbnRpYWxEb3dubG9hZGVyL1Byb2dyZXNzRGlmZmVyZW50aWFsRG93bmxvYWRDYWxsYmFja1RyYW5zZm9ybS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9kaWZmZXJlbnRpYWxEb3dubG9hZGVyL0RpZmZlcmVudGlhbERvd25sb2FkZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvZGlmZmVyZW50aWFsRG93bmxvYWRlci9GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L0FwcEltYWdlVXBkYXRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9EZWJVcGRhdGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L1JwbVVwZGF0ZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvTWFjVXBkYXRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9kaWZmZXJlbnRpYWxEb3dubG9hZGVyL0dlbmVyaWNEaWZmZXJlbnRpYWxEb3dubG9hZGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L3dpbmRvd3NFeGVjdXRhYmxlQ29kZVNpZ25hdHVyZVZlcmlmaWVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L05zaXNVcGRhdGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L21haW4uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvaXMtb2JqL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RvdC1wcm9wL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3BhdGgtZXhpc3RzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3AtdHJ5L2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3AtbGltaXQvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcC1sb2NhdGUvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9jYXRlLXBhdGgvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZmluZC11cC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wa2ctdXAvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZW52LXBhdGhzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC9jb25zdHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL2F0dGVtcHRpZnkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL2ZzX2hhbmRsZXJzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC91dGlscy9yZXRyeWlmeV9xdWV1ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hdG9taWNhbGx5L2Rpc3QvdXRpbHMvcmV0cnlpZnkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL2ZzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC91dGlscy9sYW5nLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC91dGlscy9zY2hlZHVsZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL3RlbXAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvY29kZWdlbi9jb2RlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvY29kZWdlbi9zY29wZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2NvZGVnZW4vaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS91dGlsLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvbmFtZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9lcnJvcnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9ib29sU2NoZW1hLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvcnVsZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9hcHBsaWNhYmlsaXR5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9kZWZhdWx0cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvY29kZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2tleXdvcmQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9zdWJzY2hlbWEuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZmFzdC1kZWVwLWVxdWFsL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLXRyYXZlcnNlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3VyaS1qcy9kaXN0L2VzNS91cmkuYWxsLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvcmVzb2x2ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3JlZl9lcnJvci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvcmUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvcmUvaWQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvcmUvcmVmLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9jb3JlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0TnVtYmVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL211bHRpcGxlT2YuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS91Y3MybGVuZ3RoLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0TGVuZ3RoLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL3BhdHRlcm4uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbGltaXRQcm9wZXJ0aWVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL3JlcXVpcmVkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0SXRlbXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS9lcXVhbC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi91bmlxdWVJdGVtcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9jb25zdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9lbnVtLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FkZGl0aW9uYWxJdGVtcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pdGVtcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wcmVmaXhJdGVtcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pdGVtczIwMjAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvY29udGFpbnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvZGVwZW5kZW5jaWVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3Byb3BlcnR5TmFtZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWRkaXRpb25hbFByb3BlcnRpZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJvcGVydGllcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wYXR0ZXJuUHJvcGVydGllcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9ub3QuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYW55T2YuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3Ivb25lT2YuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWxsT2YuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaWYuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvdGhlbkVsc2UuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Zvcm1hdC9mb3JtYXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Zvcm1hdC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvbWV0YWRhdGEuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2RyYWZ0Ny5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvci90eXBlcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvci9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9hanYuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvZGlzdC9mb3JtYXRzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi1mb3JtYXRzL2Rpc3QvbGltaXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvZGlzdC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZWJvdW5jZS1mbi9ub2RlX21vZHVsZXMvbWltaWMtZm4vaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGVib3VuY2UtZm4vaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2NvbnN0YW50cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvZGVidWcuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL3JlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9wYXJzZS1vcHRpb25zLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9pZGVudGlmaWVycy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9zZW12ZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wYXJzZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3ZhbGlkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY2xlYW4uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9pbmMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZXEuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9kaWZmLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbWFqb3IuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9taW5vci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3BhdGNoLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcHJlcmVsZWFzZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3Jjb21wYXJlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS1sb29zZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUtYnVpbGQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zb3J0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcnNvcnQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9ndC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbmVxLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZ3RlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbHRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY21wLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29lcmNlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL3JhbmdlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL2NvbXBhcmF0b3IuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zYXRpc2ZpZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy90by1jb21wYXJhdG9ycy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21heC1zYXRpc2Z5aW5nLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWluLXNhdGlzZnlpbmcuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9taW4tdmVyc2lvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3ZhbGlkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvb3V0c2lkZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2d0ci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2x0ci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2ludGVyc2VjdHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zaW1wbGlmeS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3N1YnNldC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbWltaWMtZm4vaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvb25ldGltZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL2Rpc3Qvc291cmNlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXN0b3JlL2luZGV4LmpzIiwiLi4vc3JjL3N0b3JlL21vZHVsZXMvZGF0YS5zdG9yZS5qcyIsIi4uL3NyYy9zdG9yZS9tb2R1bGVzL3NldHRpbmdzLnN0b3JlLmpzIiwiLi4vc3JjL3N0b3JlL2luZGV4LmpzIiwiLi4vc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY2xhc3MgTm9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcblx0XHRzdXBlcihOb25FcnJvci5fcHJlcGFyZVN1cGVyTWVzc2FnZShtZXNzYWdlKSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYW1lJywge1xuXHRcdFx0dmFsdWU6ICdOb25FcnJvcicsXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHR3cml0YWJsZTogdHJ1ZVxuXHRcdH0pO1xuXG5cdFx0aWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG5cdFx0XHRFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBOb25FcnJvcik7XG5cdFx0fVxuXHR9XG5cblx0c3RhdGljIF9wcmVwYXJlU3VwZXJNZXNzYWdlKG1lc3NhZ2UpIHtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpO1xuXHRcdH0gY2F0Y2gge1xuXHRcdFx0cmV0dXJuIFN0cmluZyhtZXNzYWdlKTtcblx0XHR9XG5cdH1cbn1cblxuY29uc3QgY29tbW9uUHJvcGVydGllcyA9IFtcblx0e3Byb3BlcnR5OiAnbmFtZScsIGVudW1lcmFibGU6IGZhbHNlfSxcblx0e3Byb3BlcnR5OiAnbWVzc2FnZScsIGVudW1lcmFibGU6IGZhbHNlfSxcblx0e3Byb3BlcnR5OiAnc3RhY2snLCBlbnVtZXJhYmxlOiBmYWxzZX0sXG5cdHtwcm9wZXJ0eTogJ2NvZGUnLCBlbnVtZXJhYmxlOiB0cnVlfVxuXTtcblxuY29uc3QgaXNDYWxsZWQgPSBTeW1ib2woJy50b0pTT04gY2FsbGVkJyk7XG5cbmNvbnN0IHRvSlNPTiA9IGZyb20gPT4ge1xuXHRmcm9tW2lzQ2FsbGVkXSA9IHRydWU7XG5cdGNvbnN0IGpzb24gPSBmcm9tLnRvSlNPTigpO1xuXHRkZWxldGUgZnJvbVtpc0NhbGxlZF07XG5cdHJldHVybiBqc29uO1xufTtcblxuY29uc3QgZGVzdHJveUNpcmN1bGFyID0gKHtcblx0ZnJvbSxcblx0c2Vlbixcblx0dG9fLFxuXHRmb3JjZUVudW1lcmFibGUsXG5cdG1heERlcHRoLFxuXHRkZXB0aFxufSkgPT4ge1xuXHRjb25zdCB0byA9IHRvXyB8fCAoQXJyYXkuaXNBcnJheShmcm9tKSA/IFtdIDoge30pO1xuXG5cdHNlZW4ucHVzaChmcm9tKTtcblxuXHRpZiAoZGVwdGggPj0gbWF4RGVwdGgpIHtcblx0XHRyZXR1cm4gdG87XG5cdH1cblxuXHRpZiAodHlwZW9mIGZyb20udG9KU09OID09PSAnZnVuY3Rpb24nICYmIGZyb21baXNDYWxsZWRdICE9PSB0cnVlKSB7XG5cdFx0cmV0dXJuIHRvSlNPTihmcm9tKTtcblx0fVxuXG5cdGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZyb20pKSB7XG5cdFx0aWYgKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuXHRcdFx0dG9ba2V5XSA9ICdbb2JqZWN0IEJ1ZmZlcl0nO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG5cdFx0XHR0b1trZXldID0gdmFsdWU7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoIXNlZW4uaW5jbHVkZXMoZnJvbVtrZXldKSkge1xuXHRcdFx0ZGVwdGgrKztcblxuXHRcdFx0dG9ba2V5XSA9IGRlc3Ryb3lDaXJjdWxhcih7XG5cdFx0XHRcdGZyb206IGZyb21ba2V5XSxcblx0XHRcdFx0c2Vlbjogc2Vlbi5zbGljZSgpLFxuXHRcdFx0XHRmb3JjZUVudW1lcmFibGUsXG5cdFx0XHRcdG1heERlcHRoLFxuXHRcdFx0XHRkZXB0aFxuXHRcdFx0fSk7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHR0b1trZXldID0gJ1tDaXJjdWxhcl0nO1xuXHR9XG5cblx0Zm9yIChjb25zdCB7cHJvcGVydHksIGVudW1lcmFibGV9IG9mIGNvbW1vblByb3BlcnRpZXMpIHtcblx0XHRpZiAodHlwZW9mIGZyb21bcHJvcGVydHldID09PSAnc3RyaW5nJykge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCBwcm9wZXJ0eSwge1xuXHRcdFx0XHR2YWx1ZTogZnJvbVtwcm9wZXJ0eV0sXG5cdFx0XHRcdGVudW1lcmFibGU6IGZvcmNlRW51bWVyYWJsZSA/IHRydWUgOiBlbnVtZXJhYmxlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5jb25zdCBzZXJpYWxpemVFcnJvciA9ICh2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG5cdGNvbnN0IHttYXhEZXB0aCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWX0gPSBvcHRpb25zO1xuXG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG5cdFx0cmV0dXJuIGRlc3Ryb3lDaXJjdWxhcih7XG5cdFx0XHRmcm9tOiB2YWx1ZSxcblx0XHRcdHNlZW46IFtdLFxuXHRcdFx0Zm9yY2VFbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0bWF4RGVwdGgsXG5cdFx0XHRkZXB0aDogMFxuXHRcdH0pO1xuXHR9XG5cblx0Ly8gUGVvcGxlIHNvbWV0aW1lcyB0aHJvdyB0aGluZ3MgYmVzaWRlcyBFcnJvciBvYmplY3Rz4oCmXG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcblx0XHQvLyBgSlNPTi5zdHJpbmdpZnkoKWAgZGlzY2FyZHMgZnVuY3Rpb25zLiBXZSBkbyB0b28sIHVubGVzcyBhIGZ1bmN0aW9uIGlzIHRocm93biBkaXJlY3RseS5cblx0XHRyZXR1cm4gYFtGdW5jdGlvbjogJHsodmFsdWUubmFtZSB8fCAnYW5vbnltb3VzJyl9XWA7XG5cdH1cblxuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG5jb25zdCBkZXNlcmlhbGl6ZUVycm9yID0gKHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcblx0Y29uc3Qge21heERlcHRoID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfSA9IG9wdGlvbnM7XG5cblx0aWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblxuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRjb25zdCBuZXdFcnJvciA9IG5ldyBFcnJvcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHVuaWNvcm4vZXJyb3ItbWVzc2FnZVxuXHRcdGRlc3Ryb3lDaXJjdWxhcih7XG5cdFx0XHRmcm9tOiB2YWx1ZSxcblx0XHRcdHNlZW46IFtdLFxuXHRcdFx0dG9fOiBuZXdFcnJvcixcblx0XHRcdG1heERlcHRoLFxuXHRcdFx0ZGVwdGg6IDBcblx0XHR9KTtcblx0XHRyZXR1cm4gbmV3RXJyb3I7XG5cdH1cblxuXHRyZXR1cm4gbmV3IE5vbkVycm9yKHZhbHVlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRzZXJpYWxpemVFcnJvcixcblx0ZGVzZXJpYWxpemVFcnJvclxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZ2V0VW5pcXVlSWQgPSAoKSA9PiBgJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCl9YDtcblxuY29uc3QgZ2V0U2VuZENoYW5uZWwgPSBjaGFubmVsID0+IGAlYmV0dGVyLWlwYy1zZW5kLWNoYW5uZWwtJHtjaGFubmVsfWA7XG5jb25zdCBnZXRSZW5kZXJlclNlbmRDaGFubmVsID0gY2hhbm5lbCA9PiBgJWJldHRlci1pcGMtc2VuZC1jaGFubmVsLSR7Y2hhbm5lbH1gO1xuXG5tb2R1bGUuZXhwb3J0cy5jdXJyZW50V2luZG93Q2hhbm5lbCA9ICclYmV0dGVyLWlwYy1jdXJyZW50LXdpbmRvdyc7XG5cbm1vZHVsZS5leHBvcnRzLmdldFNlbmRDaGFubmVsID0gZ2V0U2VuZENoYW5uZWw7XG5tb2R1bGUuZXhwb3J0cy5nZXRSZW5kZXJlclNlbmRDaGFubmVsID0gZ2V0UmVuZGVyZXJTZW5kQ2hhbm5lbDtcblxubW9kdWxlLmV4cG9ydHMuZ2V0UmVzcG9uc2VDaGFubmVscyA9IGNoYW5uZWwgPT4ge1xuXHRjb25zdCBpZCA9IGdldFVuaXF1ZUlkKCk7XG5cdHJldHVybiB7XG5cdFx0c2VuZENoYW5uZWw6IGdldFNlbmRDaGFubmVsKGNoYW5uZWwpLFxuXHRcdGRhdGFDaGFubmVsOiBgJWJldHRlci1pcGMtcmVzcG9uc2UtZGF0YS1jaGFubmVsLSR7Y2hhbm5lbH0tJHtpZH1gLFxuXHRcdGVycm9yQ2hhbm5lbDogYCViZXR0ZXItaXBjLXJlc3BvbnNlLWVycm9yLWNoYW5uZWwtJHtjaGFubmVsfS0ke2lkfWBcblx0fTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmdldFJlbmRlcmVyUmVzcG9uc2VDaGFubmVscyA9IGNoYW5uZWwgPT4ge1xuXHRjb25zdCBpZCA9IGdldFVuaXF1ZUlkKCk7XG5cdHJldHVybiB7XG5cdFx0c2VuZENoYW5uZWw6IGdldFJlbmRlcmVyU2VuZENoYW5uZWwoY2hhbm5lbCksXG5cdFx0ZGF0YUNoYW5uZWw6IGAlYmV0dGVyLWlwYy1yZXNwb25zZS1kYXRhLWNoYW5uZWwtJHtjaGFubmVsfS0ke2lkfWAsXG5cdFx0ZXJyb3JDaGFubmVsOiBgJWJldHRlci1pcGMtcmVzcG9uc2UtZXJyb3ItY2hhbm5lbC0ke2NoYW5uZWx9LSR7aWR9YFxuXHR9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IGVsZWN0cm9uID0gcmVxdWlyZSgnZWxlY3Ryb24nKTtcbmNvbnN0IHtzZXJpYWxpemVFcnJvciwgZGVzZXJpYWxpemVFcnJvcn0gPSByZXF1aXJlKCdzZXJpYWxpemUtZXJyb3InKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwuanMnKTtcblxuY29uc3Qge2lwY1JlbmRlcmVyfSA9IGVsZWN0cm9uO1xuY29uc3QgaXBjID0gT2JqZWN0LmNyZWF0ZShpcGNSZW5kZXJlciB8fCB7fSk7XG5cbmlwYy5jYWxsTWFpbiA9IChjaGFubmVsLCBkYXRhKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdGNvbnN0IHtzZW5kQ2hhbm5lbCwgZGF0YUNoYW5uZWwsIGVycm9yQ2hhbm5lbH0gPSB1dGlsLmdldFJlc3BvbnNlQ2hhbm5lbHMoY2hhbm5lbCk7XG5cblx0Y29uc3QgY2xlYW51cCA9ICgpID0+IHtcblx0XHRpcGNSZW5kZXJlci5vZmYoZGF0YUNoYW5uZWwsIG9uRGF0YSk7XG5cdFx0aXBjUmVuZGVyZXIub2ZmKGVycm9yQ2hhbm5lbCwgb25FcnJvcik7XG5cdH07XG5cblx0Y29uc3Qgb25EYXRhID0gKF9ldmVudCwgcmVzdWx0KSA9PiB7XG5cdFx0Y2xlYW51cCgpO1xuXHRcdHJlc29sdmUocmVzdWx0KTtcblx0fTtcblxuXHRjb25zdCBvbkVycm9yID0gKF9ldmVudCwgZXJyb3IpID0+IHtcblx0XHRjbGVhbnVwKCk7XG5cdFx0cmVqZWN0KGRlc2VyaWFsaXplRXJyb3IoZXJyb3IpKTtcblx0fTtcblxuXHRpcGNSZW5kZXJlci5vbmNlKGRhdGFDaGFubmVsLCBvbkRhdGEpO1xuXHRpcGNSZW5kZXJlci5vbmNlKGVycm9yQ2hhbm5lbCwgb25FcnJvcik7XG5cblx0Y29uc3QgY29tcGxldGVEYXRhID0ge1xuXHRcdGRhdGFDaGFubmVsLFxuXHRcdGVycm9yQ2hhbm5lbCxcblx0XHR1c2VyRGF0YTogZGF0YVxuXHR9O1xuXG5cdGlwY1JlbmRlcmVyLnNlbmQoc2VuZENoYW5uZWwsIGNvbXBsZXRlRGF0YSk7XG59KTtcblxuaXBjLmFuc3dlck1haW4gPSAoY2hhbm5lbCwgY2FsbGJhY2spID0+IHtcblx0Y29uc3Qgc2VuZENoYW5uZWwgPSB1dGlsLmdldFJlbmRlcmVyU2VuZENoYW5uZWwoY2hhbm5lbCk7XG5cblx0Y29uc3QgbGlzdGVuZXIgPSBhc3luYyAoX2V2ZW50LCBkYXRhKSA9PiB7XG5cdFx0Y29uc3Qge2RhdGFDaGFubmVsLCBlcnJvckNoYW5uZWwsIHVzZXJEYXRhfSA9IGRhdGE7XG5cblx0XHR0cnkge1xuXHRcdFx0aXBjUmVuZGVyZXIuc2VuZChkYXRhQ2hhbm5lbCwgYXdhaXQgY2FsbGJhY2sodXNlckRhdGEpKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aXBjUmVuZGVyZXIuc2VuZChlcnJvckNoYW5uZWwsIHNlcmlhbGl6ZUVycm9yKGVycm9yKSk7XG5cdFx0fVxuXHR9O1xuXG5cdGlwY1JlbmRlcmVyLm9uKHNlbmRDaGFubmVsLCBsaXN0ZW5lcik7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpcGNSZW5kZXJlci5vZmYoc2VuZENoYW5uZWwsIGxpc3RlbmVyKTtcblx0fTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXBjO1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgZWxlY3Ryb24gPSByZXF1aXJlKCdlbGVjdHJvbicpO1xuY29uc3Qge3NlcmlhbGl6ZUVycm9yLCBkZXNlcmlhbGl6ZUVycm9yfSA9IHJlcXVpcmUoJ3NlcmlhbGl6ZS1lcnJvcicpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbC5qcycpO1xuXG5jb25zdCB7aXBjTWFpbiwgQnJvd3NlcldpbmRvd30gPSBlbGVjdHJvbjtcbmNvbnN0IGlwYyA9IE9iamVjdC5jcmVhdGUoaXBjTWFpbiB8fCB7fSk7XG5cbmlwYy5jYWxsUmVuZGVyZXIgPSAoYnJvd3NlcldpbmRvdywgY2hhbm5lbCwgZGF0YSkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRpZiAoIWJyb3dzZXJXaW5kb3cpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Jyb3dzZXIgd2luZG93IHJlcXVpcmVkJyk7XG5cdH1cblxuXHRjb25zdCB7c2VuZENoYW5uZWwsIGRhdGFDaGFubmVsLCBlcnJvckNoYW5uZWx9ID0gdXRpbC5nZXRSZW5kZXJlclJlc3BvbnNlQ2hhbm5lbHMoY2hhbm5lbCk7XG5cblx0Y29uc3QgY2xlYW51cCA9ICgpID0+IHtcblx0XHRpcGNNYWluLm9mZihkYXRhQ2hhbm5lbCwgb25EYXRhKTtcblx0XHRpcGNNYWluLm9mZihlcnJvckNoYW5uZWwsIG9uRXJyb3IpO1xuXHR9O1xuXG5cdGNvbnN0IG9uRGF0YSA9IChldmVudCwgcmVzdWx0KSA9PiB7XG5cdFx0Y29uc3Qgd2luZG93ID0gQnJvd3NlcldpbmRvdy5mcm9tV2ViQ29udGVudHMoZXZlbnQuc2VuZGVyKTtcblx0XHRpZiAod2luZG93LmlkID09PSBicm93c2VyV2luZG93LmlkKSB7XG5cdFx0XHRjbGVhbnVwKCk7XG5cdFx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cdFx0fVxuXHR9O1xuXG5cdGNvbnN0IG9uRXJyb3IgPSAoZXZlbnQsIGVycm9yKSA9PiB7XG5cdFx0Y29uc3Qgd2luZG93ID0gQnJvd3NlcldpbmRvdy5mcm9tV2ViQ29udGVudHMoZXZlbnQuc2VuZGVyKTtcblx0XHRpZiAod2luZG93LmlkID09PSBicm93c2VyV2luZG93LmlkKSB7XG5cdFx0XHRjbGVhbnVwKCk7XG5cdFx0XHRyZWplY3QoZGVzZXJpYWxpemVFcnJvcihlcnJvcikpO1xuXHRcdH1cblx0fTtcblxuXHRpcGNNYWluLm9uKGRhdGFDaGFubmVsLCBvbkRhdGEpO1xuXHRpcGNNYWluLm9uKGVycm9yQ2hhbm5lbCwgb25FcnJvcik7XG5cblx0Y29uc3QgY29tcGxldGVEYXRhID0ge1xuXHRcdGRhdGFDaGFubmVsLFxuXHRcdGVycm9yQ2hhbm5lbCxcblx0XHR1c2VyRGF0YTogZGF0YVxuXHR9O1xuXG5cdGlmIChicm93c2VyV2luZG93LndlYkNvbnRlbnRzKSB7XG5cdFx0YnJvd3NlcldpbmRvdy53ZWJDb250ZW50cy5zZW5kKHNlbmRDaGFubmVsLCBjb21wbGV0ZURhdGEpO1xuXHR9XG59KTtcblxuaXBjLmNhbGxGb2N1c2VkUmVuZGVyZXIgPSBhc3luYyAoLi4uYXJncykgPT4ge1xuXHRjb25zdCBmb2N1c2VkV2luZG93ID0gQnJvd3NlcldpbmRvdy5nZXRGb2N1c2VkV2luZG93KCk7XG5cdGlmICghZm9jdXNlZFdpbmRvdykge1xuXHRcdHRocm93IG5ldyBFcnJvcignTm8gYnJvd3NlciB3aW5kb3cgaW4gZm9jdXMnKTtcblx0fVxuXG5cdHJldHVybiBpcGMuY2FsbFJlbmRlcmVyKGZvY3VzZWRXaW5kb3csIC4uLmFyZ3MpO1xufTtcblxuaXBjLmFuc3dlclJlbmRlcmVyID0gKGJyb3dzZXJXaW5kb3dPckNoYW5uZWwsIGNoYW5uZWxPckNhbGxiYWNrLCBjYWxsYmFja09yTm90aGluZykgPT4ge1xuXHRsZXQgd2luZG93O1xuXHRsZXQgY2hhbm5lbDtcblx0bGV0IGNhbGxiYWNrO1xuXG5cdGlmIChjYWxsYmFja09yTm90aGluZyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Y2hhbm5lbCA9IGJyb3dzZXJXaW5kb3dPckNoYW5uZWw7XG5cdFx0Y2FsbGJhY2sgPSBjaGFubmVsT3JDYWxsYmFjaztcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cgPSBicm93c2VyV2luZG93T3JDaGFubmVsO1xuXHRcdGNoYW5uZWwgPSBjaGFubmVsT3JDYWxsYmFjaztcblx0XHRjYWxsYmFjayA9IGNhbGxiYWNrT3JOb3RoaW5nO1xuXG5cdFx0aWYgKCF3aW5kb3cpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignQnJvd3NlciB3aW5kb3cgcmVxdWlyZWQnKTtcblx0XHR9XG5cdH1cblxuXHRjb25zdCBzZW5kQ2hhbm5lbCA9IHV0aWwuZ2V0U2VuZENoYW5uZWwoY2hhbm5lbCk7XG5cblx0Y29uc3QgbGlzdGVuZXIgPSBhc3luYyAoZXZlbnQsIGRhdGEpID0+IHtcblx0XHRjb25zdCBicm93c2VyV2luZG93ID0gQnJvd3NlcldpbmRvdy5mcm9tV2ViQ29udGVudHMoZXZlbnQuc2VuZGVyKTtcblxuXHRcdGlmICh3aW5kb3cgJiYgd2luZG93LmlkICE9PSBicm93c2VyV2luZG93LmlkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3Qgc2VuZCA9IChjaGFubmVsLCBkYXRhKSA9PiB7XG5cdFx0XHRpZiAoIShicm93c2VyV2luZG93ICYmIGJyb3dzZXJXaW5kb3cuaXNEZXN0cm95ZWQoKSkpIHtcblx0XHRcdFx0ZXZlbnQuc2VuZGVyLnNlbmQoY2hhbm5lbCwgZGF0YSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGNvbnN0IHtkYXRhQ2hhbm5lbCwgZXJyb3JDaGFubmVsLCB1c2VyRGF0YX0gPSBkYXRhO1xuXG5cdFx0dHJ5IHtcblx0XHRcdHNlbmQoZGF0YUNoYW5uZWwsIGF3YWl0IGNhbGxiYWNrKHVzZXJEYXRhLCBicm93c2VyV2luZG93KSk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHNlbmQoZXJyb3JDaGFubmVsLCBzZXJpYWxpemVFcnJvcihlcnJvcikpO1xuXHRcdH1cblx0fTtcblxuXHRpcGNNYWluLm9uKHNlbmRDaGFubmVsLCBsaXN0ZW5lcik7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpcGNNYWluLm9mZihzZW5kQ2hhbm5lbCwgbGlzdGVuZXIpO1xuXHR9O1xufTtcblxuaXBjLnNlbmRUb1JlbmRlcmVycyA9IChjaGFubmVsLCBkYXRhKSA9PiB7XG5cdGZvciAoY29uc3QgYnJvd3NlcldpbmRvdyBvZiBCcm93c2VyV2luZG93LmdldEFsbFdpbmRvd3MoKSkge1xuXHRcdGlmIChicm93c2VyV2luZG93LndlYkNvbnRlbnRzKSB7XG5cdFx0XHRicm93c2VyV2luZG93LndlYkNvbnRlbnRzLnNlbmQoY2hhbm5lbCwgZGF0YSk7XG5cdFx0fVxuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlwYztcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuXHRtb2R1bGUuZXhwb3J0cy5pcGNSZW5kZXJlciA9IHJlcXVpcmUoJy4vc291cmNlL3JlbmRlcmVyLmpzJyk7XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cy5pcGNNYWluID0gcmVxdWlyZSgnLi9zb3VyY2UvbWFpbi5qcycpO1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuZnJvbUNhbGxiYWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykgZm4uYXBwbHkodGhpcywgYXJncylcbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGZuLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgIChlcnIsIHJlcykgPT4gKGVyciAhPSBudWxsKSA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShyZXMpXG4gICAgICAgIClcbiAgICAgIH0pXG4gICAgfVxuICB9LCAnbmFtZScsIHsgdmFsdWU6IGZuLm5hbWUgfSlcbn1cblxuZXhwb3J0cy5mcm9tUHJvbWlzZSA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgY29uc3QgY2IgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV1cbiAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncylcbiAgICBlbHNlIGZuLmFwcGx5KHRoaXMsIGFyZ3Muc2xpY2UoMCwgLTEpKS50aGVuKHIgPT4gY2IobnVsbCwgciksIGNiKVxuICB9LCAnbmFtZScsIHsgdmFsdWU6IGZuLm5hbWUgfSlcbn1cbiIsInZhciBjb25zdGFudHMgPSByZXF1aXJlKCdjb25zdGFudHMnKVxuXG52YXIgb3JpZ0N3ZCA9IHByb2Nlc3MuY3dkXG52YXIgY3dkID0gbnVsbFxuXG52YXIgcGxhdGZvcm0gPSBwcm9jZXNzLmVudi5HUkFDRUZVTF9GU19QTEFURk9STSB8fCBwcm9jZXNzLnBsYXRmb3JtXG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24oKSB7XG4gIGlmICghY3dkKVxuICAgIGN3ZCA9IG9yaWdDd2QuY2FsbChwcm9jZXNzKVxuICByZXR1cm4gY3dkXG59XG50cnkge1xuICBwcm9jZXNzLmN3ZCgpXG59IGNhdGNoIChlcikge31cblxuLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdW50aWwgbm9kZS5qcyAxMiBpcyByZXF1aXJlZFxuaWYgKHR5cGVvZiBwcm9jZXNzLmNoZGlyID09PSAnZnVuY3Rpb24nKSB7XG4gIHZhciBjaGRpciA9IHByb2Nlc3MuY2hkaXJcbiAgcHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkKSB7XG4gICAgY3dkID0gbnVsbFxuICAgIGNoZGlyLmNhbGwocHJvY2VzcywgZClcbiAgfVxuICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvY2Vzcy5jaGRpciwgY2hkaXIpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGF0Y2hcblxuZnVuY3Rpb24gcGF0Y2ggKGZzKSB7XG4gIC8vIChyZS0paW1wbGVtZW50IHNvbWUgdGhpbmdzIHRoYXQgYXJlIGtub3duIGJ1c3RlZCBvciBtaXNzaW5nLlxuXG4gIC8vIGxjaG1vZCwgYnJva2VuIHByaW9yIHRvIDAuNi4yXG4gIC8vIGJhY2stcG9ydCB0aGUgZml4IGhlcmUuXG4gIGlmIChjb25zdGFudHMuaGFzT3duUHJvcGVydHkoJ09fU1lNTElOSycpICYmXG4gICAgICBwcm9jZXNzLnZlcnNpb24ubWF0Y2goL152MFxcLjZcXC5bMC0yXXxedjBcXC41XFwuLykpIHtcbiAgICBwYXRjaExjaG1vZChmcylcbiAgfVxuXG4gIC8vIGx1dGltZXMgaW1wbGVtZW50YXRpb24sIG9yIG5vLW9wXG4gIGlmICghZnMubHV0aW1lcykge1xuICAgIHBhdGNoTHV0aW1lcyhmcylcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3Mvbm9kZS1ncmFjZWZ1bC1mcy9pc3N1ZXMvNFxuICAvLyBDaG93biBzaG91bGQgbm90IGZhaWwgb24gZWludmFsIG9yIGVwZXJtIGlmIG5vbi1yb290LlxuICAvLyBJdCBzaG91bGQgbm90IGZhaWwgb24gZW5vc3lzIGV2ZXIsIGFzIHRoaXMganVzdCBpbmRpY2F0ZXNcbiAgLy8gdGhhdCBhIGZzIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgaW50ZW5kZWQgb3BlcmF0aW9uLlxuXG4gIGZzLmNob3duID0gY2hvd25GaXgoZnMuY2hvd24pXG4gIGZzLmZjaG93biA9IGNob3duRml4KGZzLmZjaG93bilcbiAgZnMubGNob3duID0gY2hvd25GaXgoZnMubGNob3duKVxuXG4gIGZzLmNobW9kID0gY2htb2RGaXgoZnMuY2htb2QpXG4gIGZzLmZjaG1vZCA9IGNobW9kRml4KGZzLmZjaG1vZClcbiAgZnMubGNobW9kID0gY2htb2RGaXgoZnMubGNobW9kKVxuXG4gIGZzLmNob3duU3luYyA9IGNob3duRml4U3luYyhmcy5jaG93blN5bmMpXG4gIGZzLmZjaG93blN5bmMgPSBjaG93bkZpeFN5bmMoZnMuZmNob3duU3luYylcbiAgZnMubGNob3duU3luYyA9IGNob3duRml4U3luYyhmcy5sY2hvd25TeW5jKVxuXG4gIGZzLmNobW9kU3luYyA9IGNobW9kRml4U3luYyhmcy5jaG1vZFN5bmMpXG4gIGZzLmZjaG1vZFN5bmMgPSBjaG1vZEZpeFN5bmMoZnMuZmNobW9kU3luYylcbiAgZnMubGNobW9kU3luYyA9IGNobW9kRml4U3luYyhmcy5sY2htb2RTeW5jKVxuXG4gIGZzLnN0YXQgPSBzdGF0Rml4KGZzLnN0YXQpXG4gIGZzLmZzdGF0ID0gc3RhdEZpeChmcy5mc3RhdClcbiAgZnMubHN0YXQgPSBzdGF0Rml4KGZzLmxzdGF0KVxuXG4gIGZzLnN0YXRTeW5jID0gc3RhdEZpeFN5bmMoZnMuc3RhdFN5bmMpXG4gIGZzLmZzdGF0U3luYyA9IHN0YXRGaXhTeW5jKGZzLmZzdGF0U3luYylcbiAgZnMubHN0YXRTeW5jID0gc3RhdEZpeFN5bmMoZnMubHN0YXRTeW5jKVxuXG4gIC8vIGlmIGxjaG1vZC9sY2hvd24gZG8gbm90IGV4aXN0LCB0aGVuIG1ha2UgdGhlbSBuby1vcHNcbiAgaWYgKCFmcy5sY2htb2QpIHtcbiAgICBmcy5sY2htb2QgPSBmdW5jdGlvbiAocGF0aCwgbW9kZSwgY2IpIHtcbiAgICAgIGlmIChjYikgcHJvY2Vzcy5uZXh0VGljayhjYilcbiAgICB9XG4gICAgZnMubGNobW9kU3luYyA9IGZ1bmN0aW9uICgpIHt9XG4gIH1cbiAgaWYgKCFmcy5sY2hvd24pIHtcbiAgICBmcy5sY2hvd24gPSBmdW5jdGlvbiAocGF0aCwgdWlkLCBnaWQsIGNiKSB7XG4gICAgICBpZiAoY2IpIHByb2Nlc3MubmV4dFRpY2soY2IpXG4gICAgfVxuICAgIGZzLmxjaG93blN5bmMgPSBmdW5jdGlvbiAoKSB7fVxuICB9XG5cbiAgLy8gb24gV2luZG93cywgQS9WIHNvZnR3YXJlIGNhbiBsb2NrIHRoZSBkaXJlY3RvcnksIGNhdXNpbmcgdGhpc1xuICAvLyB0byBmYWlsIHdpdGggYW4gRUFDQ0VTIG9yIEVQRVJNIGlmIHRoZSBkaXJlY3RvcnkgY29udGFpbnMgbmV3bHlcbiAgLy8gY3JlYXRlZCBmaWxlcy4gIFRyeSBhZ2FpbiBvbiBmYWlsdXJlLCBmb3IgdXAgdG8gNjAgc2Vjb25kcy5cblxuICAvLyBTZXQgdGhlIHRpbWVvdXQgdGhpcyBsb25nIGJlY2F1c2Ugc29tZSBXaW5kb3dzIEFudGktVmlydXMsIHN1Y2ggYXMgUGFyaXR5XG4gIC8vIGJpdDksIG1heSBsb2NrIGZpbGVzIGZvciB1cCB0byBhIG1pbnV0ZSwgY2F1c2luZyBucG0gcGFja2FnZSBpbnN0YWxsXG4gIC8vIGZhaWx1cmVzLiBBbHNvLCB0YWtlIGNhcmUgdG8geWllbGQgdGhlIHNjaGVkdWxlci4gV2luZG93cyBzY2hlZHVsaW5nIGdpdmVzXG4gIC8vIENQVSB0byBhIGJ1c3kgbG9vcGluZyBwcm9jZXNzLCB3aGljaCBjYW4gY2F1c2UgdGhlIHByb2dyYW0gY2F1c2luZyB0aGUgbG9ja1xuICAvLyBjb250ZW50aW9uIHRvIGJlIHN0YXJ2ZWQgb2YgQ1BVIGJ5IG5vZGUsIHNvIHRoZSBjb250ZW50aW9uIGRvZXNuJ3QgcmVzb2x2ZS5cbiAgaWYgKHBsYXRmb3JtID09PSBcIndpbjMyXCIpIHtcbiAgICBmcy5yZW5hbWUgPSAoZnVuY3Rpb24gKGZzJHJlbmFtZSkgeyByZXR1cm4gZnVuY3Rpb24gKGZyb20sIHRvLCBjYikge1xuICAgICAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKVxuICAgICAgdmFyIGJhY2tvZmYgPSAwO1xuICAgICAgZnMkcmVuYW1lKGZyb20sIHRvLCBmdW5jdGlvbiBDQiAoZXIpIHtcbiAgICAgICAgaWYgKGVyXG4gICAgICAgICAgICAmJiAoZXIuY29kZSA9PT0gXCJFQUNDRVNcIiB8fCBlci5jb2RlID09PSBcIkVQRVJNXCIpXG4gICAgICAgICAgICAmJiBEYXRlLm5vdygpIC0gc3RhcnQgPCA2MDAwMCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmcy5zdGF0KHRvLCBmdW5jdGlvbiAoc3RhdGVyLCBzdCkge1xuICAgICAgICAgICAgICBpZiAoc3RhdGVyICYmIHN0YXRlci5jb2RlID09PSBcIkVOT0VOVFwiKVxuICAgICAgICAgICAgICAgIGZzJHJlbmFtZShmcm9tLCB0bywgQ0IpO1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY2IoZXIpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0sIGJhY2tvZmYpXG4gICAgICAgICAgaWYgKGJhY2tvZmYgPCAxMDApXG4gICAgICAgICAgICBiYWNrb2ZmICs9IDEwO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2IpIGNiKGVyKVxuICAgICAgfSlcbiAgICB9fSkoZnMucmVuYW1lKVxuICB9XG5cbiAgLy8gaWYgcmVhZCgpIHJldHVybnMgRUFHQUlOLCB0aGVuIGp1c3QgdHJ5IGl0IGFnYWluLlxuICBmcy5yZWFkID0gKGZ1bmN0aW9uIChmcyRyZWFkKSB7XG4gICAgZnVuY3Rpb24gcmVhZCAoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFja18pIHtcbiAgICAgIHZhciBjYWxsYmFja1xuICAgICAgaWYgKGNhbGxiYWNrXyAmJiB0eXBlb2YgY2FsbGJhY2tfID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBlYWdDb3VudGVyID0gMFxuICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uIChlciwgXywgX18pIHtcbiAgICAgICAgICBpZiAoZXIgJiYgZXIuY29kZSA9PT0gJ0VBR0FJTicgJiYgZWFnQ291bnRlciA8IDEwKSB7XG4gICAgICAgICAgICBlYWdDb3VudGVyICsrXG4gICAgICAgICAgICByZXR1cm4gZnMkcmVhZC5jYWxsKGZzLCBmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFja18uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnMkcmVhZC5jYWxsKGZzLCBmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKVxuICAgIH1cblxuICAgIC8vIFRoaXMgZW5zdXJlcyBgdXRpbC5wcm9taXNpZnlgIHdvcmtzIGFzIGl0IGRvZXMgZm9yIG5hdGl2ZSBgZnMucmVhZGAuXG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikgT2JqZWN0LnNldFByb3RvdHlwZU9mKHJlYWQsIGZzJHJlYWQpXG4gICAgcmV0dXJuIHJlYWRcbiAgfSkoZnMucmVhZClcblxuICBmcy5yZWFkU3luYyA9IChmdW5jdGlvbiAoZnMkcmVhZFN5bmMpIHsgcmV0dXJuIGZ1bmN0aW9uIChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHtcbiAgICB2YXIgZWFnQ291bnRlciA9IDBcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZzJHJlYWRTeW5jLmNhbGwoZnMsIGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbilcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGlmIChlci5jb2RlID09PSAnRUFHQUlOJyAmJiBlYWdDb3VudGVyIDwgMTApIHtcbiAgICAgICAgICBlYWdDb3VudGVyICsrXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlclxuICAgICAgfVxuICAgIH1cbiAgfX0pKGZzLnJlYWRTeW5jKVxuXG4gIGZ1bmN0aW9uIHBhdGNoTGNobW9kIChmcykge1xuICAgIGZzLmxjaG1vZCA9IGZ1bmN0aW9uIChwYXRoLCBtb2RlLCBjYWxsYmFjaykge1xuICAgICAgZnMub3BlbiggcGF0aFxuICAgICAgICAgICAgICwgY29uc3RhbnRzLk9fV1JPTkxZIHwgY29uc3RhbnRzLk9fU1lNTElOS1xuICAgICAgICAgICAgICwgbW9kZVxuICAgICAgICAgICAgICwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIC8vIHByZWZlciB0byByZXR1cm4gdGhlIGNobW9kIGVycm9yLCBpZiBvbmUgb2NjdXJzLFxuICAgICAgICAvLyBidXQgc3RpbGwgdHJ5IHRvIGNsb3NlLCBhbmQgcmVwb3J0IGNsb3NpbmcgZXJyb3JzIGlmIHRoZXkgb2NjdXIuXG4gICAgICAgIGZzLmZjaG1vZChmZCwgbW9kZSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGZzLmNsb3NlKGZkLCBmdW5jdGlvbihlcnIyKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVyciB8fCBlcnIyKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZzLmxjaG1vZFN5bmMgPSBmdW5jdGlvbiAocGF0aCwgbW9kZSkge1xuICAgICAgdmFyIGZkID0gZnMub3BlblN5bmMocGF0aCwgY29uc3RhbnRzLk9fV1JPTkxZIHwgY29uc3RhbnRzLk9fU1lNTElOSywgbW9kZSlcblxuICAgICAgLy8gcHJlZmVyIHRvIHJldHVybiB0aGUgY2htb2QgZXJyb3IsIGlmIG9uZSBvY2N1cnMsXG4gICAgICAvLyBidXQgc3RpbGwgdHJ5IHRvIGNsb3NlLCBhbmQgcmVwb3J0IGNsb3NpbmcgZXJyb3JzIGlmIHRoZXkgb2NjdXIuXG4gICAgICB2YXIgdGhyZXcgPSB0cnVlXG4gICAgICB2YXIgcmV0XG4gICAgICB0cnkge1xuICAgICAgICByZXQgPSBmcy5mY2htb2RTeW5jKGZkLCBtb2RlKVxuICAgICAgICB0aHJldyA9IGZhbHNlXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodGhyZXcpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZnMuY2xvc2VTeW5jKGZkKVxuICAgICAgICAgIH0gY2F0Y2ggKGVyKSB7fVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoTHV0aW1lcyAoZnMpIHtcbiAgICBpZiAoY29uc3RhbnRzLmhhc093blByb3BlcnR5KFwiT19TWU1MSU5LXCIpKSB7XG4gICAgICBmcy5sdXRpbWVzID0gZnVuY3Rpb24gKHBhdGgsIGF0LCBtdCwgY2IpIHtcbiAgICAgICAgZnMub3BlbihwYXRoLCBjb25zdGFudHMuT19TWU1MSU5LLCBmdW5jdGlvbiAoZXIsIGZkKSB7XG4gICAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICBpZiAoY2IpIGNiKGVyKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGZzLmZ1dGltZXMoZmQsIGF0LCBtdCwgZnVuY3Rpb24gKGVyKSB7XG4gICAgICAgICAgICBmcy5jbG9zZShmZCwgZnVuY3Rpb24gKGVyMikge1xuICAgICAgICAgICAgICBpZiAoY2IpIGNiKGVyIHx8IGVyMilcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgZnMubHV0aW1lc1N5bmMgPSBmdW5jdGlvbiAocGF0aCwgYXQsIG10KSB7XG4gICAgICAgIHZhciBmZCA9IGZzLm9wZW5TeW5jKHBhdGgsIGNvbnN0YW50cy5PX1NZTUxJTkspXG4gICAgICAgIHZhciByZXRcbiAgICAgICAgdmFyIHRocmV3ID0gdHJ1ZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldCA9IGZzLmZ1dGltZXNTeW5jKGZkLCBhdCwgbXQpXG4gICAgICAgICAgdGhyZXcgPSBmYWxzZVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmICh0aHJldykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZnMuY2xvc2VTeW5jKGZkKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXIpIHt9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldFxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGZzLmx1dGltZXMgPSBmdW5jdGlvbiAoX2EsIF9iLCBfYywgY2IpIHsgaWYgKGNiKSBwcm9jZXNzLm5leHRUaWNrKGNiKSB9XG4gICAgICBmcy5sdXRpbWVzU3luYyA9IGZ1bmN0aW9uICgpIHt9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2htb2RGaXggKG9yaWcpIHtcbiAgICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIG1vZGUsIGNiKSB7XG4gICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIG1vZGUsIGZ1bmN0aW9uIChlcikge1xuICAgICAgICBpZiAoY2hvd25Fck9rKGVyKSkgZXIgPSBudWxsXG4gICAgICAgIGlmIChjYikgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaG1vZEZpeFN5bmMgKG9yaWcpIHtcbiAgICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIG1vZGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBvcmlnLmNhbGwoZnMsIHRhcmdldCwgbW9kZSlcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGlmICghY2hvd25Fck9rKGVyKSkgdGhyb3cgZXJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGNob3duRml4IChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCB1aWQsIGdpZCwgY2IpIHtcbiAgICAgIHJldHVybiBvcmlnLmNhbGwoZnMsIHRhcmdldCwgdWlkLCBnaWQsIGZ1bmN0aW9uIChlcikge1xuICAgICAgICBpZiAoY2hvd25Fck9rKGVyKSkgZXIgPSBudWxsXG4gICAgICAgIGlmIChjYikgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaG93bkZpeFN5bmMgKG9yaWcpIHtcbiAgICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIHVpZCwgZ2lkKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIHVpZCwgZ2lkKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgaWYgKCFjaG93bkVyT2soZXIpKSB0aHJvdyBlclxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXRGaXggKG9yaWcpIHtcbiAgICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gICAgLy8gT2xkZXIgdmVyc2lvbnMgb2YgTm9kZSBlcnJvbmVvdXNseSByZXR1cm5lZCBzaWduZWQgaW50ZWdlcnMgZm9yXG4gICAgLy8gdWlkICsgZ2lkLlxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zLCBjYikge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNiID0gb3B0aW9uc1xuICAgICAgICBvcHRpb25zID0gbnVsbFxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY2FsbGJhY2sgKGVyLCBzdGF0cykge1xuICAgICAgICBpZiAoc3RhdHMpIHtcbiAgICAgICAgICBpZiAoc3RhdHMudWlkIDwgMCkgc3RhdHMudWlkICs9IDB4MTAwMDAwMDAwXG4gICAgICAgICAgaWYgKHN0YXRzLmdpZCA8IDApIHN0YXRzLmdpZCArPSAweDEwMDAwMDAwMFxuICAgICAgICB9XG4gICAgICAgIGlmIChjYikgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMgPyBvcmlnLmNhbGwoZnMsIHRhcmdldCwgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgICAgIDogb3JpZy5jYWxsKGZzLCB0YXJnZXQsIGNhbGxiYWNrKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXRGaXhTeW5jIChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIC8vIE9sZGVyIHZlcnNpb25zIG9mIE5vZGUgZXJyb25lb3VzbHkgcmV0dXJuZWQgc2lnbmVkIGludGVnZXJzIGZvclxuICAgIC8vIHVpZCArIGdpZC5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgdmFyIHN0YXRzID0gb3B0aW9ucyA/IG9yaWcuY2FsbChmcywgdGFyZ2V0LCBvcHRpb25zKVxuICAgICAgICA6IG9yaWcuY2FsbChmcywgdGFyZ2V0KVxuICAgICAgaWYgKHN0YXRzLnVpZCA8IDApIHN0YXRzLnVpZCArPSAweDEwMDAwMDAwMFxuICAgICAgaWYgKHN0YXRzLmdpZCA8IDApIHN0YXRzLmdpZCArPSAweDEwMDAwMDAwMFxuICAgICAgcmV0dXJuIHN0YXRzO1xuICAgIH1cbiAgfVxuXG4gIC8vIEVOT1NZUyBtZWFucyB0aGF0IHRoZSBmcyBkb2Vzbid0IHN1cHBvcnQgdGhlIG9wLiBKdXN0IGlnbm9yZVxuICAvLyB0aGF0LCBiZWNhdXNlIGl0IGRvZXNuJ3QgbWF0dGVyLlxuICAvL1xuICAvLyBpZiB0aGVyZSdzIG5vIGdldHVpZCwgb3IgaWYgZ2V0dWlkKCkgaXMgc29tZXRoaW5nIG90aGVyXG4gIC8vIHRoYW4gMCwgYW5kIHRoZSBlcnJvciBpcyBFSU5WQUwgb3IgRVBFUk0sIHRoZW4ganVzdCBpZ25vcmVcbiAgLy8gaXQuXG4gIC8vXG4gIC8vIFRoaXMgc3BlY2lmaWMgY2FzZSBpcyBhIHNpbGVudCBmYWlsdXJlIGluIGNwLCBpbnN0YWxsLCB0YXIsXG4gIC8vIGFuZCBtb3N0IG90aGVyIHVuaXggdG9vbHMgdGhhdCBtYW5hZ2UgcGVybWlzc2lvbnMuXG4gIC8vXG4gIC8vIFdoZW4gcnVubmluZyBhcyByb290LCBvciBpZiBvdGhlciB0eXBlcyBvZiBlcnJvcnMgYXJlXG4gIC8vIGVuY291bnRlcmVkLCB0aGVuIGl0J3Mgc3RyaWN0LlxuICBmdW5jdGlvbiBjaG93bkVyT2sgKGVyKSB7XG4gICAgaWYgKCFlcilcbiAgICAgIHJldHVybiB0cnVlXG5cbiAgICBpZiAoZXIuY29kZSA9PT0gXCJFTk9TWVNcIilcbiAgICAgIHJldHVybiB0cnVlXG5cbiAgICB2YXIgbm9ucm9vdCA9ICFwcm9jZXNzLmdldHVpZCB8fCBwcm9jZXNzLmdldHVpZCgpICE9PSAwXG4gICAgaWYgKG5vbnJvb3QpIHtcbiAgICAgIGlmIChlci5jb2RlID09PSBcIkVJTlZBTFwiIHx8IGVyLmNvZGUgPT09IFwiRVBFUk1cIilcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuIiwidmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpLlN0cmVhbVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxlZ2FjeVxuXG5mdW5jdGlvbiBsZWdhY3kgKGZzKSB7XG4gIHJldHVybiB7XG4gICAgUmVhZFN0cmVhbTogUmVhZFN0cmVhbSxcbiAgICBXcml0ZVN0cmVhbTogV3JpdGVTdHJlYW1cbiAgfVxuXG4gIGZ1bmN0aW9uIFJlYWRTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZFN0cmVhbSkpIHJldHVybiBuZXcgUmVhZFN0cmVhbShwYXRoLCBvcHRpb25zKTtcblxuICAgIFN0cmVhbS5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLmZkID0gbnVsbDtcbiAgICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5mbGFncyA9ICdyJztcbiAgICB0aGlzLm1vZGUgPSA0Mzg7IC8qPTA2NjYqL1xuICAgIHRoaXMuYnVmZmVyU2l6ZSA9IDY0ICogMTAyNDtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gTWl4aW4gb3B0aW9ucyBpbnRvIHRoaXNcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpbmRleF07XG4gICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZW5jb2RpbmcpIHRoaXMuc2V0RW5jb2RpbmcodGhpcy5lbmNvZGluZyk7XG5cbiAgICBpZiAodGhpcy5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoJ251bWJlcicgIT09IHR5cGVvZiB0aGlzLnN0YXJ0KSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignc3RhcnQgbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5lbmQgPSBJbmZpbml0eTtcbiAgICAgIH0gZWxzZSBpZiAoJ251bWJlcicgIT09IHR5cGVvZiB0aGlzLmVuZCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ2VuZCBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnN0YXJ0ID4gdGhpcy5lbmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydCBtdXN0IGJlIDw9IGVuZCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmQgIT09IG51bGwpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuX3JlYWQoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZzLm9wZW4odGhpcy5wYXRoLCB0aGlzLmZsYWdzLCB0aGlzLm1vZGUsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICBzZWxmLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi5mZCA9IGZkO1xuICAgICAgc2VsZi5lbWl0KCdvcGVuJywgZmQpO1xuICAgICAgc2VsZi5fcmVhZCgpO1xuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBXcml0ZVN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcml0ZVN0cmVhbSkpIHJldHVybiBuZXcgV3JpdGVTdHJlYW0ocGF0aCwgb3B0aW9ucyk7XG5cbiAgICBTdHJlYW0uY2FsbCh0aGlzKTtcblxuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5mZCA9IG51bGw7XG4gICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgICB0aGlzLmZsYWdzID0gJ3cnO1xuICAgIHRoaXMuZW5jb2RpbmcgPSAnYmluYXJ5JztcbiAgICB0aGlzLm1vZGUgPSA0Mzg7IC8qPTA2NjYqL1xuICAgIHRoaXMuYnl0ZXNXcml0dGVuID0gMDtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gTWl4aW4gb3B0aW9ucyBpbnRvIHRoaXNcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpbmRleF07XG4gICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdGhpcy5zdGFydCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ3N0YXJ0IG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXJ0IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0IG11c3QgYmUgPj0gemVybycpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgfVxuXG4gICAgdGhpcy5idXN5ID0gZmFsc2U7XG4gICAgdGhpcy5fcXVldWUgPSBbXTtcblxuICAgIGlmICh0aGlzLmZkID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9vcGVuID0gZnMub3BlbjtcbiAgICAgIHRoaXMuX3F1ZXVlLnB1c2goW3RoaXMuX29wZW4sIHRoaXMucGF0aCwgdGhpcy5mbGFncywgdGhpcy5tb2RlLCB1bmRlZmluZWRdKTtcbiAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lXG5cbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmouX19wcm90b19fXG59XG5cbmZ1bmN0aW9uIGNsb25lIChvYmopIHtcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JylcbiAgICByZXR1cm4gb2JqXG5cbiAgaWYgKG9iaiBpbnN0YW5jZW9mIE9iamVjdClcbiAgICB2YXIgY29weSA9IHsgX19wcm90b19fOiBnZXRQcm90b3R5cGVPZihvYmopIH1cbiAgZWxzZVxuICAgIHZhciBjb3B5ID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvcHksIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkpXG4gIH0pXG5cbiAgcmV0dXJuIGNvcHlcbn1cbiIsInZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcbnZhciBwb2x5ZmlsbHMgPSByZXF1aXJlKCcuL3BvbHlmaWxscy5qcycpXG52YXIgbGVnYWN5ID0gcmVxdWlyZSgnLi9sZWdhY3ktc3RyZWFtcy5qcycpXG52YXIgY2xvbmUgPSByZXF1aXJlKCcuL2Nsb25lLmpzJylcblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBub2RlIDAueCBwb2x5ZmlsbCAqL1xudmFyIGdyYWNlZnVsUXVldWVcbnZhciBwcmV2aW91c1N5bWJvbFxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtIG5vZGUgMC54IHBvbHlmaWxsICovXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLmZvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBncmFjZWZ1bFF1ZXVlID0gU3ltYm9sLmZvcignZ3JhY2VmdWwtZnMucXVldWUnKVxuICAvLyBUaGlzIGlzIHVzZWQgaW4gdGVzdGluZyBieSBmdXR1cmUgdmVyc2lvbnNcbiAgcHJldmlvdXNTeW1ib2wgPSBTeW1ib2wuZm9yKCdncmFjZWZ1bC1mcy5wcmV2aW91cycpXG59IGVsc2Uge1xuICBncmFjZWZ1bFF1ZXVlID0gJ19fX2dyYWNlZnVsLWZzLnF1ZXVlJ1xuICBwcmV2aW91c1N5bWJvbCA9ICdfX19ncmFjZWZ1bC1mcy5wcmV2aW91cydcbn1cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5mdW5jdGlvbiBwdWJsaXNoUXVldWUoY29udGV4dCwgcXVldWUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnRleHQsIGdyYWNlZnVsUXVldWUsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHF1ZXVlXG4gICAgfVxuICB9KVxufVxuXG52YXIgZGVidWcgPSBub29wXG5pZiAodXRpbC5kZWJ1Z2xvZylcbiAgZGVidWcgPSB1dGlsLmRlYnVnbG9nKCdnZnM0JylcbmVsc2UgaWYgKC9cXGJnZnM0XFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnKSlcbiAgZGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbSA9IHV0aWwuZm9ybWF0LmFwcGx5KHV0aWwsIGFyZ3VtZW50cylcbiAgICBtID0gJ0dGUzQ6ICcgKyBtLnNwbGl0KC9cXG4vKS5qb2luKCdcXG5HRlM0OiAnKVxuICAgIGNvbnNvbGUuZXJyb3IobSlcbiAgfVxuXG4vLyBPbmNlIHRpbWUgaW5pdGlhbGl6YXRpb25cbmlmICghZnNbZ3JhY2VmdWxRdWV1ZV0pIHtcbiAgLy8gVGhpcyBxdWV1ZSBjYW4gYmUgc2hhcmVkIGJ5IG11bHRpcGxlIGxvYWRlZCBpbnN0YW5jZXNcbiAgdmFyIHF1ZXVlID0gZ2xvYmFsW2dyYWNlZnVsUXVldWVdIHx8IFtdXG4gIHB1Ymxpc2hRdWV1ZShmcywgcXVldWUpXG5cbiAgLy8gUGF0Y2ggZnMuY2xvc2UvY2xvc2VTeW5jIHRvIHNoYXJlZCBxdWV1ZSB2ZXJzaW9uLCBiZWNhdXNlIHdlIG5lZWRcbiAgLy8gdG8gcmV0cnkoKSB3aGVuZXZlciBhIGNsb3NlIGhhcHBlbnMgKmFueXdoZXJlKiBpbiB0aGUgcHJvZ3JhbS5cbiAgLy8gVGhpcyBpcyBlc3NlbnRpYWwgd2hlbiBtdWx0aXBsZSBncmFjZWZ1bC1mcyBpbnN0YW5jZXMgYXJlXG4gIC8vIGluIHBsYXkgYXQgdGhlIHNhbWUgdGltZS5cbiAgZnMuY2xvc2UgPSAoZnVuY3Rpb24gKGZzJGNsb3NlKSB7XG4gICAgZnVuY3Rpb24gY2xvc2UgKGZkLCBjYikge1xuICAgICAgcmV0dXJuIGZzJGNsb3NlLmNhbGwoZnMsIGZkLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gdXNlcyB0aGUgZ3JhY2VmdWwtZnMgc2hhcmVkIHF1ZXVlXG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgcmVzZXRRdWV1ZSgpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb3NlLCBwcmV2aW91c1N5bWJvbCwge1xuICAgICAgdmFsdWU6IGZzJGNsb3NlXG4gICAgfSlcbiAgICByZXR1cm4gY2xvc2VcbiAgfSkoZnMuY2xvc2UpXG5cbiAgZnMuY2xvc2VTeW5jID0gKGZ1bmN0aW9uIChmcyRjbG9zZVN5bmMpIHtcbiAgICBmdW5jdGlvbiBjbG9zZVN5bmMgKGZkKSB7XG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIHVzZXMgdGhlIGdyYWNlZnVsLWZzIHNoYXJlZCBxdWV1ZVxuICAgICAgZnMkY2xvc2VTeW5jLmFwcGx5KGZzLCBhcmd1bWVudHMpXG4gICAgICByZXNldFF1ZXVlKClcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xvc2VTeW5jLCBwcmV2aW91c1N5bWJvbCwge1xuICAgICAgdmFsdWU6IGZzJGNsb3NlU3luY1xuICAgIH0pXG4gICAgcmV0dXJuIGNsb3NlU3luY1xuICB9KShmcy5jbG9zZVN5bmMpXG5cbiAgaWYgKC9cXGJnZnM0XFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnKSkge1xuICAgIHByb2Nlc3Mub24oJ2V4aXQnLCBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKGZzW2dyYWNlZnVsUXVldWVdKVxuICAgICAgcmVxdWlyZSgnYXNzZXJ0JykuZXF1YWwoZnNbZ3JhY2VmdWxRdWV1ZV0ubGVuZ3RoLCAwKVxuICAgIH0pXG4gIH1cbn1cblxuaWYgKCFnbG9iYWxbZ3JhY2VmdWxRdWV1ZV0pIHtcbiAgcHVibGlzaFF1ZXVlKGdsb2JhbCwgZnNbZ3JhY2VmdWxRdWV1ZV0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoKGNsb25lKGZzKSlcbmlmIChwcm9jZXNzLmVudi5URVNUX0dSQUNFRlVMX0ZTX0dMT0JBTF9QQVRDSCAmJiAhZnMuX19wYXRjaGVkKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwYXRjaChmcylcbiAgICBmcy5fX3BhdGNoZWQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBwYXRjaCAoZnMpIHtcbiAgLy8gRXZlcnl0aGluZyB0aGF0IHJlZmVyZW5jZXMgdGhlIG9wZW4oKSBmdW5jdGlvbiBuZWVkcyB0byBiZSBpbiBoZXJlXG4gIHBvbHlmaWxscyhmcylcbiAgZnMuZ3JhY2VmdWxpZnkgPSBwYXRjaFxuXG4gIGZzLmNyZWF0ZVJlYWRTdHJlYW0gPSBjcmVhdGVSZWFkU3RyZWFtXG4gIGZzLmNyZWF0ZVdyaXRlU3RyZWFtID0gY3JlYXRlV3JpdGVTdHJlYW1cbiAgdmFyIGZzJHJlYWRGaWxlID0gZnMucmVhZEZpbGVcbiAgZnMucmVhZEZpbGUgPSByZWFkRmlsZVxuICBmdW5jdGlvbiByZWFkRmlsZSAocGF0aCwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG9wdGlvbnMsIG9wdGlvbnMgPSBudWxsXG5cbiAgICByZXR1cm4gZ28kcmVhZEZpbGUocGF0aCwgb3B0aW9ucywgY2IpXG5cbiAgICBmdW5jdGlvbiBnbyRyZWFkRmlsZSAocGF0aCwgb3B0aW9ucywgY2IsIHN0YXJ0VGltZSkge1xuICAgICAgcmV0dXJuIGZzJHJlYWRGaWxlKHBhdGgsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kcmVhZEZpbGUsIFtwYXRoLCBvcHRpb25zLCBjYl0sIGVyciwgc3RhcnRUaW1lIHx8IERhdGUubm93KCksIERhdGUubm93KCldKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyR3cml0ZUZpbGUgPSBmcy53cml0ZUZpbGVcbiAgZnMud3JpdGVGaWxlID0gd3JpdGVGaWxlXG4gIGZ1bmN0aW9uIHdyaXRlRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG9wdGlvbnMsIG9wdGlvbnMgPSBudWxsXG5cbiAgICByZXR1cm4gZ28kd3JpdGVGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kd3JpdGVGaWxlIChwYXRoLCBkYXRhLCBvcHRpb25zLCBjYiwgc3RhcnRUaW1lKSB7XG4gICAgICByZXR1cm4gZnMkd3JpdGVGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kd3JpdGVGaWxlLCBbcGF0aCwgZGF0YSwgb3B0aW9ucywgY2JdLCBlcnIsIHN0YXJ0VGltZSB8fCBEYXRlLm5vdygpLCBEYXRlLm5vdygpXSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICB2YXIgZnMkYXBwZW5kRmlsZSA9IGZzLmFwcGVuZEZpbGVcbiAgaWYgKGZzJGFwcGVuZEZpbGUpXG4gICAgZnMuYXBwZW5kRmlsZSA9IGFwcGVuZEZpbGVcbiAgZnVuY3Rpb24gYXBwZW5kRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG9wdGlvbnMsIG9wdGlvbnMgPSBudWxsXG5cbiAgICByZXR1cm4gZ28kYXBwZW5kRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBjYilcblxuICAgIGZ1bmN0aW9uIGdvJGFwcGVuZEZpbGUgKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiLCBzdGFydFRpbWUpIHtcbiAgICAgIHJldHVybiBmcyRhcHBlbmRGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kYXBwZW5kRmlsZSwgW3BhdGgsIGRhdGEsIG9wdGlvbnMsIGNiXSwgZXJyLCBzdGFydFRpbWUgfHwgRGF0ZS5ub3coKSwgRGF0ZS5ub3coKV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgdmFyIGZzJGNvcHlGaWxlID0gZnMuY29weUZpbGVcbiAgaWYgKGZzJGNvcHlGaWxlKVxuICAgIGZzLmNvcHlGaWxlID0gY29weUZpbGVcbiAgZnVuY3Rpb24gY29weUZpbGUgKHNyYywgZGVzdCwgZmxhZ3MsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBmbGFncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBmbGFnc1xuICAgICAgZmxhZ3MgPSAwXG4gICAgfVxuICAgIHJldHVybiBnbyRjb3B5RmlsZShzcmMsIGRlc3QsIGZsYWdzLCBjYilcblxuICAgIGZ1bmN0aW9uIGdvJGNvcHlGaWxlIChzcmMsIGRlc3QsIGZsYWdzLCBjYiwgc3RhcnRUaW1lKSB7XG4gICAgICByZXR1cm4gZnMkY29weUZpbGUoc3JjLCBkZXN0LCBmbGFncywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyICYmIChlcnIuY29kZSA9PT0gJ0VNRklMRScgfHwgZXJyLmNvZGUgPT09ICdFTkZJTEUnKSlcbiAgICAgICAgICBlbnF1ZXVlKFtnbyRjb3B5RmlsZSwgW3NyYywgZGVzdCwgZmxhZ3MsIGNiXSwgZXJyLCBzdGFydFRpbWUgfHwgRGF0ZS5ub3coKSwgRGF0ZS5ub3coKV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgdmFyIGZzJHJlYWRkaXIgPSBmcy5yZWFkZGlyXG4gIGZzLnJlYWRkaXIgPSByZWFkZGlyXG4gIGZ1bmN0aW9uIHJlYWRkaXIgKHBhdGgsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBvcHRpb25zLCBvcHRpb25zID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJHJlYWRkaXIocGF0aCwgb3B0aW9ucywgY2IpXG5cbiAgICBmdW5jdGlvbiBnbyRyZWFkZGlyIChwYXRoLCBvcHRpb25zLCBjYiwgc3RhcnRUaW1lKSB7XG4gICAgICByZXR1cm4gZnMkcmVhZGRpcihwYXRoLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCBmaWxlcykge1xuICAgICAgICBpZiAoZXJyICYmIChlcnIuY29kZSA9PT0gJ0VNRklMRScgfHwgZXJyLmNvZGUgPT09ICdFTkZJTEUnKSlcbiAgICAgICAgICBlbnF1ZXVlKFtnbyRyZWFkZGlyLCBbcGF0aCwgb3B0aW9ucywgY2JdLCBlcnIsIHN0YXJ0VGltZSB8fCBEYXRlLm5vdygpLCBEYXRlLm5vdygpXSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGZpbGVzICYmIGZpbGVzLnNvcnQpXG4gICAgICAgICAgICBmaWxlcy5zb3J0KClcblxuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5jYWxsKHRoaXMsIGVyciwgZmlsZXMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MudmVyc2lvbi5zdWJzdHIoMCwgNCkgPT09ICd2MC44Jykge1xuICAgIHZhciBsZWdTdHJlYW1zID0gbGVnYWN5KGZzKVxuICAgIFJlYWRTdHJlYW0gPSBsZWdTdHJlYW1zLlJlYWRTdHJlYW1cbiAgICBXcml0ZVN0cmVhbSA9IGxlZ1N0cmVhbXMuV3JpdGVTdHJlYW1cbiAgfVxuXG4gIHZhciBmcyRSZWFkU3RyZWFtID0gZnMuUmVhZFN0cmVhbVxuICBpZiAoZnMkUmVhZFN0cmVhbSkge1xuICAgIFJlYWRTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShmcyRSZWFkU3RyZWFtLnByb3RvdHlwZSlcbiAgICBSZWFkU3RyZWFtLnByb3RvdHlwZS5vcGVuID0gUmVhZFN0cmVhbSRvcGVuXG4gIH1cblxuICB2YXIgZnMkV3JpdGVTdHJlYW0gPSBmcy5Xcml0ZVN0cmVhbVxuICBpZiAoZnMkV3JpdGVTdHJlYW0pIHtcbiAgICBXcml0ZVN0cmVhbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGZzJFdyaXRlU3RyZWFtLnByb3RvdHlwZSlcbiAgICBXcml0ZVN0cmVhbS5wcm90b3R5cGUub3BlbiA9IFdyaXRlU3RyZWFtJG9wZW5cbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmcywgJ1JlYWRTdHJlYW0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gUmVhZFN0cmVhbVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBSZWFkU3RyZWFtID0gdmFsXG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnMsICdXcml0ZVN0cmVhbScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBXcml0ZVN0cmVhbVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBXcml0ZVN0cmVhbSA9IHZhbFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcblxuICAvLyBsZWdhY3kgbmFtZXNcbiAgdmFyIEZpbGVSZWFkU3RyZWFtID0gUmVhZFN0cmVhbVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnMsICdGaWxlUmVhZFN0cmVhbScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBGaWxlUmVhZFN0cmVhbVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBGaWxlUmVhZFN0cmVhbSA9IHZhbFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcbiAgdmFyIEZpbGVXcml0ZVN0cmVhbSA9IFdyaXRlU3RyZWFtXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmcywgJ0ZpbGVXcml0ZVN0cmVhbScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBGaWxlV3JpdGVTdHJlYW1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgRmlsZVdyaXRlU3RyZWFtID0gdmFsXG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxuXG4gIGZ1bmN0aW9uIFJlYWRTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFJlYWRTdHJlYW0pXG4gICAgICByZXR1cm4gZnMkUmVhZFN0cmVhbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0aGlzXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIFJlYWRTdHJlYW0uYXBwbHkoT2JqZWN0LmNyZWF0ZShSZWFkU3RyZWFtLnByb3RvdHlwZSksIGFyZ3VtZW50cylcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlYWRTdHJlYW0kb3BlbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgb3Blbih0aGF0LnBhdGgsIHRoYXQuZmxhZ3MsIHRoYXQubW9kZSwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKHRoYXQuYXV0b0Nsb3NlKVxuICAgICAgICAgIHRoYXQuZGVzdHJveSgpXG5cbiAgICAgICAgdGhhdC5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoYXQuZmQgPSBmZFxuICAgICAgICB0aGF0LmVtaXQoJ29wZW4nLCBmZClcbiAgICAgICAgdGhhdC5yZWFkKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gV3JpdGVTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFdyaXRlU3RyZWFtKVxuICAgICAgcmV0dXJuIGZzJFdyaXRlU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRoaXNcbiAgICBlbHNlXG4gICAgICByZXR1cm4gV3JpdGVTdHJlYW0uYXBwbHkoT2JqZWN0LmNyZWF0ZShXcml0ZVN0cmVhbS5wcm90b3R5cGUpLCBhcmd1bWVudHMpXG4gIH1cblxuICBmdW5jdGlvbiBXcml0ZVN0cmVhbSRvcGVuICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICBvcGVuKHRoYXQucGF0aCwgdGhhdC5mbGFncywgdGhhdC5tb2RlLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGF0LmRlc3Ryb3koKVxuICAgICAgICB0aGF0LmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhhdC5mZCA9IGZkXG4gICAgICAgIHRoYXQuZW1pdCgnb3BlbicsIGZkKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSZWFkU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBmcy5SZWFkU3RyZWFtKHBhdGgsIG9wdGlvbnMpXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVXcml0ZVN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgZnMuV3JpdGVTdHJlYW0ocGF0aCwgb3B0aW9ucylcbiAgfVxuXG4gIHZhciBmcyRvcGVuID0gZnMub3BlblxuICBmcy5vcGVuID0gb3BlblxuICBmdW5jdGlvbiBvcGVuIChwYXRoLCBmbGFncywgbW9kZSwgY2IpIHtcbiAgICBpZiAodHlwZW9mIG1vZGUgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG1vZGUsIG1vZGUgPSBudWxsXG5cbiAgICByZXR1cm4gZ28kb3BlbihwYXRoLCBmbGFncywgbW9kZSwgY2IpXG5cbiAgICBmdW5jdGlvbiBnbyRvcGVuIChwYXRoLCBmbGFncywgbW9kZSwgY2IsIHN0YXJ0VGltZSkge1xuICAgICAgcmV0dXJuIGZzJG9wZW4ocGF0aCwgZmxhZ3MsIG1vZGUsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJG9wZW4sIFtwYXRoLCBmbGFncywgbW9kZSwgY2JdLCBlcnIsIHN0YXJ0VGltZSB8fCBEYXRlLm5vdygpLCBEYXRlLm5vdygpXSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnNcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZSAoZWxlbSkge1xuICBkZWJ1ZygnRU5RVUVVRScsIGVsZW1bMF0ubmFtZSwgZWxlbVsxXSlcbiAgZnNbZ3JhY2VmdWxRdWV1ZV0ucHVzaChlbGVtKVxuICByZXRyeSgpXG59XG5cbi8vIGtlZXAgdHJhY2sgb2YgdGhlIHRpbWVvdXQgYmV0d2VlbiByZXRyeSgpIGNhbGxzXG52YXIgcmV0cnlUaW1lclxuXG4vLyByZXNldCB0aGUgc3RhcnRUaW1lIGFuZCBsYXN0VGltZSB0byBub3dcbi8vIHRoaXMgcmVzZXRzIHRoZSBzdGFydCBvZiB0aGUgNjAgc2Vjb25kIG92ZXJhbGwgdGltZW91dCBhcyB3ZWxsIGFzIHRoZVxuLy8gZGVsYXkgYmV0d2VlbiBhdHRlbXB0cyBzbyB0aGF0IHdlJ2xsIHJldHJ5IHRoZXNlIGpvYnMgc29vbmVyXG5mdW5jdGlvbiByZXNldFF1ZXVlICgpIHtcbiAgdmFyIG5vdyA9IERhdGUubm93KClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmc1tncmFjZWZ1bFF1ZXVlXS5sZW5ndGg7ICsraSkge1xuICAgIC8vIGVudHJpZXMgdGhhdCBhcmUgb25seSBhIGxlbmd0aCBvZiAyIGFyZSBmcm9tIGFuIG9sZGVyIHZlcnNpb24sIGRvbid0XG4gICAgLy8gYm90aGVyIG1vZGlmeWluZyB0aG9zZSBzaW5jZSB0aGV5J2xsIGJlIHJldHJpZWQgYW55d2F5LlxuICAgIGlmIChmc1tncmFjZWZ1bFF1ZXVlXVtpXS5sZW5ndGggPiAyKSB7XG4gICAgICBmc1tncmFjZWZ1bFF1ZXVlXVtpXVszXSA9IG5vdyAvLyBzdGFydFRpbWVcbiAgICAgIGZzW2dyYWNlZnVsUXVldWVdW2ldWzRdID0gbm93IC8vIGxhc3RUaW1lXG4gICAgfVxuICB9XG4gIC8vIGNhbGwgcmV0cnkgdG8gbWFrZSBzdXJlIHdlJ3JlIGFjdGl2ZWx5IHByb2Nlc3NpbmcgdGhlIHF1ZXVlXG4gIHJldHJ5KClcbn1cblxuZnVuY3Rpb24gcmV0cnkgKCkge1xuICAvLyBjbGVhciB0aGUgdGltZXIgYW5kIHJlbW92ZSBpdCB0byBoZWxwIHByZXZlbnQgdW5pbnRlbmRlZCBjb25jdXJyZW5jeVxuICBjbGVhclRpbWVvdXQocmV0cnlUaW1lcilcbiAgcmV0cnlUaW1lciA9IHVuZGVmaW5lZFxuXG4gIGlmIChmc1tncmFjZWZ1bFF1ZXVlXS5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuXG5cbiAgdmFyIGVsZW0gPSBmc1tncmFjZWZ1bFF1ZXVlXS5zaGlmdCgpXG4gIHZhciBmbiA9IGVsZW1bMF1cbiAgdmFyIGFyZ3MgPSBlbGVtWzFdXG4gIC8vIHRoZXNlIGl0ZW1zIG1heSBiZSB1bnNldCBpZiB0aGV5IHdlcmUgYWRkZWQgYnkgYW4gb2xkZXIgZ3JhY2VmdWwtZnNcbiAgdmFyIGVyciA9IGVsZW1bMl1cbiAgdmFyIHN0YXJ0VGltZSA9IGVsZW1bM11cbiAgdmFyIGxhc3RUaW1lID0gZWxlbVs0XVxuXG4gIC8vIGlmIHdlIGRvbid0IGhhdmUgYSBzdGFydFRpbWUgd2UgaGF2ZSBubyB3YXkgb2Yga25vd2luZyBpZiB3ZSd2ZSB3YWl0ZWRcbiAgLy8gbG9uZyBlbm91Z2gsIHNvIGdvIGFoZWFkIGFuZCByZXRyeSB0aGlzIGl0ZW0gbm93XG4gIGlmIChzdGFydFRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIGRlYnVnKCdSRVRSWScsIGZuLm5hbWUsIGFyZ3MpXG4gICAgZm4uYXBwbHkobnVsbCwgYXJncylcbiAgfSBlbHNlIGlmIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lID49IDYwMDAwKSB7XG4gICAgLy8gaXQncyBiZWVuIG1vcmUgdGhhbiA2MCBzZWNvbmRzIHRvdGFsLCBiYWlsIG5vd1xuICAgIGRlYnVnKCdUSU1FT1VUJywgZm4ubmFtZSwgYXJncylcbiAgICB2YXIgY2IgPSBhcmdzLnBvcCgpXG4gICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiLmNhbGwobnVsbCwgZXJyKVxuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBhbW91bnQgb2YgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGF0dGVtcHQgYW5kIHJpZ2h0IG5vd1xuICAgIHZhciBzaW5jZUF0dGVtcHQgPSBEYXRlLm5vdygpIC0gbGFzdFRpbWVcbiAgICAvLyB0aGUgYW1vdW50IG9mIHRpbWUgYmV0d2VlbiB3aGVuIHdlIGZpcnN0IHRyaWVkLCBhbmQgd2hlbiB3ZSBsYXN0IHRyaWVkXG4gICAgLy8gcm91bmRlZCB1cCB0byBhdCBsZWFzdCAxXG4gICAgdmFyIHNpbmNlU3RhcnQgPSBNYXRoLm1heChsYXN0VGltZSAtIHN0YXJ0VGltZSwgMSlcbiAgICAvLyBiYWNrb2ZmLiB3YWl0IGxvbmdlciB0aGFuIHRoZSB0b3RhbCB0aW1lIHdlJ3ZlIGJlZW4gcmV0cnlpbmcsIGJ1dCBvbmx5XG4gICAgLy8gdXAgdG8gYSBtYXhpbXVtIG9mIDEwMG1zXG4gICAgdmFyIGRlc2lyZWREZWxheSA9IE1hdGgubWluKHNpbmNlU3RhcnQgKiAxLjIsIDEwMClcbiAgICAvLyBpdCdzIGJlZW4gbG9uZyBlbm91Z2ggc2luY2UgdGhlIGxhc3QgcmV0cnksIGRvIGl0IGFnYWluXG4gICAgaWYgKHNpbmNlQXR0ZW1wdCA+PSBkZXNpcmVkRGVsYXkpIHtcbiAgICAgIGRlYnVnKCdSRVRSWScsIGZuLm5hbWUsIGFyZ3MpXG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChbc3RhcnRUaW1lXSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIHdlIGNhbid0IGRvIHRoaXMgam9iIHlldCwgcHVzaCBpdCB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuICAgICAgLy8gYW5kIGxldCB0aGUgbmV4dCBpdGVyYXRpb24gY2hlY2sgYWdhaW5cbiAgICAgIGZzW2dyYWNlZnVsUXVldWVdLnB1c2goZWxlbSlcbiAgICB9XG4gIH1cblxuICAvLyBzY2hlZHVsZSBvdXIgbmV4dCBydW4gaWYgb25lIGlzbid0IGFscmVhZHkgc2NoZWR1bGVkXG4gIGlmIChyZXRyeVRpbWVyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXRyeVRpbWVyID0gc2V0VGltZW91dChyZXRyeSwgMClcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG4vLyBUaGlzIGlzIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbm9ybWFsaXplL216XG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNiBKb25hdGhhbiBPbmcgbWVAam9uZ2xlYmVycnkuY29tIGFuZCBDb250cmlidXRvcnNcbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuXG5jb25zdCBhcGkgPSBbXG4gICdhY2Nlc3MnLFxuICAnYXBwZW5kRmlsZScsXG4gICdjaG1vZCcsXG4gICdjaG93bicsXG4gICdjbG9zZScsXG4gICdjb3B5RmlsZScsXG4gICdmY2htb2QnLFxuICAnZmNob3duJyxcbiAgJ2ZkYXRhc3luYycsXG4gICdmc3RhdCcsXG4gICdmc3luYycsXG4gICdmdHJ1bmNhdGUnLFxuICAnZnV0aW1lcycsXG4gICdsY2htb2QnLFxuICAnbGNob3duJyxcbiAgJ2xpbmsnLFxuICAnbHN0YXQnLFxuICAnbWtkaXInLFxuICAnbWtkdGVtcCcsXG4gICdvcGVuJyxcbiAgJ29wZW5kaXInLFxuICAncmVhZGRpcicsXG4gICdyZWFkRmlsZScsXG4gICdyZWFkbGluaycsXG4gICdyZWFscGF0aCcsXG4gICdyZW5hbWUnLFxuICAncm0nLFxuICAncm1kaXInLFxuICAnc3RhdCcsXG4gICdzeW1saW5rJyxcbiAgJ3RydW5jYXRlJyxcbiAgJ3VubGluaycsXG4gICd1dGltZXMnLFxuICAnd3JpdGVGaWxlJ1xuXS5maWx0ZXIoa2V5ID0+IHtcbiAgLy8gU29tZSBjb21tYW5kcyBhcmUgbm90IGF2YWlsYWJsZSBvbiBzb21lIHN5c3RlbXMuIEV4OlxuICAvLyBmcy5vcGVuZGlyIHdhcyBhZGRlZCBpbiBOb2RlLmpzIHYxMi4xMi4wXG4gIC8vIGZzLnJtIHdhcyBhZGRlZCBpbiBOb2RlLmpzIHYxNC4xNC4wXG4gIC8vIGZzLmxjaG93biBpcyBub3QgYXZhaWxhYmxlIG9uIGF0IGxlYXN0IHNvbWUgTGludXhcbiAgcmV0dXJuIHR5cGVvZiBmc1trZXldID09PSAnZnVuY3Rpb24nXG59KVxuXG4vLyBFeHBvcnQgY2xvbmVkIGZzOlxuT2JqZWN0LmFzc2lnbihleHBvcnRzLCBmcylcblxuLy8gVW5pdmVyc2FsaWZ5IGFzeW5jIG1ldGhvZHM6XG5hcGkuZm9yRWFjaChtZXRob2QgPT4ge1xuICBleHBvcnRzW21ldGhvZF0gPSB1KGZzW21ldGhvZF0pXG59KVxuZXhwb3J0cy5yZWFscGF0aC5uYXRpdmUgPSB1KGZzLnJlYWxwYXRoLm5hdGl2ZSlcblxuLy8gV2UgZGlmZmVyIGZyb20gbXovZnMgaW4gdGhhdCB3ZSBzdGlsbCBzaGlwIHRoZSBvbGQsIGJyb2tlbiwgZnMuZXhpc3RzKClcbi8vIHNpbmNlIHdlIGFyZSBhIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIHRoZSBuYXRpdmUgbW9kdWxlXG5leHBvcnRzLmV4aXN0cyA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmcy5leGlzdHMoZmlsZW5hbWUsIGNhbGxiYWNrKVxuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICByZXR1cm4gZnMuZXhpc3RzKGZpbGVuYW1lLCByZXNvbHZlKVxuICB9KVxufVxuXG4vLyBmcy5yZWFkKCksIGZzLndyaXRlKCksICYgZnMud3JpdGV2KCkgbmVlZCBzcGVjaWFsIHRyZWF0bWVudCBkdWUgdG8gbXVsdGlwbGUgY2FsbGJhY2sgYXJnc1xuXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZzLnJlYWQoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaylcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZzLnJlYWQoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCAoZXJyLCBieXRlc1JlYWQsIGJ1ZmZlcikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICByZXNvbHZlKHsgYnl0ZXNSZWFkLCBidWZmZXIgfSlcbiAgICB9KVxuICB9KVxufVxuXG4vLyBGdW5jdGlvbiBzaWduYXR1cmUgY2FuIGJlXG4vLyBmcy53cml0ZShmZCwgYnVmZmVyWywgb2Zmc2V0WywgbGVuZ3RoWywgcG9zaXRpb25dXV0sIGNhbGxiYWNrKVxuLy8gT1Jcbi8vIGZzLndyaXRlKGZkLCBzdHJpbmdbLCBwb3NpdGlvblssIGVuY29kaW5nXV0sIGNhbGxiYWNrKVxuLy8gV2UgbmVlZCB0byBoYW5kbGUgYm90aCBjYXNlcywgc28gd2UgdXNlIC4uLmFyZ3NcbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoZmQsIGJ1ZmZlciwgLi4uYXJncykge1xuICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmcy53cml0ZShmZCwgYnVmZmVyLCAuLi5hcmdzKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmcy53cml0ZShmZCwgYnVmZmVyLCAuLi5hcmdzLCAoZXJyLCBieXRlc1dyaXR0ZW4sIGJ1ZmZlcikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICByZXNvbHZlKHsgYnl0ZXNXcml0dGVuLCBidWZmZXIgfSlcbiAgICB9KVxuICB9KVxufVxuXG4vLyBmcy53cml0ZXYgb25seSBhdmFpbGFibGUgaW4gTm9kZSB2MTIuOS4wK1xuaWYgKHR5cGVvZiBmcy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gRnVuY3Rpb24gc2lnbmF0dXJlIGlzXG4gIC8vIHMud3JpdGV2KGZkLCBidWZmZXJzWywgcG9zaXRpb25dLCBjYWxsYmFjaylcbiAgLy8gV2UgbmVlZCB0byBoYW5kbGUgdGhlIG9wdGlvbmFsIGFyZywgc28gd2UgdXNlIC4uLmFyZ3NcbiAgZXhwb3J0cy53cml0ZXYgPSBmdW5jdGlvbiAoZmQsIGJ1ZmZlcnMsIC4uLmFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGZzLndyaXRldihmZCwgYnVmZmVycywgLi4uYXJncylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZnMud3JpdGV2KGZkLCBidWZmZXJzLCAuLi5hcmdzLCAoZXJyLCBieXRlc1dyaXR0ZW4sIGJ1ZmZlcnMpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICAgIHJlc29sdmUoeyBieXRlc1dyaXR0ZW4sIGJ1ZmZlcnMgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuIiwiLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvbWFrZS1kaXJcbi8vIENvcHlyaWdodCAoYykgU2luZHJlIFNvcmh1cyA8c2luZHJlc29yaHVzQGdtYWlsLmNvbT4gKHNpbmRyZXNvcmh1cy5jb20pXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbid1c2Ugc3RyaWN0J1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzg5ODdcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9saWJ1di9saWJ1di9wdWxsLzEwODhcbm1vZHVsZS5leHBvcnRzLmNoZWNrUGF0aCA9IGZ1bmN0aW9uIGNoZWNrUGF0aCAocHRoKSB7XG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgY29uc3QgcGF0aEhhc0ludmFsaWRXaW5DaGFyYWN0ZXJzID0gL1s8PjpcInw/Kl0vLnRlc3QocHRoLnJlcGxhY2UocGF0aC5wYXJzZShwdGgpLnJvb3QsICcnKSlcblxuICAgIGlmIChwYXRoSGFzSW52YWxpZFdpbkNoYXJhY3RlcnMpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBQYXRoIGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVyczogJHtwdGh9YClcbiAgICAgIGVycm9yLmNvZGUgPSAnRUlOVkFMJ1xuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5jb25zdCB7IGNoZWNrUGF0aCB9ID0gcmVxdWlyZSgnLi91dGlscycpXG5cbmNvbnN0IGdldE1vZGUgPSBvcHRpb25zID0+IHtcbiAgY29uc3QgZGVmYXVsdHMgPSB7IG1vZGU6IDBvNzc3IH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykgcmV0dXJuIG9wdGlvbnNcbiAgcmV0dXJuICh7IC4uLmRlZmF1bHRzLCAuLi5vcHRpb25zIH0pLm1vZGVcbn1cblxubW9kdWxlLmV4cG9ydHMubWFrZURpciA9IGFzeW5jIChkaXIsIG9wdGlvbnMpID0+IHtcbiAgY2hlY2tQYXRoKGRpcilcblxuICByZXR1cm4gZnMubWtkaXIoZGlyLCB7XG4gICAgbW9kZTogZ2V0TW9kZShvcHRpb25zKSxcbiAgICByZWN1cnNpdmU6IHRydWVcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMubWFrZURpclN5bmMgPSAoZGlyLCBvcHRpb25zKSA9PiB7XG4gIGNoZWNrUGF0aChkaXIpXG5cbiAgcmV0dXJuIGZzLm1rZGlyU3luYyhkaXIsIHtcbiAgICBtb2RlOiBnZXRNb2RlKG9wdGlvbnMpLFxuICAgIHJlY3Vyc2l2ZTogdHJ1ZVxuICB9KVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2VcbmNvbnN0IHsgbWFrZURpcjogX21ha2VEaXIsIG1ha2VEaXJTeW5jIH0gPSByZXF1aXJlKCcuL21ha2UtZGlyJylcbmNvbnN0IG1ha2VEaXIgPSB1KF9tYWtlRGlyKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWtkaXJzOiBtYWtlRGlyLFxuICBta2RpcnNTeW5jOiBtYWtlRGlyU3luYyxcbiAgLy8gYWxpYXNcbiAgbWtkaXJwOiBtYWtlRGlyLFxuICBta2RpcnBTeW5jOiBtYWtlRGlyU3luYyxcbiAgZW5zdXJlRGlyOiBtYWtlRGlyLFxuICBlbnN1cmVEaXJTeW5jOiBtYWtlRGlyU3luY1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuXG5mdW5jdGlvbiB1dGltZXNNaWxsaXMgKHBhdGgsIGF0aW1lLCBtdGltZSwgY2FsbGJhY2spIHtcbiAgLy8gaWYgKCFIQVNfTUlMTElTX1JFUykgcmV0dXJuIGZzLnV0aW1lcyhwYXRoLCBhdGltZSwgbXRpbWUsIGNhbGxiYWNrKVxuICBmcy5vcGVuKHBhdGgsICdyKycsIChlcnIsIGZkKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICBmcy5mdXRpbWVzKGZkLCBhdGltZSwgbXRpbWUsIGZ1dGltZXNFcnIgPT4ge1xuICAgICAgZnMuY2xvc2UoZmQsIGNsb3NlRXJyID0+IHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhmdXRpbWVzRXJyIHx8IGNsb3NlRXJyKVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiB1dGltZXNNaWxsaXNTeW5jIChwYXRoLCBhdGltZSwgbXRpbWUpIHtcbiAgY29uc3QgZmQgPSBmcy5vcGVuU3luYyhwYXRoLCAncisnKVxuICBmcy5mdXRpbWVzU3luYyhmZCwgYXRpbWUsIG10aW1lKVxuICByZXR1cm4gZnMuY2xvc2VTeW5jKGZkKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdXRpbWVzTWlsbGlzLFxuICB1dGltZXNNaWxsaXNTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG5cbmZ1bmN0aW9uIGdldFN0YXRzIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgY29uc3Qgc3RhdEZ1bmMgPSBvcHRzLmRlcmVmZXJlbmNlXG4gICAgPyAoZmlsZSkgPT4gZnMuc3RhdChmaWxlLCB7IGJpZ2ludDogdHJ1ZSB9KVxuICAgIDogKGZpbGUpID0+IGZzLmxzdGF0KGZpbGUsIHsgYmlnaW50OiB0cnVlIH0pXG4gIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgc3RhdEZ1bmMoc3JjKSxcbiAgICBzdGF0RnVuYyhkZXN0KS5jYXRjaChlcnIgPT4ge1xuICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykgcmV0dXJuIG51bGxcbiAgICAgIHRocm93IGVyclxuICAgIH0pXG4gIF0pLnRoZW4oKFtzcmNTdGF0LCBkZXN0U3RhdF0pID0+ICh7IHNyY1N0YXQsIGRlc3RTdGF0IH0pKVxufVxuXG5mdW5jdGlvbiBnZXRTdGF0c1N5bmMgKHNyYywgZGVzdCwgb3B0cykge1xuICBsZXQgZGVzdFN0YXRcbiAgY29uc3Qgc3RhdEZ1bmMgPSBvcHRzLmRlcmVmZXJlbmNlXG4gICAgPyAoZmlsZSkgPT4gZnMuc3RhdFN5bmMoZmlsZSwgeyBiaWdpbnQ6IHRydWUgfSlcbiAgICA6IChmaWxlKSA9PiBmcy5sc3RhdFN5bmMoZmlsZSwgeyBiaWdpbnQ6IHRydWUgfSlcbiAgY29uc3Qgc3JjU3RhdCA9IHN0YXRGdW5jKHNyYylcbiAgdHJ5IHtcbiAgICBkZXN0U3RhdCA9IHN0YXRGdW5jKGRlc3QpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHJldHVybiB7IHNyY1N0YXQsIGRlc3RTdGF0OiBudWxsIH1cbiAgICB0aHJvdyBlcnJcbiAgfVxuICByZXR1cm4geyBzcmNTdGF0LCBkZXN0U3RhdCB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUGF0aHMgKHNyYywgZGVzdCwgZnVuY05hbWUsIG9wdHMsIGNiKSB7XG4gIHV0aWwuY2FsbGJhY2tpZnkoZ2V0U3RhdHMpKHNyYywgZGVzdCwgb3B0cywgKGVyciwgc3RhdHMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGNvbnN0IHsgc3JjU3RhdCwgZGVzdFN0YXQgfSA9IHN0YXRzXG5cbiAgICBpZiAoZGVzdFN0YXQpIHtcbiAgICAgIGlmIChhcmVJZGVudGljYWwoc3JjU3RhdCwgZGVzdFN0YXQpKSB7XG4gICAgICAgIGNvbnN0IHNyY0Jhc2VOYW1lID0gcGF0aC5iYXNlbmFtZShzcmMpXG4gICAgICAgIGNvbnN0IGRlc3RCYXNlTmFtZSA9IHBhdGguYmFzZW5hbWUoZGVzdClcbiAgICAgICAgaWYgKGZ1bmNOYW1lID09PSAnbW92ZScgJiZcbiAgICAgICAgICBzcmNCYXNlTmFtZSAhPT0gZGVzdEJhc2VOYW1lICYmXG4gICAgICAgICAgc3JjQmFzZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gZGVzdEJhc2VOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICByZXR1cm4gY2IobnVsbCwgeyBzcmNTdGF0LCBkZXN0U3RhdCwgaXNDaGFuZ2luZ0Nhc2U6IHRydWUgfSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdTb3VyY2UgYW5kIGRlc3RpbmF0aW9uIG11c3Qgbm90IGJlIHRoZSBzYW1lLicpKVxuICAgICAgfVxuICAgICAgaWYgKHNyY1N0YXQuaXNEaXJlY3RvcnkoKSAmJiAhZGVzdFN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKGBDYW5ub3Qgb3ZlcndyaXRlIG5vbi1kaXJlY3RvcnkgJyR7ZGVzdH0nIHdpdGggZGlyZWN0b3J5ICcke3NyY30nLmApKVxuICAgICAgfVxuICAgICAgaWYgKCFzcmNTdGF0LmlzRGlyZWN0b3J5KCkgJiYgZGVzdFN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKGBDYW5ub3Qgb3ZlcndyaXRlIGRpcmVjdG9yeSAnJHtkZXN0fScgd2l0aCBub24tZGlyZWN0b3J5ICcke3NyY30nLmApKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzcmNTdGF0LmlzRGlyZWN0b3J5KCkgJiYgaXNTcmNTdWJkaXIoc3JjLCBkZXN0KSkge1xuICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihlcnJNc2coc3JjLCBkZXN0LCBmdW5jTmFtZSkpKVxuICAgIH1cbiAgICByZXR1cm4gY2IobnVsbCwgeyBzcmNTdGF0LCBkZXN0U3RhdCB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjaGVja1BhdGhzU3luYyAoc3JjLCBkZXN0LCBmdW5jTmFtZSwgb3B0cykge1xuICBjb25zdCB7IHNyY1N0YXQsIGRlc3RTdGF0IH0gPSBnZXRTdGF0c1N5bmMoc3JjLCBkZXN0LCBvcHRzKVxuXG4gIGlmIChkZXN0U3RhdCkge1xuICAgIGlmIChhcmVJZGVudGljYWwoc3JjU3RhdCwgZGVzdFN0YXQpKSB7XG4gICAgICBjb25zdCBzcmNCYXNlTmFtZSA9IHBhdGguYmFzZW5hbWUoc3JjKVxuICAgICAgY29uc3QgZGVzdEJhc2VOYW1lID0gcGF0aC5iYXNlbmFtZShkZXN0KVxuICAgICAgaWYgKGZ1bmNOYW1lID09PSAnbW92ZScgJiZcbiAgICAgICAgc3JjQmFzZU5hbWUgIT09IGRlc3RCYXNlTmFtZSAmJlxuICAgICAgICBzcmNCYXNlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBkZXN0QmFzZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICByZXR1cm4geyBzcmNTdGF0LCBkZXN0U3RhdCwgaXNDaGFuZ2luZ0Nhc2U6IHRydWUgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTb3VyY2UgYW5kIGRlc3RpbmF0aW9uIG11c3Qgbm90IGJlIHRoZSBzYW1lLicpXG4gICAgfVxuICAgIGlmIChzcmNTdGF0LmlzRGlyZWN0b3J5KCkgJiYgIWRlc3RTdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IG92ZXJ3cml0ZSBub24tZGlyZWN0b3J5ICcke2Rlc3R9JyB3aXRoIGRpcmVjdG9yeSAnJHtzcmN9Jy5gKVxuICAgIH1cbiAgICBpZiAoIXNyY1N0YXQuaXNEaXJlY3RvcnkoKSAmJiBkZXN0U3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBvdmVyd3JpdGUgZGlyZWN0b3J5ICcke2Rlc3R9JyB3aXRoIG5vbi1kaXJlY3RvcnkgJyR7c3JjfScuYClcbiAgICB9XG4gIH1cblxuICBpZiAoc3JjU3RhdC5pc0RpcmVjdG9yeSgpICYmIGlzU3JjU3ViZGlyKHNyYywgZGVzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKHNyYywgZGVzdCwgZnVuY05hbWUpKVxuICB9XG4gIHJldHVybiB7IHNyY1N0YXQsIGRlc3RTdGF0IH1cbn1cblxuLy8gcmVjdXJzaXZlbHkgY2hlY2sgaWYgZGVzdCBwYXJlbnQgaXMgYSBzdWJkaXJlY3Rvcnkgb2Ygc3JjLlxuLy8gSXQgd29ya3MgZm9yIGFsbCBmaWxlIHR5cGVzIGluY2x1ZGluZyBzeW1saW5rcyBzaW5jZSBpdFxuLy8gY2hlY2tzIHRoZSBzcmMgYW5kIGRlc3QgaW5vZGVzLiBJdCBzdGFydHMgZnJvbSB0aGUgZGVlcGVzdFxuLy8gcGFyZW50IGFuZCBzdG9wcyBvbmNlIGl0IHJlYWNoZXMgdGhlIHNyYyBwYXJlbnQgb3IgdGhlIHJvb3QgcGF0aC5cbmZ1bmN0aW9uIGNoZWNrUGFyZW50UGF0aHMgKHNyYywgc3JjU3RhdCwgZGVzdCwgZnVuY05hbWUsIGNiKSB7XG4gIGNvbnN0IHNyY1BhcmVudCA9IHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUoc3JjKSlcbiAgY29uc3QgZGVzdFBhcmVudCA9IHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUoZGVzdCkpXG4gIGlmIChkZXN0UGFyZW50ID09PSBzcmNQYXJlbnQgfHwgZGVzdFBhcmVudCA9PT0gcGF0aC5wYXJzZShkZXN0UGFyZW50KS5yb290KSByZXR1cm4gY2IoKVxuICBmcy5zdGF0KGRlc3RQYXJlbnQsIHsgYmlnaW50OiB0cnVlIH0sIChlcnIsIGRlc3RTdGF0KSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykgcmV0dXJuIGNiKClcbiAgICAgIHJldHVybiBjYihlcnIpXG4gICAgfVxuICAgIGlmIChhcmVJZGVudGljYWwoc3JjU3RhdCwgZGVzdFN0YXQpKSB7XG4gICAgICByZXR1cm4gY2IobmV3IEVycm9yKGVyck1zZyhzcmMsIGRlc3QsIGZ1bmNOYW1lKSkpXG4gICAgfVxuICAgIHJldHVybiBjaGVja1BhcmVudFBhdGhzKHNyYywgc3JjU3RhdCwgZGVzdFBhcmVudCwgZnVuY05hbWUsIGNiKVxuICB9KVxufVxuXG5mdW5jdGlvbiBjaGVja1BhcmVudFBhdGhzU3luYyAoc3JjLCBzcmNTdGF0LCBkZXN0LCBmdW5jTmFtZSkge1xuICBjb25zdCBzcmNQYXJlbnQgPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKHNyYykpXG4gIGNvbnN0IGRlc3RQYXJlbnQgPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKGRlc3QpKVxuICBpZiAoZGVzdFBhcmVudCA9PT0gc3JjUGFyZW50IHx8IGRlc3RQYXJlbnQgPT09IHBhdGgucGFyc2UoZGVzdFBhcmVudCkucm9vdCkgcmV0dXJuXG4gIGxldCBkZXN0U3RhdFxuICB0cnkge1xuICAgIGRlc3RTdGF0ID0gZnMuc3RhdFN5bmMoZGVzdFBhcmVudCwgeyBiaWdpbnQ6IHRydWUgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykgcmV0dXJuXG4gICAgdGhyb3cgZXJyXG4gIH1cbiAgaWYgKGFyZUlkZW50aWNhbChzcmNTdGF0LCBkZXN0U3RhdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKHNyYywgZGVzdCwgZnVuY05hbWUpKVxuICB9XG4gIHJldHVybiBjaGVja1BhcmVudFBhdGhzU3luYyhzcmMsIHNyY1N0YXQsIGRlc3RQYXJlbnQsIGZ1bmNOYW1lKVxufVxuXG5mdW5jdGlvbiBhcmVJZGVudGljYWwgKHNyY1N0YXQsIGRlc3RTdGF0KSB7XG4gIHJldHVybiBkZXN0U3RhdC5pbm8gJiYgZGVzdFN0YXQuZGV2ICYmIGRlc3RTdGF0LmlubyA9PT0gc3JjU3RhdC5pbm8gJiYgZGVzdFN0YXQuZGV2ID09PSBzcmNTdGF0LmRldlxufVxuXG4vLyByZXR1cm4gdHJ1ZSBpZiBkZXN0IGlzIGEgc3ViZGlyIG9mIHNyYywgb3RoZXJ3aXNlIGZhbHNlLlxuLy8gSXQgb25seSBjaGVja3MgdGhlIHBhdGggc3RyaW5ncy5cbmZ1bmN0aW9uIGlzU3JjU3ViZGlyIChzcmMsIGRlc3QpIHtcbiAgY29uc3Qgc3JjQXJyID0gcGF0aC5yZXNvbHZlKHNyYykuc3BsaXQocGF0aC5zZXApLmZpbHRlcihpID0+IGkpXG4gIGNvbnN0IGRlc3RBcnIgPSBwYXRoLnJlc29sdmUoZGVzdCkuc3BsaXQocGF0aC5zZXApLmZpbHRlcihpID0+IGkpXG4gIHJldHVybiBzcmNBcnIucmVkdWNlKChhY2MsIGN1ciwgaSkgPT4gYWNjICYmIGRlc3RBcnJbaV0gPT09IGN1ciwgdHJ1ZSlcbn1cblxuZnVuY3Rpb24gZXJyTXNnIChzcmMsIGRlc3QsIGZ1bmNOYW1lKSB7XG4gIHJldHVybiBgQ2Fubm90ICR7ZnVuY05hbWV9ICcke3NyY30nIHRvIGEgc3ViZGlyZWN0b3J5IG9mIGl0c2VsZiwgJyR7ZGVzdH0nLmBcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNoZWNrUGF0aHMsXG4gIGNoZWNrUGF0aHNTeW5jLFxuICBjaGVja1BhcmVudFBhdGhzLFxuICBjaGVja1BhcmVudFBhdGhzU3luYyxcbiAgaXNTcmNTdWJkaXIsXG4gIGFyZUlkZW50aWNhbFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgbWtkaXJzU3luYyA9IHJlcXVpcmUoJy4uL21rZGlycycpLm1rZGlyc1N5bmNcbmNvbnN0IHV0aW1lc01pbGxpc1N5bmMgPSByZXF1aXJlKCcuLi91dGlsL3V0aW1lcycpLnV0aW1lc01pbGxpc1N5bmNcbmNvbnN0IHN0YXQgPSByZXF1aXJlKCcuLi91dGlsL3N0YXQnKVxuXG5mdW5jdGlvbiBjb3B5U3luYyAoc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdHMgPSB7IGZpbHRlcjogb3B0cyB9XG4gIH1cblxuICBvcHRzID0gb3B0cyB8fCB7fVxuICBvcHRzLmNsb2JiZXIgPSAnY2xvYmJlcicgaW4gb3B0cyA/ICEhb3B0cy5jbG9iYmVyIDogdHJ1ZSAvLyBkZWZhdWx0IHRvIHRydWUgZm9yIG5vd1xuICBvcHRzLm92ZXJ3cml0ZSA9ICdvdmVyd3JpdGUnIGluIG9wdHMgPyAhIW9wdHMub3ZlcndyaXRlIDogb3B0cy5jbG9iYmVyIC8vIG92ZXJ3cml0ZSBmYWxscyBiYWNrIHRvIGNsb2JiZXJcblxuICAvLyBXYXJuIGFib3V0IHVzaW5nIHByZXNlcnZlVGltZXN0YW1wcyBvbiAzMi1iaXQgbm9kZVxuICBpZiAob3B0cy5wcmVzZXJ2ZVRpbWVzdGFtcHMgJiYgcHJvY2Vzcy5hcmNoID09PSAnaWEzMicpIHtcbiAgICBjb25zb2xlLndhcm4oYGZzLWV4dHJhOiBVc2luZyB0aGUgcHJlc2VydmVUaW1lc3RhbXBzIG9wdGlvbiBpbiAzMi1iaXQgbm9kZSBpcyBub3QgcmVjb21tZW5kZWQ7XFxuXG4gICAgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcHJpY2hhcmRzb24vbm9kZS1mcy1leHRyYS9pc3N1ZXMvMjY5YClcbiAgfVxuXG4gIGNvbnN0IHsgc3JjU3RhdCwgZGVzdFN0YXQgfSA9IHN0YXQuY2hlY2tQYXRoc1N5bmMoc3JjLCBkZXN0LCAnY29weScsIG9wdHMpXG4gIHN0YXQuY2hlY2tQYXJlbnRQYXRoc1N5bmMoc3JjLCBzcmNTdGF0LCBkZXN0LCAnY29weScpXG4gIHJldHVybiBoYW5kbGVGaWx0ZXJBbmRDb3B5KGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG59XG5cbmZ1bmN0aW9uIGhhbmRsZUZpbHRlckFuZENvcHkgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgaWYgKG9wdHMuZmlsdGVyICYmICFvcHRzLmZpbHRlcihzcmMsIGRlc3QpKSByZXR1cm5cbiAgY29uc3QgZGVzdFBhcmVudCA9IHBhdGguZGlybmFtZShkZXN0KVxuICBpZiAoIWZzLmV4aXN0c1N5bmMoZGVzdFBhcmVudCkpIG1rZGlyc1N5bmMoZGVzdFBhcmVudClcbiAgcmV0dXJuIGdldFN0YXRzKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29weSAoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBpZiAob3B0cy5maWx0ZXIgJiYgIW9wdHMuZmlsdGVyKHNyYywgZGVzdCkpIHJldHVyblxuICByZXR1cm4gZ2V0U3RhdHMoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdHMgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgY29uc3Qgc3RhdFN5bmMgPSBvcHRzLmRlcmVmZXJlbmNlID8gZnMuc3RhdFN5bmMgOiBmcy5sc3RhdFN5bmNcbiAgY29uc3Qgc3JjU3RhdCA9IHN0YXRTeW5jKHNyYylcblxuICBpZiAoc3JjU3RhdC5pc0RpcmVjdG9yeSgpKSByZXR1cm4gb25EaXIoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcbiAgZWxzZSBpZiAoc3JjU3RhdC5pc0ZpbGUoKSB8fFxuICAgICAgICAgICBzcmNTdGF0LmlzQ2hhcmFjdGVyRGV2aWNlKCkgfHxcbiAgICAgICAgICAgc3JjU3RhdC5pc0Jsb2NrRGV2aWNlKCkpIHJldHVybiBvbkZpbGUoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcbiAgZWxzZSBpZiAoc3JjU3RhdC5pc1N5bWJvbGljTGluaygpKSByZXR1cm4gb25MaW5rKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIGVsc2UgaWYgKHNyY1N0YXQuaXNTb2NrZXQoKSkgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29weSBhIHNvY2tldCBmaWxlOiAke3NyY31gKVxuICBlbHNlIGlmIChzcmNTdGF0LmlzRklGTygpKSB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb3B5IGEgRklGTyBwaXBlOiAke3NyY31gKVxuICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZmlsZTogJHtzcmN9YClcbn1cblxuZnVuY3Rpb24gb25GaWxlIChzcmNTdGF0LCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmICghZGVzdFN0YXQpIHJldHVybiBjb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIHJldHVybiBtYXlDb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG59XG5cbmZ1bmN0aW9uIG1heUNvcHlGaWxlIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgaWYgKG9wdHMub3ZlcndyaXRlKSB7XG4gICAgZnMudW5saW5rU3luYyhkZXN0KVxuICAgIHJldHVybiBjb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIH0gZWxzZSBpZiAob3B0cy5lcnJvck9uRXhpc3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCcke2Rlc3R9JyBhbHJlYWR5IGV4aXN0c2ApXG4gIH1cbn1cblxuZnVuY3Rpb24gY29weUZpbGUgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBmcy5jb3B5RmlsZVN5bmMoc3JjLCBkZXN0KVxuICBpZiAob3B0cy5wcmVzZXJ2ZVRpbWVzdGFtcHMpIGhhbmRsZVRpbWVzdGFtcHMoc3JjU3RhdC5tb2RlLCBzcmMsIGRlc3QpXG4gIHJldHVybiBzZXREZXN0TW9kZShkZXN0LCBzcmNTdGF0Lm1vZGUpXG59XG5cbmZ1bmN0aW9uIGhhbmRsZVRpbWVzdGFtcHMgKHNyY01vZGUsIHNyYywgZGVzdCkge1xuICAvLyBNYWtlIHN1cmUgdGhlIGZpbGUgaXMgd3JpdGFibGUgYmVmb3JlIHNldHRpbmcgdGhlIHRpbWVzdGFtcFxuICAvLyBvdGhlcndpc2Ugb3BlbiBmYWlscyB3aXRoIEVQRVJNIHdoZW4gaW52b2tlZCB3aXRoICdyKydcbiAgLy8gKHRocm91Z2ggdXRpbWVzIGNhbGwpXG4gIGlmIChmaWxlSXNOb3RXcml0YWJsZShzcmNNb2RlKSkgbWFrZUZpbGVXcml0YWJsZShkZXN0LCBzcmNNb2RlKVxuICByZXR1cm4gc2V0RGVzdFRpbWVzdGFtcHMoc3JjLCBkZXN0KVxufVxuXG5mdW5jdGlvbiBmaWxlSXNOb3RXcml0YWJsZSAoc3JjTW9kZSkge1xuICByZXR1cm4gKHNyY01vZGUgJiAwbzIwMCkgPT09IDBcbn1cblxuZnVuY3Rpb24gbWFrZUZpbGVXcml0YWJsZSAoZGVzdCwgc3JjTW9kZSkge1xuICByZXR1cm4gc2V0RGVzdE1vZGUoZGVzdCwgc3JjTW9kZSB8IDBvMjAwKVxufVxuXG5mdW5jdGlvbiBzZXREZXN0TW9kZSAoZGVzdCwgc3JjTW9kZSkge1xuICByZXR1cm4gZnMuY2htb2RTeW5jKGRlc3QsIHNyY01vZGUpXG59XG5cbmZ1bmN0aW9uIHNldERlc3RUaW1lc3RhbXBzIChzcmMsIGRlc3QpIHtcbiAgLy8gVGhlIGluaXRpYWwgc3JjU3RhdC5hdGltZSBjYW5ub3QgYmUgdHJ1c3RlZFxuICAvLyBiZWNhdXNlIGl0IGlzIG1vZGlmaWVkIGJ5IHRoZSByZWFkKDIpIHN5c3RlbSBjYWxsXG4gIC8vIChTZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sI2ZzX3N0YXRfdGltZV92YWx1ZXMpXG4gIGNvbnN0IHVwZGF0ZWRTcmNTdGF0ID0gZnMuc3RhdFN5bmMoc3JjKVxuICByZXR1cm4gdXRpbWVzTWlsbGlzU3luYyhkZXN0LCB1cGRhdGVkU3JjU3RhdC5hdGltZSwgdXBkYXRlZFNyY1N0YXQubXRpbWUpXG59XG5cbmZ1bmN0aW9uIG9uRGlyIChzcmNTdGF0LCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmICghZGVzdFN0YXQpIHJldHVybiBta0RpckFuZENvcHkoc3JjU3RhdC5tb2RlLCBzcmMsIGRlc3QsIG9wdHMpXG4gIHJldHVybiBjb3B5RGlyKHNyYywgZGVzdCwgb3B0cylcbn1cblxuZnVuY3Rpb24gbWtEaXJBbmRDb3B5IChzcmNNb2RlLCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgZnMubWtkaXJTeW5jKGRlc3QpXG4gIGNvcHlEaXIoc3JjLCBkZXN0LCBvcHRzKVxuICByZXR1cm4gc2V0RGVzdE1vZGUoZGVzdCwgc3JjTW9kZSlcbn1cblxuZnVuY3Rpb24gY29weURpciAoc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGZzLnJlYWRkaXJTeW5jKHNyYykuZm9yRWFjaChpdGVtID0+IGNvcHlEaXJJdGVtKGl0ZW0sIHNyYywgZGVzdCwgb3B0cykpXG59XG5cbmZ1bmN0aW9uIGNvcHlEaXJJdGVtIChpdGVtLCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgY29uc3Qgc3JjSXRlbSA9IHBhdGguam9pbihzcmMsIGl0ZW0pXG4gIGNvbnN0IGRlc3RJdGVtID0gcGF0aC5qb2luKGRlc3QsIGl0ZW0pXG4gIGNvbnN0IHsgZGVzdFN0YXQgfSA9IHN0YXQuY2hlY2tQYXRoc1N5bmMoc3JjSXRlbSwgZGVzdEl0ZW0sICdjb3B5Jywgb3B0cylcbiAgcmV0dXJuIHN0YXJ0Q29weShkZXN0U3RhdCwgc3JjSXRlbSwgZGVzdEl0ZW0sIG9wdHMpXG59XG5cbmZ1bmN0aW9uIG9uTGluayAoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBsZXQgcmVzb2x2ZWRTcmMgPSBmcy5yZWFkbGlua1N5bmMoc3JjKVxuICBpZiAob3B0cy5kZXJlZmVyZW5jZSkge1xuICAgIHJlc29sdmVkU3JjID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIHJlc29sdmVkU3JjKVxuICB9XG5cbiAgaWYgKCFkZXN0U3RhdCkge1xuICAgIHJldHVybiBmcy5zeW1saW5rU3luYyhyZXNvbHZlZFNyYywgZGVzdClcbiAgfSBlbHNlIHtcbiAgICBsZXQgcmVzb2x2ZWREZXN0XG4gICAgdHJ5IHtcbiAgICAgIHJlc29sdmVkRGVzdCA9IGZzLnJlYWRsaW5rU3luYyhkZXN0KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gZGVzdCBleGlzdHMgYW5kIGlzIGEgcmVndWxhciBmaWxlIG9yIGRpcmVjdG9yeSxcbiAgICAgIC8vIFdpbmRvd3MgbWF5IHRocm93IFVOS05PV04gZXJyb3IuIElmIGRlc3QgYWxyZWFkeSBleGlzdHMsXG4gICAgICAvLyBmcyB0aHJvd3MgZXJyb3IgYW55d2F5LCBzbyBubyBuZWVkIHRvIGd1YXJkIGFnYWluc3QgaXQgaGVyZS5cbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VJTlZBTCcgfHwgZXJyLmNvZGUgPT09ICdVTktOT1dOJykgcmV0dXJuIGZzLnN5bWxpbmtTeW5jKHJlc29sdmVkU3JjLCBkZXN0KVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICAgIGlmIChvcHRzLmRlcmVmZXJlbmNlKSB7XG4gICAgICByZXNvbHZlZERlc3QgPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgcmVzb2x2ZWREZXN0KVxuICAgIH1cbiAgICBpZiAoc3RhdC5pc1NyY1N1YmRpcihyZXNvbHZlZFNyYywgcmVzb2x2ZWREZXN0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29weSAnJHtyZXNvbHZlZFNyY30nIHRvIGEgc3ViZGlyZWN0b3J5IG9mIGl0c2VsZiwgJyR7cmVzb2x2ZWREZXN0fScuYClcbiAgICB9XG5cbiAgICAvLyBwcmV2ZW50IGNvcHkgaWYgc3JjIGlzIGEgc3ViZGlyIG9mIGRlc3Qgc2luY2UgdW5saW5raW5nXG4gICAgLy8gZGVzdCBpbiB0aGlzIGNhc2Ugd291bGQgcmVzdWx0IGluIHJlbW92aW5nIHNyYyBjb250ZW50c1xuICAgIC8vIGFuZCB0aGVyZWZvcmUgYSBicm9rZW4gc3ltbGluayB3b3VsZCBiZSBjcmVhdGVkLlxuICAgIGlmIChmcy5zdGF0U3luYyhkZXN0KS5pc0RpcmVjdG9yeSgpICYmIHN0YXQuaXNTcmNTdWJkaXIocmVzb2x2ZWREZXN0LCByZXNvbHZlZFNyYykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IG92ZXJ3cml0ZSAnJHtyZXNvbHZlZERlc3R9JyB3aXRoICcke3Jlc29sdmVkU3JjfScuYClcbiAgICB9XG4gICAgcmV0dXJuIGNvcHlMaW5rKHJlc29sdmVkU3JjLCBkZXN0KVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHlMaW5rIChyZXNvbHZlZFNyYywgZGVzdCkge1xuICBmcy51bmxpbmtTeW5jKGRlc3QpXG4gIHJldHVybiBmcy5zeW1saW5rU3luYyhyZXNvbHZlZFNyYywgZGVzdClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3luY1xuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb3B5U3luYzogcmVxdWlyZSgnLi9jb3B5LXN5bmMnKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2VcbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vZnMnKVxuXG5mdW5jdGlvbiBwYXRoRXhpc3RzIChwYXRoKSB7XG4gIHJldHVybiBmcy5hY2Nlc3MocGF0aCkudGhlbigoKSA9PiB0cnVlKS5jYXRjaCgoKSA9PiBmYWxzZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhdGhFeGlzdHM6IHUocGF0aEV4aXN0cyksXG4gIHBhdGhFeGlzdHNTeW5jOiBmcy5leGlzdHNTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBta2RpcnMgPSByZXF1aXJlKCcuLi9ta2RpcnMnKS5ta2RpcnNcbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpLnBhdGhFeGlzdHNcbmNvbnN0IHV0aW1lc01pbGxpcyA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbWVzJykudXRpbWVzTWlsbGlzXG5jb25zdCBzdGF0ID0gcmVxdWlyZSgnLi4vdXRpbC9zdGF0JylcblxuZnVuY3Rpb24gY29weSAoc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicgJiYgIWNiKSB7XG4gICAgY2IgPSBvcHRzXG4gICAgb3B0cyA9IHt9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRzID0geyBmaWx0ZXI6IG9wdHMgfVxuICB9XG5cbiAgY2IgPSBjYiB8fCBmdW5jdGlvbiAoKSB7fVxuICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gIG9wdHMuY2xvYmJlciA9ICdjbG9iYmVyJyBpbiBvcHRzID8gISFvcHRzLmNsb2JiZXIgOiB0cnVlIC8vIGRlZmF1bHQgdG8gdHJ1ZSBmb3Igbm93XG4gIG9wdHMub3ZlcndyaXRlID0gJ292ZXJ3cml0ZScgaW4gb3B0cyA/ICEhb3B0cy5vdmVyd3JpdGUgOiBvcHRzLmNsb2JiZXIgLy8gb3ZlcndyaXRlIGZhbGxzIGJhY2sgdG8gY2xvYmJlclxuXG4gIC8vIFdhcm4gYWJvdXQgdXNpbmcgcHJlc2VydmVUaW1lc3RhbXBzIG9uIDMyLWJpdCBub2RlXG4gIGlmIChvcHRzLnByZXNlcnZlVGltZXN0YW1wcyAmJiBwcm9jZXNzLmFyY2ggPT09ICdpYTMyJykge1xuICAgIGNvbnNvbGUud2FybihgZnMtZXh0cmE6IFVzaW5nIHRoZSBwcmVzZXJ2ZVRpbWVzdGFtcHMgb3B0aW9uIGluIDMyLWJpdCBub2RlIGlzIG5vdCByZWNvbW1lbmRlZDtcXG5cbiAgICBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pwcmljaGFyZHNvbi9ub2RlLWZzLWV4dHJhL2lzc3Vlcy8yNjlgKVxuICB9XG5cbiAgc3RhdC5jaGVja1BhdGhzKHNyYywgZGVzdCwgJ2NvcHknLCBvcHRzLCAoZXJyLCBzdGF0cykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgY29uc3QgeyBzcmNTdGF0LCBkZXN0U3RhdCB9ID0gc3RhdHNcbiAgICBzdGF0LmNoZWNrUGFyZW50UGF0aHMoc3JjLCBzcmNTdGF0LCBkZXN0LCAnY29weScsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgaWYgKG9wdHMuZmlsdGVyKSByZXR1cm4gaGFuZGxlRmlsdGVyKGNoZWNrUGFyZW50RGlyLCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICAgIHJldHVybiBjaGVja1BhcmVudERpcihkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjaGVja1BhcmVudERpciAoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgY29uc3QgZGVzdFBhcmVudCA9IHBhdGguZGlybmFtZShkZXN0KVxuICBwYXRoRXhpc3RzKGRlc3RQYXJlbnQsIChlcnIsIGRpckV4aXN0cykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgaWYgKGRpckV4aXN0cykgcmV0dXJuIGdldFN0YXRzKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIG1rZGlycyhkZXN0UGFyZW50LCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIHJldHVybiBnZXRTdGF0cyhkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBoYW5kbGVGaWx0ZXIgKG9uSW5jbHVkZSwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgUHJvbWlzZS5yZXNvbHZlKG9wdHMuZmlsdGVyKHNyYywgZGVzdCkpLnRoZW4oaW5jbHVkZSA9PiB7XG4gICAgaWYgKGluY2x1ZGUpIHJldHVybiBvbkluY2x1ZGUoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgcmV0dXJuIGNiKClcbiAgfSwgZXJyb3IgPT4gY2IoZXJyb3IpKVxufVxuXG5mdW5jdGlvbiBzdGFydENvcHkgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGlmIChvcHRzLmZpbHRlcikgcmV0dXJuIGhhbmRsZUZpbHRlcihnZXRTdGF0cywgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gIHJldHVybiBnZXRTdGF0cyhkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdHMgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGNvbnN0IHN0YXQgPSBvcHRzLmRlcmVmZXJlbmNlID8gZnMuc3RhdCA6IGZzLmxzdGF0XG4gIHN0YXQoc3JjLCAoZXJyLCBzcmNTdGF0KSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcblxuICAgIGlmIChzcmNTdGF0LmlzRGlyZWN0b3J5KCkpIHJldHVybiBvbkRpcihzcmNTdGF0LCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICBlbHNlIGlmIChzcmNTdGF0LmlzRmlsZSgpIHx8XG4gICAgICAgICAgICAgc3JjU3RhdC5pc0NoYXJhY3RlckRldmljZSgpIHx8XG4gICAgICAgICAgICAgc3JjU3RhdC5pc0Jsb2NrRGV2aWNlKCkpIHJldHVybiBvbkZpbGUoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgZWxzZSBpZiAoc3JjU3RhdC5pc1N5bWJvbGljTGluaygpKSByZXR1cm4gb25MaW5rKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIGVsc2UgaWYgKHNyY1N0YXQuaXNTb2NrZXQoKSkgcmV0dXJuIGNiKG5ldyBFcnJvcihgQ2Fubm90IGNvcHkgYSBzb2NrZXQgZmlsZTogJHtzcmN9YCkpXG4gICAgZWxzZSBpZiAoc3JjU3RhdC5pc0ZJRk8oKSkgcmV0dXJuIGNiKG5ldyBFcnJvcihgQ2Fubm90IGNvcHkgYSBGSUZPIHBpcGU6ICR7c3JjfWApKVxuICAgIHJldHVybiBjYihuZXcgRXJyb3IoYFVua25vd24gZmlsZTogJHtzcmN9YCkpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG9uRmlsZSAoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgaWYgKCFkZXN0U3RhdCkgcmV0dXJuIGNvcHlGaWxlKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gIHJldHVybiBtYXlDb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxufVxuXG5mdW5jdGlvbiBtYXlDb3B5RmlsZSAoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBpZiAob3B0cy5vdmVyd3JpdGUpIHtcbiAgICBmcy51bmxpbmsoZGVzdCwgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICByZXR1cm4gY29weUZpbGUoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICB9KVxuICB9IGVsc2UgaWYgKG9wdHMuZXJyb3JPbkV4aXN0KSB7XG4gICAgcmV0dXJuIGNiKG5ldyBFcnJvcihgJyR7ZGVzdH0nIGFscmVhZHkgZXhpc3RzYCkpXG4gIH0gZWxzZSByZXR1cm4gY2IoKVxufVxuXG5mdW5jdGlvbiBjb3B5RmlsZSAoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBmcy5jb3B5RmlsZShzcmMsIGRlc3QsIGVyciA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBpZiAob3B0cy5wcmVzZXJ2ZVRpbWVzdGFtcHMpIHJldHVybiBoYW5kbGVUaW1lc3RhbXBzQW5kTW9kZShzcmNTdGF0Lm1vZGUsIHNyYywgZGVzdCwgY2IpXG4gICAgcmV0dXJuIHNldERlc3RNb2RlKGRlc3QsIHNyY1N0YXQubW9kZSwgY2IpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGhhbmRsZVRpbWVzdGFtcHNBbmRNb2RlIChzcmNNb2RlLCBzcmMsIGRlc3QsIGNiKSB7XG4gIC8vIE1ha2Ugc3VyZSB0aGUgZmlsZSBpcyB3cml0YWJsZSBiZWZvcmUgc2V0dGluZyB0aGUgdGltZXN0YW1wXG4gIC8vIG90aGVyd2lzZSBvcGVuIGZhaWxzIHdpdGggRVBFUk0gd2hlbiBpbnZva2VkIHdpdGggJ3IrJ1xuICAvLyAodGhyb3VnaCB1dGltZXMgY2FsbClcbiAgaWYgKGZpbGVJc05vdFdyaXRhYmxlKHNyY01vZGUpKSB7XG4gICAgcmV0dXJuIG1ha2VGaWxlV3JpdGFibGUoZGVzdCwgc3JjTW9kZSwgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICByZXR1cm4gc2V0RGVzdFRpbWVzdGFtcHNBbmRNb2RlKHNyY01vZGUsIHNyYywgZGVzdCwgY2IpXG4gICAgfSlcbiAgfVxuICByZXR1cm4gc2V0RGVzdFRpbWVzdGFtcHNBbmRNb2RlKHNyY01vZGUsIHNyYywgZGVzdCwgY2IpXG59XG5cbmZ1bmN0aW9uIGZpbGVJc05vdFdyaXRhYmxlIChzcmNNb2RlKSB7XG4gIHJldHVybiAoc3JjTW9kZSAmIDBvMjAwKSA9PT0gMFxufVxuXG5mdW5jdGlvbiBtYWtlRmlsZVdyaXRhYmxlIChkZXN0LCBzcmNNb2RlLCBjYikge1xuICByZXR1cm4gc2V0RGVzdE1vZGUoZGVzdCwgc3JjTW9kZSB8IDBvMjAwLCBjYilcbn1cblxuZnVuY3Rpb24gc2V0RGVzdFRpbWVzdGFtcHNBbmRNb2RlIChzcmNNb2RlLCBzcmMsIGRlc3QsIGNiKSB7XG4gIHNldERlc3RUaW1lc3RhbXBzKHNyYywgZGVzdCwgZXJyID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHJldHVybiBzZXREZXN0TW9kZShkZXN0LCBzcmNNb2RlLCBjYilcbiAgfSlcbn1cblxuZnVuY3Rpb24gc2V0RGVzdE1vZGUgKGRlc3QsIHNyY01vZGUsIGNiKSB7XG4gIHJldHVybiBmcy5jaG1vZChkZXN0LCBzcmNNb2RlLCBjYilcbn1cblxuZnVuY3Rpb24gc2V0RGVzdFRpbWVzdGFtcHMgKHNyYywgZGVzdCwgY2IpIHtcbiAgLy8gVGhlIGluaXRpYWwgc3JjU3RhdC5hdGltZSBjYW5ub3QgYmUgdHJ1c3RlZFxuICAvLyBiZWNhdXNlIGl0IGlzIG1vZGlmaWVkIGJ5IHRoZSByZWFkKDIpIHN5c3RlbSBjYWxsXG4gIC8vIChTZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sI2ZzX3N0YXRfdGltZV92YWx1ZXMpXG4gIGZzLnN0YXQoc3JjLCAoZXJyLCB1cGRhdGVkU3JjU3RhdCkgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgcmV0dXJuIHV0aW1lc01pbGxpcyhkZXN0LCB1cGRhdGVkU3JjU3RhdC5hdGltZSwgdXBkYXRlZFNyY1N0YXQubXRpbWUsIGNiKVxuICB9KVxufVxuXG5mdW5jdGlvbiBvbkRpciAoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgaWYgKCFkZXN0U3RhdCkgcmV0dXJuIG1rRGlyQW5kQ29weShzcmNTdGF0Lm1vZGUsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gIHJldHVybiBjb3B5RGlyKHNyYywgZGVzdCwgb3B0cywgY2IpXG59XG5cbmZ1bmN0aW9uIG1rRGlyQW5kQ29weSAoc3JjTW9kZSwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBmcy5ta2RpcihkZXN0LCBlcnIgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgY29weURpcihzcmMsIGRlc3QsIG9wdHMsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgcmV0dXJuIHNldERlc3RNb2RlKGRlc3QsIHNyY01vZGUsIGNiKVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNvcHlEaXIgKHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgZnMucmVhZGRpcihzcmMsIChlcnIsIGl0ZW1zKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICByZXR1cm4gY29weURpckl0ZW1zKGl0ZW1zLCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICB9KVxufVxuXG5mdW5jdGlvbiBjb3B5RGlySXRlbXMgKGl0ZW1zLCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGNvbnN0IGl0ZW0gPSBpdGVtcy5wb3AoKVxuICBpZiAoIWl0ZW0pIHJldHVybiBjYigpXG4gIHJldHVybiBjb3B5RGlySXRlbShpdGVtcywgaXRlbSwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbn1cblxuZnVuY3Rpb24gY29weURpckl0ZW0gKGl0ZW1zLCBpdGVtLCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGNvbnN0IHNyY0l0ZW0gPSBwYXRoLmpvaW4oc3JjLCBpdGVtKVxuICBjb25zdCBkZXN0SXRlbSA9IHBhdGguam9pbihkZXN0LCBpdGVtKVxuICBzdGF0LmNoZWNrUGF0aHMoc3JjSXRlbSwgZGVzdEl0ZW0sICdjb3B5Jywgb3B0cywgKGVyciwgc3RhdHMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGNvbnN0IHsgZGVzdFN0YXQgfSA9IHN0YXRzXG4gICAgc3RhcnRDb3B5KGRlc3RTdGF0LCBzcmNJdGVtLCBkZXN0SXRlbSwgb3B0cywgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICByZXR1cm4gY29weURpckl0ZW1zKGl0ZW1zLCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG9uTGluayAoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgZnMucmVhZGxpbmsoc3JjLCAoZXJyLCByZXNvbHZlZFNyYykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgaWYgKG9wdHMuZGVyZWZlcmVuY2UpIHtcbiAgICAgIHJlc29sdmVkU3JjID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIHJlc29sdmVkU3JjKVxuICAgIH1cblxuICAgIGlmICghZGVzdFN0YXQpIHtcbiAgICAgIHJldHVybiBmcy5zeW1saW5rKHJlc29sdmVkU3JjLCBkZXN0LCBjYilcbiAgICB9IGVsc2Uge1xuICAgICAgZnMucmVhZGxpbmsoZGVzdCwgKGVyciwgcmVzb2x2ZWREZXN0KSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAvLyBkZXN0IGV4aXN0cyBhbmQgaXMgYSByZWd1bGFyIGZpbGUgb3IgZGlyZWN0b3J5LFxuICAgICAgICAgIC8vIFdpbmRvd3MgbWF5IHRocm93IFVOS05PV04gZXJyb3IuIElmIGRlc3QgYWxyZWFkeSBleGlzdHMsXG4gICAgICAgICAgLy8gZnMgdGhyb3dzIGVycm9yIGFueXdheSwgc28gbm8gbmVlZCB0byBndWFyZCBhZ2FpbnN0IGl0IGhlcmUuXG4gICAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRUlOVkFMJyB8fCBlcnIuY29kZSA9PT0gJ1VOS05PV04nKSByZXR1cm4gZnMuc3ltbGluayhyZXNvbHZlZFNyYywgZGVzdCwgY2IpXG4gICAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5kZXJlZmVyZW5jZSkge1xuICAgICAgICAgIHJlc29sdmVkRGVzdCA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCByZXNvbHZlZERlc3QpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXQuaXNTcmNTdWJkaXIocmVzb2x2ZWRTcmMsIHJlc29sdmVkRGVzdCkpIHtcbiAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKGBDYW5ub3QgY29weSAnJHtyZXNvbHZlZFNyY30nIHRvIGEgc3ViZGlyZWN0b3J5IG9mIGl0c2VsZiwgJyR7cmVzb2x2ZWREZXN0fScuYCkpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBkbyBub3QgY29weSBpZiBzcmMgaXMgYSBzdWJkaXIgb2YgZGVzdCBzaW5jZSB1bmxpbmtpbmdcbiAgICAgICAgLy8gZGVzdCBpbiB0aGlzIGNhc2Ugd291bGQgcmVzdWx0IGluIHJlbW92aW5nIHNyYyBjb250ZW50c1xuICAgICAgICAvLyBhbmQgdGhlcmVmb3JlIGEgYnJva2VuIHN5bWxpbmsgd291bGQgYmUgY3JlYXRlZC5cbiAgICAgICAgaWYgKGRlc3RTdGF0LmlzRGlyZWN0b3J5KCkgJiYgc3RhdC5pc1NyY1N1YmRpcihyZXNvbHZlZERlc3QsIHJlc29sdmVkU3JjKSkge1xuICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoYENhbm5vdCBvdmVyd3JpdGUgJyR7cmVzb2x2ZWREZXN0fScgd2l0aCAnJHtyZXNvbHZlZFNyY30nLmApKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3B5TGluayhyZXNvbHZlZFNyYywgZGVzdCwgY2IpXG4gICAgICB9KVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gY29weUxpbmsgKHJlc29sdmVkU3JjLCBkZXN0LCBjYikge1xuICBmcy51bmxpbmsoZGVzdCwgZXJyID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHJldHVybiBmcy5zeW1saW5rKHJlc29sdmVkU3JjLCBkZXN0LCBjYilcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvcHk6IHUocmVxdWlyZSgnLi9jb3B5JykpXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuXG5jb25zdCBpc1dpbmRvd3MgPSAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJylcblxuZnVuY3Rpb24gZGVmYXVsdHMgKG9wdGlvbnMpIHtcbiAgY29uc3QgbWV0aG9kcyA9IFtcbiAgICAndW5saW5rJyxcbiAgICAnY2htb2QnLFxuICAgICdzdGF0JyxcbiAgICAnbHN0YXQnLFxuICAgICdybWRpcicsXG4gICAgJ3JlYWRkaXInXG4gIF1cbiAgbWV0aG9kcy5mb3JFYWNoKG0gPT4ge1xuICAgIG9wdGlvbnNbbV0gPSBvcHRpb25zW21dIHx8IGZzW21dXG4gICAgbSA9IG0gKyAnU3luYydcbiAgICBvcHRpb25zW21dID0gb3B0aW9uc1ttXSB8fCBmc1ttXVxuICB9KVxuXG4gIG9wdGlvbnMubWF4QnVzeVRyaWVzID0gb3B0aW9ucy5tYXhCdXN5VHJpZXMgfHwgM1xufVxuXG5mdW5jdGlvbiByaW1yYWYgKHAsIG9wdGlvbnMsIGNiKSB7XG4gIGxldCBidXN5VHJpZXMgPSAwXG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHt9XG4gIH1cblxuICBhc3NlcnQocCwgJ3JpbXJhZjogbWlzc2luZyBwYXRoJylcbiAgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiBwLCAnc3RyaW5nJywgJ3JpbXJhZjogcGF0aCBzaG91bGQgYmUgYSBzdHJpbmcnKVxuICBhc3NlcnQuc3RyaWN0RXF1YWwodHlwZW9mIGNiLCAnZnVuY3Rpb24nLCAncmltcmFmOiBjYWxsYmFjayBmdW5jdGlvbiByZXF1aXJlZCcpXG4gIGFzc2VydChvcHRpb25zLCAncmltcmFmOiBpbnZhbGlkIG9wdGlvbnMgYXJndW1lbnQgcHJvdmlkZWQnKVxuICBhc3NlcnQuc3RyaWN0RXF1YWwodHlwZW9mIG9wdGlvbnMsICdvYmplY3QnLCAncmltcmFmOiBvcHRpb25zIHNob3VsZCBiZSBvYmplY3QnKVxuXG4gIGRlZmF1bHRzKG9wdGlvbnMpXG5cbiAgcmltcmFmXyhwLCBvcHRpb25zLCBmdW5jdGlvbiBDQiAoZXIpIHtcbiAgICBpZiAoZXIpIHtcbiAgICAgIGlmICgoZXIuY29kZSA9PT0gJ0VCVVNZJyB8fCBlci5jb2RlID09PSAnRU5PVEVNUFRZJyB8fCBlci5jb2RlID09PSAnRVBFUk0nKSAmJlxuICAgICAgICAgIGJ1c3lUcmllcyA8IG9wdGlvbnMubWF4QnVzeVRyaWVzKSB7XG4gICAgICAgIGJ1c3lUcmllcysrXG4gICAgICAgIGNvbnN0IHRpbWUgPSBidXN5VHJpZXMgKiAxMDBcbiAgICAgICAgLy8gdHJ5IGFnYWluLCB3aXRoIHRoZSBzYW1lIGV4YWN0IGNhbGxiYWNrIGFzIHRoaXMgb25lLlxuICAgICAgICByZXR1cm4gc2V0VGltZW91dCgoKSA9PiByaW1yYWZfKHAsIG9wdGlvbnMsIENCKSwgdGltZSlcbiAgICAgIH1cblxuICAgICAgLy8gYWxyZWFkeSBnb25lXG4gICAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpIGVyID0gbnVsbFxuICAgIH1cblxuICAgIGNiKGVyKVxuICB9KVxufVxuXG4vLyBUd28gcG9zc2libGUgc3RyYXRlZ2llcy5cbi8vIDEuIEFzc3VtZSBpdCdzIGEgZmlsZS4gIHVubGluayBpdCwgdGhlbiBkbyB0aGUgZGlyIHN0dWZmIG9uIEVQRVJNIG9yIEVJU0RJUlxuLy8gMi4gQXNzdW1lIGl0J3MgYSBkaXJlY3RvcnkuICByZWFkZGlyLCB0aGVuIGRvIHRoZSBmaWxlIHN0dWZmIG9uIEVOT1RESVJcbi8vXG4vLyBCb3RoIHJlc3VsdCBpbiBhbiBleHRyYSBzeXNjYWxsIHdoZW4geW91IGd1ZXNzIHdyb25nLiAgSG93ZXZlciwgdGhlcmVcbi8vIGFyZSBsaWtlbHkgZmFyIG1vcmUgbm9ybWFsIGZpbGVzIGluIHRoZSB3b3JsZCB0aGFuIGRpcmVjdG9yaWVzLiAgVGhpc1xuLy8gaXMgYmFzZWQgb24gdGhlIGFzc3VtcHRpb24gdGhhdCBhIHRoZSBhdmVyYWdlIG51bWJlciBvZiBmaWxlcyBwZXJcbi8vIGRpcmVjdG9yeSBpcyA+PSAxLlxuLy9cbi8vIElmIGFueW9uZSBldmVyIGNvbXBsYWlucyBhYm91dCB0aGlzLCB0aGVuIEkgZ3Vlc3MgdGhlIHN0cmF0ZWd5IGNvdWxkXG4vLyBiZSBtYWRlIGNvbmZpZ3VyYWJsZSBzb21laG93LiAgQnV0IHVudGlsIHRoZW4sIFlBR05JLlxuZnVuY3Rpb24gcmltcmFmXyAocCwgb3B0aW9ucywgY2IpIHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBhc3NlcnQodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuXG4gIC8vIHN1bm9zIGxldHMgdGhlIHJvb3QgdXNlciB1bmxpbmsgZGlyZWN0b3JpZXMsIHdoaWNoIGlzLi4uIHdlaXJkLlxuICAvLyBzbyB3ZSBoYXZlIHRvIGxzdGF0IGhlcmUgYW5kIG1ha2Ugc3VyZSBpdCdzIG5vdCBhIGRpci5cbiAgb3B0aW9ucy5sc3RhdChwLCAoZXIsIHN0KSA9PiB7XG4gICAgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICByZXR1cm4gY2IobnVsbClcbiAgICB9XG5cbiAgICAvLyBXaW5kb3dzIGNhbiBFUEVSTSBvbiBzdGF0LiAgTGlmZSBpcyBzdWZmZXJpbmcuXG4gICAgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFUEVSTScgJiYgaXNXaW5kb3dzKSB7XG4gICAgICByZXR1cm4gZml4V2luRVBFUk0ocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgIH1cblxuICAgIGlmIChzdCAmJiBzdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICByZXR1cm4gcm1kaXIocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgIH1cblxuICAgIG9wdGlvbnMudW5saW5rKHAsIGVyID0+IHtcbiAgICAgIGlmIChlcikge1xuICAgICAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICByZXR1cm4gY2IobnVsbClcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXIuY29kZSA9PT0gJ0VQRVJNJykge1xuICAgICAgICAgIHJldHVybiAoaXNXaW5kb3dzKVxuICAgICAgICAgICAgPyBmaXhXaW5FUEVSTShwLCBvcHRpb25zLCBlciwgY2IpXG4gICAgICAgICAgICA6IHJtZGlyKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXIuY29kZSA9PT0gJ0VJU0RJUicpIHtcbiAgICAgICAgICByZXR1cm4gcm1kaXIocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY2IoZXIpXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gZml4V2luRVBFUk0gKHAsIG9wdGlvbnMsIGVyLCBjYikge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG4gIGFzc2VydCh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG5cbiAgb3B0aW9ucy5jaG1vZChwLCAwbzY2NiwgZXIyID0+IHtcbiAgICBpZiAoZXIyKSB7XG4gICAgICBjYihlcjIuY29kZSA9PT0gJ0VOT0VOVCcgPyBudWxsIDogZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuc3RhdChwLCAoZXIzLCBzdGF0cykgPT4ge1xuICAgICAgICBpZiAoZXIzKSB7XG4gICAgICAgICAgY2IoZXIzLmNvZGUgPT09ICdFTk9FTlQnID8gbnVsbCA6IGVyKVxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICBybWRpcihwLCBvcHRpb25zLCBlciwgY2IpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy51bmxpbmsocCwgY2IpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBmaXhXaW5FUEVSTVN5bmMgKHAsIG9wdGlvbnMsIGVyKSB7XG4gIGxldCBzdGF0c1xuXG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcblxuICB0cnkge1xuICAgIG9wdGlvbnMuY2htb2RTeW5jKHAsIDBvNjY2KVxuICB9IGNhdGNoIChlcjIpIHtcbiAgICBpZiAoZXIyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIHN0YXRzID0gb3B0aW9ucy5zdGF0U3luYyhwKVxuICB9IGNhdGNoIChlcjMpIHtcbiAgICBpZiAoZXIzLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgIHJtZGlyU3luYyhwLCBvcHRpb25zLCBlcilcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLnVubGlua1N5bmMocClcbiAgfVxufVxuXG5mdW5jdGlvbiBybWRpciAocCwgb3B0aW9ucywgb3JpZ2luYWxFciwgY2IpIHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBhc3NlcnQodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuXG4gIC8vIHRyeSB0byBybWRpciBmaXJzdCwgYW5kIG9ubHkgcmVhZGRpciBvbiBFTk9URU1QVFkgb3IgRUVYSVNUIChTdW5PUylcbiAgLy8gaWYgd2UgZ3Vlc3NlZCB3cm9uZywgYW5kIGl0J3Mgbm90IGEgZGlyZWN0b3J5LCB0aGVuXG4gIC8vIHJhaXNlIHRoZSBvcmlnaW5hbCBlcnJvci5cbiAgb3B0aW9ucy5ybWRpcihwLCBlciA9PiB7XG4gICAgaWYgKGVyICYmIChlci5jb2RlID09PSAnRU5PVEVNUFRZJyB8fCBlci5jb2RlID09PSAnRUVYSVNUJyB8fCBlci5jb2RlID09PSAnRVBFUk0nKSkge1xuICAgICAgcm1raWRzKHAsIG9wdGlvbnMsIGNiKVxuICAgIH0gZWxzZSBpZiAoZXIgJiYgZXIuY29kZSA9PT0gJ0VOT1RESVInKSB7XG4gICAgICBjYihvcmlnaW5hbEVyKVxuICAgIH0gZWxzZSB7XG4gICAgICBjYihlcilcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJta2lkcyAocCwgb3B0aW9ucywgY2IpIHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBhc3NlcnQodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuXG4gIG9wdGlvbnMucmVhZGRpcihwLCAoZXIsIGZpbGVzKSA9PiB7XG4gICAgaWYgKGVyKSByZXR1cm4gY2IoZXIpXG5cbiAgICBsZXQgbiA9IGZpbGVzLmxlbmd0aFxuICAgIGxldCBlcnJTdGF0ZVxuXG4gICAgaWYgKG4gPT09IDApIHJldHVybiBvcHRpb25zLnJtZGlyKHAsIGNiKVxuXG4gICAgZmlsZXMuZm9yRWFjaChmID0+IHtcbiAgICAgIHJpbXJhZihwYXRoLmpvaW4ocCwgZiksIG9wdGlvbnMsIGVyID0+IHtcbiAgICAgICAgaWYgKGVyclN0YXRlKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVyKSByZXR1cm4gY2IoZXJyU3RhdGUgPSBlcilcbiAgICAgICAgaWYgKC0tbiA9PT0gMCkge1xuICAgICAgICAgIG9wdGlvbnMucm1kaXIocCwgY2IpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuLy8gdGhpcyBsb29rcyBzaW1wbGVyLCBhbmQgaXMgc3RyaWN0bHkgKmZhc3RlciosIGJ1dCB3aWxsXG4vLyB0aWUgdXAgdGhlIEphdmFTY3JpcHQgdGhyZWFkIGFuZCBmYWlsIG9uIGV4Y2Vzc2l2ZWx5XG4vLyBkZWVwIGRpcmVjdG9yeSB0cmVlcy5cbmZ1bmN0aW9uIHJpbXJhZlN5bmMgKHAsIG9wdGlvbnMpIHtcbiAgbGV0IHN0XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgZGVmYXVsdHMob3B0aW9ucylcblxuICBhc3NlcnQocCwgJ3JpbXJhZjogbWlzc2luZyBwYXRoJylcbiAgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiBwLCAnc3RyaW5nJywgJ3JpbXJhZjogcGF0aCBzaG91bGQgYmUgYSBzdHJpbmcnKVxuICBhc3NlcnQob3B0aW9ucywgJ3JpbXJhZjogbWlzc2luZyBvcHRpb25zJylcbiAgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiBvcHRpb25zLCAnb2JqZWN0JywgJ3JpbXJhZjogb3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0JylcblxuICB0cnkge1xuICAgIHN0ID0gb3B0aW9ucy5sc3RhdFN5bmMocClcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFdpbmRvd3MgY2FuIEVQRVJNIG9uIHN0YXQuICBMaWZlIGlzIHN1ZmZlcmluZy5cbiAgICBpZiAoZXIuY29kZSA9PT0gJ0VQRVJNJyAmJiBpc1dpbmRvd3MpIHtcbiAgICAgIGZpeFdpbkVQRVJNU3luYyhwLCBvcHRpb25zLCBlcilcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIC8vIHN1bm9zIGxldHMgdGhlIHJvb3QgdXNlciB1bmxpbmsgZGlyZWN0b3JpZXMsIHdoaWNoIGlzLi4uIHdlaXJkLlxuICAgIGlmIChzdCAmJiBzdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICBybWRpclN5bmMocCwgb3B0aW9ucywgbnVsbClcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy51bmxpbmtTeW5jKHApXG4gICAgfVxuICB9IGNhdGNoIChlcikge1xuICAgIGlmIChlci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIGlmIChlci5jb2RlID09PSAnRVBFUk0nKSB7XG4gICAgICByZXR1cm4gaXNXaW5kb3dzID8gZml4V2luRVBFUk1TeW5jKHAsIG9wdGlvbnMsIGVyKSA6IHJtZGlyU3luYyhwLCBvcHRpb25zLCBlcilcbiAgICB9IGVsc2UgaWYgKGVyLmNvZGUgIT09ICdFSVNESVInKSB7XG4gICAgICB0aHJvdyBlclxuICAgIH1cbiAgICBybWRpclN5bmMocCwgb3B0aW9ucywgZXIpXG4gIH1cbn1cblxuZnVuY3Rpb24gcm1kaXJTeW5jIChwLCBvcHRpb25zLCBvcmlnaW5hbEVyKSB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcblxuICB0cnkge1xuICAgIG9wdGlvbnMucm1kaXJTeW5jKHApXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgaWYgKGVyLmNvZGUgPT09ICdFTk9URElSJykge1xuICAgICAgdGhyb3cgb3JpZ2luYWxFclxuICAgIH0gZWxzZSBpZiAoZXIuY29kZSA9PT0gJ0VOT1RFTVBUWScgfHwgZXIuY29kZSA9PT0gJ0VFWElTVCcgfHwgZXIuY29kZSA9PT0gJ0VQRVJNJykge1xuICAgICAgcm1raWRzU3luYyhwLCBvcHRpb25zKVxuICAgIH0gZWxzZSBpZiAoZXIuY29kZSAhPT0gJ0VOT0VOVCcpIHtcbiAgICAgIHRocm93IGVyXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJta2lkc1N5bmMgKHAsIG9wdGlvbnMpIHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBvcHRpb25zLnJlYWRkaXJTeW5jKHApLmZvckVhY2goZiA9PiByaW1yYWZTeW5jKHBhdGguam9pbihwLCBmKSwgb3B0aW9ucykpXG5cbiAgaWYgKGlzV2luZG93cykge1xuICAgIC8vIFdlIG9ubHkgZW5kIHVwIGhlcmUgb25jZSB3ZSBnb3QgRU5PVEVNUFRZIGF0IGxlYXN0IG9uY2UsIGFuZFxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIHdlIGFyZSBndWFyYW50ZWVkIHRvIGhhdmUgcmVtb3ZlZCBhbGwgdGhlIGtpZHMuXG4gICAgLy8gU28sIHdlIGtub3cgdGhhdCBpdCB3b24ndCBiZSBFTk9FTlQgb3IgRU5PVERJUiBvciBhbnl0aGluZyBlbHNlLlxuICAgIC8vIHRyeSByZWFsbHkgaGFyZCB0byBkZWxldGUgc3R1ZmYgb24gd2luZG93cywgYmVjYXVzZSBpdCBoYXMgYVxuICAgIC8vIFBST0ZPVU5ETFkgYW5ub3lpbmcgaGFiaXQgb2Ygbm90IGNsb3NpbmcgaGFuZGxlcyBwcm9tcHRseSB3aGVuXG4gICAgLy8gZmlsZXMgYXJlIGRlbGV0ZWQsIHJlc3VsdGluZyBpbiBzcHVyaW91cyBFTk9URU1QVFkgZXJyb3JzLlxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KClcbiAgICBkbyB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXQgPSBvcHRpb25zLnJtZGlyU3luYyhwLCBvcHRpb25zKVxuICAgICAgICByZXR1cm4gcmV0XG4gICAgICB9IGNhdGNoIHt9XG4gICAgfSB3aGlsZSAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA8IDUwMCkgLy8gZ2l2ZSB1cCBhZnRlciA1MDBtc1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHJldCA9IG9wdGlvbnMucm1kaXJTeW5jKHAsIG9wdGlvbnMpXG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmltcmFmXG5yaW1yYWYuc3luYyA9IHJpbXJhZlN5bmNcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcbmNvbnN0IHJpbXJhZiA9IHJlcXVpcmUoJy4vcmltcmFmJylcblxuZnVuY3Rpb24gcmVtb3ZlIChwYXRoLCBjYWxsYmFjaykge1xuICAvLyBOb2RlIDE0LjE0LjArXG4gIGlmIChmcy5ybSkgcmV0dXJuIGZzLnJtKHBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlLCBmb3JjZTogdHJ1ZSB9LCBjYWxsYmFjaylcbiAgcmltcmFmKHBhdGgsIGNhbGxiYWNrKVxufVxuXG5mdW5jdGlvbiByZW1vdmVTeW5jIChwYXRoKSB7XG4gIC8vIE5vZGUgMTQuMTQuMCtcbiAgaWYgKGZzLnJtU3luYykgcmV0dXJuIGZzLnJtU3luYyhwYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSlcbiAgcmltcmFmLnN5bmMocGF0aClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlbW92ZTogdShyZW1vdmUpLFxuICByZW1vdmVTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21Qcm9taXNlXG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL2ZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHJlbW92ZSA9IHJlcXVpcmUoJy4uL3JlbW92ZScpXG5cbmNvbnN0IGVtcHR5RGlyID0gdShhc3luYyBmdW5jdGlvbiBlbXB0eURpciAoZGlyKSB7XG4gIGxldCBpdGVtc1xuICB0cnkge1xuICAgIGl0ZW1zID0gYXdhaXQgZnMucmVhZGRpcihkaXIpXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBta2Rpci5ta2RpcnMoZGlyKVxuICB9XG5cbiAgcmV0dXJuIFByb21pc2UuYWxsKGl0ZW1zLm1hcChpdGVtID0+IHJlbW92ZS5yZW1vdmUocGF0aC5qb2luKGRpciwgaXRlbSkpKSlcbn0pXG5cbmZ1bmN0aW9uIGVtcHR5RGlyU3luYyAoZGlyKSB7XG4gIGxldCBpdGVtc1xuICB0cnkge1xuICAgIGl0ZW1zID0gZnMucmVhZGRpclN5bmMoZGlyKVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbWtkaXIubWtkaXJzU3luYyhkaXIpXG4gIH1cblxuICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgIGl0ZW0gPSBwYXRoLmpvaW4oZGlyLCBpdGVtKVxuICAgIHJlbW92ZS5yZW1vdmVTeW5jKGl0ZW0pXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlbXB0eURpclN5bmMsXG4gIGVtcHR5ZGlyU3luYzogZW1wdHlEaXJTeW5jLFxuICBlbXB0eURpcixcbiAgZW1wdHlkaXI6IGVtcHR5RGlyXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBta2RpciA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5cbmZ1bmN0aW9uIGNyZWF0ZUZpbGUgKGZpbGUsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIG1ha2VGaWxlICgpIHtcbiAgICBmcy53cml0ZUZpbGUoZmlsZSwgJycsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgY2FsbGJhY2soKVxuICAgIH0pXG4gIH1cblxuICBmcy5zdGF0KGZpbGUsIChlcnIsIHN0YXRzKSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaGFuZGxlLWNhbGxiYWNrLWVyclxuICAgIGlmICghZXJyICYmIHN0YXRzLmlzRmlsZSgpKSByZXR1cm4gY2FsbGJhY2soKVxuICAgIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShmaWxlKVxuICAgIGZzLnN0YXQoZGlyLCAoZXJyLCBzdGF0cykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICAvLyBpZiB0aGUgZGlyZWN0b3J5IGRvZXNuJ3QgZXhpc3QsIG1ha2UgaXRcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICAgIHJldHVybiBta2Rpci5ta2RpcnMoZGlyLCBlcnIgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgICAgIG1ha2VGaWxlKClcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpKSBtYWtlRmlsZSgpXG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gcGFyZW50IGlzIG5vdCBhIGRpcmVjdG9yeVxuICAgICAgICAvLyBUaGlzIGlzIGp1c3QgdG8gY2F1c2UgYW4gaW50ZXJuYWwgRU5PVERJUiBlcnJvciB0byBiZSB0aHJvd25cbiAgICAgICAgZnMucmVhZGRpcihkaXIsIGVyciA9PiB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWxlU3luYyAoZmlsZSkge1xuICBsZXQgc3RhdHNcbiAgdHJ5IHtcbiAgICBzdGF0cyA9IGZzLnN0YXRTeW5jKGZpbGUpXG4gIH0gY2F0Y2gge31cbiAgaWYgKHN0YXRzICYmIHN0YXRzLmlzRmlsZSgpKSByZXR1cm5cblxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZmlsZSlcbiAgdHJ5IHtcbiAgICBpZiAoIWZzLnN0YXRTeW5jKGRpcikuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgLy8gcGFyZW50IGlzIG5vdCBhIGRpcmVjdG9yeVxuICAgICAgLy8gVGhpcyBpcyBqdXN0IHRvIGNhdXNlIGFuIGludGVybmFsIEVOT1RESVIgZXJyb3IgdG8gYmUgdGhyb3duXG4gICAgICBmcy5yZWFkZGlyU3luYyhkaXIpXG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBJZiB0aGUgc3RhdCBjYWxsIGFib3ZlIGZhaWxlZCBiZWNhdXNlIHRoZSBkaXJlY3RvcnkgZG9lc24ndCBleGlzdCwgY3JlYXRlIGl0XG4gICAgaWYgKGVyciAmJiBlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIG1rZGlyLm1rZGlyc1N5bmMoZGlyKVxuICAgIGVsc2UgdGhyb3cgZXJyXG4gIH1cblxuICBmcy53cml0ZUZpbGVTeW5jKGZpbGUsICcnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlRmlsZTogdShjcmVhdGVGaWxlKSxcbiAgY3JlYXRlRmlsZVN5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpLnBhdGhFeGlzdHNcbmNvbnN0IHsgYXJlSWRlbnRpY2FsIH0gPSByZXF1aXJlKCcuLi91dGlsL3N0YXQnKVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rIChzcmNwYXRoLCBkc3RwYXRoLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBtYWtlTGluayAoc3JjcGF0aCwgZHN0cGF0aCkge1xuICAgIGZzLmxpbmsoc3JjcGF0aCwgZHN0cGF0aCwgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICBjYWxsYmFjayhudWxsKVxuICAgIH0pXG4gIH1cblxuICBmcy5sc3RhdChkc3RwYXRoLCAoXywgZHN0U3RhdCkgPT4ge1xuICAgIGZzLmxzdGF0KHNyY3BhdGgsIChlcnIsIHNyY1N0YXQpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZXJyLm1lc3NhZ2UgPSBlcnIubWVzc2FnZS5yZXBsYWNlKCdsc3RhdCcsICdlbnN1cmVMaW5rJylcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cbiAgICAgIGlmIChkc3RTdGF0ICYmIGFyZUlkZW50aWNhbChzcmNTdGF0LCBkc3RTdGF0KSkgcmV0dXJuIGNhbGxiYWNrKG51bGwpXG5cbiAgICAgIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShkc3RwYXRoKVxuICAgICAgcGF0aEV4aXN0cyhkaXIsIChlcnIsIGRpckV4aXN0cykgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICBpZiAoZGlyRXhpc3RzKSByZXR1cm4gbWFrZUxpbmsoc3JjcGF0aCwgZHN0cGF0aClcbiAgICAgICAgbWtkaXIubWtkaXJzKGRpciwgZXJyID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICAgIG1ha2VMaW5rKHNyY3BhdGgsIGRzdHBhdGgpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtTeW5jIChzcmNwYXRoLCBkc3RwYXRoKSB7XG4gIGxldCBkc3RTdGF0XG4gIHRyeSB7XG4gICAgZHN0U3RhdCA9IGZzLmxzdGF0U3luYyhkc3RwYXRoKVxuICB9IGNhdGNoIHt9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBzcmNTdGF0ID0gZnMubHN0YXRTeW5jKHNyY3BhdGgpXG4gICAgaWYgKGRzdFN0YXQgJiYgYXJlSWRlbnRpY2FsKHNyY1N0YXQsIGRzdFN0YXQpKSByZXR1cm5cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLm1lc3NhZ2UgPSBlcnIubWVzc2FnZS5yZXBsYWNlKCdsc3RhdCcsICdlbnN1cmVMaW5rJylcbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShkc3RwYXRoKVxuICBjb25zdCBkaXJFeGlzdHMgPSBmcy5leGlzdHNTeW5jKGRpcilcbiAgaWYgKGRpckV4aXN0cykgcmV0dXJuIGZzLmxpbmtTeW5jKHNyY3BhdGgsIGRzdHBhdGgpXG4gIG1rZGlyLm1rZGlyc1N5bmMoZGlyKVxuXG4gIHJldHVybiBmcy5saW5rU3luYyhzcmNwYXRoLCBkc3RwYXRoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlTGluazogdShjcmVhdGVMaW5rKSxcbiAgY3JlYXRlTGlua1N5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpLnBhdGhFeGlzdHNcblxuLyoqXG4gKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgdHdvIHR5cGVzIG9mIHBhdGhzLCBvbmUgcmVsYXRpdmUgdG8gc3ltbGluaywgYW5kIG9uZVxuICogcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuIENoZWNrcyBpZiBwYXRoIGlzIGFic29sdXRlIG9yXG4gKiByZWxhdGl2ZS4gSWYgdGhlIHBhdGggaXMgcmVsYXRpdmUsIHRoaXMgZnVuY3Rpb24gY2hlY2tzIGlmIHRoZSBwYXRoIGlzXG4gKiByZWxhdGl2ZSB0byBzeW1saW5rIG9yIHJlbGF0aXZlIHRvIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuIFRoaXMgaXMgYW5cbiAqIGluaXRpYXRpdmUgdG8gZmluZCBhIHNtYXJ0ZXIgYHNyY3BhdGhgIHRvIHN1cHBseSB3aGVuIGJ1aWxkaW5nIHN5bWxpbmtzLlxuICogVGhpcyBhbGxvd3MgeW91IHRvIGRldGVybWluZSB3aGljaCBwYXRoIHRvIHVzZSBvdXQgb2Ygb25lIG9mIHRocmVlIHBvc3NpYmxlXG4gKiB0eXBlcyBvZiBzb3VyY2UgcGF0aHMuIFRoZSBmaXJzdCBpcyBhbiBhYnNvbHV0ZSBwYXRoLiBUaGlzIGlzIGRldGVjdGVkIGJ5XG4gKiBgcGF0aC5pc0Fic29sdXRlKClgLiBXaGVuIGFuIGFic29sdXRlIHBhdGggaXMgcHJvdmlkZWQsIGl0IGlzIGNoZWNrZWQgdG9cbiAqIHNlZSBpZiBpdCBleGlzdHMuIElmIGl0IGRvZXMgaXQncyB1c2VkLCBpZiBub3QgYW4gZXJyb3IgaXMgcmV0dXJuZWRcbiAqIChjYWxsYmFjaykvIHRocm93biAoc3luYykuIFRoZSBvdGhlciB0d28gb3B0aW9ucyBmb3IgYHNyY3BhdGhgIGFyZSBhXG4gKiByZWxhdGl2ZSB1cmwuIEJ5IGRlZmF1bHQgTm9kZSdzIGBmcy5zeW1saW5rYCB3b3JrcyBieSBjcmVhdGluZyBhIHN5bWxpbmtcbiAqIHVzaW5nIGBkc3RwYXRoYCBhbmQgZXhwZWN0cyB0aGUgYHNyY3BhdGhgIHRvIGJlIHJlbGF0aXZlIHRvIHRoZSBuZXdseVxuICogY3JlYXRlZCBzeW1saW5rLiBJZiB5b3UgcHJvdmlkZSBhIGBzcmNwYXRoYCB0aGF0IGRvZXMgbm90IGV4aXN0IG9uIHRoZSBmaWxlXG4gKiBzeXN0ZW0gaXQgcmVzdWx0cyBpbiBhIGJyb2tlbiBzeW1saW5rLiBUbyBtaW5pbWl6ZSB0aGlzLCB0aGUgZnVuY3Rpb25cbiAqIGNoZWNrcyB0byBzZWUgaWYgdGhlICdyZWxhdGl2ZSB0byBzeW1saW5rJyBzb3VyY2UgZmlsZSBleGlzdHMsIGFuZCBpZiBpdFxuICogZG9lcyBpdCB3aWxsIHVzZSBpdC4gSWYgaXQgZG9lcyBub3QsIGl0IGNoZWNrcyBpZiB0aGVyZSdzIGEgZmlsZSB0aGF0XG4gKiBleGlzdHMgdGhhdCBpcyByZWxhdGl2ZSB0byB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeSwgaWYgZG9lcyBpdHMgdXNlZC5cbiAqIFRoaXMgcHJlc2VydmVzIHRoZSBleHBlY3RhdGlvbnMgb2YgdGhlIG9yaWdpbmFsIGZzLnN5bWxpbmsgc3BlYyBhbmQgYWRkc1xuICogdGhlIGFiaWxpdHkgdG8gcGFzcyBpbiBgcmVsYXRpdmUgdG8gY3VycmVudCB3b3JraW5nIGRpcmVjb3RyeWAgcGF0aHMuXG4gKi9cblxuZnVuY3Rpb24gc3ltbGlua1BhdGhzIChzcmNwYXRoLCBkc3RwYXRoLCBjYWxsYmFjaykge1xuICBpZiAocGF0aC5pc0Fic29sdXRlKHNyY3BhdGgpKSB7XG4gICAgcmV0dXJuIGZzLmxzdGF0KHNyY3BhdGgsIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZXJyLm1lc3NhZ2UgPSBlcnIubWVzc2FnZS5yZXBsYWNlKCdsc3RhdCcsICdlbnN1cmVTeW1saW5rJylcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgIHRvQ3dkOiBzcmNwYXRoLFxuICAgICAgICB0b0RzdDogc3JjcGF0aFxuICAgICAgfSlcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGRzdGRpciA9IHBhdGguZGlybmFtZShkc3RwYXRoKVxuICAgIGNvbnN0IHJlbGF0aXZlVG9Ec3QgPSBwYXRoLmpvaW4oZHN0ZGlyLCBzcmNwYXRoKVxuICAgIHJldHVybiBwYXRoRXhpc3RzKHJlbGF0aXZlVG9Ec3QsIChlcnIsIGV4aXN0cykgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIGlmIChleGlzdHMpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICB0b0N3ZDogcmVsYXRpdmVUb0RzdCxcbiAgICAgICAgICB0b0RzdDogc3JjcGF0aFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZzLmxzdGF0KHNyY3BhdGgsIChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9IGVyci5tZXNzYWdlLnJlcGxhY2UoJ2xzdGF0JywgJ2Vuc3VyZVN5bWxpbmsnKVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICAgIHRvQ3dkOiBzcmNwYXRoLFxuICAgICAgICAgICAgdG9Ec3Q6IHBhdGgucmVsYXRpdmUoZHN0ZGlyLCBzcmNwYXRoKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBzeW1saW5rUGF0aHNTeW5jIChzcmNwYXRoLCBkc3RwYXRoKSB7XG4gIGxldCBleGlzdHNcbiAgaWYgKHBhdGguaXNBYnNvbHV0ZShzcmNwYXRoKSkge1xuICAgIGV4aXN0cyA9IGZzLmV4aXN0c1N5bmMoc3JjcGF0aClcbiAgICBpZiAoIWV4aXN0cykgdGhyb3cgbmV3IEVycm9yKCdhYnNvbHV0ZSBzcmNwYXRoIGRvZXMgbm90IGV4aXN0JylcbiAgICByZXR1cm4ge1xuICAgICAgdG9Dd2Q6IHNyY3BhdGgsXG4gICAgICB0b0RzdDogc3JjcGF0aFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBkc3RkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgICBjb25zdCByZWxhdGl2ZVRvRHN0ID0gcGF0aC5qb2luKGRzdGRpciwgc3JjcGF0aClcbiAgICBleGlzdHMgPSBmcy5leGlzdHNTeW5jKHJlbGF0aXZlVG9Ec3QpXG4gICAgaWYgKGV4aXN0cykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9Dd2Q6IHJlbGF0aXZlVG9Ec3QsXG4gICAgICAgIHRvRHN0OiBzcmNwYXRoXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0cyA9IGZzLmV4aXN0c1N5bmMoc3JjcGF0aClcbiAgICAgIGlmICghZXhpc3RzKSB0aHJvdyBuZXcgRXJyb3IoJ3JlbGF0aXZlIHNyY3BhdGggZG9lcyBub3QgZXhpc3QnKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9Dd2Q6IHNyY3BhdGgsXG4gICAgICAgIHRvRHN0OiBwYXRoLnJlbGF0aXZlKGRzdGRpciwgc3JjcGF0aClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN5bWxpbmtQYXRocyxcbiAgc3ltbGlua1BhdGhzU3luY1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuXG5mdW5jdGlvbiBzeW1saW5rVHlwZSAoc3JjcGF0aCwgdHlwZSwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpID8gdHlwZSA6IGNhbGxiYWNrXG4gIHR5cGUgPSAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpID8gZmFsc2UgOiB0eXBlXG4gIGlmICh0eXBlKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgdHlwZSlcbiAgZnMubHN0YXQoc3JjcGF0aCwgKGVyciwgc3RhdHMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgJ2ZpbGUnKVxuICAgIHR5cGUgPSAoc3RhdHMgJiYgc3RhdHMuaXNEaXJlY3RvcnkoKSkgPyAnZGlyJyA6ICdmaWxlJ1xuICAgIGNhbGxiYWNrKG51bGwsIHR5cGUpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHN5bWxpbmtUeXBlU3luYyAoc3JjcGF0aCwgdHlwZSkge1xuICBsZXQgc3RhdHNcblxuICBpZiAodHlwZSkgcmV0dXJuIHR5cGVcbiAgdHJ5IHtcbiAgICBzdGF0cyA9IGZzLmxzdGF0U3luYyhzcmNwYXRoKVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gJ2ZpbGUnXG4gIH1cbiAgcmV0dXJuIChzdGF0cyAmJiBzdGF0cy5pc0RpcmVjdG9yeSgpKSA/ICdkaXInIDogJ2ZpbGUnXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzeW1saW5rVHlwZSxcbiAgc3ltbGlua1R5cGVTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5jb25zdCBfbWtkaXJzID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IG1rZGlycyA9IF9ta2RpcnMubWtkaXJzXG5jb25zdCBta2RpcnNTeW5jID0gX21rZGlycy5ta2RpcnNTeW5jXG5cbmNvbnN0IF9zeW1saW5rUGF0aHMgPSByZXF1aXJlKCcuL3N5bWxpbmstcGF0aHMnKVxuY29uc3Qgc3ltbGlua1BhdGhzID0gX3N5bWxpbmtQYXRocy5zeW1saW5rUGF0aHNcbmNvbnN0IHN5bWxpbmtQYXRoc1N5bmMgPSBfc3ltbGlua1BhdGhzLnN5bWxpbmtQYXRoc1N5bmNcblxuY29uc3QgX3N5bWxpbmtUeXBlID0gcmVxdWlyZSgnLi9zeW1saW5rLXR5cGUnKVxuY29uc3Qgc3ltbGlua1R5cGUgPSBfc3ltbGlua1R5cGUuc3ltbGlua1R5cGVcbmNvbnN0IHN5bWxpbmtUeXBlU3luYyA9IF9zeW1saW5rVHlwZS5zeW1saW5rVHlwZVN5bmNcblxuY29uc3QgcGF0aEV4aXN0cyA9IHJlcXVpcmUoJy4uL3BhdGgtZXhpc3RzJykucGF0aEV4aXN0c1xuXG5jb25zdCB7IGFyZUlkZW50aWNhbCB9ID0gcmVxdWlyZSgnLi4vdXRpbC9zdGF0JylcblxuZnVuY3Rpb24gY3JlYXRlU3ltbGluayAoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpID8gdHlwZSA6IGNhbGxiYWNrXG4gIHR5cGUgPSAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpID8gZmFsc2UgOiB0eXBlXG5cbiAgZnMubHN0YXQoZHN0cGF0aCwgKGVyciwgc3RhdHMpID0+IHtcbiAgICBpZiAoIWVyciAmJiBzdGF0cy5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgIGZzLnN0YXQoc3JjcGF0aCksXG4gICAgICAgIGZzLnN0YXQoZHN0cGF0aClcbiAgICAgIF0pLnRoZW4oKFtzcmNTdGF0LCBkc3RTdGF0XSkgPT4ge1xuICAgICAgICBpZiAoYXJlSWRlbnRpY2FsKHNyY1N0YXQsIGRzdFN0YXQpKSByZXR1cm4gY2FsbGJhY2sobnVsbClcbiAgICAgICAgX2NyZWF0ZVN5bWxpbmsoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSwgY2FsbGJhY2spXG4gICAgICB9KVxuICAgIH0gZWxzZSBfY3JlYXRlU3ltbGluayhzcmNwYXRoLCBkc3RwYXRoLCB0eXBlLCBjYWxsYmFjaylcbiAgfSlcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN5bWxpbmsgKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUsIGNhbGxiYWNrKSB7XG4gIHN5bWxpbmtQYXRocyhzcmNwYXRoLCBkc3RwYXRoLCAoZXJyLCByZWxhdGl2ZSkgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgc3JjcGF0aCA9IHJlbGF0aXZlLnRvRHN0XG4gICAgc3ltbGlua1R5cGUocmVsYXRpdmUudG9Dd2QsIHR5cGUsIChlcnIsIHR5cGUpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgICAgIHBhdGhFeGlzdHMoZGlyLCAoZXJyLCBkaXJFeGlzdHMpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgaWYgKGRpckV4aXN0cykgcmV0dXJuIGZzLnN5bWxpbmsoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSwgY2FsbGJhY2spXG4gICAgICAgIG1rZGlycyhkaXIsIGVyciA9PiB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgICBmcy5zeW1saW5rKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUsIGNhbGxiYWNrKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTeW1saW5rU3luYyAoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSkge1xuICBsZXQgc3RhdHNcbiAgdHJ5IHtcbiAgICBzdGF0cyA9IGZzLmxzdGF0U3luYyhkc3RwYXRoKVxuICB9IGNhdGNoIHt9XG4gIGlmIChzdGF0cyAmJiBzdGF0cy5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgY29uc3Qgc3JjU3RhdCA9IGZzLnN0YXRTeW5jKHNyY3BhdGgpXG4gICAgY29uc3QgZHN0U3RhdCA9IGZzLnN0YXRTeW5jKGRzdHBhdGgpXG4gICAgaWYgKGFyZUlkZW50aWNhbChzcmNTdGF0LCBkc3RTdGF0KSkgcmV0dXJuXG4gIH1cblxuICBjb25zdCByZWxhdGl2ZSA9IHN5bWxpbmtQYXRoc1N5bmMoc3JjcGF0aCwgZHN0cGF0aClcbiAgc3JjcGF0aCA9IHJlbGF0aXZlLnRvRHN0XG4gIHR5cGUgPSBzeW1saW5rVHlwZVN5bmMocmVsYXRpdmUudG9Dd2QsIHR5cGUpXG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShkc3RwYXRoKVxuICBjb25zdCBleGlzdHMgPSBmcy5leGlzdHNTeW5jKGRpcilcbiAgaWYgKGV4aXN0cykgcmV0dXJuIGZzLnN5bWxpbmtTeW5jKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUpXG4gIG1rZGlyc1N5bmMoZGlyKVxuICByZXR1cm4gZnMuc3ltbGlua1N5bmMoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZVN5bWxpbms6IHUoY3JlYXRlU3ltbGluayksXG4gIGNyZWF0ZVN5bWxpbmtTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZmlsZSA9IHJlcXVpcmUoJy4vZmlsZScpXG5jb25zdCBsaW5rID0gcmVxdWlyZSgnLi9saW5rJylcbmNvbnN0IHN5bWxpbmsgPSByZXF1aXJlKCcuL3N5bWxpbmsnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gZmlsZVxuICBjcmVhdGVGaWxlOiBmaWxlLmNyZWF0ZUZpbGUsXG4gIGNyZWF0ZUZpbGVTeW5jOiBmaWxlLmNyZWF0ZUZpbGVTeW5jLFxuICBlbnN1cmVGaWxlOiBmaWxlLmNyZWF0ZUZpbGUsXG4gIGVuc3VyZUZpbGVTeW5jOiBmaWxlLmNyZWF0ZUZpbGVTeW5jLFxuICAvLyBsaW5rXG4gIGNyZWF0ZUxpbms6IGxpbmsuY3JlYXRlTGluayxcbiAgY3JlYXRlTGlua1N5bmM6IGxpbmsuY3JlYXRlTGlua1N5bmMsXG4gIGVuc3VyZUxpbms6IGxpbmsuY3JlYXRlTGluayxcbiAgZW5zdXJlTGlua1N5bmM6IGxpbmsuY3JlYXRlTGlua1N5bmMsXG4gIC8vIHN5bWxpbmtcbiAgY3JlYXRlU3ltbGluazogc3ltbGluay5jcmVhdGVTeW1saW5rLFxuICBjcmVhdGVTeW1saW5rU3luYzogc3ltbGluay5jcmVhdGVTeW1saW5rU3luYyxcbiAgZW5zdXJlU3ltbGluazogc3ltbGluay5jcmVhdGVTeW1saW5rLFxuICBlbnN1cmVTeW1saW5rU3luYzogc3ltbGluay5jcmVhdGVTeW1saW5rU3luY1xufVxuIiwiZnVuY3Rpb24gc3RyaW5naWZ5IChvYmosIHsgRU9MID0gJ1xcbicsIGZpbmFsRU9MID0gdHJ1ZSwgcmVwbGFjZXIgPSBudWxsLCBzcGFjZXMgfSA9IHt9KSB7XG4gIGNvbnN0IEVPRiA9IGZpbmFsRU9MID8gRU9MIDogJydcbiAgY29uc3Qgc3RyID0gSlNPTi5zdHJpbmdpZnkob2JqLCByZXBsYWNlciwgc3BhY2VzKVxuXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxuL2csIEVPTCkgKyBFT0Zcbn1cblxuZnVuY3Rpb24gc3RyaXBCb20gKGNvbnRlbnQpIHtcbiAgLy8gd2UgZG8gdGhpcyBiZWNhdXNlIEpTT04ucGFyc2Ugd291bGQgY29udmVydCBpdCB0byBhIHV0Zjggc3RyaW5nIGlmIGVuY29kaW5nIHdhc24ndCBzcGVjaWZpZWRcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjb250ZW50KSkgY29udGVudCA9IGNvbnRlbnQudG9TdHJpbmcoJ3V0ZjgnKVxuICByZXR1cm4gY29udGVudC5yZXBsYWNlKC9eXFx1RkVGRi8sICcnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgc3RyaW5naWZ5LCBzdHJpcEJvbSB9XG4iLCJsZXQgX2ZzXG50cnkge1xuICBfZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG59IGNhdGNoIChfKSB7XG4gIF9mcyA9IHJlcXVpcmUoJ2ZzJylcbn1cbmNvbnN0IHVuaXZlcnNhbGlmeSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpXG5jb25zdCB7IHN0cmluZ2lmeSwgc3RyaXBCb20gfSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuXG5hc3luYyBmdW5jdGlvbiBfcmVhZEZpbGUgKGZpbGUsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHsgZW5jb2Rpbmc6IG9wdGlvbnMgfVxuICB9XG5cbiAgY29uc3QgZnMgPSBvcHRpb25zLmZzIHx8IF9mc1xuXG4gIGNvbnN0IHNob3VsZFRocm93ID0gJ3Rocm93cycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudGhyb3dzIDogdHJ1ZVxuXG4gIGxldCBkYXRhID0gYXdhaXQgdW5pdmVyc2FsaWZ5LmZyb21DYWxsYmFjayhmcy5yZWFkRmlsZSkoZmlsZSwgb3B0aW9ucylcblxuICBkYXRhID0gc3RyaXBCb20oZGF0YSlcblxuICBsZXQgb2JqXG4gIHRyeSB7XG4gICAgb2JqID0gSlNPTi5wYXJzZShkYXRhLCBvcHRpb25zID8gb3B0aW9ucy5yZXZpdmVyIDogbnVsbClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHNob3VsZFRocm93KSB7XG4gICAgICBlcnIubWVzc2FnZSA9IGAke2ZpbGV9OiAke2Vyci5tZXNzYWdlfWBcbiAgICAgIHRocm93IGVyclxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmpcbn1cblxuY29uc3QgcmVhZEZpbGUgPSB1bml2ZXJzYWxpZnkuZnJvbVByb21pc2UoX3JlYWRGaWxlKVxuXG5mdW5jdGlvbiByZWFkRmlsZVN5bmMgKGZpbGUsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHsgZW5jb2Rpbmc6IG9wdGlvbnMgfVxuICB9XG5cbiAgY29uc3QgZnMgPSBvcHRpb25zLmZzIHx8IF9mc1xuXG4gIGNvbnN0IHNob3VsZFRocm93ID0gJ3Rocm93cycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudGhyb3dzIDogdHJ1ZVxuXG4gIHRyeSB7XG4gICAgbGV0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZSwgb3B0aW9ucylcbiAgICBjb250ZW50ID0gc3RyaXBCb20oY29udGVudClcbiAgICByZXR1cm4gSlNPTi5wYXJzZShjb250ZW50LCBvcHRpb25zLnJldml2ZXIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgZXJyLm1lc3NhZ2UgPSBgJHtmaWxlfTogJHtlcnIubWVzc2FnZX1gXG4gICAgICB0aHJvdyBlcnJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gX3dyaXRlRmlsZSAoZmlsZSwgb2JqLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgZnMgPSBvcHRpb25zLmZzIHx8IF9mc1xuXG4gIGNvbnN0IHN0ciA9IHN0cmluZ2lmeShvYmosIG9wdGlvbnMpXG5cbiAgYXdhaXQgdW5pdmVyc2FsaWZ5LmZyb21DYWxsYmFjayhmcy53cml0ZUZpbGUpKGZpbGUsIHN0ciwgb3B0aW9ucylcbn1cblxuY29uc3Qgd3JpdGVGaWxlID0gdW5pdmVyc2FsaWZ5LmZyb21Qcm9taXNlKF93cml0ZUZpbGUpXG5cbmZ1bmN0aW9uIHdyaXRlRmlsZVN5bmMgKGZpbGUsIG9iaiwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGZzID0gb3B0aW9ucy5mcyB8fCBfZnNcblxuICBjb25zdCBzdHIgPSBzdHJpbmdpZnkob2JqLCBvcHRpb25zKVxuICAvLyBub3Qgc3VyZSBpZiBmcy53cml0ZUZpbGVTeW5jIHJldHVybnMgYW55dGhpbmcsIGJ1dCBqdXN0IGluIGNhc2VcbiAgcmV0dXJuIGZzLndyaXRlRmlsZVN5bmMoZmlsZSwgc3RyLCBvcHRpb25zKVxufVxuXG5jb25zdCBqc29uZmlsZSA9IHtcbiAgcmVhZEZpbGUsXG4gIHJlYWRGaWxlU3luYyxcbiAgd3JpdGVGaWxlLFxuICB3cml0ZUZpbGVTeW5jXG59XG5cbm1vZHVsZS5leHBvcnRzID0ganNvbmZpbGVcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBqc29uRmlsZSA9IHJlcXVpcmUoJ2pzb25maWxlJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGpzb25maWxlIGV4cG9ydHNcbiAgcmVhZEpzb246IGpzb25GaWxlLnJlYWRGaWxlLFxuICByZWFkSnNvblN5bmM6IGpzb25GaWxlLnJlYWRGaWxlU3luYyxcbiAgd3JpdGVKc29uOiBqc29uRmlsZS53cml0ZUZpbGUsXG4gIHdyaXRlSnNvblN5bmM6IGpzb25GaWxlLndyaXRlRmlsZVN5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpLnBhdGhFeGlzdHNcblxuZnVuY3Rpb24gb3V0cHV0RmlsZSAoZmlsZSwgZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShmaWxlKVxuICBwYXRoRXhpc3RzKGRpciwgKGVyciwgaXREb2VzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICBpZiAoaXREb2VzKSByZXR1cm4gZnMud3JpdGVGaWxlKGZpbGUsIGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaylcblxuICAgIG1rZGlyLm1rZGlycyhkaXIsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuXG4gICAgICBmcy53cml0ZUZpbGUoZmlsZSwgZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG91dHB1dEZpbGVTeW5jIChmaWxlLCAuLi5hcmdzKSB7XG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShmaWxlKVxuICBpZiAoZnMuZXhpc3RzU3luYyhkaXIpKSB7XG4gICAgcmV0dXJuIGZzLndyaXRlRmlsZVN5bmMoZmlsZSwgLi4uYXJncylcbiAgfVxuICBta2Rpci5ta2RpcnNTeW5jKGRpcilcbiAgZnMud3JpdGVGaWxlU3luYyhmaWxlLCAuLi5hcmdzKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgb3V0cHV0RmlsZTogdShvdXRwdXRGaWxlKSxcbiAgb3V0cHV0RmlsZVN5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHN0cmluZ2lmeSB9ID0gcmVxdWlyZSgnanNvbmZpbGUvdXRpbHMnKVxuY29uc3QgeyBvdXRwdXRGaWxlIH0gPSByZXF1aXJlKCcuLi9vdXRwdXQnKVxuXG5hc3luYyBmdW5jdGlvbiBvdXRwdXRKc29uIChmaWxlLCBkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qgc3RyID0gc3RyaW5naWZ5KGRhdGEsIG9wdGlvbnMpXG5cbiAgYXdhaXQgb3V0cHV0RmlsZShmaWxlLCBzdHIsIG9wdGlvbnMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3V0cHV0SnNvblxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgc3RyaW5naWZ5IH0gPSByZXF1aXJlKCdqc29uZmlsZS91dGlscycpXG5jb25zdCB7IG91dHB1dEZpbGVTeW5jIH0gPSByZXF1aXJlKCcuLi9vdXRwdXQnKVxuXG5mdW5jdGlvbiBvdXRwdXRKc29uU3luYyAoZmlsZSwgZGF0YSwgb3B0aW9ucykge1xuICBjb25zdCBzdHIgPSBzdHJpbmdpZnkoZGF0YSwgb3B0aW9ucylcblxuICBvdXRwdXRGaWxlU3luYyhmaWxlLCBzdHIsIG9wdGlvbnMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3V0cHV0SnNvblN5bmNcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2VcbmNvbnN0IGpzb25GaWxlID0gcmVxdWlyZSgnLi9qc29uZmlsZScpXG5cbmpzb25GaWxlLm91dHB1dEpzb24gPSB1KHJlcXVpcmUoJy4vb3V0cHV0LWpzb24nKSlcbmpzb25GaWxlLm91dHB1dEpzb25TeW5jID0gcmVxdWlyZSgnLi9vdXRwdXQtanNvbi1zeW5jJylcbi8vIGFsaWFzZXNcbmpzb25GaWxlLm91dHB1dEpTT04gPSBqc29uRmlsZS5vdXRwdXRKc29uXG5qc29uRmlsZS5vdXRwdXRKU09OU3luYyA9IGpzb25GaWxlLm91dHB1dEpzb25TeW5jXG5qc29uRmlsZS53cml0ZUpTT04gPSBqc29uRmlsZS53cml0ZUpzb25cbmpzb25GaWxlLndyaXRlSlNPTlN5bmMgPSBqc29uRmlsZS53cml0ZUpzb25TeW5jXG5qc29uRmlsZS5yZWFkSlNPTiA9IGpzb25GaWxlLnJlYWRKc29uXG5qc29uRmlsZS5yZWFkSlNPTlN5bmMgPSBqc29uRmlsZS5yZWFkSnNvblN5bmNcblxubW9kdWxlLmV4cG9ydHMgPSBqc29uRmlsZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgY29weVN5bmMgPSByZXF1aXJlKCcuLi9jb3B5LXN5bmMnKS5jb3B5U3luY1xuY29uc3QgcmVtb3ZlU3luYyA9IHJlcXVpcmUoJy4uL3JlbW92ZScpLnJlbW92ZVN5bmNcbmNvbnN0IG1rZGlycFN5bmMgPSByZXF1aXJlKCcuLi9ta2RpcnMnKS5ta2RpcnBTeW5jXG5jb25zdCBzdGF0ID0gcmVxdWlyZSgnLi4vdXRpbC9zdGF0JylcblxuZnVuY3Rpb24gbW92ZVN5bmMgKHNyYywgZGVzdCwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fVxuICBjb25zdCBvdmVyd3JpdGUgPSBvcHRzLm92ZXJ3cml0ZSB8fCBvcHRzLmNsb2JiZXIgfHwgZmFsc2VcblxuICBjb25zdCB7IHNyY1N0YXQsIGlzQ2hhbmdpbmdDYXNlID0gZmFsc2UgfSA9IHN0YXQuY2hlY2tQYXRoc1N5bmMoc3JjLCBkZXN0LCAnbW92ZScsIG9wdHMpXG4gIHN0YXQuY2hlY2tQYXJlbnRQYXRoc1N5bmMoc3JjLCBzcmNTdGF0LCBkZXN0LCAnbW92ZScpXG4gIGlmICghaXNQYXJlbnRSb290KGRlc3QpKSBta2RpcnBTeW5jKHBhdGguZGlybmFtZShkZXN0KSlcbiAgcmV0dXJuIGRvUmVuYW1lKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBpc0NoYW5naW5nQ2FzZSlcbn1cblxuZnVuY3Rpb24gaXNQYXJlbnRSb290IChkZXN0KSB7XG4gIGNvbnN0IHBhcmVudCA9IHBhdGguZGlybmFtZShkZXN0KVxuICBjb25zdCBwYXJzZWRQYXRoID0gcGF0aC5wYXJzZShwYXJlbnQpXG4gIHJldHVybiBwYXJzZWRQYXRoLnJvb3QgPT09IHBhcmVudFxufVxuXG5mdW5jdGlvbiBkb1JlbmFtZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGlzQ2hhbmdpbmdDYXNlKSB7XG4gIGlmIChpc0NoYW5naW5nQ2FzZSkgcmV0dXJuIHJlbmFtZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSlcbiAgaWYgKG92ZXJ3cml0ZSkge1xuICAgIHJlbW92ZVN5bmMoZGVzdClcbiAgICByZXR1cm4gcmVuYW1lKHNyYywgZGVzdCwgb3ZlcndyaXRlKVxuICB9XG4gIGlmIChmcy5leGlzdHNTeW5jKGRlc3QpKSB0aHJvdyBuZXcgRXJyb3IoJ2Rlc3QgYWxyZWFkeSBleGlzdHMuJylcbiAgcmV0dXJuIHJlbmFtZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSlcbn1cblxuZnVuY3Rpb24gcmVuYW1lIChzcmMsIGRlc3QsIG92ZXJ3cml0ZSkge1xuICB0cnkge1xuICAgIGZzLnJlbmFtZVN5bmMoc3JjLCBkZXN0KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgIT09ICdFWERFVicpIHRocm93IGVyclxuICAgIHJldHVybiBtb3ZlQWNyb3NzRGV2aWNlKHNyYywgZGVzdCwgb3ZlcndyaXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vdmVBY3Jvc3NEZXZpY2UgKHNyYywgZGVzdCwgb3ZlcndyaXRlKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgb3ZlcndyaXRlLFxuICAgIGVycm9yT25FeGlzdDogdHJ1ZVxuICB9XG4gIGNvcHlTeW5jKHNyYywgZGVzdCwgb3B0cylcbiAgcmV0dXJuIHJlbW92ZVN5bmMoc3JjKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1vdmVTeW5jXG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1vdmVTeW5jOiByZXF1aXJlKCcuL21vdmUtc3luYycpXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBjb3B5ID0gcmVxdWlyZSgnLi4vY29weScpLmNvcHlcbmNvbnN0IHJlbW92ZSA9IHJlcXVpcmUoJy4uL3JlbW92ZScpLnJlbW92ZVxuY29uc3QgbWtkaXJwID0gcmVxdWlyZSgnLi4vbWtkaXJzJykubWtkaXJwXG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKS5wYXRoRXhpc3RzXG5jb25zdCBzdGF0ID0gcmVxdWlyZSgnLi4vdXRpbC9zdGF0JylcblxuZnVuY3Rpb24gbW92ZSAoc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdHNcbiAgICBvcHRzID0ge31cbiAgfVxuXG4gIGNvbnN0IG92ZXJ3cml0ZSA9IG9wdHMub3ZlcndyaXRlIHx8IG9wdHMuY2xvYmJlciB8fCBmYWxzZVxuXG4gIHN0YXQuY2hlY2tQYXRocyhzcmMsIGRlc3QsICdtb3ZlJywgb3B0cywgKGVyciwgc3RhdHMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGNvbnN0IHsgc3JjU3RhdCwgaXNDaGFuZ2luZ0Nhc2UgPSBmYWxzZSB9ID0gc3RhdHNcbiAgICBzdGF0LmNoZWNrUGFyZW50UGF0aHMoc3JjLCBzcmNTdGF0LCBkZXN0LCAnbW92ZScsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgaWYgKGlzUGFyZW50Um9vdChkZXN0KSkgcmV0dXJuIGRvUmVuYW1lKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBpc0NoYW5naW5nQ2FzZSwgY2IpXG4gICAgICBta2RpcnAocGF0aC5kaXJuYW1lKGRlc3QpLCBlcnIgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgICByZXR1cm4gZG9SZW5hbWUoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGlzQ2hhbmdpbmdDYXNlLCBjYilcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gaXNQYXJlbnRSb290IChkZXN0KSB7XG4gIGNvbnN0IHBhcmVudCA9IHBhdGguZGlybmFtZShkZXN0KVxuICBjb25zdCBwYXJzZWRQYXRoID0gcGF0aC5wYXJzZShwYXJlbnQpXG4gIHJldHVybiBwYXJzZWRQYXRoLnJvb3QgPT09IHBhcmVudFxufVxuXG5mdW5jdGlvbiBkb1JlbmFtZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGlzQ2hhbmdpbmdDYXNlLCBjYikge1xuICBpZiAoaXNDaGFuZ2luZ0Nhc2UpIHJldHVybiByZW5hbWUoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGNiKVxuICBpZiAob3ZlcndyaXRlKSB7XG4gICAgcmV0dXJuIHJlbW92ZShkZXN0LCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIHJldHVybiByZW5hbWUoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGNiKVxuICAgIH0pXG4gIH1cbiAgcGF0aEV4aXN0cyhkZXN0LCAoZXJyLCBkZXN0RXhpc3RzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBpZiAoZGVzdEV4aXN0cykgcmV0dXJuIGNiKG5ldyBFcnJvcignZGVzdCBhbHJlYWR5IGV4aXN0cy4nKSlcbiAgICByZXR1cm4gcmVuYW1lKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBjYilcbiAgfSlcbn1cblxuZnVuY3Rpb24gcmVuYW1lIChzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgY2IpIHtcbiAgZnMucmVuYW1lKHNyYywgZGVzdCwgZXJyID0+IHtcbiAgICBpZiAoIWVycikgcmV0dXJuIGNiKClcbiAgICBpZiAoZXJyLmNvZGUgIT09ICdFWERFVicpIHJldHVybiBjYihlcnIpXG4gICAgcmV0dXJuIG1vdmVBY3Jvc3NEZXZpY2Uoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGNiKVxuICB9KVxufVxuXG5mdW5jdGlvbiBtb3ZlQWNyb3NzRGV2aWNlIChzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgY2IpIHtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBvdmVyd3JpdGUsXG4gICAgZXJyb3JPbkV4aXN0OiB0cnVlXG4gIH1cbiAgY29weShzcmMsIGRlc3QsIG9wdHMsIGVyciA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICByZXR1cm4gcmVtb3ZlKHNyYywgY2IpXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbW92ZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcbm1vZHVsZS5leHBvcnRzID0ge1xuICBtb3ZlOiB1KHJlcXVpcmUoJy4vbW92ZScpKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBFeHBvcnQgcHJvbWlzZWlmaWVkIGdyYWNlZnVsLWZzOlxuICAuLi5yZXF1aXJlKCcuL2ZzJyksXG4gIC8vIEV4cG9ydCBleHRyYSBtZXRob2RzOlxuICAuLi5yZXF1aXJlKCcuL2NvcHktc3luYycpLFxuICAuLi5yZXF1aXJlKCcuL2NvcHknKSxcbiAgLi4ucmVxdWlyZSgnLi9lbXB0eScpLFxuICAuLi5yZXF1aXJlKCcuL2Vuc3VyZScpLFxuICAuLi5yZXF1aXJlKCcuL2pzb24nKSxcbiAgLi4ucmVxdWlyZSgnLi9ta2RpcnMnKSxcbiAgLi4ucmVxdWlyZSgnLi9tb3ZlLXN5bmMnKSxcbiAgLi4ucmVxdWlyZSgnLi9tb3ZlJyksXG4gIC4uLnJlcXVpcmUoJy4vb3V0cHV0JyksXG4gIC4uLnJlcXVpcmUoJy4vcGF0aC1leGlzdHMnKSxcbiAgLi4ucmVxdWlyZSgnLi9yZW1vdmUnKVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNhbmNlbGxhdGlvbkVycm9yID0gZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlbiA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNsYXNzIENhbmNlbGxhdGlvblRva2VuIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICAvLyBiYWJlbCBjYW5ub3QgY29tcGlsZSAuLi4gY29ycmVjdGx5IGZvciBzdXBlciBjYWxsc1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBhcmVudENhbmNlbEhhbmRsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY2FuY2VsbGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FuY2VsbGVkIHx8ICh0aGlzLl9wYXJlbnQgIT0gbnVsbCAmJiB0aGlzLl9wYXJlbnQuY2FuY2VsbGVkKTtcbiAgICB9XG4gICAgc2V0IHBhcmVudCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnJlbW92ZVBhcmVudENhbmNlbEhhbmRsZXIoKTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gdmFsdWU7XG4gICAgICAgIHRoaXMucGFyZW50Q2FuY2VsSGFuZGxlciA9ICgpID0+IHRoaXMuY2FuY2VsKCk7XG4gICAgICAgIHRoaXMuX3BhcmVudC5vbkNhbmNlbCh0aGlzLnBhcmVudENhbmNlbEhhbmRsZXIpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHRoaXMuX2NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdChcImNhbmNlbFwiKTtcbiAgICB9XG4gICAgb25DYW5jZWwoaGFuZGxlcikge1xuICAgICAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25jZShcImNhbmNlbFwiLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVQcm9taXNlKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBDYW5jZWxsYXRpb25FcnJvcigpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaW5hbGx5SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChjYW5jZWxIYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKFwiY2FuY2VsXCIsIGNhbmNlbEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCBjYW5jZWxIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCBhZGRlZENhbmNlbEhhbmRsZXIgPSBudWxsO1xuICAgICAgICAgICAgY2FuY2VsSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkZWRDYW5jZWxIYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZGVkQ2FuY2VsSGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWRDYW5jZWxIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBDYW5jZWxsYXRpb25FcnJvcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsSGFuZGxlcigpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub25DYW5jZWwoY2FuY2VsSGFuZGxlcik7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXNvbHZlLCByZWplY3QsIChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIGFkZGVkQ2FuY2VsSGFuZGxlciA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihpdCA9PiB7XG4gICAgICAgICAgICBmaW5hbGx5SGFuZGxlcigpO1xuICAgICAgICAgICAgcmV0dXJuIGl0O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICBmaW5hbGx5SGFuZGxlcigpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZVBhcmVudENhbmNlbEhhbmRsZXIoKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX3BhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCAhPSBudWxsICYmIHRoaXMucGFyZW50Q2FuY2VsSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlTGlzdGVuZXIoXCJjYW5jZWxcIiwgdGhpcy5wYXJlbnRDYW5jZWxIYW5kbGVyKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50Q2FuY2VsSGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUGFyZW50Q2FuY2VsSGFuZGxlcigpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkNhbmNlbGxhdGlvblRva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW47XG5jbGFzcyBDYW5jZWxsYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJjYW5jZWxsZWRcIik7XG4gICAgfVxufVxuZXhwb3J0cy5DYW5jZWxsYXRpb25FcnJvciA9IENhbmNlbGxhdGlvbkVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FuY2VsbGF0aW9uVG9rZW4uanMubWFwIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcblx0Y3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG5cdGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cdGNyZWF0ZURlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG5cdE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcblx0fSk7XG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCovXG5cblx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0KiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCpcblx0KiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcblx0KiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG5cdFx0bGV0IGhhc2ggPSAwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG5cdH1cblx0Y3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcblxuXHQvKipcblx0KiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblx0XHRsZXQgcHJldlRpbWU7XG5cdFx0bGV0IGVuYWJsZU92ZXJyaWRlID0gbnVsbDtcblx0XHRsZXQgbmFtZXNwYWNlc0NhY2hlO1xuXHRcdGxldCBlbmFibGVkQ2FjaGU7XG5cblx0XHRmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG5cdFx0XHQvLyBEaXNhYmxlZD9cblx0XHRcdGlmICghZGVidWcuZW5hYmxlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbGYgPSBkZWJ1ZztcblxuXHRcdFx0Ly8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0XHRcdGNvbnN0IGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cdFx0XHRjb25zdCBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG5cdFx0XHRzZWxmLmRpZmYgPSBtcztcblx0XHRcdHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHRcdFx0c2VsZi5jdXJyID0gY3Vycjtcblx0XHRcdHByZXZUaW1lID0gY3VycjtcblxuXHRcdFx0YXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoJyVPJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0YXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIChtYXRjaCwgZm9ybWF0KSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcblx0XHRcdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRcdFx0cmV0dXJuICclJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdFx0XHRcdGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gYXJnc1tpbmRleF07XG5cdFx0XHRcdFx0bWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdFx0XHRcdFx0Ly8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHRcdFx0XHRcdGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXHRcdFx0Y3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG5cdFx0XHRjb25zdCBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcblx0XHRcdGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0XHRkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcblx0XHRkZWJ1Zy5jb2xvciA9IGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcuZXh0ZW5kID0gZXh0ZW5kO1xuXHRcdGRlYnVnLmRlc3Ryb3kgPSBjcmVhdGVEZWJ1Zy5kZXN0cm95OyAvLyBYWFggVGVtcG9yYXJ5LiBXaWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWJ1ZywgJ2VuYWJsZWQnLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRpZiAoZW5hYmxlT3ZlcnJpZGUgIT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gZW5hYmxlT3ZlcnJpZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5hbWVzcGFjZXNDYWNoZSAhPT0gY3JlYXRlRGVidWcubmFtZXNwYWNlcykge1xuXHRcdFx0XHRcdG5hbWVzcGFjZXNDYWNoZSA9IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXM7XG5cdFx0XHRcdFx0ZW5hYmxlZENhY2hlID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVuYWJsZWRDYWNoZTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IHYgPT4ge1xuXHRcdFx0XHRlbmFibGVPdmVycmlkZSA9IHY7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBFbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXHRcdGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlYnVnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cdFx0Y3JlYXRlRGVidWcubmFtZXNwYWNlcyA9IG5hbWVzcGFjZXM7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRsZXQgaTtcblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0Y29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zbGljZSgxKSArICckJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0KiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0KlxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdFx0Y29uc3QgbmFtZXNwYWNlcyA9IFtcblx0XHRcdC4uLmNyZWF0ZURlYnVnLm5hbWVzLm1hcCh0b05hbWVzcGFjZSksXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5za2lwcy5tYXAodG9OYW1lc3BhY2UpLm1hcChuYW1lc3BhY2UgPT4gJy0nICsgbmFtZXNwYWNlKVxuXHRcdF0uam9pbignLCcpO1xuXHRcdGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG5cdFx0cmV0dXJuIG5hbWVzcGFjZXM7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG5cdFx0aWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRsZXQgaTtcblx0XHRsZXQgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCogQ29udmVydCByZWdleHAgdG8gbmFtZXNwYWNlXG5cdCpcblx0KiBAcGFyYW0ge1JlZ0V4cH0gcmVneGVwXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gdG9OYW1lc3BhY2UocmVnZXhwKSB7XG5cdFx0cmV0dXJuIHJlZ2V4cC50b1N0cmluZygpXG5cdFx0XHQuc3Vic3RyaW5nKDIsIHJlZ2V4cC50b1N0cmluZygpLmxlbmd0aCAtIDIpXG5cdFx0XHQucmVwbGFjZSgvXFwuXFwqXFw/JC8sICcqJyk7XG5cdH1cblxuXHQvKipcblx0KiBDb2VyY2UgYHZhbGAuXG5cdCpcblx0KiBAcGFyYW0ge01peGVkfSB2YWxcblx0KiBAcmV0dXJuIHtNaXhlZH1cblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0cmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdC8qKlxuXHQqIFhYWCBETyBOT1QgVVNFLiBUaGlzIGlzIGEgdGVtcG9yYXJ5IHN0dWIgZnVuY3Rpb24uXG5cdCogWFhYIEl0IFdJTEwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXHQqL1xuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHR9XG5cblx0Y3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG5cblx0cmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG5leHBvcnRzLmRlc3Ryb3kgPSAoKCkgPT4ge1xuXHRsZXQgd2FybmVkID0gZmFsc2U7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoIXdhcm5lZCkge1xuXHRcdFx0d2FybmVkID0gdHJ1ZTtcblx0XHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHRcdH1cblx0fTtcbn0pKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuXHQnIzAwMDBDQycsXG5cdCcjMDAwMEZGJyxcblx0JyMwMDMzQ0MnLFxuXHQnIzAwMzNGRicsXG5cdCcjMDA2NkNDJyxcblx0JyMwMDY2RkYnLFxuXHQnIzAwOTlDQycsXG5cdCcjMDA5OUZGJyxcblx0JyMwMENDMDAnLFxuXHQnIzAwQ0MzMycsXG5cdCcjMDBDQzY2Jyxcblx0JyMwMENDOTknLFxuXHQnIzAwQ0NDQycsXG5cdCcjMDBDQ0ZGJyxcblx0JyMzMzAwQ0MnLFxuXHQnIzMzMDBGRicsXG5cdCcjMzMzM0NDJyxcblx0JyMzMzMzRkYnLFxuXHQnIzMzNjZDQycsXG5cdCcjMzM2NkZGJyxcblx0JyMzMzk5Q0MnLFxuXHQnIzMzOTlGRicsXG5cdCcjMzNDQzAwJyxcblx0JyMzM0NDMzMnLFxuXHQnIzMzQ0M2NicsXG5cdCcjMzNDQzk5Jyxcblx0JyMzM0NDQ0MnLFxuXHQnIzMzQ0NGRicsXG5cdCcjNjYwMENDJyxcblx0JyM2NjAwRkYnLFxuXHQnIzY2MzNDQycsXG5cdCcjNjYzM0ZGJyxcblx0JyM2NkNDMDAnLFxuXHQnIzY2Q0MzMycsXG5cdCcjOTkwMENDJyxcblx0JyM5OTAwRkYnLFxuXHQnIzk5MzNDQycsXG5cdCcjOTkzM0ZGJyxcblx0JyM5OUNDMDAnLFxuXHQnIzk5Q0MzMycsXG5cdCcjQ0MwMDAwJyxcblx0JyNDQzAwMzMnLFxuXHQnI0NDMDA2NicsXG5cdCcjQ0MwMDk5Jyxcblx0JyNDQzAwQ0MnLFxuXHQnI0NDMDBGRicsXG5cdCcjQ0MzMzAwJyxcblx0JyNDQzMzMzMnLFxuXHQnI0NDMzM2NicsXG5cdCcjQ0MzMzk5Jyxcblx0JyNDQzMzQ0MnLFxuXHQnI0NDMzNGRicsXG5cdCcjQ0M2NjAwJyxcblx0JyNDQzY2MzMnLFxuXHQnI0NDOTkwMCcsXG5cdCcjQ0M5OTMzJyxcblx0JyNDQ0NDMDAnLFxuXHQnI0NDQ0MzMycsXG5cdCcjRkYwMDAwJyxcblx0JyNGRjAwMzMnLFxuXHQnI0ZGMDA2NicsXG5cdCcjRkYwMDk5Jyxcblx0JyNGRjAwQ0MnLFxuXHQnI0ZGMDBGRicsXG5cdCcjRkYzMzAwJyxcblx0JyNGRjMzMzMnLFxuXHQnI0ZGMzM2NicsXG5cdCcjRkYzMzk5Jyxcblx0JyNGRjMzQ0MnLFxuXHQnI0ZGMzNGRicsXG5cdCcjRkY2NjAwJyxcblx0JyNGRjY2MzMnLFxuXHQnI0ZGOTkwMCcsXG5cdCcjRkY5OTMzJyxcblx0JyNGRkNDMDAnLFxuXHQnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0Ly8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuXHQvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuXHQvLyBleHBsaWNpdGx5XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG5cdC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cdHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuXHRcdC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcblx0XHQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuXHRcdC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuXHRcdC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArXG5cdFx0dGhpcy5uYW1lc3BhY2UgK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArXG5cdFx0YXJnc1swXSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICtcblx0XHQnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdGlmICghdGhpcy51c2VDb2xvcnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcblx0YXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cblx0Ly8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0Ly8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0bGV0IGluZGV4ID0gMDtcblx0bGV0IGxhc3RDID0gMDtcblx0YXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIG1hdGNoID0+IHtcblx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aW5kZXgrKztcblx0XHRpZiAobWF0Y2ggPT09ICclYycpIHtcblx0XHRcdC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuXHRcdFx0Ly8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0XHRcdGxhc3RDID0gaW5kZXg7XG5cdFx0fVxuXHR9KTtcblxuXHRhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5kZWJ1ZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqIElmIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYXZhaWxhYmxlLCBmYWxscyBiYWNrXG4gKiB0byBgY29uc29sZS5sb2dgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMubG9nID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZyB8fCAoKCkgPT4ge30pO1xuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdHRyeSB7XG5cdFx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdGxldCByO1xuXHR0cnkge1xuXHRcdHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cblxuXHQvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cdGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuXHRcdHIgPSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxuXG5cdHJldHVybiByO1xufVxuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcblx0dHJ5IHtcblx0XHQvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG5cdFx0Ly8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cblx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuXHR0cnkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcblx0fVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtID0gdm9pZCAwO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY2xhc3MgUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybSBleHRlbmRzIHN0cmVhbV8xLlRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IodG90YWwsIGNhbmNlbGxhdGlvblRva2VuLCBvblByb2dyZXNzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICAgICAgdGhpcy5jYW5jZWxsYXRpb25Ub2tlbiA9IGNhbmNlbGxhdGlvblRva2VuO1xuICAgICAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBvblByb2dyZXNzO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy50cmFuc2ZlcnJlZCA9IDA7XG4gICAgICAgIHRoaXMuZGVsdGEgPSAwO1xuICAgICAgICB0aGlzLm5leHRVcGRhdGUgPSB0aGlzLnN0YXJ0ICsgMTAwMDtcbiAgICB9XG4gICAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbGxhdGlvblRva2VuLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKFwiY2FuY2VsbGVkXCIpLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYW5zZmVycmVkICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgdGhpcy5kZWx0YSArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChub3cgPj0gdGhpcy5uZXh0VXBkYXRlICYmIHRoaXMudHJhbnNmZXJyZWQgIT09IHRoaXMudG90YWwgLyogd2lsbCBiZSBlbWl0dGVkIG9uIF9mbHVzaCAqLykge1xuICAgICAgICAgICAgdGhpcy5uZXh0VXBkYXRlID0gbm93ICsgMTAwMDtcbiAgICAgICAgICAgIHRoaXMub25Qcm9ncmVzcyh7XG4gICAgICAgICAgICAgICAgdG90YWw6IHRoaXMudG90YWwsXG4gICAgICAgICAgICAgICAgZGVsdGE6IHRoaXMuZGVsdGEsXG4gICAgICAgICAgICAgICAgdHJhbnNmZXJyZWQ6IHRoaXMudHJhbnNmZXJyZWQsXG4gICAgICAgICAgICAgICAgcGVyY2VudDogKHRoaXMudHJhbnNmZXJyZWQgLyB0aGlzLnRvdGFsKSAqIDEwMCxcbiAgICAgICAgICAgICAgICBieXRlc1BlclNlY29uZDogTWF0aC5yb3VuZCh0aGlzLnRyYW5zZmVycmVkIC8gKChub3cgLSB0aGlzLnN0YXJ0KSAvIDEwMDApKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5kZWx0YSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgY2h1bmspO1xuICAgIH1cbiAgICBfZmx1c2goY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsbGF0aW9uVG9rZW4uY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoXCJjYW5jZWxsZWRcIikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25Qcm9ncmVzcyh7XG4gICAgICAgICAgICB0b3RhbDogdGhpcy50b3RhbCxcbiAgICAgICAgICAgIGRlbHRhOiB0aGlzLmRlbHRhLFxuICAgICAgICAgICAgdHJhbnNmZXJyZWQ6IHRoaXMudG90YWwsXG4gICAgICAgICAgICBwZXJjZW50OiAxMDAsXG4gICAgICAgICAgICBieXRlc1BlclNlY29uZDogTWF0aC5yb3VuZCh0aGlzLnRyYW5zZmVycmVkIC8gKChEYXRlLm5vdygpIC0gdGhpcy5zdGFydCkgLyAxMDAwKSksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRlbHRhID0gMDtcbiAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtID0gUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVByb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNhZmVTdHJpbmdpZnlKc29uID0gZXhwb3J0cy5jb25maWd1cmVSZXF1ZXN0T3B0aW9ucyA9IGV4cG9ydHMuc2FmZUdldEhlYWRlciA9IGV4cG9ydHMuRGlnZXN0VHJhbnNmb3JtID0gZXhwb3J0cy5jb25maWd1cmVSZXF1ZXN0VXJsID0gZXhwb3J0cy5jb25maWd1cmVSZXF1ZXN0T3B0aW9uc0Zyb21VcmwgPSBleHBvcnRzLkh0dHBFeGVjdXRvciA9IGV4cG9ydHMucGFyc2VKc29uID0gZXhwb3J0cy5IdHRwRXJyb3IgPSBleHBvcnRzLmNyZWF0ZUh0dHBFcnJvciA9IHZvaWQgMDtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBmc18xID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY29uc3QgdXJsXzEgPSByZXF1aXJlKFwidXJsXCIpO1xuY29uc3QgQ2FuY2VsbGF0aW9uVG9rZW5fMSA9IHJlcXVpcmUoXCIuL0NhbmNlbGxhdGlvblRva2VuXCIpO1xuY29uc3QgaW5kZXhfMSA9IHJlcXVpcmUoXCIuL2luZGV4XCIpO1xuY29uc3QgUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybV8xID0gcmVxdWlyZShcIi4vUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybVwiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJlbGVjdHJvbi1idWlsZGVyXCIpO1xuZnVuY3Rpb24gY3JlYXRlSHR0cEVycm9yKHJlc3BvbnNlLCBkZXNjcmlwdGlvbiA9IG51bGwpIHtcbiAgICByZXR1cm4gbmV3IEh0dHBFcnJvcihyZXNwb25zZS5zdGF0dXNDb2RlIHx8IC0xLCBgJHtyZXNwb25zZS5zdGF0dXNDb2RlfSAke3Jlc3BvbnNlLnN0YXR1c01lc3NhZ2V9YCArXG4gICAgICAgIChkZXNjcmlwdGlvbiA9PSBudWxsID8gXCJcIiA6IFwiXFxuXCIgKyBKU09OLnN0cmluZ2lmeShkZXNjcmlwdGlvbiwgbnVsbCwgXCIgIFwiKSkgK1xuICAgICAgICBcIlxcbkhlYWRlcnM6IFwiICtcbiAgICAgICAgc2FmZVN0cmluZ2lmeUpzb24ocmVzcG9uc2UuaGVhZGVycyksIGRlc2NyaXB0aW9uKTtcbn1cbmV4cG9ydHMuY3JlYXRlSHR0cEVycm9yID0gY3JlYXRlSHR0cEVycm9yO1xuY29uc3QgSFRUUF9TVEFUVVNfQ09ERVMgPSBuZXcgTWFwKFtcbiAgICBbNDI5LCBcIlRvbyBtYW55IHJlcXVlc3RzXCJdLFxuICAgIFs0MDAsIFwiQmFkIHJlcXVlc3RcIl0sXG4gICAgWzQwMywgXCJGb3JiaWRkZW5cIl0sXG4gICAgWzQwNCwgXCJOb3QgZm91bmRcIl0sXG4gICAgWzQwNSwgXCJNZXRob2Qgbm90IGFsbG93ZWRcIl0sXG4gICAgWzQwNiwgXCJOb3QgYWNjZXB0YWJsZVwiXSxcbiAgICBbNDA4LCBcIlJlcXVlc3QgdGltZW91dFwiXSxcbiAgICBbNDEzLCBcIlJlcXVlc3QgZW50aXR5IHRvbyBsYXJnZVwiXSxcbiAgICBbNTAwLCBcIkludGVybmFsIHNlcnZlciBlcnJvclwiXSxcbiAgICBbNTAyLCBcIkJhZCBnYXRld2F5XCJdLFxuICAgIFs1MDMsIFwiU2VydmljZSB1bmF2YWlsYWJsZVwiXSxcbiAgICBbNTA0LCBcIkdhdGV3YXkgdGltZW91dFwiXSxcbiAgICBbNTA1LCBcIkhUVFAgdmVyc2lvbiBub3Qgc3VwcG9ydGVkXCJdLFxuXSk7XG5jbGFzcyBIdHRwRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Ioc3RhdHVzQ29kZSwgbWVzc2FnZSA9IGBIVFRQIGVycm9yOiAke0hUVFBfU1RBVFVTX0NPREVTLmdldChzdGF0dXNDb2RlKSB8fCBzdGF0dXNDb2RlfWAsIGRlc2NyaXB0aW9uID0gbnVsbCkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkh0dHBFcnJvclwiO1xuICAgICAgICB0aGlzLmNvZGUgPSBgSFRUUF9FUlJPUl8ke3N0YXR1c0NvZGV9YDtcbiAgICB9XG4gICAgaXNTZXJ2ZXJFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzQ29kZSA+PSA1MDAgJiYgdGhpcy5zdGF0dXNDb2RlIDw9IDU5OTtcbiAgICB9XG59XG5leHBvcnRzLkh0dHBFcnJvciA9IEh0dHBFcnJvcjtcbmZ1bmN0aW9uIHBhcnNlSnNvbihyZXN1bHQpIHtcbiAgICByZXR1cm4gcmVzdWx0LnRoZW4oaXQgPT4gKGl0ID09IG51bGwgfHwgaXQubGVuZ3RoID09PSAwID8gbnVsbCA6IEpTT04ucGFyc2UoaXQpKSk7XG59XG5leHBvcnRzLnBhcnNlSnNvbiA9IHBhcnNlSnNvbjtcbmNsYXNzIEh0dHBFeGVjdXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubWF4UmVkaXJlY3RzID0gMTA7XG4gICAgfVxuICAgIHJlcXVlc3Qob3B0aW9ucywgY2FuY2VsbGF0aW9uVG9rZW4gPSBuZXcgQ2FuY2VsbGF0aW9uVG9rZW5fMS5DYW5jZWxsYXRpb25Ub2tlbigpLCBkYXRhKSB7XG4gICAgICAgIGNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBqc29uID0gZGF0YSA9PSBudWxsID8gdW5kZWZpbmVkIDogSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgIGNvbnN0IGVuY29kZWREYXRhID0ganNvbiA/IEJ1ZmZlci5mcm9tKGpzb24pIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZW5jb2RlZERhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgZGVidWcoanNvbik7XG4gICAgICAgICAgICBjb25zdCB7IGhlYWRlcnMsIC4uLm9wdHMgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJwb3N0XCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LUxlbmd0aFwiOiBlbmNvZGVkRGF0YS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIC4uLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kb0FwaVJlcXVlc3Qob3B0aW9ucywgY2FuY2VsbGF0aW9uVG9rZW4sIGl0ID0+IGl0LmVuZChlbmNvZGVkRGF0YSkpO1xuICAgIH1cbiAgICBkb0FwaVJlcXVlc3Qob3B0aW9ucywgY2FuY2VsbGF0aW9uVG9rZW4sIHJlcXVlc3RQcm9jZXNzb3IsIHJlZGlyZWN0Q291bnQgPSAwKSB7XG4gICAgICAgIGlmIChkZWJ1Zy5lbmFibGVkKSB7XG4gICAgICAgICAgICBkZWJ1ZyhgUmVxdWVzdDogJHtzYWZlU3RyaW5naWZ5SnNvbihvcHRpb25zKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FuY2VsbGF0aW9uVG9rZW4uY3JlYXRlUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0LCBvbkNhbmNlbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdChvcHRpb25zLCAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlLCBvcHRpb25zLCBjYW5jZWxsYXRpb25Ub2tlbiwgcmVzb2x2ZSwgcmVqZWN0LCByZWRpcmVjdENvdW50LCByZXF1ZXN0UHJvY2Vzc29yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5hZGRFcnJvckFuZFRpbWVvdXRIYW5kbGVycyhyZXF1ZXN0LCByZWplY3QsIG9wdGlvbnMudGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLmFkZFJlZGlyZWN0SGFuZGxlcnMocmVxdWVzdCwgb3B0aW9ucywgcmVqZWN0LCByZWRpcmVjdENvdW50LCBvcHRpb25zID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQXBpUmVxdWVzdChvcHRpb25zLCBjYW5jZWxsYXRpb25Ub2tlbiwgcmVxdWVzdFByb2Nlc3NvciwgcmVkaXJlY3RDb3VudCkudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXF1ZXN0UHJvY2Vzc29yKHJlcXVlc3QsIHJlamVjdCk7XG4gICAgICAgICAgICBvbkNhbmNlbCgoKSA9PiByZXF1ZXN0LmFib3J0KCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gbm9pbnNwZWN0aW9uIEpTVW51c2VkTG9jYWxTeW1ib2xzXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgYWRkUmVkaXJlY3RIYW5kbGVycyhyZXF1ZXN0LCBvcHRpb25zLCByZWplY3QsIHJlZGlyZWN0Q291bnQsIGhhbmRsZXIpIHtcbiAgICAgICAgLy8gbm90IHJlcXVpcmVkIGZvciBOb2RlSlNcbiAgICB9XG4gICAgYWRkRXJyb3JBbmRUaW1lb3V0SGFuZGxlcnMocmVxdWVzdCwgcmVqZWN0LCB0aW1lb3V0ID0gNjAgKiAxMDAwKSB7XG4gICAgICAgIHRoaXMuYWRkVGltZU91dEhhbmRsZXIocmVxdWVzdCwgcmVqZWN0LCB0aW1lb3V0KTtcbiAgICAgICAgcmVxdWVzdC5vbihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgIHJlcXVlc3Qub24oXCJhYm9ydGVkXCIsICgpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJSZXF1ZXN0IGhhcyBiZWVuIGFib3J0ZWQgYnkgdGhlIHNlcnZlclwiKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVSZXNwb25zZShyZXNwb25zZSwgb3B0aW9ucywgY2FuY2VsbGF0aW9uVG9rZW4sIHJlc29sdmUsIHJlamVjdCwgcmVkaXJlY3RDb3VudCwgcmVxdWVzdFByb2Nlc3Nvcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChkZWJ1Zy5lbmFibGVkKSB7XG4gICAgICAgICAgICBkZWJ1ZyhgUmVzcG9uc2U6ICR7cmVzcG9uc2Uuc3RhdHVzQ29kZX0gJHtyZXNwb25zZS5zdGF0dXNNZXNzYWdlfSwgcmVxdWVzdCBvcHRpb25zOiAke3NhZmVTdHJpbmdpZnlKc29uKG9wdGlvbnMpfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIGhhbmRsZSBhbnkgb3RoZXIgPj0gNDAwIGVycm9yIG9uIHJlcXVlc3QgZW5kIChyZWFkIGRldGFpbGVkIG1lc3NhZ2UgaW4gdGhlIHJlc3BvbnNlIGJvZHkpXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MDQpIHtcbiAgICAgICAgICAgIC8vIGVycm9yIGlzIGNsZWFyLCB3ZSBkb24ndCBuZWVkIHRvIHJlYWQgZGV0YWlsZWQgZXJyb3IgZGVzY3JpcHRpb25cbiAgICAgICAgICAgIHJlamVjdChjcmVhdGVIdHRwRXJyb3IocmVzcG9uc2UsIGBtZXRob2Q6ICR7b3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIn0gdXJsOiAke29wdGlvbnMucHJvdG9jb2wgfHwgXCJodHRwczpcIn0vLyR7b3B0aW9ucy5ob3N0bmFtZX0ke29wdGlvbnMucG9ydCA/IGA6JHtvcHRpb25zLnBvcnR9YCA6IFwiXCJ9JHtvcHRpb25zLnBhdGh9XG5cblBsZWFzZSBkb3VibGUgY2hlY2sgdGhhdCB5b3VyIGF1dGhlbnRpY2F0aW9uIHRva2VuIGlzIGNvcnJlY3QuIER1ZSB0byBzZWN1cml0eSByZWFzb25zLCBhY3R1YWwgc3RhdHVzIG1heWJlIG5vdCByZXBvcnRlZCwgYnV0IDQwNC5cbmApKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSAyMDQpIHtcbiAgICAgICAgICAgIC8vIG9uIERFTEVURSByZXF1ZXN0XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZSA9IChfYSA9IHJlc3BvbnNlLnN0YXR1c0NvZGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgIGNvbnN0IHNob3VsZFJlZGlyZWN0ID0gY29kZSA+PSAzMDAgJiYgY29kZSA8IDQwMDtcbiAgICAgICAgY29uc3QgcmVkaXJlY3RVcmwgPSBzYWZlR2V0SGVhZGVyKHJlc3BvbnNlLCBcImxvY2F0aW9uXCIpO1xuICAgICAgICBpZiAoc2hvdWxkUmVkaXJlY3QgJiYgcmVkaXJlY3RVcmwgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHJlZGlyZWN0Q291bnQgPiB0aGlzLm1heFJlZGlyZWN0cykge1xuICAgICAgICAgICAgICAgIHJlamVjdCh0aGlzLmNyZWF0ZU1heFJlZGlyZWN0RXJyb3IoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kb0FwaVJlcXVlc3QoSHR0cEV4ZWN1dG9yLnByZXBhcmVSZWRpcmVjdFVybE9wdGlvbnMocmVkaXJlY3RVcmwsIG9wdGlvbnMpLCBjYW5jZWxsYXRpb25Ub2tlbiwgcmVxdWVzdFByb2Nlc3NvciwgcmVkaXJlY3RDb3VudCkudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc3BvbnNlLnNldEVuY29kaW5nKFwidXRmOFwiKTtcbiAgICAgICAgbGV0IGRhdGEgPSBcIlwiO1xuICAgICAgICByZXNwb25zZS5vbihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgIHJlc3BvbnNlLm9uKFwiZGF0YVwiLCAoY2h1bmspID0+IChkYXRhICs9IGNodW5rKSk7XG4gICAgICAgIHJlc3BvbnNlLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgIT0gbnVsbCAmJiByZXNwb25zZS5zdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHNhZmVHZXRIZWFkZXIocmVzcG9uc2UsIFwiY29udGVudC10eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0pzb24gPSBjb250ZW50VHlwZSAhPSBudWxsICYmIChBcnJheS5pc0FycmF5KGNvbnRlbnRUeXBlKSA/IGNvbnRlbnRUeXBlLmZpbmQoaXQgPT4gaXQuaW5jbHVkZXMoXCJqc29uXCIpKSAhPSBudWxsIDogY29udGVudFR5cGUuaW5jbHVkZXMoXCJqc29uXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGNyZWF0ZUh0dHBFcnJvcihyZXNwb25zZSwgYG1ldGhvZDogJHtvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwifSB1cmw6ICR7b3B0aW9ucy5wcm90b2NvbCB8fCBcImh0dHBzOlwifS8vJHtvcHRpb25zLmhvc3RuYW1lfSR7b3B0aW9ucy5wb3J0ID8gYDoke29wdGlvbnMucG9ydH1gIDogXCJcIn0ke29wdGlvbnMucGF0aH1cblxuICAgICAgICAgIERhdGE6XG4gICAgICAgICAgJHtpc0pzb24gPyBKU09OLnN0cmluZ2lmeShKU09OLnBhcnNlKGRhdGEpKSA6IGRhdGF9XG4gICAgICAgICAgYCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGRvd25sb2FkVG9CdWZmZXIodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBvcHRpb25zLmNhbmNlbGxhdGlvblRva2VuLmNyZWF0ZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCwgb25DYW5jZWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQ2h1bmtzID0gW107XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnMgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgUHJpdmF0ZUdpdEh1YlByb3ZpZGVyIHJlcXVpcmVzIEh0dHBFeGVjdXRvci5wcmVwYXJlUmVkaXJlY3RVcmxPcHRpb25zIGxvZ2ljLCBzbywgd2UgbmVlZCB0byByZWRpcmVjdCBtYW51YWxseVxuICAgICAgICAgICAgICAgIHJlZGlyZWN0OiBcIm1hbnVhbFwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbmZpZ3VyZVJlcXVlc3RVcmwodXJsLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgICAgICBjb25maWd1cmVSZXF1ZXN0T3B0aW9ucyhyZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmRvRG93bmxvYWQocmVxdWVzdE9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgIG9uQ2FuY2VsLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKEJ1ZmZlci5jb25jYXQocmVzcG9uc2VDaHVua3MpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlSGFuZGxlcjogKHJlc3BvbnNlLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjZWl2ZWRMZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5vbihcImRhdGFcIiwgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlZExlbmd0aCArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWl2ZWRMZW5ndGggPiA1MjQyODgwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoXCJNYXhpbXVtIGFsbG93ZWQgc2l6ZSBpcyA1MDAgTUJcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlQ2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRvRG93bmxvYWQocmVxdWVzdE9wdGlvbnMsIG9wdGlvbnMsIHJlZGlyZWN0Q291bnQpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdChyZXF1ZXN0T3B0aW9ucywgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKG5ldyBFcnJvcihgQ2Fubm90IGRvd25sb2FkIFwiJHtyZXF1ZXN0T3B0aW9ucy5wcm90b2NvbCB8fCBcImh0dHBzOlwifS8vJHtyZXF1ZXN0T3B0aW9ucy5ob3N0bmFtZX0ke3JlcXVlc3RPcHRpb25zLnBhdGh9XCIsIHN0YXR1cyAke3Jlc3BvbnNlLnN0YXR1c0NvZGV9OiAke3Jlc3BvbnNlLnN0YXR1c01lc3NhZ2V9YCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEl0IGlzIHBvc3NpYmxlIGZvciB0aGUgcmVzcG9uc2Ugc3RyZWFtIHRvIGZhaWwsIGUuZy4gd2hlbiBhIG5ldHdvcmsgaXMgbG9zdCB3aGlsZVxuICAgICAgICAgICAgLy8gcmVzcG9uc2Ugc3RyZWFtIGlzIGluIHByb2dyZXNzLiBTdG9wIHdhaXRpbmcgYW5kIHJlamVjdCBzbyBjb25zdW1lciBjYW4gY2F0Y2ggdGhlIGVycm9yLlxuICAgICAgICAgICAgcmVzcG9uc2Uub24oXCJlcnJvclwiLCBvcHRpb25zLmNhbGxiYWNrKTtcbiAgICAgICAgICAgIC8vIHRoaXMgY29kZSBub3QgcmVsZXZhbnQgZm9yIEVsZWN0cm9uIChyZWRpcmVjdCBldmVudCBpbnN0ZWFkIGhhbmRsZWQpXG4gICAgICAgICAgICBjb25zdCByZWRpcmVjdFVybCA9IHNhZmVHZXRIZWFkZXIocmVzcG9uc2UsIFwibG9jYXRpb25cIik7XG4gICAgICAgICAgICBpZiAocmVkaXJlY3RVcmwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChyZWRpcmVjdENvdW50IDwgdGhpcy5tYXhSZWRpcmVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb0Rvd25sb2FkKEh0dHBFeGVjdXRvci5wcmVwYXJlUmVkaXJlY3RVcmxPcHRpb25zKHJlZGlyZWN0VXJsLCByZXF1ZXN0T3B0aW9ucyksIG9wdGlvbnMsIHJlZGlyZWN0Q291bnQrKyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKHRoaXMuY3JlYXRlTWF4UmVkaXJlY3RFcnJvcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVzcG9uc2VIYW5kbGVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmVQaXBlcyhvcHRpb25zLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnJlc3BvbnNlSGFuZGxlcihyZXNwb25zZSwgb3B0aW9ucy5jYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFkZEVycm9yQW5kVGltZW91dEhhbmRsZXJzKHJlcXVlc3QsIG9wdGlvbnMuY2FsbGJhY2ssIHJlcXVlc3RPcHRpb25zLnRpbWVvdXQpO1xuICAgICAgICB0aGlzLmFkZFJlZGlyZWN0SGFuZGxlcnMocmVxdWVzdCwgcmVxdWVzdE9wdGlvbnMsIG9wdGlvbnMuY2FsbGJhY2ssIHJlZGlyZWN0Q291bnQsIHJlcXVlc3RPcHRpb25zID0+IHtcbiAgICAgICAgICAgIHRoaXMuZG9Eb3dubG9hZChyZXF1ZXN0T3B0aW9ucywgb3B0aW9ucywgcmVkaXJlY3RDb3VudCsrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcXVlc3QuZW5kKCk7XG4gICAgfVxuICAgIGNyZWF0ZU1heFJlZGlyZWN0RXJyb3IoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoYFRvbyBtYW55IHJlZGlyZWN0cyAoPiAke3RoaXMubWF4UmVkaXJlY3RzfSlgKTtcbiAgICB9XG4gICAgYWRkVGltZU91dEhhbmRsZXIocmVxdWVzdCwgY2FsbGJhY2ssIHRpbWVvdXQpIHtcbiAgICAgICAgcmVxdWVzdC5vbihcInNvY2tldFwiLCAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICBzb2NrZXQuc2V0VGltZW91dCh0aW1lb3V0LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihcIlJlcXVlc3QgdGltZWQgb3V0XCIpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIHByZXBhcmVSZWRpcmVjdFVybE9wdGlvbnMocmVkaXJlY3RVcmwsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbmV3T3B0aW9ucyA9IGNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zRnJvbVVybChyZWRpcmVjdFVybCwgeyAuLi5vcHRpb25zIH0pO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gbmV3T3B0aW9ucy5oZWFkZXJzO1xuICAgICAgICBpZiAoaGVhZGVycyA9PT0gbnVsbCB8fCBoZWFkZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBoZWFkZXJzLmF1dGhvcml6YXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZE5ld1VybCA9IG5ldyB1cmxfMS5VUkwocmVkaXJlY3RVcmwpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZE5ld1VybC5ob3N0bmFtZS5lbmRzV2l0aChcIi5hbWF6b25hd3MuY29tXCIpIHx8IHBhcnNlZE5ld1VybC5zZWFyY2hQYXJhbXMuaGFzKFwiWC1BbXotQ3JlZGVudGlhbFwiKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBoZWFkZXJzLmF1dGhvcml6YXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld09wdGlvbnM7XG4gICAgfVxuICAgIHN0YXRpYyByZXRyeU9uU2VydmVyRXJyb3IodGFzaywgbWF4UmV0cmllcyA9IDMpIHtcbiAgICAgICAgZm9yIChsZXQgYXR0ZW1wdE51bWJlciA9IDA7OyBhdHRlbXB0TnVtYmVyKyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhc2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dGVtcHROdW1iZXIgPCBtYXhSZXRyaWVzICYmICgoZSBpbnN0YW5jZW9mIEh0dHBFcnJvciAmJiBlLmlzU2VydmVyRXJyb3IoKSkgfHwgZS5jb2RlID09PSBcIkVQSVBFXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5IdHRwRXhlY3V0b3IgPSBIdHRwRXhlY3V0b3I7XG5mdW5jdGlvbiBjb25maWd1cmVSZXF1ZXN0T3B0aW9uc0Zyb21VcmwodXJsLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gY29uZmlndXJlUmVxdWVzdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uZmlndXJlUmVxdWVzdFVybChuZXcgdXJsXzEuVVJMKHVybCksIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuY29uZmlndXJlUmVxdWVzdE9wdGlvbnNGcm9tVXJsID0gY29uZmlndXJlUmVxdWVzdE9wdGlvbnNGcm9tVXJsO1xuZnVuY3Rpb24gY29uZmlndXJlUmVxdWVzdFVybCh1cmwsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLnByb3RvY29sID0gdXJsLnByb3RvY29sO1xuICAgIG9wdGlvbnMuaG9zdG5hbWUgPSB1cmwuaG9zdG5hbWU7XG4gICAgaWYgKHVybC5wb3J0KSB7XG4gICAgICAgIG9wdGlvbnMucG9ydCA9IHVybC5wb3J0O1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zLnBvcnQpIHtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMucG9ydDtcbiAgICB9XG4gICAgb3B0aW9ucy5wYXRoID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbn1cbmV4cG9ydHMuY29uZmlndXJlUmVxdWVzdFVybCA9IGNvbmZpZ3VyZVJlcXVlc3RVcmw7XG5jbGFzcyBEaWdlc3RUcmFuc2Zvcm0gZXh0ZW5kcyBzdHJlYW1fMS5UcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKGV4cGVjdGVkLCBhbGdvcml0aG0gPSBcInNoYTUxMlwiLCBlbmNvZGluZyA9IFwiYmFzZTY0XCIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICAgICAgICB0aGlzLmFsZ29yaXRobSA9IGFsZ29yaXRobTtcbiAgICAgICAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgICAgICB0aGlzLl9hY3R1YWwgPSBudWxsO1xuICAgICAgICB0aGlzLmlzVmFsaWRhdGVPbkVuZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlnZXN0ZXIgPSAoMCwgY3J5cHRvXzEuY3JlYXRlSGFzaCkoYWxnb3JpdGhtKTtcbiAgICB9XG4gICAgLy8gbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xuICAgIGdldCBhY3R1YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3R1YWw7XG4gICAgfVxuICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5kaWdlc3Rlci51cGRhdGUoY2h1bmspO1xuICAgICAgICBjYWxsYmFjayhudWxsLCBjaHVuayk7XG4gICAgfVxuICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcbiAgICBfZmx1c2goY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fYWN0dWFsID0gdGhpcy5kaWdlc3Rlci5kaWdlc3QodGhpcy5lbmNvZGluZyk7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWRhdGVPbkVuZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9XG4gICAgdmFsaWRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hY3R1YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIGluZGV4XzEubmV3RXJyb3IpKFwiTm90IGZpbmlzaGVkIHlldFwiLCBcIkVSUl9TVFJFQU1fTk9UX0ZJTklTSEVEXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9hY3R1YWwgIT09IHRoaXMuZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCBpbmRleF8xLm5ld0Vycm9yKShgJHt0aGlzLmFsZ29yaXRobX0gY2hlY2tzdW0gbWlzbWF0Y2gsIGV4cGVjdGVkICR7dGhpcy5leHBlY3RlZH0sIGdvdCAke3RoaXMuX2FjdHVhbH1gLCBcIkVSUl9DSEVDS1NVTV9NSVNNQVRDSFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkRpZ2VzdFRyYW5zZm9ybSA9IERpZ2VzdFRyYW5zZm9ybTtcbmZ1bmN0aW9uIGNoZWNrU2hhMihzaGEySGVhZGVyLCBzaGEyLCBjYWxsYmFjaykge1xuICAgIGlmIChzaGEySGVhZGVyICE9IG51bGwgJiYgc2hhMiAhPSBudWxsICYmIHNoYTJIZWFkZXIgIT09IHNoYTIpIHtcbiAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKGBjaGVja3N1bSBtaXNtYXRjaDogZXhwZWN0ZWQgJHtzaGEyfSBidXQgZ290ICR7c2hhMkhlYWRlcn0gKFgtQ2hlY2tzdW0tU2hhMiBoZWFkZXIpYCkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc2FmZUdldEhlYWRlcihyZXNwb25zZSwgaGVhZGVyS2V5KSB7XG4gICAgY29uc3QgdmFsdWUgPSByZXNwb25zZS5oZWFkZXJzW2hlYWRlcktleV07XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIC8vIGVsZWN0cm9uIEFQSVxuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID09PSAwID8gbnVsbCA6IHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydHMuc2FmZUdldEhlYWRlciA9IHNhZmVHZXRIZWFkZXI7XG5mdW5jdGlvbiBjb25maWd1cmVQaXBlcyhvcHRpb25zLCByZXNwb25zZSkge1xuICAgIGlmICghY2hlY2tTaGEyKHNhZmVHZXRIZWFkZXIocmVzcG9uc2UsIFwiWC1DaGVja3N1bS1TaGEyXCIpLCBvcHRpb25zLm9wdGlvbnMuc2hhMiwgb3B0aW9ucy5jYWxsYmFjaykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdHJlYW1zID0gW107XG4gICAgaWYgKG9wdGlvbnMub3B0aW9ucy5vblByb2dyZXNzICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IHNhZmVHZXRIZWFkZXIocmVzcG9uc2UsIFwiY29udGVudC1sZW5ndGhcIik7XG4gICAgICAgIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN0cmVhbXMucHVzaChuZXcgUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybV8xLlByb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0ocGFyc2VJbnQoY29udGVudExlbmd0aCwgMTApLCBvcHRpb25zLm9wdGlvbnMuY2FuY2VsbGF0aW9uVG9rZW4sIG9wdGlvbnMub3B0aW9ucy5vblByb2dyZXNzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc2hhNTEyID0gb3B0aW9ucy5vcHRpb25zLnNoYTUxMjtcbiAgICBpZiAoc2hhNTEyICE9IG51bGwpIHtcbiAgICAgICAgc3RyZWFtcy5wdXNoKG5ldyBEaWdlc3RUcmFuc2Zvcm0oc2hhNTEyLCBcInNoYTUxMlwiLCBzaGE1MTIubGVuZ3RoID09PSAxMjggJiYgIXNoYTUxMi5pbmNsdWRlcyhcIitcIikgJiYgIXNoYTUxMi5pbmNsdWRlcyhcIlpcIikgJiYgIXNoYTUxMi5pbmNsdWRlcyhcIj1cIikgPyBcImhleFwiIDogXCJiYXNlNjRcIikpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zLm9wdGlvbnMuc2hhMiAhPSBudWxsKSB7XG4gICAgICAgIHN0cmVhbXMucHVzaChuZXcgRGlnZXN0VHJhbnNmb3JtKG9wdGlvbnMub3B0aW9ucy5zaGEyLCBcInNoYTI1NlwiLCBcImhleFwiKSk7XG4gICAgfVxuICAgIGNvbnN0IGZpbGVPdXQgPSAoMCwgZnNfMS5jcmVhdGVXcml0ZVN0cmVhbSkob3B0aW9ucy5kZXN0aW5hdGlvbik7XG4gICAgc3RyZWFtcy5wdXNoKGZpbGVPdXQpO1xuICAgIGxldCBsYXN0U3RyZWFtID0gcmVzcG9uc2U7XG4gICAgZm9yIChjb25zdCBzdHJlYW0gb2Ygc3RyZWFtcykge1xuICAgICAgICBzdHJlYW0ub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGZpbGVPdXQuY2xvc2UoKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5vcHRpb25zLmNhbmNlbGxhdGlvblRva2VuLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbGFzdFN0cmVhbSA9IGxhc3RTdHJlYW0ucGlwZShzdHJlYW0pO1xuICAgIH1cbiAgICBmaWxlT3V0Lm9uKFwiZmluaXNoXCIsICgpID0+IHtcbiAgICAgICAgO1xuICAgICAgICBmaWxlT3V0LmNsb3NlKG9wdGlvbnMuY2FsbGJhY2spO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY29uZmlndXJlUmVxdWVzdE9wdGlvbnMob3B0aW9ucywgdG9rZW4sIG1ldGhvZCkge1xuICAgIGlmIChtZXRob2QgIT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLm1ldGhvZCA9IG1ldGhvZDtcbiAgICB9XG4gICAgb3B0aW9ucy5oZWFkZXJzID0geyAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICBjb25zdCBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzO1xuICAgIGlmICh0b2tlbiAhPSBudWxsKSB7XG4gICAgICAgIDtcbiAgICAgICAgaGVhZGVycy5hdXRob3JpemF0aW9uID0gdG9rZW4uc3RhcnRzV2l0aChcIkJhc2ljXCIpIHx8IHRva2VuLnN0YXJ0c1dpdGgoXCJCZWFyZXJcIikgPyB0b2tlbiA6IGB0b2tlbiAke3Rva2VufWA7XG4gICAgfVxuICAgIGlmIChoZWFkZXJzW1wiVXNlci1BZ2VudFwiXSA9PSBudWxsKSB7XG4gICAgICAgIGhlYWRlcnNbXCJVc2VyLUFnZW50XCJdID0gXCJlbGVjdHJvbi1idWlsZGVyXCI7XG4gICAgfVxuICAgIGlmIChtZXRob2QgPT0gbnVsbCB8fCBtZXRob2QgPT09IFwiR0VUXCIgfHwgaGVhZGVyc1tcIkNhY2hlLUNvbnRyb2xcIl0gPT0gbnVsbCkge1xuICAgICAgICBoZWFkZXJzW1wiQ2FjaGUtQ29udHJvbFwiXSA9IFwibm8tY2FjaGVcIjtcbiAgICB9XG4gICAgLy8gZG8gbm90IHNwZWNpZnkgZm9yIG5vZGUgKGluIGFueSBjYXNlIHdlIHVzZSBodHRwcyBtb2R1bGUpXG4gICAgaWYgKG9wdGlvbnMucHJvdG9jb2wgPT0gbnVsbCAmJiBwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uICE9IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucy5wcm90b2NvbCA9IFwiaHR0cHM6XCI7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZXhwb3J0cy5jb25maWd1cmVSZXF1ZXN0T3B0aW9ucyA9IGNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zO1xuZnVuY3Rpb24gc2FmZVN0cmluZ2lmeUpzb24oZGF0YSwgc2tpcHBlZE5hbWVzKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEsIChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAobmFtZS5lbmRzV2l0aChcIkF1dGhvcml6YXRpb25cIikgfHxcbiAgICAgICAgICAgIG5hbWUuZW5kc1dpdGgoXCJhdXRob3JpemF0aW9uXCIpIHx8XG4gICAgICAgICAgICBuYW1lLmVuZHNXaXRoKFwiUGFzc3dvcmRcIikgfHxcbiAgICAgICAgICAgIG5hbWUuZW5kc1dpdGgoXCJQQVNTV09SRFwiKSB8fFxuICAgICAgICAgICAgbmFtZS5lbmRzV2l0aChcIlRva2VuXCIpIHx8XG4gICAgICAgICAgICBuYW1lLmluY2x1ZGVzKFwicGFzc3dvcmRcIikgfHxcbiAgICAgICAgICAgIG5hbWUuaW5jbHVkZXMoXCJ0b2tlblwiKSB8fFxuICAgICAgICAgICAgKHNraXBwZWROYW1lcyAhPSBudWxsICYmIHNraXBwZWROYW1lcy5oYXMobmFtZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCI8c3RyaXBwZWQgc2Vuc2l0aXZlIGRhdGE+XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sIDIpO1xufVxuZXhwb3J0cy5zYWZlU3RyaW5naWZ5SnNvbiA9IHNhZmVTdHJpbmdpZnlKc29uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHR0cEV4ZWN1dG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRTM0xpa2VQcm92aWRlckJhc2VVcmwgPSBleHBvcnRzLmdpdGh1YlVybCA9IHZvaWQgMDtcbi8qKiBAcHJpdmF0ZSAqL1xuZnVuY3Rpb24gZ2l0aHViVXJsKG9wdGlvbnMsIGRlZmF1bHRIb3N0ID0gXCJnaXRodWIuY29tXCIpIHtcbiAgICByZXR1cm4gYCR7b3B0aW9ucy5wcm90b2NvbCB8fCBcImh0dHBzXCJ9Oi8vJHtvcHRpb25zLmhvc3QgfHwgZGVmYXVsdEhvc3R9YDtcbn1cbmV4cG9ydHMuZ2l0aHViVXJsID0gZ2l0aHViVXJsO1xuZnVuY3Rpb24gZ2V0UzNMaWtlUHJvdmlkZXJCYXNlVXJsKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBwcm92aWRlciA9IGNvbmZpZ3VyYXRpb24ucHJvdmlkZXI7XG4gICAgaWYgKHByb3ZpZGVyID09PSBcInMzXCIpIHtcbiAgICAgICAgcmV0dXJuIHMzVXJsKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbiAgICBpZiAocHJvdmlkZXIgPT09IFwic3BhY2VzXCIpIHtcbiAgICAgICAgcmV0dXJuIHNwYWNlc1VybChjb25maWd1cmF0aW9uKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOb3Qgc3VwcG9ydGVkIHByb3ZpZGVyOiAke3Byb3ZpZGVyfWApO1xufVxuZXhwb3J0cy5nZXRTM0xpa2VQcm92aWRlckJhc2VVcmwgPSBnZXRTM0xpa2VQcm92aWRlckJhc2VVcmw7XG5mdW5jdGlvbiBzM1VybChvcHRpb25zKSB7XG4gICAgbGV0IHVybDtcbiAgICBpZiAob3B0aW9ucy5hY2NlbGVyYXRlID09IHRydWUpIHtcbiAgICAgICAgdXJsID0gYGh0dHBzOi8vJHtvcHRpb25zLmJ1Y2tldH0uczMtYWNjZWxlcmF0ZS5hbWF6b25hd3MuY29tYDtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5lbmRwb2ludCAhPSBudWxsKSB7XG4gICAgICAgIHVybCA9IGAke29wdGlvbnMuZW5kcG9pbnR9LyR7b3B0aW9ucy5idWNrZXR9YDtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5idWNrZXQuaW5jbHVkZXMoXCIuXCIpKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnJlZ2lvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJ1Y2tldCBuYW1lIFwiJHtvcHRpb25zLmJ1Y2tldH1cIiBpbmNsdWRlcyBhIGRvdCwgYnV0IFMzIHJlZ2lvbiBpcyBtaXNzaW5nYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlLCBzZWUgaHR0cDovL2RvY3MuYXdzLmFtYXpvbi5jb20vQW1hem9uUzMvbGF0ZXN0L2Rldi9Vc2luZ0J1Y2tldC5odG1sI2FjY2Vzcy1idWNrZXQtaW50cm9cbiAgICAgICAgaWYgKG9wdGlvbnMucmVnaW9uID09PSBcInVzLWVhc3QtMVwiKSB7XG4gICAgICAgICAgICB1cmwgPSBgaHR0cHM6Ly9zMy5hbWF6b25hd3MuY29tLyR7b3B0aW9ucy5idWNrZXR9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVybCA9IGBodHRwczovL3MzLSR7b3B0aW9ucy5yZWdpb259LmFtYXpvbmF3cy5jb20vJHtvcHRpb25zLmJ1Y2tldH1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMucmVnaW9uID09PSBcImNuLW5vcnRoLTFcIikge1xuICAgICAgICB1cmwgPSBgaHR0cHM6Ly8ke29wdGlvbnMuYnVja2V0fS5zMy4ke29wdGlvbnMucmVnaW9ufS5hbWF6b25hd3MuY29tLmNuYDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVybCA9IGBodHRwczovLyR7b3B0aW9ucy5idWNrZXR9LnMzLmFtYXpvbmF3cy5jb21gO1xuICAgIH1cbiAgICByZXR1cm4gYXBwZW5kUGF0aCh1cmwsIG9wdGlvbnMucGF0aCk7XG59XG5mdW5jdGlvbiBhcHBlbmRQYXRoKHVybCwgcCkge1xuICAgIGlmIChwICE9IG51bGwgJiYgcC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICghcC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgICAgdXJsICs9IFwiL1wiO1xuICAgICAgICB9XG4gICAgICAgIHVybCArPSBwO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xufVxuZnVuY3Rpb24gc3BhY2VzVXJsKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5uYW1lID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBuYW1lIGlzIG1pc3NpbmdgKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucmVnaW9uID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZWdpb24gaXMgbWlzc2luZ2ApO1xuICAgIH1cbiAgICByZXR1cm4gYXBwZW5kUGF0aChgaHR0cHM6Ly8ke29wdGlvbnMubmFtZX0uJHtvcHRpb25zLnJlZ2lvbn0uZGlnaXRhbG9jZWFuc3BhY2VzLmNvbWAsIG9wdGlvbnMucGF0aCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdWJsaXNoT3B0aW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VEbiA9IHZvaWQgMDtcbmZ1bmN0aW9uIHBhcnNlRG4oc2VxKSB7XG4gICAgbGV0IHF1b3RlZCA9IGZhbHNlO1xuICAgIGxldCBrZXkgPSBudWxsO1xuICAgIGxldCB0b2tlbiA9IFwiXCI7XG4gICAgbGV0IG5leHROb25TcGFjZSA9IDA7XG4gICAgc2VxID0gc2VxLnRyaW0oKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gc2VxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpID09PSBzZXEubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChrZXksIHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoID0gc2VxW2ldO1xuICAgICAgICBpZiAocXVvdGVkKSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICBxdW90ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgIHF1b3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2ggPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yZCA9IHBhcnNlSW50KHNlcS5zbGljZShpLCBpICsgMiksIDE2KTtcbiAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKG9yZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gKz0gc2VxW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG9yZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleSA9PT0gbnVsbCAmJiBjaCA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IFwiXCI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2ggPT09IFwiLFwiIHx8IGNoID09PSBcIjtcIiB8fCBjaCA9PT0gXCIrXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCB0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGtleSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBcIlwiO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gXCIgXCIgJiYgIXF1b3RlZCkge1xuICAgICAgICAgICAgaWYgKHRva2VuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPiBuZXh0Tm9uU3BhY2UpIHtcbiAgICAgICAgICAgICAgICBsZXQgaiA9IGk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNlcVtqXSA9PT0gXCIgXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0Tm9uU3BhY2UgPSBqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHROb25TcGFjZSA+PSBzZXEubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgc2VxW25leHROb25TcGFjZV0gPT09IFwiLFwiIHx8XG4gICAgICAgICAgICAgICAgc2VxW25leHROb25TcGFjZV0gPT09IFwiO1wiIHx8XG4gICAgICAgICAgICAgICAgKGtleSA9PT0gbnVsbCAmJiBzZXFbbmV4dE5vblNwYWNlXSA9PT0gXCI9XCIpIHx8XG4gICAgICAgICAgICAgICAgKGtleSAhPT0gbnVsbCAmJiBzZXFbbmV4dE5vblNwYWNlXSA9PT0gXCIrXCIpKSB7XG4gICAgICAgICAgICAgICAgaSA9IG5leHROb25TcGFjZSAtIDE7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW4gKz0gY2g7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnBhcnNlRG4gPSBwYXJzZURuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmZjMjI1M1BhcnNlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubmlsID0gZXhwb3J0cy5VVUlEID0gdm9pZCAwO1xuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xuY29uc3QgaW5kZXhfMSA9IHJlcXVpcmUoXCIuL2luZGV4XCIpO1xuY29uc3QgaW52YWxpZE5hbWUgPSBcIm9wdGlvbnMubmFtZSBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBhIEJ1ZmZlclwiO1xuLy8gTm9kZSBJRCBhY2NvcmRpbmcgdG8gcmZjNDEyMiNzZWN0aW9uLTQuNVxuY29uc3QgcmFuZG9tSG9zdCA9ICgwLCBjcnlwdG9fMS5yYW5kb21CeXRlcykoMTYpO1xucmFuZG9tSG9zdFswXSA9IHJhbmRvbUhvc3RbMF0gfCAweDAxO1xuLy8gbG9va3VwIHRhYmxlIGhleCB0byBieXRlXG5jb25zdCBoZXgyYnl0ZSA9IHt9O1xuLy8gbG9va3VwIHRhYmxlIGJ5dGUgdG8gaGV4XG5jb25zdCBieXRlMmhleCA9IFtdO1xuLy8gcG9wdWxhdGUgbG9va3VwIHRhYmxlc1xuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgIGNvbnN0IGhleCA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG4gICAgaGV4MmJ5dGVbaGV4XSA9IGk7XG4gICAgYnl0ZTJoZXhbaV0gPSBoZXg7XG59XG4vLyBVVUlEIGNsYXNzXG5jbGFzcyBVVUlEIHtcbiAgICBjb25zdHJ1Y3Rvcih1dWlkKSB7XG4gICAgICAgIHRoaXMuYXNjaWkgPSBudWxsO1xuICAgICAgICB0aGlzLmJpbmFyeSA9IG51bGw7XG4gICAgICAgIGNvbnN0IGNoZWNrID0gVVVJRC5jaGVjayh1dWlkKTtcbiAgICAgICAgaWYgKCFjaGVjaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGEgVVVJRFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZlcnNpb24gPSBjaGVjay52ZXJzaW9uO1xuICAgICAgICBpZiAoY2hlY2suZm9ybWF0ID09PSBcImFzY2lpXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYXNjaWkgPSB1dWlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iaW5hcnkgPSB1dWlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyB2NShuYW1lLCBuYW1lc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuIHV1aWROYW1lZChuYW1lLCBcInNoYTFcIiwgMHg1MCwgbmFtZXNwYWNlKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLmFzY2lpID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYXNjaWkgPSBzdHJpbmdpZnkodGhpcy5iaW5hcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFzY2lpO1xuICAgIH1cbiAgICBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4gYFVVSUQgdiR7dGhpcy52ZXJzaW9ufSAke3RoaXMudG9TdHJpbmcoKX1gO1xuICAgIH1cbiAgICBzdGF0aWMgY2hlY2sodXVpZCwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBpZiAodHlwZW9mIHV1aWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHV1aWQgPSB1dWlkLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoIS9eW2EtZjAtOV17OH0oLVthLWYwLTldezR9KXszfS0oW2EtZjAtOV17MTJ9KSQvLnRlc3QodXVpZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXVpZCA9PT0gXCIwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDBcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZlcnNpb246IHVuZGVmaW5lZCwgdmFyaWFudDogXCJuaWxcIiwgZm9ybWF0OiBcImFzY2lpXCIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogKGhleDJieXRlW3V1aWRbMTRdICsgdXVpZFsxNV1dICYgMHhmMCkgPj4gNCxcbiAgICAgICAgICAgICAgICB2YXJpYW50OiBnZXRWYXJpYW50KChoZXgyYnl0ZVt1dWlkWzE5XSArIHV1aWRbMjBdXSAmIDB4ZTApID4+IDUpLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJhc2NpaVwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHV1aWQpKSB7XG4gICAgICAgICAgICBpZiAodXVpZC5sZW5ndGggPCBvZmZzZXQgKyAxNikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh1dWlkW29mZnNldCArIGldICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID09PSAxNikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZlcnNpb246IHVuZGVmaW5lZCwgdmFyaWFudDogXCJuaWxcIiwgZm9ybWF0OiBcImJpbmFyeVwiIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZlcnNpb246ICh1dWlkW29mZnNldCArIDZdICYgMHhmMCkgPj4gNCxcbiAgICAgICAgICAgICAgICB2YXJpYW50OiBnZXRWYXJpYW50KCh1dWlkW29mZnNldCArIDhdICYgMHhlMCkgPj4gNSksXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImJpbmFyeVwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyAoMCwgaW5kZXhfMS5uZXdFcnJvcikoXCJVbmtub3duIHR5cGUgb2YgdXVpZFwiLCBcIkVSUl9VTktOT1dOX1VVSURfVFlQRVwiKTtcbiAgICB9XG4gICAgLy8gcmVhZCBzdHJpbmdpZmllZCB1dWlkIGludG8gYSBCdWZmZXJcbiAgICBzdGF0aWMgcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDE2KTtcbiAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IGhleDJieXRlW2lucHV0W2orK10gKyBpbnB1dFtqKytdXTtcbiAgICAgICAgICAgIGlmIChpID09PSAzIHx8IGkgPT09IDUgfHwgaSA9PT0gNyB8fCBpID09PSA5KSB7XG4gICAgICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxufVxuZXhwb3J0cy5VVUlEID0gVVVJRDtcbi8vIGZyb20gcmZjNDEyMiNhcHBlbmRpeC1DXG5VVUlELk9JRCA9IFVVSUQucGFyc2UoXCI2YmE3YjgxMi05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzhcIik7XG4vLyBhY2NvcmRpbmcgdG8gcmZjNDEyMiNzZWN0aW9uLTQuMS4xXG5mdW5jdGlvbiBnZXRWYXJpYW50KGJpdHMpIHtcbiAgICBzd2l0Y2ggKGJpdHMpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBcIm5jc1wiO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBcInJmYzQxMjJcIjtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmV0dXJuIFwibWljcm9zb2Z0XCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJmdXR1cmVcIjtcbiAgICB9XG59XG52YXIgVXVpZEVuY29kaW5nO1xuKGZ1bmN0aW9uIChVdWlkRW5jb2RpbmcpIHtcbiAgICBVdWlkRW5jb2RpbmdbVXVpZEVuY29kaW5nW1wiQVNDSUlcIl0gPSAwXSA9IFwiQVNDSUlcIjtcbiAgICBVdWlkRW5jb2RpbmdbVXVpZEVuY29kaW5nW1wiQklOQVJZXCJdID0gMV0gPSBcIkJJTkFSWVwiO1xuICAgIFV1aWRFbmNvZGluZ1tVdWlkRW5jb2RpbmdbXCJPQkpFQ1RcIl0gPSAyXSA9IFwiT0JKRUNUXCI7XG59KShVdWlkRW5jb2RpbmcgfHwgKFV1aWRFbmNvZGluZyA9IHt9KSk7XG4vLyB2MyArIHY1XG5mdW5jdGlvbiB1dWlkTmFtZWQobmFtZSwgaGFzaE1ldGhvZCwgdmVyc2lvbiwgbmFtZXNwYWNlLCBlbmNvZGluZyA9IFV1aWRFbmNvZGluZy5BU0NJSSkge1xuICAgIGNvbnN0IGhhc2ggPSAoMCwgY3J5cHRvXzEuY3JlYXRlSGFzaCkoaGFzaE1ldGhvZCk7XG4gICAgY29uc3QgbmFtZUlzTm90QVN0cmluZyA9IHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiO1xuICAgIGlmIChuYW1lSXNOb3RBU3RyaW5nICYmICFCdWZmZXIuaXNCdWZmZXIobmFtZSkpIHtcbiAgICAgICAgdGhyb3cgKDAsIGluZGV4XzEubmV3RXJyb3IpKGludmFsaWROYW1lLCBcIkVSUl9JTlZBTElEX1VVSURfTkFNRVwiKTtcbiAgICB9XG4gICAgaGFzaC51cGRhdGUobmFtZXNwYWNlKTtcbiAgICBoYXNoLnVwZGF0ZShuYW1lKTtcbiAgICBjb25zdCBidWZmZXIgPSBoYXNoLmRpZ2VzdCgpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgICBjYXNlIFV1aWRFbmNvZGluZy5CSU5BUlk6XG4gICAgICAgICAgICBidWZmZXJbNl0gPSAoYnVmZmVyWzZdICYgMHgwZikgfCB2ZXJzaW9uO1xuICAgICAgICAgICAgYnVmZmVyWzhdID0gKGJ1ZmZlcls4XSAmIDB4M2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHJlc3VsdCA9IGJ1ZmZlcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFV1aWRFbmNvZGluZy5PQkpFQ1Q6XG4gICAgICAgICAgICBidWZmZXJbNl0gPSAoYnVmZmVyWzZdICYgMHgwZikgfCB2ZXJzaW9uO1xuICAgICAgICAgICAgYnVmZmVyWzhdID0gKGJ1ZmZlcls4XSAmIDB4M2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBVVUlEKGJ1ZmZlcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzBdXSArXG4gICAgICAgICAgICAgICAgICAgIGJ5dGUyaGV4W2J1ZmZlclsxXV0gK1xuICAgICAgICAgICAgICAgICAgICBieXRlMmhleFtidWZmZXJbMl1dICtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzNdXSArXG4gICAgICAgICAgICAgICAgICAgIFwiLVwiICtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzRdXSArXG4gICAgICAgICAgICAgICAgICAgIGJ5dGUyaGV4W2J1ZmZlcls1XV0gK1xuICAgICAgICAgICAgICAgICAgICBcIi1cIiArXG4gICAgICAgICAgICAgICAgICAgIGJ5dGUyaGV4WyhidWZmZXJbNl0gJiAweDBmKSB8IHZlcnNpb25dICtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzddXSArXG4gICAgICAgICAgICAgICAgICAgIFwiLVwiICtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZTJoZXhbKGJ1ZmZlcls4XSAmIDB4M2YpIHwgMHg4MF0gK1xuICAgICAgICAgICAgICAgICAgICBieXRlMmhleFtidWZmZXJbOV1dICtcbiAgICAgICAgICAgICAgICAgICAgXCItXCIgK1xuICAgICAgICAgICAgICAgICAgICBieXRlMmhleFtidWZmZXJbMTBdXSArXG4gICAgICAgICAgICAgICAgICAgIGJ5dGUyaGV4W2J1ZmZlclsxMV1dICtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzEyXV0gK1xuICAgICAgICAgICAgICAgICAgICBieXRlMmhleFtidWZmZXJbMTNdXSArXG4gICAgICAgICAgICAgICAgICAgIGJ5dGUyaGV4W2J1ZmZlclsxNF1dICtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzE1XV07XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeShidWZmZXIpIHtcbiAgICByZXR1cm4gKGJ5dGUyaGV4W2J1ZmZlclswXV0gK1xuICAgICAgICBieXRlMmhleFtidWZmZXJbMV1dICtcbiAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzJdXSArXG4gICAgICAgIGJ5dGUyaGV4W2J1ZmZlclszXV0gK1xuICAgICAgICBcIi1cIiArXG4gICAgICAgIGJ5dGUyaGV4W2J1ZmZlcls0XV0gK1xuICAgICAgICBieXRlMmhleFtidWZmZXJbNV1dICtcbiAgICAgICAgXCItXCIgK1xuICAgICAgICBieXRlMmhleFtidWZmZXJbNl1dICtcbiAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzddXSArXG4gICAgICAgIFwiLVwiICtcbiAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzhdXSArXG4gICAgICAgIGJ5dGUyaGV4W2J1ZmZlcls5XV0gK1xuICAgICAgICBcIi1cIiArXG4gICAgICAgIGJ5dGUyaGV4W2J1ZmZlclsxMF1dICtcbiAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzExXV0gK1xuICAgICAgICBieXRlMmhleFtidWZmZXJbMTJdXSArXG4gICAgICAgIGJ5dGUyaGV4W2J1ZmZlclsxM11dICtcbiAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzE0XV0gK1xuICAgICAgICBieXRlMmhleFtidWZmZXJbMTVdXSk7XG59XG4vLyBhY2NvcmRpbmcgdG8gcmZjNDEyMiNzZWN0aW9uLTQuMS43XG5leHBvcnRzLm5pbCA9IG5ldyBVVUlEKFwiMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwXCIpO1xuLy8gVVVJRC52NCA9IHV1aWRSYW5kb21cbi8vIFVVSUQudjRmYXN0ID0gdXVpZFJhbmRvbUZhc3Rcbi8vIFVVSUQudjMgPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuLy8gICAgIHJldHVybiB1dWlkTmFtZWQoXCJtZDVcIiwgMHgzMCwgb3B0aW9ucywgY2FsbGJhY2spXG4vLyB9XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dWlkLmpzLm1hcCIsIjsoZnVuY3Rpb24gKHNheCkgeyAvLyB3cmFwcGVyIGZvciBub24tbm9kZSBlbnZzXG4gIHNheC5wYXJzZXIgPSBmdW5jdGlvbiAoc3RyaWN0LCBvcHQpIHsgcmV0dXJuIG5ldyBTQVhQYXJzZXIoc3RyaWN0LCBvcHQpIH1cbiAgc2F4LlNBWFBhcnNlciA9IFNBWFBhcnNlclxuICBzYXguU0FYU3RyZWFtID0gU0FYU3RyZWFtXG4gIHNheC5jcmVhdGVTdHJlYW0gPSBjcmVhdGVTdHJlYW1cblxuICAvLyBXaGVuIHdlIHBhc3MgdGhlIE1BWF9CVUZGRVJfTEVOR1RIIHBvc2l0aW9uLCBzdGFydCBjaGVja2luZyBmb3IgYnVmZmVyIG92ZXJydW5zLlxuICAvLyBXaGVuIHdlIGNoZWNrLCBzY2hlZHVsZSB0aGUgbmV4dCBjaGVjayBmb3IgTUFYX0JVRkZFUl9MRU5HVEggLSAobWF4KGJ1ZmZlciBsZW5ndGhzKSksXG4gIC8vIHNpbmNlIHRoYXQncyB0aGUgZWFybGllc3QgdGhhdCBhIGJ1ZmZlciBvdmVycnVuIGNvdWxkIG9jY3VyLiAgVGhpcyB3YXksIGNoZWNrcyBhcmVcbiAgLy8gYXMgcmFyZSBhcyByZXF1aXJlZCwgYnV0IGFzIG9mdGVuIGFzIG5lY2Vzc2FyeSB0byBlbnN1cmUgbmV2ZXIgY3Jvc3NpbmcgdGhpcyBib3VuZC5cbiAgLy8gRnVydGhlcm1vcmUsIGJ1ZmZlcnMgYXJlIG9ubHkgdGVzdGVkIGF0IG1vc3Qgb25jZSBwZXIgd3JpdGUoKSwgc28gcGFzc2luZyBhIHZlcnlcbiAgLy8gbGFyZ2Ugc3RyaW5nIGludG8gd3JpdGUoKSBtaWdodCBoYXZlIHVuZGVzaXJhYmxlIGVmZmVjdHMsIGJ1dCB0aGlzIGlzIG1hbmFnZWFibGUgYnlcbiAgLy8gdGhlIGNhbGxlciwgc28gaXQgaXMgYXNzdW1lZCB0byBiZSBzYWZlLiAgVGh1cywgYSBjYWxsIHRvIHdyaXRlKCkgbWF5LCBpbiB0aGUgZXh0cmVtZVxuICAvLyBlZGdlIGNhc2UsIHJlc3VsdCBpbiBjcmVhdGluZyBhdCBtb3N0IG9uZSBjb21wbGV0ZSBjb3B5IG9mIHRoZSBzdHJpbmcgcGFzc2VkIGluLlxuICAvLyBTZXQgdG8gSW5maW5pdHkgdG8gaGF2ZSB1bmxpbWl0ZWQgYnVmZmVycy5cbiAgc2F4Lk1BWF9CVUZGRVJfTEVOR1RIID0gNjQgKiAxMDI0XG5cbiAgdmFyIGJ1ZmZlcnMgPSBbXG4gICAgJ2NvbW1lbnQnLCAnc2dtbERlY2wnLCAndGV4dE5vZGUnLCAndGFnTmFtZScsICdkb2N0eXBlJyxcbiAgICAncHJvY0luc3ROYW1lJywgJ3Byb2NJbnN0Qm9keScsICdlbnRpdHknLCAnYXR0cmliTmFtZScsXG4gICAgJ2F0dHJpYlZhbHVlJywgJ2NkYXRhJywgJ3NjcmlwdCdcbiAgXVxuXG4gIHNheC5FVkVOVFMgPSBbXG4gICAgJ3RleHQnLFxuICAgICdwcm9jZXNzaW5naW5zdHJ1Y3Rpb24nLFxuICAgICdzZ21sZGVjbGFyYXRpb24nLFxuICAgICdkb2N0eXBlJyxcbiAgICAnY29tbWVudCcsXG4gICAgJ29wZW50YWdzdGFydCcsXG4gICAgJ2F0dHJpYnV0ZScsXG4gICAgJ29wZW50YWcnLFxuICAgICdjbG9zZXRhZycsXG4gICAgJ29wZW5jZGF0YScsXG4gICAgJ2NkYXRhJyxcbiAgICAnY2xvc2VjZGF0YScsXG4gICAgJ2Vycm9yJyxcbiAgICAnZW5kJyxcbiAgICAncmVhZHknLFxuICAgICdzY3JpcHQnLFxuICAgICdvcGVubmFtZXNwYWNlJyxcbiAgICAnY2xvc2VuYW1lc3BhY2UnXG4gIF1cblxuICBmdW5jdGlvbiBTQVhQYXJzZXIgKHN0cmljdCwgb3B0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNBWFBhcnNlcikpIHtcbiAgICAgIHJldHVybiBuZXcgU0FYUGFyc2VyKHN0cmljdCwgb3B0KVxuICAgIH1cblxuICAgIHZhciBwYXJzZXIgPSB0aGlzXG4gICAgY2xlYXJCdWZmZXJzKHBhcnNlcilcbiAgICBwYXJzZXIucSA9IHBhcnNlci5jID0gJydcbiAgICBwYXJzZXIuYnVmZmVyQ2hlY2tQb3NpdGlvbiA9IHNheC5NQVhfQlVGRkVSX0xFTkdUSFxuICAgIHBhcnNlci5vcHQgPSBvcHQgfHwge31cbiAgICBwYXJzZXIub3B0Lmxvd2VyY2FzZSA9IHBhcnNlci5vcHQubG93ZXJjYXNlIHx8IHBhcnNlci5vcHQubG93ZXJjYXNldGFnc1xuICAgIHBhcnNlci5sb29zZUNhc2UgPSBwYXJzZXIub3B0Lmxvd2VyY2FzZSA/ICd0b0xvd2VyQ2FzZScgOiAndG9VcHBlckNhc2UnXG4gICAgcGFyc2VyLnRhZ3MgPSBbXVxuICAgIHBhcnNlci5jbG9zZWQgPSBwYXJzZXIuY2xvc2VkUm9vdCA9IHBhcnNlci5zYXdSb290ID0gZmFsc2VcbiAgICBwYXJzZXIudGFnID0gcGFyc2VyLmVycm9yID0gbnVsbFxuICAgIHBhcnNlci5zdHJpY3QgPSAhIXN0cmljdFxuICAgIHBhcnNlci5ub3NjcmlwdCA9ICEhKHN0cmljdCB8fCBwYXJzZXIub3B0Lm5vc2NyaXB0KVxuICAgIHBhcnNlci5zdGF0ZSA9IFMuQkVHSU5cbiAgICBwYXJzZXIuc3RyaWN0RW50aXRpZXMgPSBwYXJzZXIub3B0LnN0cmljdEVudGl0aWVzXG4gICAgcGFyc2VyLkVOVElUSUVTID0gcGFyc2VyLnN0cmljdEVudGl0aWVzID8gT2JqZWN0LmNyZWF0ZShzYXguWE1MX0VOVElUSUVTKSA6IE9iamVjdC5jcmVhdGUoc2F4LkVOVElUSUVTKVxuICAgIHBhcnNlci5hdHRyaWJMaXN0ID0gW11cblxuICAgIC8vIG5hbWVzcGFjZXMgZm9ybSBhIHByb3RvdHlwZSBjaGFpbi5cbiAgICAvLyBpdCBhbHdheXMgcG9pbnRzIGF0IHRoZSBjdXJyZW50IHRhZyxcbiAgICAvLyB3aGljaCBwcm90b3MgdG8gaXRzIHBhcmVudCB0YWcuXG4gICAgaWYgKHBhcnNlci5vcHQueG1sbnMpIHtcbiAgICAgIHBhcnNlci5ucyA9IE9iamVjdC5jcmVhdGUocm9vdE5TKVxuICAgIH1cblxuICAgIC8vIG1vc3RseSBqdXN0IGZvciBlcnJvciByZXBvcnRpbmdcbiAgICBwYXJzZXIudHJhY2tQb3NpdGlvbiA9IHBhcnNlci5vcHQucG9zaXRpb24gIT09IGZhbHNlXG4gICAgaWYgKHBhcnNlci50cmFja1Bvc2l0aW9uKSB7XG4gICAgICBwYXJzZXIucG9zaXRpb24gPSBwYXJzZXIubGluZSA9IHBhcnNlci5jb2x1bW4gPSAwXG4gICAgfVxuICAgIGVtaXQocGFyc2VyLCAnb25yZWFkeScpXG4gIH1cblxuICBpZiAoIU9iamVjdC5jcmVhdGUpIHtcbiAgICBPYmplY3QuY3JlYXRlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIGZ1bmN0aW9uIEYgKCkge31cbiAgICAgIEYucHJvdG90eXBlID0gb1xuICAgICAgdmFyIG5ld2YgPSBuZXcgRigpXG4gICAgICByZXR1cm4gbmV3ZlxuICAgIH1cbiAgfVxuXG4gIGlmICghT2JqZWN0LmtleXMpIHtcbiAgICBPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgYSA9IFtdXG4gICAgICBmb3IgKHZhciBpIGluIG8pIGlmIChvLmhhc093blByb3BlcnR5KGkpKSBhLnB1c2goaSlcbiAgICAgIHJldHVybiBhXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tCdWZmZXJMZW5ndGggKHBhcnNlcikge1xuICAgIHZhciBtYXhBbGxvd2VkID0gTWF0aC5tYXgoc2F4Lk1BWF9CVUZGRVJfTEVOR1RILCAxMClcbiAgICB2YXIgbWF4QWN0dWFsID0gMFxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYnVmZmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBsZW4gPSBwYXJzZXJbYnVmZmVyc1tpXV0ubGVuZ3RoXG4gICAgICBpZiAobGVuID4gbWF4QWxsb3dlZCkge1xuICAgICAgICAvLyBUZXh0L2NkYXRhIG5vZGVzIGNhbiBnZXQgYmlnLCBhbmQgc2luY2UgdGhleSdyZSBidWZmZXJlZCxcbiAgICAgICAgLy8gd2UgY2FuIGdldCBoZXJlIHVuZGVyIG5vcm1hbCBjb25kaXRpb25zLlxuICAgICAgICAvLyBBdm9pZCBpc3N1ZXMgYnkgZW1pdHRpbmcgdGhlIHRleHQgbm9kZSBub3csXG4gICAgICAgIC8vIHNvIGF0IGxlYXN0IGl0IHdvbid0IGdldCBhbnkgYmlnZ2VyLlxuICAgICAgICBzd2l0Y2ggKGJ1ZmZlcnNbaV0pIHtcbiAgICAgICAgICBjYXNlICd0ZXh0Tm9kZSc6XG4gICAgICAgICAgICBjbG9zZVRleHQocGFyc2VyKVxuICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgIGNhc2UgJ2NkYXRhJzpcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY2RhdGEnLCBwYXJzZXIuY2RhdGEpXG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgPSAnJ1xuICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgIGNhc2UgJ3NjcmlwdCc6XG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbnNjcmlwdCcsIHBhcnNlci5zY3JpcHQpXG4gICAgICAgICAgICBwYXJzZXIuc2NyaXB0ID0gJydcbiAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZXJyb3IocGFyc2VyLCAnTWF4IGJ1ZmZlciBsZW5ndGggZXhjZWVkZWQ6ICcgKyBidWZmZXJzW2ldKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtYXhBY3R1YWwgPSBNYXRoLm1heChtYXhBY3R1YWwsIGxlbilcbiAgICB9XG4gICAgLy8gc2NoZWR1bGUgdGhlIG5leHQgY2hlY2sgZm9yIHRoZSBlYXJsaWVzdCBwb3NzaWJsZSBidWZmZXIgb3ZlcnJ1bi5cbiAgICB2YXIgbSA9IHNheC5NQVhfQlVGRkVSX0xFTkdUSCAtIG1heEFjdHVhbFxuICAgIHBhcnNlci5idWZmZXJDaGVja1Bvc2l0aW9uID0gbSArIHBhcnNlci5wb3NpdGlvblxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJCdWZmZXJzIChwYXJzZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGJ1ZmZlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXJzZXJbYnVmZmVyc1tpXV0gPSAnJ1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoQnVmZmVycyAocGFyc2VyKSB7XG4gICAgY2xvc2VUZXh0KHBhcnNlcilcbiAgICBpZiAocGFyc2VyLmNkYXRhICE9PSAnJykge1xuICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jZGF0YScsIHBhcnNlci5jZGF0YSlcbiAgICAgIHBhcnNlci5jZGF0YSA9ICcnXG4gICAgfVxuICAgIGlmIChwYXJzZXIuc2NyaXB0ICE9PSAnJykge1xuICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25zY3JpcHQnLCBwYXJzZXIuc2NyaXB0KVxuICAgICAgcGFyc2VyLnNjcmlwdCA9ICcnXG4gICAgfVxuICB9XG5cbiAgU0FYUGFyc2VyLnByb3RvdHlwZSA9IHtcbiAgICBlbmQ6IGZ1bmN0aW9uICgpIHsgZW5kKHRoaXMpIH0sXG4gICAgd3JpdGU6IHdyaXRlLFxuICAgIHJlc3VtZTogZnVuY3Rpb24gKCkgeyB0aGlzLmVycm9yID0gbnVsbDsgcmV0dXJuIHRoaXMgfSxcbiAgICBjbG9zZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy53cml0ZShudWxsKSB9LFxuICAgIGZsdXNoOiBmdW5jdGlvbiAoKSB7IGZsdXNoQnVmZmVycyh0aGlzKSB9XG4gIH1cblxuICB2YXIgU3RyZWFtXG4gIHRyeSB7XG4gICAgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuU3RyZWFtXG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgU3RyZWFtID0gZnVuY3Rpb24gKCkge31cbiAgfVxuXG4gIHZhciBzdHJlYW1XcmFwcyA9IHNheC5FVkVOVFMuZmlsdGVyKGZ1bmN0aW9uIChldikge1xuICAgIHJldHVybiBldiAhPT0gJ2Vycm9yJyAmJiBldiAhPT0gJ2VuZCdcbiAgfSlcblxuICBmdW5jdGlvbiBjcmVhdGVTdHJlYW0gKHN0cmljdCwgb3B0KSB7XG4gICAgcmV0dXJuIG5ldyBTQVhTdHJlYW0oc3RyaWN0LCBvcHQpXG4gIH1cblxuICBmdW5jdGlvbiBTQVhTdHJlYW0gKHN0cmljdCwgb3B0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNBWFN0cmVhbSkpIHtcbiAgICAgIHJldHVybiBuZXcgU0FYU3RyZWFtKHN0cmljdCwgb3B0KVxuICAgIH1cblxuICAgIFN0cmVhbS5hcHBseSh0aGlzKVxuXG4gICAgdGhpcy5fcGFyc2VyID0gbmV3IFNBWFBhcnNlcihzdHJpY3QsIG9wdClcbiAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZVxuICAgIHRoaXMucmVhZGFibGUgPSB0cnVlXG5cbiAgICB2YXIgbWUgPSB0aGlzXG5cbiAgICB0aGlzLl9wYXJzZXIub25lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBtZS5lbWl0KCdlbmQnKVxuICAgIH1cblxuICAgIHRoaXMuX3BhcnNlci5vbmVycm9yID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgICBtZS5lbWl0KCdlcnJvcicsIGVyKVxuXG4gICAgICAvLyBpZiBkaWRuJ3QgdGhyb3csIHRoZW4gbWVhbnMgZXJyb3Igd2FzIGhhbmRsZWQuXG4gICAgICAvLyBnbyBhaGVhZCBhbmQgY2xlYXIgZXJyb3IsIHNvIHdlIGNhbiB3cml0ZSBhZ2Fpbi5cbiAgICAgIG1lLl9wYXJzZXIuZXJyb3IgPSBudWxsXG4gICAgfVxuXG4gICAgdGhpcy5fZGVjb2RlciA9IG51bGxcblxuICAgIHN0cmVhbVdyYXBzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWUsICdvbicgKyBldiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbWUuX3BhcnNlclsnb24nICsgZXZdXG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICBpZiAoIWgpIHtcbiAgICAgICAgICAgIG1lLnJlbW92ZUFsbExpc3RlbmVycyhldilcbiAgICAgICAgICAgIG1lLl9wYXJzZXJbJ29uJyArIGV2XSA9IGhcbiAgICAgICAgICAgIHJldHVybiBoXG4gICAgICAgICAgfVxuICAgICAgICAgIG1lLm9uKGV2LCBoKVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBTQVhTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdHJlYW0ucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBTQVhTdHJlYW1cbiAgICB9XG4gIH0pXG5cbiAgU0FYU3RyZWFtLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHR5cGVvZiBCdWZmZXIuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgaWYgKCF0aGlzLl9kZWNvZGVyKSB7XG4gICAgICAgIHZhciBTRCA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlclxuICAgICAgICB0aGlzLl9kZWNvZGVyID0gbmV3IFNEKCd1dGY4JylcbiAgICAgIH1cbiAgICAgIGRhdGEgPSB0aGlzLl9kZWNvZGVyLndyaXRlKGRhdGEpXG4gICAgfVxuXG4gICAgdGhpcy5fcGFyc2VyLndyaXRlKGRhdGEudG9TdHJpbmcoKSlcbiAgICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBTQVhTdHJlYW0ucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHRoaXMud3JpdGUoY2h1bmspXG4gICAgfVxuICAgIHRoaXMuX3BhcnNlci5lbmQoKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBTQVhTdHJlYW0ucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBoYW5kbGVyKSB7XG4gICAgdmFyIG1lID0gdGhpc1xuICAgIGlmICghbWUuX3BhcnNlclsnb24nICsgZXZdICYmIHN0cmVhbVdyYXBzLmluZGV4T2YoZXYpICE9PSAtMSkge1xuICAgICAgbWUuX3BhcnNlclsnb24nICsgZXZdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBbYXJndW1lbnRzWzBdXSA6IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICAgICAgYXJncy5zcGxpY2UoMCwgMCwgZXYpXG4gICAgICAgIG1lLmVtaXQuYXBwbHkobWUsIGFyZ3MpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmVhbS5wcm90b3R5cGUub24uY2FsbChtZSwgZXYsIGhhbmRsZXIpXG4gIH1cblxuICAvLyB0aGlzIHJlYWxseSBuZWVkcyB0byBiZSByZXBsYWNlZCB3aXRoIGNoYXJhY3RlciBjbGFzc2VzLlxuICAvLyBYTUwgYWxsb3dzIGFsbCBtYW5uZXIgb2YgcmlkaWN1bG91cyBudW1iZXJzIGFuZCBkaWdpdHMuXG4gIHZhciBDREFUQSA9ICdbQ0RBVEFbJ1xuICB2YXIgRE9DVFlQRSA9ICdET0NUWVBFJ1xuICB2YXIgWE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXG4gIHZhciBYTUxOU19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nXG4gIHZhciByb290TlMgPSB7IHhtbDogWE1MX05BTUVTUEFDRSwgeG1sbnM6IFhNTE5TX05BTUVTUEFDRSB9XG5cbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVN0YXJ0Q2hhclxuICAvLyBUaGlzIGltcGxlbWVudGF0aW9uIHdvcmtzIG9uIHN0cmluZ3MsIGEgc2luZ2xlIGNoYXJhY3RlciBhdCBhIHRpbWVcbiAgLy8gYXMgc3VjaCwgaXQgY2Fubm90IGV2ZXIgc3VwcG9ydCBhc3RyYWwtcGxhbmUgY2hhcmFjdGVycyAoMTAwMDAtRUZGRkYpXG4gIC8vIHdpdGhvdXQgYSBzaWduaWZpY2FudCBicmVha2luZyBjaGFuZ2UgdG8gZWl0aGVyIHRoaXMgIHBhcnNlciwgb3IgdGhlXG4gIC8vIEphdmFTY3JpcHQgbGFuZ3VhZ2UuICBJbXBsZW1lbnRhdGlvbiBvZiBhbiBlbW9qaS1jYXBhYmxlIHhtbCBwYXJzZXJcbiAgLy8gaXMgbGVmdCBhcyBhbiBleGVyY2lzZSBmb3IgdGhlIHJlYWRlci5cbiAgdmFyIG5hbWVTdGFydCA9IC9bOl9BLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRdL1xuXG4gIHZhciBuYW1lQm9keSA9IC9bOl9BLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRcXHUwMEI3XFx1MDMwMC1cXHUwMzZGXFx1MjAzRi1cXHUyMDQwLlxcZC1dL1xuXG4gIHZhciBlbnRpdHlTdGFydCA9IC9bIzpfQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXS9cbiAgdmFyIGVudGl0eUJvZHkgPSAvWyM6X0EtWmEtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRFxcdTAwQjdcXHUwMzAwLVxcdTAzNkZcXHUyMDNGLVxcdTIwNDAuXFxkLV0vXG5cbiAgZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChjKSB7XG4gICAgcmV0dXJuIGMgPT09ICcgJyB8fCBjID09PSAnXFxuJyB8fCBjID09PSAnXFxyJyB8fCBjID09PSAnXFx0J1xuICB9XG5cbiAgZnVuY3Rpb24gaXNRdW90ZSAoYykge1xuICAgIHJldHVybiBjID09PSAnXCInIHx8IGMgPT09ICdcXCcnXG4gIH1cblxuICBmdW5jdGlvbiBpc0F0dHJpYkVuZCAoYykge1xuICAgIHJldHVybiBjID09PSAnPicgfHwgaXNXaGl0ZXNwYWNlKGMpXG4gIH1cblxuICBmdW5jdGlvbiBpc01hdGNoIChyZWdleCwgYykge1xuICAgIHJldHVybiByZWdleC50ZXN0KGMpXG4gIH1cblxuICBmdW5jdGlvbiBub3RNYXRjaCAocmVnZXgsIGMpIHtcbiAgICByZXR1cm4gIWlzTWF0Y2gocmVnZXgsIGMpXG4gIH1cblxuICB2YXIgUyA9IDBcbiAgc2F4LlNUQVRFID0ge1xuICAgIEJFR0lOOiBTKyssIC8vIGxlYWRpbmcgYnl0ZSBvcmRlciBtYXJrIG9yIHdoaXRlc3BhY2VcbiAgICBCRUdJTl9XSElURVNQQUNFOiBTKyssIC8vIGxlYWRpbmcgd2hpdGVzcGFjZVxuICAgIFRFWFQ6IFMrKywgLy8gZ2VuZXJhbCBzdHVmZlxuICAgIFRFWFRfRU5USVRZOiBTKyssIC8vICZhbXAgYW5kIHN1Y2guXG4gICAgT1BFTl9XQUtBOiBTKyssIC8vIDxcbiAgICBTR01MX0RFQ0w6IFMrKywgLy8gPCFCTEFSR1xuICAgIFNHTUxfREVDTF9RVU9URUQ6IFMrKywgLy8gPCFCTEFSRyBmb28gXCJiYXJcbiAgICBET0NUWVBFOiBTKyssIC8vIDwhRE9DVFlQRVxuICAgIERPQ1RZUEVfUVVPVEVEOiBTKyssIC8vIDwhRE9DVFlQRSBcIi8vYmxhaFxuICAgIERPQ1RZUEVfRFREOiBTKyssIC8vIDwhRE9DVFlQRSBcIi8vYmxhaFwiIFsgLi4uXG4gICAgRE9DVFlQRV9EVERfUVVPVEVEOiBTKyssIC8vIDwhRE9DVFlQRSBcIi8vYmxhaFwiIFsgXCJmb29cbiAgICBDT01NRU5UX1NUQVJUSU5HOiBTKyssIC8vIDwhLVxuICAgIENPTU1FTlQ6IFMrKywgLy8gPCEtLVxuICAgIENPTU1FTlRfRU5ESU5HOiBTKyssIC8vIDwhLS0gYmxhaCAtXG4gICAgQ09NTUVOVF9FTkRFRDogUysrLCAvLyA8IS0tIGJsYWggLS1cbiAgICBDREFUQTogUysrLCAvLyA8IVtDREFUQVsgc29tZXRoaW5nXG4gICAgQ0RBVEFfRU5ESU5HOiBTKyssIC8vIF1cbiAgICBDREFUQV9FTkRJTkdfMjogUysrLCAvLyBdXVxuICAgIFBST0NfSU5TVDogUysrLCAvLyA8P2hpXG4gICAgUFJPQ19JTlNUX0JPRFk6IFMrKywgLy8gPD9oaSB0aGVyZVxuICAgIFBST0NfSU5TVF9FTkRJTkc6IFMrKywgLy8gPD9oaSBcInRoZXJlXCIgP1xuICAgIE9QRU5fVEFHOiBTKyssIC8vIDxzdHJvbmdcbiAgICBPUEVOX1RBR19TTEFTSDogUysrLCAvLyA8c3Ryb25nIC9cbiAgICBBVFRSSUI6IFMrKywgLy8gPGFcbiAgICBBVFRSSUJfTkFNRTogUysrLCAvLyA8YSBmb29cbiAgICBBVFRSSUJfTkFNRV9TQVdfV0hJVEU6IFMrKywgLy8gPGEgZm9vIF9cbiAgICBBVFRSSUJfVkFMVUU6IFMrKywgLy8gPGEgZm9vPVxuICAgIEFUVFJJQl9WQUxVRV9RVU9URUQ6IFMrKywgLy8gPGEgZm9vPVwiYmFyXG4gICAgQVRUUklCX1ZBTFVFX0NMT1NFRDogUysrLCAvLyA8YSBmb289XCJiYXJcIlxuICAgIEFUVFJJQl9WQUxVRV9VTlFVT1RFRDogUysrLCAvLyA8YSBmb289YmFyXG4gICAgQVRUUklCX1ZBTFVFX0VOVElUWV9ROiBTKyssIC8vIDxmb28gYmFyPVwiJnF1b3Q7XCJcbiAgICBBVFRSSUJfVkFMVUVfRU5USVRZX1U6IFMrKywgLy8gPGZvbyBiYXI9JnF1b3RcbiAgICBDTE9TRV9UQUc6IFMrKywgLy8gPC9hXG4gICAgQ0xPU0VfVEFHX1NBV19XSElURTogUysrLCAvLyA8L2EgICA+XG4gICAgU0NSSVBUOiBTKyssIC8vIDxzY3JpcHQ+IC4uLlxuICAgIFNDUklQVF9FTkRJTkc6IFMrKyAvLyA8c2NyaXB0PiAuLi4gPFxuICB9XG5cbiAgc2F4LlhNTF9FTlRJVElFUyA9IHtcbiAgICAnYW1wJzogJyYnLFxuICAgICdndCc6ICc+JyxcbiAgICAnbHQnOiAnPCcsXG4gICAgJ3F1b3QnOiAnXCInLFxuICAgICdhcG9zJzogXCInXCJcbiAgfVxuXG4gIHNheC5FTlRJVElFUyA9IHtcbiAgICAnYW1wJzogJyYnLFxuICAgICdndCc6ICc+JyxcbiAgICAnbHQnOiAnPCcsXG4gICAgJ3F1b3QnOiAnXCInLFxuICAgICdhcG9zJzogXCInXCIsXG4gICAgJ0FFbGlnJzogMTk4LFxuICAgICdBYWN1dGUnOiAxOTMsXG4gICAgJ0FjaXJjJzogMTk0LFxuICAgICdBZ3JhdmUnOiAxOTIsXG4gICAgJ0FyaW5nJzogMTk3LFxuICAgICdBdGlsZGUnOiAxOTUsXG4gICAgJ0F1bWwnOiAxOTYsXG4gICAgJ0NjZWRpbCc6IDE5OSxcbiAgICAnRVRIJzogMjA4LFxuICAgICdFYWN1dGUnOiAyMDEsXG4gICAgJ0VjaXJjJzogMjAyLFxuICAgICdFZ3JhdmUnOiAyMDAsXG4gICAgJ0V1bWwnOiAyMDMsXG4gICAgJ0lhY3V0ZSc6IDIwNSxcbiAgICAnSWNpcmMnOiAyMDYsXG4gICAgJ0lncmF2ZSc6IDIwNCxcbiAgICAnSXVtbCc6IDIwNyxcbiAgICAnTnRpbGRlJzogMjA5LFxuICAgICdPYWN1dGUnOiAyMTEsXG4gICAgJ09jaXJjJzogMjEyLFxuICAgICdPZ3JhdmUnOiAyMTAsXG4gICAgJ09zbGFzaCc6IDIxNixcbiAgICAnT3RpbGRlJzogMjEzLFxuICAgICdPdW1sJzogMjE0LFxuICAgICdUSE9STic6IDIyMixcbiAgICAnVWFjdXRlJzogMjE4LFxuICAgICdVY2lyYyc6IDIxOSxcbiAgICAnVWdyYXZlJzogMjE3LFxuICAgICdVdW1sJzogMjIwLFxuICAgICdZYWN1dGUnOiAyMjEsXG4gICAgJ2FhY3V0ZSc6IDIyNSxcbiAgICAnYWNpcmMnOiAyMjYsXG4gICAgJ2FlbGlnJzogMjMwLFxuICAgICdhZ3JhdmUnOiAyMjQsXG4gICAgJ2FyaW5nJzogMjI5LFxuICAgICdhdGlsZGUnOiAyMjcsXG4gICAgJ2F1bWwnOiAyMjgsXG4gICAgJ2NjZWRpbCc6IDIzMSxcbiAgICAnZWFjdXRlJzogMjMzLFxuICAgICdlY2lyYyc6IDIzNCxcbiAgICAnZWdyYXZlJzogMjMyLFxuICAgICdldGgnOiAyNDAsXG4gICAgJ2V1bWwnOiAyMzUsXG4gICAgJ2lhY3V0ZSc6IDIzNyxcbiAgICAnaWNpcmMnOiAyMzgsXG4gICAgJ2lncmF2ZSc6IDIzNixcbiAgICAnaXVtbCc6IDIzOSxcbiAgICAnbnRpbGRlJzogMjQxLFxuICAgICdvYWN1dGUnOiAyNDMsXG4gICAgJ29jaXJjJzogMjQ0LFxuICAgICdvZ3JhdmUnOiAyNDIsXG4gICAgJ29zbGFzaCc6IDI0OCxcbiAgICAnb3RpbGRlJzogMjQ1LFxuICAgICdvdW1sJzogMjQ2LFxuICAgICdzemxpZyc6IDIyMyxcbiAgICAndGhvcm4nOiAyNTQsXG4gICAgJ3VhY3V0ZSc6IDI1MCxcbiAgICAndWNpcmMnOiAyNTEsXG4gICAgJ3VncmF2ZSc6IDI0OSxcbiAgICAndXVtbCc6IDI1MixcbiAgICAneWFjdXRlJzogMjUzLFxuICAgICd5dW1sJzogMjU1LFxuICAgICdjb3B5JzogMTY5LFxuICAgICdyZWcnOiAxNzQsXG4gICAgJ25ic3AnOiAxNjAsXG4gICAgJ2lleGNsJzogMTYxLFxuICAgICdjZW50JzogMTYyLFxuICAgICdwb3VuZCc6IDE2MyxcbiAgICAnY3VycmVuJzogMTY0LFxuICAgICd5ZW4nOiAxNjUsXG4gICAgJ2JydmJhcic6IDE2NixcbiAgICAnc2VjdCc6IDE2NyxcbiAgICAndW1sJzogMTY4LFxuICAgICdvcmRmJzogMTcwLFxuICAgICdsYXF1byc6IDE3MSxcbiAgICAnbm90JzogMTcyLFxuICAgICdzaHknOiAxNzMsXG4gICAgJ21hY3InOiAxNzUsXG4gICAgJ2RlZyc6IDE3NixcbiAgICAncGx1c21uJzogMTc3LFxuICAgICdzdXAxJzogMTg1LFxuICAgICdzdXAyJzogMTc4LFxuICAgICdzdXAzJzogMTc5LFxuICAgICdhY3V0ZSc6IDE4MCxcbiAgICAnbWljcm8nOiAxODEsXG4gICAgJ3BhcmEnOiAxODIsXG4gICAgJ21pZGRvdCc6IDE4MyxcbiAgICAnY2VkaWwnOiAxODQsXG4gICAgJ29yZG0nOiAxODYsXG4gICAgJ3JhcXVvJzogMTg3LFxuICAgICdmcmFjMTQnOiAxODgsXG4gICAgJ2ZyYWMxMic6IDE4OSxcbiAgICAnZnJhYzM0JzogMTkwLFxuICAgICdpcXVlc3QnOiAxOTEsXG4gICAgJ3RpbWVzJzogMjE1LFxuICAgICdkaXZpZGUnOiAyNDcsXG4gICAgJ09FbGlnJzogMzM4LFxuICAgICdvZWxpZyc6IDMzOSxcbiAgICAnU2Nhcm9uJzogMzUyLFxuICAgICdzY2Fyb24nOiAzNTMsXG4gICAgJ1l1bWwnOiAzNzYsXG4gICAgJ2Zub2YnOiA0MDIsXG4gICAgJ2NpcmMnOiA3MTAsXG4gICAgJ3RpbGRlJzogNzMyLFxuICAgICdBbHBoYSc6IDkxMyxcbiAgICAnQmV0YSc6IDkxNCxcbiAgICAnR2FtbWEnOiA5MTUsXG4gICAgJ0RlbHRhJzogOTE2LFxuICAgICdFcHNpbG9uJzogOTE3LFxuICAgICdaZXRhJzogOTE4LFxuICAgICdFdGEnOiA5MTksXG4gICAgJ1RoZXRhJzogOTIwLFxuICAgICdJb3RhJzogOTIxLFxuICAgICdLYXBwYSc6IDkyMixcbiAgICAnTGFtYmRhJzogOTIzLFxuICAgICdNdSc6IDkyNCxcbiAgICAnTnUnOiA5MjUsXG4gICAgJ1hpJzogOTI2LFxuICAgICdPbWljcm9uJzogOTI3LFxuICAgICdQaSc6IDkyOCxcbiAgICAnUmhvJzogOTI5LFxuICAgICdTaWdtYSc6IDkzMSxcbiAgICAnVGF1JzogOTMyLFxuICAgICdVcHNpbG9uJzogOTMzLFxuICAgICdQaGknOiA5MzQsXG4gICAgJ0NoaSc6IDkzNSxcbiAgICAnUHNpJzogOTM2LFxuICAgICdPbWVnYSc6IDkzNyxcbiAgICAnYWxwaGEnOiA5NDUsXG4gICAgJ2JldGEnOiA5NDYsXG4gICAgJ2dhbW1hJzogOTQ3LFxuICAgICdkZWx0YSc6IDk0OCxcbiAgICAnZXBzaWxvbic6IDk0OSxcbiAgICAnemV0YSc6IDk1MCxcbiAgICAnZXRhJzogOTUxLFxuICAgICd0aGV0YSc6IDk1MixcbiAgICAnaW90YSc6IDk1MyxcbiAgICAna2FwcGEnOiA5NTQsXG4gICAgJ2xhbWJkYSc6IDk1NSxcbiAgICAnbXUnOiA5NTYsXG4gICAgJ251JzogOTU3LFxuICAgICd4aSc6IDk1OCxcbiAgICAnb21pY3Jvbic6IDk1OSxcbiAgICAncGknOiA5NjAsXG4gICAgJ3Jobyc6IDk2MSxcbiAgICAnc2lnbWFmJzogOTYyLFxuICAgICdzaWdtYSc6IDk2MyxcbiAgICAndGF1JzogOTY0LFxuICAgICd1cHNpbG9uJzogOTY1LFxuICAgICdwaGknOiA5NjYsXG4gICAgJ2NoaSc6IDk2NyxcbiAgICAncHNpJzogOTY4LFxuICAgICdvbWVnYSc6IDk2OSxcbiAgICAndGhldGFzeW0nOiA5NzcsXG4gICAgJ3Vwc2loJzogOTc4LFxuICAgICdwaXYnOiA5ODIsXG4gICAgJ2Vuc3AnOiA4MTk0LFxuICAgICdlbXNwJzogODE5NSxcbiAgICAndGhpbnNwJzogODIwMSxcbiAgICAnenduaic6IDgyMDQsXG4gICAgJ3p3aic6IDgyMDUsXG4gICAgJ2xybSc6IDgyMDYsXG4gICAgJ3JsbSc6IDgyMDcsXG4gICAgJ25kYXNoJzogODIxMSxcbiAgICAnbWRhc2gnOiA4MjEyLFxuICAgICdsc3F1byc6IDgyMTYsXG4gICAgJ3JzcXVvJzogODIxNyxcbiAgICAnc2JxdW8nOiA4MjE4LFxuICAgICdsZHF1byc6IDgyMjAsXG4gICAgJ3JkcXVvJzogODIyMSxcbiAgICAnYmRxdW8nOiA4MjIyLFxuICAgICdkYWdnZXInOiA4MjI0LFxuICAgICdEYWdnZXInOiA4MjI1LFxuICAgICdidWxsJzogODIyNixcbiAgICAnaGVsbGlwJzogODIzMCxcbiAgICAncGVybWlsJzogODI0MCxcbiAgICAncHJpbWUnOiA4MjQyLFxuICAgICdQcmltZSc6IDgyNDMsXG4gICAgJ2xzYXF1byc6IDgyNDksXG4gICAgJ3JzYXF1byc6IDgyNTAsXG4gICAgJ29saW5lJzogODI1NCxcbiAgICAnZnJhc2wnOiA4MjYwLFxuICAgICdldXJvJzogODM2NCxcbiAgICAnaW1hZ2UnOiA4NDY1LFxuICAgICd3ZWllcnAnOiA4NDcyLFxuICAgICdyZWFsJzogODQ3NixcbiAgICAndHJhZGUnOiA4NDgyLFxuICAgICdhbGVmc3ltJzogODUwMSxcbiAgICAnbGFycic6IDg1OTIsXG4gICAgJ3VhcnInOiA4NTkzLFxuICAgICdyYXJyJzogODU5NCxcbiAgICAnZGFycic6IDg1OTUsXG4gICAgJ2hhcnInOiA4NTk2LFxuICAgICdjcmFycic6IDg2MjksXG4gICAgJ2xBcnInOiA4NjU2LFxuICAgICd1QXJyJzogODY1NyxcbiAgICAnckFycic6IDg2NTgsXG4gICAgJ2RBcnInOiA4NjU5LFxuICAgICdoQXJyJzogODY2MCxcbiAgICAnZm9yYWxsJzogODcwNCxcbiAgICAncGFydCc6IDg3MDYsXG4gICAgJ2V4aXN0JzogODcwNyxcbiAgICAnZW1wdHknOiA4NzA5LFxuICAgICduYWJsYSc6IDg3MTEsXG4gICAgJ2lzaW4nOiA4NzEyLFxuICAgICdub3Rpbic6IDg3MTMsXG4gICAgJ25pJzogODcxNSxcbiAgICAncHJvZCc6IDg3MTksXG4gICAgJ3N1bSc6IDg3MjEsXG4gICAgJ21pbnVzJzogODcyMixcbiAgICAnbG93YXN0JzogODcyNyxcbiAgICAncmFkaWMnOiA4NzMwLFxuICAgICdwcm9wJzogODczMyxcbiAgICAnaW5maW4nOiA4NzM0LFxuICAgICdhbmcnOiA4NzM2LFxuICAgICdhbmQnOiA4NzQzLFxuICAgICdvcic6IDg3NDQsXG4gICAgJ2NhcCc6IDg3NDUsXG4gICAgJ2N1cCc6IDg3NDYsXG4gICAgJ2ludCc6IDg3NDcsXG4gICAgJ3RoZXJlNCc6IDg3NTYsXG4gICAgJ3NpbSc6IDg3NjQsXG4gICAgJ2NvbmcnOiA4NzczLFxuICAgICdhc3ltcCc6IDg3NzYsXG4gICAgJ25lJzogODgwMCxcbiAgICAnZXF1aXYnOiA4ODAxLFxuICAgICdsZSc6IDg4MDQsXG4gICAgJ2dlJzogODgwNSxcbiAgICAnc3ViJzogODgzNCxcbiAgICAnc3VwJzogODgzNSxcbiAgICAnbnN1Yic6IDg4MzYsXG4gICAgJ3N1YmUnOiA4ODM4LFxuICAgICdzdXBlJzogODgzOSxcbiAgICAnb3BsdXMnOiA4ODUzLFxuICAgICdvdGltZXMnOiA4ODU1LFxuICAgICdwZXJwJzogODg2OSxcbiAgICAnc2RvdCc6IDg5MDEsXG4gICAgJ2xjZWlsJzogODk2OCxcbiAgICAncmNlaWwnOiA4OTY5LFxuICAgICdsZmxvb3InOiA4OTcwLFxuICAgICdyZmxvb3InOiA4OTcxLFxuICAgICdsYW5nJzogOTAwMSxcbiAgICAncmFuZyc6IDkwMDIsXG4gICAgJ2xveic6IDk2NzQsXG4gICAgJ3NwYWRlcyc6IDk4MjQsXG4gICAgJ2NsdWJzJzogOTgyNyxcbiAgICAnaGVhcnRzJzogOTgyOSxcbiAgICAnZGlhbXMnOiA5ODMwXG4gIH1cblxuICBPYmplY3Qua2V5cyhzYXguRU5USVRJRVMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBlID0gc2F4LkVOVElUSUVTW2tleV1cbiAgICB2YXIgcyA9IHR5cGVvZiBlID09PSAnbnVtYmVyJyA/IFN0cmluZy5mcm9tQ2hhckNvZGUoZSkgOiBlXG4gICAgc2F4LkVOVElUSUVTW2tleV0gPSBzXG4gIH0pXG5cbiAgZm9yICh2YXIgcyBpbiBzYXguU1RBVEUpIHtcbiAgICBzYXguU1RBVEVbc2F4LlNUQVRFW3NdXSA9IHNcbiAgfVxuXG4gIC8vIHNob3J0aGFuZFxuICBTID0gc2F4LlNUQVRFXG5cbiAgZnVuY3Rpb24gZW1pdCAocGFyc2VyLCBldmVudCwgZGF0YSkge1xuICAgIHBhcnNlcltldmVudF0gJiYgcGFyc2VyW2V2ZW50XShkYXRhKVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdE5vZGUgKHBhcnNlciwgbm9kZVR5cGUsIGRhdGEpIHtcbiAgICBpZiAocGFyc2VyLnRleHROb2RlKSBjbG9zZVRleHQocGFyc2VyKVxuICAgIGVtaXQocGFyc2VyLCBub2RlVHlwZSwgZGF0YSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlVGV4dCAocGFyc2VyKSB7XG4gICAgcGFyc2VyLnRleHROb2RlID0gdGV4dG9wdHMocGFyc2VyLm9wdCwgcGFyc2VyLnRleHROb2RlKVxuICAgIGlmIChwYXJzZXIudGV4dE5vZGUpIGVtaXQocGFyc2VyLCAnb250ZXh0JywgcGFyc2VyLnRleHROb2RlKVxuICAgIHBhcnNlci50ZXh0Tm9kZSA9ICcnXG4gIH1cblxuICBmdW5jdGlvbiB0ZXh0b3B0cyAob3B0LCB0ZXh0KSB7XG4gICAgaWYgKG9wdC50cmltKSB0ZXh0ID0gdGV4dC50cmltKClcbiAgICBpZiAob3B0Lm5vcm1hbGl6ZSkgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxzKy9nLCAnICcpXG4gICAgcmV0dXJuIHRleHRcbiAgfVxuXG4gIGZ1bmN0aW9uIGVycm9yIChwYXJzZXIsIGVyKSB7XG4gICAgY2xvc2VUZXh0KHBhcnNlcilcbiAgICBpZiAocGFyc2VyLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgIGVyICs9ICdcXG5MaW5lOiAnICsgcGFyc2VyLmxpbmUgK1xuICAgICAgICAnXFxuQ29sdW1uOiAnICsgcGFyc2VyLmNvbHVtbiArXG4gICAgICAgICdcXG5DaGFyOiAnICsgcGFyc2VyLmNcbiAgICB9XG4gICAgZXIgPSBuZXcgRXJyb3IoZXIpXG4gICAgcGFyc2VyLmVycm9yID0gZXJcbiAgICBlbWl0KHBhcnNlciwgJ29uZXJyb3InLCBlcilcbiAgICByZXR1cm4gcGFyc2VyXG4gIH1cblxuICBmdW5jdGlvbiBlbmQgKHBhcnNlcikge1xuICAgIGlmIChwYXJzZXIuc2F3Um9vdCAmJiAhcGFyc2VyLmNsb3NlZFJvb3QpIHN0cmljdEZhaWwocGFyc2VyLCAnVW5jbG9zZWQgcm9vdCB0YWcnKVxuICAgIGlmICgocGFyc2VyLnN0YXRlICE9PSBTLkJFR0lOKSAmJlxuICAgICAgKHBhcnNlci5zdGF0ZSAhPT0gUy5CRUdJTl9XSElURVNQQUNFKSAmJlxuICAgICAgKHBhcnNlci5zdGF0ZSAhPT0gUy5URVhUKSkge1xuICAgICAgZXJyb3IocGFyc2VyLCAnVW5leHBlY3RlZCBlbmQnKVxuICAgIH1cbiAgICBjbG9zZVRleHQocGFyc2VyKVxuICAgIHBhcnNlci5jID0gJydcbiAgICBwYXJzZXIuY2xvc2VkID0gdHJ1ZVxuICAgIGVtaXQocGFyc2VyLCAnb25lbmQnKVxuICAgIFNBWFBhcnNlci5jYWxsKHBhcnNlciwgcGFyc2VyLnN0cmljdCwgcGFyc2VyLm9wdClcbiAgICByZXR1cm4gcGFyc2VyXG4gIH1cblxuICBmdW5jdGlvbiBzdHJpY3RGYWlsIChwYXJzZXIsIG1lc3NhZ2UpIHtcbiAgICBpZiAodHlwZW9mIHBhcnNlciAhPT0gJ29iamVjdCcgfHwgIShwYXJzZXIgaW5zdGFuY2VvZiBTQVhQYXJzZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBjYWxsIHRvIHN0cmljdEZhaWwnKVxuICAgIH1cbiAgICBpZiAocGFyc2VyLnN0cmljdCkge1xuICAgICAgZXJyb3IocGFyc2VyLCBtZXNzYWdlKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5ld1RhZyAocGFyc2VyKSB7XG4gICAgaWYgKCFwYXJzZXIuc3RyaWN0KSBwYXJzZXIudGFnTmFtZSA9IHBhcnNlci50YWdOYW1lW3BhcnNlci5sb29zZUNhc2VdKClcbiAgICB2YXIgcGFyZW50ID0gcGFyc2VyLnRhZ3NbcGFyc2VyLnRhZ3MubGVuZ3RoIC0gMV0gfHwgcGFyc2VyXG4gICAgdmFyIHRhZyA9IHBhcnNlci50YWcgPSB7IG5hbWU6IHBhcnNlci50YWdOYW1lLCBhdHRyaWJ1dGVzOiB7fSB9XG5cbiAgICAvLyB3aWxsIGJlIG92ZXJyaWRkZW4gaWYgdGFnIGNvbnRhaWxzIGFuIHhtbG5zPVwiZm9vXCIgb3IgeG1sbnM6Zm9vPVwiYmFyXCJcbiAgICBpZiAocGFyc2VyLm9wdC54bWxucykge1xuICAgICAgdGFnLm5zID0gcGFyZW50Lm5zXG4gICAgfVxuICAgIHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aCA9IDBcbiAgICBlbWl0Tm9kZShwYXJzZXIsICdvbm9wZW50YWdzdGFydCcsIHRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIHFuYW1lIChuYW1lLCBhdHRyaWJ1dGUpIHtcbiAgICB2YXIgaSA9IG5hbWUuaW5kZXhPZignOicpXG4gICAgdmFyIHF1YWxOYW1lID0gaSA8IDAgPyBbICcnLCBuYW1lIF0gOiBuYW1lLnNwbGl0KCc6JylcbiAgICB2YXIgcHJlZml4ID0gcXVhbE5hbWVbMF1cbiAgICB2YXIgbG9jYWwgPSBxdWFsTmFtZVsxXVxuXG4gICAgLy8gPHggXCJ4bWxuc1wiPVwiaHR0cDovL2Zvb1wiPlxuICAgIGlmIChhdHRyaWJ1dGUgJiYgbmFtZSA9PT0gJ3htbG5zJykge1xuICAgICAgcHJlZml4ID0gJ3htbG5zJ1xuICAgICAgbG9jYWwgPSAnJ1xuICAgIH1cblxuICAgIHJldHVybiB7IHByZWZpeDogcHJlZml4LCBsb2NhbDogbG9jYWwgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXR0cmliIChwYXJzZXIpIHtcbiAgICBpZiAoIXBhcnNlci5zdHJpY3QpIHtcbiAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gcGFyc2VyLmF0dHJpYk5hbWVbcGFyc2VyLmxvb3NlQ2FzZV0oKVxuICAgIH1cblxuICAgIGlmIChwYXJzZXIuYXR0cmliTGlzdC5pbmRleE9mKHBhcnNlci5hdHRyaWJOYW1lKSAhPT0gLTEgfHxcbiAgICAgIHBhcnNlci50YWcuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShwYXJzZXIuYXR0cmliTmFtZSkpIHtcbiAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gcGFyc2VyLmF0dHJpYlZhbHVlID0gJydcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChwYXJzZXIub3B0LnhtbG5zKSB7XG4gICAgICB2YXIgcW4gPSBxbmFtZShwYXJzZXIuYXR0cmliTmFtZSwgdHJ1ZSlcbiAgICAgIHZhciBwcmVmaXggPSBxbi5wcmVmaXhcbiAgICAgIHZhciBsb2NhbCA9IHFuLmxvY2FsXG5cbiAgICAgIGlmIChwcmVmaXggPT09ICd4bWxucycpIHtcbiAgICAgICAgLy8gbmFtZXNwYWNlIGJpbmRpbmcgYXR0cmlidXRlLiBwdXNoIHRoZSBiaW5kaW5nIGludG8gc2NvcGVcbiAgICAgICAgaWYgKGxvY2FsID09PSAneG1sJyAmJiBwYXJzZXIuYXR0cmliVmFsdWUgIT09IFhNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlcixcbiAgICAgICAgICAgICd4bWw6IHByZWZpeCBtdXN0IGJlIGJvdW5kIHRvICcgKyBYTUxfTkFNRVNQQUNFICsgJ1xcbicgK1xuICAgICAgICAgICAgJ0FjdHVhbDogJyArIHBhcnNlci5hdHRyaWJWYWx1ZSlcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbCA9PT0gJ3htbG5zJyAmJiBwYXJzZXIuYXR0cmliVmFsdWUgIT09IFhNTE5TX05BTUVTUEFDRSkge1xuICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLFxuICAgICAgICAgICAgJ3htbG5zOiBwcmVmaXggbXVzdCBiZSBib3VuZCB0byAnICsgWE1MTlNfTkFNRVNQQUNFICsgJ1xcbicgK1xuICAgICAgICAgICAgJ0FjdHVhbDogJyArIHBhcnNlci5hdHRyaWJWYWx1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdGFnID0gcGFyc2VyLnRhZ1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJzZXIudGFnc1twYXJzZXIudGFncy5sZW5ndGggLSAxXSB8fCBwYXJzZXJcbiAgICAgICAgICBpZiAodGFnLm5zID09PSBwYXJlbnQubnMpIHtcbiAgICAgICAgICAgIHRhZy5ucyA9IE9iamVjdC5jcmVhdGUocGFyZW50Lm5zKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0YWcubnNbbG9jYWxdID0gcGFyc2VyLmF0dHJpYlZhbHVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZGVmZXIgb25hdHRyaWJ1dGUgZXZlbnRzIHVudGlsIGFsbCBhdHRyaWJ1dGVzIGhhdmUgYmVlbiBzZWVuXG4gICAgICAvLyBzbyBhbnkgbmV3IGJpbmRpbmdzIGNhbiB0YWtlIGVmZmVjdC4gcHJlc2VydmUgYXR0cmlidXRlIG9yZGVyXG4gICAgICAvLyBzbyBkZWZlcnJlZCBldmVudHMgY2FuIGJlIGVtaXR0ZWQgaW4gZG9jdW1lbnQgb3JkZXJcbiAgICAgIHBhcnNlci5hdHRyaWJMaXN0LnB1c2goW3BhcnNlci5hdHRyaWJOYW1lLCBwYXJzZXIuYXR0cmliVmFsdWVdKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbiBub24teG1sbnMgbW9kZSwgd2UgY2FuIGVtaXQgdGhlIGV2ZW50IHJpZ2h0IGF3YXlcbiAgICAgIHBhcnNlci50YWcuYXR0cmlidXRlc1twYXJzZXIuYXR0cmliTmFtZV0gPSBwYXJzZXIuYXR0cmliVmFsdWVcbiAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uYXR0cmlidXRlJywge1xuICAgICAgICBuYW1lOiBwYXJzZXIuYXR0cmliTmFtZSxcbiAgICAgICAgdmFsdWU6IHBhcnNlci5hdHRyaWJWYWx1ZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBwYXJzZXIuYXR0cmliTmFtZSA9IHBhcnNlci5hdHRyaWJWYWx1ZSA9ICcnXG4gIH1cblxuICBmdW5jdGlvbiBvcGVuVGFnIChwYXJzZXIsIHNlbGZDbG9zaW5nKSB7XG4gICAgaWYgKHBhcnNlci5vcHQueG1sbnMpIHtcbiAgICAgIC8vIGVtaXQgbmFtZXNwYWNlIGJpbmRpbmcgZXZlbnRzXG4gICAgICB2YXIgdGFnID0gcGFyc2VyLnRhZ1xuXG4gICAgICAvLyBhZGQgbmFtZXNwYWNlIGluZm8gdG8gdGFnXG4gICAgICB2YXIgcW4gPSBxbmFtZShwYXJzZXIudGFnTmFtZSlcbiAgICAgIHRhZy5wcmVmaXggPSBxbi5wcmVmaXhcbiAgICAgIHRhZy5sb2NhbCA9IHFuLmxvY2FsXG4gICAgICB0YWcudXJpID0gdGFnLm5zW3FuLnByZWZpeF0gfHwgJydcblxuICAgICAgaWYgKHRhZy5wcmVmaXggJiYgIXRhZy51cmkpIHtcbiAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdVbmJvdW5kIG5hbWVzcGFjZSBwcmVmaXg6ICcgK1xuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHBhcnNlci50YWdOYW1lKSlcbiAgICAgICAgdGFnLnVyaSA9IHFuLnByZWZpeFxuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50ID0gcGFyc2VyLnRhZ3NbcGFyc2VyLnRhZ3MubGVuZ3RoIC0gMV0gfHwgcGFyc2VyXG4gICAgICBpZiAodGFnLm5zICYmIHBhcmVudC5ucyAhPT0gdGFnLm5zKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHRhZy5ucykuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29ub3Blbm5hbWVzcGFjZScsIHtcbiAgICAgICAgICAgIHByZWZpeDogcCxcbiAgICAgICAgICAgIHVyaTogdGFnLm5zW3BdXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gaGFuZGxlIGRlZmVycmVkIG9uYXR0cmlidXRlIGV2ZW50c1xuICAgICAgLy8gTm90ZTogZG8gbm90IGFwcGx5IGRlZmF1bHQgbnMgdG8gYXR0cmlidXRlczpcbiAgICAgIC8vICAgaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC1uYW1lcy8jZGVmYXVsdGluZ1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXJzZXIuYXR0cmliTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIG52ID0gcGFyc2VyLmF0dHJpYkxpc3RbaV1cbiAgICAgICAgdmFyIG5hbWUgPSBudlswXVxuICAgICAgICB2YXIgdmFsdWUgPSBudlsxXVxuICAgICAgICB2YXIgcXVhbE5hbWUgPSBxbmFtZShuYW1lLCB0cnVlKVxuICAgICAgICB2YXIgcHJlZml4ID0gcXVhbE5hbWUucHJlZml4XG4gICAgICAgIHZhciBsb2NhbCA9IHF1YWxOYW1lLmxvY2FsXG4gICAgICAgIHZhciB1cmkgPSBwcmVmaXggPT09ICcnID8gJycgOiAodGFnLm5zW3ByZWZpeF0gfHwgJycpXG4gICAgICAgIHZhciBhID0ge1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICAgIGxvY2FsOiBsb2NhbCxcbiAgICAgICAgICB1cmk6IHVyaVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlcmUncyBhbnkgYXR0cmlidXRlcyB3aXRoIGFuIHVuZGVmaW5lZCBuYW1lc3BhY2UsXG4gICAgICAgIC8vIHRoZW4gZmFpbCBvbiB0aGVtIG5vdy5cbiAgICAgICAgaWYgKHByZWZpeCAmJiBwcmVmaXggIT09ICd4bWxucycgJiYgIXVyaSkge1xuICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnVW5ib3VuZCBuYW1lc3BhY2UgcHJlZml4OiAnICtcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHByZWZpeCkpXG4gICAgICAgICAgYS51cmkgPSBwcmVmaXhcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIudGFnLmF0dHJpYnV0ZXNbbmFtZV0gPSBhXG4gICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uYXR0cmlidXRlJywgYSlcbiAgICAgIH1cbiAgICAgIHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aCA9IDBcbiAgICB9XG5cbiAgICBwYXJzZXIudGFnLmlzU2VsZkNsb3NpbmcgPSAhIXNlbGZDbG9zaW5nXG5cbiAgICAvLyBwcm9jZXNzIHRoZSB0YWdcbiAgICBwYXJzZXIuc2F3Um9vdCA9IHRydWVcbiAgICBwYXJzZXIudGFncy5wdXNoKHBhcnNlci50YWcpXG4gICAgZW1pdE5vZGUocGFyc2VyLCAnb25vcGVudGFnJywgcGFyc2VyLnRhZylcbiAgICBpZiAoIXNlbGZDbG9zaW5nKSB7XG4gICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIDxzY3JpcHQ+IGluIG5vbi1zdHJpY3QgbW9kZS5cbiAgICAgIGlmICghcGFyc2VyLm5vc2NyaXB0ICYmIHBhcnNlci50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzY3JpcHQnKSB7XG4gICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgIH1cbiAgICAgIHBhcnNlci50YWcgPSBudWxsXG4gICAgICBwYXJzZXIudGFnTmFtZSA9ICcnXG4gICAgfVxuICAgIHBhcnNlci5hdHRyaWJOYW1lID0gcGFyc2VyLmF0dHJpYlZhbHVlID0gJydcbiAgICBwYXJzZXIuYXR0cmliTGlzdC5sZW5ndGggPSAwXG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZVRhZyAocGFyc2VyKSB7XG4gICAgaWYgKCFwYXJzZXIudGFnTmFtZSkge1xuICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdXZWlyZCBlbXB0eSBjbG9zZSB0YWcuJylcbiAgICAgIHBhcnNlci50ZXh0Tm9kZSArPSAnPC8+J1xuICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAocGFyc2VyLnNjcmlwdCkge1xuICAgICAgaWYgKHBhcnNlci50YWdOYW1lICE9PSAnc2NyaXB0Jykge1xuICAgICAgICBwYXJzZXIuc2NyaXB0ICs9ICc8LycgKyBwYXJzZXIudGFnTmFtZSArICc+J1xuICAgICAgICBwYXJzZXIudGFnTmFtZSA9ICcnXG4gICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25zY3JpcHQnLCBwYXJzZXIuc2NyaXB0KVxuICAgICAgcGFyc2VyLnNjcmlwdCA9ICcnXG4gICAgfVxuXG4gICAgLy8gZmlyc3QgbWFrZSBzdXJlIHRoYXQgdGhlIGNsb3NpbmcgdGFnIGFjdHVhbGx5IGV4aXN0cy5cbiAgICAvLyA8YT48Yj48L2M+PC9iPjwvYT4gd2lsbCBjbG9zZSBldmVyeXRoaW5nLCBvdGhlcndpc2UuXG4gICAgdmFyIHQgPSBwYXJzZXIudGFncy5sZW5ndGhcbiAgICB2YXIgdGFnTmFtZSA9IHBhcnNlci50YWdOYW1lXG4gICAgaWYgKCFwYXJzZXIuc3RyaWN0KSB7XG4gICAgICB0YWdOYW1lID0gdGFnTmFtZVtwYXJzZXIubG9vc2VDYXNlXSgpXG4gICAgfVxuICAgIHZhciBjbG9zZVRvID0gdGFnTmFtZVxuICAgIHdoaWxlICh0LS0pIHtcbiAgICAgIHZhciBjbG9zZSA9IHBhcnNlci50YWdzW3RdXG4gICAgICBpZiAoY2xvc2UubmFtZSAhPT0gY2xvc2VUbykge1xuICAgICAgICAvLyBmYWlsIHRoZSBmaXJzdCB0aW1lIGluIHN0cmljdCBtb2RlXG4gICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnVW5leHBlY3RlZCBjbG9zZSB0YWcnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkaWRuJ3QgZmluZCBpdC4gIHdlIGFscmVhZHkgZmFpbGVkIGZvciBzdHJpY3QsIHNvIGp1c3QgYWJvcnQuXG4gICAgaWYgKHQgPCAwKSB7XG4gICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VubWF0Y2hlZCBjbG9zaW5nIHRhZzogJyArIHBhcnNlci50YWdOYW1lKVxuICAgICAgcGFyc2VyLnRleHROb2RlICs9ICc8LycgKyBwYXJzZXIudGFnTmFtZSArICc+J1xuICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgcGFyc2VyLnRhZ05hbWUgPSB0YWdOYW1lXG4gICAgdmFyIHMgPSBwYXJzZXIudGFncy5sZW5ndGhcbiAgICB3aGlsZSAocy0tID4gdCkge1xuICAgICAgdmFyIHRhZyA9IHBhcnNlci50YWcgPSBwYXJzZXIudGFncy5wb3AoKVxuICAgICAgcGFyc2VyLnRhZ05hbWUgPSBwYXJzZXIudGFnLm5hbWVcbiAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY2xvc2V0YWcnLCBwYXJzZXIudGFnTmFtZSlcblxuICAgICAgdmFyIHggPSB7fVxuICAgICAgZm9yICh2YXIgaSBpbiB0YWcubnMpIHtcbiAgICAgICAgeFtpXSA9IHRhZy5uc1tpXVxuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50ID0gcGFyc2VyLnRhZ3NbcGFyc2VyLnRhZ3MubGVuZ3RoIC0gMV0gfHwgcGFyc2VyXG4gICAgICBpZiAocGFyc2VyLm9wdC54bWxucyAmJiB0YWcubnMgIT09IHBhcmVudC5ucykge1xuICAgICAgICAvLyByZW1vdmUgbmFtZXNwYWNlIGJpbmRpbmdzIGludHJvZHVjZWQgYnkgdGFnXG4gICAgICAgIE9iamVjdC5rZXlzKHRhZy5ucykuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICAgIHZhciBuID0gdGFnLm5zW3BdXG4gICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jbG9zZW5hbWVzcGFjZScsIHsgcHJlZml4OiBwLCB1cmk6IG4gfSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHQgPT09IDApIHBhcnNlci5jbG9zZWRSb290ID0gdHJ1ZVxuICAgIHBhcnNlci50YWdOYW1lID0gcGFyc2VyLmF0dHJpYlZhbHVlID0gcGFyc2VyLmF0dHJpYk5hbWUgPSAnJ1xuICAgIHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aCA9IDBcbiAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW50aXR5IChwYXJzZXIpIHtcbiAgICB2YXIgZW50aXR5ID0gcGFyc2VyLmVudGl0eVxuICAgIHZhciBlbnRpdHlMQyA9IGVudGl0eS50b0xvd2VyQ2FzZSgpXG4gICAgdmFyIG51bVxuICAgIHZhciBudW1TdHIgPSAnJ1xuXG4gICAgaWYgKHBhcnNlci5FTlRJVElFU1tlbnRpdHldKSB7XG4gICAgICByZXR1cm4gcGFyc2VyLkVOVElUSUVTW2VudGl0eV1cbiAgICB9XG4gICAgaWYgKHBhcnNlci5FTlRJVElFU1tlbnRpdHlMQ10pIHtcbiAgICAgIHJldHVybiBwYXJzZXIuRU5USVRJRVNbZW50aXR5TENdXG4gICAgfVxuICAgIGVudGl0eSA9IGVudGl0eUxDXG4gICAgaWYgKGVudGl0eS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgaWYgKGVudGl0eS5jaGFyQXQoMSkgPT09ICd4Jykge1xuICAgICAgICBlbnRpdHkgPSBlbnRpdHkuc2xpY2UoMilcbiAgICAgICAgbnVtID0gcGFyc2VJbnQoZW50aXR5LCAxNilcbiAgICAgICAgbnVtU3RyID0gbnVtLnRvU3RyaW5nKDE2KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW50aXR5ID0gZW50aXR5LnNsaWNlKDEpXG4gICAgICAgIG51bSA9IHBhcnNlSW50KGVudGl0eSwgMTApXG4gICAgICAgIG51bVN0ciA9IG51bS50b1N0cmluZygxMClcbiAgICAgIH1cbiAgICB9XG4gICAgZW50aXR5ID0gZW50aXR5LnJlcGxhY2UoL14wKy8sICcnKVxuICAgIGlmIChpc05hTihudW0pIHx8IG51bVN0ci50b0xvd2VyQ2FzZSgpICE9PSBlbnRpdHkpIHtcbiAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBjaGFyYWN0ZXIgZW50aXR5JylcbiAgICAgIHJldHVybiAnJicgKyBwYXJzZXIuZW50aXR5ICsgJzsnXG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KG51bSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZ2luV2hpdGVTcGFjZSAocGFyc2VyLCBjKSB7XG4gICAgaWYgKGMgPT09ICc8Jykge1xuICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1dBS0FcbiAgICAgIHBhcnNlci5zdGFydFRhZ1Bvc2l0aW9uID0gcGFyc2VyLnBvc2l0aW9uXG4gICAgfSBlbHNlIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAvLyBoYXZlIHRvIHByb2Nlc3MgdGhpcyBhcyBhIHRleHQgbm9kZS5cbiAgICAgIC8vIHdlaXJkLCBidXQgaGFwcGVucy5cbiAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnTm9uLXdoaXRlc3BhY2UgYmVmb3JlIGZpcnN0IHRhZy4nKVxuICAgICAgcGFyc2VyLnRleHROb2RlID0gY1xuICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hhckF0IChjaHVuaywgaSkge1xuICAgIHZhciByZXN1bHQgPSAnJ1xuICAgIGlmIChpIDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgICByZXN1bHQgPSBjaHVuay5jaGFyQXQoaSlcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gd3JpdGUgKGNodW5rKSB7XG4gICAgdmFyIHBhcnNlciA9IHRoaXNcbiAgICBpZiAodGhpcy5lcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5lcnJvclxuICAgIH1cbiAgICBpZiAocGFyc2VyLmNsb3NlZCkge1xuICAgICAgcmV0dXJuIGVycm9yKHBhcnNlcixcbiAgICAgICAgJ0Nhbm5vdCB3cml0ZSBhZnRlciBjbG9zZS4gQXNzaWduIGFuIG9ucmVhZHkgaGFuZGxlci4nKVxuICAgIH1cbiAgICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbmQocGFyc2VyKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnb2JqZWN0Jykge1xuICAgICAgY2h1bmsgPSBjaHVuay50b1N0cmluZygpXG4gICAgfVxuICAgIHZhciBpID0gMFxuICAgIHZhciBjID0gJydcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgYyA9IGNoYXJBdChjaHVuaywgaSsrKVxuICAgICAgcGFyc2VyLmMgPSBjXG5cbiAgICAgIGlmICghYykge1xuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyc2VyLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgICAgcGFyc2VyLnBvc2l0aW9uKytcbiAgICAgICAgaWYgKGMgPT09ICdcXG4nKSB7XG4gICAgICAgICAgcGFyc2VyLmxpbmUrK1xuICAgICAgICAgIHBhcnNlci5jb2x1bW4gPSAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyc2VyLmNvbHVtbisrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwYXJzZXIuc3RhdGUpIHtcbiAgICAgICAgY2FzZSBTLkJFR0lOOlxuICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQkVHSU5fV0hJVEVTUEFDRVxuICAgICAgICAgIGlmIChjID09PSAnXFx1RkVGRicpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJlZ2luV2hpdGVTcGFjZShwYXJzZXIsIGMpXG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQkVHSU5fV0hJVEVTUEFDRTpcbiAgICAgICAgICBiZWdpbldoaXRlU3BhY2UocGFyc2VyLCBjKVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlRFWFQ6XG4gICAgICAgICAgaWYgKHBhcnNlci5zYXdSb290ICYmICFwYXJzZXIuY2xvc2VkUm9vdCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0aSA9IGkgLSAxXG4gICAgICAgICAgICB3aGlsZSAoYyAmJiBjICE9PSAnPCcgJiYgYyAhPT0gJyYnKSB7XG4gICAgICAgICAgICAgIGMgPSBjaGFyQXQoY2h1bmssIGkrKylcbiAgICAgICAgICAgICAgaWYgKGMgJiYgcGFyc2VyLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIucG9zaXRpb24rK1xuICAgICAgICAgICAgICAgIGlmIChjID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgcGFyc2VyLmxpbmUrK1xuICAgICAgICAgICAgICAgICAgcGFyc2VyLmNvbHVtbiA9IDBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGFyc2VyLmNvbHVtbisrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIudGV4dE5vZGUgKz0gY2h1bmsuc3Vic3RyaW5nKHN0YXJ0aSwgaSAtIDEpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjID09PSAnPCcgJiYgIShwYXJzZXIuc2F3Um9vdCAmJiBwYXJzZXIuY2xvc2VkUm9vdCAmJiAhcGFyc2VyLnN0cmljdCkpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9XQUtBXG4gICAgICAgICAgICBwYXJzZXIuc3RhcnRUYWdQb3NpdGlvbiA9IHBhcnNlci5wb3NpdGlvblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWlzV2hpdGVzcGFjZShjKSAmJiAoIXBhcnNlci5zYXdSb290IHx8IHBhcnNlci5jbG9zZWRSb290KSkge1xuICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1RleHQgZGF0YSBvdXRzaWRlIG9mIHJvb3Qgbm9kZS4nKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICcmJykge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRfRU5USVRZXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXJzZXIudGV4dE5vZGUgKz0gY1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5TQ1JJUFQ6XG4gICAgICAgICAgLy8gb25seSBub24tc3RyaWN0XG4gICAgICAgICAgaWYgKGMgPT09ICc8Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFRfRU5ESU5HXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5TQ1JJUFRfRU5ESU5HOlxuICAgICAgICAgIGlmIChjID09PSAnLycpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0xPU0VfVEFHXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gJzwnICsgY1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFRcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuT1BFTl9XQUtBOlxuICAgICAgICAgIC8vIGVpdGhlciBhIC8sID8sICEsIG9yIHRleHQgaXMgY29taW5nIG5leHQuXG4gICAgICAgICAgaWYgKGMgPT09ICchJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TR01MX0RFQ0xcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9ICcnXG4gICAgICAgICAgfSBlbHNlIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIGl0Li4uXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9UQUdcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gY1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNMT1NFX1RBR1xuICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSAnJ1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVFxuICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0TmFtZSA9IHBhcnNlci5wcm9jSW5zdEJvZHkgPSAnJ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VuZW5jb2RlZCA8JylcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIHdhcyBzb21lIHdoaXRlc3BhY2UsIHRoZW4gYWRkIHRoYXQgaW4uXG4gICAgICAgICAgICBpZiAocGFyc2VyLnN0YXJ0VGFnUG9zaXRpb24gKyAxIDwgcGFyc2VyLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIHZhciBwYWQgPSBwYXJzZXIucG9zaXRpb24gLSBwYXJzZXIuc3RhcnRUYWdQb3NpdGlvblxuICAgICAgICAgICAgICBjID0gbmV3IEFycmF5KHBhZCkuam9pbignICcpICsgY1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLnRleHROb2RlICs9ICc8JyArIGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5TR01MX0RFQ0w6XG4gICAgICAgICAgaWYgKChwYXJzZXIuc2dtbERlY2wgKyBjKS50b1VwcGVyQ2FzZSgpID09PSBDREFUQSkge1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25vcGVuY2RhdGEnKVxuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DREFUQVxuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gJydcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSA9ICcnXG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJzZXIuc2dtbERlY2wgKyBjID09PSAnLS0nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlRcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9ICcnXG4gICAgICAgICAgfSBlbHNlIGlmICgocGFyc2VyLnNnbWxEZWNsICsgYykudG9VcHBlckNhc2UoKSA9PT0gRE9DVFlQRSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFXG4gICAgICAgICAgICBpZiAocGFyc2VyLmRvY3R5cGUgfHwgcGFyc2VyLnNhd1Jvb3QpIHtcbiAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsXG4gICAgICAgICAgICAgICAgJ0luYXBwcm9wcmlhdGVseSBsb2NhdGVkIGRvY3R5cGUgZGVjbGFyYXRpb24nKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLmRvY3R5cGUgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gJydcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25zZ21sZGVjbGFyYXRpb24nLCBwYXJzZXIuc2dtbERlY2wpXG4gICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgfSBlbHNlIGlmIChpc1F1b3RlKGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNHTUxfREVDTF9RVU9URURcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCArPSBjXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCArPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlNHTUxfREVDTF9RVU9URUQ6XG4gICAgICAgICAgaWYgKGMgPT09IHBhcnNlci5xKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNHTUxfREVDTFxuICAgICAgICAgICAgcGFyc2VyLnEgPSAnJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgKz0gY1xuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkRPQ1RZUEU6XG4gICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmRvY3R5cGUnLCBwYXJzZXIuZG9jdHlwZSlcbiAgICAgICAgICAgIHBhcnNlci5kb2N0eXBlID0gdHJ1ZSAvLyBqdXN0IHJlbWVtYmVyIHRoYXQgd2Ugc2F3IGl0LlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuZG9jdHlwZSArPSBjXG4gICAgICAgICAgICBpZiAoYyA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRV9EVERcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNRdW90ZShjKSkge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEVfUVVPVEVEXG4gICAgICAgICAgICAgIHBhcnNlci5xID0gY1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5ET0NUWVBFX1FVT1RFRDpcbiAgICAgICAgICBwYXJzZXIuZG9jdHlwZSArPSBjXG4gICAgICAgICAgaWYgKGMgPT09IHBhcnNlci5xKSB7XG4gICAgICAgICAgICBwYXJzZXIucSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEVcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuRE9DVFlQRV9EVEQ6XG4gICAgICAgICAgcGFyc2VyLmRvY3R5cGUgKz0gY1xuICAgICAgICAgIGlmIChjID09PSAnXScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNRdW90ZShjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFX0RURF9RVU9URURcbiAgICAgICAgICAgIHBhcnNlci5xID0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5ET0NUWVBFX0RURF9RVU9URUQ6XG4gICAgICAgICAgcGFyc2VyLmRvY3R5cGUgKz0gY1xuICAgICAgICAgIGlmIChjID09PSBwYXJzZXIucSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFX0RURFxuICAgICAgICAgICAgcGFyc2VyLnEgPSAnJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DT01NRU5UOlxuICAgICAgICAgIGlmIChjID09PSAnLScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVF9FTkRJTkdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgKz0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DT01NRU5UX0VORElORzpcbiAgICAgICAgICBpZiAoYyA9PT0gJy0nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlRfRU5ERURcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ID0gdGV4dG9wdHMocGFyc2VyLm9wdCwgcGFyc2VyLmNvbW1lbnQpXG4gICAgICAgICAgICBpZiAocGFyc2VyLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jb21tZW50JywgcGFyc2VyLmNvbW1lbnQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIuY29tbWVudCA9ICcnXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ICs9ICctJyArIGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DT01NRU5UX0VOREVEOlxuICAgICAgICAgIGlmIChjICE9PSAnPicpIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnTWFsZm9ybWVkIGNvbW1lbnQnKVxuICAgICAgICAgICAgLy8gYWxsb3cgPCEtLSBibGFoIC0tIGJsb28gLS0+IGluIG5vbi1zdHJpY3QgbW9kZSxcbiAgICAgICAgICAgIC8vIHdoaWNoIGlzIGEgY29tbWVudCBvZiBcIiBibGFoIC0tIGJsb28gXCJcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ICs9ICctLScgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlRcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNEQVRBOlxuICAgICAgICAgIGlmIChjID09PSAnXScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0RBVEFfRU5ESU5HXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNEQVRBX0VORElORzpcbiAgICAgICAgICBpZiAoYyA9PT0gJ10nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBX0VORElOR18yXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSAnXScgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNEQVRBX0VORElOR18yOlxuICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIGlmIChwYXJzZXIuY2RhdGEpIHtcbiAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jZGF0YScsIHBhcnNlci5jZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY2xvc2VjZGF0YScpXG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnXScpIHtcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSAnXSdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLmNkYXRhICs9ICddXScgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlBST0NfSU5TVDpcbiAgICAgICAgICBpZiAoYyA9PT0gJz8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVF9FTkRJTkdcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1RfQk9EWVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIucHJvY0luc3ROYW1lICs9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuUFJPQ19JTlNUX0JPRFk6XG4gICAgICAgICAgaWYgKCFwYXJzZXIucHJvY0luc3RCb2R5ICYmIGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc/Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1RfRU5ESU5HXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5wcm9jSW5zdEJvZHkgKz0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5QUk9DX0lOU1RfRU5ESU5HOlxuICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29ucHJvY2Vzc2luZ2luc3RydWN0aW9uJywge1xuICAgICAgICAgICAgICBuYW1lOiBwYXJzZXIucHJvY0luc3ROYW1lLFxuICAgICAgICAgICAgICBib2R5OiBwYXJzZXIucHJvY0luc3RCb2R5XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0TmFtZSA9IHBhcnNlci5wcm9jSW5zdEJvZHkgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5wcm9jSW5zdEJvZHkgKz0gJz8nICsgY1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1RfQk9EWVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5PUEVOX1RBRzpcbiAgICAgICAgICBpZiAoaXNNYXRjaChuYW1lQm9keSwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lICs9IGNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3VGFnKHBhcnNlcilcbiAgICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICcvJykge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fVEFHX1NMQVNIXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIWlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBjaGFyYWN0ZXIgaW4gdGFnIG5hbWUnKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLk9QRU5fVEFHX1NMQVNIOlxuICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyLCB0cnVlKVxuICAgICAgICAgICAgY2xvc2VUYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ZvcndhcmQtc2xhc2ggaW4gb3BlbmluZyB0YWcgbm90IGZvbGxvd2VkIGJ5ID4nKVxuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQVRUUklCOlxuICAgICAgICAgIC8vIGhhdmVuJ3QgcmVhZCB0aGUgYXR0cmlidXRlIG5hbWUgeWV0LlxuICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fVEFHX1NMQVNIXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gY1xuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX05BTUVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lJylcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQVRUUklCX05BTUU6XG4gICAgICAgICAgaWYgKGMgPT09ICc9Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdBdHRyaWJ1dGUgd2l0aG91dCB2YWx1ZScpXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgPSBwYXJzZXIuYXR0cmliTmFtZVxuICAgICAgICAgICAgYXR0cmliKHBhcnNlcilcbiAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9OQU1FX1NBV19XSElURVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNYXRjaChuYW1lQm9keSwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lICs9IGNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lJylcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQVRUUklCX05BTUVfU0FXX1dISVRFOlxuICAgICAgICAgIGlmIChjID09PSAnPScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFXG4gICAgICAgICAgfSBlbHNlIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnQXR0cmlidXRlIHdpdGhvdXQgdmFsdWUnKVxuICAgICAgICAgICAgcGFyc2VyLnRhZy5hdHRyaWJ1dGVzW3BhcnNlci5hdHRyaWJOYW1lXSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgPSAnJ1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25hdHRyaWJ1dGUnLCB7XG4gICAgICAgICAgICAgIG5hbWU6IHBhcnNlci5hdHRyaWJOYW1lLFxuICAgICAgICAgICAgICB2YWx1ZTogJydcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9ICcnXG4gICAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBjXG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX05BTUVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZScpXG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRTpcbiAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNRdW90ZShjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnEgPSBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9RVU9URURcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdVbnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUnKVxuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVfVU5RVU9URURcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX1FVT1RFRDpcbiAgICAgICAgICBpZiAoYyAhPT0gcGFyc2VyLnEpIHtcbiAgICAgICAgICAgIGlmIChjID09PSAnJicpIHtcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVfRU5USVRZX1FcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSArPSBjXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRyaWIocGFyc2VyKVxuICAgICAgICAgIHBhcnNlci5xID0gJydcbiAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9DTE9TRURcbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfQ0xPU0VEOlxuICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fVEFHX1NMQVNIXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnTm8gd2hpdGVzcGFjZSBiZXR3ZWVuIGF0dHJpYnV0ZXMnKVxuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBjXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfTkFNRVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWUnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfVU5RVU9URUQ6XG4gICAgICAgICAgaWYgKCFpc0F0dHJpYkVuZChjKSkge1xuICAgICAgICAgICAgaWYgKGMgPT09ICcmJykge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfVVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlICs9IGNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHJpYihwYXJzZXIpXG4gICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNMT1NFX1RBRzpcbiAgICAgICAgICBpZiAoIXBhcnNlci50YWdOYW1lKSB7XG4gICAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vdE1hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgICAgaWYgKHBhcnNlci5zY3JpcHQpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc2NyaXB0ICs9ICc8LycgKyBjXG4gICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFRcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgdGFnbmFtZSBpbiBjbG9zaW5nIHRhZy4nKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXJzZXIudGFnTmFtZSA9IGNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgY2xvc2VUYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNYXRjaChuYW1lQm9keSwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lICs9IGNcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlci5zY3JpcHQpIHtcbiAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gJzwvJyArIHBhcnNlci50YWdOYW1lXG4gICAgICAgICAgICBwYXJzZXIudGFnTmFtZSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgdGFnbmFtZSBpbiBjbG9zaW5nIHRhZycpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNMT1NFX1RBR19TQVdfV0hJVEVcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQ0xPU0VfVEFHX1NBV19XSElURTpcbiAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBjbG9zZVRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBjaGFyYWN0ZXJzIGluIGNsb3NpbmcgdGFnJylcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuVEVYVF9FTlRJVFk6XG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfRU5USVRZX1E6XG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfRU5USVRZX1U6XG4gICAgICAgICAgdmFyIHJldHVyblN0YXRlXG4gICAgICAgICAgdmFyIGJ1ZmZlclxuICAgICAgICAgIHN3aXRjaCAocGFyc2VyLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFMuVEVYVF9FTlRJVFk6XG4gICAgICAgICAgICAgIHJldHVyblN0YXRlID0gUy5URVhUXG4gICAgICAgICAgICAgIGJ1ZmZlciA9ICd0ZXh0Tm9kZSdcbiAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfUTpcbiAgICAgICAgICAgICAgcmV0dXJuU3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9RVU9URURcbiAgICAgICAgICAgICAgYnVmZmVyID0gJ2F0dHJpYlZhbHVlJ1xuICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX0VOVElUWV9VOlxuICAgICAgICAgICAgICByZXR1cm5TdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX1VOUVVPVEVEXG4gICAgICAgICAgICAgIGJ1ZmZlciA9ICdhdHRyaWJWYWx1ZSdcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYyA9PT0gJzsnKSB7XG4gICAgICAgICAgICBwYXJzZXJbYnVmZmVyXSArPSBwYXJzZUVudGl0eShwYXJzZXIpXG4gICAgICAgICAgICBwYXJzZXIuZW50aXR5ID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IHJldHVyblN0YXRlXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKHBhcnNlci5lbnRpdHkubGVuZ3RoID8gZW50aXR5Qm9keSA6IGVudGl0eVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLmVudGl0eSArPSBjXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBjaGFyYWN0ZXIgaW4gZW50aXR5IG5hbWUnKVxuICAgICAgICAgICAgcGFyc2VyW2J1ZmZlcl0gKz0gJyYnICsgcGFyc2VyLmVudGl0eSArIGNcbiAgICAgICAgICAgIHBhcnNlci5lbnRpdHkgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gcmV0dXJuU3RhdGVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHBhcnNlciwgJ1Vua25vd24gc3RhdGU6ICcgKyBwYXJzZXIuc3RhdGUpXG4gICAgICB9XG4gICAgfSAvLyB3aGlsZVxuXG4gICAgaWYgKHBhcnNlci5wb3NpdGlvbiA+PSBwYXJzZXIuYnVmZmVyQ2hlY2tQb3NpdGlvbikge1xuICAgICAgY2hlY2tCdWZmZXJMZW5ndGgocGFyc2VyKVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VyXG4gIH1cblxuICAvKiEgaHR0cDovL210aHMuYmUvZnJvbWNvZGVwb2ludCB2MC4xLjAgYnkgQG1hdGhpYXMgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKCFTdHJpbmcuZnJvbUNvZGVQb2ludCkge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZVxuICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vclxuICAgICAgdmFyIGZyb21Db2RlUG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBNQVhfU0laRSA9IDB4NDAwMFxuICAgICAgICB2YXIgY29kZVVuaXRzID0gW11cbiAgICAgICAgdmFyIGhpZ2hTdXJyb2dhdGVcbiAgICAgICAgdmFyIGxvd1N1cnJvZ2F0ZVxuICAgICAgICB2YXIgaW5kZXggPSAtMVxuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiAnJ1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSAnJ1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSBOdW1iZXIoYXJndW1lbnRzW2luZGV4XSlcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhaXNGaW5pdGUoY29kZVBvaW50KSB8fCAvLyBgTmFOYCwgYCtJbmZpbml0eWAsIG9yIGAtSW5maW5pdHlgXG4gICAgICAgICAgICBjb2RlUG9pbnQgPCAwIHx8IC8vIG5vdCBhIHZhbGlkIFVuaWNvZGUgY29kZSBwb2ludFxuICAgICAgICAgICAgY29kZVBvaW50ID4gMHgxMEZGRkYgfHwgLy8gbm90IGEgdmFsaWQgVW5pY29kZSBjb2RlIHBvaW50XG4gICAgICAgICAgICBmbG9vcihjb2RlUG9pbnQpICE9PSBjb2RlUG9pbnQgLy8gbm90IGFuIGludGVnZXJcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludDogJyArIGNvZGVQb2ludClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweEZGRkYpIHsgLy8gQk1QIGNvZGUgcG9pbnRcbiAgICAgICAgICAgIGNvZGVVbml0cy5wdXNoKGNvZGVQb2ludClcbiAgICAgICAgICB9IGVsc2UgeyAvLyBBc3RyYWwgY29kZSBwb2ludDsgc3BsaXQgaW4gc3Vycm9nYXRlIGhhbHZlc1xuICAgICAgICAgICAgLy8gaHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcbiAgICAgICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICAgICAgICBoaWdoU3Vycm9nYXRlID0gKGNvZGVQb2ludCA+PiAxMCkgKyAweEQ4MDBcbiAgICAgICAgICAgIGxvd1N1cnJvZ2F0ZSA9IChjb2RlUG9pbnQgJSAweDQwMCkgKyAweERDMDBcbiAgICAgICAgICAgIGNvZGVVbml0cy5wdXNoKGhpZ2hTdXJyb2dhdGUsIGxvd1N1cnJvZ2F0ZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZGV4ICsgMSA9PT0gbGVuZ3RoIHx8IGNvZGVVbml0cy5sZW5ndGggPiBNQVhfU0laRSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZS5hcHBseShudWxsLCBjb2RlVW5pdHMpXG4gICAgICAgICAgICBjb2RlVW5pdHMubGVuZ3RoID0gMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyaW5nLCAnZnJvbUNvZGVQb2ludCcsIHtcbiAgICAgICAgICB2YWx1ZTogZnJvbUNvZGVQb2ludCxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFN0cmluZy5mcm9tQ29kZVBvaW50ID0gZnJvbUNvZGVQb2ludFxuICAgICAgfVxuICAgIH0oKSlcbiAgfVxufSkodHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gdGhpcy5zYXggPSB7fSA6IGV4cG9ydHMpXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VYbWwgPSBleHBvcnRzLlhFbGVtZW50ID0gdm9pZCAwO1xuY29uc3Qgc2F4ID0gcmVxdWlyZShcInNheFwiKTtcbmNvbnN0IGluZGV4XzEgPSByZXF1aXJlKFwiLi9pbmRleFwiKTtcbmNsYXNzIFhFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBudWxsO1xuICAgICAgICB0aGlzLmlzQ0RhdGEgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IG51bGw7XG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIGluZGV4XzEubmV3RXJyb3IpKFwiRWxlbWVudCBuYW1lIGNhbm5vdCBiZSBlbXB0eVwiLCBcIkVSUl9YTUxfRUxFTUVOVF9OQU1FX0VNUFRZXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNWYWxpZE5hbWUobmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCBpbmRleF8xLm5ld0Vycm9yKShgSW52YWxpZCBlbGVtZW50IG5hbWU6ICR7bmFtZX1gLCBcIkVSUl9YTUxfRUxFTUVOVF9JTlZBTElEX05BTUVcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXR0cmlidXRlKG5hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5hdHRyaWJ1dGVzID09PSBudWxsID8gbnVsbCA6IHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgaW5kZXhfMS5uZXdFcnJvcikoYE5vIGF0dHJpYnV0ZSBcIiR7bmFtZX1cImAsIFwiRVJSX1hNTF9NSVNTRURfQVRUUklCVVRFXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlbW92ZUF0dHJpYnV0ZShuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudChuYW1lLCBpZ25vcmVDYXNlID0gZmFsc2UsIGVycm9ySWZNaXNzZWQgPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZWxlbWVudE9yTnVsbChuYW1lLCBpZ25vcmVDYXNlKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIGluZGV4XzEubmV3RXJyb3IpKGVycm9ySWZNaXNzZWQgfHwgYE5vIGVsZW1lbnQgXCIke25hbWV9XCJgLCBcIkVSUl9YTUxfTUlTU0VEX0VMRU1FTlRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZWxlbWVudE9yTnVsbChuYW1lLCBpZ25vcmVDYXNlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLmVsZW1lbnRzKSB7XG4gICAgICAgICAgICBpZiAoaXNOYW1lRXF1YWxzKGVsZW1lbnQsIG5hbWUsIGlnbm9yZUNhc2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldEVsZW1lbnRzKG5hbWUsIGlnbm9yZUNhc2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzLmZpbHRlcihpdCA9PiBpc05hbWVFcXVhbHMoaXQsIG5hbWUsIGlnbm9yZUNhc2UpKTtcbiAgICB9XG4gICAgZWxlbWVudFZhbHVlT3JFbXB0eShuYW1lLCBpZ25vcmVDYXNlID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudE9yTnVsbChuYW1lLCBpZ25vcmVDYXNlKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQgPT09IG51bGwgPyBcIlwiIDogZWxlbWVudC52YWx1ZTtcbiAgICB9XG59XG5leHBvcnRzLlhFbGVtZW50ID0gWEVsZW1lbnQ7XG5jb25zdCBOQU1FX1JFR19FWFAgPSBuZXcgUmVnRXhwKC9eW0EtWmEtel9dWzpBLVphLXowLTlfLV0qJC9pKTtcbmZ1bmN0aW9uIGlzVmFsaWROYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gTkFNRV9SRUdfRVhQLnRlc3QobmFtZSk7XG59XG5mdW5jdGlvbiBpc05hbWVFcXVhbHMoZWxlbWVudCwgbmFtZSwgaWdub3JlQ2FzZSkge1xuICAgIGNvbnN0IGVsZW1lbnROYW1lID0gZWxlbWVudC5uYW1lO1xuICAgIHJldHVybiBlbGVtZW50TmFtZSA9PT0gbmFtZSB8fCAoaWdub3JlQ2FzZSA9PT0gdHJ1ZSAmJiBlbGVtZW50TmFtZS5sZW5ndGggPT09IG5hbWUubGVuZ3RoICYmIGVsZW1lbnROYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKSk7XG59XG5mdW5jdGlvbiBwYXJzZVhtbChkYXRhKSB7XG4gICAgbGV0IHJvb3RFbGVtZW50ID0gbnVsbDtcbiAgICBjb25zdCBwYXJzZXIgPSBzYXgucGFyc2VyKHRydWUsIHt9KTtcbiAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgIHBhcnNlci5vbm9wZW50YWcgPSBzYXhFbGVtZW50ID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IG5ldyBYRWxlbWVudChzYXhFbGVtZW50Lm5hbWUpO1xuICAgICAgICBlbGVtZW50LmF0dHJpYnV0ZXMgPSBzYXhFbGVtZW50LmF0dHJpYnV0ZXM7XG4gICAgICAgIGlmIChyb290RWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcm9vdEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAocGFyZW50LmVsZW1lbnRzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuZWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudC5lbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgfTtcbiAgICBwYXJzZXIub25jbG9zZXRhZyA9ICgpID0+IHtcbiAgICAgICAgZWxlbWVudHMucG9wKCk7XG4gICAgfTtcbiAgICBwYXJzZXIub250ZXh0ID0gdGV4dCA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXS52YWx1ZSA9IHRleHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHBhcnNlci5vbmNkYXRhID0gY2RhdGEgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGVsZW1lbnQudmFsdWUgPSBjZGF0YTtcbiAgICAgICAgZWxlbWVudC5pc0NEYXRhID0gdHJ1ZTtcbiAgICB9O1xuICAgIHBhcnNlci5vbmVycm9yID0gZXJyID0+IHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH07XG4gICAgcGFyc2VyLndyaXRlKGRhdGEpO1xuICAgIHJldHVybiByb290RWxlbWVudDtcbn1cbmV4cG9ydHMucGFyc2VYbWwgPSBwYXJzZVhtbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXhtbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubmV3RXJyb3IgPSBleHBvcnRzLmFzQXJyYXkgPSBleHBvcnRzLkNVUlJFTlRfQVBQX1BBQ0tBR0VfRklMRV9OQU1FID0gZXhwb3J0cy5DVVJSRU5UX0FQUF9JTlNUQUxMRVJfRklMRV9OQU1FID0gZXhwb3J0cy5YRWxlbWVudCA9IGV4cG9ydHMucGFyc2VYbWwgPSBleHBvcnRzLlByb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0gPSBleHBvcnRzLlVVSUQgPSBleHBvcnRzLnBhcnNlRG4gPSBleHBvcnRzLmdpdGh1YlVybCA9IGV4cG9ydHMuZ2V0UzNMaWtlUHJvdmlkZXJCYXNlVXJsID0gZXhwb3J0cy5jb25maWd1cmVSZXF1ZXN0VXJsID0gZXhwb3J0cy5wYXJzZUpzb24gPSBleHBvcnRzLnNhZmVTdHJpbmdpZnlKc29uID0gZXhwb3J0cy5jb25maWd1cmVSZXF1ZXN0T3B0aW9uc0Zyb21VcmwgPSBleHBvcnRzLmNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zID0gZXhwb3J0cy5zYWZlR2V0SGVhZGVyID0gZXhwb3J0cy5EaWdlc3RUcmFuc2Zvcm0gPSBleHBvcnRzLkh0dHBFeGVjdXRvciA9IGV4cG9ydHMuY3JlYXRlSHR0cEVycm9yID0gZXhwb3J0cy5IdHRwRXJyb3IgPSBleHBvcnRzLkNhbmNlbGxhdGlvbkVycm9yID0gZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlbiA9IHZvaWQgMDtcbnZhciBDYW5jZWxsYXRpb25Ub2tlbl8xID0gcmVxdWlyZShcIi4vQ2FuY2VsbGF0aW9uVG9rZW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25Ub2tlblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ2FuY2VsbGF0aW9uVG9rZW5fMS5DYW5jZWxsYXRpb25Ub2tlbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbmNlbGxhdGlvbkVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDYW5jZWxsYXRpb25Ub2tlbl8xLkNhbmNlbGxhdGlvbkVycm9yOyB9IH0pO1xudmFyIGh0dHBFeGVjdXRvcl8xID0gcmVxdWlyZShcIi4vaHR0cEV4ZWN1dG9yXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSHR0cEVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBodHRwRXhlY3V0b3JfMS5IdHRwRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVIdHRwRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGh0dHBFeGVjdXRvcl8xLmNyZWF0ZUh0dHBFcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkh0dHBFeGVjdXRvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaHR0cEV4ZWN1dG9yXzEuSHR0cEV4ZWN1dG9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlnZXN0VHJhbnNmb3JtXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBodHRwRXhlY3V0b3JfMS5EaWdlc3RUcmFuc2Zvcm07IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzYWZlR2V0SGVhZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBodHRwRXhlY3V0b3JfMS5zYWZlR2V0SGVhZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uZmlndXJlUmVxdWVzdE9wdGlvbnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGh0dHBFeGVjdXRvcl8xLmNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uZmlndXJlUmVxdWVzdE9wdGlvbnNGcm9tVXJsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBodHRwRXhlY3V0b3JfMS5jb25maWd1cmVSZXF1ZXN0T3B0aW9uc0Zyb21Vcmw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzYWZlU3RyaW5naWZ5SnNvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaHR0cEV4ZWN1dG9yXzEuc2FmZVN0cmluZ2lmeUpzb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZUpzb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGh0dHBFeGVjdXRvcl8xLnBhcnNlSnNvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbmZpZ3VyZVJlcXVlc3RVcmxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGh0dHBFeGVjdXRvcl8xLmNvbmZpZ3VyZVJlcXVlc3RVcmw7IH0gfSk7XG52YXIgcHVibGlzaE9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuL3B1Ymxpc2hPcHRpb25zXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0UzNMaWtlUHJvdmlkZXJCYXNlVXJsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwdWJsaXNoT3B0aW9uc18xLmdldFMzTGlrZVByb3ZpZGVyQmFzZVVybDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdpdGh1YlVybFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHVibGlzaE9wdGlvbnNfMS5naXRodWJVcmw7IH0gfSk7XG52YXIgcmZjMjI1M1BhcnNlcl8xID0gcmVxdWlyZShcIi4vcmZjMjI1M1BhcnNlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlRG5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJmYzIyNTNQYXJzZXJfMS5wYXJzZURuOyB9IH0pO1xudmFyIHV1aWRfMSA9IHJlcXVpcmUoXCIuL3V1aWRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVVUlEXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dWlkXzEuVVVJRDsgfSB9KTtcbnZhciBQcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtXzEgPSByZXF1aXJlKFwiLi9Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybV8xLlByb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm07IH0gfSk7XG52YXIgeG1sXzEgPSByZXF1aXJlKFwiLi94bWxcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZVhtbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geG1sXzEucGFyc2VYbWw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJYRWxlbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geG1sXzEuWEVsZW1lbnQ7IH0gfSk7XG4vLyBuc2lzXG5leHBvcnRzLkNVUlJFTlRfQVBQX0lOU1RBTExFUl9GSUxFX05BTUUgPSBcImluc3RhbGxlci5leGVcIjtcbi8vIG5zaXMtd2ViXG5leHBvcnRzLkNVUlJFTlRfQVBQX1BBQ0tBR0VfRklMRV9OQU1FID0gXCJwYWNrYWdlLjd6XCI7XG5mdW5jdGlvbiBhc0FycmF5KHYpIHtcbiAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbdl07XG4gICAgfVxufVxuZXhwb3J0cy5hc0FycmF5ID0gYXNBcnJheTtcbmZ1bmN0aW9uIG5ld0Vycm9yKG1lc3NhZ2UsIGNvZGUpIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgICByZXR1cm4gZXJyb3I7XG59XG5leHBvcnRzLm5ld0Vycm9yID0gbmV3RXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCdcbi8vIFRoaXMgaXMgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ub3JtYWxpemUvbXpcbi8vIENvcHlyaWdodCAoYykgMjAxNC0yMDE2IEpvbmF0aGFuIE9uZyBtZUBqb25nbGViZXJyeS5jb20gYW5kIENvbnRyaWJ1dG9yc1xuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5cbmNvbnN0IGFwaSA9IFtcbiAgJ2FjY2VzcycsXG4gICdhcHBlbmRGaWxlJyxcbiAgJ2NobW9kJyxcbiAgJ2Nob3duJyxcbiAgJ2Nsb3NlJyxcbiAgJ2NvcHlGaWxlJyxcbiAgJ2ZjaG1vZCcsXG4gICdmY2hvd24nLFxuICAnZmRhdGFzeW5jJyxcbiAgJ2ZzdGF0JyxcbiAgJ2ZzeW5jJyxcbiAgJ2Z0cnVuY2F0ZScsXG4gICdmdXRpbWVzJyxcbiAgJ2xjaG1vZCcsXG4gICdsY2hvd24nLFxuICAnbGluaycsXG4gICdsc3RhdCcsXG4gICdta2RpcicsXG4gICdta2R0ZW1wJyxcbiAgJ29wZW4nLFxuICAnb3BlbmRpcicsXG4gICdyZWFkZGlyJyxcbiAgJ3JlYWRGaWxlJyxcbiAgJ3JlYWRsaW5rJyxcbiAgJ3JlYWxwYXRoJyxcbiAgJ3JlbmFtZScsXG4gICdybScsXG4gICdybWRpcicsXG4gICdzdGF0JyxcbiAgJ3N5bWxpbmsnLFxuICAndHJ1bmNhdGUnLFxuICAndW5saW5rJyxcbiAgJ3V0aW1lcycsXG4gICd3cml0ZUZpbGUnXG5dLmZpbHRlcihrZXkgPT4ge1xuICAvLyBTb21lIGNvbW1hbmRzIGFyZSBub3QgYXZhaWxhYmxlIG9uIHNvbWUgc3lzdGVtcy4gRXg6XG4gIC8vIGZzLm9wZW5kaXIgd2FzIGFkZGVkIGluIE5vZGUuanMgdjEyLjEyLjBcbiAgLy8gZnMucm0gd2FzIGFkZGVkIGluIE5vZGUuanMgdjE0LjE0LjBcbiAgLy8gZnMubGNob3duIGlzIG5vdCBhdmFpbGFibGUgb24gYXQgbGVhc3Qgc29tZSBMaW51eFxuICByZXR1cm4gdHlwZW9mIGZzW2tleV0gPT09ICdmdW5jdGlvbidcbn0pXG5cbi8vIEV4cG9ydCBjbG9uZWQgZnM6XG5PYmplY3QuYXNzaWduKGV4cG9ydHMsIGZzKVxuXG4vLyBVbml2ZXJzYWxpZnkgYXN5bmMgbWV0aG9kczpcbmFwaS5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gIGV4cG9ydHNbbWV0aG9kXSA9IHUoZnNbbWV0aG9kXSlcbn0pXG5cbi8vIFdlIGRpZmZlciBmcm9tIG16L2ZzIGluIHRoYXQgd2Ugc3RpbGwgc2hpcCB0aGUgb2xkLCBicm9rZW4sIGZzLmV4aXN0cygpXG4vLyBzaW5jZSB3ZSBhcmUgYSBkcm9wLWluIHJlcGxhY2VtZW50IGZvciB0aGUgbmF0aXZlIG1vZHVsZVxuZXhwb3J0cy5leGlzdHMgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnMuZXhpc3RzKGZpbGVuYW1lLCBjYWxsYmFjaylcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgcmV0dXJuIGZzLmV4aXN0cyhmaWxlbmFtZSwgcmVzb2x2ZSlcbiAgfSlcbn1cblxuLy8gZnMucmVhZCgpLCBmcy53cml0ZSgpLCAmIGZzLndyaXRldigpIG5lZWQgc3BlY2lhbCB0cmVhdG1lbnQgZHVlIHRvIG11bHRpcGxlIGNhbGxiYWNrIGFyZ3NcblxuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmcy5yZWFkKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spXG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmcy5yZWFkKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgKGVyciwgYnl0ZXNSZWFkLCBidWZmZXIpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgcmVzb2x2ZSh7IGJ5dGVzUmVhZCwgYnVmZmVyIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuLy8gRnVuY3Rpb24gc2lnbmF0dXJlIGNhbiBiZVxuLy8gZnMud3JpdGUoZmQsIGJ1ZmZlclssIG9mZnNldFssIGxlbmd0aFssIHBvc2l0aW9uXV1dLCBjYWxsYmFjaylcbi8vIE9SXG4vLyBmcy53cml0ZShmZCwgc3RyaW5nWywgcG9zaXRpb25bLCBlbmNvZGluZ11dLCBjYWxsYmFjaylcbi8vIFdlIG5lZWQgdG8gaGFuZGxlIGJvdGggY2FzZXMsIHNvIHdlIHVzZSAuLi5hcmdzXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGZkLCBidWZmZXIsIC4uLmFyZ3MpIHtcbiAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnMud3JpdGUoZmQsIGJ1ZmZlciwgLi4uYXJncylcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnMud3JpdGUoZmQsIGJ1ZmZlciwgLi4uYXJncywgKGVyciwgYnl0ZXNXcml0dGVuLCBidWZmZXIpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgcmVzb2x2ZSh7IGJ5dGVzV3JpdHRlbiwgYnVmZmVyIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuLy8gZnMud3JpdGV2IG9ubHkgYXZhaWxhYmxlIGluIE5vZGUgdjEyLjkuMCtcbmlmICh0eXBlb2YgZnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIEZ1bmN0aW9uIHNpZ25hdHVyZSBpc1xuICAvLyBzLndyaXRldihmZCwgYnVmZmVyc1ssIHBvc2l0aW9uXSwgY2FsbGJhY2spXG4gIC8vIFdlIG5lZWQgdG8gaGFuZGxlIHRoZSBvcHRpb25hbCBhcmcsIHNvIHdlIHVzZSAuLi5hcmdzXG4gIGV4cG9ydHMud3JpdGV2ID0gZnVuY3Rpb24gKGZkLCBidWZmZXJzLCAuLi5hcmdzKSB7XG4gICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBmcy53cml0ZXYoZmQsIGJ1ZmZlcnMsIC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGZzLndyaXRldihmZCwgYnVmZmVycywgLi4uYXJncywgKGVyciwgYnl0ZXNXcml0dGVuLCBidWZmZXJzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgICByZXNvbHZlKHsgYnl0ZXNXcml0dGVuLCBidWZmZXJzIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cblxuLy8gZnMucmVhbHBhdGgubmF0aXZlIHNvbWV0aW1lcyBub3QgYXZhaWxhYmxlIGlmIGZzIGlzIG1vbmtleS1wYXRjaGVkXG5pZiAodHlwZW9mIGZzLnJlYWxwYXRoLm5hdGl2ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICBleHBvcnRzLnJlYWxwYXRoLm5hdGl2ZSA9IHUoZnMucmVhbHBhdGgubmF0aXZlKVxufSBlbHNlIHtcbiAgcHJvY2Vzcy5lbWl0V2FybmluZyhcbiAgICAnZnMucmVhbHBhdGgubmF0aXZlIGlzIG5vdCBhIGZ1bmN0aW9uLiBJcyBmcyBiZWluZyBtb25rZXktcGF0Y2hlZD8nLFxuICAgICdXYXJuaW5nJywgJ2ZzLWV4dHJhLVdBUk4wMDAzJ1xuICApXG59XG4iLCIvLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9tYWtlLWRpclxuLy8gQ29weXJpZ2h0IChjKSBTaW5kcmUgU29yaHVzIDxzaW5kcmVzb3JodXNAZ21haWwuY29tPiAoc2luZHJlc29yaHVzLmNvbSlcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuJ3VzZSBzdHJpY3QnXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvODk4N1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2xpYnV2L2xpYnV2L3B1bGwvMTA4OFxubW9kdWxlLmV4cG9ydHMuY2hlY2tQYXRoID0gZnVuY3Rpb24gY2hlY2tQYXRoIChwdGgpIHtcbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICBjb25zdCBwYXRoSGFzSW52YWxpZFdpbkNoYXJhY3RlcnMgPSAvWzw+OlwifD8qXS8udGVzdChwdGgucmVwbGFjZShwYXRoLnBhcnNlKHB0aCkucm9vdCwgJycpKVxuXG4gICAgaWYgKHBhdGhIYXNJbnZhbGlkV2luQ2hhcmFjdGVycykge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYFBhdGggY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzOiAke3B0aH1gKVxuICAgICAgZXJyb3IuY29kZSA9ICdFSU5WQUwnXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL2ZzJylcbmNvbnN0IHsgY2hlY2tQYXRoIH0gPSByZXF1aXJlKCcuL3V0aWxzJylcblxuY29uc3QgZ2V0TW9kZSA9IG9wdGlvbnMgPT4ge1xuICBjb25zdCBkZWZhdWx0cyA9IHsgbW9kZTogMG83NzcgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSByZXR1cm4gb3B0aW9uc1xuICByZXR1cm4gKHsgLi4uZGVmYXVsdHMsIC4uLm9wdGlvbnMgfSkubW9kZVxufVxuXG5tb2R1bGUuZXhwb3J0cy5tYWtlRGlyID0gYXN5bmMgKGRpciwgb3B0aW9ucykgPT4ge1xuICBjaGVja1BhdGgoZGlyKVxuXG4gIHJldHVybiBmcy5ta2RpcihkaXIsIHtcbiAgICBtb2RlOiBnZXRNb2RlKG9wdGlvbnMpLFxuICAgIHJlY3Vyc2l2ZTogdHJ1ZVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cy5tYWtlRGlyU3luYyA9IChkaXIsIG9wdGlvbnMpID0+IHtcbiAgY2hlY2tQYXRoKGRpcilcblxuICByZXR1cm4gZnMubWtkaXJTeW5jKGRpciwge1xuICAgIG1vZGU6IGdldE1vZGUob3B0aW9ucyksXG4gICAgcmVjdXJzaXZlOiB0cnVlXG4gIH0pXG59XG4iLCIndXNlIHN0cmljdCdcbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tUHJvbWlzZVxuY29uc3QgeyBtYWtlRGlyOiBfbWFrZURpciwgbWFrZURpclN5bmMgfSA9IHJlcXVpcmUoJy4vbWFrZS1kaXInKVxuY29uc3QgbWFrZURpciA9IHUoX21ha2VEaXIpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBta2RpcnM6IG1ha2VEaXIsXG4gIG1rZGlyc1N5bmM6IG1ha2VEaXJTeW5jLFxuICAvLyBhbGlhc1xuICBta2RpcnA6IG1ha2VEaXIsXG4gIG1rZGlycFN5bmM6IG1ha2VEaXJTeW5jLFxuICBlbnN1cmVEaXI6IG1ha2VEaXIsXG4gIGVuc3VyZURpclN5bmM6IG1ha2VEaXJTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tUHJvbWlzZVxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5cbmZ1bmN0aW9uIHBhdGhFeGlzdHMgKHBhdGgpIHtcbiAgcmV0dXJuIGZzLmFjY2VzcyhwYXRoKS50aGVuKCgpID0+IHRydWUpLmNhdGNoKCgpID0+IGZhbHNlKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGF0aEV4aXN0czogdShwYXRoRXhpc3RzKSxcbiAgcGF0aEV4aXN0c1N5bmM6IGZzLmV4aXN0c1N5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcblxuZnVuY3Rpb24gdXRpbWVzTWlsbGlzIChwYXRoLCBhdGltZSwgbXRpbWUsIGNhbGxiYWNrKSB7XG4gIC8vIGlmICghSEFTX01JTExJU19SRVMpIHJldHVybiBmcy51dGltZXMocGF0aCwgYXRpbWUsIG10aW1lLCBjYWxsYmFjaylcbiAgZnMub3BlbihwYXRoLCAncisnLCAoZXJyLCBmZCkgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgZnMuZnV0aW1lcyhmZCwgYXRpbWUsIG10aW1lLCBmdXRpbWVzRXJyID0+IHtcbiAgICAgIGZzLmNsb3NlKGZkLCBjbG9zZUVyciA9PiB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZnV0aW1lc0VyciB8fCBjbG9zZUVycilcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gdXRpbWVzTWlsbGlzU3luYyAocGF0aCwgYXRpbWUsIG10aW1lKSB7XG4gIGNvbnN0IGZkID0gZnMub3BlblN5bmMocGF0aCwgJ3IrJylcbiAgZnMuZnV0aW1lc1N5bmMoZmQsIGF0aW1lLCBtdGltZSlcbiAgcmV0dXJuIGZzLmNsb3NlU3luYyhmZClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHV0aW1lc01pbGxpcyxcbiAgdXRpbWVzTWlsbGlzU3luY1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuXG5mdW5jdGlvbiBnZXRTdGF0cyAoc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGNvbnN0IHN0YXRGdW5jID0gb3B0cy5kZXJlZmVyZW5jZVxuICAgID8gKGZpbGUpID0+IGZzLnN0YXQoZmlsZSwgeyBiaWdpbnQ6IHRydWUgfSlcbiAgICA6IChmaWxlKSA9PiBmcy5sc3RhdChmaWxlLCB7IGJpZ2ludDogdHJ1ZSB9KVxuICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgIHN0YXRGdW5jKHNyYyksXG4gICAgc3RhdEZ1bmMoZGVzdCkuY2F0Y2goZXJyID0+IHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHJldHVybiBudWxsXG4gICAgICB0aHJvdyBlcnJcbiAgICB9KVxuICBdKS50aGVuKChbc3JjU3RhdCwgZGVzdFN0YXRdKSA9PiAoeyBzcmNTdGF0LCBkZXN0U3RhdCB9KSlcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdHNTeW5jIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgbGV0IGRlc3RTdGF0XG4gIGNvbnN0IHN0YXRGdW5jID0gb3B0cy5kZXJlZmVyZW5jZVxuICAgID8gKGZpbGUpID0+IGZzLnN0YXRTeW5jKGZpbGUsIHsgYmlnaW50OiB0cnVlIH0pXG4gICAgOiAoZmlsZSkgPT4gZnMubHN0YXRTeW5jKGZpbGUsIHsgYmlnaW50OiB0cnVlIH0pXG4gIGNvbnN0IHNyY1N0YXQgPSBzdGF0RnVuYyhzcmMpXG4gIHRyeSB7XG4gICAgZGVzdFN0YXQgPSBzdGF0RnVuYyhkZXN0KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgPT09ICdFTk9FTlQnKSByZXR1cm4geyBzcmNTdGF0LCBkZXN0U3RhdDogbnVsbCB9XG4gICAgdGhyb3cgZXJyXG4gIH1cbiAgcmV0dXJuIHsgc3JjU3RhdCwgZGVzdFN0YXQgfVxufVxuXG5mdW5jdGlvbiBjaGVja1BhdGhzIChzcmMsIGRlc3QsIGZ1bmNOYW1lLCBvcHRzLCBjYikge1xuICB1dGlsLmNhbGxiYWNraWZ5KGdldFN0YXRzKShzcmMsIGRlc3QsIG9wdHMsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBjb25zdCB7IHNyY1N0YXQsIGRlc3RTdGF0IH0gPSBzdGF0c1xuXG4gICAgaWYgKGRlc3RTdGF0KSB7XG4gICAgICBpZiAoYXJlSWRlbnRpY2FsKHNyY1N0YXQsIGRlc3RTdGF0KSkge1xuICAgICAgICBjb25zdCBzcmNCYXNlTmFtZSA9IHBhdGguYmFzZW5hbWUoc3JjKVxuICAgICAgICBjb25zdCBkZXN0QmFzZU5hbWUgPSBwYXRoLmJhc2VuYW1lKGRlc3QpXG4gICAgICAgIGlmIChmdW5jTmFtZSA9PT0gJ21vdmUnICYmXG4gICAgICAgICAgc3JjQmFzZU5hbWUgIT09IGRlc3RCYXNlTmFtZSAmJlxuICAgICAgICAgIHNyY0Jhc2VOYW1lLnRvTG93ZXJDYXNlKCkgPT09IGRlc3RCYXNlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKG51bGwsIHsgc3JjU3RhdCwgZGVzdFN0YXQsIGlzQ2hhbmdpbmdDYXNlOiB0cnVlIH0pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignU291cmNlIGFuZCBkZXN0aW5hdGlvbiBtdXN0IG5vdCBiZSB0aGUgc2FtZS4nKSlcbiAgICAgIH1cbiAgICAgIGlmIChzcmNTdGF0LmlzRGlyZWN0b3J5KCkgJiYgIWRlc3RTdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihgQ2Fubm90IG92ZXJ3cml0ZSBub24tZGlyZWN0b3J5ICcke2Rlc3R9JyB3aXRoIGRpcmVjdG9yeSAnJHtzcmN9Jy5gKSlcbiAgICAgIH1cbiAgICAgIGlmICghc3JjU3RhdC5pc0RpcmVjdG9yeSgpICYmIGRlc3RTdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihgQ2Fubm90IG92ZXJ3cml0ZSBkaXJlY3RvcnkgJyR7ZGVzdH0nIHdpdGggbm9uLWRpcmVjdG9yeSAnJHtzcmN9Jy5gKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3JjU3RhdC5pc0RpcmVjdG9yeSgpICYmIGlzU3JjU3ViZGlyKHNyYywgZGVzdCkpIHtcbiAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoZXJyTXNnKHNyYywgZGVzdCwgZnVuY05hbWUpKSlcbiAgICB9XG4gICAgcmV0dXJuIGNiKG51bGwsIHsgc3JjU3RhdCwgZGVzdFN0YXQgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gY2hlY2tQYXRoc1N5bmMgKHNyYywgZGVzdCwgZnVuY05hbWUsIG9wdHMpIHtcbiAgY29uc3QgeyBzcmNTdGF0LCBkZXN0U3RhdCB9ID0gZ2V0U3RhdHNTeW5jKHNyYywgZGVzdCwgb3B0cylcblxuICBpZiAoZGVzdFN0YXQpIHtcbiAgICBpZiAoYXJlSWRlbnRpY2FsKHNyY1N0YXQsIGRlc3RTdGF0KSkge1xuICAgICAgY29uc3Qgc3JjQmFzZU5hbWUgPSBwYXRoLmJhc2VuYW1lKHNyYylcbiAgICAgIGNvbnN0IGRlc3RCYXNlTmFtZSA9IHBhdGguYmFzZW5hbWUoZGVzdClcbiAgICAgIGlmIChmdW5jTmFtZSA9PT0gJ21vdmUnICYmXG4gICAgICAgIHNyY0Jhc2VOYW1lICE9PSBkZXN0QmFzZU5hbWUgJiZcbiAgICAgICAgc3JjQmFzZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gZGVzdEJhc2VOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgcmV0dXJuIHsgc3JjU3RhdCwgZGVzdFN0YXQsIGlzQ2hhbmdpbmdDYXNlOiB0cnVlIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignU291cmNlIGFuZCBkZXN0aW5hdGlvbiBtdXN0IG5vdCBiZSB0aGUgc2FtZS4nKVxuICAgIH1cbiAgICBpZiAoc3JjU3RhdC5pc0RpcmVjdG9yeSgpICYmICFkZXN0U3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBvdmVyd3JpdGUgbm9uLWRpcmVjdG9yeSAnJHtkZXN0fScgd2l0aCBkaXJlY3RvcnkgJyR7c3JjfScuYClcbiAgICB9XG4gICAgaWYgKCFzcmNTdGF0LmlzRGlyZWN0b3J5KCkgJiYgZGVzdFN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgb3ZlcndyaXRlIGRpcmVjdG9yeSAnJHtkZXN0fScgd2l0aCBub24tZGlyZWN0b3J5ICcke3NyY30nLmApXG4gICAgfVxuICB9XG5cbiAgaWYgKHNyY1N0YXQuaXNEaXJlY3RvcnkoKSAmJiBpc1NyY1N1YmRpcihzcmMsIGRlc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyhzcmMsIGRlc3QsIGZ1bmNOYW1lKSlcbiAgfVxuICByZXR1cm4geyBzcmNTdGF0LCBkZXN0U3RhdCB9XG59XG5cbi8vIHJlY3Vyc2l2ZWx5IGNoZWNrIGlmIGRlc3QgcGFyZW50IGlzIGEgc3ViZGlyZWN0b3J5IG9mIHNyYy5cbi8vIEl0IHdvcmtzIGZvciBhbGwgZmlsZSB0eXBlcyBpbmNsdWRpbmcgc3ltbGlua3Mgc2luY2UgaXRcbi8vIGNoZWNrcyB0aGUgc3JjIGFuZCBkZXN0IGlub2Rlcy4gSXQgc3RhcnRzIGZyb20gdGhlIGRlZXBlc3Rcbi8vIHBhcmVudCBhbmQgc3RvcHMgb25jZSBpdCByZWFjaGVzIHRoZSBzcmMgcGFyZW50IG9yIHRoZSByb290IHBhdGguXG5mdW5jdGlvbiBjaGVja1BhcmVudFBhdGhzIChzcmMsIHNyY1N0YXQsIGRlc3QsIGZ1bmNOYW1lLCBjYikge1xuICBjb25zdCBzcmNQYXJlbnQgPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKHNyYykpXG4gIGNvbnN0IGRlc3RQYXJlbnQgPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKGRlc3QpKVxuICBpZiAoZGVzdFBhcmVudCA9PT0gc3JjUGFyZW50IHx8IGRlc3RQYXJlbnQgPT09IHBhdGgucGFyc2UoZGVzdFBhcmVudCkucm9vdCkgcmV0dXJuIGNiKClcbiAgZnMuc3RhdChkZXN0UGFyZW50LCB7IGJpZ2ludDogdHJ1ZSB9LCAoZXJyLCBkZXN0U3RhdCkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHJldHVybiBjYigpXG4gICAgICByZXR1cm4gY2IoZXJyKVxuICAgIH1cbiAgICBpZiAoYXJlSWRlbnRpY2FsKHNyY1N0YXQsIGRlc3RTdGF0KSkge1xuICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihlcnJNc2coc3JjLCBkZXN0LCBmdW5jTmFtZSkpKVxuICAgIH1cbiAgICByZXR1cm4gY2hlY2tQYXJlbnRQYXRocyhzcmMsIHNyY1N0YXQsIGRlc3RQYXJlbnQsIGZ1bmNOYW1lLCBjYilcbiAgfSlcbn1cblxuZnVuY3Rpb24gY2hlY2tQYXJlbnRQYXRoc1N5bmMgKHNyYywgc3JjU3RhdCwgZGVzdCwgZnVuY05hbWUpIHtcbiAgY29uc3Qgc3JjUGFyZW50ID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShzcmMpKVxuICBjb25zdCBkZXN0UGFyZW50ID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShkZXN0KSlcbiAgaWYgKGRlc3RQYXJlbnQgPT09IHNyY1BhcmVudCB8fCBkZXN0UGFyZW50ID09PSBwYXRoLnBhcnNlKGRlc3RQYXJlbnQpLnJvb3QpIHJldHVyblxuICBsZXQgZGVzdFN0YXRcbiAgdHJ5IHtcbiAgICBkZXN0U3RhdCA9IGZzLnN0YXRTeW5jKGRlc3RQYXJlbnQsIHsgYmlnaW50OiB0cnVlIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHJldHVyblxuICAgIHRocm93IGVyclxuICB9XG4gIGlmIChhcmVJZGVudGljYWwoc3JjU3RhdCwgZGVzdFN0YXQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyhzcmMsIGRlc3QsIGZ1bmNOYW1lKSlcbiAgfVxuICByZXR1cm4gY2hlY2tQYXJlbnRQYXRoc1N5bmMoc3JjLCBzcmNTdGF0LCBkZXN0UGFyZW50LCBmdW5jTmFtZSlcbn1cblxuZnVuY3Rpb24gYXJlSWRlbnRpY2FsIChzcmNTdGF0LCBkZXN0U3RhdCkge1xuICByZXR1cm4gZGVzdFN0YXQuaW5vICYmIGRlc3RTdGF0LmRldiAmJiBkZXN0U3RhdC5pbm8gPT09IHNyY1N0YXQuaW5vICYmIGRlc3RTdGF0LmRldiA9PT0gc3JjU3RhdC5kZXZcbn1cblxuLy8gcmV0dXJuIHRydWUgaWYgZGVzdCBpcyBhIHN1YmRpciBvZiBzcmMsIG90aGVyd2lzZSBmYWxzZS5cbi8vIEl0IG9ubHkgY2hlY2tzIHRoZSBwYXRoIHN0cmluZ3MuXG5mdW5jdGlvbiBpc1NyY1N1YmRpciAoc3JjLCBkZXN0KSB7XG4gIGNvbnN0IHNyY0FyciA9IHBhdGgucmVzb2x2ZShzcmMpLnNwbGl0KHBhdGguc2VwKS5maWx0ZXIoaSA9PiBpKVxuICBjb25zdCBkZXN0QXJyID0gcGF0aC5yZXNvbHZlKGRlc3QpLnNwbGl0KHBhdGguc2VwKS5maWx0ZXIoaSA9PiBpKVxuICByZXR1cm4gc3JjQXJyLnJlZHVjZSgoYWNjLCBjdXIsIGkpID0+IGFjYyAmJiBkZXN0QXJyW2ldID09PSBjdXIsIHRydWUpXG59XG5cbmZ1bmN0aW9uIGVyck1zZyAoc3JjLCBkZXN0LCBmdW5jTmFtZSkge1xuICByZXR1cm4gYENhbm5vdCAke2Z1bmNOYW1lfSAnJHtzcmN9JyB0byBhIHN1YmRpcmVjdG9yeSBvZiBpdHNlbGYsICcke2Rlc3R9Jy5gXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjaGVja1BhdGhzLFxuICBjaGVja1BhdGhzU3luYyxcbiAgY2hlY2tQYXJlbnRQYXRocyxcbiAgY2hlY2tQYXJlbnRQYXRoc1N5bmMsXG4gIGlzU3JjU3ViZGlyLFxuICBhcmVJZGVudGljYWxcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlycyA9IHJlcXVpcmUoJy4uL21rZGlycycpLm1rZGlyc1xuY29uc3QgcGF0aEV4aXN0cyA9IHJlcXVpcmUoJy4uL3BhdGgtZXhpc3RzJykucGF0aEV4aXN0c1xuY29uc3QgdXRpbWVzTWlsbGlzID0gcmVxdWlyZSgnLi4vdXRpbC91dGltZXMnKS51dGltZXNNaWxsaXNcbmNvbnN0IHN0YXQgPSByZXF1aXJlKCcuLi91dGlsL3N0YXQnKVxuXG5mdW5jdGlvbiBjb3B5IChzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJyAmJiAhY2IpIHtcbiAgICBjYiA9IG9wdHNcbiAgICBvcHRzID0ge31cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdHMgPSB7IGZpbHRlcjogb3B0cyB9XG4gIH1cblxuICBjYiA9IGNiIHx8IGZ1bmN0aW9uICgpIHt9XG4gIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgb3B0cy5jbG9iYmVyID0gJ2Nsb2JiZXInIGluIG9wdHMgPyAhIW9wdHMuY2xvYmJlciA6IHRydWUgLy8gZGVmYXVsdCB0byB0cnVlIGZvciBub3dcbiAgb3B0cy5vdmVyd3JpdGUgPSAnb3ZlcndyaXRlJyBpbiBvcHRzID8gISFvcHRzLm92ZXJ3cml0ZSA6IG9wdHMuY2xvYmJlciAvLyBvdmVyd3JpdGUgZmFsbHMgYmFjayB0byBjbG9iYmVyXG5cbiAgLy8gV2FybiBhYm91dCB1c2luZyBwcmVzZXJ2ZVRpbWVzdGFtcHMgb24gMzItYml0IG5vZGVcbiAgaWYgKG9wdHMucHJlc2VydmVUaW1lc3RhbXBzICYmIHByb2Nlc3MuYXJjaCA9PT0gJ2lhMzInKSB7XG4gICAgcHJvY2Vzcy5lbWl0V2FybmluZyhcbiAgICAgICdVc2luZyB0aGUgcHJlc2VydmVUaW1lc3RhbXBzIG9wdGlvbiBpbiAzMi1iaXQgbm9kZSBpcyBub3QgcmVjb21tZW5kZWQ7XFxuXFxuJyArXG4gICAgICAnXFx0c2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcHJpY2hhcmRzb24vbm9kZS1mcy1leHRyYS9pc3N1ZXMvMjY5JyxcbiAgICAgICdXYXJuaW5nJywgJ2ZzLWV4dHJhLVdBUk4wMDAxJ1xuICAgIClcbiAgfVxuXG4gIHN0YXQuY2hlY2tQYXRocyhzcmMsIGRlc3QsICdjb3B5Jywgb3B0cywgKGVyciwgc3RhdHMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGNvbnN0IHsgc3JjU3RhdCwgZGVzdFN0YXQgfSA9IHN0YXRzXG4gICAgc3RhdC5jaGVja1BhcmVudFBhdGhzKHNyYywgc3JjU3RhdCwgZGVzdCwgJ2NvcHknLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIGlmIChvcHRzLmZpbHRlcikgcmV0dXJuIGhhbmRsZUZpbHRlcihjaGVja1BhcmVudERpciwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgICByZXR1cm4gY2hlY2tQYXJlbnREaXIoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gY2hlY2tQYXJlbnREaXIgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGNvbnN0IGRlc3RQYXJlbnQgPSBwYXRoLmRpcm5hbWUoZGVzdClcbiAgcGF0aEV4aXN0cyhkZXN0UGFyZW50LCAoZXJyLCBkaXJFeGlzdHMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGlmIChkaXJFeGlzdHMpIHJldHVybiBnZXRTdGF0cyhkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICBta2RpcnMoZGVzdFBhcmVudCwgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICByZXR1cm4gZ2V0U3RhdHMoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gaGFuZGxlRmlsdGVyIChvbkluY2x1ZGUsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIFByb21pc2UucmVzb2x2ZShvcHRzLmZpbHRlcihzcmMsIGRlc3QpKS50aGVuKGluY2x1ZGUgPT4ge1xuICAgIGlmIChpbmNsdWRlKSByZXR1cm4gb25JbmNsdWRlKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIHJldHVybiBjYigpXG4gIH0sIGVycm9yID0+IGNiKGVycm9yKSlcbn1cblxuZnVuY3Rpb24gc3RhcnRDb3B5IChkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBpZiAob3B0cy5maWx0ZXIpIHJldHVybiBoYW5kbGVGaWx0ZXIoZ2V0U3RhdHMsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICByZXR1cm4gZ2V0U3RhdHMoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG59XG5cbmZ1bmN0aW9uIGdldFN0YXRzIChkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBjb25zdCBzdGF0ID0gb3B0cy5kZXJlZmVyZW5jZSA/IGZzLnN0YXQgOiBmcy5sc3RhdFxuICBzdGF0KHNyYywgKGVyciwgc3JjU3RhdCkgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG5cbiAgICBpZiAoc3JjU3RhdC5pc0RpcmVjdG9yeSgpKSByZXR1cm4gb25EaXIoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgZWxzZSBpZiAoc3JjU3RhdC5pc0ZpbGUoKSB8fFxuICAgICAgICAgICAgIHNyY1N0YXQuaXNDaGFyYWN0ZXJEZXZpY2UoKSB8fFxuICAgICAgICAgICAgIHNyY1N0YXQuaXNCbG9ja0RldmljZSgpKSByZXR1cm4gb25GaWxlKHNyY1N0YXQsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIGVsc2UgaWYgKHNyY1N0YXQuaXNTeW1ib2xpY0xpbmsoKSkgcmV0dXJuIG9uTGluayhkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICBlbHNlIGlmIChzcmNTdGF0LmlzU29ja2V0KCkpIHJldHVybiBjYihuZXcgRXJyb3IoYENhbm5vdCBjb3B5IGEgc29ja2V0IGZpbGU6ICR7c3JjfWApKVxuICAgIGVsc2UgaWYgKHNyY1N0YXQuaXNGSUZPKCkpIHJldHVybiBjYihuZXcgRXJyb3IoYENhbm5vdCBjb3B5IGEgRklGTyBwaXBlOiAke3NyY31gKSlcbiAgICByZXR1cm4gY2IobmV3IEVycm9yKGBVbmtub3duIGZpbGU6ICR7c3JjfWApKVxuICB9KVxufVxuXG5mdW5jdGlvbiBvbkZpbGUgKHNyY1N0YXQsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGlmICghZGVzdFN0YXQpIHJldHVybiBjb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICByZXR1cm4gbWF5Q29weUZpbGUoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbn1cblxuZnVuY3Rpb24gbWF5Q29weUZpbGUgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgaWYgKG9wdHMub3ZlcndyaXRlKSB7XG4gICAgZnMudW5saW5rKGRlc3QsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgcmV0dXJuIGNvcHlGaWxlKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgfSlcbiAgfSBlbHNlIGlmIChvcHRzLmVycm9yT25FeGlzdCkge1xuICAgIHJldHVybiBjYihuZXcgRXJyb3IoYCcke2Rlc3R9JyBhbHJlYWR5IGV4aXN0c2ApKVxuICB9IGVsc2UgcmV0dXJuIGNiKClcbn1cblxuZnVuY3Rpb24gY29weUZpbGUgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgZnMuY29weUZpbGUoc3JjLCBkZXN0LCBlcnIgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgaWYgKG9wdHMucHJlc2VydmVUaW1lc3RhbXBzKSByZXR1cm4gaGFuZGxlVGltZXN0YW1wc0FuZE1vZGUoc3JjU3RhdC5tb2RlLCBzcmMsIGRlc3QsIGNiKVxuICAgIHJldHVybiBzZXREZXN0TW9kZShkZXN0LCBzcmNTdGF0Lm1vZGUsIGNiKVxuICB9KVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUaW1lc3RhbXBzQW5kTW9kZSAoc3JjTW9kZSwgc3JjLCBkZXN0LCBjYikge1xuICAvLyBNYWtlIHN1cmUgdGhlIGZpbGUgaXMgd3JpdGFibGUgYmVmb3JlIHNldHRpbmcgdGhlIHRpbWVzdGFtcFxuICAvLyBvdGhlcndpc2Ugb3BlbiBmYWlscyB3aXRoIEVQRVJNIHdoZW4gaW52b2tlZCB3aXRoICdyKydcbiAgLy8gKHRocm91Z2ggdXRpbWVzIGNhbGwpXG4gIGlmIChmaWxlSXNOb3RXcml0YWJsZShzcmNNb2RlKSkge1xuICAgIHJldHVybiBtYWtlRmlsZVdyaXRhYmxlKGRlc3QsIHNyY01vZGUsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgcmV0dXJuIHNldERlc3RUaW1lc3RhbXBzQW5kTW9kZShzcmNNb2RlLCBzcmMsIGRlc3QsIGNiKVxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIHNldERlc3RUaW1lc3RhbXBzQW5kTW9kZShzcmNNb2RlLCBzcmMsIGRlc3QsIGNiKVxufVxuXG5mdW5jdGlvbiBmaWxlSXNOb3RXcml0YWJsZSAoc3JjTW9kZSkge1xuICByZXR1cm4gKHNyY01vZGUgJiAwbzIwMCkgPT09IDBcbn1cblxuZnVuY3Rpb24gbWFrZUZpbGVXcml0YWJsZSAoZGVzdCwgc3JjTW9kZSwgY2IpIHtcbiAgcmV0dXJuIHNldERlc3RNb2RlKGRlc3QsIHNyY01vZGUgfCAwbzIwMCwgY2IpXG59XG5cbmZ1bmN0aW9uIHNldERlc3RUaW1lc3RhbXBzQW5kTW9kZSAoc3JjTW9kZSwgc3JjLCBkZXN0LCBjYikge1xuICBzZXREZXN0VGltZXN0YW1wcyhzcmMsIGRlc3QsIGVyciA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICByZXR1cm4gc2V0RGVzdE1vZGUoZGVzdCwgc3JjTW9kZSwgY2IpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHNldERlc3RNb2RlIChkZXN0LCBzcmNNb2RlLCBjYikge1xuICByZXR1cm4gZnMuY2htb2QoZGVzdCwgc3JjTW9kZSwgY2IpXG59XG5cbmZ1bmN0aW9uIHNldERlc3RUaW1lc3RhbXBzIChzcmMsIGRlc3QsIGNiKSB7XG4gIC8vIFRoZSBpbml0aWFsIHNyY1N0YXQuYXRpbWUgY2Fubm90IGJlIHRydXN0ZWRcbiAgLy8gYmVjYXVzZSBpdCBpcyBtb2RpZmllZCBieSB0aGUgcmVhZCgyKSBzeXN0ZW0gY2FsbFxuICAvLyAoU2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZnMuaHRtbCNmc19zdGF0X3RpbWVfdmFsdWVzKVxuICBmcy5zdGF0KHNyYywgKGVyciwgdXBkYXRlZFNyY1N0YXQpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHJldHVybiB1dGltZXNNaWxsaXMoZGVzdCwgdXBkYXRlZFNyY1N0YXQuYXRpbWUsIHVwZGF0ZWRTcmNTdGF0Lm10aW1lLCBjYilcbiAgfSlcbn1cblxuZnVuY3Rpb24gb25EaXIgKHNyY1N0YXQsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGlmICghZGVzdFN0YXQpIHJldHVybiBta0RpckFuZENvcHkoc3JjU3RhdC5tb2RlLCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICByZXR1cm4gY29weURpcihzcmMsIGRlc3QsIG9wdHMsIGNiKVxufVxuXG5mdW5jdGlvbiBta0RpckFuZENvcHkgKHNyY01vZGUsIHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgZnMubWtkaXIoZGVzdCwgZXJyID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGNvcHlEaXIoc3JjLCBkZXN0LCBvcHRzLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIHJldHVybiBzZXREZXN0TW9kZShkZXN0LCBzcmNNb2RlLCBjYilcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjb3B5RGlyIChzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGZzLnJlYWRkaXIoc3JjLCAoZXJyLCBpdGVtcykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgcmV0dXJuIGNvcHlEaXJJdGVtcyhpdGVtcywgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgfSlcbn1cblxuZnVuY3Rpb24gY29weURpckl0ZW1zIChpdGVtcywgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBjb25zdCBpdGVtID0gaXRlbXMucG9wKClcbiAgaWYgKCFpdGVtKSByZXR1cm4gY2IoKVxuICByZXR1cm4gY29weURpckl0ZW0oaXRlbXMsIGl0ZW0sIHNyYywgZGVzdCwgb3B0cywgY2IpXG59XG5cbmZ1bmN0aW9uIGNvcHlEaXJJdGVtIChpdGVtcywgaXRlbSwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBjb25zdCBzcmNJdGVtID0gcGF0aC5qb2luKHNyYywgaXRlbSlcbiAgY29uc3QgZGVzdEl0ZW0gPSBwYXRoLmpvaW4oZGVzdCwgaXRlbSlcbiAgc3RhdC5jaGVja1BhdGhzKHNyY0l0ZW0sIGRlc3RJdGVtLCAnY29weScsIG9wdHMsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBjb25zdCB7IGRlc3RTdGF0IH0gPSBzdGF0c1xuICAgIHN0YXJ0Q29weShkZXN0U3RhdCwgc3JjSXRlbSwgZGVzdEl0ZW0sIG9wdHMsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgcmV0dXJuIGNvcHlEaXJJdGVtcyhpdGVtcywgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBvbkxpbmsgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGZzLnJlYWRsaW5rKHNyYywgKGVyciwgcmVzb2x2ZWRTcmMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGlmIChvcHRzLmRlcmVmZXJlbmNlKSB7XG4gICAgICByZXNvbHZlZFNyYyA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCByZXNvbHZlZFNyYylcbiAgICB9XG5cbiAgICBpZiAoIWRlc3RTdGF0KSB7XG4gICAgICByZXR1cm4gZnMuc3ltbGluayhyZXNvbHZlZFNyYywgZGVzdCwgY2IpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZzLnJlYWRsaW5rKGRlc3QsIChlcnIsIHJlc29sdmVkRGVzdCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgLy8gZGVzdCBleGlzdHMgYW5kIGlzIGEgcmVndWxhciBmaWxlIG9yIGRpcmVjdG9yeSxcbiAgICAgICAgICAvLyBXaW5kb3dzIG1heSB0aHJvdyBVTktOT1dOIGVycm9yLiBJZiBkZXN0IGFscmVhZHkgZXhpc3RzLFxuICAgICAgICAgIC8vIGZzIHRocm93cyBlcnJvciBhbnl3YXksIHNvIG5vIG5lZWQgdG8gZ3VhcmQgYWdhaW5zdCBpdCBoZXJlLlxuICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VJTlZBTCcgfHwgZXJyLmNvZGUgPT09ICdVTktOT1dOJykgcmV0dXJuIGZzLnN5bWxpbmsocmVzb2x2ZWRTcmMsIGRlc3QsIGNiKVxuICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuZGVyZWZlcmVuY2UpIHtcbiAgICAgICAgICByZXNvbHZlZERlc3QgPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgcmVzb2x2ZWREZXN0KVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0LmlzU3JjU3ViZGlyKHJlc29sdmVkU3JjLCByZXNvbHZlZERlc3QpKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihgQ2Fubm90IGNvcHkgJyR7cmVzb2x2ZWRTcmN9JyB0byBhIHN1YmRpcmVjdG9yeSBvZiBpdHNlbGYsICcke3Jlc29sdmVkRGVzdH0nLmApKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG8gbm90IGNvcHkgaWYgc3JjIGlzIGEgc3ViZGlyIG9mIGRlc3Qgc2luY2UgdW5saW5raW5nXG4gICAgICAgIC8vIGRlc3QgaW4gdGhpcyBjYXNlIHdvdWxkIHJlc3VsdCBpbiByZW1vdmluZyBzcmMgY29udGVudHNcbiAgICAgICAgLy8gYW5kIHRoZXJlZm9yZSBhIGJyb2tlbiBzeW1saW5rIHdvdWxkIGJlIGNyZWF0ZWQuXG4gICAgICAgIGlmIChkZXN0U3RhdC5pc0RpcmVjdG9yeSgpICYmIHN0YXQuaXNTcmNTdWJkaXIocmVzb2x2ZWREZXN0LCByZXNvbHZlZFNyYykpIHtcbiAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKGBDYW5ub3Qgb3ZlcndyaXRlICcke3Jlc29sdmVkRGVzdH0nIHdpdGggJyR7cmVzb2x2ZWRTcmN9Jy5gKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weUxpbmsocmVzb2x2ZWRTcmMsIGRlc3QsIGNiKVxuICAgICAgfSlcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNvcHlMaW5rIChyZXNvbHZlZFNyYywgZGVzdCwgY2IpIHtcbiAgZnMudW5saW5rKGRlc3QsIGVyciA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICByZXR1cm4gZnMuc3ltbGluayhyZXNvbHZlZFNyYywgZGVzdCwgY2IpXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgbWtkaXJzU3luYyA9IHJlcXVpcmUoJy4uL21rZGlycycpLm1rZGlyc1N5bmNcbmNvbnN0IHV0aW1lc01pbGxpc1N5bmMgPSByZXF1aXJlKCcuLi91dGlsL3V0aW1lcycpLnV0aW1lc01pbGxpc1N5bmNcbmNvbnN0IHN0YXQgPSByZXF1aXJlKCcuLi91dGlsL3N0YXQnKVxuXG5mdW5jdGlvbiBjb3B5U3luYyAoc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdHMgPSB7IGZpbHRlcjogb3B0cyB9XG4gIH1cblxuICBvcHRzID0gb3B0cyB8fCB7fVxuICBvcHRzLmNsb2JiZXIgPSAnY2xvYmJlcicgaW4gb3B0cyA/ICEhb3B0cy5jbG9iYmVyIDogdHJ1ZSAvLyBkZWZhdWx0IHRvIHRydWUgZm9yIG5vd1xuICBvcHRzLm92ZXJ3cml0ZSA9ICdvdmVyd3JpdGUnIGluIG9wdHMgPyAhIW9wdHMub3ZlcndyaXRlIDogb3B0cy5jbG9iYmVyIC8vIG92ZXJ3cml0ZSBmYWxscyBiYWNrIHRvIGNsb2JiZXJcblxuICAvLyBXYXJuIGFib3V0IHVzaW5nIHByZXNlcnZlVGltZXN0YW1wcyBvbiAzMi1iaXQgbm9kZVxuICBpZiAob3B0cy5wcmVzZXJ2ZVRpbWVzdGFtcHMgJiYgcHJvY2Vzcy5hcmNoID09PSAnaWEzMicpIHtcbiAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKFxuICAgICAgJ1VzaW5nIHRoZSBwcmVzZXJ2ZVRpbWVzdGFtcHMgb3B0aW9uIGluIDMyLWJpdCBub2RlIGlzIG5vdCByZWNvbW1lbmRlZDtcXG5cXG4nICtcbiAgICAgICdcXHRzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pwcmljaGFyZHNvbi9ub2RlLWZzLWV4dHJhL2lzc3Vlcy8yNjknLFxuICAgICAgJ1dhcm5pbmcnLCAnZnMtZXh0cmEtV0FSTjAwMDInXG4gICAgKVxuICB9XG5cbiAgY29uc3QgeyBzcmNTdGF0LCBkZXN0U3RhdCB9ID0gc3RhdC5jaGVja1BhdGhzU3luYyhzcmMsIGRlc3QsICdjb3B5Jywgb3B0cylcbiAgc3RhdC5jaGVja1BhcmVudFBhdGhzU3luYyhzcmMsIHNyY1N0YXQsIGRlc3QsICdjb3B5JylcbiAgcmV0dXJuIGhhbmRsZUZpbHRlckFuZENvcHkoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcbn1cblxuZnVuY3Rpb24gaGFuZGxlRmlsdGVyQW5kQ29weSAoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBpZiAob3B0cy5maWx0ZXIgJiYgIW9wdHMuZmlsdGVyKHNyYywgZGVzdCkpIHJldHVyblxuICBjb25zdCBkZXN0UGFyZW50ID0gcGF0aC5kaXJuYW1lKGRlc3QpXG4gIGlmICghZnMuZXhpc3RzU3luYyhkZXN0UGFyZW50KSkgbWtkaXJzU3luYyhkZXN0UGFyZW50KVxuICByZXR1cm4gZ2V0U3RhdHMoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcbn1cblxuZnVuY3Rpb24gc3RhcnRDb3B5IChkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmIChvcHRzLmZpbHRlciAmJiAhb3B0cy5maWx0ZXIoc3JjLCBkZXN0KSkgcmV0dXJuXG4gIHJldHVybiBnZXRTdGF0cyhkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxufVxuXG5mdW5jdGlvbiBnZXRTdGF0cyAoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBjb25zdCBzdGF0U3luYyA9IG9wdHMuZGVyZWZlcmVuY2UgPyBmcy5zdGF0U3luYyA6IGZzLmxzdGF0U3luY1xuICBjb25zdCBzcmNTdGF0ID0gc3RhdFN5bmMoc3JjKVxuXG4gIGlmIChzcmNTdGF0LmlzRGlyZWN0b3J5KCkpIHJldHVybiBvbkRpcihzcmNTdGF0LCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxuICBlbHNlIGlmIChzcmNTdGF0LmlzRmlsZSgpIHx8XG4gICAgICAgICAgIHNyY1N0YXQuaXNDaGFyYWN0ZXJEZXZpY2UoKSB8fFxuICAgICAgICAgICBzcmNTdGF0LmlzQmxvY2tEZXZpY2UoKSkgcmV0dXJuIG9uRmlsZShzcmNTdGF0LCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxuICBlbHNlIGlmIChzcmNTdGF0LmlzU3ltYm9saWNMaW5rKCkpIHJldHVybiBvbkxpbmsoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcbiAgZWxzZSBpZiAoc3JjU3RhdC5pc1NvY2tldCgpKSB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb3B5IGEgc29ja2V0IGZpbGU6ICR7c3JjfWApXG4gIGVsc2UgaWYgKHNyY1N0YXQuaXNGSUZPKCkpIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvcHkgYSBGSUZPIHBpcGU6ICR7c3JjfWApXG4gIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBmaWxlOiAke3NyY31gKVxufVxuXG5mdW5jdGlvbiBvbkZpbGUgKHNyY1N0YXQsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgaWYgKCFkZXN0U3RhdCkgcmV0dXJuIGNvcHlGaWxlKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cylcbiAgcmV0dXJuIG1heUNvcHlGaWxlKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cylcbn1cblxuZnVuY3Rpb24gbWF5Q29weUZpbGUgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBpZiAob3B0cy5vdmVyd3JpdGUpIHtcbiAgICBmcy51bmxpbmtTeW5jKGRlc3QpXG4gICAgcmV0dXJuIGNvcHlGaWxlKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cylcbiAgfSBlbHNlIGlmIChvcHRzLmVycm9yT25FeGlzdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJyR7ZGVzdH0nIGFscmVhZHkgZXhpc3RzYClcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5RmlsZSAoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGZzLmNvcHlGaWxlU3luYyhzcmMsIGRlc3QpXG4gIGlmIChvcHRzLnByZXNlcnZlVGltZXN0YW1wcykgaGFuZGxlVGltZXN0YW1wcyhzcmNTdGF0Lm1vZGUsIHNyYywgZGVzdClcbiAgcmV0dXJuIHNldERlc3RNb2RlKGRlc3QsIHNyY1N0YXQubW9kZSlcbn1cblxuZnVuY3Rpb24gaGFuZGxlVGltZXN0YW1wcyAoc3JjTW9kZSwgc3JjLCBkZXN0KSB7XG4gIC8vIE1ha2Ugc3VyZSB0aGUgZmlsZSBpcyB3cml0YWJsZSBiZWZvcmUgc2V0dGluZyB0aGUgdGltZXN0YW1wXG4gIC8vIG90aGVyd2lzZSBvcGVuIGZhaWxzIHdpdGggRVBFUk0gd2hlbiBpbnZva2VkIHdpdGggJ3IrJ1xuICAvLyAodGhyb3VnaCB1dGltZXMgY2FsbClcbiAgaWYgKGZpbGVJc05vdFdyaXRhYmxlKHNyY01vZGUpKSBtYWtlRmlsZVdyaXRhYmxlKGRlc3QsIHNyY01vZGUpXG4gIHJldHVybiBzZXREZXN0VGltZXN0YW1wcyhzcmMsIGRlc3QpXG59XG5cbmZ1bmN0aW9uIGZpbGVJc05vdFdyaXRhYmxlIChzcmNNb2RlKSB7XG4gIHJldHVybiAoc3JjTW9kZSAmIDBvMjAwKSA9PT0gMFxufVxuXG5mdW5jdGlvbiBtYWtlRmlsZVdyaXRhYmxlIChkZXN0LCBzcmNNb2RlKSB7XG4gIHJldHVybiBzZXREZXN0TW9kZShkZXN0LCBzcmNNb2RlIHwgMG8yMDApXG59XG5cbmZ1bmN0aW9uIHNldERlc3RNb2RlIChkZXN0LCBzcmNNb2RlKSB7XG4gIHJldHVybiBmcy5jaG1vZFN5bmMoZGVzdCwgc3JjTW9kZSlcbn1cblxuZnVuY3Rpb24gc2V0RGVzdFRpbWVzdGFtcHMgKHNyYywgZGVzdCkge1xuICAvLyBUaGUgaW5pdGlhbCBzcmNTdGF0LmF0aW1lIGNhbm5vdCBiZSB0cnVzdGVkXG4gIC8vIGJlY2F1c2UgaXQgaXMgbW9kaWZpZWQgYnkgdGhlIHJlYWQoMikgc3lzdGVtIGNhbGxcbiAgLy8gKFNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL2ZzLmh0bWwjZnNfc3RhdF90aW1lX3ZhbHVlcylcbiAgY29uc3QgdXBkYXRlZFNyY1N0YXQgPSBmcy5zdGF0U3luYyhzcmMpXG4gIHJldHVybiB1dGltZXNNaWxsaXNTeW5jKGRlc3QsIHVwZGF0ZWRTcmNTdGF0LmF0aW1lLCB1cGRhdGVkU3JjU3RhdC5tdGltZSlcbn1cblxuZnVuY3Rpb24gb25EaXIgKHNyY1N0YXQsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgaWYgKCFkZXN0U3RhdCkgcmV0dXJuIG1rRGlyQW5kQ29weShzcmNTdGF0Lm1vZGUsIHNyYywgZGVzdCwgb3B0cylcbiAgcmV0dXJuIGNvcHlEaXIoc3JjLCBkZXN0LCBvcHRzKVxufVxuXG5mdW5jdGlvbiBta0RpckFuZENvcHkgKHNyY01vZGUsIHNyYywgZGVzdCwgb3B0cykge1xuICBmcy5ta2RpclN5bmMoZGVzdClcbiAgY29weURpcihzcmMsIGRlc3QsIG9wdHMpXG4gIHJldHVybiBzZXREZXN0TW9kZShkZXN0LCBzcmNNb2RlKVxufVxuXG5mdW5jdGlvbiBjb3B5RGlyIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgZnMucmVhZGRpclN5bmMoc3JjKS5mb3JFYWNoKGl0ZW0gPT4gY29weURpckl0ZW0oaXRlbSwgc3JjLCBkZXN0LCBvcHRzKSlcbn1cblxuZnVuY3Rpb24gY29weURpckl0ZW0gKGl0ZW0sIHNyYywgZGVzdCwgb3B0cykge1xuICBjb25zdCBzcmNJdGVtID0gcGF0aC5qb2luKHNyYywgaXRlbSlcbiAgY29uc3QgZGVzdEl0ZW0gPSBwYXRoLmpvaW4oZGVzdCwgaXRlbSlcbiAgY29uc3QgeyBkZXN0U3RhdCB9ID0gc3RhdC5jaGVja1BhdGhzU3luYyhzcmNJdGVtLCBkZXN0SXRlbSwgJ2NvcHknLCBvcHRzKVxuICByZXR1cm4gc3RhcnRDb3B5KGRlc3RTdGF0LCBzcmNJdGVtLCBkZXN0SXRlbSwgb3B0cylcbn1cblxuZnVuY3Rpb24gb25MaW5rIChkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGxldCByZXNvbHZlZFNyYyA9IGZzLnJlYWRsaW5rU3luYyhzcmMpXG4gIGlmIChvcHRzLmRlcmVmZXJlbmNlKSB7XG4gICAgcmVzb2x2ZWRTcmMgPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgcmVzb2x2ZWRTcmMpXG4gIH1cblxuICBpZiAoIWRlc3RTdGF0KSB7XG4gICAgcmV0dXJuIGZzLnN5bWxpbmtTeW5jKHJlc29sdmVkU3JjLCBkZXN0KVxuICB9IGVsc2Uge1xuICAgIGxldCByZXNvbHZlZERlc3RcbiAgICB0cnkge1xuICAgICAgcmVzb2x2ZWREZXN0ID0gZnMucmVhZGxpbmtTeW5jKGRlc3QpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBkZXN0IGV4aXN0cyBhbmQgaXMgYSByZWd1bGFyIGZpbGUgb3IgZGlyZWN0b3J5LFxuICAgICAgLy8gV2luZG93cyBtYXkgdGhyb3cgVU5LTk9XTiBlcnJvci4gSWYgZGVzdCBhbHJlYWR5IGV4aXN0cyxcbiAgICAgIC8vIGZzIHRocm93cyBlcnJvciBhbnl3YXksIHNvIG5vIG5lZWQgdG8gZ3VhcmQgYWdhaW5zdCBpdCBoZXJlLlxuICAgICAgaWYgKGVyci5jb2RlID09PSAnRUlOVkFMJyB8fCBlcnIuY29kZSA9PT0gJ1VOS05PV04nKSByZXR1cm4gZnMuc3ltbGlua1N5bmMocmVzb2x2ZWRTcmMsIGRlc3QpXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gICAgaWYgKG9wdHMuZGVyZWZlcmVuY2UpIHtcbiAgICAgIHJlc29sdmVkRGVzdCA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCByZXNvbHZlZERlc3QpXG4gICAgfVxuICAgIGlmIChzdGF0LmlzU3JjU3ViZGlyKHJlc29sdmVkU3JjLCByZXNvbHZlZERlc3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb3B5ICcke3Jlc29sdmVkU3JjfScgdG8gYSBzdWJkaXJlY3Rvcnkgb2YgaXRzZWxmLCAnJHtyZXNvbHZlZERlc3R9Jy5gKVxuICAgIH1cblxuICAgIC8vIHByZXZlbnQgY29weSBpZiBzcmMgaXMgYSBzdWJkaXIgb2YgZGVzdCBzaW5jZSB1bmxpbmtpbmdcbiAgICAvLyBkZXN0IGluIHRoaXMgY2FzZSB3b3VsZCByZXN1bHQgaW4gcmVtb3Zpbmcgc3JjIGNvbnRlbnRzXG4gICAgLy8gYW5kIHRoZXJlZm9yZSBhIGJyb2tlbiBzeW1saW5rIHdvdWxkIGJlIGNyZWF0ZWQuXG4gICAgaWYgKGZzLnN0YXRTeW5jKGRlc3QpLmlzRGlyZWN0b3J5KCkgJiYgc3RhdC5pc1NyY1N1YmRpcihyZXNvbHZlZERlc3QsIHJlc29sdmVkU3JjKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgb3ZlcndyaXRlICcke3Jlc29sdmVkRGVzdH0nIHdpdGggJyR7cmVzb2x2ZWRTcmN9Jy5gKVxuICAgIH1cbiAgICByZXR1cm4gY29weUxpbmsocmVzb2x2ZWRTcmMsIGRlc3QpXG4gIH1cbn1cblxuZnVuY3Rpb24gY29weUxpbmsgKHJlc29sdmVkU3JjLCBkZXN0KSB7XG4gIGZzLnVubGlua1N5bmMoZGVzdClcbiAgcmV0dXJuIGZzLnN5bWxpbmtTeW5jKHJlc29sdmVkU3JjLCBkZXN0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW5jXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvcHk6IHUocmVxdWlyZSgnLi9jb3B5JykpLFxuICBjb3B5U3luYzogcmVxdWlyZSgnLi9jb3B5LXN5bmMnKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcblxuY29uc3QgaXNXaW5kb3dzID0gKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpXG5cbmZ1bmN0aW9uIGRlZmF1bHRzIChvcHRpb25zKSB7XG4gIGNvbnN0IG1ldGhvZHMgPSBbXG4gICAgJ3VubGluaycsXG4gICAgJ2NobW9kJyxcbiAgICAnc3RhdCcsXG4gICAgJ2xzdGF0JyxcbiAgICAncm1kaXInLFxuICAgICdyZWFkZGlyJ1xuICBdXG4gIG1ldGhvZHMuZm9yRWFjaChtID0+IHtcbiAgICBvcHRpb25zW21dID0gb3B0aW9uc1ttXSB8fCBmc1ttXVxuICAgIG0gPSBtICsgJ1N5bmMnXG4gICAgb3B0aW9uc1ttXSA9IG9wdGlvbnNbbV0gfHwgZnNbbV1cbiAgfSlcblxuICBvcHRpb25zLm1heEJ1c3lUcmllcyA9IG9wdGlvbnMubWF4QnVzeVRyaWVzIHx8IDNcbn1cblxuZnVuY3Rpb24gcmltcmFmIChwLCBvcHRpb25zLCBjYikge1xuICBsZXQgYnVzeVRyaWVzID0gMFxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG5cbiAgYXNzZXJ0KHAsICdyaW1yYWY6IG1pc3NpbmcgcGF0aCcpXG4gIGFzc2VydC5zdHJpY3RFcXVhbCh0eXBlb2YgcCwgJ3N0cmluZycsICdyaW1yYWY6IHBhdGggc2hvdWxkIGJlIGEgc3RyaW5nJylcbiAgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiBjYiwgJ2Z1bmN0aW9uJywgJ3JpbXJhZjogY2FsbGJhY2sgZnVuY3Rpb24gcmVxdWlyZWQnKVxuICBhc3NlcnQob3B0aW9ucywgJ3JpbXJhZjogaW52YWxpZCBvcHRpb25zIGFyZ3VtZW50IHByb3ZpZGVkJylcbiAgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiBvcHRpb25zLCAnb2JqZWN0JywgJ3JpbXJhZjogb3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0JylcblxuICBkZWZhdWx0cyhvcHRpb25zKVxuXG4gIHJpbXJhZl8ocCwgb3B0aW9ucywgZnVuY3Rpb24gQ0IgKGVyKSB7XG4gICAgaWYgKGVyKSB7XG4gICAgICBpZiAoKGVyLmNvZGUgPT09ICdFQlVTWScgfHwgZXIuY29kZSA9PT0gJ0VOT1RFTVBUWScgfHwgZXIuY29kZSA9PT0gJ0VQRVJNJykgJiZcbiAgICAgICAgICBidXN5VHJpZXMgPCBvcHRpb25zLm1heEJ1c3lUcmllcykge1xuICAgICAgICBidXN5VHJpZXMrK1xuICAgICAgICBjb25zdCB0aW1lID0gYnVzeVRyaWVzICogMTAwXG4gICAgICAgIC8vIHRyeSBhZ2Fpbiwgd2l0aCB0aGUgc2FtZSBleGFjdCBjYWxsYmFjayBhcyB0aGlzIG9uZS5cbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKCkgPT4gcmltcmFmXyhwLCBvcHRpb25zLCBDQiksIHRpbWUpXG4gICAgICB9XG5cbiAgICAgIC8vIGFscmVhZHkgZ29uZVxuICAgICAgaWYgKGVyLmNvZGUgPT09ICdFTk9FTlQnKSBlciA9IG51bGxcbiAgICB9XG5cbiAgICBjYihlcilcbiAgfSlcbn1cblxuLy8gVHdvIHBvc3NpYmxlIHN0cmF0ZWdpZXMuXG4vLyAxLiBBc3N1bWUgaXQncyBhIGZpbGUuICB1bmxpbmsgaXQsIHRoZW4gZG8gdGhlIGRpciBzdHVmZiBvbiBFUEVSTSBvciBFSVNESVJcbi8vIDIuIEFzc3VtZSBpdCdzIGEgZGlyZWN0b3J5LiAgcmVhZGRpciwgdGhlbiBkbyB0aGUgZmlsZSBzdHVmZiBvbiBFTk9URElSXG4vL1xuLy8gQm90aCByZXN1bHQgaW4gYW4gZXh0cmEgc3lzY2FsbCB3aGVuIHlvdSBndWVzcyB3cm9uZy4gIEhvd2V2ZXIsIHRoZXJlXG4vLyBhcmUgbGlrZWx5IGZhciBtb3JlIG5vcm1hbCBmaWxlcyBpbiB0aGUgd29ybGQgdGhhbiBkaXJlY3Rvcmllcy4gIFRoaXNcbi8vIGlzIGJhc2VkIG9uIHRoZSBhc3N1bXB0aW9uIHRoYXQgYSB0aGUgYXZlcmFnZSBudW1iZXIgb2YgZmlsZXMgcGVyXG4vLyBkaXJlY3RvcnkgaXMgPj0gMS5cbi8vXG4vLyBJZiBhbnlvbmUgZXZlciBjb21wbGFpbnMgYWJvdXQgdGhpcywgdGhlbiBJIGd1ZXNzIHRoZSBzdHJhdGVneSBjb3VsZFxuLy8gYmUgbWFkZSBjb25maWd1cmFibGUgc29tZWhvdy4gIEJ1dCB1bnRpbCB0aGVuLCBZQUdOSS5cbmZ1bmN0aW9uIHJpbXJhZl8gKHAsIG9wdGlvbnMsIGNiKSB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgYXNzZXJ0KHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcblxuICAvLyBzdW5vcyBsZXRzIHRoZSByb290IHVzZXIgdW5saW5rIGRpcmVjdG9yaWVzLCB3aGljaCBpcy4uLiB3ZWlyZC5cbiAgLy8gc28gd2UgaGF2ZSB0byBsc3RhdCBoZXJlIGFuZCBtYWtlIHN1cmUgaXQncyBub3QgYSBkaXIuXG4gIG9wdGlvbnMubHN0YXQocCwgKGVyLCBzdCkgPT4ge1xuICAgIGlmIChlciAmJiBlci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgcmV0dXJuIGNiKG51bGwpXG4gICAgfVxuXG4gICAgLy8gV2luZG93cyBjYW4gRVBFUk0gb24gc3RhdC4gIExpZmUgaXMgc3VmZmVyaW5nLlxuICAgIGlmIChlciAmJiBlci5jb2RlID09PSAnRVBFUk0nICYmIGlzV2luZG93cykge1xuICAgICAgcmV0dXJuIGZpeFdpbkVQRVJNKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICB9XG5cbiAgICBpZiAoc3QgJiYgc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgcmV0dXJuIHJtZGlyKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICB9XG5cbiAgICBvcHRpb25zLnVubGluayhwLCBlciA9PiB7XG4gICAgICBpZiAoZXIpIHtcbiAgICAgICAgaWYgKGVyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKG51bGwpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVyLmNvZGUgPT09ICdFUEVSTScpIHtcbiAgICAgICAgICByZXR1cm4gKGlzV2luZG93cylcbiAgICAgICAgICAgID8gZml4V2luRVBFUk0ocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgICAgICAgICAgOiBybWRpcihwLCBvcHRpb25zLCBlciwgY2IpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVyLmNvZGUgPT09ICdFSVNESVInKSB7XG4gICAgICAgICAgcmV0dXJuIHJtZGlyKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNiKGVyKVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGZpeFdpbkVQRVJNIChwLCBvcHRpb25zLCBlciwgY2IpIHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBhc3NlcnQodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuXG4gIG9wdGlvbnMuY2htb2QocCwgMG82NjYsIGVyMiA9PiB7XG4gICAgaWYgKGVyMikge1xuICAgICAgY2IoZXIyLmNvZGUgPT09ICdFTk9FTlQnID8gbnVsbCA6IGVyKVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLnN0YXQocCwgKGVyMywgc3RhdHMpID0+IHtcbiAgICAgICAgaWYgKGVyMykge1xuICAgICAgICAgIGNiKGVyMy5jb2RlID09PSAnRU5PRU5UJyA/IG51bGwgOiBlcilcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgcm1kaXIocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMudW5saW5rKHAsIGNiKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gZml4V2luRVBFUk1TeW5jIChwLCBvcHRpb25zLCBlcikge1xuICBsZXQgc3RhdHNcblxuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG5cbiAgdHJ5IHtcbiAgICBvcHRpb25zLmNobW9kU3luYyhwLCAwbzY2NilcbiAgfSBjYXRjaCAoZXIyKSB7XG4gICAgaWYgKGVyMi5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyXG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICBzdGF0cyA9IG9wdGlvbnMuc3RhdFN5bmMocClcbiAgfSBjYXRjaCAoZXIzKSB7XG4gICAgaWYgKGVyMy5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyXG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICBybWRpclN5bmMocCwgb3B0aW9ucywgZXIpXG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy51bmxpbmtTeW5jKHApXG4gIH1cbn1cblxuZnVuY3Rpb24gcm1kaXIgKHAsIG9wdGlvbnMsIG9yaWdpbmFsRXIsIGNiKSB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgYXNzZXJ0KHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcblxuICAvLyB0cnkgdG8gcm1kaXIgZmlyc3QsIGFuZCBvbmx5IHJlYWRkaXIgb24gRU5PVEVNUFRZIG9yIEVFWElTVCAoU3VuT1MpXG4gIC8vIGlmIHdlIGd1ZXNzZWQgd3JvbmcsIGFuZCBpdCdzIG5vdCBhIGRpcmVjdG9yeSwgdGhlblxuICAvLyByYWlzZSB0aGUgb3JpZ2luYWwgZXJyb3IuXG4gIG9wdGlvbnMucm1kaXIocCwgZXIgPT4ge1xuICAgIGlmIChlciAmJiAoZXIuY29kZSA9PT0gJ0VOT1RFTVBUWScgfHwgZXIuY29kZSA9PT0gJ0VFWElTVCcgfHwgZXIuY29kZSA9PT0gJ0VQRVJNJykpIHtcbiAgICAgIHJta2lkcyhwLCBvcHRpb25zLCBjYilcbiAgICB9IGVsc2UgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFTk9URElSJykge1xuICAgICAgY2Iob3JpZ2luYWxFcilcbiAgICB9IGVsc2Uge1xuICAgICAgY2IoZXIpXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBybWtpZHMgKHAsIG9wdGlvbnMsIGNiKSB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgYXNzZXJ0KHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcblxuICBvcHRpb25zLnJlYWRkaXIocCwgKGVyLCBmaWxlcykgPT4ge1xuICAgIGlmIChlcikgcmV0dXJuIGNiKGVyKVxuXG4gICAgbGV0IG4gPSBmaWxlcy5sZW5ndGhcbiAgICBsZXQgZXJyU3RhdGVcblxuICAgIGlmIChuID09PSAwKSByZXR1cm4gb3B0aW9ucy5ybWRpcihwLCBjYilcblxuICAgIGZpbGVzLmZvckVhY2goZiA9PiB7XG4gICAgICByaW1yYWYocGF0aC5qb2luKHAsIGYpLCBvcHRpb25zLCBlciA9PiB7XG4gICAgICAgIGlmIChlcnJTdGF0ZSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmIChlcikgcmV0dXJuIGNiKGVyclN0YXRlID0gZXIpXG4gICAgICAgIGlmICgtLW4gPT09IDApIHtcbiAgICAgICAgICBvcHRpb25zLnJtZGlyKHAsIGNiKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbi8vIHRoaXMgbG9va3Mgc2ltcGxlciwgYW5kIGlzIHN0cmljdGx5ICpmYXN0ZXIqLCBidXQgd2lsbFxuLy8gdGllIHVwIHRoZSBKYXZhU2NyaXB0IHRocmVhZCBhbmQgZmFpbCBvbiBleGNlc3NpdmVseVxuLy8gZGVlcCBkaXJlY3RvcnkgdHJlZXMuXG5mdW5jdGlvbiByaW1yYWZTeW5jIChwLCBvcHRpb25zKSB7XG4gIGxldCBzdFxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIGRlZmF1bHRzKG9wdGlvbnMpXG5cbiAgYXNzZXJ0KHAsICdyaW1yYWY6IG1pc3NpbmcgcGF0aCcpXG4gIGFzc2VydC5zdHJpY3RFcXVhbCh0eXBlb2YgcCwgJ3N0cmluZycsICdyaW1yYWY6IHBhdGggc2hvdWxkIGJlIGEgc3RyaW5nJylcbiAgYXNzZXJ0KG9wdGlvbnMsICdyaW1yYWY6IG1pc3Npbmcgb3B0aW9ucycpXG4gIGFzc2VydC5zdHJpY3RFcXVhbCh0eXBlb2Ygb3B0aW9ucywgJ29iamVjdCcsICdyaW1yYWY6IG9wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCcpXG5cbiAgdHJ5IHtcbiAgICBzdCA9IG9wdGlvbnMubHN0YXRTeW5jKHApXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgaWYgKGVyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBXaW5kb3dzIGNhbiBFUEVSTSBvbiBzdGF0LiAgTGlmZSBpcyBzdWZmZXJpbmcuXG4gICAgaWYgKGVyLmNvZGUgPT09ICdFUEVSTScgJiYgaXNXaW5kb3dzKSB7XG4gICAgICBmaXhXaW5FUEVSTVN5bmMocCwgb3B0aW9ucywgZXIpXG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBzdW5vcyBsZXRzIHRoZSByb290IHVzZXIgdW5saW5rIGRpcmVjdG9yaWVzLCB3aGljaCBpcy4uLiB3ZWlyZC5cbiAgICBpZiAoc3QgJiYgc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgcm1kaXJTeW5jKHAsIG9wdGlvbnMsIG51bGwpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMudW5saW5rU3luYyhwKVxuICAgIH1cbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSBpZiAoZXIuY29kZSA9PT0gJ0VQRVJNJykge1xuICAgICAgcmV0dXJuIGlzV2luZG93cyA/IGZpeFdpbkVQRVJNU3luYyhwLCBvcHRpb25zLCBlcikgOiBybWRpclN5bmMocCwgb3B0aW9ucywgZXIpXG4gICAgfSBlbHNlIGlmIChlci5jb2RlICE9PSAnRUlTRElSJykge1xuICAgICAgdGhyb3cgZXJcbiAgICB9XG4gICAgcm1kaXJTeW5jKHAsIG9wdGlvbnMsIGVyKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJtZGlyU3luYyAocCwgb3B0aW9ucywgb3JpZ2luYWxFcikge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG5cbiAgdHJ5IHtcbiAgICBvcHRpb25zLnJtZGlyU3luYyhwKVxuICB9IGNhdGNoIChlcikge1xuICAgIGlmIChlci5jb2RlID09PSAnRU5PVERJUicpIHtcbiAgICAgIHRocm93IG9yaWdpbmFsRXJcbiAgICB9IGVsc2UgaWYgKGVyLmNvZGUgPT09ICdFTk9URU1QVFknIHx8IGVyLmNvZGUgPT09ICdFRVhJU1QnIHx8IGVyLmNvZGUgPT09ICdFUEVSTScpIHtcbiAgICAgIHJta2lkc1N5bmMocCwgb3B0aW9ucylcbiAgICB9IGVsc2UgaWYgKGVyLmNvZGUgIT09ICdFTk9FTlQnKSB7XG4gICAgICB0aHJvdyBlclxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBybWtpZHNTeW5jIChwLCBvcHRpb25zKSB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgb3B0aW9ucy5yZWFkZGlyU3luYyhwKS5mb3JFYWNoKGYgPT4gcmltcmFmU3luYyhwYXRoLmpvaW4ocCwgZiksIG9wdGlvbnMpKVxuXG4gIGlmIChpc1dpbmRvd3MpIHtcbiAgICAvLyBXZSBvbmx5IGVuZCB1cCBoZXJlIG9uY2Ugd2UgZ290IEVOT1RFTVBUWSBhdCBsZWFzdCBvbmNlLCBhbmRcbiAgICAvLyBhdCB0aGlzIHBvaW50LCB3ZSBhcmUgZ3VhcmFudGVlZCB0byBoYXZlIHJlbW92ZWQgYWxsIHRoZSBraWRzLlxuICAgIC8vIFNvLCB3ZSBrbm93IHRoYXQgaXQgd29uJ3QgYmUgRU5PRU5UIG9yIEVOT1RESVIgb3IgYW55dGhpbmcgZWxzZS5cbiAgICAvLyB0cnkgcmVhbGx5IGhhcmQgdG8gZGVsZXRlIHN0dWZmIG9uIHdpbmRvd3MsIGJlY2F1c2UgaXQgaGFzIGFcbiAgICAvLyBQUk9GT1VORExZIGFubm95aW5nIGhhYml0IG9mIG5vdCBjbG9zaW5nIGhhbmRsZXMgcHJvbXB0bHkgd2hlblxuICAgIC8vIGZpbGVzIGFyZSBkZWxldGVkLCByZXN1bHRpbmcgaW4gc3B1cmlvdXMgRU5PVEVNUFRZIGVycm9ycy5cbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpXG4gICAgZG8ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0ID0gb3B0aW9ucy5ybWRpclN5bmMocCwgb3B0aW9ucylcbiAgICAgICAgcmV0dXJuIHJldFxuICAgICAgfSBjYXRjaCB7fVxuICAgIH0gd2hpbGUgKERhdGUubm93KCkgLSBzdGFydFRpbWUgPCA1MDApIC8vIGdpdmUgdXAgYWZ0ZXIgNTAwbXNcbiAgfSBlbHNlIHtcbiAgICBjb25zdCByZXQgPSBvcHRpb25zLnJtZGlyU3luYyhwLCBvcHRpb25zKVxuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJpbXJhZlxucmltcmFmLnN5bmMgPSByaW1yYWZTeW5jXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCByaW1yYWYgPSByZXF1aXJlKCcuL3JpbXJhZicpXG5cbmZ1bmN0aW9uIHJlbW92ZSAocGF0aCwgY2FsbGJhY2spIHtcbiAgLy8gTm9kZSAxNC4xNC4wK1xuICBpZiAoZnMucm0pIHJldHVybiBmcy5ybShwYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSwgY2FsbGJhY2spXG4gIHJpbXJhZihwYXRoLCBjYWxsYmFjaylcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3luYyAocGF0aCkge1xuICAvLyBOb2RlIDE0LjE0LjArXG4gIGlmIChmcy5ybVN5bmMpIHJldHVybiBmcy5ybVN5bmMocGF0aCwgeyByZWN1cnNpdmU6IHRydWUsIGZvcmNlOiB0cnVlIH0pXG4gIHJpbXJhZi5zeW5jKHBhdGgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZW1vdmU6IHUocmVtb3ZlKSxcbiAgcmVtb3ZlU3luY1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tUHJvbWlzZVxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBta2RpciA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5jb25zdCByZW1vdmUgPSByZXF1aXJlKCcuLi9yZW1vdmUnKVxuXG5jb25zdCBlbXB0eURpciA9IHUoYXN5bmMgZnVuY3Rpb24gZW1wdHlEaXIgKGRpcikge1xuICBsZXQgaXRlbXNcbiAgdHJ5IHtcbiAgICBpdGVtcyA9IGF3YWl0IGZzLnJlYWRkaXIoZGlyKVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbWtkaXIubWtkaXJzKGRpcilcbiAgfVxuXG4gIHJldHVybiBQcm9taXNlLmFsbChpdGVtcy5tYXAoaXRlbSA9PiByZW1vdmUucmVtb3ZlKHBhdGguam9pbihkaXIsIGl0ZW0pKSkpXG59KVxuXG5mdW5jdGlvbiBlbXB0eURpclN5bmMgKGRpcikge1xuICBsZXQgaXRlbXNcbiAgdHJ5IHtcbiAgICBpdGVtcyA9IGZzLnJlYWRkaXJTeW5jKGRpcilcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG1rZGlyLm1rZGlyc1N5bmMoZGlyKVxuICB9XG5cbiAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICBpdGVtID0gcGF0aC5qb2luKGRpciwgaXRlbSlcbiAgICByZW1vdmUucmVtb3ZlU3luYyhpdGVtKVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZW1wdHlEaXJTeW5jLFxuICBlbXB0eWRpclN5bmM6IGVtcHR5RGlyU3luYyxcbiAgZW1wdHlEaXIsXG4gIGVtcHR5ZGlyOiBlbXB0eURpclxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgbWtkaXIgPSByZXF1aXJlKCcuLi9ta2RpcnMnKVxuXG5mdW5jdGlvbiBjcmVhdGVGaWxlIChmaWxlLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBtYWtlRmlsZSAoKSB7XG4gICAgZnMud3JpdGVGaWxlKGZpbGUsICcnLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9KVxuICB9XG5cbiAgZnMuc3RhdChmaWxlLCAoZXJyLCBzdGF0cykgPT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGhhbmRsZS1jYWxsYmFjay1lcnJcbiAgICBpZiAoIWVyciAmJiBzdGF0cy5pc0ZpbGUoKSkgcmV0dXJuIGNhbGxiYWNrKClcbiAgICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZmlsZSlcbiAgICBmcy5zdGF0KGRpciwgKGVyciwgc3RhdHMpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgLy8gaWYgdGhlIGRpcmVjdG9yeSBkb2Vzbid0IGV4aXN0LCBtYWtlIGl0XG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICByZXR1cm4gbWtkaXIubWtkaXJzKGRpciwgZXJyID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgICBtYWtlRmlsZSgpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkgbWFrZUZpbGUoKVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHBhcmVudCBpcyBub3QgYSBkaXJlY3RvcnlcbiAgICAgICAgLy8gVGhpcyBpcyBqdXN0IHRvIGNhdXNlIGFuIGludGVybmFsIEVOT1RESVIgZXJyb3IgdG8gYmUgdGhyb3duXG4gICAgICAgIGZzLnJlYWRkaXIoZGlyLCBlcnIgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmlsZVN5bmMgKGZpbGUpIHtcbiAgbGV0IHN0YXRzXG4gIHRyeSB7XG4gICAgc3RhdHMgPSBmcy5zdGF0U3luYyhmaWxlKVxuICB9IGNhdGNoIHt9XG4gIGlmIChzdGF0cyAmJiBzdGF0cy5pc0ZpbGUoKSkgcmV0dXJuXG5cbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGUpXG4gIHRyeSB7XG4gICAgaWYgKCFmcy5zdGF0U3luYyhkaXIpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIC8vIHBhcmVudCBpcyBub3QgYSBkaXJlY3RvcnlcbiAgICAgIC8vIFRoaXMgaXMganVzdCB0byBjYXVzZSBhbiBpbnRlcm5hbCBFTk9URElSIGVycm9yIHRvIGJlIHRocm93blxuICAgICAgZnMucmVhZGRpclN5bmMoZGlyKVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gSWYgdGhlIHN0YXQgY2FsbCBhYm92ZSBmYWlsZWQgYmVjYXVzZSB0aGUgZGlyZWN0b3J5IGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBpdFxuICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09ICdFTk9FTlQnKSBta2Rpci5ta2RpcnNTeW5jKGRpcilcbiAgICBlbHNlIHRocm93IGVyclxuICB9XG5cbiAgZnMud3JpdGVGaWxlU3luYyhmaWxlLCAnJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZUZpbGU6IHUoY3JlYXRlRmlsZSksXG4gIGNyZWF0ZUZpbGVTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBta2RpciA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKS5wYXRoRXhpc3RzXG5jb25zdCB7IGFyZUlkZW50aWNhbCB9ID0gcmVxdWlyZSgnLi4vdXRpbC9zdGF0JylcblxuZnVuY3Rpb24gY3JlYXRlTGluayAoc3JjcGF0aCwgZHN0cGF0aCwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gbWFrZUxpbmsgKHNyY3BhdGgsIGRzdHBhdGgpIHtcbiAgICBmcy5saW5rKHNyY3BhdGgsIGRzdHBhdGgsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgY2FsbGJhY2sobnVsbClcbiAgICB9KVxuICB9XG5cbiAgZnMubHN0YXQoZHN0cGF0aCwgKF8sIGRzdFN0YXQpID0+IHtcbiAgICBmcy5sc3RhdChzcmNwYXRoLCAoZXJyLCBzcmNTdGF0KSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGVyci5tZXNzYWdlID0gZXJyLm1lc3NhZ2UucmVwbGFjZSgnbHN0YXQnLCAnZW5zdXJlTGluaycpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG4gICAgICBpZiAoZHN0U3RhdCAmJiBhcmVJZGVudGljYWwoc3JjU3RhdCwgZHN0U3RhdCkpIHJldHVybiBjYWxsYmFjayhudWxsKVxuXG4gICAgICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgICAgIHBhdGhFeGlzdHMoZGlyLCAoZXJyLCBkaXJFeGlzdHMpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgaWYgKGRpckV4aXN0cykgcmV0dXJuIG1ha2VMaW5rKHNyY3BhdGgsIGRzdHBhdGgpXG4gICAgICAgIG1rZGlyLm1rZGlycyhkaXIsIGVyciA9PiB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgICBtYWtlTGluayhzcmNwYXRoLCBkc3RwYXRoKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rU3luYyAoc3JjcGF0aCwgZHN0cGF0aCkge1xuICBsZXQgZHN0U3RhdFxuICB0cnkge1xuICAgIGRzdFN0YXQgPSBmcy5sc3RhdFN5bmMoZHN0cGF0aClcbiAgfSBjYXRjaCB7fVxuXG4gIHRyeSB7XG4gICAgY29uc3Qgc3JjU3RhdCA9IGZzLmxzdGF0U3luYyhzcmNwYXRoKVxuICAgIGlmIChkc3RTdGF0ICYmIGFyZUlkZW50aWNhbChzcmNTdGF0LCBkc3RTdGF0KSkgcmV0dXJuXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5tZXNzYWdlID0gZXJyLm1lc3NhZ2UucmVwbGFjZSgnbHN0YXQnLCAnZW5zdXJlTGluaycpXG4gICAgdGhyb3cgZXJyXG4gIH1cblxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgY29uc3QgZGlyRXhpc3RzID0gZnMuZXhpc3RzU3luYyhkaXIpXG4gIGlmIChkaXJFeGlzdHMpIHJldHVybiBmcy5saW5rU3luYyhzcmNwYXRoLCBkc3RwYXRoKVxuICBta2Rpci5ta2RpcnNTeW5jKGRpcilcblxuICByZXR1cm4gZnMubGlua1N5bmMoc3JjcGF0aCwgZHN0cGF0aClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZUxpbms6IHUoY3JlYXRlTGluayksXG4gIGNyZWF0ZUxpbmtTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKS5wYXRoRXhpc3RzXG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCByZXR1cm5zIHR3byB0eXBlcyBvZiBwYXRocywgb25lIHJlbGF0aXZlIHRvIHN5bWxpbmssIGFuZCBvbmVcbiAqIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LiBDaGVja3MgaWYgcGF0aCBpcyBhYnNvbHV0ZSBvclxuICogcmVsYXRpdmUuIElmIHRoZSBwYXRoIGlzIHJlbGF0aXZlLCB0aGlzIGZ1bmN0aW9uIGNoZWNrcyBpZiB0aGUgcGF0aCBpc1xuICogcmVsYXRpdmUgdG8gc3ltbGluayBvciByZWxhdGl2ZSB0byBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LiBUaGlzIGlzIGFuXG4gKiBpbml0aWF0aXZlIHRvIGZpbmQgYSBzbWFydGVyIGBzcmNwYXRoYCB0byBzdXBwbHkgd2hlbiBidWlsZGluZyBzeW1saW5rcy5cbiAqIFRoaXMgYWxsb3dzIHlvdSB0byBkZXRlcm1pbmUgd2hpY2ggcGF0aCB0byB1c2Ugb3V0IG9mIG9uZSBvZiB0aHJlZSBwb3NzaWJsZVxuICogdHlwZXMgb2Ygc291cmNlIHBhdGhzLiBUaGUgZmlyc3QgaXMgYW4gYWJzb2x1dGUgcGF0aC4gVGhpcyBpcyBkZXRlY3RlZCBieVxuICogYHBhdGguaXNBYnNvbHV0ZSgpYC4gV2hlbiBhbiBhYnNvbHV0ZSBwYXRoIGlzIHByb3ZpZGVkLCBpdCBpcyBjaGVja2VkIHRvXG4gKiBzZWUgaWYgaXQgZXhpc3RzLiBJZiBpdCBkb2VzIGl0J3MgdXNlZCwgaWYgbm90IGFuIGVycm9yIGlzIHJldHVybmVkXG4gKiAoY2FsbGJhY2spLyB0aHJvd24gKHN5bmMpLiBUaGUgb3RoZXIgdHdvIG9wdGlvbnMgZm9yIGBzcmNwYXRoYCBhcmUgYVxuICogcmVsYXRpdmUgdXJsLiBCeSBkZWZhdWx0IE5vZGUncyBgZnMuc3ltbGlua2Agd29ya3MgYnkgY3JlYXRpbmcgYSBzeW1saW5rXG4gKiB1c2luZyBgZHN0cGF0aGAgYW5kIGV4cGVjdHMgdGhlIGBzcmNwYXRoYCB0byBiZSByZWxhdGl2ZSB0byB0aGUgbmV3bHlcbiAqIGNyZWF0ZWQgc3ltbGluay4gSWYgeW91IHByb3ZpZGUgYSBgc3JjcGF0aGAgdGhhdCBkb2VzIG5vdCBleGlzdCBvbiB0aGUgZmlsZVxuICogc3lzdGVtIGl0IHJlc3VsdHMgaW4gYSBicm9rZW4gc3ltbGluay4gVG8gbWluaW1pemUgdGhpcywgdGhlIGZ1bmN0aW9uXG4gKiBjaGVja3MgdG8gc2VlIGlmIHRoZSAncmVsYXRpdmUgdG8gc3ltbGluaycgc291cmNlIGZpbGUgZXhpc3RzLCBhbmQgaWYgaXRcbiAqIGRvZXMgaXQgd2lsbCB1c2UgaXQuIElmIGl0IGRvZXMgbm90LCBpdCBjaGVja3MgaWYgdGhlcmUncyBhIGZpbGUgdGhhdFxuICogZXhpc3RzIHRoYXQgaXMgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnksIGlmIGRvZXMgaXRzIHVzZWQuXG4gKiBUaGlzIHByZXNlcnZlcyB0aGUgZXhwZWN0YXRpb25zIG9mIHRoZSBvcmlnaW5hbCBmcy5zeW1saW5rIHNwZWMgYW5kIGFkZHNcbiAqIHRoZSBhYmlsaXR5IHRvIHBhc3MgaW4gYHJlbGF0aXZlIHRvIGN1cnJlbnQgd29ya2luZyBkaXJlY290cnlgIHBhdGhzLlxuICovXG5cbmZ1bmN0aW9uIHN5bWxpbmtQYXRocyAoc3JjcGF0aCwgZHN0cGF0aCwgY2FsbGJhY2spIHtcbiAgaWYgKHBhdGguaXNBYnNvbHV0ZShzcmNwYXRoKSkge1xuICAgIHJldHVybiBmcy5sc3RhdChzcmNwYXRoLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGVyci5tZXNzYWdlID0gZXJyLm1lc3NhZ2UucmVwbGFjZSgnbHN0YXQnLCAnZW5zdXJlU3ltbGluaycpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwge1xuICAgICAgICB0b0N3ZDogc3JjcGF0aCxcbiAgICAgICAgdG9Ec3Q6IHNyY3BhdGhcbiAgICAgIH0pXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBkc3RkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgICBjb25zdCByZWxhdGl2ZVRvRHN0ID0gcGF0aC5qb2luKGRzdGRpciwgc3JjcGF0aClcbiAgICByZXR1cm4gcGF0aEV4aXN0cyhyZWxhdGl2ZVRvRHN0LCAoZXJyLCBleGlzdHMpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICBpZiAoZXhpc3RzKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgdG9Dd2Q6IHJlbGF0aXZlVG9Ec3QsXG4gICAgICAgICAgdG9Ec3Q6IHNyY3BhdGhcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmcy5sc3RhdChzcmNwYXRoLCAoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBlcnIubWVzc2FnZS5yZXBsYWNlKCdsc3RhdCcsICdlbnN1cmVTeW1saW5rJylcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgICB0b0N3ZDogc3JjcGF0aCxcbiAgICAgICAgICAgIHRvRHN0OiBwYXRoLnJlbGF0aXZlKGRzdGRpciwgc3JjcGF0aClcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gc3ltbGlua1BhdGhzU3luYyAoc3JjcGF0aCwgZHN0cGF0aCkge1xuICBsZXQgZXhpc3RzXG4gIGlmIChwYXRoLmlzQWJzb2x1dGUoc3JjcGF0aCkpIHtcbiAgICBleGlzdHMgPSBmcy5leGlzdHNTeW5jKHNyY3BhdGgpXG4gICAgaWYgKCFleGlzdHMpIHRocm93IG5ldyBFcnJvcignYWJzb2x1dGUgc3JjcGF0aCBkb2VzIG5vdCBleGlzdCcpXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvQ3dkOiBzcmNwYXRoLFxuICAgICAgdG9Ec3Q6IHNyY3BhdGhcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZHN0ZGlyID0gcGF0aC5kaXJuYW1lKGRzdHBhdGgpXG4gICAgY29uc3QgcmVsYXRpdmVUb0RzdCA9IHBhdGguam9pbihkc3RkaXIsIHNyY3BhdGgpXG4gICAgZXhpc3RzID0gZnMuZXhpc3RzU3luYyhyZWxhdGl2ZVRvRHN0KVxuICAgIGlmIChleGlzdHMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvQ3dkOiByZWxhdGl2ZVRvRHN0LFxuICAgICAgICB0b0RzdDogc3JjcGF0aFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdHMgPSBmcy5leGlzdHNTeW5jKHNyY3BhdGgpXG4gICAgICBpZiAoIWV4aXN0cykgdGhyb3cgbmV3IEVycm9yKCdyZWxhdGl2ZSBzcmNwYXRoIGRvZXMgbm90IGV4aXN0JylcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvQ3dkOiBzcmNwYXRoLFxuICAgICAgICB0b0RzdDogcGF0aC5yZWxhdGl2ZShkc3RkaXIsIHNyY3BhdGgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzeW1saW5rUGF0aHMsXG4gIHN5bWxpbmtQYXRoc1N5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcblxuZnVuY3Rpb24gc3ltbGlua1R5cGUgKHNyY3BhdGgsIHR5cGUsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSA/IHR5cGUgOiBjYWxsYmFja1xuICB0eXBlID0gKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSA/IGZhbHNlIDogdHlwZVxuICBpZiAodHlwZSkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHR5cGUpXG4gIGZzLmxzdGF0KHNyY3BhdGgsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKG51bGwsICdmaWxlJylcbiAgICB0eXBlID0gKHN0YXRzICYmIHN0YXRzLmlzRGlyZWN0b3J5KCkpID8gJ2RpcicgOiAnZmlsZSdcbiAgICBjYWxsYmFjayhudWxsLCB0eXBlKVxuICB9KVxufVxuXG5mdW5jdGlvbiBzeW1saW5rVHlwZVN5bmMgKHNyY3BhdGgsIHR5cGUpIHtcbiAgbGV0IHN0YXRzXG5cbiAgaWYgKHR5cGUpIHJldHVybiB0eXBlXG4gIHRyeSB7XG4gICAgc3RhdHMgPSBmcy5sc3RhdFN5bmMoc3JjcGF0aClcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICdmaWxlJ1xuICB9XG4gIHJldHVybiAoc3RhdHMgJiYgc3RhdHMuaXNEaXJlY3RvcnkoKSkgPyAnZGlyJyA6ICdmaWxlJ1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3ltbGlua1R5cGUsXG4gIHN5bWxpbmtUeXBlU3luY1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vZnMnKVxuY29uc3QgX21rZGlycyA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5jb25zdCBta2RpcnMgPSBfbWtkaXJzLm1rZGlyc1xuY29uc3QgbWtkaXJzU3luYyA9IF9ta2RpcnMubWtkaXJzU3luY1xuXG5jb25zdCBfc3ltbGlua1BhdGhzID0gcmVxdWlyZSgnLi9zeW1saW5rLXBhdGhzJylcbmNvbnN0IHN5bWxpbmtQYXRocyA9IF9zeW1saW5rUGF0aHMuc3ltbGlua1BhdGhzXG5jb25zdCBzeW1saW5rUGF0aHNTeW5jID0gX3N5bWxpbmtQYXRocy5zeW1saW5rUGF0aHNTeW5jXG5cbmNvbnN0IF9zeW1saW5rVHlwZSA9IHJlcXVpcmUoJy4vc3ltbGluay10eXBlJylcbmNvbnN0IHN5bWxpbmtUeXBlID0gX3N5bWxpbmtUeXBlLnN5bWxpbmtUeXBlXG5jb25zdCBzeW1saW5rVHlwZVN5bmMgPSBfc3ltbGlua1R5cGUuc3ltbGlua1R5cGVTeW5jXG5cbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpLnBhdGhFeGlzdHNcblxuY29uc3QgeyBhcmVJZGVudGljYWwgfSA9IHJlcXVpcmUoJy4uL3V0aWwvc3RhdCcpXG5cbmZ1bmN0aW9uIGNyZWF0ZVN5bWxpbmsgKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSA/IHR5cGUgOiBjYWxsYmFja1xuICB0eXBlID0gKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSA/IGZhbHNlIDogdHlwZVxuXG4gIGZzLmxzdGF0KGRzdHBhdGgsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgaWYgKCFlcnIgJiYgc3RhdHMuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICBmcy5zdGF0KHNyY3BhdGgpLFxuICAgICAgICBmcy5zdGF0KGRzdHBhdGgpXG4gICAgICBdKS50aGVuKChbc3JjU3RhdCwgZHN0U3RhdF0pID0+IHtcbiAgICAgICAgaWYgKGFyZUlkZW50aWNhbChzcmNTdGF0LCBkc3RTdGF0KSkgcmV0dXJuIGNhbGxiYWNrKG51bGwpXG4gICAgICAgIF9jcmVhdGVTeW1saW5rKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUsIGNhbGxiYWNrKVxuICAgICAgfSlcbiAgICB9IGVsc2UgX2NyZWF0ZVN5bWxpbmsoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSwgY2FsbGJhY2spXG4gIH0pXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTeW1saW5rIChzcmNwYXRoLCBkc3RwYXRoLCB0eXBlLCBjYWxsYmFjaykge1xuICBzeW1saW5rUGF0aHMoc3JjcGF0aCwgZHN0cGF0aCwgKGVyciwgcmVsYXRpdmUpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIHNyY3BhdGggPSByZWxhdGl2ZS50b0RzdFxuICAgIHN5bWxpbmtUeXBlKHJlbGF0aXZlLnRvQ3dkLCB0eXBlLCAoZXJyLCB0eXBlKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGRzdHBhdGgpXG4gICAgICBwYXRoRXhpc3RzKGRpciwgKGVyciwgZGlyRXhpc3RzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIGlmIChkaXJFeGlzdHMpIHJldHVybiBmcy5zeW1saW5rKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUsIGNhbGxiYWNrKVxuICAgICAgICBta2RpcnMoZGlyLCBlcnIgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgZnMuc3ltbGluayhzcmNwYXRoLCBkc3RwYXRoLCB0eXBlLCBjYWxsYmFjaylcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3ltbGlua1N5bmMgKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUpIHtcbiAgbGV0IHN0YXRzXG4gIHRyeSB7XG4gICAgc3RhdHMgPSBmcy5sc3RhdFN5bmMoZHN0cGF0aClcbiAgfSBjYXRjaCB7fVxuICBpZiAoc3RhdHMgJiYgc3RhdHMuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgIGNvbnN0IHNyY1N0YXQgPSBmcy5zdGF0U3luYyhzcmNwYXRoKVxuICAgIGNvbnN0IGRzdFN0YXQgPSBmcy5zdGF0U3luYyhkc3RwYXRoKVxuICAgIGlmIChhcmVJZGVudGljYWwoc3JjU3RhdCwgZHN0U3RhdCkpIHJldHVyblxuICB9XG5cbiAgY29uc3QgcmVsYXRpdmUgPSBzeW1saW5rUGF0aHNTeW5jKHNyY3BhdGgsIGRzdHBhdGgpXG4gIHNyY3BhdGggPSByZWxhdGl2ZS50b0RzdFxuICB0eXBlID0gc3ltbGlua1R5cGVTeW5jKHJlbGF0aXZlLnRvQ3dkLCB0eXBlKVxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgY29uc3QgZXhpc3RzID0gZnMuZXhpc3RzU3luYyhkaXIpXG4gIGlmIChleGlzdHMpIHJldHVybiBmcy5zeW1saW5rU3luYyhzcmNwYXRoLCBkc3RwYXRoLCB0eXBlKVxuICBta2RpcnNTeW5jKGRpcilcbiAgcmV0dXJuIGZzLnN5bWxpbmtTeW5jKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVTeW1saW5rOiB1KGNyZWF0ZVN5bWxpbmspLFxuICBjcmVhdGVTeW1saW5rU3luY1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgY3JlYXRlRmlsZSwgY3JlYXRlRmlsZVN5bmMgfSA9IHJlcXVpcmUoJy4vZmlsZScpXG5jb25zdCB7IGNyZWF0ZUxpbmssIGNyZWF0ZUxpbmtTeW5jIH0gPSByZXF1aXJlKCcuL2xpbmsnKVxuY29uc3QgeyBjcmVhdGVTeW1saW5rLCBjcmVhdGVTeW1saW5rU3luYyB9ID0gcmVxdWlyZSgnLi9zeW1saW5rJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGZpbGVcbiAgY3JlYXRlRmlsZSxcbiAgY3JlYXRlRmlsZVN5bmMsXG4gIGVuc3VyZUZpbGU6IGNyZWF0ZUZpbGUsXG4gIGVuc3VyZUZpbGVTeW5jOiBjcmVhdGVGaWxlU3luYyxcbiAgLy8gbGlua1xuICBjcmVhdGVMaW5rLFxuICBjcmVhdGVMaW5rU3luYyxcbiAgZW5zdXJlTGluazogY3JlYXRlTGluayxcbiAgZW5zdXJlTGlua1N5bmM6IGNyZWF0ZUxpbmtTeW5jLFxuICAvLyBzeW1saW5rXG4gIGNyZWF0ZVN5bWxpbmssXG4gIGNyZWF0ZVN5bWxpbmtTeW5jLFxuICBlbnN1cmVTeW1saW5rOiBjcmVhdGVTeW1saW5rLFxuICBlbnN1cmVTeW1saW5rU3luYzogY3JlYXRlU3ltbGlua1N5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBqc29uRmlsZSA9IHJlcXVpcmUoJ2pzb25maWxlJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGpzb25maWxlIGV4cG9ydHNcbiAgcmVhZEpzb246IGpzb25GaWxlLnJlYWRGaWxlLFxuICByZWFkSnNvblN5bmM6IGpzb25GaWxlLnJlYWRGaWxlU3luYyxcbiAgd3JpdGVKc29uOiBqc29uRmlsZS53cml0ZUZpbGUsXG4gIHdyaXRlSnNvblN5bmM6IGpzb25GaWxlLndyaXRlRmlsZVN5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpLnBhdGhFeGlzdHNcblxuZnVuY3Rpb24gb3V0cHV0RmlsZSAoZmlsZSwgZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShmaWxlKVxuICBwYXRoRXhpc3RzKGRpciwgKGVyciwgaXREb2VzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICBpZiAoaXREb2VzKSByZXR1cm4gZnMud3JpdGVGaWxlKGZpbGUsIGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaylcblxuICAgIG1rZGlyLm1rZGlycyhkaXIsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuXG4gICAgICBmcy53cml0ZUZpbGUoZmlsZSwgZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG91dHB1dEZpbGVTeW5jIChmaWxlLCAuLi5hcmdzKSB7XG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShmaWxlKVxuICBpZiAoZnMuZXhpc3RzU3luYyhkaXIpKSB7XG4gICAgcmV0dXJuIGZzLndyaXRlRmlsZVN5bmMoZmlsZSwgLi4uYXJncylcbiAgfVxuICBta2Rpci5ta2RpcnNTeW5jKGRpcilcbiAgZnMud3JpdGVGaWxlU3luYyhmaWxlLCAuLi5hcmdzKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgb3V0cHV0RmlsZTogdShvdXRwdXRGaWxlKSxcbiAgb3V0cHV0RmlsZVN5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHN0cmluZ2lmeSB9ID0gcmVxdWlyZSgnanNvbmZpbGUvdXRpbHMnKVxuY29uc3QgeyBvdXRwdXRGaWxlIH0gPSByZXF1aXJlKCcuLi9vdXRwdXQtZmlsZScpXG5cbmFzeW5jIGZ1bmN0aW9uIG91dHB1dEpzb24gKGZpbGUsIGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBzdHIgPSBzdHJpbmdpZnkoZGF0YSwgb3B0aW9ucylcblxuICBhd2FpdCBvdXRwdXRGaWxlKGZpbGUsIHN0ciwgb3B0aW9ucylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdXRwdXRKc29uXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBzdHJpbmdpZnkgfSA9IHJlcXVpcmUoJ2pzb25maWxlL3V0aWxzJylcbmNvbnN0IHsgb3V0cHV0RmlsZVN5bmMgfSA9IHJlcXVpcmUoJy4uL291dHB1dC1maWxlJylcblxuZnVuY3Rpb24gb3V0cHV0SnNvblN5bmMgKGZpbGUsIGRhdGEsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc3RyID0gc3RyaW5naWZ5KGRhdGEsIG9wdGlvbnMpXG5cbiAgb3V0cHV0RmlsZVN5bmMoZmlsZSwgc3RyLCBvcHRpb25zKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG91dHB1dEpzb25TeW5jXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21Qcm9taXNlXG5jb25zdCBqc29uRmlsZSA9IHJlcXVpcmUoJy4vanNvbmZpbGUnKVxuXG5qc29uRmlsZS5vdXRwdXRKc29uID0gdShyZXF1aXJlKCcuL291dHB1dC1qc29uJykpXG5qc29uRmlsZS5vdXRwdXRKc29uU3luYyA9IHJlcXVpcmUoJy4vb3V0cHV0LWpzb24tc3luYycpXG4vLyBhbGlhc2VzXG5qc29uRmlsZS5vdXRwdXRKU09OID0ganNvbkZpbGUub3V0cHV0SnNvblxuanNvbkZpbGUub3V0cHV0SlNPTlN5bmMgPSBqc29uRmlsZS5vdXRwdXRKc29uU3luY1xuanNvbkZpbGUud3JpdGVKU09OID0ganNvbkZpbGUud3JpdGVKc29uXG5qc29uRmlsZS53cml0ZUpTT05TeW5jID0ganNvbkZpbGUud3JpdGVKc29uU3luY1xuanNvbkZpbGUucmVhZEpTT04gPSBqc29uRmlsZS5yZWFkSnNvblxuanNvbkZpbGUucmVhZEpTT05TeW5jID0ganNvbkZpbGUucmVhZEpzb25TeW5jXG5cbm1vZHVsZS5leHBvcnRzID0ganNvbkZpbGVcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGNvcHkgPSByZXF1aXJlKCcuLi9jb3B5JykuY29weVxuY29uc3QgcmVtb3ZlID0gcmVxdWlyZSgnLi4vcmVtb3ZlJykucmVtb3ZlXG5jb25zdCBta2RpcnAgPSByZXF1aXJlKCcuLi9ta2RpcnMnKS5ta2RpcnBcbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpLnBhdGhFeGlzdHNcbmNvbnN0IHN0YXQgPSByZXF1aXJlKCcuLi91dGlsL3N0YXQnKVxuXG5mdW5jdGlvbiBtb3ZlIChzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0c1xuICAgIG9wdHMgPSB7fVxuICB9XG5cbiAgb3B0cyA9IG9wdHMgfHwge31cblxuICBjb25zdCBvdmVyd3JpdGUgPSBvcHRzLm92ZXJ3cml0ZSB8fCBvcHRzLmNsb2JiZXIgfHwgZmFsc2VcblxuICBzdGF0LmNoZWNrUGF0aHMoc3JjLCBkZXN0LCAnbW92ZScsIG9wdHMsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBjb25zdCB7IHNyY1N0YXQsIGlzQ2hhbmdpbmdDYXNlID0gZmFsc2UgfSA9IHN0YXRzXG4gICAgc3RhdC5jaGVja1BhcmVudFBhdGhzKHNyYywgc3JjU3RhdCwgZGVzdCwgJ21vdmUnLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIGlmIChpc1BhcmVudFJvb3QoZGVzdCkpIHJldHVybiBkb1JlbmFtZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgaXNDaGFuZ2luZ0Nhc2UsIGNiKVxuICAgICAgbWtkaXJwKHBhdGguZGlybmFtZShkZXN0KSwgZXJyID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgICAgcmV0dXJuIGRvUmVuYW1lKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBpc0NoYW5naW5nQ2FzZSwgY2IpXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGlzUGFyZW50Um9vdCAoZGVzdCkge1xuICBjb25zdCBwYXJlbnQgPSBwYXRoLmRpcm5hbWUoZGVzdClcbiAgY29uc3QgcGFyc2VkUGF0aCA9IHBhdGgucGFyc2UocGFyZW50KVxuICByZXR1cm4gcGFyc2VkUGF0aC5yb290ID09PSBwYXJlbnRcbn1cblxuZnVuY3Rpb24gZG9SZW5hbWUgKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBpc0NoYW5naW5nQ2FzZSwgY2IpIHtcbiAgaWYgKGlzQ2hhbmdpbmdDYXNlKSByZXR1cm4gcmVuYW1lKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBjYilcbiAgaWYgKG92ZXJ3cml0ZSkge1xuICAgIHJldHVybiByZW1vdmUoZGVzdCwgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICByZXR1cm4gcmVuYW1lKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBjYilcbiAgICB9KVxuICB9XG4gIHBhdGhFeGlzdHMoZGVzdCwgKGVyciwgZGVzdEV4aXN0cykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgaWYgKGRlc3RFeGlzdHMpIHJldHVybiBjYihuZXcgRXJyb3IoJ2Rlc3QgYWxyZWFkeSBleGlzdHMuJykpXG4gICAgcmV0dXJuIHJlbmFtZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgY2IpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJlbmFtZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGNiKSB7XG4gIGZzLnJlbmFtZShzcmMsIGRlc3QsIGVyciA9PiB7XG4gICAgaWYgKCFlcnIpIHJldHVybiBjYigpXG4gICAgaWYgKGVyci5jb2RlICE9PSAnRVhERVYnKSByZXR1cm4gY2IoZXJyKVxuICAgIHJldHVybiBtb3ZlQWNyb3NzRGV2aWNlKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBjYilcbiAgfSlcbn1cblxuZnVuY3Rpb24gbW92ZUFjcm9zc0RldmljZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGNiKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgb3ZlcndyaXRlLFxuICAgIGVycm9yT25FeGlzdDogdHJ1ZVxuICB9XG4gIGNvcHkoc3JjLCBkZXN0LCBvcHRzLCBlcnIgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgcmV0dXJuIHJlbW92ZShzcmMsIGNiKVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1vdmVcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGNvcHlTeW5jID0gcmVxdWlyZSgnLi4vY29weScpLmNvcHlTeW5jXG5jb25zdCByZW1vdmVTeW5jID0gcmVxdWlyZSgnLi4vcmVtb3ZlJykucmVtb3ZlU3luY1xuY29uc3QgbWtkaXJwU3luYyA9IHJlcXVpcmUoJy4uL21rZGlycycpLm1rZGlycFN5bmNcbmNvbnN0IHN0YXQgPSByZXF1aXJlKCcuLi91dGlsL3N0YXQnKVxuXG5mdW5jdGlvbiBtb3ZlU3luYyAoc3JjLCBkZXN0LCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9XG4gIGNvbnN0IG92ZXJ3cml0ZSA9IG9wdHMub3ZlcndyaXRlIHx8IG9wdHMuY2xvYmJlciB8fCBmYWxzZVxuXG4gIGNvbnN0IHsgc3JjU3RhdCwgaXNDaGFuZ2luZ0Nhc2UgPSBmYWxzZSB9ID0gc3RhdC5jaGVja1BhdGhzU3luYyhzcmMsIGRlc3QsICdtb3ZlJywgb3B0cylcbiAgc3RhdC5jaGVja1BhcmVudFBhdGhzU3luYyhzcmMsIHNyY1N0YXQsIGRlc3QsICdtb3ZlJylcbiAgaWYgKCFpc1BhcmVudFJvb3QoZGVzdCkpIG1rZGlycFN5bmMocGF0aC5kaXJuYW1lKGRlc3QpKVxuICByZXR1cm4gZG9SZW5hbWUoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGlzQ2hhbmdpbmdDYXNlKVxufVxuXG5mdW5jdGlvbiBpc1BhcmVudFJvb3QgKGRlc3QpIHtcbiAgY29uc3QgcGFyZW50ID0gcGF0aC5kaXJuYW1lKGRlc3QpXG4gIGNvbnN0IHBhcnNlZFBhdGggPSBwYXRoLnBhcnNlKHBhcmVudClcbiAgcmV0dXJuIHBhcnNlZFBhdGgucm9vdCA9PT0gcGFyZW50XG59XG5cbmZ1bmN0aW9uIGRvUmVuYW1lIChzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgaXNDaGFuZ2luZ0Nhc2UpIHtcbiAgaWYgKGlzQ2hhbmdpbmdDYXNlKSByZXR1cm4gcmVuYW1lKHNyYywgZGVzdCwgb3ZlcndyaXRlKVxuICBpZiAob3ZlcndyaXRlKSB7XG4gICAgcmVtb3ZlU3luYyhkZXN0KVxuICAgIHJldHVybiByZW5hbWUoc3JjLCBkZXN0LCBvdmVyd3JpdGUpXG4gIH1cbiAgaWYgKGZzLmV4aXN0c1N5bmMoZGVzdCkpIHRocm93IG5ldyBFcnJvcignZGVzdCBhbHJlYWR5IGV4aXN0cy4nKVxuICByZXR1cm4gcmVuYW1lKHNyYywgZGVzdCwgb3ZlcndyaXRlKVxufVxuXG5mdW5jdGlvbiByZW5hbWUgKHNyYywgZGVzdCwgb3ZlcndyaXRlKSB7XG4gIHRyeSB7XG4gICAgZnMucmVuYW1lU3luYyhzcmMsIGRlc3QpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIuY29kZSAhPT0gJ0VYREVWJykgdGhyb3cgZXJyXG4gICAgcmV0dXJuIG1vdmVBY3Jvc3NEZXZpY2Uoc3JjLCBkZXN0LCBvdmVyd3JpdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gbW92ZUFjcm9zc0RldmljZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUpIHtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBvdmVyd3JpdGUsXG4gICAgZXJyb3JPbkV4aXN0OiB0cnVlXG4gIH1cbiAgY29weVN5bmMoc3JjLCBkZXN0LCBvcHRzKVxuICByZXR1cm4gcmVtb3ZlU3luYyhzcmMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbW92ZVN5bmNcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbW92ZTogdShyZXF1aXJlKCcuL21vdmUnKSksXG4gIG1vdmVTeW5jOiByZXF1aXJlKCcuL21vdmUtc3luYycpXG59XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIEV4cG9ydCBwcm9taXNlaWZpZWQgZ3JhY2VmdWwtZnM6XG4gIC4uLnJlcXVpcmUoJy4vZnMnKSxcbiAgLy8gRXhwb3J0IGV4dHJhIG1ldGhvZHM6XG4gIC4uLnJlcXVpcmUoJy4vY29weScpLFxuICAuLi5yZXF1aXJlKCcuL2VtcHR5JyksXG4gIC4uLnJlcXVpcmUoJy4vZW5zdXJlJyksXG4gIC4uLnJlcXVpcmUoJy4vanNvbicpLFxuICAuLi5yZXF1aXJlKCcuL21rZGlycycpLFxuICAuLi5yZXF1aXJlKCcuL21vdmUnKSxcbiAgLi4ucmVxdWlyZSgnLi9vdXRwdXQtZmlsZScpLFxuICAuLi5yZXF1aXJlKCcuL3BhdGgtZXhpc3RzJyksXG4gIC4uLnJlcXVpcmUoJy4vcmVtb3ZlJylcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuXG5mdW5jdGlvbiBpc05vdGhpbmcoc3ViamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBzdWJqZWN0ID09PSAndW5kZWZpbmVkJykgfHwgKHN1YmplY3QgPT09IG51bGwpO1xufVxuXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHN1YmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcpICYmIChzdWJqZWN0ICE9PSBudWxsKTtcbn1cblxuXG5mdW5jdGlvbiB0b0FycmF5KHNlcXVlbmNlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHNlcXVlbmNlKSkgcmV0dXJuIHNlcXVlbmNlO1xuICBlbHNlIGlmIChpc05vdGhpbmcoc2VxdWVuY2UpKSByZXR1cm4gW107XG5cbiAgcmV0dXJuIFsgc2VxdWVuY2UgXTtcbn1cblxuXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgdmFyIGluZGV4LCBsZW5ndGgsIGtleSwgc291cmNlS2V5cztcblxuICBpZiAoc291cmNlKSB7XG4gICAgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gc291cmNlS2V5cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICBrZXkgPSBzb3VyY2VLZXlzW2luZGV4XTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuXG5mdW5jdGlvbiByZXBlYXQoc3RyaW5nLCBjb3VudCkge1xuICB2YXIgcmVzdWx0ID0gJycsIGN5Y2xlO1xuXG4gIGZvciAoY3ljbGUgPSAwOyBjeWNsZSA8IGNvdW50OyBjeWNsZSArPSAxKSB7XG4gICAgcmVzdWx0ICs9IHN0cmluZztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gaXNOZWdhdGl2ZVplcm8obnVtYmVyKSB7XG4gIHJldHVybiAobnVtYmVyID09PSAwKSAmJiAoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZID09PSAxIC8gbnVtYmVyKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cy5pc05vdGhpbmcgICAgICA9IGlzTm90aGluZztcbm1vZHVsZS5leHBvcnRzLmlzT2JqZWN0ICAgICAgID0gaXNPYmplY3Q7XG5tb2R1bGUuZXhwb3J0cy50b0FycmF5ICAgICAgICA9IHRvQXJyYXk7XG5tb2R1bGUuZXhwb3J0cy5yZXBlYXQgICAgICAgICA9IHJlcGVhdDtcbm1vZHVsZS5leHBvcnRzLmlzTmVnYXRpdmVaZXJvID0gaXNOZWdhdGl2ZVplcm87XG5tb2R1bGUuZXhwb3J0cy5leHRlbmQgICAgICAgICA9IGV4dGVuZDtcbiIsIi8vIFlBTUwgZXJyb3IgY2xhc3MuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODQ1ODk4NFxuLy9cbid1c2Ugc3RyaWN0JztcblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcihleGNlcHRpb24sIGNvbXBhY3QpIHtcbiAgdmFyIHdoZXJlID0gJycsIG1lc3NhZ2UgPSBleGNlcHRpb24ucmVhc29uIHx8ICcodW5rbm93biByZWFzb24pJztcblxuICBpZiAoIWV4Y2VwdGlvbi5tYXJrKSByZXR1cm4gbWVzc2FnZTtcblxuICBpZiAoZXhjZXB0aW9uLm1hcmsubmFtZSkge1xuICAgIHdoZXJlICs9ICdpbiBcIicgKyBleGNlcHRpb24ubWFyay5uYW1lICsgJ1wiICc7XG4gIH1cblxuICB3aGVyZSArPSAnKCcgKyAoZXhjZXB0aW9uLm1hcmsubGluZSArIDEpICsgJzonICsgKGV4Y2VwdGlvbi5tYXJrLmNvbHVtbiArIDEpICsgJyknO1xuXG4gIGlmICghY29tcGFjdCAmJiBleGNlcHRpb24ubWFyay5zbmlwcGV0KSB7XG4gICAgd2hlcmUgKz0gJ1xcblxcbicgKyBleGNlcHRpb24ubWFyay5zbmlwcGV0O1xuICB9XG5cbiAgcmV0dXJuIG1lc3NhZ2UgKyAnICcgKyB3aGVyZTtcbn1cblxuXG5mdW5jdGlvbiBZQU1MRXhjZXB0aW9uKHJlYXNvbiwgbWFyaykge1xuICAvLyBTdXBlciBjb25zdHJ1Y3RvclxuICBFcnJvci5jYWxsKHRoaXMpO1xuXG4gIHRoaXMubmFtZSA9ICdZQU1MRXhjZXB0aW9uJztcbiAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gIHRoaXMubWFyayA9IG1hcms7XG4gIHRoaXMubWVzc2FnZSA9IGZvcm1hdEVycm9yKHRoaXMsIGZhbHNlKTtcblxuICAvLyBJbmNsdWRlIHN0YWNrIHRyYWNlIGluIGVycm9yIG9iamVjdFxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAvLyBDaHJvbWUgYW5kIE5vZGVKU1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICB9IGVsc2Uge1xuICAgIC8vIEZGLCBJRSAxMCsgYW5kIFNhZmFyaSA2Ky4gRmFsbGJhY2sgZm9yIG90aGVyc1xuICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrIHx8ICcnO1xuICB9XG59XG5cblxuLy8gSW5oZXJpdCBmcm9tIEVycm9yXG5ZQU1MRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbllBTUxFeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWUFNTEV4Y2VwdGlvbjtcblxuXG5ZQU1MRXhjZXB0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGNvbXBhY3QpIHtcbiAgcmV0dXJuIHRoaXMubmFtZSArICc6ICcgKyBmb3JtYXRFcnJvcih0aGlzLCBjb21wYWN0KTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBZQU1MRXhjZXB0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5cbi8vIGdldCBzbmlwcGV0IGZvciBhIHNpbmdsZSBsaW5lLCByZXNwZWN0aW5nIG1heExlbmd0aFxuZnVuY3Rpb24gZ2V0TGluZShidWZmZXIsIGxpbmVTdGFydCwgbGluZUVuZCwgcG9zaXRpb24sIG1heExpbmVMZW5ndGgpIHtcbiAgdmFyIGhlYWQgPSAnJztcbiAgdmFyIHRhaWwgPSAnJztcbiAgdmFyIG1heEhhbGZMZW5ndGggPSBNYXRoLmZsb29yKG1heExpbmVMZW5ndGggLyAyKSAtIDE7XG5cbiAgaWYgKHBvc2l0aW9uIC0gbGluZVN0YXJ0ID4gbWF4SGFsZkxlbmd0aCkge1xuICAgIGhlYWQgPSAnIC4uLiAnO1xuICAgIGxpbmVTdGFydCA9IHBvc2l0aW9uIC0gbWF4SGFsZkxlbmd0aCArIGhlYWQubGVuZ3RoO1xuICB9XG5cbiAgaWYgKGxpbmVFbmQgLSBwb3NpdGlvbiA+IG1heEhhbGZMZW5ndGgpIHtcbiAgICB0YWlsID0gJyAuLi4nO1xuICAgIGxpbmVFbmQgPSBwb3NpdGlvbiArIG1heEhhbGZMZW5ndGggLSB0YWlsLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RyOiBoZWFkICsgYnVmZmVyLnNsaWNlKGxpbmVTdGFydCwgbGluZUVuZCkucmVwbGFjZSgvXFx0L2csICfihpInKSArIHRhaWwsXG4gICAgcG9zOiBwb3NpdGlvbiAtIGxpbmVTdGFydCArIGhlYWQubGVuZ3RoIC8vIHJlbGF0aXZlIHBvc2l0aW9uXG4gIH07XG59XG5cblxuZnVuY3Rpb24gcGFkU3RhcnQoc3RyaW5nLCBtYXgpIHtcbiAgcmV0dXJuIGNvbW1vbi5yZXBlYXQoJyAnLCBtYXggLSBzdHJpbmcubGVuZ3RoKSArIHN0cmluZztcbn1cblxuXG5mdW5jdGlvbiBtYWtlU25pcHBldChtYXJrLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMgfHwgbnVsbCk7XG5cbiAgaWYgKCFtYXJrLmJ1ZmZlcikgcmV0dXJuIG51bGw7XG5cbiAgaWYgKCFvcHRpb25zLm1heExlbmd0aCkgb3B0aW9ucy5tYXhMZW5ndGggPSA3OTtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmluZGVudCAgICAgICE9PSAnbnVtYmVyJykgb3B0aW9ucy5pbmRlbnQgICAgICA9IDE7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5saW5lc0JlZm9yZSAhPT0gJ251bWJlcicpIG9wdGlvbnMubGluZXNCZWZvcmUgPSAzO1xuICBpZiAodHlwZW9mIG9wdGlvbnMubGluZXNBZnRlciAgIT09ICdudW1iZXInKSBvcHRpb25zLmxpbmVzQWZ0ZXIgID0gMjtcblxuICB2YXIgcmUgPSAvXFxyP1xcbnxcXHJ8XFwwL2c7XG4gIHZhciBsaW5lU3RhcnRzID0gWyAwIF07XG4gIHZhciBsaW5lRW5kcyA9IFtdO1xuICB2YXIgbWF0Y2g7XG4gIHZhciBmb3VuZExpbmVObyA9IC0xO1xuXG4gIHdoaWxlICgobWF0Y2ggPSByZS5leGVjKG1hcmsuYnVmZmVyKSkpIHtcbiAgICBsaW5lRW5kcy5wdXNoKG1hdGNoLmluZGV4KTtcbiAgICBsaW5lU3RhcnRzLnB1c2gobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuXG4gICAgaWYgKG1hcmsucG9zaXRpb24gPD0gbWF0Y2guaW5kZXggJiYgZm91bmRMaW5lTm8gPCAwKSB7XG4gICAgICBmb3VuZExpbmVObyA9IGxpbmVTdGFydHMubGVuZ3RoIC0gMjtcbiAgICB9XG4gIH1cblxuICBpZiAoZm91bmRMaW5lTm8gPCAwKSBmb3VuZExpbmVObyA9IGxpbmVTdGFydHMubGVuZ3RoIC0gMTtcblxuICB2YXIgcmVzdWx0ID0gJycsIGksIGxpbmU7XG4gIHZhciBsaW5lTm9MZW5ndGggPSBNYXRoLm1pbihtYXJrLmxpbmUgKyBvcHRpb25zLmxpbmVzQWZ0ZXIsIGxpbmVFbmRzLmxlbmd0aCkudG9TdHJpbmcoKS5sZW5ndGg7XG4gIHZhciBtYXhMaW5lTGVuZ3RoID0gb3B0aW9ucy5tYXhMZW5ndGggLSAob3B0aW9ucy5pbmRlbnQgKyBsaW5lTm9MZW5ndGggKyAzKTtcblxuICBmb3IgKGkgPSAxOyBpIDw9IG9wdGlvbnMubGluZXNCZWZvcmU7IGkrKykge1xuICAgIGlmIChmb3VuZExpbmVObyAtIGkgPCAwKSBicmVhaztcbiAgICBsaW5lID0gZ2V0TGluZShcbiAgICAgIG1hcmsuYnVmZmVyLFxuICAgICAgbGluZVN0YXJ0c1tmb3VuZExpbmVObyAtIGldLFxuICAgICAgbGluZUVuZHNbZm91bmRMaW5lTm8gLSBpXSxcbiAgICAgIG1hcmsucG9zaXRpb24gLSAobGluZVN0YXJ0c1tmb3VuZExpbmVOb10gLSBsaW5lU3RhcnRzW2ZvdW5kTGluZU5vIC0gaV0pLFxuICAgICAgbWF4TGluZUxlbmd0aFxuICAgICk7XG4gICAgcmVzdWx0ID0gY29tbW9uLnJlcGVhdCgnICcsIG9wdGlvbnMuaW5kZW50KSArIHBhZFN0YXJ0KChtYXJrLmxpbmUgLSBpICsgMSkudG9TdHJpbmcoKSwgbGluZU5vTGVuZ3RoKSArXG4gICAgICAnIHwgJyArIGxpbmUuc3RyICsgJ1xcbicgKyByZXN1bHQ7XG4gIH1cblxuICBsaW5lID0gZ2V0TGluZShtYXJrLmJ1ZmZlciwgbGluZVN0YXJ0c1tmb3VuZExpbmVOb10sIGxpbmVFbmRzW2ZvdW5kTGluZU5vXSwgbWFyay5wb3NpdGlvbiwgbWF4TGluZUxlbmd0aCk7XG4gIHJlc3VsdCArPSBjb21tb24ucmVwZWF0KCcgJywgb3B0aW9ucy5pbmRlbnQpICsgcGFkU3RhcnQoKG1hcmsubGluZSArIDEpLnRvU3RyaW5nKCksIGxpbmVOb0xlbmd0aCkgK1xuICAgICcgfCAnICsgbGluZS5zdHIgKyAnXFxuJztcbiAgcmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJy0nLCBvcHRpb25zLmluZGVudCArIGxpbmVOb0xlbmd0aCArIDMgKyBsaW5lLnBvcykgKyAnXicgKyAnXFxuJztcblxuICBmb3IgKGkgPSAxOyBpIDw9IG9wdGlvbnMubGluZXNBZnRlcjsgaSsrKSB7XG4gICAgaWYgKGZvdW5kTGluZU5vICsgaSA+PSBsaW5lRW5kcy5sZW5ndGgpIGJyZWFrO1xuICAgIGxpbmUgPSBnZXRMaW5lKFxuICAgICAgbWFyay5idWZmZXIsXG4gICAgICBsaW5lU3RhcnRzW2ZvdW5kTGluZU5vICsgaV0sXG4gICAgICBsaW5lRW5kc1tmb3VuZExpbmVObyArIGldLFxuICAgICAgbWFyay5wb3NpdGlvbiAtIChsaW5lU3RhcnRzW2ZvdW5kTGluZU5vXSAtIGxpbmVTdGFydHNbZm91bmRMaW5lTm8gKyBpXSksXG4gICAgICBtYXhMaW5lTGVuZ3RoXG4gICAgKTtcbiAgICByZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnICcsIG9wdGlvbnMuaW5kZW50KSArIHBhZFN0YXJ0KChtYXJrLmxpbmUgKyBpICsgMSkudG9TdHJpbmcoKSwgbGluZU5vTGVuZ3RoKSArXG4gICAgICAnIHwgJyArIGxpbmUuc3RyICsgJ1xcbic7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0LnJlcGxhY2UoL1xcbiQvLCAnJyk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBtYWtlU25pcHBldDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFlBTUxFeGNlcHRpb24gPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xuXG52YXIgVFlQRV9DT05TVFJVQ1RPUl9PUFRJT05TID0gW1xuICAna2luZCcsXG4gICdtdWx0aScsXG4gICdyZXNvbHZlJyxcbiAgJ2NvbnN0cnVjdCcsXG4gICdpbnN0YW5jZU9mJyxcbiAgJ3ByZWRpY2F0ZScsXG4gICdyZXByZXNlbnQnLFxuICAncmVwcmVzZW50TmFtZScsXG4gICdkZWZhdWx0U3R5bGUnLFxuICAnc3R5bGVBbGlhc2VzJ1xuXTtcblxudmFyIFlBTUxfTk9ERV9LSU5EUyA9IFtcbiAgJ3NjYWxhcicsXG4gICdzZXF1ZW5jZScsXG4gICdtYXBwaW5nJ1xuXTtcblxuZnVuY3Rpb24gY29tcGlsZVN0eWxlQWxpYXNlcyhtYXApIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gIGlmIChtYXAgIT09IG51bGwpIHtcbiAgICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICBtYXBbc3R5bGVdLmZvckVhY2goZnVuY3Rpb24gKGFsaWFzKSB7XG4gICAgICAgIHJlc3VsdFtTdHJpbmcoYWxpYXMpXSA9IHN0eWxlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBUeXBlKHRhZywgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKFRZUEVfQ09OU1RSVUNUT1JfT1BUSU9OUy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1Vua25vd24gb3B0aW9uIFwiJyArIG5hbWUgKyAnXCIgaXMgbWV0IGluIGRlZmluaXRpb24gb2YgXCInICsgdGFnICsgJ1wiIFlBTUwgdHlwZS4nKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFRPRE86IEFkZCB0YWcgZm9ybWF0IGNoZWNrLlxuICB0aGlzLm9wdGlvbnMgICAgICAgPSBvcHRpb25zOyAvLyBrZWVwIG9yaWdpbmFsIG9wdGlvbnMgaW4gY2FzZSB1c2VyIHdhbnRzIHRvIGV4dGVuZCB0aGlzIHR5cGUgbGF0ZXJcbiAgdGhpcy50YWcgICAgICAgICAgID0gdGFnO1xuICB0aGlzLmtpbmQgICAgICAgICAgPSBvcHRpb25zWydraW5kJ10gICAgICAgICAgfHwgbnVsbDtcbiAgdGhpcy5yZXNvbHZlICAgICAgID0gb3B0aW9uc1sncmVzb2x2ZSddICAgICAgIHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XG4gIHRoaXMuY29uc3RydWN0ICAgICA9IG9wdGlvbnNbJ2NvbnN0cnVjdCddICAgICB8fCBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YTsgfTtcbiAgdGhpcy5pbnN0YW5jZU9mICAgID0gb3B0aW9uc1snaW5zdGFuY2VPZiddICAgIHx8IG51bGw7XG4gIHRoaXMucHJlZGljYXRlICAgICA9IG9wdGlvbnNbJ3ByZWRpY2F0ZSddICAgICB8fCBudWxsO1xuICB0aGlzLnJlcHJlc2VudCAgICAgPSBvcHRpb25zWydyZXByZXNlbnQnXSAgICAgfHwgbnVsbDtcbiAgdGhpcy5yZXByZXNlbnROYW1lID0gb3B0aW9uc1sncmVwcmVzZW50TmFtZSddIHx8IG51bGw7XG4gIHRoaXMuZGVmYXVsdFN0eWxlICA9IG9wdGlvbnNbJ2RlZmF1bHRTdHlsZSddICB8fCBudWxsO1xuICB0aGlzLm11bHRpICAgICAgICAgPSBvcHRpb25zWydtdWx0aSddICAgICAgICAgfHwgZmFsc2U7XG4gIHRoaXMuc3R5bGVBbGlhc2VzICA9IGNvbXBpbGVTdHlsZUFsaWFzZXMob3B0aW9uc1snc3R5bGVBbGlhc2VzJ10gfHwgbnVsbCk7XG5cbiAgaWYgKFlBTUxfTk9ERV9LSU5EUy5pbmRleE9mKHRoaXMua2luZCkgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1Vua25vd24ga2luZCBcIicgKyB0aGlzLmtpbmQgKyAnXCIgaXMgc3BlY2lmaWVkIGZvciBcIicgKyB0YWcgKyAnXCIgWUFNTCB0eXBlLicpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuKi9cblxudmFyIFlBTUxFeGNlcHRpb24gPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xudmFyIFR5cGUgICAgICAgICAgPSByZXF1aXJlKCcuL3R5cGUnKTtcblxuXG5mdW5jdGlvbiBjb21waWxlTGlzdChzY2hlbWEsIG5hbWUpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIHNjaGVtYVtuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uIChjdXJyZW50VHlwZSkge1xuICAgIHZhciBuZXdJbmRleCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICByZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAocHJldmlvdXNUeXBlLCBwcmV2aW91c0luZGV4KSB7XG4gICAgICBpZiAocHJldmlvdXNUeXBlLnRhZyA9PT0gY3VycmVudFR5cGUudGFnICYmXG4gICAgICAgICAgcHJldmlvdXNUeXBlLmtpbmQgPT09IGN1cnJlbnRUeXBlLmtpbmQgJiZcbiAgICAgICAgICBwcmV2aW91c1R5cGUubXVsdGkgPT09IGN1cnJlbnRUeXBlLm11bHRpKSB7XG5cbiAgICAgICAgbmV3SW5kZXggPSBwcmV2aW91c0luZGV4O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVzdWx0W25ld0luZGV4XSA9IGN1cnJlbnRUeXBlO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIGNvbXBpbGVNYXAoLyogbGlzdHMuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgc2NhbGFyOiB7fSxcbiAgICAgICAgc2VxdWVuY2U6IHt9LFxuICAgICAgICBtYXBwaW5nOiB7fSxcbiAgICAgICAgZmFsbGJhY2s6IHt9LFxuICAgICAgICBtdWx0aToge1xuICAgICAgICAgIHNjYWxhcjogW10sXG4gICAgICAgICAgc2VxdWVuY2U6IFtdLFxuICAgICAgICAgIG1hcHBpbmc6IFtdLFxuICAgICAgICAgIGZhbGxiYWNrOiBbXVxuICAgICAgICB9XG4gICAgICB9LCBpbmRleCwgbGVuZ3RoO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3RUeXBlKHR5cGUpIHtcbiAgICBpZiAodHlwZS5tdWx0aSkge1xuICAgICAgcmVzdWx0Lm11bHRpW3R5cGUua2luZF0ucHVzaCh0eXBlKTtcbiAgICAgIHJlc3VsdC5tdWx0aVsnZmFsbGJhY2snXS5wdXNoKHR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRbdHlwZS5raW5kXVt0eXBlLnRhZ10gPSByZXN1bHRbJ2ZhbGxiYWNrJ11bdHlwZS50YWddID0gdHlwZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBhcmd1bWVudHNbaW5kZXhdLmZvckVhY2goY29sbGVjdFR5cGUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gU2NoZW1hKGRlZmluaXRpb24pIHtcbiAgcmV0dXJuIHRoaXMuZXh0ZW5kKGRlZmluaXRpb24pO1xufVxuXG5cblNjaGVtYS5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kKGRlZmluaXRpb24pIHtcbiAgdmFyIGltcGxpY2l0ID0gW107XG4gIHZhciBleHBsaWNpdCA9IFtdO1xuXG4gIGlmIChkZWZpbml0aW9uIGluc3RhbmNlb2YgVHlwZSkge1xuICAgIC8vIFNjaGVtYS5leHRlbmQodHlwZSlcbiAgICBleHBsaWNpdC5wdXNoKGRlZmluaXRpb24pO1xuXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkZWZpbml0aW9uKSkge1xuICAgIC8vIFNjaGVtYS5leHRlbmQoWyB0eXBlMSwgdHlwZTIsIC4uLiBdKVxuICAgIGV4cGxpY2l0ID0gZXhwbGljaXQuY29uY2F0KGRlZmluaXRpb24pO1xuXG4gIH0gZWxzZSBpZiAoZGVmaW5pdGlvbiAmJiAoQXJyYXkuaXNBcnJheShkZWZpbml0aW9uLmltcGxpY2l0KSB8fCBBcnJheS5pc0FycmF5KGRlZmluaXRpb24uZXhwbGljaXQpKSkge1xuICAgIC8vIFNjaGVtYS5leHRlbmQoeyBleHBsaWNpdDogWyB0eXBlMSwgdHlwZTIsIC4uLiBdLCBpbXBsaWNpdDogWyB0eXBlMSwgdHlwZTIsIC4uLiBdIH0pXG4gICAgaWYgKGRlZmluaXRpb24uaW1wbGljaXQpIGltcGxpY2l0ID0gaW1wbGljaXQuY29uY2F0KGRlZmluaXRpb24uaW1wbGljaXQpO1xuICAgIGlmIChkZWZpbml0aW9uLmV4cGxpY2l0KSBleHBsaWNpdCA9IGV4cGxpY2l0LmNvbmNhdChkZWZpbml0aW9uLmV4cGxpY2l0KTtcblxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdTY2hlbWEuZXh0ZW5kIGFyZ3VtZW50IHNob3VsZCBiZSBhIFR5cGUsIFsgVHlwZSBdLCAnICtcbiAgICAgICdvciBhIHNjaGVtYSBkZWZpbml0aW9uICh7IGltcGxpY2l0OiBbLi4uXSwgZXhwbGljaXQ6IFsuLi5dIH0pJyk7XG4gIH1cblxuICBpbXBsaWNpdC5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKCEodHlwZSBpbnN0YW5jZW9mIFR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignU3BlY2lmaWVkIGxpc3Qgb2YgWUFNTCB0eXBlcyAob3IgYSBzaW5nbGUgVHlwZSBvYmplY3QpIGNvbnRhaW5zIGEgbm9uLVR5cGUgb2JqZWN0LicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlLmxvYWRLaW5kICYmIHR5cGUubG9hZEtpbmQgIT09ICdzY2FsYXInKSB7XG4gICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignVGhlcmUgaXMgYSBub24tc2NhbGFyIHR5cGUgaW4gdGhlIGltcGxpY2l0IGxpc3Qgb2YgYSBzY2hlbWEuIEltcGxpY2l0IHJlc29sdmluZyBvZiBzdWNoIHR5cGVzIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUubXVsdGkpIHtcbiAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdUaGVyZSBpcyBhIG11bHRpIHR5cGUgaW4gdGhlIGltcGxpY2l0IGxpc3Qgb2YgYSBzY2hlbWEuIE11bHRpIHRhZ3MgY2FuIG9ubHkgYmUgbGlzdGVkIGFzIGV4cGxpY2l0LicpO1xuICAgIH1cbiAgfSk7XG5cbiAgZXhwbGljaXQuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmICghKHR5cGUgaW5zdGFuY2VvZiBUeXBlKSkge1xuICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1NwZWNpZmllZCBsaXN0IG9mIFlBTUwgdHlwZXMgKG9yIGEgc2luZ2xlIFR5cGUgb2JqZWN0KSBjb250YWlucyBhIG5vbi1UeXBlIG9iamVjdC4nKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKFNjaGVtYS5wcm90b3R5cGUpO1xuXG4gIHJlc3VsdC5pbXBsaWNpdCA9ICh0aGlzLmltcGxpY2l0IHx8IFtdKS5jb25jYXQoaW1wbGljaXQpO1xuICByZXN1bHQuZXhwbGljaXQgPSAodGhpcy5leHBsaWNpdCB8fCBbXSkuY29uY2F0KGV4cGxpY2l0KTtcblxuICByZXN1bHQuY29tcGlsZWRJbXBsaWNpdCA9IGNvbXBpbGVMaXN0KHJlc3VsdCwgJ2ltcGxpY2l0Jyk7XG4gIHJlc3VsdC5jb21waWxlZEV4cGxpY2l0ID0gY29tcGlsZUxpc3QocmVzdWx0LCAnZXhwbGljaXQnKTtcbiAgcmVzdWx0LmNvbXBpbGVkVHlwZU1hcCAgPSBjb21waWxlTWFwKHJlc3VsdC5jb21waWxlZEltcGxpY2l0LCByZXN1bHQuY29tcGlsZWRFeHBsaWNpdCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWE7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6ICcnOyB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnNlcScsIHtcbiAga2luZDogJ3NlcXVlbmNlJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiBbXTsgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjptYXAnLCB7XG4gIGtpbmQ6ICdtYXBwaW5nJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiB7fTsgfVxufSk7XG4iLCIvLyBTdGFuZGFyZCBZQU1MJ3MgRmFpbHNhZmUgc2NoZW1hLlxuLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyODAyMzQ2XG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBTY2hlbWEgPSByZXF1aXJlKCcuLi9zY2hlbWEnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBTY2hlbWEoe1xuICBleHBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvc3RyJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9zZXEnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL21hcCcpXG4gIF1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxOdWxsKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aDtcblxuICByZXR1cm4gKG1heCA9PT0gMSAmJiBkYXRhID09PSAnficpIHx8XG4gICAgICAgICAobWF4ID09PSA0ICYmIChkYXRhID09PSAnbnVsbCcgfHwgZGF0YSA9PT0gJ051bGwnIHx8IGRhdGEgPT09ICdOVUxMJykpO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzTnVsbChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCA9PT0gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bnVsbCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sTnVsbCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sTnVsbCxcbiAgcHJlZGljYXRlOiBpc051bGwsXG4gIHJlcHJlc2VudDoge1xuICAgIGNhbm9uaWNhbDogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ34nOyAgICB9LFxuICAgIGxvd2VyY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ251bGwnOyB9LFxuICAgIHVwcGVyY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ05VTEwnOyB9LFxuICAgIGNhbWVsY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ051bGwnOyB9LFxuICAgIGVtcHR5OiAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gJyc7ICAgICB9XG4gIH0sXG4gIGRlZmF1bHRTdHlsZTogJ2xvd2VyY2FzZSdcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxCb29sZWFuKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGg7XG5cbiAgcmV0dXJuIChtYXggPT09IDQgJiYgKGRhdGEgPT09ICd0cnVlJyB8fCBkYXRhID09PSAnVHJ1ZScgfHwgZGF0YSA9PT0gJ1RSVUUnKSkgfHxcbiAgICAgICAgIChtYXggPT09IDUgJiYgKGRhdGEgPT09ICdmYWxzZScgfHwgZGF0YSA9PT0gJ0ZhbHNlJyB8fCBkYXRhID09PSAnRkFMU0UnKSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxCb29sZWFuKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgPT09ICd0cnVlJyB8fFxuICAgICAgICAgZGF0YSA9PT0gJ1RydWUnIHx8XG4gICAgICAgICBkYXRhID09PSAnVFJVRSc7XG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBCb29sZWFuXSc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEJvb2xlYW4sXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEJvb2xlYW4sXG4gIHByZWRpY2F0ZTogaXNCb29sZWFuLFxuICByZXByZXNlbnQ6IHtcbiAgICBsb3dlcmNhc2U6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIG9iamVjdCA/ICd0cnVlJyA6ICdmYWxzZSc7IH0sXG4gICAgdXBwZXJjYXNlOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBvYmplY3QgPyAnVFJVRScgOiAnRkFMU0UnOyB9LFxuICAgIGNhbWVsY2FzZTogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0ID8gJ1RydWUnIDogJ0ZhbHNlJzsgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xudmFyIFR5cGUgICA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gaXNIZXhDb2RlKGMpIHtcbiAgcmV0dXJuICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKSB8fFxuICAgICAgICAgKCgweDQxLyogQSAqLyA8PSBjKSAmJiAoYyA8PSAweDQ2LyogRiAqLykpIHx8XG4gICAgICAgICAoKDB4NjEvKiBhICovIDw9IGMpICYmIChjIDw9IDB4NjYvKiBmICovKSk7XG59XG5cbmZ1bmN0aW9uIGlzT2N0Q29kZShjKSB7XG4gIHJldHVybiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzcvKiA3ICovKSk7XG59XG5cbmZ1bmN0aW9uIGlzRGVjQ29kZShjKSB7XG4gIHJldHVybiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sSW50ZWdlcihkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgaGFzRGlnaXRzID0gZmFsc2UsXG4gICAgICBjaDtcblxuICBpZiAoIW1heCkgcmV0dXJuIGZhbHNlO1xuXG4gIGNoID0gZGF0YVtpbmRleF07XG5cbiAgLy8gc2lnblxuICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7XG4gICAgY2ggPSBkYXRhWysraW5kZXhdO1xuICB9XG5cbiAgaWYgKGNoID09PSAnMCcpIHtcbiAgICAvLyAwXG4gICAgaWYgKGluZGV4ICsgMSA9PT0gbWF4KSByZXR1cm4gdHJ1ZTtcbiAgICBjaCA9IGRhdGFbKytpbmRleF07XG5cbiAgICAvLyBiYXNlIDIsIGJhc2UgOCwgYmFzZSAxNlxuXG4gICAgaWYgKGNoID09PSAnYicpIHtcbiAgICAgIC8vIGJhc2UgMlxuICAgICAgaW5kZXgrKztcblxuICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChjaCA9PT0gJ18nKSBjb250aW51ZTtcbiAgICAgICAgaWYgKGNoICE9PSAnMCcgJiYgY2ggIT09ICcxJykgcmV0dXJuIGZhbHNlO1xuICAgICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc0RpZ2l0cyAmJiBjaCAhPT0gJ18nO1xuICAgIH1cblxuXG4gICAgaWYgKGNoID09PSAneCcpIHtcbiAgICAgIC8vIGJhc2UgMTZcbiAgICAgIGluZGV4Kys7XG5cbiAgICAgIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgICAgIGlmICghaXNIZXhDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzRGlnaXRzICYmIGNoICE9PSAnXyc7XG4gICAgfVxuXG5cbiAgICBpZiAoY2ggPT09ICdvJykge1xuICAgICAgLy8gYmFzZSA4XG4gICAgICBpbmRleCsrO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWlzT2N0Q29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc0RpZ2l0cyAmJiBjaCAhPT0gJ18nO1xuICAgIH1cbiAgfVxuXG4gIC8vIGJhc2UgMTAgKGV4Y2VwdCAwKVxuXG4gIC8vIHZhbHVlIHNob3VsZCBub3Qgc3RhcnQgd2l0aCBgX2A7XG4gIGlmIChjaCA9PT0gJ18nKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgaWYgKCFpc0RlY0NvZGUoZGF0YS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIFNob3VsZCBoYXZlIGRpZ2l0cyBhbmQgc2hvdWxkIG5vdCBlbmQgd2l0aCBgX2BcbiAgaWYgKCFoYXNEaWdpdHMgfHwgY2ggPT09ICdfJykgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sSW50ZWdlcihkYXRhKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGEsIHNpZ24gPSAxLCBjaDtcblxuICBpZiAodmFsdWUuaW5kZXhPZignXycpICE9PSAtMSkge1xuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXy9nLCAnJyk7XG4gIH1cblxuICBjaCA9IHZhbHVlWzBdO1xuXG4gIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICBpZiAoY2ggPT09ICctJykgc2lnbiA9IC0xO1xuICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XG4gICAgY2ggPSB2YWx1ZVswXTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gJzAnKSByZXR1cm4gMDtcblxuICBpZiAoY2ggPT09ICcwJykge1xuICAgIGlmICh2YWx1ZVsxXSA9PT0gJ2InKSByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCAyKTtcbiAgICBpZiAodmFsdWVbMV0gPT09ICd4JykgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgMTYpO1xuICAgIGlmICh2YWx1ZVsxXSA9PT0gJ28nKSByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCA4KTtcbiAgfVxuXG4gIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDEwKTtcbn1cblxuZnVuY3Rpb24gaXNJbnRlZ2VyKG9iamVjdCkge1xuICByZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScgJiZcbiAgICAgICAgIChvYmplY3QgJSAxID09PSAwICYmICFjb21tb24uaXNOZWdhdGl2ZVplcm8ob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sSW50ZWdlcixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sSW50ZWdlcixcbiAgcHJlZGljYXRlOiBpc0ludGVnZXIsXG4gIHJlcHJlc2VudDoge1xuICAgIGJpbmFyeTogICAgICBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogPj0gMCA/ICcwYicgKyBvYmoudG9TdHJpbmcoMikgOiAnLTBiJyArIG9iai50b1N0cmluZygyKS5zbGljZSgxKTsgfSxcbiAgICBvY3RhbDogICAgICAgZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqID49IDAgPyAnMG8nICArIG9iai50b1N0cmluZyg4KSA6ICctMG8nICArIG9iai50b1N0cmluZyg4KS5zbGljZSgxKTsgfSxcbiAgICBkZWNpbWFsOiAgICAgZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqLnRvU3RyaW5nKDEwKTsgfSxcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgaGV4YWRlY2ltYWw6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiA+PSAwID8gJzB4JyArIG9iai50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSA6ICAnLTB4JyArIG9iai50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5zbGljZSgxKTsgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdkZWNpbWFsJyxcbiAgc3R5bGVBbGlhc2VzOiB7XG4gICAgYmluYXJ5OiAgICAgIFsgMiwgICdiaW4nIF0sXG4gICAgb2N0YWw6ICAgICAgIFsgOCwgICdvY3QnIF0sXG4gICAgZGVjaW1hbDogICAgIFsgMTAsICdkZWMnIF0sXG4gICAgaGV4YWRlY2ltYWw6IFsgMTYsICdoZXgnIF1cbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBUeXBlICAgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbnZhciBZQU1MX0ZMT0FUX1BBVFRFUk4gPSBuZXcgUmVnRXhwKFxuICAvLyAyLjVlNCwgMi41IGFuZCBpbnRlZ2Vyc1xuICAnXig/OlstK10/KD86WzAtOV1bMC05X10qKSg/OlxcXFwuWzAtOV9dKik/KD86W2VFXVstK10/WzAtOV0rKT8nICtcbiAgLy8gLjJlNCwgLjJcbiAgLy8gc3BlY2lhbCBjYXNlLCBzZWVtcyBub3QgZnJvbSBzcGVjXG4gICd8XFxcXC5bMC05X10rKD86W2VFXVstK10/WzAtOV0rKT8nICtcbiAgLy8gLmluZlxuICAnfFstK10/XFxcXC4oPzppbmZ8SW5mfElORiknICtcbiAgLy8gLm5hblxuICAnfFxcXFwuKD86bmFufE5hTnxOQU4pKSQnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxGbG9hdChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKCFZQU1MX0ZMT0FUX1BBVFRFUk4udGVzdChkYXRhKSB8fFxuICAgICAgLy8gUXVpY2sgaGFjayB0byBub3QgYWxsb3cgaW50ZWdlcnMgZW5kIHdpdGggYF9gXG4gICAgICAvLyBQcm9iYWJseSBzaG91bGQgdXBkYXRlIHJlZ2V4cCAmIGNoZWNrIHNwZWVkXG4gICAgICBkYXRhW2RhdGEubGVuZ3RoIC0gMV0gPT09ICdfJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sRmxvYXQoZGF0YSkge1xuICB2YXIgdmFsdWUsIHNpZ247XG5cbiAgdmFsdWUgID0gZGF0YS5yZXBsYWNlKC9fL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuICBzaWduICAgPSB2YWx1ZVswXSA9PT0gJy0nID8gLTEgOiAxO1xuXG4gIGlmICgnKy0nLmluZGV4T2YodmFsdWVbMF0pID49IDApIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSAnLmluZicpIHtcbiAgICByZXR1cm4gKHNpZ24gPT09IDEpID8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuXG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICcubmFuJykge1xuICAgIHJldHVybiBOYU47XG4gIH1cbiAgcmV0dXJuIHNpZ24gKiBwYXJzZUZsb2F0KHZhbHVlLCAxMCk7XG59XG5cblxudmFyIFNDSUVOVElGSUNfV0lUSE9VVF9ET1QgPSAvXlstK10/WzAtOV0rZS87XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxGbG9hdChvYmplY3QsIHN0eWxlKSB7XG4gIHZhciByZXM7XG5cbiAgaWYgKGlzTmFOKG9iamVjdCkpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICBjYXNlICdsb3dlcmNhc2UnOiByZXR1cm4gJy5uYW4nO1xuICAgICAgY2FzZSAndXBwZXJjYXNlJzogcmV0dXJuICcuTkFOJztcbiAgICAgIGNhc2UgJ2NhbWVsY2FzZSc6IHJldHVybiAnLk5hTic7XG4gICAgfVxuICB9IGVsc2UgaWYgKE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA9PT0gb2JqZWN0KSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgY2FzZSAnbG93ZXJjYXNlJzogcmV0dXJuICcuaW5mJztcbiAgICAgIGNhc2UgJ3VwcGVyY2FzZSc6IHJldHVybiAnLklORic7XG4gICAgICBjYXNlICdjYW1lbGNhc2UnOiByZXR1cm4gJy5JbmYnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPT09IG9iamVjdCkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgIGNhc2UgJ2xvd2VyY2FzZSc6IHJldHVybiAnLS5pbmYnO1xuICAgICAgY2FzZSAndXBwZXJjYXNlJzogcmV0dXJuICctLklORic7XG4gICAgICBjYXNlICdjYW1lbGNhc2UnOiByZXR1cm4gJy0uSW5mJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoY29tbW9uLmlzTmVnYXRpdmVaZXJvKG9iamVjdCkpIHtcbiAgICByZXR1cm4gJy0wLjAnO1xuICB9XG5cbiAgcmVzID0gb2JqZWN0LnRvU3RyaW5nKDEwKTtcblxuICAvLyBKUyBzdHJpbmdpZmllciBjYW4gYnVpbGQgc2NpZW50aWZpYyBmb3JtYXQgd2l0aG91dCBkb3RzOiA1ZS0xMDAsXG4gIC8vIHdoaWxlIFlBTUwgcmVxdXJlcyBkb3Q6IDUuZS0xMDAuIEZpeCBpdCB3aXRoIHNpbXBsZSBoYWNrXG5cbiAgcmV0dXJuIFNDSUVOVElGSUNfV0lUSE9VVF9ET1QudGVzdChyZXMpID8gcmVzLnJlcGxhY2UoJ2UnLCAnLmUnKSA6IHJlcztcbn1cblxuZnVuY3Rpb24gaXNGbG9hdChvYmplY3QpIHtcbiAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgTnVtYmVyXScpICYmXG4gICAgICAgICAob2JqZWN0ICUgMSAhPT0gMCB8fCBjb21tb24uaXNOZWdhdGl2ZVplcm8ob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0Jywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxGbG9hdCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sRmxvYXQsXG4gIHByZWRpY2F0ZTogaXNGbG9hdCxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRZYW1sRmxvYXQsXG4gIGRlZmF1bHRTdHlsZTogJ2xvd2VyY2FzZSdcbn0pO1xuIiwiLy8gU3RhbmRhcmQgWUFNTCdzIEpTT04gc2NoZW1hLlxuLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyODAzMjMxXG4vL1xuLy8gTk9URTogSlMtWUFNTCBkb2VzIG5vdCBzdXBwb3J0IHNjaGVtYS1zcGVjaWZpYyB0YWcgcmVzb2x1dGlvbiByZXN0cmljdGlvbnMuXG4vLyBTbywgdGhpcyBzY2hlbWEgaXMgbm90IHN1Y2ggc3RyaWN0IGFzIGRlZmluZWQgaW4gdGhlIFlBTUwgc3BlY2lmaWNhdGlvbi5cbi8vIEl0IGFsbG93cyBudW1iZXJzIGluIGJpbmFyeSBub3RhaW9uLCB1c2UgYE51bGxgIGFuZCBgTlVMTGAgYXMgYG51bGxgLCBldGMuXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWlsc2FmZScpLmV4dGVuZCh7XG4gIGltcGxpY2l0OiBbXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9udWxsJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9ib29sJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9pbnQnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL2Zsb2F0JylcbiAgXVxufSk7XG4iLCIvLyBTdGFuZGFyZCBZQU1MJ3MgQ29yZSBzY2hlbWEuXG4vLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI4MDQ5MjNcbi8vXG4vLyBOT1RFOiBKUy1ZQU1MIGRvZXMgbm90IHN1cHBvcnQgc2NoZW1hLXNwZWNpZmljIHRhZyByZXNvbHV0aW9uIHJlc3RyaWN0aW9ucy5cbi8vIFNvLCBDb3JlIHNjaGVtYSBoYXMgbm8gZGlzdGluY3Rpb25zIGZyb20gSlNPTiBzY2hlbWEgaXMgSlMtWUFNTC5cblxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2pzb24nKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbnZhciBZQU1MX0RBVEVfUkVHRVhQID0gbmV3IFJlZ0V4cChcbiAgJ14oWzAtOV1bMC05XVswLTldWzAtOV0pJyAgICAgICAgICArIC8vIFsxXSB5ZWFyXG4gICctKFswLTldWzAtOV0pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbMl0gbW9udGhcbiAgJy0oWzAtOV1bMC05XSkkJyk7ICAgICAgICAgICAgICAgICAgIC8vIFszXSBkYXlcblxudmFyIFlBTUxfVElNRVNUQU1QX1JFR0VYUCA9IG5ldyBSZWdFeHAoXG4gICdeKFswLTldWzAtOV1bMC05XVswLTldKScgICAgICAgICAgKyAvLyBbMV0geWVhclxuICAnLShbMC05XVswLTldPyknICAgICAgICAgICAgICAgICAgICsgLy8gWzJdIG1vbnRoXG4gICctKFswLTldWzAtOV0/KScgICAgICAgICAgICAgICAgICAgKyAvLyBbM10gZGF5XG4gICcoPzpbVHRdfFsgXFxcXHRdKyknICAgICAgICAgICAgICAgICArIC8vIC4uLlxuICAnKFswLTldWzAtOV0/KScgICAgICAgICAgICAgICAgICAgICsgLy8gWzRdIGhvdXJcbiAgJzooWzAtOV1bMC05XSknICAgICAgICAgICAgICAgICAgICArIC8vIFs1XSBtaW51dGVcbiAgJzooWzAtOV1bMC05XSknICAgICAgICAgICAgICAgICAgICArIC8vIFs2XSBzZWNvbmRcbiAgJyg/OlxcXFwuKFswLTldKikpPycgICAgICAgICAgICAgICAgICsgLy8gWzddIGZyYWN0aW9uXG4gICcoPzpbIFxcXFx0XSooWnwoWy0rXSkoWzAtOV1bMC05XT8pJyArIC8vIFs4XSB0eiBbOV0gdHpfc2lnbiBbMTBdIHR6X2hvdXJcbiAgJyg/OjooWzAtOV1bMC05XSkpPykpPyQnKTsgICAgICAgICAgIC8vIFsxMV0gdHpfbWludXRlXG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sVGltZXN0YW1wKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgaWYgKFlBTUxfREFURV9SRUdFWFAuZXhlYyhkYXRhKSAhPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIGlmIChZQU1MX1RJTUVTVEFNUF9SRUdFWFAuZXhlYyhkYXRhKSAhPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFRpbWVzdGFtcChkYXRhKSB7XG4gIHZhciBtYXRjaCwgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIGZyYWN0aW9uID0gMCxcbiAgICAgIGRlbHRhID0gbnVsbCwgdHpfaG91ciwgdHpfbWludXRlLCBkYXRlO1xuXG4gIG1hdGNoID0gWUFNTF9EQVRFX1JFR0VYUC5leGVjKGRhdGEpO1xuICBpZiAobWF0Y2ggPT09IG51bGwpIG1hdGNoID0gWUFNTF9USU1FU1RBTVBfUkVHRVhQLmV4ZWMoZGF0YSk7XG5cbiAgaWYgKG1hdGNoID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoJ0RhdGUgcmVzb2x2ZSBlcnJvcicpO1xuXG4gIC8vIG1hdGNoOiBbMV0geWVhciBbMl0gbW9udGggWzNdIGRheVxuXG4gIHllYXIgPSArKG1hdGNoWzFdKTtcbiAgbW9udGggPSArKG1hdGNoWzJdKSAtIDE7IC8vIEpTIG1vbnRoIHN0YXJ0cyB3aXRoIDBcbiAgZGF5ID0gKyhtYXRjaFszXSk7XG5cbiAgaWYgKCFtYXRjaFs0XSkgeyAvLyBubyBob3VyXG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXkpKTtcbiAgfVxuXG4gIC8vIG1hdGNoOiBbNF0gaG91ciBbNV0gbWludXRlIFs2XSBzZWNvbmQgWzddIGZyYWN0aW9uXG5cbiAgaG91ciA9ICsobWF0Y2hbNF0pO1xuICBtaW51dGUgPSArKG1hdGNoWzVdKTtcbiAgc2Vjb25kID0gKyhtYXRjaFs2XSk7XG5cbiAgaWYgKG1hdGNoWzddKSB7XG4gICAgZnJhY3Rpb24gPSBtYXRjaFs3XS5zbGljZSgwLCAzKTtcbiAgICB3aGlsZSAoZnJhY3Rpb24ubGVuZ3RoIDwgMykgeyAvLyBtaWxsaS1zZWNvbmRzXG4gICAgICBmcmFjdGlvbiArPSAnMCc7XG4gICAgfVxuICAgIGZyYWN0aW9uID0gK2ZyYWN0aW9uO1xuICB9XG5cbiAgLy8gbWF0Y2g6IFs4XSB0eiBbOV0gdHpfc2lnbiBbMTBdIHR6X2hvdXIgWzExXSB0el9taW51dGVcblxuICBpZiAobWF0Y2hbOV0pIHtcbiAgICB0el9ob3VyID0gKyhtYXRjaFsxMF0pO1xuICAgIHR6X21pbnV0ZSA9ICsobWF0Y2hbMTFdIHx8IDApO1xuICAgIGRlbHRhID0gKHR6X2hvdXIgKiA2MCArIHR6X21pbnV0ZSkgKiA2MDAwMDsgLy8gZGVsdGEgaW4gbWlsaS1zZWNvbmRzXG4gICAgaWYgKG1hdGNoWzldID09PSAnLScpIGRlbHRhID0gLWRlbHRhO1xuICB9XG5cbiAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBmcmFjdGlvbikpO1xuXG4gIGlmIChkZWx0YSkgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpIC0gZGVsdGEpO1xuXG4gIHJldHVybiBkYXRlO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sVGltZXN0YW1wKG9iamVjdCAvKiwgc3R5bGUqLykge1xuICByZXR1cm4gb2JqZWN0LnRvSVNPU3RyaW5nKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sVGltZXN0YW1wLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxUaW1lc3RhbXAsXG4gIGluc3RhbmNlT2Y6IERhdGUsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbFRpbWVzdGFtcFxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE1lcmdlKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgPT09ICc8PCcgfHwgZGF0YSA9PT0gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bWVyZ2UnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbE1lcmdlXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlKi9cblxuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuXG4vLyBbIDY0LCA2NSwgNjYgXSAtPiBbIHBhZGRpbmcsIENSLCBMRiBdXG52YXIgQkFTRTY0X01BUCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVxcblxccic7XG5cblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxCaW5hcnkoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBjb2RlLCBpZHgsIGJpdGxlbiA9IDAsIG1heCA9IGRhdGEubGVuZ3RoLCBtYXAgPSBCQVNFNjRfTUFQO1xuXG4gIC8vIENvbnZlcnQgb25lIGJ5IG9uZS5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgY29kZSA9IG1hcC5pbmRleE9mKGRhdGEuY2hhckF0KGlkeCkpO1xuXG4gICAgLy8gU2tpcCBDUi9MRlxuICAgIGlmIChjb2RlID4gNjQpIGNvbnRpbnVlO1xuXG4gICAgLy8gRmFpbCBvbiBpbGxlZ2FsIGNoYXJhY3RlcnNcbiAgICBpZiAoY29kZSA8IDApIHJldHVybiBmYWxzZTtcblxuICAgIGJpdGxlbiArPSA2O1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgYXJlIGFueSBiaXRzIGxlZnQsIHNvdXJjZSB3YXMgY29ycnVwdGVkXG4gIHJldHVybiAoYml0bGVuICUgOCkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxCaW5hcnkoZGF0YSkge1xuICB2YXIgaWR4LCB0YWlsYml0cyxcbiAgICAgIGlucHV0ID0gZGF0YS5yZXBsYWNlKC9bXFxyXFxuPV0vZywgJycpLCAvLyByZW1vdmUgQ1IvTEYgJiBwYWRkaW5nIHRvIHNpbXBsaWZ5IHNjYW5cbiAgICAgIG1heCA9IGlucHV0Lmxlbmd0aCxcbiAgICAgIG1hcCA9IEJBU0U2NF9NQVAsXG4gICAgICBiaXRzID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIC8vIENvbGxlY3QgYnkgNio0IGJpdHMgKDMgYnl0ZXMpXG5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgaWYgKChpZHggJSA0ID09PSAwKSAmJiBpZHgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDE2KSAmIDB4RkYpO1xuICAgICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gOCkgJiAweEZGKTtcbiAgICAgIHJlc3VsdC5wdXNoKGJpdHMgJiAweEZGKTtcbiAgICB9XG5cbiAgICBiaXRzID0gKGJpdHMgPDwgNikgfCBtYXAuaW5kZXhPZihpbnB1dC5jaGFyQXQoaWR4KSk7XG4gIH1cblxuICAvLyBEdW1wIHRhaWxcblxuICB0YWlsYml0cyA9IChtYXggJSA0KSAqIDY7XG5cbiAgaWYgKHRhaWxiaXRzID09PSAwKSB7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gMTYpICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gOCkgJiAweEZGKTtcbiAgICByZXN1bHQucHVzaChiaXRzICYgMHhGRik7XG4gIH0gZWxzZSBpZiAodGFpbGJpdHMgPT09IDE4KSB7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gMTApICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gMikgJiAweEZGKTtcbiAgfSBlbHNlIGlmICh0YWlsYml0cyA9PT0gMTIpIHtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiA0KSAmIDB4RkYpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxCaW5hcnkob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHZhciByZXN1bHQgPSAnJywgYml0cyA9IDAsIGlkeCwgdGFpbCxcbiAgICAgIG1heCA9IG9iamVjdC5sZW5ndGgsXG4gICAgICBtYXAgPSBCQVNFNjRfTUFQO1xuXG4gIC8vIENvbnZlcnQgZXZlcnkgdGhyZWUgYnl0ZXMgdG8gNCBBU0NJSSBjaGFyYWN0ZXJzLlxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGlmICgoaWR4ICUgMyA9PT0gMCkgJiYgaWR4KSB7XG4gICAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDE4KSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxMikgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gNikgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbYml0cyAmIDB4M0ZdO1xuICAgIH1cblxuICAgIGJpdHMgPSAoYml0cyA8PCA4KSArIG9iamVjdFtpZHhdO1xuICB9XG5cbiAgLy8gRHVtcCB0YWlsXG5cbiAgdGFpbCA9IG1heCAlIDM7XG5cbiAgaWYgKHRhaWwgPT09IDApIHtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDE4KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTIpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA2KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbYml0cyAmIDB4M0ZdO1xuICB9IGVsc2UgaWYgKHRhaWwgPT09IDIpIHtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDEwKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gNCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzIDw8IDIpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gIH0gZWxzZSBpZiAodGFpbCA9PT0gMSkge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzIDw8IDQpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc0JpbmFyeShvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAgJ1tvYmplY3QgVWludDhBcnJheV0nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpiaW5hcnknLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEJpbmFyeSxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sQmluYXJ5LFxuICBwcmVkaWNhdGU6IGlzQmluYXJ5LFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxCaW5hcnlcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX3RvU3RyaW5nICAgICAgID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxPbWFwKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHZhciBvYmplY3RLZXlzID0gW10sIGluZGV4LCBsZW5ndGgsIHBhaXIsIHBhaXJLZXksIHBhaXJIYXNLZXksXG4gICAgICBvYmplY3QgPSBkYXRhO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXIgPSBvYmplY3RbaW5kZXhdO1xuICAgIHBhaXJIYXNLZXkgPSBmYWxzZTtcblxuICAgIGlmIChfdG9TdHJpbmcuY2FsbChwYWlyKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAocGFpcktleSBpbiBwYWlyKSB7XG4gICAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwocGFpciwgcGFpcktleSkpIHtcbiAgICAgICAgaWYgKCFwYWlySGFzS2V5KSBwYWlySGFzS2V5ID0gdHJ1ZTtcbiAgICAgICAgZWxzZSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYWlySGFzS2V5KSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAob2JqZWN0S2V5cy5pbmRleE9mKHBhaXJLZXkpID09PSAtMSkgb2JqZWN0S2V5cy5wdXNoKHBhaXJLZXkpO1xuICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxPbWFwKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sT21hcCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sT21hcFxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxQYWlycyhkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgaW5kZXgsIGxlbmd0aCwgcGFpciwga2V5cywgcmVzdWx0LFxuICAgICAgb2JqZWN0ID0gZGF0YTtcblxuICByZXN1bHQgPSBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG5cbiAgICBpZiAoX3RvU3RyaW5nLmNhbGwocGFpcikgIT09ICdbb2JqZWN0IE9iamVjdF0nKSByZXR1cm4gZmFsc2U7XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMocGFpcik7XG5cbiAgICBpZiAoa2V5cy5sZW5ndGggIT09IDEpIHJldHVybiBmYWxzZTtcblxuICAgIHJlc3VsdFtpbmRleF0gPSBbIGtleXNbMF0sIHBhaXJba2V5c1swXV0gXTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sUGFpcnMoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIFtdO1xuXG4gIHZhciBpbmRleCwgbGVuZ3RoLCBwYWlyLCBrZXlzLCByZXN1bHQsXG4gICAgICBvYmplY3QgPSBkYXRhO1xuXG4gIHJlc3VsdCA9IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhwYWlyKTtcblxuICAgIHJlc3VsdFtpbmRleF0gPSBbIGtleXNbMF0sIHBhaXJba2V5c1swXV0gXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFBhaXJzLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxQYWlyc1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxTZXQoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIGtleSwgb2JqZWN0ID0gZGF0YTtcblxuICBmb3IgKGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICBpZiAob2JqZWN0W2tleV0gIT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFNldChkYXRhKSB7XG4gIHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnLCB7XG4gIGtpbmQ6ICdtYXBwaW5nJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxTZXQsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbFNldFxufSk7XG4iLCIvLyBKUy1ZQU1MJ3MgZGVmYXVsdCBzY2hlbWEgZm9yIGBzYWZlTG9hZGAgZnVuY3Rpb24uXG4vLyBJdCBpcyBub3QgZGVzY3JpYmVkIGluIHRoZSBZQU1MIHNwZWNpZmljYXRpb24uXG4vL1xuLy8gVGhpcyBzY2hlbWEgaXMgYmFzZWQgb24gc3RhbmRhcmQgWUFNTCdzIENvcmUgc2NoZW1hIGFuZCBpbmNsdWRlcyBtb3N0IG9mXG4vLyBleHRyYSB0eXBlcyBkZXNjcmliZWQgYXQgWUFNTCB0YWcgcmVwb3NpdG9yeS4gKGh0dHA6Ly95YW1sLm9yZy90eXBlLylcblxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvcmUnKS5leHRlbmQoe1xuICBpbXBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvdGltZXN0YW1wJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9tZXJnZScpXG4gIF0sXG4gIGV4cGxpY2l0OiBbXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9iaW5hcnknKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL29tYXAnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL3BhaXJzJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9zZXQnKVxuICBdXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuLG5vLXVzZS1iZWZvcmUtZGVmaW5lKi9cblxudmFyIGNvbW1vbiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIFlBTUxFeGNlcHRpb24gICAgICAgPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xudmFyIG1ha2VTbmlwcGV0ICAgICAgICAgPSByZXF1aXJlKCcuL3NuaXBwZXQnKTtcbnZhciBERUZBVUxUX1NDSEVNQSAgICAgID0gcmVxdWlyZSgnLi9zY2hlbWEvZGVmYXVsdCcpO1xuXG5cbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5cbnZhciBDT05URVhUX0ZMT1dfSU4gICA9IDE7XG52YXIgQ09OVEVYVF9GTE9XX09VVCAgPSAyO1xudmFyIENPTlRFWFRfQkxPQ0tfSU4gID0gMztcbnZhciBDT05URVhUX0JMT0NLX09VVCA9IDQ7XG5cblxudmFyIENIT01QSU5HX0NMSVAgID0gMTtcbnZhciBDSE9NUElOR19TVFJJUCA9IDI7XG52YXIgQ0hPTVBJTkdfS0VFUCAgPSAzO1xuXG5cbnZhciBQQVRURVJOX05PTl9QUklOVEFCTEUgICAgICAgICA9IC9bXFx4MDAtXFx4MDhcXHgwQlxceDBDXFx4MEUtXFx4MUZcXHg3Ri1cXHg4NFxceDg2LVxceDlGXFx1RkZGRVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdLztcbnZhciBQQVRURVJOX05PTl9BU0NJSV9MSU5FX0JSRUFLUyA9IC9bXFx4ODVcXHUyMDI4XFx1MjAyOV0vO1xudmFyIFBBVFRFUk5fRkxPV19JTkRJQ0FUT1JTICAgICAgID0gL1ssXFxbXFxdXFx7XFx9XS87XG52YXIgUEFUVEVSTl9UQUdfSEFORExFICAgICAgICAgICAgPSAvXig/OiF8ISF8IVthLXpcXC1dKyEpJC9pO1xudmFyIFBBVFRFUk5fVEFHX1VSSSAgICAgICAgICAgICAgID0gL14oPzohfFteLFxcW1xcXVxce1xcfV0pKD86JVswLTlhLWZdezJ9fFswLTlhLXpcXC0jO1xcL1xcPzpAJj1cXCtcXCQsX1xcLiF+XFwqJ1xcKFxcKVxcW1xcXV0pKiQvaTtcblxuXG5mdW5jdGlvbiBfY2xhc3Mob2JqKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTsgfVxuXG5mdW5jdGlvbiBpc19FT0woYykge1xuICByZXR1cm4gKGMgPT09IDB4MEEvKiBMRiAqLykgfHwgKGMgPT09IDB4MEQvKiBDUiAqLyk7XG59XG5cbmZ1bmN0aW9uIGlzX1dISVRFX1NQQUNFKGMpIHtcbiAgcmV0dXJuIChjID09PSAweDA5LyogVGFiICovKSB8fCAoYyA9PT0gMHgyMC8qIFNwYWNlICovKTtcbn1cblxuZnVuY3Rpb24gaXNfV1NfT1JfRU9MKGMpIHtcbiAgcmV0dXJuIChjID09PSAweDA5LyogVGFiICovKSB8fFxuICAgICAgICAgKGMgPT09IDB4MjAvKiBTcGFjZSAqLykgfHxcbiAgICAgICAgIChjID09PSAweDBBLyogTEYgKi8pIHx8XG4gICAgICAgICAoYyA9PT0gMHgwRC8qIENSICovKTtcbn1cblxuZnVuY3Rpb24gaXNfRkxPV19JTkRJQ0FUT1IoYykge1xuICByZXR1cm4gYyA9PT0gMHgyQy8qICwgKi8gfHxcbiAgICAgICAgIGMgPT09IDB4NUIvKiBbICovIHx8XG4gICAgICAgICBjID09PSAweDVELyogXSAqLyB8fFxuICAgICAgICAgYyA9PT0gMHg3Qi8qIHsgKi8gfHxcbiAgICAgICAgIGMgPT09IDB4N0QvKiB9ICovO1xufVxuXG5mdW5jdGlvbiBmcm9tSGV4Q29kZShjKSB7XG4gIHZhciBsYztcblxuICBpZiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkge1xuICAgIHJldHVybiBjIC0gMHgzMDtcbiAgfVxuXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSovXG4gIGxjID0gYyB8IDB4MjA7XG5cbiAgaWYgKCgweDYxLyogYSAqLyA8PSBsYykgJiYgKGxjIDw9IDB4NjYvKiBmICovKSkge1xuICAgIHJldHVybiBsYyAtIDB4NjEgKyAxMDtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlZEhleExlbihjKSB7XG4gIGlmIChjID09PSAweDc4LyogeCAqLykgeyByZXR1cm4gMjsgfVxuICBpZiAoYyA9PT0gMHg3NS8qIHUgKi8pIHsgcmV0dXJuIDQ7IH1cbiAgaWYgKGMgPT09IDB4NTUvKiBVICovKSB7IHJldHVybiA4OyB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBmcm9tRGVjaW1hbENvZGUoYykge1xuICBpZiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkge1xuICAgIHJldHVybiBjIC0gMHgzMDtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRXNjYXBlU2VxdWVuY2UoYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBpbmRlbnQgKi9cbiAgcmV0dXJuIChjID09PSAweDMwLyogMCAqLykgPyAnXFx4MDAnIDpcbiAgICAgICAgKGMgPT09IDB4NjEvKiBhICovKSA/ICdcXHgwNycgOlxuICAgICAgICAoYyA9PT0gMHg2Mi8qIGIgKi8pID8gJ1xceDA4JyA6XG4gICAgICAgIChjID09PSAweDc0LyogdCAqLykgPyAnXFx4MDknIDpcbiAgICAgICAgKGMgPT09IDB4MDkvKiBUYWIgKi8pID8gJ1xceDA5JyA6XG4gICAgICAgIChjID09PSAweDZFLyogbiAqLykgPyAnXFx4MEEnIDpcbiAgICAgICAgKGMgPT09IDB4NzYvKiB2ICovKSA/ICdcXHgwQicgOlxuICAgICAgICAoYyA9PT0gMHg2Ni8qIGYgKi8pID8gJ1xceDBDJyA6XG4gICAgICAgIChjID09PSAweDcyLyogciAqLykgPyAnXFx4MEQnIDpcbiAgICAgICAgKGMgPT09IDB4NjUvKiBlICovKSA/ICdcXHgxQicgOlxuICAgICAgICAoYyA9PT0gMHgyMC8qIFNwYWNlICovKSA/ICcgJyA6XG4gICAgICAgIChjID09PSAweDIyLyogXCIgKi8pID8gJ1xceDIyJyA6XG4gICAgICAgIChjID09PSAweDJGLyogLyAqLykgPyAnLycgOlxuICAgICAgICAoYyA9PT0gMHg1Qy8qIFxcICovKSA/ICdcXHg1QycgOlxuICAgICAgICAoYyA9PT0gMHg0RS8qIE4gKi8pID8gJ1xceDg1JyA6XG4gICAgICAgIChjID09PSAweDVGLyogXyAqLykgPyAnXFx4QTAnIDpcbiAgICAgICAgKGMgPT09IDB4NEMvKiBMICovKSA/ICdcXHUyMDI4JyA6XG4gICAgICAgIChjID09PSAweDUwLyogUCAqLykgPyAnXFx1MjAyOScgOiAnJztcbn1cblxuZnVuY3Rpb24gY2hhckZyb21Db2RlcG9pbnQoYykge1xuICBpZiAoYyA8PSAweEZGRkYpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgfVxuICAvLyBFbmNvZGUgVVRGLTE2IHN1cnJvZ2F0ZSBwYWlyXG4gIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi0xNiNDb2RlX3BvaW50c19VLjJCMDEwMDAwX3RvX1UuMkIxMEZGRkZcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgKChjIC0gMHgwMTAwMDApID4+IDEwKSArIDB4RDgwMCxcbiAgICAoKGMgLSAweDAxMDAwMCkgJiAweDAzRkYpICsgMHhEQzAwXG4gICk7XG59XG5cbnZhciBzaW1wbGVFc2NhcGVDaGVjayA9IG5ldyBBcnJheSgyNTYpOyAvLyBpbnRlZ2VyLCBmb3IgZmFzdCBhY2Nlc3NcbnZhciBzaW1wbGVFc2NhcGVNYXAgPSBuZXcgQXJyYXkoMjU2KTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgc2ltcGxlRXNjYXBlQ2hlY2tbaV0gPSBzaW1wbGVFc2NhcGVTZXF1ZW5jZShpKSA/IDEgOiAwO1xuICBzaW1wbGVFc2NhcGVNYXBbaV0gPSBzaW1wbGVFc2NhcGVTZXF1ZW5jZShpKTtcbn1cblxuXG5mdW5jdGlvbiBTdGF0ZShpbnB1dCwgb3B0aW9ucykge1xuICB0aGlzLmlucHV0ID0gaW5wdXQ7XG5cbiAgdGhpcy5maWxlbmFtZSAgPSBvcHRpb25zWydmaWxlbmFtZSddICB8fCBudWxsO1xuICB0aGlzLnNjaGVtYSAgICA9IG9wdGlvbnNbJ3NjaGVtYSddICAgIHx8IERFRkFVTFRfU0NIRU1BO1xuICB0aGlzLm9uV2FybmluZyA9IG9wdGlvbnNbJ29uV2FybmluZyddIHx8IG51bGw7XG4gIC8vIChIaWRkZW4pIFJlbW92ZT8gbWFrZXMgdGhlIGxvYWRlciB0byBleHBlY3QgWUFNTCAxLjEgZG9jdW1lbnRzXG4gIC8vIGlmIHN1Y2ggZG9jdW1lbnRzIGhhdmUgbm8gZXhwbGljaXQgJVlBTUwgZGlyZWN0aXZlXG4gIHRoaXMubGVnYWN5ICAgID0gb3B0aW9uc1snbGVnYWN5J10gICAgfHwgZmFsc2U7XG5cbiAgdGhpcy5qc29uICAgICAgPSBvcHRpb25zWydqc29uJ10gICAgICB8fCBmYWxzZTtcbiAgdGhpcy5saXN0ZW5lciAgPSBvcHRpb25zWydsaXN0ZW5lciddICB8fCBudWxsO1xuXG4gIHRoaXMuaW1wbGljaXRUeXBlcyA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkSW1wbGljaXQ7XG4gIHRoaXMudHlwZU1hcCAgICAgICA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkVHlwZU1hcDtcblxuICB0aGlzLmxlbmd0aCAgICAgPSBpbnB1dC5sZW5ndGg7XG4gIHRoaXMucG9zaXRpb24gICA9IDA7XG4gIHRoaXMubGluZSAgICAgICA9IDA7XG4gIHRoaXMubGluZVN0YXJ0ICA9IDA7XG4gIHRoaXMubGluZUluZGVudCA9IDA7XG5cbiAgLy8gcG9zaXRpb24gb2YgZmlyc3QgbGVhZGluZyB0YWIgaW4gdGhlIGN1cnJlbnQgbGluZSxcbiAgLy8gdXNlZCB0byBtYWtlIHN1cmUgdGhlcmUgYXJlIG5vIHRhYnMgaW4gdGhlIGluZGVudGF0aW9uXG4gIHRoaXMuZmlyc3RUYWJJbkxpbmUgPSAtMTtcblxuICB0aGlzLmRvY3VtZW50cyA9IFtdO1xuXG4gIC8qXG4gIHRoaXMudmVyc2lvbjtcbiAgdGhpcy5jaGVja0xpbmVCcmVha3M7XG4gIHRoaXMudGFnTWFwO1xuICB0aGlzLmFuY2hvck1hcDtcbiAgdGhpcy50YWc7XG4gIHRoaXMuYW5jaG9yO1xuICB0aGlzLmtpbmQ7XG4gIHRoaXMucmVzdWx0OyovXG5cbn1cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKSB7XG4gIHZhciBtYXJrID0ge1xuICAgIG5hbWU6ICAgICBzdGF0ZS5maWxlbmFtZSxcbiAgICBidWZmZXI6ICAgc3RhdGUuaW5wdXQuc2xpY2UoMCwgLTEpLCAvLyBvbWl0IHRyYWlsaW5nIFxcMFxuICAgIHBvc2l0aW9uOiBzdGF0ZS5wb3NpdGlvbixcbiAgICBsaW5lOiAgICAgc3RhdGUubGluZSxcbiAgICBjb2x1bW46ICAgc3RhdGUucG9zaXRpb24gLSBzdGF0ZS5saW5lU3RhcnRcbiAgfTtcblxuICBtYXJrLnNuaXBwZXQgPSBtYWtlU25pcHBldChtYXJrKTtcblxuICByZXR1cm4gbmV3IFlBTUxFeGNlcHRpb24obWVzc2FnZSwgbWFyayk7XG59XG5cbmZ1bmN0aW9uIHRocm93RXJyb3Ioc3RhdGUsIG1lc3NhZ2UpIHtcbiAgdGhyb3cgZ2VuZXJhdGVFcnJvcihzdGF0ZSwgbWVzc2FnZSk7XG59XG5cbmZ1bmN0aW9uIHRocm93V2FybmluZyhzdGF0ZSwgbWVzc2FnZSkge1xuICBpZiAoc3RhdGUub25XYXJuaW5nKSB7XG4gICAgc3RhdGUub25XYXJuaW5nLmNhbGwobnVsbCwgZ2VuZXJhdGVFcnJvcihzdGF0ZSwgbWVzc2FnZSkpO1xuICB9XG59XG5cblxudmFyIGRpcmVjdGl2ZUhhbmRsZXJzID0ge1xuXG4gIFlBTUw6IGZ1bmN0aW9uIGhhbmRsZVlhbWxEaXJlY3RpdmUoc3RhdGUsIG5hbWUsIGFyZ3MpIHtcblxuICAgIHZhciBtYXRjaCwgbWFqb3IsIG1pbm9yO1xuXG4gICAgaWYgKHN0YXRlLnZlcnNpb24gIT09IG51bGwpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGlvbiBvZiAlWUFNTCBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdZQU1MIGRpcmVjdGl2ZSBhY2NlcHRzIGV4YWN0bHkgb25lIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgbWF0Y2ggPSAvXihbMC05XSspXFwuKFswLTldKykkLy5leGVjKGFyZ3NbMF0pO1xuXG4gICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCBhcmd1bWVudCBvZiB0aGUgWUFNTCBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBtYWpvciA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgbWlub3IgPSBwYXJzZUludChtYXRjaFsyXSwgMTApO1xuXG4gICAgaWYgKG1ham9yICE9PSAxKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5hY2NlcHRhYmxlIFlBTUwgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnQnKTtcbiAgICB9XG5cbiAgICBzdGF0ZS52ZXJzaW9uID0gYXJnc1swXTtcbiAgICBzdGF0ZS5jaGVja0xpbmVCcmVha3MgPSAobWlub3IgPCAyKTtcblxuICAgIGlmIChtaW5vciAhPT0gMSAmJiBtaW5vciAhPT0gMikge1xuICAgICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAndW5zdXBwb3J0ZWQgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuICAgIH1cbiAgfSxcblxuICBUQUc6IGZ1bmN0aW9uIGhhbmRsZVRhZ0RpcmVjdGl2ZShzdGF0ZSwgbmFtZSwgYXJncykge1xuXG4gICAgdmFyIGhhbmRsZSwgcHJlZml4O1xuXG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnVEFHIGRpcmVjdGl2ZSBhY2NlcHRzIGV4YWN0bHkgdHdvIGFyZ3VtZW50cycpO1xuICAgIH1cblxuICAgIGhhbmRsZSA9IGFyZ3NbMF07XG4gICAgcHJlZml4ID0gYXJnc1sxXTtcblxuICAgIGlmICghUEFUVEVSTl9UQUdfSEFORExFLnRlc3QoaGFuZGxlKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2lsbC1mb3JtZWQgdGFnIGhhbmRsZSAoZmlyc3QgYXJndW1lbnQpIG9mIHRoZSBUQUcgZGlyZWN0aXZlJyk7XG4gICAgfVxuXG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLnRhZ01hcCwgaGFuZGxlKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RoZXJlIGlzIGEgcHJldmlvdXNseSBkZWNsYXJlZCBzdWZmaXggZm9yIFwiJyArIGhhbmRsZSArICdcIiB0YWcgaGFuZGxlJyk7XG4gICAgfVxuXG4gICAgaWYgKCFQQVRURVJOX1RBR19VUkkudGVzdChwcmVmaXgpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCB0YWcgcHJlZml4IChzZWNvbmQgYXJndW1lbnQpIG9mIHRoZSBUQUcgZGlyZWN0aXZlJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHByZWZpeCA9IGRlY29kZVVSSUNvbXBvbmVudChwcmVmaXgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBwcmVmaXggaXMgbWFsZm9ybWVkOiAnICsgcHJlZml4KTtcbiAgICB9XG5cbiAgICBzdGF0ZS50YWdNYXBbaGFuZGxlXSA9IHByZWZpeDtcbiAgfVxufTtcblxuXG5mdW5jdGlvbiBjYXB0dXJlU2VnbWVudChzdGF0ZSwgc3RhcnQsIGVuZCwgY2hlY2tKc29uKSB7XG4gIHZhciBfcG9zaXRpb24sIF9sZW5ndGgsIF9jaGFyYWN0ZXIsIF9yZXN1bHQ7XG5cbiAgaWYgKHN0YXJ0IDwgZW5kKSB7XG4gICAgX3Jlc3VsdCA9IHN0YXRlLmlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgaWYgKGNoZWNrSnNvbikge1xuICAgICAgZm9yIChfcG9zaXRpb24gPSAwLCBfbGVuZ3RoID0gX3Jlc3VsdC5sZW5ndGg7IF9wb3NpdGlvbiA8IF9sZW5ndGg7IF9wb3NpdGlvbiArPSAxKSB7XG4gICAgICAgIF9jaGFyYWN0ZXIgPSBfcmVzdWx0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTtcbiAgICAgICAgaWYgKCEoX2NoYXJhY3RlciA9PT0gMHgwOSB8fFxuICAgICAgICAgICAgICAoMHgyMCA8PSBfY2hhcmFjdGVyICYmIF9jaGFyYWN0ZXIgPD0gMHgxMEZGRkYpKSkge1xuICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdleHBlY3RlZCB2YWxpZCBKU09OIGNoYXJhY3RlcicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChQQVRURVJOX05PTl9QUklOVEFCTEUudGVzdChfcmVzdWx0KSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RoZSBzdHJlYW0gY29udGFpbnMgbm9uLXByaW50YWJsZSBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuXG4gICAgc3RhdGUucmVzdWx0ICs9IF9yZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VNYXBwaW5ncyhzdGF0ZSwgZGVzdGluYXRpb24sIHNvdXJjZSwgb3ZlcnJpZGFibGVLZXlzKSB7XG4gIHZhciBzb3VyY2VLZXlzLCBrZXksIGluZGV4LCBxdWFudGl0eTtcblxuICBpZiAoIWNvbW1vbi5pc09iamVjdChzb3VyY2UpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Nhbm5vdCBtZXJnZSBtYXBwaW5nczsgdGhlIHByb3ZpZGVkIHNvdXJjZSBvYmplY3QgaXMgdW5hY2NlcHRhYmxlJyk7XG4gIH1cblxuICBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICBmb3IgKGluZGV4ID0gMCwgcXVhbnRpdHkgPSBzb3VyY2VLZXlzLmxlbmd0aDsgaW5kZXggPCBxdWFudGl0eTsgaW5kZXggKz0gMSkge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaW5kZXhdO1xuXG4gICAgaWYgKCFfaGFzT3duUHJvcGVydHkuY2FsbChkZXN0aW5hdGlvbiwga2V5KSkge1xuICAgICAgZGVzdGluYXRpb25ba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgb3ZlcnJpZGFibGVLZXlzW2tleV0gPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlLFxuICBzdGFydExpbmUsIHN0YXJ0TGluZVN0YXJ0LCBzdGFydFBvcykge1xuXG4gIHZhciBpbmRleCwgcXVhbnRpdHk7XG5cbiAgLy8gVGhlIG91dHB1dCBpcyBhIHBsYWluIG9iamVjdCBoZXJlLCBzbyBrZXlzIGNhbiBvbmx5IGJlIHN0cmluZ3MuXG4gIC8vIFdlIG5lZWQgdG8gY29udmVydCBrZXlOb2RlIHRvIGEgc3RyaW5nLCBidXQgZG9pbmcgc28gY2FuIGhhbmcgdGhlIHByb2Nlc3NcbiAgLy8gKGRlZXBseSBuZXN0ZWQgYXJyYXlzIHRoYXQgZXhwbG9kZSBleHBvbmVudGlhbGx5IHVzaW5nIGFsaWFzZXMpLlxuICBpZiAoQXJyYXkuaXNBcnJheShrZXlOb2RlKSkge1xuICAgIGtleU5vZGUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChrZXlOb2RlKTtcblxuICAgIGZvciAoaW5kZXggPSAwLCBxdWFudGl0eSA9IGtleU5vZGUubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXlOb2RlW2luZGV4XSkpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25lc3RlZCBhcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW5zaWRlIGtleXMnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBrZXlOb2RlID09PSAnb2JqZWN0JyAmJiBfY2xhc3Moa2V5Tm9kZVtpbmRleF0pID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICBrZXlOb2RlW2luZGV4XSA9ICdbb2JqZWN0IE9iamVjdF0nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEF2b2lkIGNvZGUgZXhlY3V0aW9uIGluIGxvYWQoKSB2aWEgdG9TdHJpbmcgcHJvcGVydHlcbiAgLy8gKHN0aWxsIHVzZSBpdHMgb3duIHRvU3RyaW5nIGZvciBhcnJheXMsIHRpbWVzdGFtcHMsXG4gIC8vIGFuZCB3aGF0ZXZlciB1c2VyIHNjaGVtYSBleHRlbnNpb25zIGhhcHBlbiB0byBoYXZlIEBAdG9TdHJpbmdUYWcpXG4gIGlmICh0eXBlb2Yga2V5Tm9kZSA9PT0gJ29iamVjdCcgJiYgX2NsYXNzKGtleU5vZGUpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIGtleU5vZGUgPSAnW29iamVjdCBPYmplY3RdJztcbiAgfVxuXG5cbiAga2V5Tm9kZSA9IFN0cmluZyhrZXlOb2RlKTtcblxuICBpZiAoX3Jlc3VsdCA9PT0gbnVsbCkge1xuICAgIF9yZXN1bHQgPSB7fTtcbiAgfVxuXG4gIGlmIChrZXlUYWcgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjptZXJnZScpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZU5vZGUpKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgcXVhbnRpdHkgPSB2YWx1ZU5vZGUubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAgICAgIG1lcmdlTWFwcGluZ3Moc3RhdGUsIF9yZXN1bHQsIHZhbHVlTm9kZVtpbmRleF0sIG92ZXJyaWRhYmxlS2V5cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlTWFwcGluZ3Moc3RhdGUsIF9yZXN1bHQsIHZhbHVlTm9kZSwgb3ZlcnJpZGFibGVLZXlzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFzdGF0ZS5qc29uICYmXG4gICAgICAgICFfaGFzT3duUHJvcGVydHkuY2FsbChvdmVycmlkYWJsZUtleXMsIGtleU5vZGUpICYmXG4gICAgICAgIF9oYXNPd25Qcm9wZXJ0eS5jYWxsKF9yZXN1bHQsIGtleU5vZGUpKSB7XG4gICAgICBzdGF0ZS5saW5lID0gc3RhcnRMaW5lIHx8IHN0YXRlLmxpbmU7XG4gICAgICBzdGF0ZS5saW5lU3RhcnQgPSBzdGFydExpbmVTdGFydCB8fCBzdGF0ZS5saW5lU3RhcnQ7XG4gICAgICBzdGF0ZS5wb3NpdGlvbiA9IHN0YXJ0UG9zIHx8IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0ZWQgbWFwcGluZyBrZXknKTtcbiAgICB9XG5cbiAgICAvLyB1c2VkIGZvciB0aGlzIHNwZWNpZmljIGtleSBvbmx5IGJlY2F1c2UgT2JqZWN0LmRlZmluZVByb3BlcnR5IGlzIHNsb3dcbiAgICBpZiAoa2V5Tm9kZSA9PT0gJ19fcHJvdG9fXycpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfcmVzdWx0LCBrZXlOb2RlLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZU5vZGVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBfcmVzdWx0W2tleU5vZGVdID0gdmFsdWVOb2RlO1xuICAgIH1cbiAgICBkZWxldGUgb3ZlcnJpZGFibGVLZXlzW2tleU5vZGVdO1xuICB9XG5cbiAgcmV0dXJuIF9yZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRMaW5lQnJlYWsoc3RhdGUpIHtcbiAgdmFyIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDBBLyogTEYgKi8pIHtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICB9IGVsc2UgaWYgKGNoID09PSAweDBELyogQ1IgKi8pIHtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgIGlmIChzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSA9PT0gMHgwQS8qIExGICovKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYSBsaW5lIGJyZWFrIGlzIGV4cGVjdGVkJyk7XG4gIH1cblxuICBzdGF0ZS5saW5lICs9IDE7XG4gIHN0YXRlLmxpbmVTdGFydCA9IHN0YXRlLnBvc2l0aW9uO1xuICBzdGF0ZS5maXJzdFRhYkluTGluZSA9IC0xO1xufVxuXG5mdW5jdGlvbiBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBhbGxvd0NvbW1lbnRzLCBjaGVja0luZGVudCkge1xuICB2YXIgbGluZUJyZWFrcyA9IDAsXG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgIGlmIChjaCA9PT0gMHgwOS8qIFRhYiAqLyAmJiBzdGF0ZS5maXJzdFRhYkluTGluZSA9PT0gLTEpIHtcbiAgICAgICAgc3RhdGUuZmlyc3RUYWJJbkxpbmUgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoYWxsb3dDb21tZW50cyAmJiBjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgIGRvIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfSB3aGlsZSAoY2ggIT09IDB4MEEvKiBMRiAqLyAmJiBjaCAhPT0gMHgwRC8qIENSICovICYmIGNoICE9PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG5cbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBsaW5lQnJlYWtzKys7XG4gICAgICBzdGF0ZS5saW5lSW5kZW50ID0gMDtcblxuICAgICAgd2hpbGUgKGNoID09PSAweDIwLyogU3BhY2UgKi8pIHtcbiAgICAgICAgc3RhdGUubGluZUluZGVudCsrO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjaGVja0luZGVudCAhPT0gLTEgJiYgbGluZUJyZWFrcyAhPT0gMCAmJiBzdGF0ZS5saW5lSW5kZW50IDwgY2hlY2tJbmRlbnQpIHtcbiAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICdkZWZpY2llbnQgaW5kZW50YXRpb24nKTtcbiAgfVxuXG4gIHJldHVybiBsaW5lQnJlYWtzO1xufVxuXG5mdW5jdGlvbiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG5cbiAgLy8gQ29uZGl0aW9uIHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgaXMgdGVzdGVkXG4gIC8vIGluIHBhcmVudCBvbiBlYWNoIGNhbGwsIGZvciBlZmZpY2llbmN5LiBObyBuZWVkcyB0byB0ZXN0IGhlcmUgYWdhaW4uXG4gIGlmICgoY2ggPT09IDB4MkQvKiAtICovIHx8IGNoID09PSAweDJFLyogLiAqLykgJiZcbiAgICAgIGNoID09PSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbiArIDEpICYmXG4gICAgICBjaCA9PT0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24gKyAyKSkge1xuXG4gICAgX3Bvc2l0aW9uICs9IDM7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gMCB8fCBpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRm9sZGVkTGluZXMoc3RhdGUsIGNvdW50KSB7XG4gIGlmIChjb3VudCA9PT0gMSkge1xuICAgIHN0YXRlLnJlc3VsdCArPSAnICc7XG4gIH0gZWxzZSBpZiAoY291bnQgPiAxKSB7XG4gICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGNvdW50IC0gMSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiByZWFkUGxhaW5TY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQsIHdpdGhpbkZsb3dDb2xsZWN0aW9uKSB7XG4gIHZhciBwcmVjZWRpbmcsXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICBjYXB0dXJlU3RhcnQsXG4gICAgICBjYXB0dXJlRW5kLFxuICAgICAgaGFzUGVuZGluZ0NvbnRlbnQsXG4gICAgICBfbGluZSxcbiAgICAgIF9saW5lU3RhcnQsXG4gICAgICBfbGluZUluZGVudCxcbiAgICAgIF9raW5kID0gc3RhdGUua2luZCxcbiAgICAgIF9yZXN1bHQgPSBzdGF0ZS5yZXN1bHQsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChpc19XU19PUl9FT0woY2gpICAgICAgfHxcbiAgICAgIGlzX0ZMT1dfSU5ESUNBVE9SKGNoKSB8fFxuICAgICAgY2ggPT09IDB4MjMvKiAjICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyNi8qICYgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDJBLyogKiAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjEvKiAhICovICAgIHx8XG4gICAgICBjaCA9PT0gMHg3Qy8qIHwgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDNFLyogPiAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjcvKiAnICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyMi8qIFwiICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyNS8qICUgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDQwLyogQCAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4NjAvKiBgICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGNoID09PSAweDNGLyogPyAqLyB8fCBjaCA9PT0gMHgyRC8qIC0gKi8pIHtcbiAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykgfHxcbiAgICAgICAgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoZm9sbG93aW5nKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG4gIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgaGFzUGVuZGluZ0NvbnRlbnQgPSBmYWxzZTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBpZiAoY2ggPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICAgIGlmIChpc19XU19PUl9FT0woZm9sbG93aW5nKSB8fFxuICAgICAgICAgIHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmIGlzX0ZMT1dfSU5ESUNBVE9SKGZvbGxvd2luZykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDIzLyogIyAqLykge1xuICAgICAgcHJlY2VkaW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiAtIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKHByZWNlZGluZykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHx8XG4gICAgICAgICAgICAgICB3aXRoaW5GbG93Q29sbGVjdGlvbiAmJiBpc19GTE9XX0lORElDQVRPUihjaCkpIHtcbiAgICAgIGJyZWFrO1xuXG4gICAgfSBlbHNlIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBfbGluZSA9IHN0YXRlLmxpbmU7XG4gICAgICBfbGluZVN0YXJ0ID0gc3RhdGUubGluZVN0YXJ0O1xuICAgICAgX2xpbmVJbmRlbnQgPSBzdGF0ZS5saW5lSW5kZW50O1xuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIC0xKTtcblxuICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPj0gbm9kZUluZGVudCkge1xuICAgICAgICBoYXNQZW5kaW5nQ29udGVudCA9IHRydWU7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucG9zaXRpb24gPSBjYXB0dXJlRW5kO1xuICAgICAgICBzdGF0ZS5saW5lID0gX2xpbmU7XG4gICAgICAgIHN0YXRlLmxpbmVTdGFydCA9IF9saW5lU3RhcnQ7XG4gICAgICAgIHN0YXRlLmxpbmVJbmRlbnQgPSBfbGluZUluZGVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc1BlbmRpbmdDb250ZW50KSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kLCBmYWxzZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBzdGF0ZS5saW5lIC0gX2xpbmUpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgaGFzUGVuZGluZ0NvbnRlbnQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uICsgMTtcbiAgICB9XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIH1cblxuICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kLCBmYWxzZSk7XG5cbiAgaWYgKHN0YXRlLnJlc3VsdCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9IF9raW5kO1xuICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlYWRTaW5nbGVRdW90ZWRTY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIGNoLFxuICAgICAgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDI3LyogJyAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG4gIHN0YXRlLnBvc2l0aW9uKys7XG4gIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDI3LyogJyAqLykge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICBpZiAoY2ggPT09IDB4MjcvKiAnICovKSB7XG4gICAgICAgIGNhcHR1cmVTdGFydCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgICBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgdHJ1ZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCkpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgZG9jdW1lbnQgd2l0aGluIGEgc2luZ2xlIHF1b3RlZCBzY2FsYXInKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWREb3VibGVRdW90ZWRTY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIGNhcHR1cmVTdGFydCxcbiAgICAgIGNhcHR1cmVFbmQsXG4gICAgICBoZXhMZW5ndGgsXG4gICAgICBoZXhSZXN1bHQsXG4gICAgICB0bXAsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyMi8qIFwiICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcbiAgc3RhdGUucG9zaXRpb24rKztcbiAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIHdoaWxlICgoY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkgIT09IDApIHtcbiAgICBpZiAoY2ggPT09IDB4MjIvKiBcIiAqLykge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHg1Qy8qIFxcICovKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCBub2RlSW5kZW50KTtcblxuICAgICAgICAvLyBUT0RPOiByZXdvcmsgdG8gaW5saW5lIGZuIHdpdGggbm8gdHlwZSBjYXN0P1xuICAgICAgfSBlbHNlIGlmIChjaCA8IDI1NiAmJiBzaW1wbGVFc2NhcGVDaGVja1tjaF0pIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IHNpbXBsZUVzY2FwZU1hcFtjaF07XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG5cbiAgICAgIH0gZWxzZSBpZiAoKHRtcCA9IGVzY2FwZWRIZXhMZW4oY2gpKSA+IDApIHtcbiAgICAgICAgaGV4TGVuZ3RoID0gdG1wO1xuICAgICAgICBoZXhSZXN1bHQgPSAwO1xuXG4gICAgICAgIGZvciAoOyBoZXhMZW5ndGggPiAwOyBoZXhMZW5ndGgtLSkge1xuICAgICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICAgIGlmICgodG1wID0gZnJvbUhleENvZGUoY2gpKSA+PSAwKSB7XG4gICAgICAgICAgICBoZXhSZXN1bHQgPSAoaGV4UmVzdWx0IDw8IDQpICsgdG1wO1xuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdleHBlY3RlZCBoZXhhZGVjaW1hbCBjaGFyYWN0ZXInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY2hhckZyb21Db2RlcG9pbnQoaGV4UmVzdWx0KTtcblxuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5rbm93biBlc2NhcGUgc2VxdWVuY2UnKTtcbiAgICAgIH1cblxuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgfSBlbHNlIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kLCB0cnVlKTtcbiAgICAgIHdyaXRlRm9sZGVkTGluZXMoc3RhdGUsIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCBub2RlSW5kZW50KSk7XG4gICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB9IGVsc2UgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBkb2N1bWVudCB3aXRoaW4gYSBkb3VibGUgcXVvdGVkIHNjYWxhcicpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gICAgfVxuICB9XG5cbiAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgZG91YmxlIHF1b3RlZCBzY2FsYXInKTtcbn1cblxuZnVuY3Rpb24gcmVhZEZsb3dDb2xsZWN0aW9uKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciByZWFkTmV4dCA9IHRydWUsXG4gICAgICBfbGluZSxcbiAgICAgIF9saW5lU3RhcnQsXG4gICAgICBfcG9zLFxuICAgICAgX3RhZyAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBfcmVzdWx0LFxuICAgICAgX2FuY2hvciAgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICB0ZXJtaW5hdG9yLFxuICAgICAgaXNQYWlyLFxuICAgICAgaXNFeHBsaWNpdFBhaXIsXG4gICAgICBpc01hcHBpbmcsXG4gICAgICBvdmVycmlkYWJsZUtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAga2V5Tm9kZSxcbiAgICAgIGtleVRhZyxcbiAgICAgIHZhbHVlTm9kZSxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDVCLyogWyAqLykge1xuICAgIHRlcm1pbmF0b3IgPSAweDVEOy8qIF0gKi9cbiAgICBpc01hcHBpbmcgPSBmYWxzZTtcbiAgICBfcmVzdWx0ID0gW107XG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4N0IvKiB7ICovKSB7XG4gICAgdGVybWluYXRvciA9IDB4N0Q7LyogfSAqL1xuICAgIGlzTWFwcGluZyA9IHRydWU7XG4gICAgX3Jlc3VsdCA9IHt9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSB0ZXJtaW5hdG9yKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgc3RhdGUudGFnID0gX3RhZztcbiAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICBzdGF0ZS5raW5kID0gaXNNYXBwaW5nID8gJ21hcHBpbmcnIDogJ3NlcXVlbmNlJztcbiAgICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCFyZWFkTmV4dCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ21pc3NlZCBjb21tYSBiZXR3ZWVuIGZsb3cgY29sbGVjdGlvbiBlbnRyaWVzJyk7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyQy8qICwgKi8pIHtcbiAgICAgIC8vIFwiZmxvdyBjb2xsZWN0aW9uIGVudHJpZXMgY2FuIG5ldmVyIGJlIGNvbXBsZXRlbHkgZW1wdHlcIiwgYXMgcGVyIFlBTUwgMS4yLCBzZWN0aW9uIDcuNFxuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgXCJleHBlY3RlZCB0aGUgbm9kZSBjb250ZW50LCBidXQgZm91bmQgJywnXCIpO1xuICAgIH1cblxuICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgIGlzUGFpciA9IGlzRXhwbGljaXRQYWlyID0gZmFsc2U7XG5cbiAgICBpZiAoY2ggPT09IDB4M0YvKiA/ICovKSB7XG4gICAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICAgIGlmIChpc19XU19PUl9FT0woZm9sbG93aW5nKSkge1xuICAgICAgICBpc1BhaXIgPSBpc0V4cGxpY2l0UGFpciA9IHRydWU7XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9saW5lID0gc3RhdGUubGluZTsgLy8gU2F2ZSB0aGUgY3VycmVudCBsaW5lLlxuICAgIF9saW5lU3RhcnQgPSBzdGF0ZS5saW5lU3RhcnQ7XG4gICAgX3BvcyA9IHN0YXRlLnBvc2l0aW9uO1xuICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0ZMT1dfSU4sIGZhbHNlLCB0cnVlKTtcbiAgICBrZXlUYWcgPSBzdGF0ZS50YWc7XG4gICAga2V5Tm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoKGlzRXhwbGljaXRQYWlyIHx8IHN0YXRlLmxpbmUgPT09IF9saW5lKSAmJiBjaCA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGlzUGFpciA9IHRydWU7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcbiAgICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0ZMT1dfSU4sIGZhbHNlLCB0cnVlKTtcbiAgICAgIHZhbHVlTm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAoaXNNYXBwaW5nKSB7XG4gICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlLCBfbGluZSwgX2xpbmVTdGFydCwgX3Bvcyk7XG4gICAgfSBlbHNlIGlmIChpc1BhaXIpIHtcbiAgICAgIF9yZXN1bHQucHVzaChzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBudWxsLCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlLCBfbGluZSwgX2xpbmVTdGFydCwgX3BvcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfcmVzdWx0LnB1c2goa2V5Tm9kZSk7XG4gICAgfVxuXG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSAweDJDLyogLCAqLykge1xuICAgICAgcmVhZE5leHQgPSB0cnVlO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWFkTmV4dCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIGZsb3cgY29sbGVjdGlvbicpO1xufVxuXG5mdW5jdGlvbiByZWFkQmxvY2tTY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIGNhcHR1cmVTdGFydCxcbiAgICAgIGZvbGRpbmcsXG4gICAgICBjaG9tcGluZyAgICAgICA9IENIT01QSU5HX0NMSVAsXG4gICAgICBkaWRSZWFkQ29udGVudCA9IGZhbHNlLFxuICAgICAgZGV0ZWN0ZWRJbmRlbnQgPSBmYWxzZSxcbiAgICAgIHRleHRJbmRlbnQgICAgID0gbm9kZUluZGVudCxcbiAgICAgIGVtcHR5TGluZXMgICAgID0gMCxcbiAgICAgIGF0TW9yZUluZGVudGVkID0gZmFsc2UsXG4gICAgICB0bXAsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHg3Qy8qIHwgKi8pIHtcbiAgICBmb2xkaW5nID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4M0UvKiA+ICovKSB7XG4gICAgZm9sZGluZyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IDB4MkIvKiArICovIHx8IGNoID09PSAweDJELyogLSAqLykge1xuICAgICAgaWYgKENIT01QSU5HX0NMSVAgPT09IGNob21waW5nKSB7XG4gICAgICAgIGNob21waW5nID0gKGNoID09PSAweDJCLyogKyAqLykgPyBDSE9NUElOR19LRUVQIDogQ0hPTVBJTkdfU1RSSVA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAncmVwZWF0IG9mIGEgY2hvbXBpbmcgbW9kZSBpZGVudGlmaWVyJyk7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKCh0bXAgPSBmcm9tRGVjaW1hbENvZGUoY2gpKSA+PSAwKSB7XG4gICAgICBpZiAodG1wID09PSAwKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdiYWQgZXhwbGljaXQgaW5kZW50YXRpb24gd2lkdGggb2YgYSBibG9jayBzY2FsYXI7IGl0IGNhbm5vdCBiZSBsZXNzIHRoYW4gb25lJyk7XG4gICAgICB9IGVsc2UgaWYgKCFkZXRlY3RlZEluZGVudCkge1xuICAgICAgICB0ZXh0SW5kZW50ID0gbm9kZUluZGVudCArIHRtcCAtIDE7XG4gICAgICAgIGRldGVjdGVkSW5kZW50ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdyZXBlYXQgb2YgYW4gaW5kZW50YXRpb24gd2lkdGggaWRlbnRpZmllcicpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICBkbyB7IGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTsgfVxuICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpO1xuXG4gICAgaWYgKGNoID09PSAweDIzLyogIyAqLykge1xuICAgICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICAgIHdoaWxlICghaXNfRU9MKGNoKSAmJiAoY2ggIT09IDApKTtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICByZWFkTGluZUJyZWFrKHN0YXRlKTtcbiAgICBzdGF0ZS5saW5lSW5kZW50ID0gMDtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICB3aGlsZSAoKCFkZXRlY3RlZEluZGVudCB8fCBzdGF0ZS5saW5lSW5kZW50IDwgdGV4dEluZGVudCkgJiZcbiAgICAgICAgICAgKGNoID09PSAweDIwLyogU3BhY2UgKi8pKSB7XG4gICAgICBzdGF0ZS5saW5lSW5kZW50Kys7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKCFkZXRlY3RlZEluZGVudCAmJiBzdGF0ZS5saW5lSW5kZW50ID4gdGV4dEluZGVudCkge1xuICAgICAgdGV4dEluZGVudCA9IHN0YXRlLmxpbmVJbmRlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGVtcHR5TGluZXMrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEVuZCBvZiB0aGUgc2NhbGFyLlxuICAgIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgdGV4dEluZGVudCkge1xuXG4gICAgICAvLyBQZXJmb3JtIHRoZSBjaG9tcGluZy5cbiAgICAgIGlmIChjaG9tcGluZyA9PT0gQ0hPTVBJTkdfS0VFUCkge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZGlkUmVhZENvbnRlbnQgPyAxICsgZW1wdHlMaW5lcyA6IGVtcHR5TGluZXMpO1xuICAgICAgfSBlbHNlIGlmIChjaG9tcGluZyA9PT0gQ0hPTVBJTkdfQ0xJUCkge1xuICAgICAgICBpZiAoZGlkUmVhZENvbnRlbnQpIHsgLy8gaS5lLiBvbmx5IGlmIHRoZSBzY2FsYXIgaXMgbm90IGVtcHR5LlxuICAgICAgICAgIHN0YXRlLnJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBCcmVhayB0aGlzIGB3aGlsZWAgY3ljbGUgYW5kIGdvIHRvIHRoZSBmdW5jaXRvbidzIGVwaWxvZ3VlLlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gRm9sZGVkIHN0eWxlOiB1c2UgZmFuY3kgcnVsZXMgdG8gaGFuZGxlIGxpbmUgYnJlYWtzLlxuICAgIGlmIChmb2xkaW5nKSB7XG5cbiAgICAgIC8vIExpbmVzIHN0YXJ0aW5nIHdpdGggd2hpdGUgc3BhY2UgY2hhcmFjdGVycyAobW9yZS1pbmRlbnRlZCBsaW5lcykgYXJlIG5vdCBmb2xkZWQuXG4gICAgICBpZiAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgIGF0TW9yZUluZGVudGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gZXhjZXB0IGZvciB0aGUgZmlyc3QgY29udGVudCBsaW5lIChjZi4gRXhhbXBsZSA4LjEpXG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBkaWRSZWFkQ29udGVudCA/IDEgKyBlbXB0eUxpbmVzIDogZW1wdHlMaW5lcyk7XG5cbiAgICAgIC8vIEVuZCBvZiBtb3JlLWluZGVudGVkIGJsb2NrLlxuICAgICAgfSBlbHNlIGlmIChhdE1vcmVJbmRlbnRlZCkge1xuICAgICAgICBhdE1vcmVJbmRlbnRlZCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZW1wdHlMaW5lcyArIDEpO1xuXG4gICAgICAvLyBKdXN0IG9uZSBsaW5lIGJyZWFrIC0gcGVyY2VpdmUgYXMgdGhlIHNhbWUgbGluZS5cbiAgICAgIH0gZWxzZSBpZiAoZW1wdHlMaW5lcyA9PT0gMCkge1xuICAgICAgICBpZiAoZGlkUmVhZENvbnRlbnQpIHsgLy8gaS5lLiBvbmx5IGlmIHdlIGhhdmUgYWxyZWFkeSByZWFkIHNvbWUgc2NhbGFyIGNvbnRlbnQuXG4gICAgICAgICAgc3RhdGUucmVzdWx0ICs9ICcgJztcbiAgICAgICAgfVxuXG4gICAgICAvLyBTZXZlcmFsIGxpbmUgYnJlYWtzIC0gcGVyY2VpdmUgYXMgZGlmZmVyZW50IGxpbmVzLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMpO1xuICAgICAgfVxuXG4gICAgLy8gTGl0ZXJhbCBzdHlsZToganVzdCBhZGQgZXhhY3QgbnVtYmVyIG9mIGxpbmUgYnJlYWtzIGJldHdlZW4gY29udGVudCBsaW5lcy5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gS2VlcCBhbGwgbGluZSBicmVha3MgZXhjZXB0IHRoZSBoZWFkZXIgbGluZSBicmVhay5cbiAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBkaWRSZWFkQ29udGVudCA/IDEgKyBlbXB0eUxpbmVzIDogZW1wdHlMaW5lcyk7XG4gICAgfVxuXG4gICAgZGlkUmVhZENvbnRlbnQgPSB0cnVlO1xuICAgIGRldGVjdGVkSW5kZW50ID0gdHJ1ZTtcbiAgICBlbXB0eUxpbmVzID0gMDtcbiAgICBjYXB0dXJlU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIHdoaWxlICghaXNfRU9MKGNoKSAmJiAoY2ggIT09IDApKSB7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWFkQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgX2xpbmUsXG4gICAgICBfdGFnICAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBfYW5jaG9yICAgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBfcmVzdWx0ICAgPSBbXSxcbiAgICAgIGZvbGxvd2luZyxcbiAgICAgIGRldGVjdGVkICA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgLy8gdGhlcmUgaXMgYSBsZWFkaW5nIHRhYiBiZWZvcmUgdGhpcyB0b2tlbiwgc28gaXQgY2FuJ3QgYmUgYSBibG9jayBzZXF1ZW5jZS9tYXBwaW5nO1xuICAvLyBpdCBjYW4gc3RpbGwgYmUgZmxvdyBzZXF1ZW5jZS9tYXBwaW5nIG9yIGEgc2NhbGFyXG4gIGlmIChzdGF0ZS5maXJzdFRhYkluTGluZSAhPT0gLTEpIHJldHVybiBmYWxzZTtcblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBfcmVzdWx0O1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBpZiAoc3RhdGUuZmlyc3RUYWJJbkxpbmUgIT09IC0xKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbiA9IHN0YXRlLmZpcnN0VGFiSW5MaW5lO1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhYiBjaGFyYWN0ZXJzIG11c3Qgbm90IGJlIHVzZWQgaW4gaW5kZW50YXRpb24nKTtcbiAgICB9XG5cbiAgICBpZiAoY2ggIT09IDB4MkQvKiAtICovKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICBpZiAoIWlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50IDw9IG5vZGVJbmRlbnQpIHtcbiAgICAgICAgX3Jlc3VsdC5wdXNoKG51bGwpO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7XG4gICAgY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfQkxPQ0tfSU4sIGZhbHNlLCB0cnVlKTtcbiAgICBfcmVzdWx0LnB1c2goc3RhdGUucmVzdWx0KTtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKChzdGF0ZS5saW5lID09PSBfbGluZSB8fCBzdGF0ZS5saW5lSW5kZW50ID4gbm9kZUluZGVudCkgJiYgKGNoICE9PSAwKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2JhZCBpbmRlbnRhdGlvbiBvZiBhIHNlcXVlbmNlIGVudHJ5Jyk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgbm9kZUluZGVudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRldGVjdGVkKSB7XG4gICAgc3RhdGUudGFnID0gX3RhZztcbiAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgIHN0YXRlLmtpbmQgPSAnc2VxdWVuY2UnO1xuICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZWFkQmxvY2tNYXBwaW5nKHN0YXRlLCBub2RlSW5kZW50LCBmbG93SW5kZW50KSB7XG4gIHZhciBmb2xsb3dpbmcsXG4gICAgICBhbGxvd0NvbXBhY3QsXG4gICAgICBfbGluZSxcbiAgICAgIF9rZXlMaW5lLFxuICAgICAgX2tleUxpbmVTdGFydCxcbiAgICAgIF9rZXlQb3MsXG4gICAgICBfdGFnICAgICAgICAgID0gc3RhdGUudGFnLFxuICAgICAgX2FuY2hvciAgICAgICA9IHN0YXRlLmFuY2hvcixcbiAgICAgIF9yZXN1bHQgICAgICAgPSB7fSxcbiAgICAgIG92ZXJyaWRhYmxlS2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBrZXlUYWcgICAgICAgID0gbnVsbCxcbiAgICAgIGtleU5vZGUgICAgICAgPSBudWxsLFxuICAgICAgdmFsdWVOb2RlICAgICA9IG51bGwsXG4gICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2UsXG4gICAgICBkZXRlY3RlZCAgICAgID0gZmFsc2UsXG4gICAgICBjaDtcblxuICAvLyB0aGVyZSBpcyBhIGxlYWRpbmcgdGFiIGJlZm9yZSB0aGlzIHRva2VuLCBzbyBpdCBjYW4ndCBiZSBhIGJsb2NrIHNlcXVlbmNlL21hcHBpbmc7XG4gIC8vIGl0IGNhbiBzdGlsbCBiZSBmbG93IHNlcXVlbmNlL21hcHBpbmcgb3IgYSBzY2FsYXJcbiAgaWYgKHN0YXRlLmZpcnN0VGFiSW5MaW5lICE9PSAtMSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIGlmICghYXRFeHBsaWNpdEtleSAmJiBzdGF0ZS5maXJzdFRhYkluTGluZSAhPT0gLTEpIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uID0gc3RhdGUuZmlyc3RUYWJJbkxpbmU7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFiIGNoYXJhY3RlcnMgbXVzdCBub3QgYmUgdXNlZCBpbiBpbmRlbnRhdGlvbicpO1xuICAgIH1cblxuICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7IC8vIFNhdmUgdGhlIGN1cnJlbnQgbGluZS5cblxuICAgIC8vXG4gICAgLy8gRXhwbGljaXQgbm90YXRpb24gY2FzZS4gVGhlcmUgYXJlIHR3byBzZXBhcmF0ZSBibG9ja3M6XG4gICAgLy8gZmlyc3QgZm9yIHRoZSBrZXkgKGRlbm90ZWQgYnkgXCI/XCIpIGFuZCBzZWNvbmQgZm9yIHRoZSB2YWx1ZSAoZGVub3RlZCBieSBcIjpcIilcbiAgICAvL1xuICAgIGlmICgoY2ggPT09IDB4M0YvKiA/ICovIHx8IGNoID09PSAweDNBLyogOiAqLykgJiYgaXNfV1NfT1JfRU9MKGZvbGxvd2luZykpIHtcblxuICAgICAgaWYgKGNoID09PSAweDNGLyogPyAqLykge1xuICAgICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCBudWxsLCBfa2V5TGluZSwgX2tleUxpbmVTdGFydCwgX2tleVBvcyk7XG4gICAgICAgICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgICAgIGF0RXhwbGljaXRLZXkgPSB0cnVlO1xuICAgICAgICBhbGxvd0NvbXBhY3QgPSB0cnVlO1xuXG4gICAgICB9IGVsc2UgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgLy8gaS5lLiAweDNBLyogOiAqLyA9PT0gY2hhcmFjdGVyIGFmdGVyIHRoZSBleHBsaWNpdCBrZXkuXG4gICAgICAgIGF0RXhwbGljaXRLZXkgPSBmYWxzZTtcbiAgICAgICAgYWxsb3dDb21wYWN0ID0gdHJ1ZTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2luY29tcGxldGUgZXhwbGljaXQgbWFwcGluZyBwYWlyOyBhIGtleSBub2RlIGlzIG1pc3NlZDsgb3IgZm9sbG93ZWQgYnkgYSBub24tdGFidWxhdGVkIGVtcHR5IGxpbmUnKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUucG9zaXRpb24gKz0gMTtcbiAgICAgIGNoID0gZm9sbG93aW5nO1xuXG4gICAgLy9cbiAgICAvLyBJbXBsaWNpdCBub3RhdGlvbiBjYXNlLiBGbG93LXN0eWxlIG5vZGUgYXMgdGhlIGtleSBmaXJzdCwgdGhlbiBcIjpcIiwgYW5kIHRoZSB2YWx1ZS5cbiAgICAvL1xuICAgIH0gZWxzZSB7XG4gICAgICBfa2V5TGluZSA9IHN0YXRlLmxpbmU7XG4gICAgICBfa2V5TGluZVN0YXJ0ID0gc3RhdGUubGluZVN0YXJ0O1xuICAgICAgX2tleVBvcyA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgICBpZiAoIWNvbXBvc2VOb2RlKHN0YXRlLCBmbG93SW5kZW50LCBDT05URVhUX0ZMT1dfT1VULCBmYWxzZSwgdHJ1ZSkpIHtcbiAgICAgICAgLy8gTmVpdGhlciBpbXBsaWNpdCBub3IgZXhwbGljaXQgbm90YXRpb24uXG4gICAgICAgIC8vIFJlYWRpbmcgaXMgZG9uZS4gR28gdG8gdGhlIGVwaWxvZ3VlLlxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLmxpbmUgPT09IF9saW5lKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgd2hpbGUgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaCA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgICBpZiAoIWlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdhIHdoaXRlc3BhY2UgY2hhcmFjdGVyIGlzIGV4cGVjdGVkIGFmdGVyIHRoZSBrZXktdmFsdWUgc2VwYXJhdG9yIHdpdGhpbiBhIGJsb2NrIG1hcHBpbmcnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIG51bGwsIF9rZXlMaW5lLCBfa2V5TGluZVN0YXJ0LCBfa2V5UG9zKTtcbiAgICAgICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRldGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgICAgICAgYWxsb3dDb21wYWN0ID0gZmFsc2U7XG4gICAgICAgICAga2V5VGFnID0gc3RhdGUudGFnO1xuICAgICAgICAgIGtleU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG5cbiAgICAgICAgfSBlbHNlIGlmIChkZXRlY3RlZCkge1xuICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW4gbm90IHJlYWQgYW4gaW1wbGljaXQgbWFwcGluZyBwYWlyOyBhIGNvbG9uIGlzIG1pc3NlZCcpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUudGFnID0gX3RhZztcbiAgICAgICAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBLZWVwIHRoZSByZXN1bHQgb2YgYGNvbXBvc2VOb2RlYC5cbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKGRldGVjdGVkKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW4gbm90IHJlYWQgYSBibG9jayBtYXBwaW5nIGVudHJ5OyBhIG11bHRpbGluZSBrZXkgbWF5IG5vdCBiZSBhbiBpbXBsaWNpdCBrZXknKTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUudGFnID0gX3RhZztcbiAgICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEtlZXAgdGhlIHJlc3VsdCBvZiBgY29tcG9zZU5vZGVgLlxuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gQ29tbW9uIHJlYWRpbmcgY29kZSBmb3IgYm90aCBleHBsaWNpdCBhbmQgaW1wbGljaXQgbm90YXRpb25zLlxuICAgIC8vXG4gICAgaWYgKHN0YXRlLmxpbmUgPT09IF9saW5lIHx8IHN0YXRlLmxpbmVJbmRlbnQgPiBub2RlSW5kZW50KSB7XG4gICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICBfa2V5TGluZSA9IHN0YXRlLmxpbmU7XG4gICAgICAgIF9rZXlMaW5lU3RhcnQgPSBzdGF0ZS5saW5lU3RhcnQ7XG4gICAgICAgIF9rZXlQb3MgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0JMT0NLX09VVCwgdHJ1ZSwgYWxsb3dDb21wYWN0KSkge1xuICAgICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAgIGtleU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWVOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghYXRFeHBsaWNpdEtleSkge1xuICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlLCBfa2V5TGluZSwgX2tleUxpbmVTdGFydCwgX2tleVBvcyk7XG4gICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmICgoc3RhdGUubGluZSA9PT0gX2xpbmUgfHwgc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQpICYmIChjaCAhPT0gMCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdiYWQgaW5kZW50YXRpb24gb2YgYSBtYXBwaW5nIGVudHJ5Jyk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgbm9kZUluZGVudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy9cbiAgLy8gRXBpbG9ndWUuXG4gIC8vXG5cbiAgLy8gU3BlY2lhbCBjYXNlOiBsYXN0IG1hcHBpbmcncyBub2RlIGNvbnRhaW5zIG9ubHkgdGhlIGtleSBpbiBleHBsaWNpdCBub3RhdGlvbi5cbiAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgbnVsbCwgX2tleUxpbmUsIF9rZXlMaW5lU3RhcnQsIF9rZXlQb3MpO1xuICB9XG5cbiAgLy8gRXhwb3NlIHRoZSByZXN1bHRpbmcgbWFwcGluZy5cbiAgaWYgKGRldGVjdGVkKSB7XG4gICAgc3RhdGUudGFnID0gX3RhZztcbiAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgIHN0YXRlLmtpbmQgPSAnbWFwcGluZyc7XG4gICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBkZXRlY3RlZDtcbn1cblxuZnVuY3Rpb24gcmVhZFRhZ1Byb3BlcnR5KHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sXG4gICAgICBpc1ZlcmJhdGltID0gZmFsc2UsXG4gICAgICBpc05hbWVkICAgID0gZmFsc2UsXG4gICAgICB0YWdIYW5kbGUsXG4gICAgICB0YWdOYW1lLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MjEvKiAhICovKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbCkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGlvbiBvZiBhIHRhZyBwcm9wZXJ0eScpO1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHgzQy8qIDwgKi8pIHtcbiAgICBpc1ZlcmJhdGltID0gdHJ1ZTtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgfSBlbHNlIGlmIChjaCA9PT0gMHgyMS8qICEgKi8pIHtcbiAgICBpc05hbWVkID0gdHJ1ZTtcbiAgICB0YWdIYW5kbGUgPSAnISEnO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICB9IGVsc2Uge1xuICAgIHRhZ0hhbmRsZSA9ICchJztcbiAgfVxuXG4gIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIGlmIChpc1ZlcmJhdGltKSB7XG4gICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICB3aGlsZSAoY2ggIT09IDAgJiYgY2ggIT09IDB4M0UvKiA+ICovKTtcblxuICAgIGlmIChzdGF0ZS5wb3NpdGlvbiA8IHN0YXRlLmxlbmd0aCkge1xuICAgICAgdGFnTmFtZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSB2ZXJiYXRpbSB0YWcnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpKSB7XG5cbiAgICAgIGlmIChjaCA9PT0gMHgyMS8qICEgKi8pIHtcbiAgICAgICAgaWYgKCFpc05hbWVkKSB7XG4gICAgICAgICAgdGFnSGFuZGxlID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uIC0gMSwgc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgICAgICAgIGlmICghUEFUVEVSTl9UQUdfSEFORExFLnRlc3QodGFnSGFuZGxlKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWVkIHRhZyBoYW5kbGUgY2Fubm90IGNvbnRhaW4gc3VjaCBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaXNOYW1lZCA9IHRydWU7XG4gICAgICAgICAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb24gKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgc3VmZml4IGNhbm5vdCBjb250YWluIGV4Y2xhbWF0aW9uIG1hcmtzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIHRhZ05hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChQQVRURVJOX0ZMT1dfSU5ESUNBVE9SUy50ZXN0KHRhZ05hbWUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIHN1ZmZpeCBjYW5ub3QgY29udGFpbiBmbG93IGluZGljYXRvciBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRhZ05hbWUgJiYgIVBBVFRFUk5fVEFHX1VSSS50ZXN0KHRhZ05hbWUpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBuYW1lIGNhbm5vdCBjb250YWluIHN1Y2ggY2hhcmFjdGVyczogJyArIHRhZ05hbWUpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB0YWdOYW1lID0gZGVjb2RlVVJJQ29tcG9uZW50KHRhZ05hbWUpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIG5hbWUgaXMgbWFsZm9ybWVkOiAnICsgdGFnTmFtZSk7XG4gIH1cblxuICBpZiAoaXNWZXJiYXRpbSkge1xuICAgIHN0YXRlLnRhZyA9IHRhZ05hbWU7XG5cbiAgfSBlbHNlIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChzdGF0ZS50YWdNYXAsIHRhZ0hhbmRsZSkpIHtcbiAgICBzdGF0ZS50YWcgPSBzdGF0ZS50YWdNYXBbdGFnSGFuZGxlXSArIHRhZ05hbWU7XG5cbiAgfSBlbHNlIGlmICh0YWdIYW5kbGUgPT09ICchJykge1xuICAgIHN0YXRlLnRhZyA9ICchJyArIHRhZ05hbWU7XG5cbiAgfSBlbHNlIGlmICh0YWdIYW5kbGUgPT09ICchIScpIHtcbiAgICBzdGF0ZS50YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6JyArIHRhZ05hbWU7XG5cbiAgfSBlbHNlIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5kZWNsYXJlZCB0YWcgaGFuZGxlIFwiJyArIHRhZ0hhbmRsZSArICdcIicpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRBbmNob3JQcm9wZXJ0eShzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MjYvKiAmICovKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGlvbiBvZiBhbiBhbmNob3IgcHJvcGVydHknKTtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpICYmICFpc19GTE9XX0lORElDQVRPUihjaCkpIHtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIH1cblxuICBpZiAoc3RhdGUucG9zaXRpb24gPT09IF9wb3NpdGlvbikge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lIG9mIGFuIGFuY2hvciBub2RlIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyJyk7XG4gIH1cblxuICBzdGF0ZS5hbmNob3IgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRBbGlhcyhzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLCBhbGlhcyxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDJBLyogKiAqLykgcmV0dXJuIGZhbHNlO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpICYmICFpc19GTE9XX0lORElDQVRPUihjaCkpIHtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIH1cblxuICBpZiAoc3RhdGUucG9zaXRpb24gPT09IF9wb3NpdGlvbikge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lIG9mIGFuIGFsaWFzIG5vZGUgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXInKTtcbiAgfVxuXG4gIGFsaWFzID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKCFfaGFzT3duUHJvcGVydHkuY2FsbChzdGF0ZS5hbmNob3JNYXAsIGFsaWFzKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmlkZW50aWZpZWQgYWxpYXMgXCInICsgYWxpYXMgKyAnXCInKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VsdCA9IHN0YXRlLmFuY2hvck1hcFthbGlhc107XG4gIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbXBvc2VOb2RlKHN0YXRlLCBwYXJlbnRJbmRlbnQsIG5vZGVDb250ZXh0LCBhbGxvd1RvU2VlaywgYWxsb3dDb21wYWN0KSB7XG4gIHZhciBhbGxvd0Jsb2NrU3R5bGVzLFxuICAgICAgYWxsb3dCbG9ja1NjYWxhcnMsXG4gICAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMsXG4gICAgICBpbmRlbnRTdGF0dXMgPSAxLCAvLyAxOiB0aGlzPnBhcmVudCwgMDogdGhpcz1wYXJlbnQsIC0xOiB0aGlzPHBhcmVudFxuICAgICAgYXROZXdMaW5lICA9IGZhbHNlLFxuICAgICAgaGFzQ29udGVudCA9IGZhbHNlLFxuICAgICAgdHlwZUluZGV4LFxuICAgICAgdHlwZVF1YW50aXR5LFxuICAgICAgdHlwZUxpc3QsXG4gICAgICB0eXBlLFxuICAgICAgZmxvd0luZGVudCxcbiAgICAgIGJsb2NrSW5kZW50O1xuXG4gIGlmIChzdGF0ZS5saXN0ZW5lciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmxpc3RlbmVyKCdvcGVuJywgc3RhdGUpO1xuICB9XG5cbiAgc3RhdGUudGFnICAgID0gbnVsbDtcbiAgc3RhdGUuYW5jaG9yID0gbnVsbDtcbiAgc3RhdGUua2luZCAgID0gbnVsbDtcbiAgc3RhdGUucmVzdWx0ID0gbnVsbDtcblxuICBhbGxvd0Jsb2NrU3R5bGVzID0gYWxsb3dCbG9ja1NjYWxhcnMgPSBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPVxuICAgIENPTlRFWFRfQkxPQ0tfT1VUID09PSBub2RlQ29udGV4dCB8fFxuICAgIENPTlRFWFRfQkxPQ0tfSU4gID09PSBub2RlQ29udGV4dDtcblxuICBpZiAoYWxsb3dUb1NlZWspIHtcbiAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICBhdE5ld0xpbmUgPSB0cnVlO1xuXG4gICAgICBpZiAoc3RhdGUubGluZUluZGVudCA+IHBhcmVudEluZGVudCkge1xuICAgICAgICBpbmRlbnRTdGF0dXMgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50ID09PSBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgaW5kZW50U3RhdHVzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IHBhcmVudEluZGVudCkge1xuICAgICAgICBpbmRlbnRTdGF0dXMgPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaW5kZW50U3RhdHVzID09PSAxKSB7XG4gICAgd2hpbGUgKHJlYWRUYWdQcm9wZXJ0eShzdGF0ZSkgfHwgcmVhZEFuY2hvclByb3BlcnR5KHN0YXRlKSkge1xuICAgICAgaWYgKHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKSkge1xuICAgICAgICBhdE5ld0xpbmUgPSB0cnVlO1xuICAgICAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBhbGxvd0Jsb2NrU3R5bGVzO1xuXG4gICAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gcGFyZW50SW5kZW50KSB7XG4gICAgICAgICAgaW5kZW50U3RhdHVzID0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50ID09PSBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgICBpbmRlbnRTdGF0dXMgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgICBpbmRlbnRTdGF0dXMgPSAtMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGFsbG93QmxvY2tDb2xsZWN0aW9ucykge1xuICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGF0TmV3TGluZSB8fCBhbGxvd0NvbXBhY3Q7XG4gIH1cblxuICBpZiAoaW5kZW50U3RhdHVzID09PSAxIHx8IENPTlRFWFRfQkxPQ0tfT1VUID09PSBub2RlQ29udGV4dCkge1xuICAgIGlmIChDT05URVhUX0ZMT1dfSU4gPT09IG5vZGVDb250ZXh0IHx8IENPTlRFWFRfRkxPV19PVVQgPT09IG5vZGVDb250ZXh0KSB7XG4gICAgICBmbG93SW5kZW50ID0gcGFyZW50SW5kZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBmbG93SW5kZW50ID0gcGFyZW50SW5kZW50ICsgMTtcbiAgICB9XG5cbiAgICBibG9ja0luZGVudCA9IHN0YXRlLnBvc2l0aW9uIC0gc3RhdGUubGluZVN0YXJ0O1xuXG4gICAgaWYgKGluZGVudFN0YXR1cyA9PT0gMSkge1xuICAgICAgaWYgKGFsbG93QmxvY2tDb2xsZWN0aW9ucyAmJlxuICAgICAgICAgIChyZWFkQmxvY2tTZXF1ZW5jZShzdGF0ZSwgYmxvY2tJbmRlbnQpIHx8XG4gICAgICAgICAgIHJlYWRCbG9ja01hcHBpbmcoc3RhdGUsIGJsb2NrSW5kZW50LCBmbG93SW5kZW50KSkgfHxcbiAgICAgICAgICByZWFkRmxvd0NvbGxlY3Rpb24oc3RhdGUsIGZsb3dJbmRlbnQpKSB7XG4gICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKChhbGxvd0Jsb2NrU2NhbGFycyAmJiByZWFkQmxvY2tTY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQpKSB8fFxuICAgICAgICAgICAgcmVhZFNpbmdsZVF1b3RlZFNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkgfHxcbiAgICAgICAgICAgIHJlYWREb3VibGVRdW90ZWRTY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQpKSB7XG4gICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWFkQWxpYXMoc3RhdGUpKSB7XG4gICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoc3RhdGUudGFnICE9PSBudWxsIHx8IHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2FsaWFzIG5vZGUgc2hvdWxkIG5vdCBoYXZlIGFueSBwcm9wZXJ0aWVzJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAocmVhZFBsYWluU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50LCBDT05URVhUX0ZMT1dfSU4gPT09IG5vZGVDb250ZXh0KSkge1xuICAgICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLnRhZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdGUudGFnID0gJz8nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgICAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW5kZW50U3RhdHVzID09PSAwKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2U6IGJsb2NrIHNlcXVlbmNlcyBhcmUgYWxsb3dlZCB0byBoYXZlIHNhbWUgaW5kZW50YXRpb24gbGV2ZWwgYXMgdGhlIHBhcmVudC5cbiAgICAgIC8vIGh0dHA6Ly93d3cueWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2lkMjc5OTc4NFxuICAgICAgaGFzQ29udGVudCA9IGFsbG93QmxvY2tDb2xsZWN0aW9ucyAmJiByZWFkQmxvY2tTZXF1ZW5jZShzdGF0ZSwgYmxvY2tJbmRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS50YWcgPT09IG51bGwpIHtcbiAgICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IHN0YXRlLnJlc3VsdDtcbiAgICB9XG5cbiAgfSBlbHNlIGlmIChzdGF0ZS50YWcgPT09ICc/Jykge1xuICAgIC8vIEltcGxpY2l0IHJlc29sdmluZyBpcyBub3QgYWxsb3dlZCBmb3Igbm9uLXNjYWxhciB0eXBlcywgYW5kICc/J1xuICAgIC8vIG5vbi1zcGVjaWZpYyB0YWcgaXMgb25seSBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIHRvIHBsYWluIHNjYWxhcnMuXG4gICAgLy9cbiAgICAvLyBXZSBvbmx5IG5lZWQgdG8gY2hlY2sga2luZCBjb25mb3JtaXR5IGluIGNhc2UgdXNlciBleHBsaWNpdGx5IGFzc2lnbnMgJz8nXG4gICAgLy8gdGFnLCBmb3IgZXhhbXBsZSBsaWtlIHRoaXM6IFwiITw/PiBbMF1cIlxuICAgIC8vXG4gICAgaWYgKHN0YXRlLnJlc3VsdCAhPT0gbnVsbCAmJiBzdGF0ZS5raW5kICE9PSAnc2NhbGFyJykge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuYWNjZXB0YWJsZSBub2RlIGtpbmQgZm9yICE8Pz4gdGFnOyBpdCBzaG91bGQgYmUgXCJzY2FsYXJcIiwgbm90IFwiJyArIHN0YXRlLmtpbmQgKyAnXCInKTtcbiAgICB9XG5cbiAgICBmb3IgKHR5cGVJbmRleCA9IDAsIHR5cGVRdWFudGl0eSA9IHN0YXRlLmltcGxpY2l0VHlwZXMubGVuZ3RoOyB0eXBlSW5kZXggPCB0eXBlUXVhbnRpdHk7IHR5cGVJbmRleCArPSAxKSB7XG4gICAgICB0eXBlID0gc3RhdGUuaW1wbGljaXRUeXBlc1t0eXBlSW5kZXhdO1xuXG4gICAgICBpZiAodHlwZS5yZXNvbHZlKHN0YXRlLnJlc3VsdCkpIHsgLy8gYHN0YXRlLnJlc3VsdGAgdXBkYXRlZCBpbiByZXNvbHZlciBpZiBtYXRjaGVkXG4gICAgICAgIHN0YXRlLnJlc3VsdCA9IHR5cGUuY29uc3RydWN0KHN0YXRlLnJlc3VsdCk7XG4gICAgICAgIHN0YXRlLnRhZyA9IHR5cGUudGFnO1xuICAgICAgICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHN0YXRlLnRhZyAhPT0gJyEnKSB7XG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLnR5cGVNYXBbc3RhdGUua2luZCB8fCAnZmFsbGJhY2snXSwgc3RhdGUudGFnKSkge1xuICAgICAgdHlwZSA9IHN0YXRlLnR5cGVNYXBbc3RhdGUua2luZCB8fCAnZmFsbGJhY2snXVtzdGF0ZS50YWddO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsb29raW5nIGZvciBtdWx0aSB0eXBlXG4gICAgICB0eXBlID0gbnVsbDtcbiAgICAgIHR5cGVMaXN0ID0gc3RhdGUudHlwZU1hcC5tdWx0aVtzdGF0ZS5raW5kIHx8ICdmYWxsYmFjayddO1xuXG4gICAgICBmb3IgKHR5cGVJbmRleCA9IDAsIHR5cGVRdWFudGl0eSA9IHR5cGVMaXN0Lmxlbmd0aDsgdHlwZUluZGV4IDwgdHlwZVF1YW50aXR5OyB0eXBlSW5kZXggKz0gMSkge1xuICAgICAgICBpZiAoc3RhdGUudGFnLnNsaWNlKDAsIHR5cGVMaXN0W3R5cGVJbmRleF0udGFnLmxlbmd0aCkgPT09IHR5cGVMaXN0W3R5cGVJbmRleF0udGFnKSB7XG4gICAgICAgICAgdHlwZSA9IHR5cGVMaXN0W3R5cGVJbmRleF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmtub3duIHRhZyAhPCcgKyBzdGF0ZS50YWcgKyAnPicpO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5yZXN1bHQgIT09IG51bGwgJiYgdHlwZS5raW5kICE9PSBzdGF0ZS5raW5kKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5hY2NlcHRhYmxlIG5vZGUga2luZCBmb3IgITwnICsgc3RhdGUudGFnICsgJz4gdGFnOyBpdCBzaG91bGQgYmUgXCInICsgdHlwZS5raW5kICsgJ1wiLCBub3QgXCInICsgc3RhdGUua2luZCArICdcIicpO1xuICAgIH1cblxuICAgIGlmICghdHlwZS5yZXNvbHZlKHN0YXRlLnJlc3VsdCwgc3RhdGUudGFnKSkgeyAvLyBgc3RhdGUucmVzdWx0YCB1cGRhdGVkIGluIHJlc29sdmVyIGlmIG1hdGNoZWRcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW5ub3QgcmVzb2x2ZSBhIG5vZGUgd2l0aCAhPCcgKyBzdGF0ZS50YWcgKyAnPiBleHBsaWNpdCB0YWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucmVzdWx0ID0gdHlwZS5jb25zdHJ1Y3Qoc3RhdGUucmVzdWx0LCBzdGF0ZS50YWcpO1xuICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUubGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5saXN0ZW5lcignY2xvc2UnLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLnRhZyAhPT0gbnVsbCB8fCAgc3RhdGUuYW5jaG9yICE9PSBudWxsIHx8IGhhc0NvbnRlbnQ7XG59XG5cbmZ1bmN0aW9uIHJlYWREb2N1bWVudChzdGF0ZSkge1xuICB2YXIgZG9jdW1lbnRTdGFydCA9IHN0YXRlLnBvc2l0aW9uLFxuICAgICAgX3Bvc2l0aW9uLFxuICAgICAgZGlyZWN0aXZlTmFtZSxcbiAgICAgIGRpcmVjdGl2ZUFyZ3MsXG4gICAgICBoYXNEaXJlY3RpdmVzID0gZmFsc2UsXG4gICAgICBjaDtcblxuICBzdGF0ZS52ZXJzaW9uID0gbnVsbDtcbiAgc3RhdGUuY2hlY2tMaW5lQnJlYWtzID0gc3RhdGUubGVnYWN5O1xuICBzdGF0ZS50YWdNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBzdGF0ZS5hbmNob3JNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHdoaWxlICgoY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkgIT09IDApIHtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiAwIHx8IGNoICE9PSAweDI1LyogJSAqLykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgZGlyZWN0aXZlTmFtZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICAgIGRpcmVjdGl2ZUFyZ3MgPSBbXTtcblxuICAgIGlmIChkaXJlY3RpdmVOYW1lLmxlbmd0aCA8IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkaXJlY3RpdmUgbmFtZSBtdXN0IG5vdCBiZSBsZXNzIHRoYW4gb25lIGNoYXJhY3RlciBpbiBsZW5ndGgnKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ggPT09IDB4MjMvKiAjICovKSB7XG4gICAgICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfRU9MKGNoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNfRU9MKGNoKSkgYnJlYWs7XG5cbiAgICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBkaXJlY3RpdmVBcmdzLnB1c2goc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbikpO1xuICAgIH1cblxuICAgIGlmIChjaCAhPT0gMCkgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG5cbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwoZGlyZWN0aXZlSGFuZGxlcnMsIGRpcmVjdGl2ZU5hbWUpKSB7XG4gICAgICBkaXJlY3RpdmVIYW5kbGVyc1tkaXJlY3RpdmVOYW1lXShzdGF0ZSwgZGlyZWN0aXZlTmFtZSwgZGlyZWN0aXZlQXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ3Vua25vd24gZG9jdW1lbnQgZGlyZWN0aXZlIFwiJyArIGRpcmVjdGl2ZU5hbWUgKyAnXCInKTtcbiAgICB9XG4gIH1cblxuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IDAgJiZcbiAgICAgIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pICAgICA9PT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKSA9PT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAyKSA9PT0gMHgyRC8qIC0gKi8pIHtcbiAgICBzdGF0ZS5wb3NpdGlvbiArPSAzO1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICB9IGVsc2UgaWYgKGhhc0RpcmVjdGl2ZXMpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZGlyZWN0aXZlcyBlbmQgbWFyayBpcyBleHBlY3RlZCcpO1xuICB9XG5cbiAgY29tcG9zZU5vZGUoc3RhdGUsIHN0YXRlLmxpbmVJbmRlbnQgLSAxLCBDT05URVhUX0JMT0NLX09VVCwgZmFsc2UsIHRydWUpO1xuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgaWYgKHN0YXRlLmNoZWNrTGluZUJyZWFrcyAmJlxuICAgICAgUEFUVEVSTl9OT05fQVNDSUlfTElORV9CUkVBS1MudGVzdChzdGF0ZS5pbnB1dC5zbGljZShkb2N1bWVudFN0YXJ0LCBzdGF0ZS5wb3NpdGlvbikpKSB7XG4gICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAnbm9uLUFTQ0lJIGxpbmUgYnJlYWtzIGFyZSBpbnRlcnByZXRlZCBhcyBjb250ZW50Jyk7XG4gIH1cblxuICBzdGF0ZS5kb2N1bWVudHMucHVzaChzdGF0ZS5yZXN1bHQpO1xuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcblxuICAgIGlmIChzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSA9PT0gMHgyRS8qIC4gKi8pIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uICs9IDM7XG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA8IChzdGF0ZS5sZW5ndGggLSAxKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdlbmQgb2YgdGhlIHN0cmVhbSBvciBhIGRvY3VtZW50IHNlcGFyYXRvciBpcyBleHBlY3RlZCcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGxvYWREb2N1bWVudHMoaW5wdXQsIG9wdGlvbnMpIHtcbiAgaW5wdXQgPSBTdHJpbmcoaW5wdXQpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5wdXQubGVuZ3RoICE9PSAwKSB7XG5cbiAgICAvLyBBZGQgdGFpbGluZyBgXFxuYCBpZiBub3QgZXhpc3RzXG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoaW5wdXQubGVuZ3RoIC0gMSkgIT09IDB4MEEvKiBMRiAqLyAmJlxuICAgICAgICBpbnB1dC5jaGFyQ29kZUF0KGlucHV0Lmxlbmd0aCAtIDEpICE9PSAweDBELyogQ1IgKi8pIHtcbiAgICAgIGlucHV0ICs9ICdcXG4nO1xuICAgIH1cblxuICAgIC8vIFN0cmlwIEJPTVxuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0YXRlID0gbmV3IFN0YXRlKGlucHV0LCBvcHRpb25zKTtcblxuICB2YXIgbnVsbHBvcyA9IGlucHV0LmluZGV4T2YoJ1xcMCcpO1xuXG4gIGlmIChudWxscG9zICE9PSAtMSkge1xuICAgIHN0YXRlLnBvc2l0aW9uID0gbnVsbHBvcztcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbnVsbCBieXRlIGlzIG5vdCBhbGxvd2VkIGluIGlucHV0Jyk7XG4gIH1cblxuICAvLyBVc2UgMCBhcyBzdHJpbmcgdGVybWluYXRvci4gVGhhdCBzaWduaWZpY2FudGx5IHNpbXBsaWZpZXMgYm91bmRzIGNoZWNrLlxuICBzdGF0ZS5pbnB1dCArPSAnXFwwJztcblxuICB3aGlsZSAoc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgPT09IDB4MjAvKiBTcGFjZSAqLykge1xuICAgIHN0YXRlLmxpbmVJbmRlbnQgKz0gMTtcbiAgICBzdGF0ZS5wb3NpdGlvbiArPSAxO1xuICB9XG5cbiAgd2hpbGUgKHN0YXRlLnBvc2l0aW9uIDwgKHN0YXRlLmxlbmd0aCAtIDEpKSB7XG4gICAgcmVhZERvY3VtZW50KHN0YXRlKTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5kb2N1bWVudHM7XG59XG5cblxuZnVuY3Rpb24gbG9hZEFsbChpbnB1dCwgaXRlcmF0b3IsIG9wdGlvbnMpIHtcbiAgaWYgKGl0ZXJhdG9yICE9PSBudWxsICYmIHR5cGVvZiBpdGVyYXRvciA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3B0aW9ucyA9IGl0ZXJhdG9yO1xuICAgIGl0ZXJhdG9yID0gbnVsbDtcbiAgfVxuXG4gIHZhciBkb2N1bWVudHMgPSBsb2FkRG9jdW1lbnRzKGlucHV0LCBvcHRpb25zKTtcblxuICBpZiAodHlwZW9mIGl0ZXJhdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50cztcbiAgfVxuXG4gIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZG9jdW1lbnRzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBpdGVyYXRvcihkb2N1bWVudHNbaW5kZXhdKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGxvYWQoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGRvY3VtZW50cyA9IGxvYWREb2N1bWVudHMoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIGlmIChkb2N1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQqL1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBkb2N1bWVudHNbMF07XG4gIH1cbiAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ2V4cGVjdGVkIGEgc2luZ2xlIGRvY3VtZW50IGluIHRoZSBzdHJlYW0sIGJ1dCBmb3VuZCBtb3JlJyk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMubG9hZEFsbCA9IGxvYWRBbGw7XG5tb2R1bGUuZXhwb3J0cy5sb2FkICAgID0gbG9hZDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQtZGlzYWJsZSBuby11c2UtYmVmb3JlLWRlZmluZSovXG5cbnZhciBjb21tb24gICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbnZhciBZQU1MRXhjZXB0aW9uICAgICAgID0gcmVxdWlyZSgnLi9leGNlcHRpb24nKTtcbnZhciBERUZBVUxUX1NDSEVNQSAgICAgID0gcmVxdWlyZSgnLi9zY2hlbWEvZGVmYXVsdCcpO1xuXG52YXIgX3RvU3RyaW5nICAgICAgID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgQ0hBUl9CT00gICAgICAgICAgICAgICAgICA9IDB4RkVGRjtcbnZhciBDSEFSX1RBQiAgICAgICAgICAgICAgICAgID0gMHgwOTsgLyogVGFiICovXG52YXIgQ0hBUl9MSU5FX0ZFRUQgICAgICAgICAgICA9IDB4MEE7IC8qIExGICovXG52YXIgQ0hBUl9DQVJSSUFHRV9SRVRVUk4gICAgICA9IDB4MEQ7IC8qIENSICovXG52YXIgQ0hBUl9TUEFDRSAgICAgICAgICAgICAgICA9IDB4MjA7IC8qIFNwYWNlICovXG52YXIgQ0hBUl9FWENMQU1BVElPTiAgICAgICAgICA9IDB4MjE7IC8qICEgKi9cbnZhciBDSEFSX0RPVUJMRV9RVU9URSAgICAgICAgID0gMHgyMjsgLyogXCIgKi9cbnZhciBDSEFSX1NIQVJQICAgICAgICAgICAgICAgID0gMHgyMzsgLyogIyAqL1xudmFyIENIQVJfUEVSQ0VOVCAgICAgICAgICAgICAgPSAweDI1OyAvKiAlICovXG52YXIgQ0hBUl9BTVBFUlNBTkQgICAgICAgICAgICA9IDB4MjY7IC8qICYgKi9cbnZhciBDSEFSX1NJTkdMRV9RVU9URSAgICAgICAgID0gMHgyNzsgLyogJyAqL1xudmFyIENIQVJfQVNURVJJU0sgICAgICAgICAgICAgPSAweDJBOyAvKiAqICovXG52YXIgQ0hBUl9DT01NQSAgICAgICAgICAgICAgICA9IDB4MkM7IC8qICwgKi9cbnZhciBDSEFSX01JTlVTICAgICAgICAgICAgICAgID0gMHgyRDsgLyogLSAqL1xudmFyIENIQVJfQ09MT04gICAgICAgICAgICAgICAgPSAweDNBOyAvKiA6ICovXG52YXIgQ0hBUl9FUVVBTFMgICAgICAgICAgICAgICA9IDB4M0Q7IC8qID0gKi9cbnZhciBDSEFSX0dSRUFURVJfVEhBTiAgICAgICAgID0gMHgzRTsgLyogPiAqL1xudmFyIENIQVJfUVVFU1RJT04gICAgICAgICAgICAgPSAweDNGOyAvKiA/ICovXG52YXIgQ0hBUl9DT01NRVJDSUFMX0FUICAgICAgICA9IDB4NDA7IC8qIEAgKi9cbnZhciBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQgID0gMHg1QjsgLyogWyAqL1xudmFyIENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQgPSAweDVEOyAvKiBdICovXG52YXIgQ0hBUl9HUkFWRV9BQ0NFTlQgICAgICAgICA9IDB4NjA7IC8qIGAgKi9cbnZhciBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVCAgID0gMHg3QjsgLyogeyAqL1xudmFyIENIQVJfVkVSVElDQUxfTElORSAgICAgICAgPSAweDdDOyAvKiB8ICovXG52YXIgQ0hBUl9SSUdIVF9DVVJMWV9CUkFDS0VUICA9IDB4N0Q7IC8qIH0gKi9cblxudmFyIEVTQ0FQRV9TRVFVRU5DRVMgPSB7fTtcblxuRVNDQVBFX1NFUVVFTkNFU1sweDAwXSAgID0gJ1xcXFwwJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwN10gICA9ICdcXFxcYSc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDhdICAgPSAnXFxcXGInO1xuRVNDQVBFX1NFUVVFTkNFU1sweDA5XSAgID0gJ1xcXFx0JztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwQV0gICA9ICdcXFxcbic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MEJdICAgPSAnXFxcXHYnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBDXSAgID0gJ1xcXFxmJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwRF0gICA9ICdcXFxccic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MUJdICAgPSAnXFxcXGUnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDIyXSAgID0gJ1xcXFxcIic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4NUNdICAgPSAnXFxcXFxcXFwnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDg1XSAgID0gJ1xcXFxOJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHhBMF0gICA9ICdcXFxcXyc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MjAyOF0gPSAnXFxcXEwnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDIwMjldID0gJ1xcXFxQJztcblxudmFyIERFUFJFQ0FURURfQk9PTEVBTlNfU1lOVEFYID0gW1xuICAneScsICdZJywgJ3llcycsICdZZXMnLCAnWUVTJywgJ29uJywgJ09uJywgJ09OJyxcbiAgJ24nLCAnTicsICdubycsICdObycsICdOTycsICdvZmYnLCAnT2ZmJywgJ09GRidcbl07XG5cbnZhciBERVBSRUNBVEVEX0JBU0U2MF9TWU5UQVggPSAvXlstK10/WzAtOV9dKyg/OjpbMC05X10rKSsoPzpcXC5bMC05X10qKT8kLztcblxuZnVuY3Rpb24gY29tcGlsZVN0eWxlTWFwKHNjaGVtYSwgbWFwKSB7XG4gIHZhciByZXN1bHQsIGtleXMsIGluZGV4LCBsZW5ndGgsIHRhZywgc3R5bGUsIHR5cGU7XG5cbiAgaWYgKG1hcCA9PT0gbnVsbCkgcmV0dXJuIHt9O1xuXG4gIHJlc3VsdCA9IHt9O1xuICBrZXlzID0gT2JqZWN0LmtleXMobWFwKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdGFnID0ga2V5c1tpbmRleF07XG4gICAgc3R5bGUgPSBTdHJpbmcobWFwW3RhZ10pO1xuXG4gICAgaWYgKHRhZy5zbGljZSgwLCAyKSA9PT0gJyEhJykge1xuICAgICAgdGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOicgKyB0YWcuc2xpY2UoMik7XG4gICAgfVxuICAgIHR5cGUgPSBzY2hlbWEuY29tcGlsZWRUeXBlTWFwWydmYWxsYmFjayddW3RhZ107XG5cbiAgICBpZiAodHlwZSAmJiBfaGFzT3duUHJvcGVydHkuY2FsbCh0eXBlLnN0eWxlQWxpYXNlcywgc3R5bGUpKSB7XG4gICAgICBzdHlsZSA9IHR5cGUuc3R5bGVBbGlhc2VzW3N0eWxlXTtcbiAgICB9XG5cbiAgICByZXN1bHRbdGFnXSA9IHN0eWxlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZW5jb2RlSGV4KGNoYXJhY3Rlcikge1xuICB2YXIgc3RyaW5nLCBoYW5kbGUsIGxlbmd0aDtcblxuICBzdHJpbmcgPSBjaGFyYWN0ZXIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cbiAgaWYgKGNoYXJhY3RlciA8PSAweEZGKSB7XG4gICAgaGFuZGxlID0gJ3gnO1xuICAgIGxlbmd0aCA9IDI7XG4gIH0gZWxzZSBpZiAoY2hhcmFjdGVyIDw9IDB4RkZGRikge1xuICAgIGhhbmRsZSA9ICd1JztcbiAgICBsZW5ndGggPSA0O1xuICB9IGVsc2UgaWYgKGNoYXJhY3RlciA8PSAweEZGRkZGRkZGKSB7XG4gICAgaGFuZGxlID0gJ1UnO1xuICAgIGxlbmd0aCA9IDg7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ2NvZGUgcG9pbnQgd2l0aGluIGEgc3RyaW5nIG1heSBub3QgYmUgZ3JlYXRlciB0aGFuIDB4RkZGRkZGRkYnKTtcbiAgfVxuXG4gIHJldHVybiAnXFxcXCcgKyBoYW5kbGUgKyBjb21tb24ucmVwZWF0KCcwJywgbGVuZ3RoIC0gc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XG59XG5cblxudmFyIFFVT1RJTkdfVFlQRV9TSU5HTEUgPSAxLFxuICAgIFFVT1RJTkdfVFlQRV9ET1VCTEUgPSAyO1xuXG5mdW5jdGlvbiBTdGF0ZShvcHRpb25zKSB7XG4gIHRoaXMuc2NoZW1hICAgICAgICA9IG9wdGlvbnNbJ3NjaGVtYSddIHx8IERFRkFVTFRfU0NIRU1BO1xuICB0aGlzLmluZGVudCAgICAgICAgPSBNYXRoLm1heCgxLCAob3B0aW9uc1snaW5kZW50J10gfHwgMikpO1xuICB0aGlzLm5vQXJyYXlJbmRlbnQgPSBvcHRpb25zWydub0FycmF5SW5kZW50J10gfHwgZmFsc2U7XG4gIHRoaXMuc2tpcEludmFsaWQgICA9IG9wdGlvbnNbJ3NraXBJbnZhbGlkJ10gfHwgZmFsc2U7XG4gIHRoaXMuZmxvd0xldmVsICAgICA9IChjb21tb24uaXNOb3RoaW5nKG9wdGlvbnNbJ2Zsb3dMZXZlbCddKSA/IC0xIDogb3B0aW9uc1snZmxvd0xldmVsJ10pO1xuICB0aGlzLnN0eWxlTWFwICAgICAgPSBjb21waWxlU3R5bGVNYXAodGhpcy5zY2hlbWEsIG9wdGlvbnNbJ3N0eWxlcyddIHx8IG51bGwpO1xuICB0aGlzLnNvcnRLZXlzICAgICAgPSBvcHRpb25zWydzb3J0S2V5cyddIHx8IGZhbHNlO1xuICB0aGlzLmxpbmVXaWR0aCAgICAgPSBvcHRpb25zWydsaW5lV2lkdGgnXSB8fCA4MDtcbiAgdGhpcy5ub1JlZnMgICAgICAgID0gb3B0aW9uc1snbm9SZWZzJ10gfHwgZmFsc2U7XG4gIHRoaXMubm9Db21wYXRNb2RlICA9IG9wdGlvbnNbJ25vQ29tcGF0TW9kZSddIHx8IGZhbHNlO1xuICB0aGlzLmNvbmRlbnNlRmxvdyAgPSBvcHRpb25zWydjb25kZW5zZUZsb3cnXSB8fCBmYWxzZTtcbiAgdGhpcy5xdW90aW5nVHlwZSAgID0gb3B0aW9uc1sncXVvdGluZ1R5cGUnXSA9PT0gJ1wiJyA/IFFVT1RJTkdfVFlQRV9ET1VCTEUgOiBRVU9USU5HX1RZUEVfU0lOR0xFO1xuICB0aGlzLmZvcmNlUXVvdGVzICAgPSBvcHRpb25zWydmb3JjZVF1b3RlcyddIHx8IGZhbHNlO1xuICB0aGlzLnJlcGxhY2VyICAgICAgPSB0eXBlb2Ygb3B0aW9uc1sncmVwbGFjZXInXSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnNbJ3JlcGxhY2VyJ10gOiBudWxsO1xuXG4gIHRoaXMuaW1wbGljaXRUeXBlcyA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkSW1wbGljaXQ7XG4gIHRoaXMuZXhwbGljaXRUeXBlcyA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkRXhwbGljaXQ7XG5cbiAgdGhpcy50YWcgPSBudWxsO1xuICB0aGlzLnJlc3VsdCA9ICcnO1xuXG4gIHRoaXMuZHVwbGljYXRlcyA9IFtdO1xuICB0aGlzLnVzZWREdXBsaWNhdGVzID0gbnVsbDtcbn1cblxuLy8gSW5kZW50cyBldmVyeSBsaW5lIGluIGEgc3RyaW5nLiBFbXB0eSBsaW5lcyAoXFxuIG9ubHkpIGFyZSBub3QgaW5kZW50ZWQuXG5mdW5jdGlvbiBpbmRlbnRTdHJpbmcoc3RyaW5nLCBzcGFjZXMpIHtcbiAgdmFyIGluZCA9IGNvbW1vbi5yZXBlYXQoJyAnLCBzcGFjZXMpLFxuICAgICAgcG9zaXRpb24gPSAwLFxuICAgICAgbmV4dCA9IC0xLFxuICAgICAgcmVzdWx0ID0gJycsXG4gICAgICBsaW5lLFxuICAgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblxuICB3aGlsZSAocG9zaXRpb24gPCBsZW5ndGgpIHtcbiAgICBuZXh0ID0gc3RyaW5nLmluZGV4T2YoJ1xcbicsIHBvc2l0aW9uKTtcbiAgICBpZiAobmV4dCA9PT0gLTEpIHtcbiAgICAgIGxpbmUgPSBzdHJpbmcuc2xpY2UocG9zaXRpb24pO1xuICAgICAgcG9zaXRpb24gPSBsZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmUgPSBzdHJpbmcuc2xpY2UocG9zaXRpb24sIG5leHQgKyAxKTtcbiAgICAgIHBvc2l0aW9uID0gbmV4dCArIDE7XG4gICAgfVxuXG4gICAgaWYgKGxpbmUubGVuZ3RoICYmIGxpbmUgIT09ICdcXG4nKSByZXN1bHQgKz0gaW5kO1xuXG4gICAgcmVzdWx0ICs9IGxpbmU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCkge1xuICByZXR1cm4gJ1xcbicgKyBjb21tb24ucmVwZWF0KCcgJywgc3RhdGUuaW5kZW50ICogbGV2ZWwpO1xufVxuXG5mdW5jdGlvbiB0ZXN0SW1wbGljaXRSZXNvbHZpbmcoc3RhdGUsIHN0cikge1xuICB2YXIgaW5kZXgsIGxlbmd0aCwgdHlwZTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gc3RhdGUuaW1wbGljaXRUeXBlcy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdHlwZSA9IHN0YXRlLmltcGxpY2l0VHlwZXNbaW5kZXhdO1xuXG4gICAgaWYgKHR5cGUucmVzb2x2ZShzdHIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIFszM10gcy13aGl0ZSA6Oj0gcy1zcGFjZSB8IHMtdGFiXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UoYykge1xuICByZXR1cm4gYyA9PT0gQ0hBUl9TUEFDRSB8fCBjID09PSBDSEFSX1RBQjtcbn1cblxuLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBjaGFyYWN0ZXIgY2FuIGJlIHByaW50ZWQgd2l0aG91dCBlc2NhcGluZy5cbi8vIEZyb20gWUFNTCAxLjI6IFwiYW55IGFsbG93ZWQgY2hhcmFjdGVycyBrbm93biB0byBiZSBub24tcHJpbnRhYmxlXG4vLyBzaG91bGQgYWxzbyBiZSBlc2NhcGVkLiBbSG93ZXZlcixdIFRoaXMgaXNu4oCZdCBtYW5kYXRvcnlcIlxuLy8gRGVyaXZlZCBmcm9tIG5iLWNoYXIgLSBcXHQgLSAjeDg1IC0gI3hBMCAtICN4MjAyOCAtICN4MjAyOS5cbmZ1bmN0aW9uIGlzUHJpbnRhYmxlKGMpIHtcbiAgcmV0dXJuICAoMHgwMDAyMCA8PSBjICYmIGMgPD0gMHgwMDAwN0UpXG4gICAgICB8fCAoKDB4MDAwQTEgPD0gYyAmJiBjIDw9IDB4MDBEN0ZGKSAmJiBjICE9PSAweDIwMjggJiYgYyAhPT0gMHgyMDI5KVxuICAgICAgfHwgKCgweDBFMDAwIDw9IGMgJiYgYyA8PSAweDAwRkZGRCkgJiYgYyAhPT0gQ0hBUl9CT00pXG4gICAgICB8fCAgKDB4MTAwMDAgPD0gYyAmJiBjIDw9IDB4MTBGRkZGKTtcbn1cblxuLy8gWzM0XSBucy1jaGFyIDo6PSBuYi1jaGFyIC0gcy13aGl0ZVxuLy8gWzI3XSBuYi1jaGFyIDo6PSBjLXByaW50YWJsZSAtIGItY2hhciAtIGMtYnl0ZS1vcmRlci1tYXJrXG4vLyBbMjZdIGItY2hhciAgOjo9IGItbGluZS1mZWVkIHwgYi1jYXJyaWFnZS1yZXR1cm5cbi8vIEluY2x1ZGluZyBzLXdoaXRlIChmb3Igc29tZSByZWFzb24sIGV4YW1wbGVzIGRvZXNuJ3QgbWF0Y2ggc3BlY3MgaW4gdGhpcyBhc3BlY3QpXG4vLyBucy1jaGFyIDo6PSBjLXByaW50YWJsZSAtIGItbGluZS1mZWVkIC0gYi1jYXJyaWFnZS1yZXR1cm4gLSBjLWJ5dGUtb3JkZXItbWFya1xuZnVuY3Rpb24gaXNOc0NoYXJPcldoaXRlc3BhY2UoYykge1xuICByZXR1cm4gaXNQcmludGFibGUoYylcbiAgICAmJiBjICE9PSBDSEFSX0JPTVxuICAgIC8vIC0gYi1jaGFyXG4gICAgJiYgYyAhPT0gQ0hBUl9DQVJSSUFHRV9SRVRVUk5cbiAgICAmJiBjICE9PSBDSEFSX0xJTkVfRkVFRDtcbn1cblxuLy8gWzEyN10gIG5zLXBsYWluLXNhZmUoYykgOjo9IGMgPSBmbG93LW91dCAg4oeSIG5zLXBsYWluLXNhZmUtb3V0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGZsb3ctaW4gICDih5IgbnMtcGxhaW4tc2FmZS1pblxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBibG9jay1rZXkg4oeSIG5zLXBsYWluLXNhZmUtb3V0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGZsb3cta2V5ICDih5IgbnMtcGxhaW4tc2FmZS1pblxuLy8gWzEyOF0gbnMtcGxhaW4tc2FmZS1vdXQgOjo9IG5zLWNoYXJcbi8vIFsxMjldICBucy1wbGFpbi1zYWZlLWluIDo6PSBucy1jaGFyIC0gYy1mbG93LWluZGljYXRvclxuLy8gWzEzMF0gIG5zLXBsYWluLWNoYXIoYykgOjo9ICAoIG5zLXBsYWluLXNhZmUoYykgLSDigJw64oCdIC0g4oCcI+KAnSApXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICggLyogQW4gbnMtY2hhciBwcmVjZWRpbmcgKi8g4oCcI+KAnSApXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICgg4oCcOuKAnSAvKiBGb2xsb3dlZCBieSBhbiBucy1wbGFpbi1zYWZlKGMpICovIClcbmZ1bmN0aW9uIGlzUGxhaW5TYWZlKGMsIHByZXYsIGluYmxvY2spIHtcbiAgdmFyIGNJc05zQ2hhck9yV2hpdGVzcGFjZSA9IGlzTnNDaGFyT3JXaGl0ZXNwYWNlKGMpO1xuICB2YXIgY0lzTnNDaGFyID0gY0lzTnNDaGFyT3JXaGl0ZXNwYWNlICYmICFpc1doaXRlc3BhY2UoYyk7XG4gIHJldHVybiAoXG4gICAgLy8gbnMtcGxhaW4tc2FmZVxuICAgIGluYmxvY2sgPyAvLyBjID0gZmxvdy1pblxuICAgICAgY0lzTnNDaGFyT3JXaGl0ZXNwYWNlXG4gICAgICA6IGNJc05zQ2hhck9yV2hpdGVzcGFjZVxuICAgICAgICAvLyAtIGMtZmxvdy1pbmRpY2F0b3JcbiAgICAgICAgJiYgYyAhPT0gQ0hBUl9DT01NQVxuICAgICAgICAmJiBjICE9PSBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVRcbiAgICAgICAgJiYgYyAhPT0gQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVFxuICAgICAgICAmJiBjICE9PSBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVFxuICAgICAgICAmJiBjICE9PSBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVRcbiAgKVxuICAgIC8vIG5zLXBsYWluLWNoYXJcbiAgICAmJiBjICE9PSBDSEFSX1NIQVJQIC8vIGZhbHNlIG9uICcjJ1xuICAgICYmICEocHJldiA9PT0gQ0hBUl9DT0xPTiAmJiAhY0lzTnNDaGFyKSAvLyBmYWxzZSBvbiAnOiAnXG4gICAgfHwgKGlzTnNDaGFyT3JXaGl0ZXNwYWNlKHByZXYpICYmICFpc1doaXRlc3BhY2UocHJldikgJiYgYyA9PT0gQ0hBUl9TSEFSUCkgLy8gY2hhbmdlIHRvIHRydWUgb24gJ1teIF0jJ1xuICAgIHx8IChwcmV2ID09PSBDSEFSX0NPTE9OICYmIGNJc05zQ2hhcik7IC8vIGNoYW5nZSB0byB0cnVlIG9uICc6W14gXSdcbn1cblxuLy8gU2ltcGxpZmllZCB0ZXN0IGZvciB2YWx1ZXMgYWxsb3dlZCBhcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHBsYWluIHN0eWxlLlxuZnVuY3Rpb24gaXNQbGFpblNhZmVGaXJzdChjKSB7XG4gIC8vIFVzZXMgYSBzdWJzZXQgb2YgbnMtY2hhciAtIGMtaW5kaWNhdG9yXG4gIC8vIHdoZXJlIG5zLWNoYXIgPSBuYi1jaGFyIC0gcy13aGl0ZS5cbiAgLy8gTm8gc3VwcG9ydCBvZiAoICgg4oCcP+KAnSB8IOKAnDrigJ0gfCDigJwt4oCdICkgLyogRm9sbG93ZWQgYnkgYW4gbnMtcGxhaW4tc2FmZShjKSkgKi8gKSBwYXJ0XG4gIHJldHVybiBpc1ByaW50YWJsZShjKSAmJiBjICE9PSBDSEFSX0JPTVxuICAgICYmICFpc1doaXRlc3BhY2UoYykgLy8gLSBzLXdoaXRlXG4gICAgLy8gLSAoYy1pbmRpY2F0b3IgOjo9XG4gICAgLy8g4oCcLeKAnSB8IOKAnD/igJ0gfCDigJw64oCdIHwg4oCcLOKAnSB8IOKAnFvigJ0gfCDigJxd4oCdIHwg4oCce+KAnSB8IOKAnH3igJ1cbiAgICAmJiBjICE9PSBDSEFSX01JTlVTXG4gICAgJiYgYyAhPT0gQ0hBUl9RVUVTVElPTlxuICAgICYmIGMgIT09IENIQVJfQ09MT05cbiAgICAmJiBjICE9PSBDSEFSX0NPTU1BXG4gICAgJiYgYyAhPT0gQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUXG4gICAgJiYgYyAhPT0gQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUXG4gICAgJiYgYyAhPT0gQ0hBUl9SSUdIVF9DVVJMWV9CUkFDS0VUXG4gICAgLy8gfCDigJwj4oCdIHwg4oCcJuKAnSB8IOKAnCrigJ0gfCDigJwh4oCdIHwg4oCcfOKAnSB8IOKAnD3igJ0gfCDigJw+4oCdIHwg4oCcJ+KAnSB8IOKAnFwi4oCdXG4gICAgJiYgYyAhPT0gQ0hBUl9TSEFSUFxuICAgICYmIGMgIT09IENIQVJfQU1QRVJTQU5EXG4gICAgJiYgYyAhPT0gQ0hBUl9BU1RFUklTS1xuICAgICYmIGMgIT09IENIQVJfRVhDTEFNQVRJT05cbiAgICAmJiBjICE9PSBDSEFSX1ZFUlRJQ0FMX0xJTkVcbiAgICAmJiBjICE9PSBDSEFSX0VRVUFMU1xuICAgICYmIGMgIT09IENIQVJfR1JFQVRFUl9USEFOXG4gICAgJiYgYyAhPT0gQ0hBUl9TSU5HTEVfUVVPVEVcbiAgICAmJiBjICE9PSBDSEFSX0RPVUJMRV9RVU9URVxuICAgIC8vIHwg4oCcJeKAnSB8IOKAnEDigJ0gfCDigJxg4oCdKVxuICAgICYmIGMgIT09IENIQVJfUEVSQ0VOVFxuICAgICYmIGMgIT09IENIQVJfQ09NTUVSQ0lBTF9BVFxuICAgICYmIGMgIT09IENIQVJfR1JBVkVfQUNDRU5UO1xufVxuXG4vLyBTaW1wbGlmaWVkIHRlc3QgZm9yIHZhbHVlcyBhbGxvd2VkIGFzIHRoZSBsYXN0IGNoYXJhY3RlciBpbiBwbGFpbiBzdHlsZS5cbmZ1bmN0aW9uIGlzUGxhaW5TYWZlTGFzdChjKSB7XG4gIC8vIGp1c3Qgbm90IHdoaXRlc3BhY2Ugb3IgY29sb24sIGl0IHdpbGwgYmUgY2hlY2tlZCB0byBiZSBwbGFpbiBjaGFyYWN0ZXIgbGF0ZXJcbiAgcmV0dXJuICFpc1doaXRlc3BhY2UoYykgJiYgYyAhPT0gQ0hBUl9DT0xPTjtcbn1cblxuLy8gU2FtZSBhcyAnc3RyaW5nJy5jb2RlUG9pbnRBdChwb3MpLCBidXQgd29ya3MgaW4gb2xkZXIgYnJvd3NlcnMuXG5mdW5jdGlvbiBjb2RlUG9pbnRBdChzdHJpbmcsIHBvcykge1xuICB2YXIgZmlyc3QgPSBzdHJpbmcuY2hhckNvZGVBdChwb3MpLCBzZWNvbmQ7XG4gIGlmIChmaXJzdCA+PSAweEQ4MDAgJiYgZmlyc3QgPD0gMHhEQkZGICYmIHBvcyArIDEgPCBzdHJpbmcubGVuZ3RoKSB7XG4gICAgc2Vjb25kID0gc3RyaW5nLmNoYXJDb2RlQXQocG9zICsgMSk7XG4gICAgaWYgKHNlY29uZCA+PSAweERDMDAgJiYgc2Vjb25kIDw9IDB4REZGRikge1xuICAgICAgLy8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG4gICAgICByZXR1cm4gKGZpcnN0IC0gMHhEODAwKSAqIDB4NDAwICsgc2Vjb25kIC0gMHhEQzAwICsgMHgxMDAwMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpcnN0O1xufVxuXG4vLyBEZXRlcm1pbmVzIHdoZXRoZXIgYmxvY2sgaW5kZW50YXRpb24gaW5kaWNhdG9yIGlzIHJlcXVpcmVkLlxuZnVuY3Rpb24gbmVlZEluZGVudEluZGljYXRvcihzdHJpbmcpIHtcbiAgdmFyIGxlYWRpbmdTcGFjZVJlID0gL15cXG4qIC87XG4gIHJldHVybiBsZWFkaW5nU3BhY2VSZS50ZXN0KHN0cmluZyk7XG59XG5cbnZhciBTVFlMRV9QTEFJTiAgID0gMSxcbiAgICBTVFlMRV9TSU5HTEUgID0gMixcbiAgICBTVFlMRV9MSVRFUkFMID0gMyxcbiAgICBTVFlMRV9GT0xERUQgID0gNCxcbiAgICBTVFlMRV9ET1VCTEUgID0gNTtcblxuLy8gRGV0ZXJtaW5lcyB3aGljaCBzY2FsYXIgc3R5bGVzIGFyZSBwb3NzaWJsZSBhbmQgcmV0dXJucyB0aGUgcHJlZmVycmVkIHN0eWxlLlxuLy8gbGluZVdpZHRoID0gLTEgPT4gbm8gbGltaXQuXG4vLyBQcmUtY29uZGl0aW9uczogc3RyLmxlbmd0aCA+IDAuXG4vLyBQb3N0LWNvbmRpdGlvbnM6XG4vLyAgICBTVFlMRV9QTEFJTiBvciBTVFlMRV9TSU5HTEUgPT4gbm8gXFxuIGFyZSBpbiB0aGUgc3RyaW5nLlxuLy8gICAgU1RZTEVfTElURVJBTCA9PiBubyBsaW5lcyBhcmUgc3VpdGFibGUgZm9yIGZvbGRpbmcgKG9yIGxpbmVXaWR0aCBpcyAtMSkuXG4vLyAgICBTVFlMRV9GT0xERUQgPT4gYSBsaW5lID4gbGluZVdpZHRoIGFuZCBjYW4gYmUgZm9sZGVkIChhbmQgbGluZVdpZHRoICE9IC0xKS5cbmZ1bmN0aW9uIGNob29zZVNjYWxhclN0eWxlKHN0cmluZywgc2luZ2xlTGluZU9ubHksIGluZGVudFBlckxldmVsLCBsaW5lV2lkdGgsXG4gIHRlc3RBbWJpZ3VvdXNUeXBlLCBxdW90aW5nVHlwZSwgZm9yY2VRdW90ZXMsIGluYmxvY2spIHtcblxuICB2YXIgaTtcbiAgdmFyIGNoYXIgPSAwO1xuICB2YXIgcHJldkNoYXIgPSBudWxsO1xuICB2YXIgaGFzTGluZUJyZWFrID0gZmFsc2U7XG4gIHZhciBoYXNGb2xkYWJsZUxpbmUgPSBmYWxzZTsgLy8gb25seSBjaGVja2VkIGlmIHNob3VsZFRyYWNrV2lkdGhcbiAgdmFyIHNob3VsZFRyYWNrV2lkdGggPSBsaW5lV2lkdGggIT09IC0xO1xuICB2YXIgcHJldmlvdXNMaW5lQnJlYWsgPSAtMTsgLy8gY291bnQgdGhlIGZpcnN0IGxpbmUgY29ycmVjdGx5XG4gIHZhciBwbGFpbiA9IGlzUGxhaW5TYWZlRmlyc3QoY29kZVBvaW50QXQoc3RyaW5nLCAwKSlcbiAgICAgICAgICAmJiBpc1BsYWluU2FmZUxhc3QoY29kZVBvaW50QXQoc3RyaW5nLCBzdHJpbmcubGVuZ3RoIC0gMSkpO1xuXG4gIGlmIChzaW5nbGVMaW5lT25seSB8fCBmb3JjZVF1b3Rlcykge1xuICAgIC8vIENhc2U6IG5vIGJsb2NrIHN0eWxlcy5cbiAgICAvLyBDaGVjayBmb3IgZGlzYWxsb3dlZCBjaGFyYWN0ZXJzIHRvIHJ1bGUgb3V0IHBsYWluIGFuZCBzaW5nbGUuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGNoYXIgPj0gMHgxMDAwMCA/IGkgKz0gMiA6IGkrKykge1xuICAgICAgY2hhciA9IGNvZGVQb2ludEF0KHN0cmluZywgaSk7XG4gICAgICBpZiAoIWlzUHJpbnRhYmxlKGNoYXIpKSB7XG4gICAgICAgIHJldHVybiBTVFlMRV9ET1VCTEU7XG4gICAgICB9XG4gICAgICBwbGFpbiA9IHBsYWluICYmIGlzUGxhaW5TYWZlKGNoYXIsIHByZXZDaGFyLCBpbmJsb2NrKTtcbiAgICAgIHByZXZDaGFyID0gY2hhcjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2FzZTogYmxvY2sgc3R5bGVzIHBlcm1pdHRlZC5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgY2hhciA+PSAweDEwMDAwID8gaSArPSAyIDogaSsrKSB7XG4gICAgICBjaGFyID0gY29kZVBvaW50QXQoc3RyaW5nLCBpKTtcbiAgICAgIGlmIChjaGFyID09PSBDSEFSX0xJTkVfRkVFRCkge1xuICAgICAgICBoYXNMaW5lQnJlYWsgPSB0cnVlO1xuICAgICAgICAvLyBDaGVjayBpZiBhbnkgbGluZSBjYW4gYmUgZm9sZGVkLlxuICAgICAgICBpZiAoc2hvdWxkVHJhY2tXaWR0aCkge1xuICAgICAgICAgIGhhc0ZvbGRhYmxlTGluZSA9IGhhc0ZvbGRhYmxlTGluZSB8fFxuICAgICAgICAgICAgLy8gRm9sZGFibGUgbGluZSA9IHRvbyBsb25nLCBhbmQgbm90IG1vcmUtaW5kZW50ZWQuXG4gICAgICAgICAgICAoaSAtIHByZXZpb3VzTGluZUJyZWFrIC0gMSA+IGxpbmVXaWR0aCAmJlxuICAgICAgICAgICAgIHN0cmluZ1twcmV2aW91c0xpbmVCcmVhayArIDFdICE9PSAnICcpO1xuICAgICAgICAgIHByZXZpb3VzTGluZUJyZWFrID0gaTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaXNQcmludGFibGUoY2hhcikpIHtcbiAgICAgICAgcmV0dXJuIFNUWUxFX0RPVUJMRTtcbiAgICAgIH1cbiAgICAgIHBsYWluID0gcGxhaW4gJiYgaXNQbGFpblNhZmUoY2hhciwgcHJldkNoYXIsIGluYmxvY2spO1xuICAgICAgcHJldkNoYXIgPSBjaGFyO1xuICAgIH1cbiAgICAvLyBpbiBjYXNlIHRoZSBlbmQgaXMgbWlzc2luZyBhIFxcblxuICAgIGhhc0ZvbGRhYmxlTGluZSA9IGhhc0ZvbGRhYmxlTGluZSB8fCAoc2hvdWxkVHJhY2tXaWR0aCAmJlxuICAgICAgKGkgLSBwcmV2aW91c0xpbmVCcmVhayAtIDEgPiBsaW5lV2lkdGggJiZcbiAgICAgICBzdHJpbmdbcHJldmlvdXNMaW5lQnJlYWsgKyAxXSAhPT0gJyAnKSk7XG4gIH1cbiAgLy8gQWx0aG91Z2ggZXZlcnkgc3R5bGUgY2FuIHJlcHJlc2VudCBcXG4gd2l0aG91dCBlc2NhcGluZywgcHJlZmVyIGJsb2NrIHN0eWxlc1xuICAvLyBmb3IgbXVsdGlsaW5lLCBzaW5jZSB0aGV5J3JlIG1vcmUgcmVhZGFibGUgYW5kIHRoZXkgZG9uJ3QgYWRkIGVtcHR5IGxpbmVzLlxuICAvLyBBbHNvIHByZWZlciBmb2xkaW5nIGEgc3VwZXItbG9uZyBsaW5lLlxuICBpZiAoIWhhc0xpbmVCcmVhayAmJiAhaGFzRm9sZGFibGVMaW5lKSB7XG4gICAgLy8gU3RyaW5ncyBpbnRlcnByZXRhYmxlIGFzIGFub3RoZXIgdHlwZSBoYXZlIHRvIGJlIHF1b3RlZDtcbiAgICAvLyBlLmcuIHRoZSBzdHJpbmcgJ3RydWUnIHZzLiB0aGUgYm9vbGVhbiB0cnVlLlxuICAgIGlmIChwbGFpbiAmJiAhZm9yY2VRdW90ZXMgJiYgIXRlc3RBbWJpZ3VvdXNUeXBlKHN0cmluZykpIHtcbiAgICAgIHJldHVybiBTVFlMRV9QTEFJTjtcbiAgICB9XG4gICAgcmV0dXJuIHF1b3RpbmdUeXBlID09PSBRVU9USU5HX1RZUEVfRE9VQkxFID8gU1RZTEVfRE9VQkxFIDogU1RZTEVfU0lOR0xFO1xuICB9XG4gIC8vIEVkZ2UgY2FzZTogYmxvY2sgaW5kZW50YXRpb24gaW5kaWNhdG9yIGNhbiBvbmx5IGhhdmUgb25lIGRpZ2l0LlxuICBpZiAoaW5kZW50UGVyTGV2ZWwgPiA5ICYmIG5lZWRJbmRlbnRJbmRpY2F0b3Ioc3RyaW5nKSkge1xuICAgIHJldHVybiBTVFlMRV9ET1VCTEU7XG4gIH1cbiAgLy8gQXQgdGhpcyBwb2ludCB3ZSBrbm93IGJsb2NrIHN0eWxlcyBhcmUgdmFsaWQuXG4gIC8vIFByZWZlciBsaXRlcmFsIHN0eWxlIHVubGVzcyB3ZSB3YW50IHRvIGZvbGQuXG4gIGlmICghZm9yY2VRdW90ZXMpIHtcbiAgICByZXR1cm4gaGFzRm9sZGFibGVMaW5lID8gU1RZTEVfRk9MREVEIDogU1RZTEVfTElURVJBTDtcbiAgfVxuICByZXR1cm4gcXVvdGluZ1R5cGUgPT09IFFVT1RJTkdfVFlQRV9ET1VCTEUgPyBTVFlMRV9ET1VCTEUgOiBTVFlMRV9TSU5HTEU7XG59XG5cbi8vIE5vdGU6IGxpbmUgYnJlYWtpbmcvZm9sZGluZyBpcyBpbXBsZW1lbnRlZCBmb3Igb25seSB0aGUgZm9sZGVkIHN0eWxlLlxuLy8gTkIuIFdlIGRyb3AgdGhlIGxhc3QgdHJhaWxpbmcgbmV3bGluZSAoaWYgYW55KSBvZiBhIHJldHVybmVkIGJsb2NrIHNjYWxhclxuLy8gIHNpbmNlIHRoZSBkdW1wZXIgYWRkcyBpdHMgb3duIG5ld2xpbmUuIFRoaXMgYWx3YXlzIHdvcmtzOlxuLy8gICAg4oCiIE5vIGVuZGluZyBuZXdsaW5lID0+IHVuYWZmZWN0ZWQ7IGFscmVhZHkgdXNpbmcgc3RyaXAgXCItXCIgY2hvbXBpbmcuXG4vLyAgICDigKIgRW5kaW5nIG5ld2xpbmUgICAgPT4gcmVtb3ZlZCB0aGVuIHJlc3RvcmVkLlxuLy8gIEltcG9ydGFudGx5LCB0aGlzIGtlZXBzIHRoZSBcIitcIiBjaG9tcCBpbmRpY2F0b3IgZnJvbSBnYWluaW5nIGFuIGV4dHJhIGxpbmUuXG5mdW5jdGlvbiB3cml0ZVNjYWxhcihzdGF0ZSwgc3RyaW5nLCBsZXZlbCwgaXNrZXksIGluYmxvY2spIHtcbiAgc3RhdGUuZHVtcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHN0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBzdGF0ZS5xdW90aW5nVHlwZSA9PT0gUVVPVElOR19UWVBFX0RPVUJMRSA/ICdcIlwiJyA6IFwiJydcIjtcbiAgICB9XG4gICAgaWYgKCFzdGF0ZS5ub0NvbXBhdE1vZGUpIHtcbiAgICAgIGlmIChERVBSRUNBVEVEX0JPT0xFQU5TX1NZTlRBWC5pbmRleE9mKHN0cmluZykgIT09IC0xIHx8IERFUFJFQ0FURURfQkFTRTYwX1NZTlRBWC50ZXN0KHN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLnF1b3RpbmdUeXBlID09PSBRVU9USU5HX1RZUEVfRE9VQkxFID8gKCdcIicgKyBzdHJpbmcgKyAnXCInKSA6IChcIidcIiArIHN0cmluZyArIFwiJ1wiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaW5kZW50ID0gc3RhdGUuaW5kZW50ICogTWF0aC5tYXgoMSwgbGV2ZWwpOyAvLyBubyAwLWluZGVudCBzY2FsYXJzXG4gICAgLy8gQXMgaW5kZW50YXRpb24gZ2V0cyBkZWVwZXIsIGxldCB0aGUgd2lkdGggZGVjcmVhc2UgbW9ub3RvbmljYWxseVxuICAgIC8vIHRvIHRoZSBsb3dlciBib3VuZCBtaW4oc3RhdGUubGluZVdpZHRoLCA0MCkuXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgaW1wbGllc1xuICAgIC8vICBzdGF0ZS5saW5lV2lkdGgg4omkIDQwICsgc3RhdGUuaW5kZW50OiB3aWR0aCBpcyBmaXhlZCBhdCB0aGUgbG93ZXIgYm91bmQuXG4gICAgLy8gIHN0YXRlLmxpbmVXaWR0aCA+IDQwICsgc3RhdGUuaW5kZW50OiB3aWR0aCBkZWNyZWFzZXMgdW50aWwgdGhlIGxvd2VyIGJvdW5kLlxuICAgIC8vIFRoaXMgYmVoYXZlcyBiZXR0ZXIgdGhhbiBhIGNvbnN0YW50IG1pbmltdW0gd2lkdGggd2hpY2ggZGlzYWxsb3dzIG5hcnJvd2VyIG9wdGlvbnMsXG4gICAgLy8gb3IgYW4gaW5kZW50IHRocmVzaG9sZCB3aGljaCBjYXVzZXMgdGhlIHdpZHRoIHRvIHN1ZGRlbmx5IGluY3JlYXNlLlxuICAgIHZhciBsaW5lV2lkdGggPSBzdGF0ZS5saW5lV2lkdGggPT09IC0xXG4gICAgICA/IC0xIDogTWF0aC5tYXgoTWF0aC5taW4oc3RhdGUubGluZVdpZHRoLCA0MCksIHN0YXRlLmxpbmVXaWR0aCAtIGluZGVudCk7XG5cbiAgICAvLyBXaXRob3V0IGtub3dpbmcgaWYga2V5cyBhcmUgaW1wbGljaXQvZXhwbGljaXQsIGFzc3VtZSBpbXBsaWNpdCBmb3Igc2FmZXR5LlxuICAgIHZhciBzaW5nbGVMaW5lT25seSA9IGlza2V5XG4gICAgICAvLyBObyBibG9jayBzdHlsZXMgaW4gZmxvdyBtb2RlLlxuICAgICAgfHwgKHN0YXRlLmZsb3dMZXZlbCA+IC0xICYmIGxldmVsID49IHN0YXRlLmZsb3dMZXZlbCk7XG4gICAgZnVuY3Rpb24gdGVzdEFtYmlndWl0eShzdHJpbmcpIHtcbiAgICAgIHJldHVybiB0ZXN0SW1wbGljaXRSZXNvbHZpbmcoc3RhdGUsIHN0cmluZyk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChjaG9vc2VTY2FsYXJTdHlsZShzdHJpbmcsIHNpbmdsZUxpbmVPbmx5LCBzdGF0ZS5pbmRlbnQsIGxpbmVXaWR0aCxcbiAgICAgIHRlc3RBbWJpZ3VpdHksIHN0YXRlLnF1b3RpbmdUeXBlLCBzdGF0ZS5mb3JjZVF1b3RlcyAmJiAhaXNrZXksIGluYmxvY2spKSB7XG5cbiAgICAgIGNhc2UgU1RZTEVfUExBSU46XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICBjYXNlIFNUWUxFX1NJTkdMRTpcbiAgICAgICAgcmV0dXJuIFwiJ1wiICsgc3RyaW5nLnJlcGxhY2UoLycvZywgXCInJ1wiKSArIFwiJ1wiO1xuICAgICAgY2FzZSBTVFlMRV9MSVRFUkFMOlxuICAgICAgICByZXR1cm4gJ3wnICsgYmxvY2tIZWFkZXIoc3RyaW5nLCBzdGF0ZS5pbmRlbnQpXG4gICAgICAgICAgKyBkcm9wRW5kaW5nTmV3bGluZShpbmRlbnRTdHJpbmcoc3RyaW5nLCBpbmRlbnQpKTtcbiAgICAgIGNhc2UgU1RZTEVfRk9MREVEOlxuICAgICAgICByZXR1cm4gJz4nICsgYmxvY2tIZWFkZXIoc3RyaW5nLCBzdGF0ZS5pbmRlbnQpXG4gICAgICAgICAgKyBkcm9wRW5kaW5nTmV3bGluZShpbmRlbnRTdHJpbmcoZm9sZFN0cmluZyhzdHJpbmcsIGxpbmVXaWR0aCksIGluZGVudCkpO1xuICAgICAgY2FzZSBTVFlMRV9ET1VCTEU6XG4gICAgICAgIHJldHVybiAnXCInICsgZXNjYXBlU3RyaW5nKHN0cmluZywgbGluZVdpZHRoKSArICdcIic7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignaW1wb3NzaWJsZSBlcnJvcjogaW52YWxpZCBzY2FsYXIgc3R5bGUnKTtcbiAgICB9XG4gIH0oKSk7XG59XG5cbi8vIFByZS1jb25kaXRpb25zOiBzdHJpbmcgaXMgdmFsaWQgZm9yIGEgYmxvY2sgc2NhbGFyLCAxIDw9IGluZGVudFBlckxldmVsIDw9IDkuXG5mdW5jdGlvbiBibG9ja0hlYWRlcihzdHJpbmcsIGluZGVudFBlckxldmVsKSB7XG4gIHZhciBpbmRlbnRJbmRpY2F0b3IgPSBuZWVkSW5kZW50SW5kaWNhdG9yKHN0cmluZykgPyBTdHJpbmcoaW5kZW50UGVyTGV2ZWwpIDogJyc7XG5cbiAgLy8gbm90ZSB0aGUgc3BlY2lhbCBjYXNlOiB0aGUgc3RyaW5nICdcXG4nIGNvdW50cyBhcyBhIFwidHJhaWxpbmdcIiBlbXB0eSBsaW5lLlxuICB2YXIgY2xpcCA9ICAgICAgICAgIHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gMV0gPT09ICdcXG4nO1xuICB2YXIga2VlcCA9IGNsaXAgJiYgKHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gMl0gPT09ICdcXG4nIHx8IHN0cmluZyA9PT0gJ1xcbicpO1xuICB2YXIgY2hvbXAgPSBrZWVwID8gJysnIDogKGNsaXAgPyAnJyA6ICctJyk7XG5cbiAgcmV0dXJuIGluZGVudEluZGljYXRvciArIGNob21wICsgJ1xcbic7XG59XG5cbi8vIChTZWUgdGhlIG5vdGUgZm9yIHdyaXRlU2NhbGFyLilcbmZ1bmN0aW9uIGRyb3BFbmRpbmdOZXdsaW5lKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nW3N0cmluZy5sZW5ndGggLSAxXSA9PT0gJ1xcbicgPyBzdHJpbmcuc2xpY2UoMCwgLTEpIDogc3RyaW5nO1xufVxuXG4vLyBOb3RlOiBhIGxvbmcgbGluZSB3aXRob3V0IGEgc3VpdGFibGUgYnJlYWsgcG9pbnQgd2lsbCBleGNlZWQgdGhlIHdpZHRoIGxpbWl0LlxuLy8gUHJlLWNvbmRpdGlvbnM6IGV2ZXJ5IGNoYXIgaW4gc3RyIGlzUHJpbnRhYmxlLCBzdHIubGVuZ3RoID4gMCwgd2lkdGggPiAwLlxuZnVuY3Rpb24gZm9sZFN0cmluZyhzdHJpbmcsIHdpZHRoKSB7XG4gIC8vIEluIGZvbGRlZCBzdHlsZSwgJGskIGNvbnNlY3V0aXZlIG5ld2xpbmVzIG91dHB1dCBhcyAkaysxJCBuZXdsaW5lc+KAlFxuICAvLyB1bmxlc3MgdGhleSdyZSBiZWZvcmUgb3IgYWZ0ZXIgYSBtb3JlLWluZGVudGVkIGxpbmUsIG9yIGF0IHRoZSB2ZXJ5XG4gIC8vIGJlZ2lubmluZyBvciBlbmQsIGluIHdoaWNoIGNhc2UgJGskIG1hcHMgdG8gJGskLlxuICAvLyBUaGVyZWZvcmUsIHBhcnNlIGVhY2ggY2h1bmsgYXMgbmV3bGluZShzKSBmb2xsb3dlZCBieSBhIGNvbnRlbnQgbGluZS5cbiAgdmFyIGxpbmVSZSA9IC8oXFxuKykoW15cXG5dKikvZztcblxuICAvLyBmaXJzdCBsaW5lIChwb3NzaWJseSBhbiBlbXB0eSBsaW5lKVxuICB2YXIgcmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmV4dExGID0gc3RyaW5nLmluZGV4T2YoJ1xcbicpO1xuICAgIG5leHRMRiA9IG5leHRMRiAhPT0gLTEgPyBuZXh0TEYgOiBzdHJpbmcubGVuZ3RoO1xuICAgIGxpbmVSZS5sYXN0SW5kZXggPSBuZXh0TEY7XG4gICAgcmV0dXJuIGZvbGRMaW5lKHN0cmluZy5zbGljZSgwLCBuZXh0TEYpLCB3aWR0aCk7XG4gIH0oKSk7XG4gIC8vIElmIHdlIGhhdmVuJ3QgcmVhY2hlZCB0aGUgZmlyc3QgY29udGVudCBsaW5lIHlldCwgZG9uJ3QgYWRkIGFuIGV4dHJhIFxcbi5cbiAgdmFyIHByZXZNb3JlSW5kZW50ZWQgPSBzdHJpbmdbMF0gPT09ICdcXG4nIHx8IHN0cmluZ1swXSA9PT0gJyAnO1xuICB2YXIgbW9yZUluZGVudGVkO1xuXG4gIC8vIHJlc3Qgb2YgdGhlIGxpbmVzXG4gIHZhciBtYXRjaDtcbiAgd2hpbGUgKChtYXRjaCA9IGxpbmVSZS5leGVjKHN0cmluZykpKSB7XG4gICAgdmFyIHByZWZpeCA9IG1hdGNoWzFdLCBsaW5lID0gbWF0Y2hbMl07XG4gICAgbW9yZUluZGVudGVkID0gKGxpbmVbMF0gPT09ICcgJyk7XG4gICAgcmVzdWx0ICs9IHByZWZpeFxuICAgICAgKyAoIXByZXZNb3JlSW5kZW50ZWQgJiYgIW1vcmVJbmRlbnRlZCAmJiBsaW5lICE9PSAnJ1xuICAgICAgICA/ICdcXG4nIDogJycpXG4gICAgICArIGZvbGRMaW5lKGxpbmUsIHdpZHRoKTtcbiAgICBwcmV2TW9yZUluZGVudGVkID0gbW9yZUluZGVudGVkO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gR3JlZWR5IGxpbmUgYnJlYWtpbmcuXG4vLyBQaWNrcyB0aGUgbG9uZ2VzdCBsaW5lIHVuZGVyIHRoZSBsaW1pdCBlYWNoIHRpbWUsXG4vLyBvdGhlcndpc2Ugc2V0dGxlcyBmb3IgdGhlIHNob3J0ZXN0IGxpbmUgb3ZlciB0aGUgbGltaXQuXG4vLyBOQi4gTW9yZS1pbmRlbnRlZCBsaW5lcyAqY2Fubm90KiBiZSBmb2xkZWQsIGFzIHRoYXQgd291bGQgYWRkIGFuIGV4dHJhIFxcbi5cbmZ1bmN0aW9uIGZvbGRMaW5lKGxpbmUsIHdpZHRoKSB7XG4gIGlmIChsaW5lID09PSAnJyB8fCBsaW5lWzBdID09PSAnICcpIHJldHVybiBsaW5lO1xuXG4gIC8vIFNpbmNlIGEgbW9yZS1pbmRlbnRlZCBsaW5lIGFkZHMgYSBcXG4sIGJyZWFrcyBjYW4ndCBiZSBmb2xsb3dlZCBieSBhIHNwYWNlLlxuICB2YXIgYnJlYWtSZSA9IC8gW14gXS9nOyAvLyBub3RlOiB0aGUgbWF0Y2ggaW5kZXggd2lsbCBhbHdheXMgYmUgPD0gbGVuZ3RoLTIuXG4gIHZhciBtYXRjaDtcbiAgLy8gc3RhcnQgaXMgYW4gaW5jbHVzaXZlIGluZGV4LiBlbmQsIGN1cnIsIGFuZCBuZXh0IGFyZSBleGNsdXNpdmUuXG4gIHZhciBzdGFydCA9IDAsIGVuZCwgY3VyciA9IDAsIG5leHQgPSAwO1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgLy8gSW52YXJpYW50czogMCA8PSBzdGFydCA8PSBsZW5ndGgtMS5cbiAgLy8gICAwIDw9IGN1cnIgPD0gbmV4dCA8PSBtYXgoMCwgbGVuZ3RoLTIpLiBjdXJyIC0gc3RhcnQgPD0gd2lkdGguXG4gIC8vIEluc2lkZSB0aGUgbG9vcDpcbiAgLy8gICBBIG1hdGNoIGltcGxpZXMgbGVuZ3RoID49IDIsIHNvIGN1cnIgYW5kIG5leHQgYXJlIDw9IGxlbmd0aC0yLlxuICB3aGlsZSAoKG1hdGNoID0gYnJlYWtSZS5leGVjKGxpbmUpKSkge1xuICAgIG5leHQgPSBtYXRjaC5pbmRleDtcbiAgICAvLyBtYWludGFpbiBpbnZhcmlhbnQ6IGN1cnIgLSBzdGFydCA8PSB3aWR0aFxuICAgIGlmIChuZXh0IC0gc3RhcnQgPiB3aWR0aCkge1xuICAgICAgZW5kID0gKGN1cnIgPiBzdGFydCkgPyBjdXJyIDogbmV4dDsgLy8gZGVyaXZlIGVuZCA8PSBsZW5ndGgtMlxuICAgICAgcmVzdWx0ICs9ICdcXG4nICsgbGluZS5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgIC8vIHNraXAgdGhlIHNwYWNlIHRoYXQgd2FzIG91dHB1dCBhcyBcXG5cbiAgICAgIHN0YXJ0ID0gZW5kICsgMTsgICAgICAgICAgICAgICAgICAgIC8vIGRlcml2ZSBzdGFydCA8PSBsZW5ndGgtMVxuICAgIH1cbiAgICBjdXJyID0gbmV4dDtcbiAgfVxuXG4gIC8vIEJ5IHRoZSBpbnZhcmlhbnRzLCBzdGFydCA8PSBsZW5ndGgtMSwgc28gdGhlcmUgaXMgc29tZXRoaW5nIGxlZnQgb3Zlci5cbiAgLy8gSXQgaXMgZWl0aGVyIHRoZSB3aG9sZSBzdHJpbmcgb3IgYSBwYXJ0IHN0YXJ0aW5nIGZyb20gbm9uLXdoaXRlc3BhY2UuXG4gIHJlc3VsdCArPSAnXFxuJztcbiAgLy8gSW5zZXJ0IGEgYnJlYWsgaWYgdGhlIHJlbWFpbmRlciBpcyB0b28gbG9uZyBhbmQgdGhlcmUgaXMgYSBicmVhayBhdmFpbGFibGUuXG4gIGlmIChsaW5lLmxlbmd0aCAtIHN0YXJ0ID4gd2lkdGggJiYgY3VyciA+IHN0YXJ0KSB7XG4gICAgcmVzdWx0ICs9IGxpbmUuc2xpY2Uoc3RhcnQsIGN1cnIpICsgJ1xcbicgKyBsaW5lLnNsaWNlKGN1cnIgKyAxKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgKz0gbGluZS5zbGljZShzdGFydCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0LnNsaWNlKDEpOyAvLyBkcm9wIGV4dHJhIFxcbiBqb2luZXJcbn1cblxuLy8gRXNjYXBlcyBhIGRvdWJsZS1xdW90ZWQgc3RyaW5nLlxuZnVuY3Rpb24gZXNjYXBlU3RyaW5nKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHZhciBjaGFyID0gMDtcbiAgdmFyIGVzY2FwZVNlcTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGNoYXIgPj0gMHgxMDAwMCA/IGkgKz0gMiA6IGkrKykge1xuICAgIGNoYXIgPSBjb2RlUG9pbnRBdChzdHJpbmcsIGkpO1xuICAgIGVzY2FwZVNlcSA9IEVTQ0FQRV9TRVFVRU5DRVNbY2hhcl07XG5cbiAgICBpZiAoIWVzY2FwZVNlcSAmJiBpc1ByaW50YWJsZShjaGFyKSkge1xuICAgICAgcmVzdWx0ICs9IHN0cmluZ1tpXTtcbiAgICAgIGlmIChjaGFyID49IDB4MTAwMDApIHJlc3VsdCArPSBzdHJpbmdbaSArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgKz0gZXNjYXBlU2VxIHx8IGVuY29kZUhleChjaGFyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB3cml0ZUZsb3dTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwsIG9iamVjdCkge1xuICB2YXIgX3Jlc3VsdCA9ICcnLFxuICAgICAgX3RhZyAgICA9IHN0YXRlLnRhZyxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoLFxuICAgICAgdmFsdWU7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdmFsdWUgPSBvYmplY3RbaW5kZXhdO1xuXG4gICAgaWYgKHN0YXRlLnJlcGxhY2VyKSB7XG4gICAgICB2YWx1ZSA9IHN0YXRlLnJlcGxhY2VyLmNhbGwob2JqZWN0LCBTdHJpbmcoaW5kZXgpLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gV3JpdGUgb25seSB2YWxpZCBlbGVtZW50cywgcHV0IG51bGwgaW5zdGVhZCBvZiBpbnZhbGlkIGVsZW1lbnRzLlxuICAgIGlmICh3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCB2YWx1ZSwgZmFsc2UsIGZhbHNlKSB8fFxuICAgICAgICAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgbnVsbCwgZmFsc2UsIGZhbHNlKSkpIHtcblxuICAgICAgaWYgKF9yZXN1bHQgIT09ICcnKSBfcmVzdWx0ICs9ICcsJyArICghc3RhdGUuY29uZGVuc2VGbG93ID8gJyAnIDogJycpO1xuICAgICAgX3Jlc3VsdCArPSBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSAnWycgKyBfcmVzdWx0ICsgJ10nO1xufVxuXG5mdW5jdGlvbiB3cml0ZUJsb2NrU2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBvYmplY3QsIGNvbXBhY3QpIHtcbiAgdmFyIF9yZXN1bHQgPSAnJyxcbiAgICAgIF90YWcgICAgPSBzdGF0ZS50YWcsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIHZhbHVlO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHZhbHVlID0gb2JqZWN0W2luZGV4XTtcblxuICAgIGlmIChzdGF0ZS5yZXBsYWNlcikge1xuICAgICAgdmFsdWUgPSBzdGF0ZS5yZXBsYWNlci5jYWxsKG9iamVjdCwgU3RyaW5nKGluZGV4KSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8vIFdyaXRlIG9ubHkgdmFsaWQgZWxlbWVudHMsIHB1dCBudWxsIGluc3RlYWQgb2YgaW52YWxpZCBlbGVtZW50cy5cbiAgICBpZiAod3JpdGVOb2RlKHN0YXRlLCBsZXZlbCArIDEsIHZhbHVlLCB0cnVlLCB0cnVlLCBmYWxzZSwgdHJ1ZSkgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgIHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCBudWxsLCB0cnVlLCB0cnVlLCBmYWxzZSwgdHJ1ZSkpKSB7XG5cbiAgICAgIGlmICghY29tcGFjdCB8fCBfcmVzdWx0ICE9PSAnJykge1xuICAgICAgICBfcmVzdWx0ICs9IGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLmR1bXAgJiYgQ0hBUl9MSU5FX0ZFRUQgPT09IHN0YXRlLmR1bXAuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICBfcmVzdWx0ICs9ICctJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9yZXN1bHQgKz0gJy0gJztcbiAgICAgIH1cblxuICAgICAgX3Jlc3VsdCArPSBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSBfcmVzdWx0IHx8ICdbXSc7IC8vIEVtcHR5IHNlcXVlbmNlIGlmIG5vIHZhbGlkIHZhbHVlcy5cbn1cblxuZnVuY3Rpb24gd3JpdGVGbG93TWFwcGluZyhzdGF0ZSwgbGV2ZWwsIG9iamVjdCkge1xuICB2YXIgX3Jlc3VsdCAgICAgICA9ICcnLFxuICAgICAgX3RhZyAgICAgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIG9iamVjdEtleUxpc3QgPSBPYmplY3Qua2V5cyhvYmplY3QpLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICBvYmplY3RLZXksXG4gICAgICBvYmplY3RWYWx1ZSxcbiAgICAgIHBhaXJCdWZmZXI7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdEtleUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuXG4gICAgcGFpckJ1ZmZlciA9ICcnO1xuICAgIGlmIChfcmVzdWx0ICE9PSAnJykgcGFpckJ1ZmZlciArPSAnLCAnO1xuXG4gICAgaWYgKHN0YXRlLmNvbmRlbnNlRmxvdykgcGFpckJ1ZmZlciArPSAnXCInO1xuXG4gICAgb2JqZWN0S2V5ID0gb2JqZWN0S2V5TGlzdFtpbmRleF07XG4gICAgb2JqZWN0VmFsdWUgPSBvYmplY3Rbb2JqZWN0S2V5XTtcblxuICAgIGlmIChzdGF0ZS5yZXBsYWNlcikge1xuICAgICAgb2JqZWN0VmFsdWUgPSBzdGF0ZS5yZXBsYWNlci5jYWxsKG9iamVjdCwgb2JqZWN0S2V5LCBvYmplY3RWYWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3RLZXksIGZhbHNlLCBmYWxzZSkpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQga2V5O1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5kdW1wLmxlbmd0aCA+IDEwMjQpIHBhaXJCdWZmZXIgKz0gJz8gJztcblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcCArIChzdGF0ZS5jb25kZW5zZUZsb3cgPyAnXCInIDogJycpICsgJzonICsgKHN0YXRlLmNvbmRlbnNlRmxvdyA/ICcnIDogJyAnKTtcblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0VmFsdWUsIGZhbHNlLCBmYWxzZSkpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQgdmFsdWUuXG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgLy8gQm90aCBrZXkgYW5kIHZhbHVlIGFyZSB2YWxpZC5cbiAgICBfcmVzdWx0ICs9IHBhaXJCdWZmZXI7XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gJ3snICsgX3Jlc3VsdCArICd9Jztcbn1cblxuZnVuY3Rpb24gd3JpdGVCbG9ja01hcHBpbmcoc3RhdGUsIGxldmVsLCBvYmplY3QsIGNvbXBhY3QpIHtcbiAgdmFyIF9yZXN1bHQgICAgICAgPSAnJyxcbiAgICAgIF90YWcgICAgICAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBvYmplY3RLZXlMaXN0ID0gT2JqZWN0LmtleXMob2JqZWN0KSxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoLFxuICAgICAgb2JqZWN0S2V5LFxuICAgICAgb2JqZWN0VmFsdWUsXG4gICAgICBleHBsaWNpdFBhaXIsXG4gICAgICBwYWlyQnVmZmVyO1xuXG4gIC8vIEFsbG93IHNvcnRpbmcga2V5cyBzbyB0aGF0IHRoZSBvdXRwdXQgZmlsZSBpcyBkZXRlcm1pbmlzdGljXG4gIGlmIChzdGF0ZS5zb3J0S2V5cyA9PT0gdHJ1ZSkge1xuICAgIC8vIERlZmF1bHQgc29ydGluZ1xuICAgIG9iamVjdEtleUxpc3Quc29ydCgpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzdGF0ZS5zb3J0S2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEN1c3RvbSBzb3J0IGZ1bmN0aW9uXG4gICAgb2JqZWN0S2V5TGlzdC5zb3J0KHN0YXRlLnNvcnRLZXlzKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5zb3J0S2V5cykge1xuICAgIC8vIFNvbWV0aGluZyBpcyB3cm9uZ1xuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdzb3J0S2V5cyBtdXN0IGJlIGEgYm9vbGVhbiBvciBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpckJ1ZmZlciA9ICcnO1xuXG4gICAgaWYgKCFjb21wYWN0IHx8IF9yZXN1bHQgIT09ICcnKSB7XG4gICAgICBwYWlyQnVmZmVyICs9IGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKTtcbiAgICB9XG5cbiAgICBvYmplY3RLZXkgPSBvYmplY3RLZXlMaXN0W2luZGV4XTtcbiAgICBvYmplY3RWYWx1ZSA9IG9iamVjdFtvYmplY3RLZXldO1xuXG4gICAgaWYgKHN0YXRlLnJlcGxhY2VyKSB7XG4gICAgICBvYmplY3RWYWx1ZSA9IHN0YXRlLnJlcGxhY2VyLmNhbGwob2JqZWN0LCBvYmplY3RLZXksIG9iamVjdFZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCBvYmplY3RLZXksIHRydWUsIHRydWUsIHRydWUpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIGtleS5cbiAgICB9XG5cbiAgICBleHBsaWNpdFBhaXIgPSAoc3RhdGUudGFnICE9PSBudWxsICYmIHN0YXRlLnRhZyAhPT0gJz8nKSB8fFxuICAgICAgICAgICAgICAgICAgIChzdGF0ZS5kdW1wICYmIHN0YXRlLmR1bXAubGVuZ3RoID4gMTAyNCk7XG5cbiAgICBpZiAoZXhwbGljaXRQYWlyKSB7XG4gICAgICBpZiAoc3RhdGUuZHVtcCAmJiBDSEFSX0xJTkVfRkVFRCA9PT0gc3RhdGUuZHVtcC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgIHBhaXJCdWZmZXIgKz0gJz8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFpckJ1ZmZlciArPSAnPyAnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDtcblxuICAgIGlmIChleHBsaWNpdFBhaXIpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgIH1cblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCArIDEsIG9iamVjdFZhbHVlLCB0cnVlLCBleHBsaWNpdFBhaXIpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIHZhbHVlLlxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5kdW1wICYmIENIQVJfTElORV9GRUVEID09PSBzdGF0ZS5kdW1wLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gJzonO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWlyQnVmZmVyICs9ICc6ICc7XG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgLy8gQm90aCBrZXkgYW5kIHZhbHVlIGFyZSB2YWxpZC5cbiAgICBfcmVzdWx0ICs9IHBhaXJCdWZmZXI7XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gX3Jlc3VsdCB8fCAne30nOyAvLyBFbXB0eSBtYXBwaW5nIGlmIG5vIHZhbGlkIHBhaXJzLlxufVxuXG5mdW5jdGlvbiBkZXRlY3RUeXBlKHN0YXRlLCBvYmplY3QsIGV4cGxpY2l0KSB7XG4gIHZhciBfcmVzdWx0LCB0eXBlTGlzdCwgaW5kZXgsIGxlbmd0aCwgdHlwZSwgc3R5bGU7XG5cbiAgdHlwZUxpc3QgPSBleHBsaWNpdCA/IHN0YXRlLmV4cGxpY2l0VHlwZXMgOiBzdGF0ZS5pbXBsaWNpdFR5cGVzO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB0eXBlTGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdHlwZSA9IHR5cGVMaXN0W2luZGV4XTtcblxuICAgIGlmICgodHlwZS5pbnN0YW5jZU9mICB8fCB0eXBlLnByZWRpY2F0ZSkgJiZcbiAgICAgICAgKCF0eXBlLmluc3RhbmNlT2YgfHwgKCh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JykgJiYgKG9iamVjdCBpbnN0YW5jZW9mIHR5cGUuaW5zdGFuY2VPZikpKSAmJlxuICAgICAgICAoIXR5cGUucHJlZGljYXRlICB8fCB0eXBlLnByZWRpY2F0ZShvYmplY3QpKSkge1xuXG4gICAgICBpZiAoZXhwbGljaXQpIHtcbiAgICAgICAgaWYgKHR5cGUubXVsdGkgJiYgdHlwZS5yZXByZXNlbnROYW1lKSB7XG4gICAgICAgICAgc3RhdGUudGFnID0gdHlwZS5yZXByZXNlbnROYW1lKG9iamVjdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUudGFnID0gdHlwZS50YWc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnRhZyA9ICc/JztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUucmVwcmVzZW50KSB7XG4gICAgICAgIHN0eWxlID0gc3RhdGUuc3R5bGVNYXBbdHlwZS50YWddIHx8IHR5cGUuZGVmYXVsdFN0eWxlO1xuXG4gICAgICAgIGlmIChfdG9TdHJpbmcuY2FsbCh0eXBlLnJlcHJlc2VudCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgICBfcmVzdWx0ID0gdHlwZS5yZXByZXNlbnQob2JqZWN0LCBzdHlsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5LmNhbGwodHlwZS5yZXByZXNlbnQsIHN0eWxlKSkge1xuICAgICAgICAgIF9yZXN1bHQgPSB0eXBlLnJlcHJlc2VudFtzdHlsZV0ob2JqZWN0LCBzdHlsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJyE8JyArIHR5cGUudGFnICsgJz4gdGFnIHJlc29sdmVyIGFjY2VwdHMgbm90IFwiJyArIHN0eWxlICsgJ1wiIHN0eWxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5kdW1wID0gX3Jlc3VsdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTZXJpYWxpemVzIGBvYmplY3RgIGFuZCB3cml0ZXMgaXQgdG8gZ2xvYmFsIGByZXN1bHRgLlxuLy8gUmV0dXJucyB0cnVlIG9uIHN1Y2Nlc3MsIG9yIGZhbHNlIG9uIGludmFsaWQgb2JqZWN0LlxuLy9cbmZ1bmN0aW9uIHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG9iamVjdCwgYmxvY2ssIGNvbXBhY3QsIGlza2V5LCBpc2Jsb2Nrc2VxKSB7XG4gIHN0YXRlLnRhZyA9IG51bGw7XG4gIHN0YXRlLmR1bXAgPSBvYmplY3Q7XG5cbiAgaWYgKCFkZXRlY3RUeXBlKHN0YXRlLCBvYmplY3QsIGZhbHNlKSkge1xuICAgIGRldGVjdFR5cGUoc3RhdGUsIG9iamVjdCwgdHJ1ZSk7XG4gIH1cblxuICB2YXIgdHlwZSA9IF90b1N0cmluZy5jYWxsKHN0YXRlLmR1bXApO1xuICB2YXIgaW5ibG9jayA9IGJsb2NrO1xuICB2YXIgdGFnU3RyO1xuXG4gIGlmIChibG9jaykge1xuICAgIGJsb2NrID0gKHN0YXRlLmZsb3dMZXZlbCA8IDAgfHwgc3RhdGUuZmxvd0xldmVsID4gbGV2ZWwpO1xuICB9XG5cbiAgdmFyIG9iamVjdE9yQXJyYXkgPSB0eXBlID09PSAnW29iamVjdCBPYmplY3RdJyB8fCB0eXBlID09PSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgZHVwbGljYXRlSW5kZXgsXG4gICAgICBkdXBsaWNhdGU7XG5cbiAgaWYgKG9iamVjdE9yQXJyYXkpIHtcbiAgICBkdXBsaWNhdGVJbmRleCA9IHN0YXRlLmR1cGxpY2F0ZXMuaW5kZXhPZihvYmplY3QpO1xuICAgIGR1cGxpY2F0ZSA9IGR1cGxpY2F0ZUluZGV4ICE9PSAtMTtcbiAgfVxuXG4gIGlmICgoc3RhdGUudGFnICE9PSBudWxsICYmIHN0YXRlLnRhZyAhPT0gJz8nKSB8fCBkdXBsaWNhdGUgfHwgKHN0YXRlLmluZGVudCAhPT0gMiAmJiBsZXZlbCA+IDApKSB7XG4gICAgY29tcGFjdCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKGR1cGxpY2F0ZSAmJiBzdGF0ZS51c2VkRHVwbGljYXRlc1tkdXBsaWNhdGVJbmRleF0pIHtcbiAgICBzdGF0ZS5kdW1wID0gJypyZWZfJyArIGR1cGxpY2F0ZUluZGV4O1xuICB9IGVsc2Uge1xuICAgIGlmIChvYmplY3RPckFycmF5ICYmIGR1cGxpY2F0ZSAmJiAhc3RhdGUudXNlZER1cGxpY2F0ZXNbZHVwbGljYXRlSW5kZXhdKSB7XG4gICAgICBzdGF0ZS51c2VkRHVwbGljYXRlc1tkdXBsaWNhdGVJbmRleF0gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgIGlmIChibG9jayAmJiAoT2JqZWN0LmtleXMoc3RhdGUuZHVtcCkubGVuZ3RoICE9PSAwKSkge1xuICAgICAgICB3cml0ZUJsb2NrTWFwcGluZyhzdGF0ZSwgbGV2ZWwsIHN0YXRlLmR1bXAsIGNvbXBhY3QpO1xuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlRmxvd01hcHBpbmcoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wKTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyAnICcgKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICBpZiAoYmxvY2sgJiYgKHN0YXRlLmR1bXAubGVuZ3RoICE9PSAwKSkge1xuICAgICAgICBpZiAoc3RhdGUubm9BcnJheUluZGVudCAmJiAhaXNibG9ja3NlcSAmJiBsZXZlbCA+IDApIHtcbiAgICAgICAgICB3cml0ZUJsb2NrU2VxdWVuY2Uoc3RhdGUsIGxldmVsIC0gMSwgc3RhdGUuZHVtcCwgY29tcGFjdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd3JpdGVCbG9ja1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCwgY29tcGFjdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZUZsb3dTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwsIHN0YXRlLmR1bXApO1xuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArICcgJyArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFN0cmluZ10nKSB7XG4gICAgICBpZiAoc3RhdGUudGFnICE9PSAnPycpIHtcbiAgICAgICAgd3JpdGVTY2FsYXIoc3RhdGUsIHN0YXRlLmR1bXAsIGxldmVsLCBpc2tleSwgaW5ibG9jayk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnW29iamVjdCBVbmRlZmluZWRdJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuc2tpcEludmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCd1bmFjY2VwdGFibGUga2luZCBvZiBhbiBvYmplY3QgdG8gZHVtcCAnICsgdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbCAmJiBzdGF0ZS50YWcgIT09ICc/Jykge1xuICAgICAgLy8gTmVlZCB0byBlbmNvZGUgYWxsIGNoYXJhY3RlcnMgZXhjZXB0IHRob3NlIGFsbG93ZWQgYnkgdGhlIHNwZWM6XG4gICAgICAvL1xuICAgICAgLy8gWzM1XSBucy1kZWMtZGlnaXQgICAgOjo9ICBbI3gzMC0jeDM5XSAvKiAwLTkgKi9cbiAgICAgIC8vIFszNl0gbnMtaGV4LWRpZ2l0ICAgIDo6PSAgbnMtZGVjLWRpZ2l0XG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB8IFsjeDQxLSN4NDZdIC8qIEEtRiAqLyB8IFsjeDYxLSN4NjZdIC8qIGEtZiAqL1xuICAgICAgLy8gWzM3XSBucy1hc2NpaS1sZXR0ZXIgOjo9ICBbI3g0MS0jeDVBXSAvKiBBLVogKi8gfCBbI3g2MS0jeDdBXSAvKiBhLXogKi9cbiAgICAgIC8vIFszOF0gbnMtd29yZC1jaGFyICAgIDo6PSAgbnMtZGVjLWRpZ2l0IHwgbnMtYXNjaWktbGV0dGVyIHwg4oCcLeKAnVxuICAgICAgLy8gWzM5XSBucy11cmktY2hhciAgICAgOjo9ICDigJwl4oCdIG5zLWhleC1kaWdpdCBucy1oZXgtZGlnaXQgfCBucy13b3JkLWNoYXIgfCDigJwj4oCdXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB8IOKAnDvigJ0gfCDigJwv4oCdIHwg4oCcP+KAnSB8IOKAnDrigJ0gfCDigJxA4oCdIHwg4oCcJuKAnSB8IOKAnD3igJ0gfCDigJwr4oCdIHwg4oCcJOKAnSB8IOKAnCzigJ1cbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIHwg4oCcX+KAnSB8IOKAnC7igJ0gfCDigJwh4oCdIHwg4oCcfuKAnSB8IOKAnCrigJ0gfCDigJwn4oCdIHwg4oCcKOKAnSB8IOKAnCnigJ0gfCDigJxb4oCdIHwg4oCcXeKAnVxuICAgICAgLy9cbiAgICAgIC8vIEFsc28gbmVlZCB0byBlbmNvZGUgJyEnIGJlY2F1c2UgaXQgaGFzIHNwZWNpYWwgbWVhbmluZyAoZW5kIG9mIHRhZyBwcmVmaXgpLlxuICAgICAgLy9cbiAgICAgIHRhZ1N0ciA9IGVuY29kZVVSSShcbiAgICAgICAgc3RhdGUudGFnWzBdID09PSAnIScgPyBzdGF0ZS50YWcuc2xpY2UoMSkgOiBzdGF0ZS50YWdcbiAgICAgICkucmVwbGFjZSgvIS9nLCAnJTIxJyk7XG5cbiAgICAgIGlmIChzdGF0ZS50YWdbMF0gPT09ICchJykge1xuICAgICAgICB0YWdTdHIgPSAnIScgKyB0YWdTdHI7XG4gICAgICB9IGVsc2UgaWYgKHRhZ1N0ci5zbGljZSgwLCAxOCkgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjonKSB7XG4gICAgICAgIHRhZ1N0ciA9ICchIScgKyB0YWdTdHIuc2xpY2UoMTgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFnU3RyID0gJyE8JyArIHRhZ1N0ciArICc+JztcbiAgICAgIH1cblxuICAgICAgc3RhdGUuZHVtcCA9IHRhZ1N0ciArICcgJyArIHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldER1cGxpY2F0ZVJlZmVyZW5jZXMob2JqZWN0LCBzdGF0ZSkge1xuICB2YXIgb2JqZWN0cyA9IFtdLFxuICAgICAgZHVwbGljYXRlc0luZGV4ZXMgPSBbXSxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoO1xuXG4gIGluc3BlY3ROb2RlKG9iamVjdCwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBkdXBsaWNhdGVzSW5kZXhlcy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgc3RhdGUuZHVwbGljYXRlcy5wdXNoKG9iamVjdHNbZHVwbGljYXRlc0luZGV4ZXNbaW5kZXhdXSk7XG4gIH1cbiAgc3RhdGUudXNlZER1cGxpY2F0ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gaW5zcGVjdE5vZGUob2JqZWN0LCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcykge1xuICB2YXIgb2JqZWN0S2V5TGlzdCxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoO1xuXG4gIGlmIChvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcpIHtcbiAgICBpbmRleCA9IG9iamVjdHMuaW5kZXhPZihvYmplY3QpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmIChkdXBsaWNhdGVzSW5kZXhlcy5pbmRleE9mKGluZGV4KSA9PT0gLTEpIHtcbiAgICAgICAgZHVwbGljYXRlc0luZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdHMucHVzaChvYmplY3QpO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgIGluc3BlY3ROb2RlKG9iamVjdFtpbmRleF0sIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdEtleUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgIGluc3BlY3ROb2RlKG9iamVjdFtvYmplY3RLZXlMaXN0W2luZGV4XV0sIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkdW1wKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShvcHRpb25zKTtcblxuICBpZiAoIXN0YXRlLm5vUmVmcykgZ2V0RHVwbGljYXRlUmVmZXJlbmNlcyhpbnB1dCwgc3RhdGUpO1xuXG4gIHZhciB2YWx1ZSA9IGlucHV0O1xuXG4gIGlmIChzdGF0ZS5yZXBsYWNlcikge1xuICAgIHZhbHVlID0gc3RhdGUucmVwbGFjZXIuY2FsbCh7ICcnOiB2YWx1ZSB9LCAnJywgdmFsdWUpO1xuICB9XG5cbiAgaWYgKHdyaXRlTm9kZShzdGF0ZSwgMCwgdmFsdWUsIHRydWUsIHRydWUpKSByZXR1cm4gc3RhdGUuZHVtcCArICdcXG4nO1xuXG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMuZHVtcCA9IGR1bXA7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIGxvYWRlciA9IHJlcXVpcmUoJy4vbGliL2xvYWRlcicpO1xudmFyIGR1bXBlciA9IHJlcXVpcmUoJy4vbGliL2R1bXBlcicpO1xuXG5cbmZ1bmN0aW9uIHJlbmFtZWQoZnJvbSwgdG8pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIHlhbWwuJyArIGZyb20gKyAnIGlzIHJlbW92ZWQgaW4ganMteWFtbCA0LiAnICtcbiAgICAgICdVc2UgeWFtbC4nICsgdG8gKyAnIGluc3RlYWQsIHdoaWNoIGlzIG5vdyBzYWZlIGJ5IGRlZmF1bHQuJyk7XG4gIH07XG59XG5cblxubW9kdWxlLmV4cG9ydHMuVHlwZSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vbGliL3R5cGUnKTtcbm1vZHVsZS5leHBvcnRzLlNjaGVtYSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2xpYi9zY2hlbWEnKTtcbm1vZHVsZS5leHBvcnRzLkZBSUxTQUZFX1NDSEVNQSAgICAgPSByZXF1aXJlKCcuL2xpYi9zY2hlbWEvZmFpbHNhZmUnKTtcbm1vZHVsZS5leHBvcnRzLkpTT05fU0NIRU1BICAgICAgICAgPSByZXF1aXJlKCcuL2xpYi9zY2hlbWEvanNvbicpO1xubW9kdWxlLmV4cG9ydHMuQ09SRV9TQ0hFTUEgICAgICAgICA9IHJlcXVpcmUoJy4vbGliL3NjaGVtYS9jb3JlJyk7XG5tb2R1bGUuZXhwb3J0cy5ERUZBVUxUX1NDSEVNQSAgICAgID0gcmVxdWlyZSgnLi9saWIvc2NoZW1hL2RlZmF1bHQnKTtcbm1vZHVsZS5leHBvcnRzLmxvYWQgICAgICAgICAgICAgICAgPSBsb2FkZXIubG9hZDtcbm1vZHVsZS5leHBvcnRzLmxvYWRBbGwgICAgICAgICAgICAgPSBsb2FkZXIubG9hZEFsbDtcbm1vZHVsZS5leHBvcnRzLmR1bXAgICAgICAgICAgICAgICAgPSBkdW1wZXIuZHVtcDtcbm1vZHVsZS5leHBvcnRzLllBTUxFeGNlcHRpb24gICAgICAgPSByZXF1aXJlKCcuL2xpYi9leGNlcHRpb24nKTtcblxuLy8gUmUtZXhwb3J0IGFsbCB0eXBlcyBpbiBjYXNlIHVzZXIgd2FudHMgdG8gY3JlYXRlIGN1c3RvbSBzY2hlbWFcbm1vZHVsZS5leHBvcnRzLnR5cGVzID0ge1xuICBiaW5hcnk6ICAgIHJlcXVpcmUoJy4vbGliL3R5cGUvYmluYXJ5JyksXG4gIGZsb2F0OiAgICAgcmVxdWlyZSgnLi9saWIvdHlwZS9mbG9hdCcpLFxuICBtYXA6ICAgICAgIHJlcXVpcmUoJy4vbGliL3R5cGUvbWFwJyksXG4gIG51bGw6ICAgICAgcmVxdWlyZSgnLi9saWIvdHlwZS9udWxsJyksXG4gIHBhaXJzOiAgICAgcmVxdWlyZSgnLi9saWIvdHlwZS9wYWlycycpLFxuICBzZXQ6ICAgICAgIHJlcXVpcmUoJy4vbGliL3R5cGUvc2V0JyksXG4gIHRpbWVzdGFtcDogcmVxdWlyZSgnLi9saWIvdHlwZS90aW1lc3RhbXAnKSxcbiAgYm9vbDogICAgICByZXF1aXJlKCcuL2xpYi90eXBlL2Jvb2wnKSxcbiAgaW50OiAgICAgICByZXF1aXJlKCcuL2xpYi90eXBlL2ludCcpLFxuICBtZXJnZTogICAgIHJlcXVpcmUoJy4vbGliL3R5cGUvbWVyZ2UnKSxcbiAgb21hcDogICAgICByZXF1aXJlKCcuL2xpYi90eXBlL29tYXAnKSxcbiAgc2VxOiAgICAgICByZXF1aXJlKCcuL2xpYi90eXBlL3NlcScpLFxuICBzdHI6ICAgICAgIHJlcXVpcmUoJy4vbGliL3R5cGUvc3RyJylcbn07XG5cbi8vIFJlbW92ZWQgZnVuY3Rpb25zIGZyb20gSlMtWUFNTCAzLjAueFxubW9kdWxlLmV4cG9ydHMuc2FmZUxvYWQgICAgICAgICAgICA9IHJlbmFtZWQoJ3NhZmVMb2FkJywgJ2xvYWQnKTtcbm1vZHVsZS5leHBvcnRzLnNhZmVMb2FkQWxsICAgICAgICAgPSByZW5hbWVkKCdzYWZlTG9hZEFsbCcsICdsb2FkQWxsJyk7XG5tb2R1bGUuZXhwb3J0cy5zYWZlRHVtcCAgICAgICAgICAgID0gcmVuYW1lZCgnc2FmZUR1bXAnLCAnZHVtcCcpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxhenkgPSB2b2lkIDA7XG5jbGFzcyBMYXp5IHtcbiAgICBjb25zdHJ1Y3RvcihjcmVhdG9yKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jcmVhdG9yID0gY3JlYXRvcjtcbiAgICB9XG4gICAgZ2V0IGhhc1ZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdG9yID09IG51bGw7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3JlYXRvciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jcmVhdG9yKCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSByZXN1bHQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNyZWF0b3IgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuTGF6eSA9IExhenk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWluLmpzLm1hcCIsIi8vIE5vdGU6IHRoaXMgaXMgdGhlIHNlbXZlci5vcmcgdmVyc2lvbiBvZiB0aGUgc3BlYyB0aGF0IGl0IGltcGxlbWVudHNcbi8vIE5vdCBuZWNlc3NhcmlseSB0aGUgcGFja2FnZSB2ZXJzaW9uIG9mIHRoaXMgY29kZS5cbmNvbnN0IFNFTVZFUl9TUEVDX1ZFUlNJT04gPSAnMi4wLjAnXG5cbmNvbnN0IE1BWF9MRU5HVEggPSAyNTZcbmNvbnN0IE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fFxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gOTAwNzE5OTI1NDc0MDk5MVxuXG4vLyBNYXggc2FmZSBzZWdtZW50IGxlbmd0aCBmb3IgY29lcmNpb24uXG5jb25zdCBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIID0gMTZcblxuLy8gTWF4IHNhZmUgbGVuZ3RoIGZvciBhIGJ1aWxkIGlkZW50aWZpZXIuIFRoZSBtYXggbGVuZ3RoIG1pbnVzIDYgY2hhcmFjdGVycyBmb3Jcbi8vIHRoZSBzaG9ydGVzdCB2ZXJzaW9uIHdpdGggYSBidWlsZCAwLjAuMCtCVUlMRC5cbmNvbnN0IE1BWF9TQUZFX0JVSUxEX0xFTkdUSCA9IE1BWF9MRU5HVEggLSA2XG5cbmNvbnN0IFJFTEVBU0VfVFlQRVMgPSBbXG4gICdtYWpvcicsXG4gICdwcmVtYWpvcicsXG4gICdtaW5vcicsXG4gICdwcmVtaW5vcicsXG4gICdwYXRjaCcsXG4gICdwcmVwYXRjaCcsXG4gICdwcmVyZWxlYXNlJyxcbl1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIE1BWF9MRU5HVEgsXG4gIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEgsXG4gIE1BWF9TQUZFX0JVSUxEX0xFTkdUSCxcbiAgTUFYX1NBRkVfSU5URUdFUixcbiAgUkVMRUFTRV9UWVBFUyxcbiAgU0VNVkVSX1NQRUNfVkVSU0lPTixcbiAgRkxBR19JTkNMVURFX1BSRVJFTEVBU0U6IDBiMDAxLFxuICBGTEFHX0xPT1NFOiAwYjAxMCxcbn1cbiIsImNvbnN0IGRlYnVnID0gKFxuICB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiZcbiAgcHJvY2Vzcy5lbnYgJiZcbiAgcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyAmJlxuICAvXFxic2VtdmVyXFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKVxuKSA/ICguLi5hcmdzKSA9PiBjb25zb2xlLmVycm9yKCdTRU1WRVInLCAuLi5hcmdzKVxuICA6ICgpID0+IHt9XG5cbm1vZHVsZS5leHBvcnRzID0gZGVidWdcbiIsImNvbnN0IHsgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCwgTUFYX1NBRkVfQlVJTERfTEVOR1RIIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4vZGVidWcnKVxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge31cblxuLy8gVGhlIGFjdHVhbCByZWdleHBzIGdvIG9uIGV4cG9ydHMucmVcbmNvbnN0IHJlID0gZXhwb3J0cy5yZSA9IFtdXG5jb25zdCBzYWZlUmUgPSBleHBvcnRzLnNhZmVSZSA9IFtdXG5jb25zdCBzcmMgPSBleHBvcnRzLnNyYyA9IFtdXG5jb25zdCB0ID0gZXhwb3J0cy50ID0ge31cbmxldCBSID0gMFxuXG5jb25zdCBMRVRURVJEQVNITlVNQkVSID0gJ1thLXpBLVowLTktXSdcblxuLy8gUmVwbGFjZSBzb21lIGdyZWVkeSByZWdleCB0b2tlbnMgdG8gcHJldmVudCByZWdleCBkb3MgaXNzdWVzLiBUaGVzZSByZWdleCBhcmVcbi8vIHVzZWQgaW50ZXJuYWxseSB2aWEgdGhlIHNhZmVSZSBvYmplY3Qgc2luY2UgYWxsIGlucHV0cyBpbiB0aGlzIGxpYnJhcnkgZ2V0XG4vLyBub3JtYWxpemVkIGZpcnN0IHRvIHRyaW0gYW5kIGNvbGxhcHNlIGFsbCBleHRyYSB3aGl0ZXNwYWNlLiBUaGUgb3JpZ2luYWxcbi8vIHJlZ2V4ZXMgYXJlIGV4cG9ydGVkIGZvciB1c2VybGFuZCBjb25zdW1wdGlvbiBhbmQgbG93ZXIgbGV2ZWwgdXNhZ2UuIEFcbi8vIGZ1dHVyZSBicmVha2luZyBjaGFuZ2UgY291bGQgZXhwb3J0IHRoZSBzYWZlciByZWdleCBvbmx5IHdpdGggYSBub3RlIHRoYXRcbi8vIGFsbCBpbnB1dCBzaG91bGQgaGF2ZSBleHRyYSB3aGl0ZXNwYWNlIHJlbW92ZWQuXG5jb25zdCBzYWZlUmVnZXhSZXBsYWNlbWVudHMgPSBbXG4gIFsnXFxcXHMnLCAxXSxcbiAgWydcXFxcZCcsIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEhdLFxuICBbTEVUVEVSREFTSE5VTUJFUiwgTUFYX1NBRkVfQlVJTERfTEVOR1RIXSxcbl1cblxuY29uc3QgbWFrZVNhZmVSZWdleCA9ICh2YWx1ZSkgPT4ge1xuICBmb3IgKGNvbnN0IFt0b2tlbiwgbWF4XSBvZiBzYWZlUmVnZXhSZXBsYWNlbWVudHMpIHtcbiAgICB2YWx1ZSA9IHZhbHVlXG4gICAgICAuc3BsaXQoYCR7dG9rZW59KmApLmpvaW4oYCR7dG9rZW59ezAsJHttYXh9fWApXG4gICAgICAuc3BsaXQoYCR7dG9rZW59K2ApLmpvaW4oYCR7dG9rZW59ezEsJHttYXh9fWApXG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbmNvbnN0IGNyZWF0ZVRva2VuID0gKG5hbWUsIHZhbHVlLCBpc0dsb2JhbCkgPT4ge1xuICBjb25zdCBzYWZlID0gbWFrZVNhZmVSZWdleCh2YWx1ZSlcbiAgY29uc3QgaW5kZXggPSBSKytcbiAgZGVidWcobmFtZSwgaW5kZXgsIHZhbHVlKVxuICB0W25hbWVdID0gaW5kZXhcbiAgc3JjW2luZGV4XSA9IHZhbHVlXG4gIHJlW2luZGV4XSA9IG5ldyBSZWdFeHAodmFsdWUsIGlzR2xvYmFsID8gJ2cnIDogdW5kZWZpbmVkKVxuICBzYWZlUmVbaW5kZXhdID0gbmV3IFJlZ0V4cChzYWZlLCBpc0dsb2JhbCA/ICdnJyA6IHVuZGVmaW5lZClcbn1cblxuLy8gVGhlIGZvbGxvd2luZyBSZWd1bGFyIEV4cHJlc3Npb25zIGNhbiBiZSB1c2VkIGZvciB0b2tlbml6aW5nLFxuLy8gdmFsaWRhdGluZywgYW5kIHBhcnNpbmcgU2VtVmVyIHZlcnNpb24gc3RyaW5ncy5cblxuLy8gIyMgTnVtZXJpYyBJZGVudGlmaWVyXG4vLyBBIHNpbmdsZSBgMGAsIG9yIGEgbm9uLXplcm8gZGlnaXQgZm9sbG93ZWQgYnkgemVybyBvciBtb3JlIGRpZ2l0cy5cblxuY3JlYXRlVG9rZW4oJ05VTUVSSUNJREVOVElGSUVSJywgJzB8WzEtOV1cXFxcZConKVxuY3JlYXRlVG9rZW4oJ05VTUVSSUNJREVOVElGSUVSTE9PU0UnLCAnXFxcXGQrJylcblxuLy8gIyMgTm9uLW51bWVyaWMgSWRlbnRpZmllclxuLy8gWmVybyBvciBtb3JlIGRpZ2l0cywgZm9sbG93ZWQgYnkgYSBsZXR0ZXIgb3IgaHlwaGVuLCBhbmQgdGhlbiB6ZXJvIG9yXG4vLyBtb3JlIGxldHRlcnMsIGRpZ2l0cywgb3IgaHlwaGVucy5cblxuY3JlYXRlVG9rZW4oJ05PTk5VTUVSSUNJREVOVElGSUVSJywgYFxcXFxkKlthLXpBLVotXSR7TEVUVEVSREFTSE5VTUJFUn0qYClcblxuLy8gIyMgTWFpbiBWZXJzaW9uXG4vLyBUaHJlZSBkb3Qtc2VwYXJhdGVkIG51bWVyaWMgaWRlbnRpZmllcnMuXG5cbmNyZWF0ZVRva2VuKCdNQUlOVkVSU0lPTicsIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlgKVxuXG5jcmVhdGVUb2tlbignTUFJTlZFUlNJT05MT09TRScsIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pYClcblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvbiBJZGVudGlmaWVyXG4vLyBBIG51bWVyaWMgaWRlbnRpZmllciwgb3IgYSBub24tbnVtZXJpYyBpZGVudGlmaWVyLlxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRUlERU5USUZJRVInLCBgKD86JHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl1cbn18JHtzcmNbdC5OT05OVU1FUklDSURFTlRJRklFUl19KWApXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFJywgYCg/OiR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV1cbn18JHtzcmNbdC5OT05OVU1FUklDSURFTlRJRklFUl19KWApXG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb25cbi8vIEh5cGhlbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgZG90LXNlcGFyYXRlZCBwcmUtcmVsZWFzZSB2ZXJzaW9uXG4vLyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0UnLCBgKD86LSgke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSXVxufSg/OlxcXFwuJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUl19KSopKWApXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFTE9PU0UnLCBgKD86LT8oJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXVxufSg/OlxcXFwuJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXX0pKikpYClcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGEgSWRlbnRpZmllclxuLy8gQW55IGNvbWJpbmF0aW9uIG9mIGRpZ2l0cywgbGV0dGVycywgb3IgaHlwaGVucy5cblxuY3JlYXRlVG9rZW4oJ0JVSUxESURFTlRJRklFUicsIGAke0xFVFRFUkRBU0hOVU1CRVJ9K2ApXG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhXG4vLyBQbHVzIHNpZ24sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIHBlcmlvZC1zZXBhcmF0ZWQgYnVpbGQgbWV0YWRhdGFcbi8vIGlkZW50aWZpZXJzLlxuXG5jcmVhdGVUb2tlbignQlVJTEQnLCBgKD86XFxcXCsoJHtzcmNbdC5CVUlMRElERU5USUZJRVJdXG59KD86XFxcXC4ke3NyY1t0LkJVSUxESURFTlRJRklFUl19KSopKWApXG5cbi8vICMjIEZ1bGwgVmVyc2lvbiBTdHJpbmdcbi8vIEEgbWFpbiB2ZXJzaW9uLCBmb2xsb3dlZCBvcHRpb25hbGx5IGJ5IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiBhbmRcbi8vIGJ1aWxkIG1ldGFkYXRhLlxuXG4vLyBOb3RlIHRoYXQgdGhlIG9ubHkgbWFqb3IsIG1pbm9yLCBwYXRjaCwgYW5kIHByZS1yZWxlYXNlIHNlY3Rpb25zIG9mXG4vLyB0aGUgdmVyc2lvbiBzdHJpbmcgYXJlIGNhcHR1cmluZyBncm91cHMuICBUaGUgYnVpbGQgbWV0YWRhdGEgaXMgbm90IGFcbi8vIGNhcHR1cmluZyBncm91cCwgYmVjYXVzZSBpdCBzaG91bGQgbm90IGV2ZXIgYmUgdXNlZCBpbiB2ZXJzaW9uXG4vLyBjb21wYXJpc29uLlxuXG5jcmVhdGVUb2tlbignRlVMTFBMQUlOJywgYHY/JHtzcmNbdC5NQUlOVkVSU0lPTl1cbn0ke3NyY1t0LlBSRVJFTEVBU0VdfT8ke1xuICBzcmNbdC5CVUlMRF19P2ApXG5cbmNyZWF0ZVRva2VuKCdGVUxMJywgYF4ke3NyY1t0LkZVTExQTEFJTl19JGApXG5cbi8vIGxpa2UgZnVsbCwgYnV0IGFsbG93cyB2MS4yLjMgYW5kID0xLjIuMywgd2hpY2ggcGVvcGxlIGRvIHNvbWV0aW1lcy5cbi8vIGFsc28sIDEuMC4wYWxwaGExIChwcmVyZWxlYXNlIHdpdGhvdXQgdGhlIGh5cGhlbikgd2hpY2ggaXMgcHJldHR5XG4vLyBjb21tb24gaW4gdGhlIG5wbSByZWdpc3RyeS5cbmNyZWF0ZVRva2VuKCdMT09TRVBMQUlOJywgYFt2PVxcXFxzXSoke3NyY1t0Lk1BSU5WRVJTSU9OTE9PU0VdXG59JHtzcmNbdC5QUkVSRUxFQVNFTE9PU0VdfT8ke1xuICBzcmNbdC5CVUlMRF19P2ApXG5cbmNyZWF0ZVRva2VuKCdMT09TRScsIGBeJHtzcmNbdC5MT09TRVBMQUlOXX0kYClcblxuY3JlYXRlVG9rZW4oJ0dUTFQnLCAnKCg/Ojx8Pik/PT8pJylcblxuLy8gU29tZXRoaW5nIGxpa2UgXCIyLipcIiBvciBcIjEuMi54XCIuXG4vLyBOb3RlIHRoYXQgXCJ4LnhcIiBpcyBhIHZhbGlkIHhSYW5nZSBpZGVudGlmZXIsIG1lYW5pbmcgXCJhbnkgdmVyc2lvblwiXG4vLyBPbmx5IHRoZSBmaXJzdCBpdGVtIGlzIHN0cmljdGx5IHJlcXVpcmVkLlxuY3JlYXRlVG9rZW4oJ1hSQU5HRUlERU5USUZJRVJMT09TRScsIGAke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfXx4fFh8XFxcXCpgKVxuY3JlYXRlVG9rZW4oJ1hSQU5HRUlERU5USUZJRVInLCBgJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19fHh8WHxcXFxcKmApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0VQTEFJTicsIGBbdj1cXFxcc10qKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJdfSlgICtcbiAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYCg/OiR7c3JjW3QuUFJFUkVMRUFTRV19KT8ke1xuICAgICAgICAgICAgICAgICAgICAgc3JjW3QuQlVJTERdfT9gICtcbiAgICAgICAgICAgICAgICAgICBgKT8pP2ApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0VQTEFJTkxPT1NFJywgYFt2PVxcXFxzXSooJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKD86JHtzcmNbdC5QUkVSRUxFQVNFTE9PU0VdfSk/JHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjW3QuQlVJTERdfT9gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGApPyk/YClcblxuY3JlYXRlVG9rZW4oJ1hSQU5HRScsIGBeJHtzcmNbdC5HVExUXX1cXFxccyoke3NyY1t0LlhSQU5HRVBMQUlOXX0kYClcbmNyZWF0ZVRva2VuKCdYUkFOR0VMT09TRScsIGBeJHtzcmNbdC5HVExUXX1cXFxccyoke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKVxuXG4vLyBDb2VyY2lvbi5cbi8vIEV4dHJhY3QgYW55dGhpbmcgdGhhdCBjb3VsZCBjb25jZWl2YWJseSBiZSBhIHBhcnQgb2YgYSB2YWxpZCBzZW12ZXJcbmNyZWF0ZVRva2VuKCdDT0VSQ0UnLCBgJHsnKF58W15cXFxcZF0pJyArXG4gICAgICAgICAgICAgICcoXFxcXGR7MSwnfSR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KWAgK1xuICAgICAgICAgICAgICBgKD86XFxcXC4oXFxcXGR7MSwke01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEh9fSkpP2AgK1xuICAgICAgICAgICAgICBgKD86XFxcXC4oXFxcXGR7MSwke01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEh9fSkpP2AgK1xuICAgICAgICAgICAgICBgKD86JHxbXlxcXFxkXSlgKVxuY3JlYXRlVG9rZW4oJ0NPRVJDRVJUTCcsIHNyY1t0LkNPRVJDRV0sIHRydWUpXG5cbi8vIFRpbGRlIHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJyZWFzb25hYmx5IGF0IG9yIGdyZWF0ZXIgdGhhblwiXG5jcmVhdGVUb2tlbignTE9ORVRJTERFJywgJyg/On4+PyknKVxuXG5jcmVhdGVUb2tlbignVElMREVUUklNJywgYChcXFxccyopJHtzcmNbdC5MT05FVElMREVdfVxcXFxzK2AsIHRydWUpXG5leHBvcnRzLnRpbGRlVHJpbVJlcGxhY2UgPSAnJDF+J1xuXG5jcmVhdGVUb2tlbignVElMREUnLCBgXiR7c3JjW3QuTE9ORVRJTERFXX0ke3NyY1t0LlhSQU5HRVBMQUlOXX0kYClcbmNyZWF0ZVRva2VuKCdUSUxERUxPT1NFJywgYF4ke3NyY1t0LkxPTkVUSUxERV19JHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQ2FyZXQgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcImF0IGxlYXN0IGFuZCBiYWNrd2FyZHMgY29tcGF0aWJsZSB3aXRoXCJcbmNyZWF0ZVRva2VuKCdMT05FQ0FSRVQnLCAnKD86XFxcXF4pJylcblxuY3JlYXRlVG9rZW4oJ0NBUkVUVFJJTScsIGAoXFxcXHMqKSR7c3JjW3QuTE9ORUNBUkVUXX1cXFxccytgLCB0cnVlKVxuZXhwb3J0cy5jYXJldFRyaW1SZXBsYWNlID0gJyQxXidcblxuY3JlYXRlVG9rZW4oJ0NBUkVUJywgYF4ke3NyY1t0LkxPTkVDQVJFVF19JHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignQ0FSRVRMT09TRScsIGBeJHtzcmNbdC5MT05FQ0FSRVRdfSR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19JGApXG5cbi8vIEEgc2ltcGxlIGd0L2x0L2VxIHRoaW5nLCBvciBqdXN0IFwiXCIgdG8gaW5kaWNhdGUgXCJhbnkgdmVyc2lvblwiXG5jcmVhdGVUb2tlbignQ09NUEFSQVRPUkxPT1NFJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKigke3NyY1t0LkxPT1NFUExBSU5dfSkkfF4kYClcbmNyZWF0ZVRva2VuKCdDT01QQVJBVE9SJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKigke3NyY1t0LkZVTExQTEFJTl19KSR8XiRgKVxuXG4vLyBBbiBleHByZXNzaW9uIHRvIHN0cmlwIGFueSB3aGl0ZXNwYWNlIGJldHdlZW4gdGhlIGd0bHQgYW5kIHRoZSB0aGluZ1xuLy8gaXQgbW9kaWZpZXMsIHNvIHRoYXQgYD4gMS4yLjNgID09PiBgPjEuMi4zYFxuY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1JUUklNJywgYChcXFxccyopJHtzcmNbdC5HVExUXVxufVxcXFxzKigke3NyY1t0LkxPT1NFUExBSU5dfXwke3NyY1t0LlhSQU5HRVBMQUlOXX0pYCwgdHJ1ZSlcbmV4cG9ydHMuY29tcGFyYXRvclRyaW1SZXBsYWNlID0gJyQxJDIkMydcblxuLy8gU29tZXRoaW5nIGxpa2UgYDEuMi4zIC0gMS4yLjRgXG4vLyBOb3RlIHRoYXQgdGhlc2UgYWxsIHVzZSB0aGUgbG9vc2UgZm9ybSwgYmVjYXVzZSB0aGV5J2xsIGJlXG4vLyBjaGVja2VkIGFnYWluc3QgZWl0aGVyIHRoZSBzdHJpY3Qgb3IgbG9vc2UgY29tcGFyYXRvciBmb3JtXG4vLyBsYXRlci5cbmNyZWF0ZVRva2VuKCdIWVBIRU5SQU5HRScsIGBeXFxcXHMqKCR7c3JjW3QuWFJBTkdFUExBSU5dfSlgICtcbiAgICAgICAgICAgICAgICAgICBgXFxcXHMrLVxcXFxzK2AgK1xuICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5YUkFOR0VQTEFJTl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGBcXFxccyokYClcblxuY3JlYXRlVG9rZW4oJ0hZUEhFTlJBTkdFTE9PU0UnLCBgXlxcXFxzKigke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcXFxccystXFxcXHMrYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYFxcXFxzKiRgKVxuXG4vLyBTdGFyIHJhbmdlcyBiYXNpY2FsbHkganVzdCBhbGxvdyBhbnl0aGluZyBhdCBhbGwuXG5jcmVhdGVUb2tlbignU1RBUicsICcoPHw+KT89P1xcXFxzKlxcXFwqJylcbi8vID49MC4wLjAgaXMgbGlrZSBhIHN0YXJcbmNyZWF0ZVRva2VuKCdHVEUwJywgJ15cXFxccyo+PVxcXFxzKjBcXFxcLjBcXFxcLjBcXFxccyokJylcbmNyZWF0ZVRva2VuKCdHVEUwUFJFJywgJ15cXFxccyo+PVxcXFxzKjBcXFxcLjBcXFxcLjAtMFxcXFxzKiQnKVxuIiwiLy8gcGFyc2Ugb3V0IGp1c3QgdGhlIG9wdGlvbnMgd2UgY2FyZSBhYm91dFxuY29uc3QgbG9vc2VPcHRpb24gPSBPYmplY3QuZnJlZXplKHsgbG9vc2U6IHRydWUgfSlcbmNvbnN0IGVtcHR5T3B0cyA9IE9iamVjdC5mcmVlemUoeyB9KVxuY29uc3QgcGFyc2VPcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIHJldHVybiBlbXB0eU9wdHNcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbG9vc2VPcHRpb25cbiAgfVxuXG4gIHJldHVybiBvcHRpb25zXG59XG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlT3B0aW9uc1xuIiwiY29uc3QgbnVtZXJpYyA9IC9eWzAtOV0rJC9cbmNvbnN0IGNvbXBhcmVJZGVudGlmaWVycyA9IChhLCBiKSA9PiB7XG4gIGNvbnN0IGFudW0gPSBudW1lcmljLnRlc3QoYSlcbiAgY29uc3QgYm51bSA9IG51bWVyaWMudGVzdChiKVxuXG4gIGlmIChhbnVtICYmIGJudW0pIHtcbiAgICBhID0gK2FcbiAgICBiID0gK2JcbiAgfVxuXG4gIHJldHVybiBhID09PSBiID8gMFxuICAgIDogKGFudW0gJiYgIWJudW0pID8gLTFcbiAgICA6IChibnVtICYmICFhbnVtKSA/IDFcbiAgICA6IGEgPCBiID8gLTFcbiAgICA6IDFcbn1cblxuY29uc3QgcmNvbXBhcmVJZGVudGlmaWVycyA9IChhLCBiKSA9PiBjb21wYXJlSWRlbnRpZmllcnMoYiwgYSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXBhcmVJZGVudGlmaWVycyxcbiAgcmNvbXBhcmVJZGVudGlmaWVycyxcbn1cbiIsImNvbnN0IGRlYnVnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvZGVidWcnKVxuY29uc3QgeyBNQVhfTEVOR1RILCBNQVhfU0FGRV9JTlRFR0VSIH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9jb25zdGFudHMnKVxuY29uc3QgeyBzYWZlUmU6IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgeyBjb21wYXJlSWRlbnRpZmllcnMgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lkZW50aWZpZXJzJylcbmNsYXNzIFNlbVZlciB7XG4gIGNvbnN0cnVjdG9yICh2ZXJzaW9uLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICAgIGlmICh2ZXJzaW9uLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UgJiZcbiAgICAgICAgICB2ZXJzaW9uLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgICAgcmV0dXJuIHZlcnNpb25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnZlcnNpb25cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCB2ZXJzaW9uLiBNdXN0IGJlIGEgc3RyaW5nLiBHb3QgdHlwZSBcIiR7dHlwZW9mIHZlcnNpb259XCIuYClcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBgdmVyc2lvbiBpcyBsb25nZXIgdGhhbiAke01BWF9MRU5HVEh9IGNoYXJhY3RlcnNgXG4gICAgICApXG4gICAgfVxuXG4gICAgZGVidWcoJ1NlbVZlcicsIHZlcnNpb24sIG9wdGlvbnMpXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgICAvLyB0aGlzIGlzbid0IGFjdHVhbGx5IHJlbGV2YW50IGZvciB2ZXJzaW9ucywgYnV0IGtlZXAgaXQgc28gdGhhdCB3ZVxuICAgIC8vIGRvbid0IHJ1biBpbnRvIHRyb3VibGUgcGFzc2luZyB0aGlzLm9wdGlvbnMgYXJvdW5kLlxuICAgIHRoaXMuaW5jbHVkZVByZXJlbGVhc2UgPSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcblxuICAgIGNvbnN0IG0gPSB2ZXJzaW9uLnRyaW0oKS5tYXRjaChvcHRpb25zLmxvb3NlID8gcmVbdC5MT09TRV0gOiByZVt0LkZVTExdKVxuXG4gICAgaWYgKCFtKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFZlcnNpb246ICR7dmVyc2lvbn1gKVxuICAgIH1cblxuICAgIHRoaXMucmF3ID0gdmVyc2lvblxuXG4gICAgLy8gdGhlc2UgYXJlIGFjdHVhbGx5IG51bWJlcnNcbiAgICB0aGlzLm1ham9yID0gK21bMV1cbiAgICB0aGlzLm1pbm9yID0gK21bMl1cbiAgICB0aGlzLnBhdGNoID0gK21bM11cblxuICAgIGlmICh0aGlzLm1ham9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1ham9yIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWpvciB2ZXJzaW9uJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5taW5vciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5taW5vciA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWlub3IgdmVyc2lvbicpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGF0Y2ggPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMucGF0Y2ggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHBhdGNoIHZlcnNpb24nKVxuICAgIH1cblxuICAgIC8vIG51bWJlcmlmeSBhbnkgcHJlcmVsZWFzZSBudW1lcmljIGlkc1xuICAgIGlmICghbVs0XSkge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gbVs0XS5zcGxpdCgnLicpLm1hcCgoaWQpID0+IHtcbiAgICAgICAgaWYgKC9eWzAtOV0rJC8udGVzdChpZCkpIHtcbiAgICAgICAgICBjb25zdCBudW0gPSAraWRcbiAgICAgICAgICBpZiAobnVtID49IDAgJiYgbnVtIDwgTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgcmV0dXJuIG51bVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5idWlsZCA9IG1bNV0gPyBtWzVdLnNwbGl0KCcuJykgOiBbXVxuICAgIHRoaXMuZm9ybWF0KClcbiAgfVxuXG4gIGZvcm1hdCAoKSB7XG4gICAgdGhpcy52ZXJzaW9uID0gYCR7dGhpcy5tYWpvcn0uJHt0aGlzLm1pbm9yfS4ke3RoaXMucGF0Y2h9YFxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICB0aGlzLnZlcnNpb24gKz0gYC0ke3RoaXMucHJlcmVsZWFzZS5qb2luKCcuJyl9YFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy52ZXJzaW9uXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVyc2lvblxuICB9XG5cbiAgY29tcGFyZSAob3RoZXIpIHtcbiAgICBkZWJ1ZygnU2VtVmVyLmNvbXBhcmUnLCB0aGlzLnZlcnNpb24sIHRoaXMub3B0aW9ucywgb3RoZXIpXG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBpZiAodHlwZW9mIG90aGVyID09PSAnc3RyaW5nJyAmJiBvdGhlciA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICBpZiAob3RoZXIudmVyc2lvbiA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbXBhcmVNYWluKG90aGVyKSB8fCB0aGlzLmNvbXBhcmVQcmUob3RoZXIpXG4gIH1cblxuICBjb21wYXJlTWFpbiAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5tYWpvciwgb3RoZXIubWFqb3IpIHx8XG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5taW5vciwgb3RoZXIubWlub3IpIHx8XG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5wYXRjaCwgb3RoZXIucGF0Y2gpXG4gICAgKVxuICB9XG5cbiAgY29tcGFyZVByZSAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIC8vIE5PVCBoYXZpbmcgYSBwcmVyZWxlYXNlIGlzID4gaGF2aW5nIG9uZVxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfSBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiBvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICBsZXQgaSA9IDBcbiAgICBkbyB7XG4gICAgICBjb25zdCBhID0gdGhpcy5wcmVyZWxlYXNlW2ldXG4gICAgICBjb25zdCBiID0gb3RoZXIucHJlcmVsZWFzZVtpXVxuICAgICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgY29tcGFyZUJ1aWxkIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgbGV0IGkgPSAwXG4gICAgZG8ge1xuICAgICAgY29uc3QgYSA9IHRoaXMuYnVpbGRbaV1cbiAgICAgIGNvbnN0IGIgPSBvdGhlci5idWlsZFtpXVxuICAgICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgLy8gcHJlbWlub3Igd2lsbCBidW1wIHRoZSB2ZXJzaW9uIHVwIHRvIHRoZSBuZXh0IG1pbm9yIHJlbGVhc2UsIGFuZCBpbW1lZGlhdGVseVxuICAvLyBkb3duIHRvIHByZS1yZWxlYXNlLiBwcmVtYWpvciBhbmQgcHJlcGF0Y2ggd29yayB0aGUgc2FtZSB3YXkuXG4gIGluYyAocmVsZWFzZSwgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpIHtcbiAgICBzd2l0Y2ggKHJlbGVhc2UpIHtcbiAgICAgIGNhc2UgJ3ByZW1ham9yJzpcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5taW5vciA9IDBcbiAgICAgICAgdGhpcy5tYWpvcisrXG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3ByZW1pbm9yJzpcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5taW5vcisrXG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3ByZXBhdGNoJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhbHJlYWR5IGEgcHJlcmVsZWFzZSwgaXQgd2lsbCBidW1wIHRvIHRoZSBuZXh0IHZlcnNpb25cbiAgICAgICAgLy8gZHJvcCBhbnkgcHJlcmVsZWFzZXMgdGhhdCBtaWdodCBhbHJlYWR5IGV4aXN0LCBzaW5jZSB0aGV5IGFyZSBub3RcbiAgICAgICAgLy8gcmVsZXZhbnQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSlcbiAgICAgICAgYnJlYWtcbiAgICAgIC8vIElmIHRoZSBpbnB1dCBpcyBhIG5vbi1wcmVyZWxlYXNlIHZlcnNpb24sIHRoaXMgYWN0cyB0aGUgc2FtZSBhc1xuICAgICAgLy8gcHJlcGF0Y2guXG4gICAgICBjYXNlICdwcmVyZWxlYXNlJzpcbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSlcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ21ham9yJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1tYWpvciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1ham9yIHZlcnNpb24uXG4gICAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWFqb3IuXG4gICAgICAgIC8vIDEuMC4wLTUgYnVtcHMgdG8gMS4wLjBcbiAgICAgICAgLy8gMS4xLjAgYnVtcHMgdG8gMi4wLjBcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMubWlub3IgIT09IDAgfHxcbiAgICAgICAgICB0aGlzLnBhdGNoICE9PSAwIHx8XG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLm1ham9yKytcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1pbm9yID0gMFxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnbWlub3InOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1pbm9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWlub3IgdmVyc2lvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtaW5vci5cbiAgICAgICAgLy8gMS4yLjAtNSBidW1wcyB0byAxLjIuMFxuICAgICAgICAvLyAxLjIuMSBidW1wcyB0byAxLjMuMFxuICAgICAgICBpZiAodGhpcy5wYXRjaCAhPT0gMCB8fCB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5taW5vcisrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3BhdGNoJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uLCBpdCB3aWxsIGluY3JlbWVudCB0aGUgcGF0Y2guXG4gICAgICAgIC8vIElmIGl0IGlzIGEgcHJlLXJlbGVhc2UgaXQgd2lsbCBidW1wIHVwIHRvIHRoZSBzYW1lIHBhdGNoIHZlcnNpb24uXG4gICAgICAgIC8vIDEuMi4wLTUgcGF0Y2hlcyB0byAxLjIuMFxuICAgICAgICAvLyAxLjIuMCBwYXRjaGVzIHRvIDEuMi4xXG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5wYXRjaCsrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIC8vIFRoaXMgcHJvYmFibHkgc2hvdWxkbid0IGJlIHVzZWQgcHVibGljbHkuXG4gICAgICAvLyAxLjAuMCAncHJlJyB3b3VsZCBiZWNvbWUgMS4wLjAtMCB3aGljaCBpcyB0aGUgd3JvbmcgZGlyZWN0aW9uLlxuICAgICAgY2FzZSAncHJlJzoge1xuICAgICAgICBjb25zdCBiYXNlID0gTnVtYmVyKGlkZW50aWZpZXJCYXNlKSA/IDEgOiAwXG5cbiAgICAgICAgaWYgKCFpZGVudGlmaWVyICYmIGlkZW50aWZpZXJCYXNlID09PSBmYWxzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6IGlkZW50aWZpZXIgaXMgZW1wdHknKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbYmFzZV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgaSA9IHRoaXMucHJlcmVsZWFzZS5sZW5ndGhcbiAgICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcmVyZWxlYXNlW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2VbaV0rK1xuICAgICAgICAgICAgICBpID0gLTJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBkaWRuJ3QgaW5jcmVtZW50IGFueXRoaW5nXG4gICAgICAgICAgICBpZiAoaWRlbnRpZmllciA9PT0gdGhpcy5wcmVyZWxlYXNlLmpvaW4oJy4nKSAmJiBpZGVudGlmaWVyQmFzZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluY3JlbWVudCBhcmd1bWVudDogaWRlbnRpZmllciBhbHJlYWR5IGV4aXN0cycpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UucHVzaChiYXNlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgICAgIC8vIDEuMi4wLWJldGEuMSBidW1wcyB0byAxLjIuMC1iZXRhLjIsXG4gICAgICAgICAgLy8gMS4yLjAtYmV0YS5mb29ibHogb3IgMS4yLjAtYmV0YSBidW1wcyB0byAxLjIuMC1iZXRhLjBcbiAgICAgICAgICBsZXQgcHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCBiYXNlXVxuICAgICAgICAgIGlmIChpZGVudGlmaWVyQmFzZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHByZXJlbGVhc2UgPSBbaWRlbnRpZmllcl1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLnByZXJlbGVhc2VbMF0sIGlkZW50aWZpZXIpID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4odGhpcy5wcmVyZWxlYXNlWzFdKSkge1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBwcmVyZWxlYXNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IHByZXJlbGVhc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6ICR7cmVsZWFzZX1gKVxuICAgIH1cbiAgICB0aGlzLnJhdyA9IHRoaXMuZm9ybWF0KClcbiAgICBpZiAodGhpcy5idWlsZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmF3ICs9IGArJHt0aGlzLmJ1aWxkLmpvaW4oJy4nKX1gXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZW1WZXJcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IHBhcnNlID0gKHZlcnNpb24sIG9wdGlvbnMsIHRocm93RXJyb3JzID0gZmFsc2UpID0+IHtcbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICByZXR1cm4gdmVyc2lvblxuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAoIXRocm93RXJyb3JzKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICB0aHJvdyBlclxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VcbiIsImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCB2YWxpZCA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHYgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKVxuICByZXR1cm4gdiA/IHYudmVyc2lvbiA6IG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRcbiIsImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCBjbGVhbiA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHMgPSBwYXJzZSh2ZXJzaW9uLnRyaW0oKS5yZXBsYWNlKC9eWz12XSsvLCAnJyksIG9wdGlvbnMpXG4gIHJldHVybiBzID8gcy52ZXJzaW9uIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBjbGVhblxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuXG5jb25zdCBpbmMgPSAodmVyc2lvbiwgcmVsZWFzZSwgb3B0aW9ucywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpID0+IHtcbiAgaWYgKHR5cGVvZiAob3B0aW9ucykgPT09ICdzdHJpbmcnKSB7XG4gICAgaWRlbnRpZmllckJhc2UgPSBpZGVudGlmaWVyXG4gICAgaWRlbnRpZmllciA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKFxuICAgICAgdmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlciA/IHZlcnNpb24udmVyc2lvbiA6IHZlcnNpb24sXG4gICAgICBvcHRpb25zXG4gICAgKS5pbmMocmVsZWFzZSwgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpLnZlcnNpb25cbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluY1xuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlLmpzJylcblxuY29uc3QgZGlmZiA9ICh2ZXJzaW9uMSwgdmVyc2lvbjIpID0+IHtcbiAgY29uc3QgdjEgPSBwYXJzZSh2ZXJzaW9uMSwgbnVsbCwgdHJ1ZSlcbiAgY29uc3QgdjIgPSBwYXJzZSh2ZXJzaW9uMiwgbnVsbCwgdHJ1ZSlcbiAgY29uc3QgY29tcGFyaXNvbiA9IHYxLmNvbXBhcmUodjIpXG5cbiAgaWYgKGNvbXBhcmlzb24gPT09IDApIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgdjFIaWdoZXIgPSBjb21wYXJpc29uID4gMFxuICBjb25zdCBoaWdoVmVyc2lvbiA9IHYxSGlnaGVyID8gdjEgOiB2MlxuICBjb25zdCBsb3dWZXJzaW9uID0gdjFIaWdoZXIgPyB2MiA6IHYxXG4gIGNvbnN0IGhpZ2hIYXNQcmUgPSAhIWhpZ2hWZXJzaW9uLnByZXJlbGVhc2UubGVuZ3RoXG4gIGNvbnN0IGxvd0hhc1ByZSA9ICEhbG93VmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aFxuXG4gIGlmIChsb3dIYXNQcmUgJiYgIWhpZ2hIYXNQcmUpIHtcbiAgICAvLyBHb2luZyBmcm9tIHByZXJlbGVhc2UgLT4gbm8gcHJlcmVsZWFzZSByZXF1aXJlcyBzb21lIHNwZWNpYWwgY2FzaW5nXG5cbiAgICAvLyBJZiB0aGUgbG93IHZlcnNpb24gaGFzIG9ubHkgYSBtYWpvciwgdGhlbiBpdCB3aWxsIGFsd2F5cyBiZSBhIG1ham9yXG4gICAgLy8gU29tZSBleGFtcGxlczpcbiAgICAvLyAxLjAuMC0xIC0+IDEuMC4wXG4gICAgLy8gMS4wLjAtMSAtPiAxLjEuMVxuICAgIC8vIDEuMC4wLTEgLT4gMi4wLjBcbiAgICBpZiAoIWxvd1ZlcnNpb24ucGF0Y2ggJiYgIWxvd1ZlcnNpb24ubWlub3IpIHtcbiAgICAgIHJldHVybiAnbWFqb3InXG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlIGl0IGNhbiBiZSBkZXRlcm1pbmVkIGJ5IGNoZWNraW5nIHRoZSBoaWdoIHZlcnNpb25cblxuICAgIGlmIChoaWdoVmVyc2lvbi5wYXRjaCkge1xuICAgICAgLy8gYW55dGhpbmcgaGlnaGVyIHRoYW4gYSBwYXRjaCBidW1wIHdvdWxkIHJlc3VsdCBpbiB0aGUgd3JvbmcgdmVyc2lvblxuICAgICAgcmV0dXJuICdwYXRjaCdcbiAgICB9XG5cbiAgICBpZiAoaGlnaFZlcnNpb24ubWlub3IpIHtcbiAgICAgIC8vIGFueXRoaW5nIGhpZ2hlciB0aGFuIGEgbWlub3IgYnVtcCB3b3VsZCByZXN1bHQgaW4gdGhlIHdyb25nIHZlcnNpb25cbiAgICAgIHJldHVybiAnbWlub3InXG4gICAgfVxuXG4gICAgLy8gYnVtcGluZyBtYWpvci9taW5vci9wYXRjaCBhbGwgaGF2ZSBzYW1lIHJlc3VsdFxuICAgIHJldHVybiAnbWFqb3InXG4gIH1cblxuICAvLyBhZGQgdGhlIGBwcmVgIHByZWZpeCBpZiB3ZSBhcmUgZ29pbmcgdG8gYSBwcmVyZWxlYXNlIHZlcnNpb25cbiAgY29uc3QgcHJlZml4ID0gaGlnaEhhc1ByZSA/ICdwcmUnIDogJydcblxuICBpZiAodjEubWFqb3IgIT09IHYyLm1ham9yKSB7XG4gICAgcmV0dXJuIHByZWZpeCArICdtYWpvcidcbiAgfVxuXG4gIGlmICh2MS5taW5vciAhPT0gdjIubWlub3IpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgJ21pbm9yJ1xuICB9XG5cbiAgaWYgKHYxLnBhdGNoICE9PSB2Mi5wYXRjaCkge1xuICAgIHJldHVybiBwcmVmaXggKyAncGF0Y2gnXG4gIH1cblxuICAvLyBoaWdoIGFuZCBsb3cgYXJlIHByZWxlYXNlc1xuICByZXR1cm4gJ3ByZXJlbGVhc2UnXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGlmZlxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgbWFqb3IgPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1ham9yXG5tb2R1bGUuZXhwb3J0cyA9IG1ham9yXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBtaW5vciA9IChhLCBsb29zZSkgPT4gbmV3IFNlbVZlcihhLCBsb29zZSkubWlub3Jcbm1vZHVsZS5leHBvcnRzID0gbWlub3JcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IHBhdGNoID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5wYXRjaFxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaFxuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHByZXJlbGVhc2UgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBwYXJzZWQgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKVxuICByZXR1cm4gKHBhcnNlZCAmJiBwYXJzZWQucHJlcmVsZWFzZS5sZW5ndGgpID8gcGFyc2VkLnByZXJlbGVhc2UgOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IHByZXJlbGVhc2VcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IGNvbXBhcmUgPSAoYSwgYiwgbG9vc2UpID0+XG4gIG5ldyBTZW1WZXIoYSwgbG9vc2UpLmNvbXBhcmUobmV3IFNlbVZlcihiLCBsb29zZSkpXG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZVxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCByY29tcGFyZSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShiLCBhLCBsb29zZSlcbm1vZHVsZS5leHBvcnRzID0gcmNvbXBhcmVcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgY29tcGFyZUxvb3NlID0gKGEsIGIpID0+IGNvbXBhcmUoYSwgYiwgdHJ1ZSlcbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZUxvb3NlXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBjb21wYXJlQnVpbGQgPSAoYSwgYiwgbG9vc2UpID0+IHtcbiAgY29uc3QgdmVyc2lvbkEgPSBuZXcgU2VtVmVyKGEsIGxvb3NlKVxuICBjb25zdCB2ZXJzaW9uQiA9IG5ldyBTZW1WZXIoYiwgbG9vc2UpXG4gIHJldHVybiB2ZXJzaW9uQS5jb21wYXJlKHZlcnNpb25CKSB8fCB2ZXJzaW9uQS5jb21wYXJlQnVpbGQodmVyc2lvbkIpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVCdWlsZFxuIiwiY29uc3QgY29tcGFyZUJ1aWxkID0gcmVxdWlyZSgnLi9jb21wYXJlLWJ1aWxkJylcbmNvbnN0IHNvcnQgPSAobGlzdCwgbG9vc2UpID0+IGxpc3Quc29ydCgoYSwgYikgPT4gY29tcGFyZUJ1aWxkKGEsIGIsIGxvb3NlKSlcbm1vZHVsZS5leHBvcnRzID0gc29ydFxuIiwiY29uc3QgY29tcGFyZUJ1aWxkID0gcmVxdWlyZSgnLi9jb21wYXJlLWJ1aWxkJylcbmNvbnN0IHJzb3J0ID0gKGxpc3QsIGxvb3NlKSA9PiBsaXN0LnNvcnQoKGEsIGIpID0+IGNvbXBhcmVCdWlsZChiLCBhLCBsb29zZSkpXG5tb2R1bGUuZXhwb3J0cyA9IHJzb3J0XG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGd0ID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+IDBcbm1vZHVsZS5leHBvcnRzID0gZ3RcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbHQgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpIDwgMFxubW9kdWxlLmV4cG9ydHMgPSBsdFxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBlcSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPT09IDBcbm1vZHVsZS5leHBvcnRzID0gZXFcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbmVxID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSAhPT0gMFxubW9kdWxlLmV4cG9ydHMgPSBuZXFcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZ3RlID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGd0ZVxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBsdGUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpIDw9IDBcbm1vZHVsZS5leHBvcnRzID0gbHRlXG4iLCJjb25zdCBlcSA9IHJlcXVpcmUoJy4vZXEnKVxuY29uc3QgbmVxID0gcmVxdWlyZSgnLi9uZXEnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuL2d0JylcbmNvbnN0IGd0ZSA9IHJlcXVpcmUoJy4vZ3RlJylcbmNvbnN0IGx0ID0gcmVxdWlyZSgnLi9sdCcpXG5jb25zdCBsdGUgPSByZXF1aXJlKCcuL2x0ZScpXG5cbmNvbnN0IGNtcCA9IChhLCBvcCwgYiwgbG9vc2UpID0+IHtcbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgJz09PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGEgPSBhLnZlcnNpb25cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYiA9IGIudmVyc2lvblxuICAgICAgfVxuICAgICAgcmV0dXJuIGEgPT09IGJcblxuICAgIGNhc2UgJyE9PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGEgPSBhLnZlcnNpb25cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYiA9IGIudmVyc2lvblxuICAgICAgfVxuICAgICAgcmV0dXJuIGEgIT09IGJcblxuICAgIGNhc2UgJyc6XG4gICAgY2FzZSAnPSc6XG4gICAgY2FzZSAnPT0nOlxuICAgICAgcmV0dXJuIGVxKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnIT0nOlxuICAgICAgcmV0dXJuIG5lcShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJz4nOlxuICAgICAgcmV0dXJuIGd0KGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPj0nOlxuICAgICAgcmV0dXJuIGd0ZShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJzwnOlxuICAgICAgcmV0dXJuIGx0KGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPD0nOlxuICAgICAgcmV0dXJuIGx0ZShhLCBiLCBsb29zZSlcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIG9wZXJhdG9yOiAke29wfWApXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gY21wXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgeyBzYWZlUmU6IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IGNvZXJjZSA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgcmV0dXJuIHZlcnNpb25cbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ251bWJlcicpIHtcbiAgICB2ZXJzaW9uID0gU3RyaW5nKHZlcnNpb24pXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgbGV0IG1hdGNoID0gbnVsbFxuICBpZiAoIW9wdGlvbnMucnRsKSB7XG4gICAgbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKHJlW3QuQ09FUkNFXSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5kIHRoZSByaWdodC1tb3N0IGNvZXJjaWJsZSBzdHJpbmcgdGhhdCBkb2VzIG5vdCBzaGFyZVxuICAgIC8vIGEgdGVybWludXMgd2l0aCBhIG1vcmUgbGVmdC13YXJkIGNvZXJjaWJsZSBzdHJpbmcuXG4gICAgLy8gRWcsICcxLjIuMy40JyB3YW50cyB0byBjb2VyY2UgJzIuMy40Jywgbm90ICczLjQnIG9yICc0J1xuICAgIC8vXG4gICAgLy8gV2FsayB0aHJvdWdoIHRoZSBzdHJpbmcgY2hlY2tpbmcgd2l0aCBhIC9nIHJlZ2V4cFxuICAgIC8vIE1hbnVhbGx5IHNldCB0aGUgaW5kZXggc28gYXMgdG8gcGljayB1cCBvdmVybGFwcGluZyBtYXRjaGVzLlxuICAgIC8vIFN0b3Agd2hlbiB3ZSBnZXQgYSBtYXRjaCB0aGF0IGVuZHMgYXQgdGhlIHN0cmluZyBlbmQsIHNpbmNlIG5vXG4gICAgLy8gY29lcmNpYmxlIHN0cmluZyBjYW4gYmUgbW9yZSByaWdodC13YXJkIHdpdGhvdXQgdGhlIHNhbWUgdGVybWludXMuXG4gICAgbGV0IG5leHRcbiAgICB3aGlsZSAoKG5leHQgPSByZVt0LkNPRVJDRVJUTF0uZXhlYyh2ZXJzaW9uKSkgJiZcbiAgICAgICAgKCFtYXRjaCB8fCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCAhPT0gdmVyc2lvbi5sZW5ndGgpXG4gICAgKSB7XG4gICAgICBpZiAoIW1hdGNoIHx8XG4gICAgICAgICAgICBuZXh0LmluZGV4ICsgbmV4dFswXS5sZW5ndGggIT09IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSB7XG4gICAgICAgIG1hdGNoID0gbmV4dFxuICAgICAgfVxuICAgICAgcmVbdC5DT0VSQ0VSVExdLmxhc3RJbmRleCA9IG5leHQuaW5kZXggKyBuZXh0WzFdLmxlbmd0aCArIG5leHRbMl0ubGVuZ3RoXG4gICAgfVxuICAgIC8vIGxlYXZlIGl0IGluIGEgY2xlYW4gc3RhdGVcbiAgICByZVt0LkNPRVJDRVJUTF0ubGFzdEluZGV4ID0gLTFcbiAgfVxuXG4gIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4gcGFyc2UoYCR7bWF0Y2hbMl19LiR7bWF0Y2hbM10gfHwgJzAnfS4ke21hdGNoWzRdIHx8ICcwJ31gLCBvcHRpb25zKVxufVxubW9kdWxlLmV4cG9ydHMgPSBjb2VyY2VcbiIsIid1c2Ugc3RyaWN0J1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoWWFsbGlzdCkge1xuICBZYWxsaXN0LnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24qICgpIHtcbiAgICBmb3IgKGxldCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlcjsgd2Fsa2VyID0gd2Fsa2VyLm5leHQpIHtcbiAgICAgIHlpZWxkIHdhbGtlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IFlhbGxpc3RcblxuWWFsbGlzdC5Ob2RlID0gTm9kZVxuWWFsbGlzdC5jcmVhdGUgPSBZYWxsaXN0XG5cbmZ1bmN0aW9uIFlhbGxpc3QgKGxpc3QpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghKHNlbGYgaW5zdGFuY2VvZiBZYWxsaXN0KSkge1xuICAgIHNlbGYgPSBuZXcgWWFsbGlzdCgpXG4gIH1cblxuICBzZWxmLnRhaWwgPSBudWxsXG4gIHNlbGYuaGVhZCA9IG51bGxcbiAgc2VsZi5sZW5ndGggPSAwXG5cbiAgaWYgKGxpc3QgJiYgdHlwZW9mIGxpc3QuZm9yRWFjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgc2VsZi5wdXNoKGl0ZW0pXG4gICAgfSlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgc2VsZi5wdXNoKGFyZ3VtZW50c1tpXSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VsZlxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZW1vdmVOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUubGlzdCAhPT0gdGhpcykge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVtb3Zpbmcgbm9kZSB3aGljaCBkb2VzIG5vdCBiZWxvbmcgdG8gdGhpcyBsaXN0JylcbiAgfVxuXG4gIHZhciBuZXh0ID0gbm9kZS5uZXh0XG4gIHZhciBwcmV2ID0gbm9kZS5wcmV2XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0LnByZXYgPSBwcmV2XG4gIH1cblxuICBpZiAocHJldikge1xuICAgIHByZXYubmV4dCA9IG5leHRcbiAgfVxuXG4gIGlmIChub2RlID09PSB0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQgPSBuZXh0XG4gIH1cbiAgaWYgKG5vZGUgPT09IHRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbCA9IHByZXZcbiAgfVxuXG4gIG5vZGUubGlzdC5sZW5ndGgtLVxuICBub2RlLm5leHQgPSBudWxsXG4gIG5vZGUucHJldiA9IG51bGxcbiAgbm9kZS5saXN0ID0gbnVsbFxuXG4gIHJldHVybiBuZXh0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnVuc2hpZnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKG5vZGUubGlzdCkge1xuICAgIG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpXG4gIH1cblxuICB2YXIgaGVhZCA9IHRoaXMuaGVhZFxuICBub2RlLmxpc3QgPSB0aGlzXG4gIG5vZGUubmV4dCA9IGhlYWRcbiAgaWYgKGhlYWQpIHtcbiAgICBoZWFkLnByZXYgPSBub2RlXG4gIH1cblxuICB0aGlzLmhlYWQgPSBub2RlXG4gIGlmICghdGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsID0gbm9kZVxuICB9XG4gIHRoaXMubGVuZ3RoKytcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucHVzaE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAobm9kZS5saXN0KSB7XG4gICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSlcbiAgfVxuXG4gIHZhciB0YWlsID0gdGhpcy50YWlsXG4gIG5vZGUubGlzdCA9IHRoaXNcbiAgbm9kZS5wcmV2ID0gdGFpbFxuICBpZiAodGFpbCkge1xuICAgIHRhaWwubmV4dCA9IG5vZGVcbiAgfVxuXG4gIHRoaXMudGFpbCA9IG5vZGVcbiAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQgPSBub2RlXG4gIH1cbiAgdGhpcy5sZW5ndGgrK1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBwdXNoKHRoaXMsIGFyZ3VtZW50c1tpXSlcbiAgfVxuICByZXR1cm4gdGhpcy5sZW5ndGhcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdW5zaGlmdCh0aGlzLCBhcmd1bWVudHNbaV0pXG4gIH1cbiAgcmV0dXJuIHRoaXMubGVuZ3RoXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICB2YXIgcmVzID0gdGhpcy50YWlsLnZhbHVlXG4gIHRoaXMudGFpbCA9IHRoaXMudGFpbC5wcmV2XG4gIGlmICh0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwubmV4dCA9IG51bGxcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhlYWQgPSBudWxsXG4gIH1cbiAgdGhpcy5sZW5ndGgtLVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHZhciByZXMgPSB0aGlzLmhlYWQudmFsdWVcbiAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHRcbiAgaWYgKHRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZC5wcmV2ID0gbnVsbFxuICB9IGVsc2Uge1xuICAgIHRoaXMudGFpbCA9IG51bGxcbiAgfVxuICB0aGlzLmxlbmd0aC0tXG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMuaGVhZCwgaSA9IDA7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCBpLCB0aGlzKVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZm9yRWFjaFJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWwsIGkgPSB0aGlzLmxlbmd0aCAtIDE7IHdhbGtlciAhPT0gbnVsbDsgaS0tKSB7XG4gICAgZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCBpLCB0aGlzKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG4pIHtcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBuOyBpKyspIHtcbiAgICAvLyBhYm9ydCBvdXQgb2YgdGhlIGxpc3QgZWFybHkgaWYgd2UgaGl0IGEgY3ljbGVcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIGlmIChpID09PSBuICYmIHdhbGtlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB3YWxrZXIudmFsdWVcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5nZXRSZXZlcnNlID0gZnVuY3Rpb24gKG4pIHtcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBuOyBpKyspIHtcbiAgICAvLyBhYm9ydCBvdXQgb2YgdGhlIGxpc3QgZWFybHkgaWYgd2UgaGl0IGEgY3ljbGVcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIGlmIChpID09PSBuICYmIHdhbGtlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB3YWxrZXIudmFsdWVcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QoKVxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5tYXBSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgdmFyIHJlcyA9IG5ldyBZYWxsaXN0KClcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgcmVzLnB1c2goZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCB0aGlzKSlcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsKSB7XG4gIHZhciBhY2NcbiAgdmFyIHdhbGtlciA9IHRoaXMuaGVhZFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsXG4gIH0gZWxzZSBpZiAodGhpcy5oZWFkKSB7XG4gICAgd2Fsa2VyID0gdGhpcy5oZWFkLm5leHRcbiAgICBhY2MgPSB0aGlzLmhlYWQudmFsdWVcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYWNjID0gZm4oYWNjLCB3YWxrZXIudmFsdWUsIGkpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuXG4gIHJldHVybiBhY2Ncbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVkdWNlUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgaW5pdGlhbCkge1xuICB2YXIgYWNjXG4gIHZhciB3YWxrZXIgPSB0aGlzLnRhaWxcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgYWNjID0gaW5pdGlhbFxuICB9IGVsc2UgaWYgKHRoaXMudGFpbCkge1xuICAgIHdhbGtlciA9IHRoaXMudGFpbC5wcmV2XG4gICAgYWNjID0gdGhpcy50YWlsLnZhbHVlXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGxpc3Qgd2l0aCBubyBpbml0aWFsIHZhbHVlJylcbiAgfVxuXG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IHdhbGtlciAhPT0gbnVsbDsgaS0tKSB7XG4gICAgYWNjID0gZm4oYWNjLCB3YWxrZXIudmFsdWUsIGkpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuXG4gIHJldHVybiBhY2Ncbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhcnJbaV0gPSB3YWxrZXIudmFsdWVcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIHJldHVybiBhcnJcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudG9BcnJheVJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYXJyW2ldID0gd2Fsa2VyLnZhbHVlXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuICByZXR1cm4gYXJyXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gIHRvID0gdG8gfHwgdGhpcy5sZW5ndGhcbiAgaWYgKHRvIDwgMCkge1xuICAgIHRvICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZnJvbSA9IGZyb20gfHwgMFxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgdmFyIHJldCA9IG5ldyBZYWxsaXN0KClcbiAgaWYgKHRvIDwgZnJvbSB8fCB0byA8IDApIHtcbiAgICByZXR1cm4gcmV0XG4gIH1cbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSA9IDBcbiAgfVxuICBpZiAodG8gPiB0aGlzLmxlbmd0aCkge1xuICAgIHRvID0gdGhpcy5sZW5ndGhcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IGZyb207IGkrKykge1xuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgZm9yICg7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgdG87IGkrKywgd2Fsa2VyID0gd2Fsa2VyLm5leHQpIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5zbGljZVJldmVyc2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aFxuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICBmcm9tID0gZnJvbSB8fCAwXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKVxuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXRcbiAgfVxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tID0gMFxuICB9XG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGwgJiYgaSA+IHRvOyBpLS0pIHtcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIGZvciAoOyB3YWxrZXIgIT09IG51bGwgJiYgaSA+IGZyb207IGktLSwgd2Fsa2VyID0gd2Fsa2VyLnByZXYpIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5zcGxpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGRlbGV0ZUNvdW50LCAuLi5ub2Rlcykge1xuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGggLSAxXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGggKyBzdGFydDtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgc3RhcnQ7IGkrKykge1xuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cblxuICB2YXIgcmV0ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IHdhbGtlciAmJiBpIDwgZGVsZXRlQ291bnQ7IGkrKykge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgICB3YWxrZXIgPSB0aGlzLnJlbW92ZU5vZGUod2Fsa2VyKVxuICB9XG4gIGlmICh3YWxrZXIgPT09IG51bGwpIHtcbiAgICB3YWxrZXIgPSB0aGlzLnRhaWxcbiAgfVxuXG4gIGlmICh3YWxrZXIgIT09IHRoaXMuaGVhZCAmJiB3YWxrZXIgIT09IHRoaXMudGFpbCkge1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgd2Fsa2VyID0gaW5zZXJ0KHRoaXMsIHdhbGtlciwgbm9kZXNbaV0pXG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhlYWQgPSB0aGlzLmhlYWRcbiAgdmFyIHRhaWwgPSB0aGlzLnRhaWxcbiAgZm9yICh2YXIgd2Fsa2VyID0gaGVhZDsgd2Fsa2VyICE9PSBudWxsOyB3YWxrZXIgPSB3YWxrZXIucHJldikge1xuICAgIHZhciBwID0gd2Fsa2VyLnByZXZcbiAgICB3YWxrZXIucHJldiA9IHdhbGtlci5uZXh0XG4gICAgd2Fsa2VyLm5leHQgPSBwXG4gIH1cbiAgdGhpcy5oZWFkID0gdGFpbFxuICB0aGlzLnRhaWwgPSBoZWFkXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIGluc2VydCAoc2VsZiwgbm9kZSwgdmFsdWUpIHtcbiAgdmFyIGluc2VydGVkID0gbm9kZSA9PT0gc2VsZi5oZWFkID9cbiAgICBuZXcgTm9kZSh2YWx1ZSwgbnVsbCwgbm9kZSwgc2VsZikgOlxuICAgIG5ldyBOb2RlKHZhbHVlLCBub2RlLCBub2RlLm5leHQsIHNlbGYpXG5cbiAgaWYgKGluc2VydGVkLm5leHQgPT09IG51bGwpIHtcbiAgICBzZWxmLnRhaWwgPSBpbnNlcnRlZFxuICB9XG4gIGlmIChpbnNlcnRlZC5wcmV2ID09PSBudWxsKSB7XG4gICAgc2VsZi5oZWFkID0gaW5zZXJ0ZWRcbiAgfVxuXG4gIHNlbGYubGVuZ3RoKytcblxuICByZXR1cm4gaW5zZXJ0ZWRcbn1cblxuZnVuY3Rpb24gcHVzaCAoc2VsZiwgaXRlbSkge1xuICBzZWxmLnRhaWwgPSBuZXcgTm9kZShpdGVtLCBzZWxmLnRhaWwsIG51bGwsIHNlbGYpXG4gIGlmICghc2VsZi5oZWFkKSB7XG4gICAgc2VsZi5oZWFkID0gc2VsZi50YWlsXG4gIH1cbiAgc2VsZi5sZW5ndGgrK1xufVxuXG5mdW5jdGlvbiB1bnNoaWZ0IChzZWxmLCBpdGVtKSB7XG4gIHNlbGYuaGVhZCA9IG5ldyBOb2RlKGl0ZW0sIG51bGwsIHNlbGYuaGVhZCwgc2VsZilcbiAgaWYgKCFzZWxmLnRhaWwpIHtcbiAgICBzZWxmLnRhaWwgPSBzZWxmLmhlYWRcbiAgfVxuICBzZWxmLmxlbmd0aCsrXG59XG5cbmZ1bmN0aW9uIE5vZGUgKHZhbHVlLCBwcmV2LCBuZXh0LCBsaXN0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBOb2RlKSkge1xuICAgIHJldHVybiBuZXcgTm9kZSh2YWx1ZSwgcHJldiwgbmV4dCwgbGlzdClcbiAgfVxuXG4gIHRoaXMubGlzdCA9IGxpc3RcbiAgdGhpcy52YWx1ZSA9IHZhbHVlXG5cbiAgaWYgKHByZXYpIHtcbiAgICBwcmV2Lm5leHQgPSB0aGlzXG4gICAgdGhpcy5wcmV2ID0gcHJldlxuICB9IGVsc2Uge1xuICAgIHRoaXMucHJldiA9IG51bGxcbiAgfVxuXG4gIGlmIChuZXh0KSB7XG4gICAgbmV4dC5wcmV2ID0gdGhpc1xuICAgIHRoaXMubmV4dCA9IG5leHRcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5leHQgPSBudWxsXG4gIH1cbn1cblxudHJ5IHtcbiAgLy8gYWRkIGlmIHN1cHBvcnQgZm9yIFN5bWJvbC5pdGVyYXRvciBpcyBwcmVzZW50XG4gIHJlcXVpcmUoJy4vaXRlcmF0b3IuanMnKShZYWxsaXN0KVxufSBjYXRjaCAoZXIpIHt9XG4iLCIndXNlIHN0cmljdCdcblxuLy8gQSBsaW5rZWQgbGlzdCB0byBrZWVwIHRyYWNrIG9mIHJlY2VudGx5LXVzZWQtbmVzc1xuY29uc3QgWWFsbGlzdCA9IHJlcXVpcmUoJ3lhbGxpc3QnKVxuXG5jb25zdCBNQVggPSBTeW1ib2woJ21heCcpXG5jb25zdCBMRU5HVEggPSBTeW1ib2woJ2xlbmd0aCcpXG5jb25zdCBMRU5HVEhfQ0FMQ1VMQVRPUiA9IFN5bWJvbCgnbGVuZ3RoQ2FsY3VsYXRvcicpXG5jb25zdCBBTExPV19TVEFMRSA9IFN5bWJvbCgnYWxsb3dTdGFsZScpXG5jb25zdCBNQVhfQUdFID0gU3ltYm9sKCdtYXhBZ2UnKVxuY29uc3QgRElTUE9TRSA9IFN5bWJvbCgnZGlzcG9zZScpXG5jb25zdCBOT19ESVNQT1NFX09OX1NFVCA9IFN5bWJvbCgnbm9EaXNwb3NlT25TZXQnKVxuY29uc3QgTFJVX0xJU1QgPSBTeW1ib2woJ2xydUxpc3QnKVxuY29uc3QgQ0FDSEUgPSBTeW1ib2woJ2NhY2hlJylcbmNvbnN0IFVQREFURV9BR0VfT05fR0VUID0gU3ltYm9sKCd1cGRhdGVBZ2VPbkdldCcpXG5cbmNvbnN0IG5haXZlTGVuZ3RoID0gKCkgPT4gMVxuXG4vLyBscnVMaXN0IGlzIGEgeWFsbGlzdCB3aGVyZSB0aGUgaGVhZCBpcyB0aGUgeW91bmdlc3Rcbi8vIGl0ZW0sIGFuZCB0aGUgdGFpbCBpcyB0aGUgb2xkZXN0LiAgdGhlIGxpc3QgY29udGFpbnMgdGhlIEhpdFxuLy8gb2JqZWN0cyBhcyB0aGUgZW50cmllcy5cbi8vIEVhY2ggSGl0IG9iamVjdCBoYXMgYSByZWZlcmVuY2UgdG8gaXRzIFlhbGxpc3QuTm9kZS4gIFRoaXNcbi8vIG5ldmVyIGNoYW5nZXMuXG4vL1xuLy8gY2FjaGUgaXMgYSBNYXAgKG9yIFBzZXVkb01hcCkgdGhhdCBtYXRjaGVzIHRoZSBrZXlzIHRvXG4vLyB0aGUgWWFsbGlzdC5Ob2RlIG9iamVjdC5cbmNsYXNzIExSVUNhY2hlIHtcbiAgY29uc3RydWN0b3IgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKVxuICAgICAgb3B0aW9ucyA9IHsgbWF4OiBvcHRpb25zIH1cblxuICAgIGlmICghb3B0aW9ucylcbiAgICAgIG9wdGlvbnMgPSB7fVxuXG4gICAgaWYgKG9wdGlvbnMubWF4ICYmICh0eXBlb2Ygb3B0aW9ucy5tYXggIT09ICdudW1iZXInIHx8IG9wdGlvbnMubWF4IDwgMCkpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXggbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKVxuICAgIC8vIEtpbmQgb2Ygd2VpcmQgdG8gaGF2ZSBhIGRlZmF1bHQgbWF4IG9mIEluZmluaXR5LCBidXQgb2ggd2VsbC5cbiAgICBjb25zdCBtYXggPSB0aGlzW01BWF0gPSBvcHRpb25zLm1heCB8fCBJbmZpbml0eVxuXG4gICAgY29uc3QgbGMgPSBvcHRpb25zLmxlbmd0aCB8fCBuYWl2ZUxlbmd0aFxuICAgIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdID0gKHR5cGVvZiBsYyAhPT0gJ2Z1bmN0aW9uJykgPyBuYWl2ZUxlbmd0aCA6IGxjXG4gICAgdGhpc1tBTExPV19TVEFMRV0gPSBvcHRpb25zLnN0YWxlIHx8IGZhbHNlXG4gICAgaWYgKG9wdGlvbnMubWF4QWdlICYmIHR5cGVvZiBvcHRpb25zLm1heEFnZSAhPT0gJ251bWJlcicpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhBZ2UgbXVzdCBiZSBhIG51bWJlcicpXG4gICAgdGhpc1tNQVhfQUdFXSA9IG9wdGlvbnMubWF4QWdlIHx8IDBcbiAgICB0aGlzW0RJU1BPU0VdID0gb3B0aW9ucy5kaXNwb3NlXG4gICAgdGhpc1tOT19ESVNQT1NFX09OX1NFVF0gPSBvcHRpb25zLm5vRGlzcG9zZU9uU2V0IHx8IGZhbHNlXG4gICAgdGhpc1tVUERBVEVfQUdFX09OX0dFVF0gPSBvcHRpb25zLnVwZGF0ZUFnZU9uR2V0IHx8IGZhbHNlXG4gICAgdGhpcy5yZXNldCgpXG4gIH1cblxuICAvLyByZXNpemUgdGhlIGNhY2hlIHdoZW4gdGhlIG1heCBjaGFuZ2VzLlxuICBzZXQgbWF4IChtTCkge1xuICAgIGlmICh0eXBlb2YgbUwgIT09ICdudW1iZXInIHx8IG1MIDwgMClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpXG5cbiAgICB0aGlzW01BWF0gPSBtTCB8fCBJbmZpbml0eVxuICAgIHRyaW0odGhpcylcbiAgfVxuICBnZXQgbWF4ICgpIHtcbiAgICByZXR1cm4gdGhpc1tNQVhdXG4gIH1cblxuICBzZXQgYWxsb3dTdGFsZSAoYWxsb3dTdGFsZSkge1xuICAgIHRoaXNbQUxMT1dfU1RBTEVdID0gISFhbGxvd1N0YWxlXG4gIH1cbiAgZ2V0IGFsbG93U3RhbGUgKCkge1xuICAgIHJldHVybiB0aGlzW0FMTE9XX1NUQUxFXVxuICB9XG5cbiAgc2V0IG1heEFnZSAobUEpIHtcbiAgICBpZiAodHlwZW9mIG1BICE9PSAnbnVtYmVyJylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heEFnZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpXG5cbiAgICB0aGlzW01BWF9BR0VdID0gbUFcbiAgICB0cmltKHRoaXMpXG4gIH1cbiAgZ2V0IG1heEFnZSAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTUFYX0FHRV1cbiAgfVxuXG4gIC8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbGVuZ3RoQ2FsY3VsYXRvciBjaGFuZ2VzLlxuICBzZXQgbGVuZ3RoQ2FsY3VsYXRvciAobEMpIHtcbiAgICBpZiAodHlwZW9mIGxDICE9PSAnZnVuY3Rpb24nKVxuICAgICAgbEMgPSBuYWl2ZUxlbmd0aFxuXG4gICAgaWYgKGxDICE9PSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSkge1xuICAgICAgdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gPSBsQ1xuICAgICAgdGhpc1tMRU5HVEhdID0gMFxuICAgICAgdGhpc1tMUlVfTElTVF0uZm9yRWFjaChoaXQgPT4ge1xuICAgICAgICBoaXQubGVuZ3RoID0gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0oaGl0LnZhbHVlLCBoaXQua2V5KVxuICAgICAgICB0aGlzW0xFTkdUSF0gKz0gaGl0Lmxlbmd0aFxuICAgICAgfSlcbiAgICB9XG4gICAgdHJpbSh0aGlzKVxuICB9XG4gIGdldCBsZW5ndGhDYWxjdWxhdG9yICgpIHsgcmV0dXJuIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdIH1cblxuICBnZXQgbGVuZ3RoICgpIHsgcmV0dXJuIHRoaXNbTEVOR1RIXSB9XG4gIGdldCBpdGVtQ291bnQgKCkgeyByZXR1cm4gdGhpc1tMUlVfTElTVF0ubGVuZ3RoIH1cblxuICByZm9yRWFjaCAoZm4sIHRoaXNwKSB7XG4gICAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gICAgZm9yIChsZXQgd2Fsa2VyID0gdGhpc1tMUlVfTElTVF0udGFpbDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgICAgY29uc3QgcHJldiA9IHdhbGtlci5wcmV2XG4gICAgICBmb3JFYWNoU3RlcCh0aGlzLCBmbiwgd2Fsa2VyLCB0aGlzcClcbiAgICAgIHdhbGtlciA9IHByZXZcbiAgICB9XG4gIH1cblxuICBmb3JFYWNoIChmbiwgdGhpc3ApIHtcbiAgICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgICBmb3IgKGxldCB3YWxrZXIgPSB0aGlzW0xSVV9MSVNUXS5oZWFkOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICBjb25zdCBuZXh0ID0gd2Fsa2VyLm5leHRcbiAgICAgIGZvckVhY2hTdGVwKHRoaXMsIGZuLCB3YWxrZXIsIHRoaXNwKVxuICAgICAgd2Fsa2VyID0gbmV4dFxuICAgIH1cbiAgfVxuXG4gIGtleXMgKCkge1xuICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXS50b0FycmF5KCkubWFwKGsgPT4gay5rZXkpXG4gIH1cblxuICB2YWx1ZXMgKCkge1xuICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXS50b0FycmF5KCkubWFwKGsgPT4gay52YWx1ZSlcbiAgfVxuXG4gIHJlc2V0ICgpIHtcbiAgICBpZiAodGhpc1tESVNQT1NFXSAmJlxuICAgICAgICB0aGlzW0xSVV9MSVNUXSAmJlxuICAgICAgICB0aGlzW0xSVV9MSVNUXS5sZW5ndGgpIHtcbiAgICAgIHRoaXNbTFJVX0xJU1RdLmZvckVhY2goaGl0ID0+IHRoaXNbRElTUE9TRV0oaGl0LmtleSwgaGl0LnZhbHVlKSlcbiAgICB9XG5cbiAgICB0aGlzW0NBQ0hFXSA9IG5ldyBNYXAoKSAvLyBoYXNoIG9mIGl0ZW1zIGJ5IGtleVxuICAgIHRoaXNbTFJVX0xJU1RdID0gbmV3IFlhbGxpc3QoKSAvLyBsaXN0IG9mIGl0ZW1zIGluIG9yZGVyIG9mIHVzZSByZWNlbmN5XG4gICAgdGhpc1tMRU5HVEhdID0gMCAvLyBsZW5ndGggb2YgaXRlbXMgaW4gdGhlIGxpc3RcbiAgfVxuXG4gIGR1bXAgKCkge1xuICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXS5tYXAoaGl0ID0+XG4gICAgICBpc1N0YWxlKHRoaXMsIGhpdCkgPyBmYWxzZSA6IHtcbiAgICAgICAgazogaGl0LmtleSxcbiAgICAgICAgdjogaGl0LnZhbHVlLFxuICAgICAgICBlOiBoaXQubm93ICsgKGhpdC5tYXhBZ2UgfHwgMClcbiAgICAgIH0pLnRvQXJyYXkoKS5maWx0ZXIoaCA9PiBoKVxuICB9XG5cbiAgZHVtcExydSAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdXG4gIH1cblxuICBzZXQgKGtleSwgdmFsdWUsIG1heEFnZSkge1xuICAgIG1heEFnZSA9IG1heEFnZSB8fCB0aGlzW01BWF9BR0VdXG5cbiAgICBpZiAobWF4QWdlICYmIHR5cGVvZiBtYXhBZ2UgIT09ICdudW1iZXInKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4QWdlIG11c3QgYmUgYSBudW1iZXInKVxuXG4gICAgY29uc3Qgbm93ID0gbWF4QWdlID8gRGF0ZS5ub3coKSA6IDBcbiAgICBjb25zdCBsZW4gPSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSh2YWx1ZSwga2V5KVxuXG4gICAgaWYgKHRoaXNbQ0FDSEVdLmhhcyhrZXkpKSB7XG4gICAgICBpZiAobGVuID4gdGhpc1tNQVhdKSB7XG4gICAgICAgIGRlbCh0aGlzLCB0aGlzW0NBQ0hFXS5nZXQoa2V5KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzW0NBQ0hFXS5nZXQoa2V5KVxuICAgICAgY29uc3QgaXRlbSA9IG5vZGUudmFsdWVcblxuICAgICAgLy8gZGlzcG9zZSBvZiB0aGUgb2xkIG9uZSBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgICAgIC8vIHNwbGl0IG91dCBpbnRvIDIgaWZzIGZvciBiZXR0ZXIgY292ZXJhZ2UgdHJhY2tpbmdcbiAgICAgIGlmICh0aGlzW0RJU1BPU0VdKSB7XG4gICAgICAgIGlmICghdGhpc1tOT19ESVNQT1NFX09OX1NFVF0pXG4gICAgICAgICAgdGhpc1tESVNQT1NFXShrZXksIGl0ZW0udmFsdWUpXG4gICAgICB9XG5cbiAgICAgIGl0ZW0ubm93ID0gbm93XG4gICAgICBpdGVtLm1heEFnZSA9IG1heEFnZVxuICAgICAgaXRlbS52YWx1ZSA9IHZhbHVlXG4gICAgICB0aGlzW0xFTkdUSF0gKz0gbGVuIC0gaXRlbS5sZW5ndGhcbiAgICAgIGl0ZW0ubGVuZ3RoID0gbGVuXG4gICAgICB0aGlzLmdldChrZXkpXG4gICAgICB0cmltKHRoaXMpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IGhpdCA9IG5ldyBFbnRyeShrZXksIHZhbHVlLCBsZW4sIG5vdywgbWF4QWdlKVxuXG4gICAgLy8gb3ZlcnNpemVkIG9iamVjdHMgZmFsbCBvdXQgb2YgY2FjaGUgYXV0b21hdGljYWxseS5cbiAgICBpZiAoaGl0Lmxlbmd0aCA+IHRoaXNbTUFYXSkge1xuICAgICAgaWYgKHRoaXNbRElTUE9TRV0pXG4gICAgICAgIHRoaXNbRElTUE9TRV0oa2V5LCB2YWx1ZSlcblxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdGhpc1tMRU5HVEhdICs9IGhpdC5sZW5ndGhcbiAgICB0aGlzW0xSVV9MSVNUXS51bnNoaWZ0KGhpdClcbiAgICB0aGlzW0NBQ0hFXS5zZXQoa2V5LCB0aGlzW0xSVV9MSVNUXS5oZWFkKVxuICAgIHRyaW0odGhpcylcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaGFzIChrZXkpIHtcbiAgICBpZiAoIXRoaXNbQ0FDSEVdLmhhcyhrZXkpKSByZXR1cm4gZmFsc2VcbiAgICBjb25zdCBoaXQgPSB0aGlzW0NBQ0hFXS5nZXQoa2V5KS52YWx1ZVxuICAgIHJldHVybiAhaXNTdGFsZSh0aGlzLCBoaXQpXG4gIH1cblxuICBnZXQgKGtleSkge1xuICAgIHJldHVybiBnZXQodGhpcywga2V5LCB0cnVlKVxuICB9XG5cbiAgcGVlayAoa2V5KSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBrZXksIGZhbHNlKVxuICB9XG5cbiAgcG9wICgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpc1tMUlVfTElTVF0udGFpbFxuICAgIGlmICghbm9kZSlcbiAgICAgIHJldHVybiBudWxsXG5cbiAgICBkZWwodGhpcywgbm9kZSlcbiAgICByZXR1cm4gbm9kZS52YWx1ZVxuICB9XG5cbiAgZGVsIChrZXkpIHtcbiAgICBkZWwodGhpcywgdGhpc1tDQUNIRV0uZ2V0KGtleSkpXG4gIH1cblxuICBsb2FkIChhcnIpIHtcbiAgICAvLyByZXNldCB0aGUgY2FjaGVcbiAgICB0aGlzLnJlc2V0KClcblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KClcbiAgICAvLyBBIHByZXZpb3VzIHNlcmlhbGl6ZWQgY2FjaGUgaGFzIHRoZSBtb3N0IHJlY2VudCBpdGVtcyBmaXJzdFxuICAgIGZvciAobGV0IGwgPSBhcnIubGVuZ3RoIC0gMTsgbCA+PSAwOyBsLS0pIHtcbiAgICAgIGNvbnN0IGhpdCA9IGFycltsXVxuICAgICAgY29uc3QgZXhwaXJlc0F0ID0gaGl0LmUgfHwgMFxuICAgICAgaWYgKGV4cGlyZXNBdCA9PT0gMClcbiAgICAgICAgLy8gdGhlIGl0ZW0gd2FzIGNyZWF0ZWQgd2l0aG91dCBleHBpcmF0aW9uIGluIGEgbm9uIGFnZWQgY2FjaGVcbiAgICAgICAgdGhpcy5zZXQoaGl0LmssIGhpdC52KVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG1heEFnZSA9IGV4cGlyZXNBdCAtIG5vd1xuICAgICAgICAvLyBkb250IGFkZCBhbHJlYWR5IGV4cGlyZWQgaXRlbXNcbiAgICAgICAgaWYgKG1heEFnZSA+IDApIHtcbiAgICAgICAgICB0aGlzLnNldChoaXQuaywgaGl0LnYsIG1heEFnZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBydW5lICgpIHtcbiAgICB0aGlzW0NBQ0hFXS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiBnZXQodGhpcywga2V5LCBmYWxzZSkpXG4gIH1cbn1cblxuY29uc3QgZ2V0ID0gKHNlbGYsIGtleSwgZG9Vc2UpID0+IHtcbiAgY29uc3Qgbm9kZSA9IHNlbGZbQ0FDSEVdLmdldChrZXkpXG4gIGlmIChub2RlKSB7XG4gICAgY29uc3QgaGl0ID0gbm9kZS52YWx1ZVxuICAgIGlmIChpc1N0YWxlKHNlbGYsIGhpdCkpIHtcbiAgICAgIGRlbChzZWxmLCBub2RlKVxuICAgICAgaWYgKCFzZWxmW0FMTE9XX1NUQUxFXSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZG9Vc2UpIHtcbiAgICAgICAgaWYgKHNlbGZbVVBEQVRFX0FHRV9PTl9HRVRdKVxuICAgICAgICAgIG5vZGUudmFsdWUubm93ID0gRGF0ZS5ub3coKVxuICAgICAgICBzZWxmW0xSVV9MSVNUXS51bnNoaWZ0Tm9kZShub2RlKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGl0LnZhbHVlXG4gIH1cbn1cblxuY29uc3QgaXNTdGFsZSA9IChzZWxmLCBoaXQpID0+IHtcbiAgaWYgKCFoaXQgfHwgKCFoaXQubWF4QWdlICYmICFzZWxmW01BWF9BR0VdKSlcbiAgICByZXR1cm4gZmFsc2VcblxuICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIGhpdC5ub3dcbiAgcmV0dXJuIGhpdC5tYXhBZ2UgPyBkaWZmID4gaGl0Lm1heEFnZVxuICAgIDogc2VsZltNQVhfQUdFXSAmJiAoZGlmZiA+IHNlbGZbTUFYX0FHRV0pXG59XG5cbmNvbnN0IHRyaW0gPSBzZWxmID0+IHtcbiAgaWYgKHNlbGZbTEVOR1RIXSA+IHNlbGZbTUFYXSkge1xuICAgIGZvciAobGV0IHdhbGtlciA9IHNlbGZbTFJVX0xJU1RdLnRhaWw7XG4gICAgICBzZWxmW0xFTkdUSF0gPiBzZWxmW01BWF0gJiYgd2Fsa2VyICE9PSBudWxsOykge1xuICAgICAgLy8gV2Uga25vdyB0aGF0IHdlJ3JlIGFib3V0IHRvIGRlbGV0ZSB0aGlzIG9uZSwgYW5kIGFsc29cbiAgICAgIC8vIHdoYXQgdGhlIG5leHQgbGVhc3QgcmVjZW50bHkgdXNlZCBrZXkgd2lsbCBiZSwgc28ganVzdFxuICAgICAgLy8gZ28gYWhlYWQgYW5kIHNldCBpdCBub3cuXG4gICAgICBjb25zdCBwcmV2ID0gd2Fsa2VyLnByZXZcbiAgICAgIGRlbChzZWxmLCB3YWxrZXIpXG4gICAgICB3YWxrZXIgPSBwcmV2XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGRlbCA9IChzZWxmLCBub2RlKSA9PiB7XG4gIGlmIChub2RlKSB7XG4gICAgY29uc3QgaGl0ID0gbm9kZS52YWx1ZVxuICAgIGlmIChzZWxmW0RJU1BPU0VdKVxuICAgICAgc2VsZltESVNQT1NFXShoaXQua2V5LCBoaXQudmFsdWUpXG5cbiAgICBzZWxmW0xFTkdUSF0gLT0gaGl0Lmxlbmd0aFxuICAgIHNlbGZbQ0FDSEVdLmRlbGV0ZShoaXQua2V5KVxuICAgIHNlbGZbTFJVX0xJU1RdLnJlbW92ZU5vZGUobm9kZSlcbiAgfVxufVxuXG5jbGFzcyBFbnRyeSB7XG4gIGNvbnN0cnVjdG9yIChrZXksIHZhbHVlLCBsZW5ndGgsIG5vdywgbWF4QWdlKSB7XG4gICAgdGhpcy5rZXkgPSBrZXlcbiAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aFxuICAgIHRoaXMubm93ID0gbm93XG4gICAgdGhpcy5tYXhBZ2UgPSBtYXhBZ2UgfHwgMFxuICB9XG59XG5cbmNvbnN0IGZvckVhY2hTdGVwID0gKHNlbGYsIGZuLCBub2RlLCB0aGlzcCkgPT4ge1xuICBsZXQgaGl0ID0gbm9kZS52YWx1ZVxuICBpZiAoaXNTdGFsZShzZWxmLCBoaXQpKSB7XG4gICAgZGVsKHNlbGYsIG5vZGUpXG4gICAgaWYgKCFzZWxmW0FMTE9XX1NUQUxFXSlcbiAgICAgIGhpdCA9IHVuZGVmaW5lZFxuICB9XG4gIGlmIChoaXQpXG4gICAgZm4uY2FsbCh0aGlzcCwgaGl0LnZhbHVlLCBoaXQua2V5LCBzZWxmKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExSVUNhY2hlXG4iLCIvLyBob2lzdGVkIGNsYXNzIGZvciBjeWNsaWMgZGVwZW5kZW5jeVxuY2xhc3MgUmFuZ2Uge1xuICBjb25zdHJ1Y3RvciAocmFuZ2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkge1xuICAgICAgaWYgKFxuICAgICAgICByYW5nZS5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlICYmXG4gICAgICAgIHJhbmdlLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gcmFuZ2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UucmF3LCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICAgIC8vIGp1c3QgcHV0IGl0IGluIHRoZSBzZXQgYW5kIHJldHVyblxuICAgICAgdGhpcy5yYXcgPSByYW5nZS52YWx1ZVxuICAgICAgdGhpcy5zZXQgPSBbW3JhbmdlXV1cbiAgICAgIHRoaXMuZm9ybWF0KClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgICB0aGlzLmluY2x1ZGVQcmVyZWxlYXNlID0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlXG5cbiAgICAvLyBGaXJzdCByZWR1Y2UgYWxsIHdoaXRlc3BhY2UgYXMgbXVjaCBhcyBwb3NzaWJsZSBzbyB3ZSBkbyBub3QgaGF2ZSB0byByZWx5XG4gICAgLy8gb24gcG90ZW50aWFsbHkgc2xvdyByZWdleGVzIGxpa2UgXFxzKi4gVGhpcyBpcyB0aGVuIHN0b3JlZCBhbmQgdXNlZCBmb3JcbiAgICAvLyBmdXR1cmUgZXJyb3IgbWVzc2FnZXMgYXMgd2VsbC5cbiAgICB0aGlzLnJhdyA9IHJhbmdlXG4gICAgICAudHJpbSgpXG4gICAgICAuc3BsaXQoL1xccysvKVxuICAgICAgLmpvaW4oJyAnKVxuXG4gICAgLy8gRmlyc3QsIHNwbGl0IG9uIHx8XG4gICAgdGhpcy5zZXQgPSB0aGlzLnJhd1xuICAgICAgLnNwbGl0KCd8fCcpXG4gICAgICAvLyBtYXAgdGhlIHJhbmdlIHRvIGEgMmQgYXJyYXkgb2YgY29tcGFyYXRvcnNcbiAgICAgIC5tYXAociA9PiB0aGlzLnBhcnNlUmFuZ2UocikpXG4gICAgICAvLyB0aHJvdyBvdXQgYW55IGNvbXBhcmF0b3IgbGlzdHMgdGhhdCBhcmUgZW1wdHlcbiAgICAgIC8vIHRoaXMgZ2VuZXJhbGx5IG1lYW5zIHRoYXQgaXQgd2FzIG5vdCBhIHZhbGlkIHJhbmdlLCB3aGljaCBpcyBhbGxvd2VkXG4gICAgICAvLyBpbiBsb29zZSBtb2RlLCBidXQgd2lsbCBzdGlsbCB0aHJvdyBpZiB0aGUgV0hPTEUgcmFuZ2UgaXMgaW52YWxpZC5cbiAgICAgIC5maWx0ZXIoYyA9PiBjLmxlbmd0aClcblxuICAgIGlmICghdGhpcy5zZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFNlbVZlciBSYW5nZTogJHt0aGlzLnJhd31gKVxuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmUgYW55IHRoYXQgYXJlIG5vdCB0aGUgbnVsbCBzZXQsIHRocm93IG91dCBudWxsIHNldHMuXG4gICAgaWYgKHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIGtlZXAgdGhlIGZpcnN0IG9uZSwgaW4gY2FzZSB0aGV5J3JlIGFsbCBudWxsIHNldHNcbiAgICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5zZXRbMF1cbiAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXQuZmlsdGVyKGMgPT4gIWlzTnVsbFNldChjWzBdKSlcbiAgICAgIGlmICh0aGlzLnNldC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5zZXQgPSBbZmlyc3RdXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhbnkgdGhhdCBhcmUgKiwgdGhlbiB0aGUgcmFuZ2UgaXMganVzdCAqXG4gICAgICAgIGZvciAoY29uc3QgYyBvZiB0aGlzLnNldCkge1xuICAgICAgICAgIGlmIChjLmxlbmd0aCA9PT0gMSAmJiBpc0FueShjWzBdKSkge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSBbY11cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5mb3JtYXQoKVxuICB9XG5cbiAgZm9ybWF0ICgpIHtcbiAgICB0aGlzLnJhbmdlID0gdGhpcy5zZXRcbiAgICAgIC5tYXAoKGNvbXBzKSA9PiBjb21wcy5qb2luKCcgJykudHJpbSgpKVxuICAgICAgLmpvaW4oJ3x8JylcbiAgICAgIC50cmltKClcbiAgICByZXR1cm4gdGhpcy5yYW5nZVxuICB9XG5cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLnJhbmdlXG4gIH1cblxuICBwYXJzZVJhbmdlIChyYW5nZSkge1xuICAgIC8vIG1lbW9pemUgcmFuZ2UgcGFyc2luZyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgLy8gdGhpcyBpcyBhIHZlcnkgaG90IHBhdGgsIGFuZCBmdWxseSBkZXRlcm1pbmlzdGljLlxuICAgIGNvbnN0IG1lbW9PcHRzID1cbiAgICAgICh0aGlzLm9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiYgRkxBR19JTkNMVURFX1BSRVJFTEVBU0UpIHxcbiAgICAgICh0aGlzLm9wdGlvbnMubG9vc2UgJiYgRkxBR19MT09TRSlcbiAgICBjb25zdCBtZW1vS2V5ID0gbWVtb09wdHMgKyAnOicgKyByYW5nZVxuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChtZW1vS2V5KVxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWRcbiAgICB9XG5cbiAgICBjb25zdCBsb29zZSA9IHRoaXMub3B0aW9ucy5sb29zZVxuICAgIC8vIGAxLjIuMyAtIDEuMi40YCA9PiBgPj0xLjIuMyA8PTEuMi40YFxuICAgIGNvbnN0IGhyID0gbG9vc2UgPyByZVt0LkhZUEhFTlJBTkdFTE9PU0VdIDogcmVbdC5IWVBIRU5SQU5HRV1cbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UoaHIsIGh5cGhlblJlcGxhY2UodGhpcy5vcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSlcbiAgICBkZWJ1ZygnaHlwaGVuIHJlcGxhY2UnLCByYW5nZSlcblxuICAgIC8vIGA+IDEuMi4zIDwgMS4yLjVgID0+IGA+MS4yLjMgPDEuMi41YFxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LkNPTVBBUkFUT1JUUklNXSwgY29tcGFyYXRvclRyaW1SZXBsYWNlKVxuICAgIGRlYnVnKCdjb21wYXJhdG9yIHRyaW0nLCByYW5nZSlcblxuICAgIC8vIGB+IDEuMi4zYCA9PiBgfjEuMi4zYFxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LlRJTERFVFJJTV0sIHRpbGRlVHJpbVJlcGxhY2UpXG4gICAgZGVidWcoJ3RpbGRlIHRyaW0nLCByYW5nZSlcblxuICAgIC8vIGBeIDEuMi4zYCA9PiBgXjEuMi4zYFxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LkNBUkVUVFJJTV0sIGNhcmV0VHJpbVJlcGxhY2UpXG4gICAgZGVidWcoJ2NhcmV0IHRyaW0nLCByYW5nZSlcblxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByYW5nZSBpcyBjb21wbGV0ZWx5IHRyaW1tZWQgYW5kXG4gICAgLy8gcmVhZHkgdG8gYmUgc3BsaXQgaW50byBjb21wYXJhdG9ycy5cblxuICAgIGxldCByYW5nZUxpc3QgPSByYW5nZVxuICAgICAgLnNwbGl0KCcgJylcbiAgICAgIC5tYXAoY29tcCA9PiBwYXJzZUNvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKSlcbiAgICAgIC5qb2luKCcgJylcbiAgICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgICAvLyA+PTAuMC4wIGlzIGVxdWl2YWxlbnQgdG8gKlxuICAgICAgLm1hcChjb21wID0+IHJlcGxhY2VHVEUwKGNvbXAsIHRoaXMub3B0aW9ucykpXG5cbiAgICBpZiAobG9vc2UpIHtcbiAgICAgIC8vIGluIGxvb3NlIG1vZGUsIHRocm93IG91dCBhbnkgdGhhdCBhcmUgbm90IHZhbGlkIGNvbXBhcmF0b3JzXG4gICAgICByYW5nZUxpc3QgPSByYW5nZUxpc3QuZmlsdGVyKGNvbXAgPT4ge1xuICAgICAgICBkZWJ1ZygnbG9vc2UgaW52YWxpZCBmaWx0ZXInLCBjb21wLCB0aGlzLm9wdGlvbnMpXG4gICAgICAgIHJldHVybiAhIWNvbXAubWF0Y2gocmVbdC5DT01QQVJBVE9STE9PU0VdKVxuICAgICAgfSlcbiAgICB9XG4gICAgZGVidWcoJ3JhbmdlIGxpc3QnLCByYW5nZUxpc3QpXG5cbiAgICAvLyBpZiBhbnkgY29tcGFyYXRvcnMgYXJlIHRoZSBudWxsIHNldCwgdGhlbiByZXBsYWNlIHdpdGggSlVTVCBudWxsIHNldFxuICAgIC8vIGlmIG1vcmUgdGhhbiBvbmUgY29tcGFyYXRvciwgcmVtb3ZlIGFueSAqIGNvbXBhcmF0b3JzXG4gICAgLy8gYWxzbywgZG9uJ3QgaW5jbHVkZSB0aGUgc2FtZSBjb21wYXJhdG9yIG1vcmUgdGhhbiBvbmNlXG4gICAgY29uc3QgcmFuZ2VNYXAgPSBuZXcgTWFwKClcbiAgICBjb25zdCBjb21wYXJhdG9ycyA9IHJhbmdlTGlzdC5tYXAoY29tcCA9PiBuZXcgQ29tcGFyYXRvcihjb21wLCB0aGlzLm9wdGlvbnMpKVxuICAgIGZvciAoY29uc3QgY29tcCBvZiBjb21wYXJhdG9ycykge1xuICAgICAgaWYgKGlzTnVsbFNldChjb21wKSkge1xuICAgICAgICByZXR1cm4gW2NvbXBdXG4gICAgICB9XG4gICAgICByYW5nZU1hcC5zZXQoY29tcC52YWx1ZSwgY29tcClcbiAgICB9XG4gICAgaWYgKHJhbmdlTWFwLnNpemUgPiAxICYmIHJhbmdlTWFwLmhhcygnJykpIHtcbiAgICAgIHJhbmdlTWFwLmRlbGV0ZSgnJylcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBbLi4ucmFuZ2VNYXAudmFsdWVzKCldXG4gICAgY2FjaGUuc2V0KG1lbW9LZXksIHJlc3VsdClcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBpbnRlcnNlY3RzIChyYW5nZSwgb3B0aW9ucykge1xuICAgIGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIFJhbmdlIGlzIHJlcXVpcmVkJylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXQuc29tZSgodGhpc0NvbXBhcmF0b3JzKSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBpc1NhdGlzZmlhYmxlKHRoaXNDb21wYXJhdG9ycywgb3B0aW9ucykgJiZcbiAgICAgICAgcmFuZ2Uuc2V0LnNvbWUoKHJhbmdlQ29tcGFyYXRvcnMpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXNTYXRpc2ZpYWJsZShyYW5nZUNvbXBhcmF0b3JzLCBvcHRpb25zKSAmJlxuICAgICAgICAgICAgdGhpc0NvbXBhcmF0b3JzLmV2ZXJ5KCh0aGlzQ29tcGFyYXRvcikgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VDb21wYXJhdG9ycy5ldmVyeSgocmFuZ2VDb21wYXJhdG9yKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNDb21wYXJhdG9yLmludGVyc2VjdHMocmFuZ2VDb21wYXJhdG9yLCBvcHRpb25zKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfSlcbiAgfVxuXG4gIC8vIGlmIEFOWSBvZiB0aGUgc2V0cyBtYXRjaCBBTEwgb2YgaXRzIGNvbXBhcmF0b3JzLCB0aGVuIHBhc3NcbiAgdGVzdCAodmVyc2lvbikge1xuICAgIGlmICghdmVyc2lvbikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNldC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRlc3RTZXQodGhpcy5zZXRbaV0sIHZlcnNpb24sIHRoaXMub3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSYW5nZVxuXG5jb25zdCBMUlUgPSByZXF1aXJlKCdscnUtY2FjaGUnKVxuY29uc3QgY2FjaGUgPSBuZXcgTFJVKHsgbWF4OiAxMDAwIH0pXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4vY29tcGFyYXRvcicpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4vc2VtdmVyJylcbmNvbnN0IHtcbiAgc2FmZVJlOiByZSxcbiAgdCxcbiAgY29tcGFyYXRvclRyaW1SZXBsYWNlLFxuICB0aWxkZVRyaW1SZXBsYWNlLFxuICBjYXJldFRyaW1SZXBsYWNlLFxufSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcbmNvbnN0IHsgRkxBR19JTkNMVURFX1BSRVJFTEVBU0UsIEZMQUdfTE9PU0UgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NvbnN0YW50cycpXG5cbmNvbnN0IGlzTnVsbFNldCA9IGMgPT4gYy52YWx1ZSA9PT0gJzwwLjAuMC0wJ1xuY29uc3QgaXNBbnkgPSBjID0+IGMudmFsdWUgPT09ICcnXG5cbi8vIHRha2UgYSBzZXQgb2YgY29tcGFyYXRvcnMgYW5kIGRldGVybWluZSB3aGV0aGVyIHRoZXJlXG4vLyBleGlzdHMgYSB2ZXJzaW9uIHdoaWNoIGNhbiBzYXRpc2Z5IGl0XG5jb25zdCBpc1NhdGlzZmlhYmxlID0gKGNvbXBhcmF0b3JzLCBvcHRpb25zKSA9PiB7XG4gIGxldCByZXN1bHQgPSB0cnVlXG4gIGNvbnN0IHJlbWFpbmluZ0NvbXBhcmF0b3JzID0gY29tcGFyYXRvcnMuc2xpY2UoKVxuICBsZXQgdGVzdENvbXBhcmF0b3IgPSByZW1haW5pbmdDb21wYXJhdG9ycy5wb3AoKVxuXG4gIHdoaWxlIChyZXN1bHQgJiYgcmVtYWluaW5nQ29tcGFyYXRvcnMubGVuZ3RoKSB7XG4gICAgcmVzdWx0ID0gcmVtYWluaW5nQ29tcGFyYXRvcnMuZXZlcnkoKG90aGVyQ29tcGFyYXRvcikgPT4ge1xuICAgICAgcmV0dXJuIHRlc3RDb21wYXJhdG9yLmludGVyc2VjdHMob3RoZXJDb21wYXJhdG9yLCBvcHRpb25zKVxuICAgIH0pXG5cbiAgICB0ZXN0Q29tcGFyYXRvciA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLnBvcCgpXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIGNvbXByaXNlZCBvZiB4cmFuZ2VzLCB0aWxkZXMsIHN0YXJzLCBhbmQgZ3RsdCdzIGF0IHRoaXMgcG9pbnQuXG4vLyBhbHJlYWR5IHJlcGxhY2VkIHRoZSBoeXBoZW4gcmFuZ2VzXG4vLyB0dXJuIGludG8gYSBzZXQgb2YgSlVTVCBjb21wYXJhdG9ycy5cbmNvbnN0IHBhcnNlQ29tcGFyYXRvciA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdjb21wJywgY29tcCwgb3B0aW9ucylcbiAgY29tcCA9IHJlcGxhY2VDYXJldHMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ2NhcmV0JywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VUaWxkZXMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3RpbGRlcycsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlWFJhbmdlcyhjb21wLCBvcHRpb25zKVxuICBkZWJ1ZygneHJhbmdlJywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VTdGFycyhjb21wLCBvcHRpb25zKVxuICBkZWJ1Zygnc3RhcnMnLCBjb21wKVxuICByZXR1cm4gY29tcFxufVxuXG5jb25zdCBpc1ggPSBpZCA9PiAhaWQgfHwgaWQudG9Mb3dlckNhc2UoKSA9PT0gJ3gnIHx8IGlkID09PSAnKidcblxuLy8gfiwgfj4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyB+MiwgfjIueCwgfjIueC54LCB+PjIsIH4+Mi54IH4+Mi54LnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIH4yLjAsIH4yLjAueCwgfj4yLjAsIH4+Mi4wLnggLS0+ID49Mi4wLjAgPDIuMS4wLTBcbi8vIH4xLjIsIH4xLjIueCwgfj4xLjIsIH4+MS4yLnggLS0+ID49MS4yLjAgPDEuMy4wLTBcbi8vIH4xLjIuMywgfj4xLjIuMyAtLT4gPj0xLjIuMyA8MS4zLjAtMFxuLy8gfjEuMi4wLCB+PjEuMi4wIC0tPiA+PTEuMi4wIDwxLjMuMC0wXG4vLyB+MC4wLjEgLS0+ID49MC4wLjEgPDAuMS4wLTBcbmNvbnN0IHJlcGxhY2VUaWxkZXMgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICByZXR1cm4gY29tcFxuICAgIC50cmltKClcbiAgICAuc3BsaXQoL1xccysvKVxuICAgIC5tYXAoKGMpID0+IHJlcGxhY2VUaWxkZShjLCBvcHRpb25zKSlcbiAgICAuam9pbignICcpXG59XG5cbmNvbnN0IHJlcGxhY2VUaWxkZSA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5USUxERUxPT1NFXSA6IHJlW3QuVElMREVdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKF8sIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ3RpbGRlJywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgbGV0IHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAgPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKGlzWChwKSkge1xuICAgICAgLy8gfjEuMiA9PSA+PTEuMi4wIDwxLjMuMC0wXG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uMCA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlVGlsZGUgcHInLCBwcilcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gfjEuMi4zID09ID49MS4yLjMgPDEuMy4wLTBcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9XG5cbiAgICBkZWJ1ZygndGlsZGUgcmV0dXJuJywgcmV0KVxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuLy8gXiAtLT4gKiAoYW55LCBraW5kYSBzaWxseSlcbi8vIF4yLCBeMi54LCBeMi54LnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIF4yLjAsIF4yLjAueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuLy8gXjEuMiwgXjEuMi54IC0tPiA+PTEuMi4wIDwyLjAuMC0wXG4vLyBeMS4yLjMgLS0+ID49MS4yLjMgPDIuMC4wLTBcbi8vIF4xLjIuMCAtLT4gPj0xLjIuMCA8Mi4wLjAtMFxuLy8gXjAuMC4xIC0tPiA+PTAuMC4xIDwwLjAuMi0wXG4vLyBeMC4xLjAgLS0+ID49MC4xLjAgPDAuMi4wLTBcbmNvbnN0IHJlcGxhY2VDYXJldHMgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICByZXR1cm4gY29tcFxuICAgIC50cmltKClcbiAgICAuc3BsaXQoL1xccysvKVxuICAgIC5tYXAoKGMpID0+IHJlcGxhY2VDYXJldChjLCBvcHRpb25zKSlcbiAgICAuam9pbignICcpXG59XG5cbmNvbnN0IHJlcGxhY2VDYXJldCA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdjYXJldCcsIGNvbXAsIG9wdGlvbnMpXG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5DQVJFVExPT1NFXSA6IHJlW3QuQ0FSRVRdXG4gIGNvbnN0IHogPSBvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gJy0wJyA6ICcnXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKF8sIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ2NhcmV0JywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgbGV0IHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAke3p9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgfSBlbHNlIGlmIChpc1gocCkpIHtcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3p9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7en0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZUNhcmV0IHByJywgcHIpXG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICAgICAgfSA8JHtNfS4ke219LiR7K3AgKyAxfS0wYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Zygnbm8gcHInKVxuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICAgIH0ke3p9IDwke019LiR7bX0uJHsrcCArIDF9LTBgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICAgIH0ke3p9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgICAgfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH1cblxuICAgIGRlYnVnKCdjYXJldCByZXR1cm4nLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG5jb25zdCByZXBsYWNlWFJhbmdlcyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlWFJhbmdlcycsIGNvbXAsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wXG4gICAgLnNwbGl0KC9cXHMrLylcbiAgICAubWFwKChjKSA9PiByZXBsYWNlWFJhbmdlKGMsIG9wdGlvbnMpKVxuICAgIC5qb2luKCcgJylcbn1cblxuY29uc3QgcmVwbGFjZVhSYW5nZSA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGNvbXAgPSBjb21wLnRyaW0oKVxuICBjb25zdCByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuWFJBTkdFTE9PU0VdIDogcmVbdC5YUkFOR0VdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpID0+IHtcbiAgICBkZWJ1ZygneFJhbmdlJywgY29tcCwgcmV0LCBndGx0LCBNLCBtLCBwLCBwcilcbiAgICBjb25zdCB4TSA9IGlzWChNKVxuICAgIGNvbnN0IHhtID0geE0gfHwgaXNYKG0pXG4gICAgY29uc3QgeHAgPSB4bSB8fCBpc1gocClcbiAgICBjb25zdCBhbnlYID0geHBcblxuICAgIGlmIChndGx0ID09PSAnPScgJiYgYW55WCkge1xuICAgICAgZ3RsdCA9ICcnXG4gICAgfVxuXG4gICAgLy8gaWYgd2UncmUgaW5jbHVkaW5nIHByZXJlbGVhc2VzIGluIHRoZSBtYXRjaCwgdGhlbiB3ZSBuZWVkXG4gICAgLy8gdG8gZml4IHRoaXMgdG8gLTAsIHRoZSBsb3dlc3QgcG9zc2libGUgcHJlcmVsZWFzZSB2YWx1ZVxuICAgIHByID0gb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/ICctMCcgOiAnJ1xuXG4gICAgaWYgKHhNKSB7XG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nIHx8IGd0bHQgPT09ICc8Jykge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGFsbG93ZWRcbiAgICAgICAgcmV0ID0gJzwwLjAuMC0wJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBmb3JiaWRkZW5cbiAgICAgICAgcmV0ID0gJyonXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChndGx0ICYmIGFueVgpIHtcbiAgICAgIC8vIHdlIGtub3cgcGF0Y2ggaXMgYW4geCwgYmVjYXVzZSB3ZSBoYXZlIGFueSB4IGF0IGFsbC5cbiAgICAgIC8vIHJlcGxhY2UgWCB3aXRoIDBcbiAgICAgIGlmICh4bSkge1xuICAgICAgICBtID0gMFxuICAgICAgfVxuICAgICAgcCA9IDBcblxuICAgICAgaWYgKGd0bHQgPT09ICc+Jykge1xuICAgICAgICAvLyA+MSA9PiA+PTIuMC4wXG4gICAgICAgIC8vID4xLjIgPT4gPj0xLjMuMFxuICAgICAgICBndGx0ID0gJz49J1xuICAgICAgICBpZiAoeG0pIHtcbiAgICAgICAgICBNID0gK00gKyAxXG4gICAgICAgICAgbSA9IDBcbiAgICAgICAgICBwID0gMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSArbSArIDFcbiAgICAgICAgICBwID0gMFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGd0bHQgPT09ICc8PScpIHtcbiAgICAgICAgLy8gPD0wLjcueCBpcyBhY3R1YWxseSA8MC44LjAsIHNpbmNlIGFueSAwLjcueCBzaG91bGRcbiAgICAgICAgLy8gcGFzcy4gIFNpbWlsYXJseSwgPD03LnggaXMgYWN0dWFsbHkgPDguMC4wLCBldGMuXG4gICAgICAgIGd0bHQgPSAnPCdcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSArbSArIDFcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZ3RsdCA9PT0gJzwnKSB7XG4gICAgICAgIHByID0gJy0wJ1xuICAgICAgfVxuXG4gICAgICByZXQgPSBgJHtndGx0ICsgTX0uJHttfS4ke3B9JHtwcn1gXG4gICAgfSBlbHNlIGlmICh4bSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAke3ByfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgIH0gZWxzZSBpZiAoeHApIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wJHtwclxuICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH1cblxuICAgIGRlYnVnKCd4UmFuZ2UgcmV0dXJuJywgcmV0KVxuXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG4vLyBCZWNhdXNlICogaXMgQU5ELWVkIHdpdGggZXZlcnl0aGluZyBlbHNlIGluIHRoZSBjb21wYXJhdG9yLFxuLy8gYW5kICcnIG1lYW5zIFwiYW55IHZlcnNpb25cIiwganVzdCByZW1vdmUgdGhlICpzIGVudGlyZWx5LlxuY29uc3QgcmVwbGFjZVN0YXJzID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ3JlcGxhY2VTdGFycycsIGNvbXAsIG9wdGlvbnMpXG4gIC8vIExvb3NlbmVzcyBpcyBpZ25vcmVkIGhlcmUuICBzdGFyIGlzIGFsd2F5cyBhcyBsb29zZSBhcyBpdCBnZXRzIVxuICByZXR1cm4gY29tcFxuICAgIC50cmltKClcbiAgICAucmVwbGFjZShyZVt0LlNUQVJdLCAnJylcbn1cblxuY29uc3QgcmVwbGFjZUdURTAgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygncmVwbGFjZUdURTAnLCBjb21wLCBvcHRpb25zKVxuICByZXR1cm4gY29tcFxuICAgIC50cmltKClcbiAgICAucmVwbGFjZShyZVtvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gdC5HVEUwUFJFIDogdC5HVEUwXSwgJycpXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgcGFzc2VkIHRvIHN0cmluZy5yZXBsYWNlKHJlW3QuSFlQSEVOUkFOR0VdKVxuLy8gTSwgbSwgcGF0Y2gsIHByZXJlbGVhc2UsIGJ1aWxkXG4vLyAxLjIgLSAzLjQuNSA9PiA+PTEuMi4wIDw9My40LjVcbi8vIDEuMi4zIC0gMy40ID0+ID49MS4yLjAgPDMuNS4wLTAgQW55IDMuNC54IHdpbGwgZG9cbi8vIDEuMiAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMC0wXG5jb25zdCBoeXBoZW5SZXBsYWNlID0gaW5jUHIgPT4gKCQwLFxuICBmcm9tLCBmTSwgZm0sIGZwLCBmcHIsIGZiLFxuICB0bywgdE0sIHRtLCB0cCwgdHByLCB0YikgPT4ge1xuICBpZiAoaXNYKGZNKSkge1xuICAgIGZyb20gPSAnJ1xuICB9IGVsc2UgaWYgKGlzWChmbSkpIHtcbiAgICBmcm9tID0gYD49JHtmTX0uMC4wJHtpbmNQciA/ICctMCcgOiAnJ31gXG4gIH0gZWxzZSBpZiAoaXNYKGZwKSkge1xuICAgIGZyb20gPSBgPj0ke2ZNfS4ke2ZtfS4wJHtpbmNQciA/ICctMCcgOiAnJ31gXG4gIH0gZWxzZSBpZiAoZnByKSB7XG4gICAgZnJvbSA9IGA+PSR7ZnJvbX1gXG4gIH0gZWxzZSB7XG4gICAgZnJvbSA9IGA+PSR7ZnJvbX0ke2luY1ByID8gJy0wJyA6ICcnfWBcbiAgfVxuXG4gIGlmIChpc1godE0pKSB7XG4gICAgdG8gPSAnJ1xuICB9IGVsc2UgaWYgKGlzWCh0bSkpIHtcbiAgICB0byA9IGA8JHsrdE0gKyAxfS4wLjAtMGBcbiAgfSBlbHNlIGlmIChpc1godHApKSB7XG4gICAgdG8gPSBgPCR7dE19LiR7K3RtICsgMX0uMC0wYFxuICB9IGVsc2UgaWYgKHRwcikge1xuICAgIHRvID0gYDw9JHt0TX0uJHt0bX0uJHt0cH0tJHt0cHJ9YFxuICB9IGVsc2UgaWYgKGluY1ByKSB7XG4gICAgdG8gPSBgPCR7dE19LiR7dG19LiR7K3RwICsgMX0tMGBcbiAgfSBlbHNlIHtcbiAgICB0byA9IGA8PSR7dG99YFxuICB9XG5cbiAgcmV0dXJuIGAke2Zyb219ICR7dG99YC50cmltKClcbn1cblxuY29uc3QgdGVzdFNldCA9IChzZXQsIHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXNldFtpXS50ZXN0KHZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBpZiAodmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgIC8vIEZpbmQgdGhlIHNldCBvZiB2ZXJzaW9ucyB0aGF0IGFyZSBhbGxvd2VkIHRvIGhhdmUgcHJlcmVsZWFzZXNcbiAgICAvLyBGb3IgZXhhbXBsZSwgXjEuMi4zLXByLjEgZGVzdWdhcnMgdG8gPj0xLjIuMy1wci4xIDwyLjAuMFxuICAgIC8vIFRoYXQgc2hvdWxkIGFsbG93IGAxLjIuMy1wci4yYCB0byBwYXNzLlxuICAgIC8vIEhvd2V2ZXIsIGAxLjIuNC1hbHBoYS5ub3RyZWFkeWAgc2hvdWxkIE5PVCBiZSBhbGxvd2VkLFxuICAgIC8vIGV2ZW4gdGhvdWdoIGl0J3Mgd2l0aGluIHRoZSByYW5nZSBzZXQgYnkgdGhlIGNvbXBhcmF0b3JzLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWJ1ZyhzZXRbaV0uc2VtdmVyKVxuICAgICAgaWYgKHNldFtpXS5zZW12ZXIgPT09IENvbXBhcmF0b3IuQU5ZKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBhbGxvd2VkID0gc2V0W2ldLnNlbXZlclxuICAgICAgICBpZiAoYWxsb3dlZC5tYWpvciA9PT0gdmVyc2lvbi5tYWpvciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5taW5vciA9PT0gdmVyc2lvbi5taW5vciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5wYXRjaCA9PT0gdmVyc2lvbi5wYXRjaCkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWZXJzaW9uIGhhcyBhIC1wcmUsIGJ1dCBpdCdzIG5vdCBvbmUgb2YgdGhlIG9uZXMgd2UgbGlrZS5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCJjb25zdCBBTlkgPSBTeW1ib2woJ1NlbVZlciBBTlknKVxuLy8gaG9pc3RlZCBjbGFzcyBmb3IgY3ljbGljIGRlcGVuZGVuY3lcbmNsYXNzIENvbXBhcmF0b3Ige1xuICBzdGF0aWMgZ2V0IEFOWSAoKSB7XG4gICAgcmV0dXJuIEFOWVxuICB9XG5cbiAgY29uc3RydWN0b3IgKGNvbXAsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICAgIGlmIChjb21wLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXAgPSBjb21wLnZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tcCA9IGNvbXAudHJpbSgpLnNwbGl0KC9cXHMrLykuam9pbignICcpXG4gICAgZGVidWcoJ2NvbXBhcmF0b3InLCBjb21wLCBvcHRpb25zKVxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG4gICAgdGhpcy5wYXJzZShjb21wKVxuXG4gICAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgIHRoaXMudmFsdWUgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5vcGVyYXRvciArIHRoaXMuc2VtdmVyLnZlcnNpb25cbiAgICB9XG5cbiAgICBkZWJ1ZygnY29tcCcsIHRoaXMpXG4gIH1cblxuICBwYXJzZSAoY29tcCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLm9wdGlvbnMubG9vc2UgPyByZVt0LkNPTVBBUkFUT1JMT09TRV0gOiByZVt0LkNPTVBBUkFUT1JdXG4gICAgY29uc3QgbSA9IGNvbXAubWF0Y2gocilcblxuICAgIGlmICghbSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBjb21wYXJhdG9yOiAke2NvbXB9YClcbiAgICB9XG5cbiAgICB0aGlzLm9wZXJhdG9yID0gbVsxXSAhPT0gdW5kZWZpbmVkID8gbVsxXSA6ICcnXG4gICAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICc9Jykge1xuICAgICAgdGhpcy5vcGVyYXRvciA9ICcnXG4gICAgfVxuXG4gICAgLy8gaWYgaXQgbGl0ZXJhbGx5IGlzIGp1c3QgJz4nIG9yICcnIHRoZW4gYWxsb3cgYW55dGhpbmcuXG4gICAgaWYgKCFtWzJdKSB7XG4gICAgICB0aGlzLnNlbXZlciA9IEFOWVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbXZlciA9IG5ldyBTZW1WZXIobVsyXSwgdGhpcy5vcHRpb25zLmxvb3NlKVxuICAgIH1cbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVxuICB9XG5cbiAgdGVzdCAodmVyc2lvbikge1xuICAgIGRlYnVnKCdDb21wYXJhdG9yLnRlc3QnLCB2ZXJzaW9uLCB0aGlzLm9wdGlvbnMubG9vc2UpXG5cbiAgICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSB8fCB2ZXJzaW9uID09PSBBTlkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNtcCh2ZXJzaW9uLCB0aGlzLm9wZXJhdG9yLCB0aGlzLnNlbXZlciwgdGhpcy5vcHRpb25zKVxuICB9XG5cbiAgaW50ZXJzZWN0cyAoY29tcCwgb3B0aW9ucykge1xuICAgIGlmICghKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBDb21wYXJhdG9yIGlzIHJlcXVpcmVkJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJycpIHtcbiAgICAgIGlmICh0aGlzLnZhbHVlID09PSAnJykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYW5nZShjb21wLnZhbHVlLCBvcHRpb25zKS50ZXN0KHRoaXMudmFsdWUpXG4gICAgfSBlbHNlIGlmIChjb21wLm9wZXJhdG9yID09PSAnJykge1xuICAgICAgaWYgKGNvbXAudmFsdWUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKHRoaXMudmFsdWUsIG9wdGlvbnMpLnRlc3QoY29tcC5zZW12ZXIpXG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgLy8gU3BlY2lhbCBjYXNlcyB3aGVyZSBub3RoaW5nIGNhbiBwb3NzaWJseSBiZSBsb3dlclxuICAgIGlmIChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgICAodGhpcy52YWx1ZSA9PT0gJzwwLjAuMC0wJyB8fCBjb21wLnZhbHVlID09PSAnPDAuMC4wLTAnKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJlxuICAgICAgKHRoaXMudmFsdWUuc3RhcnRzV2l0aCgnPDAuMC4wJykgfHwgY29tcC52YWx1ZS5zdGFydHNXaXRoKCc8MC4wLjAnKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIFNhbWUgZGlyZWN0aW9uIGluY3JlYXNpbmcgKD4gb3IgPj0pXG4gICAgaWYgKHRoaXMub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPicpICYmIGNvbXAub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPicpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBTYW1lIGRpcmVjdGlvbiBkZWNyZWFzaW5nICg8IG9yIDw9KVxuICAgIGlmICh0aGlzLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJzwnKSAmJiBjb21wLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJzwnKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gc2FtZSBTZW1WZXIgYW5kIGJvdGggc2lkZXMgYXJlIGluY2x1c2l2ZSAoPD0gb3IgPj0pXG4gICAgaWYgKFxuICAgICAgKHRoaXMuc2VtdmVyLnZlcnNpb24gPT09IGNvbXAuc2VtdmVyLnZlcnNpb24pICYmXG4gICAgICB0aGlzLm9wZXJhdG9yLmluY2x1ZGVzKCc9JykgJiYgY29tcC5vcGVyYXRvci5pbmNsdWRlcygnPScpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBvcHBvc2l0ZSBkaXJlY3Rpb25zIGxlc3MgdGhhblxuICAgIGlmIChjbXAodGhpcy5zZW12ZXIsICc8JywgY29tcC5zZW12ZXIsIG9wdGlvbnMpICYmXG4gICAgICB0aGlzLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJz4nKSAmJiBjb21wLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJzwnKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gb3Bwb3NpdGUgZGlyZWN0aW9ucyBncmVhdGVyIHRoYW5cbiAgICBpZiAoY21wKHRoaXMuc2VtdmVyLCAnPicsIGNvbXAuc2VtdmVyLCBvcHRpb25zKSAmJlxuICAgICAgdGhpcy5vcGVyYXRvci5zdGFydHNXaXRoKCc8JykgJiYgY29tcC5vcGVyYXRvci5zdGFydHNXaXRoKCc+JykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcGFyYXRvclxuXG5jb25zdCBwYXJzZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9wYXJzZS1vcHRpb25zJylcbmNvbnN0IHsgc2FmZVJlOiByZSwgdCB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuY29uc3QgY21wID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NtcCcpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4vc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi9yYW5nZScpXG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3Qgc2F0aXNmaWVzID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIHRyeSB7XG4gICAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHJhbmdlLnRlc3QodmVyc2lvbilcbn1cbm1vZHVsZS5leHBvcnRzID0gc2F0aXNmaWVzXG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuXG4vLyBNb3N0bHkganVzdCBmb3IgdGVzdGluZyBhbmQgbGVnYWN5IEFQSSByZWFzb25zXG5jb25zdCB0b0NvbXBhcmF0b3JzID0gKHJhbmdlLCBvcHRpb25zKSA9PlxuICBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpLnNldFxuICAgIC5tYXAoY29tcCA9PiBjb21wLm1hcChjID0+IGMudmFsdWUpLmpvaW4oJyAnKS50cmltKCkuc3BsaXQoJyAnKSlcblxubW9kdWxlLmV4cG9ydHMgPSB0b0NvbXBhcmF0b3JzXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuXG5jb25zdCBtYXhTYXRpc2Z5aW5nID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBsZXQgbWF4ID0gbnVsbFxuICBsZXQgbWF4U1YgPSBudWxsXG4gIGxldCByYW5nZU9iaiA9IG51bGxcbiAgdHJ5IHtcbiAgICByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZlcnNpb25zLmZvckVhY2goKHYpID0+IHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkge1xuICAgICAgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtYXggfHwgbWF4U1YuY29tcGFyZSh2KSA9PT0gLTEpIHtcbiAgICAgICAgLy8gY29tcGFyZShtYXgsIHYsIHRydWUpXG4gICAgICAgIG1heCA9IHZcbiAgICAgICAgbWF4U1YgPSBuZXcgU2VtVmVyKG1heCwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBtYXhcbn1cbm1vZHVsZS5leHBvcnRzID0gbWF4U2F0aXNmeWluZ1xuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IG1pblNhdGlzZnlpbmcgPSAodmVyc2lvbnMsIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIGxldCBtaW4gPSBudWxsXG4gIGxldCBtaW5TViA9IG51bGxcbiAgbGV0IHJhbmdlT2JqID0gbnVsbFxuICB0cnkge1xuICAgIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmVyc2lvbnMuZm9yRWFjaCgodikgPT4ge1xuICAgIGlmIChyYW5nZU9iai50ZXN0KHYpKSB7XG4gICAgICAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgICBpZiAoIW1pbiB8fCBtaW5TVi5jb21wYXJlKHYpID09PSAxKSB7XG4gICAgICAgIC8vIGNvbXBhcmUobWluLCB2LCB0cnVlKVxuICAgICAgICBtaW4gPSB2XG4gICAgICAgIG1pblNWID0gbmV3IFNlbVZlcihtaW4sIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWluXG59XG5tb2R1bGUuZXhwb3J0cyA9IG1pblNhdGlzZnlpbmdcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9ndCcpXG5cbmNvbnN0IG1pblZlcnNpb24gPSAocmFuZ2UsIGxvb3NlKSA9PiB7XG4gIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSlcblxuICBsZXQgbWludmVyID0gbmV3IFNlbVZlcignMC4wLjAnKVxuICBpZiAocmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgbWludmVyID0gbmV3IFNlbVZlcignMC4wLjAtMCcpXG4gIGlmIChyYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICBtaW52ZXIgPSBudWxsXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV1cblxuICAgIGxldCBzZXRNaW4gPSBudWxsXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaCgoY29tcGFyYXRvcikgPT4ge1xuICAgICAgLy8gQ2xvbmUgdG8gYXZvaWQgbWFuaXB1bGF0aW5nIHRoZSBjb21wYXJhdG9yJ3Mgc2VtdmVyIG9iamVjdC5cbiAgICAgIGNvbnN0IGNvbXB2ZXIgPSBuZXcgU2VtVmVyKGNvbXBhcmF0b3Iuc2VtdmVyLnZlcnNpb24pXG4gICAgICBzd2l0Y2ggKGNvbXBhcmF0b3Iub3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgaWYgKGNvbXB2ZXIucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbXB2ZXIucGF0Y2grK1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wdmVyLnByZXJlbGVhc2UucHVzaCgwKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb21wdmVyLnJhdyA9IGNvbXB2ZXIuZm9ybWF0KClcbiAgICAgICAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICcnOlxuICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgaWYgKCFzZXRNaW4gfHwgZ3QoY29tcHZlciwgc2V0TWluKSkge1xuICAgICAgICAgICAgc2V0TWluID0gY29tcHZlclxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgIC8qIElnbm9yZSBtYXhpbXVtIHZlcnNpb25zICovXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgb3BlcmF0aW9uOiAke2NvbXBhcmF0b3Iub3BlcmF0b3J9YClcbiAgICAgIH1cbiAgICB9KVxuICAgIGlmIChzZXRNaW4gJiYgKCFtaW52ZXIgfHwgZ3QobWludmVyLCBzZXRNaW4pKSkge1xuICAgICAgbWludmVyID0gc2V0TWluXG4gICAgfVxuICB9XG5cbiAgaWYgKG1pbnZlciAmJiByYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBtaW5WZXJzaW9uXG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgdmFsaWRSYW5nZSA9IChyYW5nZSwgb3B0aW9ucykgPT4ge1xuICB0cnkge1xuICAgIC8vIFJldHVybiAnKicgaW5zdGVhZCBvZiAnJyBzbyB0aGF0IHRydXRoaW5lc3Mgd29ya3MuXG4gICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIGl0J3MgaW52YWxpZCBhbnl3YXlcbiAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKS5yYW5nZSB8fCAnKidcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkUmFuZ2VcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuLi9jbGFzc2VzL2NvbXBhcmF0b3InKVxuY29uc3QgeyBBTlkgfSA9IENvbXBhcmF0b3JcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBzYXRpc2ZpZXMgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvc2F0aXNmaWVzJylcbmNvbnN0IGd0ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2d0JylcbmNvbnN0IGx0ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2x0JylcbmNvbnN0IGx0ZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9sdGUnKVxuY29uc3QgZ3RlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2d0ZScpXG5cbmNvbnN0IG91dHNpZGUgPSAodmVyc2lvbiwgcmFuZ2UsIGhpbG8sIG9wdGlvbnMpID0+IHtcbiAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucylcbiAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG5cbiAgbGV0IGd0Zm4sIGx0ZWZuLCBsdGZuLCBjb21wLCBlY29tcFxuICBzd2l0Y2ggKGhpbG8pIHtcbiAgICBjYXNlICc+JzpcbiAgICAgIGd0Zm4gPSBndFxuICAgICAgbHRlZm4gPSBsdGVcbiAgICAgIGx0Zm4gPSBsdFxuICAgICAgY29tcCA9ICc+J1xuICAgICAgZWNvbXAgPSAnPj0nXG4gICAgICBicmVha1xuICAgIGNhc2UgJzwnOlxuICAgICAgZ3RmbiA9IGx0XG4gICAgICBsdGVmbiA9IGd0ZVxuICAgICAgbHRmbiA9IGd0XG4gICAgICBjb21wID0gJzwnXG4gICAgICBlY29tcCA9ICc8PSdcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ011c3QgcHJvdmlkZSBhIGhpbG8gdmFsIG9mIFwiPFwiIG9yIFwiPlwiJylcbiAgfVxuXG4gIC8vIElmIGl0IHNhdGlzZmllcyB0aGUgcmFuZ2UgaXQgaXMgbm90IG91dHNpZGVcbiAgaWYgKHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIEZyb20gbm93IG9uLCB2YXJpYWJsZSB0ZXJtcyBhcmUgYXMgaWYgd2UncmUgaW4gXCJndHJcIiBtb2RlLlxuICAvLyBidXQgbm90ZSB0aGF0IGV2ZXJ5dGhpbmcgaXMgZmxpcHBlZCBmb3IgdGhlIFwibHRyXCIgZnVuY3Rpb24uXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZS5zZXQubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjb21wYXJhdG9ycyA9IHJhbmdlLnNldFtpXVxuXG4gICAgbGV0IGhpZ2ggPSBudWxsXG4gICAgbGV0IGxvdyA9IG51bGxcblxuICAgIGNvbXBhcmF0b3JzLmZvckVhY2goKGNvbXBhcmF0b3IpID0+IHtcbiAgICAgIGlmIChjb21wYXJhdG9yLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICAgIGNvbXBhcmF0b3IgPSBuZXcgQ29tcGFyYXRvcignPj0wLjAuMCcpXG4gICAgICB9XG4gICAgICBoaWdoID0gaGlnaCB8fCBjb21wYXJhdG9yXG4gICAgICBsb3cgPSBsb3cgfHwgY29tcGFyYXRvclxuICAgICAgaWYgKGd0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGhpZ2guc2VtdmVyLCBvcHRpb25zKSkge1xuICAgICAgICBoaWdoID0gY29tcGFyYXRvclxuICAgICAgfSBlbHNlIGlmIChsdGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBsb3cuc2VtdmVyLCBvcHRpb25zKSkge1xuICAgICAgICBsb3cgPSBjb21wYXJhdG9yXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIElmIHRoZSBlZGdlIHZlcnNpb24gY29tcGFyYXRvciBoYXMgYSBvcGVyYXRvciB0aGVuIG91ciB2ZXJzaW9uXG4gICAgLy8gaXNuJ3Qgb3V0c2lkZSBpdFxuICAgIGlmIChoaWdoLm9wZXJhdG9yID09PSBjb21wIHx8IGhpZ2gub3BlcmF0b3IgPT09IGVjb21wKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbG93ZXN0IHZlcnNpb24gY29tcGFyYXRvciBoYXMgYW4gb3BlcmF0b3IgYW5kIG91ciB2ZXJzaW9uXG4gICAgLy8gaXMgbGVzcyB0aGFuIGl0IHRoZW4gaXQgaXNuJ3QgaGlnaGVyIHRoYW4gdGhlIHJhbmdlXG4gICAgaWYgKCghbG93Lm9wZXJhdG9yIHx8IGxvdy5vcGVyYXRvciA9PT0gY29tcCkgJiZcbiAgICAgICAgbHRlZm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSBpZiAobG93Lm9wZXJhdG9yID09PSBlY29tcCAmJiBsdGZuKHZlcnNpb24sIGxvdy5zZW12ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdXRzaWRlXG4iLCIvLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2UuXG5jb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9vdXRzaWRlJylcbmNvbnN0IGd0ciA9ICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykgPT4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJz4nLCBvcHRpb25zKVxubW9kdWxlLmV4cG9ydHMgPSBndHJcbiIsImNvbnN0IG91dHNpZGUgPSByZXF1aXJlKCcuL291dHNpZGUnKVxuLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgbGVzcyB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlXG5jb25zdCBsdHIgPSAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpID0+IG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc8Jywgb3B0aW9ucylcbm1vZHVsZS5leHBvcnRzID0gbHRyXG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgaW50ZXJzZWN0cyA9IChyMSwgcjIsIG9wdGlvbnMpID0+IHtcbiAgcjEgPSBuZXcgUmFuZ2UocjEsIG9wdGlvbnMpXG4gIHIyID0gbmV3IFJhbmdlKHIyLCBvcHRpb25zKVxuICByZXR1cm4gcjEuaW50ZXJzZWN0cyhyMiwgb3B0aW9ucylcbn1cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJzZWN0c1xuIiwiLy8gZ2l2ZW4gYSBzZXQgb2YgdmVyc2lvbnMgYW5kIGEgcmFuZ2UsIGNyZWF0ZSBhIFwic2ltcGxpZmllZFwiIHJhbmdlXG4vLyB0aGF0IGluY2x1ZGVzIHRoZSBzYW1lIHZlcnNpb25zIHRoYXQgdGhlIG9yaWdpbmFsIHJhbmdlIGRvZXNcbi8vIElmIHRoZSBvcmlnaW5hbCByYW5nZSBpcyBzaG9ydGVyIHRoYW4gdGhlIHNpbXBsaWZpZWQgb25lLCByZXR1cm4gdGhhdC5cbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMuanMnKVxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9jb21wYXJlLmpzJylcbm1vZHVsZS5leHBvcnRzID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBzZXQgPSBbXVxuICBsZXQgZmlyc3QgPSBudWxsXG4gIGxldCBwcmV2ID0gbnVsbFxuICBjb25zdCB2ID0gdmVyc2lvbnMuc29ydCgoYSwgYikgPT4gY29tcGFyZShhLCBiLCBvcHRpb25zKSlcbiAgZm9yIChjb25zdCB2ZXJzaW9uIG9mIHYpIHtcbiAgICBjb25zdCBpbmNsdWRlZCA9IHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucylcbiAgICBpZiAoaW5jbHVkZWQpIHtcbiAgICAgIHByZXYgPSB2ZXJzaW9uXG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gdmVyc2lvblxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJldikge1xuICAgICAgICBzZXQucHVzaChbZmlyc3QsIHByZXZdKVxuICAgICAgfVxuICAgICAgcHJldiA9IG51bGxcbiAgICAgIGZpcnN0ID0gbnVsbFxuICAgIH1cbiAgfVxuICBpZiAoZmlyc3QpIHtcbiAgICBzZXQucHVzaChbZmlyc3QsIG51bGxdKVxuICB9XG5cbiAgY29uc3QgcmFuZ2VzID0gW11cbiAgZm9yIChjb25zdCBbbWluLCBtYXhdIG9mIHNldCkge1xuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgcmFuZ2VzLnB1c2gobWluKVxuICAgIH0gZWxzZSBpZiAoIW1heCAmJiBtaW4gPT09IHZbMF0pIHtcbiAgICAgIHJhbmdlcy5wdXNoKCcqJylcbiAgICB9IGVsc2UgaWYgKCFtYXgpIHtcbiAgICAgIHJhbmdlcy5wdXNoKGA+PSR7bWlufWApXG4gICAgfSBlbHNlIGlmIChtaW4gPT09IHZbMF0pIHtcbiAgICAgIHJhbmdlcy5wdXNoKGA8PSR7bWF4fWApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlcy5wdXNoKGAke21pbn0gLSAke21heH1gKVxuICAgIH1cbiAgfVxuICBjb25zdCBzaW1wbGlmaWVkID0gcmFuZ2VzLmpvaW4oJyB8fCAnKVxuICBjb25zdCBvcmlnaW5hbCA9IHR5cGVvZiByYW5nZS5yYXcgPT09ICdzdHJpbmcnID8gcmFuZ2UucmF3IDogU3RyaW5nKHJhbmdlKVxuICByZXR1cm4gc2ltcGxpZmllZC5sZW5ndGggPCBvcmlnaW5hbC5sZW5ndGggPyBzaW1wbGlmaWVkIDogcmFuZ2Vcbn1cbiIsImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZS5qcycpXG5jb25zdCBDb21wYXJhdG9yID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9jb21wYXJhdG9yLmpzJylcbmNvbnN0IHsgQU5ZIH0gPSBDb21wYXJhdG9yXG5jb25zdCBzYXRpc2ZpZXMgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzJylcbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvY29tcGFyZS5qcycpXG5cbi8vIENvbXBsZXggcmFuZ2UgYHIxIHx8IHIyIHx8IC4uLmAgaXMgYSBzdWJzZXQgb2YgYFIxIHx8IFIyIHx8IC4uLmAgaWZmOlxuLy8gLSBFdmVyeSBzaW1wbGUgcmFuZ2UgYHIxLCByMiwgLi4uYCBpcyBhIG51bGwgc2V0LCBPUlxuLy8gLSBFdmVyeSBzaW1wbGUgcmFuZ2UgYHIxLCByMiwgLi4uYCB3aGljaCBpcyBub3QgYSBudWxsIHNldCBpcyBhIHN1YnNldCBvZlxuLy8gICBzb21lIGBSMSwgUjIsIC4uLmBcbi8vXG4vLyBTaW1wbGUgcmFuZ2UgYGMxIGMyIC4uLmAgaXMgYSBzdWJzZXQgb2Ygc2ltcGxlIHJhbmdlIGBDMSBDMiAuLi5gIGlmZjpcbi8vIC0gSWYgYyBpcyBvbmx5IHRoZSBBTlkgY29tcGFyYXRvclxuLy8gICAtIElmIEMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3IsIHJldHVybiB0cnVlXG4vLyAgIC0gRWxzZSBpZiBpbiBwcmVyZWxlYXNlIG1vZGUsIHJldHVybiBmYWxzZVxuLy8gICAtIGVsc2UgcmVwbGFjZSBjIHdpdGggYFs+PTAuMC4wXWBcbi8vIC0gSWYgQyBpcyBvbmx5IHRoZSBBTlkgY29tcGFyYXRvclxuLy8gICAtIGlmIGluIHByZXJlbGVhc2UgbW9kZSwgcmV0dXJuIHRydWVcbi8vICAgLSBlbHNlIHJlcGxhY2UgQyB3aXRoIGBbPj0wLjAuMF1gXG4vLyAtIExldCBFUSBiZSB0aGUgc2V0IG9mID0gY29tcGFyYXRvcnMgaW4gY1xuLy8gLSBJZiBFUSBpcyBtb3JlIHRoYW4gb25lLCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAtIExldCBHVCBiZSB0aGUgaGlnaGVzdCA+IG9yID49IGNvbXBhcmF0b3IgaW4gY1xuLy8gLSBMZXQgTFQgYmUgdGhlIGxvd2VzdCA8IG9yIDw9IGNvbXBhcmF0b3IgaW4gY1xuLy8gLSBJZiBHVCBhbmQgTFQsIGFuZCBHVC5zZW12ZXIgPiBMVC5zZW12ZXIsIHJldHVybiB0cnVlIChudWxsIHNldClcbi8vIC0gSWYgYW55IEMgaXMgYSA9IHJhbmdlLCBhbmQgR1Qgb3IgTFQgYXJlIHNldCwgcmV0dXJuIGZhbHNlXG4vLyAtIElmIEVRXG4vLyAgIC0gSWYgR1QsIGFuZCBFUSBkb2VzIG5vdCBzYXRpc2Z5IEdULCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAgIC0gSWYgTFQsIGFuZCBFUSBkb2VzIG5vdCBzYXRpc2Z5IExULCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAgIC0gSWYgRVEgc2F0aXNmaWVzIGV2ZXJ5IEMsIHJldHVybiB0cnVlXG4vLyAgIC0gRWxzZSByZXR1cm4gZmFsc2Vcbi8vIC0gSWYgR1Rcbi8vICAgLSBJZiBHVC5zZW12ZXIgaXMgbG93ZXIgdGhhbiBhbnkgPiBvciA+PSBjb21wIGluIEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIEdUIGlzID49LCBhbmQgR1Quc2VtdmVyIGRvZXMgbm90IHNhdGlzZnkgZXZlcnkgQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgR1Quc2VtdmVyIGhhcyBhIHByZXJlbGVhc2UsIGFuZCBub3QgaW4gcHJlcmVsZWFzZSBtb2RlXG4vLyAgICAgLSBJZiBubyBDIGhhcyBhIHByZXJlbGVhc2UgYW5kIHRoZSBHVC5zZW12ZXIgdHVwbGUsIHJldHVybiBmYWxzZVxuLy8gLSBJZiBMVFxuLy8gICAtIElmIExULnNlbXZlciBpcyBncmVhdGVyIHRoYW4gYW55IDwgb3IgPD0gY29tcCBpbiBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBMVCBpcyA8PSwgYW5kIExULnNlbXZlciBkb2VzIG5vdCBzYXRpc2Z5IGV2ZXJ5IEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIEdULnNlbXZlciBoYXMgYSBwcmVyZWxlYXNlLCBhbmQgbm90IGluIHByZXJlbGVhc2UgbW9kZVxuLy8gICAgIC0gSWYgbm8gQyBoYXMgYSBwcmVyZWxlYXNlIGFuZCB0aGUgTFQuc2VtdmVyIHR1cGxlLCByZXR1cm4gZmFsc2Vcbi8vIC0gRWxzZSByZXR1cm4gdHJ1ZVxuXG5jb25zdCBzdWJzZXQgPSAoc3ViLCBkb20sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBpZiAoc3ViID09PSBkb20pIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgc3ViID0gbmV3IFJhbmdlKHN1Yiwgb3B0aW9ucylcbiAgZG9tID0gbmV3IFJhbmdlKGRvbSwgb3B0aW9ucylcbiAgbGV0IHNhd05vbk51bGwgPSBmYWxzZVxuXG4gIE9VVEVSOiBmb3IgKGNvbnN0IHNpbXBsZVN1YiBvZiBzdWIuc2V0KSB7XG4gICAgZm9yIChjb25zdCBzaW1wbGVEb20gb2YgZG9tLnNldCkge1xuICAgICAgY29uc3QgaXNTdWIgPSBzaW1wbGVTdWJzZXQoc2ltcGxlU3ViLCBzaW1wbGVEb20sIG9wdGlvbnMpXG4gICAgICBzYXdOb25OdWxsID0gc2F3Tm9uTnVsbCB8fCBpc1N1YiAhPT0gbnVsbFxuICAgICAgaWYgKGlzU3ViKSB7XG4gICAgICAgIGNvbnRpbnVlIE9VVEVSXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHRoZSBudWxsIHNldCBpcyBhIHN1YnNldCBvZiBldmVyeXRoaW5nLCBidXQgbnVsbCBzaW1wbGUgcmFuZ2VzIGluXG4gICAgLy8gYSBjb21wbGV4IHJhbmdlIHNob3VsZCBiZSBpZ25vcmVkLiAgc28gaWYgd2Ugc2F3IGEgbm9uLW51bGwgcmFuZ2UsXG4gICAgLy8gdGhlbiB3ZSBrbm93IHRoaXMgaXNuJ3QgYSBzdWJzZXQsIGJ1dCBpZiBFVkVSWSBzaW1wbGUgcmFuZ2Ugd2FzIG51bGwsXG4gICAgLy8gdGhlbiBpdCBpcyBhIHN1YnNldC5cbiAgICBpZiAoc2F3Tm9uTnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmNvbnN0IG1pbmltdW1WZXJzaW9uV2l0aFByZVJlbGVhc2UgPSBbbmV3IENvbXBhcmF0b3IoJz49MC4wLjAtMCcpXVxuY29uc3QgbWluaW11bVZlcnNpb24gPSBbbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKV1cblxuY29uc3Qgc2ltcGxlU3Vic2V0ID0gKHN1YiwgZG9tLCBvcHRpb25zKSA9PiB7XG4gIGlmIChzdWIgPT09IGRvbSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoc3ViLmxlbmd0aCA9PT0gMSAmJiBzdWJbMF0uc2VtdmVyID09PSBBTlkpIHtcbiAgICBpZiAoZG9tLmxlbmd0aCA9PT0gMSAmJiBkb21bMF0uc2VtdmVyID09PSBBTlkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSB7XG4gICAgICBzdWIgPSBtaW5pbXVtVmVyc2lvbldpdGhQcmVSZWxlYXNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YiA9IG1pbmltdW1WZXJzaW9uXG4gICAgfVxuICB9XG5cbiAgaWYgKGRvbS5sZW5ndGggPT09IDEgJiYgZG9tWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgaWYgKG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbSA9IG1pbmltdW1WZXJzaW9uXG4gICAgfVxuICB9XG5cbiAgY29uc3QgZXFTZXQgPSBuZXcgU2V0KClcbiAgbGV0IGd0LCBsdFxuICBmb3IgKGNvbnN0IGMgb2Ygc3ViKSB7XG4gICAgaWYgKGMub3BlcmF0b3IgPT09ICc+JyB8fCBjLm9wZXJhdG9yID09PSAnPj0nKSB7XG4gICAgICBndCA9IGhpZ2hlckdUKGd0LCBjLCBvcHRpb25zKVxuICAgIH0gZWxzZSBpZiAoYy5vcGVyYXRvciA9PT0gJzwnIHx8IGMub3BlcmF0b3IgPT09ICc8PScpIHtcbiAgICAgIGx0ID0gbG93ZXJMVChsdCwgYywgb3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgZXFTZXQuYWRkKGMuc2VtdmVyKVxuICAgIH1cbiAgfVxuXG4gIGlmIChlcVNldC5zaXplID4gMSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBsZXQgZ3RsdENvbXBcbiAgaWYgKGd0ICYmIGx0KSB7XG4gICAgZ3RsdENvbXAgPSBjb21wYXJlKGd0LnNlbXZlciwgbHQuc2VtdmVyLCBvcHRpb25zKVxuICAgIGlmIChndGx0Q29tcCA+IDApIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfSBlbHNlIGlmIChndGx0Q29tcCA9PT0gMCAmJiAoZ3Qub3BlcmF0b3IgIT09ICc+PScgfHwgbHQub3BlcmF0b3IgIT09ICc8PScpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8vIHdpbGwgaXRlcmF0ZSBvbmUgb3IgemVybyB0aW1lc1xuICBmb3IgKGNvbnN0IGVxIG9mIGVxU2V0KSB7XG4gICAgaWYgKGd0ICYmICFzYXRpc2ZpZXMoZXEsIFN0cmluZyhndCksIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGlmIChsdCAmJiAhc2F0aXNmaWVzKGVxLCBTdHJpbmcobHQpLCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGMgb2YgZG9tKSB7XG4gICAgICBpZiAoIXNhdGlzZmllcyhlcSwgU3RyaW5nKGMpLCBvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgbGV0IGhpZ2hlciwgbG93ZXJcbiAgbGV0IGhhc0RvbUxULCBoYXNEb21HVFxuICAvLyBpZiB0aGUgc3Vic2V0IGhhcyBhIHByZXJlbGVhc2UsIHdlIG5lZWQgYSBjb21wYXJhdG9yIGluIHRoZSBzdXBlcnNldFxuICAvLyB3aXRoIHRoZSBzYW1lIHR1cGxlIGFuZCBhIHByZXJlbGVhc2UsIG9yIGl0J3Mgbm90IGEgc3Vic2V0XG4gIGxldCBuZWVkRG9tTFRQcmUgPSBsdCAmJlxuICAgICFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgbHQuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID8gbHQuc2VtdmVyIDogZmFsc2VcbiAgbGV0IG5lZWREb21HVFByZSA9IGd0ICYmXG4gICAgIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiZcbiAgICBndC5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggPyBndC5zZW12ZXIgOiBmYWxzZVxuICAvLyBleGNlcHRpb246IDwxLjIuMy0wIGlzIHRoZSBzYW1lIGFzIDwxLjIuM1xuICBpZiAobmVlZERvbUxUUHJlICYmIG5lZWREb21MVFByZS5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbHQub3BlcmF0b3IgPT09ICc8JyAmJiBuZWVkRG9tTFRQcmUucHJlcmVsZWFzZVswXSA9PT0gMCkge1xuICAgIG5lZWREb21MVFByZSA9IGZhbHNlXG4gIH1cblxuICBmb3IgKGNvbnN0IGMgb2YgZG9tKSB7XG4gICAgaGFzRG9tR1QgPSBoYXNEb21HVCB8fCBjLm9wZXJhdG9yID09PSAnPicgfHwgYy5vcGVyYXRvciA9PT0gJz49J1xuICAgIGhhc0RvbUxUID0gaGFzRG9tTFQgfHwgYy5vcGVyYXRvciA9PT0gJzwnIHx8IGMub3BlcmF0b3IgPT09ICc8PSdcbiAgICBpZiAoZ3QpIHtcbiAgICAgIGlmIChuZWVkRG9tR1RQcmUpIHtcbiAgICAgICAgaWYgKGMuc2VtdmVyLnByZXJlbGVhc2UgJiYgYy5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1ham9yID09PSBuZWVkRG9tR1RQcmUubWFqb3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1pbm9yID09PSBuZWVkRG9tR1RQcmUubWlub3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLnBhdGNoID09PSBuZWVkRG9tR1RQcmUucGF0Y2gpIHtcbiAgICAgICAgICBuZWVkRG9tR1RQcmUgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYy5vcGVyYXRvciA9PT0gJz4nIHx8IGMub3BlcmF0b3IgPT09ICc+PScpIHtcbiAgICAgICAgaGlnaGVyID0gaGlnaGVyR1QoZ3QsIGMsIG9wdGlvbnMpXG4gICAgICAgIGlmIChoaWdoZXIgPT09IGMgJiYgaGlnaGVyICE9PSBndCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGd0Lm9wZXJhdG9yID09PSAnPj0nICYmICFzYXRpc2ZpZXMoZ3Quc2VtdmVyLCBTdHJpbmcoYyksIG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobHQpIHtcbiAgICAgIGlmIChuZWVkRG9tTFRQcmUpIHtcbiAgICAgICAgaWYgKGMuc2VtdmVyLnByZXJlbGVhc2UgJiYgYy5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1ham9yID09PSBuZWVkRG9tTFRQcmUubWFqb3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1pbm9yID09PSBuZWVkRG9tTFRQcmUubWlub3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLnBhdGNoID09PSBuZWVkRG9tTFRQcmUucGF0Y2gpIHtcbiAgICAgICAgICBuZWVkRG9tTFRQcmUgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYy5vcGVyYXRvciA9PT0gJzwnIHx8IGMub3BlcmF0b3IgPT09ICc8PScpIHtcbiAgICAgICAgbG93ZXIgPSBsb3dlckxUKGx0LCBjLCBvcHRpb25zKVxuICAgICAgICBpZiAobG93ZXIgPT09IGMgJiYgbG93ZXIgIT09IGx0KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobHQub3BlcmF0b3IgPT09ICc8PScgJiYgIXNhdGlzZmllcyhsdC5zZW12ZXIsIFN0cmluZyhjKSwgb3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmICghYy5vcGVyYXRvciAmJiAobHQgfHwgZ3QpICYmIGd0bHRDb21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGVyZSB3YXMgYSA8IG9yID4sIGFuZCBub3RoaW5nIGluIHRoZSBkb20sIHRoZW4gbXVzdCBiZSBmYWxzZVxuICAvLyBVTkxFU1MgaXQgd2FzIGxpbWl0ZWQgYnkgYW5vdGhlciByYW5nZSBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uLlxuICAvLyBFZywgPjEuMC4wIDwxLjAuMSBpcyBzdGlsbCBhIHN1YnNldCBvZiA8Mi4wLjBcbiAgaWYgKGd0ICYmIGhhc0RvbUxUICYmICFsdCAmJiBndGx0Q29tcCAhPT0gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKGx0ICYmIGhhc0RvbUdUICYmICFndCAmJiBndGx0Q29tcCAhPT0gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gd2UgbmVlZGVkIGEgcHJlcmVsZWFzZSByYW5nZSBpbiBhIHNwZWNpZmljIHR1cGxlLCBidXQgZGlkbid0IGdldCBvbmVcbiAgLy8gdGhlbiB0aGlzIGlzbid0IGEgc3Vic2V0LiAgZWcgPj0xLjIuMy1wcmUgaXMgbm90IGEgc3Vic2V0IG9mID49MS4wLjAsXG4gIC8vIGJlY2F1c2UgaXQgaW5jbHVkZXMgcHJlcmVsZWFzZXMgaW4gdGhlIDEuMi4zIHR1cGxlXG4gIGlmIChuZWVkRG9tR1RQcmUgfHwgbmVlZERvbUxUUHJlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyA+PTEuMi4zIGlzIGxvd2VyIHRoYW4gPjEuMi4zXG5jb25zdCBoaWdoZXJHVCA9IChhLCBiLCBvcHRpb25zKSA9PiB7XG4gIGlmICghYSkge1xuICAgIHJldHVybiBiXG4gIH1cbiAgY29uc3QgY29tcCA9IGNvbXBhcmUoYS5zZW12ZXIsIGIuc2VtdmVyLCBvcHRpb25zKVxuICByZXR1cm4gY29tcCA+IDAgPyBhXG4gICAgOiBjb21wIDwgMCA/IGJcbiAgICA6IGIub3BlcmF0b3IgPT09ICc+JyAmJiBhLm9wZXJhdG9yID09PSAnPj0nID8gYlxuICAgIDogYVxufVxuXG4vLyA8PTEuMi4zIGlzIGhpZ2hlciB0aGFuIDwxLjIuM1xuY29uc3QgbG93ZXJMVCA9IChhLCBiLCBvcHRpb25zKSA9PiB7XG4gIGlmICghYSkge1xuICAgIHJldHVybiBiXG4gIH1cbiAgY29uc3QgY29tcCA9IGNvbXBhcmUoYS5zZW12ZXIsIGIuc2VtdmVyLCBvcHRpb25zKVxuICByZXR1cm4gY29tcCA8IDAgPyBhXG4gICAgOiBjb21wID4gMCA/IGJcbiAgICA6IGIub3BlcmF0b3IgPT09ICc8JyAmJiBhLm9wZXJhdG9yID09PSAnPD0nID8gYlxuICAgIDogYVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN1YnNldFxuIiwiLy8ganVzdCBwcmUtbG9hZCBhbGwgdGhlIHN0dWZmIHRoYXQgaW5kZXguanMgbGF6aWx5IGV4cG9ydHNcbmNvbnN0IGludGVybmFsUmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3JlJylcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvY29uc3RhbnRzJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgaWRlbnRpZmllcnMgPSByZXF1aXJlKCcuL2ludGVybmFsL2lkZW50aWZpZXJzJylcbmNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvcGFyc2UnKVxuY29uc3QgdmFsaWQgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy92YWxpZCcpXG5jb25zdCBjbGVhbiA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NsZWFuJylcbmNvbnN0IGluYyA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2luYycpXG5jb25zdCBkaWZmID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvZGlmZicpXG5jb25zdCBtYWpvciA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL21ham9yJylcbmNvbnN0IG1pbm9yID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvbWlub3InKVxuY29uc3QgcGF0Y2ggPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wYXRjaCcpXG5jb25zdCBwcmVyZWxlYXNlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvcHJlcmVsZWFzZScpXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29tcGFyZScpXG5jb25zdCByY29tcGFyZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3Jjb21wYXJlJylcbmNvbnN0IGNvbXBhcmVMb29zZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvbXBhcmUtbG9vc2UnKVxuY29uc3QgY29tcGFyZUJ1aWxkID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29tcGFyZS1idWlsZCcpXG5jb25zdCBzb3J0ID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvc29ydCcpXG5jb25zdCByc29ydCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3Jzb3J0JylcbmNvbnN0IGd0ID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvZ3QnKVxuY29uc3QgbHQgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9sdCcpXG5jb25zdCBlcSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2VxJylcbmNvbnN0IG5lcSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL25lcScpXG5jb25zdCBndGUgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9ndGUnKVxuY29uc3QgbHRlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvbHRlJylcbmNvbnN0IGNtcCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NtcCcpXG5jb25zdCBjb2VyY2UgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb2VyY2UnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4vY2xhc3Nlcy9jb21wYXJhdG9yJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3NhdGlzZmllcycpXG5jb25zdCB0b0NvbXBhcmF0b3JzID0gcmVxdWlyZSgnLi9yYW5nZXMvdG8tY29tcGFyYXRvcnMnKVxuY29uc3QgbWF4U2F0aXNmeWluZyA9IHJlcXVpcmUoJy4vcmFuZ2VzL21heC1zYXRpc2Z5aW5nJylcbmNvbnN0IG1pblNhdGlzZnlpbmcgPSByZXF1aXJlKCcuL3Jhbmdlcy9taW4tc2F0aXNmeWluZycpXG5jb25zdCBtaW5WZXJzaW9uID0gcmVxdWlyZSgnLi9yYW5nZXMvbWluLXZlcnNpb24nKVxuY29uc3QgdmFsaWRSYW5nZSA9IHJlcXVpcmUoJy4vcmFuZ2VzL3ZhbGlkJylcbmNvbnN0IG91dHNpZGUgPSByZXF1aXJlKCcuL3Jhbmdlcy9vdXRzaWRlJylcbmNvbnN0IGd0ciA9IHJlcXVpcmUoJy4vcmFuZ2VzL2d0cicpXG5jb25zdCBsdHIgPSByZXF1aXJlKCcuL3Jhbmdlcy9sdHInKVxuY29uc3QgaW50ZXJzZWN0cyA9IHJlcXVpcmUoJy4vcmFuZ2VzL2ludGVyc2VjdHMnKVxuY29uc3Qgc2ltcGxpZnlSYW5nZSA9IHJlcXVpcmUoJy4vcmFuZ2VzL3NpbXBsaWZ5JylcbmNvbnN0IHN1YnNldCA9IHJlcXVpcmUoJy4vcmFuZ2VzL3N1YnNldCcpXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2UsXG4gIHZhbGlkLFxuICBjbGVhbixcbiAgaW5jLFxuICBkaWZmLFxuICBtYWpvcixcbiAgbWlub3IsXG4gIHBhdGNoLFxuICBwcmVyZWxlYXNlLFxuICBjb21wYXJlLFxuICByY29tcGFyZSxcbiAgY29tcGFyZUxvb3NlLFxuICBjb21wYXJlQnVpbGQsXG4gIHNvcnQsXG4gIHJzb3J0LFxuICBndCxcbiAgbHQsXG4gIGVxLFxuICBuZXEsXG4gIGd0ZSxcbiAgbHRlLFxuICBjbXAsXG4gIGNvZXJjZSxcbiAgQ29tcGFyYXRvcixcbiAgUmFuZ2UsXG4gIHNhdGlzZmllcyxcbiAgdG9Db21wYXJhdG9ycyxcbiAgbWF4U2F0aXNmeWluZyxcbiAgbWluU2F0aXNmeWluZyxcbiAgbWluVmVyc2lvbixcbiAgdmFsaWRSYW5nZSxcbiAgb3V0c2lkZSxcbiAgZ3RyLFxuICBsdHIsXG4gIGludGVyc2VjdHMsXG4gIHNpbXBsaWZ5UmFuZ2UsXG4gIHN1YnNldCxcbiAgU2VtVmVyLFxuICByZTogaW50ZXJuYWxSZS5yZSxcbiAgc3JjOiBpbnRlcm5hbFJlLnNyYyxcbiAgdG9rZW5zOiBpbnRlcm5hbFJlLnQsXG4gIFNFTVZFUl9TUEVDX1ZFUlNJT046IGNvbnN0YW50cy5TRU1WRVJfU1BFQ19WRVJTSU9OLFxuICBSRUxFQVNFX1RZUEVTOiBjb25zdGFudHMuUkVMRUFTRV9UWVBFUyxcbiAgY29tcGFyZUlkZW50aWZpZXJzOiBpZGVudGlmaWVycy5jb21wYXJlSWRlbnRpZmllcnMsXG4gIHJjb21wYXJlSWRlbnRpZmllcnM6IGlkZW50aWZpZXJzLnJjb21wYXJlSWRlbnRpZmllcnMsXG59XG4iLCIvKipcbiAqIExvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcy5mb3VuZGF0aW9uLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBTeW1ib2wgPSByb290LlN5bWJvbCxcbiAgICBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5LFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpLFxuICAgIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyksXG4gICAgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpLFxuICAgIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0JyksXG4gICAgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpLFxuICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmXG4gICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gKiBlcXVpdmFsZW50LlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucyxcbiAqIGRhdGUgb2JqZWN0cywgZXJyb3Igb2JqZWN0cywgbWFwcywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcyxcbiAqIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZCBhcnJheXMuIGBPYmplY3RgIG9iamVjdHMgYXJlIGNvbXBhcmVkXG4gKiBieSB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET01cbiAqIG5vZGVzIGFyZSBjb21wYXJlZCBieSBzdHJpY3QgZXF1YWxpdHksIGkuZS4gYD09PWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBvYmplY3QgPT09IG90aGVyO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFcXVhbDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVUZW1wVXBkYXRlRmlsZSA9IGV4cG9ydHMuRG93bmxvYWRlZFVwZGF0ZUhlbHBlciA9IHZvaWQgMDtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XG4vLyBAdHMtaWdub3JlXG5jb25zdCBpc0VxdWFsID0gcmVxdWlyZShcImxvZGFzaC5pc2VxdWFsXCIpO1xuY29uc3QgZnNfZXh0cmFfMSA9IHJlcXVpcmUoXCJmcy1leHRyYVwiKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbi8qKiBAcHJpdmF0ZSAqKi9cbmNsYXNzIERvd25sb2FkZWRVcGRhdGVIZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKGNhY2hlRGlyKSB7XG4gICAgICAgIHRoaXMuY2FjaGVEaXIgPSBjYWNoZURpcjtcbiAgICAgICAgdGhpcy5fZmlsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhY2thZ2VGaWxlID0gbnVsbDtcbiAgICAgICAgdGhpcy52ZXJzaW9uSW5mbyA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlsZUluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLl9kb3dubG9hZGVkRmlsZUluZm8gPSBudWxsO1xuICAgIH1cbiAgICBnZXQgZG93bmxvYWRlZEZpbGVJbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZG93bmxvYWRlZEZpbGVJbmZvO1xuICAgIH1cbiAgICBnZXQgZmlsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGU7XG4gICAgfVxuICAgIGdldCBwYWNrYWdlRmlsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhY2thZ2VGaWxlO1xuICAgIH1cbiAgICBnZXQgY2FjaGVEaXJGb3JQZW5kaW5nVXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gcGF0aC5qb2luKHRoaXMuY2FjaGVEaXIsIFwicGVuZGluZ1wiKTtcbiAgICB9XG4gICAgYXN5bmMgdmFsaWRhdGVEb3dubG9hZGVkUGF0aCh1cGRhdGVGaWxlLCB1cGRhdGVJbmZvLCBmaWxlSW5mbywgbG9nZ2VyKSB7XG4gICAgICAgIGlmICh0aGlzLnZlcnNpb25JbmZvICE9IG51bGwgJiYgdGhpcy5maWxlID09PSB1cGRhdGVGaWxlICYmIHRoaXMuZmlsZUluZm8gIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gdXBkYXRlIGhhcyBhbHJlYWR5IGJlZW4gZG93bmxvYWRlZCBmcm9tIHRoaXMgcnVubmluZyBpbnN0YW5jZVxuICAgICAgICAgICAgLy8gY2hlY2sgaGVyZSBvbmx5IGV4aXN0ZW5jZSwgbm90IGNoZWNrc3VtXG4gICAgICAgICAgICBpZiAoaXNFcXVhbCh0aGlzLnZlcnNpb25JbmZvLCB1cGRhdGVJbmZvKSAmJiBpc0VxdWFsKHRoaXMuZmlsZUluZm8uaW5mbywgZmlsZUluZm8uaW5mbykgJiYgKGF3YWl0ICgwLCBmc19leHRyYV8xLnBhdGhFeGlzdHMpKHVwZGF0ZUZpbGUpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVGaWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIGhhcyBhbHJlYWR5IGJlZW4gZG93bmxvYWRlZCBmcm9tIHNvbWUgcHJldmlvdXMgYXBwIGxhdW5jaFxuICAgICAgICBjb25zdCBjYWNoZWRVcGRhdGVGaWxlID0gYXdhaXQgdGhpcy5nZXRWYWxpZENhY2hlZFVwZGF0ZUZpbGUoZmlsZUluZm8sIGxvZ2dlcik7XG4gICAgICAgIGlmIChjYWNoZWRVcGRhdGVGaWxlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuaW5mbyhgVXBkYXRlIGhhcyBhbHJlYWR5IGJlZW4gZG93bmxvYWRlZCB0byAke3VwZGF0ZUZpbGV9KS5gKTtcbiAgICAgICAgdGhpcy5fZmlsZSA9IGNhY2hlZFVwZGF0ZUZpbGU7XG4gICAgICAgIHJldHVybiBjYWNoZWRVcGRhdGVGaWxlO1xuICAgIH1cbiAgICBhc3luYyBzZXREb3dubG9hZGVkRmlsZShkb3dubG9hZGVkRmlsZSwgcGFja2FnZUZpbGUsIHZlcnNpb25JbmZvLCBmaWxlSW5mbywgdXBkYXRlRmlsZU5hbWUsIGlzU2F2ZUNhY2hlKSB7XG4gICAgICAgIHRoaXMuX2ZpbGUgPSBkb3dubG9hZGVkRmlsZTtcbiAgICAgICAgdGhpcy5fcGFja2FnZUZpbGUgPSBwYWNrYWdlRmlsZTtcbiAgICAgICAgdGhpcy52ZXJzaW9uSW5mbyA9IHZlcnNpb25JbmZvO1xuICAgICAgICB0aGlzLmZpbGVJbmZvID0gZmlsZUluZm87XG4gICAgICAgIHRoaXMuX2Rvd25sb2FkZWRGaWxlSW5mbyA9IHtcbiAgICAgICAgICAgIGZpbGVOYW1lOiB1cGRhdGVGaWxlTmFtZSxcbiAgICAgICAgICAgIHNoYTUxMjogZmlsZUluZm8uaW5mby5zaGE1MTIsXG4gICAgICAgICAgICBpc0FkbWluUmlnaHRzUmVxdWlyZWQ6IGZpbGVJbmZvLmluZm8uaXNBZG1pblJpZ2h0c1JlcXVpcmVkID09PSB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaXNTYXZlQ2FjaGUpIHtcbiAgICAgICAgICAgIGF3YWl0ICgwLCBmc19leHRyYV8xLm91dHB1dEpzb24pKHRoaXMuZ2V0VXBkYXRlSW5mb0ZpbGUoKSwgdGhpcy5fZG93bmxvYWRlZEZpbGVJbmZvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fZmlsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhY2thZ2VGaWxlID0gbnVsbDtcbiAgICAgICAgdGhpcy52ZXJzaW9uSW5mbyA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlsZUluZm8gPSBudWxsO1xuICAgICAgICBhd2FpdCB0aGlzLmNsZWFuQ2FjaGVEaXJGb3JQZW5kaW5nVXBkYXRlKCk7XG4gICAgfVxuICAgIGFzeW5jIGNsZWFuQ2FjaGVEaXJGb3JQZW5kaW5nVXBkYXRlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHN0YWxlIGRhdGFcbiAgICAgICAgICAgIGF3YWl0ICgwLCBmc19leHRyYV8xLmVtcHR5RGlyKSh0aGlzLmNhY2hlRGlyRm9yUGVuZGluZ1VwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGlnbm9yZSkge1xuICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBcInVwZGF0ZS1pbmZvLmpzb25cIiB3aGljaCBpcyBjcmVhdGVkIGluIHRoZSB1cGRhdGUgY2FjaGUgZGlyZWN0b3J5J3MgXCJwZW5kaW5nXCIgc3ViZm9sZGVyIGFmdGVyIHRoZSBmaXJzdCB1cGRhdGUgaXMgZG93bmxvYWRlZC4gIElmIHRoZSB1cGRhdGUgZmlsZSBkb2VzIG5vdCBleGlzdCB0aGVuIHRoZSBjYWNoZSBpcyBjbGVhcmVkIGFuZCByZWNyZWF0ZWQuICBJZiB0aGUgdXBkYXRlIGZpbGUgZXhpc3RzIHRoZW4gaXRzIHByb3BlcnRpZXMgYXJlIHZhbGlkYXRlZC5cbiAgICAgKiBAcGFyYW0gZmlsZUluZm9cbiAgICAgKiBAcGFyYW0gbG9nZ2VyXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VmFsaWRDYWNoZWRVcGRhdGVGaWxlKGZpbGVJbmZvLCBsb2dnZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB1cGRhdGVJbmZvRmlsZVBhdGggPSB0aGlzLmdldFVwZGF0ZUluZm9GaWxlKCk7XG4gICAgICAgIGNvbnN0IGRvZXNVcGRhdGVJbmZvRmlsZUV4aXN0ID0gYXdhaXQgKDAsIGZzX2V4dHJhXzEucGF0aEV4aXN0cykodXBkYXRlSW5mb0ZpbGVQYXRoKTtcbiAgICAgICAgaWYgKCFkb2VzVXBkYXRlSW5mb0ZpbGVFeGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNhY2hlZEluZm87XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYWNoZWRJbmZvID0gYXdhaXQgKDAsIGZzX2V4dHJhXzEucmVhZEpzb24pKHVwZGF0ZUluZm9GaWxlUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZSA9IGBObyBjYWNoZWQgdXBkYXRlIGluZm8gYXZhaWxhYmxlYDtcbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlICE9PSBcIkVOT0VOVFwiKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jbGVhbkNhY2hlRGlyRm9yUGVuZGluZ1VwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gYCAoZXJyb3Igb24gcmVhZDogJHtlcnJvci5tZXNzYWdlfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmluZm8obWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0NhY2hlZEluZm9GaWxlTmFtZVZhbGlkID0gKF9hID0gKGNhY2hlZEluZm8gPT09IG51bGwgfHwgY2FjaGVkSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FjaGVkSW5mby5maWxlTmFtZSkgIT09IG51bGwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgICAgICBpZiAoIWlzQ2FjaGVkSW5mb0ZpbGVOYW1lVmFsaWQpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBDYWNoZWQgdXBkYXRlIGluZm8gaXMgY29ycnVwdGVkOiBubyBmaWxlTmFtZSwgZGlyZWN0b3J5IGZvciBjYWNoZWQgdXBkYXRlIHdpbGwgYmUgY2xlYW5lZGApO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jbGVhbkNhY2hlRGlyRm9yUGVuZGluZ1VwZGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbGVJbmZvLmluZm8uc2hhNTEyICE9PSBjYWNoZWRJbmZvLnNoYTUxMikge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYENhY2hlZCB1cGRhdGUgc2hhNTEyIGNoZWNrc3VtIGRvZXNuJ3QgbWF0Y2ggdGhlIGxhdGVzdCBhdmFpbGFibGUgdXBkYXRlLiBOZXcgdXBkYXRlIG11c3QgYmUgZG93bmxvYWRlZC4gQ2FjaGVkOiAke2NhY2hlZEluZm8uc2hhNTEyfSwgZXhwZWN0ZWQ6ICR7ZmlsZUluZm8uaW5mby5zaGE1MTJ9LiBEaXJlY3RvcnkgZm9yIGNhY2hlZCB1cGRhdGUgd2lsbCBiZSBjbGVhbmVkYCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNsZWFuQ2FjaGVEaXJGb3JQZW5kaW5nVXBkYXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGRhdGVGaWxlID0gcGF0aC5qb2luKHRoaXMuY2FjaGVEaXJGb3JQZW5kaW5nVXBkYXRlLCBjYWNoZWRJbmZvLmZpbGVOYW1lKTtcbiAgICAgICAgaWYgKCEoYXdhaXQgKDAsIGZzX2V4dHJhXzEucGF0aEV4aXN0cykodXBkYXRlRmlsZSkpKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcIkNhY2hlZCB1cGRhdGUgZmlsZSBkb2Vzbid0IGV4aXN0XCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2hhNTEyID0gYXdhaXQgaGFzaEZpbGUodXBkYXRlRmlsZSk7XG4gICAgICAgIGlmIChmaWxlSW5mby5pbmZvLnNoYTUxMiAhPT0gc2hhNTEyKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgU2hhNTEyIGNoZWNrc3VtIGRvZXNuJ3QgbWF0Y2ggdGhlIGxhdGVzdCBhdmFpbGFibGUgdXBkYXRlLiBOZXcgdXBkYXRlIG11c3QgYmUgZG93bmxvYWRlZC4gQ2FjaGVkOiAke3NoYTUxMn0sIGV4cGVjdGVkOiAke2ZpbGVJbmZvLmluZm8uc2hhNTEyfWApO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jbGVhbkNhY2hlRGlyRm9yUGVuZGluZ1VwZGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZG93bmxvYWRlZEZpbGVJbmZvID0gY2FjaGVkSW5mbztcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZpbGU7XG4gICAgfVxuICAgIGdldFVwZGF0ZUluZm9GaWxlKCkge1xuICAgICAgICByZXR1cm4gcGF0aC5qb2luKHRoaXMuY2FjaGVEaXJGb3JQZW5kaW5nVXBkYXRlLCBcInVwZGF0ZS1pbmZvLmpzb25cIik7XG4gICAgfVxufVxuZXhwb3J0cy5Eb3dubG9hZGVkVXBkYXRlSGVscGVyID0gRG93bmxvYWRlZFVwZGF0ZUhlbHBlcjtcbmZ1bmN0aW9uIGhhc2hGaWxlKGZpbGUsIGFsZ29yaXRobSA9IFwic2hhNTEyXCIsIGVuY29kaW5nID0gXCJiYXNlNjRcIiwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGhhc2ggPSAoMCwgY3J5cHRvXzEuY3JlYXRlSGFzaCkoYWxnb3JpdGhtKTtcbiAgICAgICAgaGFzaC5vbihcImVycm9yXCIsIHJlamVjdCkuc2V0RW5jb2RpbmcoZW5jb2RpbmcpO1xuICAgICAgICAoMCwgZnNfMS5jcmVhdGVSZWFkU3RyZWFtKShmaWxlLCB7IC4uLm9wdGlvbnMsIGhpZ2hXYXRlck1hcms6IDEwMjQgKiAxMDI0IC8qIGJldHRlciB0byB1c2UgbW9yZSBtZW1vcnkgYnV0IGhhc2ggZmFzdGVyICovIH0pXG4gICAgICAgICAgICAub24oXCJlcnJvclwiLCByZWplY3QpXG4gICAgICAgICAgICAub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgaGFzaC5lbmQoKTtcbiAgICAgICAgICAgIHJlc29sdmUoaGFzaC5yZWFkKCkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnBpcGUoaGFzaCwgeyBlbmQ6IGZhbHNlIH0pO1xuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlVGVtcFVwZGF0ZUZpbGUobmFtZSwgY2FjaGVEaXIsIGxvZykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi11c2VybGFuZC9lbGVjdHJvbi1idWlsZGVyL3B1bGwvMjQ3NCNpc3N1ZWNvbW1lbnQtMzY2NDgxOTEyXG4gICAgbGV0IG5hbWVDb3VudGVyID0gMDtcbiAgICBsZXQgcmVzdWx0ID0gcGF0aC5qb2luKGNhY2hlRGlyLCBuYW1lKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgKDAsIGZzX2V4dHJhXzEudW5saW5rKShyZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUuY29kZSA9PT0gXCJFTk9FTlRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2cud2FybihgRXJyb3Igb24gcmVtb3ZlIHRlbXAgdXBkYXRlIGZpbGU6ICR7ZX1gKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhdGguam9pbihjYWNoZURpciwgYCR7bmFtZUNvdW50ZXIrK30tJHtuYW1lfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmNyZWF0ZVRlbXBVcGRhdGVGaWxlID0gY3JlYXRlVGVtcFVwZGF0ZUZpbGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Eb3dubG9hZGVkVXBkYXRlSGVscGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRBcHBDYWNoZURpciA9IHZvaWQgMDtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IG9zXzEgPSByZXF1aXJlKFwib3NcIik7XG5mdW5jdGlvbiBnZXRBcHBDYWNoZURpcigpIHtcbiAgICBjb25zdCBob21lZGlyID0gKDAsIG9zXzEuaG9tZWRpcikoKTtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZWxlY3Ryb24vZWxlY3Ryb24vaXNzdWVzLzE0MDQjaXNzdWVjb21tZW50LTE5NDM5MTI0N1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIikge1xuICAgICAgICByZXN1bHQgPSBwcm9jZXNzLmVudltcIkxPQ0FMQVBQREFUQVwiXSB8fCBwYXRoLmpvaW4oaG9tZWRpciwgXCJBcHBEYXRhXCIsIFwiTG9jYWxcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09IFwiZGFyd2luXCIpIHtcbiAgICAgICAgcmVzdWx0ID0gcGF0aC5qb2luKGhvbWVkaXIsIFwiTGlicmFyeVwiLCBcIkNhY2hlc1wiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHByb2Nlc3MuZW52W1wiWERHX0NBQ0hFX0hPTUVcIl0gfHwgcGF0aC5qb2luKGhvbWVkaXIsIFwiLmNhY2hlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5nZXRBcHBDYWNoZURpciA9IGdldEFwcENhY2hlRGlyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXBwQWRhcHRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRWxlY3Ryb25BcHBBZGFwdGVyID0gdm9pZCAwO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgQXBwQWRhcHRlcl8xID0gcmVxdWlyZShcIi4vQXBwQWRhcHRlclwiKTtcbmNsYXNzIEVsZWN0cm9uQXBwQWRhcHRlciB7XG4gICAgY29uc3RydWN0b3IoYXBwID0gcmVxdWlyZShcImVsZWN0cm9uXCIpLmFwcCkge1xuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICB9XG4gICAgd2hlblJlYWR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHAud2hlblJlYWR5KCk7XG4gICAgfVxuICAgIGdldCB2ZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHAuZ2V0VmVyc2lvbigpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwLmdldE5hbWUoKTtcbiAgICB9XG4gICAgZ2V0IGlzUGFja2FnZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcC5pc1BhY2thZ2VkID09PSB0cnVlO1xuICAgIH1cbiAgICBnZXQgYXBwVXBkYXRlQ29uZmlnUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNQYWNrYWdlZCA/IHBhdGguam9pbihwcm9jZXNzLnJlc291cmNlc1BhdGgsIFwiYXBwLXVwZGF0ZS55bWxcIikgOiBwYXRoLmpvaW4odGhpcy5hcHAuZ2V0QXBwUGF0aCgpLCBcImRldi1hcHAtdXBkYXRlLnltbFwiKTtcbiAgICB9XG4gICAgZ2V0IHVzZXJEYXRhUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwLmdldFBhdGgoXCJ1c2VyRGF0YVwiKTtcbiAgICB9XG4gICAgZ2V0IGJhc2VDYWNoZVBhdGgoKSB7XG4gICAgICAgIHJldHVybiAoMCwgQXBwQWRhcHRlcl8xLmdldEFwcENhY2hlRGlyKSgpO1xuICAgIH1cbiAgICBxdWl0KCkge1xuICAgICAgICB0aGlzLmFwcC5xdWl0KCk7XG4gICAgfVxuICAgIG9uUXVpdChoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuYXBwLm9uY2UoXCJxdWl0XCIsIChfLCBleGl0Q29kZSkgPT4gaGFuZGxlcihleGl0Q29kZSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuRWxlY3Ryb25BcHBBZGFwdGVyID0gRWxlY3Ryb25BcHBBZGFwdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RWxlY3Ryb25BcHBBZGFwdGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FbGVjdHJvbkh0dHBFeGVjdXRvciA9IGV4cG9ydHMuZ2V0TmV0U2Vzc2lvbiA9IGV4cG9ydHMuTkVUX1NFU1NJT05fTkFNRSA9IHZvaWQgMDtcbmNvbnN0IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG5leHBvcnRzLk5FVF9TRVNTSU9OX05BTUUgPSBcImVsZWN0cm9uLXVwZGF0ZXJcIjtcbmZ1bmN0aW9uIGdldE5ldFNlc3Npb24oKSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoXCJlbGVjdHJvblwiKS5zZXNzaW9uLmZyb21QYXJ0aXRpb24oZXhwb3J0cy5ORVRfU0VTU0lPTl9OQU1FLCB7XG4gICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICB9KTtcbn1cbmV4cG9ydHMuZ2V0TmV0U2Vzc2lvbiA9IGdldE5ldFNlc3Npb247XG5jbGFzcyBFbGVjdHJvbkh0dHBFeGVjdXRvciBleHRlbmRzIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuSHR0cEV4ZWN1dG9yIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm94eUxvZ2luQ2FsbGJhY2spIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wcm94eUxvZ2luQ2FsbGJhY2sgPSBwcm94eUxvZ2luQ2FsbGJhY2s7XG4gICAgICAgIHRoaXMuY2FjaGVkU2Vzc2lvbiA9IG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGRvd25sb2FkKHVybCwgZGVzdGluYXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IG9wdGlvbnMuY2FuY2VsbGF0aW9uVG9rZW4uY3JlYXRlUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0LCBvbkNhbmNlbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByZWRpcmVjdDogXCJtYW51YWxcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAoMCwgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5jb25maWd1cmVSZXF1ZXN0VXJsKSh1cmwsIHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgICAgICgwLCBidWlsZGVyX3V0aWxfcnVudGltZV8xLmNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zKShyZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmRvRG93bmxvYWQocmVxdWVzdE9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgIG9uQ2FuY2VsLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlSGFuZGxlcjogbnVsbCxcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBmaXggKG5vZGUgNyspIGZvciBtYWtpbmcgZWxlY3Ryb24gdXBkYXRlciB3b3JrIHdoZW4gdXNpbmcgQVdTIHByaXZhdGUgYnVja2V0cywgY2hlY2sgaWYgaGVhZGVycyBjb250YWluIEhvc3QgcHJvcGVydHlcbiAgICAgICAgaWYgKG9wdGlvbnMuaGVhZGVycyAmJiBvcHRpb25zLmhlYWRlcnMuSG9zdCkge1xuICAgICAgICAgICAgLy8gc2V0IGhvc3QgdmFsdWUgZnJvbSBoZWFkZXJzLkhvc3RcbiAgICAgICAgICAgIG9wdGlvbnMuaG9zdCA9IG9wdGlvbnMuaGVhZGVycy5Ib3N0O1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGhlYWRlciBwcm9wZXJ0eSAnSG9zdCcsIGlmIG5vdCByZW1vdmVkIGNhdXNlcyBuZXQ6OkVSUl9JTlZBTElEX0FSR1VNRU5UIGV4Y2VwdGlvblxuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuaGVhZGVycy5Ib3N0O1xuICAgICAgICB9XG4gICAgICAgIC8vIGRpZmZlcmVudGlhbCBkb3dubG9hZGVyIGNhbiBjYWxsIHRoaXMgbWV0aG9kIHZlcnkgb2Z0ZW4sIHNvLCBiZXR0ZXIgdG8gY2FjaGUgc2Vzc2lvblxuICAgICAgICBpZiAodGhpcy5jYWNoZWRTZXNzaW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkU2Vzc2lvbiA9IGdldE5ldFNlc3Npb24oKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWlyZShcImVsZWN0cm9uXCIpLm5ldC5yZXF1ZXN0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBzZXNzaW9uOiB0aGlzLmNhY2hlZFNlc3Npb24sXG4gICAgICAgIH0pO1xuICAgICAgICByZXF1ZXN0Lm9uKFwicmVzcG9uc2VcIiwgY2FsbGJhY2spO1xuICAgICAgICBpZiAodGhpcy5wcm94eUxvZ2luQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVxdWVzdC5vbihcImxvZ2luXCIsIHRoaXMucHJveHlMb2dpbkNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG4gICAgYWRkUmVkaXJlY3RIYW5kbGVycyhyZXF1ZXN0LCBvcHRpb25zLCByZWplY3QsIHJlZGlyZWN0Q291bnQsIGhhbmRsZXIpIHtcbiAgICAgICAgcmVxdWVzdC5vbihcInJlZGlyZWN0XCIsIChzdGF0dXNDb2RlLCBtZXRob2QsIHJlZGlyZWN0VXJsKSA9PiB7XG4gICAgICAgICAgICAvLyBubyB3YXkgdG8gbW9kaWZ5IHJlcXVlc3Qgb3B0aW9ucywgYWJvcnQgb2xkIGFuZCBtYWtlIGEgbmV3IG9uZVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uL2VsZWN0cm9uL2lzc3Vlcy8xMTUwNVxuICAgICAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICAgICAgaWYgKHJlZGlyZWN0Q291bnQgPiB0aGlzLm1heFJlZGlyZWN0cykge1xuICAgICAgICAgICAgICAgIHJlamVjdCh0aGlzLmNyZWF0ZU1heFJlZGlyZWN0RXJyb3IoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuSHR0cEV4ZWN1dG9yLnByZXBhcmVSZWRpcmVjdFVybE9wdGlvbnMocmVkaXJlY3RVcmwsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5FbGVjdHJvbkh0dHBFeGVjdXRvciA9IEVsZWN0cm9uSHR0cEV4ZWN1dG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWxlY3Ryb25IdHRwRXhlY3V0b3IuanMubWFwIiwiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZyxcbiAgICByZUhhc1JlZ0V4cENoYXIgPSBSZWdFeHAocmVSZWdFeHBDaGFyLnNvdXJjZSk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIEVzY2FwZXMgdGhlIGBSZWdFeHBgIHNwZWNpYWwgY2hhcmFjdGVycyBcIl5cIiwgXCIkXCIsIFwiXFxcIiwgXCIuXCIsIFwiKlwiLCBcIitcIixcbiAqIFwiP1wiLCBcIihcIiwgXCIpXCIsIFwiW1wiLCBcIl1cIiwgXCJ7XCIsIFwifVwiLCBhbmQgXCJ8XCIgaW4gYHN0cmluZ2AuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZXNjYXBlUmVnRXhwKCdbbG9kYXNoXShodHRwczovL2xvZGFzaC5jb20vKScpO1xuICogLy8gPT4gJ1xcW2xvZGFzaFxcXVxcKGh0dHBzOi8vbG9kYXNoXFwuY29tL1xcKSdcbiAqL1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1JlZ0V4cENoYXIudGVzdChzdHJpbmcpKVxuICAgID8gc3RyaW5nLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgICA6IHN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVSZWdFeHA7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmxvY2ttYXBGaWxlcyA9IGV4cG9ydHMuZ2V0Q2hhbm5lbEZpbGVuYW1lID0gZXhwb3J0cy5uZXdVcmxGcm9tQmFzZSA9IGV4cG9ydHMubmV3QmFzZVVybCA9IHZvaWQgMDtcbi8vIGlmIGJhc2VVcmwgcGF0aCBkb2Vzbid0IGVuZHMgd2l0aCAvLCB0aGlzIHBhdGggd2lsbCBiZSBub3QgcHJlcGVuZGVkIHRvIHBhc3NlZCBwYXRobmFtZSBmb3IgbmV3IFVSTChpbnB1dCwgYmFzZSlcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGVzY2FwZVJlZ0V4cCA9IHJlcXVpcmUoXCJsb2Rhc2guZXNjYXBlcmVnZXhwXCIpO1xuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gbmV3QmFzZVVybCh1cmwpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgdXJsXzEuVVJMKHVybCk7XG4gICAgaWYgKCFyZXN1bHQucGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICAgIHJlc3VsdC5wYXRobmFtZSArPSBcIi9cIjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMubmV3QmFzZVVybCA9IG5ld0Jhc2VVcmw7XG4vLyBhZGRSYW5kb21RdWVyeVRvQXZvaWRDYWNoaW5nIGlzIGZhbHNlIGJ5IGRlZmF1bHQgYmVjYXVzZSBpbiBtb3N0IGNhc2VzIFVSTCBhbHJlYWR5IGNvbnRhaW5zIHZlcnNpb24gbnVtYmVyLFxuLy8gc28sIGl0IG1ha2VzIHNlbnNlIG9ubHkgZm9yIEdlbmVyaWMgUHJvdmlkZXIgZm9yIGNoYW5uZWwgZmlsZXNcbmZ1bmN0aW9uIG5ld1VybEZyb21CYXNlKHBhdGhuYW1lLCBiYXNlVXJsLCBhZGRSYW5kb21RdWVyeVRvQXZvaWRDYWNoaW5nID0gZmFsc2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgdXJsXzEuVVJMKHBhdGhuYW1lLCBiYXNlVXJsKTtcbiAgICAvLyBzZWFyY2ggaXMgbm90IHByb3BhZ2F0ZWQgKHNlYXJjaCBpcyBhbiBlbXB0eSBzdHJpbmcgaWYgbm90IHNwZWNpZmllZClcbiAgICBjb25zdCBzZWFyY2ggPSBiYXNlVXJsLnNlYXJjaDtcbiAgICBpZiAoc2VhcmNoICE9IG51bGwgJiYgc2VhcmNoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICByZXN1bHQuc2VhcmNoID0gc2VhcmNoO1xuICAgIH1cbiAgICBlbHNlIGlmIChhZGRSYW5kb21RdWVyeVRvQXZvaWRDYWNoaW5nKSB7XG4gICAgICAgIHJlc3VsdC5zZWFyY2ggPSBgbm9DYWNoZT0ke0RhdGUubm93KCkudG9TdHJpbmcoMzIpfWA7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLm5ld1VybEZyb21CYXNlID0gbmV3VXJsRnJvbUJhc2U7XG5mdW5jdGlvbiBnZXRDaGFubmVsRmlsZW5hbWUoY2hhbm5lbCkge1xuICAgIHJldHVybiBgJHtjaGFubmVsfS55bWxgO1xufVxuZXhwb3J0cy5nZXRDaGFubmVsRmlsZW5hbWUgPSBnZXRDaGFubmVsRmlsZW5hbWU7XG5mdW5jdGlvbiBibG9ja21hcEZpbGVzKGJhc2VVcmwsIG9sZFZlcnNpb24sIG5ld1ZlcnNpb24pIHtcbiAgICBjb25zdCBuZXdCbG9ja01hcFVybCA9IG5ld1VybEZyb21CYXNlKGAke2Jhc2VVcmwucGF0aG5hbWV9LmJsb2NrbWFwYCwgYmFzZVVybCk7XG4gICAgY29uc3Qgb2xkQmxvY2tNYXBVcmwgPSBuZXdVcmxGcm9tQmFzZShgJHtiYXNlVXJsLnBhdGhuYW1lLnJlcGxhY2UobmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAobmV3VmVyc2lvbiksIFwiZ1wiKSwgb2xkVmVyc2lvbil9LmJsb2NrbWFwYCwgYmFzZVVybCk7XG4gICAgcmV0dXJuIFtvbGRCbG9ja01hcFVybCwgbmV3QmxvY2tNYXBVcmxdO1xufVxuZXhwb3J0cy5ibG9ja21hcEZpbGVzID0gYmxvY2ttYXBGaWxlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlc29sdmVGaWxlcyA9IGV4cG9ydHMuZ2V0RmlsZUxpc3QgPSBleHBvcnRzLnBhcnNlVXBkYXRlSW5mbyA9IGV4cG9ydHMuZmluZEZpbGUgPSBleHBvcnRzLlByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgYnVpbGRlcl91dGlsX3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbmNvbnN0IGpzX3lhbWxfMSA9IHJlcXVpcmUoXCJqcy15YW1sXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jbGFzcyBQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IocnVudGltZU9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5ydW50aW1lT3B0aW9ucyA9IHJ1bnRpbWVPcHRpb25zO1xuICAgICAgICB0aGlzLnJlcXVlc3RIZWFkZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5leGVjdXRvciA9IHJ1bnRpbWVPcHRpb25zLmV4ZWN1dG9yO1xuICAgIH1cbiAgICBnZXQgaXNVc2VNdWx0aXBsZVJhbmdlUmVxdWVzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnVudGltZU9wdGlvbnMuaXNVc2VNdWx0aXBsZVJhbmdlUmVxdWVzdCAhPT0gZmFsc2U7XG4gICAgfVxuICAgIGdldENoYW5uZWxGaWxlUHJlZml4KCkge1xuICAgICAgICBpZiAodGhpcy5ydW50aW1lT3B0aW9ucy5wbGF0Zm9ybSA9PT0gXCJsaW51eFwiKSB7XG4gICAgICAgICAgICBjb25zdCBhcmNoID0gcHJvY2Vzcy5lbnZbXCJURVNUX1VQREFURVJfQVJDSFwiXSB8fCBwcm9jZXNzLmFyY2g7XG4gICAgICAgICAgICBjb25zdCBhcmNoU3VmZml4ID0gYXJjaCA9PT0gXCJ4NjRcIiA/IFwiXCIgOiBgLSR7YXJjaH1gO1xuICAgICAgICAgICAgcmV0dXJuIFwiLWxpbnV4XCIgKyBhcmNoU3VmZml4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVudGltZU9wdGlvbnMucGxhdGZvcm0gPT09IFwiZGFyd2luXCIgPyBcIi1tYWNcIiA6IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZHVlIHRvIGhpc3RvcmljYWwgcmVhc29ucyBmb3Igd2luZG93cyB3ZSB1c2UgY2hhbm5lbCBuYW1lIHdpdGhvdXQgcGxhdGZvcm0gc3BlY2lmaWVyXG4gICAgZ2V0RGVmYXVsdENoYW5uZWxOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXN0b21DaGFubmVsTmFtZShcImxhdGVzdFwiKTtcbiAgICB9XG4gICAgZ2V0Q3VzdG9tQ2hhbm5lbE5hbWUoY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gYCR7Y2hhbm5lbH0ke3RoaXMuZ2V0Q2hhbm5lbEZpbGVQcmVmaXgoKX1gO1xuICAgIH1cbiAgICBnZXQgZmlsZUV4dHJhRG93bmxvYWRIZWFkZXJzKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc2V0UmVxdWVzdEhlYWRlcnModmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0SGVhZGVycyA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gcGVyZm9ybSBBUEkgcmVxdWVzdCBvbmx5IHRvIHJlc29sdmUgdXBkYXRlIGluZm8sIGJ1dCBub3QgdG8gZG93bmxvYWQgdXBkYXRlLlxuICAgICAqL1xuICAgIGh0dHBSZXF1ZXN0KHVybCwgaGVhZGVycywgY2FuY2VsbGF0aW9uVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0b3IucmVxdWVzdCh0aGlzLmNyZWF0ZVJlcXVlc3RPcHRpb25zKHVybCwgaGVhZGVycyksIGNhbmNlbGxhdGlvblRva2VuKTtcbiAgICB9XG4gICAgY3JlYXRlUmVxdWVzdE9wdGlvbnModXJsLCBoZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0SGVhZGVycyA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVycyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LmhlYWRlcnMgPSBoZWFkZXJzID09IG51bGwgPyB0aGlzLnJlcXVlc3RIZWFkZXJzIDogeyAuLi50aGlzLnJlcXVlc3RIZWFkZXJzLCAuLi5oZWFkZXJzIH07XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuY29uZmlndXJlUmVxdWVzdFVybCkodXJsLCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvdmlkZXIgPSBQcm92aWRlcjtcbmZ1bmN0aW9uIGZpbmRGaWxlKGZpbGVzLCBleHRlbnNpb24sIG5vdCkge1xuICAgIGlmIChmaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgKDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IpKFwiTm8gZmlsZXMgcHJvdmlkZWRcIiwgXCJFUlJfVVBEQVRFUl9OT19GSUxFU19QUk9WSURFRFwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gZmlsZXMuZmluZChpdCA9PiBpdC51cmwucGF0aG5hbWUudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChgLiR7ZXh0ZW5zaW9ufWApKTtcbiAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZWxzZSBpZiAobm90ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZpbGVzWzBdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZpbGVzLmZpbmQoZmlsZUluZm8gPT4gIW5vdC5zb21lKGV4dCA9PiBmaWxlSW5mby51cmwucGF0aG5hbWUudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChgLiR7ZXh0fWApKSk7XG4gICAgfVxufVxuZXhwb3J0cy5maW5kRmlsZSA9IGZpbmRGaWxlO1xuZnVuY3Rpb24gcGFyc2VVcGRhdGVJbmZvKHJhd0RhdGEsIGNoYW5uZWxGaWxlLCBjaGFubmVsRmlsZVVybCkge1xuICAgIGlmIChyYXdEYXRhID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgKDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IpKGBDYW5ub3QgcGFyc2UgdXBkYXRlIGluZm8gZnJvbSAke2NoYW5uZWxGaWxlfSBpbiB0aGUgbGF0ZXN0IHJlbGVhc2UgYXJ0aWZhY3RzICgke2NoYW5uZWxGaWxlVXJsfSk6IHJhd0RhdGE6IG51bGxgLCBcIkVSUl9VUERBVEVSX0lOVkFMSURfVVBEQVRFX0lORk9cIik7XG4gICAgfVxuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gKDAsIGpzX3lhbWxfMS5sb2FkKShyYXdEYXRhKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgKDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IpKGBDYW5ub3QgcGFyc2UgdXBkYXRlIGluZm8gZnJvbSAke2NoYW5uZWxGaWxlfSBpbiB0aGUgbGF0ZXN0IHJlbGVhc2UgYXJ0aWZhY3RzICgke2NoYW5uZWxGaWxlVXJsfSk6ICR7ZS5zdGFjayB8fCBlLm1lc3NhZ2V9LCByYXdEYXRhOiAke3Jhd0RhdGF9YCwgXCJFUlJfVVBEQVRFUl9JTlZBTElEX1VQREFURV9JTkZPXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5wYXJzZVVwZGF0ZUluZm8gPSBwYXJzZVVwZGF0ZUluZm87XG5mdW5jdGlvbiBnZXRGaWxlTGlzdCh1cGRhdGVJbmZvKSB7XG4gICAgY29uc3QgZmlsZXMgPSB1cGRhdGVJbmZvLmZpbGVzO1xuICAgIGlmIChmaWxlcyAhPSBudWxsICYmIGZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGZpbGVzO1xuICAgIH1cbiAgICAvLyBub2luc3BlY3Rpb24gSlNEZXByZWNhdGVkU3ltYm9sc1xuICAgIGlmICh1cGRhdGVJbmZvLnBhdGggIT0gbnVsbCkge1xuICAgICAgICAvLyBub2luc3BlY3Rpb24gSlNEZXByZWNhdGVkU3ltYm9sc1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHVybDogdXBkYXRlSW5mby5wYXRoLFxuICAgICAgICAgICAgICAgIHNoYTI6IHVwZGF0ZUluZm8uc2hhMixcbiAgICAgICAgICAgICAgICBzaGE1MTI6IHVwZGF0ZUluZm8uc2hhNTEyLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93ICgwLCBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKShgTm8gZmlsZXMgcHJvdmlkZWQ6ICR7KDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuc2FmZVN0cmluZ2lmeUpzb24pKHVwZGF0ZUluZm8pfWAsIFwiRVJSX1VQREFURVJfTk9fRklMRVNfUFJPVklERURcIik7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRGaWxlTGlzdCA9IGdldEZpbGVMaXN0O1xuZnVuY3Rpb24gcmVzb2x2ZUZpbGVzKHVwZGF0ZUluZm8sIGJhc2VVcmwsIHBhdGhUcmFuc2Zvcm1lciA9IChwKSA9PiBwKSB7XG4gICAgY29uc3QgZmlsZXMgPSBnZXRGaWxlTGlzdCh1cGRhdGVJbmZvKTtcbiAgICBjb25zdCByZXN1bHQgPSBmaWxlcy5tYXAoZmlsZUluZm8gPT4ge1xuICAgICAgICBpZiAoZmlsZUluZm8uc2hhMiA9PSBudWxsICYmIGZpbGVJbmZvLnNoYTUxMiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcikoYFVwZGF0ZSBpbmZvIGRvZXNuJ3QgY29udGFpbiBub3Igc2hhMjU2IG5laXRoZXIgc2hhNTEyIGNoZWNrc3VtOiAkeygwLCBidWlsZGVyX3V0aWxfcnVudGltZV8xLnNhZmVTdHJpbmdpZnlKc29uKShmaWxlSW5mbyl9YCwgXCJFUlJfVVBEQVRFUl9OT19DSEVDS1NVTVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXJsOiAoMCwgdXRpbF8xLm5ld1VybEZyb21CYXNlKShwYXRoVHJhbnNmb3JtZXIoZmlsZUluZm8udXJsKSwgYmFzZVVybCksXG4gICAgICAgICAgICBpbmZvOiBmaWxlSW5mbyxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBwYWNrYWdlcyA9IHVwZGF0ZUluZm8ucGFja2FnZXM7XG4gICAgY29uc3QgcGFja2FnZUluZm8gPSBwYWNrYWdlcyA9PSBudWxsID8gbnVsbCA6IHBhY2thZ2VzW3Byb2Nlc3MuYXJjaF0gfHwgcGFja2FnZXMuaWEzMjtcbiAgICBpZiAocGFja2FnZUluZm8gIT0gbnVsbCkge1xuICAgICAgICA7XG4gICAgICAgIHJlc3VsdFswXS5wYWNrYWdlSW5mbyA9IHtcbiAgICAgICAgICAgIC4uLnBhY2thZ2VJbmZvLFxuICAgICAgICAgICAgcGF0aDogKDAsIHV0aWxfMS5uZXdVcmxGcm9tQmFzZSkocGF0aFRyYW5zZm9ybWVyKHBhY2thZ2VJbmZvLnBhdGgpLCBiYXNlVXJsKS5ocmVmLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5yZXNvbHZlRmlsZXMgPSByZXNvbHZlRmlsZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qcm92aWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR2VuZXJpY1Byb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgYnVpbGRlcl91dGlsX3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL1Byb3ZpZGVyXCIpO1xuY2xhc3MgR2VuZXJpY1Byb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJfMS5Qcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbiwgdXBkYXRlciwgcnVudGltZU9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIocnVudGltZU9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSBjb25maWd1cmF0aW9uO1xuICAgICAgICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyO1xuICAgICAgICB0aGlzLmJhc2VVcmwgPSAoMCwgdXRpbF8xLm5ld0Jhc2VVcmwpKHRoaXMuY29uZmlndXJhdGlvbi51cmwpO1xuICAgIH1cbiAgICBnZXQgY2hhbm5lbCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy51cGRhdGVyLmNoYW5uZWwgfHwgdGhpcy5jb25maWd1cmF0aW9uLmNoYW5uZWw7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT0gbnVsbCA/IHRoaXMuZ2V0RGVmYXVsdENoYW5uZWxOYW1lKCkgOiB0aGlzLmdldEN1c3RvbUNoYW5uZWxOYW1lKHJlc3VsdCk7XG4gICAgfVxuICAgIGFzeW5jIGdldExhdGVzdFZlcnNpb24oKSB7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxGaWxlID0gKDAsIHV0aWxfMS5nZXRDaGFubmVsRmlsZW5hbWUpKHRoaXMuY2hhbm5lbCk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxVcmwgPSAoMCwgdXRpbF8xLm5ld1VybEZyb21CYXNlKShjaGFubmVsRmlsZSwgdGhpcy5iYXNlVXJsLCB0aGlzLnVwZGF0ZXIuaXNBZGROb0NhY2hlUXVlcnkpO1xuICAgICAgICBmb3IgKGxldCBhdHRlbXB0TnVtYmVyID0gMDs7IGF0dGVtcHROdW1iZXIrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIFByb3ZpZGVyXzEucGFyc2VVcGRhdGVJbmZvKShhd2FpdCB0aGlzLmh0dHBSZXF1ZXN0KGNoYW5uZWxVcmwpLCBjaGFubmVsRmlsZSwgY2hhbm5lbFVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5IdHRwRXJyb3IgJiYgZS5zdGF0dXNDb2RlID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgKDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IpKGBDYW5ub3QgZmluZCBjaGFubmVsIFwiJHtjaGFubmVsRmlsZX1cIiB1cGRhdGUgaW5mbzogJHtlLnN0YWNrIHx8IGUubWVzc2FnZX1gLCBcIkVSUl9VUERBVEVSX0NIQU5ORUxfRklMRV9OT1RfRk9VTkRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGUuY29kZSA9PT0gXCJFQ09OTlJFRlVTRURcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdE51bWJlciA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDAgKiBhdHRlbXB0TnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNvbHZlRmlsZXModXBkYXRlSW5mbykge1xuICAgICAgICByZXR1cm4gKDAsIFByb3ZpZGVyXzEucmVzb2x2ZUZpbGVzKSh1cGRhdGVJbmZvLCB0aGlzLmJhc2VVcmwpO1xuICAgIH1cbn1cbmV4cG9ydHMuR2VuZXJpY1Byb3ZpZGVyID0gR2VuZXJpY1Byb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2VuZXJpY1Byb3ZpZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CaXRidWNrZXRQcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IFByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9Qcm92aWRlclwiKTtcbmNsYXNzIEJpdGJ1Y2tldFByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJfMS5Qcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbiwgdXBkYXRlciwgcnVudGltZU9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgLi4ucnVudGltZU9wdGlvbnMsXG4gICAgICAgICAgICBpc1VzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0OiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgICAgIHRoaXMudXBkYXRlciA9IHVwZGF0ZXI7XG4gICAgICAgIGNvbnN0IHsgb3duZXIsIHNsdWcgfSA9IGNvbmZpZ3VyYXRpb247XG4gICAgICAgIHRoaXMuYmFzZVVybCA9ICgwLCB1dGlsXzEubmV3QmFzZVVybCkoYGh0dHBzOi8vYXBpLmJpdGJ1Y2tldC5vcmcvMi4wL3JlcG9zaXRvcmllcy8ke293bmVyfS8ke3NsdWd9L2Rvd25sb2Fkc2ApO1xuICAgIH1cbiAgICBnZXQgY2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlci5jaGFubmVsIHx8IHRoaXMuY29uZmlndXJhdGlvbi5jaGFubmVsIHx8IFwibGF0ZXN0XCI7XG4gICAgfVxuICAgIGFzeW5jIGdldExhdGVzdFZlcnNpb24oKSB7XG4gICAgICAgIGNvbnN0IGNhbmNlbGxhdGlvblRva2VuID0gbmV3IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuQ2FuY2VsbGF0aW9uVG9rZW4oKTtcbiAgICAgICAgY29uc3QgY2hhbm5lbEZpbGUgPSAoMCwgdXRpbF8xLmdldENoYW5uZWxGaWxlbmFtZSkodGhpcy5nZXRDdXN0b21DaGFubmVsTmFtZSh0aGlzLmNoYW5uZWwpKTtcbiAgICAgICAgY29uc3QgY2hhbm5lbFVybCA9ICgwLCB1dGlsXzEubmV3VXJsRnJvbUJhc2UpKGNoYW5uZWxGaWxlLCB0aGlzLmJhc2VVcmwsIHRoaXMudXBkYXRlci5pc0FkZE5vQ2FjaGVRdWVyeSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVJbmZvID0gYXdhaXQgdGhpcy5odHRwUmVxdWVzdChjaGFubmVsVXJsLCB1bmRlZmluZWQsIGNhbmNlbGxhdGlvblRva2VuKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgUHJvdmlkZXJfMS5wYXJzZVVwZGF0ZUluZm8pKHVwZGF0ZUluZm8sIGNoYW5uZWxGaWxlLCBjaGFubmVsVXJsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IpKGBVbmFibGUgdG8gZmluZCBsYXRlc3QgdmVyc2lvbiBvbiAke3RoaXMudG9TdHJpbmcoKX0sIHBsZWFzZSBlbnN1cmUgcmVsZWFzZSBleGlzdHM6ICR7ZS5zdGFjayB8fCBlLm1lc3NhZ2V9YCwgXCJFUlJfVVBEQVRFUl9MQVRFU1RfVkVSU0lPTl9OT1RfRk9VTkRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzb2x2ZUZpbGVzKHVwZGF0ZUluZm8pIHtcbiAgICAgICAgcmV0dXJuICgwLCBQcm92aWRlcl8xLnJlc29sdmVGaWxlcykodXBkYXRlSW5mbywgdGhpcy5iYXNlVXJsKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHsgb3duZXIsIHNsdWcgfSA9IHRoaXMuY29uZmlndXJhdGlvbjtcbiAgICAgICAgcmV0dXJuIGBCaXRidWNrZXQgKG93bmVyOiAke293bmVyfSwgc2x1ZzogJHtzbHVnfSwgY2hhbm5lbDogJHt0aGlzLmNoYW5uZWx9KWA7XG4gICAgfVxufVxuZXhwb3J0cy5CaXRidWNrZXRQcm92aWRlciA9IEJpdGJ1Y2tldFByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qml0YnVja2V0UHJvdmlkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbXB1dGVSZWxlYXNlTm90ZXMgPSBleHBvcnRzLkdpdEh1YlByb3ZpZGVyID0gZXhwb3J0cy5CYXNlR2l0SHViUHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCBidWlsZGVyX3V0aWxfcnVudGltZV8xID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xuY29uc3Qgc2VtdmVyID0gcmVxdWlyZShcInNlbXZlclwiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL1Byb3ZpZGVyXCIpO1xuY29uc3QgaHJlZlJlZ0V4cCA9IC9cXC90YWdcXC8oW14vXSspJC87XG5jbGFzcyBCYXNlR2l0SHViUHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlcl8xLlByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBkZWZhdWx0SG9zdCwgcnVudGltZU9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgLi4ucnVudGltZU9wdGlvbnMsXG4gICAgICAgICAgICAvKiBiZWNhdXNlIEdpdEhpYiB1c2VzIFMzICovXG4gICAgICAgICAgICBpc1VzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0OiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuYmFzZVVybCA9ICgwLCB1dGlsXzEubmV3QmFzZVVybCkoKDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuZ2l0aHViVXJsKShvcHRpb25zLCBkZWZhdWx0SG9zdCkpO1xuICAgICAgICBjb25zdCBhcGlIb3N0ID0gZGVmYXVsdEhvc3QgPT09IFwiZ2l0aHViLmNvbVwiID8gXCJhcGkuZ2l0aHViLmNvbVwiIDogZGVmYXVsdEhvc3Q7XG4gICAgICAgIHRoaXMuYmFzZUFwaVVybCA9ICgwLCB1dGlsXzEubmV3QmFzZVVybCkoKDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuZ2l0aHViVXJsKShvcHRpb25zLCBhcGlIb3N0KSk7XG4gICAgfVxuICAgIGNvbXB1dGVHaXRodWJCYXNlUGF0aChyZXN1bHQpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uLXVzZXJsYW5kL2VsZWN0cm9uLWJ1aWxkZXIvaXNzdWVzLzE5MDMjaXNzdWVjb21tZW50LTMyMDg4MTIxMVxuICAgICAgICBjb25zdCBob3N0ID0gdGhpcy5vcHRpb25zLmhvc3Q7XG4gICAgICAgIHJldHVybiBob3N0ICYmICFbXCJnaXRodWIuY29tXCIsIFwiYXBpLmdpdGh1Yi5jb21cIl0uaW5jbHVkZXMoaG9zdCkgPyBgL2FwaS92MyR7cmVzdWx0fWAgOiByZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlR2l0SHViUHJvdmlkZXIgPSBCYXNlR2l0SHViUHJvdmlkZXI7XG5jbGFzcyBHaXRIdWJQcm92aWRlciBleHRlbmRzIEJhc2VHaXRIdWJQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgdXBkYXRlciwgcnVudGltZU9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucywgXCJnaXRodWIuY29tXCIsIHJ1bnRpbWVPcHRpb25zKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlcjtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TGF0ZXN0VmVyc2lvbigpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCBjYW5jZWxsYXRpb25Ub2tlbiA9IG5ldyBidWlsZGVyX3V0aWxfcnVudGltZV8xLkNhbmNlbGxhdGlvblRva2VuKCk7XG4gICAgICAgIGNvbnN0IGZlZWRYbWwgPSAoYXdhaXQgdGhpcy5odHRwUmVxdWVzdCgoMCwgdXRpbF8xLm5ld1VybEZyb21CYXNlKShgJHt0aGlzLmJhc2VQYXRofS5hdG9tYCwgdGhpcy5iYXNlVXJsKSwge1xuICAgICAgICAgICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL3htbCwgYXBwbGljYXRpb24vYXRvbSt4bWwsIHRleHQveG1sLCAqLypcIixcbiAgICAgICAgfSwgY2FuY2VsbGF0aW9uVG9rZW4pKTtcbiAgICAgICAgY29uc3QgZmVlZCA9ICgwLCBidWlsZGVyX3V0aWxfcnVudGltZV8xLnBhcnNlWG1sKShmZWVkWG1sKTtcbiAgICAgICAgLy8gbm9pbnNwZWN0aW9uIFR5cGVTY3JpcHRWYWxpZGF0ZUpTVHlwZXNcbiAgICAgICAgbGV0IGxhdGVzdFJlbGVhc2UgPSBmZWVkLmVsZW1lbnQoXCJlbnRyeVwiLCBmYWxzZSwgYE5vIHB1Ymxpc2hlZCB2ZXJzaW9ucyBvbiBHaXRIdWJgKTtcbiAgICAgICAgbGV0IHRhZyA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy51cGRhdGVyLmFsbG93UHJlcmVsZWFzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDaGFubmVsID0gKChfYSA9IHRoaXMudXBkYXRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNoYW5uZWwpIHx8ICgoX2IgPSBzZW12ZXIucHJlcmVsZWFzZSh0aGlzLnVwZGF0ZXIuY3VycmVudFZlcnNpb24pKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbMF0pIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFubmVsID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vaW5zcGVjdGlvbiBUeXBlU2NyaXB0VmFsaWRhdGVKU1R5cGVzXG4gICAgICAgICAgICAgICAgICAgIHRhZyA9IGhyZWZSZWdFeHAuZXhlYyhsYXRlc3RSZWxlYXNlLmVsZW1lbnQoXCJsaW5rXCIpLmF0dHJpYnV0ZShcImhyZWZcIikpWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGZlZWQuZ2V0RWxlbWVudHMoXCJlbnRyeVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9pbnNwZWN0aW9uIFR5cGVTY3JpcHRWYWxpZGF0ZUpTVHlwZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhyZWZFbGVtZW50ID0gaHJlZlJlZ0V4cC5leGVjKGVsZW1lbnQuZWxlbWVudChcImxpbmtcIikuYXR0cmlidXRlKFwiaHJlZlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIG51bGwgdGhlbiBzb21ldGhpbmcgaXMgd3JvbmcgYW5kIHNraXAgdGhpcyByZWxlYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHJlZkVsZW1lbnQgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIFJlbGVhc2UncyBUYWdcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhyZWZUYWcgPSBocmVmRWxlbWVudFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vR2V0IENoYW5uZWwgZnJvbSB0aGlzIHJlbGVhc2UncyB0YWdcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhyZWZDaGFubmVsID0gKChfYyA9IHNlbXZlci5wcmVyZWxlYXNlKGhyZWZUYWcpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NbMF0pIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRGZXRjaFZlcnNpb24gPSAhY3VycmVudENoYW5uZWwgfHwgW1wiYWxwaGFcIiwgXCJiZXRhXCJdLmluY2x1ZGVzKGN1cnJlbnRDaGFubmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzQ3VzdG9tQ2hhbm5lbCA9ICFbXCJhbHBoYVwiLCBcImJldGFcIl0uaW5jbHVkZXMoU3RyaW5nKGhyZWZDaGFubmVsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyBtb3ZpbmcgZnJvbSBhbHBoYSB0byBiZXRhIGJ1dCBub3QgZG93blxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbE1pc21hdGNoID0gY3VycmVudENoYW5uZWwgPT09IFwiYmV0YVwiICYmIGhyZWZDaGFubmVsID09PSBcImFscGhhXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkRmV0Y2hWZXJzaW9uICYmICFpc0N1c3RvbUNoYW5uZWwgJiYgIWNoYW5uZWxNaXNtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZyA9IGhyZWZUYWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc05leHRQcmVSZWxlYXNlID0gaHJlZkNoYW5uZWwgJiYgaHJlZkNoYW5uZWwgPT09IGN1cnJlbnRDaGFubmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmV4dFByZVJlbGVhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWcgPSBocmVmVGFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFnID0gYXdhaXQgdGhpcy5nZXRMYXRlc3RUYWdOYW1lKGNhbmNlbGxhdGlvblRva2VuKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZmVlZC5nZXRFbGVtZW50cyhcImVudHJ5XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vaW5zcGVjdGlvbiBUeXBlU2NyaXB0VmFsaWRhdGVKU1R5cGVzXG4gICAgICAgICAgICAgICAgICAgIGlmIChocmVmUmVnRXhwLmV4ZWMoZWxlbWVudC5lbGVtZW50KFwibGlua1wiKS5hdHRyaWJ1dGUoXCJocmVmXCIpKVsxXSA9PT0gdGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXRlc3RSZWxlYXNlID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcikoYENhbm5vdCBwYXJzZSByZWxlYXNlcyBmZWVkOiAke2Uuc3RhY2sgfHwgZS5tZXNzYWdlfSxcXG5YTUw6XFxuJHtmZWVkWG1sfWAsIFwiRVJSX1VQREFURVJfSU5WQUxJRF9SRUxFQVNFX0ZFRURcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcikoYE5vIHB1Ymxpc2hlZCB2ZXJzaW9ucyBvbiBHaXRIdWJgLCBcIkVSUl9VUERBVEVSX05PX1BVQkxJU0hFRF9WRVJTSU9OU1wiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmF3RGF0YTtcbiAgICAgICAgbGV0IGNoYW5uZWxGaWxlID0gXCJcIjtcbiAgICAgICAgbGV0IGNoYW5uZWxGaWxlVXJsID0gXCJcIjtcbiAgICAgICAgY29uc3QgZmV0Y2hEYXRhID0gYXN5bmMgKGNoYW5uZWxOYW1lKSA9PiB7XG4gICAgICAgICAgICBjaGFubmVsRmlsZSA9ICgwLCB1dGlsXzEuZ2V0Q2hhbm5lbEZpbGVuYW1lKShjaGFubmVsTmFtZSk7XG4gICAgICAgICAgICBjaGFubmVsRmlsZVVybCA9ICgwLCB1dGlsXzEubmV3VXJsRnJvbUJhc2UpKHRoaXMuZ2V0QmFzZURvd25sb2FkUGF0aChTdHJpbmcodGFnKSwgY2hhbm5lbEZpbGUpLCB0aGlzLmJhc2VVcmwpO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSB0aGlzLmNyZWF0ZVJlcXVlc3RPcHRpb25zKGNoYW5uZWxGaWxlVXJsKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmV4ZWN1dG9yLnJlcXVlc3QocmVxdWVzdE9wdGlvbnMsIGNhbmNlbGxhdGlvblRva2VuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5IdHRwRXJyb3IgJiYgZS5zdGF0dXNDb2RlID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgKDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IpKGBDYW5ub3QgZmluZCAke2NoYW5uZWxGaWxlfSBpbiB0aGUgbGF0ZXN0IHJlbGVhc2UgYXJ0aWZhY3RzICgke2NoYW5uZWxGaWxlVXJsfSk6ICR7ZS5zdGFjayB8fCBlLm1lc3NhZ2V9YCwgXCJFUlJfVVBEQVRFUl9DSEFOTkVMX0ZJTEVfTk9UX0ZPVU5EXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMudXBkYXRlci5hbGxvd1ByZXJlbGVhc2UgPyB0aGlzLmdldEN1c3RvbUNoYW5uZWxOYW1lKFN0cmluZygoKF9kID0gc2VtdmVyLnByZXJlbGVhc2UodGFnKSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kWzBdKSB8fCBcImxhdGVzdFwiKSkgOiB0aGlzLmdldERlZmF1bHRDaGFubmVsTmFtZSgpO1xuICAgICAgICAgICAgcmF3RGF0YSA9IGF3YWl0IGZldGNoRGF0YShjaGFubmVsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudXBkYXRlci5hbGxvd1ByZXJlbGVhc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBBbGxvdyBmYWxsYmFjayB0byBgbGF0ZXN0LnltbGBcbiAgICAgICAgICAgICAgICByYXdEYXRhID0gYXdhaXQgZmV0Y2hEYXRhKHRoaXMuZ2V0RGVmYXVsdENoYW5uZWxOYW1lKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSAoMCwgUHJvdmlkZXJfMS5wYXJzZVVwZGF0ZUluZm8pKHJhd0RhdGEsIGNoYW5uZWxGaWxlLCBjaGFubmVsRmlsZVVybCk7XG4gICAgICAgIGlmIChyZXN1bHQucmVsZWFzZU5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnJlbGVhc2VOYW1lID0gbGF0ZXN0UmVsZWFzZS5lbGVtZW50VmFsdWVPckVtcHR5KFwidGl0bGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5yZWxlYXNlTm90ZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnJlbGVhc2VOb3RlcyA9IGNvbXB1dGVSZWxlYXNlTm90ZXModGhpcy51cGRhdGVyLmN1cnJlbnRWZXJzaW9uLCB0aGlzLnVwZGF0ZXIuZnVsbENoYW5nZWxvZywgZmVlZCwgbGF0ZXN0UmVsZWFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBnZXRMYXRlc3RUYWdOYW1lKGNhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIC8vIGRvIG5vdCB1c2UgQVBJIGZvciBHaXRIdWIgdG8gYXZvaWQgbGltaXQsIG9ubHkgZm9yIGN1c3RvbSBob3N0IG9yIEdpdEh1YiBFbnRlcnByaXNlXG4gICAgICAgIGNvbnN0IHVybCA9IG9wdGlvbnMuaG9zdCA9PSBudWxsIHx8IG9wdGlvbnMuaG9zdCA9PT0gXCJnaXRodWIuY29tXCJcbiAgICAgICAgICAgID8gKDAsIHV0aWxfMS5uZXdVcmxGcm9tQmFzZSkoYCR7dGhpcy5iYXNlUGF0aH0vbGF0ZXN0YCwgdGhpcy5iYXNlVXJsKVxuICAgICAgICAgICAgOiBuZXcgdXJsXzEuVVJMKGAke3RoaXMuY29tcHV0ZUdpdGh1YkJhc2VQYXRoKGAvcmVwb3MvJHtvcHRpb25zLm93bmVyfS8ke29wdGlvbnMucmVwb30vcmVsZWFzZXNgKX0vbGF0ZXN0YCwgdGhpcy5iYXNlQXBpVXJsKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJhd0RhdGEgPSBhd2FpdCB0aGlzLmh0dHBSZXF1ZXN0KHVybCwgeyBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiIH0sIGNhbmNlbGxhdGlvblRva2VuKTtcbiAgICAgICAgICAgIGlmIChyYXdEYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VJbmZvID0gSlNPTi5wYXJzZShyYXdEYXRhKTtcbiAgICAgICAgICAgIHJldHVybiByZWxlYXNlSW5mby50YWdfbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IpKGBVbmFibGUgdG8gZmluZCBsYXRlc3QgdmVyc2lvbiBvbiBHaXRIdWIgKCR7dXJsfSksIHBsZWFzZSBlbnN1cmUgYSBwcm9kdWN0aW9uIHJlbGVhc2UgZXhpc3RzOiAke2Uuc3RhY2sgfHwgZS5tZXNzYWdlfWAsIFwiRVJSX1VQREFURVJfTEFURVNUX1ZFUlNJT05fTk9UX0ZPVU5EXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBiYXNlUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIGAvJHt0aGlzLm9wdGlvbnMub3duZXJ9LyR7dGhpcy5vcHRpb25zLnJlcG99L3JlbGVhc2VzYDtcbiAgICB9XG4gICAgcmVzb2x2ZUZpbGVzKHVwZGF0ZUluZm8pIHtcbiAgICAgICAgLy8gc3RpbGwgcmVwbGFjZSBzcGFjZSB0byAtIGR1ZSB0byBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgIHJldHVybiAoMCwgUHJvdmlkZXJfMS5yZXNvbHZlRmlsZXMpKHVwZGF0ZUluZm8sIHRoaXMuYmFzZVVybCwgcCA9PiB0aGlzLmdldEJhc2VEb3dubG9hZFBhdGgodXBkYXRlSW5mby50YWcsIHAucmVwbGFjZSgvIC9nLCBcIi1cIikpKTtcbiAgICB9XG4gICAgZ2V0QmFzZURvd25sb2FkUGF0aCh0YWcsIGZpbGVOYW1lKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmJhc2VQYXRofS9kb3dubG9hZC8ke3RhZ30vJHtmaWxlTmFtZX1gO1xuICAgIH1cbn1cbmV4cG9ydHMuR2l0SHViUHJvdmlkZXIgPSBHaXRIdWJQcm92aWRlcjtcbmZ1bmN0aW9uIGdldE5vdGVWYWx1ZShwYXJlbnQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJlbnQuZWxlbWVudFZhbHVlT3JFbXB0eShcImNvbnRlbnRcIik7XG4gICAgLy8gR2l0SHViIHJlcG9ydHMgZW1wdHkgbm90ZXMgYXMgPGNvbnRlbnQ+Tm8gY29udGVudC48L2NvbnRlbnQ+XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gXCJObyBjb250ZW50LlwiID8gXCJcIiA6IHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVSZWxlYXNlTm90ZXMoY3VycmVudFZlcnNpb24sIGlzRnVsbENoYW5nZWxvZywgZmVlZCwgbGF0ZXN0UmVsZWFzZSkge1xuICAgIGlmICghaXNGdWxsQ2hhbmdlbG9nKSB7XG4gICAgICAgIHJldHVybiBnZXROb3RlVmFsdWUobGF0ZXN0UmVsZWFzZSk7XG4gICAgfVxuICAgIGNvbnN0IHJlbGVhc2VOb3RlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgcmVsZWFzZSBvZiBmZWVkLmdldEVsZW1lbnRzKFwiZW50cnlcIikpIHtcbiAgICAgICAgLy8gbm9pbnNwZWN0aW9uIFR5cGVTY3JpcHRWYWxpZGF0ZUpTVHlwZXNcbiAgICAgICAgY29uc3QgdmVyc2lvblJlbGVhc2UgPSAvXFwvdGFnXFwvdj8oW14vXSspJC8uZXhlYyhyZWxlYXNlLmVsZW1lbnQoXCJsaW5rXCIpLmF0dHJpYnV0ZShcImhyZWZcIikpWzFdO1xuICAgICAgICBpZiAoc2VtdmVyLmx0KGN1cnJlbnRWZXJzaW9uLCB2ZXJzaW9uUmVsZWFzZSkpIHtcbiAgICAgICAgICAgIHJlbGVhc2VOb3Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uUmVsZWFzZSxcbiAgICAgICAgICAgICAgICBub3RlOiBnZXROb3RlVmFsdWUocmVsZWFzZSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVsZWFzZU5vdGVzLnNvcnQoKGEsIGIpID0+IHNlbXZlci5yY29tcGFyZShhLnZlcnNpb24sIGIudmVyc2lvbikpO1xufVxuZXhwb3J0cy5jb21wdXRlUmVsZWFzZU5vdGVzID0gY29tcHV0ZVJlbGVhc2VOb3Rlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdpdEh1YlByb3ZpZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5LZXlnZW5Qcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IFByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9Qcm92aWRlclwiKTtcbmNsYXNzIEtleWdlblByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJfMS5Qcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbiwgdXBkYXRlciwgcnVudGltZU9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgLi4ucnVudGltZU9wdGlvbnMsXG4gICAgICAgICAgICBpc1VzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0OiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgICAgIHRoaXMudXBkYXRlciA9IHVwZGF0ZXI7XG4gICAgICAgIHRoaXMuYmFzZVVybCA9ICgwLCB1dGlsXzEubmV3QmFzZVVybCkoYGh0dHBzOi8vYXBpLmtleWdlbi5zaC92MS9hY2NvdW50cy8ke3RoaXMuY29uZmlndXJhdGlvbi5hY2NvdW50fS9hcnRpZmFjdHM/cHJvZHVjdD0ke3RoaXMuY29uZmlndXJhdGlvbi5wcm9kdWN0fWApO1xuICAgIH1cbiAgICBnZXQgY2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlci5jaGFubmVsIHx8IHRoaXMuY29uZmlndXJhdGlvbi5jaGFubmVsIHx8IFwic3RhYmxlXCI7XG4gICAgfVxuICAgIGFzeW5jIGdldExhdGVzdFZlcnNpb24oKSB7XG4gICAgICAgIGNvbnN0IGNhbmNlbGxhdGlvblRva2VuID0gbmV3IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuQ2FuY2VsbGF0aW9uVG9rZW4oKTtcbiAgICAgICAgY29uc3QgY2hhbm5lbEZpbGUgPSAoMCwgdXRpbF8xLmdldENoYW5uZWxGaWxlbmFtZSkodGhpcy5nZXRDdXN0b21DaGFubmVsTmFtZSh0aGlzLmNoYW5uZWwpKTtcbiAgICAgICAgY29uc3QgY2hhbm5lbFVybCA9ICgwLCB1dGlsXzEubmV3VXJsRnJvbUJhc2UpKGNoYW5uZWxGaWxlLCB0aGlzLmJhc2VVcmwsIHRoaXMudXBkYXRlci5pc0FkZE5vQ2FjaGVRdWVyeSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVJbmZvID0gYXdhaXQgdGhpcy5odHRwUmVxdWVzdChjaGFubmVsVXJsLCB7XG4gICAgICAgICAgICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL3ZuZC5hcGkranNvblwiLFxuICAgICAgICAgICAgICAgIFwiS2V5Z2VuLVZlcnNpb25cIjogXCIxLjFcIixcbiAgICAgICAgICAgIH0sIGNhbmNlbGxhdGlvblRva2VuKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgUHJvdmlkZXJfMS5wYXJzZVVwZGF0ZUluZm8pKHVwZGF0ZUluZm8sIGNoYW5uZWxGaWxlLCBjaGFubmVsVXJsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IpKGBVbmFibGUgdG8gZmluZCBsYXRlc3QgdmVyc2lvbiBvbiAke3RoaXMudG9TdHJpbmcoKX0sIHBsZWFzZSBlbnN1cmUgcmVsZWFzZSBleGlzdHM6ICR7ZS5zdGFjayB8fCBlLm1lc3NhZ2V9YCwgXCJFUlJfVVBEQVRFUl9MQVRFU1RfVkVSU0lPTl9OT1RfRk9VTkRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzb2x2ZUZpbGVzKHVwZGF0ZUluZm8pIHtcbiAgICAgICAgcmV0dXJuICgwLCBQcm92aWRlcl8xLnJlc29sdmVGaWxlcykodXBkYXRlSW5mbywgdGhpcy5iYXNlVXJsKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHsgYWNjb3VudCwgcHJvZHVjdCwgcGxhdGZvcm0gfSA9IHRoaXMuY29uZmlndXJhdGlvbjtcbiAgICAgICAgcmV0dXJuIGBLZXlnZW4gKGFjY291bnQ6ICR7YWNjb3VudH0sIHByb2R1Y3Q6ICR7cHJvZHVjdH0sIHBsYXRmb3JtOiAke3BsYXRmb3JtfSwgY2hhbm5lbDogJHt0aGlzLmNoYW5uZWx9KWA7XG4gICAgfVxufVxuZXhwb3J0cy5LZXlnZW5Qcm92aWRlciA9IEtleWdlblByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9S2V5Z2VuUHJvdmlkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByaXZhdGVHaXRIdWJQcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG5jb25zdCBqc195YW1sXzEgPSByZXF1aXJlKFwianMteWFtbFwiKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgR2l0SHViUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL0dpdEh1YlByb3ZpZGVyXCIpO1xuY29uc3QgUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL1Byb3ZpZGVyXCIpO1xuY2xhc3MgUHJpdmF0ZUdpdEh1YlByb3ZpZGVyIGV4dGVuZHMgR2l0SHViUHJvdmlkZXJfMS5CYXNlR2l0SHViUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHVwZGF0ZXIsIHRva2VuLCBydW50aW1lT3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zLCBcImFwaS5naXRodWIuY29tXCIsIHJ1bnRpbWVPcHRpb25zKTtcbiAgICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlcjtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIH1cbiAgICBjcmVhdGVSZXF1ZXN0T3B0aW9ucyh1cmwsIGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuY3JlYXRlUmVxdWVzdE9wdGlvbnModXJsLCBoZWFkZXJzKTtcbiAgICAgICAgcmVzdWx0LnJlZGlyZWN0ID0gXCJtYW51YWxcIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TGF0ZXN0VmVyc2lvbigpIHtcbiAgICAgICAgY29uc3QgY2FuY2VsbGF0aW9uVG9rZW4gPSBuZXcgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5DYW5jZWxsYXRpb25Ub2tlbigpO1xuICAgICAgICBjb25zdCBjaGFubmVsRmlsZSA9ICgwLCB1dGlsXzEuZ2V0Q2hhbm5lbEZpbGVuYW1lKSh0aGlzLmdldERlZmF1bHRDaGFubmVsTmFtZSgpKTtcbiAgICAgICAgY29uc3QgcmVsZWFzZUluZm8gPSBhd2FpdCB0aGlzLmdldExhdGVzdFZlcnNpb25JbmZvKGNhbmNlbGxhdGlvblRva2VuKTtcbiAgICAgICAgY29uc3QgYXNzZXQgPSByZWxlYXNlSW5mby5hc3NldHMuZmluZChpdCA9PiBpdC5uYW1lID09PSBjaGFubmVsRmlsZSk7XG4gICAgICAgIGlmIChhc3NldCA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBodG1sX3VybCBtdXN0IGJlIGFsd2F5cywgYnV0IGp1c3QgdG8gYmUgc3VyZVxuICAgICAgICAgICAgdGhyb3cgKDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IpKGBDYW5ub3QgZmluZCAke2NoYW5uZWxGaWxlfSBpbiB0aGUgcmVsZWFzZSAke3JlbGVhc2VJbmZvLmh0bWxfdXJsIHx8IHJlbGVhc2VJbmZvLm5hbWV9YCwgXCJFUlJfVVBEQVRFUl9DSEFOTkVMX0ZJTEVfTk9UX0ZPVU5EXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyB1cmxfMS5VUkwoYXNzZXQudXJsKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9ICgwLCBqc195YW1sXzEubG9hZCkoKGF3YWl0IHRoaXMuaHR0cFJlcXVlc3QodXJsLCB0aGlzLmNvbmZpZ3VyZUhlYWRlcnMoXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIiksIGNhbmNlbGxhdGlvblRva2VuKSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuSHR0cEVycm9yICYmIGUuc3RhdHVzQ29kZSA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IpKGBDYW5ub3QgZmluZCAke2NoYW5uZWxGaWxlfSBpbiB0aGUgbGF0ZXN0IHJlbGVhc2UgYXJ0aWZhY3RzICgke3VybH0pOiAke2Uuc3RhY2sgfHwgZS5tZXNzYWdlfWAsIFwiRVJSX1VQREFURVJfQ0hBTk5FTF9GSUxFX05PVF9GT1VORFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICByZXN1bHQuYXNzZXRzID0gcmVsZWFzZUluZm8uYXNzZXRzO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBnZXQgZmlsZUV4dHJhRG93bmxvYWRIZWFkZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmVIZWFkZXJzKFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LWZ1bmN0aW9uLXJldHVybi10eXBlXG4gICAgY29uZmlndXJlSGVhZGVycyhhY2NlcHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjY2VwdCxcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb246IGB0b2tlbiAke3RoaXMudG9rZW59YCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TGF0ZXN0VmVyc2lvbkluZm8oY2FuY2VsbGF0aW9uVG9rZW4pIHtcbiAgICAgICAgY29uc3QgYWxsb3dQcmVyZWxlYXNlID0gdGhpcy51cGRhdGVyLmFsbG93UHJlcmVsZWFzZTtcbiAgICAgICAgbGV0IGJhc2VQYXRoID0gdGhpcy5iYXNlUGF0aDtcbiAgICAgICAgaWYgKCFhbGxvd1ByZXJlbGVhc2UpIHtcbiAgICAgICAgICAgIGJhc2VQYXRoID0gYCR7YmFzZVBhdGh9L2xhdGVzdGA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gKDAsIHV0aWxfMS5uZXdVcmxGcm9tQmFzZSkoYmFzZVBhdGgsIHRoaXMuYmFzZVVybCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gSlNPTi5wYXJzZSgoYXdhaXQgdGhpcy5odHRwUmVxdWVzdCh1cmwsIHRoaXMuY29uZmlndXJlSGVhZGVycyhcImFwcGxpY2F0aW9uL3ZuZC5naXRodWIudjMranNvblwiKSwgY2FuY2VsbGF0aW9uVG9rZW4pKSk7XG4gICAgICAgICAgICBpZiAoYWxsb3dQcmVyZWxlYXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcnNpb24uZmluZChpdCA9PiBpdC5wcmVyZWxlYXNlKSB8fCB2ZXJzaW9uWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKShgVW5hYmxlIHRvIGZpbmQgbGF0ZXN0IHZlcnNpb24gb24gR2l0SHViICgke3VybH0pLCBwbGVhc2UgZW5zdXJlIGEgcHJvZHVjdGlvbiByZWxlYXNlIGV4aXN0czogJHtlLnN0YWNrIHx8IGUubWVzc2FnZX1gLCBcIkVSUl9VUERBVEVSX0xBVEVTVF9WRVJTSU9OX05PVF9GT1VORFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgYmFzZVBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVHaXRodWJCYXNlUGF0aChgL3JlcG9zLyR7dGhpcy5vcHRpb25zLm93bmVyfS8ke3RoaXMub3B0aW9ucy5yZXBvfS9yZWxlYXNlc2ApO1xuICAgIH1cbiAgICByZXNvbHZlRmlsZXModXBkYXRlSW5mbykge1xuICAgICAgICByZXR1cm4gKDAsIFByb3ZpZGVyXzEuZ2V0RmlsZUxpc3QpKHVwZGF0ZUluZm8pLm1hcChpdCA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gcGF0aC5wb3NpeC5iYXNlbmFtZShpdC51cmwpLnJlcGxhY2UoLyAvZywgXCItXCIpO1xuICAgICAgICAgICAgY29uc3QgYXNzZXQgPSB1cGRhdGVJbmZvLmFzc2V0cy5maW5kKGl0ID0+IGl0ICE9IG51bGwgJiYgaXQubmFtZSA9PT0gbmFtZSk7XG4gICAgICAgICAgICBpZiAoYXNzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKShgQ2Fubm90IGZpbmQgYXNzZXQgXCIke25hbWV9XCIgaW46ICR7SlNPTi5zdHJpbmdpZnkodXBkYXRlSW5mby5hc3NldHMsIG51bGwsIDIpfWAsIFwiRVJSX1VQREFURVJfQVNTRVRfTk9UX0ZPVU5EXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6IG5ldyB1cmxfMS5VUkwoYXNzZXQudXJsKSxcbiAgICAgICAgICAgICAgICBpbmZvOiBpdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJpdmF0ZUdpdEh1YlByb3ZpZGVyID0gUHJpdmF0ZUdpdEh1YlByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJpdmF0ZUdpdEh1YlByb3ZpZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVDbGllbnQgPSBleHBvcnRzLmlzVXJsUHJvYmFibHlTdXBwb3J0TXVsdGlSYW5nZVJlcXVlc3RzID0gdm9pZCAwO1xuY29uc3QgYnVpbGRlcl91dGlsX3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbmNvbnN0IEJpdGJ1Y2tldFByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlcnMvQml0YnVja2V0UHJvdmlkZXJcIik7XG5jb25zdCBHZW5lcmljUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVycy9HZW5lcmljUHJvdmlkZXJcIik7XG5jb25zdCBHaXRIdWJQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vcHJvdmlkZXJzL0dpdEh1YlByb3ZpZGVyXCIpO1xuY29uc3QgS2V5Z2VuUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVycy9LZXlnZW5Qcm92aWRlclwiKTtcbmNvbnN0IFByaXZhdGVHaXRIdWJQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vcHJvdmlkZXJzL1ByaXZhdGVHaXRIdWJQcm92aWRlclwiKTtcbmZ1bmN0aW9uIGlzVXJsUHJvYmFibHlTdXBwb3J0TXVsdGlSYW5nZVJlcXVlc3RzKHVybCkge1xuICAgIHJldHVybiAhdXJsLmluY2x1ZGVzKFwiczMuYW1hem9uYXdzLmNvbVwiKTtcbn1cbmV4cG9ydHMuaXNVcmxQcm9iYWJseVN1cHBvcnRNdWx0aVJhbmdlUmVxdWVzdHMgPSBpc1VybFByb2JhYmx5U3VwcG9ydE11bHRpUmFuZ2VSZXF1ZXN0cztcbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudChkYXRhLCB1cGRhdGVyLCBydW50aW1lT3B0aW9ucykge1xuICAgIC8vIG5vaW5zcGVjdGlvbiBTdXNwaWNpb3VzVHlwZU9mR3VhcmRcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgKDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IpKFwiUGxlYXNlIHBhc3MgUHVibGlzaENvbmZpZ3VyYXRpb24gb2JqZWN0XCIsIFwiRVJSX1VQREFURVJfSU5WQUxJRF9QUk9WSURFUl9DT05GSUdVUkFUSU9OXCIpO1xuICAgIH1cbiAgICBjb25zdCBwcm92aWRlciA9IGRhdGEucHJvdmlkZXI7XG4gICAgc3dpdGNoIChwcm92aWRlcikge1xuICAgICAgICBjYXNlIFwiZ2l0aHViXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IGdpdGh1Yk9wdGlvbnMgPSBkYXRhO1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSAoZ2l0aHViT3B0aW9ucy5wcml2YXRlID8gcHJvY2Vzcy5lbnZbXCJHSF9UT0tFTlwiXSB8fCBwcm9jZXNzLmVudltcIkdJVEhVQl9UT0tFTlwiXSA6IG51bGwpIHx8IGdpdGh1Yk9wdGlvbnMudG9rZW47XG4gICAgICAgICAgICBpZiAodG9rZW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR2l0SHViUHJvdmlkZXJfMS5HaXRIdWJQcm92aWRlcihnaXRodWJPcHRpb25zLCB1cGRhdGVyLCBydW50aW1lT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByaXZhdGVHaXRIdWJQcm92aWRlcl8xLlByaXZhdGVHaXRIdWJQcm92aWRlcihnaXRodWJPcHRpb25zLCB1cGRhdGVyLCB0b2tlbiwgcnVudGltZU9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJiaXRidWNrZXRcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQml0YnVja2V0UHJvdmlkZXJfMS5CaXRidWNrZXRQcm92aWRlcihkYXRhLCB1cGRhdGVyLCBydW50aW1lT3B0aW9ucyk7XG4gICAgICAgIGNhc2UgXCJrZXlnZW5cIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgS2V5Z2VuUHJvdmlkZXJfMS5LZXlnZW5Qcm92aWRlcihkYXRhLCB1cGRhdGVyLCBydW50aW1lT3B0aW9ucyk7XG4gICAgICAgIGNhc2UgXCJzM1wiOlxuICAgICAgICBjYXNlIFwic3BhY2VzXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNQcm92aWRlcl8xLkdlbmVyaWNQcm92aWRlcih7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IFwiZ2VuZXJpY1wiLFxuICAgICAgICAgICAgICAgIHVybDogKDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuZ2V0UzNMaWtlUHJvdmlkZXJCYXNlVXJsKShkYXRhKSxcbiAgICAgICAgICAgICAgICBjaGFubmVsOiBkYXRhLmNoYW5uZWwgfHwgbnVsbCxcbiAgICAgICAgICAgIH0sIHVwZGF0ZXIsIHtcbiAgICAgICAgICAgICAgICAuLi5ydW50aW1lT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWluaW8vbWluaW8vaXNzdWVzLzUyODUjaXNzdWVjb21tZW50LTM1MDQyODk1NVxuICAgICAgICAgICAgICAgIGlzVXNlTXVsdGlwbGVSYW5nZVJlcXVlc3Q6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgXCJnZW5lcmljXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBkYXRhO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljUHJvdmlkZXJfMS5HZW5lcmljUHJvdmlkZXIob3B0aW9ucywgdXBkYXRlciwge1xuICAgICAgICAgICAgICAgIC4uLnJ1bnRpbWVPcHRpb25zLFxuICAgICAgICAgICAgICAgIGlzVXNlTXVsdGlwbGVSYW5nZVJlcXVlc3Q6IG9wdGlvbnMudXNlTXVsdGlwbGVSYW5nZVJlcXVlc3QgIT09IGZhbHNlICYmIGlzVXJsUHJvYmFibHlTdXBwb3J0TXVsdGlSYW5nZVJlcXVlc3RzKG9wdGlvbnMudXJsKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJjdXN0b21cIjoge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGRhdGE7XG4gICAgICAgICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IG9wdGlvbnMudXBkYXRlUHJvdmlkZXI7XG4gICAgICAgICAgICBpZiAoIWNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IpKFwiQ3VzdG9tIHByb3ZpZGVyIG5vdCBzcGVjaWZpZWRcIiwgXCJFUlJfVVBEQVRFUl9JTlZBTElEX1BST1ZJREVSX0NPTkZJR1VSQVRJT05cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNvbnN0cnVjdG9yKG9wdGlvbnMsIHVwZGF0ZXIsIHJ1bnRpbWVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgKDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IpKGBVbnN1cHBvcnRlZCBwcm92aWRlcjogJHtwcm92aWRlcn1gLCBcIkVSUl9VUERBVEVSX1VOU1VQUE9SVEVEX1BST1ZJREVSXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlQ2xpZW50ID0gY3JlYXRlQ2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXJGYWN0b3J5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ob09wTG9nZ2VyID0gZXhwb3J0cy5BcHBVcGRhdGVyID0gdm9pZCAwO1xuY29uc3QgYnVpbGRlcl91dGlsX3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IGZzX2V4dHJhXzEgPSByZXF1aXJlKFwiZnMtZXh0cmFcIik7XG5jb25zdCBqc195YW1sXzEgPSByZXF1aXJlKFwianMteWFtbFwiKTtcbmNvbnN0IGxhenlfdmFsXzEgPSByZXF1aXJlKFwibGF6eS12YWxcIik7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBzZW12ZXJfMSA9IHJlcXVpcmUoXCJzZW12ZXJcIik7XG5jb25zdCBEb3dubG9hZGVkVXBkYXRlSGVscGVyXzEgPSByZXF1aXJlKFwiLi9Eb3dubG9hZGVkVXBkYXRlSGVscGVyXCIpO1xuY29uc3QgRWxlY3Ryb25BcHBBZGFwdGVyXzEgPSByZXF1aXJlKFwiLi9FbGVjdHJvbkFwcEFkYXB0ZXJcIik7XG5jb25zdCBlbGVjdHJvbkh0dHBFeGVjdXRvcl8xID0gcmVxdWlyZShcIi4vZWxlY3Ryb25IdHRwRXhlY3V0b3JcIik7XG5jb25zdCBHZW5lcmljUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVycy9HZW5lcmljUHJvdmlkZXJcIik7XG5jb25zdCBtYWluXzEgPSByZXF1aXJlKFwiLi9tYWluXCIpO1xuY29uc3QgcHJvdmlkZXJGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi9wcm92aWRlckZhY3RvcnlcIik7XG5jbGFzcyBBcHBVcGRhdGVyIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhcHApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdG8gYXV0b21hdGljYWxseSBkb3dubG9hZCBhbiB1cGRhdGUgd2hlbiBpdCBpcyBmb3VuZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXV0b0Rvd25sb2FkID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdG8gYXV0b21hdGljYWxseSBpbnN0YWxsIGEgZG93bmxvYWRlZCB1cGRhdGUgb24gYXBwIHF1aXQgKGlmIGBxdWl0QW5kSW5zdGFsbGAgd2FzIG5vdCBjYWxsZWQgYmVmb3JlKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXV0b0luc3RhbGxPbkFwcFF1aXQgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogKndpbmRvd3Mtb25seSogV2hldGhlciB0byBydW4gdGhlIGFwcCBhZnRlciBmaW5pc2ggaW5zdGFsbCB3aGVuIHJ1biB0aGUgaW5zdGFsbGVyIE5PVCBpbiBzaWxlbnQgbW9kZS5cbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hdXRvUnVuQXBwQWZ0ZXJJbnN0YWxsID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICpHaXRIdWIgcHJvdmlkZXIgb25seS4qIFdoZXRoZXIgdG8gYWxsb3cgdXBkYXRlIHRvIHByZS1yZWxlYXNlIHZlcnNpb25zLiBEZWZhdWx0cyB0byBgdHJ1ZWAgaWYgYXBwbGljYXRpb24gdmVyc2lvbiBjb250YWlucyBwcmVyZWxlYXNlIGNvbXBvbmVudHMgKGUuZy4gYDAuMTIuMS1hbHBoYS4xYCwgaGVyZSBgYWxwaGFgIGlzIGEgcHJlcmVsZWFzZSBjb21wb25lbnQpLCBvdGhlcndpc2UgYGZhbHNlYC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYHRydWVgLCBkb3duZ3JhZGUgd2lsbCBiZSBhbGxvd2VkIChgYWxsb3dEb3duZ3JhZGVgIHdpbGwgYmUgc2V0IHRvIGB0cnVlYCkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFsbG93UHJlcmVsZWFzZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogKkdpdEh1YiBwcm92aWRlciBvbmx5LiogR2V0IGFsbCByZWxlYXNlIG5vdGVzIChmcm9tIGN1cnJlbnQgdmVyc2lvbiB0byBsYXRlc3QpLCBub3QganVzdCB0aGUgbGF0ZXN0LlxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mdWxsQ2hhbmdlbG9nID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRvIGFsbG93IHZlcnNpb24gZG93bmdyYWRlICh3aGVuIGEgdXNlciBmcm9tIHRoZSBiZXRhIGNoYW5uZWwgd2FudHMgdG8gZ28gYmFjayB0byB0aGUgc3RhYmxlIGNoYW5uZWwpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUYWtlbiBpbiBhY2NvdW50IG9ubHkgaWYgY2hhbm5lbCBkaWZmZXJzIChwcmUtcmVsZWFzZSB2ZXJzaW9uIGNvbXBvbmVudCBpbiB0ZXJtcyBvZiBzZW1hbnRpYyB2ZXJzaW9uaW5nKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWxsb3dEb3duZ3JhZGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlYiBpbnN0YWxsZXIgZmlsZXMgbWlnaHQgbm90IGhhdmUgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiwgdGhpcyBzd2l0Y2ggcHJldmVudHMgdG8gbG9hZCB0aGVtIHVubGVzcyBpdCBpcyBuZWVkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEN1cnJlbnRseSBmYWxzZSB0byBwcmV2ZW50IGJyZWFraW5nIHRoZSBjdXJyZW50IEFQSSwgYnV0IGl0IHNob3VsZCBiZSBjaGFuZ2VkIHRvIGRlZmF1bHQgdHJ1ZSBhdCBzb21lIHBvaW50IHRoYXRcbiAgICAgICAgICogYnJlYWtpbmcgY2hhbmdlcyBhcmUgYWxsb3dlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZVdlYkluc3RhbGxlciA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxsb3dzIGRldmVsb3BlciB0byBmb3JjZSB0aGUgdXBkYXRlciB0byB3b3JrIGluIFwiZGV2XCIgbW9kZSwgbG9va2luZyBmb3IgXCJkZXYtYXBwLXVwZGF0ZS55bWxcIiBpbnN0ZWFkIG9mIFwiYXBwLXVwZGF0ZS55bWxcIlxuICAgICAgICAgKiBEZXY6IGBwYXRoLmpvaW4odGhpcy5hcHAuZ2V0QXBwUGF0aCgpLCBcImRldi1hcHAtdXBkYXRlLnltbFwiKWBcbiAgICAgICAgICogUHJvZDogYHBhdGguam9pbihwcm9jZXNzLnJlc291cmNlc1BhdGghLCBcImFwcC11cGRhdGUueW1sXCIpYFxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JjZURldlVwZGF0ZUNvbmZpZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jaGFubmVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb3dubG9hZGVkVXBkYXRlSGVscGVyID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICBUaGUgcmVxdWVzdCBoZWFkZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXF1ZXN0SGVhZGVycyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IGNvbnNvbGU7XG4gICAgICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvciB0eXBlIHNhZmV0eSB5b3UgY2FuIHVzZSBzaWduYWxzLCBlLmcuIGBhdXRvVXBkYXRlci5zaWduYWxzLnVwZGF0ZURvd25sb2FkZWQoKCkgPT4ge30pYCBpbnN0ZWFkIG9mIGBhdXRvVXBkYXRlci5vbigndXBkYXRlLWF2YWlsYWJsZScsICgpID0+IHt9KWBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2lnbmFscyA9IG5ldyBtYWluXzEuVXBkYXRlclNpZ25hbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fYXBwVXBkYXRlQ29uZmlnUGF0aCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2xpZW50UHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhZ2luZ1VzZXJJZFByb21pc2UgPSBuZXcgbGF6eV92YWxfMS5MYXp5KCgpID0+IHRoaXMuZ2V0T3JDcmVhdGVTdGFnaW5nVXNlcklkKCkpO1xuICAgICAgICAvLyBwdWJsaWMsIGFsbG93IHRvIHJlYWQgb2xkIGNvbmZpZyBmb3IgYW55b25lXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5jb25maWdPbkRpc2sgPSBuZXcgbGF6eV92YWxfMS5MYXp5KCgpID0+IHRoaXMubG9hZFVwZGF0ZUNvbmZpZygpKTtcbiAgICAgICAgdGhpcy5jaGVja0ZvclVwZGF0ZXNQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy51cGRhdGVJbmZvQW5kUHJvdmlkZXIgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90ZXN0T25seU9wdGlvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLm9uKFwiZXJyb3JcIiwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoYEVycm9yOiAke2Vycm9yLnN0YWNrIHx8IGVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYXBwID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwID0gbmV3IEVsZWN0cm9uQXBwQWRhcHRlcl8xLkVsZWN0cm9uQXBwQWRhcHRlcigpO1xuICAgICAgICAgICAgdGhpcy5odHRwRXhlY3V0b3IgPSBuZXcgZWxlY3Ryb25IdHRwRXhlY3V0b3JfMS5FbGVjdHJvbkh0dHBFeGVjdXRvcigoYXV0aEluZm8sIGNhbGxiYWNrKSA9PiB0aGlzLmVtaXQoXCJsb2dpblwiLCBhdXRoSW5mbywgY2FsbGJhY2spKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXBwID0gYXBwO1xuICAgICAgICAgICAgdGhpcy5odHRwRXhlY3V0b3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWZXJzaW9uU3RyaW5nID0gdGhpcy5hcHAudmVyc2lvbjtcbiAgICAgICAgY29uc3QgY3VycmVudFZlcnNpb24gPSAoMCwgc2VtdmVyXzEucGFyc2UpKGN1cnJlbnRWZXJzaW9uU3RyaW5nKTtcbiAgICAgICAgaWYgKGN1cnJlbnRWZXJzaW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKShgQXBwIHZlcnNpb24gaXMgbm90IGEgdmFsaWQgc2VtdmVyIHZlcnNpb246IFwiJHtjdXJyZW50VmVyc2lvblN0cmluZ31cImAsIFwiRVJSX1VQREFURVJfSU5WQUxJRF9WRVJTSU9OXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudFZlcnNpb24gPSBjdXJyZW50VmVyc2lvbjtcbiAgICAgICAgdGhpcy5hbGxvd1ByZXJlbGVhc2UgPSBoYXNQcmVyZWxlYXNlQ29tcG9uZW50cyhjdXJyZW50VmVyc2lvbik7XG4gICAgICAgIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RmVlZFVSTChvcHRpb25zKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gXCJzdHJpbmdcIiAmJiBvcHRpb25zLnJlcXVlc3RIZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0SGVhZGVycyA9IG9wdGlvbnMucmVxdWVzdEhlYWRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB1cGRhdGUgY2hhbm5lbC4gTm90IGFwcGxpY2FibGUgZm9yIEdpdEh1Yi4gRG9lc24ndCByZXR1cm4gYGNoYW5uZWxgIGZyb20gdGhlIHVwZGF0ZSBjb25maWd1cmF0aW9uLCBvbmx5IGlmIHdhcyBwcmV2aW91c2x5IHNldC5cbiAgICAgKi9cbiAgICBnZXQgY2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5uZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdXBkYXRlIGNoYW5uZWwuIE5vdCBhcHBsaWNhYmxlIGZvciBHaXRIdWIuIE92ZXJyaWRlcyBgY2hhbm5lbGAgaW4gdGhlIHVwZGF0ZSBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogYGFsbG93RG93bmdyYWRlYCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgc2V0IHRvIGB0cnVlYC4gSWYgdGhpcyBiZWhhdmlvciBpcyBub3Qgc3VpdGFibGUgZm9yIHlvdSwgc2ltcGxlIHNldCBgYWxsb3dEb3duZ3JhZGVgIGV4cGxpY2l0bHkgYWZ0ZXIuXG4gICAgICovXG4gICAgc2V0IGNoYW5uZWwodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NoYW5uZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm9pbnNwZWN0aW9uIFN1c3BpY2lvdXNUeXBlT2ZHdWFyZFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKShgQ2hhbm5lbCBtdXN0IGJlIGEgc3RyaW5nLCBidXQgZ290OiAke3ZhbHVlfWAsIFwiRVJSX1VQREFURVJfSU5WQUxJRF9DSEFOTkVMXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IpKGBDaGFubmVsIG11c3QgYmUgbm90IGFuIGVtcHR5IHN0cmluZ2AsIFwiRVJSX1VQREFURVJfSU5WQUxJRF9DSEFOTkVMXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoYW5uZWwgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5hbGxvd0Rvd25ncmFkZSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTaG9ydGN1dCBmb3IgZXhwbGljaXRseSBhZGRpbmcgYXV0aCB0b2tlbnMgdG8gcmVxdWVzdCBoZWFkZXJzXG4gICAgICovXG4gICAgYWRkQXV0aEhlYWRlcih0b2tlbikge1xuICAgICAgICB0aGlzLnJlcXVlc3RIZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5yZXF1ZXN0SGVhZGVycywge1xuICAgICAgICAgICAgYXV0aG9yaXphdGlvbjogdG9rZW4sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBub2luc3BlY3Rpb24gSlNNZXRob2RDYW5CZVN0YXRpYyxKU1VudXNlZEdsb2JhbFN5bWJvbHNcbiAgICBnZXQgbmV0U2Vzc2lvbigpIHtcbiAgICAgICAgcmV0dXJuICgwLCBlbGVjdHJvbkh0dHBFeGVjdXRvcl8xLmdldE5ldFNlc3Npb24pKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBsb2dnZXIuIFlvdSBjYW4gcGFzcyBbZWxlY3Ryb24tbG9nXShodHRwczovL2dpdGh1Yi5jb20vbWVnYWhlcnR6L2VsZWN0cm9uLWxvZyksIFt3aW5zdG9uXShodHRwczovL2dpdGh1Yi5jb20vd2luc3RvbmpzL3dpbnN0b24pIG9yIGFub3RoZXIgbG9nZ2VyIHdpdGggdGhlIGZvbGxvd2luZyBpbnRlcmZhY2U6IGB7IGluZm8oKSwgd2FybigpLCBlcnJvcigpIH1gLlxuICAgICAqIFNldCBpdCB0byBgbnVsbGAgaWYgeW91IHdvdWxkIGxpa2UgdG8gZGlzYWJsZSBhIGxvZ2dpbmcgZmVhdHVyZS5cbiAgICAgKi9cbiAgICBnZXQgbG9nZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9nZ2VyO1xuICAgIH1cbiAgICBzZXQgbG9nZ2VyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IHZhbHVlID09IG51bGwgPyBuZXcgTm9PcExvZ2dlcigpIDogdmFsdWU7XG4gICAgfVxuICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcbiAgICAvKipcbiAgICAgKiB0ZXN0IG9ubHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNldCB1cGRhdGVDb25maWdQYXRoKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2xpZW50UHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2FwcFVwZGF0ZUNvbmZpZ1BhdGggPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jb25maWdPbkRpc2sgPSBuZXcgbGF6eV92YWxfMS5MYXp5KCgpID0+IHRoaXMubG9hZFVwZGF0ZUNvbmZpZygpKTtcbiAgICB9XG4gICAgLy9ub2luc3BlY3Rpb24gSlNNZXRob2RDYW5CZVN0YXRpYyxKU1VudXNlZEdsb2JhbFN5bWJvbHNcbiAgICBnZXRGZWVkVVJMKCkge1xuICAgICAgICByZXR1cm4gXCJEZXByZWNhdGVkLiBEbyBub3QgdXNlIGl0LlwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmUgdXBkYXRlIHByb3ZpZGVyLiBJZiB2YWx1ZSBpcyBgc3RyaW5nYCwgW0dlbmVyaWNTZXJ2ZXJPcHRpb25zXSgvY29uZmlndXJhdGlvbi9wdWJsaXNoI2dlbmVyaWNzZXJ2ZXJvcHRpb25zKSB3aWxsIGJlIHNldCB3aXRoIHZhbHVlIGFzIGB1cmxgLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIElmIHlvdSB3YW50IHRvIG92ZXJyaWRlIGNvbmZpZ3VyYXRpb24gaW4gdGhlIGBhcHAtdXBkYXRlLnltbGAuXG4gICAgICovXG4gICAgc2V0RmVlZFVSTChvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJ1bnRpbWVPcHRpb25zID0gdGhpcy5jcmVhdGVQcm92aWRlclJ1bnRpbWVPcHRpb25zKCk7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi11c2VybGFuZC9lbGVjdHJvbi1idWlsZGVyL2lzc3Vlcy8xMTA1XG4gICAgICAgIGxldCBwcm92aWRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBwcm92aWRlciA9IG5ldyBHZW5lcmljUHJvdmlkZXJfMS5HZW5lcmljUHJvdmlkZXIoeyBwcm92aWRlcjogXCJnZW5lcmljXCIsIHVybDogb3B0aW9ucyB9LCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgLi4ucnVudGltZU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgaXNVc2VNdWx0aXBsZVJhbmdlUmVxdWVzdDogKDAsIHByb3ZpZGVyRmFjdG9yeV8xLmlzVXJsUHJvYmFibHlTdXBwb3J0TXVsdGlSYW5nZVJlcXVlc3RzKShvcHRpb25zKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvdmlkZXIgPSAoMCwgcHJvdmlkZXJGYWN0b3J5XzEuY3JlYXRlQ2xpZW50KShvcHRpb25zLCB0aGlzLCBydW50aW1lT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGllbnRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHByb3ZpZGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNrcyB0aGUgc2VydmVyIHdoZXRoZXIgdGhlcmUgaXMgYW4gdXBkYXRlLlxuICAgICAqL1xuICAgIGNoZWNrRm9yVXBkYXRlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVXBkYXRlckFjdGl2ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaGVja0ZvclVwZGF0ZXNQcm9taXNlID0gdGhpcy5jaGVja0ZvclVwZGF0ZXNQcm9taXNlO1xuICAgICAgICBpZiAoY2hlY2tGb3JVcGRhdGVzUHJvbWlzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIkNoZWNraW5nIGZvciB1cGRhdGUgKGFscmVhZHkgaW4gcHJvZ3Jlc3MpXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrRm9yVXBkYXRlc1Byb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbnVsbGl6ZVByb21pc2UgPSAoKSA9PiAodGhpcy5jaGVja0ZvclVwZGF0ZXNQcm9taXNlID0gbnVsbCk7XG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiQ2hlY2tpbmcgZm9yIHVwZGF0ZVwiKTtcbiAgICAgICAgY2hlY2tGb3JVcGRhdGVzUHJvbWlzZSA9IHRoaXMuZG9DaGVja0ZvclVwZGF0ZXMoKVxuICAgICAgICAgICAgLnRoZW4oaXQgPT4ge1xuICAgICAgICAgICAgbnVsbGl6ZVByb21pc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBpdDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgbnVsbGl6ZVByb21pc2UoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGUsIGBDYW5ub3QgY2hlY2sgZm9yIHVwZGF0ZXM6ICR7KGUuc3RhY2sgfHwgZSkudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNoZWNrRm9yVXBkYXRlc1Byb21pc2UgPSBjaGVja0ZvclVwZGF0ZXNQcm9taXNlO1xuICAgICAgICByZXR1cm4gY2hlY2tGb3JVcGRhdGVzUHJvbWlzZTtcbiAgICB9XG4gICAgaXNVcGRhdGVyQWN0aXZlKCkge1xuICAgICAgICBjb25zdCBpc0VuYWJsZWQgPSB0aGlzLmFwcC5pc1BhY2thZ2VkIHx8IHRoaXMuZm9yY2VEZXZVcGRhdGVDb25maWc7XG4gICAgICAgIGlmICghaXNFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIlNraXAgY2hlY2tGb3JVcGRhdGVzIGJlY2F1c2UgYXBwbGljYXRpb24gaXMgbm90IHBhY2tlZCBhbmQgZGV2IHVwZGF0ZSBjb25maWcgaXMgbm90IGZvcmNlZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xuICAgIGNoZWNrRm9yVXBkYXRlc0FuZE5vdGlmeShkb3dubG9hZE5vdGlmaWNhdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGVja0ZvclVwZGF0ZXMoKS50aGVuKGl0ID0+IHtcbiAgICAgICAgICAgIGlmICghKGl0ID09PSBudWxsIHx8IGl0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpdC5kb3dubG9hZFByb21pc2UpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xvZ2dlci5kZWJ1ZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcImNoZWNrRm9yVXBkYXRlc0FuZE5vdGlmeSBjYWxsZWQsIGRvd25sb2FkUHJvbWlzZSBpcyBudWxsXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2b2lkIGl0LmRvd25sb2FkUHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBub3RpZmljYXRpb25Db250ZW50ID0gQXBwVXBkYXRlci5mb3JtYXREb3dubG9hZE5vdGlmaWNhdGlvbihpdC51cGRhdGVJbmZvLnZlcnNpb24sIHRoaXMuYXBwLm5hbWUsIGRvd25sb2FkTm90aWZpY2F0aW9uKTtcbiAgICAgICAgICAgICAgICBuZXcgKHJlcXVpcmUoXCJlbGVjdHJvblwiKS5Ob3RpZmljYXRpb24pKG5vdGlmaWNhdGlvbkNvbnRlbnQpLnNob3coKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGl0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZvcm1hdERvd25sb2FkTm90aWZpY2F0aW9uKHZlcnNpb24sIGFwcE5hbWUsIGRvd25sb2FkTm90aWZpY2F0aW9uKSB7XG4gICAgICAgIGlmIChkb3dubG9hZE5vdGlmaWNhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBkb3dubG9hZE5vdGlmaWNhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJBIG5ldyB1cGRhdGUgaXMgcmVhZHkgdG8gaW5zdGFsbFwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IGB7YXBwTmFtZX0gdmVyc2lvbiB7dmVyc2lvbn0gaGFzIGJlZW4gZG93bmxvYWRlZCBhbmQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGluc3RhbGxlZCBvbiBleGl0YCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZG93bmxvYWROb3RpZmljYXRpb24gPSB7XG4gICAgICAgICAgICB0aXRsZTogZG93bmxvYWROb3RpZmljYXRpb24udGl0bGUucmVwbGFjZShcInthcHBOYW1lfVwiLCBhcHBOYW1lKS5yZXBsYWNlKFwie3ZlcnNpb259XCIsIHZlcnNpb24pLFxuICAgICAgICAgICAgYm9keTogZG93bmxvYWROb3RpZmljYXRpb24uYm9keS5yZXBsYWNlKFwie2FwcE5hbWV9XCIsIGFwcE5hbWUpLnJlcGxhY2UoXCJ7dmVyc2lvbn1cIiwgdmVyc2lvbiksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBkb3dubG9hZE5vdGlmaWNhdGlvbjtcbiAgICB9XG4gICAgYXN5bmMgaXNTdGFnaW5nTWF0Y2godXBkYXRlSW5mbykge1xuICAgICAgICBjb25zdCByYXdTdGFnaW5nUGVyY2VudGFnZSA9IHVwZGF0ZUluZm8uc3RhZ2luZ1BlcmNlbnRhZ2U7XG4gICAgICAgIGxldCBzdGFnaW5nUGVyY2VudGFnZSA9IHJhd1N0YWdpbmdQZXJjZW50YWdlO1xuICAgICAgICBpZiAoc3RhZ2luZ1BlcmNlbnRhZ2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RhZ2luZ1BlcmNlbnRhZ2UgPSBwYXJzZUludChzdGFnaW5nUGVyY2VudGFnZSwgMTApO1xuICAgICAgICBpZiAoaXNOYU4oc3RhZ2luZ1BlcmNlbnRhZ2UpKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihgU3RhZ2luZyBwZXJjZW50YWdlIGlzIE5hTjogJHtyYXdTdGFnaW5nUGVyY2VudGFnZX1gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnZlcnQgZnJvbSB1c2VyIDAtMTAwIHRvIGludGVybmFsIDAtMVxuICAgICAgICBzdGFnaW5nUGVyY2VudGFnZSA9IHN0YWdpbmdQZXJjZW50YWdlIC8gMTAwO1xuICAgICAgICBjb25zdCBzdGFnaW5nVXNlcklkID0gYXdhaXQgdGhpcy5zdGFnaW5nVXNlcklkUHJvbWlzZS52YWx1ZTtcbiAgICAgICAgY29uc3QgdmFsID0gYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5VVUlELnBhcnNlKHN0YWdpbmdVc2VySWQpLnJlYWRVSW50MzJCRSgxMik7XG4gICAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSB2YWwgLyAweGZmZmZmZmZmO1xuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhgU3RhZ2luZyBwZXJjZW50YWdlOiAke3N0YWdpbmdQZXJjZW50YWdlfSwgcGVyY2VudGFnZTogJHtwZXJjZW50YWdlfSwgdXNlciBpZDogJHtzdGFnaW5nVXNlcklkfWApO1xuICAgICAgICByZXR1cm4gcGVyY2VudGFnZSA8IHN0YWdpbmdQZXJjZW50YWdlO1xuICAgIH1cbiAgICBjb21wdXRlRmluYWxIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdEhlYWRlcnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihoZWFkZXJzLCB0aGlzLnJlcXVlc3RIZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgYXN5bmMgaXNVcGRhdGVBdmFpbGFibGUodXBkYXRlSW5mbykge1xuICAgICAgICBjb25zdCBsYXRlc3RWZXJzaW9uID0gKDAsIHNlbXZlcl8xLnBhcnNlKSh1cGRhdGVJbmZvLnZlcnNpb24pO1xuICAgICAgICBpZiAobGF0ZXN0VmVyc2lvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcikoYFRoaXMgZmlsZSBjb3VsZCBub3QgYmUgZG93bmxvYWRlZCwgb3IgdGhlIGxhdGVzdCB2ZXJzaW9uIChmcm9tIHVwZGF0ZSBzZXJ2ZXIpIGRvZXMgbm90IGhhdmUgYSB2YWxpZCBzZW12ZXIgdmVyc2lvbjogXCIke3VwZGF0ZUluZm8udmVyc2lvbn1cImAsIFwiRVJSX1VQREFURVJfSU5WQUxJRF9WRVJTSU9OXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWZXJzaW9uID0gdGhpcy5jdXJyZW50VmVyc2lvbjtcbiAgICAgICAgaWYgKCgwLCBzZW12ZXJfMS5lcSkobGF0ZXN0VmVyc2lvbiwgY3VycmVudFZlcnNpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNTdGFnaW5nTWF0Y2ggPSBhd2FpdCB0aGlzLmlzU3RhZ2luZ01hdGNoKHVwZGF0ZUluZm8pO1xuICAgICAgICBpZiAoIWlzU3RhZ2luZ01hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uLXVzZXJsYW5kL2VsZWN0cm9uLWJ1aWxkZXIvcHVsbC8zMTExI2lzc3VlY29tbWVudC00MDUwMzMyMjdcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uLXVzZXJsYW5kL2VsZWN0cm9uLWJ1aWxkZXIvcHVsbC8zMTExI2lzc3VlY29tbWVudC00MDUwMzA3OTdcbiAgICAgICAgY29uc3QgaXNMYXRlc3RWZXJzaW9uTmV3ZXIgPSAoMCwgc2VtdmVyXzEuZ3QpKGxhdGVzdFZlcnNpb24sIGN1cnJlbnRWZXJzaW9uKTtcbiAgICAgICAgY29uc3QgaXNMYXRlc3RWZXJzaW9uT2xkZXIgPSAoMCwgc2VtdmVyXzEubHQpKGxhdGVzdFZlcnNpb24sIGN1cnJlbnRWZXJzaW9uKTtcbiAgICAgICAgaWYgKGlzTGF0ZXN0VmVyc2lvbk5ld2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hbGxvd0Rvd25ncmFkZSAmJiBpc0xhdGVzdFZlcnNpb25PbGRlcjtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VXBkYXRlSW5mb0FuZFByb3ZpZGVyKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmFwcC53aGVuUmVhZHkoKTtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50UHJvbWlzZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudFByb21pc2UgPSB0aGlzLmNvbmZpZ09uRGlzay52YWx1ZS50aGVuKGl0ID0+ICgwLCBwcm92aWRlckZhY3RvcnlfMS5jcmVhdGVDbGllbnQpKGl0LCB0aGlzLCB0aGlzLmNyZWF0ZVByb3ZpZGVyUnVudGltZU9wdGlvbnMoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuY2xpZW50UHJvbWlzZTtcbiAgICAgICAgY29uc3Qgc3RhZ2luZ1VzZXJJZCA9IGF3YWl0IHRoaXMuc3RhZ2luZ1VzZXJJZFByb21pc2UudmFsdWU7XG4gICAgICAgIGNsaWVudC5zZXRSZXF1ZXN0SGVhZGVycyh0aGlzLmNvbXB1dGVGaW5hbEhlYWRlcnMoeyBcIngtdXNlci1zdGFnaW5nLWlkXCI6IHN0YWdpbmdVc2VySWQgfSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5mbzogYXdhaXQgY2xpZW50LmdldExhdGVzdFZlcnNpb24oKSxcbiAgICAgICAgICAgIHByb3ZpZGVyOiBjbGllbnQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtZnVuY3Rpb24tcmV0dXJuLXR5cGVcbiAgICBjcmVhdGVQcm92aWRlclJ1bnRpbWVPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNVc2VNdWx0aXBsZVJhbmdlUmVxdWVzdDogdHJ1ZSxcbiAgICAgICAgICAgIHBsYXRmb3JtOiB0aGlzLl90ZXN0T25seU9wdGlvbnMgPT0gbnVsbCA/IHByb2Nlc3MucGxhdGZvcm0gOiB0aGlzLl90ZXN0T25seU9wdGlvbnMucGxhdGZvcm0sXG4gICAgICAgICAgICBleGVjdXRvcjogdGhpcy5odHRwRXhlY3V0b3IsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGRvQ2hlY2tGb3JVcGRhdGVzKCkge1xuICAgICAgICB0aGlzLmVtaXQoXCJjaGVja2luZy1mb3ItdXBkYXRlXCIpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmdldFVwZGF0ZUluZm9BbmRQcm92aWRlcigpO1xuICAgICAgICBjb25zdCB1cGRhdGVJbmZvID0gcmVzdWx0LmluZm87XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMuaXNVcGRhdGVBdmFpbGFibGUodXBkYXRlSW5mbykpKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhgVXBkYXRlIGZvciB2ZXJzaW9uICR7dGhpcy5jdXJyZW50VmVyc2lvbn0gaXMgbm90IGF2YWlsYWJsZSAobGF0ZXN0IHZlcnNpb246ICR7dXBkYXRlSW5mby52ZXJzaW9ufSwgZG93bmdyYWRlIGlzICR7dGhpcy5hbGxvd0Rvd25ncmFkZSA/IFwiYWxsb3dlZFwiIDogXCJkaXNhbGxvd2VkXCJ9KS5gKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZS1ub3QtYXZhaWxhYmxlXCIsIHVwZGF0ZUluZm8pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uSW5mbzogdXBkYXRlSW5mbyxcbiAgICAgICAgICAgICAgICB1cGRhdGVJbmZvLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUluZm9BbmRQcm92aWRlciA9IHJlc3VsdDtcbiAgICAgICAgdGhpcy5vblVwZGF0ZUF2YWlsYWJsZSh1cGRhdGVJbmZvKTtcbiAgICAgICAgY29uc3QgY2FuY2VsbGF0aW9uVG9rZW4gPSBuZXcgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5DYW5jZWxsYXRpb25Ub2tlbigpO1xuICAgICAgICAvL25vaW5zcGVjdGlvbiBFUzZNaXNzaW5nQXdhaXRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcnNpb25JbmZvOiB1cGRhdGVJbmZvLFxuICAgICAgICAgICAgdXBkYXRlSW5mbyxcbiAgICAgICAgICAgIGNhbmNlbGxhdGlvblRva2VuLFxuICAgICAgICAgICAgZG93bmxvYWRQcm9taXNlOiB0aGlzLmF1dG9Eb3dubG9hZCA/IHRoaXMuZG93bmxvYWRVcGRhdGUoY2FuY2VsbGF0aW9uVG9rZW4pIDogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgb25VcGRhdGVBdmFpbGFibGUodXBkYXRlSW5mbykge1xuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhgRm91bmQgdmVyc2lvbiAke3VwZGF0ZUluZm8udmVyc2lvbn0gKHVybDogJHsoMCwgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5hc0FycmF5KSh1cGRhdGVJbmZvLmZpbGVzKVxuICAgICAgICAgICAgLm1hcChpdCA9PiBpdC51cmwpXG4gICAgICAgICAgICAuam9pbihcIiwgXCIpfSlgKTtcbiAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlLWF2YWlsYWJsZVwiLCB1cGRhdGVJbmZvKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgZG93bmxvYWRpbmcgdXBkYXRlIG1hbnVhbGx5LiBZb3UgY2FuIHVzZSB0aGlzIG1ldGhvZCBpZiBgYXV0b0Rvd25sb2FkYCBvcHRpb24gaXMgc2V0IHRvIGBmYWxzZWAuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8c3RyaW5nPj59IFBhdGhzIHRvIGRvd25sb2FkZWQgZmlsZXMuXG4gICAgICovXG4gICAgZG93bmxvYWRVcGRhdGUoY2FuY2VsbGF0aW9uVG9rZW4gPSBuZXcgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5DYW5jZWxsYXRpb25Ub2tlbigpKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZUluZm9BbmRQcm92aWRlciA9IHRoaXMudXBkYXRlSW5mb0FuZFByb3ZpZGVyO1xuICAgICAgICBpZiAodXBkYXRlSW5mb0FuZFByb3ZpZGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiUGxlYXNlIGNoZWNrIHVwZGF0ZSBmaXJzdFwiKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFcnJvcihlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGBEb3dubG9hZGluZyB1cGRhdGUgZnJvbSAkeygwLCBidWlsZGVyX3V0aWxfcnVudGltZV8xLmFzQXJyYXkpKHVwZGF0ZUluZm9BbmRQcm92aWRlci5pbmZvLmZpbGVzKVxuICAgICAgICAgICAgLm1hcChpdCA9PiBpdC51cmwpXG4gICAgICAgICAgICAuam9pbihcIiwgXCIpfWApO1xuICAgICAgICBjb25zdCBlcnJvckhhbmRsZXIgPSAoZSkgPT4ge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uLXVzZXJsYW5kL2VsZWN0cm9uLWJ1aWxkZXIvaXNzdWVzLzExNTAjaXNzdWVjb21tZW50LTQzNjg5MTE1OVxuICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuQ2FuY2VsbGF0aW9uRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEVycm9yKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAobmVzdGVkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oYENhbm5vdCBkaXNwYXRjaCBlcnJvciBldmVudDogJHtuZXN0ZWRFcnJvci5zdGFjayB8fCBuZXN0ZWRFcnJvcn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvRG93bmxvYWRVcGRhdGUoe1xuICAgICAgICAgICAgICAgIHVwZGF0ZUluZm9BbmRQcm92aWRlcixcbiAgICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVyczogdGhpcy5jb21wdXRlUmVxdWVzdEhlYWRlcnModXBkYXRlSW5mb0FuZFByb3ZpZGVyLnByb3ZpZGVyKSxcbiAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25Ub2tlbixcbiAgICAgICAgICAgICAgICBkaXNhYmxlV2ViSW5zdGFsbGVyOiB0aGlzLmRpc2FibGVXZWJJbnN0YWxsZXIsXG4gICAgICAgICAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9ySGFuZGxlcihlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3JIYW5kbGVyKGUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwYXRjaEVycm9yKGUpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZSwgKGUuc3RhY2sgfHwgZSkudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGRpc3BhdGNoVXBkYXRlRG93bmxvYWRlZChldmVudCkge1xuICAgICAgICB0aGlzLmVtaXQobWFpbl8xLlVQREFURV9ET1dOTE9BREVELCBldmVudCk7XG4gICAgfVxuICAgIGFzeW5jIGxvYWRVcGRhdGVDb25maWcoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hcHBVcGRhdGVDb25maWdQYXRoID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2FwcFVwZGF0ZUNvbmZpZ1BhdGggPSB0aGlzLmFwcC5hcHBVcGRhdGVDb25maWdQYXRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwganNfeWFtbF8xLmxvYWQpKGF3YWl0ICgwLCBmc19leHRyYV8xLnJlYWRGaWxlKSh0aGlzLl9hcHBVcGRhdGVDb25maWdQYXRoLCBcInV0Zi04XCIpKTtcbiAgICB9XG4gICAgY29tcHV0ZVJlcXVlc3RIZWFkZXJzKHByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnN0IGZpbGVFeHRyYURvd25sb2FkSGVhZGVycyA9IHByb3ZpZGVyLmZpbGVFeHRyYURvd25sb2FkSGVhZGVycztcbiAgICAgICAgaWYgKGZpbGVFeHRyYURvd25sb2FkSGVhZGVycyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0SGVhZGVycyA9IHRoaXMucmVxdWVzdEhlYWRlcnM7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdEhlYWRlcnMgPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZmlsZUV4dHJhRG93bmxvYWRIZWFkZXJzXG4gICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmZpbGVFeHRyYURvd25sb2FkSGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgLi4ucmVxdWVzdEhlYWRlcnMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlRmluYWxIZWFkZXJzKHsgYWNjZXB0OiBcIiovKlwiIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRPckNyZWF0ZVN0YWdpbmdVc2VySWQoKSB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBwYXRoLmpvaW4odGhpcy5hcHAudXNlckRhdGFQYXRoLCBcIi51cGRhdGVySWRcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IGF3YWl0ICgwLCBmc19leHRyYV8xLnJlYWRGaWxlKShmaWxlLCBcInV0Zi04XCIpO1xuICAgICAgICAgICAgaWYgKGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuVVVJRC5jaGVjayhpZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihgU3RhZ2luZyB1c2VyIGlkIGZpbGUgZXhpc3RzLCBidXQgY29udGVudCB3YXMgaW52YWxpZDogJHtpZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUuY29kZSAhPT0gXCJFTk9FTlRcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKGBDb3VsZG4ndCByZWFkIHN0YWdpbmcgdXNlciBJRCwgY3JlYXRpbmcgYSBibGFuayBvbmU6ICR7ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZCA9IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuVVVJRC52NSgoMCwgY3J5cHRvXzEucmFuZG9tQnl0ZXMpKDQwOTYpLCBidWlsZGVyX3V0aWxfcnVudGltZV8xLlVVSUQuT0lEKTtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oYEdlbmVyYXRlZCBuZXcgc3RhZ2luZyB1c2VyIElEOiAke2lkfWApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgKDAsIGZzX2V4dHJhXzEub3V0cHV0RmlsZSkoZmlsZSwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihgQ291bGRuJ3Qgd3JpdGUgb3V0IHN0YWdpbmcgdXNlciBJRDogJHtlfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGdldCBpc0FkZE5vQ2FjaGVRdWVyeSgpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMucmVxdWVzdEhlYWRlcnM7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi11c2VybGFuZC9lbGVjdHJvbi1idWlsZGVyL2lzc3Vlcy8zMDIxXG4gICAgICAgIGlmIChoZWFkZXJzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgaGVhZGVyTmFtZSBvZiBPYmplY3Qua2V5cyhoZWFkZXJzKSkge1xuICAgICAgICAgICAgY29uc3QgcyA9IGhlYWRlck5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChzID09PSBcImF1dGhvcml6YXRpb25cIiB8fCBzID09PSBcInByaXZhdGUtdG9rZW5cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0T3JDcmVhdGVEb3dubG9hZEhlbHBlcigpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuZG93bmxvYWRlZFVwZGF0ZUhlbHBlcjtcbiAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBkaXJOYW1lID0gKGF3YWl0IHRoaXMuY29uZmlnT25EaXNrLnZhbHVlKS51cGRhdGVyQ2FjaGVEaXJOYW1lO1xuICAgICAgICAgICAgY29uc3QgbG9nZ2VyID0gdGhpcy5fbG9nZ2VyO1xuICAgICAgICAgICAgaWYgKGRpck5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcInVwZGF0ZXJDYWNoZURpck5hbWUgaXMgbm90IHNwZWNpZmllZCBpbiBhcHAtdXBkYXRlLnltbCBXYXMgYXBwIGJ1aWxkIHVzaW5nIGF0IGxlYXN0IGVsZWN0cm9uLWJ1aWxkZXIgMjAuMzQuMD9cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjYWNoZURpciA9IHBhdGguam9pbih0aGlzLmFwcC5iYXNlQ2FjaGVQYXRoLCBkaXJOYW1lIHx8IHRoaXMuYXBwLm5hbWUpO1xuICAgICAgICAgICAgaWYgKGxvZ2dlci5kZWJ1ZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGB1cGRhdGVyIGNhY2hlIGRpcjogJHtjYWNoZURpcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBEb3dubG9hZGVkVXBkYXRlSGVscGVyXzEuRG93bmxvYWRlZFVwZGF0ZUhlbHBlcihjYWNoZURpcik7XG4gICAgICAgICAgICB0aGlzLmRvd25sb2FkZWRVcGRhdGVIZWxwZXIgPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgZXhlY3V0ZURvd25sb2FkKHRhc2tPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGZpbGVJbmZvID0gdGFza09wdGlvbnMuZmlsZUluZm87XG4gICAgICAgIGNvbnN0IGRvd25sb2FkT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHRhc2tPcHRpb25zLmRvd25sb2FkVXBkYXRlT3B0aW9ucy5yZXF1ZXN0SGVhZGVycyxcbiAgICAgICAgICAgIGNhbmNlbGxhdGlvblRva2VuOiB0YXNrT3B0aW9ucy5kb3dubG9hZFVwZGF0ZU9wdGlvbnMuY2FuY2VsbGF0aW9uVG9rZW4sXG4gICAgICAgICAgICBzaGEyOiBmaWxlSW5mby5pbmZvLnNoYTIsXG4gICAgICAgICAgICBzaGE1MTI6IGZpbGVJbmZvLmluZm8uc2hhNTEyLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5saXN0ZW5lckNvdW50KG1haW5fMS5ET1dOTE9BRF9QUk9HUkVTUykgPiAwKSB7XG4gICAgICAgICAgICBkb3dubG9hZE9wdGlvbnMub25Qcm9ncmVzcyA9IGl0ID0+IHRoaXMuZW1pdChtYWluXzEuRE9XTkxPQURfUFJPR1JFU1MsIGl0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGRhdGVJbmZvID0gdGFza09wdGlvbnMuZG93bmxvYWRVcGRhdGVPcHRpb25zLnVwZGF0ZUluZm9BbmRQcm92aWRlci5pbmZvO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gdXBkYXRlSW5mby52ZXJzaW9uO1xuICAgICAgICBjb25zdCBwYWNrYWdlSW5mbyA9IGZpbGVJbmZvLnBhY2thZ2VJbmZvO1xuICAgICAgICBmdW5jdGlvbiBnZXRDYWNoZVVwZGF0ZUZpbGVOYW1lKCkge1xuICAgICAgICAgICAgLy8gTm9kZUpTIFVSTCBkb2Vzbid0IGRlY29kZSBhdXRvbWF0aWNhbGx5XG4gICAgICAgICAgICBjb25zdCB1cmxQYXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KHRhc2tPcHRpb25zLmZpbGVJbmZvLnVybC5wYXRobmFtZSk7XG4gICAgICAgICAgICBpZiAodXJsUGF0aC5lbmRzV2l0aChgLiR7dGFza09wdGlvbnMuZmlsZUV4dGVuc2lvbn1gKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoLmJhc2VuYW1lKHVybFBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdXJsIGxpa2UgL2xhdGVzdCwgZ2VuZXJhdGUgbmFtZVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXNrT3B0aW9ucy5maWxlSW5mby5pbmZvLnVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb3dubG9hZGVkVXBkYXRlSGVscGVyID0gYXdhaXQgdGhpcy5nZXRPckNyZWF0ZURvd25sb2FkSGVscGVyKCk7XG4gICAgICAgIGNvbnN0IGNhY2hlRGlyID0gZG93bmxvYWRlZFVwZGF0ZUhlbHBlci5jYWNoZURpckZvclBlbmRpbmdVcGRhdGU7XG4gICAgICAgIGF3YWl0ICgwLCBmc19leHRyYV8xLm1rZGlyKShjYWNoZURpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZUZpbGVOYW1lID0gZ2V0Q2FjaGVVcGRhdGVGaWxlTmFtZSgpO1xuICAgICAgICBsZXQgdXBkYXRlRmlsZSA9IHBhdGguam9pbihjYWNoZURpciwgdXBkYXRlRmlsZU5hbWUpO1xuICAgICAgICBjb25zdCBwYWNrYWdlRmlsZSA9IHBhY2thZ2VJbmZvID09IG51bGwgPyBudWxsIDogcGF0aC5qb2luKGNhY2hlRGlyLCBgcGFja2FnZS0ke3ZlcnNpb259JHtwYXRoLmV4dG5hbWUocGFja2FnZUluZm8ucGF0aCkgfHwgXCIuN3pcIn1gKTtcbiAgICAgICAgY29uc3QgZG9uZSA9IGFzeW5jIChpc1NhdmVDYWNoZSkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgZG93bmxvYWRlZFVwZGF0ZUhlbHBlci5zZXREb3dubG9hZGVkRmlsZSh1cGRhdGVGaWxlLCBwYWNrYWdlRmlsZSwgdXBkYXRlSW5mbywgZmlsZUluZm8sIHVwZGF0ZUZpbGVOYW1lLCBpc1NhdmVDYWNoZSk7XG4gICAgICAgICAgICBhd2FpdCB0YXNrT3B0aW9ucy5kb25lKHtcbiAgICAgICAgICAgICAgICAuLi51cGRhdGVJbmZvLFxuICAgICAgICAgICAgICAgIGRvd25sb2FkZWRGaWxlOiB1cGRhdGVGaWxlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGFja2FnZUZpbGUgPT0gbnVsbCA/IFt1cGRhdGVGaWxlXSA6IFt1cGRhdGVGaWxlLCBwYWNrYWdlRmlsZV07XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGxvZyA9IHRoaXMuX2xvZ2dlcjtcbiAgICAgICAgY29uc3QgY2FjaGVkVXBkYXRlRmlsZSA9IGF3YWl0IGRvd25sb2FkZWRVcGRhdGVIZWxwZXIudmFsaWRhdGVEb3dubG9hZGVkUGF0aCh1cGRhdGVGaWxlLCB1cGRhdGVJbmZvLCBmaWxlSW5mbywgbG9nKTtcbiAgICAgICAgaWYgKGNhY2hlZFVwZGF0ZUZpbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXBkYXRlRmlsZSA9IGNhY2hlZFVwZGF0ZUZpbGU7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZG9uZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVtb3ZlRmlsZUlmQW55ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgZG93bmxvYWRlZFVwZGF0ZUhlbHBlci5jbGVhcigpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0ICgwLCBmc19leHRyYV8xLnVubGluaykodXBkYXRlRmlsZSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRlbXBVcGRhdGVGaWxlID0gYXdhaXQgKDAsIERvd25sb2FkZWRVcGRhdGVIZWxwZXJfMS5jcmVhdGVUZW1wVXBkYXRlRmlsZSkoYHRlbXAtJHt1cGRhdGVGaWxlTmFtZX1gLCBjYWNoZURpciwgbG9nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRhc2tPcHRpb25zLnRhc2sodGVtcFVwZGF0ZUZpbGUsIGRvd25sb2FkT3B0aW9ucywgcGFja2FnZUZpbGUsIHJlbW92ZUZpbGVJZkFueSk7XG4gICAgICAgICAgICBhd2FpdCAoMCwgZnNfZXh0cmFfMS5yZW5hbWUpKHRlbXBVcGRhdGVGaWxlLCB1cGRhdGVGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgcmVtb3ZlRmlsZUlmQW55KCk7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuQ2FuY2VsbGF0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2cuaW5mbyhcImNhbmNlbGxlZFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGUtY2FuY2VsbGVkXCIsIHVwZGF0ZUluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBsb2cuaW5mbyhgTmV3IHZlcnNpb24gJHt2ZXJzaW9ufSBoYXMgYmVlbiBkb3dubG9hZGVkIHRvICR7dXBkYXRlRmlsZX1gKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGRvbmUodHJ1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5BcHBVcGRhdGVyID0gQXBwVXBkYXRlcjtcbmZ1bmN0aW9uIGhhc1ByZXJlbGVhc2VDb21wb25lbnRzKHZlcnNpb24pIHtcbiAgICBjb25zdCB2ZXJzaW9uUHJlcmVsZWFzZUNvbXBvbmVudCA9ICgwLCBzZW12ZXJfMS5wcmVyZWxlYXNlKSh2ZXJzaW9uKTtcbiAgICByZXR1cm4gdmVyc2lvblByZXJlbGVhc2VDb21wb25lbnQgIT0gbnVsbCAmJiB2ZXJzaW9uUHJlcmVsZWFzZUNvbXBvbmVudC5sZW5ndGggPiAwO1xufVxuLyoqIEBwcml2YXRlICovXG5jbGFzcyBOb09wTG9nZ2VyIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgaW5mbyhtZXNzYWdlKSB7XG4gICAgICAgIC8vIGlnbm9yZVxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgd2FybihtZXNzYWdlKSB7XG4gICAgICAgIC8vIGlnbm9yZVxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgZXJyb3IobWVzc2FnZSkge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICB9XG59XG5leHBvcnRzLk5vT3BMb2dnZXIgPSBOb09wTG9nZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXBwVXBkYXRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZVVwZGF0ZXIgPSB2b2lkIDA7XG5jb25zdCBjaGlsZF9wcm9jZXNzXzEgPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKTtcbmNvbnN0IEFwcFVwZGF0ZXJfMSA9IHJlcXVpcmUoXCIuL0FwcFVwZGF0ZXJcIik7XG5jbGFzcyBCYXNlVXBkYXRlciBleHRlbmRzIEFwcFVwZGF0ZXJfMS5BcHBVcGRhdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhcHApIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucywgYXBwKTtcbiAgICAgICAgdGhpcy5xdWl0QW5kSW5zdGFsbENhbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnF1aXRIYW5kbGVyQWRkZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcXVpdEFuZEluc3RhbGwoaXNTaWxlbnQgPSBmYWxzZSwgaXNGb3JjZVJ1bkFmdGVyID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oYEluc3RhbGwgb24gZXhwbGljaXQgcXVpdEFuZEluc3RhbGxgKTtcbiAgICAgICAgLy8gSWYgTk9UIGluIHNpbGVudCBtb2RlIHVzZSBgYXV0b1J1bkFwcEFmdGVySW5zdGFsbGAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gZm9yY2UgcnVuIHRoZSBhcHBcbiAgICAgICAgY29uc3QgaXNJbnN0YWxsZWQgPSB0aGlzLmluc3RhbGwoaXNTaWxlbnQsIGlzU2lsZW50ID8gaXNGb3JjZVJ1bkFmdGVyIDogdGhpcy5hdXRvUnVuQXBwQWZ0ZXJJbnN0YWxsKTtcbiAgICAgICAgaWYgKGlzSW5zdGFsbGVkKSB7XG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgZXZlbnQgaXMgbm9ybWFsbHkgZW1pdHRlZCB3aGVuIGNhbGxpbmcgcXVpdEFuZEluc3RhbGwsIHRoaXMgZW11bGF0ZXMgdGhhdFxuICAgICAgICAgICAgICAgIHJlcXVpcmUoXCJlbGVjdHJvblwiKS5hdXRvVXBkYXRlci5lbWl0KFwiYmVmb3JlLXF1aXQtZm9yLXVwZGF0ZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcC5xdWl0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucXVpdEFuZEluc3RhbGxDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleGVjdXRlRG93bmxvYWQodGFza09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmV4ZWN1dGVEb3dubG9hZCh7XG4gICAgICAgICAgICAuLi50YXNrT3B0aW9ucyxcbiAgICAgICAgICAgIGRvbmU6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVXBkYXRlRG93bmxvYWRlZChldmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRRdWl0SGFuZGxlcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBtdXN0IGJlIHN5bmMgKGJlY2F1c2UgcXVpdCBldmVuIGhhbmRsZXIgaXMgbm90IGFzeW5jKVxuICAgIGluc3RhbGwoaXNTaWxlbnQgPSBmYWxzZSwgaXNGb3JjZVJ1bkFmdGVyID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMucXVpdEFuZEluc3RhbGxDYWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKFwiaW5zdGFsbCBjYWxsIGlnbm9yZWQ6IHF1aXRBbmRJbnN0YWxsQ2FsbGVkIGlzIHNldCB0byB0cnVlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvd25sb2FkZWRVcGRhdGVIZWxwZXIgPSB0aGlzLmRvd25sb2FkZWRVcGRhdGVIZWxwZXI7XG4gICAgICAgIGNvbnN0IGluc3RhbGxlclBhdGggPSBkb3dubG9hZGVkVXBkYXRlSGVscGVyID09IG51bGwgPyBudWxsIDogZG93bmxvYWRlZFVwZGF0ZUhlbHBlci5maWxlO1xuICAgICAgICBjb25zdCBkb3dubG9hZGVkRmlsZUluZm8gPSBkb3dubG9hZGVkVXBkYXRlSGVscGVyID09IG51bGwgPyBudWxsIDogZG93bmxvYWRlZFVwZGF0ZUhlbHBlci5kb3dubG9hZGVkRmlsZUluZm87XG4gICAgICAgIGlmIChpbnN0YWxsZXJQYXRoID09IG51bGwgfHwgZG93bmxvYWRlZEZpbGVJbmZvID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFcnJvcihuZXcgRXJyb3IoXCJObyB2YWxpZCB1cGRhdGUgYXZhaWxhYmxlLCBjYW4ndCBxdWl0IGFuZCBpbnN0YWxsXCIpKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcmV2ZW50IGNhbGxpbmcgc2V2ZXJhbCB0aW1lc1xuICAgICAgICB0aGlzLnF1aXRBbmRJbnN0YWxsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGBJbnN0YWxsOiBpc1NpbGVudDogJHtpc1NpbGVudH0sIGlzRm9yY2VSdW5BZnRlcjogJHtpc0ZvcmNlUnVuQWZ0ZXJ9YCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb0luc3RhbGwoe1xuICAgICAgICAgICAgICAgIGluc3RhbGxlclBhdGgsXG4gICAgICAgICAgICAgICAgaXNTaWxlbnQsXG4gICAgICAgICAgICAgICAgaXNGb3JjZVJ1bkFmdGVyLFxuICAgICAgICAgICAgICAgIGlzQWRtaW5SaWdodHNSZXF1aXJlZDogZG93bmxvYWRlZEZpbGVJbmZvLmlzQWRtaW5SaWdodHNSZXF1aXJlZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXJyb3IoZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkUXVpdEhhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnF1aXRIYW5kbGVyQWRkZWQgfHwgIXRoaXMuYXV0b0luc3RhbGxPbkFwcFF1aXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnF1aXRIYW5kbGVyQWRkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmFwcC5vblF1aXQoZXhpdENvZGUgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucXVpdEFuZEluc3RhbGxDYWxsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIlVwZGF0ZSBpbnN0YWxsZXIgaGFzIGFscmVhZHkgYmVlbiB0cmlnZ2VyZWQuIFF1aXR0aW5nIGFwcGxpY2F0aW9uLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuYXV0b0luc3RhbGxPbkFwcFF1aXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIlVwZGF0ZSB3aWxsIG5vdCBiZSBpbnN0YWxsZWQgb24gcXVpdCBiZWNhdXNlIGF1dG9JbnN0YWxsT25BcHBRdWl0IGlzIHNldCB0byBmYWxzZS5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4aXRDb2RlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oYFVwZGF0ZSB3aWxsIGJlIG5vdCBpbnN0YWxsZWQgb24gcXVpdCBiZWNhdXNlIGFwcGxpY2F0aW9uIGlzIHF1aXR0aW5nIHdpdGggZXhpdCBjb2RlICR7ZXhpdENvZGV9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCJBdXRvIGluc3RhbGwgdXBkYXRlIG9uIHF1aXRcIik7XG4gICAgICAgICAgICB0aGlzLmluc3RhbGwodHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgd3JhcFN1ZG8oKSB7XG4gICAgICAgIGNvbnN0IHsgbmFtZSB9ID0gdGhpcy5hcHA7XG4gICAgICAgIGNvbnN0IGluc3RhbGxDb21tZW50ID0gYFwiJHtuYW1lfSB3b3VsZCBsaWtlIHRvIHVwZGF0ZVwiYDtcbiAgICAgICAgY29uc3Qgc3VkbyA9IHRoaXMuc3Bhd25TeW5jTG9nKFwid2hpY2ggZ2tzdWRvIHx8IHdoaWNoIGtkZXN1ZG8gfHwgd2hpY2ggcGtleGVjIHx8IHdoaWNoIGJlZXN1XCIpO1xuICAgICAgICBjb25zdCBjb21tYW5kID0gW3N1ZG9dO1xuICAgICAgICBpZiAoL2tkZXN1ZG8vaS50ZXN0KHN1ZG8pKSB7XG4gICAgICAgICAgICBjb21tYW5kLnB1c2goXCItLWNvbW1lbnRcIiwgaW5zdGFsbENvbW1lbnQpO1xuICAgICAgICAgICAgY29tbWFuZC5wdXNoKFwiLWNcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL2drc3Vkby9pLnRlc3Qoc3VkbykpIHtcbiAgICAgICAgICAgIGNvbW1hbmQucHVzaChcIi0tbWVzc2FnZVwiLCBpbnN0YWxsQ29tbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL3BrZXhlYy9pLnRlc3Qoc3VkbykpIHtcbiAgICAgICAgICAgIGNvbW1hbmQucHVzaChcIi0tZGlzYWJsZS1pbnRlcm5hbC1hZ2VudFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tbWFuZC5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgc3Bhd25TeW5jTG9nKGNtZCwgYXJncyA9IFtdLCBlbnYgPSB7fSkge1xuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhgRXhlY3V0aW5nOiAke2NtZH0gd2l0aCBhcmdzOiAke2FyZ3N9YCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gKDAsIGNoaWxkX3Byb2Nlc3NfMS5zcGF3blN5bmMpKGNtZCwgYXJncywge1xuICAgICAgICAgICAgc3RkaW86IFwiaW5oZXJpdFwiLFxuICAgICAgICAgICAgZW52OiB7IC4uLnByb2Nlc3MuZW52LCAuLi5lbnYgfSxcbiAgICAgICAgICAgIGVuY29kaW5nOiBcInV0Zi04XCIsXG4gICAgICAgICAgICBzaGVsbDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5zdGRvdXQudHJpbSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGhhbmRsZXMgYm90aCBub2RlIDggYW5kIG5vZGUgMTAgd2F5IG9mIGVtaXR0aW5nIGVycm9yIHdoZW4gc3Bhd25pbmcgYSBwcm9jZXNzXG4gICAgICogICAtIG5vZGUgODogVGhyb3dzIHRoZSBlcnJvclxuICAgICAqICAgLSBub2RlIDEwOiBFbWl0IHRoZSBlcnJvcihOZWVkIHRvIGxpc3RlbiB3aXRoIG9uKVxuICAgICAqL1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi11c2VybGFuZC9lbGVjdHJvbi1idWlsZGVyL2lzc3Vlcy8xMTI5XG4gICAgLy8gTm9kZSA4IHNlbmRzIGVycm9yczogaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0LXY4LngvZG9jcy9hcGkvZXJyb3JzLmh0bWwjZXJyb3JzX2NvbW1vbl9zeXN0ZW1fZXJyb3JzXG4gICAgYXN5bmMgc3Bhd25Mb2coY21kLCBhcmdzID0gW10sIGVudiA9IHVuZGVmaW5lZCwgc3RkaW8gPSBcImlnbm9yZVwiKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGBFeGVjdXRpbmc6ICR7Y21kfSB3aXRoIGFyZ3M6ICR7YXJnc31gKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0geyBzdGRpbywgZW52LCBkZXRhY2hlZDogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSAoMCwgY2hpbGRfcHJvY2Vzc18xLnNwYXduKShjbWQsIGFyZ3MsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgcC5vbihcImVycm9yXCIsIGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwLnVucmVmKCk7XG4gICAgICAgICAgICAgICAgaWYgKHAucGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VVcGRhdGVyID0gQmFzZVVwZGF0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXNlVXBkYXRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29tcHV0ZU9wZXJhdGlvbnMgPSBleHBvcnRzLk9wZXJhdGlvbktpbmQgPSB2b2lkIDA7XG52YXIgT3BlcmF0aW9uS2luZDtcbihmdW5jdGlvbiAoT3BlcmF0aW9uS2luZCkge1xuICAgIE9wZXJhdGlvbktpbmRbT3BlcmF0aW9uS2luZFtcIkNPUFlcIl0gPSAwXSA9IFwiQ09QWVwiO1xuICAgIE9wZXJhdGlvbktpbmRbT3BlcmF0aW9uS2luZFtcIkRPV05MT0FEXCJdID0gMV0gPSBcIkRPV05MT0FEXCI7XG59KShPcGVyYXRpb25LaW5kID0gZXhwb3J0cy5PcGVyYXRpb25LaW5kIHx8IChleHBvcnRzLk9wZXJhdGlvbktpbmQgPSB7fSkpO1xuZnVuY3Rpb24gY29tcHV0ZU9wZXJhdGlvbnMob2xkQmxvY2tNYXAsIG5ld0Jsb2NrTWFwLCBsb2dnZXIpIHtcbiAgICBjb25zdCBuYW1lVG9PbGRCbG9ja3MgPSBidWlsZEJsb2NrRmlsZU1hcChvbGRCbG9ja01hcC5maWxlcyk7XG4gICAgY29uc3QgbmFtZVRvTmV3QmxvY2tzID0gYnVpbGRCbG9ja0ZpbGVNYXAobmV3QmxvY2tNYXAuZmlsZXMpO1xuICAgIGxldCBsYXN0T3BlcmF0aW9uID0gbnVsbDtcbiAgICAvLyBmb3Igbm93IG9ubHkgb25lIGZpbGUgaXMgc3VwcG9ydGVkIGluIGJsb2NrIG1hcFxuICAgIGNvbnN0IGJsb2NrTWFwRmlsZSA9IG5ld0Jsb2NrTWFwLmZpbGVzWzBdO1xuICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBbXTtcbiAgICBjb25zdCBuYW1lID0gYmxvY2tNYXBGaWxlLm5hbWU7XG4gICAgY29uc3Qgb2xkRW50cnkgPSBuYW1lVG9PbGRCbG9ja3MuZ2V0KG5hbWUpO1xuICAgIGlmIChvbGRFbnRyeSA9PSBudWxsKSB7XG4gICAgICAgIC8vIG5ldyBmaWxlICh1bnJlYWxpc3RpYyBjYXNlIGZvciBub3csIGJlY2F1c2UgaW4gYW55IGNhc2UgYm90aCBibG9ja21hcCBjb250YWluIHRoZSBvbmx5IGZpbGUgbmFtZWQgYXMgXCJmaWxlXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gZmlsZSAke25hbWV9IGluIG9sZCBibG9ja21hcGApO1xuICAgIH1cbiAgICBjb25zdCBuZXdGaWxlID0gbmFtZVRvTmV3QmxvY2tzLmdldChuYW1lKTtcbiAgICBsZXQgY2hhbmdlZEJsb2NrQ291bnQgPSAwO1xuICAgIGNvbnN0IHsgY2hlY2tzdW1Ub09mZnNldDogY2hlY2tzdW1Ub09sZE9mZnNldCwgY2hlY2tzdW1Ub09sZFNpemUgfSA9IGJ1aWxkQ2hlY2tzdW1NYXAobmFtZVRvT2xkQmxvY2tzLmdldChuYW1lKSwgb2xkRW50cnkub2Zmc2V0LCBsb2dnZXIpO1xuICAgIGxldCBuZXdPZmZzZXQgPSBibG9ja01hcEZpbGUub2Zmc2V0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3RmlsZS5jaGVja3N1bXMubGVuZ3RoOyBuZXdPZmZzZXQgKz0gbmV3RmlsZS5zaXplc1tpXSwgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrU2l6ZSA9IG5ld0ZpbGUuc2l6ZXNbaV07XG4gICAgICAgIGNvbnN0IGNoZWNrc3VtID0gbmV3RmlsZS5jaGVja3N1bXNbaV07XG4gICAgICAgIGxldCBvbGRPZmZzZXQgPSBjaGVja3N1bVRvT2xkT2Zmc2V0LmdldChjaGVja3N1bSk7XG4gICAgICAgIGlmIChvbGRPZmZzZXQgIT0gbnVsbCAmJiBjaGVja3N1bVRvT2xkU2l6ZS5nZXQoY2hlY2tzdW0pICE9PSBibG9ja1NpemUpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBDaGVja3N1bSAoXCIke2NoZWNrc3VtfVwiKSBtYXRjaGVzLCBidXQgc2l6ZSBkaWZmZXJzIChvbGQ6ICR7Y2hlY2tzdW1Ub09sZFNpemUuZ2V0KGNoZWNrc3VtKX0sIG5ldzogJHtibG9ja1NpemV9KWApO1xuICAgICAgICAgICAgb2xkT2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZG93bmxvYWQgZGF0YSBmcm9tIG5ldyBmaWxlXG4gICAgICAgICAgICBjaGFuZ2VkQmxvY2tDb3VudCsrO1xuICAgICAgICAgICAgaWYgKGxhc3RPcGVyYXRpb24gIT0gbnVsbCAmJiBsYXN0T3BlcmF0aW9uLmtpbmQgPT09IE9wZXJhdGlvbktpbmQuRE9XTkxPQUQgJiYgbGFzdE9wZXJhdGlvbi5lbmQgPT09IG5ld09mZnNldCkge1xuICAgICAgICAgICAgICAgIGxhc3RPcGVyYXRpb24uZW5kICs9IGJsb2NrU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhc3RPcGVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IE9wZXJhdGlvbktpbmQuRE9XTkxPQUQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBuZXdPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogbmV3T2Zmc2V0ICsgYmxvY2tTaXplLFxuICAgICAgICAgICAgICAgICAgICAvLyBvbGRCbG9ja3M6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUFuZEFkZChsYXN0T3BlcmF0aW9uLCBvcGVyYXRpb25zLCBjaGVja3N1bSwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyByZXVzZSBkYXRhIGZyb20gb2xkIGZpbGVcbiAgICAgICAgICAgIGlmIChsYXN0T3BlcmF0aW9uICE9IG51bGwgJiYgbGFzdE9wZXJhdGlvbi5raW5kID09PSBPcGVyYXRpb25LaW5kLkNPUFkgJiYgbGFzdE9wZXJhdGlvbi5lbmQgPT09IG9sZE9mZnNldCkge1xuICAgICAgICAgICAgICAgIGxhc3RPcGVyYXRpb24uZW5kICs9IGJsb2NrU2l6ZTtcbiAgICAgICAgICAgICAgICAvLyBsYXN0T3BlcmF0aW9uLm9sZEJsb2NrcyEhLnB1c2goY2hlY2tzdW0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYXN0T3BlcmF0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBPcGVyYXRpb25LaW5kLkNPUFksXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBvbGRPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogb2xkT2Zmc2V0ICsgYmxvY2tTaXplLFxuICAgICAgICAgICAgICAgICAgICAvLyBvbGRCbG9ja3M6IFtjaGVja3N1bV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlQW5kQWRkKGxhc3RPcGVyYXRpb24sIG9wZXJhdGlvbnMsIGNoZWNrc3VtLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2hhbmdlZEJsb2NrQ291bnQgPiAwKSB7XG4gICAgICAgIGxvZ2dlci5pbmZvKGBGaWxlJHtibG9ja01hcEZpbGUubmFtZSA9PT0gXCJmaWxlXCIgPyBcIlwiIDogXCIgXCIgKyBibG9ja01hcEZpbGUubmFtZX0gaGFzICR7Y2hhbmdlZEJsb2NrQ291bnR9IGNoYW5nZWQgYmxvY2tzYCk7XG4gICAgfVxuICAgIHJldHVybiBvcGVyYXRpb25zO1xufVxuZXhwb3J0cy5jb21wdXRlT3BlcmF0aW9ucyA9IGNvbXB1dGVPcGVyYXRpb25zO1xuY29uc3QgaXNWYWxpZGF0ZU9wZXJhdGlvblJhbmdlID0gcHJvY2Vzcy5lbnZbXCJESUZGRVJFTlRJQUxfRE9XTkxPQURfUExBTl9CVUlMREVSX1ZBTElEQVRFX1JBTkdFU1wiXSA9PT0gXCJ0cnVlXCI7XG5mdW5jdGlvbiB2YWxpZGF0ZUFuZEFkZChvcGVyYXRpb24sIG9wZXJhdGlvbnMsIGNoZWNrc3VtLCBpbmRleCkge1xuICAgIGlmIChpc1ZhbGlkYXRlT3BlcmF0aW9uUmFuZ2UgJiYgb3BlcmF0aW9ucy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgY29uc3QgbGFzdE9wZXJhdGlvbiA9IG9wZXJhdGlvbnNbb3BlcmF0aW9ucy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RPcGVyYXRpb24ua2luZCA9PT0gb3BlcmF0aW9uLmtpbmQgJiYgb3BlcmF0aW9uLnN0YXJ0IDwgbGFzdE9wZXJhdGlvbi5lbmQgJiYgb3BlcmF0aW9uLnN0YXJ0ID4gbGFzdE9wZXJhdGlvbi5zdGFydCkge1xuICAgICAgICAgICAgY29uc3QgbWluID0gW2xhc3RPcGVyYXRpb24uc3RhcnQsIGxhc3RPcGVyYXRpb24uZW5kLCBvcGVyYXRpb24uc3RhcnQsIG9wZXJhdGlvbi5lbmRdLnJlZHVjZSgocCwgdikgPT4gKHAgPCB2ID8gcCA6IHYpKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb3BlcmF0aW9uIChibG9jayBpbmRleDogJHtpbmRleH0sIGNoZWNrc3VtOiAke2NoZWNrc3VtfSwga2luZDogJHtPcGVyYXRpb25LaW5kW29wZXJhdGlvbi5raW5kXX0pIG92ZXJsYXBzIHByZXZpb3VzIG9wZXJhdGlvbiAoY2hlY2tzdW06ICR7Y2hlY2tzdW19KTpcXG5gICtcbiAgICAgICAgICAgICAgICBgYWJzOiAke2xhc3RPcGVyYXRpb24uc3RhcnR9IHVudGlsICR7bGFzdE9wZXJhdGlvbi5lbmR9IGFuZCAke29wZXJhdGlvbi5zdGFydH0gdW50aWwgJHtvcGVyYXRpb24uZW5kfVxcbmAgK1xuICAgICAgICAgICAgICAgIGByZWw6ICR7bGFzdE9wZXJhdGlvbi5zdGFydCAtIG1pbn0gdW50aWwgJHtsYXN0T3BlcmF0aW9uLmVuZCAtIG1pbn0gYW5kICR7b3BlcmF0aW9uLnN0YXJ0IC0gbWlufSB1bnRpbCAke29wZXJhdGlvbi5lbmQgLSBtaW59YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3BlcmF0aW9ucy5wdXNoKG9wZXJhdGlvbik7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LWZ1bmN0aW9uLXJldHVybi10eXBlXG5mdW5jdGlvbiBidWlsZENoZWNrc3VtTWFwKGZpbGUsIGZpbGVPZmZzZXQsIGxvZ2dlcikge1xuICAgIGNvbnN0IGNoZWNrc3VtVG9PZmZzZXQgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgY2hlY2tzdW1Ub1NpemUgPSBuZXcgTWFwKCk7XG4gICAgbGV0IG9mZnNldCA9IGZpbGVPZmZzZXQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlLmNoZWNrc3Vtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGVja3N1bSA9IGZpbGUuY2hlY2tzdW1zW2ldO1xuICAgICAgICBjb25zdCBzaXplID0gZmlsZS5zaXplc1tpXTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBjaGVja3N1bVRvU2l6ZS5nZXQoY2hlY2tzdW0pO1xuICAgICAgICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hlY2tzdW1Ub09mZnNldC5zZXQoY2hlY2tzdW0sIG9mZnNldCk7XG4gICAgICAgICAgICBjaGVja3N1bVRvU2l6ZS5zZXQoY2hlY2tzdW0sIHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxvZ2dlci5kZWJ1ZyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBzaXplRXhwbGFuYXRpb24gPSBleGlzdGluZyA9PT0gc2l6ZSA/IFwiKHNhbWUgc2l6ZSlcIiA6IGAoc2l6ZTogJHtleGlzdGluZ30sIHRoaXMgc2l6ZTogJHtzaXplfSlgO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGAke2NoZWNrc3VtfSBkdXBsaWNhdGVkIGluIGJsb2NrbWFwICR7c2l6ZUV4cGxhbmF0aW9ufSwgaXQgZG9lc24ndCBsZWFkIHRvIGJyb2tlbiBkaWZmZXJlbnRpYWwgZG93bmxvYWRlciwganVzdCBjb3JyZXNwb25kaW5nIGJsb2NrIHdpbGwgYmUgc2tpcHBlZClgKTtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gc2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY2hlY2tzdW1Ub09mZnNldCwgY2hlY2tzdW1Ub09sZFNpemU6IGNoZWNrc3VtVG9TaXplIH07XG59XG5mdW5jdGlvbiBidWlsZEJsb2NrRmlsZU1hcChsaXN0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBsaXN0KSB7XG4gICAgICAgIHJlc3VsdC5zZXQoaXRlbS5uYW1lLCBpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvd25sb2FkUGxhbkJ1aWxkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRhdGFTcGxpdHRlciA9IGV4cG9ydHMuY29weURhdGEgPSB2b2lkIDA7XG5jb25zdCBidWlsZGVyX3V0aWxfcnVudGltZV8xID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xuY29uc3QgZnNfMSA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IGRvd25sb2FkUGxhbkJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL2Rvd25sb2FkUGxhbkJ1aWxkZXJcIik7XG5jb25zdCBET1VCTEVfQ1JMRiA9IEJ1ZmZlci5mcm9tKFwiXFxyXFxuXFxyXFxuXCIpO1xudmFyIFJlYWRTdGF0ZTtcbihmdW5jdGlvbiAoUmVhZFN0YXRlKSB7XG4gICAgUmVhZFN0YXRlW1JlYWRTdGF0ZVtcIklOSVRcIl0gPSAwXSA9IFwiSU5JVFwiO1xuICAgIFJlYWRTdGF0ZVtSZWFkU3RhdGVbXCJIRUFERVJcIl0gPSAxXSA9IFwiSEVBREVSXCI7XG4gICAgUmVhZFN0YXRlW1JlYWRTdGF0ZVtcIkJPRFlcIl0gPSAyXSA9IFwiQk9EWVwiO1xufSkoUmVhZFN0YXRlIHx8IChSZWFkU3RhdGUgPSB7fSkpO1xuZnVuY3Rpb24gY29weURhdGEodGFzaywgb3V0LCBvbGRGaWxlRmQsIHJlamVjdCwgcmVzb2x2ZSkge1xuICAgIGNvbnN0IHJlYWRTdHJlYW0gPSAoMCwgZnNfMS5jcmVhdGVSZWFkU3RyZWFtKShcIlwiLCB7XG4gICAgICAgIGZkOiBvbGRGaWxlRmQsXG4gICAgICAgIGF1dG9DbG9zZTogZmFsc2UsXG4gICAgICAgIHN0YXJ0OiB0YXNrLnN0YXJ0LFxuICAgICAgICAvLyBlbmQgaXMgaW5jbHVzaXZlXG4gICAgICAgIGVuZDogdGFzay5lbmQgLSAxLFxuICAgIH0pO1xuICAgIHJlYWRTdHJlYW0ub24oXCJlcnJvclwiLCByZWplY3QpO1xuICAgIHJlYWRTdHJlYW0ub25jZShcImVuZFwiLCByZXNvbHZlKTtcbiAgICByZWFkU3RyZWFtLnBpcGUob3V0LCB7XG4gICAgICAgIGVuZDogZmFsc2UsXG4gICAgfSk7XG59XG5leHBvcnRzLmNvcHlEYXRhID0gY29weURhdGE7XG5jbGFzcyBEYXRhU3BsaXR0ZXIgZXh0ZW5kcyBzdHJlYW1fMS5Xcml0YWJsZSB7XG4gICAgY29uc3RydWN0b3Iob3V0LCBvcHRpb25zLCBwYXJ0SW5kZXhUb1Rhc2tJbmRleCwgYm91bmRhcnksIHBhcnRJbmRleFRvTGVuZ3RoLCBmaW5pc2hIYW5kbGVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub3V0ID0gb3V0O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnBhcnRJbmRleFRvVGFza0luZGV4ID0gcGFydEluZGV4VG9UYXNrSW5kZXg7XG4gICAgICAgIHRoaXMucGFydEluZGV4VG9MZW5ndGggPSBwYXJ0SW5kZXhUb0xlbmd0aDtcbiAgICAgICAgdGhpcy5maW5pc2hIYW5kbGVyID0gZmluaXNoSGFuZGxlcjtcbiAgICAgICAgdGhpcy5wYXJ0SW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5oZWFkZXJMaXN0QnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuSU5JVDtcbiAgICAgICAgdGhpcy5pZ25vcmVCeXRlQ291bnQgPSAwO1xuICAgICAgICB0aGlzLnJlbWFpbmluZ1BhcnREYXRhQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmFjdHVhbFBhcnRMZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmJvdW5kYXJ5TGVuZ3RoID0gYm91bmRhcnkubGVuZ3RoICsgNDsgLyogc2l6ZSBvZiBcXHJcXG4tLSAqL1xuICAgICAgICAvLyBmaXJzdCBjaHVuayBkb2Vzbid0IHN0YXJ0IHdpdGggXFxyXFxuXG4gICAgICAgIHRoaXMuaWdub3JlQnl0ZUNvdW50ID0gdGhpcy5ib3VuZGFyeUxlbmd0aCAtIDI7XG4gICAgfVxuICAgIGdldCBpc0ZpbmlzaGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0SW5kZXggPT09IHRoaXMucGFydEluZGV4VG9MZW5ndGgubGVuZ3RoO1xuICAgIH1cbiAgICAvLyBub2luc3BlY3Rpb24gSlNVbnVzZWRHbG9iYWxTeW1ib2xzXG4gICAgX3dyaXRlKGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBUcmFpbGluZyBpZ25vcmVkIGRhdGE6ICR7ZGF0YS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kbGVEYXRhKGRhdGEpLnRoZW4oY2FsbGJhY2spLmNhdGNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlRGF0YShjaHVuaykge1xuICAgICAgICBsZXQgc3RhcnQgPSAwO1xuICAgICAgICBpZiAodGhpcy5pZ25vcmVCeXRlQ291bnQgIT09IDAgJiYgdGhpcy5yZW1haW5pbmdQYXJ0RGF0YUNvdW50ICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcikoXCJJbnRlcm5hbCBlcnJvclwiLCBcIkVSUl9EQVRBX1NQTElUVEVSX0JZVEVfQ09VTlRfTUlTTUFUQ0hcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaWdub3JlQnl0ZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgY29uc3QgdG9JZ25vcmUgPSBNYXRoLm1pbih0aGlzLmlnbm9yZUJ5dGVDb3VudCwgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuaWdub3JlQnl0ZUNvdW50IC09IHRvSWdub3JlO1xuICAgICAgICAgICAgc3RhcnQgPSB0b0lnbm9yZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnJlbWFpbmluZ1BhcnREYXRhQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB0b1JlYWQgPSBNYXRoLm1pbih0aGlzLnJlbWFpbmluZ1BhcnREYXRhQ291bnQsIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLnJlbWFpbmluZ1BhcnREYXRhQ291bnQgLT0gdG9SZWFkO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzUGFydERhdGEoY2h1bmssIDAsIHRvUmVhZCk7XG4gICAgICAgICAgICBzdGFydCA9IHRvUmVhZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPT09IGNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlYWRTdGF0ZSA9PT0gUmVhZFN0YXRlLkhFQURFUikge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyTGlzdEVuZCA9IHRoaXMuc2VhcmNoSGVhZGVyTGlzdEVuZChjaHVuaywgc3RhcnQpO1xuICAgICAgICAgICAgaWYgKGhlYWRlckxpc3RFbmQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgPSBoZWFkZXJMaXN0RW5kO1xuICAgICAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuQk9EWTtcbiAgICAgICAgICAgIC8vIGhlYWRlciBsaXN0IGlzIGlnbm9yZWQsIHdlIGRvbid0IG5lZWQgaXRcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyTGlzdEJ1ZmZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRTdGF0ZSA9PT0gUmVhZFN0YXRlLkJPRFkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5JTklUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0SW5kZXgrKztcbiAgICAgICAgICAgICAgICBsZXQgdGFza0luZGV4ID0gdGhpcy5wYXJ0SW5kZXhUb1Rhc2tJbmRleC5nZXQodGhpcy5wYXJ0SW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICh0YXNrSW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrSW5kZXggPSB0aGlzLm9wdGlvbnMuZW5kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgKDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IpKFwidGFza0luZGV4IGlzIG51bGxcIiwgXCJFUlJfREFUQV9TUExJVFRFUl9UQVNLX0lOREVYX0lTX05VTExcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldlRhc2tJbmRleCA9IHRoaXMucGFydEluZGV4ID09PSAwID8gdGhpcy5vcHRpb25zLnN0YXJ0IDogdGhpcy5wYXJ0SW5kZXhUb1Rhc2tJbmRleC5nZXQodGhpcy5wYXJ0SW5kZXggLSAxKSArIDE7IC8qIHByZXYgcGFydCBpcyBkb3dubG9hZCwgbmV4dCBtYXliZSBjb3B5ICovXG4gICAgICAgICAgICAgICAgaWYgKHByZXZUYXNrSW5kZXggPCB0YXNrSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jb3B5RXhpc3RpbmdEYXRhKHByZXZUYXNrSW5kZXgsIHRhc2tJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByZXZUYXNrSW5kZXggPiB0YXNrSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgKDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IpKFwicHJldlRhc2tJbmRleCBtdXN0IGJlIDwgdGFza0luZGV4XCIsIFwiRVJSX0RBVEFfU1BMSVRURVJfVEFTS19JTkRFWF9BU1NFUlRfRkFJTEVEXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25QYXJ0RW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoSGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5zZWFyY2hIZWFkZXJMaXN0RW5kKGNodW5rLCBzdGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5IRUFERVI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJ0TGVuZ3RoID0gdGhpcy5wYXJ0SW5kZXhUb0xlbmd0aFt0aGlzLnBhcnRJbmRleF07XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIHBhcnRMZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBlZmZlY3RpdmVFbmQgPSBNYXRoLm1pbihlbmQsIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnByb2Nlc3NQYXJ0U3RhcnRlZChjaHVuaywgc3RhcnQsIGVmZmVjdGl2ZUVuZCk7XG4gICAgICAgICAgICB0aGlzLnJlbWFpbmluZ1BhcnREYXRhQ291bnQgPSBwYXJ0TGVuZ3RoIC0gKGVmZmVjdGl2ZUVuZCAtIHN0YXJ0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbWFpbmluZ1BhcnREYXRhQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgPSBlbmQgKyB0aGlzLmJvdW5kYXJ5TGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID49IGNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaWdub3JlQnl0ZUNvdW50ID0gdGhpcy5ib3VuZGFyeUxlbmd0aCAtIChjaHVuay5sZW5ndGggLSBlbmQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb3B5RXhpc3RpbmdEYXRhKGluZGV4LCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHcgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHRhc2sgPSB0aGlzLm9wdGlvbnMudGFza3NbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmICh0YXNrLmtpbmQgIT09IGRvd25sb2FkUGxhbkJ1aWxkZXJfMS5PcGVyYXRpb25LaW5kLkNPUFkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlRhc2sga2luZCBtdXN0IGJlIENPUFlcIikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvcHlEYXRhKHRhc2ssIHRoaXMub3V0LCB0aGlzLm9wdGlvbnMub2xkRmlsZUZkLCByZWplY3QsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgdygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHcoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlYXJjaEhlYWRlckxpc3RFbmQoY2h1bmssIHJlYWRPZmZzZXQpIHtcbiAgICAgICAgY29uc3QgaGVhZGVyTGlzdEVuZCA9IGNodW5rLmluZGV4T2YoRE9VQkxFX0NSTEYsIHJlYWRPZmZzZXQpO1xuICAgICAgICBpZiAoaGVhZGVyTGlzdEVuZCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBoZWFkZXJMaXN0RW5kICsgRE9VQkxFX0NSTEYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdCBhbGwgaGVhZGVycyBkYXRhIHdlcmUgcmVjZWl2ZWQsIHNhdmUgdG8gYnVmZmVyXG4gICAgICAgIGNvbnN0IHBhcnRpYWxDaHVuayA9IHJlYWRPZmZzZXQgPT09IDAgPyBjaHVuayA6IGNodW5rLnNsaWNlKHJlYWRPZmZzZXQpO1xuICAgICAgICBpZiAodGhpcy5oZWFkZXJMaXN0QnVmZmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyTGlzdEJ1ZmZlciA9IHBhcnRpYWxDaHVuaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyTGlzdEJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuaGVhZGVyTGlzdEJ1ZmZlciwgcGFydGlhbENodW5rXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBvblBhcnRFbmQoKSB7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkTGVuZ3RoID0gdGhpcy5wYXJ0SW5kZXhUb0xlbmd0aFt0aGlzLnBhcnRJbmRleCAtIDFdO1xuICAgICAgICBpZiAodGhpcy5hY3R1YWxQYXJ0TGVuZ3RoICE9PSBleHBlY3RlZExlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IpKGBFeHBlY3RlZCBsZW5ndGg6ICR7ZXhwZWN0ZWRMZW5ndGh9IGRpZmZlcnMgZnJvbSBhY3R1YWw6ICR7dGhpcy5hY3R1YWxQYXJ0TGVuZ3RofWAsIFwiRVJSX0RBVEFfU1BMSVRURVJfTEVOR1RIX01JU01BVENIXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0dWFsUGFydExlbmd0aCA9IDA7XG4gICAgfVxuICAgIHByb2Nlc3NQYXJ0U3RhcnRlZChkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcnRJbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5vblBhcnRFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUGFydERhdGEoZGF0YSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIHByb2Nlc3NQYXJ0RGF0YShkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMuYWN0dWFsUGFydExlbmd0aCArPSBlbmQgLSBzdGFydDtcbiAgICAgICAgY29uc3Qgb3V0ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmIChvdXQud3JpdGUoc3RhcnQgPT09IDAgJiYgZGF0YS5sZW5ndGggPT09IGVuZCA/IGRhdGEgOiBkYXRhLnNsaWNlKHN0YXJ0LCBlbmQpKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBvdXQub24oXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIG91dC5vbmNlKFwiZHJhaW5cIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvdXQucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRGF0YVNwbGl0dGVyID0gRGF0YVNwbGl0dGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGF0YVNwbGl0dGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jaGVja0lzUmFuZ2VzU3VwcG9ydGVkID0gZXhwb3J0cy5leGVjdXRlVGFza3NVc2luZ011bHRpcGxlUmFuZ2VSZXF1ZXN0cyA9IHZvaWQgMDtcbmNvbnN0IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG5jb25zdCBEYXRhU3BsaXR0ZXJfMSA9IHJlcXVpcmUoXCIuL0RhdGFTcGxpdHRlclwiKTtcbmNvbnN0IGRvd25sb2FkUGxhbkJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL2Rvd25sb2FkUGxhbkJ1aWxkZXJcIik7XG5mdW5jdGlvbiBleGVjdXRlVGFza3NVc2luZ011bHRpcGxlUmFuZ2VSZXF1ZXN0cyhkaWZmZXJlbnRpYWxEb3dubG9hZGVyLCB0YXNrcywgb3V0LCBvbGRGaWxlRmQsIHJlamVjdCkge1xuICAgIGNvbnN0IHcgPSAodGFza09mZnNldCkgPT4ge1xuICAgICAgICBpZiAodGFza09mZnNldCA+PSB0YXNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChkaWZmZXJlbnRpYWxEb3dubG9hZGVyLmZpbGVNZXRhZGF0YUJ1ZmZlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3V0LndyaXRlKGRpZmZlcmVudGlhbERvd25sb2FkZXIuZmlsZU1ldGFkYXRhQnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dC5lbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0T2Zmc2V0ID0gdGFza09mZnNldCArIDEwMDA7XG4gICAgICAgIGRvRXhlY3V0ZVRhc2tzKGRpZmZlcmVudGlhbERvd25sb2FkZXIsIHtcbiAgICAgICAgICAgIHRhc2tzLFxuICAgICAgICAgICAgc3RhcnQ6IHRhc2tPZmZzZXQsXG4gICAgICAgICAgICBlbmQ6IE1hdGgubWluKHRhc2tzLmxlbmd0aCwgbmV4dE9mZnNldCksXG4gICAgICAgICAgICBvbGRGaWxlRmQsXG4gICAgICAgIH0sIG91dCwgKCkgPT4gdyhuZXh0T2Zmc2V0KSwgcmVqZWN0KTtcbiAgICB9O1xuICAgIHJldHVybiB3O1xufVxuZXhwb3J0cy5leGVjdXRlVGFza3NVc2luZ011bHRpcGxlUmFuZ2VSZXF1ZXN0cyA9IGV4ZWN1dGVUYXNrc1VzaW5nTXVsdGlwbGVSYW5nZVJlcXVlc3RzO1xuZnVuY3Rpb24gZG9FeGVjdXRlVGFza3MoZGlmZmVyZW50aWFsRG93bmxvYWRlciwgb3B0aW9ucywgb3V0LCByZXNvbHZlLCByZWplY3QpIHtcbiAgICBsZXQgcmFuZ2VzID0gXCJieXRlcz1cIjtcbiAgICBsZXQgcGFydENvdW50ID0gMDtcbiAgICBjb25zdCBwYXJ0SW5kZXhUb1Rhc2tJbmRleCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBwYXJ0SW5kZXhUb0xlbmd0aCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSBvcHRpb25zLnN0YXJ0OyBpIDwgb3B0aW9ucy5lbmQ7IGkrKykge1xuICAgICAgICBjb25zdCB0YXNrID0gb3B0aW9ucy50YXNrc1tpXTtcbiAgICAgICAgaWYgKHRhc2sua2luZCA9PT0gZG93bmxvYWRQbGFuQnVpbGRlcl8xLk9wZXJhdGlvbktpbmQuRE9XTkxPQUQpIHtcbiAgICAgICAgICAgIHJhbmdlcyArPSBgJHt0YXNrLnN0YXJ0fS0ke3Rhc2suZW5kIC0gMX0sIGA7XG4gICAgICAgICAgICBwYXJ0SW5kZXhUb1Rhc2tJbmRleC5zZXQocGFydENvdW50LCBpKTtcbiAgICAgICAgICAgIHBhcnRDb3VudCsrO1xuICAgICAgICAgICAgcGFydEluZGV4VG9MZW5ndGgucHVzaCh0YXNrLmVuZCAtIHRhc2suc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJ0Q291bnQgPD0gMSkge1xuICAgICAgICAvLyB0aGUgb25seSByZW1vdGUgcmFuZ2UgLSBjb3B5XG4gICAgICAgIGNvbnN0IHcgPSAoaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSBvcHRpb25zLmVuZCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gb3B0aW9ucy50YXNrc1tpbmRleCsrXTtcbiAgICAgICAgICAgIGlmICh0YXNrLmtpbmQgPT09IGRvd25sb2FkUGxhbkJ1aWxkZXJfMS5PcGVyYXRpb25LaW5kLkNPUFkpIHtcbiAgICAgICAgICAgICAgICAoMCwgRGF0YVNwbGl0dGVyXzEuY29weURhdGEpKHRhc2ssIG91dCwgb3B0aW9ucy5vbGRGaWxlRmQsIHJlamVjdCwgKCkgPT4gdyhpbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBkaWZmZXJlbnRpYWxEb3dubG9hZGVyLmNyZWF0ZVJlcXVlc3RPcHRpb25zKCk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMuaGVhZGVycy5SYW5nZSA9IGBieXRlcz0ke3Rhc2suc3RhcnR9LSR7dGFzay5lbmQgLSAxfWA7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IGRpZmZlcmVudGlhbERvd25sb2FkZXIuaHR0cEV4ZWN1dG9yLmNyZWF0ZVJlcXVlc3QocmVxdWVzdE9wdGlvbnMsIHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja0lzUmFuZ2VzU3VwcG9ydGVkKHJlc3BvbnNlLCByZWplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UucGlwZShvdXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5vbmNlKFwiZW5kXCIsICgpID0+IHcoaW5kZXgpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkaWZmZXJlbnRpYWxEb3dubG9hZGVyLmh0dHBFeGVjdXRvci5hZGRFcnJvckFuZFRpbWVvdXRIYW5kbGVycyhyZXF1ZXN0LCByZWplY3QpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHcob3B0aW9ucy5zdGFydCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBkaWZmZXJlbnRpYWxEb3dubG9hZGVyLmNyZWF0ZVJlcXVlc3RPcHRpb25zKCk7XG4gICAgcmVxdWVzdE9wdGlvbnMuaGVhZGVycy5SYW5nZSA9IHJhbmdlcy5zdWJzdHJpbmcoMCwgcmFuZ2VzLmxlbmd0aCAtIDIpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSBkaWZmZXJlbnRpYWxEb3dubG9hZGVyLmh0dHBFeGVjdXRvci5jcmVhdGVSZXF1ZXN0KHJlcXVlc3RPcHRpb25zLCByZXNwb25zZSA9PiB7XG4gICAgICAgIGlmICghY2hlY2tJc1Jhbmdlc1N1cHBvcnRlZChyZXNwb25zZSwgcmVqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gKDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuc2FmZUdldEhlYWRlcikocmVzcG9uc2UsIFwiY29udGVudC10eXBlXCIpO1xuICAgICAgICBjb25zdCBtID0gL15tdWx0aXBhcnRcXC8uKz8oPzo7IGJvdW5kYXJ5PSg/Oig/OlwiKC4rKVwiKXwoPzooW15cXHNdKykpKSkkL2kuZXhlYyhjb250ZW50VHlwZSk7XG4gICAgICAgIGlmIChtID09IG51bGwpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYENvbnRlbnQtVHlwZSBcIm11bHRpcGFydC9ieXRlcmFuZ2VzXCIgaXMgZXhwZWN0ZWQsIGJ1dCBnb3QgXCIke2NvbnRlbnRUeXBlfVwiYCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpY2VyID0gbmV3IERhdGFTcGxpdHRlcl8xLkRhdGFTcGxpdHRlcihvdXQsIG9wdGlvbnMsIHBhcnRJbmRleFRvVGFza0luZGV4LCBtWzFdIHx8IG1bMl0sIHBhcnRJbmRleFRvTGVuZ3RoLCByZXNvbHZlKTtcbiAgICAgICAgZGljZXIub24oXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICByZXNwb25zZS5waXBlKGRpY2VyKTtcbiAgICAgICAgcmVzcG9uc2Uub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJSZXNwb25zZSBlbmRzIHdpdGhvdXQgY2FsbGluZyBhbnkgaGFuZGxlcnNcIikpO1xuICAgICAgICAgICAgfSwgMTAwMDApO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBkaWZmZXJlbnRpYWxEb3dubG9hZGVyLmh0dHBFeGVjdXRvci5hZGRFcnJvckFuZFRpbWVvdXRIYW5kbGVycyhyZXF1ZXN0LCByZWplY3QpO1xuICAgIHJlcXVlc3QuZW5kKCk7XG59XG5mdW5jdGlvbiBjaGVja0lzUmFuZ2VzU3VwcG9ydGVkKHJlc3BvbnNlLCByZWplY3QpIHtcbiAgICAvLyBFbGVjdHJvbiBuZXQgaGFuZGxlcyByZWRpcmVjdHMgYXV0b21hdGljYWxseSwgb3VyIE5vZGVKUyB0ZXN0IHNlcnZlciBkb2Vzbid0IHVzZSByZWRpcmVjdHMgLSBzbywgd2UgZG9uJ3QgY2hlY2sgM3h4IGNvZGVzLlxuICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgICByZWplY3QoKDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuY3JlYXRlSHR0cEVycm9yKShyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlICE9PSAyMDYpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0UmFuZ2VzID0gKDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuc2FmZUdldEhlYWRlcikocmVzcG9uc2UsIFwiYWNjZXB0LXJhbmdlc1wiKTtcbiAgICAgICAgaWYgKGFjY2VwdFJhbmdlcyA9PSBudWxsIHx8IGFjY2VwdFJhbmdlcyA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFNlcnZlciBkb2Vzbid0IHN1cHBvcnQgQWNjZXB0LVJhbmdlcyAocmVzcG9uc2UgY29kZSAke3Jlc3BvbnNlLnN0YXR1c0NvZGV9KWApKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuY2hlY2tJc1Jhbmdlc1N1cHBvcnRlZCA9IGNoZWNrSXNSYW5nZXNTdXBwb3J0ZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aXBsZVJhbmdlRG93bmxvYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZENhbGxiYWNrVHJhbnNmb3JtID0gdm9pZCAwO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xudmFyIE9wZXJhdGlvbktpbmQ7XG4oZnVuY3Rpb24gKE9wZXJhdGlvbktpbmQpIHtcbiAgICBPcGVyYXRpb25LaW5kW09wZXJhdGlvbktpbmRbXCJDT1BZXCJdID0gMF0gPSBcIkNPUFlcIjtcbiAgICBPcGVyYXRpb25LaW5kW09wZXJhdGlvbktpbmRbXCJET1dOTE9BRFwiXSA9IDFdID0gXCJET1dOTE9BRFwiO1xufSkoT3BlcmF0aW9uS2luZCB8fCAoT3BlcmF0aW9uS2luZCA9IHt9KSk7XG5jbGFzcyBQcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkQ2FsbGJhY2tUcmFuc2Zvcm0gZXh0ZW5kcyBzdHJlYW1fMS5UcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKHByb2dyZXNzRGlmZmVyZW50aWFsRG93bmxvYWRJbmZvLCBjYW5jZWxsYXRpb25Ub2tlbiwgb25Qcm9ncmVzcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnByb2dyZXNzRGlmZmVyZW50aWFsRG93bmxvYWRJbmZvID0gcHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZEluZm87XG4gICAgICAgIHRoaXMuY2FuY2VsbGF0aW9uVG9rZW4gPSBjYW5jZWxsYXRpb25Ub2tlbjtcbiAgICAgICAgdGhpcy5vblByb2dyZXNzID0gb25Qcm9ncmVzcztcbiAgICAgICAgdGhpcy5zdGFydCA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMudHJhbnNmZXJyZWQgPSAwO1xuICAgICAgICB0aGlzLmRlbHRhID0gMDtcbiAgICAgICAgdGhpcy5leHBlY3RlZEJ5dGVzID0gMDtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMub3BlcmF0aW9uVHlwZSA9IE9wZXJhdGlvbktpbmQuQ09QWTtcbiAgICAgICAgdGhpcy5uZXh0VXBkYXRlID0gdGhpcy5zdGFydCArIDEwMDA7XG4gICAgfVxuICAgIF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5jYW5jZWxsYXRpb25Ub2tlbi5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihcImNhbmNlbGxlZFwiKSwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9uJ3Qgc2VuZCBwcm9ncmVzcyB1cGRhdGUgd2hlbiBjb3B5aW5nIGZyb20gZGlza1xuICAgICAgICBpZiAodGhpcy5vcGVyYXRpb25UeXBlID09IE9wZXJhdGlvbktpbmQuQ09QWSkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgY2h1bmspO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNmZXJyZWQgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICB0aGlzLmRlbHRhICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKG5vdyA+PSB0aGlzLm5leHRVcGRhdGUgJiZcbiAgICAgICAgICAgIHRoaXMudHJhbnNmZXJyZWQgIT09IHRoaXMuZXhwZWN0ZWRCeXRlcyAvKiB3aWxsIGJlIGVtaXR0ZWQgYnkgZW5kUmFuZ2VEb3dubG9hZCgpICovICYmXG4gICAgICAgICAgICB0aGlzLnRyYW5zZmVycmVkICE9PSB0aGlzLnByb2dyZXNzRGlmZmVyZW50aWFsRG93bmxvYWRJbmZvLmdyYW5kVG90YWwgLyogd2lsbCBiZSBlbWl0dGVkIG9uIF9mbHVzaCAqLykge1xuICAgICAgICAgICAgdGhpcy5uZXh0VXBkYXRlID0gbm93ICsgMTAwMDtcbiAgICAgICAgICAgIHRoaXMub25Qcm9ncmVzcyh7XG4gICAgICAgICAgICAgICAgdG90YWw6IHRoaXMucHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZEluZm8uZ3JhbmRUb3RhbCxcbiAgICAgICAgICAgICAgICBkZWx0YTogdGhpcy5kZWx0YSxcbiAgICAgICAgICAgICAgICB0cmFuc2ZlcnJlZDogdGhpcy50cmFuc2ZlcnJlZCxcbiAgICAgICAgICAgICAgICBwZXJjZW50OiAodGhpcy50cmFuc2ZlcnJlZCAvIHRoaXMucHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZEluZm8uZ3JhbmRUb3RhbCkgKiAxMDAsXG4gICAgICAgICAgICAgICAgYnl0ZXNQZXJTZWNvbmQ6IE1hdGgucm91bmQodGhpcy50cmFuc2ZlcnJlZCAvICgobm93IC0gdGhpcy5zdGFydCkgLyAxMDAwKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZGVsdGEgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGNodW5rKTtcbiAgICB9XG4gICAgYmVnaW5GaWxlQ29weSgpIHtcbiAgICAgICAgdGhpcy5vcGVyYXRpb25UeXBlID0gT3BlcmF0aW9uS2luZC5DT1BZO1xuICAgIH1cbiAgICBiZWdpblJhbmdlRG93bmxvYWQoKSB7XG4gICAgICAgIHRoaXMub3BlcmF0aW9uVHlwZSA9IE9wZXJhdGlvbktpbmQuRE9XTkxPQUQ7XG4gICAgICAgIHRoaXMuZXhwZWN0ZWRCeXRlcyArPSB0aGlzLnByb2dyZXNzRGlmZmVyZW50aWFsRG93bmxvYWRJbmZvLmV4cGVjdGVkQnl0ZUNvdW50c1t0aGlzLmluZGV4KytdO1xuICAgIH1cbiAgICBlbmRSYW5nZURvd25sb2FkKCkge1xuICAgICAgICAvLyBfZmx1c2goKSB3aWxsIGRvb3VyIGZpbmFsIDEwMCVcbiAgICAgICAgaWYgKHRoaXMudHJhbnNmZXJyZWQgIT09IHRoaXMucHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZEluZm8uZ3JhbmRUb3RhbCkge1xuICAgICAgICAgICAgdGhpcy5vblByb2dyZXNzKHtcbiAgICAgICAgICAgICAgICB0b3RhbDogdGhpcy5wcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkSW5mby5ncmFuZFRvdGFsLFxuICAgICAgICAgICAgICAgIGRlbHRhOiB0aGlzLmRlbHRhLFxuICAgICAgICAgICAgICAgIHRyYW5zZmVycmVkOiB0aGlzLnRyYW5zZmVycmVkLFxuICAgICAgICAgICAgICAgIHBlcmNlbnQ6ICh0aGlzLnRyYW5zZmVycmVkIC8gdGhpcy5wcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkSW5mby5ncmFuZFRvdGFsKSAqIDEwMCxcbiAgICAgICAgICAgICAgICBieXRlc1BlclNlY29uZDogTWF0aC5yb3VuZCh0aGlzLnRyYW5zZmVycmVkIC8gKChEYXRlLm5vdygpIC0gdGhpcy5zdGFydCkgLyAxMDAwKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDYWxsZWQgd2hlbiB3ZSBhcmUgMTAwJSBkb25lIHdpdGggdGhlIGNvbm5lY3Rpb24vZG93bmxvYWRcbiAgICBfZmx1c2goY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsbGF0aW9uVG9rZW4uY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoXCJjYW5jZWxsZWRcIikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25Qcm9ncmVzcyh7XG4gICAgICAgICAgICB0b3RhbDogdGhpcy5wcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkSW5mby5ncmFuZFRvdGFsLFxuICAgICAgICAgICAgZGVsdGE6IHRoaXMuZGVsdGEsXG4gICAgICAgICAgICB0cmFuc2ZlcnJlZDogdGhpcy50cmFuc2ZlcnJlZCxcbiAgICAgICAgICAgIHBlcmNlbnQ6IDEwMCxcbiAgICAgICAgICAgIGJ5dGVzUGVyU2Vjb25kOiBNYXRoLnJvdW5kKHRoaXMudHJhbnNmZXJyZWQgLyAoKERhdGUubm93KCkgLSB0aGlzLnN0YXJ0KSAvIDEwMDApKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVsdGEgPSAwO1xuICAgICAgICB0aGlzLnRyYW5zZmVycmVkID0gMDtcbiAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkQ2FsbGJhY2tUcmFuc2Zvcm0gPSBQcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkQ2FsbGJhY2tUcmFuc2Zvcm07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkQ2FsbGJhY2tUcmFuc2Zvcm0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRpZmZlcmVudGlhbERvd25sb2FkZXIgPSB2b2lkIDA7XG5jb25zdCBidWlsZGVyX3V0aWxfcnVudGltZV8xID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xuY29uc3QgZnNfZXh0cmFfMSA9IHJlcXVpcmUoXCJmcy1leHRyYVwiKTtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBEYXRhU3BsaXR0ZXJfMSA9IHJlcXVpcmUoXCIuL0RhdGFTcGxpdHRlclwiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IGRvd25sb2FkUGxhbkJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL2Rvd25sb2FkUGxhbkJ1aWxkZXJcIik7XG5jb25zdCBtdWx0aXBsZVJhbmdlRG93bmxvYWRlcl8xID0gcmVxdWlyZShcIi4vbXVsdGlwbGVSYW5nZURvd25sb2FkZXJcIik7XG5jb25zdCBQcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkQ2FsbGJhY2tUcmFuc2Zvcm1fMSA9IHJlcXVpcmUoXCIuL1Byb2dyZXNzRGlmZmVyZW50aWFsRG93bmxvYWRDYWxsYmFja1RyYW5zZm9ybVwiKTtcbmNsYXNzIERpZmZlcmVudGlhbERvd25sb2FkZXIge1xuICAgIC8vIG5vaW5zcGVjdGlvbiBUeXBlU2NyaXB0QWJzdHJhY3RDbGFzc0NvbnN0cnVjdG9yQ2FuQmVNYWRlUHJvdGVjdGVkXG4gICAgY29uc3RydWN0b3IoYmxvY2tBd2FyZUZpbGVJbmZvLCBodHRwRXhlY3V0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5ibG9ja0F3YXJlRmlsZUluZm8gPSBibG9ja0F3YXJlRmlsZUluZm87XG4gICAgICAgIHRoaXMuaHR0cEV4ZWN1dG9yID0gaHR0cEV4ZWN1dG9yO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmZpbGVNZXRhZGF0YUJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gb3B0aW9ucy5sb2dnZXI7XG4gICAgfVxuICAgIGNyZWF0ZVJlcXVlc3RPcHRpb25zKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLnJlcXVlc3RIZWFkZXJzLFxuICAgICAgICAgICAgICAgIGFjY2VwdDogXCIqLypcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgICgwLCBidWlsZGVyX3V0aWxfcnVudGltZV8xLmNvbmZpZ3VyZVJlcXVlc3RVcmwpKHRoaXMub3B0aW9ucy5uZXdVcmwsIHJlc3VsdCk7XG4gICAgICAgIC8vIHVzZXItYWdlbnQsIGNhY2hlLWNvbnRyb2wgYW5kIG90aGVyIGNvbW1vbiBvcHRpb25zXG4gICAgICAgICgwLCBidWlsZGVyX3V0aWxfcnVudGltZV8xLmNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zKShyZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBkb0Rvd25sb2FkKG9sZEJsb2NrTWFwLCBuZXdCbG9ja01hcCkge1xuICAgICAgICAvLyB3ZSBkb24ndCBjaGVjayBvdGhlciBtZXRhZGF0YSBsaWtlIGNvbXByZXNzaW9uTWV0aG9kIC0gZ2VuZXJpYyBjaGVjayB0aGF0IGl0IGlzIG1ha2Ugc2Vuc2UgdG8gZGlmZmVyZW50aWFsbHkgdXBkYXRlIGlzIHN1aXRhYmxlIGZvciBpdFxuICAgICAgICBpZiAob2xkQmxvY2tNYXAudmVyc2lvbiAhPT0gbmV3QmxvY2tNYXAudmVyc2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2ZXJzaW9uIGlzIGRpZmZlcmVudCAoJHtvbGRCbG9ja01hcC52ZXJzaW9ufSAtICR7bmV3QmxvY2tNYXAudmVyc2lvbn0pLCBmdWxsIGRvd25sb2FkIGlzIHJlcXVpcmVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9nZ2VyID0gdGhpcy5sb2dnZXI7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbnMgPSAoMCwgZG93bmxvYWRQbGFuQnVpbGRlcl8xLmNvbXB1dGVPcGVyYXRpb25zKShvbGRCbG9ja01hcCwgbmV3QmxvY2tNYXAsIGxvZ2dlcik7XG4gICAgICAgIGlmIChsb2dnZXIuZGVidWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKEpTT04uc3RyaW5naWZ5KG9wZXJhdGlvbnMsIG51bGwsIDIpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZG93bmxvYWRTaXplID0gMDtcbiAgICAgICAgbGV0IGNvcHlTaXplID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBvcGVyYXRpb24gb2Ygb3BlcmF0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gb3BlcmF0aW9uLmVuZCAtIG9wZXJhdGlvbi5zdGFydDtcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ua2luZCA9PT0gZG93bmxvYWRQbGFuQnVpbGRlcl8xLk9wZXJhdGlvbktpbmQuRE9XTkxPQUQpIHtcbiAgICAgICAgICAgICAgICBkb3dubG9hZFNpemUgKz0gbGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29weVNpemUgKz0gbGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1NpemUgPSB0aGlzLmJsb2NrQXdhcmVGaWxlSW5mby5zaXplO1xuICAgICAgICBpZiAoZG93bmxvYWRTaXplICsgY29weVNpemUgKyAodGhpcy5maWxlTWV0YWRhdGFCdWZmZXIgPT0gbnVsbCA/IDAgOiB0aGlzLmZpbGVNZXRhZGF0YUJ1ZmZlci5sZW5ndGgpICE9PSBuZXdTaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIGVycm9yLCBzaXplIG1pc21hdGNoOiBkb3dubG9hZFNpemU6ICR7ZG93bmxvYWRTaXplfSwgY29weVNpemU6ICR7Y29weVNpemV9LCBuZXdTaXplOiAke25ld1NpemV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmluZm8oYEZ1bGw6ICR7Zm9ybWF0Qnl0ZXMobmV3U2l6ZSl9LCBUbyBkb3dubG9hZDogJHtmb3JtYXRCeXRlcyhkb3dubG9hZFNpemUpfSAoJHtNYXRoLnJvdW5kKGRvd25sb2FkU2l6ZSAvIChuZXdTaXplIC8gMTAwKSl9JSlgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG93bmxvYWRGaWxlKG9wZXJhdGlvbnMpO1xuICAgIH1cbiAgICBkb3dubG9hZEZpbGUodGFza3MpIHtcbiAgICAgICAgY29uc3QgZmRMaXN0ID0gW107XG4gICAgICAgIGNvbnN0IGNsb3NlRmlsZXMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZmRMaXN0Lm1hcChvcGVuZWRGaWxlID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGZzX2V4dHJhXzEuY2xvc2UpKG9wZW5lZEZpbGUuZGVzY3JpcHRvcikuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYGNhbm5vdCBjbG9zZSBmaWxlIFwiJHtvcGVuZWRGaWxlLnBhdGh9XCI6ICR7ZX1gKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9Eb3dubG9hZEZpbGUodGFza3MsIGZkTGlzdClcbiAgICAgICAgICAgIC50aGVuKGNsb3NlRmlsZXMpXG4gICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIHRoZW4gbXVzdCBiZSBhZnRlciBjYXRjaCBoZXJlIChzaW5jZSB0aGVuIGFsd2F5cyB0aHJvd3MgZXJyb3IpXG4gICAgICAgICAgICByZXR1cm4gY2xvc2VGaWxlcygpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGNsb3NlRmlsZXNFcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgLy8gY2xvc2VGaWxlcyBuZXZlciB0aHJvdyBlcnJvciwgYnV0IGp1c3QgdG8gYmUgc3VyZVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBjYW5ub3QgY2xvc2UgZmlsZXM6ICR7Y2xvc2VGaWxlc0Vycm9yfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3JPbkxvZykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvck9uTG9nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2ssIGdpdmUgdXAgYW5kIGlnbm9yZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBkb0Rvd25sb2FkRmlsZSh0YXNrcywgZmRMaXN0KSB7XG4gICAgICAgIGNvbnN0IG9sZEZpbGVGZCA9IGF3YWl0ICgwLCBmc19leHRyYV8xLm9wZW4pKHRoaXMub3B0aW9ucy5vbGRGaWxlLCBcInJcIik7XG4gICAgICAgIGZkTGlzdC5wdXNoKHsgZGVzY3JpcHRvcjogb2xkRmlsZUZkLCBwYXRoOiB0aGlzLm9wdGlvbnMub2xkRmlsZSB9KTtcbiAgICAgICAgY29uc3QgbmV3RmlsZUZkID0gYXdhaXQgKDAsIGZzX2V4dHJhXzEub3BlbikodGhpcy5vcHRpb25zLm5ld0ZpbGUsIFwid1wiKTtcbiAgICAgICAgZmRMaXN0LnB1c2goeyBkZXNjcmlwdG9yOiBuZXdGaWxlRmQsIHBhdGg6IHRoaXMub3B0aW9ucy5uZXdGaWxlIH0pO1xuICAgICAgICBjb25zdCBmaWxlT3V0ID0gKDAsIGZzXzEuY3JlYXRlV3JpdGVTdHJlYW0pKHRoaXMub3B0aW9ucy5uZXdGaWxlLCB7IGZkOiBuZXdGaWxlRmQgfSk7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbXMgPSBbXTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBvdXIgZG93bmxvYWQgaW5mbyB0cmFuc2Zvcm1lciBpZiB3ZSBoYXZlIG9uZVxuICAgICAgICAgICAgbGV0IGRvd25sb2FkSW5mb1RyYW5zZm9ybSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmlzVXNlTXVsdGlwbGVSYW5nZVJlcXVlc3QgJiYgdGhpcy5vcHRpb25zLm9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBEb2VzIG5vdCBzdXBwb3J0IG11bHRpcGxlIHJhbmdlcyAoc29tZW9uZSBmZWVsIGZyZWUgdG8gUFIgdGhpcyEpXG4gICAgICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRCeXRlQ291bnRzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IGdyYW5kVG90YWxCeXRlcyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0YXNrIG9mIHRhc2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXNrLmtpbmQgPT09IGRvd25sb2FkUGxhbkJ1aWxkZXJfMS5PcGVyYXRpb25LaW5kLkRPV05MT0FEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZEJ5dGVDb3VudHMucHVzaCh0YXNrLmVuZCAtIHRhc2suc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhbmRUb3RhbEJ5dGVzICs9IHRhc2suZW5kIC0gdGFzay5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRCeXRlQ291bnRzOiBleHBlY3RlZEJ5dGVDb3VudHMsXG4gICAgICAgICAgICAgICAgICAgIGdyYW5kVG90YWw6IGdyYW5kVG90YWxCeXRlcyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRvd25sb2FkSW5mb1RyYW5zZm9ybSA9IG5ldyBQcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkQ2FsbGJhY2tUcmFuc2Zvcm1fMS5Qcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkQ2FsbGJhY2tUcmFuc2Zvcm0ocHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZEluZm8sIHRoaXMub3B0aW9ucy5jYW5jZWxsYXRpb25Ub2tlbiwgdGhpcy5vcHRpb25zLm9uUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIHN0cmVhbXMucHVzaChkb3dubG9hZEluZm9UcmFuc2Zvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGlnZXN0VHJhbnNmb3JtID0gbmV3IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuRGlnZXN0VHJhbnNmb3JtKHRoaXMuYmxvY2tBd2FyZUZpbGVJbmZvLnNoYTUxMik7XG4gICAgICAgICAgICAvLyB0byBzaW1wbHkgZGVidWcsIGRvIG1hbnVhbCB2YWxpZGF0aW9uIHRvIGFsbG93IGZpbGUgdG8gYmUgZnVsbHkgd3JpdHRlblxuICAgICAgICAgICAgZGlnZXN0VHJhbnNmb3JtLmlzVmFsaWRhdGVPbkVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgc3RyZWFtcy5wdXNoKGRpZ2VzdFRyYW5zZm9ybSk7XG4gICAgICAgICAgICAvLyBub2luc3BlY3Rpb24gSlNBcnJvd0Z1bmN0aW9uQ2FuQmVSZXBsYWNlZFdpdGhTaG9ydGhhbmRcbiAgICAgICAgICAgIGZpbGVPdXQub24oXCJmaW5pc2hcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBmaWxlT3V0LmNsb3NlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gZmQgbGlzdCBiZWNhdXNlIGNsb3NlZCBzdWNjZXNzZnVsbHlcbiAgICAgICAgICAgICAgICAgICAgZmRMaXN0LnNwbGljZSgxLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZ2VzdFRyYW5zZm9ybS52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdHJlYW1zLnB1c2goZmlsZU91dCk7XG4gICAgICAgICAgICBsZXQgbGFzdFN0cmVhbSA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN0cmVhbSBvZiBzdHJlYW1zKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLm9uKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFN0cmVhbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTdHJlYW0gPSBzdHJlYW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsYXN0U3RyZWFtID0gbGFzdFN0cmVhbS5waXBlKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmlyc3RTdHJlYW0gPSBzdHJlYW1zWzBdO1xuICAgICAgICAgICAgbGV0IHc7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmlzVXNlTXVsdGlwbGVSYW5nZVJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICB3ID0gKDAsIG11bHRpcGxlUmFuZ2VEb3dubG9hZGVyXzEuZXhlY3V0ZVRhc2tzVXNpbmdNdWx0aXBsZVJhbmdlUmVxdWVzdHMpKHRoaXMsIHRhc2tzLCBmaXJzdFN0cmVhbSwgb2xkRmlsZUZkLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIHcoMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRvd25sb2FkT3BlcmF0aW9uQ291bnQgPSAwO1xuICAgICAgICAgICAgbGV0IGFjdHVhbFVybCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGBEaWZmZXJlbnRpYWwgZG93bmxvYWQ6ICR7dGhpcy5vcHRpb25zLm5ld1VybH1gKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gdGhpcy5jcmVhdGVSZXF1ZXN0T3B0aW9ucygpO1xuICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMucmVkaXJlY3QgPSBcIm1hbnVhbFwiO1xuICAgICAgICAgICAgdyA9IChpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IHRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5maWxlTWV0YWRhdGFCdWZmZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RTdHJlYW0ud3JpdGUodGhpcy5maWxlTWV0YWRhdGFCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0U3RyZWFtLmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRhc2tzW2luZGV4KytdO1xuICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24ua2luZCA9PT0gZG93bmxvYWRQbGFuQnVpbGRlcl8xLk9wZXJhdGlvbktpbmQuQ09QWSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgY29weWluZywgbGV0J3Mgbm90IHNlbmQgc3RhdHVzIHVwZGF0ZXMgdG8gdGhlIFVJXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb3dubG9hZEluZm9UcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvd25sb2FkSW5mb1RyYW5zZm9ybS5iZWdpbkZpbGVDb3B5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKDAsIERhdGFTcGxpdHRlcl8xLmNvcHlEYXRhKShvcGVyYXRpb24sIGZpcnN0U3RyZWFtLCBvbGRGaWxlRmQsIHJlamVjdCwgKCkgPT4gdyhpbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gYGJ5dGVzPSR7b3BlcmF0aW9uLnN0YXJ0fS0ke29wZXJhdGlvbi5lbmQgLSAxfWA7XG4gICAgICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMuaGVhZGVycy5yYW5nZSA9IHJhbmdlO1xuICAgICAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMubG9nZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVidWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBgZG93bmxvYWQgcmFuZ2U6ICR7cmFuZ2V9YCk7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXJlIHN0YXJ0aW5nIHRvIGRvd25sb2FkXG4gICAgICAgICAgICAgICAgaWYgKGRvd25sb2FkSW5mb1RyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICBkb3dubG9hZEluZm9UcmFuc2Zvcm0uYmVnaW5SYW5nZURvd25sb2FkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmh0dHBFeGVjdXRvci5jcmVhdGVSZXF1ZXN0KHJlcXVlc3RPcHRpb25zLCByZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm9uKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uub24oXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwicmVzcG9uc2UgaGFzIGJlZW4gYWJvcnRlZCBieSB0aGUgc2VydmVyXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVsZWN0cm9uIG5ldCBoYW5kbGVzIHJlZGlyZWN0cyBhdXRvbWF0aWNhbGx5LCBvdXIgTm9kZUpTIHRlc3Qgc2VydmVyIGRvZXNuJ3QgdXNlIHJlZGlyZWN0cyAtIHNvLCB3ZSBkb24ndCBjaGVjayAzeHggY29kZXMuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCgwLCBidWlsZGVyX3V0aWxfcnVudGltZV8xLmNyZWF0ZUh0dHBFcnJvcikocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5waXBlKGZpcnN0U3RyZWFtLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uub25jZShcImVuZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIG9uIHRoYXQgd2UgYXJlIGRvd25sb2FkaW5nIGEgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvd25sb2FkSW5mb1RyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvd25sb2FkSW5mb1RyYW5zZm9ybS5lbmRSYW5nZURvd25sb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKytkb3dubG9hZE9wZXJhdGlvbkNvdW50ID09PSAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3dubG9hZE9wZXJhdGlvbkNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHcoaW5kZXgpLCAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHcoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uKFwicmVkaXJlY3RcIiwgKHN0YXR1c0NvZGUsIG1ldGhvZCwgcmVkaXJlY3RVcmwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgUmVkaXJlY3QgdG8gJHtyZW1vdmVRdWVyeShyZWRpcmVjdFVybCl9YCk7XG4gICAgICAgICAgICAgICAgICAgIGFjdHVhbFVybCA9IHJlZGlyZWN0VXJsO1xuICAgICAgICAgICAgICAgICAgICAoMCwgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5jb25maWd1cmVSZXF1ZXN0VXJsKShuZXcgdXJsXzEuVVJMKGFjdHVhbFVybCksIHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5mb2xsb3dSZWRpcmVjdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuaHR0cEV4ZWN1dG9yLmFkZEVycm9yQW5kVGltZW91dEhhbmRsZXJzKHJlcXVlc3QsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5lbmQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3KDApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFJlbW90ZUJ5dGVzKHN0YXJ0LCBlbmRJbmNsdXNpdmUpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGVuZEluY2x1c2l2ZSArIDEgLSBzdGFydCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gdGhpcy5jcmVhdGVSZXF1ZXN0T3B0aW9ucygpO1xuICAgICAgICByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLnJhbmdlID0gYGJ5dGVzPSR7c3RhcnR9LSR7ZW5kSW5jbHVzaXZlfWA7XG4gICAgICAgIGxldCBwb3NpdGlvbiA9IDA7XG4gICAgICAgIGF3YWl0IHRoaXMucmVxdWVzdChyZXF1ZXN0T3B0aW9ucywgY2h1bmsgPT4ge1xuICAgICAgICAgICAgY2h1bmsuY29weShidWZmZXIsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHBvc2l0aW9uICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwb3NpdGlvbiAhPT0gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWNlaXZlZCBkYXRhIGxlbmd0aCAke3Bvc2l0aW9ufSBpcyBub3QgZXF1YWwgdG8gZXhwZWN0ZWQgJHtidWZmZXIubGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuICAgIHJlcXVlc3QocmVxdWVzdE9wdGlvbnMsIGRhdGFIYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5odHRwRXhlY3V0b3IuY3JlYXRlUmVxdWVzdChyZXF1ZXN0T3B0aW9ucywgcmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghKDAsIG11bHRpcGxlUmFuZ2VEb3dubG9hZGVyXzEuY2hlY2tJc1Jhbmdlc1N1cHBvcnRlZCkocmVzcG9uc2UsIHJlamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNwb25zZS5vbihcImRhdGFcIiwgZGF0YUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLm9uKFwiZW5kXCIsICgpID0+IHJlc29sdmUoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuaHR0cEV4ZWN1dG9yLmFkZEVycm9yQW5kVGltZW91dEhhbmRsZXJzKHJlcXVlc3QsIHJlamVjdCk7XG4gICAgICAgICAgICByZXF1ZXN0LmVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkRpZmZlcmVudGlhbERvd25sb2FkZXIgPSBEaWZmZXJlbnRpYWxEb3dubG9hZGVyO1xuZnVuY3Rpb24gZm9ybWF0Qnl0ZXModmFsdWUsIHN5bWJvbCA9IFwiIEtCXCIpIHtcbiAgICByZXR1cm4gbmV3IEludGwuTnVtYmVyRm9ybWF0KFwiZW5cIikuZm9ybWF0KCh2YWx1ZSAvIDEwMjQpLnRvRml4ZWQoMikpICsgc3ltYm9sO1xufVxuLy8gc2FmZXR5XG5mdW5jdGlvbiByZW1vdmVRdWVyeSh1cmwpIHtcbiAgICBjb25zdCBpbmRleCA9IHVybC5pbmRleE9mKFwiP1wiKTtcbiAgICByZXR1cm4gaW5kZXggPCAwID8gdXJsIDogdXJsLnN1YnN0cmluZygwLCBpbmRleCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EaWZmZXJlbnRpYWxEb3dubG9hZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyID0gdm9pZCAwO1xuY29uc3QgZnNfZXh0cmFfMSA9IHJlcXVpcmUoXCJmcy1leHRyYVwiKTtcbmNvbnN0IERpZmZlcmVudGlhbERvd25sb2FkZXJfMSA9IHJlcXVpcmUoXCIuL0RpZmZlcmVudGlhbERvd25sb2FkZXJcIik7XG5jb25zdCB6bGliXzEgPSByZXF1aXJlKFwiemxpYlwiKTtcbmNsYXNzIEZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIgZXh0ZW5kcyBEaWZmZXJlbnRpYWxEb3dubG9hZGVyXzEuRGlmZmVyZW50aWFsRG93bmxvYWRlciB7XG4gICAgYXN5bmMgZG93bmxvYWQoKSB7XG4gICAgICAgIGNvbnN0IHBhY2thZ2VJbmZvID0gdGhpcy5ibG9ja0F3YXJlRmlsZUluZm87XG4gICAgICAgIGNvbnN0IGZpbGVTaXplID0gcGFja2FnZUluZm8uc2l6ZTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZmlsZVNpemUgLSAocGFja2FnZUluZm8uYmxvY2tNYXBTaXplICsgNCk7XG4gICAgICAgIHRoaXMuZmlsZU1ldGFkYXRhQnVmZmVyID0gYXdhaXQgdGhpcy5yZWFkUmVtb3RlQnl0ZXMob2Zmc2V0LCBmaWxlU2l6ZSAtIDEpO1xuICAgICAgICBjb25zdCBuZXdCbG9ja01hcCA9IHJlYWRCbG9ja01hcCh0aGlzLmZpbGVNZXRhZGF0YUJ1ZmZlci5zbGljZSgwLCB0aGlzLmZpbGVNZXRhZGF0YUJ1ZmZlci5sZW5ndGggLSA0KSk7XG4gICAgICAgIGF3YWl0IHRoaXMuZG9Eb3dubG9hZChhd2FpdCByZWFkRW1iZWRkZWRCbG9ja01hcERhdGEodGhpcy5vcHRpb25zLm9sZEZpbGUpLCBuZXdCbG9ja01hcCk7XG4gICAgfVxufVxuZXhwb3J0cy5GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyID0gRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlcjtcbmZ1bmN0aW9uIHJlYWRCbG9ja01hcChkYXRhKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoKDAsIHpsaWJfMS5pbmZsYXRlUmF3U3luYykoZGF0YSkudG9TdHJpbmcoKSk7XG59XG5hc3luYyBmdW5jdGlvbiByZWFkRW1iZWRkZWRCbG9ja01hcERhdGEoZmlsZSkge1xuICAgIGNvbnN0IGZkID0gYXdhaXQgKDAsIGZzX2V4dHJhXzEub3BlbikoZmlsZSwgXCJyXCIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZpbGVTaXplID0gKGF3YWl0ICgwLCBmc19leHRyYV8xLmZzdGF0KShmZCkpLnNpemU7XG4gICAgICAgIGNvbnN0IHNpemVCdWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNCk7XG4gICAgICAgIGF3YWl0ICgwLCBmc19leHRyYV8xLnJlYWQpKGZkLCBzaXplQnVmZmVyLCAwLCBzaXplQnVmZmVyLmxlbmd0aCwgZmlsZVNpemUgLSBzaXplQnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGRhdGFCdWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZUJ1ZmZlci5yZWFkVUludDMyQkUoMCkpO1xuICAgICAgICBhd2FpdCAoMCwgZnNfZXh0cmFfMS5yZWFkKShmZCwgZGF0YUJ1ZmZlciwgMCwgZGF0YUJ1ZmZlci5sZW5ndGgsIGZpbGVTaXplIC0gc2l6ZUJ1ZmZlci5sZW5ndGggLSBkYXRhQnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIGF3YWl0ICgwLCBmc19leHRyYV8xLmNsb3NlKShmZCk7XG4gICAgICAgIHJldHVybiByZWFkQmxvY2tNYXAoZGF0YUJ1ZmZlcik7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGF3YWl0ICgwLCBmc19leHRyYV8xLmNsb3NlKShmZCk7XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXBwSW1hZ2VVcGRhdGVyID0gdm9pZCAwO1xuY29uc3QgYnVpbGRlcl91dGlsX3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbmNvbnN0IGNoaWxkX3Byb2Nlc3NfMSA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpO1xuY29uc3QgZnNfZXh0cmFfMSA9IHJlcXVpcmUoXCJmcy1leHRyYVwiKTtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBCYXNlVXBkYXRlcl8xID0gcmVxdWlyZShcIi4vQmFzZVVwZGF0ZXJcIik7XG5jb25zdCBGaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyXzEgPSByZXF1aXJlKFwiLi9kaWZmZXJlbnRpYWxEb3dubG9hZGVyL0ZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXJcIik7XG5jb25zdCBtYWluXzEgPSByZXF1aXJlKFwiLi9tYWluXCIpO1xuY29uc3QgUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVycy9Qcm92aWRlclwiKTtcbmNsYXNzIEFwcEltYWdlVXBkYXRlciBleHRlbmRzIEJhc2VVcGRhdGVyXzEuQmFzZVVwZGF0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGFwcCkge1xuICAgICAgICBzdXBlcihvcHRpb25zLCBhcHApO1xuICAgIH1cbiAgICBpc1VwZGF0ZXJBY3RpdmUoKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudltcIkFQUElNQUdFXCJdID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudltcIlNOQVBcIl0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKFwiQVBQSU1BR0UgZW52IGlzIG5vdCBkZWZpbmVkLCBjdXJyZW50IGFwcGxpY2F0aW9uIGlzIG5vdCBhbiBBcHBJbWFnZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiU05BUCBlbnYgaXMgZGVmaW5lZCwgdXBkYXRlciBpcyBkaXNhYmxlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuaXNVcGRhdGVyQWN0aXZlKCk7XG4gICAgfVxuICAgIC8qKiogQHByaXZhdGUgKi9cbiAgICBkb0Rvd25sb2FkVXBkYXRlKGRvd25sb2FkVXBkYXRlT3B0aW9ucykge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGRvd25sb2FkVXBkYXRlT3B0aW9ucy51cGRhdGVJbmZvQW5kUHJvdmlkZXIucHJvdmlkZXI7XG4gICAgICAgIGNvbnN0IGZpbGVJbmZvID0gKDAsIFByb3ZpZGVyXzEuZmluZEZpbGUpKHByb3ZpZGVyLnJlc29sdmVGaWxlcyhkb3dubG9hZFVwZGF0ZU9wdGlvbnMudXBkYXRlSW5mb0FuZFByb3ZpZGVyLmluZm8pLCBcIkFwcEltYWdlXCIsIFtcInJwbVwiLCBcImRlYlwiXSk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVEb3dubG9hZCh7XG4gICAgICAgICAgICBmaWxlRXh0ZW5zaW9uOiBcIkFwcEltYWdlXCIsXG4gICAgICAgICAgICBmaWxlSW5mbyxcbiAgICAgICAgICAgIGRvd25sb2FkVXBkYXRlT3B0aW9ucyxcbiAgICAgICAgICAgIHRhc2s6IGFzeW5jICh1cGRhdGVGaWxlLCBkb3dubG9hZE9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRGaWxlID0gcHJvY2Vzcy5lbnZbXCJBUFBJTUFHRVwiXTtcbiAgICAgICAgICAgICAgICBpZiAob2xkRmlsZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICgwLCBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKShcIkFQUElNQUdFIGVudiBpcyBub3QgZGVmaW5lZFwiLCBcIkVSUl9VUERBVEVSX09MRF9GSUxFX05PVF9GT1VORFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGlzRG93bmxvYWRGdWxsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG93bmxvYWRPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VXJsOiBmaWxlSW5mby51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRGaWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyOiB0aGlzLl9sb2dnZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdGaWxlOiB1cGRhdGVGaWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNVc2VNdWx0aXBsZVJhbmdlUmVxdWVzdDogcHJvdmlkZXIuaXNVc2VNdWx0aXBsZVJhbmdlUmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzOiBkb3dubG9hZFVwZGF0ZU9wdGlvbnMucmVxdWVzdEhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25Ub2tlbjogZG93bmxvYWRVcGRhdGVPcHRpb25zLmNhbmNlbGxhdGlvblRva2VuLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5saXN0ZW5lckNvdW50KG1haW5fMS5ET1dOTE9BRF9QUk9HUkVTUykgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3dubG9hZE9wdGlvbnMub25Qcm9ncmVzcyA9IGl0ID0+IHRoaXMuZW1pdChtYWluXzEuRE9XTkxPQURfUFJPR1JFU1MsIGl0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlcl8xLkZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIoZmlsZUluZm8uaW5mbywgdGhpcy5odHRwRXhlY3V0b3IsIGRvd25sb2FkT3B0aW9ucykuZG93bmxvYWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGBDYW5ub3QgZG93bmxvYWQgZGlmZmVyZW50aWFsbHksIGZhbGxiYWNrIHRvIGZ1bGwgZG93bmxvYWQ6ICR7ZS5zdGFjayB8fCBlfWApO1xuICAgICAgICAgICAgICAgICAgICAvLyBkdXJpbmcgdGVzdCAoZGV2ZWxvcGVyIG1hY2hpbmUgbWFjKSB3ZSBtdXN0IHRocm93IGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGlzRG93bmxvYWRGdWxsID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJsaW51eFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNEb3dubG9hZEZ1bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5odHRwRXhlY3V0b3IuZG93bmxvYWQoZmlsZUluZm8udXJsLCB1cGRhdGVGaWxlLCBkb3dubG9hZE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCAoMCwgZnNfZXh0cmFfMS5jaG1vZCkodXBkYXRlRmlsZSwgMG83NTUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRvSW5zdGFsbChvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFwcEltYWdlRmlsZSA9IHByb2Nlc3MuZW52W1wiQVBQSU1BR0VcIl07XG4gICAgICAgIGlmIChhcHBJbWFnZUZpbGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IpKFwiQVBQSU1BR0UgZW52IGlzIG5vdCBkZWZpbmVkXCIsIFwiRVJSX1VQREFURVJfT0xEX0ZJTEVfTk9UX0ZPVU5EXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNzEyMDUxLzE5MTAxOTFcbiAgICAgICAgKDAsIGZzXzEudW5saW5rU3luYykoYXBwSW1hZ2VGaWxlKTtcbiAgICAgICAgbGV0IGRlc3RpbmF0aW9uO1xuICAgICAgICBjb25zdCBleGlzdGluZ0Jhc2VOYW1lID0gcGF0aC5iYXNlbmFtZShhcHBJbWFnZUZpbGUpO1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZWxlY3Ryb24tdXNlcmxhbmQvZWxlY3Ryb24tYnVpbGRlci9pc3N1ZXMvMjk2NFxuICAgICAgICAvLyBpZiBubyB2ZXJzaW9uIGluIGV4aXN0aW5nIGZpbGUgbmFtZSwgaXQgbWVhbnMgdGhhdCB1c2VyIHdhbnRzIHRvIHByZXNlcnZlIGN1cnJlbnQgY3VzdG9tIG5hbWVcbiAgICAgICAgaWYgKHBhdGguYmFzZW5hbWUob3B0aW9ucy5pbnN0YWxsZXJQYXRoKSA9PT0gZXhpc3RpbmdCYXNlTmFtZSB8fCAhL1xcZCtcXC5cXGQrXFwuXFxkKy8udGVzdChleGlzdGluZ0Jhc2VOYW1lKSkge1xuICAgICAgICAgICAgLy8gbm8gdmVyc2lvbiBpbiB0aGUgZmlsZSBuYW1lLCBvdmVyd3JpdGUgZXhpc3RpbmdcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uID0gYXBwSW1hZ2VGaWxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVzdGluYXRpb24gPSBwYXRoLmpvaW4ocGF0aC5kaXJuYW1lKGFwcEltYWdlRmlsZSksIHBhdGguYmFzZW5hbWUob3B0aW9ucy5pbnN0YWxsZXJQYXRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGNoaWxkX3Byb2Nlc3NfMS5leGVjRmlsZVN5bmMpKFwibXZcIiwgW1wiLWZcIiwgb3B0aW9ucy5pbnN0YWxsZXJQYXRoLCBkZXN0aW5hdGlvbl0pO1xuICAgICAgICBpZiAoZGVzdGluYXRpb24gIT09IGFwcEltYWdlRmlsZSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiYXBwaW1hZ2UtZmlsZW5hbWUtdXBkYXRlZFwiLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW52ID0ge1xuICAgICAgICAgICAgLi4ucHJvY2Vzcy5lbnYsXG4gICAgICAgICAgICBBUFBJTUFHRV9TSUxFTlRfSU5TVEFMTDogXCJ0cnVlXCIsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLmlzRm9yY2VSdW5BZnRlcikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICAgICAgdGhpcy5zcGF3bkxvZyhkZXN0aW5hdGlvbiwgW10sIGVudik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbnYuQVBQSU1BR0VfRVhJVF9BRlRFUl9JTlNUQUxMID0gXCJ0cnVlXCI7XG4gICAgICAgICAgICAoMCwgY2hpbGRfcHJvY2Vzc18xLmV4ZWNGaWxlU3luYykoZGVzdGluYXRpb24sIFtdLCB7IGVudiB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnRzLkFwcEltYWdlVXBkYXRlciA9IEFwcEltYWdlVXBkYXRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFwcEltYWdlVXBkYXRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGViVXBkYXRlciA9IHZvaWQgMDtcbmNvbnN0IEJhc2VVcGRhdGVyXzEgPSByZXF1aXJlKFwiLi9CYXNlVXBkYXRlclwiKTtcbmNvbnN0IG1haW5fMSA9IHJlcXVpcmUoXCIuL21haW5cIik7XG5jb25zdCBQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vcHJvdmlkZXJzL1Byb3ZpZGVyXCIpO1xuY2xhc3MgRGViVXBkYXRlciBleHRlbmRzIEJhc2VVcGRhdGVyXzEuQmFzZVVwZGF0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGFwcCkge1xuICAgICAgICBzdXBlcihvcHRpb25zLCBhcHApO1xuICAgIH1cbiAgICAvKioqIEBwcml2YXRlICovXG4gICAgZG9Eb3dubG9hZFVwZGF0ZShkb3dubG9hZFVwZGF0ZU9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBkb3dubG9hZFVwZGF0ZU9wdGlvbnMudXBkYXRlSW5mb0FuZFByb3ZpZGVyLnByb3ZpZGVyO1xuICAgICAgICBjb25zdCBmaWxlSW5mbyA9ICgwLCBQcm92aWRlcl8xLmZpbmRGaWxlKShwcm92aWRlci5yZXNvbHZlRmlsZXMoZG93bmxvYWRVcGRhdGVPcHRpb25zLnVwZGF0ZUluZm9BbmRQcm92aWRlci5pbmZvKSwgXCJkZWJcIiwgW1wiQXBwSW1hZ2VcIiwgXCJycG1cIl0pO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlRG93bmxvYWQoe1xuICAgICAgICAgICAgZmlsZUV4dGVuc2lvbjogXCJkZWJcIixcbiAgICAgICAgICAgIGZpbGVJbmZvLFxuICAgICAgICAgICAgZG93bmxvYWRVcGRhdGVPcHRpb25zLFxuICAgICAgICAgICAgdGFzazogYXN5bmMgKHVwZGF0ZUZpbGUsIGRvd25sb2FkT3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpc3RlbmVyQ291bnQobWFpbl8xLkRPV05MT0FEX1BST0dSRVNTKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZG93bmxvYWRPcHRpb25zLm9uUHJvZ3Jlc3MgPSBpdCA9PiB0aGlzLmVtaXQobWFpbl8xLkRPV05MT0FEX1BST0dSRVNTLCBpdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuaHR0cEV4ZWN1dG9yLmRvd25sb2FkKGZpbGVJbmZvLnVybCwgdXBkYXRlRmlsZSwgZG93bmxvYWRPcHRpb25zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkb0luc3RhbGwob3B0aW9ucykge1xuICAgICAgICBjb25zdCBzdWRvID0gdGhpcy53cmFwU3VkbygpO1xuICAgICAgICAvLyBwa2V4ZWMgZG9lc24ndCB3YW50IHRoZSBjb21tYW5kIHRvIGJlIHdyYXBwZWQgaW4gXCIgcXVvdGVzXG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSAvcGtleGVjL2kudGVzdChzdWRvKSA/IFwiXCIgOiBgXCJgO1xuICAgICAgICBjb25zdCBjbWQgPSBbXCJkcGtnXCIsIFwiLWlcIiwgb3B0aW9ucy5pbnN0YWxsZXJQYXRoLCBcInx8XCIsIFwiYXB0LWdldFwiLCBcImluc3RhbGxcIiwgXCItZlwiLCBcIi15XCJdO1xuICAgICAgICB0aGlzLnNwYXduU3luY0xvZyhzdWRvLCBbYCR7d3JhcHBlcn0vYmluL2Jhc2hgLCBcIi1jXCIsIGAnJHtjbWQuam9pbihcIiBcIil9JyR7d3JhcHBlcn1gXSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuRGViVXBkYXRlciA9IERlYlVwZGF0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZWJVcGRhdGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ScG1VcGRhdGVyID0gdm9pZCAwO1xuY29uc3QgQmFzZVVwZGF0ZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VVcGRhdGVyXCIpO1xuY29uc3QgbWFpbl8xID0gcmVxdWlyZShcIi4vbWFpblwiKTtcbmNvbnN0IFByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlcnMvUHJvdmlkZXJcIik7XG5jbGFzcyBScG1VcGRhdGVyIGV4dGVuZHMgQmFzZVVwZGF0ZXJfMS5CYXNlVXBkYXRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgYXBwKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMsIGFwcCk7XG4gICAgfVxuICAgIC8qKiogQHByaXZhdGUgKi9cbiAgICBkb0Rvd25sb2FkVXBkYXRlKGRvd25sb2FkVXBkYXRlT3B0aW9ucykge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGRvd25sb2FkVXBkYXRlT3B0aW9ucy51cGRhdGVJbmZvQW5kUHJvdmlkZXIucHJvdmlkZXI7XG4gICAgICAgIGNvbnN0IGZpbGVJbmZvID0gKDAsIFByb3ZpZGVyXzEuZmluZEZpbGUpKHByb3ZpZGVyLnJlc29sdmVGaWxlcyhkb3dubG9hZFVwZGF0ZU9wdGlvbnMudXBkYXRlSW5mb0FuZFByb3ZpZGVyLmluZm8pLCBcInJwbVwiLCBbXCJBcHBJbWFnZVwiLCBcImRlYlwiXSk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVEb3dubG9hZCh7XG4gICAgICAgICAgICBmaWxlRXh0ZW5zaW9uOiBcInJwbVwiLFxuICAgICAgICAgICAgZmlsZUluZm8sXG4gICAgICAgICAgICBkb3dubG9hZFVwZGF0ZU9wdGlvbnMsXG4gICAgICAgICAgICB0YXNrOiBhc3luYyAodXBkYXRlRmlsZSwgZG93bmxvYWRPcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJDb3VudChtYWluXzEuRE9XTkxPQURfUFJPR1JFU1MpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBkb3dubG9hZE9wdGlvbnMub25Qcm9ncmVzcyA9IGl0ID0+IHRoaXMuZW1pdChtYWluXzEuRE9XTkxPQURfUFJPR1JFU1MsIGl0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5odHRwRXhlY3V0b3IuZG93bmxvYWQoZmlsZUluZm8udXJsLCB1cGRhdGVGaWxlLCBkb3dubG9hZE9wdGlvbnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRvSW5zdGFsbChvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHVwZ3JhZGVQYXRoID0gb3B0aW9ucy5pbnN0YWxsZXJQYXRoO1xuICAgICAgICBjb25zdCBzdWRvID0gdGhpcy53cmFwU3VkbygpO1xuICAgICAgICAvLyBwa2V4ZWMgZG9lc24ndCB3YW50IHRoZSBjb21tYW5kIHRvIGJlIHdyYXBwZWQgaW4gXCIgcXVvdGVzXG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSAvcGtleGVjL2kudGVzdChzdWRvKSA/IFwiXCIgOiBgXCJgO1xuICAgICAgICBjb25zdCBwYWNrYWdlTWFuYWdlciA9IHRoaXMuc3Bhd25TeW5jTG9nKFwid2hpY2ggenlwcGVyXCIpO1xuICAgICAgICBsZXQgY21kO1xuICAgICAgICBpZiAoIXBhY2thZ2VNYW5hZ2VyKSB7XG4gICAgICAgICAgICBjb25zdCBwYWNrYWdlTWFuYWdlciA9IHRoaXMuc3Bhd25TeW5jTG9nKFwid2hpY2ggZG5mIHx8IHdoaWNoIHl1bVwiKTtcbiAgICAgICAgICAgIGNtZCA9IFtwYWNrYWdlTWFuYWdlciwgXCIteVwiLCBcInJlbW92ZVwiLCBgJyR7dGhpcy5hcHAubmFtZX0nYCwgXCI7XCIsIHBhY2thZ2VNYW5hZ2VyLCBcIi15XCIsIFwiaW5zdGFsbFwiLCB1cGdyYWRlUGF0aF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbWQgPSBbXG4gICAgICAgICAgICAgICAgcGFja2FnZU1hbmFnZXIsXG4gICAgICAgICAgICAgICAgXCJyZW1vdmVcIixcbiAgICAgICAgICAgICAgICBcIi15XCIsXG4gICAgICAgICAgICAgICAgYCcke3RoaXMuYXBwLm5hbWV9J2AsXG4gICAgICAgICAgICAgICAgXCI7XCIsXG4gICAgICAgICAgICAgICAgcGFja2FnZU1hbmFnZXIsXG4gICAgICAgICAgICAgICAgXCJjbGVhblwiLFxuICAgICAgICAgICAgICAgIFwiLS1hbGxcIixcbiAgICAgICAgICAgICAgICBcIjtcIixcbiAgICAgICAgICAgICAgICBwYWNrYWdlTWFuYWdlcixcbiAgICAgICAgICAgICAgICBcIi0tbm8tcmVmcmVzaFwiLFxuICAgICAgICAgICAgICAgIFwiaW5zdGFsbFwiLFxuICAgICAgICAgICAgICAgIFwiLS1hbGxvdy11bnNpZ25lZC1ycG1cIixcbiAgICAgICAgICAgICAgICBcIi15XCIsXG4gICAgICAgICAgICAgICAgXCItZlwiLFxuICAgICAgICAgICAgICAgIHVwZ3JhZGVQYXRoLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNwYXduU3luY0xvZyhzdWRvLCBbYCR7d3JhcHBlcn0vYmluL2Jhc2hgLCBcIi1jXCIsIGAnJHtjbWQuam9pbihcIiBcIil9JyR7d3JhcHBlcn1gXSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuUnBtVXBkYXRlciA9IFJwbVVwZGF0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ScG1VcGRhdGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWNVcGRhdGVyID0gdm9pZCAwO1xuY29uc3QgYnVpbGRlcl91dGlsX3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbmNvbnN0IGZzX2V4dHJhXzEgPSByZXF1aXJlKFwiZnMtZXh0cmFcIik7XG5jb25zdCBmc18xID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgaHR0cF8xID0gcmVxdWlyZShcImh0dHBcIik7XG5jb25zdCBBcHBVcGRhdGVyXzEgPSByZXF1aXJlKFwiLi9BcHBVcGRhdGVyXCIpO1xuY29uc3QgUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVycy9Qcm92aWRlclwiKTtcbmNvbnN0IGNoaWxkX3Byb2Nlc3NfMSA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpO1xuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xuY2xhc3MgTWFjVXBkYXRlciBleHRlbmRzIEFwcFVwZGF0ZXJfMS5BcHBVcGRhdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhcHApIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucywgYXBwKTtcbiAgICAgICAgdGhpcy5uYXRpdmVVcGRhdGVyID0gcmVxdWlyZShcImVsZWN0cm9uXCIpLmF1dG9VcGRhdGVyO1xuICAgICAgICB0aGlzLnNxdWlycmVsRG93bmxvYWRlZFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5hdGl2ZVVwZGF0ZXIub24oXCJlcnJvclwiLCBpdCA9PiB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihpdCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBpdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hdGl2ZVVwZGF0ZXIub24oXCJ1cGRhdGUtZG93bmxvYWRlZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNxdWlycmVsRG93bmxvYWRlZFVwZGF0ZSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWJ1ZyhtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLl9sb2dnZXIuZGVidWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRvRG93bmxvYWRVcGRhdGUoZG93bmxvYWRVcGRhdGVPcHRpb25zKSB7XG4gICAgICAgIGxldCBmaWxlcyA9IGRvd25sb2FkVXBkYXRlT3B0aW9ucy51cGRhdGVJbmZvQW5kUHJvdmlkZXIucHJvdmlkZXIucmVzb2x2ZUZpbGVzKGRvd25sb2FkVXBkYXRlT3B0aW9ucy51cGRhdGVJbmZvQW5kUHJvdmlkZXIuaW5mbyk7XG4gICAgICAgIGNvbnN0IGxvZyA9IHRoaXMuX2xvZ2dlcjtcbiAgICAgICAgLy8gZGV0ZWN0IGlmIHdlIGFyZSBydW5uaW5nIGluc2lkZSBSb3NldHRhIGVtdWxhdGlvblxuICAgICAgICBjb25zdCBzeXNjdGxSb3NldHRhSW5mb0tleSA9IFwic3lzY3RsLnByb2NfdHJhbnNsYXRlZFwiO1xuICAgICAgICBsZXQgaXNSb3NldHRhID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKFwiQ2hlY2tpbmcgZm9yIG1hY09TIFJvc2V0dGEgZW52aXJvbm1lbnRcIik7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoMCwgY2hpbGRfcHJvY2Vzc18xLmV4ZWNGaWxlU3luYykoXCJzeXNjdGxcIiwgW3N5c2N0bFJvc2V0dGFJbmZvS2V5XSwgeyBlbmNvZGluZzogXCJ1dGY4XCIgfSk7XG4gICAgICAgICAgICBpc1Jvc2V0dGEgPSByZXN1bHQuaW5jbHVkZXMoYCR7c3lzY3RsUm9zZXR0YUluZm9LZXl9OiAxYCk7XG4gICAgICAgICAgICBsb2cuaW5mbyhgQ2hlY2tlZCBmb3IgbWFjT1MgUm9zZXR0YSBlbnZpcm9ubWVudCAoaXNSb3NldHRhPSR7aXNSb3NldHRhfSlgKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nLndhcm4oYHN5c2N0bCBzaGVsbCBjb21tYW5kIHRvIGNoZWNrIGZvciBtYWNPUyBSb3NldHRhIGVudmlyb25tZW50IGZhaWxlZDogJHtlfWApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpc0FybTY0TWFjID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKFwiQ2hlY2tpbmcgZm9yIGFybTY0IGluIHVuYW1lXCIpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gKDAsIGNoaWxkX3Byb2Nlc3NfMS5leGVjRmlsZVN5bmMpKFwidW5hbWVcIiwgW1wiLWFcIl0sIHsgZW5jb2Rpbmc6IFwidXRmOFwiIH0pO1xuICAgICAgICAgICAgY29uc3QgaXNBcm0gPSByZXN1bHQuaW5jbHVkZXMoXCJBUk1cIik7XG4gICAgICAgICAgICBsb2cuaW5mbyhgQ2hlY2tlZCAndW5hbWUgLWEnOiBhcm02ND0ke2lzQXJtfWApO1xuICAgICAgICAgICAgaXNBcm02NE1hYyA9IGlzQXJtNjRNYWMgfHwgaXNBcm07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZy53YXJuKGB1bmFtZSBzaGVsbCBjb21tYW5kIHRvIGNoZWNrIGZvciBhcm02NCBmYWlsZWQ6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpc0FybTY0TWFjID0gaXNBcm02NE1hYyB8fCBwcm9jZXNzLmFyY2ggPT09IFwiYXJtNjRcIiB8fCBpc1Jvc2V0dGE7XG4gICAgICAgIC8vIGFsbG93IGFybTY0IG1hY3MgdG8gaW5zdGFsbCB1bml2ZXJzYWwgb3Igcm9zZXR0YTIoeDY0KSAtIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi11c2VybGFuZC9lbGVjdHJvbi1idWlsZGVyL3B1bGwvNTUyNFxuICAgICAgICBjb25zdCBpc0FybTY0ID0gKGZpbGUpID0+IHsgdmFyIF9hOyByZXR1cm4gZmlsZS51cmwucGF0aG5hbWUuaW5jbHVkZXMoXCJhcm02NFwiKSB8fCAoKF9hID0gZmlsZS5pbmZvLnVybCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKFwiYXJtNjRcIikpOyB9O1xuICAgICAgICBpZiAoaXNBcm02NE1hYyAmJiBmaWxlcy5zb21lKGlzQXJtNjQpKSB7XG4gICAgICAgICAgICBmaWxlcyA9IGZpbGVzLmZpbHRlcihmaWxlID0+IGlzQXJtNjRNYWMgPT09IGlzQXJtNjQoZmlsZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmlsZXMgPSBmaWxlcy5maWx0ZXIoZmlsZSA9PiAhaXNBcm02NChmaWxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgemlwRmlsZUluZm8gPSAoMCwgUHJvdmlkZXJfMS5maW5kRmlsZSkoZmlsZXMsIFwiemlwXCIsIFtcInBrZ1wiLCBcImRtZ1wiXSk7XG4gICAgICAgIGlmICh6aXBGaWxlSW5mbyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcikoYFpJUCBmaWxlIG5vdCBwcm92aWRlZDogJHsoMCwgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5zYWZlU3RyaW5naWZ5SnNvbikoZmlsZXMpfWAsIFwiRVJSX1VQREFURVJfWklQX0ZJTEVfTk9UX0ZPVU5EXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVEb3dubG9hZCh7XG4gICAgICAgICAgICBmaWxlRXh0ZW5zaW9uOiBcInppcFwiLFxuICAgICAgICAgICAgZmlsZUluZm86IHppcEZpbGVJbmZvLFxuICAgICAgICAgICAgZG93bmxvYWRVcGRhdGVPcHRpb25zLFxuICAgICAgICAgICAgdGFzazogKGRlc3RpbmF0aW9uRmlsZSwgZG93bmxvYWRPcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHR0cEV4ZWN1dG9yLmRvd25sb2FkKHppcEZpbGVJbmZvLnVybCwgZGVzdGluYXRpb25GaWxlLCBkb3dubG9hZE9wdGlvbnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvbmU6IGV2ZW50ID0+IHRoaXMudXBkYXRlRG93bmxvYWRlZCh6aXBGaWxlSW5mbywgZXZlbnQpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlRG93bmxvYWRlZCh6aXBGaWxlSW5mbywgZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgZG93bmxvYWRlZEZpbGUgPSBldmVudC5kb3dubG9hZGVkRmlsZTtcbiAgICAgICAgY29uc3QgdXBkYXRlRmlsZVNpemUgPSAoX2EgPSB6aXBGaWxlSW5mby5pbmZvLnNpemUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChhd2FpdCAoMCwgZnNfZXh0cmFfMS5zdGF0KShkb3dubG9hZGVkRmlsZSkpLnNpemU7XG4gICAgICAgIGNvbnN0IGxvZyA9IHRoaXMuX2xvZ2dlcjtcbiAgICAgICAgY29uc3QgbG9nQ29udGV4dCA9IGBmaWxlVG9Qcm94eT0ke3ppcEZpbGVJbmZvLnVybC5ocmVmfWA7XG4gICAgICAgIHRoaXMuZGVidWcoYENyZWF0aW5nIHByb3h5IHNlcnZlciBmb3IgbmF0aXZlIFNxdWlycmVsLk1hYyAoJHtsb2dDb250ZXh0fSlgKTtcbiAgICAgICAgKF9iID0gdGhpcy5zZXJ2ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jbG9zZSgpO1xuICAgICAgICB0aGlzLnNlcnZlciA9ICgwLCBodHRwXzEuY3JlYXRlU2VydmVyKSgpO1xuICAgICAgICB0aGlzLmRlYnVnKGBQcm94eSBzZXJ2ZXIgZm9yIG5hdGl2ZSBTcXVpcnJlbC5NYWMgaXMgY3JlYXRlZCAoJHtsb2dDb250ZXh0fSlgKTtcbiAgICAgICAgdGhpcy5zZXJ2ZXIub24oXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICBsb2cuaW5mbyhgUHJveHkgc2VydmVyIGZvciBuYXRpdmUgU3F1aXJyZWwuTWFjIGlzIGNsb3NlZCAoJHtsb2dDb250ZXh0fSlgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIG11c3QgYmUgY2FsbGVkIGFmdGVyIHNlcnZlciBpcyBsaXN0ZW5pbmcsIG90aGVyd2lzZSBhZGRyZXNzIGlzIG51bGxcbiAgICAgICAgY29uc3QgZ2V0U2VydmVyVXJsID0gKHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBzLmFkZHJlc3MoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYWRkcmVzcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGBodHRwOi8vMTI3LjAuMC4xOiR7YWRkcmVzcyA9PT0gbnVsbCB8fCBhZGRyZXNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhZGRyZXNzLnBvcnR9YDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhc3MgPSAoMCwgY3J5cHRvXzEucmFuZG9tQnl0ZXMpKDY0KS50b1N0cmluZyhcImJhc2U2NFwiKS5yZXBsYWNlKC9cXC8vZywgXCJfXCIpLnJlcGxhY2UoL1xcKy9nLCBcIi1cIik7XG4gICAgICAgICAgICBjb25zdCBhdXRoSW5mbyA9IEJ1ZmZlci5mcm9tKGBhdXRvdXBkYXRlcjoke3Bhc3N9YCwgXCJhc2NpaVwiKTtcbiAgICAgICAgICAgIC8vIGluc2VjdXJlIHJhbmRvbSBpcyBva1xuICAgICAgICAgICAgY29uc3QgZmlsZVVybCA9IGAvJHsoMCwgY3J5cHRvXzEucmFuZG9tQnl0ZXMpKDY0KS50b1N0cmluZyhcImhleFwiKX0uemlwYDtcbiAgICAgICAgICAgIHRoaXMuc2VydmVyLm9uKFwicmVxdWVzdFwiLCAocmVxdWVzdCwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0VXJsID0gcmVxdWVzdC51cmw7XG4gICAgICAgICAgICAgICAgbG9nLmluZm8oYCR7cmVxdWVzdFVybH0gcmVxdWVzdGVkYCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RVcmwgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBiYXNpYyBhdXRoIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcXVlc3QuaGVhZGVycy5hdXRob3JpemF0aW9uIHx8IHJlcXVlc3QuaGVhZGVycy5hdXRob3JpemF0aW9uLmluZGV4T2YoXCJCYXNpYyBcIikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zdGF0dXNDb2RlID0gNDAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzTWVzc2FnZSA9IFwiSW52YWxpZCBBdXRoZW50aWNhdGlvbiBDcmVkZW50aWFsc1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cud2FybihcIk5vIGF1dGhlbnRoaWNhdGlvbiBpbmZvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHZlcmlmeSBhdXRoIGNyZWRlbnRpYWxzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhc2U2NENyZWRlbnRpYWxzID0gcmVxdWVzdC5oZWFkZXJzLmF1dGhvcml6YXRpb24uc3BsaXQoXCIgXCIpWzFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjcmVkZW50aWFscyA9IEJ1ZmZlci5mcm9tKGJhc2U2NENyZWRlbnRpYWxzLCBcImJhc2U2NFwiKS50b1N0cmluZyhcImFzY2lpXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbdXNlcm5hbWUsIHBhc3N3b3JkXSA9IGNyZWRlbnRpYWxzLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJuYW1lICE9PSBcImF1dG91cGRhdGVyXCIgfHwgcGFzc3dvcmQgIT09IHBhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1c0NvZGUgPSA0MDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zdGF0dXNNZXNzYWdlID0gXCJJbnZhbGlkIEF1dGhlbnRpY2F0aW9uIENyZWRlbnRpYWxzXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKFwiSW52YWxpZCBhdXRoZW50aGljYXRpb24gY3JlZGVudGlhbHNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEJ1ZmZlci5mcm9tKGB7IFwidXJsXCI6IFwiJHtnZXRTZXJ2ZXJVcmwodGhpcy5zZXJ2ZXIpfSR7ZmlsZVVybH1cIiB9YCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLndyaXRlSGVhZCgyMDAsIHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsIFwiQ29udGVudC1MZW5ndGhcIjogZGF0YS5sZW5ndGggfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmVuZChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXJlcXVlc3RVcmwuc3RhcnRzV2l0aChmaWxlVXJsKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2cud2FybihgJHtyZXF1ZXN0VXJsfSByZXF1ZXN0ZWQsIGJ1dCBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLndyaXRlSGVhZCg0MDQpO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2cuaW5mbyhgJHtmaWxlVXJsfSByZXF1ZXN0ZWQgYnkgU3F1aXJyZWwuTWFjLCBwaXBlICR7ZG93bmxvYWRlZEZpbGV9YCk7XG4gICAgICAgICAgICAgICAgbGV0IGVycm9yT2NjdXJyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5vbihcImZpbmlzaFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXJyb3JPY2N1cnJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVVcGRhdGVyLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoW10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVhZFN0cmVhbSA9ICgwLCBmc18xLmNyZWF0ZVJlYWRTdHJlYW0pKGRvd25sb2FkZWRGaWxlKTtcbiAgICAgICAgICAgICAgICByZWFkU3RyZWFtLm9uKFwiZXJyb3JcIiwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKGBjYW5ub3QgZW5kIHJlc3BvbnNlOiAke2V9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JPY2N1cnJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlVXBkYXRlci5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYENhbm5vdCBwaXBlIFwiJHtkb3dubG9hZGVkRmlsZX1cIjogJHtlcnJvcn1gKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uud3JpdGVIZWFkKDIwMCwge1xuICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL3ppcFwiLFxuICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtTGVuZ3RoXCI6IHVwZGF0ZUZpbGVTaXplLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlYWRTdHJlYW0ucGlwZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoYFByb3h5IHNlcnZlciBmb3IgbmF0aXZlIFNxdWlycmVsLk1hYyBpcyBzdGFydGluZyB0byBsaXN0ZW4gKCR7bG9nQ29udGV4dH0pYCk7XG4gICAgICAgICAgICB0aGlzLnNlcnZlci5saXN0ZW4oMCwgXCIxMjcuMC4wLjFcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoYFByb3h5IHNlcnZlciBmb3IgbmF0aXZlIFNxdWlycmVsLk1hYyBpcyBsaXN0ZW5pbmcgKGFkZHJlc3M9JHtnZXRTZXJ2ZXJVcmwodGhpcy5zZXJ2ZXIpfSwgJHtsb2dDb250ZXh0fSlgKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5hdGl2ZVVwZGF0ZXIuc2V0RmVlZFVSTCh7XG4gICAgICAgICAgICAgICAgICAgIHVybDogZ2V0U2VydmVyVXJsKHRoaXMuc2VydmVyKSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJDYWNoZS1Db250cm9sXCI6IFwibm8tY2FjaGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCYXNpYyAke2F1dGhJbmZvLnRvU3RyaW5nKFwiYmFzZTY0XCIpfWAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHVwZGF0ZSBoYXMgYmVlbiBkb3dubG9hZGVkIGFuZCBpcyByZWFkeSB0byBiZSBzZXJ2ZWQgdG8gU3F1aXJyZWxcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVXBkYXRlRG93bmxvYWRlZChldmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXV0b0luc3RhbGxPbkFwcFF1aXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVVcGRhdGVyLm9uY2UoXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgdHJpZ2dlciBmZXRjaGluZyBhbmQgaW5zdGFsbGluZyB0aGUgZmlsZSBvbiBTcXVpcnJlbCBzaWRlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlVXBkYXRlci5jaGVja0ZvclVwZGF0ZXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcXVpdEFuZEluc3RhbGwoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuc3F1aXJyZWxEb3dubG9hZGVkVXBkYXRlKSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgYWxyZWFkeSBmZXRjaGVkIGJ5IFNxdWlycmVsLCBpdCdzIHJlYWR5IHRvIGluc3RhbGxcbiAgICAgICAgICAgIHRoaXMubmF0aXZlVXBkYXRlci5xdWl0QW5kSW5zdGFsbCgpO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5zZXJ2ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUXVpdCBhbmQgaW5zdGFsbCBhcyBzb29uIGFzIFNxdWlycmVsIGdldCB0aGUgdXBkYXRlXG4gICAgICAgICAgICB0aGlzLm5hdGl2ZVVwZGF0ZXIub24oXCJ1cGRhdGUtZG93bmxvYWRlZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlVXBkYXRlci5xdWl0QW5kSW5zdGFsbCgpO1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuc2VydmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmF1dG9JbnN0YWxsT25BcHBRdWl0KSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgdGhpcyB3YXMgbm90IGB0cnVlYCBwcmV2aW91c2x5IHRoZW4gTWFjVXBkYXRlci5kb0Rvd25sb2FkVXBkYXRlKClcbiAgICAgICAgICAgICAgICAgKiB3b3VsZCBub3QgYWN0dWFsbHkgaW5pdGlhdGUgdGhlIGRvd25sb2FkaW5nIGJ5IGVsZWN0cm9uJ3MgYXV0b1VwZGF0ZXJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLm5hdGl2ZVVwZGF0ZXIuY2hlY2tGb3JVcGRhdGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLk1hY1VwZGF0ZXIgPSBNYWNVcGRhdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFjVXBkYXRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXIgPSB2b2lkIDA7XG5jb25zdCBEaWZmZXJlbnRpYWxEb3dubG9hZGVyXzEgPSByZXF1aXJlKFwiLi9EaWZmZXJlbnRpYWxEb3dubG9hZGVyXCIpO1xuY2xhc3MgR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXIgZXh0ZW5kcyBEaWZmZXJlbnRpYWxEb3dubG9hZGVyXzEuRGlmZmVyZW50aWFsRG93bmxvYWRlciB7XG4gICAgZG93bmxvYWQob2xkQmxvY2tNYXAsIG5ld0Jsb2NrTWFwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvRG93bmxvYWQob2xkQmxvY2tNYXAsIG5ld0Jsb2NrTWFwKTtcbiAgICB9XG59XG5leHBvcnRzLkdlbmVyaWNEaWZmZXJlbnRpYWxEb3dubG9hZGVyID0gR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmVyaWZ5U2lnbmF0dXJlID0gdm9pZCAwO1xuY29uc3QgYnVpbGRlcl91dGlsX3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbmNvbnN0IGNoaWxkX3Byb2Nlc3NfMSA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpO1xuY29uc3Qgb3MgPSByZXF1aXJlKFwib3NcIik7XG4vLyAkY2VydGlmaWNhdGVJbmZvID0gKEdldC1BdXRoZW50aWNvZGVTaWduYXR1cmUgJ3h4eFxceXl5LmV4ZSdcbi8vIHwgd2hlcmUgeyRfLlN0YXR1cy5FcXVhbHMoW1N5c3RlbS5NYW5hZ2VtZW50LkF1dG9tYXRpb24uU2lnbmF0dXJlU3RhdHVzXTo6VmFsaWQpIC1hbmQgJF8uU2lnbmVyQ2VydGlmaWNhdGUuU3ViamVjdC5Db250YWlucyhcIkNOPXNpZW1lbnMuY29tXCIpfSlcbi8vIHwgT3V0LVN0cmluZyA7IGlmICgkY2VydGlmaWNhdGVJbmZvKSB7IGV4aXQgMCB9IGVsc2UgeyBleGl0IDEgfVxuZnVuY3Rpb24gdmVyaWZ5U2lnbmF0dXJlKHB1Ymxpc2hlck5hbWVzLCB1bmVzY2FwZWRUZW1wVXBkYXRlRmlsZSwgbG9nZ2VyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgLy8gRXNjYXBlIHF1b3RlcyBhbmQgYmFja3RpY2tzIGluIGZpbGVuYW1lcyB0byBwcmV2ZW50IHVzZXIgZnJvbSBicmVha2luZyB0aGVcbiAgICAgICAgLy8gYXJndW1lbnRzIGFuZCBwZXJmb3JtIGEgcmVtb3RlIGNvbW1hbmQgaW5qZWN0aW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBDb25zaWRlciBleGFtcGxlIHBvd2Vyc2hlbGwgY29tbWFuZDpcbiAgICAgICAgLy8gYGBgcG93ZXJzaGVsbFxuICAgICAgICAvLyBHZXQtQXV0aGVudGljb2RlU2lnbmF0dXJlICdDOlxcXFxwYXRoXFxcXG15LWJhZC0nO2NhbGM7J2ZpbGVuYW1lLmV4ZSdcbiAgICAgICAgLy8gYGBgXG4gICAgICAgIC8vIFRoZSBhYm92ZSB3b3VsZCB3b3JrIGV4cGVjdGVkIGFuZCBmaW5kIHRoZSBmaWxlIG5hbWUsIGhvd2V2ZXIsIGl0IHdpbGwgYWxzbyBleGVjdXRlIGA7Y2FsYztgXG4gICAgICAgIC8vIGNvbW1hbmQgYW5kIHN0YXJ0IHRoZSBjYWxjdWxhdG9yIGFwcC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRnJvbSBQb3dlcnNoZWxsIHF1b3RpbmcgcnVsZXM6XG4gICAgICAgIC8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3Bvd2Vyc2hlbGwvbW9kdWxlL21pY3Jvc29mdC5wb3dlcnNoZWxsLmNvcmUvYWJvdXQvYWJvdXRfcXVvdGluZ19ydWxlcz92aWV3PXBvd2Vyc2hlbGwtN1xuICAgICAgICAvLyAqIERvdWJsZSBxdW90ZXMgYFwiYCBhcmUgdHJlYXRlZCBsaXRlcmFsbHkgd2l0aGluIHNpbmdsZS1xdW90ZWQgc3RyaW5ncztcbiAgICAgICAgLy8gKiBTaW5nbGUgcXVvdGVzIGNhbiBiZSBlc2NhcGVkIGJ5IGRvdWJsaW5nIHRoZW06ICdkb24nJ3QnIC0+IGRvbid0O1xuICAgICAgICAvL1xuICAgICAgICAvLyBBbHNvIG5vdGUgdGhhdCBhdCB0aGlzIHBvaW50IHRoZSBmaWxlIGhhcyBhbHJlYWR5IGJlZW4gd3JpdHRlbiB0byB0aGUgZGlzaywgdGh1cyB3ZSBhcmVcbiAgICAgICAgLy8gZ3VhcmFudGVlZCB0aGF0IHRoZSBwYXRoIHdpbGwgbm90IGNvbnRhaW4gYW55IGlsbGVnYWwgY2hhcmFjdGVycyBsaWtlIDw+OlwiL1xcfD8qXG4gICAgICAgIC8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3dpbmRvd3Mvd2luMzIvZmlsZWlvL25hbWluZy1hLWZpbGVcbiAgICAgICAgY29uc3QgdGVtcFVwZGF0ZUZpbGUgPSB1bmVzY2FwZWRUZW1wVXBkYXRlRmlsZS5yZXBsYWNlKC8nL2csIFwiJydcIik7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi11c2VybGFuZC9lbGVjdHJvbi1idWlsZGVyL2lzc3Vlcy8yNDIxXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi11c2VybGFuZC9lbGVjdHJvbi1idWlsZGVyL2lzc3Vlcy8yNTM1XG4gICAgICAgICgwLCBjaGlsZF9wcm9jZXNzXzEuZXhlY0ZpbGUpKFwiY2hjcCA2NTAwMSA+TlVMICYgcG93ZXJzaGVsbC5leGVcIiwgW1wiLU5vUHJvZmlsZVwiLCBcIi1Ob25JbnRlcmFjdGl2ZVwiLCBcIi1JbnB1dEZvcm1hdFwiLCBcIk5vbmVcIiwgXCItQ29tbWFuZFwiLCBgXCJHZXQtQXV0aGVudGljb2RlU2lnbmF0dXJlIC1MaXRlcmFsUGF0aCAnJHt0ZW1wVXBkYXRlRmlsZX0nIHwgQ29udmVydFRvLUpzb24gLUNvbXByZXNzXCJgXSwge1xuICAgICAgICAgICAgc2hlbGw6IHRydWUsXG4gICAgICAgICAgICB0aW1lb3V0OiAyMCAqIDEwMDAsXG4gICAgICAgIH0sIChlcnJvciwgc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yICE9IG51bGwgfHwgc3RkZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGxvZ2dlciwgZXJyb3IsIHN0ZGVyciwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gcGFyc2VPdXQoc3Rkb3V0KTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5TdGF0dXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ViamVjdCA9ICgwLCBidWlsZGVyX3V0aWxfcnVudGltZV8xLnBhcnNlRG4pKGRhdGEuU2lnbmVyQ2VydGlmaWNhdGUuU3ViamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgcHVibGlzaGVyTmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRuID0gKDAsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEucGFyc2VEbikobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG4uc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYSBmdWxsIEROLCBjb21wYXJlIGFsbCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxLZXlzID0gQXJyYXkuZnJvbShkbi5rZXlzKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gYWxsS2V5cy5ldmVyeShrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG4uZ2V0KGtleSkgPT09IHN1YmplY3QuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSBzdWJqZWN0LmdldChcIkNOXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFNpZ25hdHVyZSB2YWxpZGF0ZWQgdXNpbmcgb25seSBDTiAke25hbWV9LiBQbGVhc2UgYWRkIHlvdXIgZnVsbCBEaXN0aW5ndWlzaGVkIE5hbWUgKEROKSB0byBwdWJsaXNoZXJOYW1lcyBjb25maWd1cmF0aW9uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYHB1Ymxpc2hlck5hbWVzOiAke3B1Ymxpc2hlck5hbWVzLmpvaW4oXCIgfCBcIil9LCByYXcgaW5mbzogYCArIEpTT04uc3RyaW5naWZ5KGRhdGEsIChuYW1lLCB2YWx1ZSkgPT4gKG5hbWUgPT09IFwiUmF3RGF0YVwiID8gdW5kZWZpbmVkIDogdmFsdWUpLCAyKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgU2lnbiB2ZXJpZmljYXRpb24gZmFpbGVkLCBpbnN0YWxsZXIgc2lnbmVkIHdpdGggaW5jb3JyZWN0IGNlcnRpZmljYXRlOiAke3Jlc3VsdH1gKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGxvZ2dlciwgZSwgbnVsbCwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnZlcmlmeVNpZ25hdHVyZSA9IHZlcmlmeVNpZ25hdHVyZTtcbmZ1bmN0aW9uIHBhcnNlT3V0KG91dCkge1xuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKG91dCk7XG4gICAgZGVsZXRlIGRhdGEuUHJpdmF0ZUtleTtcbiAgICBkZWxldGUgZGF0YS5Jc09TQmluYXJ5O1xuICAgIGRlbGV0ZSBkYXRhLlNpZ25hdHVyZVR5cGU7XG4gICAgY29uc3Qgc2lnbmVyQ2VydGlmaWNhdGUgPSBkYXRhLlNpZ25lckNlcnRpZmljYXRlO1xuICAgIGlmIChzaWduZXJDZXJ0aWZpY2F0ZSAhPSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBzaWduZXJDZXJ0aWZpY2F0ZS5BcmNoaXZlZDtcbiAgICAgICAgZGVsZXRlIHNpZ25lckNlcnRpZmljYXRlLkV4dGVuc2lvbnM7XG4gICAgICAgIGRlbGV0ZSBzaWduZXJDZXJ0aWZpY2F0ZS5IYW5kbGU7XG4gICAgICAgIGRlbGV0ZSBzaWduZXJDZXJ0aWZpY2F0ZS5IYXNQcml2YXRlS2V5O1xuICAgICAgICAvLyBkdXBsaWNhdGVzIGRhdGEuU2lnbmVyQ2VydGlmaWNhdGUgKGNvbnRhaW5zIFJhd0RhdGEpXG4gICAgICAgIGRlbGV0ZSBzaWduZXJDZXJ0aWZpY2F0ZS5TdWJqZWN0TmFtZTtcbiAgICB9XG4gICAgZGVsZXRlIGRhdGEuUGF0aDtcbiAgICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGxvZ2dlciwgZXJyb3IsIHN0ZGVyciwgcmVqZWN0KSB7XG4gICAgaWYgKGlzT2xkV2luNigpKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBDYW5ub3QgZXhlY3V0ZSBHZXQtQXV0aGVudGljb2RlU2lnbmF0dXJlOiAke2Vycm9yIHx8IHN0ZGVycn0uIElnbm9yaW5nIHNpZ25hdHVyZSB2YWxpZGF0aW9uIGR1ZSB0byB1bnN1cHBvcnRlZCBwb3dlcnNoZWxsIHZlcnNpb24uIFBsZWFzZSB1cGdyYWRlIHRvIHBvd2Vyc2hlbGwgMyBvciBoaWdoZXIuYCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgKDAsIGNoaWxkX3Byb2Nlc3NfMS5leGVjRmlsZVN5bmMpKFwicG93ZXJzaGVsbC5leGVcIiwgW1wiLU5vUHJvZmlsZVwiLCBcIi1Ob25JbnRlcmFjdGl2ZVwiLCBcIi1Db21tYW5kXCIsIFwiQ29udmVydFRvLUpzb24gdGVzdFwiXSwgeyB0aW1lb3V0OiAxMCAqIDEwMDAgfSk7XG4gICAgfVxuICAgIGNhdGNoICh0ZXN0RXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYENhbm5vdCBleGVjdXRlIENvbnZlcnRUby1Kc29uOiAke3Rlc3RFcnJvci5tZXNzYWdlfS4gSWdub3Jpbmcgc2lnbmF0dXJlIHZhbGlkYXRpb24gZHVlIHRvIHVuc3VwcG9ydGVkIHBvd2Vyc2hlbGwgdmVyc2lvbi4gUGxlYXNlIHVwZ3JhZGUgdG8gcG93ZXJzaGVsbCAzIG9yIGhpZ2hlci5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgIT0gbnVsbCkge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgICBpZiAoc3RkZXJyKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoYENhbm5vdCBleGVjdXRlIEdldC1BdXRoZW50aWNvZGVTaWduYXR1cmUsIHN0ZGVycjogJHtzdGRlcnJ9LiBGYWlsaW5nIHNpZ25hdHVyZSB2YWxpZGF0aW9uIGR1ZSB0byB1bmtub3duIHN0ZGVyci5gKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNPbGRXaW42KCkge1xuICAgIGNvbnN0IHdpblZlcnNpb24gPSBvcy5yZWxlYXNlKCk7XG4gICAgcmV0dXJuIHdpblZlcnNpb24uc3RhcnRzV2l0aChcIjYuXCIpICYmICF3aW5WZXJzaW9uLnN0YXJ0c1dpdGgoXCI2LjNcIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5kb3dzRXhlY3V0YWJsZUNvZGVTaWduYXR1cmVWZXJpZmllci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTnNpc1VwZGF0ZXIgPSB2b2lkIDA7XG5jb25zdCBidWlsZGVyX3V0aWxfcnVudGltZV8xID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgQmFzZVVwZGF0ZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VVcGRhdGVyXCIpO1xuY29uc3QgRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlcl8xID0gcmVxdWlyZShcIi4vZGlmZmVyZW50aWFsRG93bmxvYWRlci9GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyXCIpO1xuY29uc3QgR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXJfMSA9IHJlcXVpcmUoXCIuL2RpZmZlcmVudGlhbERvd25sb2FkZXIvR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXJcIik7XG5jb25zdCBtYWluXzEgPSByZXF1aXJlKFwiLi9tYWluXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IFByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlcnMvUHJvdmlkZXJcIik7XG5jb25zdCBmc19leHRyYV8xID0gcmVxdWlyZShcImZzLWV4dHJhXCIpO1xuY29uc3Qgd2luZG93c0V4ZWN1dGFibGVDb2RlU2lnbmF0dXJlVmVyaWZpZXJfMSA9IHJlcXVpcmUoXCIuL3dpbmRvd3NFeGVjdXRhYmxlQ29kZVNpZ25hdHVyZVZlcmlmaWVyXCIpO1xuY29uc3QgdXJsXzEgPSByZXF1aXJlKFwidXJsXCIpO1xuY29uc3QgemxpYl8xID0gcmVxdWlyZShcInpsaWJcIik7XG5jbGFzcyBOc2lzVXBkYXRlciBleHRlbmRzIEJhc2VVcGRhdGVyXzEuQmFzZVVwZGF0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGFwcCkge1xuICAgICAgICBzdXBlcihvcHRpb25zLCBhcHApO1xuICAgICAgICB0aGlzLl92ZXJpZnlVcGRhdGVDb2RlU2lnbmF0dXJlID0gKHB1Ymxpc2hlck5hbWVzLCB1bmVzY2FwZWRUZW1wVXBkYXRlRmlsZSkgPT4gKDAsIHdpbmRvd3NFeGVjdXRhYmxlQ29kZVNpZ25hdHVyZVZlcmlmaWVyXzEudmVyaWZ5U2lnbmF0dXJlKShwdWJsaXNoZXJOYW1lcywgdW5lc2NhcGVkVGVtcFVwZGF0ZUZpbGUsIHRoaXMuX2xvZ2dlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJpZnlVcGRhdGVDb2RlU2lnbmF0dXJlLiBZb3UgY2FuIHBhc3MgW3dpbi12ZXJpZnktc2lnbmF0dXJlXShodHRwczovL2dpdGh1Yi5jb20vYmV5b25ka21wL3dpbi12ZXJpZnktdHJ1c3QpIG9yIGFub3RoZXIgY3VzdG9tIHZlcmlmeSBmdW5jdGlvbjogYCAocHVibGlzaGVyTmFtZTogc3RyaW5nW10sIHBhdGg6IHN0cmluZykgPT4gUHJvbWlzZTxzdHJpbmcgfCBudWxsPmAuXG4gICAgICogVGhlIGRlZmF1bHQgdmVyaWZ5IGZ1bmN0aW9uIHVzZXMgW3dpbmRvd3NFeGVjdXRhYmxlQ29kZVNpZ25hdHVyZVZlcmlmaWVyXShodHRwczovL2dpdGh1Yi5jb20vZWxlY3Ryb24tdXNlcmxhbmQvZWxlY3Ryb24tYnVpbGRlci9ibG9iL21hc3Rlci9wYWNrYWdlcy9lbGVjdHJvbi11cGRhdGVyL3NyYy93aW5kb3dzRXhlY3V0YWJsZUNvZGVTaWduYXR1cmVWZXJpZmllci50cylcbiAgICAgKi9cbiAgICBnZXQgdmVyaWZ5VXBkYXRlQ29kZVNpZ25hdHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcmlmeVVwZGF0ZUNvZGVTaWduYXR1cmU7XG4gICAgfVxuICAgIHNldCB2ZXJpZnlVcGRhdGVDb2RlU2lnbmF0dXJlKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdmVyaWZ5VXBkYXRlQ29kZVNpZ25hdHVyZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiogQHByaXZhdGUgKi9cbiAgICBkb0Rvd25sb2FkVXBkYXRlKGRvd25sb2FkVXBkYXRlT3B0aW9ucykge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGRvd25sb2FkVXBkYXRlT3B0aW9ucy51cGRhdGVJbmZvQW5kUHJvdmlkZXIucHJvdmlkZXI7XG4gICAgICAgIGNvbnN0IGZpbGVJbmZvID0gKDAsIFByb3ZpZGVyXzEuZmluZEZpbGUpKHByb3ZpZGVyLnJlc29sdmVGaWxlcyhkb3dubG9hZFVwZGF0ZU9wdGlvbnMudXBkYXRlSW5mb0FuZFByb3ZpZGVyLmluZm8pLCBcImV4ZVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZURvd25sb2FkKHtcbiAgICAgICAgICAgIGZpbGVFeHRlbnNpb246IFwiZXhlXCIsXG4gICAgICAgICAgICBkb3dubG9hZFVwZGF0ZU9wdGlvbnMsXG4gICAgICAgICAgICBmaWxlSW5mbyxcbiAgICAgICAgICAgIHRhc2s6IGFzeW5jIChkZXN0aW5hdGlvbkZpbGUsIGRvd25sb2FkT3B0aW9ucywgcGFja2FnZUZpbGUsIHJlbW92ZVRlbXBEaXJJZkFueSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhY2thZ2VJbmZvID0gZmlsZUluZm8ucGFja2FnZUluZm87XG4gICAgICAgICAgICAgICAgY29uc3QgaXNXZWJJbnN0YWxsZXIgPSBwYWNrYWdlSW5mbyAhPSBudWxsICYmIHBhY2thZ2VGaWxlICE9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGlzV2ViSW5zdGFsbGVyICYmIGRvd25sb2FkVXBkYXRlT3B0aW9ucy5kaXNhYmxlV2ViSW5zdGFsbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICgwLCBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKShgVW5hYmxlIHRvIGRvd25sb2FkIG5ldyB2ZXJzaW9uICR7ZG93bmxvYWRVcGRhdGVPcHRpb25zLnVwZGF0ZUluZm9BbmRQcm92aWRlci5pbmZvLnZlcnNpb259LiBXZWIgSW5zdGFsbGVycyBhcmUgZGlzYWJsZWRgLCBcIkVSUl9VUERBVEVSX1dFQl9JTlNUQUxMRVJfRElTQUJMRURcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNXZWJJbnN0YWxsZXIgJiYgIWRvd25sb2FkVXBkYXRlT3B0aW9ucy5kaXNhYmxlV2ViSW5zdGFsbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKFwiZGlzYWJsZVdlYkluc3RhbGxlciBpcyBzZXQgdG8gZmFsc2UsIHlvdSBzaG91bGQgc2V0IGl0IHRvIHRydWUgaWYgeW91IGRvIG5vdCBwbGFuIG9uIHVzaW5nIGEgd2ViIGluc3RhbGxlci4gVGhpcyB3aWxsIGRlZmF1bHQgdG8gdHJ1ZSBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzV2ViSW5zdGFsbGVyIHx8IChhd2FpdCB0aGlzLmRpZmZlcmVudGlhbERvd25sb2FkSW5zdGFsbGVyKGZpbGVJbmZvLCBkb3dubG9hZFVwZGF0ZU9wdGlvbnMsIGRlc3RpbmF0aW9uRmlsZSwgcHJvdmlkZXIpKSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmh0dHBFeGVjdXRvci5kb3dubG9hZChmaWxlSW5mby51cmwsIGRlc3RpbmF0aW9uRmlsZSwgZG93bmxvYWRPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlVmVyaWZpY2F0aW9uU3RhdHVzID0gYXdhaXQgdGhpcy52ZXJpZnlTaWduYXR1cmUoZGVzdGluYXRpb25GaWxlKTtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbmF0dXJlVmVyaWZpY2F0aW9uU3RhdHVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcmVtb3ZlVGVtcERpcklmQW55KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vaW5zcGVjdGlvbiBUaHJvd0luc2lkZUZpbmFsbHlCbG9ja0pTXG4gICAgICAgICAgICAgICAgICAgIHRocm93ICgwLCBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKShgTmV3IHZlcnNpb24gJHtkb3dubG9hZFVwZGF0ZU9wdGlvbnMudXBkYXRlSW5mb0FuZFByb3ZpZGVyLmluZm8udmVyc2lvbn0gaXMgbm90IHNpZ25lZCBieSB0aGUgYXBwbGljYXRpb24gb3duZXI6ICR7c2lnbmF0dXJlVmVyaWZpY2F0aW9uU3RhdHVzfWAsIFwiRVJSX1VQREFURVJfSU5WQUxJRF9TSUdOQVRVUkVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1dlYkluc3RhbGxlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXdhaXQgdGhpcy5kaWZmZXJlbnRpYWxEb3dubG9hZFdlYlBhY2thZ2UoZG93bmxvYWRVcGRhdGVPcHRpb25zLCBwYWNrYWdlSW5mbywgcGFja2FnZUZpbGUsIHByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmh0dHBFeGVjdXRvci5kb3dubG9hZChuZXcgdXJsXzEuVVJMKHBhY2thZ2VJbmZvLnBhdGgpLCBwYWNrYWdlRmlsZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBkb3dubG9hZFVwZGF0ZU9wdGlvbnMucmVxdWVzdEhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblRva2VuOiBkb3dubG9hZFVwZGF0ZU9wdGlvbnMuY2FuY2VsbGF0aW9uVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYTUxMjogcGFja2FnZUluZm8uc2hhNTEyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCAoMCwgZnNfZXh0cmFfMS51bmxpbmspKHBhY2thZ2VGaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gJGNlcnRpZmljYXRlSW5mbyA9IChHZXQtQXV0aGVudGljb2RlU2lnbmF0dXJlICd4eHhcXHl5eS5leGUnXG4gICAgLy8gfCB3aGVyZSB7JF8uU3RhdHVzLkVxdWFscyhbU3lzdGVtLk1hbmFnZW1lbnQuQXV0b21hdGlvbi5TaWduYXR1cmVTdGF0dXNdOjpWYWxpZCkgLWFuZCAkXy5TaWduZXJDZXJ0aWZpY2F0ZS5TdWJqZWN0LkNvbnRhaW5zKFwiQ049c2llbWVucy5jb21cIil9KVxuICAgIC8vIHwgT3V0LVN0cmluZyA7IGlmICgkY2VydGlmaWNhdGVJbmZvKSB7IGV4aXQgMCB9IGVsc2UgeyBleGl0IDEgfVxuICAgIGFzeW5jIHZlcmlmeVNpZ25hdHVyZSh0ZW1wVXBkYXRlRmlsZSkge1xuICAgICAgICBsZXQgcHVibGlzaGVyTmFtZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHB1Ymxpc2hlck5hbWUgPSAoYXdhaXQgdGhpcy5jb25maWdPbkRpc2sudmFsdWUpLnB1Ymxpc2hlck5hbWU7XG4gICAgICAgICAgICBpZiAocHVibGlzaGVyTmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmNvZGUgPT09IFwiRU5PRU5UXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBubyBhcHAtdXBkYXRlLnltbFxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdmVyaWZ5VXBkYXRlQ29kZVNpZ25hdHVyZShBcnJheS5pc0FycmF5KHB1Ymxpc2hlck5hbWUpID8gcHVibGlzaGVyTmFtZSA6IFtwdWJsaXNoZXJOYW1lXSwgdGVtcFVwZGF0ZUZpbGUpO1xuICAgIH1cbiAgICBkb0luc3RhbGwob3B0aW9ucykge1xuICAgICAgICBjb25zdCBhcmdzID0gW1wiLS11cGRhdGVkXCJdO1xuICAgICAgICBpZiAob3B0aW9ucy5pc1NpbGVudCkge1xuICAgICAgICAgICAgYXJncy5wdXNoKFwiL1NcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaXNGb3JjZVJ1bkFmdGVyKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goXCItLWZvcmNlLXJ1blwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbnN0YWxsRGlyZWN0b3J5KSB7XG4gICAgICAgICAgICAvLyBtYXliZSBjaGVjayBpZiBmb2xkZXIgZXhpc3RzXG4gICAgICAgICAgICBhcmdzLnB1c2goYC9EPSR7dGhpcy5pbnN0YWxsRGlyZWN0b3J5fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhY2thZ2VQYXRoID0gdGhpcy5kb3dubG9hZGVkVXBkYXRlSGVscGVyID09IG51bGwgPyBudWxsIDogdGhpcy5kb3dubG9hZGVkVXBkYXRlSGVscGVyLnBhY2thZ2VGaWxlO1xuICAgICAgICBpZiAocGFja2FnZVBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gb25seSA9IGZvcm0gaXMgc3VwcG9ydGVkXG4gICAgICAgICAgICBhcmdzLnB1c2goYC0tcGFja2FnZS1maWxlPSR7cGFja2FnZVBhdGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FsbFVzaW5nRWxldmF0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zcGF3bkxvZyhwYXRoLmpvaW4ocHJvY2Vzcy5yZXNvdXJjZXNQYXRoLCBcImVsZXZhdGUuZXhlXCIpLCBbb3B0aW9ucy5pbnN0YWxsZXJQYXRoXS5jb25jYXQoYXJncykpLmNhdGNoKGUgPT4gdGhpcy5kaXNwYXRjaEVycm9yKGUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMuaXNBZG1pblJpZ2h0c1JlcXVpcmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcImlzQWRtaW5SaWdodHNSZXF1aXJlZCBpcyBzZXQgdG8gdHJ1ZSwgcnVuIGluc3RhbGxlciB1c2luZyBlbGV2YXRlLmV4ZVwiKTtcbiAgICAgICAgICAgIGNhbGxVc2luZ0VsZXZhdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zcGF3bkxvZyhvcHRpb25zLmluc3RhbGxlclBhdGgsIGFyZ3MpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZWxlY3Ryb24tdXNlcmxhbmQvZWxlY3Ryb24tYnVpbGRlci9pc3N1ZXMvMTEyOVxuICAgICAgICAgICAgLy8gTm9kZSA4IHNlbmRzIGVycm9yczogaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0LXY4LngvZG9jcy9hcGkvZXJyb3JzLmh0bWwjZXJyb3JzX2NvbW1vbl9zeXN0ZW1fZXJyb3JzXG4gICAgICAgICAgICBjb25zdCBlcnJvckNvZGUgPSBlLmNvZGU7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhgQ2Fubm90IHJ1biBpbnN0YWxsZXI6IGVycm9yIGNvZGU6ICR7ZXJyb3JDb2RlfSwgZXJyb3IgbWVzc2FnZTogXCIke2UubWVzc2FnZX1cIiwgd2lsbCBiZSBleGVjdXRlZCBhZ2FpbiB1c2luZyBlbGV2YXRlIGlmIEVBQ0NFU1wiYCk7XG4gICAgICAgICAgICBpZiAoZXJyb3JDb2RlID09PSBcIlVOS05PV05cIiB8fCBlcnJvckNvZGUgPT09IFwiRUFDQ0VTXCIpIHtcbiAgICAgICAgICAgICAgICBjYWxsVXNpbmdFbGV2YXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhc3luYyBkaWZmZXJlbnRpYWxEb3dubG9hZEluc3RhbGxlcihmaWxlSW5mbywgZG93bmxvYWRVcGRhdGVPcHRpb25zLCBpbnN0YWxsZXJQYXRoLCBwcm92aWRlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Rlc3RPbmx5T3B0aW9ucyAhPSBudWxsICYmICF0aGlzLl90ZXN0T25seU9wdGlvbnMuaXNVc2VEaWZmZXJlbnRpYWxEb3dubG9hZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmxvY2ttYXBGaWxlVXJscyA9ICgwLCB1dGlsXzEuYmxvY2ttYXBGaWxlcykoZmlsZUluZm8udXJsLCB0aGlzLmFwcC52ZXJzaW9uLCBkb3dubG9hZFVwZGF0ZU9wdGlvbnMudXBkYXRlSW5mb0FuZFByb3ZpZGVyLmluZm8udmVyc2lvbik7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhgRG93bmxvYWQgYmxvY2sgbWFwcyAob2xkOiBcIiR7YmxvY2ttYXBGaWxlVXJsc1swXX1cIiwgbmV3OiAke2Jsb2NrbWFwRmlsZVVybHNbMV19KWApO1xuICAgICAgICAgICAgY29uc3QgZG93bmxvYWRCbG9ja01hcCA9IGFzeW5jICh1cmwpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5odHRwRXhlY3V0b3IuZG93bmxvYWRUb0J1ZmZlcih1cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogZG93bmxvYWRVcGRhdGVPcHRpb25zLnJlcXVlc3RIZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25Ub2tlbjogZG93bmxvYWRVcGRhdGVPcHRpb25zLmNhbmNlbGxhdGlvblRva2VuLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhID09IG51bGwgfHwgZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCbG9ja21hcCBcIiR7dXJsLmhyZWZ9XCIgaXMgZW1wdHlgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoKDAsIHpsaWJfMS5ndW56aXBTeW5jKShkYXRhKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcGFyc2UgYmxvY2ttYXAgXCIke3VybC5ocmVmfVwiLCBlcnJvcjogJHtlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBkb3dubG9hZE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgbmV3VXJsOiBmaWxlSW5mby51cmwsXG4gICAgICAgICAgICAgICAgb2xkRmlsZTogcGF0aC5qb2luKHRoaXMuZG93bmxvYWRlZFVwZGF0ZUhlbHBlci5jYWNoZURpciwgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5DVVJSRU5UX0FQUF9JTlNUQUxMRVJfRklMRV9OQU1FKSxcbiAgICAgICAgICAgICAgICBsb2dnZXI6IHRoaXMuX2xvZ2dlcixcbiAgICAgICAgICAgICAgICBuZXdGaWxlOiBpbnN0YWxsZXJQYXRoLFxuICAgICAgICAgICAgICAgIGlzVXNlTXVsdGlwbGVSYW5nZVJlcXVlc3Q6IHByb3ZpZGVyLmlzVXNlTXVsdGlwbGVSYW5nZVJlcXVlc3QsXG4gICAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnM6IGRvd25sb2FkVXBkYXRlT3B0aW9ucy5yZXF1ZXN0SGVhZGVycyxcbiAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25Ub2tlbjogZG93bmxvYWRVcGRhdGVPcHRpb25zLmNhbmNlbGxhdGlvblRva2VuLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RlbmVyQ291bnQobWFpbl8xLkRPV05MT0FEX1BST0dSRVNTKSA+IDApIHtcbiAgICAgICAgICAgICAgICBkb3dubG9hZE9wdGlvbnMub25Qcm9ncmVzcyA9IGl0ID0+IHRoaXMuZW1pdChtYWluXzEuRE9XTkxPQURfUFJPR1JFU1MsIGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTWFwRGF0YUxpc3QgPSBhd2FpdCBQcm9taXNlLmFsbChibG9ja21hcEZpbGVVcmxzLm1hcCh1ID0+IGRvd25sb2FkQmxvY2tNYXAodSkpKTtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBHZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlcl8xLkdlbmVyaWNEaWZmZXJlbnRpYWxEb3dubG9hZGVyKGZpbGVJbmZvLmluZm8sIHRoaXMuaHR0cEV4ZWN1dG9yLCBkb3dubG9hZE9wdGlvbnMpLmRvd25sb2FkKGJsb2NrTWFwRGF0YUxpc3RbMF0sIGJsb2NrTWFwRGF0YUxpc3RbMV0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoYENhbm5vdCBkb3dubG9hZCBkaWZmZXJlbnRpYWxseSwgZmFsbGJhY2sgdG8gZnVsbCBkb3dubG9hZDogJHtlLnN0YWNrIHx8IGV9YCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fdGVzdE9ubHlPcHRpb25zICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB0ZXN0IG1vZGVcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGlmZmVyZW50aWFsRG93bmxvYWRXZWJQYWNrYWdlKGRvd25sb2FkVXBkYXRlT3B0aW9ucywgcGFja2FnZUluZm8sIHBhY2thZ2VQYXRoLCBwcm92aWRlcikge1xuICAgICAgICBpZiAocGFja2FnZUluZm8uYmxvY2tNYXBTaXplID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkb3dubG9hZE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgbmV3VXJsOiBuZXcgdXJsXzEuVVJMKHBhY2thZ2VJbmZvLnBhdGgpLFxuICAgICAgICAgICAgICAgIG9sZEZpbGU6IHBhdGguam9pbih0aGlzLmRvd25sb2FkZWRVcGRhdGVIZWxwZXIuY2FjaGVEaXIsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuQ1VSUkVOVF9BUFBfUEFDS0FHRV9GSUxFX05BTUUpLFxuICAgICAgICAgICAgICAgIGxvZ2dlcjogdGhpcy5fbG9nZ2VyLFxuICAgICAgICAgICAgICAgIG5ld0ZpbGU6IHBhY2thZ2VQYXRoLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzOiB0aGlzLnJlcXVlc3RIZWFkZXJzLFxuICAgICAgICAgICAgICAgIGlzVXNlTXVsdGlwbGVSYW5nZVJlcXVlc3Q6IHByb3ZpZGVyLmlzVXNlTXVsdGlwbGVSYW5nZVJlcXVlc3QsXG4gICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uVG9rZW46IGRvd25sb2FkVXBkYXRlT3B0aW9ucy5jYW5jZWxsYXRpb25Ub2tlbixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5saXN0ZW5lckNvdW50KG1haW5fMS5ET1dOTE9BRF9QUk9HUkVTUykgPiAwKSB7XG4gICAgICAgICAgICAgICAgZG93bmxvYWRPcHRpb25zLm9uUHJvZ3Jlc3MgPSBpdCA9PiB0aGlzLmVtaXQobWFpbl8xLkRPV05MT0FEX1BST0dSRVNTLCBpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBuZXcgRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlcl8xLkZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIocGFja2FnZUluZm8sIHRoaXMuaHR0cEV4ZWN1dG9yLCBkb3dubG9hZE9wdGlvbnMpLmRvd25sb2FkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihgQ2Fubm90IGRvd25sb2FkIGRpZmZlcmVudGlhbGx5LCBmYWxsYmFjayB0byBmdWxsIGRvd25sb2FkOiAke2Uuc3RhY2sgfHwgZX1gKTtcbiAgICAgICAgICAgIC8vIGR1cmluZyB0ZXN0IChkZXZlbG9wZXIgbWFjaGluZSBtYWMgb3IgbGludXgpIHdlIG11c3QgdGhyb3cgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzLnBsYXRmb3JtID09PSBcIndpbjMyXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuTnNpc1VwZGF0ZXIgPSBOc2lzVXBkYXRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5zaXNVcGRhdGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VcGRhdGVyU2lnbmFsID0gZXhwb3J0cy5VUERBVEVfRE9XTkxPQURFRCA9IGV4cG9ydHMuRE9XTkxPQURfUFJPR1JFU1MgPSBleHBvcnRzLk5zaXNVcGRhdGVyID0gZXhwb3J0cy5NYWNVcGRhdGVyID0gZXhwb3J0cy5ScG1VcGRhdGVyID0gZXhwb3J0cy5EZWJVcGRhdGVyID0gZXhwb3J0cy5BcHBJbWFnZVVwZGF0ZXIgPSBleHBvcnRzLlByb3ZpZGVyID0gZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlbiA9IGV4cG9ydHMuTm9PcExvZ2dlciA9IGV4cG9ydHMuQXBwVXBkYXRlciA9IHZvaWQgMDtcbmNvbnN0IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25Ub2tlblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5DYW5jZWxsYXRpb25Ub2tlbjsgfSB9KTtcbmNvbnN0IGZzX2V4dHJhXzEgPSByZXF1aXJlKFwiZnMtZXh0cmFcIik7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG52YXIgQXBwVXBkYXRlcl8xID0gcmVxdWlyZShcIi4vQXBwVXBkYXRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFwcFVwZGF0ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFwcFVwZGF0ZXJfMS5BcHBVcGRhdGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm9PcExvZ2dlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQXBwVXBkYXRlcl8xLk5vT3BMb2dnZXI7IH0gfSk7XG52YXIgUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVycy9Qcm92aWRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBQcm92aWRlcl8xLlByb3ZpZGVyOyB9IH0pO1xudmFyIEFwcEltYWdlVXBkYXRlcl8xID0gcmVxdWlyZShcIi4vQXBwSW1hZ2VVcGRhdGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXBwSW1hZ2VVcGRhdGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBBcHBJbWFnZVVwZGF0ZXJfMS5BcHBJbWFnZVVwZGF0ZXI7IH0gfSk7XG52YXIgRGViVXBkYXRlcl8xID0gcmVxdWlyZShcIi4vRGViVXBkYXRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRlYlVwZGF0ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERlYlVwZGF0ZXJfMS5EZWJVcGRhdGVyOyB9IH0pO1xudmFyIFJwbVVwZGF0ZXJfMSA9IHJlcXVpcmUoXCIuL1JwbVVwZGF0ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJScG1VcGRhdGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBScG1VcGRhdGVyXzEuUnBtVXBkYXRlcjsgfSB9KTtcbnZhciBNYWNVcGRhdGVyXzEgPSByZXF1aXJlKFwiLi9NYWNVcGRhdGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWFjVXBkYXRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTWFjVXBkYXRlcl8xLk1hY1VwZGF0ZXI7IH0gfSk7XG52YXIgTnNpc1VwZGF0ZXJfMSA9IHJlcXVpcmUoXCIuL05zaXNVcGRhdGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTnNpc1VwZGF0ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5zaXNVcGRhdGVyXzEuTnNpc1VwZGF0ZXI7IH0gfSk7XG4vLyBhdXRvVXBkYXRlciB0byBtaW1pYyBlbGVjdHJvbiBidW5kbGVkIGF1dG9VcGRhdGVyXG5sZXQgX2F1dG9VcGRhdGVyO1xuZnVuY3Rpb24gZG9Mb2FkQXV0b1VwZGF0ZXIoKSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGU6cHJlZmVyLWNvbmRpdGlvbmFsLWV4cHJlc3Npb25cbiAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgICAgIF9hdXRvVXBkYXRlciA9IG5ldyAocmVxdWlyZShcIi4vTnNpc1VwZGF0ZXJcIikuTnNpc1VwZGF0ZXIpKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09IFwiZGFyd2luXCIpIHtcbiAgICAgICAgX2F1dG9VcGRhdGVyID0gbmV3IChyZXF1aXJlKFwiLi9NYWNVcGRhdGVyXCIpLk1hY1VwZGF0ZXIpKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBfYXV0b1VwZGF0ZXIgPSBuZXcgKHJlcXVpcmUoXCIuL0FwcEltYWdlVXBkYXRlclwiKS5BcHBJbWFnZVVwZGF0ZXIpKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpZGVudGl0eSA9IHBhdGguam9pbihwcm9jZXNzLnJlc291cmNlc1BhdGgsIFwicGFja2FnZS10eXBlXCIpO1xuICAgICAgICAgICAgaWYgKCEoMCwgZnNfZXh0cmFfMS5leGlzdHNTeW5jKShpZGVudGl0eSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2F1dG9VcGRhdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiQ2hlY2tpbmcgZm9yIGJldGEgYXV0b3VwZGF0ZSBmZWF0dXJlIGZvciBkZWIvcnBtIGRpc3RyaWJ1dGlvbnNcIik7XG4gICAgICAgICAgICBjb25zdCBmaWxlVHlwZSA9ICgwLCBmc19leHRyYV8xLnJlYWRGaWxlU3luYykoaWRlbnRpdHkpLnRvU3RyaW5nKCkudHJpbSgpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiRm91bmQgcGFja2FnZS10eXBlOlwiLCBmaWxlVHlwZSk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpbGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRlYlwiOlxuICAgICAgICAgICAgICAgICAgICBfYXV0b1VwZGF0ZXIgPSBuZXcgKHJlcXVpcmUoXCIuL0RlYlVwZGF0ZXJcIikuRGViVXBkYXRlcikoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJwbVwiOlxuICAgICAgICAgICAgICAgICAgICBfYXV0b1VwZGF0ZXIgPSBuZXcgKHJlcXVpcmUoXCIuL1JwbVVwZGF0ZXJcIikuUnBtVXBkYXRlcikoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmFibGUgdG8gZGV0ZWN0ICdwYWNrYWdlLXR5cGUnIGZvciBhdXRvVXBkYXRlciAoYmV0YSBycG0vZGViIHN1cHBvcnQpLiBJZiB5b3UnZCBsaWtlIHRvIGV4cGFuZCBzdXBwb3J0LCBwbGVhc2UgY29uc2lkZXIgY29udHJpYnV0aW5nIHRvIGVsZWN0cm9uLWJ1aWxkZXJcIiwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9hdXRvVXBkYXRlcjtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImF1dG9VcGRhdGVyXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gX2F1dG9VcGRhdGVyIHx8IGRvTG9hZEF1dG9VcGRhdGVyKCk7XG4gICAgfSxcbn0pO1xuZXhwb3J0cy5ET1dOTE9BRF9QUk9HUkVTUyA9IFwiZG93bmxvYWQtcHJvZ3Jlc3NcIjtcbmV4cG9ydHMuVVBEQVRFX0RPV05MT0FERUQgPSBcInVwZGF0ZS1kb3dubG9hZGVkXCI7XG5jbGFzcyBVcGRhdGVyU2lnbmFsIHtcbiAgICBjb25zdHJ1Y3RvcihlbWl0dGVyKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiBhbiBhdXRoZW50aWNhdGluZyBwcm94eSBpcyBbYXNraW5nIGZvciB1c2VyIGNyZWRlbnRpYWxzXShodHRwczovL2dpdGh1Yi5jb20vZWxlY3Ryb24vZWxlY3Ryb24vYmxvYi9tYXN0ZXIvZG9jcy9hcGkvY2xpZW50LXJlcXVlc3QubWQjZXZlbnQtbG9naW4pLlxuICAgICAqL1xuICAgIGxvZ2luKGhhbmRsZXIpIHtcbiAgICAgICAgYWRkSGFuZGxlcih0aGlzLmVtaXR0ZXIsIFwibG9naW5cIiwgaGFuZGxlcik7XG4gICAgfVxuICAgIHByb2dyZXNzKGhhbmRsZXIpIHtcbiAgICAgICAgYWRkSGFuZGxlcih0aGlzLmVtaXR0ZXIsIGV4cG9ydHMuRE9XTkxPQURfUFJPR1JFU1MsIGhhbmRsZXIpO1xuICAgIH1cbiAgICB1cGRhdGVEb3dubG9hZGVkKGhhbmRsZXIpIHtcbiAgICAgICAgYWRkSGFuZGxlcih0aGlzLmVtaXR0ZXIsIGV4cG9ydHMuVVBEQVRFX0RPV05MT0FERUQsIGhhbmRsZXIpO1xuICAgIH1cbiAgICB1cGRhdGVDYW5jZWxsZWQoaGFuZGxlcikge1xuICAgICAgICBhZGRIYW5kbGVyKHRoaXMuZW1pdHRlciwgXCJ1cGRhdGUtY2FuY2VsbGVkXCIsIGhhbmRsZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuVXBkYXRlclNpZ25hbCA9IFVwZGF0ZXJTaWduYWw7XG5jb25zdCBpc0xvZ0V2ZW50ID0gZmFsc2U7XG5mdW5jdGlvbiBhZGRIYW5kbGVyKGVtaXR0ZXIsIGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgaWYgKGlzTG9nRXZlbnQpIHtcbiAgICAgICAgZW1pdHRlci5vbihldmVudCwgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiJXMgJXNcIiwgZXZlbnQsIGFyZ3MpO1xuICAgICAgICAgICAgaGFuZGxlciguLi5hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbWl0dGVyLm9uKGV2ZW50LCBoYW5kbGVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWluLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB2YWx1ZSA9PiB7XG5cdGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cdHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgaXNPYmogPSByZXF1aXJlKCdpcy1vYmonKTtcblxuY29uc3QgZGlzYWxsb3dlZEtleXMgPSBuZXcgU2V0KFtcblx0J19fcHJvdG9fXycsXG5cdCdwcm90b3R5cGUnLFxuXHQnY29uc3RydWN0b3InXG5dKTtcblxuY29uc3QgaXNWYWxpZFBhdGggPSBwYXRoU2VnbWVudHMgPT4gIXBhdGhTZWdtZW50cy5zb21lKHNlZ21lbnQgPT4gZGlzYWxsb3dlZEtleXMuaGFzKHNlZ21lbnQpKTtcblxuZnVuY3Rpb24gZ2V0UGF0aFNlZ21lbnRzKHBhdGgpIHtcblx0Y29uc3QgcGF0aEFycmF5ID0gcGF0aC5zcGxpdCgnLicpO1xuXHRjb25zdCBwYXJ0cyA9IFtdO1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aEFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0bGV0IHAgPSBwYXRoQXJyYXlbaV07XG5cblx0XHR3aGlsZSAocFtwLmxlbmd0aCAtIDFdID09PSAnXFxcXCcgJiYgcGF0aEFycmF5W2kgKyAxXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRwID0gcC5zbGljZSgwLCAtMSkgKyAnLic7XG5cdFx0XHRwICs9IHBhdGhBcnJheVsrK2ldO1xuXHRcdH1cblxuXHRcdHBhcnRzLnB1c2gocCk7XG5cdH1cblxuXHRpZiAoIWlzVmFsaWRQYXRoKHBhcnRzKSkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXG5cdHJldHVybiBwYXJ0cztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGdldChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG5cdFx0aWYgKCFpc09iaihvYmplY3QpIHx8IHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyBvYmplY3QgOiB2YWx1ZTtcblx0XHR9XG5cblx0XHRjb25zdCBwYXRoQXJyYXkgPSBnZXRQYXRoU2VnbWVudHMocGF0aCk7XG5cdFx0aWYgKHBhdGhBcnJheS5sZW5ndGggPT09IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhBcnJheS5sZW5ndGg7IGkrKykge1xuXHRcdFx0b2JqZWN0ID0gb2JqZWN0W3BhdGhBcnJheVtpXV07XG5cblx0XHRcdGlmIChvYmplY3QgPT09IHVuZGVmaW5lZCB8fCBvYmplY3QgPT09IG51bGwpIHtcblx0XHRcdFx0Ly8gYG9iamVjdGAgaXMgZWl0aGVyIGB1bmRlZmluZWRgIG9yIGBudWxsYCBzbyB3ZSB3YW50IHRvIHN0b3AgdGhlIGxvb3AsIGFuZFxuXHRcdFx0XHQvLyBpZiB0aGlzIGlzIG5vdCB0aGUgbGFzdCBiaXQgb2YgdGhlIHBhdGgsIGFuZFxuXHRcdFx0XHQvLyBpZiBpdCBkaWQndCByZXR1cm4gYHVuZGVmaW5lZGBcblx0XHRcdFx0Ly8gaXQgd291bGQgcmV0dXJuIGBudWxsYCBpZiBgb2JqZWN0YCBpcyBgbnVsbGBcblx0XHRcdFx0Ly8gYnV0IHdlIHdhbnQgYGdldCh7Zm9vOiBudWxsfSwgJ2Zvby5iYXInKWAgdG8gZXF1YWwgYHVuZGVmaW5lZGAsIG9yIHRoZSBzdXBwbGllZCB2YWx1ZSwgbm90IGBudWxsYFxuXHRcdFx0XHRpZiAoaSAhPT0gcGF0aEFycmF5Lmxlbmd0aCAtIDEpIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqZWN0ID09PSB1bmRlZmluZWQgPyB2YWx1ZSA6IG9iamVjdDtcblx0fSxcblxuXHRzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuXHRcdGlmICghaXNPYmoob2JqZWN0KSB8fCB0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBvYmplY3Q7XG5cdFx0fVxuXG5cdFx0Y29uc3Qgcm9vdCA9IG9iamVjdDtcblx0XHRjb25zdCBwYXRoQXJyYXkgPSBnZXRQYXRoU2VnbWVudHMocGF0aCk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhBcnJheS5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgcCA9IHBhdGhBcnJheVtpXTtcblxuXHRcdFx0aWYgKCFpc09iaihvYmplY3RbcF0pKSB7XG5cdFx0XHRcdG9iamVjdFtwXSA9IHt9O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaSA9PT0gcGF0aEFycmF5Lmxlbmd0aCAtIDEpIHtcblx0XHRcdFx0b2JqZWN0W3BdID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdG9iamVjdCA9IG9iamVjdFtwXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcm9vdDtcblx0fSxcblxuXHRkZWxldGUob2JqZWN0LCBwYXRoKSB7XG5cdFx0aWYgKCFpc09iaihvYmplY3QpIHx8IHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGNvbnN0IHBhdGhBcnJheSA9IGdldFBhdGhTZWdtZW50cyhwYXRoKTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aEFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBwID0gcGF0aEFycmF5W2ldO1xuXG5cdFx0XHRpZiAoaSA9PT0gcGF0aEFycmF5Lmxlbmd0aCAtIDEpIHtcblx0XHRcdFx0ZGVsZXRlIG9iamVjdFtwXTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdG9iamVjdCA9IG9iamVjdFtwXTtcblxuXHRcdFx0aWYgKCFpc09iaihvYmplY3QpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0aGFzKG9iamVjdCwgcGF0aCkge1xuXHRcdGlmICghaXNPYmoob2JqZWN0KSB8fCB0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRjb25zdCBwYXRoQXJyYXkgPSBnZXRQYXRoU2VnbWVudHMocGF0aCk7XG5cdFx0aWYgKHBhdGhBcnJheS5sZW5ndGggPT09IDApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby1mb3ItbG9vcFxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aEFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoaXNPYmoob2JqZWN0KSkge1xuXHRcdFx0XHRpZiAoIShwYXRoQXJyYXlbaV0gaW4gb2JqZWN0KSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9iamVjdCA9IG9iamVjdFtwYXRoQXJyYXlbaV1dO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZwID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuXHRmcy5hY2Nlc3MoZnAsIGVyciA9PiB7XG5cdFx0cmVzb2x2ZSghZXJyKTtcblx0fSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMuc3luYyA9IGZwID0+IHtcblx0dHJ5IHtcblx0XHRmcy5hY2Nlc3NTeW5jKGZwKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBwVHJ5ID0gKGZuLCAuLi5hcmd1bWVudHNfKSA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcblx0cmVzb2x2ZShmbiguLi5hcmd1bWVudHNfKSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwVHJ5O1xuLy8gVE9ETzogcmVtb3ZlIHRoaXMgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvblxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IHBUcnk7XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBwVHJ5ID0gcmVxdWlyZSgncC10cnknKTtcblxuY29uc3QgcExpbWl0ID0gY29uY3VycmVuY3kgPT4ge1xuXHRpZiAoISgoTnVtYmVyLmlzSW50ZWdlcihjb25jdXJyZW5jeSkgfHwgY29uY3VycmVuY3kgPT09IEluZmluaXR5KSAmJiBjb25jdXJyZW5jeSA+IDApKSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBjb25jdXJyZW5jeWAgdG8gYmUgYSBudW1iZXIgZnJvbSAxIGFuZCB1cCcpKTtcblx0fVxuXG5cdGNvbnN0IHF1ZXVlID0gW107XG5cdGxldCBhY3RpdmVDb3VudCA9IDA7XG5cblx0Y29uc3QgbmV4dCA9ICgpID0+IHtcblx0XHRhY3RpdmVDb3VudC0tO1xuXG5cdFx0aWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcblx0XHRcdHF1ZXVlLnNoaWZ0KCkoKTtcblx0XHR9XG5cdH07XG5cblx0Y29uc3QgcnVuID0gKGZuLCByZXNvbHZlLCAuLi5hcmdzKSA9PiB7XG5cdFx0YWN0aXZlQ291bnQrKztcblxuXHRcdGNvbnN0IHJlc3VsdCA9IHBUcnkoZm4sIC4uLmFyZ3MpO1xuXG5cdFx0cmVzb2x2ZShyZXN1bHQpO1xuXG5cdFx0cmVzdWx0LnRoZW4obmV4dCwgbmV4dCk7XG5cdH07XG5cblx0Y29uc3QgZW5xdWV1ZSA9IChmbiwgcmVzb2x2ZSwgLi4uYXJncykgPT4ge1xuXHRcdGlmIChhY3RpdmVDb3VudCA8IGNvbmN1cnJlbmN5KSB7XG5cdFx0XHRydW4oZm4sIHJlc29sdmUsIC4uLmFyZ3MpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRxdWV1ZS5wdXNoKHJ1bi5iaW5kKG51bGwsIGZuLCByZXNvbHZlLCAuLi5hcmdzKSk7XG5cdFx0fVxuXHR9O1xuXG5cdGNvbnN0IGdlbmVyYXRvciA9IChmbiwgLi4uYXJncykgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBlbnF1ZXVlKGZuLCByZXNvbHZlLCAuLi5hcmdzKSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGdlbmVyYXRvciwge1xuXHRcdGFjdGl2ZUNvdW50OiB7XG5cdFx0XHRnZXQ6ICgpID0+IGFjdGl2ZUNvdW50XG5cdFx0fSxcblx0XHRwZW5kaW5nQ291bnQ6IHtcblx0XHRcdGdldDogKCkgPT4gcXVldWUubGVuZ3RoXG5cdFx0fSxcblx0XHRjbGVhclF1ZXVlOiB7XG5cdFx0XHR2YWx1ZTogKCkgPT4ge1xuXHRcdFx0XHRxdWV1ZS5sZW5ndGggPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIGdlbmVyYXRvcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcExpbWl0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IHBMaW1pdDtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHBMaW1pdCA9IHJlcXVpcmUoJ3AtbGltaXQnKTtcblxuY2xhc3MgRW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKHZhbHVlKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdH1cbn1cblxuLy8gVGhlIGlucHV0IGNhbiBhbHNvIGJlIGEgcHJvbWlzZSwgc28gd2UgYFByb21pc2UucmVzb2x2ZSgpYCBpdFxuY29uc3QgdGVzdEVsZW1lbnQgPSAoZWwsIHRlc3RlcikgPT4gUHJvbWlzZS5yZXNvbHZlKGVsKS50aGVuKHRlc3Rlcik7XG5cbi8vIFRoZSBpbnB1dCBjYW4gYWxzbyBiZSBhIHByb21pc2UsIHNvIHdlIGBQcm9taXNlLmFsbCgpYCB0aGVtIGJvdGhcbmNvbnN0IGZpbmRlciA9IGVsID0+IFByb21pc2UuYWxsKGVsKS50aGVuKHZhbCA9PiB2YWxbMV0gPT09IHRydWUgJiYgUHJvbWlzZS5yZWplY3QobmV3IEVuZEVycm9yKHZhbFswXSkpKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoaXRlcmFibGUsIHRlc3Rlciwgb3B0cykgPT4ge1xuXHRvcHRzID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0Y29uY3VycmVuY3k6IEluZmluaXR5LFxuXHRcdHByZXNlcnZlT3JkZXI6IHRydWVcblx0fSwgb3B0cyk7XG5cblx0Y29uc3QgbGltaXQgPSBwTGltaXQob3B0cy5jb25jdXJyZW5jeSk7XG5cblx0Ly8gU3RhcnQgYWxsIHRoZSBwcm9taXNlcyBjb25jdXJyZW50bHkgd2l0aCBvcHRpb25hbCBsaW1pdFxuXHRjb25zdCBpdGVtcyA9IFsuLi5pdGVyYWJsZV0ubWFwKGVsID0+IFtlbCwgbGltaXQodGVzdEVsZW1lbnQsIGVsLCB0ZXN0ZXIpXSk7XG5cblx0Ly8gQ2hlY2sgdGhlIHByb21pc2VzIGVpdGhlciBzZXJpYWxseSBvciBjb25jdXJyZW50bHlcblx0Y29uc3QgY2hlY2tMaW1pdCA9IHBMaW1pdChvcHRzLnByZXNlcnZlT3JkZXIgPyAxIDogSW5maW5pdHkpO1xuXG5cdHJldHVybiBQcm9taXNlLmFsbChpdGVtcy5tYXAoZWwgPT4gY2hlY2tMaW1pdChmaW5kZXIsIGVsKSkpXG5cdFx0LnRoZW4oKCkgPT4ge30pXG5cdFx0LmNhdGNoKGVyciA9PiBlcnIgaW5zdGFuY2VvZiBFbmRFcnJvciA/IGVyci52YWx1ZSA6IFByb21pc2UucmVqZWN0KGVycikpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgncGF0aC1leGlzdHMnKTtcbmNvbnN0IHBMb2NhdGUgPSByZXF1aXJlKCdwLWxvY2F0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChpdGVyYWJsZSwgb3B0aW9ucykgPT4ge1xuXHRvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0Y3dkOiBwcm9jZXNzLmN3ZCgpXG5cdH0sIG9wdGlvbnMpO1xuXG5cdHJldHVybiBwTG9jYXRlKGl0ZXJhYmxlLCBlbCA9PiBwYXRoRXhpc3RzKHBhdGgucmVzb2x2ZShvcHRpb25zLmN3ZCwgZWwpKSwgb3B0aW9ucyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5zeW5jID0gKGl0ZXJhYmxlLCBvcHRpb25zKSA9PiB7XG5cdG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRjd2Q6IHByb2Nlc3MuY3dkKClcblx0fSwgb3B0aW9ucyk7XG5cblx0Zm9yIChjb25zdCBlbCBvZiBpdGVyYWJsZSkge1xuXHRcdGlmIChwYXRoRXhpc3RzLnN5bmMocGF0aC5yZXNvbHZlKG9wdGlvbnMuY3dkLCBlbCkpKSB7XG5cdFx0XHRyZXR1cm4gZWw7XG5cdFx0fVxuXHR9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IGxvY2F0ZVBhdGggPSByZXF1aXJlKCdsb2NhdGUtcGF0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmaWxlbmFtZSwgb3B0cyA9IHt9KSA9PiB7XG5cdGNvbnN0IHN0YXJ0RGlyID0gcGF0aC5yZXNvbHZlKG9wdHMuY3dkIHx8ICcnKTtcblx0Y29uc3Qge3Jvb3R9ID0gcGF0aC5wYXJzZShzdGFydERpcik7XG5cblx0Y29uc3QgZmlsZW5hbWVzID0gW10uY29uY2F0KGZpbGVuYW1lKTtcblxuXHRyZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG5cdFx0KGZ1bmN0aW9uIGZpbmQoZGlyKSB7XG5cdFx0XHRsb2NhdGVQYXRoKGZpbGVuYW1lcywge2N3ZDogZGlyfSkudGhlbihmaWxlID0+IHtcblx0XHRcdFx0aWYgKGZpbGUpIHtcblx0XHRcdFx0XHRyZXNvbHZlKHBhdGguam9pbihkaXIsIGZpbGUpKTtcblx0XHRcdFx0fSBlbHNlIGlmIChkaXIgPT09IHJvb3QpIHtcblx0XHRcdFx0XHRyZXNvbHZlKG51bGwpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZpbmQocGF0aC5kaXJuYW1lKGRpcikpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KShzdGFydERpcik7XG5cdH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMuc3luYyA9IChmaWxlbmFtZSwgb3B0cyA9IHt9KSA9PiB7XG5cdGxldCBkaXIgPSBwYXRoLnJlc29sdmUob3B0cy5jd2QgfHwgJycpO1xuXHRjb25zdCB7cm9vdH0gPSBwYXRoLnBhcnNlKGRpcik7XG5cblx0Y29uc3QgZmlsZW5hbWVzID0gW10uY29uY2F0KGZpbGVuYW1lKTtcblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG5cdHdoaWxlICh0cnVlKSB7XG5cdFx0Y29uc3QgZmlsZSA9IGxvY2F0ZVBhdGguc3luYyhmaWxlbmFtZXMsIHtjd2Q6IGRpcn0pO1xuXG5cdFx0aWYgKGZpbGUpIHtcblx0XHRcdHJldHVybiBwYXRoLmpvaW4oZGlyLCBmaWxlKTtcblx0XHR9XG5cblx0XHRpZiAoZGlyID09PSByb290KSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRkaXIgPSBwYXRoLmRpcm5hbWUoZGlyKTtcblx0fVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IGZpbmRVcCA9IHJlcXVpcmUoJ2ZpbmQtdXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc3luYyAoe2N3ZH0gPSB7fSkgPT4gZmluZFVwKCdwYWNrYWdlLmpzb24nLCB7Y3dkfSk7XG5tb2R1bGUuZXhwb3J0cy5zeW5jID0gKHtjd2R9ID0ge30pID0+IGZpbmRVcC5zeW5jKCdwYWNrYWdlLmpzb24nLCB7Y3dkfSk7XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuXG5jb25zdCBob21lZGlyID0gb3MuaG9tZWRpcigpO1xuY29uc3QgdG1wZGlyID0gb3MudG1wZGlyKCk7XG5jb25zdCB7ZW52fSA9IHByb2Nlc3M7XG5cbmNvbnN0IG1hY29zID0gbmFtZSA9PiB7XG5cdGNvbnN0IGxpYnJhcnkgPSBwYXRoLmpvaW4oaG9tZWRpciwgJ0xpYnJhcnknKTtcblxuXHRyZXR1cm4ge1xuXHRcdGRhdGE6IHBhdGguam9pbihsaWJyYXJ5LCAnQXBwbGljYXRpb24gU3VwcG9ydCcsIG5hbWUpLFxuXHRcdGNvbmZpZzogcGF0aC5qb2luKGxpYnJhcnksICdQcmVmZXJlbmNlcycsIG5hbWUpLFxuXHRcdGNhY2hlOiBwYXRoLmpvaW4obGlicmFyeSwgJ0NhY2hlcycsIG5hbWUpLFxuXHRcdGxvZzogcGF0aC5qb2luKGxpYnJhcnksICdMb2dzJywgbmFtZSksXG5cdFx0dGVtcDogcGF0aC5qb2luKHRtcGRpciwgbmFtZSlcblx0fTtcbn07XG5cbmNvbnN0IHdpbmRvd3MgPSBuYW1lID0+IHtcblx0Y29uc3QgYXBwRGF0YSA9IGVudi5BUFBEQVRBIHx8IHBhdGguam9pbihob21lZGlyLCAnQXBwRGF0YScsICdSb2FtaW5nJyk7XG5cdGNvbnN0IGxvY2FsQXBwRGF0YSA9IGVudi5MT0NBTEFQUERBVEEgfHwgcGF0aC5qb2luKGhvbWVkaXIsICdBcHBEYXRhJywgJ0xvY2FsJyk7XG5cblx0cmV0dXJuIHtcblx0XHQvLyBEYXRhL2NvbmZpZy9jYWNoZS9sb2cgYXJlIGludmVudGVkIGJ5IG1lIGFzIFdpbmRvd3MgaXNuJ3Qgb3BpbmlvbmF0ZWQgYWJvdXQgdGhpc1xuXHRcdGRhdGE6IHBhdGguam9pbihsb2NhbEFwcERhdGEsIG5hbWUsICdEYXRhJyksXG5cdFx0Y29uZmlnOiBwYXRoLmpvaW4oYXBwRGF0YSwgbmFtZSwgJ0NvbmZpZycpLFxuXHRcdGNhY2hlOiBwYXRoLmpvaW4obG9jYWxBcHBEYXRhLCBuYW1lLCAnQ2FjaGUnKSxcblx0XHRsb2c6IHBhdGguam9pbihsb2NhbEFwcERhdGEsIG5hbWUsICdMb2cnKSxcblx0XHR0ZW1wOiBwYXRoLmpvaW4odG1wZGlyLCBuYW1lKVxuXHR9O1xufTtcblxuLy8gaHR0cHM6Ly9zcGVjaWZpY2F0aW9ucy5mcmVlZGVza3RvcC5vcmcvYmFzZWRpci1zcGVjL2Jhc2VkaXItc3BlYy1sYXRlc3QuaHRtbFxuY29uc3QgbGludXggPSBuYW1lID0+IHtcblx0Y29uc3QgdXNlcm5hbWUgPSBwYXRoLmJhc2VuYW1lKGhvbWVkaXIpO1xuXG5cdHJldHVybiB7XG5cdFx0ZGF0YTogcGF0aC5qb2luKGVudi5YREdfREFUQV9IT01FIHx8IHBhdGguam9pbihob21lZGlyLCAnLmxvY2FsJywgJ3NoYXJlJyksIG5hbWUpLFxuXHRcdGNvbmZpZzogcGF0aC5qb2luKGVudi5YREdfQ09ORklHX0hPTUUgfHwgcGF0aC5qb2luKGhvbWVkaXIsICcuY29uZmlnJyksIG5hbWUpLFxuXHRcdGNhY2hlOiBwYXRoLmpvaW4oZW52LlhER19DQUNIRV9IT01FIHx8IHBhdGguam9pbihob21lZGlyLCAnLmNhY2hlJyksIG5hbWUpLFxuXHRcdC8vIGh0dHBzOi8vd2lraS5kZWJpYW4ub3JnL1hER0Jhc2VEaXJlY3RvcnlTcGVjaWZpY2F0aW9uI3N0YXRlXG5cdFx0bG9nOiBwYXRoLmpvaW4oZW52LlhER19TVEFURV9IT01FIHx8IHBhdGguam9pbihob21lZGlyLCAnLmxvY2FsJywgJ3N0YXRlJyksIG5hbWUpLFxuXHRcdHRlbXA6IHBhdGguam9pbih0bXBkaXIsIHVzZXJuYW1lLCBuYW1lKVxuXHR9O1xufTtcblxuY29uc3QgZW52UGF0aHMgPSAobmFtZSwgb3B0aW9ucykgPT4ge1xuXHRpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2YgbmFtZX1gKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtzdWZmaXg6ICdub2RlanMnfSwgb3B0aW9ucyk7XG5cblx0aWYgKG9wdGlvbnMuc3VmZml4KSB7XG5cdFx0Ly8gQWRkIHN1ZmZpeCB0byBwcmV2ZW50IHBvc3NpYmxlIGNvbmZsaWN0IHdpdGggbmF0aXZlIGFwcHNcblx0XHRuYW1lICs9IGAtJHtvcHRpb25zLnN1ZmZpeH1gO1xuXHR9XG5cblx0aWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG5cdFx0cmV0dXJuIG1hY29zKG5hbWUpO1xuXHR9XG5cblx0aWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcblx0XHRyZXR1cm4gd2luZG93cyhuYW1lKTtcblx0fVxuXG5cdHJldHVybiBsaW51eChuYW1lKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW52UGF0aHM7XG4vLyBUT0RPOiBSZW1vdmUgdGhpcyBmb3IgdGhlIG5leHQgbWFqb3IgcmVsZWFzZVxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGVudlBhdGhzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBDT05TVFMgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTk9PUCA9IGV4cG9ydHMuTElNSVRfRklMRVNfREVTQ1JJUFRPUlMgPSBleHBvcnRzLkxJTUlUX0JBU0VOQU1FX0xFTkdUSCA9IGV4cG9ydHMuSVNfVVNFUl9ST09UID0gZXhwb3J0cy5JU19QT1NJWCA9IGV4cG9ydHMuREVGQVVMVF9USU1FT1VUX1NZTkMgPSBleHBvcnRzLkRFRkFVTFRfVElNRU9VVF9BU1lOQyA9IGV4cG9ydHMuREVGQVVMVF9XUklURV9PUFRJT05TID0gZXhwb3J0cy5ERUZBVUxUX1JFQURfT1BUSU9OUyA9IGV4cG9ydHMuREVGQVVMVF9GT0xERVJfTU9ERSA9IGV4cG9ydHMuREVGQVVMVF9GSUxFX01PREUgPSBleHBvcnRzLkRFRkFVTFRfRU5DT0RJTkcgPSB2b2lkIDA7XG5jb25zdCBERUZBVUxUX0VOQ09ESU5HID0gJ3V0ZjgnO1xuZXhwb3J0cy5ERUZBVUxUX0VOQ09ESU5HID0gREVGQVVMVF9FTkNPRElORztcbmNvbnN0IERFRkFVTFRfRklMRV9NT0RFID0gMG82NjY7XG5leHBvcnRzLkRFRkFVTFRfRklMRV9NT0RFID0gREVGQVVMVF9GSUxFX01PREU7XG5jb25zdCBERUZBVUxUX0ZPTERFUl9NT0RFID0gMG83Nzc7XG5leHBvcnRzLkRFRkFVTFRfRk9MREVSX01PREUgPSBERUZBVUxUX0ZPTERFUl9NT0RFO1xuY29uc3QgREVGQVVMVF9SRUFEX09QVElPTlMgPSB7fTtcbmV4cG9ydHMuREVGQVVMVF9SRUFEX09QVElPTlMgPSBERUZBVUxUX1JFQURfT1BUSU9OUztcbmNvbnN0IERFRkFVTFRfV1JJVEVfT1BUSU9OUyA9IHt9O1xuZXhwb3J0cy5ERUZBVUxUX1dSSVRFX09QVElPTlMgPSBERUZBVUxUX1dSSVRFX09QVElPTlM7XG5jb25zdCBERUZBVUxUX1RJTUVPVVRfQVNZTkMgPSA1MDAwO1xuZXhwb3J0cy5ERUZBVUxUX1RJTUVPVVRfQVNZTkMgPSBERUZBVUxUX1RJTUVPVVRfQVNZTkM7XG5jb25zdCBERUZBVUxUX1RJTUVPVVRfU1lOQyA9IDEwMDtcbmV4cG9ydHMuREVGQVVMVF9USU1FT1VUX1NZTkMgPSBERUZBVUxUX1RJTUVPVVRfU1lOQztcbmNvbnN0IElTX1BPU0lYID0gISFwcm9jZXNzLmdldHVpZDtcbmV4cG9ydHMuSVNfUE9TSVggPSBJU19QT1NJWDtcbmNvbnN0IElTX1VTRVJfUk9PVCA9IHByb2Nlc3MuZ2V0dWlkID8gIXByb2Nlc3MuZ2V0dWlkKCkgOiBmYWxzZTtcbmV4cG9ydHMuSVNfVVNFUl9ST09UID0gSVNfVVNFUl9ST09UO1xuY29uc3QgTElNSVRfQkFTRU5BTUVfTEVOR1RIID0gMTI4OyAvL1RPRE86IGZldGNoIHRoZSByZWFsIGxpbWl0IGZyb20gdGhlIGZpbGVzeXN0ZW0gLy9UT0RPOiBmZXRjaCB0aGUgd2hvbGUtcGF0aCBsZW5ndGggbGltaXQgdG9vXG5leHBvcnRzLkxJTUlUX0JBU0VOQU1FX0xFTkdUSCA9IExJTUlUX0JBU0VOQU1FX0xFTkdUSDtcbmNvbnN0IExJTUlUX0ZJTEVTX0RFU0NSSVBUT1JTID0gMTAwMDA7IC8vVE9ETzogZmV0Y2ggdGhlIHJlYWwgbGltaXQgZnJvbSB0aGUgZmlsZXN5c3RlbVxuZXhwb3J0cy5MSU1JVF9GSUxFU19ERVNDUklQVE9SUyA9IExJTUlUX0ZJTEVTX0RFU0NSSVBUT1JTO1xuY29uc3QgTk9PUCA9ICgpID0+IHsgfTtcbmV4cG9ydHMuTk9PUCA9IE5PT1A7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIElNUE9SVCAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hdHRlbXB0aWZ5U3luYyA9IGV4cG9ydHMuYXR0ZW1wdGlmeUFzeW5jID0gdm9pZCAwO1xuY29uc3QgY29uc3RzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RzXCIpO1xuLyogQVRURU1QVElGWSAqL1xuLy9UT0RPOiBNYXliZSBwdWJsaXNoIHRoaXMgYXMgYSBzdGFuZGFsb25lIHBhY2thZ2Vcbi8vRklYTUU6IFRoZSB0eXBlIGNhc3RpbmdzIGhlcmUgYXJlbid0IGV4YWN0bHkgY29ycmVjdFxuY29uc3QgYXR0ZW1wdGlmeUFzeW5jID0gKGZuLCBvbkVycm9yID0gY29uc3RzXzEuTk9PUCkgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykuY2F0Y2gob25FcnJvcik7XG4gICAgfTtcbn07XG5leHBvcnRzLmF0dGVtcHRpZnlBc3luYyA9IGF0dGVtcHRpZnlBc3luYztcbmNvbnN0IGF0dGVtcHRpZnlTeW5jID0gKGZuLCBvbkVycm9yID0gY29uc3RzXzEuTk9PUCkgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5leHBvcnRzLmF0dGVtcHRpZnlTeW5jID0gYXR0ZW1wdGlmeVN5bmM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIElNUE9SVCAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29uc3RzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RzXCIpO1xuLyogRlMgSEFORExFUlMgKi9cbmNvbnN0IEhhbmRsZXJzID0ge1xuICAgIGlzQ2hhbmdlRXJyb3JPazogKGVycm9yKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY29kZSB9ID0gZXJyb3I7XG4gICAgICAgIGlmIChjb2RlID09PSAnRU5PU1lTJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoIWNvbnN0c18xLklTX1VTRVJfUk9PVCAmJiAoY29kZSA9PT0gJ0VJTlZBTCcgfHwgY29kZSA9PT0gJ0VQRVJNJykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgaXNSZXRyaWFibGVFcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY29kZSB9ID0gZXJyb3I7XG4gICAgICAgIGlmIChjb2RlID09PSAnRU1GSUxFJyB8fCBjb2RlID09PSAnRU5GSUxFJyB8fCBjb2RlID09PSAnRUFHQUlOJyB8fCBjb2RlID09PSAnRUJVU1knIHx8IGNvZGUgPT09ICdFQUNDRVNTJyB8fCBjb2RlID09PSAnRUFDQ1MnIHx8IGNvZGUgPT09ICdFUEVSTScpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgb25DaGFuZ2VFcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgIGlmIChIYW5kbGVycy5pc0NoYW5nZUVycm9yT2soZXJyb3IpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59O1xuLyogRVhQT1JUICovXG5leHBvcnRzLmRlZmF1bHQgPSBIYW5kbGVycztcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogSU1QT1JUICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb25zdHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdHNcIik7XG4vKiBSRVRSWUlGWSBRVUVVRSAqL1xuY29uc3QgUmV0cnlmeVF1ZXVlID0ge1xuICAgIGludGVydmFsOiAyNSxcbiAgICBpbnRlcnZhbElkOiB1bmRlZmluZWQsXG4gICAgbGltaXQ6IGNvbnN0c18xLkxJTUlUX0ZJTEVTX0RFU0NSSVBUT1JTLFxuICAgIHF1ZXVlQWN0aXZlOiBuZXcgU2V0KCksXG4gICAgcXVldWVXYWl0aW5nOiBuZXcgU2V0KCksXG4gICAgaW5pdDogKCkgPT4ge1xuICAgICAgICBpZiAoUmV0cnlmeVF1ZXVlLmludGVydmFsSWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIFJldHJ5ZnlRdWV1ZS5pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoUmV0cnlmeVF1ZXVlLnRpY2ssIFJldHJ5ZnlRdWV1ZS5pbnRlcnZhbCk7XG4gICAgfSxcbiAgICByZXNldDogKCkgPT4ge1xuICAgICAgICBpZiAoIVJldHJ5ZnlRdWV1ZS5pbnRlcnZhbElkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjbGVhckludGVydmFsKFJldHJ5ZnlRdWV1ZS5pbnRlcnZhbElkKTtcbiAgICAgICAgZGVsZXRlIFJldHJ5ZnlRdWV1ZS5pbnRlcnZhbElkO1xuICAgIH0sXG4gICAgYWRkOiAoZm4pID0+IHtcbiAgICAgICAgUmV0cnlmeVF1ZXVlLnF1ZXVlV2FpdGluZy5hZGQoZm4pO1xuICAgICAgICBpZiAoUmV0cnlmeVF1ZXVlLnF1ZXVlQWN0aXZlLnNpemUgPCAoUmV0cnlmeVF1ZXVlLmxpbWl0IC8gMikpIHsgLy8gQWN0aXZlIHF1ZXVlIG5vdCB1bmRlciBwcmVhc3N1cmUsIGV4ZWN1dGluZyBpbW1lZGlhdGVseVxuICAgICAgICAgICAgUmV0cnlmeVF1ZXVlLnRpY2soKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFJldHJ5ZnlRdWV1ZS5pbml0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZTogKGZuKSA9PiB7XG4gICAgICAgIFJldHJ5ZnlRdWV1ZS5xdWV1ZVdhaXRpbmcuZGVsZXRlKGZuKTtcbiAgICAgICAgUmV0cnlmeVF1ZXVlLnF1ZXVlQWN0aXZlLmRlbGV0ZShmbik7XG4gICAgfSxcbiAgICBzY2hlZHVsZTogKCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4gUmV0cnlmeVF1ZXVlLnJlbW92ZShyZXNvbHZlcik7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlciA9ICgpID0+IHJlc29sdmUoY2xlYW51cCk7XG4gICAgICAgICAgICBSZXRyeWZ5UXVldWUuYWRkKHJlc29sdmVyKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICB0aWNrOiAoKSA9PiB7XG4gICAgICAgIGlmIChSZXRyeWZ5UXVldWUucXVldWVBY3RpdmUuc2l6ZSA+PSBSZXRyeWZ5UXVldWUubGltaXQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghUmV0cnlmeVF1ZXVlLnF1ZXVlV2FpdGluZy5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIFJldHJ5ZnlRdWV1ZS5yZXNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGZuIG9mIFJldHJ5ZnlRdWV1ZS5xdWV1ZVdhaXRpbmcpIHtcbiAgICAgICAgICAgIGlmIChSZXRyeWZ5UXVldWUucXVldWVBY3RpdmUuc2l6ZSA+PSBSZXRyeWZ5UXVldWUubGltaXQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBSZXRyeWZ5UXVldWUucXVldWVXYWl0aW5nLmRlbGV0ZShmbik7XG4gICAgICAgICAgICBSZXRyeWZ5UXVldWUucXVldWVBY3RpdmUuYWRkKGZuKTtcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyogRVhQT1JUICovXG5leHBvcnRzLmRlZmF1bHQgPSBSZXRyeWZ5UXVldWU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIElNUE9SVCAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXRyeWlmeVN5bmMgPSBleHBvcnRzLnJldHJ5aWZ5QXN5bmMgPSB2b2lkIDA7XG5jb25zdCByZXRyeWlmeV9xdWV1ZV8xID0gcmVxdWlyZShcIi4vcmV0cnlpZnlfcXVldWVcIik7XG4vKiBSRVRSWUlGWSAqL1xuY29uc3QgcmV0cnlpZnlBc3luYyA9IChmbiwgaXNSZXRyaWFibGVFcnJvcikgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGltZXN0YW1wKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhdHRlbXB0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHJ5aWZ5X3F1ZXVlXzEuZGVmYXVsdC5zY2hlZHVsZSgpLnRoZW4oY2xlYW51cCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKERhdGUubm93KCkgPj0gdGltZXN0YW1wKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1JldHJpYWJsZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsYXkgPSBNYXRoLnJvdW5kKDEwMCArICg0MDAgKiBNYXRoLnJhbmRvbSgpKSksIGRlbGF5UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGF5UHJvbWlzZS50aGVuKCgpID0+IGF0dGVtcHQuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG59O1xuZXhwb3J0cy5yZXRyeWlmeUFzeW5jID0gcmV0cnlpZnlBc3luYztcbmNvbnN0IHJldHJ5aWZ5U3luYyA9IChmbiwgaXNSZXRyaWFibGVFcnJvcikgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGltZXN0YW1wKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhdHRlbXB0KCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKERhdGUubm93KCkgPiB0aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIGlmIChpc1JldHJpYWJsZUVycm9yKGVycm9yKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dGVtcHQuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG59O1xuZXhwb3J0cy5yZXRyeWlmeVN5bmMgPSByZXRyeWlmeVN5bmM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIElNUE9SVCAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IGF0dGVtcHRpZnlfMSA9IHJlcXVpcmUoXCIuL2F0dGVtcHRpZnlcIik7XG5jb25zdCBmc19oYW5kbGVyc18xID0gcmVxdWlyZShcIi4vZnNfaGFuZGxlcnNcIik7XG5jb25zdCByZXRyeWlmeV8xID0gcmVxdWlyZShcIi4vcmV0cnlpZnlcIik7XG4vKiBGUyAqL1xuY29uc3QgRlMgPSB7XG4gICAgY2htb2RBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMuY2htb2QpLCBmc19oYW5kbGVyc18xLmRlZmF1bHQub25DaGFuZ2VFcnJvciksXG4gICAgY2hvd25BdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMuY2hvd24pLCBmc19oYW5kbGVyc18xLmRlZmF1bHQub25DaGFuZ2VFcnJvciksXG4gICAgY2xvc2VBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMuY2xvc2UpKSxcbiAgICBmc3luY0F0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5mc3luYykpLFxuICAgIG1rZGlyQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLm1rZGlyKSksXG4gICAgcmVhbHBhdGhBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMucmVhbHBhdGgpKSxcbiAgICBzdGF0QXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLnN0YXQpKSxcbiAgICB1bmxpbmtBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMudW5saW5rKSksXG4gICAgY2xvc2VSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMuY2xvc2UpLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgZnN5bmNSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMuZnN5bmMpLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgb3BlblJldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5vcGVuKSwgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIHJlYWRGaWxlUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLnJlYWRGaWxlKSwgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIHJlbmFtZVJldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5yZW5hbWUpLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgc3RhdFJldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5zdGF0KSwgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIHdyaXRlUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLndyaXRlKSwgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIGNobW9kU3luY0F0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5U3luYyhmcy5jaG1vZFN5bmMsIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5vbkNoYW5nZUVycm9yKSxcbiAgICBjaG93blN5bmNBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeVN5bmMoZnMuY2hvd25TeW5jLCBmc19oYW5kbGVyc18xLmRlZmF1bHQub25DaGFuZ2VFcnJvciksXG4gICAgY2xvc2VTeW5jQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlTeW5jKGZzLmNsb3NlU3luYyksXG4gICAgbWtkaXJTeW5jQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlTeW5jKGZzLm1rZGlyU3luYyksXG4gICAgcmVhbHBhdGhTeW5jQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlTeW5jKGZzLnJlYWxwYXRoU3luYyksXG4gICAgc3RhdFN5bmNBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeVN5bmMoZnMuc3RhdFN5bmMpLFxuICAgIHVubGlua1N5bmNBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeVN5bmMoZnMudW5saW5rU3luYyksXG4gICAgY2xvc2VTeW5jUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlTeW5jKGZzLmNsb3NlU3luYywgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIGZzeW5jU3luY1JldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5U3luYyhmcy5mc3luY1N5bmMsIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICBvcGVuU3luY1JldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5U3luYyhmcy5vcGVuU3luYywgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIHJlYWRGaWxlU3luY1JldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5U3luYyhmcy5yZWFkRmlsZVN5bmMsIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICByZW5hbWVTeW5jUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlTeW5jKGZzLnJlbmFtZVN5bmMsIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICBzdGF0U3luY1JldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5U3luYyhmcy5zdGF0U3luYywgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIHdyaXRlU3luY1JldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5U3luYyhmcy53cml0ZVN5bmMsIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKVxufTtcbi8qIEVYUE9SVCAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gRlM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIExBTkcgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IExhbmcgPSB7XG4gICAgaXNGdW5jdGlvbjogKHgpID0+IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xuICAgIH0sXG4gICAgaXNTdHJpbmc6ICh4KSA9PiB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ3N0cmluZyc7XG4gICAgfSxcbiAgICBpc1VuZGVmaW5lZDogKHgpID0+IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAndW5kZWZpbmVkJztcbiAgICB9XG59O1xuLyogRVhQT1JUICovXG5leHBvcnRzLmRlZmF1bHQgPSBMYW5nO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBJTVBPUlQgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qIFZBUklBQkxFUyAqL1xuY29uc3QgUXVldWVzID0ge307XG4vKiBTQ0hFRFVMRVIgKi9cbi8vVE9ETzogTWF5YmUgcHVibGlzaCB0aGlzIGFzIGEgc3RhbmRhbG9uZSBwYWNrYWdlXG5jb25zdCBTY2hlZHVsZXIgPSB7XG4gICAgbmV4dDogKGlkKSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gUXVldWVzW2lkXTtcbiAgICAgICAgaWYgKCFxdWV1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcXVldWUuc2hpZnQoKTtcbiAgICAgICAgY29uc3Qgam9iID0gcXVldWVbMF07XG4gICAgICAgIGlmIChqb2IpIHtcbiAgICAgICAgICAgIGpvYigoKSA9PiBTY2hlZHVsZXIubmV4dChpZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIFF1ZXVlc1tpZF07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNjaGVkdWxlOiAoaWQpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgbGV0IHF1ZXVlID0gUXVldWVzW2lkXTtcbiAgICAgICAgICAgIGlmICghcXVldWUpXG4gICAgICAgICAgICAgICAgcXVldWUgPSBRdWV1ZXNbaWRdID0gW107XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKHJlc29sdmUpO1xuICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcmVzb2x2ZSgoKSA9PiBTY2hlZHVsZXIubmV4dChpZCkpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuLyogRVhQT1JUICovXG5leHBvcnRzLmRlZmF1bHQgPSBTY2hlZHVsZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIElNUE9SVCAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgY29uc3RzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RzXCIpO1xuY29uc3QgZnNfMSA9IHJlcXVpcmUoXCIuL2ZzXCIpO1xuLyogVEVNUCAqL1xuLy9UT0RPOiBNYXliZSBwdWJsaXNoIHRoaXMgYXMgYSBzdGFuZGFsb25lIHBhY2thZ2VcbmNvbnN0IFRlbXAgPSB7XG4gICAgc3RvcmU6IHt9LFxuICAgIGNyZWF0ZTogKGZpbGVQYXRoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJhbmRvbW5lc3MgPSBgMDAwMDAwJHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxNjc3NzIxNSkudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTYpLCAvLyA2IHJhbmRvbS1lbm91Z2ggaGV4IGNoYXJhY3RlcnNcbiAgICAgICAgdGltZXN0YW1wID0gRGF0ZS5ub3coKS50b1N0cmluZygpLnNsaWNlKC0xMCksIC8vIDEwIHByZWNpc2UgdGltZXN0YW1wIGRpZ2l0c1xuICAgICAgICBwcmVmaXggPSAndG1wLScsIHN1ZmZpeCA9IGAuJHtwcmVmaXh9JHt0aW1lc3RhbXB9JHtyYW5kb21uZXNzfWAsIHRlbXBQYXRoID0gYCR7ZmlsZVBhdGh9JHtzdWZmaXh9YDtcbiAgICAgICAgcmV0dXJuIHRlbXBQYXRoO1xuICAgIH0sXG4gICAgZ2V0OiAoZmlsZVBhdGgsIGNyZWF0b3IsIHB1cmdlID0gdHJ1ZSkgPT4ge1xuICAgICAgICBjb25zdCB0ZW1wUGF0aCA9IFRlbXAudHJ1bmNhdGUoY3JlYXRvcihmaWxlUGF0aCkpO1xuICAgICAgICBpZiAodGVtcFBhdGggaW4gVGVtcC5zdG9yZSlcbiAgICAgICAgICAgIHJldHVybiBUZW1wLmdldChmaWxlUGF0aCwgY3JlYXRvciwgcHVyZ2UpOyAvLyBDb2xsaXNpb24gZm91bmQsIHRyeSBhZ2FpblxuICAgICAgICBUZW1wLnN0b3JlW3RlbXBQYXRoXSA9IHB1cmdlO1xuICAgICAgICBjb25zdCBkaXNwb3NlciA9ICgpID0+IGRlbGV0ZSBUZW1wLnN0b3JlW3RlbXBQYXRoXTtcbiAgICAgICAgcmV0dXJuIFt0ZW1wUGF0aCwgZGlzcG9zZXJdO1xuICAgIH0sXG4gICAgcHVyZ2U6IChmaWxlUGF0aCkgPT4ge1xuICAgICAgICBpZiAoIVRlbXAuc3RvcmVbZmlsZVBhdGhdKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBkZWxldGUgVGVtcC5zdG9yZVtmaWxlUGF0aF07XG4gICAgICAgIGZzXzEuZGVmYXVsdC51bmxpbmtBdHRlbXB0KGZpbGVQYXRoKTtcbiAgICB9LFxuICAgIHB1cmdlU3luYzogKGZpbGVQYXRoKSA9PiB7XG4gICAgICAgIGlmICghVGVtcC5zdG9yZVtmaWxlUGF0aF0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRlbGV0ZSBUZW1wLnN0b3JlW2ZpbGVQYXRoXTtcbiAgICAgICAgZnNfMS5kZWZhdWx0LnVubGlua1N5bmNBdHRlbXB0KGZpbGVQYXRoKTtcbiAgICB9LFxuICAgIHB1cmdlU3luY0FsbDogKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGZpbGVQYXRoIGluIFRlbXAuc3RvcmUpIHtcbiAgICAgICAgICAgIFRlbXAucHVyZ2VTeW5jKGZpbGVQYXRoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdHJ1bmNhdGU6IChmaWxlUGF0aCkgPT4ge1xuICAgICAgICBjb25zdCBiYXNlbmFtZSA9IHBhdGguYmFzZW5hbWUoZmlsZVBhdGgpO1xuICAgICAgICBpZiAoYmFzZW5hbWUubGVuZ3RoIDw9IGNvbnN0c18xLkxJTUlUX0JBU0VOQU1FX0xFTkdUSClcbiAgICAgICAgICAgIHJldHVybiBmaWxlUGF0aDsgLy9GSVhNRTogUm91Z2ggYW5kIHF1aWNrIGF0dGVtcHQgYXQgZGV0ZWN0aW5nIG9rIGxlbmd0aHNcbiAgICAgICAgY29uc3QgdHJ1bmNhYmxlID0gL14oXFwuPykoLio/KSgoPzpcXC5bXi5dKyk/KD86XFwudG1wLVxcZHsxMH1bYS1mMC05XXs2fSk/KSQvLmV4ZWMoYmFzZW5hbWUpO1xuICAgICAgICBpZiAoIXRydW5jYWJsZSlcbiAgICAgICAgICAgIHJldHVybiBmaWxlUGF0aDsgLy9GSVhNRTogTm8gdHJ1bmNhYmxlIHBhcnQgZGV0ZWN0ZWQsIGNhbid0IHJlYWxseSBkbyBtdWNoIHdpdGhvdXQgYWxzbyBjaGFuZ2luZyB0aGUgcGFyZW50IHBhdGgsIHdoaWNoIGlzIHVuc2FmZSwgaG9waW5nIGZvciB0aGUgYmVzdCBoZXJlXG4gICAgICAgIGNvbnN0IHRydW5jYXRpb25MZW5ndGggPSBiYXNlbmFtZS5sZW5ndGggLSBjb25zdHNfMS5MSU1JVF9CQVNFTkFNRV9MRU5HVEg7XG4gICAgICAgIHJldHVybiBgJHtmaWxlUGF0aC5zbGljZSgwLCAtYmFzZW5hbWUubGVuZ3RoKX0ke3RydW5jYWJsZVsxXX0ke3RydW5jYWJsZVsyXS5zbGljZSgwLCAtdHJ1bmNhdGlvbkxlbmd0aCl9JHt0cnVuY2FibGVbM119YDsgLy9GSVhNRTogVGhlIHRydW5jYWJsZSBwYXJ0IG1pZ2h0IGJlIHNob3J0ZXIgdGhhbiBuZWVkZWQgaGVyZVxuICAgIH1cbn07XG4vKiBJTklUICovXG5wcm9jZXNzLm9uKCdleGl0JywgVGVtcC5wdXJnZVN5bmNBbGwpOyAvLyBFbnN1cmluZyBwdXJnZWFibGUgdGVtcCBmaWxlcyBhcmUgcHVyZ2VkIG9uIGV4aXRcbi8qIEVYUE9SVCAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gVGVtcDtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogSU1QT1JUICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndyaXRlRmlsZVN5bmMgPSBleHBvcnRzLndyaXRlRmlsZSA9IGV4cG9ydHMucmVhZEZpbGVTeW5jID0gZXhwb3J0cy5yZWFkRmlsZSA9IHZvaWQgMDtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IGNvbnN0c18xID0gcmVxdWlyZShcIi4vY29uc3RzXCIpO1xuY29uc3QgZnNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2ZzXCIpO1xuY29uc3QgbGFuZ18xID0gcmVxdWlyZShcIi4vdXRpbHMvbGFuZ1wiKTtcbmNvbnN0IHNjaGVkdWxlcl8xID0gcmVxdWlyZShcIi4vdXRpbHMvc2NoZWR1bGVyXCIpO1xuY29uc3QgdGVtcF8xID0gcmVxdWlyZShcIi4vdXRpbHMvdGVtcFwiKTtcbmZ1bmN0aW9uIHJlYWRGaWxlKGZpbGVQYXRoLCBvcHRpb25zID0gY29uc3RzXzEuREVGQVVMVF9SRUFEX09QVElPTlMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGxhbmdfMS5kZWZhdWx0LmlzU3RyaW5nKG9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gcmVhZEZpbGUoZmlsZVBhdGgsIHsgZW5jb2Rpbmc6IG9wdGlvbnMgfSk7XG4gICAgY29uc3QgdGltZW91dCA9IERhdGUubm93KCkgKyAoKF9hID0gb3B0aW9ucy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb25zdHNfMS5ERUZBVUxUX1RJTUVPVVRfQVNZTkMpO1xuICAgIHJldHVybiBmc18xLmRlZmF1bHQucmVhZEZpbGVSZXRyeSh0aW1lb3V0KShmaWxlUGF0aCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLnJlYWRGaWxlID0gcmVhZEZpbGU7XG47XG5mdW5jdGlvbiByZWFkRmlsZVN5bmMoZmlsZVBhdGgsIG9wdGlvbnMgPSBjb25zdHNfMS5ERUZBVUxUX1JFQURfT1BUSU9OUykge1xuICAgIHZhciBfYTtcbiAgICBpZiAobGFuZ18xLmRlZmF1bHQuaXNTdHJpbmcob3B0aW9ucykpXG4gICAgICAgIHJldHVybiByZWFkRmlsZVN5bmMoZmlsZVBhdGgsIHsgZW5jb2Rpbmc6IG9wdGlvbnMgfSk7XG4gICAgY29uc3QgdGltZW91dCA9IERhdGUubm93KCkgKyAoKF9hID0gb3B0aW9ucy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb25zdHNfMS5ERUZBVUxUX1RJTUVPVVRfU1lOQyk7XG4gICAgcmV0dXJuIGZzXzEuZGVmYXVsdC5yZWFkRmlsZVN5bmNSZXRyeSh0aW1lb3V0KShmaWxlUGF0aCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLnJlYWRGaWxlU3luYyA9IHJlYWRGaWxlU3luYztcbjtcbmNvbnN0IHdyaXRlRmlsZSA9IChmaWxlUGF0aCwgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgICBpZiAobGFuZ18xLmRlZmF1bHQuaXNGdW5jdGlvbihvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIHdyaXRlRmlsZShmaWxlUGF0aCwgZGF0YSwgY29uc3RzXzEuREVGQVVMVF9XUklURV9PUFRJT05TLCBvcHRpb25zKTtcbiAgICBjb25zdCBwcm9taXNlID0gd3JpdGVGaWxlQXN5bmMoZmlsZVBhdGgsIGRhdGEsIG9wdGlvbnMpO1xuICAgIGlmIChjYWxsYmFjaylcbiAgICAgICAgcHJvbWlzZS50aGVuKGNhbGxiYWNrLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59O1xuZXhwb3J0cy53cml0ZUZpbGUgPSB3cml0ZUZpbGU7XG5jb25zdCB3cml0ZUZpbGVBc3luYyA9IGFzeW5jIChmaWxlUGF0aCwgZGF0YSwgb3B0aW9ucyA9IGNvbnN0c18xLkRFRkFVTFRfV1JJVEVfT1BUSU9OUykgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAobGFuZ18xLmRlZmF1bHQuaXNTdHJpbmcob3B0aW9ucykpXG4gICAgICAgIHJldHVybiB3cml0ZUZpbGVBc3luYyhmaWxlUGF0aCwgZGF0YSwgeyBlbmNvZGluZzogb3B0aW9ucyB9KTtcbiAgICBjb25zdCB0aW1lb3V0ID0gRGF0ZS5ub3coKSArICgoX2EgPSBvcHRpb25zLnRpbWVvdXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbnN0c18xLkRFRkFVTFRfVElNRU9VVF9BU1lOQyk7XG4gICAgbGV0IHNjaGVkdWxlckN1c3RvbURpc3Bvc2VyID0gbnVsbCwgc2NoZWR1bGVyRGlzcG9zZXIgPSBudWxsLCB0ZW1wRGlzcG9zZXIgPSBudWxsLCB0ZW1wUGF0aCA9IG51bGwsIGZkID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgICBpZiAob3B0aW9ucy5zY2hlZHVsZSlcbiAgICAgICAgICAgIHNjaGVkdWxlckN1c3RvbURpc3Bvc2VyID0gYXdhaXQgb3B0aW9ucy5zY2hlZHVsZShmaWxlUGF0aCk7XG4gICAgICAgIHNjaGVkdWxlckRpc3Bvc2VyID0gYXdhaXQgc2NoZWR1bGVyXzEuZGVmYXVsdC5zY2hlZHVsZShmaWxlUGF0aCk7XG4gICAgICAgIGZpbGVQYXRoID0gYXdhaXQgZnNfMS5kZWZhdWx0LnJlYWxwYXRoQXR0ZW1wdChmaWxlUGF0aCkgfHwgZmlsZVBhdGg7XG4gICAgICAgIFt0ZW1wUGF0aCwgdGVtcERpc3Bvc2VyXSA9IHRlbXBfMS5kZWZhdWx0LmdldChmaWxlUGF0aCwgb3B0aW9ucy50bXBDcmVhdGUgfHwgdGVtcF8xLmRlZmF1bHQuY3JlYXRlLCAhKG9wdGlvbnMudG1wUHVyZ2UgPT09IGZhbHNlKSk7XG4gICAgICAgIGNvbnN0IHVzZVN0YXRDaG93biA9IGNvbnN0c18xLklTX1BPU0lYICYmIGxhbmdfMS5kZWZhdWx0LmlzVW5kZWZpbmVkKG9wdGlvbnMuY2hvd24pLCB1c2VTdGF0TW9kZSA9IGxhbmdfMS5kZWZhdWx0LmlzVW5kZWZpbmVkKG9wdGlvbnMubW9kZSk7XG4gICAgICAgIGlmICh1c2VTdGF0Q2hvd24gfHwgdXNlU3RhdE1vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXQgPSBhd2FpdCBmc18xLmRlZmF1bHQuc3RhdEF0dGVtcHQoZmlsZVBhdGgpO1xuICAgICAgICAgICAgaWYgKHN0YXQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICAgICAgaWYgKHVzZVN0YXRDaG93bilcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jaG93biA9IHsgdWlkOiBzdGF0LnVpZCwgZ2lkOiBzdGF0LmdpZCB9O1xuICAgICAgICAgICAgICAgIGlmICh1c2VTdGF0TW9kZSlcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tb2RlID0gc3RhdC5tb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBwYXRoLmRpcm5hbWUoZmlsZVBhdGgpO1xuICAgICAgICBhd2FpdCBmc18xLmRlZmF1bHQubWtkaXJBdHRlbXB0KHBhcmVudFBhdGgsIHtcbiAgICAgICAgICAgIG1vZGU6IGNvbnN0c18xLkRFRkFVTFRfRk9MREVSX01PREUsXG4gICAgICAgICAgICByZWN1cnNpdmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGZkID0gYXdhaXQgZnNfMS5kZWZhdWx0Lm9wZW5SZXRyeSh0aW1lb3V0KSh0ZW1wUGF0aCwgJ3cnLCBvcHRpb25zLm1vZGUgfHwgY29uc3RzXzEuREVGQVVMVF9GSUxFX01PREUpO1xuICAgICAgICBpZiAob3B0aW9ucy50bXBDcmVhdGVkKVxuICAgICAgICAgICAgb3B0aW9ucy50bXBDcmVhdGVkKHRlbXBQYXRoKTtcbiAgICAgICAgaWYgKGxhbmdfMS5kZWZhdWx0LmlzU3RyaW5nKGRhdGEpKSB7XG4gICAgICAgICAgICBhd2FpdCBmc18xLmRlZmF1bHQud3JpdGVSZXRyeSh0aW1lb3V0KShmZCwgZGF0YSwgMCwgb3B0aW9ucy5lbmNvZGluZyB8fCBjb25zdHNfMS5ERUZBVUxUX0VOQ09ESU5HKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbGFuZ18xLmRlZmF1bHQuaXNVbmRlZmluZWQoZGF0YSkpIHtcbiAgICAgICAgICAgIGF3YWl0IGZzXzEuZGVmYXVsdC53cml0ZVJldHJ5KHRpbWVvdXQpKGZkLCBkYXRhLCAwLCBkYXRhLmxlbmd0aCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZnN5bmMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5mc3luY1dhaXQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZnNfMS5kZWZhdWx0LmZzeW5jUmV0cnkodGltZW91dCkoZmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZnNfMS5kZWZhdWx0LmZzeW5jQXR0ZW1wdChmZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZnNfMS5kZWZhdWx0LmNsb3NlUmV0cnkodGltZW91dCkoZmQpO1xuICAgICAgICBmZCA9IG51bGw7XG4gICAgICAgIGlmIChvcHRpb25zLmNob3duKVxuICAgICAgICAgICAgYXdhaXQgZnNfMS5kZWZhdWx0LmNob3duQXR0ZW1wdCh0ZW1wUGF0aCwgb3B0aW9ucy5jaG93bi51aWQsIG9wdGlvbnMuY2hvd24uZ2lkKTtcbiAgICAgICAgaWYgKG9wdGlvbnMubW9kZSlcbiAgICAgICAgICAgIGF3YWl0IGZzXzEuZGVmYXVsdC5jaG1vZEF0dGVtcHQodGVtcFBhdGgsIG9wdGlvbnMubW9kZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBmc18xLmRlZmF1bHQucmVuYW1lUmV0cnkodGltZW91dCkodGVtcFBhdGgsIGZpbGVQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlICE9PSAnRU5BTUVUT09MT05HJylcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIGF3YWl0IGZzXzEuZGVmYXVsdC5yZW5hbWVSZXRyeSh0aW1lb3V0KSh0ZW1wUGF0aCwgdGVtcF8xLmRlZmF1bHQudHJ1bmNhdGUoZmlsZVBhdGgpKTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wRGlzcG9zZXIoKTtcbiAgICAgICAgdGVtcFBhdGggPSBudWxsO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGZkKVxuICAgICAgICAgICAgYXdhaXQgZnNfMS5kZWZhdWx0LmNsb3NlQXR0ZW1wdChmZCk7XG4gICAgICAgIGlmICh0ZW1wUGF0aClcbiAgICAgICAgICAgIHRlbXBfMS5kZWZhdWx0LnB1cmdlKHRlbXBQYXRoKTtcbiAgICAgICAgaWYgKHNjaGVkdWxlckN1c3RvbURpc3Bvc2VyKVxuICAgICAgICAgICAgc2NoZWR1bGVyQ3VzdG9tRGlzcG9zZXIoKTtcbiAgICAgICAgaWYgKHNjaGVkdWxlckRpc3Bvc2VyKVxuICAgICAgICAgICAgc2NoZWR1bGVyRGlzcG9zZXIoKTtcbiAgICB9XG59O1xuY29uc3Qgd3JpdGVGaWxlU3luYyA9IChmaWxlUGF0aCwgZGF0YSwgb3B0aW9ucyA9IGNvbnN0c18xLkRFRkFVTFRfV1JJVEVfT1BUSU9OUykgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAobGFuZ18xLmRlZmF1bHQuaXNTdHJpbmcob3B0aW9ucykpXG4gICAgICAgIHJldHVybiB3cml0ZUZpbGVTeW5jKGZpbGVQYXRoLCBkYXRhLCB7IGVuY29kaW5nOiBvcHRpb25zIH0pO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBEYXRlLm5vdygpICsgKChfYSA9IG9wdGlvbnMudGltZW91dCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29uc3RzXzEuREVGQVVMVF9USU1FT1VUX1NZTkMpO1xuICAgIGxldCB0ZW1wRGlzcG9zZXIgPSBudWxsLCB0ZW1wUGF0aCA9IG51bGwsIGZkID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgICBmaWxlUGF0aCA9IGZzXzEuZGVmYXVsdC5yZWFscGF0aFN5bmNBdHRlbXB0KGZpbGVQYXRoKSB8fCBmaWxlUGF0aDtcbiAgICAgICAgW3RlbXBQYXRoLCB0ZW1wRGlzcG9zZXJdID0gdGVtcF8xLmRlZmF1bHQuZ2V0KGZpbGVQYXRoLCBvcHRpb25zLnRtcENyZWF0ZSB8fCB0ZW1wXzEuZGVmYXVsdC5jcmVhdGUsICEob3B0aW9ucy50bXBQdXJnZSA9PT0gZmFsc2UpKTtcbiAgICAgICAgY29uc3QgdXNlU3RhdENob3duID0gY29uc3RzXzEuSVNfUE9TSVggJiYgbGFuZ18xLmRlZmF1bHQuaXNVbmRlZmluZWQob3B0aW9ucy5jaG93biksIHVzZVN0YXRNb2RlID0gbGFuZ18xLmRlZmF1bHQuaXNVbmRlZmluZWQob3B0aW9ucy5tb2RlKTtcbiAgICAgICAgaWYgKHVzZVN0YXRDaG93biB8fCB1c2VTdGF0TW9kZSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdCA9IGZzXzEuZGVmYXVsdC5zdGF0U3luY0F0dGVtcHQoZmlsZVBhdGgpO1xuICAgICAgICAgICAgaWYgKHN0YXQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICAgICAgaWYgKHVzZVN0YXRDaG93bilcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jaG93biA9IHsgdWlkOiBzdGF0LnVpZCwgZ2lkOiBzdGF0LmdpZCB9O1xuICAgICAgICAgICAgICAgIGlmICh1c2VTdGF0TW9kZSlcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tb2RlID0gc3RhdC5tb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBwYXRoLmRpcm5hbWUoZmlsZVBhdGgpO1xuICAgICAgICBmc18xLmRlZmF1bHQubWtkaXJTeW5jQXR0ZW1wdChwYXJlbnRQYXRoLCB7XG4gICAgICAgICAgICBtb2RlOiBjb25zdHNfMS5ERUZBVUxUX0ZPTERFUl9NT0RFLFxuICAgICAgICAgICAgcmVjdXJzaXZlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBmZCA9IGZzXzEuZGVmYXVsdC5vcGVuU3luY1JldHJ5KHRpbWVvdXQpKHRlbXBQYXRoLCAndycsIG9wdGlvbnMubW9kZSB8fCBjb25zdHNfMS5ERUZBVUxUX0ZJTEVfTU9ERSk7XG4gICAgICAgIGlmIChvcHRpb25zLnRtcENyZWF0ZWQpXG4gICAgICAgICAgICBvcHRpb25zLnRtcENyZWF0ZWQodGVtcFBhdGgpO1xuICAgICAgICBpZiAobGFuZ18xLmRlZmF1bHQuaXNTdHJpbmcoZGF0YSkpIHtcbiAgICAgICAgICAgIGZzXzEuZGVmYXVsdC53cml0ZVN5bmNSZXRyeSh0aW1lb3V0KShmZCwgZGF0YSwgMCwgb3B0aW9ucy5lbmNvZGluZyB8fCBjb25zdHNfMS5ERUZBVUxUX0VOQ09ESU5HKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbGFuZ18xLmRlZmF1bHQuaXNVbmRlZmluZWQoZGF0YSkpIHtcbiAgICAgICAgICAgIGZzXzEuZGVmYXVsdC53cml0ZVN5bmNSZXRyeSh0aW1lb3V0KShmZCwgZGF0YSwgMCwgZGF0YS5sZW5ndGgsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmZzeW5jICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZnN5bmNXYWl0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGZzXzEuZGVmYXVsdC5mc3luY1N5bmNSZXRyeSh0aW1lb3V0KShmZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmc18xLmRlZmF1bHQuZnN5bmNBdHRlbXB0KGZkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmc18xLmRlZmF1bHQuY2xvc2VTeW5jUmV0cnkodGltZW91dCkoZmQpO1xuICAgICAgICBmZCA9IG51bGw7XG4gICAgICAgIGlmIChvcHRpb25zLmNob3duKVxuICAgICAgICAgICAgZnNfMS5kZWZhdWx0LmNob3duU3luY0F0dGVtcHQodGVtcFBhdGgsIG9wdGlvbnMuY2hvd24udWlkLCBvcHRpb25zLmNob3duLmdpZCk7XG4gICAgICAgIGlmIChvcHRpb25zLm1vZGUpXG4gICAgICAgICAgICBmc18xLmRlZmF1bHQuY2htb2RTeW5jQXR0ZW1wdCh0ZW1wUGF0aCwgb3B0aW9ucy5tb2RlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZzXzEuZGVmYXVsdC5yZW5hbWVTeW5jUmV0cnkodGltZW91dCkodGVtcFBhdGgsIGZpbGVQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlICE9PSAnRU5BTUVUT09MT05HJylcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIGZzXzEuZGVmYXVsdC5yZW5hbWVTeW5jUmV0cnkodGltZW91dCkodGVtcFBhdGgsIHRlbXBfMS5kZWZhdWx0LnRydW5jYXRlKGZpbGVQYXRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcERpc3Bvc2VyKCk7XG4gICAgICAgIHRlbXBQYXRoID0gbnVsbDtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGlmIChmZClcbiAgICAgICAgICAgIGZzXzEuZGVmYXVsdC5jbG9zZVN5bmNBdHRlbXB0KGZkKTtcbiAgICAgICAgaWYgKHRlbXBQYXRoKVxuICAgICAgICAgICAgdGVtcF8xLmRlZmF1bHQucHVyZ2UodGVtcFBhdGgpO1xuICAgIH1cbn07XG5leHBvcnRzLndyaXRlRmlsZVN5bmMgPSB3cml0ZUZpbGVTeW5jO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlZ2V4cENvZGUgPSBleHBvcnRzLmdldFByb3BlcnR5ID0gZXhwb3J0cy5zYWZlU3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLnN0ckNvbmNhdCA9IGV4cG9ydHMuYWRkQ29kZUFyZyA9IGV4cG9ydHMuc3RyID0gZXhwb3J0cy5fID0gZXhwb3J0cy5uaWwgPSBleHBvcnRzLl9Db2RlID0gZXhwb3J0cy5OYW1lID0gZXhwb3J0cy5JREVOVElGSUVSID0gZXhwb3J0cy5fQ29kZU9yTmFtZSA9IHZvaWQgMDtcbmNsYXNzIF9Db2RlT3JOYW1lIHtcbn1cbmV4cG9ydHMuX0NvZGVPck5hbWUgPSBfQ29kZU9yTmFtZTtcbmV4cG9ydHMuSURFTlRJRklFUiA9IC9eW2EteiRfXVthLXokXzAtOV0qJC9pO1xuY2xhc3MgTmFtZSBleHRlbmRzIF9Db2RlT3JOYW1lIHtcbiAgICBjb25zdHJ1Y3RvcihzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmICghZXhwb3J0cy5JREVOVElGSUVSLnRlc3QocykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb2RlR2VuOiBuYW1lIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXCIpO1xuICAgICAgICB0aGlzLnN0ciA9IHM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHI7XG4gICAgfVxuICAgIGVtcHR5U3RyKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHsgW3RoaXMuc3RyXTogMSB9O1xuICAgIH1cbn1cbmV4cG9ydHMuTmFtZSA9IE5hbWU7XG5jbGFzcyBfQ29kZSBleHRlbmRzIF9Db2RlT3JOYW1lIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gdHlwZW9mIGNvZGUgPT09IFwic3RyaW5nXCIgPyBbY29kZV0gOiBjb2RlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyO1xuICAgIH1cbiAgICBlbXB0eVN0cigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2l0ZW1zLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pdGVtc1swXTtcbiAgICAgICAgcmV0dXJuIGl0ZW0gPT09IFwiXCIgfHwgaXRlbSA9PT0gJ1wiXCInO1xuICAgIH1cbiAgICBnZXQgc3RyKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5fc3RyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAodGhpcy5fc3RyID0gdGhpcy5faXRlbXMucmVkdWNlKChzLCBjKSA9PiBgJHtzfSR7Y31gLCBcIlwiKSkpO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLl9uYW1lcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHRoaXMuX25hbWVzID0gdGhpcy5faXRlbXMucmVkdWNlKChuYW1lcywgYykgPT4ge1xuICAgICAgICAgICAgaWYgKGMgaW5zdGFuY2VvZiBOYW1lKVxuICAgICAgICAgICAgICAgIG5hbWVzW2Muc3RyXSA9IChuYW1lc1tjLnN0cl0gfHwgMCkgKyAxO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWVzO1xuICAgICAgICB9LCB7fSkpKTtcbiAgICB9XG59XG5leHBvcnRzLl9Db2RlID0gX0NvZGU7XG5leHBvcnRzLm5pbCA9IG5ldyBfQ29kZShcIlwiKTtcbmZ1bmN0aW9uIF8oc3RycywgLi4uYXJncykge1xuICAgIGNvbnN0IGNvZGUgPSBbc3Ryc1swXV07XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgYWRkQ29kZUFyZyhjb2RlLCBhcmdzW2ldKTtcbiAgICAgICAgY29kZS5wdXNoKHN0cnNbKytpXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX0NvZGUoY29kZSk7XG59XG5leHBvcnRzLl8gPSBfO1xuY29uc3QgcGx1cyA9IG5ldyBfQ29kZShcIitcIik7XG5mdW5jdGlvbiBzdHIoc3RycywgLi4uYXJncykge1xuICAgIGNvbnN0IGV4cHIgPSBbc2FmZVN0cmluZ2lmeShzdHJzWzBdKV07XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgZXhwci5wdXNoKHBsdXMpO1xuICAgICAgICBhZGRDb2RlQXJnKGV4cHIsIGFyZ3NbaV0pO1xuICAgICAgICBleHByLnB1c2gocGx1cywgc2FmZVN0cmluZ2lmeShzdHJzWysraV0pKTtcbiAgICB9XG4gICAgb3B0aW1pemUoZXhwcik7XG4gICAgcmV0dXJuIG5ldyBfQ29kZShleHByKTtcbn1cbmV4cG9ydHMuc3RyID0gc3RyO1xuZnVuY3Rpb24gYWRkQ29kZUFyZyhjb2RlLCBhcmcpIHtcbiAgICBpZiAoYXJnIGluc3RhbmNlb2YgX0NvZGUpXG4gICAgICAgIGNvZGUucHVzaCguLi5hcmcuX2l0ZW1zKTtcbiAgICBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBOYW1lKVxuICAgICAgICBjb2RlLnB1c2goYXJnKTtcbiAgICBlbHNlXG4gICAgICAgIGNvZGUucHVzaChpbnRlcnBvbGF0ZShhcmcpKTtcbn1cbmV4cG9ydHMuYWRkQ29kZUFyZyA9IGFkZENvZGVBcmc7XG5mdW5jdGlvbiBvcHRpbWl6ZShleHByKSB7XG4gICAgbGV0IGkgPSAxO1xuICAgIHdoaWxlIChpIDwgZXhwci5sZW5ndGggLSAxKSB7XG4gICAgICAgIGlmIChleHByW2ldID09PSBwbHVzKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBtZXJnZUV4cHJJdGVtcyhleHByW2kgLSAxXSwgZXhwcltpICsgMV0pO1xuICAgICAgICAgICAgaWYgKHJlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZXhwci5zcGxpY2UoaSAtIDEsIDMsIHJlcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHByW2krK10gPSBcIitcIjtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxufVxuZnVuY3Rpb24gbWVyZ2VFeHBySXRlbXMoYSwgYikge1xuICAgIGlmIChiID09PSAnXCJcIicpXG4gICAgICAgIHJldHVybiBhO1xuICAgIGlmIChhID09PSAnXCJcIicpXG4gICAgICAgIHJldHVybiBiO1xuICAgIGlmICh0eXBlb2YgYSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChiIGluc3RhbmNlb2YgTmFtZSB8fCBhW2EubGVuZ3RoIC0gMV0gIT09ICdcIicpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIGAke2Euc2xpY2UoMCwgLTEpfSR7Yn1cImA7XG4gICAgICAgIGlmIChiWzBdID09PSAnXCInKVxuICAgICAgICAgICAgcmV0dXJuIGEuc2xpY2UoMCwgLTEpICsgYi5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGIgPT0gXCJzdHJpbmdcIiAmJiBiWzBdID09PSAnXCInICYmICEoYSBpbnN0YW5jZW9mIE5hbWUpKVxuICAgICAgICByZXR1cm4gYFwiJHthfSR7Yi5zbGljZSgxKX1gO1xuICAgIHJldHVybjtcbn1cbmZ1bmN0aW9uIHN0ckNvbmNhdChjMSwgYzIpIHtcbiAgICByZXR1cm4gYzIuZW1wdHlTdHIoKSA/IGMxIDogYzEuZW1wdHlTdHIoKSA/IGMyIDogc3RyIGAke2MxfSR7YzJ9YDtcbn1cbmV4cG9ydHMuc3RyQ29uY2F0ID0gc3RyQ29uY2F0O1xuLy8gVE9ETyBkbyBub3QgYWxsb3cgYXJyYXlzIGhlcmVcbmZ1bmN0aW9uIGludGVycG9sYXRlKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgeCA9PSBcImJvb2xlYW5cIiB8fCB4ID09PSBudWxsXG4gICAgICAgID8geFxuICAgICAgICA6IHNhZmVTdHJpbmdpZnkoQXJyYXkuaXNBcnJheSh4KSA/IHguam9pbihcIixcIikgOiB4KTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeSh4KSB7XG4gICAgcmV0dXJuIG5ldyBfQ29kZShzYWZlU3RyaW5naWZ5KHgpKTtcbn1cbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuZnVuY3Rpb24gc2FmZVN0cmluZ2lmeSh4KSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHgpXG4gICAgICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csIFwiXFxcXHUyMDI4XCIpXG4gICAgICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csIFwiXFxcXHUyMDI5XCIpO1xufVxuZXhwb3J0cy5zYWZlU3RyaW5naWZ5ID0gc2FmZVN0cmluZ2lmeTtcbmZ1bmN0aW9uIGdldFByb3BlcnR5KGtleSkge1xuICAgIHJldHVybiB0eXBlb2Yga2V5ID09IFwic3RyaW5nXCIgJiYgZXhwb3J0cy5JREVOVElGSUVSLnRlc3Qoa2V5KSA/IG5ldyBfQ29kZShgLiR7a2V5fWApIDogXyBgWyR7a2V5fV1gO1xufVxuZXhwb3J0cy5nZXRQcm9wZXJ0eSA9IGdldFByb3BlcnR5O1xuZnVuY3Rpb24gcmVnZXhwQ29kZShyeCkge1xuICAgIHJldHVybiBuZXcgX0NvZGUocngudG9TdHJpbmcoKSk7XG59XG5leHBvcnRzLnJlZ2V4cENvZGUgPSByZWdleHBDb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmFsdWVTY29wZSA9IGV4cG9ydHMuVmFsdWVTY29wZU5hbWUgPSBleHBvcnRzLlNjb3BlID0gZXhwb3J0cy52YXJLaW5kcyA9IGV4cG9ydHMuVXNlZFZhbHVlU3RhdGUgPSB2b2lkIDA7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi9jb2RlXCIpO1xuY2xhc3MgVmFsdWVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHN1cGVyKGBDb2RlR2VuOiBcImNvZGVcIiBmb3IgJHtuYW1lfSBub3QgZGVmaW5lZGApO1xuICAgICAgICB0aGlzLnZhbHVlID0gbmFtZS52YWx1ZTtcbiAgICB9XG59XG52YXIgVXNlZFZhbHVlU3RhdGU7XG4oZnVuY3Rpb24gKFVzZWRWYWx1ZVN0YXRlKSB7XG4gICAgVXNlZFZhbHVlU3RhdGVbVXNlZFZhbHVlU3RhdGVbXCJTdGFydGVkXCJdID0gMF0gPSBcIlN0YXJ0ZWRcIjtcbiAgICBVc2VkVmFsdWVTdGF0ZVtVc2VkVmFsdWVTdGF0ZVtcIkNvbXBsZXRlZFwiXSA9IDFdID0gXCJDb21wbGV0ZWRcIjtcbn0pKFVzZWRWYWx1ZVN0YXRlID0gZXhwb3J0cy5Vc2VkVmFsdWVTdGF0ZSB8fCAoZXhwb3J0cy5Vc2VkVmFsdWVTdGF0ZSA9IHt9KSk7XG5leHBvcnRzLnZhcktpbmRzID0ge1xuICAgIGNvbnN0OiBuZXcgY29kZV8xLk5hbWUoXCJjb25zdFwiKSxcbiAgICBsZXQ6IG5ldyBjb2RlXzEuTmFtZShcImxldFwiKSxcbiAgICB2YXI6IG5ldyBjb2RlXzEuTmFtZShcInZhclwiKSxcbn07XG5jbGFzcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3IoeyBwcmVmaXhlcywgcGFyZW50IH0gPSB7fSkge1xuICAgICAgICB0aGlzLl9uYW1lcyA9IHt9O1xuICAgICAgICB0aGlzLl9wcmVmaXhlcyA9IHByZWZpeGVzO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHRvTmFtZShuYW1lT3JQcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVPclByZWZpeCBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lID8gbmFtZU9yUHJlZml4IDogdGhpcy5uYW1lKG5hbWVPclByZWZpeCk7XG4gICAgfVxuICAgIG5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBuZXcgY29kZV8xLk5hbWUodGhpcy5fbmV3TmFtZShwcmVmaXgpKTtcbiAgICB9XG4gICAgX25ld05hbWUocHJlZml4KSB7XG4gICAgICAgIGNvbnN0IG5nID0gdGhpcy5fbmFtZXNbcHJlZml4XSB8fCB0aGlzLl9uYW1lR3JvdXAocHJlZml4KTtcbiAgICAgICAgcmV0dXJuIGAke3ByZWZpeH0ke25nLmluZGV4Kyt9YDtcbiAgICB9XG4gICAgX25hbWVHcm91cChwcmVmaXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCgoX2IgPSAoX2EgPSB0aGlzLl9wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fcHJlZml4ZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oYXMocHJlZml4KSkgfHwgKHRoaXMuX3ByZWZpeGVzICYmICF0aGlzLl9wcmVmaXhlcy5oYXMocHJlZml4KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogcHJlZml4IFwiJHtwcmVmaXh9XCIgaXMgbm90IGFsbG93ZWQgaW4gdGhpcyBzY29wZWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5fbmFtZXNbcHJlZml4XSA9IHsgcHJlZml4LCBpbmRleDogMCB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNjb3BlID0gU2NvcGU7XG5jbGFzcyBWYWx1ZVNjb3BlTmFtZSBleHRlbmRzIGNvZGVfMS5OYW1lIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXgsIG5hbWVTdHIpIHtcbiAgICAgICAgc3VwZXIobmFtZVN0cik7XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSwgeyBwcm9wZXJ0eSwgaXRlbUluZGV4IH0pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNjb3BlUGF0aCA9IGNvZGVfMS5fIGAuJHtuZXcgY29kZV8xLk5hbWUocHJvcGVydHkpfVske2l0ZW1JbmRleH1dYDtcbiAgICB9XG59XG5leHBvcnRzLlZhbHVlU2NvcGVOYW1lID0gVmFsdWVTY29wZU5hbWU7XG5jb25zdCBsaW5lID0gY29kZV8xLl8gYFxcbmA7XG5jbGFzcyBWYWx1ZVNjb3BlIGV4dGVuZHMgU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IHt9O1xuICAgICAgICB0aGlzLl9zY29wZSA9IG9wdHMuc2NvcGU7XG4gICAgICAgIHRoaXMub3B0cyA9IHsgLi4ub3B0cywgX246IG9wdHMubGluZXMgPyBsaW5lIDogY29kZV8xLm5pbCB9O1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY29wZTtcbiAgICB9XG4gICAgbmFtZShwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZVNjb3BlTmFtZShwcmVmaXgsIHRoaXMuX25ld05hbWUocHJlZml4KSk7XG4gICAgfVxuICAgIHZhbHVlKG5hbWVPclByZWZpeCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodmFsdWUucmVmID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb2RlR2VuOiByZWYgbXVzdCBiZSBwYXNzZWQgaW4gdmFsdWVcIik7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLnRvTmFtZShuYW1lT3JQcmVmaXgpO1xuICAgICAgICBjb25zdCB7IHByZWZpeCB9ID0gbmFtZTtcbiAgICAgICAgY29uc3QgdmFsdWVLZXkgPSAoX2EgPSB2YWx1ZS5rZXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbHVlLnJlZjtcbiAgICAgICAgbGV0IHZzID0gdGhpcy5fdmFsdWVzW3ByZWZpeF07XG4gICAgICAgIGlmICh2cykge1xuICAgICAgICAgICAgY29uc3QgX25hbWUgPSB2cy5nZXQodmFsdWVLZXkpO1xuICAgICAgICAgICAgaWYgKF9uYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiBfbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZzID0gdGhpcy5fdmFsdWVzW3ByZWZpeF0gPSBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdnMuc2V0KHZhbHVlS2V5LCBuYW1lKTtcbiAgICAgICAgY29uc3QgcyA9IHRoaXMuX3Njb3BlW3ByZWZpeF0gfHwgKHRoaXMuX3Njb3BlW3ByZWZpeF0gPSBbXSk7XG4gICAgICAgIGNvbnN0IGl0ZW1JbmRleCA9IHMubGVuZ3RoO1xuICAgICAgICBzW2l0ZW1JbmRleF0gPSB2YWx1ZS5yZWY7XG4gICAgICAgIG5hbWUuc2V0VmFsdWUodmFsdWUsIHsgcHJvcGVydHk6IHByZWZpeCwgaXRlbUluZGV4IH0pO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgZ2V0VmFsdWUocHJlZml4LCBrZXlPclJlZikge1xuICAgICAgICBjb25zdCB2cyA9IHRoaXMuX3ZhbHVlc1twcmVmaXhdO1xuICAgICAgICBpZiAoIXZzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gdnMuZ2V0KGtleU9yUmVmKTtcbiAgICB9XG4gICAgc2NvcGVSZWZzKHNjb3BlTmFtZSwgdmFsdWVzID0gdGhpcy5fdmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWR1Y2VWYWx1ZXModmFsdWVzLCAobmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWUuc2NvcGVQYXRoID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBuYW1lIFwiJHtuYW1lfVwiIGhhcyBubyB2YWx1ZWApO1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVfMS5fIGAke3Njb3BlTmFtZX0ke25hbWUuc2NvcGVQYXRofWA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzY29wZUNvZGUodmFsdWVzID0gdGhpcy5fdmFsdWVzLCB1c2VkVmFsdWVzLCBnZXRDb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWR1Y2VWYWx1ZXModmFsdWVzLCAobmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWUudmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IG5hbWUgXCIke25hbWV9XCIgaGFzIG5vIHZhbHVlYCk7XG4gICAgICAgICAgICByZXR1cm4gbmFtZS52YWx1ZS5jb2RlO1xuICAgICAgICB9LCB1c2VkVmFsdWVzLCBnZXRDb2RlKTtcbiAgICB9XG4gICAgX3JlZHVjZVZhbHVlcyh2YWx1ZXMsIHZhbHVlQ29kZSwgdXNlZFZhbHVlcyA9IHt9LCBnZXRDb2RlKSB7XG4gICAgICAgIGxldCBjb2RlID0gY29kZV8xLm5pbDtcbiAgICAgICAgZm9yIChjb25zdCBwcmVmaXggaW4gdmFsdWVzKSB7XG4gICAgICAgICAgICBjb25zdCB2cyA9IHZhbHVlc1twcmVmaXhdO1xuICAgICAgICAgICAgaWYgKCF2cylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVTZXQgPSAodXNlZFZhbHVlc1twcmVmaXhdID0gdXNlZFZhbHVlc1twcmVmaXhdIHx8IG5ldyBNYXAoKSk7XG4gICAgICAgICAgICB2cy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVTZXQuaGFzKG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgbmFtZVNldC5zZXQobmFtZSwgVXNlZFZhbHVlU3RhdGUuU3RhcnRlZCk7XG4gICAgICAgICAgICAgICAgbGV0IGMgPSB2YWx1ZUNvZGUobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmID0gdGhpcy5vcHRzLmVzNSA/IGV4cG9ydHMudmFyS2luZHMudmFyIDogZXhwb3J0cy52YXJLaW5kcy5jb25zdDtcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvZGVfMS5fIGAke2NvZGV9JHtkZWZ9ICR7bmFtZX0gPSAke2N9OyR7dGhpcy5vcHRzLl9ufWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChjID0gZ2V0Q29kZSA9PT0gbnVsbCB8fCBnZXRDb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZXRDb2RlKG5hbWUpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29kZV8xLl8gYCR7Y29kZX0ke2N9JHt0aGlzLm9wdHMuX259YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuYW1lU2V0LnNldChuYW1lLCBVc2VkVmFsdWVTdGF0ZS5Db21wbGV0ZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxufVxuZXhwb3J0cy5WYWx1ZVNjb3BlID0gVmFsdWVTY29wZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjb3BlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vciA9IGV4cG9ydHMuYW5kID0gZXhwb3J0cy5ub3QgPSBleHBvcnRzLkNvZGVHZW4gPSBleHBvcnRzLm9wZXJhdG9ycyA9IGV4cG9ydHMudmFyS2luZHMgPSBleHBvcnRzLlZhbHVlU2NvcGVOYW1lID0gZXhwb3J0cy5WYWx1ZVNjb3BlID0gZXhwb3J0cy5TY29wZSA9IGV4cG9ydHMuTmFtZSA9IGV4cG9ydHMucmVnZXhwQ29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZXhwb3J0cy5nZXRQcm9wZXJ0eSA9IGV4cG9ydHMubmlsID0gZXhwb3J0cy5zdHJDb25jYXQgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuXyA9IHZvaWQgMDtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuL2NvZGVcIik7XG5jb25zdCBzY29wZV8xID0gcmVxdWlyZShcIi4vc2NvcGVcIik7XG52YXIgY29kZV8yID0gcmVxdWlyZShcIi4vY29kZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5fOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuc3RyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyQ29uY2F0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuc3RyQ29uY2F0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmlsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIubmlsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0UHJvcGVydHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5nZXRQcm9wZXJ0eTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLnN0cmluZ2lmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlZ2V4cENvZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5yZWdleHBDb2RlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLk5hbWU7IH0gfSk7XG52YXIgc2NvcGVfMiA9IHJlcXVpcmUoXCIuL3Njb3BlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2NvcGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjb3BlXzIuU2NvcGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWYWx1ZVNjb3BlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY29wZV8yLlZhbHVlU2NvcGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWYWx1ZVNjb3BlTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NvcGVfMi5WYWx1ZVNjb3BlTmFtZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZhcktpbmRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY29wZV8yLnZhcktpbmRzOyB9IH0pO1xuZXhwb3J0cy5vcGVyYXRvcnMgPSB7XG4gICAgR1Q6IG5ldyBjb2RlXzEuX0NvZGUoXCI+XCIpLFxuICAgIEdURTogbmV3IGNvZGVfMS5fQ29kZShcIj49XCIpLFxuICAgIExUOiBuZXcgY29kZV8xLl9Db2RlKFwiPFwiKSxcbiAgICBMVEU6IG5ldyBjb2RlXzEuX0NvZGUoXCI8PVwiKSxcbiAgICBFUTogbmV3IGNvZGVfMS5fQ29kZShcIj09PVwiKSxcbiAgICBORVE6IG5ldyBjb2RlXzEuX0NvZGUoXCIhPT1cIiksXG4gICAgTk9UOiBuZXcgY29kZV8xLl9Db2RlKFwiIVwiKSxcbiAgICBPUjogbmV3IGNvZGVfMS5fQ29kZShcInx8XCIpLFxuICAgIEFORDogbmV3IGNvZGVfMS5fQ29kZShcIiYmXCIpLFxuICAgIEFERDogbmV3IGNvZGVfMS5fQ29kZShcIitcIiksXG59O1xuY2xhc3MgTm9kZSB7XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMoX25hbWVzLCBfY29uc3RhbnRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmNsYXNzIERlZiBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKHZhcktpbmQsIG5hbWUsIHJocykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhcktpbmQgPSB2YXJLaW5kO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnJocyA9IHJocztcbiAgICB9XG4gICAgcmVuZGVyKHsgZXM1LCBfbiB9KSB7XG4gICAgICAgIGNvbnN0IHZhcktpbmQgPSBlczUgPyBzY29wZV8xLnZhcktpbmRzLnZhciA6IHRoaXMudmFyS2luZDtcbiAgICAgICAgY29uc3QgcmhzID0gdGhpcy5yaHMgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBgID0gJHt0aGlzLnJoc31gO1xuICAgICAgICByZXR1cm4gYCR7dmFyS2luZH0gJHt0aGlzLm5hbWV9JHtyaHN9O2AgKyBfbjtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGlmICghbmFtZXNbdGhpcy5uYW1lLnN0cl0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnJocylcbiAgICAgICAgICAgIHRoaXMucmhzID0gb3B0aW1pemVFeHByKHRoaXMucmhzLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmhzIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlT3JOYW1lID8gdGhpcy5yaHMubmFtZXMgOiB7fTtcbiAgICB9XG59XG5jbGFzcyBBc3NpZ24gZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihsaHMsIHJocywgc2lkZUVmZmVjdHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5saHMgPSBsaHM7XG4gICAgICAgIHRoaXMucmhzID0gcmhzO1xuICAgICAgICB0aGlzLnNpZGVFZmZlY3RzID0gc2lkZUVmZmVjdHM7XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubGhzfSA9ICR7dGhpcy5yaHN9O2AgKyBfbjtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGlmICh0aGlzLmxocyBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lICYmICFuYW1lc1t0aGlzLmxocy5zdHJdICYmICF0aGlzLnNpZGVFZmZlY3RzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJocyA9IG9wdGltaXplRXhwcih0aGlzLnJocywgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gdGhpcy5saHMgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSA/IHt9IDogeyAuLi50aGlzLmxocy5uYW1lcyB9O1xuICAgICAgICByZXR1cm4gYWRkRXhwck5hbWVzKG5hbWVzLCB0aGlzLnJocyk7XG4gICAgfVxufVxuY2xhc3MgQXNzaWduT3AgZXh0ZW5kcyBBc3NpZ24ge1xuICAgIGNvbnN0cnVjdG9yKGxocywgb3AsIHJocywgc2lkZUVmZmVjdHMpIHtcbiAgICAgICAgc3VwZXIobGhzLCByaHMsIHNpZGVFZmZlY3RzKTtcbiAgICAgICAgdGhpcy5vcCA9IG9wO1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmxoc30gJHt0aGlzLm9wfT0gJHt0aGlzLnJoc307YCArIF9uO1xuICAgIH1cbn1cbmNsYXNzIExhYmVsIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IobGFiZWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgICB0aGlzLm5hbWVzID0ge307XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubGFiZWx9OmAgKyBfbjtcbiAgICB9XG59XG5jbGFzcyBCcmVhayBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGxhYmVsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgdGhpcy5uYW1lcyA9IHt9O1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy5sYWJlbCA/IGAgJHt0aGlzLmxhYmVsfWAgOiBcIlwiO1xuICAgICAgICByZXR1cm4gYGJyZWFrJHtsYWJlbH07YCArIF9uO1xuICAgIH1cbn1cbmNsYXNzIFRocm93IGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IoZXJyb3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgdGhyb3cgJHt0aGlzLmVycm9yfTtgICsgX247XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IubmFtZXM7XG4gICAgfVxufVxuY2xhc3MgQW55Q29kZSBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb2RlfTtgICsgX247XG4gICAgfVxuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvZGV9YCA/IHRoaXMgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICB0aGlzLmNvZGUgPSBvcHRpbWl6ZUV4cHIodGhpcy5jb2RlLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZSBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZU9yTmFtZSA/IHRoaXMuY29kZS5uYW1lcyA6IHt9O1xuICAgIH1cbn1cbmNsYXNzIFBhcmVudE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlcyA9IFtdKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXMucmVkdWNlKChjb2RlLCBuKSA9PiBjb2RlICsgbi5yZW5kZXIob3B0cyksIFwiXCIpO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICBjb25zdCB7IG5vZGVzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgY29uc3QgbiA9IG5vZGVzW2ldLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG4pKVxuICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxLCAuLi5uKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG4pXG4gICAgICAgICAgICAgICAgbm9kZXNbaV0gPSBuO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXMubGVuZ3RoID4gMCA/IHRoaXMgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBjb25zdCB7IG5vZGVzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgLy8gaXRlcmF0aW5nIGJhY2t3YXJkcyBpbXByb3ZlcyAxLXBhc3Mgb3B0aW1pemF0aW9uXG4gICAgICAgICAgICBjb25zdCBuID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAobi5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgc3VidHJhY3ROYW1lcyhuYW1lcywgbi5uYW1lcyk7XG4gICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzLmxlbmd0aCA+IDAgPyB0aGlzIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLnJlZHVjZSgobmFtZXMsIG4pID0+IGFkZE5hbWVzKG5hbWVzLCBuLm5hbWVzKSwge30pO1xuICAgIH1cbn1cbmNsYXNzIEJsb2NrTm9kZSBleHRlbmRzIFBhcmVudE5vZGUge1xuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBcIntcIiArIG9wdHMuX24gKyBzdXBlci5yZW5kZXIob3B0cykgKyBcIn1cIiArIG9wdHMuX247XG4gICAgfVxufVxuY2xhc3MgUm9vdCBleHRlbmRzIFBhcmVudE5vZGUge1xufVxuY2xhc3MgRWxzZSBleHRlbmRzIEJsb2NrTm9kZSB7XG59XG5FbHNlLmtpbmQgPSBcImVsc2VcIjtcbmNsYXNzIElmIGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25kaXRpb24sIG5vZGVzKSB7XG4gICAgICAgIHN1cGVyKG5vZGVzKTtcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIGxldCBjb2RlID0gYGlmKCR7dGhpcy5jb25kaXRpb259KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgICAgIGlmICh0aGlzLmVsc2UpXG4gICAgICAgICAgICBjb2RlICs9IFwiZWxzZSBcIiArIHRoaXMuZWxzZS5yZW5kZXIob3B0cyk7XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICBzdXBlci5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgIGNvbnN0IGNvbmQgPSB0aGlzLmNvbmRpdGlvbjtcbiAgICAgICAgaWYgKGNvbmQgPT09IHRydWUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlczsgLy8gZWxzZSBpcyBpZ25vcmVkIGhlcmVcbiAgICAgICAgbGV0IGUgPSB0aGlzLmVsc2U7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBjb25zdCBucyA9IGUub3B0aW1pemVOb2RlcygpO1xuICAgICAgICAgICAgZSA9IHRoaXMuZWxzZSA9IEFycmF5LmlzQXJyYXkobnMpID8gbmV3IEVsc2UobnMpIDogbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIGlmIChjb25kID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIElmID8gZSA6IGUubm9kZXM7XG4gICAgICAgICAgICBpZiAodGhpcy5ub2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gbmV3IElmKG5vdChjb25kKSwgZSBpbnN0YW5jZW9mIElmID8gW2VdIDogZS5ub2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmQgPT09IGZhbHNlIHx8ICF0aGlzLm5vZGVzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmVsc2UgPSAoX2EgPSB0aGlzLmVsc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICBpZiAoIShzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHx8IHRoaXMuZWxzZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gb3B0aW1pemVFeHByKHRoaXMuY29uZGl0aW9uLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBzdXBlci5uYW1lcztcbiAgICAgICAgYWRkRXhwck5hbWVzKG5hbWVzLCB0aGlzLmNvbmRpdGlvbik7XG4gICAgICAgIGlmICh0aGlzLmVsc2UpXG4gICAgICAgICAgICBhZGROYW1lcyhuYW1lcywgdGhpcy5lbHNlLm5hbWVzKTtcbiAgICAgICAgcmV0dXJuIG5hbWVzO1xuICAgIH1cbn1cbklmLmtpbmQgPSBcImlmXCI7XG5jbGFzcyBGb3IgZXh0ZW5kcyBCbG9ja05vZGUge1xufVxuRm9yLmtpbmQgPSBcImZvclwiO1xuY2xhc3MgRm9yTG9vcCBleHRlbmRzIEZvciB7XG4gICAgY29uc3RydWN0b3IoaXRlcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaXRlcmF0aW9uID0gaXRlcmF0aW9uO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gYGZvcigke3RoaXMuaXRlcmF0aW9ufSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgaWYgKCFzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLml0ZXJhdGlvbiA9IG9wdGltaXplRXhwcih0aGlzLml0ZXJhdGlvbiwgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiBhZGROYW1lcyhzdXBlci5uYW1lcywgdGhpcy5pdGVyYXRpb24ubmFtZXMpO1xuICAgIH1cbn1cbmNsYXNzIEZvclJhbmdlIGV4dGVuZHMgRm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YXJLaW5kLCBuYW1lLCBmcm9tLCB0bykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhcktpbmQgPSB2YXJLaW5kO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIGNvbnN0IHZhcktpbmQgPSBvcHRzLmVzNSA/IHNjb3BlXzEudmFyS2luZHMudmFyIDogdGhpcy52YXJLaW5kO1xuICAgICAgICBjb25zdCB7IG5hbWUsIGZyb20sIHRvIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gYGZvcigke3ZhcktpbmR9ICR7bmFtZX09JHtmcm9tfTsgJHtuYW1lfTwke3RvfTsgJHtuYW1lfSsrKWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBhZGRFeHByTmFtZXMoc3VwZXIubmFtZXMsIHRoaXMuZnJvbSk7XG4gICAgICAgIHJldHVybiBhZGRFeHByTmFtZXMobmFtZXMsIHRoaXMudG8pO1xuICAgIH1cbn1cbmNsYXNzIEZvckl0ZXIgZXh0ZW5kcyBGb3Ige1xuICAgIGNvbnN0cnVjdG9yKGxvb3AsIHZhcktpbmQsIG5hbWUsIGl0ZXJhYmxlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubG9vcCA9IGxvb3A7XG4gICAgICAgIHRoaXMudmFyS2luZCA9IHZhcktpbmQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaXRlcmFibGUgPSBpdGVyYWJsZTtcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGBmb3IoJHt0aGlzLnZhcktpbmR9ICR7dGhpcy5uYW1lfSAke3RoaXMubG9vcH0gJHt0aGlzLml0ZXJhYmxlfSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgaWYgKCFzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLml0ZXJhYmxlID0gb3B0aW1pemVFeHByKHRoaXMuaXRlcmFibGUsIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gYWRkTmFtZXMoc3VwZXIubmFtZXMsIHRoaXMuaXRlcmFibGUubmFtZXMpO1xuICAgIH1cbn1cbmNsYXNzIEZ1bmMgZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGFyZ3MsIGFzeW5jKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMuYXN5bmMgPSBhc3luYztcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgY29uc3QgX2FzeW5jID0gdGhpcy5hc3luYyA/IFwiYXN5bmMgXCIgOiBcIlwiO1xuICAgICAgICByZXR1cm4gYCR7X2FzeW5jfWZ1bmN0aW9uICR7dGhpcy5uYW1lfSgke3RoaXMuYXJnc30pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG59XG5GdW5jLmtpbmQgPSBcImZ1bmNcIjtcbmNsYXNzIFJldHVybiBleHRlbmRzIFBhcmVudE5vZGUge1xuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBcInJldHVybiBcIiArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG59XG5SZXR1cm4ua2luZCA9IFwicmV0dXJuXCI7XG5jbGFzcyBUcnkgZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIGxldCBjb2RlID0gXCJ0cnlcIiArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICAgICAgaWYgKHRoaXMuY2F0Y2gpXG4gICAgICAgICAgICBjb2RlICs9IHRoaXMuY2F0Y2gucmVuZGVyKG9wdHMpO1xuICAgICAgICBpZiAodGhpcy5maW5hbGx5KVxuICAgICAgICAgICAgY29kZSArPSB0aGlzLmZpbmFsbHkucmVuZGVyKG9wdHMpO1xuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgc3VwZXIub3B0aW1pemVOb2RlcygpO1xuICAgICAgICAoX2EgPSB0aGlzLmNhdGNoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW1pemVOb2RlcygpO1xuICAgICAgICAoX2IgPSB0aGlzLmZpbmFsbHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgKF9hID0gdGhpcy5jYXRjaCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIChfYiA9IHRoaXMuZmluYWxseSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gc3VwZXIubmFtZXM7XG4gICAgICAgIGlmICh0aGlzLmNhdGNoKVxuICAgICAgICAgICAgYWRkTmFtZXMobmFtZXMsIHRoaXMuY2F0Y2gubmFtZXMpO1xuICAgICAgICBpZiAodGhpcy5maW5hbGx5KVxuICAgICAgICAgICAgYWRkTmFtZXMobmFtZXMsIHRoaXMuZmluYWxseS5uYW1lcyk7XG4gICAgICAgIHJldHVybiBuYW1lcztcbiAgICB9XG59XG5jbGFzcyBDYXRjaCBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgY29uc3RydWN0b3IoZXJyb3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gYGNhdGNoKCR7dGhpcy5lcnJvcn0pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG59XG5DYXRjaC5raW5kID0gXCJjYXRjaFwiO1xuY2xhc3MgRmluYWxseSBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIFwiZmluYWxseVwiICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbn1cbkZpbmFsbHkua2luZCA9IFwiZmluYWxseVwiO1xuY2xhc3MgQ29kZUdlbiB7XG4gICAgY29uc3RydWN0b3IoZXh0U2NvcGUsIG9wdHMgPSB7fSkge1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fYmxvY2tTdGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5fY29uc3RhbnRzID0ge307XG4gICAgICAgIHRoaXMub3B0cyA9IHsgLi4ub3B0cywgX246IG9wdHMubGluZXMgPyBcIlxcblwiIDogXCJcIiB9O1xuICAgICAgICB0aGlzLl9leHRTY29wZSA9IGV4dFNjb3BlO1xuICAgICAgICB0aGlzLl9zY29wZSA9IG5ldyBzY29wZV8xLlNjb3BlKHsgcGFyZW50OiBleHRTY29wZSB9KTtcbiAgICAgICAgdGhpcy5fbm9kZXMgPSBbbmV3IFJvb3QoKV07XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdC5yZW5kZXIodGhpcy5vcHRzKTtcbiAgICB9XG4gICAgLy8gcmV0dXJucyB1bmlxdWUgbmFtZSBpbiB0aGUgaW50ZXJuYWwgc2NvcGVcbiAgICBuYW1lKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NvcGUubmFtZShwcmVmaXgpO1xuICAgIH1cbiAgICAvLyByZXNlcnZlcyB1bmlxdWUgbmFtZSBpbiB0aGUgZXh0ZXJuYWwgc2NvcGVcbiAgICBzY29wZU5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5uYW1lKHByZWZpeCk7XG4gICAgfVxuICAgIC8vIHJlc2VydmVzIHVuaXF1ZSBuYW1lIGluIHRoZSBleHRlcm5hbCBzY29wZSBhbmQgYXNzaWducyB2YWx1ZSB0byBpdFxuICAgIHNjb3BlVmFsdWUocHJlZml4T3JOYW1lLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fZXh0U2NvcGUudmFsdWUocHJlZml4T3JOYW1lLCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHZzID0gdGhpcy5fdmFsdWVzW25hbWUucHJlZml4XSB8fCAodGhpcy5fdmFsdWVzW25hbWUucHJlZml4XSA9IG5ldyBTZXQoKSk7XG4gICAgICAgIHZzLmFkZChuYW1lKTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIGdldFNjb3BlVmFsdWUocHJlZml4LCBrZXlPclJlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUuZ2V0VmFsdWUocHJlZml4LCBrZXlPclJlZik7XG4gICAgfVxuICAgIC8vIHJldHVybiBjb2RlIHRoYXQgYXNzaWducyB2YWx1ZXMgaW4gdGhlIGV4dGVybmFsIHNjb3BlIHRvIHRoZSBuYW1lcyB0aGF0IGFyZSB1c2VkIGludGVybmFsbHlcbiAgICAvLyAoc2FtZSBuYW1lcyB0aGF0IHdlcmUgcmV0dXJuZWQgYnkgZ2VuLnNjb3BlTmFtZSBvciBnZW4uc2NvcGVWYWx1ZSlcbiAgICBzY29wZVJlZnMoc2NvcGVOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5zY29wZVJlZnMoc2NvcGVOYW1lLCB0aGlzLl92YWx1ZXMpO1xuICAgIH1cbiAgICBzY29wZUNvZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5zY29wZUNvZGUodGhpcy5fdmFsdWVzKTtcbiAgICB9XG4gICAgX2RlZih2YXJLaW5kLCBuYW1lT3JQcmVmaXgsIHJocywgY29uc3RhbnQpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX3Njb3BlLnRvTmFtZShuYW1lT3JQcmVmaXgpO1xuICAgICAgICBpZiAocmhzICE9PSB1bmRlZmluZWQgJiYgY29uc3RhbnQpXG4gICAgICAgICAgICB0aGlzLl9jb25zdGFudHNbbmFtZS5zdHJdID0gcmhzO1xuICAgICAgICB0aGlzLl9sZWFmTm9kZShuZXcgRGVmKHZhcktpbmQsIG5hbWUsIHJocykpO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgLy8gYGNvbnN0YCBkZWNsYXJhdGlvbiAoYHZhcmAgaW4gZXM1IG1vZGUpXG4gICAgY29uc3QobmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmKHNjb3BlXzEudmFyS2luZHMuY29uc3QsIG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpO1xuICAgIH1cbiAgICAvLyBgbGV0YCBkZWNsYXJhdGlvbiB3aXRoIG9wdGlvbmFsIGFzc2lnbm1lbnQgKGB2YXJgIGluIGVzNSBtb2RlKVxuICAgIGxldChuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYoc2NvcGVfMS52YXJLaW5kcy5sZXQsIG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpO1xuICAgIH1cbiAgICAvLyBgdmFyYCBkZWNsYXJhdGlvbiB3aXRoIG9wdGlvbmFsIGFzc2lnbm1lbnRcbiAgICB2YXIobmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmKHNjb3BlXzEudmFyS2luZHMudmFyLCBuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KTtcbiAgICB9XG4gICAgLy8gYXNzaWdubWVudCBjb2RlXG4gICAgYXNzaWduKGxocywgcmhzLCBzaWRlRWZmZWN0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IEFzc2lnbihsaHMsIHJocywgc2lkZUVmZmVjdHMpKTtcbiAgICB9XG4gICAgLy8gYCs9YCBjb2RlXG4gICAgYWRkKGxocywgcmhzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgQXNzaWduT3AobGhzLCBleHBvcnRzLm9wZXJhdG9ycy5BREQsIHJocykpO1xuICAgIH1cbiAgICAvLyBhcHBlbmRzIHBhc3NlZCBTYWZlRXhwciB0byBjb2RlIG9yIGV4ZWN1dGVzIEJsb2NrXG4gICAgY29kZShjKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBjKCk7XG4gICAgICAgIGVsc2UgaWYgKGMgIT09IGNvZGVfMS5uaWwpXG4gICAgICAgICAgICB0aGlzLl9sZWFmTm9kZShuZXcgQW55Q29kZShjKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyByZXR1cm5zIGNvZGUgZm9yIG9iamVjdCBsaXRlcmFsIGZvciB0aGUgcGFzc2VkIGFyZ3VtZW50IGxpc3Qgb2Yga2V5LXZhbHVlIHBhaXJzXG4gICAgb2JqZWN0KC4uLmtleVZhbHVlcykge1xuICAgICAgICBjb25zdCBjb2RlID0gW1wie1wiXTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Yga2V5VmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAoY29kZS5sZW5ndGggPiAxKVxuICAgICAgICAgICAgICAgIGNvZGUucHVzaChcIixcIik7XG4gICAgICAgICAgICBjb2RlLnB1c2goa2V5KTtcbiAgICAgICAgICAgIGlmIChrZXkgIT09IHZhbHVlIHx8IHRoaXMub3B0cy5lczUpIHtcbiAgICAgICAgICAgICAgICBjb2RlLnB1c2goXCI6XCIpO1xuICAgICAgICAgICAgICAgIGNvZGVfMS5hZGRDb2RlQXJnKGNvZGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb2RlLnB1c2goXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbmV3IGNvZGVfMS5fQ29kZShjb2RlKTtcbiAgICB9XG4gICAgLy8gYGlmYCBjbGF1c2UgKG9yIHN0YXRlbWVudCBpZiBgdGhlbkJvZHlgIGFuZCwgb3B0aW9uYWxseSwgYGVsc2VCb2R5YCBhcmUgcGFzc2VkKVxuICAgIGlmKGNvbmRpdGlvbiwgdGhlbkJvZHksIGVsc2VCb2R5KSB7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShuZXcgSWYoY29uZGl0aW9uKSk7XG4gICAgICAgIGlmICh0aGVuQm9keSAmJiBlbHNlQm9keSkge1xuICAgICAgICAgICAgdGhpcy5jb2RlKHRoZW5Cb2R5KS5lbHNlKCkuY29kZShlbHNlQm9keSkuZW5kSWYoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGVuQm9keSkge1xuICAgICAgICAgICAgdGhpcy5jb2RlKHRoZW5Cb2R5KS5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsc2VCb2R5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwiZWxzZVwiIGJvZHkgd2l0aG91dCBcInRoZW5cIiBib2R5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGBlbHNlIGlmYCBjbGF1c2UgLSBpbnZhbGlkIHdpdGhvdXQgYGlmYCBvciBhZnRlciBgZWxzZWAgY2xhdXNlc1xuICAgIGVsc2VJZihjb25kaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vsc2VOb2RlKG5ldyBJZihjb25kaXRpb24pKTtcbiAgICB9XG4gICAgLy8gYGVsc2VgIGNsYXVzZSAtIG9ubHkgdmFsaWQgYWZ0ZXIgYGlmYCBvciBgZWxzZSBpZmAgY2xhdXNlc1xuICAgIGVsc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbHNlTm9kZShuZXcgRWxzZSgpKTtcbiAgICB9XG4gICAgLy8gZW5kIGBpZmAgc3RhdGVtZW50IChuZWVkZWQgaWYgZ2VuLmlmIHdhcyB1c2VkIG9ubHkgd2l0aCBjb25kaXRpb24pXG4gICAgZW5kSWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoSWYsIEVsc2UpO1xuICAgIH1cbiAgICBfZm9yKG5vZGUsIGZvckJvZHkpIHtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5vZGUpO1xuICAgICAgICBpZiAoZm9yQm9keSlcbiAgICAgICAgICAgIHRoaXMuY29kZShmb3JCb2R5KS5lbmRGb3IoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGEgZ2VuZXJpYyBgZm9yYCBjbGF1c2UgKG9yIHN0YXRlbWVudCBpZiBgZm9yQm9keWAgaXMgcGFzc2VkKVxuICAgIGZvcihpdGVyYXRpb24sIGZvckJvZHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9yTG9vcChpdGVyYXRpb24pLCBmb3JCb2R5KTtcbiAgICB9XG4gICAgLy8gYGZvcmAgc3RhdGVtZW50IGZvciBhIHJhbmdlIG9mIHZhbHVlc1xuICAgIGZvclJhbmdlKG5hbWVPclByZWZpeCwgZnJvbSwgdG8sIGZvckJvZHksIHZhcktpbmQgPSB0aGlzLm9wdHMuZXM1ID8gc2NvcGVfMS52YXJLaW5kcy52YXIgOiBzY29wZV8xLnZhcktpbmRzLmxldCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvclJhbmdlKHZhcktpbmQsIG5hbWUsIGZyb20sIHRvKSwgKCkgPT4gZm9yQm9keShuYW1lKSk7XG4gICAgfVxuICAgIC8vIGBmb3Itb2ZgIHN0YXRlbWVudCAoaW4gZXM1IG1vZGUgcmVwbGFjZSB3aXRoIGEgbm9ybWFsIGZvciBsb29wKVxuICAgIGZvck9mKG5hbWVPclByZWZpeCwgaXRlcmFibGUsIGZvckJvZHksIHZhcktpbmQgPSBzY29wZV8xLnZhcktpbmRzLmNvbnN0KSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5lczUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyciA9IGl0ZXJhYmxlIGluc3RhbmNlb2YgY29kZV8xLk5hbWUgPyBpdGVyYWJsZSA6IHRoaXMudmFyKFwiX2FyclwiLCBpdGVyYWJsZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JSYW5nZShcIl9pXCIsIDAsIGNvZGVfMS5fIGAke2Fycn0ubGVuZ3RoYCwgKGkpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhcihuYW1lLCBjb2RlXzEuXyBgJHthcnJ9WyR7aX1dYCk7XG4gICAgICAgICAgICAgICAgZm9yQm9keShuYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvckl0ZXIoXCJvZlwiLCB2YXJLaW5kLCBuYW1lLCBpdGVyYWJsZSksICgpID0+IGZvckJvZHkobmFtZSkpO1xuICAgIH1cbiAgICAvLyBgZm9yLWluYCBzdGF0ZW1lbnQuXG4gICAgLy8gV2l0aCBvcHRpb24gYG93blByb3BlcnRpZXNgIHJlcGxhY2VkIHdpdGggYSBgZm9yLW9mYCBsb29wIGZvciBvYmplY3Qga2V5c1xuICAgIGZvckluKG5hbWVPclByZWZpeCwgb2JqLCBmb3JCb2R5LCB2YXJLaW5kID0gdGhpcy5vcHRzLmVzNSA/IHNjb3BlXzEudmFyS2luZHMudmFyIDogc2NvcGVfMS52YXJLaW5kcy5jb25zdCkge1xuICAgICAgICBpZiAodGhpcy5vcHRzLm93blByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvck9mKG5hbWVPclByZWZpeCwgY29kZV8xLl8gYE9iamVjdC5rZXlzKCR7b2JqfSlgLCBmb3JCb2R5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvckl0ZXIoXCJpblwiLCB2YXJLaW5kLCBuYW1lLCBvYmopLCAoKSA9PiBmb3JCb2R5KG5hbWUpKTtcbiAgICB9XG4gICAgLy8gZW5kIGBmb3JgIGxvb3BcbiAgICBlbmRGb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoRm9yKTtcbiAgICB9XG4gICAgLy8gYGxhYmVsYCBzdGF0ZW1lbnRcbiAgICBsYWJlbChsYWJlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IExhYmVsKGxhYmVsKSk7XG4gICAgfVxuICAgIC8vIGBicmVha2Agc3RhdGVtZW50XG4gICAgYnJlYWsobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBCcmVhayhsYWJlbCkpO1xuICAgIH1cbiAgICAvLyBgcmV0dXJuYCBzdGF0ZW1lbnRcbiAgICByZXR1cm4odmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBSZXR1cm4oKTtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5vZGUpO1xuICAgICAgICB0aGlzLmNvZGUodmFsdWUpO1xuICAgICAgICBpZiAobm9kZS5ub2Rlcy5sZW5ndGggIT09IDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwicmV0dXJuXCIgc2hvdWxkIGhhdmUgb25lIG5vZGUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShSZXR1cm4pO1xuICAgIH1cbiAgICAvLyBgdHJ5YCBzdGF0ZW1lbnRcbiAgICB0cnkodHJ5Qm9keSwgY2F0Y2hDb2RlLCBmaW5hbGx5Q29kZSkge1xuICAgICAgICBpZiAoIWNhdGNoQ29kZSAmJiAhZmluYWxseUNvZGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwidHJ5XCIgd2l0aG91dCBcImNhdGNoXCIgYW5kIFwiZmluYWxseVwiJyk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgVHJ5KCk7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShub2RlKTtcbiAgICAgICAgdGhpcy5jb2RlKHRyeUJvZHkpO1xuICAgICAgICBpZiAoY2F0Y2hDb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMubmFtZShcImVcIik7XG4gICAgICAgICAgICB0aGlzLl9jdXJyTm9kZSA9IG5vZGUuY2F0Y2ggPSBuZXcgQ2F0Y2goZXJyb3IpO1xuICAgICAgICAgICAgY2F0Y2hDb2RlKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmluYWxseUNvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJOb2RlID0gbm9kZS5maW5hbGx5ID0gbmV3IEZpbmFsbHkoKTtcbiAgICAgICAgICAgIHRoaXMuY29kZShmaW5hbGx5Q29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShDYXRjaCwgRmluYWxseSk7XG4gICAgfVxuICAgIC8vIGB0aHJvd2Agc3RhdGVtZW50XG4gICAgdGhyb3coZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBUaHJvdyhlcnJvcikpO1xuICAgIH1cbiAgICAvLyBzdGFydCBzZWxmLWJhbGFuY2luZyBibG9ja1xuICAgIGJsb2NrKGJvZHksIG5vZGVDb3VudCkge1xuICAgICAgICB0aGlzLl9ibG9ja1N0YXJ0cy5wdXNoKHRoaXMuX25vZGVzLmxlbmd0aCk7XG4gICAgICAgIGlmIChib2R5KVxuICAgICAgICAgICAgdGhpcy5jb2RlKGJvZHkpLmVuZEJsb2NrKG5vZGVDb3VudCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBlbmQgdGhlIGN1cnJlbnQgc2VsZi1iYWxhbmNpbmcgYmxvY2tcbiAgICBlbmRCbG9jayhub2RlQ291bnQpIHtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5fYmxvY2tTdGFydHMucG9wKCk7XG4gICAgICAgIGlmIChsZW4gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvZGVHZW46IG5vdCBpbiBzZWxmLWJhbGFuY2luZyBibG9ja1wiKTtcbiAgICAgICAgY29uc3QgdG9DbG9zZSA9IHRoaXMuX25vZGVzLmxlbmd0aCAtIGxlbjtcbiAgICAgICAgaWYgKHRvQ2xvc2UgPCAwIHx8IChub2RlQ291bnQgIT09IHVuZGVmaW5lZCAmJiB0b0Nsb3NlICE9PSBub2RlQ291bnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IHdyb25nIG51bWJlciBvZiBub2RlczogJHt0b0Nsb3NlfSB2cyAke25vZGVDb3VudH0gZXhwZWN0ZWRgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ub2Rlcy5sZW5ndGggPSBsZW47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBgZnVuY3Rpb25gIGhlYWRpbmcgKG9yIGRlZmluaXRpb24gaWYgZnVuY0JvZHkgaXMgcGFzc2VkKVxuICAgIGZ1bmMobmFtZSwgYXJncyA9IGNvZGVfMS5uaWwsIGFzeW5jLCBmdW5jQm9keSkge1xuICAgICAgICB0aGlzLl9ibG9ja05vZGUobmV3IEZ1bmMobmFtZSwgYXJncywgYXN5bmMpKTtcbiAgICAgICAgaWYgKGZ1bmNCb2R5KVxuICAgICAgICAgICAgdGhpcy5jb2RlKGZ1bmNCb2R5KS5lbmRGdW5jKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBlbmQgZnVuY3Rpb24gZGVmaW5pdGlvblxuICAgIGVuZEZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoRnVuYyk7XG4gICAgfVxuICAgIG9wdGltaXplKG4gPSAxKSB7XG4gICAgICAgIHdoaWxlIChuLS0gPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yb290Lm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3Qub3B0aW1pemVOYW1lcyh0aGlzLl9yb290Lm5hbWVzLCB0aGlzLl9jb25zdGFudHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9sZWFmTm9kZShub2RlKSB7XG4gICAgICAgIHRoaXMuX2N1cnJOb2RlLm5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBfYmxvY2tOb2RlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5fY3Vyck5vZGUubm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy5fbm9kZXMucHVzaChub2RlKTtcbiAgICB9XG4gICAgX2VuZEJsb2NrTm9kZShOMSwgTjIpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX2N1cnJOb2RlO1xuICAgICAgICBpZiAobiBpbnN0YW5jZW9mIE4xIHx8IChOMiAmJiBuIGluc3RhbmNlb2YgTjIpKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2Rlcy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogbm90IGluIGJsb2NrIFwiJHtOMiA/IGAke04xLmtpbmR9LyR7TjIua2luZH1gIDogTjEua2luZH1cImApO1xuICAgIH1cbiAgICBfZWxzZU5vZGUobm9kZSkge1xuICAgICAgICBjb25zdCBuID0gdGhpcy5fY3Vyck5vZGU7XG4gICAgICAgIGlmICghKG4gaW5zdGFuY2VvZiBJZikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJlbHNlXCIgd2l0aG91dCBcImlmXCInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJyTm9kZSA9IG4uZWxzZSA9IG5vZGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgX3Jvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub2Rlc1swXTtcbiAgICB9XG4gICAgZ2V0IF9jdXJyTm9kZSgpIHtcbiAgICAgICAgY29uc3QgbnMgPSB0aGlzLl9ub2RlcztcbiAgICAgICAgcmV0dXJuIG5zW25zLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBzZXQgX2N1cnJOb2RlKG5vZGUpIHtcbiAgICAgICAgY29uc3QgbnMgPSB0aGlzLl9ub2RlcztcbiAgICAgICAgbnNbbnMubGVuZ3RoIC0gMV0gPSBub2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29kZUdlbiA9IENvZGVHZW47XG5mdW5jdGlvbiBhZGROYW1lcyhuYW1lcywgZnJvbSkge1xuICAgIGZvciAoY29uc3QgbiBpbiBmcm9tKVxuICAgICAgICBuYW1lc1tuXSA9IChuYW1lc1tuXSB8fCAwKSArIChmcm9tW25dIHx8IDApO1xuICAgIHJldHVybiBuYW1lcztcbn1cbmZ1bmN0aW9uIGFkZEV4cHJOYW1lcyhuYW1lcywgZnJvbSkge1xuICAgIHJldHVybiBmcm9tIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlT3JOYW1lID8gYWRkTmFtZXMobmFtZXMsIGZyb20ubmFtZXMpIDogbmFtZXM7XG59XG5mdW5jdGlvbiBvcHRpbWl6ZUV4cHIoZXhwciwgbmFtZXMsIGNvbnN0YW50cykge1xuICAgIGlmIChleHByIGluc3RhbmNlb2YgY29kZV8xLk5hbWUpXG4gICAgICAgIHJldHVybiByZXBsYWNlTmFtZShleHByKTtcbiAgICBpZiAoIWNhbk9wdGltaXplKGV4cHIpKVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICByZXR1cm4gbmV3IGNvZGVfMS5fQ29kZShleHByLl9pdGVtcy5yZWR1Y2UoKGl0ZW1zLCBjKSA9PiB7XG4gICAgICAgIGlmIChjIGluc3RhbmNlb2YgY29kZV8xLk5hbWUpXG4gICAgICAgICAgICBjID0gcmVwbGFjZU5hbWUoYyk7XG4gICAgICAgIGlmIChjIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlKVxuICAgICAgICAgICAgaXRlbXMucHVzaCguLi5jLl9pdGVtcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goYyk7XG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9LCBbXSkpO1xuICAgIGZ1bmN0aW9uIHJlcGxhY2VOYW1lKG4pIHtcbiAgICAgICAgY29uc3QgYyA9IGNvbnN0YW50c1tuLnN0cl07XG4gICAgICAgIGlmIChjID09PSB1bmRlZmluZWQgfHwgbmFtZXNbbi5zdHJdICE9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIGRlbGV0ZSBuYW1lc1tuLnN0cl07XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5PcHRpbWl6ZShlKSB7XG4gICAgICAgIHJldHVybiAoZSBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZSAmJlxuICAgICAgICAgICAgZS5faXRlbXMuc29tZSgoYykgPT4gYyBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lICYmIG5hbWVzW2Muc3RyXSA9PT0gMSAmJiBjb25zdGFudHNbYy5zdHJdICE9PSB1bmRlZmluZWQpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJ0cmFjdE5hbWVzKG5hbWVzLCBmcm9tKSB7XG4gICAgZm9yIChjb25zdCBuIGluIGZyb20pXG4gICAgICAgIG5hbWVzW25dID0gKG5hbWVzW25dIHx8IDApIC0gKGZyb21bbl0gfHwgMCk7XG59XG5mdW5jdGlvbiBub3QoeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PSBcImJvb2xlYW5cIiB8fCB0eXBlb2YgeCA9PSBcIm51bWJlclwiIHx8IHggPT09IG51bGwgPyAheCA6IGNvZGVfMS5fIGAhJHtwYXIoeCl9YDtcbn1cbmV4cG9ydHMubm90ID0gbm90O1xuY29uc3QgYW5kQ29kZSA9IG1hcHBlbmQoZXhwb3J0cy5vcGVyYXRvcnMuQU5EKTtcbi8vIGJvb2xlYW4gQU5EICgmJikgZXhwcmVzc2lvbiB3aXRoIHRoZSBwYXNzZWQgYXJndW1lbnRzXG5mdW5jdGlvbiBhbmQoLi4uYXJncykge1xuICAgIHJldHVybiBhcmdzLnJlZHVjZShhbmRDb2RlKTtcbn1cbmV4cG9ydHMuYW5kID0gYW5kO1xuY29uc3Qgb3JDb2RlID0gbWFwcGVuZChleHBvcnRzLm9wZXJhdG9ycy5PUik7XG4vLyBib29sZWFuIE9SICh8fCkgZXhwcmVzc2lvbiB3aXRoIHRoZSBwYXNzZWQgYXJndW1lbnRzXG5mdW5jdGlvbiBvciguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGFyZ3MucmVkdWNlKG9yQ29kZSk7XG59XG5leHBvcnRzLm9yID0gb3I7XG5mdW5jdGlvbiBtYXBwZW5kKG9wKSB7XG4gICAgcmV0dXJuICh4LCB5KSA9PiAoeCA9PT0gY29kZV8xLm5pbCA/IHkgOiB5ID09PSBjb2RlXzEubmlsID8geCA6IGNvZGVfMS5fIGAke3Bhcih4KX0gJHtvcH0gJHtwYXIoeSl9YCk7XG59XG5mdW5jdGlvbiBwYXIoeCkge1xuICAgIHJldHVybiB4IGluc3RhbmNlb2YgY29kZV8xLk5hbWUgPyB4IDogY29kZV8xLl8gYCgke3h9KWA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hlY2tTdHJpY3RNb2RlID0gZXhwb3J0cy5nZXRFcnJvclBhdGggPSBleHBvcnRzLlR5cGUgPSBleHBvcnRzLnVzZUZ1bmMgPSBleHBvcnRzLnNldEV2YWx1YXRlZCA9IGV4cG9ydHMuZXZhbHVhdGVkUHJvcHNUb05hbWUgPSBleHBvcnRzLm1lcmdlRXZhbHVhdGVkID0gZXhwb3J0cy5lYWNoSXRlbSA9IGV4cG9ydHMudW5lc2NhcGVKc29uUG9pbnRlciA9IGV4cG9ydHMuZXNjYXBlSnNvblBvaW50ZXIgPSBleHBvcnRzLmVzY2FwZUZyYWdtZW50ID0gZXhwb3J0cy51bmVzY2FwZUZyYWdtZW50ID0gZXhwb3J0cy5zY2hlbWFSZWZPclZhbCA9IGV4cG9ydHMuc2NoZW1hSGFzUnVsZXNCdXRSZWYgPSBleHBvcnRzLnNjaGVtYUhhc1J1bGVzID0gZXhwb3J0cy5jaGVja1Vua25vd25SdWxlcyA9IGV4cG9ydHMuYWx3YXlzVmFsaWRTY2hlbWEgPSBleHBvcnRzLnRvSGFzaCA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW5cIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuL2NvZGVcIik7XG4vLyBUT0RPIHJlZmFjdG9yIHRvIHVzZSBTZXRcbmZ1bmN0aW9uIHRvSGFzaChhcnIpIHtcbiAgICBjb25zdCBoYXNoID0ge307XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFycilcbiAgICAgICAgaGFzaFtpdGVtXSA9IHRydWU7XG4gICAgcmV0dXJuIGhhc2g7XG59XG5leHBvcnRzLnRvSGFzaCA9IHRvSGFzaDtcbmZ1bmN0aW9uIGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICBpZiAoT2JqZWN0LmtleXMoc2NoZW1hKS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGNoZWNrVW5rbm93blJ1bGVzKGl0LCBzY2hlbWEpO1xuICAgIHJldHVybiAhc2NoZW1hSGFzUnVsZXMoc2NoZW1hLCBpdC5zZWxmLlJVTEVTLmFsbCk7XG59XG5leHBvcnRzLmFsd2F5c1ZhbGlkU2NoZW1hID0gYWx3YXlzVmFsaWRTY2hlbWE7XG5mdW5jdGlvbiBjaGVja1Vua25vd25SdWxlcyhpdCwgc2NoZW1hID0gaXQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICBpZiAoIW9wdHMuc3RyaWN0U2NoZW1hKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgcnVsZXMgPSBzZWxmLlJVTEVTLmtleXdvcmRzO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBpZiAoIXJ1bGVzW2tleV0pXG4gICAgICAgICAgICBjaGVja1N0cmljdE1vZGUoaXQsIGB1bmtub3duIGtleXdvcmQ6IFwiJHtrZXl9XCJgKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrVW5rbm93blJ1bGVzID0gY2hlY2tVbmtub3duUnVsZXM7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlcyhzY2hlbWEsIHJ1bGVzKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiAhc2NoZW1hO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSlcbiAgICAgICAgaWYgKHJ1bGVzW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzID0gc2NoZW1hSGFzUnVsZXM7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlc0J1dFJlZihzY2hlbWEsIFJVTEVTKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiAhc2NoZW1hO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSlcbiAgICAgICAgaWYgKGtleSAhPT0gXCIkcmVmXCIgJiYgUlVMRVMuYWxsW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzQnV0UmVmID0gc2NoZW1hSGFzUnVsZXNCdXRSZWY7XG5mdW5jdGlvbiBzY2hlbWFSZWZPclZhbCh7IHRvcFNjaGVtYVJlZiwgc2NoZW1hUGF0aCB9LCBzY2hlbWEsIGtleXdvcmQsICRkYXRhKSB7XG4gICAgaWYgKCEkZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm51bWJlclwiIHx8IHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5fIGAke3NjaGVtYX1gO1xuICAgIH1cbiAgICByZXR1cm4gY29kZWdlbl8xLl8gYCR7dG9wU2NoZW1hUmVmfSR7c2NoZW1hUGF0aH0ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eShrZXl3b3JkKX1gO1xufVxuZXhwb3J0cy5zY2hlbWFSZWZPclZhbCA9IHNjaGVtYVJlZk9yVmFsO1xuZnVuY3Rpb24gdW5lc2NhcGVGcmFnbWVudChzdHIpIHtcbiAgICByZXR1cm4gdW5lc2NhcGVKc29uUG9pbnRlcihkZWNvZGVVUklDb21wb25lbnQoc3RyKSk7XG59XG5leHBvcnRzLnVuZXNjYXBlRnJhZ21lbnQgPSB1bmVzY2FwZUZyYWdtZW50O1xuZnVuY3Rpb24gZXNjYXBlRnJhZ21lbnQoc3RyKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlc2NhcGVKc29uUG9pbnRlcihzdHIpKTtcbn1cbmV4cG9ydHMuZXNjYXBlRnJhZ21lbnQgPSBlc2NhcGVGcmFnbWVudDtcbmZ1bmN0aW9uIGVzY2FwZUpzb25Qb2ludGVyKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyID09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBgJHtzdHJ9YDtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXC8vZywgXCJ+MVwiKTtcbn1cbmV4cG9ydHMuZXNjYXBlSnNvblBvaW50ZXIgPSBlc2NhcGVKc29uUG9pbnRlcjtcbmZ1bmN0aW9uIHVuZXNjYXBlSnNvblBvaW50ZXIoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+MS9nLCBcIi9cIikucmVwbGFjZSgvfjAvZywgXCJ+XCIpO1xufVxuZXhwb3J0cy51bmVzY2FwZUpzb25Qb2ludGVyID0gdW5lc2NhcGVKc29uUG9pbnRlcjtcbmZ1bmN0aW9uIGVhY2hJdGVtKHhzLCBmKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoeHMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgeCBvZiB4cylcbiAgICAgICAgICAgIGYoeCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmKHhzKTtcbiAgICB9XG59XG5leHBvcnRzLmVhY2hJdGVtID0gZWFjaEl0ZW07XG5mdW5jdGlvbiBtYWtlTWVyZ2VFdmFsdWF0ZWQoeyBtZXJnZU5hbWVzLCBtZXJnZVRvTmFtZSwgbWVyZ2VWYWx1ZXMsIHJlc3VsdFRvTmFtZSwgfSkge1xuICAgIHJldHVybiAoZ2VuLCBmcm9tLCB0bywgdG9OYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRvID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gZnJvbVxuICAgICAgICAgICAgOiB0byBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lXG4gICAgICAgICAgICAgICAgPyAoZnJvbSBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lID8gbWVyZ2VOYW1lcyhnZW4sIGZyb20sIHRvKSA6IG1lcmdlVG9OYW1lKGdlbiwgZnJvbSwgdG8pLCB0bylcbiAgICAgICAgICAgICAgICA6IGZyb20gaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZVxuICAgICAgICAgICAgICAgICAgICA/IChtZXJnZVRvTmFtZShnZW4sIHRvLCBmcm9tKSwgZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgOiBtZXJnZVZhbHVlcyhmcm9tLCB0byk7XG4gICAgICAgIHJldHVybiB0b05hbWUgPT09IGNvZGVnZW5fMS5OYW1lICYmICEocmVzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpID8gcmVzdWx0VG9OYW1lKGdlbiwgcmVzKSA6IHJlcztcbiAgICB9O1xufVxuZXhwb3J0cy5tZXJnZUV2YWx1YXRlZCA9IHtcbiAgICBwcm9wczogbWFrZU1lcmdlRXZhbHVhdGVkKHtcbiAgICAgICAgbWVyZ2VOYW1lczogKGdlbiwgZnJvbSwgdG8pID0+IGdlbi5pZihjb2RlZ2VuXzEuXyBgJHt0b30gIT09IHRydWUgJiYgJHtmcm9tfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4ge1xuICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2Zyb219ID09PSB0cnVlYCwgKCkgPT4gZ2VuLmFzc2lnbih0bywgdHJ1ZSksICgpID0+IGdlbi5hc3NpZ24odG8sIGNvZGVnZW5fMS5fIGAke3RvfSB8fCB7fWApLmNvZGUoY29kZWdlbl8xLl8gYE9iamVjdC5hc3NpZ24oJHt0b30sICR7ZnJvbX0pYCkpO1xuICAgICAgICB9KSxcbiAgICAgICAgbWVyZ2VUb05hbWU6IChnZW4sIGZyb20sIHRvKSA9PiBnZW4uaWYoY29kZWdlbl8xLl8gYCR7dG99ICE9PSB0cnVlYCwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZyb20gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHRvLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odG8sIGNvZGVnZW5fMS5fIGAke3RvfSB8fCB7fWApO1xuICAgICAgICAgICAgICAgIHNldEV2YWx1YXRlZChnZW4sIHRvLCBmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIG1lcmdlVmFsdWVzOiAoZnJvbSwgdG8pID0+IChmcm9tID09PSB0cnVlID8gdHJ1ZSA6IHsgLi4uZnJvbSwgLi4udG8gfSksXG4gICAgICAgIHJlc3VsdFRvTmFtZTogZXZhbHVhdGVkUHJvcHNUb05hbWUsXG4gICAgfSksXG4gICAgaXRlbXM6IG1ha2VNZXJnZUV2YWx1YXRlZCh7XG4gICAgICAgIG1lcmdlTmFtZXM6IChnZW4sIGZyb20sIHRvKSA9PiBnZW4uaWYoY29kZWdlbl8xLl8gYCR7dG99ICE9PSB0cnVlICYmICR7ZnJvbX0gIT09IHVuZGVmaW5lZGAsICgpID0+IGdlbi5hc3NpZ24odG8sIGNvZGVnZW5fMS5fIGAke2Zyb219ID09PSB0cnVlID8gdHJ1ZSA6ICR7dG99ID4gJHtmcm9tfSA/ICR7dG99IDogJHtmcm9tfWApKSxcbiAgICAgICAgbWVyZ2VUb05hbWU6IChnZW4sIGZyb20sIHRvKSA9PiBnZW4uaWYoY29kZWdlbl8xLl8gYCR7dG99ICE9PSB0cnVlYCwgKCkgPT4gZ2VuLmFzc2lnbih0bywgZnJvbSA9PT0gdHJ1ZSA/IHRydWUgOiBjb2RlZ2VuXzEuXyBgJHt0b30gPiAke2Zyb219ID8gJHt0b30gOiAke2Zyb219YCkpLFxuICAgICAgICBtZXJnZVZhbHVlczogKGZyb20sIHRvKSA9PiAoZnJvbSA9PT0gdHJ1ZSA/IHRydWUgOiBNYXRoLm1heChmcm9tLCB0bykpLFxuICAgICAgICByZXN1bHRUb05hbWU6IChnZW4sIGl0ZW1zKSA9PiBnZW4udmFyKFwiaXRlbXNcIiwgaXRlbXMpLFxuICAgIH0pLFxufTtcbmZ1bmN0aW9uIGV2YWx1YXRlZFByb3BzVG9OYW1lKGdlbiwgcHMpIHtcbiAgICBpZiAocHMgPT09IHRydWUpXG4gICAgICAgIHJldHVybiBnZW4udmFyKFwicHJvcHNcIiwgdHJ1ZSk7XG4gICAgY29uc3QgcHJvcHMgPSBnZW4udmFyKFwicHJvcHNcIiwgY29kZWdlbl8xLl8gYHt9YCk7XG4gICAgaWYgKHBzICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHNldEV2YWx1YXRlZChnZW4sIHByb3BzLCBwcyk7XG4gICAgcmV0dXJuIHByb3BzO1xufVxuZXhwb3J0cy5ldmFsdWF0ZWRQcm9wc1RvTmFtZSA9IGV2YWx1YXRlZFByb3BzVG9OYW1lO1xuZnVuY3Rpb24gc2V0RXZhbHVhdGVkKGdlbiwgcHJvcHMsIHBzKSB7XG4gICAgT2JqZWN0LmtleXMocHMpLmZvckVhY2goKHApID0+IGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7cHJvcHN9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkocCl9YCwgdHJ1ZSkpO1xufVxuZXhwb3J0cy5zZXRFdmFsdWF0ZWQgPSBzZXRFdmFsdWF0ZWQ7XG5jb25zdCBzbmlwcGV0cyA9IHt9O1xuZnVuY3Rpb24gdXNlRnVuYyhnZW4sIGYpIHtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJmdW5jXCIsIHtcbiAgICAgICAgcmVmOiBmLFxuICAgICAgICBjb2RlOiBzbmlwcGV0c1tmLmNvZGVdIHx8IChzbmlwcGV0c1tmLmNvZGVdID0gbmV3IGNvZGVfMS5fQ29kZShmLmNvZGUpKSxcbiAgICB9KTtcbn1cbmV4cG9ydHMudXNlRnVuYyA9IHVzZUZ1bmM7XG52YXIgVHlwZTtcbihmdW5jdGlvbiAoVHlwZSkge1xuICAgIFR5cGVbVHlwZVtcIk51bVwiXSA9IDBdID0gXCJOdW1cIjtcbiAgICBUeXBlW1R5cGVbXCJTdHJcIl0gPSAxXSA9IFwiU3RyXCI7XG59KShUeXBlID0gZXhwb3J0cy5UeXBlIHx8IChleHBvcnRzLlR5cGUgPSB7fSkpO1xuZnVuY3Rpb24gZ2V0RXJyb3JQYXRoKGRhdGFQcm9wLCBkYXRhUHJvcFR5cGUsIGpzUHJvcGVydHlTeW50YXgpIHtcbiAgICAvLyBsZXQgcGF0aFxuICAgIGlmIChkYXRhUHJvcCBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKSB7XG4gICAgICAgIGNvbnN0IGlzTnVtYmVyID0gZGF0YVByb3BUeXBlID09PSBUeXBlLk51bTtcbiAgICAgICAgcmV0dXJuIGpzUHJvcGVydHlTeW50YXhcbiAgICAgICAgICAgID8gaXNOdW1iZXJcbiAgICAgICAgICAgICAgICA/IGNvZGVnZW5fMS5fIGBcIltcIiArICR7ZGF0YVByb3B9ICsgXCJdXCJgXG4gICAgICAgICAgICAgICAgOiBjb2RlZ2VuXzEuXyBgXCJbJ1wiICsgJHtkYXRhUHJvcH0gKyBcIiddXCJgXG4gICAgICAgICAgICA6IGlzTnVtYmVyXG4gICAgICAgICAgICAgICAgPyBjb2RlZ2VuXzEuXyBgXCIvXCIgKyAke2RhdGFQcm9wfWBcbiAgICAgICAgICAgICAgICA6IGNvZGVnZW5fMS5fIGBcIi9cIiArICR7ZGF0YVByb3B9LnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXFxcLy9nLCBcIn4xXCIpYDsgLy8gVE9ETyBtYXliZSB1c2UgZ2xvYmFsIGVzY2FwZVBvaW50ZXJcbiAgICB9XG4gICAgcmV0dXJuIGpzUHJvcGVydHlTeW50YXggPyBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkoZGF0YVByb3ApLnRvU3RyaW5nKCkgOiBcIi9cIiArIGVzY2FwZUpzb25Qb2ludGVyKGRhdGFQcm9wKTtcbn1cbmV4cG9ydHMuZ2V0RXJyb3JQYXRoID0gZ2V0RXJyb3JQYXRoO1xuZnVuY3Rpb24gY2hlY2tTdHJpY3RNb2RlKGl0LCBtc2csIG1vZGUgPSBpdC5vcHRzLnN0cmljdFNjaGVtYSkge1xuICAgIGlmICghbW9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIG1zZyA9IGBzdHJpY3QgbW9kZTogJHttc2d9YDtcbiAgICBpZiAobW9kZSA9PT0gdHJ1ZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgaXQuc2VsZi5sb2dnZXIud2Fybihtc2cpO1xufVxuZXhwb3J0cy5jaGVja1N0cmljdE1vZGUgPSBjaGVja1N0cmljdE1vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4vY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzID0ge1xuICAgIC8vIHZhbGlkYXRpb24gZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgZGF0YTogbmV3IGNvZGVnZW5fMS5OYW1lKFwiZGF0YVwiKSxcbiAgICAvLyBhcmdzIHBhc3NlZCBmcm9tIHJlZmVyZW5jaW5nIHNjaGVtYVxuICAgIHZhbEN4dDogbmV3IGNvZGVnZW5fMS5OYW1lKFwidmFsQ3h0XCIpLFxuICAgIGluc3RhbmNlUGF0aDogbmV3IGNvZGVnZW5fMS5OYW1lKFwiaW5zdGFuY2VQYXRoXCIpLFxuICAgIHBhcmVudERhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmVudERhdGFcIiksXG4gICAgcGFyZW50RGF0YVByb3BlcnR5OiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwYXJlbnREYXRhUHJvcGVydHlcIiksXG4gICAgcm9vdERhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInJvb3REYXRhXCIpLFxuICAgIGR5bmFtaWNBbmNob3JzOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJkeW5hbWljQW5jaG9yc1wiKSxcbiAgICAvLyBmdW5jdGlvbiBzY29wZWQgdmFyaWFibGVzXG4gICAgdkVycm9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwidkVycm9yc1wiKSxcbiAgICBlcnJvcnM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImVycm9yc1wiKSxcbiAgICB0aGlzOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJ0aGlzXCIpLFxuICAgIC8vIFwiZ2xvYmFsc1wiXG4gICAgc2VsZjogbmV3IGNvZGVnZW5fMS5OYW1lKFwic2VsZlwiKSxcbiAgICBzY29wZTogbmV3IGNvZGVnZW5fMS5OYW1lKFwic2NvcGVcIiksXG4gICAgLy8gSlREIHNlcmlhbGl6ZS9wYXJzZSBuYW1lIGZvciBKU09OIHN0cmluZyBhbmQgcG9zaXRpb25cbiAgICBqc29uOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJqc29uXCIpLFxuICAgIGpzb25Qb3M6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImpzb25Qb3NcIiksXG4gICAganNvbkxlbjogbmV3IGNvZGVnZW5fMS5OYW1lKFwianNvbkxlblwiKSxcbiAgICBqc29uUGFydDogbmV3IGNvZGVnZW5fMS5OYW1lKFwianNvblBhcnRcIiksXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gbmFtZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYW1lcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0ZW5kRXJyb3JzID0gZXhwb3J0cy5yZXNldEVycm9yc0NvdW50ID0gZXhwb3J0cy5yZXBvcnRFeHRyYUVycm9yID0gZXhwb3J0cy5yZXBvcnRFcnJvciA9IGV4cG9ydHMua2V5d29yZCREYXRhRXJyb3IgPSBleHBvcnRzLmtleXdvcmRFcnJvciA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuL25hbWVzXCIpO1xuZXhwb3J0cy5rZXl3b3JkRXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsga2V5d29yZCB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBtdXN0IHBhc3MgXCIke2tleXdvcmR9XCIga2V5d29yZCB2YWxpZGF0aW9uYCxcbn07XG5leHBvcnRzLmtleXdvcmQkRGF0YUVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQsIHNjaGVtYVR5cGUgfSkgPT4gc2NoZW1hVHlwZVxuICAgICAgICA/IGNvZGVnZW5fMS5zdHIgYFwiJHtrZXl3b3JkfVwiIGtleXdvcmQgbXVzdCBiZSAke3NjaGVtYVR5cGV9ICgkZGF0YSlgXG4gICAgICAgIDogY29kZWdlbl8xLnN0ciBgXCIke2tleXdvcmR9XCIga2V5d29yZCBpcyBpbnZhbGlkICgkZGF0YSlgLFxufTtcbmZ1bmN0aW9uIHJlcG9ydEVycm9yKGN4dCwgZXJyb3IgPSBleHBvcnRzLmtleXdvcmRFcnJvciwgZXJyb3JQYXRocywgb3ZlcnJpZGVBbGxFcnJvcnMpIHtcbiAgICBjb25zdCB7IGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgeyBnZW4sIGNvbXBvc2l0ZVJ1bGUsIGFsbEVycm9ycyB9ID0gaXQ7XG4gICAgY29uc3QgZXJyT2JqID0gZXJyb3JPYmplY3RDb2RlKGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpO1xuICAgIGlmIChvdmVycmlkZUFsbEVycm9ycyAhPT0gbnVsbCAmJiBvdmVycmlkZUFsbEVycm9ycyAhPT0gdm9pZCAwID8gb3ZlcnJpZGVBbGxFcnJvcnMgOiAoY29tcG9zaXRlUnVsZSB8fCBhbGxFcnJvcnMpKSB7XG4gICAgICAgIGFkZEVycm9yKGdlbiwgZXJyT2JqKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybkVycm9ycyhpdCwgY29kZWdlbl8xLl8gYFske2Vyck9ian1dYCk7XG4gICAgfVxufVxuZXhwb3J0cy5yZXBvcnRFcnJvciA9IHJlcG9ydEVycm9yO1xuZnVuY3Rpb24gcmVwb3J0RXh0cmFFcnJvcihjeHQsIGVycm9yID0gZXhwb3J0cy5rZXl3b3JkRXJyb3IsIGVycm9yUGF0aHMpIHtcbiAgICBjb25zdCB7IGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgeyBnZW4sIGNvbXBvc2l0ZVJ1bGUsIGFsbEVycm9ycyB9ID0gaXQ7XG4gICAgY29uc3QgZXJyT2JqID0gZXJyb3JPYmplY3RDb2RlKGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpO1xuICAgIGFkZEVycm9yKGdlbiwgZXJyT2JqKTtcbiAgICBpZiAoIShjb21wb3NpdGVSdWxlIHx8IGFsbEVycm9ycykpIHtcbiAgICAgICAgcmV0dXJuRXJyb3JzKGl0LCBuYW1lc18xLmRlZmF1bHQudkVycm9ycyk7XG4gICAgfVxufVxuZXhwb3J0cy5yZXBvcnRFeHRyYUVycm9yID0gcmVwb3J0RXh0cmFFcnJvcjtcbmZ1bmN0aW9uIHJlc2V0RXJyb3JzQ291bnQoZ2VuLCBlcnJzQ291bnQpIHtcbiAgICBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsIGVycnNDb3VudCk7XG4gICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfSAhPT0gbnVsbGAsICgpID0+IGdlbi5pZihlcnJzQ291bnQsICgpID0+IGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9Lmxlbmd0aGAsIGVycnNDb3VudCksICgpID0+IGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIG51bGwpKSk7XG59XG5leHBvcnRzLnJlc2V0RXJyb3JzQ291bnQgPSByZXNldEVycm9yc0NvdW50O1xuZnVuY3Rpb24gZXh0ZW5kRXJyb3JzKHsgZ2VuLCBrZXl3b3JkLCBzY2hlbWFWYWx1ZSwgZGF0YSwgZXJyc0NvdW50LCBpdCwgfSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChlcnJzQ291bnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgIGNvbnN0IGVyciA9IGdlbi5uYW1lKFwiZXJyXCIpO1xuICAgIGdlbi5mb3JSYW5nZShcImlcIiwgZXJyc0NvdW50LCBuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCAoaSkgPT4ge1xuICAgICAgICBnZW4uY29uc3QoZXJyLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc31bJHtpfV1gKTtcbiAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2Vycn0uaW5zdGFuY2VQYXRoID09PSB1bmRlZmluZWRgLCAoKSA9PiBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke2Vycn0uaW5zdGFuY2VQYXRoYCwgY29kZWdlbl8xLnN0ckNvbmNhdChuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBpdC5lcnJvclBhdGgpKSk7XG4gICAgICAgIGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7ZXJyfS5zY2hlbWFQYXRoYCwgY29kZWdlbl8xLnN0ciBgJHtpdC5lcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9YCk7XG4gICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7ZXJyfS5zY2hlbWFgLCBzY2hlbWFWYWx1ZSk7XG4gICAgICAgICAgICBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke2Vycn0uZGF0YWAsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLmV4dGVuZEVycm9ycyA9IGV4dGVuZEVycm9ycztcbmZ1bmN0aW9uIGFkZEVycm9yKGdlbiwgZXJyT2JqKSB7XG4gICAgY29uc3QgZXJyID0gZ2VuLmNvbnN0KFwiZXJyXCIsIGVyck9iaik7XG4gICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfSA9PT0gbnVsbGAsICgpID0+IGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIGNvZGVnZW5fMS5fIGBbJHtlcnJ9XWApLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30ucHVzaCgke2Vycn0pYCk7XG4gICAgZ2VuLmNvZGUoY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc30rK2ApO1xufVxuZnVuY3Rpb24gcmV0dXJuRXJyb3JzKGl0LCBlcnJzKSB7XG4gICAgY29uc3QgeyBnZW4sIHZhbGlkYXRlTmFtZSwgc2NoZW1hRW52IH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hRW52LiRhc3luYykge1xuICAgICAgICBnZW4udGhyb3coY29kZWdlbl8xLl8gYG5ldyAke2l0LlZhbGlkYXRpb25FcnJvcn0oJHtlcnJzfSlgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7dmFsaWRhdGVOYW1lfS5lcnJvcnNgLCBlcnJzKTtcbiAgICAgICAgZ2VuLnJldHVybihmYWxzZSk7XG4gICAgfVxufVxuY29uc3QgRSA9IHtcbiAgICBrZXl3b3JkOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJrZXl3b3JkXCIpLFxuICAgIHNjaGVtYVBhdGg6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNjaGVtYVBhdGhcIiksXG4gICAgcGFyYW1zOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwYXJhbXNcIiksXG4gICAgcHJvcGVydHlOYW1lOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwcm9wZXJ0eU5hbWVcIiksXG4gICAgbWVzc2FnZTogbmV3IGNvZGVnZW5fMS5OYW1lKFwibWVzc2FnZVwiKSxcbiAgICBzY2hlbWE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNjaGVtYVwiKSxcbiAgICBwYXJlbnRTY2hlbWE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmVudFNjaGVtYVwiKSxcbn07XG5mdW5jdGlvbiBlcnJvck9iamVjdENvZGUoY3h0LCBlcnJvciwgZXJyb3JQYXRocykge1xuICAgIGNvbnN0IHsgY3JlYXRlRXJyb3JzIH0gPSBjeHQuaXQ7XG4gICAgaWYgKGNyZWF0ZUVycm9ycyA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybiBjb2RlZ2VuXzEuXyBge31gO1xuICAgIHJldHVybiBlcnJvck9iamVjdChjeHQsIGVycm9yLCBlcnJvclBhdGhzKTtcbn1cbmZ1bmN0aW9uIGVycm9yT2JqZWN0KGN4dCwgZXJyb3IsIGVycm9yUGF0aHMgPSB7fSkge1xuICAgIGNvbnN0IHsgZ2VuLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IGtleVZhbHVlcyA9IFtcbiAgICAgICAgZXJyb3JJbnN0YW5jZVBhdGgoaXQsIGVycm9yUGF0aHMpLFxuICAgICAgICBlcnJvclNjaGVtYVBhdGgoY3h0LCBlcnJvclBhdGhzKSxcbiAgICBdO1xuICAgIGV4dHJhRXJyb3JQcm9wcyhjeHQsIGVycm9yLCBrZXlWYWx1ZXMpO1xuICAgIHJldHVybiBnZW4ub2JqZWN0KC4uLmtleVZhbHVlcyk7XG59XG5mdW5jdGlvbiBlcnJvckluc3RhbmNlUGF0aCh7IGVycm9yUGF0aCB9LCB7IGluc3RhbmNlUGF0aCB9KSB7XG4gICAgY29uc3QgaW5zdFBhdGggPSBpbnN0YW5jZVBhdGhcbiAgICAgICAgPyBjb2RlZ2VuXzEuc3RyIGAke2Vycm9yUGF0aH0ke3V0aWxfMS5nZXRFcnJvclBhdGgoaW5zdGFuY2VQYXRoLCB1dGlsXzEuVHlwZS5TdHIpfWBcbiAgICAgICAgOiBlcnJvclBhdGg7XG4gICAgcmV0dXJuIFtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBjb2RlZ2VuXzEuc3RyQ29uY2F0KG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsIGluc3RQYXRoKV07XG59XG5mdW5jdGlvbiBlcnJvclNjaGVtYVBhdGgoeyBrZXl3b3JkLCBpdDogeyBlcnJTY2hlbWFQYXRoIH0gfSwgeyBzY2hlbWFQYXRoLCBwYXJlbnRTY2hlbWEgfSkge1xuICAgIGxldCBzY2hQYXRoID0gcGFyZW50U2NoZW1hID8gZXJyU2NoZW1hUGF0aCA6IGNvZGVnZW5fMS5zdHIgYCR7ZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWA7XG4gICAgaWYgKHNjaGVtYVBhdGgpIHtcbiAgICAgICAgc2NoUGF0aCA9IGNvZGVnZW5fMS5zdHIgYCR7c2NoUGF0aH0ke3V0aWxfMS5nZXRFcnJvclBhdGgoc2NoZW1hUGF0aCwgdXRpbF8xLlR5cGUuU3RyKX1gO1xuICAgIH1cbiAgICByZXR1cm4gW0Uuc2NoZW1hUGF0aCwgc2NoUGF0aF07XG59XG5mdW5jdGlvbiBleHRyYUVycm9yUHJvcHMoY3h0LCB7IHBhcmFtcywgbWVzc2FnZSB9LCBrZXlWYWx1ZXMpIHtcbiAgICBjb25zdCB7IGtleXdvcmQsIGRhdGEsIHNjaGVtYVZhbHVlLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHsgb3B0cywgcHJvcGVydHlOYW1lLCB0b3BTY2hlbWFSZWYsIHNjaGVtYVBhdGggfSA9IGl0O1xuICAgIGtleVZhbHVlcy5wdXNoKFtFLmtleXdvcmQsIGtleXdvcmRdLCBbRS5wYXJhbXMsIHR5cGVvZiBwYXJhbXMgPT0gXCJmdW5jdGlvblwiID8gcGFyYW1zKGN4dCkgOiBwYXJhbXMgfHwgY29kZWdlbl8xLl8gYHt9YF0pO1xuICAgIGlmIChvcHRzLm1lc3NhZ2VzKSB7XG4gICAgICAgIGtleVZhbHVlcy5wdXNoKFtFLm1lc3NhZ2UsIHR5cGVvZiBtZXNzYWdlID09IFwiZnVuY3Rpb25cIiA/IG1lc3NhZ2UoY3h0KSA6IG1lc3NhZ2VdKTtcbiAgICB9XG4gICAgaWYgKG9wdHMudmVyYm9zZSkge1xuICAgICAgICBrZXlWYWx1ZXMucHVzaChbRS5zY2hlbWEsIHNjaGVtYVZhbHVlXSwgW0UucGFyZW50U2NoZW1hLCBjb2RlZ2VuXzEuXyBgJHt0b3BTY2hlbWFSZWZ9JHtzY2hlbWFQYXRofWBdLCBbbmFtZXNfMS5kZWZhdWx0LmRhdGEsIGRhdGFdKTtcbiAgICB9XG4gICAgaWYgKHByb3BlcnR5TmFtZSlcbiAgICAgICAga2V5VmFsdWVzLnB1c2goW0UucHJvcGVydHlOYW1lLCBwcm9wZXJ0eU5hbWVdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYm9vbE9yRW1wdHlTY2hlbWEgPSBleHBvcnRzLnRvcEJvb2xPckVtcHR5U2NoZW1hID0gdm9pZCAwO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uL25hbWVzXCIpO1xuY29uc3QgYm9vbEVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwiYm9vbGVhbiBzY2hlbWEgaXMgZmFsc2VcIixcbn07XG5mdW5jdGlvbiB0b3BCb29sT3JFbXB0eVNjaGVtYShpdCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHZhbGlkYXRlTmFtZSB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZmFsc2VTY2hlbWFFcnJvcihpdCwgZmFsc2UpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgc2NoZW1hLiRhc3luYyA9PT0gdHJ1ZSkge1xuICAgICAgICBnZW4ucmV0dXJuKG5hbWVzXzEuZGVmYXVsdC5kYXRhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7dmFsaWRhdGVOYW1lfS5lcnJvcnNgLCBudWxsKTtcbiAgICAgICAgZ2VuLnJldHVybih0cnVlKTtcbiAgICB9XG59XG5leHBvcnRzLnRvcEJvb2xPckVtcHR5U2NoZW1hID0gdG9wQm9vbE9yRW1wdHlTY2hlbWE7XG5mdW5jdGlvbiBib29sT3JFbXB0eVNjaGVtYShpdCwgdmFsaWQpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICBnZW4udmFyKHZhbGlkLCBmYWxzZSk7IC8vIFRPRE8gdmFyXG4gICAgICAgIGZhbHNlU2NoZW1hRXJyb3IoaXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2VuLnZhcih2YWxpZCwgdHJ1ZSk7IC8vIFRPRE8gdmFyXG4gICAgfVxufVxuZXhwb3J0cy5ib29sT3JFbXB0eVNjaGVtYSA9IGJvb2xPckVtcHR5U2NoZW1hO1xuZnVuY3Rpb24gZmFsc2VTY2hlbWFFcnJvcihpdCwgb3ZlcnJpZGVBbGxFcnJvcnMpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSB9ID0gaXQ7XG4gICAgLy8gVE9ETyBtYXliZSBzb21lIG90aGVyIGludGVyZmFjZSBzaG91bGQgYmUgdXNlZCBmb3Igbm9uLWtleXdvcmQgdmFsaWRhdGlvbiBlcnJvcnMuLi5cbiAgICBjb25zdCBjeHQgPSB7XG4gICAgICAgIGdlbixcbiAgICAgICAga2V5d29yZDogXCJmYWxzZSBzY2hlbWFcIixcbiAgICAgICAgZGF0YSxcbiAgICAgICAgc2NoZW1hOiBmYWxzZSxcbiAgICAgICAgc2NoZW1hQ29kZTogZmFsc2UsXG4gICAgICAgIHNjaGVtYVZhbHVlOiBmYWxzZSxcbiAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgaXQsXG4gICAgfTtcbiAgICBlcnJvcnNfMS5yZXBvcnRFcnJvcihjeHQsIGJvb2xFcnJvciwgdW5kZWZpbmVkLCBvdmVycmlkZUFsbEVycm9ycyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib29sU2NoZW1hLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRSdWxlcyA9IGV4cG9ydHMuaXNKU09OVHlwZSA9IHZvaWQgMDtcbmNvbnN0IF9qc29uVHlwZXMgPSBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJpbnRlZ2VyXCIsIFwiYm9vbGVhblwiLCBcIm51bGxcIiwgXCJvYmplY3RcIiwgXCJhcnJheVwiXTtcbmNvbnN0IGpzb25UeXBlcyA9IG5ldyBTZXQoX2pzb25UeXBlcyk7XG5mdW5jdGlvbiBpc0pTT05UeXBlKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT0gXCJzdHJpbmdcIiAmJiBqc29uVHlwZXMuaGFzKHgpO1xufVxuZXhwb3J0cy5pc0pTT05UeXBlID0gaXNKU09OVHlwZTtcbmZ1bmN0aW9uIGdldFJ1bGVzKCkge1xuICAgIGNvbnN0IGdyb3VwcyA9IHtcbiAgICAgICAgbnVtYmVyOiB7IHR5cGU6IFwibnVtYmVyXCIsIHJ1bGVzOiBbXSB9LFxuICAgICAgICBzdHJpbmc6IHsgdHlwZTogXCJzdHJpbmdcIiwgcnVsZXM6IFtdIH0sXG4gICAgICAgIGFycmF5OiB7IHR5cGU6IFwiYXJyYXlcIiwgcnVsZXM6IFtdIH0sXG4gICAgICAgIG9iamVjdDogeyB0eXBlOiBcIm9iamVjdFwiLCBydWxlczogW10gfSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVzOiB7IC4uLmdyb3VwcywgaW50ZWdlcjogdHJ1ZSwgYm9vbGVhbjogdHJ1ZSwgbnVsbDogdHJ1ZSB9LFxuICAgICAgICBydWxlczogW3sgcnVsZXM6IFtdIH0sIGdyb3Vwcy5udW1iZXIsIGdyb3Vwcy5zdHJpbmcsIGdyb3Vwcy5hcnJheSwgZ3JvdXBzLm9iamVjdF0sXG4gICAgICAgIHBvc3Q6IHsgcnVsZXM6IFtdIH0sXG4gICAgICAgIGFsbDoge30sXG4gICAgICAgIGtleXdvcmRzOiB7fSxcbiAgICB9O1xufVxuZXhwb3J0cy5nZXRSdWxlcyA9IGdldFJ1bGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnVsZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNob3VsZFVzZVJ1bGUgPSBleHBvcnRzLnNob3VsZFVzZUdyb3VwID0gZXhwb3J0cy5zY2hlbWFIYXNSdWxlc0ZvclR5cGUgPSB2b2lkIDA7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlc0ZvclR5cGUoeyBzY2hlbWEsIHNlbGYgfSwgdHlwZSkge1xuICAgIGNvbnN0IGdyb3VwID0gc2VsZi5SVUxFUy50eXBlc1t0eXBlXTtcbiAgICByZXR1cm4gZ3JvdXAgJiYgZ3JvdXAgIT09IHRydWUgJiYgc2hvdWxkVXNlR3JvdXAoc2NoZW1hLCBncm91cCk7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzRm9yVHlwZSA9IHNjaGVtYUhhc1J1bGVzRm9yVHlwZTtcbmZ1bmN0aW9uIHNob3VsZFVzZUdyb3VwKHNjaGVtYSwgZ3JvdXApIHtcbiAgICByZXR1cm4gZ3JvdXAucnVsZXMuc29tZSgocnVsZSkgPT4gc2hvdWxkVXNlUnVsZShzY2hlbWEsIHJ1bGUpKTtcbn1cbmV4cG9ydHMuc2hvdWxkVXNlR3JvdXAgPSBzaG91bGRVc2VHcm91cDtcbmZ1bmN0aW9uIHNob3VsZFVzZVJ1bGUoc2NoZW1hLCBydWxlKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoc2NoZW1hW3J1bGUua2V5d29yZF0gIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAoKF9hID0gcnVsZS5kZWZpbml0aW9uLmltcGxlbWVudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKChrd2QpID0+IHNjaGVtYVtrd2RdICE9PSB1bmRlZmluZWQpKSk7XG59XG5leHBvcnRzLnNob3VsZFVzZVJ1bGUgPSBzaG91bGRVc2VSdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwbGljYWJpbGl0eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVwb3J0VHlwZUVycm9yID0gZXhwb3J0cy5jaGVja0RhdGFUeXBlcyA9IGV4cG9ydHMuY2hlY2tEYXRhVHlwZSA9IGV4cG9ydHMuY29lcmNlQW5kQ2hlY2tEYXRhVHlwZSA9IGV4cG9ydHMuZ2V0SlNPTlR5cGVzID0gZXhwb3J0cy5nZXRTY2hlbWFUeXBlcyA9IGV4cG9ydHMuRGF0YVR5cGUgPSB2b2lkIDA7XG5jb25zdCBydWxlc18xID0gcmVxdWlyZShcIi4uL3J1bGVzXCIpO1xuY29uc3QgYXBwbGljYWJpbGl0eV8xID0gcmVxdWlyZShcIi4vYXBwbGljYWJpbGl0eVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgRGF0YVR5cGU7XG4oZnVuY3Rpb24gKERhdGFUeXBlKSB7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJDb3JyZWN0XCJdID0gMF0gPSBcIkNvcnJlY3RcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIldyb25nXCJdID0gMV0gPSBcIldyb25nXCI7XG59KShEYXRhVHlwZSA9IGV4cG9ydHMuRGF0YVR5cGUgfHwgKGV4cG9ydHMuRGF0YVR5cGUgPSB7fSkpO1xuZnVuY3Rpb24gZ2V0U2NoZW1hVHlwZXMoc2NoZW1hKSB7XG4gICAgY29uc3QgdHlwZXMgPSBnZXRKU09OVHlwZXMoc2NoZW1hLnR5cGUpO1xuICAgIGNvbnN0IGhhc051bGwgPSB0eXBlcy5pbmNsdWRlcyhcIm51bGxcIik7XG4gICAgaWYgKGhhc051bGwpIHtcbiAgICAgICAgaWYgKHNjaGVtYS5udWxsYWJsZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0eXBlOiBudWxsIGNvbnRyYWRpY3RzIG51bGxhYmxlOiBmYWxzZVwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghdHlwZXMubGVuZ3RoICYmIHNjaGVtYS5udWxsYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibnVsbGFibGVcIiBjYW5ub3QgYmUgdXNlZCB3aXRob3V0IFwidHlwZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5udWxsYWJsZSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHR5cGVzLnB1c2goXCJudWxsXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZXM7XG59XG5leHBvcnRzLmdldFNjaGVtYVR5cGVzID0gZ2V0U2NoZW1hVHlwZXM7XG5mdW5jdGlvbiBnZXRKU09OVHlwZXModHMpIHtcbiAgICBjb25zdCB0eXBlcyA9IEFycmF5LmlzQXJyYXkodHMpID8gdHMgOiB0cyA/IFt0c10gOiBbXTtcbiAgICBpZiAodHlwZXMuZXZlcnkocnVsZXNfMS5pc0pTT05UeXBlKSlcbiAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIHRocm93IG5ldyBFcnJvcihcInR5cGUgbXVzdCBiZSBKU09OVHlwZSBvciBKU09OVHlwZVtdOiBcIiArIHR5cGVzLmpvaW4oXCIsXCIpKTtcbn1cbmV4cG9ydHMuZ2V0SlNPTlR5cGVzID0gZ2V0SlNPTlR5cGVzO1xuZnVuY3Rpb24gY29lcmNlQW5kQ2hlY2tEYXRhVHlwZShpdCwgdHlwZXMpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgb3B0cyB9ID0gaXQ7XG4gICAgY29uc3QgY29lcmNlVG8gPSBjb2VyY2VUb1R5cGVzKHR5cGVzLCBvcHRzLmNvZXJjZVR5cGVzKTtcbiAgICBjb25zdCBjaGVja1R5cGVzID0gdHlwZXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAhKGNvZXJjZVRvLmxlbmd0aCA9PT0gMCAmJiB0eXBlcy5sZW5ndGggPT09IDEgJiYgYXBwbGljYWJpbGl0eV8xLnNjaGVtYUhhc1J1bGVzRm9yVHlwZShpdCwgdHlwZXNbMF0pKTtcbiAgICBpZiAoY2hlY2tUeXBlcykge1xuICAgICAgICBjb25zdCB3cm9uZ1R5cGUgPSBjaGVja0RhdGFUeXBlcyh0eXBlcywgZGF0YSwgb3B0cy5zdHJpY3ROdW1iZXJzLCBEYXRhVHlwZS5Xcm9uZyk7XG4gICAgICAgIGdlbi5pZih3cm9uZ1R5cGUsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChjb2VyY2VUby5sZW5ndGgpXG4gICAgICAgICAgICAgICAgY29lcmNlRGF0YShpdCwgdHlwZXMsIGNvZXJjZVRvKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXBvcnRUeXBlRXJyb3IoaXQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNoZWNrVHlwZXM7XG59XG5leHBvcnRzLmNvZXJjZUFuZENoZWNrRGF0YVR5cGUgPSBjb2VyY2VBbmRDaGVja0RhdGFUeXBlO1xuY29uc3QgQ09FUkNJQkxFID0gbmV3IFNldChbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJpbnRlZ2VyXCIsIFwiYm9vbGVhblwiLCBcIm51bGxcIl0pO1xuZnVuY3Rpb24gY29lcmNlVG9UeXBlcyh0eXBlcywgY29lcmNlVHlwZXMpIHtcbiAgICByZXR1cm4gY29lcmNlVHlwZXNcbiAgICAgICAgPyB0eXBlcy5maWx0ZXIoKHQpID0+IENPRVJDSUJMRS5oYXModCkgfHwgKGNvZXJjZVR5cGVzID09PSBcImFycmF5XCIgJiYgdCA9PT0gXCJhcnJheVwiKSlcbiAgICAgICAgOiBbXTtcbn1cbmZ1bmN0aW9uIGNvZXJjZURhdGEoaXQsIHR5cGVzLCBjb2VyY2VUbykge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBvcHRzIH0gPSBpdDtcbiAgICBjb25zdCBkYXRhVHlwZSA9IGdlbi5sZXQoXCJkYXRhVHlwZVwiLCBjb2RlZ2VuXzEuXyBgdHlwZW9mICR7ZGF0YX1gKTtcbiAgICBjb25zdCBjb2VyY2VkID0gZ2VuLmxldChcImNvZXJjZWRcIiwgY29kZWdlbl8xLl8gYHVuZGVmaW5lZGApO1xuICAgIGlmIChvcHRzLmNvZXJjZVR5cGVzID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2RhdGFUeXBlfSA9PSAnb2JqZWN0JyAmJiBBcnJheS5pc0FycmF5KCR7ZGF0YX0pICYmICR7ZGF0YX0ubGVuZ3RoID09IDFgLCAoKSA9PiBnZW5cbiAgICAgICAgICAgIC5hc3NpZ24oZGF0YSwgY29kZWdlbl8xLl8gYCR7ZGF0YX1bMF1gKVxuICAgICAgICAgICAgLmFzc2lnbihkYXRhVHlwZSwgY29kZWdlbl8xLl8gYHR5cGVvZiAke2RhdGF9YClcbiAgICAgICAgICAgIC5pZihjaGVja0RhdGFUeXBlcyh0eXBlcywgZGF0YSwgb3B0cy5zdHJpY3ROdW1iZXJzKSwgKCkgPT4gZ2VuLmFzc2lnbihjb2VyY2VkLCBkYXRhKSkpO1xuICAgIH1cbiAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7Y29lcmNlZH0gIT09IHVuZGVmaW5lZGApO1xuICAgIGZvciAoY29uc3QgdCBvZiBjb2VyY2VUbykge1xuICAgICAgICBpZiAoQ09FUkNJQkxFLmhhcyh0KSB8fCAodCA9PT0gXCJhcnJheVwiICYmIG9wdHMuY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIikpIHtcbiAgICAgICAgICAgIGNvZXJjZVNwZWNpZmljVHlwZSh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZW4uZWxzZSgpO1xuICAgIHJlcG9ydFR5cGVFcnJvcihpdCk7XG4gICAgZ2VuLmVuZElmKCk7XG4gICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2NvZXJjZWR9ICE9PSB1bmRlZmluZWRgLCAoKSA9PiB7XG4gICAgICAgIGdlbi5hc3NpZ24oZGF0YSwgY29lcmNlZCk7XG4gICAgICAgIGFzc2lnblBhcmVudERhdGEoaXQsIGNvZXJjZWQpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGNvZXJjZVNwZWNpZmljVHlwZSh0KSB7XG4gICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKGNvZGVnZW5fMS5fIGAke2RhdGFUeXBlfSA9PSBcIm51bWJlclwiIHx8ICR7ZGF0YVR5cGV9ID09IFwiYm9vbGVhblwiYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBjb2RlZ2VuXzEuXyBgXCJcIiArICR7ZGF0YX1gKVxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKGNvZGVnZW5fMS5fIGAke2RhdGF9ID09PSBudWxsYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBjb2RlZ2VuXzEuXyBgXCJcImApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZihjb2RlZ2VuXzEuXyBgJHtkYXRhVHlwZX0gPT0gXCJib29sZWFuXCIgfHwgJHtkYXRhfSA9PT0gbnVsbFxuICAgICAgICAgICAgICB8fCAoJHtkYXRhVHlwZX0gPT0gXCJzdHJpbmdcIiAmJiAke2RhdGF9ICYmICR7ZGF0YX0gPT0gKyR7ZGF0YX0pYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBjb2RlZ2VuXzEuXyBgKyR7ZGF0YX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiaW50ZWdlclwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKGNvZGVnZW5fMS5fIGAke2RhdGFUeXBlfSA9PT0gXCJib29sZWFuXCIgfHwgJHtkYXRhfSA9PT0gbnVsbFxuICAgICAgICAgICAgICB8fCAoJHtkYXRhVHlwZX0gPT09IFwic3RyaW5nXCIgJiYgJHtkYXRhfSAmJiAke2RhdGF9ID09ICske2RhdGF9ICYmICEoJHtkYXRhfSAlIDEpKWApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgY29kZWdlbl8xLl8gYCske2RhdGF9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZihjb2RlZ2VuXzEuXyBgJHtkYXRhfSA9PT0gXCJmYWxzZVwiIHx8ICR7ZGF0YX0gPT09IDAgfHwgJHtkYXRhfSA9PT0gbnVsbGApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoY29kZWdlbl8xLl8gYCR7ZGF0YX0gPT09IFwidHJ1ZVwiIHx8ICR7ZGF0YX0gPT09IDFgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICAgICAgZ2VuLmVsc2VJZihjb2RlZ2VuXzEuXyBgJHtkYXRhfSA9PT0gXCJcIiB8fCAke2RhdGF9ID09PSAwIHx8ICR7ZGF0YX0gPT09IGZhbHNlYCk7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihjb2VyY2VkLCBudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZihjb2RlZ2VuXzEuXyBgJHtkYXRhVHlwZX0gPT09IFwic3RyaW5nXCIgfHwgJHtkYXRhVHlwZX0gPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgfHwgJHtkYXRhVHlwZX0gPT09IFwiYm9vbGVhblwiIHx8ICR7ZGF0YX0gPT09IG51bGxgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIGNvZGVnZW5fMS5fIGBbJHtkYXRhfV1gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2lnblBhcmVudERhdGEoeyBnZW4sIHBhcmVudERhdGEsIHBhcmVudERhdGFQcm9wZXJ0eSB9LCBleHByKSB7XG4gICAgLy8gVE9ETyB1c2UgZ2VuLnByb3BlcnR5XG4gICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke3BhcmVudERhdGF9ICE9PSB1bmRlZmluZWRgLCAoKSA9PiBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke3BhcmVudERhdGF9WyR7cGFyZW50RGF0YVByb3BlcnR5fV1gLCBleHByKSk7XG59XG5mdW5jdGlvbiBjaGVja0RhdGFUeXBlKGRhdGFUeXBlLCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0ID0gRGF0YVR5cGUuQ29ycmVjdCkge1xuICAgIGNvbnN0IEVRID0gY29ycmVjdCA9PT0gRGF0YVR5cGUuQ29ycmVjdCA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuRVEgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLk5FUTtcbiAgICBsZXQgY29uZDtcbiAgICBzd2l0Y2ggKGRhdGFUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLl8gYCR7ZGF0YX0gJHtFUX0gbnVsbGA7XG4gICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgY29uZCA9IGNvZGVnZW5fMS5fIGBBcnJheS5pc0FycmF5KCR7ZGF0YX0pYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICBjb25kID0gY29kZWdlbl8xLl8gYCR7ZGF0YX0gJiYgdHlwZW9mICR7ZGF0YX0gPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSgke2RhdGF9KWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImludGVnZXJcIjpcbiAgICAgICAgICAgIGNvbmQgPSBudW1Db25kKGNvZGVnZW5fMS5fIGAhKCR7ZGF0YX0gJSAxKSAmJiAhaXNOYU4oJHtkYXRhfSlgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBjb25kID0gbnVtQ29uZCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLl8gYHR5cGVvZiAke2RhdGF9ICR7RVF9ICR7ZGF0YVR5cGV9YDtcbiAgICB9XG4gICAgcmV0dXJuIGNvcnJlY3QgPT09IERhdGFUeXBlLkNvcnJlY3QgPyBjb25kIDogY29kZWdlbl8xLm5vdChjb25kKTtcbiAgICBmdW5jdGlvbiBudW1Db25kKF9jb25kID0gY29kZWdlbl8xLm5pbCkge1xuICAgICAgICByZXR1cm4gY29kZWdlbl8xLmFuZChjb2RlZ2VuXzEuXyBgdHlwZW9mICR7ZGF0YX0gPT0gXCJudW1iZXJcImAsIF9jb25kLCBzdHJpY3ROdW1zID8gY29kZWdlbl8xLl8gYGlzRmluaXRlKCR7ZGF0YX0pYCA6IGNvZGVnZW5fMS5uaWwpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tEYXRhVHlwZSA9IGNoZWNrRGF0YVR5cGU7XG5mdW5jdGlvbiBjaGVja0RhdGFUeXBlcyhkYXRhVHlwZXMsIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QpIHtcbiAgICBpZiAoZGF0YVR5cGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gY2hlY2tEYXRhVHlwZShkYXRhVHlwZXNbMF0sIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QpO1xuICAgIH1cbiAgICBsZXQgY29uZDtcbiAgICBjb25zdCB0eXBlcyA9IHV0aWxfMS50b0hhc2goZGF0YVR5cGVzKTtcbiAgICBpZiAodHlwZXMuYXJyYXkgJiYgdHlwZXMub2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG5vdE9iaiA9IGNvZGVnZW5fMS5fIGB0eXBlb2YgJHtkYXRhfSAhPSBcIm9iamVjdFwiYDtcbiAgICAgICAgY29uZCA9IHR5cGVzLm51bGwgPyBub3RPYmogOiBjb2RlZ2VuXzEuXyBgISR7ZGF0YX0gfHwgJHtub3RPYmp9YDtcbiAgICAgICAgZGVsZXRlIHR5cGVzLm51bGw7XG4gICAgICAgIGRlbGV0ZSB0eXBlcy5hcnJheTtcbiAgICAgICAgZGVsZXRlIHR5cGVzLm9iamVjdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbmQgPSBjb2RlZ2VuXzEubmlsO1xuICAgIH1cbiAgICBpZiAodHlwZXMubnVtYmVyKVxuICAgICAgICBkZWxldGUgdHlwZXMuaW50ZWdlcjtcbiAgICBmb3IgKGNvbnN0IHQgaW4gdHlwZXMpXG4gICAgICAgIGNvbmQgPSBjb2RlZ2VuXzEuYW5kKGNvbmQsIGNoZWNrRGF0YVR5cGUodCwgZGF0YSwgc3RyaWN0TnVtcywgY29ycmVjdCkpO1xuICAgIHJldHVybiBjb25kO1xufVxuZXhwb3J0cy5jaGVja0RhdGFUeXBlcyA9IGNoZWNrRGF0YVR5cGVzO1xuY29uc3QgdHlwZUVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHNjaGVtYSB9KSA9PiBgbXVzdCBiZSAke3NjaGVtYX1gLFxuICAgIHBhcmFtczogKHsgc2NoZW1hLCBzY2hlbWFWYWx1ZSB9KSA9PiB0eXBlb2Ygc2NoZW1hID09IFwic3RyaW5nXCIgPyBjb2RlZ2VuXzEuXyBge3R5cGU6ICR7c2NoZW1hfX1gIDogY29kZWdlbl8xLl8gYHt0eXBlOiAke3NjaGVtYVZhbHVlfX1gLFxufTtcbmZ1bmN0aW9uIHJlcG9ydFR5cGVFcnJvcihpdCkge1xuICAgIGNvbnN0IGN4dCA9IGdldFR5cGVFcnJvckNvbnRleHQoaXQpO1xuICAgIGVycm9yc18xLnJlcG9ydEVycm9yKGN4dCwgdHlwZUVycm9yKTtcbn1cbmV4cG9ydHMucmVwb3J0VHlwZUVycm9yID0gcmVwb3J0VHlwZUVycm9yO1xuZnVuY3Rpb24gZ2V0VHlwZUVycm9yQ29udGV4dChpdCkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWEgfSA9IGl0O1xuICAgIGNvbnN0IHNjaGVtYUNvZGUgPSB1dGlsXzEuc2NoZW1hUmVmT3JWYWwoaXQsIHNjaGVtYSwgXCJ0eXBlXCIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGdlbixcbiAgICAgICAga2V5d29yZDogXCJ0eXBlXCIsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hLnR5cGUsXG4gICAgICAgIHNjaGVtYUNvZGUsXG4gICAgICAgIHNjaGVtYVZhbHVlOiBzY2hlbWFDb2RlLFxuICAgICAgICBwYXJlbnRTY2hlbWE6IHNjaGVtYSxcbiAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgaXQsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGFUeXBlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3NpZ25EZWZhdWx0cyA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5mdW5jdGlvbiBhc3NpZ25EZWZhdWx0cyhpdCwgdHkpIHtcbiAgICBjb25zdCB7IHByb3BlcnRpZXMsIGl0ZW1zIH0gPSBpdC5zY2hlbWE7XG4gICAgaWYgKHR5ID09PSBcIm9iamVjdFwiICYmIHByb3BlcnRpZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgYXNzaWduRGVmYXVsdChpdCwga2V5LCBwcm9wZXJ0aWVzW2tleV0uZGVmYXVsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHkgPT09IFwiYXJyYXlcIiAmJiBBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICBpdGVtcy5mb3JFYWNoKChzY2gsIGkpID0+IGFzc2lnbkRlZmF1bHQoaXQsIGksIHNjaC5kZWZhdWx0KSk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NpZ25EZWZhdWx0cyA9IGFzc2lnbkRlZmF1bHRzO1xuZnVuY3Rpb24gYXNzaWduRGVmYXVsdChpdCwgcHJvcCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgY29uc3QgeyBnZW4sIGNvbXBvc2l0ZVJ1bGUsIGRhdGEsIG9wdHMgfSA9IGl0O1xuICAgIGlmIChkZWZhdWx0VmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGNoaWxkRGF0YSA9IGNvZGVnZW5fMS5fIGAke2RhdGF9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkocHJvcCl9YDtcbiAgICBpZiAoY29tcG9zaXRlUnVsZSkge1xuICAgICAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCBgZGVmYXVsdCBpcyBpZ25vcmVkIGZvcjogJHtjaGlsZERhdGF9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGNvbmRpdGlvbiA9IGNvZGVnZW5fMS5fIGAke2NoaWxkRGF0YX0gPT09IHVuZGVmaW5lZGA7XG4gICAgaWYgKG9wdHMudXNlRGVmYXVsdHMgPT09IFwiZW1wdHlcIikge1xuICAgICAgICBjb25kaXRpb24gPSBjb2RlZ2VuXzEuXyBgJHtjb25kaXRpb259IHx8ICR7Y2hpbGREYXRhfSA9PT0gbnVsbCB8fCAke2NoaWxkRGF0YX0gPT09IFwiXCJgO1xuICAgIH1cbiAgICAvLyBgJHtjaGlsZERhdGF9ID09PSB1bmRlZmluZWRgICtcbiAgICAvLyAob3B0cy51c2VEZWZhdWx0cyA9PT0gXCJlbXB0eVwiID8gYCB8fCAke2NoaWxkRGF0YX0gPT09IG51bGwgfHwgJHtjaGlsZERhdGF9ID09PSBcIlwiYCA6IFwiXCIpXG4gICAgZ2VuLmlmKGNvbmRpdGlvbiwgY29kZWdlbl8xLl8gYCR7Y2hpbGREYXRhfSA9ICR7Y29kZWdlbl8xLnN0cmluZ2lmeShkZWZhdWx0VmFsdWUpfWApO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlVW5pb24gPSBleHBvcnRzLnZhbGlkYXRlQXJyYXkgPSBleHBvcnRzLnVzZVBhdHRlcm4gPSBleHBvcnRzLmNhbGxWYWxpZGF0ZUNvZGUgPSBleHBvcnRzLnNjaGVtYVByb3BlcnRpZXMgPSBleHBvcnRzLmFsbFNjaGVtYVByb3BlcnRpZXMgPSBleHBvcnRzLm5vUHJvcGVydHlJbkRhdGEgPSBleHBvcnRzLnByb3BlcnR5SW5EYXRhID0gZXhwb3J0cy5pc093blByb3BlcnR5ID0gZXhwb3J0cy5oYXNQcm9wRnVuYyA9IGV4cG9ydHMucmVwb3J0TWlzc2luZ1Byb3AgPSBleHBvcnRzLmNoZWNrTWlzc2luZ1Byb3AgPSBleHBvcnRzLmNoZWNrUmVwb3J0TWlzc2luZ1Byb3AgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vY29tcGlsZS9uYW1lc1wiKTtcbmZ1bmN0aW9uIGNoZWNrUmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBwcm9wKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgZ2VuLmlmKG5vUHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpLCAoKSA9PiB7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBtaXNzaW5nUHJvcGVydHk6IGNvZGVnZW5fMS5fIGAke3Byb3B9YCB9LCB0cnVlKTtcbiAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmNoZWNrUmVwb3J0TWlzc2luZ1Byb3AgPSBjaGVja1JlcG9ydE1pc3NpbmdQcm9wO1xuZnVuY3Rpb24gY2hlY2tNaXNzaW5nUHJvcCh7IGdlbiwgZGF0YSwgaXQ6IHsgb3B0cyB9IH0sIHByb3BlcnRpZXMsIG1pc3NpbmcpIHtcbiAgICByZXR1cm4gY29kZWdlbl8xLm9yKC4uLnByb3BlcnRpZXMubWFwKChwcm9wKSA9PiBjb2RlZ2VuXzEuYW5kKG5vUHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBvcHRzLm93blByb3BlcnRpZXMpLCBjb2RlZ2VuXzEuXyBgJHttaXNzaW5nfSA9ICR7cHJvcH1gKSkpO1xufVxuZXhwb3J0cy5jaGVja01pc3NpbmdQcm9wID0gY2hlY2tNaXNzaW5nUHJvcDtcbmZ1bmN0aW9uIHJlcG9ydE1pc3NpbmdQcm9wKGN4dCwgbWlzc2luZykge1xuICAgIGN4dC5zZXRQYXJhbXMoeyBtaXNzaW5nUHJvcGVydHk6IG1pc3NpbmcgfSwgdHJ1ZSk7XG4gICAgY3h0LmVycm9yKCk7XG59XG5leHBvcnRzLnJlcG9ydE1pc3NpbmdQcm9wID0gcmVwb3J0TWlzc2luZ1Byb3A7XG5mdW5jdGlvbiBoYXNQcm9wRnVuYyhnZW4pIHtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJmdW5jXCIsIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICByZWY6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICAgIGNvZGU6IGNvZGVnZW5fMS5fIGBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5YCxcbiAgICB9KTtcbn1cbmV4cG9ydHMuaGFzUHJvcEZ1bmMgPSBoYXNQcm9wRnVuYztcbmZ1bmN0aW9uIGlzT3duUHJvcGVydHkoZ2VuLCBkYXRhLCBwcm9wZXJ0eSkge1xuICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgJHtoYXNQcm9wRnVuYyhnZW4pfS5jYWxsKCR7ZGF0YX0sICR7cHJvcGVydHl9KWA7XG59XG5leHBvcnRzLmlzT3duUHJvcGVydHkgPSBpc093blByb3BlcnR5O1xuZnVuY3Rpb24gcHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wZXJ0eSwgb3duUHJvcGVydGllcykge1xuICAgIGNvbnN0IGNvbmQgPSBjb2RlZ2VuXzEuXyBgJHtkYXRhfSR7Y29kZWdlbl8xLmdldFByb3BlcnR5KHByb3BlcnR5KX0gIT09IHVuZGVmaW5lZGA7XG4gICAgcmV0dXJuIG93blByb3BlcnRpZXMgPyBjb2RlZ2VuXzEuXyBgJHtjb25kfSAmJiAke2lzT3duUHJvcGVydHkoZ2VuLCBkYXRhLCBwcm9wZXJ0eSl9YCA6IGNvbmQ7XG59XG5leHBvcnRzLnByb3BlcnR5SW5EYXRhID0gcHJvcGVydHlJbkRhdGE7XG5mdW5jdGlvbiBub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcGVydHksIG93blByb3BlcnRpZXMpIHtcbiAgICBjb25zdCBjb25kID0gY29kZWdlbl8xLl8gYCR7ZGF0YX0ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eShwcm9wZXJ0eSl9ID09PSB1bmRlZmluZWRgO1xuICAgIHJldHVybiBvd25Qcm9wZXJ0aWVzID8gY29kZWdlbl8xLm9yKGNvbmQsIGNvZGVnZW5fMS5ub3QoaXNPd25Qcm9wZXJ0eShnZW4sIGRhdGEsIHByb3BlcnR5KSkpIDogY29uZDtcbn1cbmV4cG9ydHMubm9Qcm9wZXJ0eUluRGF0YSA9IG5vUHJvcGVydHlJbkRhdGE7XG5mdW5jdGlvbiBhbGxTY2hlbWFQcm9wZXJ0aWVzKHNjaGVtYU1hcCkge1xuICAgIHJldHVybiBzY2hlbWFNYXAgPyBPYmplY3Qua2V5cyhzY2hlbWFNYXApLmZpbHRlcigocCkgPT4gcCAhPT0gXCJfX3Byb3RvX19cIikgOiBbXTtcbn1cbmV4cG9ydHMuYWxsU2NoZW1hUHJvcGVydGllcyA9IGFsbFNjaGVtYVByb3BlcnRpZXM7XG5mdW5jdGlvbiBzY2hlbWFQcm9wZXJ0aWVzKGl0LCBzY2hlbWFNYXApIHtcbiAgICByZXR1cm4gYWxsU2NoZW1hUHJvcGVydGllcyhzY2hlbWFNYXApLmZpbHRlcigocCkgPT4gIXV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hTWFwW3BdKSk7XG59XG5leHBvcnRzLnNjaGVtYVByb3BlcnRpZXMgPSBzY2hlbWFQcm9wZXJ0aWVzO1xuZnVuY3Rpb24gY2FsbFZhbGlkYXRlQ29kZSh7IHNjaGVtYUNvZGUsIGRhdGEsIGl0OiB7IGdlbiwgdG9wU2NoZW1hUmVmLCBzY2hlbWFQYXRoLCBlcnJvclBhdGggfSwgaXQgfSwgZnVuYywgY29udGV4dCwgcGFzc1NjaGVtYSkge1xuICAgIGNvbnN0IGRhdGFBbmRTY2hlbWEgPSBwYXNzU2NoZW1hID8gY29kZWdlbl8xLl8gYCR7c2NoZW1hQ29kZX0sICR7ZGF0YX0sICR7dG9wU2NoZW1hUmVmfSR7c2NoZW1hUGF0aH1gIDogZGF0YTtcbiAgICBjb25zdCB2YWxDeHQgPSBbXG4gICAgICAgIFtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBjb2RlZ2VuXzEuc3RyQ29uY2F0KG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsIGVycm9yUGF0aCldLFxuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGEsIGl0LnBhcmVudERhdGFdLFxuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSwgaXQucGFyZW50RGF0YVByb3BlcnR5XSxcbiAgICAgICAgW25hbWVzXzEuZGVmYXVsdC5yb290RGF0YSwgbmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhXSxcbiAgICBdO1xuICAgIGlmIChpdC5vcHRzLmR5bmFtaWNSZWYpXG4gICAgICAgIHZhbEN4dC5wdXNoKFtuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnMsIG5hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9yc10pO1xuICAgIGNvbnN0IGFyZ3MgPSBjb2RlZ2VuXzEuXyBgJHtkYXRhQW5kU2NoZW1hfSwgJHtnZW4ub2JqZWN0KC4uLnZhbEN4dCl9YDtcbiAgICByZXR1cm4gY29udGV4dCAhPT0gY29kZWdlbl8xLm5pbCA/IGNvZGVnZW5fMS5fIGAke2Z1bmN9LmNhbGwoJHtjb250ZXh0fSwgJHthcmdzfSlgIDogY29kZWdlbl8xLl8gYCR7ZnVuY30oJHthcmdzfSlgO1xufVxuZXhwb3J0cy5jYWxsVmFsaWRhdGVDb2RlID0gY2FsbFZhbGlkYXRlQ29kZTtcbmZ1bmN0aW9uIHVzZVBhdHRlcm4oeyBnZW4sIGl0OiB7IG9wdHMgfSB9LCBwYXR0ZXJuKSB7XG4gICAgY29uc3QgdSA9IG9wdHMudW5pY29kZVJlZ0V4cCA/IFwidVwiIDogXCJcIjtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJwYXR0ZXJuXCIsIHtcbiAgICAgICAga2V5OiBwYXR0ZXJuLFxuICAgICAgICByZWY6IG5ldyBSZWdFeHAocGF0dGVybiwgdSksXG4gICAgICAgIGNvZGU6IGNvZGVnZW5fMS5fIGBuZXcgUmVnRXhwKCR7cGF0dGVybn0sICR7dX0pYCxcbiAgICB9KTtcbn1cbmV4cG9ydHMudXNlUGF0dGVybiA9IHVzZVBhdHRlcm47XG5mdW5jdGlvbiB2YWxpZGF0ZUFycmF5KGN4dCkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICBpZiAoaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkQXJyID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpO1xuICAgICAgICB2YWxpZGF0ZUl0ZW1zKCgpID0+IGdlbi5hc3NpZ24odmFsaWRBcnIsIGZhbHNlKSk7XG4gICAgICAgIHJldHVybiB2YWxpZEFycjtcbiAgICB9XG4gICAgZ2VuLnZhcih2YWxpZCwgdHJ1ZSk7XG4gICAgdmFsaWRhdGVJdGVtcygoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgcmV0dXJuIHZhbGlkO1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXMobm90VmFsaWQpIHtcbiAgICAgICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsIGNvZGVnZW5fMS5fIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgICAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIDAsIGxlbiwgKGkpID0+IHtcbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgICAgICAgZGF0YVByb3A6IGksXG4gICAgICAgICAgICAgICAgZGF0YVByb3BUeXBlOiB1dGlsXzEuVHlwZS5OdW0sXG4gICAgICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLm5vdCh2YWxpZCksIG5vdFZhbGlkKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUFycmF5ID0gdmFsaWRhdGVBcnJheTtcbmZ1bmN0aW9uIHZhbGlkYXRlVW5pb24oY3h0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgIGNvbnN0IGFsd2F5c1ZhbGlkID0gc2NoZW1hLnNvbWUoKHNjaCkgPT4gdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2gpKTtcbiAgICBpZiAoYWx3YXlzVmFsaWQgJiYgIWl0Lm9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCBmYWxzZSk7XG4gICAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKTtcbiAgICBnZW4uYmxvY2soKCkgPT4gc2NoZW1hLmZvckVhY2goKF9zY2gsIGkpID0+IHtcbiAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgICAgc2NoZW1hUHJvcDogaSxcbiAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgIH0sIHNjaFZhbGlkKTtcbiAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgY29kZWdlbl8xLl8gYCR7dmFsaWR9IHx8ICR7c2NoVmFsaWR9YCk7XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IGN4dC5tZXJnZVZhbGlkRXZhbHVhdGVkKHNjaEN4dCwgc2NoVmFsaWQpO1xuICAgICAgICAvLyBjYW4gc2hvcnQtY2lyY3VpdCBpZiBgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzL0l0ZW1zYCBub3Qgc3VwcG9ydGVkIChvcHRzLnVuZXZhbHVhdGVkICE9PSB0cnVlKVxuICAgICAgICAvLyBvciBpZiBhbGwgcHJvcGVydGllcyBhbmQgaXRlbXMgd2VyZSBldmFsdWF0ZWQgKGl0LnByb3BzID09PSB0cnVlICYmIGl0Lml0ZW1zID09PSB0cnVlKVxuICAgICAgICBpZiAoIW1lcmdlZClcbiAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEubm90KHZhbGlkKSk7XG4gICAgfSkpO1xuICAgIGN4dC5yZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xufVxuZXhwb3J0cy52YWxpZGF0ZVVuaW9uID0gdmFsaWRhdGVVbmlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlS2V5d29yZFVzYWdlID0gZXhwb3J0cy52YWxpZFNjaGVtYVR5cGUgPSBleHBvcnRzLmZ1bmNLZXl3b3JkQ29kZSA9IGV4cG9ydHMubWFjcm9LZXl3b3JkQ29kZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi9uYW1lc1wiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi8uLi92b2NhYnVsYXJpZXMvY29kZVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmZ1bmN0aW9uIG1hY3JvS2V5d29yZENvZGUoY3h0LCBkZWYpIHtcbiAgICBjb25zdCB7IGdlbiwga2V5d29yZCwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgbWFjcm9TY2hlbWEgPSBkZWYubWFjcm8uY2FsbChpdC5zZWxmLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQpO1xuICAgIGNvbnN0IHNjaGVtYVJlZiA9IHVzZUtleXdvcmQoZ2VuLCBrZXl3b3JkLCBtYWNyb1NjaGVtYSk7XG4gICAgaWYgKGl0Lm9wdHMudmFsaWRhdGVTY2hlbWEgIT09IGZhbHNlKVxuICAgICAgICBpdC5zZWxmLnZhbGlkYXRlU2NoZW1hKG1hY3JvU2NoZW1hLCB0cnVlKTtcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgIHNjaGVtYTogbWFjcm9TY2hlbWEsXG4gICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5uaWwsXG4gICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gLFxuICAgICAgICB0b3BTY2hlbWFSZWY6IHNjaGVtYVJlZixcbiAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICB9LCB2YWxpZCk7XG4gICAgY3h0LnBhc3ModmFsaWQsICgpID0+IGN4dC5lcnJvcih0cnVlKSk7XG59XG5leHBvcnRzLm1hY3JvS2V5d29yZENvZGUgPSBtYWNyb0tleXdvcmRDb2RlO1xuZnVuY3Rpb24gZnVuY0tleXdvcmRDb2RlKGN4dCwgZGVmKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgZ2VuLCBrZXl3b3JkLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgJGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgY2hlY2tBc3luY0tleXdvcmQoaXQsIGRlZik7XG4gICAgY29uc3QgdmFsaWRhdGUgPSAhJGRhdGEgJiYgZGVmLmNvbXBpbGUgPyBkZWYuY29tcGlsZS5jYWxsKGl0LnNlbGYsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCkgOiBkZWYudmFsaWRhdGU7XG4gICAgY29uc3QgdmFsaWRhdGVSZWYgPSB1c2VLZXl3b3JkKGdlbiwga2V5d29yZCwgdmFsaWRhdGUpO1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCB2YWxpZGF0ZUtleXdvcmQpO1xuICAgIGN4dC5vaygoX2EgPSBkZWYudmFsaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbGlkKTtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUtleXdvcmQoKSB7XG4gICAgICAgIGlmIChkZWYuZXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYXNzaWduVmFsaWQoKTtcbiAgICAgICAgICAgIGlmIChkZWYubW9kaWZ5aW5nKVxuICAgICAgICAgICAgICAgIG1vZGlmeURhdGEoY3h0KTtcbiAgICAgICAgICAgIHJlcG9ydEVycnMoKCkgPT4gY3h0LmVycm9yKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcnVsZUVycnMgPSBkZWYuYXN5bmMgPyB2YWxpZGF0ZUFzeW5jKCkgOiB2YWxpZGF0ZVN5bmMoKTtcbiAgICAgICAgICAgIGlmIChkZWYubW9kaWZ5aW5nKVxuICAgICAgICAgICAgICAgIG1vZGlmeURhdGEoY3h0KTtcbiAgICAgICAgICAgIHJlcG9ydEVycnMoKCkgPT4gYWRkRXJycyhjeHQsIHJ1bGVFcnJzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVBc3luYygpIHtcbiAgICAgICAgY29uc3QgcnVsZUVycnMgPSBnZW4ubGV0KFwicnVsZUVycnNcIiwgbnVsbCk7XG4gICAgICAgIGdlbi50cnkoKCkgPT4gYXNzaWduVmFsaWQoY29kZWdlbl8xLl8gYGF3YWl0IGApLCAoZSkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmlmKGNvZGVnZW5fMS5fIGAke2V9IGluc3RhbmNlb2YgJHtpdC5WYWxpZGF0aW9uRXJyb3J9YCwgKCkgPT4gZ2VuLmFzc2lnbihydWxlRXJycywgY29kZWdlbl8xLl8gYCR7ZX0uZXJyb3JzYCksICgpID0+IGdlbi50aHJvdyhlKSkpO1xuICAgICAgICByZXR1cm4gcnVsZUVycnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU3luYygpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVFcnJzID0gY29kZWdlbl8xLl8gYCR7dmFsaWRhdGVSZWZ9LmVycm9yc2A7XG4gICAgICAgIGdlbi5hc3NpZ24odmFsaWRhdGVFcnJzLCBudWxsKTtcbiAgICAgICAgYXNzaWduVmFsaWQoY29kZWdlbl8xLm5pbCk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZUVycnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2lnblZhbGlkKF9hd2FpdCA9IGRlZi5hc3luYyA/IGNvZGVnZW5fMS5fIGBhd2FpdCBgIDogY29kZWdlbl8xLm5pbCkge1xuICAgICAgICBjb25zdCBwYXNzQ3h0ID0gaXQub3B0cy5wYXNzQ29udGV4dCA/IG5hbWVzXzEuZGVmYXVsdC50aGlzIDogbmFtZXNfMS5kZWZhdWx0LnNlbGY7XG4gICAgICAgIGNvbnN0IHBhc3NTY2hlbWEgPSAhKChcImNvbXBpbGVcIiBpbiBkZWYgJiYgISRkYXRhKSB8fCBkZWYuc2NoZW1hID09PSBmYWxzZSk7XG4gICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGNvZGVnZW5fMS5fIGAke19hd2FpdH0ke2NvZGVfMS5jYWxsVmFsaWRhdGVDb2RlKGN4dCwgdmFsaWRhdGVSZWYsIHBhc3NDeHQsIHBhc3NTY2hlbWEpfWAsIGRlZi5tb2RpZnlpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXBvcnRFcnJzKGVycm9ycykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGdlbi5pZihjb2RlZ2VuXzEubm90KChfYSA9IGRlZi52YWxpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFsaWQpLCBlcnJvcnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuZnVuY0tleXdvcmRDb2RlID0gZnVuY0tleXdvcmRDb2RlO1xuZnVuY3Rpb24gbW9kaWZ5RGF0YShjeHQpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICBnZW4uaWYoaXQucGFyZW50RGF0YSwgKCkgPT4gZ2VuLmFzc2lnbihkYXRhLCBjb2RlZ2VuXzEuXyBgJHtpdC5wYXJlbnREYXRhfVske2l0LnBhcmVudERhdGFQcm9wZXJ0eX1dYCkpO1xufVxuZnVuY3Rpb24gYWRkRXJycyhjeHQsIGVycnMpIHtcbiAgICBjb25zdCB7IGdlbiB9ID0gY3h0O1xuICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgQXJyYXkuaXNBcnJheSgke2VycnN9KWAsICgpID0+IHtcbiAgICAgICAgZ2VuXG4gICAgICAgICAgICAuYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30gPT09IG51bGwgPyAke2VycnN9IDogJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30uY29uY2F0KCR7ZXJyc30pYClcbiAgICAgICAgICAgIC5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LmVycm9ycywgY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9Lmxlbmd0aGApO1xuICAgICAgICBlcnJvcnNfMS5leHRlbmRFcnJvcnMoY3h0KTtcbiAgICB9LCAoKSA9PiBjeHQuZXJyb3IoKSk7XG59XG5mdW5jdGlvbiBjaGVja0FzeW5jS2V5d29yZCh7IHNjaGVtYUVudiB9LCBkZWYpIHtcbiAgICBpZiAoZGVmLmFzeW5jICYmICFzY2hlbWFFbnYuJGFzeW5jKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBrZXl3b3JkIGluIHN5bmMgc2NoZW1hXCIpO1xufVxuZnVuY3Rpb24gdXNlS2V5d29yZChnZW4sIGtleXdvcmQsIHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBrZXl3b3JkIFwiJHtrZXl3b3JkfVwiIGZhaWxlZCB0byBjb21waWxlYCk7XG4gICAgcmV0dXJuIGdlbi5zY29wZVZhbHVlKFwia2V5d29yZFwiLCB0eXBlb2YgcmVzdWx0ID09IFwiZnVuY3Rpb25cIiA/IHsgcmVmOiByZXN1bHQgfSA6IHsgcmVmOiByZXN1bHQsIGNvZGU6IGNvZGVnZW5fMS5zdHJpbmdpZnkocmVzdWx0KSB9KTtcbn1cbmZ1bmN0aW9uIHZhbGlkU2NoZW1hVHlwZShzY2hlbWEsIHNjaGVtYVR5cGUsIGFsbG93VW5kZWZpbmVkID0gZmFsc2UpIHtcbiAgICAvLyBUT0RPIGFkZCB0ZXN0c1xuICAgIHJldHVybiAoIXNjaGVtYVR5cGUubGVuZ3RoIHx8XG4gICAgICAgIHNjaGVtYVR5cGUuc29tZSgoc3QpID0+IHN0ID09PSBcImFycmF5XCJcbiAgICAgICAgICAgID8gQXJyYXkuaXNBcnJheShzY2hlbWEpXG4gICAgICAgICAgICA6IHN0ID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICAgICAgPyBzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHNjaGVtYSlcbiAgICAgICAgICAgICAgICA6IHR5cGVvZiBzY2hlbWEgPT0gc3QgfHwgKGFsbG93VW5kZWZpbmVkICYmIHR5cGVvZiBzY2hlbWEgPT0gXCJ1bmRlZmluZWRcIikpKTtcbn1cbmV4cG9ydHMudmFsaWRTY2hlbWFUeXBlID0gdmFsaWRTY2hlbWFUeXBlO1xuZnVuY3Rpb24gdmFsaWRhdGVLZXl3b3JkVXNhZ2UoeyBzY2hlbWEsIG9wdHMsIHNlbGYsIGVyclNjaGVtYVBhdGggfSwgZGVmLCBrZXl3b3JkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmLmtleXdvcmQpID8gIWRlZi5rZXl3b3JkLmluY2x1ZGVzKGtleXdvcmQpIDogZGVmLmtleXdvcmQgIT09IGtleXdvcmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgIH1cbiAgICBjb25zdCBkZXBzID0gZGVmLmRlcGVuZGVuY2llcztcbiAgICBpZiAoZGVwcyA9PT0gbnVsbCB8fCBkZXBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZXBzLnNvbWUoKGt3ZCkgPT4gIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzY2hlbWEsIGt3ZCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFyZW50IHNjaGVtYSBtdXN0IGhhdmUgZGVwZW5kZW5jaWVzIG9mICR7a2V5d29yZH06ICR7ZGVwcy5qb2luKFwiLFwiKX1gKTtcbiAgICB9XG4gICAgaWYgKGRlZi52YWxpZGF0ZVNjaGVtYSkge1xuICAgICAgICBjb25zdCB2YWxpZCA9IGRlZi52YWxpZGF0ZVNjaGVtYShzY2hlbWFba2V5d29yZF0pO1xuICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBga2V5d29yZCBcIiR7a2V5d29yZH1cIiB2YWx1ZSBpcyBpbnZhbGlkIGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCI6IGAgK1xuICAgICAgICAgICAgICAgIHNlbGYuZXJyb3JzVGV4dChkZWYudmFsaWRhdGVTY2hlbWEuZXJyb3JzKTtcbiAgICAgICAgICAgIGlmIChvcHRzLnZhbGlkYXRlU2NoZW1hID09PSBcImxvZ1wiKVxuICAgICAgICAgICAgICAgIHNlbGYubG9nZ2VyLmVycm9yKG1zZyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlS2V5d29yZFVzYWdlID0gdmFsaWRhdGVLZXl3b3JkVXNhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXl3b3JkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHRlbmRTdWJzY2hlbWFNb2RlID0gZXhwb3J0cy5leHRlbmRTdWJzY2hlbWFEYXRhID0gZXhwb3J0cy5nZXRTdWJzY2hlbWEgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuZnVuY3Rpb24gZ2V0U3Vic2NoZW1hKGl0LCB7IGtleXdvcmQsIHNjaGVtYVByb3AsIHNjaGVtYSwgc2NoZW1hUGF0aCwgZXJyU2NoZW1hUGF0aCwgdG9wU2NoZW1hUmVmIH0pIHtcbiAgICBpZiAoa2V5d29yZCAhPT0gdW5kZWZpbmVkICYmIHNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYm90aCBcImtleXdvcmRcIiBhbmQgXCJzY2hlbWFcIiBwYXNzZWQsIG9ubHkgb25lIGFsbG93ZWQnKTtcbiAgICB9XG4gICAgaWYgKGtleXdvcmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBzY2ggPSBpdC5zY2hlbWFba2V5d29yZF07XG4gICAgICAgIHJldHVybiBzY2hlbWFQcm9wID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoLFxuICAgICAgICAgICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5fIGAke2l0LnNjaGVtYVBhdGh9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkoa2V5d29yZCl9YCxcbiAgICAgICAgICAgICAgICBlcnJTY2hlbWFQYXRoOiBgJHtpdC5lcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9YCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoW3NjaGVtYVByb3BdLFxuICAgICAgICAgICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5fIGAke2l0LnNjaGVtYVBhdGh9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkoa2V5d29yZCl9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkoc2NoZW1hUHJvcCl9YCxcbiAgICAgICAgICAgICAgICBlcnJTY2hlbWFQYXRoOiBgJHtpdC5lcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9LyR7dXRpbF8xLmVzY2FwZUZyYWdtZW50KHNjaGVtYVByb3ApfWAsXG4gICAgICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoc2NoZW1hICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHNjaGVtYVBhdGggPT09IHVuZGVmaW5lZCB8fCBlcnJTY2hlbWFQYXRoID09PSB1bmRlZmluZWQgfHwgdG9wU2NoZW1hUmVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJzY2hlbWFQYXRoXCIsIFwiZXJyU2NoZW1hUGF0aFwiIGFuZCBcInRvcFNjaGVtYVJlZlwiIGFyZSByZXF1aXJlZCB3aXRoIFwic2NoZW1hXCInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgc2NoZW1hUGF0aCxcbiAgICAgICAgICAgIHRvcFNjaGVtYVJlZixcbiAgICAgICAgICAgIGVyclNjaGVtYVBhdGgsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignZWl0aGVyIFwia2V5d29yZFwiIG9yIFwic2NoZW1hXCIgbXVzdCBiZSBwYXNzZWQnKTtcbn1cbmV4cG9ydHMuZ2V0U3Vic2NoZW1hID0gZ2V0U3Vic2NoZW1hO1xuZnVuY3Rpb24gZXh0ZW5kU3Vic2NoZW1hRGF0YShzdWJzY2hlbWEsIGl0LCB7IGRhdGFQcm9wLCBkYXRhUHJvcFR5cGU6IGRwVHlwZSwgZGF0YSwgZGF0YVR5cGVzLCBwcm9wZXJ0eU5hbWUgfSkge1xuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQgJiYgZGF0YVByb3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGggXCJkYXRhXCIgYW5kIFwiZGF0YVByb3BcIiBwYXNzZWQsIG9ubHkgb25lIGFsbG93ZWQnKTtcbiAgICB9XG4gICAgY29uc3QgeyBnZW4gfSA9IGl0O1xuICAgIGlmIChkYXRhUHJvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHsgZXJyb3JQYXRoLCBkYXRhUGF0aEFyciwgb3B0cyB9ID0gaXQ7XG4gICAgICAgIGNvbnN0IG5leHREYXRhID0gZ2VuLmxldChcImRhdGFcIiwgY29kZWdlbl8xLl8gYCR7aXQuZGF0YX0ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eShkYXRhUHJvcCl9YCwgdHJ1ZSk7XG4gICAgICAgIGRhdGFDb250ZXh0UHJvcHMobmV4dERhdGEpO1xuICAgICAgICBzdWJzY2hlbWEuZXJyb3JQYXRoID0gY29kZWdlbl8xLnN0ciBgJHtlcnJvclBhdGh9JHt1dGlsXzEuZ2V0RXJyb3JQYXRoKGRhdGFQcm9wLCBkcFR5cGUsIG9wdHMuanNQcm9wZXJ0eVN5bnRheCl9YDtcbiAgICAgICAgc3Vic2NoZW1hLnBhcmVudERhdGFQcm9wZXJ0eSA9IGNvZGVnZW5fMS5fIGAke2RhdGFQcm9wfWA7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhUGF0aEFyciA9IFsuLi5kYXRhUGF0aEFyciwgc3Vic2NoZW1hLnBhcmVudERhdGFQcm9wZXJ0eV07XG4gICAgfVxuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgbmV4dERhdGEgPSBkYXRhIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUgPyBkYXRhIDogZ2VuLmxldChcImRhdGFcIiwgZGF0YSwgdHJ1ZSk7IC8vIHJlcGxhY2VhYmxlIGlmIHVzZWQgb25jZT9cbiAgICAgICAgZGF0YUNvbnRleHRQcm9wcyhuZXh0RGF0YSk7XG4gICAgICAgIGlmIChwcm9wZXJ0eU5hbWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHN1YnNjaGVtYS5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG4gICAgICAgIC8vIFRPRE8gc29tZXRoaW5nIGlzIHBvc3NpYmx5IHdyb25nIGhlcmUgd2l0aCBub3QgY2hhbmdpbmcgcGFyZW50RGF0YVByb3BlcnR5IGFuZCBub3QgYXBwZW5kaW5nIGRhdGFQYXRoQXJyXG4gICAgfVxuICAgIGlmIChkYXRhVHlwZXMpXG4gICAgICAgIHN1YnNjaGVtYS5kYXRhVHlwZXMgPSBkYXRhVHlwZXM7XG4gICAgZnVuY3Rpb24gZGF0YUNvbnRleHRQcm9wcyhfbmV4dERhdGEpIHtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGEgPSBfbmV4dERhdGE7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhTGV2ZWwgPSBpdC5kYXRhTGV2ZWwgKyAxO1xuICAgICAgICBzdWJzY2hlbWEuZGF0YVR5cGVzID0gW107XG4gICAgICAgIGl0LmRlZmluZWRQcm9wZXJ0aWVzID0gbmV3IFNldCgpO1xuICAgICAgICBzdWJzY2hlbWEucGFyZW50RGF0YSA9IGl0LmRhdGE7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhTmFtZXMgPSBbLi4uaXQuZGF0YU5hbWVzLCBfbmV4dERhdGFdO1xuICAgIH1cbn1cbmV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hRGF0YSA9IGV4dGVuZFN1YnNjaGVtYURhdGE7XG5mdW5jdGlvbiBleHRlbmRTdWJzY2hlbWFNb2RlKHN1YnNjaGVtYSwgeyBqdGREaXNjcmltaW5hdG9yLCBqdGRNZXRhZGF0YSwgY29tcG9zaXRlUnVsZSwgY3JlYXRlRXJyb3JzLCBhbGxFcnJvcnMgfSkge1xuICAgIGlmIChjb21wb3NpdGVSdWxlICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHN1YnNjaGVtYS5jb21wb3NpdGVSdWxlID0gY29tcG9zaXRlUnVsZTtcbiAgICBpZiAoY3JlYXRlRXJyb3JzICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHN1YnNjaGVtYS5jcmVhdGVFcnJvcnMgPSBjcmVhdGVFcnJvcnM7XG4gICAgaWYgKGFsbEVycm9ycyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBzdWJzY2hlbWEuYWxsRXJyb3JzID0gYWxsRXJyb3JzO1xuICAgIHN1YnNjaGVtYS5qdGREaXNjcmltaW5hdG9yID0ganRkRGlzY3JpbWluYXRvcjsgLy8gbm90IGluaGVyaXRlZFxuICAgIHN1YnNjaGVtYS5qdGRNZXRhZGF0YSA9IGp0ZE1ldGFkYXRhOyAvLyBub3QgaW5oZXJpdGVkXG59XG5leHBvcnRzLmV4dGVuZFN1YnNjaGVtYU1vZGUgPSBleHRlbmRTdWJzY2hlbWFNb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NoZW1hLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuLy8gZG8gbm90IGVkaXQgLmpzIGZpbGVzIGRpcmVjdGx5IC0gZWRpdCBzcmMvaW5kZXguanN0XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxlbmd0aCwgaSwga2V5cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgIGlmICghZXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG5cbiAgICBpZiAoYS5jb25zdHJ1Y3RvciA9PT0gUmVnRXhwKSByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XG4gICAgaWYgKGEudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSByZXR1cm4gYS52YWx1ZU9mKCkgPT09IGIudmFsdWVPZigpO1xuICAgIGlmIChhLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZVxuICByZXR1cm4gYSE9PWEgJiYgYiE9PWI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHJhdmVyc2UgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzY2hlbWEsIG9wdHMsIGNiKSB7XG4gIC8vIExlZ2FjeSBzdXBwb3J0IGZvciB2MC4zLjEgYW5kIGVhcmxpZXIuXG4gIGlmICh0eXBlb2Ygb3B0cyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIGNiID0gb3B0cy5jYiB8fCBjYjtcbiAgdmFyIHByZSA9ICh0eXBlb2YgY2IgPT0gJ2Z1bmN0aW9uJykgPyBjYiA6IGNiLnByZSB8fCBmdW5jdGlvbigpIHt9O1xuICB2YXIgcG9zdCA9IGNiLnBvc3QgfHwgZnVuY3Rpb24oKSB7fTtcblxuICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hlbWEsICcnLCBzY2hlbWEpO1xufTtcblxuXG50cmF2ZXJzZS5rZXl3b3JkcyA9IHtcbiAgYWRkaXRpb25hbEl0ZW1zOiB0cnVlLFxuICBpdGVtczogdHJ1ZSxcbiAgY29udGFpbnM6IHRydWUsXG4gIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiB0cnVlLFxuICBwcm9wZXJ0eU5hbWVzOiB0cnVlLFxuICBub3Q6IHRydWUsXG4gIGlmOiB0cnVlLFxuICB0aGVuOiB0cnVlLFxuICBlbHNlOiB0cnVlXG59O1xuXG50cmF2ZXJzZS5hcnJheUtleXdvcmRzID0ge1xuICBpdGVtczogdHJ1ZSxcbiAgYWxsT2Y6IHRydWUsXG4gIGFueU9mOiB0cnVlLFxuICBvbmVPZjogdHJ1ZVxufTtcblxudHJhdmVyc2UucHJvcHNLZXl3b3JkcyA9IHtcbiAgJGRlZnM6IHRydWUsXG4gIGRlZmluaXRpb25zOiB0cnVlLFxuICBwcm9wZXJ0aWVzOiB0cnVlLFxuICBwYXR0ZXJuUHJvcGVydGllczogdHJ1ZSxcbiAgZGVwZW5kZW5jaWVzOiB0cnVlXG59O1xuXG50cmF2ZXJzZS5za2lwS2V5d29yZHMgPSB7XG4gIGRlZmF1bHQ6IHRydWUsXG4gIGVudW06IHRydWUsXG4gIGNvbnN0OiB0cnVlLFxuICByZXF1aXJlZDogdHJ1ZSxcbiAgbWF4aW11bTogdHJ1ZSxcbiAgbWluaW11bTogdHJ1ZSxcbiAgZXhjbHVzaXZlTWF4aW11bTogdHJ1ZSxcbiAgZXhjbHVzaXZlTWluaW11bTogdHJ1ZSxcbiAgbXVsdGlwbGVPZjogdHJ1ZSxcbiAgbWF4TGVuZ3RoOiB0cnVlLFxuICBtaW5MZW5ndGg6IHRydWUsXG4gIHBhdHRlcm46IHRydWUsXG4gIGZvcm1hdDogdHJ1ZSxcbiAgbWF4SXRlbXM6IHRydWUsXG4gIG1pbkl0ZW1zOiB0cnVlLFxuICB1bmlxdWVJdGVtczogdHJ1ZSxcbiAgbWF4UHJvcGVydGllczogdHJ1ZSxcbiAgbWluUHJvcGVydGllczogdHJ1ZVxufTtcblxuXG5mdW5jdGlvbiBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpIHtcbiAgaWYgKHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hID09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICBwcmUoc2NoZW1hLCBqc29uUHRyLCByb290U2NoZW1hLCBwYXJlbnRKc29uUHRyLCBwYXJlbnRLZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGtleUluZGV4KTtcbiAgICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICB2YXIgc2NoID0gc2NoZW1hW2tleV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2gpKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdHJhdmVyc2UuYXJyYXlLZXl3b3Jkcykge1xuICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxzY2gubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hbaV0sIGpzb25QdHIgKyAnLycgKyBrZXkgKyAnLycgKyBpLCByb290U2NoZW1hLCBqc29uUHRyLCBrZXksIHNjaGVtYSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5IGluIHRyYXZlcnNlLnByb3BzS2V5d29yZHMpIHtcbiAgICAgICAgaWYgKHNjaCAmJiB0eXBlb2Ygc2NoID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzY2gpXG4gICAgICAgICAgICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hbcHJvcF0sIGpzb25QdHIgKyAnLycgKyBrZXkgKyAnLycgKyBlc2NhcGVKc29uUHRyKHByb3ApLCByb290U2NoZW1hLCBqc29uUHRyLCBrZXksIHNjaGVtYSwgcHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5IGluIHRyYXZlcnNlLmtleXdvcmRzIHx8IChvcHRzLmFsbEtleXMgJiYgIShrZXkgaW4gdHJhdmVyc2Uuc2tpcEtleXdvcmRzKSkpIHtcbiAgICAgICAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoLCBqc29uUHRyICsgJy8nICsga2V5LCByb290U2NoZW1hLCBqc29uUHRyLCBrZXksIHNjaGVtYSk7XG4gICAgICB9XG4gICAgfVxuICAgIHBvc3Qoc2NoZW1hLCBqc29uUHRyLCByb290U2NoZW1hLCBwYXJlbnRKc29uUHRyLCBwYXJlbnRLZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGtleUluZGV4KTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGVzY2FwZUpzb25QdHIoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvfi9nLCAnfjAnKS5yZXBsYWNlKC9cXC8vZywgJ34xJyk7XG59XG4iLCIvKiogQGxpY2Vuc2UgVVJJLmpzIHY0LjQuMSAoYykgMjAxMSBHYXJ5IENvdXJ0LiBMaWNlbnNlOiBodHRwOi8vZ2l0aHViLmNvbS9nYXJ5Y291cnQvdXJpLWpzICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwuVVJJID0gZ2xvYmFsLlVSSSB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gbWVyZ2UoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNldHMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgc2V0c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAoc2V0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHNldHNbMF0gPSBzZXRzWzBdLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgdmFyIHhsID0gc2V0cy5sZW5ndGggLSAxO1xuICAgICAgICBmb3IgKHZhciB4ID0gMTsgeCA8IHhsOyArK3gpIHtcbiAgICAgICAgICAgIHNldHNbeF0gPSBzZXRzW3hdLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRzW3hsXSA9IHNldHNbeGxdLnNsaWNlKDEpO1xuICAgICAgICByZXR1cm4gc2V0cy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2V0c1swXTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJleHAoc3RyKSB7XG4gICAgcmV0dXJuIFwiKD86XCIgKyBzdHIgKyBcIilcIjtcbn1cbmZ1bmN0aW9uIHR5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8gPT09IHVuZGVmaW5lZCA/IFwidW5kZWZpbmVkXCIgOiBvID09PSBudWxsID8gXCJudWxsXCIgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc3BsaXQoXCIgXCIpLnBvcCgpLnNwbGl0KFwiXVwiKS5zaGlmdCgpLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiB0b1VwcGVyQ2FzZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRvVXBwZXJDYXNlKCk7XG59XG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICAgIHJldHVybiBvYmogIT09IHVuZGVmaW5lZCAmJiBvYmogIT09IG51bGwgPyBvYmogaW5zdGFuY2VvZiBBcnJheSA/IG9iaiA6IHR5cGVvZiBvYmoubGVuZ3RoICE9PSBcIm51bWJlclwiIHx8IG9iai5zcGxpdCB8fCBvYmouc2V0SW50ZXJ2YWwgfHwgb2JqLmNhbGwgPyBbb2JqXSA6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaikgOiBbXTtcbn1cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuICAgIHZhciBvYmogPSB0YXJnZXQ7XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRXhwcyhpc0lSSSkge1xuICAgIHZhciBBTFBIQSQkID0gXCJbQS1aYS16XVwiLFxuICAgICAgICBDUiQgPSBcIltcXFxceDBEXVwiLFxuICAgICAgICBESUdJVCQkID0gXCJbMC05XVwiLFxuICAgICAgICBEUVVPVEUkJCA9IFwiW1xcXFx4MjJdXCIsXG4gICAgICAgIEhFWERJRyQkID0gbWVyZ2UoRElHSVQkJCwgXCJbQS1GYS1mXVwiKSxcbiAgICAgICAgLy9jYXNlLWluc2Vuc2l0aXZlXG4gICAgTEYkJCA9IFwiW1xcXFx4MEFdXCIsXG4gICAgICAgIFNQJCQgPSBcIltcXFxceDIwXVwiLFxuICAgICAgICBQQ1RfRU5DT0RFRCQgPSBzdWJleHAoc3ViZXhwKFwiJVtFRmVmXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlWzg5QS1GYS1mXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSksXG4gICAgICAgIC8vZXhwYW5kZWRcbiAgICBHRU5fREVMSU1TJCQgPSBcIltcXFxcOlxcXFwvXFxcXD9cXFxcI1xcXFxbXFxcXF1cXFxcQF1cIixcbiAgICAgICAgU1VCX0RFTElNUyQkID0gXCJbXFxcXCFcXFxcJFxcXFwmXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXDtcXFxcPV1cIixcbiAgICAgICAgUkVTRVJWRUQkJCA9IG1lcmdlKEdFTl9ERUxJTVMkJCwgU1VCX0RFTElNUyQkKSxcbiAgICAgICAgVUNTQ0hBUiQkID0gaXNJUkkgPyBcIltcXFxceEEwLVxcXFx1MjAwRFxcXFx1MjAxMC1cXFxcdTIwMjlcXFxcdTIwMkYtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdXCIgOiBcIltdXCIsXG4gICAgICAgIC8vc3Vic2V0LCBleGNsdWRlcyBiaWRpIGNvbnRyb2wgY2hhcmFjdGVyc1xuICAgIElQUklWQVRFJCQgPSBpc0lSSSA/IFwiW1xcXFx1RTAwMC1cXFxcdUY4RkZdXCIgOiBcIltdXCIsXG4gICAgICAgIC8vc3Vic2V0XG4gICAgVU5SRVNFUlZFRCQkID0gbWVyZ2UoQUxQSEEkJCwgRElHSVQkJCwgXCJbXFxcXC1cXFxcLlxcXFxfXFxcXH5dXCIsIFVDU0NIQVIkJCksXG4gICAgICAgIFNDSEVNRSQgPSBzdWJleHAoQUxQSEEkJCArIG1lcmdlKEFMUEhBJCQsIERJR0lUJCQsIFwiW1xcXFwrXFxcXC1cXFxcLl1cIikgKyBcIipcIiksXG4gICAgICAgIFVTRVJJTkZPJCA9IHN1YmV4cChzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpdXCIpKSArIFwiKlwiKSxcbiAgICAgICAgREVDX09DVEVUJCA9IHN1YmV4cChzdWJleHAoXCIyNVswLTVdXCIpICsgXCJ8XCIgKyBzdWJleHAoXCIyWzAtNF1cIiArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIxXCIgKyBESUdJVCQkICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIlsxLTldXCIgKyBESUdJVCQkKSArIFwifFwiICsgRElHSVQkJCksXG4gICAgICAgIERFQ19PQ1RFVF9SRUxBWEVEJCA9IHN1YmV4cChzdWJleHAoXCIyNVswLTVdXCIpICsgXCJ8XCIgKyBzdWJleHAoXCIyWzAtNF1cIiArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIxXCIgKyBESUdJVCQkICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIjA/WzEtOV1cIiArIERJR0lUJCQpICsgXCJ8MD8wP1wiICsgRElHSVQkJCksXG4gICAgICAgIC8vcmVsYXhlZCBwYXJzaW5nIHJ1bGVzXG4gICAgSVBWNEFERFJFU1MkID0gc3ViZXhwKERFQ19PQ1RFVF9SRUxBWEVEJCArIFwiXFxcXC5cIiArIERFQ19PQ1RFVF9SRUxBWEVEJCArIFwiXFxcXC5cIiArIERFQ19PQ1RFVF9SRUxBWEVEJCArIFwiXFxcXC5cIiArIERFQ19PQ1RFVF9SRUxBWEVEJCksXG4gICAgICAgIEgxNiQgPSBzdWJleHAoSEVYRElHJCQgKyBcInsxLDR9XCIpLFxuICAgICAgICBMUzMyJCA9IHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIiArIEgxNiQpICsgXCJ8XCIgKyBJUFY0QUREUkVTUyQpLFxuICAgICAgICBJUFY2QUREUkVTUzEkID0gc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezZ9XCIgKyBMUzMyJCksXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgNiggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTMiQgPSBzdWJleHAoXCJcXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcIns1fVwiICsgTFMzMiQpLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICBcIjo6XCIgNSggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTMyQgPSBzdWJleHAoc3ViZXhwKEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7NH1cIiArIExTMzIkKSxcbiAgICAgICAgLy9bICAgICAgICAgICAgICAgaDE2IF0gXCI6OlwiIDQoIGgxNiBcIjpcIiApIGxzMzJcbiAgICBJUFY2QUREUkVTUzQkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDF9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezN9XCIgKyBMUzMyJCksXG4gICAgICAgIC8vWyAqMSggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiIDMoIGgxNiBcIjpcIiApIGxzMzJcbiAgICBJUFY2QUREUkVTUzUkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDJ9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezJ9XCIgKyBMUzMyJCksXG4gICAgICAgIC8vWyAqMiggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiIDIoIGgxNiBcIjpcIiApIGxzMzJcbiAgICBJUFY2QUREUkVTUzYkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDN9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIEgxNiQgKyBcIlxcXFw6XCIgKyBMUzMyJCksXG4gICAgICAgIC8vWyAqMyggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgIGgxNiBcIjpcIiAgIGxzMzJcbiAgICBJUFY2QUREUkVTUzckID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDR9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIExTMzIkKSxcbiAgICAgICAgLy9bICo0KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgICAgICAgICAgIGxzMzJcbiAgICBJUFY2QUREUkVTUzgkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDV9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIEgxNiQpLFxuICAgICAgICAvL1sgKjUoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICAgICAgICAgICAgaDE2XG4gICAgSVBWNkFERFJFU1M5JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCw2fVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIpLFxuICAgICAgICAvL1sgKjYoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIlxuICAgIElQVjZBRERSRVNTJCA9IHN1YmV4cChbSVBWNkFERFJFU1MxJCwgSVBWNkFERFJFU1MyJCwgSVBWNkFERFJFU1MzJCwgSVBWNkFERFJFU1M0JCwgSVBWNkFERFJFU1M1JCwgSVBWNkFERFJFU1M2JCwgSVBWNkFERFJFU1M3JCwgSVBWNkFERFJFU1M4JCwgSVBWNkFERFJFU1M5JF0uam9pbihcInxcIikpLFxuICAgICAgICBaT05FSUQkID0gc3ViZXhwKHN1YmV4cChVTlJFU0VSVkVEJCQgKyBcInxcIiArIFBDVF9FTkNPREVEJCkgKyBcIitcIiksXG4gICAgICAgIC8vUkZDIDY4NzRcbiAgICBJUFY2QUREUlokID0gc3ViZXhwKElQVjZBRERSRVNTJCArIFwiXFxcXCUyNVwiICsgWk9ORUlEJCksXG4gICAgICAgIC8vUkZDIDY4NzRcbiAgICBJUFY2QUREUlpfUkVMQVhFRCQgPSBzdWJleHAoSVBWNkFERFJFU1MkICsgc3ViZXhwKFwiXFxcXCUyNXxcXFxcJSg/IVwiICsgSEVYRElHJCQgKyBcInsyfSlcIikgKyBaT05FSUQkKSxcbiAgICAgICAgLy9SRkMgNjg3NCwgd2l0aCByZWxheGVkIHBhcnNpbmcgcnVsZXNcbiAgICBJUFZGVVRVUkUkID0gc3ViZXhwKFwiW3ZWXVwiICsgSEVYRElHJCQgKyBcIitcXFxcLlwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XVwiKSArIFwiK1wiKSxcbiAgICAgICAgSVBfTElURVJBTCQgPSBzdWJleHAoXCJcXFxcW1wiICsgc3ViZXhwKElQVjZBRERSWl9SRUxBWEVEJCArIFwifFwiICsgSVBWNkFERFJFU1MkICsgXCJ8XCIgKyBJUFZGVVRVUkUkKSArIFwiXFxcXF1cIiksXG4gICAgICAgIC8vUkZDIDY4NzRcbiAgICBSRUdfTkFNRSQgPSBzdWJleHAoc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpKSArIFwiKlwiKSxcbiAgICAgICAgSE9TVCQgPSBzdWJleHAoSVBfTElURVJBTCQgKyBcInxcIiArIElQVjRBRERSRVNTJCArIFwiKD8hXCIgKyBSRUdfTkFNRSQgKyBcIilcIiArIFwifFwiICsgUkVHX05BTUUkKSxcbiAgICAgICAgUE9SVCQgPSBzdWJleHAoRElHSVQkJCArIFwiKlwiKSxcbiAgICAgICAgQVVUSE9SSVRZJCA9IHN1YmV4cChzdWJleHAoVVNFUklORk8kICsgXCJAXCIpICsgXCI/XCIgKyBIT1NUJCArIHN1YmV4cChcIlxcXFw6XCIgKyBQT1JUJCkgKyBcIj9cIiksXG4gICAgICAgIFBDSEFSJCA9IHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOlxcXFxAXVwiKSksXG4gICAgICAgIFNFR01FTlQkID0gc3ViZXhwKFBDSEFSJCArIFwiKlwiKSxcbiAgICAgICAgU0VHTUVOVF9OWiQgPSBzdWJleHAoUENIQVIkICsgXCIrXCIpLFxuICAgICAgICBTRUdNRU5UX05aX05DJCA9IHN1YmV4cChzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXEBdXCIpKSArIFwiK1wiKSxcbiAgICAgICAgUEFUSF9BQkVNUFRZJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1wiICsgU0VHTUVOVCQpICsgXCIqXCIpLFxuICAgICAgICBQQVRIX0FCU09MVVRFJCA9IHN1YmV4cChcIlxcXFwvXCIgKyBzdWJleHAoU0VHTUVOVF9OWiQgKyBQQVRIX0FCRU1QVFkkKSArIFwiP1wiKSxcbiAgICAgICAgLy9zaW1wbGlmaWVkXG4gICAgUEFUSF9OT1NDSEVNRSQgPSBzdWJleHAoU0VHTUVOVF9OWl9OQyQgKyBQQVRIX0FCRU1QVFkkKSxcbiAgICAgICAgLy9zaW1wbGlmaWVkXG4gICAgUEFUSF9ST09UTEVTUyQgPSBzdWJleHAoU0VHTUVOVF9OWiQgKyBQQVRIX0FCRU1QVFkkKSxcbiAgICAgICAgLy9zaW1wbGlmaWVkXG4gICAgUEFUSF9FTVBUWSQgPSBcIig/IVwiICsgUENIQVIkICsgXCIpXCIsXG4gICAgICAgIFBBVEgkID0gc3ViZXhwKFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSxcbiAgICAgICAgUVVFUlkkID0gc3ViZXhwKHN1YmV4cChQQ0hBUiQgKyBcInxcIiArIG1lcmdlKFwiW1xcXFwvXFxcXD9dXCIsIElQUklWQVRFJCQpKSArIFwiKlwiKSxcbiAgICAgICAgRlJBR01FTlQkID0gc3ViZXhwKHN1YmV4cChQQ0hBUiQgKyBcInxbXFxcXC9cXFxcP11cIikgKyBcIipcIiksXG4gICAgICAgIEhJRVJfUEFSVCQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcL1wiICsgQVVUSE9SSVRZJCArIFBBVEhfQUJFTVBUWSQpICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSxcbiAgICAgICAgVVJJJCA9IHN1YmV4cChTQ0hFTUUkICsgXCJcXFxcOlwiICsgSElFUl9QQVJUJCArIHN1YmV4cChcIlxcXFw/XCIgKyBRVUVSWSQpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcI1wiICsgRlJBR01FTlQkKSArIFwiP1wiKSxcbiAgICAgICAgUkVMQVRJVkVfUEFSVCQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcL1wiICsgQVVUSE9SSVRZJCArIFBBVEhfQUJFTVBUWSQpICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9OT1NDSEVNRSQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSxcbiAgICAgICAgUkVMQVRJVkUkID0gc3ViZXhwKFJFTEFUSVZFX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjXCIgKyBGUkFHTUVOVCQpICsgXCI/XCIpLFxuICAgICAgICBVUklfUkVGRVJFTkNFJCA9IHN1YmV4cChVUkkkICsgXCJ8XCIgKyBSRUxBVElWRSQpLFxuICAgICAgICBBQlNPTFVURV9VUkkkID0gc3ViZXhwKFNDSEVNRSQgKyBcIlxcXFw6XCIgKyBISUVSX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiksXG4gICAgICAgIEdFTkVSSUNfUkVGJCA9IFwiXihcIiArIFNDSEVNRSQgKyBcIilcXFxcOlwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC8oXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8pXCIpICsgXCI/KFwiICsgUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfUk9PVExFU1MkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCArIFwiKVwiKSArIHN1YmV4cChcIlxcXFw/KFwiICsgUVVFUlkkICsgXCIpXCIpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcIyhcIiArIEZSQUdNRU5UJCArIFwiKVwiKSArIFwiPyRcIixcbiAgICAgICAgUkVMQVRJVkVfUkVGJCA9IFwiXigpezB9XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9OT1NDSEVNRSQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjKFwiICsgRlJBR01FTlQkICsgXCIpXCIpICsgXCI/JFwiLFxuICAgICAgICBBQlNPTFVURV9SRUYkID0gXCJeKFwiICsgU0NIRU1FJCArIFwiKVxcXFw6XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj8kXCIsXG4gICAgICAgIFNBTUVET0NfUkVGJCA9IFwiXlwiICsgc3ViZXhwKFwiXFxcXCMoXCIgKyBGUkFHTUVOVCQgKyBcIilcIikgKyBcIj8kXCIsXG4gICAgICAgIEFVVEhPUklUWV9SRUYkID0gXCJeXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8kXCI7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgTk9UX1NDSEVNRTogbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBBTFBIQSQkLCBESUdJVCQkLCBcIltcXFxcK1xcXFwtXFxcXC5dXCIpLCBcImdcIiksXG4gICAgICAgIE5PVF9VU0VSSU5GTzogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcOl1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9IT1NUOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFxbXFxcXF1cXFxcOl1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9QQVRIOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFwvXFxcXDpcXFxcQF1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9QQVRIX05PU0NIRU1FOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFwvXFxcXEBdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuICAgICAgICBOT1RfUVVFUlk6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpcXFxcQFxcXFwvXFxcXD9dXCIsIElQUklWQVRFJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9GUkFHTUVOVDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOlxcXFxAXFxcXC9cXFxcP11cIiksIFwiZ1wiKSxcbiAgICAgICAgRVNDQVBFOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuICAgICAgICBVTlJFU0VSVkVEOiBuZXcgUmVnRXhwKFVOUkVTRVJWRUQkJCwgXCJnXCIpLFxuICAgICAgICBPVEhFUl9DSEFSUzogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVdXCIsIFVOUkVTRVJWRUQkJCwgUkVTRVJWRUQkJCksIFwiZ1wiKSxcbiAgICAgICAgUENUX0VOQ09ERUQ6IG5ldyBSZWdFeHAoUENUX0VOQ09ERUQkLCBcImdcIiksXG4gICAgICAgIElQVjRBRERSRVNTOiBuZXcgUmVnRXhwKFwiXihcIiArIElQVjRBRERSRVNTJCArIFwiKSRcIiksXG4gICAgICAgIElQVjZBRERSRVNTOiBuZXcgUmVnRXhwKFwiXlxcXFxbPyhcIiArIElQVjZBRERSRVNTJCArIFwiKVwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwlMjV8XFxcXCUoPyFcIiArIEhFWERJRyQkICsgXCJ7Mn0pXCIpICsgXCIoXCIgKyBaT05FSUQkICsgXCIpXCIpICsgXCI/XFxcXF0/JFwiKSAvL1JGQyA2ODc0LCB3aXRoIHJlbGF4ZWQgcGFyc2luZyBydWxlc1xuICAgIH07XG59XG52YXIgVVJJX1BST1RPQ09MID0gYnVpbGRFeHBzKGZhbHNlKTtcblxudmFyIElSSV9QUk9UT0NPTCA9IGJ1aWxkRXhwcyh0cnVlKTtcblxudmFyIHNsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7XG4gICAgdmFyIF9hcnIgPSBbXTtcbiAgICB2YXIgX24gPSB0cnVlO1xuICAgIHZhciBfZCA9IGZhbHNlO1xuICAgIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2QgPSB0cnVlO1xuICAgICAgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfYXJyO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7XG4gICAgICByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgICB9XG4gIH07XG59KCk7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciB0b0NvbnN1bWFibGVBcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShhcnIpO1xuICB9XG59O1xuXG4vKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cbnZhciBtYXhJbnQgPSAyMTQ3NDgzNjQ3OyAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cbi8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cbnZhciBiYXNlID0gMzY7XG52YXIgdE1pbiA9IDE7XG52YXIgdE1heCA9IDI2O1xudmFyIHNrZXcgPSAzODtcbnZhciBkYW1wID0gNzAwO1xudmFyIGluaXRpYWxCaWFzID0gNzI7XG52YXIgaW5pdGlhbE4gPSAxMjg7IC8vIDB4ODBcbnZhciBkZWxpbWl0ZXIgPSAnLSc7IC8vICdcXHgyRCdcblxuLyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cbnZhciByZWdleFB1bnljb2RlID0gL154bi0tLztcbnZhciByZWdleE5vbkFTQ0lJID0gL1teXFwwLVxceDdFXS87IC8vIG5vbi1BU0NJSSBjaGFyc1xudmFyIHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2c7IC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuLyoqIEVycm9yIG1lc3NhZ2VzICovXG52YXIgZXJyb3JzID0ge1xuXHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xufTtcblxuLyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xudmFyIGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbjtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8qKlxuICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGVycm9yJDEodHlwZSkge1xuXHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xufVxuXG4vKipcbiAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcbiAqIGl0ZW0uXG4gKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0dmFyIHJlc3VsdCA9IFtdO1xuXHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG4gKiBhZGRyZXNzZXMuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuICogY2hhcmFjdGVyLlxuICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0dmFyIHJlc3VsdCA9ICcnO1xuXHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHR9XG5cdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcbiAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcbiAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG4gKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcbiAqIG1hdGNoaW5nIFVURi0xNi5cbiAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG4gKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuICogQG5hbWUgZGVjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuICovXG5mdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHR2YXIgb3V0cHV0ID0gW107XG5cdHZhciBjb3VudGVyID0gMDtcblx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0dmFyIHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHQvLyBJdCdzIGEgaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyLlxuXHRcdFx0dmFyIGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkge1xuXHRcdFx0XHQvLyBMb3cgc3Vycm9nYXRlLlxuXHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSXQncyBhbiB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGVcblx0XHRcdFx0Ly8gbmV4dCBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXIuXG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG4gKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuICogQG5hbWUgZW5jb2RlXG4gKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuICovXG52YXIgdWNzMmVuY29kZSA9IGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0cmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KFN0cmluZywgdG9Db25zdW1hYmxlQXJyYXkoYXJyYXkpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG4gKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG4gKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cbiAqL1xudmFyIGJhc2ljVG9EaWdpdCA9IGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0aWYgKGNvZGVQb2ludCAtIDB4MzAgPCAweDBBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4MTY7XG5cdH1cblx0aWYgKGNvZGVQb2ludCAtIDB4NDEgPCAweDFBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4NDE7XG5cdH1cblx0aWYgKGNvZGVQb2ludCAtIDB4NjEgPCAweDFBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4NjE7XG5cdH1cblx0cmV0dXJuIGJhc2U7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2VcbiAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcbiAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG4gKi9cbnZhciBkaWdpdFRvQmFzaWMgPSBmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG59O1xuXG4vKipcbiAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuICogQHByaXZhdGVcbiAqL1xudmFyIGFkYXB0ID0gZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdHZhciBrID0gMDtcblx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRmb3IgKDsgLyogbm8gaW5pdGlhbGl6YXRpb24gKi9kZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0fVxuXHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcbiAqIHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqL1xudmFyIGRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHQvLyBEb24ndCB1c2UgVUNTLTIuXG5cdHZhciBvdXRwdXQgPSBbXTtcblx0dmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXHR2YXIgaSA9IDA7XG5cdHZhciBuID0gaW5pdGlhbE47XG5cdHZhciBiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdHZhciBiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdGlmIChiYXNpYyA8IDApIHtcblx0XHRiYXNpYyA9IDA7XG5cdH1cblxuXHRmb3IgKHZhciBqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRlcnJvciQxKCdub3QtYmFzaWMnKTtcblx0XHR9XG5cdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdH1cblxuXHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0Zm9yICh2YXIgaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOykgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqL3tcblxuXHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0dmFyIG9sZGkgPSBpO1xuXHRcdGZvciAodmFyIHcgPSAxLCBrID0gYmFzZTs7IC8qIG5vIGNvbmRpdGlvbiAqL2sgKz0gYmFzZSkge1xuXG5cdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0ZXJyb3IkMSgnaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHR2YXIgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiBrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzO1xuXG5cdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRlcnJvciQxKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cdFx0fVxuXG5cdFx0dmFyIG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdGVycm9yJDEoJ292ZXJmbG93Jyk7XG5cdFx0fVxuXG5cdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRpICU9IG91dDtcblxuXHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXQuXG5cdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXHR9XG5cblx0cmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KFN0cmluZywgb3V0cHV0KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcbiAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqL1xudmFyIGVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHR2YXIgb3V0cHV0ID0gW107XG5cblx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gYW4gYXJyYXkgb2YgVW5pY29kZSBjb2RlIHBvaW50cy5cblx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHQvLyBDYWNoZSB0aGUgbGVuZ3RoLlxuXHR2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGUuXG5cdHZhciBuID0gaW5pdGlhbE47XG5cdHZhciBkZWx0YSA9IDA7XG5cdHZhciBiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50cy5cblx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuXHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcblx0dmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG5cdHRyeSB7XG5cdFx0Zm9yICh2YXIgX2l0ZXJhdG9yID0gaW5wdXRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG5cdFx0XHR2YXIgX2N1cnJlbnRWYWx1ZTIgPSBfc3RlcC52YWx1ZTtcblxuXHRcdFx0aWYgKF9jdXJyZW50VmFsdWUyIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoX2N1cnJlbnRWYWx1ZTIpKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcblx0XHRfaXRlcmF0b3JFcnJvciA9IGVycjtcblx0fSBmaW5hbGx5IHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcblx0XHRcdFx0X2l0ZXJhdG9yLnJldHVybigpO1xuXHRcdFx0fVxuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcblx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dmFyIGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblx0dmFyIGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGg7XG5cblx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyB3aXRoIGEgZGVsaW1pdGVyIHVubGVzcyBpdCdzIGVtcHR5LlxuXHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHR9XG5cblx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0dmFyIG0gPSBtYXhJbnQ7XG5cdFx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcblx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG5cdFx0dmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuXHRcdHRyeSB7XG5cdFx0XHRmb3IgKHZhciBfaXRlcmF0b3IyID0gaW5wdXRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcblx0XHRcdFx0dmFyIGN1cnJlbnRWYWx1ZSA9IF9zdGVwMi52YWx1ZTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3cuXG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuXHRcdFx0X2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG5cdFx0XHRcdFx0X2l0ZXJhdG9yMi5yZXR1cm4oKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuXHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yMjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdGVycm9yJDEoJ292ZXJmbG93Jyk7XG5cdFx0fVxuXG5cdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRuID0gbTtcblxuXHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7XG5cdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuXHRcdHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7XG5cblx0XHR0cnkge1xuXHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yMyA9IGlucHV0W1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7XG5cdFx0XHRcdHZhciBfY3VycmVudFZhbHVlID0gX3N0ZXAzLnZhbHVlO1xuXG5cdFx0XHRcdGlmIChfY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoX2N1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXG5cdFx0XHRcdFx0dmFyIHEgPSBkZWx0YTtcblx0XHRcdFx0XHRmb3IgKHZhciBrID0gYmFzZTs7IC8qIG5vIGNvbmRpdGlvbiAqL2sgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dmFyIHQgPSBrIDw9IGJpYXMgPyB0TWluIDogayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcztcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHZhciBxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHR2YXIgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKSk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlO1xuXHRcdFx0X2l0ZXJhdG9yRXJyb3IzID0gZXJyO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuKSB7XG5cdFx0XHRcdFx0X2l0ZXJhdG9yMy5yZXR1cm4oKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yMykge1xuXHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yMztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdCsrZGVsdGE7XG5cdFx0KytuO1xuXHR9XG5cdHJldHVybiBvdXRwdXQuam9pbignJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3NcbiAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cbiAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuICogY29udmVydGVkIHRvIFVuaWNvZGUuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cbiAqIGNvbnZlcnQgdG8gVW5pY29kZS5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuICogc3RyaW5nLlxuICovXG52YXIgdG9Vbmljb2RlID0gZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uIChzdHJpbmcpIHtcblx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZykgPyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpIDogc3RyaW5nO1xuXHR9KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG4gKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcbiAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuICogQVNDSUkuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG4gKiBVbmljb2RlIHN0cmluZy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3JcbiAqIGVtYWlsIGFkZHJlc3MuXG4gKi9cbnZhciB0b0FTQ0lJID0gZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpID8gJ3huLS0nICsgZW5jb2RlKHN0cmluZykgOiBzdHJpbmc7XG5cdH0pO1xufTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cbnZhciBwdW55Y29kZSA9IHtcblx0LyoqXG4gICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuICAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICAqIEB0eXBlIFN0cmluZ1xuICAqL1xuXHQndmVyc2lvbic6ICcyLjEuMCcsXG5cdC8qKlxuICAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG4gICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cbiAgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAgKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAgKiBAdHlwZSBPYmplY3RcbiAgKi9cblx0J3VjczInOiB7XG5cdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0fSxcblx0J2RlY29kZSc6IGRlY29kZSxcblx0J2VuY29kZSc6IGVuY29kZSxcblx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG59O1xuXG4vKipcbiAqIFVSSS5qc1xuICpcbiAqIEBmaWxlb3ZlcnZpZXcgQW4gUkZDIDM5ODYgY29tcGxpYW50LCBzY2hlbWUgZXh0ZW5kYWJsZSBVUkkgcGFyc2luZy92YWxpZGF0aW5nL3Jlc29sdmluZyBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0LlxuICogQGF1dGhvciA8YSBocmVmPVwibWFpbHRvOmdhcnkuY291cnRAZ21haWwuY29tXCI+R2FyeSBDb3VydDwvYT5cbiAqIEBzZWUgaHR0cDovL2dpdGh1Yi5jb20vZ2FyeWNvdXJ0L3VyaS1qc1xuICovXG4vKipcbiAqIENvcHlyaWdodCAyMDExIEdhcnkgQ291cnQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgYXJlXG4gKiBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZlxuICogICAgICAgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0XG4gKiAgICAgICBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICogICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgR0FSWSBDT1VSVCBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRURcbiAqIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkRcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBHQVJZIENPVVJUIE9SXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUlxuICogU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuICogQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGXG4gKiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqXG4gKiBUaGUgdmlld3MgYW5kIGNvbmNsdXNpb25zIGNvbnRhaW5lZCBpbiB0aGUgc29mdHdhcmUgYW5kIGRvY3VtZW50YXRpb24gYXJlIHRob3NlIG9mIHRoZVxuICogYXV0aG9ycyBhbmQgc2hvdWxkIG5vdCBiZSBpbnRlcnByZXRlZCBhcyByZXByZXNlbnRpbmcgb2ZmaWNpYWwgcG9saWNpZXMsIGVpdGhlciBleHByZXNzZWRcbiAqIG9yIGltcGxpZWQsIG9mIEdhcnkgQ291cnQuXG4gKi9cbnZhciBTQ0hFTUVTID0ge307XG5mdW5jdGlvbiBwY3RFbmNDaGFyKGNocikge1xuICAgIHZhciBjID0gY2hyLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIGUgPSB2b2lkIDA7XG4gICAgaWYgKGMgPCAxNikgZSA9IFwiJTBcIiArIGMudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7ZWxzZSBpZiAoYyA8IDEyOCkgZSA9IFwiJVwiICsgYy50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtlbHNlIGlmIChjIDwgMjA0OCkgZSA9IFwiJVwiICsgKGMgPj4gNiB8IDE5MikudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBcIiVcIiArIChjICYgNjMgfCAxMjgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO2Vsc2UgZSA9IFwiJVwiICsgKGMgPj4gMTIgfCAyMjQpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCIlXCIgKyAoYyA+PiA2ICYgNjMgfCAxMjgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCIlXCIgKyAoYyAmIDYzIHwgMTI4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHBjdERlY0NoYXJzKHN0cikge1xuICAgIHZhciBuZXdTdHIgPSBcIlwiO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgaWwgPSBzdHIubGVuZ3RoO1xuICAgIHdoaWxlIChpIDwgaWwpIHtcbiAgICAgICAgdmFyIGMgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyAxLCAyKSwgMTYpO1xuICAgICAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgICAgICAgbmV3U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgICAgICBpICs9IDM7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA+PSAxOTQgJiYgYyA8IDIyNCkge1xuICAgICAgICAgICAgaWYgKGlsIC0gaSA+PSA2KSB7XG4gICAgICAgICAgICAgICAgdmFyIGMyID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgNCwgMiksIDE2KTtcbiAgICAgICAgICAgICAgICBuZXdTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDMxKSA8PCA2IHwgYzIgJiA2Myk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSArPSA2O1xuICAgICAgICB9IGVsc2UgaWYgKGMgPj0gMjI0KSB7XG4gICAgICAgICAgICBpZiAoaWwgLSBpID49IDkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2MgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyA0LCAyKSwgMTYpO1xuICAgICAgICAgICAgICAgIHZhciBjMyA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDcsIDIpLCAxNik7XG4gICAgICAgICAgICAgICAgbmV3U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiAxNSkgPDwgMTIgfCAoX2MgJiA2MykgPDwgNiB8IGMzICYgNjMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdTdHIgKz0gc3RyLnN1YnN0cihpLCA5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgKz0gOTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDMpO1xuICAgICAgICAgICAgaSArPSAzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdTdHI7XG59XG5mdW5jdGlvbiBfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgcHJvdG9jb2wpIHtcbiAgICBmdW5jdGlvbiBkZWNvZGVVbnJlc2VydmVkKHN0cikge1xuICAgICAgICB2YXIgZGVjU3RyID0gcGN0RGVjQ2hhcnMoc3RyKTtcbiAgICAgICAgcmV0dXJuICFkZWNTdHIubWF0Y2gocHJvdG9jb2wuVU5SRVNFUlZFRCkgPyBzdHIgOiBkZWNTdHI7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRzLnNjaGVtZSkgY29tcG9uZW50cy5zY2hlbWUgPSBTdHJpbmcoY29tcG9uZW50cy5zY2hlbWUpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShwcm90b2NvbC5OT1RfU0NIRU1FLCBcIlwiKTtcbiAgICBpZiAoY29tcG9uZW50cy51c2VyaW5mbyAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLnVzZXJpbmZvID0gU3RyaW5nKGNvbXBvbmVudHMudXNlcmluZm8pLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UocHJvdG9jb2wuTk9UX1VTRVJJTkZPLCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG4gICAgaWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLmhvc3QgPSBTdHJpbmcoY29tcG9uZW50cy5ob3N0KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UocHJvdG9jb2wuTk9UX0hPU1QsIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICBpZiAoY29tcG9uZW50cy5wYXRoICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMucGF0aCA9IFN0cmluZyhjb21wb25lbnRzLnBhdGgpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoY29tcG9uZW50cy5zY2hlbWUgPyBwcm90b2NvbC5OT1RfUEFUSCA6IHByb3RvY29sLk5PVF9QQVRIX05PU0NIRU1FLCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG4gICAgaWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5xdWVyeSA9IFN0cmluZyhjb21wb25lbnRzLnF1ZXJ5KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKHByb3RvY29sLk5PVF9RVUVSWSwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgIGlmIChjb21wb25lbnRzLmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMuZnJhZ21lbnQgPSBTdHJpbmcoY29tcG9uZW50cy5mcmFnbWVudCkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShwcm90b2NvbC5OT1RfRlJBR01FTlQsIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICByZXR1cm4gY29tcG9uZW50cztcbn1cblxuZnVuY3Rpb24gX3N0cmlwTGVhZGluZ1plcm9zKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXjAqKC4qKS8sIFwiJDFcIikgfHwgXCIwXCI7XG59XG5mdW5jdGlvbiBfbm9ybWFsaXplSVB2NChob3N0LCBwcm90b2NvbCkge1xuICAgIHZhciBtYXRjaGVzID0gaG9zdC5tYXRjaChwcm90b2NvbC5JUFY0QUREUkVTUykgfHwgW107XG5cbiAgICB2YXIgX21hdGNoZXMgPSBzbGljZWRUb0FycmF5KG1hdGNoZXMsIDIpLFxuICAgICAgICBhZGRyZXNzID0gX21hdGNoZXNbMV07XG5cbiAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gYWRkcmVzcy5zcGxpdChcIi5cIikubWFwKF9zdHJpcExlYWRpbmdaZXJvcykuam9pbihcIi5cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGhvc3Q7XG4gICAgfVxufVxuZnVuY3Rpb24gX25vcm1hbGl6ZUlQdjYoaG9zdCwgcHJvdG9jb2wpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IGhvc3QubWF0Y2gocHJvdG9jb2wuSVBWNkFERFJFU1MpIHx8IFtdO1xuXG4gICAgdmFyIF9tYXRjaGVzMiA9IHNsaWNlZFRvQXJyYXkobWF0Y2hlcywgMyksXG4gICAgICAgIGFkZHJlc3MgPSBfbWF0Y2hlczJbMV0sXG4gICAgICAgIHpvbmUgPSBfbWF0Y2hlczJbMl07XG5cbiAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICB2YXIgX2FkZHJlc3MkdG9Mb3dlckNhc2UkID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpLnNwbGl0KCc6OicpLnJldmVyc2UoKSxcbiAgICAgICAgICAgIF9hZGRyZXNzJHRvTG93ZXJDYXNlJDIgPSBzbGljZWRUb0FycmF5KF9hZGRyZXNzJHRvTG93ZXJDYXNlJCwgMiksXG4gICAgICAgICAgICBsYXN0ID0gX2FkZHJlc3MkdG9Mb3dlckNhc2UkMlswXSxcbiAgICAgICAgICAgIGZpcnN0ID0gX2FkZHJlc3MkdG9Mb3dlckNhc2UkMlsxXTtcblxuICAgICAgICB2YXIgZmlyc3RGaWVsZHMgPSBmaXJzdCA/IGZpcnN0LnNwbGl0KFwiOlwiKS5tYXAoX3N0cmlwTGVhZGluZ1plcm9zKSA6IFtdO1xuICAgICAgICB2YXIgbGFzdEZpZWxkcyA9IGxhc3Quc3BsaXQoXCI6XCIpLm1hcChfc3RyaXBMZWFkaW5nWmVyb3MpO1xuICAgICAgICB2YXIgaXNMYXN0RmllbGRJUHY0QWRkcmVzcyA9IHByb3RvY29sLklQVjRBRERSRVNTLnRlc3QobGFzdEZpZWxkc1tsYXN0RmllbGRzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgdmFyIGZpZWxkQ291bnQgPSBpc0xhc3RGaWVsZElQdjRBZGRyZXNzID8gNyA6IDg7XG4gICAgICAgIHZhciBsYXN0RmllbGRzU3RhcnQgPSBsYXN0RmllbGRzLmxlbmd0aCAtIGZpZWxkQ291bnQ7XG4gICAgICAgIHZhciBmaWVsZHMgPSBBcnJheShmaWVsZENvdW50KTtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBmaWVsZENvdW50OyArK3gpIHtcbiAgICAgICAgICAgIGZpZWxkc1t4XSA9IGZpcnN0RmllbGRzW3hdIHx8IGxhc3RGaWVsZHNbbGFzdEZpZWxkc1N0YXJ0ICsgeF0gfHwgJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGFzdEZpZWxkSVB2NEFkZHJlc3MpIHtcbiAgICAgICAgICAgIGZpZWxkc1tmaWVsZENvdW50IC0gMV0gPSBfbm9ybWFsaXplSVB2NChmaWVsZHNbZmllbGRDb3VudCAtIDFdLCBwcm90b2NvbCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFsbFplcm9GaWVsZHMgPSBmaWVsZHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGZpZWxkLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKCFmaWVsZCB8fCBmaWVsZCA9PT0gXCIwXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdExvbmdlc3QgPSBhY2NbYWNjLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0TG9uZ2VzdCAmJiBsYXN0TG9uZ2VzdC5pbmRleCArIGxhc3RMb25nZXN0Lmxlbmd0aCA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdExvbmdlc3QubGVuZ3RoKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjLnB1c2goeyBpbmRleDogaW5kZXgsIGxlbmd0aDogMSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHZhciBsb25nZXN0WmVyb0ZpZWxkcyA9IGFsbFplcm9GaWVsZHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH0pWzBdO1xuICAgICAgICB2YXIgbmV3SG9zdCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGxvbmdlc3RaZXJvRmllbGRzICYmIGxvbmdlc3RaZXJvRmllbGRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBuZXdGaXJzdCA9IGZpZWxkcy5zbGljZSgwLCBsb25nZXN0WmVyb0ZpZWxkcy5pbmRleCk7XG4gICAgICAgICAgICB2YXIgbmV3TGFzdCA9IGZpZWxkcy5zbGljZShsb25nZXN0WmVyb0ZpZWxkcy5pbmRleCArIGxvbmdlc3RaZXJvRmllbGRzLmxlbmd0aCk7XG4gICAgICAgICAgICBuZXdIb3N0ID0gbmV3Rmlyc3Quam9pbihcIjpcIikgKyBcIjo6XCIgKyBuZXdMYXN0LmpvaW4oXCI6XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3SG9zdCA9IGZpZWxkcy5qb2luKFwiOlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoem9uZSkge1xuICAgICAgICAgICAgbmV3SG9zdCArPSBcIiVcIiArIHpvbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0hvc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGhvc3Q7XG4gICAgfVxufVxudmFyIFVSSV9QQVJTRSA9IC9eKD86KFteOlxcLz8jXSspOik/KD86XFwvXFwvKCg/OihbXlxcLz8jQF0qKUApPyhcXFtbXlxcLz8jXFxdXStcXF18W15cXC8/IzpdKikoPzpcXDooXFxkKikpPykpPyhbXj8jXSopKD86XFw/KFteI10qKSk/KD86IygoPzoufFxcbnxcXHIpKikpPy9pO1xudmFyIE5PX01BVENIX0lTX1VOREVGSU5FRCA9IFwiXCIubWF0Y2goLygpezB9LylbMV0gPT09IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIHBhcnNlKHVyaVN0cmluZykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHZhciBjb21wb25lbnRzID0ge307XG4gICAgdmFyIHByb3RvY29sID0gb3B0aW9ucy5pcmkgIT09IGZhbHNlID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MO1xuICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSA9PT0gXCJzdWZmaXhcIikgdXJpU3RyaW5nID0gKG9wdGlvbnMuc2NoZW1lID8gb3B0aW9ucy5zY2hlbWUgKyBcIjpcIiA6IFwiXCIpICsgXCIvL1wiICsgdXJpU3RyaW5nO1xuICAgIHZhciBtYXRjaGVzID0gdXJpU3RyaW5nLm1hdGNoKFVSSV9QQVJTRSk7XG4gICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgaWYgKE5PX01BVENIX0lTX1VOREVGSU5FRCkge1xuICAgICAgICAgICAgLy9zdG9yZSBlYWNoIGNvbXBvbmVudFxuICAgICAgICAgICAgY29tcG9uZW50cy5zY2hlbWUgPSBtYXRjaGVzWzFdO1xuICAgICAgICAgICAgY29tcG9uZW50cy51c2VyaW5mbyA9IG1hdGNoZXNbM107XG4gICAgICAgICAgICBjb21wb25lbnRzLmhvc3QgPSBtYXRjaGVzWzRdO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wYXRoID0gbWF0Y2hlc1s2XSB8fCBcIlwiO1xuICAgICAgICAgICAgY29tcG9uZW50cy5xdWVyeSA9IG1hdGNoZXNbN107XG4gICAgICAgICAgICBjb21wb25lbnRzLmZyYWdtZW50ID0gbWF0Y2hlc1s4XTtcbiAgICAgICAgICAgIC8vZml4IHBvcnQgbnVtYmVyXG4gICAgICAgICAgICBpZiAoaXNOYU4oY29tcG9uZW50cy5wb3J0KSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucG9ydCA9IG1hdGNoZXNbNV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL0lFIEZJWCBmb3IgaW1wcm9wZXIgUmVnRXhwIG1hdGNoaW5nXG4gICAgICAgICAgICAvL3N0b3JlIGVhY2ggY29tcG9uZW50XG4gICAgICAgICAgICBjb21wb25lbnRzLnNjaGVtZSA9IG1hdGNoZXNbMV0gfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29tcG9uZW50cy51c2VyaW5mbyA9IHVyaVN0cmluZy5pbmRleE9mKFwiQFwiKSAhPT0gLTEgPyBtYXRjaGVzWzNdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gdXJpU3RyaW5nLmluZGV4T2YoXCIvL1wiKSAhPT0gLTEgPyBtYXRjaGVzWzRdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wYXRoID0gbWF0Y2hlc1s2XSB8fCBcIlwiO1xuICAgICAgICAgICAgY29tcG9uZW50cy5xdWVyeSA9IHVyaVN0cmluZy5pbmRleE9mKFwiP1wiKSAhPT0gLTEgPyBtYXRjaGVzWzddIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29tcG9uZW50cy5mcmFnbWVudCA9IHVyaVN0cmluZy5pbmRleE9mKFwiI1wiKSAhPT0gLTEgPyBtYXRjaGVzWzhdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy9maXggcG9ydCBudW1iZXJcbiAgICAgICAgICAgIGlmIChpc05hTihjb21wb25lbnRzLnBvcnQpKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gdXJpU3RyaW5nLm1hdGNoKC9cXC9cXC8oPzoufFxcbikqXFw6KD86XFwvfFxcP3xcXCN8JCkvKSA/IG1hdGNoZXNbNF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBvbmVudHMuaG9zdCkge1xuICAgICAgICAgICAgLy9ub3JtYWxpemUgSVAgaG9zdHNcbiAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9IF9ub3JtYWxpemVJUHY2KF9ub3JtYWxpemVJUHY0KGNvbXBvbmVudHMuaG9zdCwgcHJvdG9jb2wpLCBwcm90b2NvbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy9kZXRlcm1pbmUgcmVmZXJlbmNlIHR5cGVcbiAgICAgICAgaWYgKGNvbXBvbmVudHMuc2NoZW1lID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy51c2VyaW5mbyA9PT0gdW5kZWZpbmVkICYmIGNvbXBvbmVudHMuaG9zdCA9PT0gdW5kZWZpbmVkICYmIGNvbXBvbmVudHMucG9ydCA9PT0gdW5kZWZpbmVkICYmICFjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5xdWVyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwic2FtZS1kb2N1bWVudFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvbmVudHMuc2NoZW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5yZWZlcmVuY2UgPSBcImFic29sdXRlXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwidXJpXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy9jaGVjayBmb3IgcmVmZXJlbmNlIGVycm9yc1xuICAgICAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgJiYgb3B0aW9ucy5yZWZlcmVuY2UgIT09IFwic3VmZml4XCIgJiYgb3B0aW9ucy5yZWZlcmVuY2UgIT09IGNvbXBvbmVudHMucmVmZXJlbmNlKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIlVSSSBpcyBub3QgYSBcIiArIG9wdGlvbnMucmVmZXJlbmNlICsgXCIgcmVmZXJlbmNlLlwiO1xuICAgICAgICB9XG4gICAgICAgIC8vZmluZCBzY2hlbWUgaGFuZGxlclxuICAgICAgICB2YXIgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbKG9wdGlvbnMuc2NoZW1lIHx8IGNvbXBvbmVudHMuc2NoZW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAvL2NoZWNrIGlmIHNjaGVtZSBjYW4ndCBoYW5kbGUgSVJJc1xuICAgICAgICBpZiAoIW9wdGlvbnMudW5pY29kZVN1cHBvcnQgJiYgKCFzY2hlbWVIYW5kbGVyIHx8ICFzY2hlbWVIYW5kbGVyLnVuaWNvZGVTdXBwb3J0KSkge1xuICAgICAgICAgICAgLy9pZiBob3N0IGNvbXBvbmVudCBpcyBhIGRvbWFpbiBuYW1lXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50cy5ob3N0ICYmIChvcHRpb25zLmRvbWFpbkhvc3QgfHwgc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLmRvbWFpbkhvc3QpKSB7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IFVuaWNvZGUgSUROIC0+IEFTQ0lJIElETlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9IHB1bnljb2RlLnRvQVNDSUkoY29tcG9uZW50cy5ob3N0LnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHBjdERlY0NoYXJzKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSG9zdCdzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIEFTQ0lJIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY29udmVydCBJUkkgLT4gVVJJXG4gICAgICAgICAgICBfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgVVJJX1BST1RPQ09MKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vbm9ybWFsaXplIGVuY29kaW5nc1xuICAgICAgICAgICAgX25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKGNvbXBvbmVudHMsIHByb3RvY29sKTtcbiAgICAgICAgfVxuICAgICAgICAvL3BlcmZvcm0gc2NoZW1lIHNwZWNpZmljIHBhcnNpbmdcbiAgICAgICAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5wYXJzZSkge1xuICAgICAgICAgICAgc2NoZW1lSGFuZGxlci5wYXJzZShjb21wb25lbnRzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiVVJJIGNhbiBub3QgYmUgcGFyc2VkLlwiO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50cztcbn1cblxuZnVuY3Rpb24gX3JlY29tcG9zZUF1dGhvcml0eShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgdmFyIHByb3RvY29sID0gb3B0aW9ucy5pcmkgIT09IGZhbHNlID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MO1xuICAgIHZhciB1cmlUb2tlbnMgPSBbXTtcbiAgICBpZiAoY29tcG9uZW50cy51c2VyaW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMudXNlcmluZm8pO1xuICAgICAgICB1cmlUb2tlbnMucHVzaChcIkBcIik7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRzLmhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvL25vcm1hbGl6ZSBJUCBob3N0cywgYWRkIGJyYWNrZXRzIGFuZCBlc2NhcGUgem9uZSBzZXBhcmF0b3IgZm9yIElQdjZcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goX25vcm1hbGl6ZUlQdjYoX25vcm1hbGl6ZUlQdjQoU3RyaW5nKGNvbXBvbmVudHMuaG9zdCksIHByb3RvY29sKSwgcHJvdG9jb2wpLnJlcGxhY2UocHJvdG9jb2wuSVBWNkFERFJFU1MsIGZ1bmN0aW9uIChfLCAkMSwgJDIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIltcIiArICQxICsgKCQyID8gXCIlMjVcIiArICQyIDogXCJcIikgKyBcIl1cIjtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudHMucG9ydCA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgY29tcG9uZW50cy5wb3J0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiOlwiKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goU3RyaW5nKGNvbXBvbmVudHMucG9ydCkpO1xuICAgIH1cbiAgICByZXR1cm4gdXJpVG9rZW5zLmxlbmd0aCA/IHVyaVRva2Vucy5qb2luKFwiXCIpIDogdW5kZWZpbmVkO1xufVxuXG52YXIgUkRTMSA9IC9eXFwuXFwuP1xcLy87XG52YXIgUkRTMiA9IC9eXFwvXFwuKFxcL3wkKS87XG52YXIgUkRTMyA9IC9eXFwvXFwuXFwuKFxcL3wkKS87XG52YXIgUkRTNSA9IC9eXFwvPyg/Oi58XFxuKSo/KD89XFwvfCQpLztcbmZ1bmN0aW9uIHJlbW92ZURvdFNlZ21lbnRzKGlucHV0KSB7XG4gICAgdmFyIG91dHB1dCA9IFtdO1xuICAgIHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoKFJEUzEpKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoUkRTMSwgXCJcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQubWF0Y2goUkRTMikpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMyLCBcIi9cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQubWF0Y2goUkRTMykpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMzLCBcIi9cIik7XG4gICAgICAgICAgICBvdXRwdXQucG9wKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQgPT09IFwiLlwiIHx8IGlucHV0ID09PSBcIi4uXCIpIHtcbiAgICAgICAgICAgIGlucHV0ID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbSA9IGlucHV0Lm1hdGNoKFJEUzUpO1xuICAgICAgICAgICAgaWYgKGltKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBpbVswXTtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBkb3Qgc2VnbWVudCBjb25kaXRpb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dC5qb2luKFwiXCIpO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemUoY29tcG9uZW50cykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHZhciBwcm90b2NvbCA9IG9wdGlvbnMuaXJpID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MO1xuICAgIHZhciB1cmlUb2tlbnMgPSBbXTtcbiAgICAvL2ZpbmQgc2NoZW1lIGhhbmRsZXJcbiAgICB2YXIgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbKG9wdGlvbnMuc2NoZW1lIHx8IGNvbXBvbmVudHMuc2NoZW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCldO1xuICAgIC8vcGVyZm9ybSBzY2hlbWUgc3BlY2lmaWMgc2VyaWFsaXphdGlvblxuICAgIGlmIChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZShjb21wb25lbnRzLCBvcHRpb25zKTtcbiAgICBpZiAoY29tcG9uZW50cy5ob3N0KSB7XG4gICAgICAgIC8vaWYgaG9zdCBjb21wb25lbnQgaXMgYW4gSVB2NiBhZGRyZXNzXG4gICAgICAgIGlmIChwcm90b2NvbC5JUFY2QUREUkVTUy50ZXN0KGNvbXBvbmVudHMuaG9zdCkpIHt9XG4gICAgICAgIC8vVE9ETzogbm9ybWFsaXplIElQdjYgYWRkcmVzcyBhcyBwZXIgUkZDIDU5NTJcblxuICAgICAgICAvL2lmIGhvc3QgY29tcG9uZW50IGlzIGEgZG9tYWluIG5hbWVcbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5kb21haW5Ib3N0IHx8IHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5kb21haW5Ib3N0KSB7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IElETiB2aWEgcHVueWNvZGVcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLmhvc3QgPSAhb3B0aW9ucy5pcmkgPyBwdW55Y29kZS50b0FTQ0lJKGNvbXBvbmVudHMuaG9zdC5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBwY3REZWNDaGFycykudG9Mb3dlckNhc2UoKSkgOiBwdW55Y29kZS50b1VuaWNvZGUoY29tcG9uZW50cy5ob3N0KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSG9zdCdzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIFwiICsgKCFvcHRpb25zLmlyaSA/IFwiQVNDSUlcIiA6IFwiVW5pY29kZVwiKSArIFwiIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgLy9ub3JtYWxpemUgZW5jb2RpbmdcbiAgICBfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgcHJvdG9jb2wpO1xuICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAhPT0gXCJzdWZmaXhcIiAmJiBjb21wb25lbnRzLnNjaGVtZSkge1xuICAgICAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnNjaGVtZSk7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiOlwiKTtcbiAgICB9XG4gICAgdmFyIGF1dGhvcml0eSA9IF9yZWNvbXBvc2VBdXRob3JpdHkoY29tcG9uZW50cywgb3B0aW9ucyk7XG4gICAgaWYgKGF1dGhvcml0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAhPT0gXCJzdWZmaXhcIikge1xuICAgICAgICAgICAgdXJpVG9rZW5zLnB1c2goXCIvL1wiKTtcbiAgICAgICAgfVxuICAgICAgICB1cmlUb2tlbnMucHVzaChhdXRob3JpdHkpO1xuICAgICAgICBpZiAoY29tcG9uZW50cy5wYXRoICYmIGNvbXBvbmVudHMucGF0aC5jaGFyQXQoMCkgIT09IFwiL1wiKSB7XG4gICAgICAgICAgICB1cmlUb2tlbnMucHVzaChcIi9cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBzID0gY29tcG9uZW50cy5wYXRoO1xuICAgICAgICBpZiAoIW9wdGlvbnMuYWJzb2x1dGVQYXRoICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci5hYnNvbHV0ZVBhdGgpKSB7XG4gICAgICAgICAgICBzID0gcmVtb3ZlRG90U2VnbWVudHMocyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF1dGhvcml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKC9eXFwvXFwvLywgXCIvJTJGXCIpOyAvL2Rvbid0IGFsbG93IHRoZSBwYXRoIHRvIHN0YXJ0IHdpdGggXCIvL1wiXG4gICAgICAgIH1cbiAgICAgICAgdXJpVG9rZW5zLnB1c2gocyk7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRzLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goXCI/XCIpO1xuICAgICAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnF1ZXJ5KTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cmlUb2tlbnMucHVzaChcIiNcIik7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMuZnJhZ21lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdXJpVG9rZW5zLmpvaW4oXCJcIik7IC8vbWVyZ2UgdG9rZW5zIGludG8gYSBzdHJpbmdcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudHMoYmFzZSwgcmVsYXRpdmUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHNraXBOb3JtYWxpemF0aW9uID0gYXJndW1lbnRzWzNdO1xuXG4gICAgdmFyIHRhcmdldCA9IHt9O1xuICAgIGlmICghc2tpcE5vcm1hbGl6YXRpb24pIHtcbiAgICAgICAgYmFzZSA9IHBhcnNlKHNlcmlhbGl6ZShiYXNlLCBvcHRpb25zKSwgb3B0aW9ucyk7IC8vbm9ybWFsaXplIGJhc2UgY29tcG9uZW50c1xuICAgICAgICByZWxhdGl2ZSA9IHBhcnNlKHNlcmlhbGl6ZShyZWxhdGl2ZSwgb3B0aW9ucyksIG9wdGlvbnMpOyAvL25vcm1hbGl6ZSByZWxhdGl2ZSBjb21wb25lbnRzXG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghb3B0aW9ucy50b2xlcmFudCAmJiByZWxhdGl2ZS5zY2hlbWUpIHtcbiAgICAgICAgdGFyZ2V0LnNjaGVtZSA9IHJlbGF0aXZlLnNjaGVtZTtcbiAgICAgICAgLy90YXJnZXQuYXV0aG9yaXR5ID0gcmVsYXRpdmUuYXV0aG9yaXR5O1xuICAgICAgICB0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mbztcbiAgICAgICAgdGFyZ2V0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICB0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCBcIlwiKTtcbiAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlbGF0aXZlLnVzZXJpbmZvICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUuaG9zdCAhPT0gdW5kZWZpbmVkIHx8IHJlbGF0aXZlLnBvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy90YXJnZXQuYXV0aG9yaXR5ID0gcmVsYXRpdmUuYXV0aG9yaXR5O1xuICAgICAgICAgICAgdGFyZ2V0LnVzZXJpbmZvID0gcmVsYXRpdmUudXNlcmluZm87XG4gICAgICAgICAgICB0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgICAgICB0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGggfHwgXCJcIik7XG4gICAgICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghcmVsYXRpdmUucGF0aCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gYmFzZS5wYXRoO1xuICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5xdWVyeSA9IGJhc2UucXVlcnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmVsYXRpdmUucGF0aC5jaGFyQXQoMCkgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChiYXNlLnVzZXJpbmZvICE9PSB1bmRlZmluZWQgfHwgYmFzZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgYmFzZS5wb3J0ICE9PSB1bmRlZmluZWQpICYmICFiYXNlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gXCIvXCIgKyByZWxhdGl2ZS5wYXRoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFiYXNlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVsYXRpdmUucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKDAsIGJhc2UucGF0aC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKSArIHJlbGF0aXZlLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyh0YXJnZXQucGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy90YXJnZXQuYXV0aG9yaXR5ID0gYmFzZS5hdXRob3JpdHk7XG4gICAgICAgICAgICB0YXJnZXQudXNlcmluZm8gPSBiYXNlLnVzZXJpbmZvO1xuICAgICAgICAgICAgdGFyZ2V0Lmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgICB0YXJnZXQucG9ydCA9IGJhc2UucG9ydDtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuc2NoZW1lID0gYmFzZS5zY2hlbWU7XG4gICAgfVxuICAgIHRhcmdldC5mcmFnbWVudCA9IHJlbGF0aXZlLmZyYWdtZW50O1xuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUoYmFzZVVSSSwgcmVsYXRpdmVVUkksIG9wdGlvbnMpIHtcbiAgICB2YXIgc2NoZW1lbGVzc09wdGlvbnMgPSBhc3NpZ24oeyBzY2hlbWU6ICdudWxsJyB9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gc2VyaWFsaXplKHJlc29sdmVDb21wb25lbnRzKHBhcnNlKGJhc2VVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgcGFyc2UocmVsYXRpdmVVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgc2NoZW1lbGVzc09wdGlvbnMsIHRydWUpLCBzY2hlbWVsZXNzT3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZSh1cmksIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHVyaSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB1cmkgPSBzZXJpYWxpemUocGFyc2UodXJpLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0eXBlT2YodXJpKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB1cmkgPSBwYXJzZShzZXJpYWxpemUodXJpLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB1cmk7XG59XG5cbmZ1bmN0aW9uIGVxdWFsKHVyaUEsIHVyaUIsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHVyaUEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdXJpQSA9IHNlcmlhbGl6ZShwYXJzZSh1cmlBLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0eXBlT2YodXJpQSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdXJpQSA9IHNlcmlhbGl6ZSh1cmlBLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB1cmlCID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHVyaUIgPSBzZXJpYWxpemUocGFyc2UodXJpQiwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAodHlwZU9mKHVyaUIpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHVyaUIgPSBzZXJpYWxpemUodXJpQiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB1cmlBID09PSB1cmlCO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVDb21wb25lbnQoc3RyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHN0ciAmJiBzdHIudG9TdHJpbmcoKS5yZXBsYWNlKCFvcHRpb25zIHx8ICFvcHRpb25zLmlyaSA/IFVSSV9QUk9UT0NPTC5FU0NBUEUgOiBJUklfUFJPVE9DT0wuRVNDQVBFLCBwY3RFbmNDaGFyKTtcbn1cblxuZnVuY3Rpb24gdW5lc2NhcGVDb21wb25lbnQoc3RyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHN0ciAmJiBzdHIudG9TdHJpbmcoKS5yZXBsYWNlKCFvcHRpb25zIHx8ICFvcHRpb25zLmlyaSA/IFVSSV9QUk9UT0NPTC5QQ1RfRU5DT0RFRCA6IElSSV9QUk9UT0NPTC5QQ1RfRU5DT0RFRCwgcGN0RGVjQ2hhcnMpO1xufVxuXG52YXIgaGFuZGxlciA9IHtcbiAgICBzY2hlbWU6IFwiaHR0cFwiLFxuICAgIGRvbWFpbkhvc3Q6IHRydWUsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgLy9yZXBvcnQgbWlzc2luZyBob3N0XG4gICAgICAgIGlmICghY29tcG9uZW50cy5ob3N0KSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIkhUVFAgVVJJcyBtdXN0IGhhdmUgYSBob3N0LlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgc2VjdXJlID0gU3RyaW5nKGNvbXBvbmVudHMuc2NoZW1lKS50b0xvd2VyQ2FzZSgpID09PSBcImh0dHBzXCI7XG4gICAgICAgIC8vbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcbiAgICAgICAgaWYgKGNvbXBvbmVudHMucG9ydCA9PT0gKHNlY3VyZSA/IDQ0MyA6IDgwKSB8fCBjb21wb25lbnRzLnBvcnQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucG9ydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvL25vcm1hbGl6ZSB0aGUgZW1wdHkgcGF0aFxuICAgICAgICBpZiAoIWNvbXBvbmVudHMucGF0aCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5wYXRoID0gXCIvXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy9OT1RFOiBXZSBkbyBub3QgcGFyc2UgcXVlcnkgc3RyaW5ncyBmb3IgSFRUUCBVUklzXG4gICAgICAgIC8vYXMgV1dXIEZvcm0gVXJsIEVuY29kZWQgcXVlcnkgc3RyaW5ncyBhcmUgcGFydCBvZiB0aGUgSFRNTDQrIHNwZWMsXG4gICAgICAgIC8vYW5kIG5vdCB0aGUgSFRUUCBzcGVjLlxuICAgICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9XG59O1xuXG52YXIgaGFuZGxlciQxID0ge1xuICAgIHNjaGVtZTogXCJodHRwc1wiLFxuICAgIGRvbWFpbkhvc3Q6IGhhbmRsZXIuZG9tYWluSG9zdCxcbiAgICBwYXJzZTogaGFuZGxlci5wYXJzZSxcbiAgICBzZXJpYWxpemU6IGhhbmRsZXIuc2VyaWFsaXplXG59O1xuXG5mdW5jdGlvbiBpc1NlY3VyZSh3c0NvbXBvbmVudHMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdzQ29tcG9uZW50cy5zZWN1cmUgPT09ICdib29sZWFuJyA/IHdzQ29tcG9uZW50cy5zZWN1cmUgOiBTdHJpbmcod3NDb21wb25lbnRzLnNjaGVtZSkudG9Mb3dlckNhc2UoKSA9PT0gXCJ3c3NcIjtcbn1cbi8vUkZDIDY0NTVcbnZhciBoYW5kbGVyJDIgPSB7XG4gICAgc2NoZW1lOiBcIndzXCIsXG4gICAgZG9tYWluSG9zdDogdHJ1ZSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgd3NDb21wb25lbnRzID0gY29tcG9uZW50cztcbiAgICAgICAgLy9pbmRpY2F0ZSBpZiB0aGUgc2VjdXJlIGZsYWcgaXMgc2V0XG4gICAgICAgIHdzQ29tcG9uZW50cy5zZWN1cmUgPSBpc1NlY3VyZSh3c0NvbXBvbmVudHMpO1xuICAgICAgICAvL2NvbnN0cnVjdCByZXNvdWNlIG5hbWVcbiAgICAgICAgd3NDb21wb25lbnRzLnJlc291cmNlTmFtZSA9ICh3c0NvbXBvbmVudHMucGF0aCB8fCAnLycpICsgKHdzQ29tcG9uZW50cy5xdWVyeSA/ICc/JyArIHdzQ29tcG9uZW50cy5xdWVyeSA6ICcnKTtcbiAgICAgICAgd3NDb21wb25lbnRzLnBhdGggPSB1bmRlZmluZWQ7XG4gICAgICAgIHdzQ29tcG9uZW50cy5xdWVyeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHdzQ29tcG9uZW50cztcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplKHdzQ29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICAvL25vcm1hbGl6ZSB0aGUgZGVmYXVsdCBwb3J0XG4gICAgICAgIGlmICh3c0NvbXBvbmVudHMucG9ydCA9PT0gKGlzU2VjdXJlKHdzQ29tcG9uZW50cykgPyA0NDMgOiA4MCkgfHwgd3NDb21wb25lbnRzLnBvcnQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vZW5zdXJlIHNjaGVtZSBtYXRjaGVzIHNlY3VyZSBmbGFnXG4gICAgICAgIGlmICh0eXBlb2Ygd3NDb21wb25lbnRzLnNlY3VyZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB3c0NvbXBvbmVudHMuc2NoZW1lID0gd3NDb21wb25lbnRzLnNlY3VyZSA/ICd3c3MnIDogJ3dzJztcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5zZWN1cmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9yZWNvbnN0cnVjdCBwYXRoIGZyb20gcmVzb3VyY2UgbmFtZVxuICAgICAgICBpZiAod3NDb21wb25lbnRzLnJlc291cmNlTmFtZSkge1xuICAgICAgICAgICAgdmFyIF93c0NvbXBvbmVudHMkcmVzb3VyYyA9IHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUuc3BsaXQoJz8nKSxcbiAgICAgICAgICAgICAgICBfd3NDb21wb25lbnRzJHJlc291cmMyID0gc2xpY2VkVG9BcnJheShfd3NDb21wb25lbnRzJHJlc291cmMsIDIpLFxuICAgICAgICAgICAgICAgIHBhdGggPSBfd3NDb21wb25lbnRzJHJlc291cmMyWzBdLFxuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gX3dzQ29tcG9uZW50cyRyZXNvdXJjMlsxXTtcblxuICAgICAgICAgICAgd3NDb21wb25lbnRzLnBhdGggPSBwYXRoICYmIHBhdGggIT09ICcvJyA/IHBhdGggOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB3c0NvbXBvbmVudHMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9mb3JiaWQgZnJhZ21lbnQgY29tcG9uZW50XG4gICAgICAgIHdzQ29tcG9uZW50cy5mcmFnbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHdzQ29tcG9uZW50cztcbiAgICB9XG59O1xuXG52YXIgaGFuZGxlciQzID0ge1xuICAgIHNjaGVtZTogXCJ3c3NcIixcbiAgICBkb21haW5Ib3N0OiBoYW5kbGVyJDIuZG9tYWluSG9zdCxcbiAgICBwYXJzZTogaGFuZGxlciQyLnBhcnNlLFxuICAgIHNlcmlhbGl6ZTogaGFuZGxlciQyLnNlcmlhbGl6ZVxufTtcblxudmFyIE8gPSB7fTtcbnZhciBpc0lSSSA9IHRydWU7XG4vL1JGQyAzOTg2XG52YXIgVU5SRVNFUlZFRCQkID0gXCJbQS1aYS16MC05XFxcXC1cXFxcLlxcXFxfXFxcXH5cIiArIChpc0lSSSA/IFwiXFxcXHhBMC1cXFxcdTIwMERcXFxcdTIwMTAtXFxcXHUyMDI5XFxcXHUyMDJGLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXCIgOiBcIlwiKSArIFwiXVwiO1xudmFyIEhFWERJRyQkID0gXCJbMC05QS1GYS1mXVwiOyAvL2Nhc2UtaW5zZW5zaXRpdmVcbnZhciBQQ1RfRU5DT0RFRCQgPSBzdWJleHAoc3ViZXhwKFwiJVtFRmVmXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlWzg5QS1GYS1mXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSk7IC8vZXhwYW5kZWRcbi8vUkZDIDUzMjIsIGV4Y2VwdCB0aGVzZSBzeW1ib2xzIGFzIHBlciBSRkMgNjA2ODogQCA6IC8gPyAjIFsgXSAmIDsgPVxuLy9jb25zdCBBVEVYVCQkID0gXCJbQS1aYS16MC05XFxcXCFcXFxcI1xcXFwkXFxcXCVcXFxcJlxcXFwnXFxcXCpcXFxcK1xcXFwtXFxcXC9cXFxcPVxcXFw/XFxcXF5cXFxcX1xcXFxgXFxcXHtcXFxcfFxcXFx9XFxcXH5dXCI7XG4vL2NvbnN0IFdTUCQkID0gXCJbXFxcXHgyMFxcXFx4MDldXCI7XG4vL2NvbnN0IE9CU19RVEVYVCQkID0gXCJbXFxcXHgwMS1cXFxceDA4XFxcXHgwQlxcXFx4MENcXFxceDBFLVxcXFx4MUZcXFxceDdGXVwiOyAgLy8oJWQxLTggLyAlZDExLTEyIC8gJWQxNC0zMSAvICVkMTI3KVxuLy9jb25zdCBRVEVYVCQkID0gbWVyZ2UoXCJbXFxcXHgyMVxcXFx4MjMtXFxcXHg1QlxcXFx4NUQtXFxcXHg3RV1cIiwgT0JTX1FURVhUJCQpOyAgLy8lZDMzIC8gJWQzNS05MSAvICVkOTMtMTI2IC8gb2JzLXF0ZXh0XG4vL2NvbnN0IFZDSEFSJCQgPSBcIltcXFxceDIxLVxcXFx4N0VdXCI7XG4vL2NvbnN0IFdTUCQkID0gXCJbXFxcXHgyMFxcXFx4MDldXCI7XG4vL2NvbnN0IE9CU19RUCQgPSBzdWJleHAoXCJcXFxcXFxcXFwiICsgbWVyZ2UoXCJbXFxcXHgwMFxcXFx4MERcXFxceDBBXVwiLCBPQlNfUVRFWFQkJCkpOyAgLy8lZDAgLyBDUiAvIExGIC8gb2JzLXF0ZXh0XG4vL2NvbnN0IEZXUyQgPSBzdWJleHAoc3ViZXhwKFdTUCQkICsgXCIqXCIgKyBcIlxcXFx4MERcXFxceDBBXCIpICsgXCI/XCIgKyBXU1AkJCArIFwiK1wiKTtcbi8vY29uc3QgUVVPVEVEX1BBSVIkID0gc3ViZXhwKHN1YmV4cChcIlxcXFxcXFxcXCIgKyBzdWJleHAoVkNIQVIkJCArIFwifFwiICsgV1NQJCQpKSArIFwifFwiICsgT0JTX1FQJCk7XG4vL2NvbnN0IFFVT1RFRF9TVFJJTkckID0gc3ViZXhwKCdcXFxcXCInICsgc3ViZXhwKEZXUyQgKyBcIj9cIiArIFFDT05URU5UJCkgKyBcIipcIiArIEZXUyQgKyBcIj9cIiArICdcXFxcXCInKTtcbnZhciBBVEVYVCQkID0gXCJbQS1aYS16MC05XFxcXCFcXFxcJFxcXFwlXFxcXCdcXFxcKlxcXFwrXFxcXC1cXFxcXlxcXFxfXFxcXGBcXFxce1xcXFx8XFxcXH1cXFxcfl1cIjtcbnZhciBRVEVYVCQkID0gXCJbXFxcXCFcXFxcJFxcXFwlXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXC1cXFxcLjAtOVxcXFw8XFxcXD5BLVpcXFxceDVFLVxcXFx4N0VdXCI7XG52YXIgVkNIQVIkJCA9IG1lcmdlKFFURVhUJCQsIFwiW1xcXFxcXFwiXFxcXFxcXFxdXCIpO1xudmFyIFNPTUVfREVMSU1TJCQgPSBcIltcXFxcIVxcXFwkXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXDtcXFxcOlxcXFxAXVwiO1xudmFyIFVOUkVTRVJWRUQgPSBuZXcgUmVnRXhwKFVOUkVTRVJWRUQkJCwgXCJnXCIpO1xudmFyIFBDVF9FTkNPREVEID0gbmV3IFJlZ0V4cChQQ1RfRU5DT0RFRCQsIFwiZ1wiKTtcbnZhciBOT1RfTE9DQUxfUEFSVCA9IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgQVRFWFQkJCwgXCJbXFxcXC5dXCIsICdbXFxcXFwiXScsIFZDSEFSJCQpLCBcImdcIik7XG52YXIgTk9UX0hGTkFNRSA9IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgVU5SRVNFUlZFRCQkLCBTT01FX0RFTElNUyQkKSwgXCJnXCIpO1xudmFyIE5PVF9IRlZBTFVFID0gTk9UX0hGTkFNRTtcbmZ1bmN0aW9uIGRlY29kZVVucmVzZXJ2ZWQoc3RyKSB7XG4gICAgdmFyIGRlY1N0ciA9IHBjdERlY0NoYXJzKHN0cik7XG4gICAgcmV0dXJuICFkZWNTdHIubWF0Y2goVU5SRVNFUlZFRCkgPyBzdHIgOiBkZWNTdHI7XG59XG52YXIgaGFuZGxlciQ0ID0ge1xuICAgIHNjaGVtZTogXCJtYWlsdG9cIixcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UkJDEoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgbWFpbHRvQ29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gICAgICAgIHZhciB0byA9IG1haWx0b0NvbXBvbmVudHMudG8gPSBtYWlsdG9Db21wb25lbnRzLnBhdGggPyBtYWlsdG9Db21wb25lbnRzLnBhdGguc3BsaXQoXCIsXCIpIDogW107XG4gICAgICAgIG1haWx0b0NvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1haWx0b0NvbXBvbmVudHMucXVlcnkpIHtcbiAgICAgICAgICAgIHZhciB1bmtub3duSGVhZGVycyA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBoZmllbGRzID0gbWFpbHRvQ29tcG9uZW50cy5xdWVyeS5zcGxpdChcIiZcIik7XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMCwgeGwgPSBoZmllbGRzLmxlbmd0aDsgeCA8IHhsOyArK3gpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGZpZWxkID0gaGZpZWxkc1t4XS5zcGxpdChcIj1cIik7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChoZmllbGRbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9BZGRycyA9IGhmaWVsZFsxXS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfeCA9IDAsIF94bCA9IHRvQWRkcnMubGVuZ3RoOyBfeCA8IF94bDsgKytfeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvLnB1c2godG9BZGRyc1tfeF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdWJqZWN0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWlsdG9Db21wb25lbnRzLnN1YmplY3QgPSB1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWlsdG9Db21wb25lbnRzLmJvZHkgPSB1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmtub3duSGVhZGVycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW3VuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFswXSwgb3B0aW9ucyldID0gdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzFdLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmtub3duSGVhZGVycykgbWFpbHRvQ29tcG9uZW50cy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgfVxuICAgICAgICBtYWlsdG9Db21wb25lbnRzLnF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKHZhciBfeDIgPSAwLCBfeGwyID0gdG8ubGVuZ3RoOyBfeDIgPCBfeGwyOyArK194Mikge1xuICAgICAgICAgICAgdmFyIGFkZHIgPSB0b1tfeDJdLnNwbGl0KFwiQFwiKTtcbiAgICAgICAgICAgIGFkZHJbMF0gPSB1bmVzY2FwZUNvbXBvbmVudChhZGRyWzBdKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCkge1xuICAgICAgICAgICAgICAgIC8vY29udmVydCBVbmljb2RlIElETiAtPiBBU0NJSSBJRE5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhZGRyWzFdID0gcHVueWNvZGUudG9BU0NJSSh1bmVzY2FwZUNvbXBvbmVudChhZGRyWzFdLCBvcHRpb25zKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1haWx0b0NvbXBvbmVudHMuZXJyb3IgPSBtYWlsdG9Db21wb25lbnRzLmVycm9yIHx8IFwiRW1haWwgYWRkcmVzcydzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIEFTQ0lJIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkclsxXSA9IHVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMV0sIG9wdGlvbnMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b1tfeDJdID0gYWRkci5qb2luKFwiQFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFpbHRvQ29tcG9uZW50cztcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplJCQxKG1haWx0b0NvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBtYWlsdG9Db21wb25lbnRzO1xuICAgICAgICB2YXIgdG8gPSB0b0FycmF5KG1haWx0b0NvbXBvbmVudHMudG8pO1xuICAgICAgICBpZiAodG8pIHtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwLCB4bCA9IHRvLmxlbmd0aDsgeCA8IHhsOyArK3gpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9BZGRyID0gU3RyaW5nKHRvW3hdKTtcbiAgICAgICAgICAgICAgICB2YXIgYXRJZHggPSB0b0FkZHIubGFzdEluZGV4T2YoXCJAXCIpO1xuICAgICAgICAgICAgICAgIHZhciBsb2NhbFBhcnQgPSB0b0FkZHIuc2xpY2UoMCwgYXRJZHgpLnJlcGxhY2UoUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKS5yZXBsYWNlKE5PVF9MT0NBTF9QQVJULCBwY3RFbmNDaGFyKTtcbiAgICAgICAgICAgICAgICB2YXIgZG9tYWluID0gdG9BZGRyLnNsaWNlKGF0SWR4ICsgMSk7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IElETiB2aWEgcHVueWNvZGVcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkb21haW4gPSAhb3B0aW9ucy5pcmkgPyBwdW55Y29kZS50b0FTQ0lJKHVuZXNjYXBlQ29tcG9uZW50KGRvbWFpbiwgb3B0aW9ucykudG9Mb3dlckNhc2UoKSkgOiBwdW55Y29kZS50b1VuaWNvZGUoZG9tYWluKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiRW1haWwgYWRkcmVzcydzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIFwiICsgKCFvcHRpb25zLmlyaSA/IFwiQVNDSUlcIiA6IFwiVW5pY29kZVwiKSArIFwiIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b1t4XSA9IGxvY2FsUGFydCArIFwiQFwiICsgZG9tYWluO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcG9uZW50cy5wYXRoID0gdG8uam9pbihcIixcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWRlcnMgPSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgPSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgfHwge307XG4gICAgICAgIGlmIChtYWlsdG9Db21wb25lbnRzLnN1YmplY3QpIGhlYWRlcnNbXCJzdWJqZWN0XCJdID0gbWFpbHRvQ29tcG9uZW50cy5zdWJqZWN0O1xuICAgICAgICBpZiAobWFpbHRvQ29tcG9uZW50cy5ib2R5KSBoZWFkZXJzW1wiYm9keVwiXSA9IG1haWx0b0NvbXBvbmVudHMuYm9keTtcbiAgICAgICAgdmFyIGZpZWxkcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIGlmIChoZWFkZXJzW25hbWVdICE9PSBPW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2gobmFtZS5yZXBsYWNlKFBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfSEZOQU1FLCBwY3RFbmNDaGFyKSArIFwiPVwiICsgaGVhZGVyc1tuYW1lXS5yZXBsYWNlKFBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfSEZWQUxVRSwgcGN0RW5jQ2hhcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnF1ZXJ5ID0gZmllbGRzLmpvaW4oXCImXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbn07XG5cbnZhciBVUk5fUEFSU0UgPSAvXihbXlxcOl0rKVxcOiguKikvO1xuLy9SRkMgMjE0MVxudmFyIGhhbmRsZXIkNSA9IHtcbiAgICBzY2hlbWU6IFwidXJuXCIsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlJCQxKGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5wYXRoLm1hdGNoKFVSTl9QQVJTRSk7XG4gICAgICAgIHZhciB1cm5Db21wb25lbnRzID0gY29tcG9uZW50cztcbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgIHZhciBzY2hlbWUgPSBvcHRpb25zLnNjaGVtZSB8fCB1cm5Db21wb25lbnRzLnNjaGVtZSB8fCBcInVyblwiO1xuICAgICAgICAgICAgdmFyIG5pZCA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBuc3MgPSBtYXRjaGVzWzJdO1xuICAgICAgICAgICAgdmFyIHVyblNjaGVtZSA9IHNjaGVtZSArIFwiOlwiICsgKG9wdGlvbnMubmlkIHx8IG5pZCk7XG4gICAgICAgICAgICB2YXIgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbdXJuU2NoZW1lXTtcbiAgICAgICAgICAgIHVybkNvbXBvbmVudHMubmlkID0gbmlkO1xuICAgICAgICAgICAgdXJuQ29tcG9uZW50cy5uc3MgPSBuc3M7XG4gICAgICAgICAgICB1cm5Db21wb25lbnRzLnBhdGggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoc2NoZW1lSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHVybkNvbXBvbmVudHMgPSBzY2hlbWVIYW5kbGVyLnBhcnNlKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXJuQ29tcG9uZW50cy5lcnJvciA9IHVybkNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUk4gY2FuIG5vdCBiZSBwYXJzZWQuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybkNvbXBvbmVudHM7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSQkMSh1cm5Db21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBzY2hlbWUgPSBvcHRpb25zLnNjaGVtZSB8fCB1cm5Db21wb25lbnRzLnNjaGVtZSB8fCBcInVyblwiO1xuICAgICAgICB2YXIgbmlkID0gdXJuQ29tcG9uZW50cy5uaWQ7XG4gICAgICAgIHZhciB1cm5TY2hlbWUgPSBzY2hlbWUgKyBcIjpcIiArIChvcHRpb25zLm5pZCB8fCBuaWQpO1xuICAgICAgICB2YXIgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbdXJuU2NoZW1lXTtcbiAgICAgICAgaWYgKHNjaGVtZUhhbmRsZXIpIHtcbiAgICAgICAgICAgIHVybkNvbXBvbmVudHMgPSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZSh1cm5Db21wb25lbnRzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXJpQ29tcG9uZW50cyA9IHVybkNvbXBvbmVudHM7XG4gICAgICAgIHZhciBuc3MgPSB1cm5Db21wb25lbnRzLm5zcztcbiAgICAgICAgdXJpQ29tcG9uZW50cy5wYXRoID0gKG5pZCB8fCBvcHRpb25zLm5pZCkgKyBcIjpcIiArIG5zcztcbiAgICAgICAgcmV0dXJuIHVyaUNvbXBvbmVudHM7XG4gICAgfVxufTtcblxudmFyIFVVSUQgPSAvXlswLTlBLUZhLWZdezh9KD86XFwtWzAtOUEtRmEtZl17NH0pezN9XFwtWzAtOUEtRmEtZl17MTJ9JC87XG4vL1JGQyA0MTIyXG52YXIgaGFuZGxlciQ2ID0ge1xuICAgIHNjaGVtZTogXCJ1cm46dXVpZFwiLFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSh1cm5Db21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB1dWlkQ29tcG9uZW50cyA9IHVybkNvbXBvbmVudHM7XG4gICAgICAgIHV1aWRDb21wb25lbnRzLnV1aWQgPSB1dWlkQ29tcG9uZW50cy5uc3M7XG4gICAgICAgIHV1aWRDb21wb25lbnRzLm5zcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFvcHRpb25zLnRvbGVyYW50ICYmICghdXVpZENvbXBvbmVudHMudXVpZCB8fCAhdXVpZENvbXBvbmVudHMudXVpZC5tYXRjaChVVUlEKSkpIHtcbiAgICAgICAgICAgIHV1aWRDb21wb25lbnRzLmVycm9yID0gdXVpZENvbXBvbmVudHMuZXJyb3IgfHwgXCJVVUlEIGlzIG5vdCB2YWxpZC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXVpZENvbXBvbmVudHM7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSh1dWlkQ29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgdXJuQ29tcG9uZW50cyA9IHV1aWRDb21wb25lbnRzO1xuICAgICAgICAvL25vcm1hbGl6ZSBVVUlEXG4gICAgICAgIHVybkNvbXBvbmVudHMubnNzID0gKHV1aWRDb21wb25lbnRzLnV1aWQgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIHVybkNvbXBvbmVudHM7XG4gICAgfVxufTtcblxuU0NIRU1FU1toYW5kbGVyLnNjaGVtZV0gPSBoYW5kbGVyO1xuU0NIRU1FU1toYW5kbGVyJDEuc2NoZW1lXSA9IGhhbmRsZXIkMTtcblNDSEVNRVNbaGFuZGxlciQyLnNjaGVtZV0gPSBoYW5kbGVyJDI7XG5TQ0hFTUVTW2hhbmRsZXIkMy5zY2hlbWVdID0gaGFuZGxlciQzO1xuU0NIRU1FU1toYW5kbGVyJDQuc2NoZW1lXSA9IGhhbmRsZXIkNDtcblNDSEVNRVNbaGFuZGxlciQ1LnNjaGVtZV0gPSBoYW5kbGVyJDU7XG5TQ0hFTUVTW2hhbmRsZXIkNi5zY2hlbWVdID0gaGFuZGxlciQ2O1xuXG5leHBvcnRzLlNDSEVNRVMgPSBTQ0hFTUVTO1xuZXhwb3J0cy5wY3RFbmNDaGFyID0gcGN0RW5jQ2hhcjtcbmV4cG9ydHMucGN0RGVjQ2hhcnMgPSBwY3REZWNDaGFycztcbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmV4cG9ydHMucmVtb3ZlRG90U2VnbWVudHMgPSByZW1vdmVEb3RTZWdtZW50cztcbmV4cG9ydHMuc2VyaWFsaXplID0gc2VyaWFsaXplO1xuZXhwb3J0cy5yZXNvbHZlQ29tcG9uZW50cyA9IHJlc29sdmVDb21wb25lbnRzO1xuZXhwb3J0cy5yZXNvbHZlID0gcmVzb2x2ZTtcbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuZXhwb3J0cy5lcXVhbCA9IGVxdWFsO1xuZXhwb3J0cy5lc2NhcGVDb21wb25lbnQgPSBlc2NhcGVDb21wb25lbnQ7XG5leHBvcnRzLnVuZXNjYXBlQ29tcG9uZW50ID0gdW5lc2NhcGVDb21wb25lbnQ7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmkuYWxsLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFNjaGVtYVJlZnMgPSBleHBvcnRzLnJlc29sdmVVcmwgPSBleHBvcnRzLm5vcm1hbGl6ZUlkID0gZXhwb3J0cy5fZ2V0RnVsbFBhdGggPSBleHBvcnRzLmdldEZ1bGxQYXRoID0gZXhwb3J0cy5pbmxpbmVSZWYgPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgZXF1YWwgPSByZXF1aXJlKFwiZmFzdC1kZWVwLWVxdWFsXCIpO1xuY29uc3QgdHJhdmVyc2UgPSByZXF1aXJlKFwianNvbi1zY2hlbWEtdHJhdmVyc2VcIik7XG5jb25zdCBVUkkgPSByZXF1aXJlKFwidXJpLWpzXCIpO1xuLy8gVE9ETyByZWZhY3RvciB0byB1c2Uga2V5d29yZCBkZWZpbml0aW9uc1xuY29uc3QgU0lNUExFX0lOTElORUQgPSBuZXcgU2V0KFtcbiAgICBcInR5cGVcIixcbiAgICBcImZvcm1hdFwiLFxuICAgIFwicGF0dGVyblwiLFxuICAgIFwibWF4TGVuZ3RoXCIsXG4gICAgXCJtaW5MZW5ndGhcIixcbiAgICBcIm1heFByb3BlcnRpZXNcIixcbiAgICBcIm1pblByb3BlcnRpZXNcIixcbiAgICBcIm1heEl0ZW1zXCIsXG4gICAgXCJtaW5JdGVtc1wiLFxuICAgIFwibWF4aW11bVwiLFxuICAgIFwibWluaW11bVwiLFxuICAgIFwidW5pcXVlSXRlbXNcIixcbiAgICBcIm11bHRpcGxlT2ZcIixcbiAgICBcInJlcXVpcmVkXCIsXG4gICAgXCJlbnVtXCIsXG4gICAgXCJjb25zdFwiLFxuXSk7XG5mdW5jdGlvbiBpbmxpbmVSZWYoc2NoZW1hLCBsaW1pdCA9IHRydWUpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGxpbWl0ID09PSB0cnVlKVxuICAgICAgICByZXR1cm4gIWhhc1JlZihzY2hlbWEpO1xuICAgIGlmICghbGltaXQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gY291bnRLZXlzKHNjaGVtYSkgPD0gbGltaXQ7XG59XG5leHBvcnRzLmlubGluZVJlZiA9IGlubGluZVJlZjtcbmNvbnN0IFJFRl9LRVlXT1JEUyA9IG5ldyBTZXQoW1xuICAgIFwiJHJlZlwiLFxuICAgIFwiJHJlY3Vyc2l2ZVJlZlwiLFxuICAgIFwiJHJlY3Vyc2l2ZUFuY2hvclwiLFxuICAgIFwiJGR5bmFtaWNSZWZcIixcbiAgICBcIiRkeW5hbWljQW5jaG9yXCIsXG5dKTtcbmZ1bmN0aW9uIGhhc1JlZihzY2hlbWEpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKFJFRl9LRVlXT1JEUy5oYXMoa2V5KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFba2V5XTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoKSAmJiBzY2guc29tZShoYXNSZWYpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwib2JqZWN0XCIgJiYgaGFzUmVmKHNjaCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY291bnRLZXlzKHNjaGVtYSkge1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGlmIChrZXkgPT09IFwiJHJlZlwiKVxuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICBjb3VudCsrO1xuICAgICAgICBpZiAoU0lNUExFX0lOTElORUQuaGFzKGtleSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWFba2V5XSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB1dGlsXzEuZWFjaEl0ZW0oc2NoZW1hW2tleV0sIChzY2gpID0+IChjb3VudCArPSBjb3VudEtleXMoc2NoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA9PT0gSW5maW5pdHkpXG4gICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIHJldHVybiBjb3VudDtcbn1cbmZ1bmN0aW9uIGdldEZ1bGxQYXRoKGlkID0gXCJcIiwgbm9ybWFsaXplKSB7XG4gICAgaWYgKG5vcm1hbGl6ZSAhPT0gZmFsc2UpXG4gICAgICAgIGlkID0gbm9ybWFsaXplSWQoaWQpO1xuICAgIGNvbnN0IHAgPSBVUkkucGFyc2UoaWQpO1xuICAgIHJldHVybiBfZ2V0RnVsbFBhdGgocCk7XG59XG5leHBvcnRzLmdldEZ1bGxQYXRoID0gZ2V0RnVsbFBhdGg7XG5mdW5jdGlvbiBfZ2V0RnVsbFBhdGgocCkge1xuICAgIHJldHVybiBVUkkuc2VyaWFsaXplKHApLnNwbGl0KFwiI1wiKVswXSArIFwiI1wiO1xufVxuZXhwb3J0cy5fZ2V0RnVsbFBhdGggPSBfZ2V0RnVsbFBhdGg7XG5jb25zdCBUUkFJTElOR19TTEFTSF9IQVNIID0gLyNcXC8/JC87XG5mdW5jdGlvbiBub3JtYWxpemVJZChpZCkge1xuICAgIHJldHVybiBpZCA/IGlkLnJlcGxhY2UoVFJBSUxJTkdfU0xBU0hfSEFTSCwgXCJcIikgOiBcIlwiO1xufVxuZXhwb3J0cy5ub3JtYWxpemVJZCA9IG5vcm1hbGl6ZUlkO1xuZnVuY3Rpb24gcmVzb2x2ZVVybChiYXNlSWQsIGlkKSB7XG4gICAgaWQgPSBub3JtYWxpemVJZChpZCk7XG4gICAgcmV0dXJuIFVSSS5yZXNvbHZlKGJhc2VJZCwgaWQpO1xufVxuZXhwb3J0cy5yZXNvbHZlVXJsID0gcmVzb2x2ZVVybDtcbmNvbnN0IEFOQ0hPUiA9IC9eW2Etel9dWy1hLXowLTkuX10qJC9pO1xuZnVuY3Rpb24gZ2V0U2NoZW1hUmVmcyhzY2hlbWEpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICBjb25zdCBzY2hJZCA9IG5vcm1hbGl6ZUlkKHNjaGVtYVtzY2hlbWFJZF0pO1xuICAgIGNvbnN0IGJhc2VJZHMgPSB7IFwiXCI6IHNjaElkIH07XG4gICAgY29uc3QgcGF0aFByZWZpeCA9IGdldEZ1bGxQYXRoKHNjaElkLCBmYWxzZSk7XG4gICAgY29uc3QgbG9jYWxSZWZzID0ge307XG4gICAgY29uc3Qgc2NoZW1hUmVmcyA9IG5ldyBTZXQoKTtcbiAgICB0cmF2ZXJzZShzY2hlbWEsIHsgYWxsS2V5czogdHJ1ZSB9LCAoc2NoLCBqc29uUHRyLCBfLCBwYXJlbnRKc29uUHRyKSA9PiB7XG4gICAgICAgIGlmIChwYXJlbnRKc29uUHRyID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aFByZWZpeCArIGpzb25QdHI7XG4gICAgICAgIGxldCBiYXNlSWQgPSBiYXNlSWRzW3BhcmVudEpzb25QdHJdO1xuICAgICAgICBpZiAodHlwZW9mIHNjaFtzY2hlbWFJZF0gPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGJhc2VJZCA9IGFkZFJlZi5jYWxsKHRoaXMsIHNjaFtzY2hlbWFJZF0pO1xuICAgICAgICBhZGRBbmNob3IuY2FsbCh0aGlzLCBzY2guJGFuY2hvcik7XG4gICAgICAgIGFkZEFuY2hvci5jYWxsKHRoaXMsIHNjaC4kZHluYW1pY0FuY2hvcik7XG4gICAgICAgIGJhc2VJZHNbanNvblB0cl0gPSBiYXNlSWQ7XG4gICAgICAgIGZ1bmN0aW9uIGFkZFJlZihyZWYpIHtcbiAgICAgICAgICAgIHJlZiA9IG5vcm1hbGl6ZUlkKGJhc2VJZCA/IFVSSS5yZXNvbHZlKGJhc2VJZCwgcmVmKSA6IHJlZik7XG4gICAgICAgICAgICBpZiAoc2NoZW1hUmVmcy5oYXMocmVmKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBhbWJpZ3VvcyhyZWYpO1xuICAgICAgICAgICAgc2NoZW1hUmVmcy5hZGQocmVmKTtcbiAgICAgICAgICAgIGxldCBzY2hPclJlZiA9IHRoaXMucmVmc1tyZWZdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hPclJlZiA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHNjaE9yUmVmID0gdGhpcy5yZWZzW3NjaE9yUmVmXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGNoZWNrQW1iaWd1b3NSZWYoc2NoLCBzY2hPclJlZi5zY2hlbWEsIHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZWYgIT09IG5vcm1hbGl6ZUlkKGZ1bGxQYXRoKSkge1xuICAgICAgICAgICAgICAgIGlmIChyZWZbMF0gPT09IFwiI1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrQW1iaWd1b3NSZWYoc2NoLCBsb2NhbFJlZnNbcmVmXSwgcmVmKTtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxSZWZzW3JlZl0gPSBzY2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnNbcmVmXSA9IGZ1bGxQYXRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWY7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkQW5jaG9yKGFuY2hvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhbmNob3IgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGlmICghQU5DSE9SLnRlc3QoYW5jaG9yKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGFuY2hvciBcIiR7YW5jaG9yfVwiYCk7XG4gICAgICAgICAgICAgICAgYWRkUmVmLmNhbGwodGhpcywgYCMke2FuY2hvcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBsb2NhbFJlZnM7XG4gICAgZnVuY3Rpb24gY2hlY2tBbWJpZ3Vvc1JlZihzY2gxLCBzY2gyLCByZWYpIHtcbiAgICAgICAgaWYgKHNjaDIgIT09IHVuZGVmaW5lZCAmJiAhZXF1YWwoc2NoMSwgc2NoMikpXG4gICAgICAgICAgICB0aHJvdyBhbWJpZ3VvcyhyZWYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhbWJpZ3VvcyhyZWYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgcmVmZXJlbmNlIFwiJHtyZWZ9XCIgcmVzb2x2ZXMgdG8gbW9yZSB0aGFuIG9uZSBzY2hlbWFgKTtcbiAgICB9XG59XG5leHBvcnRzLmdldFNjaGVtYVJlZnMgPSBnZXRTY2hlbWFSZWZzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0RGF0YSA9IGV4cG9ydHMuS2V5d29yZEN4dCA9IGV4cG9ydHMudmFsaWRhdGVGdW5jdGlvbkNvZGUgPSB2b2lkIDA7XG5jb25zdCBib29sU2NoZW1hXzEgPSByZXF1aXJlKFwiLi9ib29sU2NoZW1hXCIpO1xuY29uc3QgZGF0YVR5cGVfMSA9IHJlcXVpcmUoXCIuL2RhdGFUeXBlXCIpO1xuY29uc3QgYXBwbGljYWJpbGl0eV8xID0gcmVxdWlyZShcIi4vYXBwbGljYWJpbGl0eVwiKTtcbmNvbnN0IGRhdGFUeXBlXzIgPSByZXF1aXJlKFwiLi9kYXRhVHlwZVwiKTtcbmNvbnN0IGRlZmF1bHRzXzEgPSByZXF1aXJlKFwiLi9kZWZhdWx0c1wiKTtcbmNvbnN0IGtleXdvcmRfMSA9IHJlcXVpcmUoXCIuL2tleXdvcmRcIik7XG5jb25zdCBzdWJzY2hlbWFfMSA9IHJlcXVpcmUoXCIuL3N1YnNjaGVtYVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi9uYW1lc1wiKTtcbmNvbnN0IHJlc29sdmVfMSA9IHJlcXVpcmUoXCIuLi9yZXNvbHZlXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG4vLyBzY2hlbWEgY29tcGlsYXRpb24gLSBnZW5lcmF0ZXMgdmFsaWRhdGlvbiBmdW5jdGlvbiwgc3Vic2NoZW1hQ29kZSAoYmVsb3cpIGlzIHVzZWQgZm9yIHN1YnNjaGVtYXNcbmZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25Db2RlKGl0KSB7XG4gICAgaWYgKGlzU2NoZW1hT2JqKGl0KSkge1xuICAgICAgICBjaGVja0tleXdvcmRzKGl0KTtcbiAgICAgICAgaWYgKHNjaGVtYUN4dEhhc1J1bGVzKGl0KSkge1xuICAgICAgICAgICAgdG9wU2NoZW1hT2JqQ29kZShpdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFsaWRhdGVGdW5jdGlvbihpdCwgKCkgPT4gYm9vbFNjaGVtYV8xLnRvcEJvb2xPckVtcHR5U2NoZW1hKGl0KSk7XG59XG5leHBvcnRzLnZhbGlkYXRlRnVuY3Rpb25Db2RlID0gdmFsaWRhdGVGdW5jdGlvbkNvZGU7XG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uKHsgZ2VuLCB2YWxpZGF0ZU5hbWUsIHNjaGVtYSwgc2NoZW1hRW52LCBvcHRzIH0sIGJvZHkpIHtcbiAgICBpZiAob3B0cy5jb2RlLmVzNSkge1xuICAgICAgICBnZW4uZnVuYyh2YWxpZGF0ZU5hbWUsIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC5kYXRhfSwgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fWAsIHNjaGVtYUVudi4kYXN5bmMsICgpID0+IHtcbiAgICAgICAgICAgIGdlbi5jb2RlKGNvZGVnZW5fMS5fIGBcInVzZSBzdHJpY3RcIjsgJHtmdW5jU291cmNlVXJsKHNjaGVtYSwgb3B0cyl9YCk7XG4gICAgICAgICAgICBkZXN0cnVjdHVyZVZhbEN4dEVTNShnZW4sIG9wdHMpO1xuICAgICAgICAgICAgZ2VuLmNvZGUoYm9keSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2VuLmZ1bmModmFsaWRhdGVOYW1lLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQuZGF0YX0sICR7ZGVzdHJ1Y3R1cmVWYWxDeHQob3B0cyl9YCwgc2NoZW1hRW52LiRhc3luYywgKCkgPT4gZ2VuLmNvZGUoZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpKS5jb2RlKGJvZHkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXN0cnVjdHVyZVZhbEN4dChvcHRzKSB7XG4gICAgcmV0dXJuIGNvZGVnZW5fMS5fIGB7JHtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRofT1cIlwiLCAke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhfSwgJHtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5fSwgJHtuYW1lc18xLmRlZmF1bHQucm9vdERhdGF9PSR7bmFtZXNfMS5kZWZhdWx0LmRhdGF9JHtvcHRzLmR5bmFtaWNSZWYgPyBjb2RlZ2VuXzEuXyBgLCAke25hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9yc309e31gIDogY29kZWdlbl8xLm5pbH19PXt9YDtcbn1cbmZ1bmN0aW9uIGRlc3RydWN0dXJlVmFsQ3h0RVM1KGdlbiwgb3B0cykge1xuICAgIGdlbi5pZihuYW1lc18xLmRlZmF1bHQudmFsQ3h0LCAoKSA9PiB7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRofWApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fS4ke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhfWApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHksIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eX1gKTtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQucm9vdERhdGEsIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhfWApO1xuICAgICAgICBpZiAob3B0cy5keW5hbWljUmVmKVxuICAgICAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnMsIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzfWApO1xuICAgIH0sICgpID0+IHtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBjb2RlZ2VuXzEuXyBgXCJcImApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhLCBjb2RlZ2VuXzEuXyBgdW5kZWZpbmVkYCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSwgY29kZWdlbl8xLl8gYHVuZGVmaW5lZGApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5yb290RGF0YSwgbmFtZXNfMS5kZWZhdWx0LmRhdGEpO1xuICAgICAgICBpZiAob3B0cy5keW5hbWljUmVmKVxuICAgICAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnMsIGNvZGVnZW5fMS5fIGB7fWApO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdG9wU2NoZW1hT2JqQ29kZShpdCkge1xuICAgIGNvbnN0IHsgc2NoZW1hLCBvcHRzLCBnZW4gfSA9IGl0O1xuICAgIHZhbGlkYXRlRnVuY3Rpb24oaXQsICgpID0+IHtcbiAgICAgICAgaWYgKG9wdHMuJGNvbW1lbnQgJiYgc2NoZW1hLiRjb21tZW50KVxuICAgICAgICAgICAgY29tbWVudEtleXdvcmQoaXQpO1xuICAgICAgICBjaGVja05vRGVmYXVsdChpdCk7XG4gICAgICAgIGdlbi5sZXQobmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIG51bGwpO1xuICAgICAgICBnZW4ubGV0KG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsIDApO1xuICAgICAgICBpZiAob3B0cy51bmV2YWx1YXRlZClcbiAgICAgICAgICAgIHJlc2V0RXZhbHVhdGVkKGl0KTtcbiAgICAgICAgdHlwZUFuZEtleXdvcmRzKGl0KTtcbiAgICAgICAgcmV0dXJuUmVzdWx0cyhpdCk7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xufVxuZnVuY3Rpb24gcmVzZXRFdmFsdWF0ZWQoaXQpIHtcbiAgICAvLyBUT0RPIG1heWJlIHNvbWUgaG9vayB0byBleGVjdXRlIGl0IGluIHRoZSBlbmQgdG8gY2hlY2sgd2hldGhlciBwcm9wcy9pdGVtcyBhcmUgTmFtZSwgYXMgaW4gYXNzaWduRXZhbHVhdGVkXG4gICAgY29uc3QgeyBnZW4sIHZhbGlkYXRlTmFtZSB9ID0gaXQ7XG4gICAgaXQuZXZhbHVhdGVkID0gZ2VuLmNvbnN0KFwiZXZhbHVhdGVkXCIsIGNvZGVnZW5fMS5fIGAke3ZhbGlkYXRlTmFtZX0uZXZhbHVhdGVkYCk7XG4gICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2l0LmV2YWx1YXRlZH0uZHluYW1pY1Byb3BzYCwgKCkgPT4gZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHtpdC5ldmFsdWF0ZWR9LnByb3BzYCwgY29kZWdlbl8xLl8gYHVuZGVmaW5lZGApKTtcbiAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7aXQuZXZhbHVhdGVkfS5keW5hbWljSXRlbXNgLCAoKSA9PiBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke2l0LmV2YWx1YXRlZH0uaXRlbXNgLCBjb2RlZ2VuXzEuXyBgdW5kZWZpbmVkYCkpO1xufVxuZnVuY3Rpb24gZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpIHtcbiAgICBjb25zdCBzY2hJZCA9IHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBzY2hlbWFbb3B0cy5zY2hlbWFJZF07XG4gICAgcmV0dXJuIHNjaElkICYmIChvcHRzLmNvZGUuc291cmNlIHx8IG9wdHMuY29kZS5wcm9jZXNzKSA/IGNvZGVnZW5fMS5fIGAvKiMgc291cmNlVVJMPSR7c2NoSWR9ICovYCA6IGNvZGVnZW5fMS5uaWw7XG59XG4vLyBzY2hlbWEgY29tcGlsYXRpb24gLSB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgcmVjdXJzaXZlbHkgdG8gZ2VuZXJhdGUgY29kZSBmb3Igc3ViLXNjaGVtYXNcbmZ1bmN0aW9uIHN1YnNjaGVtYUNvZGUoaXQsIHZhbGlkKSB7XG4gICAgaWYgKGlzU2NoZW1hT2JqKGl0KSkge1xuICAgICAgICBjaGVja0tleXdvcmRzKGl0KTtcbiAgICAgICAgaWYgKHNjaGVtYUN4dEhhc1J1bGVzKGl0KSkge1xuICAgICAgICAgICAgc3ViU2NoZW1hT2JqQ29kZShpdCwgdmFsaWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJvb2xTY2hlbWFfMS5ib29sT3JFbXB0eVNjaGVtYShpdCwgdmFsaWQpO1xufVxuZnVuY3Rpb24gc2NoZW1hQ3h0SGFzUnVsZXMoeyBzY2hlbWEsIHNlbGYgfSkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4gIXNjaGVtYTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpXG4gICAgICAgIGlmIChzZWxmLlJVTEVTLmFsbFtrZXldKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNTY2hlbWFPYmooaXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGl0LnNjaGVtYSAhPSBcImJvb2xlYW5cIjtcbn1cbmZ1bmN0aW9uIHN1YlNjaGVtYU9iakNvZGUoaXQsIHZhbGlkKSB7XG4gICAgY29uc3QgeyBzY2hlbWEsIGdlbiwgb3B0cyB9ID0gaXQ7XG4gICAgaWYgKG9wdHMuJGNvbW1lbnQgJiYgc2NoZW1hLiRjb21tZW50KVxuICAgICAgICBjb21tZW50S2V5d29yZChpdCk7XG4gICAgdXBkYXRlQ29udGV4dChpdCk7XG4gICAgY2hlY2tBc3luY1NjaGVtYShpdCk7XG4gICAgY29uc3QgZXJyc0NvdW50ID0gZ2VuLmNvbnN0KFwiX2VycnNcIiwgbmFtZXNfMS5kZWZhdWx0LmVycm9ycyk7XG4gICAgdHlwZUFuZEtleXdvcmRzKGl0LCBlcnJzQ291bnQpO1xuICAgIC8vIFRPRE8gdmFyXG4gICAgZ2VuLnZhcih2YWxpZCwgY29kZWdlbl8xLl8gYCR7ZXJyc0NvdW50fSA9PT0gJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfWApO1xufVxuZnVuY3Rpb24gY2hlY2tLZXl3b3JkcyhpdCkge1xuICAgIHV0aWxfMS5jaGVja1Vua25vd25SdWxlcyhpdCk7XG4gICAgY2hlY2tSZWZzQW5kS2V5d29yZHMoaXQpO1xufVxuZnVuY3Rpb24gdHlwZUFuZEtleXdvcmRzKGl0LCBlcnJzQ291bnQpIHtcbiAgICBpZiAoaXQub3B0cy5qdGQpXG4gICAgICAgIHJldHVybiBzY2hlbWFLZXl3b3JkcyhpdCwgW10sIGZhbHNlLCBlcnJzQ291bnQpO1xuICAgIGNvbnN0IHR5cGVzID0gZGF0YVR5cGVfMS5nZXRTY2hlbWFUeXBlcyhpdC5zY2hlbWEpO1xuICAgIGNvbnN0IGNoZWNrZWRUeXBlcyA9IGRhdGFUeXBlXzEuY29lcmNlQW5kQ2hlY2tEYXRhVHlwZShpdCwgdHlwZXMpO1xuICAgIHNjaGVtYUtleXdvcmRzKGl0LCB0eXBlcywgIWNoZWNrZWRUeXBlcywgZXJyc0NvdW50KTtcbn1cbmZ1bmN0aW9uIGNoZWNrUmVmc0FuZEtleXdvcmRzKGl0KSB7XG4gICAgY29uc3QgeyBzY2hlbWEsIGVyclNjaGVtYVBhdGgsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgIGlmIChzY2hlbWEuJHJlZiAmJiBvcHRzLmlnbm9yZUtleXdvcmRzV2l0aFJlZiAmJiB1dGlsXzEuc2NoZW1hSGFzUnVsZXNCdXRSZWYoc2NoZW1hLCBzZWxmLlJVTEVTKSkge1xuICAgICAgICBzZWxmLmxvZ2dlci53YXJuKGAkcmVmOiBrZXl3b3JkcyBpZ25vcmVkIGluIHNjaGVtYSBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tOb0RlZmF1bHQoaXQpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgb3B0cyB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYS5kZWZhdWx0ICE9PSB1bmRlZmluZWQgJiYgb3B0cy51c2VEZWZhdWx0cyAmJiBvcHRzLnN0cmljdFNjaGVtYSkge1xuICAgICAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCBcImRlZmF1bHQgaXMgaWdub3JlZCBpbiB0aGUgc2NoZW1hIHJvb3RcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlQ29udGV4dChpdCkge1xuICAgIGNvbnN0IHNjaElkID0gaXQuc2NoZW1hW2l0Lm9wdHMuc2NoZW1hSWRdO1xuICAgIGlmIChzY2hJZClcbiAgICAgICAgaXQuYmFzZUlkID0gcmVzb2x2ZV8xLnJlc29sdmVVcmwoaXQuYmFzZUlkLCBzY2hJZCk7XG59XG5mdW5jdGlvbiBjaGVja0FzeW5jU2NoZW1hKGl0KSB7XG4gICAgaWYgKGl0LnNjaGVtYS4kYXN5bmMgJiYgIWl0LnNjaGVtYUVudi4kYXN5bmMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIHNjaGVtYSBpbiBzeW5jIHNjaGVtYVwiKTtcbn1cbmZ1bmN0aW9uIGNvbW1lbnRLZXl3b3JkKHsgZ2VuLCBzY2hlbWFFbnYsIHNjaGVtYSwgZXJyU2NoZW1hUGF0aCwgb3B0cyB9KSB7XG4gICAgY29uc3QgbXNnID0gc2NoZW1hLiRjb21tZW50O1xuICAgIGlmIChvcHRzLiRjb21tZW50ID09PSB0cnVlKSB7XG4gICAgICAgIGdlbi5jb2RlKGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC5zZWxmfS5sb2dnZXIubG9nKCR7bXNnfSlgKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9wdHMuJGNvbW1lbnQgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYVBhdGggPSBjb2RlZ2VuXzEuc3RyIGAke2VyclNjaGVtYVBhdGh9LyRjb21tZW50YDtcbiAgICAgICAgY29uc3Qgcm9vdE5hbWUgPSBnZW4uc2NvcGVWYWx1ZShcInJvb3RcIiwgeyByZWY6IHNjaGVtYUVudi5yb290IH0pO1xuICAgICAgICBnZW4uY29kZShjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQuc2VsZn0ub3B0cy4kY29tbWVudCgke21zZ30sICR7c2NoZW1hUGF0aH0sICR7cm9vdE5hbWV9LnNjaGVtYSlgKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXR1cm5SZXN1bHRzKGl0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYUVudiwgdmFsaWRhdGVOYW1lLCBWYWxpZGF0aW9uRXJyb3IsIG9wdHMgfSA9IGl0O1xuICAgIGlmIChzY2hlbWFFbnYuJGFzeW5jKSB7XG4gICAgICAgIC8vIFRPRE8gYXNzaWduIHVuZXZhbHVhdGVkXG4gICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfSA9PT0gMGAsICgpID0+IGdlbi5yZXR1cm4obmFtZXNfMS5kZWZhdWx0LmRhdGEpLCAoKSA9PiBnZW4udGhyb3coY29kZWdlbl8xLl8gYG5ldyAke1ZhbGlkYXRpb25FcnJvcn0oJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30pYCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzKTtcbiAgICAgICAgaWYgKG9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICBhc3NpZ25FdmFsdWF0ZWQoaXQpO1xuICAgICAgICBnZW4ucmV0dXJuKGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9ID09PSAwYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzaWduRXZhbHVhdGVkKHsgZ2VuLCBldmFsdWF0ZWQsIHByb3BzLCBpdGVtcyB9KSB7XG4gICAgaWYgKHByb3BzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpXG4gICAgICAgIGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7ZXZhbHVhdGVkfS5wcm9wc2AsIHByb3BzKTtcbiAgICBpZiAoaXRlbXMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSlcbiAgICAgICAgZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHtldmFsdWF0ZWR9Lml0ZW1zYCwgaXRlbXMpO1xufVxuZnVuY3Rpb24gc2NoZW1hS2V5d29yZHMoaXQsIHR5cGVzLCB0eXBlRXJyb3JzLCBlcnJzQ291bnQpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBkYXRhLCBhbGxFcnJvcnMsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgIGNvbnN0IHsgUlVMRVMgfSA9IHNlbGY7XG4gICAgaWYgKHNjaGVtYS4kcmVmICYmIChvcHRzLmlnbm9yZUtleXdvcmRzV2l0aFJlZiB8fCAhdXRpbF8xLnNjaGVtYUhhc1J1bGVzQnV0UmVmKHNjaGVtYSwgUlVMRVMpKSkge1xuICAgICAgICBnZW4uYmxvY2soKCkgPT4ga2V5d29yZENvZGUoaXQsIFwiJHJlZlwiLCBSVUxFUy5hbGwuJHJlZi5kZWZpbml0aW9uKSk7IC8vIFRPRE8gdHlwZWNhc3RcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW9wdHMuanRkKVxuICAgICAgICBjaGVja1N0cmljdFR5cGVzKGl0LCB0eXBlcyk7XG4gICAgZ2VuLmJsb2NrKCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBncm91cCBvZiBSVUxFUy5ydWxlcylcbiAgICAgICAgICAgIGdyb3VwS2V5d29yZHMoZ3JvdXApO1xuICAgICAgICBncm91cEtleXdvcmRzKFJVTEVTLnBvc3QpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGdyb3VwS2V5d29yZHMoZ3JvdXApIHtcbiAgICAgICAgaWYgKCFhcHBsaWNhYmlsaXR5XzEuc2hvdWxkVXNlR3JvdXAoc2NoZW1hLCBncm91cCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChncm91cC50eXBlKSB7XG4gICAgICAgICAgICBnZW4uaWYoZGF0YVR5cGVfMi5jaGVja0RhdGFUeXBlKGdyb3VwLnR5cGUsIGRhdGEsIG9wdHMuc3RyaWN0TnVtYmVycykpO1xuICAgICAgICAgICAgaXRlcmF0ZUtleXdvcmRzKGl0LCBncm91cCk7XG4gICAgICAgICAgICBpZiAodHlwZXMubGVuZ3RoID09PSAxICYmIHR5cGVzWzBdID09PSBncm91cC50eXBlICYmIHR5cGVFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBnZW4uZWxzZSgpO1xuICAgICAgICAgICAgICAgIGRhdGFUeXBlXzIucmVwb3J0VHlwZUVycm9yKGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbi5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0ZUtleXdvcmRzKGl0LCBncm91cCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyBtYWtlIGl0IFwib2tcIiBjYWxsP1xuICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfSA9PT0gJHtlcnJzQ291bnQgfHwgMH1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpdGVyYXRlS2V5d29yZHMoaXQsIGdyb3VwKSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgb3B0czogeyB1c2VEZWZhdWx0cyB9LCB9ID0gaXQ7XG4gICAgaWYgKHVzZURlZmF1bHRzKVxuICAgICAgICBkZWZhdWx0c18xLmFzc2lnbkRlZmF1bHRzKGl0LCBncm91cC50eXBlKTtcbiAgICBnZW4uYmxvY2soKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgZ3JvdXAucnVsZXMpIHtcbiAgICAgICAgICAgIGlmIChhcHBsaWNhYmlsaXR5XzEuc2hvdWxkVXNlUnVsZShzY2hlbWEsIHJ1bGUpKSB7XG4gICAgICAgICAgICAgICAga2V5d29yZENvZGUoaXQsIHJ1bGUua2V5d29yZCwgcnVsZS5kZWZpbml0aW9uLCBncm91cC50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gY2hlY2tTdHJpY3RUeXBlcyhpdCwgdHlwZXMpIHtcbiAgICBpZiAoaXQuc2NoZW1hRW52Lm1ldGEgfHwgIWl0Lm9wdHMuc3RyaWN0VHlwZXMpXG4gICAgICAgIHJldHVybjtcbiAgICBjaGVja0NvbnRleHRUeXBlcyhpdCwgdHlwZXMpO1xuICAgIGlmICghaXQub3B0cy5hbGxvd1VuaW9uVHlwZXMpXG4gICAgICAgIGNoZWNrTXVsdGlwbGVUeXBlcyhpdCwgdHlwZXMpO1xuICAgIGNoZWNrS2V5d29yZFR5cGVzKGl0LCBpdC5kYXRhVHlwZXMpO1xufVxuZnVuY3Rpb24gY2hlY2tDb250ZXh0VHlwZXMoaXQsIHR5cGVzKSB7XG4gICAgaWYgKCF0eXBlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIWl0LmRhdGFUeXBlcy5sZW5ndGgpIHtcbiAgICAgICAgaXQuZGF0YVR5cGVzID0gdHlwZXM7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHlwZXMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgICBpZiAoIWluY2x1ZGVzVHlwZShpdC5kYXRhVHlwZXMsIHQpKSB7XG4gICAgICAgICAgICBzdHJpY3RUeXBlc0Vycm9yKGl0LCBgdHlwZSBcIiR7dH1cIiBub3QgYWxsb3dlZCBieSBjb250ZXh0IFwiJHtpdC5kYXRhVHlwZXMuam9pbihcIixcIil9XCJgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGl0LmRhdGFUeXBlcyA9IGl0LmRhdGFUeXBlcy5maWx0ZXIoKHQpID0+IGluY2x1ZGVzVHlwZSh0eXBlcywgdCkpO1xufVxuZnVuY3Rpb24gY2hlY2tNdWx0aXBsZVR5cGVzKGl0LCB0cykge1xuICAgIGlmICh0cy5sZW5ndGggPiAxICYmICEodHMubGVuZ3RoID09PSAyICYmIHRzLmluY2x1ZGVzKFwibnVsbFwiKSkpIHtcbiAgICAgICAgc3RyaWN0VHlwZXNFcnJvcihpdCwgXCJ1c2UgYWxsb3dVbmlvblR5cGVzIHRvIGFsbG93IHVuaW9uIHR5cGUga2V5d29yZFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja0tleXdvcmRUeXBlcyhpdCwgdHMpIHtcbiAgICBjb25zdCBydWxlcyA9IGl0LnNlbGYuUlVMRVMuYWxsO1xuICAgIGZvciAoY29uc3Qga2V5d29yZCBpbiBydWxlcykge1xuICAgICAgICBjb25zdCBydWxlID0gcnVsZXNba2V5d29yZF07XG4gICAgICAgIGlmICh0eXBlb2YgcnVsZSA9PSBcIm9iamVjdFwiICYmIGFwcGxpY2FiaWxpdHlfMS5zaG91bGRVc2VSdWxlKGl0LnNjaGVtYSwgcnVsZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gcnVsZS5kZWZpbml0aW9uO1xuICAgICAgICAgICAgaWYgKHR5cGUubGVuZ3RoICYmICF0eXBlLnNvbWUoKHQpID0+IGhhc0FwcGxpY2FibGVUeXBlKHRzLCB0KSkpIHtcbiAgICAgICAgICAgICAgICBzdHJpY3RUeXBlc0Vycm9yKGl0LCBgbWlzc2luZyB0eXBlIFwiJHt0eXBlLmpvaW4oXCIsXCIpfVwiIGZvciBrZXl3b3JkIFwiJHtrZXl3b3JkfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBoYXNBcHBsaWNhYmxlVHlwZShzY2hUcywga3dkVCkge1xuICAgIHJldHVybiBzY2hUcy5pbmNsdWRlcyhrd2RUKSB8fCAoa3dkVCA9PT0gXCJudW1iZXJcIiAmJiBzY2hUcy5pbmNsdWRlcyhcImludGVnZXJcIikpO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNUeXBlKHRzLCB0KSB7XG4gICAgcmV0dXJuIHRzLmluY2x1ZGVzKHQpIHx8ICh0ID09PSBcImludGVnZXJcIiAmJiB0cy5pbmNsdWRlcyhcIm51bWJlclwiKSk7XG59XG5mdW5jdGlvbiBzdHJpY3RUeXBlc0Vycm9yKGl0LCBtc2cpIHtcbiAgICBjb25zdCBzY2hlbWFQYXRoID0gaXQuc2NoZW1hRW52LmJhc2VJZCArIGl0LmVyclNjaGVtYVBhdGg7XG4gICAgbXNnICs9IGAgYXQgXCIke3NjaGVtYVBhdGh9XCIgKHN0cmljdFR5cGVzKWA7XG4gICAgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZShpdCwgbXNnLCBpdC5vcHRzLnN0cmljdFR5cGVzKTtcbn1cbmNsYXNzIEtleXdvcmRDeHQge1xuICAgIGNvbnN0cnVjdG9yKGl0LCBkZWYsIGtleXdvcmQpIHtcbiAgICAgICAga2V5d29yZF8xLnZhbGlkYXRlS2V5d29yZFVzYWdlKGl0LCBkZWYsIGtleXdvcmQpO1xuICAgICAgICB0aGlzLmdlbiA9IGl0LmdlbjtcbiAgICAgICAgdGhpcy5hbGxFcnJvcnMgPSBpdC5hbGxFcnJvcnM7XG4gICAgICAgIHRoaXMua2V5d29yZCA9IGtleXdvcmQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IGl0LmRhdGE7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gaXQuc2NoZW1hW2tleXdvcmRdO1xuICAgICAgICB0aGlzLiRkYXRhID0gZGVmLiRkYXRhICYmIGl0Lm9wdHMuJGRhdGEgJiYgdGhpcy5zY2hlbWEgJiYgdGhpcy5zY2hlbWEuJGRhdGE7XG4gICAgICAgIHRoaXMuc2NoZW1hVmFsdWUgPSB1dGlsXzEuc2NoZW1hUmVmT3JWYWwoaXQsIHRoaXMuc2NoZW1hLCBrZXl3b3JkLCB0aGlzLiRkYXRhKTtcbiAgICAgICAgdGhpcy5zY2hlbWFUeXBlID0gZGVmLnNjaGVtYVR5cGU7XG4gICAgICAgIHRoaXMucGFyZW50U2NoZW1hID0gaXQuc2NoZW1hO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHt9O1xuICAgICAgICB0aGlzLml0ID0gaXQ7XG4gICAgICAgIHRoaXMuZGVmID0gZGVmO1xuICAgICAgICBpZiAodGhpcy4kZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5zY2hlbWFDb2RlID0gaXQuZ2VuLmNvbnN0KFwidlNjaGVtYVwiLCBnZXREYXRhKHRoaXMuJGRhdGEsIGl0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVtYUNvZGUgPSB0aGlzLnNjaGVtYVZhbHVlO1xuICAgICAgICAgICAgaWYgKCFrZXl3b3JkXzEudmFsaWRTY2hlbWFUeXBlKHRoaXMuc2NoZW1hLCBkZWYuc2NoZW1hVHlwZSwgZGVmLmFsbG93VW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtrZXl3b3JkfSB2YWx1ZSBtdXN0IGJlICR7SlNPTi5zdHJpbmdpZnkoZGVmLnNjaGVtYVR5cGUpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChcImNvZGVcIiBpbiBkZWYgPyBkZWYudHJhY2tFcnJvcnMgOiBkZWYuZXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJzQ291bnQgPSBpdC5nZW4uY29uc3QoXCJfZXJyc1wiLCBuYW1lc18xLmRlZmF1bHQuZXJyb3JzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQoY29uZGl0aW9uLCBzdWNjZXNzQWN0aW9uLCBmYWlsQWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZmFpbFJlc3VsdChjb2RlZ2VuXzEubm90KGNvbmRpdGlvbiksIHN1Y2Nlc3NBY3Rpb24sIGZhaWxBY3Rpb24pO1xuICAgIH1cbiAgICBmYWlsUmVzdWx0KGNvbmRpdGlvbiwgc3VjY2Vzc0FjdGlvbiwgZmFpbEFjdGlvbikge1xuICAgICAgICB0aGlzLmdlbi5pZihjb25kaXRpb24pO1xuICAgICAgICBpZiAoZmFpbEFjdGlvbilcbiAgICAgICAgICAgIGZhaWxBY3Rpb24oKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgICBpZiAoc3VjY2Vzc0FjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5nZW4uZWxzZSgpO1xuICAgICAgICAgICAgc3VjY2Vzc0FjdGlvbigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5nZW4uZW5kSWYoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmdlbi5lbHNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFzcyhjb25kaXRpb24sIGZhaWxBY3Rpb24pIHtcbiAgICAgICAgdGhpcy5mYWlsUmVzdWx0KGNvZGVnZW5fMS5ub3QoY29uZGl0aW9uKSwgdW5kZWZpbmVkLCBmYWlsQWN0aW9uKTtcbiAgICB9XG4gICAgZmFpbChjb25kaXRpb24pIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuLmlmKGZhbHNlKTsgLy8gdGhpcyBicmFuY2ggd2lsbCBiZSByZW1vdmVkIGJ5IGdlbi5vcHRpbWl6ZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2VuLmlmKGNvbmRpdGlvbik7XG4gICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgaWYgKHRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgdGhpcy5nZW4uZW5kSWYoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5nZW4uZWxzZSgpO1xuICAgIH1cbiAgICBmYWlsJGRhdGEoY29uZGl0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy4kZGF0YSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWwoY29uZGl0aW9uKTtcbiAgICAgICAgY29uc3QgeyBzY2hlbWFDb2RlIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmZhaWwoY29kZWdlbl8xLl8gYCR7c2NoZW1hQ29kZX0gIT09IHVuZGVmaW5lZCAmJiAoJHtjb2RlZ2VuXzEub3IodGhpcy5pbnZhbGlkJGRhdGEoKSwgY29uZGl0aW9uKX0pYCk7XG4gICAgfVxuICAgIGVycm9yKGFwcGVuZCwgZXJyb3JQYXJhbXMsIGVycm9yUGF0aHMpIHtcbiAgICAgICAgaWYgKGVycm9yUGFyYW1zKSB7XG4gICAgICAgICAgICB0aGlzLnNldFBhcmFtcyhlcnJvclBhcmFtcyk7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihhcHBlbmQsIGVycm9yUGF0aHMpO1xuICAgICAgICAgICAgdGhpcy5zZXRQYXJhbXMoe30pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Vycm9yKGFwcGVuZCwgZXJyb3JQYXRocyk7XG4gICAgfVxuICAgIF9lcnJvcihhcHBlbmQsIGVycm9yUGF0aHMpIHtcbiAgICAgICAgO1xuICAgICAgICAoYXBwZW5kID8gZXJyb3JzXzEucmVwb3J0RXh0cmFFcnJvciA6IGVycm9yc18xLnJlcG9ydEVycm9yKSh0aGlzLCB0aGlzLmRlZi5lcnJvciwgZXJyb3JQYXRocyk7XG4gICAgfVxuICAgICRkYXRhRXJyb3IoKSB7XG4gICAgICAgIGVycm9yc18xLnJlcG9ydEVycm9yKHRoaXMsIHRoaXMuZGVmLiRkYXRhRXJyb3IgfHwgZXJyb3JzXzEua2V5d29yZCREYXRhRXJyb3IpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyc0NvdW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZCBcInRyYWNrRXJyb3JzXCIgdG8ga2V5d29yZCBkZWZpbml0aW9uJyk7XG4gICAgICAgIGVycm9yc18xLnJlc2V0RXJyb3JzQ291bnQodGhpcy5nZW4sIHRoaXMuZXJyc0NvdW50KTtcbiAgICB9XG4gICAgb2soY29uZCkge1xuICAgICAgICBpZiAoIXRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgdGhpcy5nZW4uaWYoY29uZCk7XG4gICAgfVxuICAgIHNldFBhcmFtcyhvYmosIGFzc2lnbikge1xuICAgICAgICBpZiAoYXNzaWduKVxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnBhcmFtcywgb2JqKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBvYmo7XG4gICAgfVxuICAgIGJsb2NrJGRhdGEodmFsaWQsIGNvZGVCbG9jaywgJGRhdGFWYWxpZCA9IGNvZGVnZW5fMS5uaWwpIHtcbiAgICAgICAgdGhpcy5nZW4uYmxvY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGVjayRkYXRhKHZhbGlkLCAkZGF0YVZhbGlkKTtcbiAgICAgICAgICAgIGNvZGVCbG9jaygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2hlY2skZGF0YSh2YWxpZCA9IGNvZGVnZW5fMS5uaWwsICRkYXRhVmFsaWQgPSBjb2RlZ2VuXzEubmlsKSB7XG4gICAgICAgIGlmICghdGhpcy4kZGF0YSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYUNvZGUsIHNjaGVtYVR5cGUsIGRlZiB9ID0gdGhpcztcbiAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5vcihjb2RlZ2VuXzEuXyBgJHtzY2hlbWFDb2RlfSA9PT0gdW5kZWZpbmVkYCwgJGRhdGFWYWxpZCkpO1xuICAgICAgICBpZiAodmFsaWQgIT09IGNvZGVnZW5fMS5uaWwpXG4gICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgaWYgKHNjaGVtYVR5cGUubGVuZ3RoIHx8IGRlZi52YWxpZGF0ZVNjaGVtYSkge1xuICAgICAgICAgICAgZ2VuLmVsc2VJZih0aGlzLmludmFsaWQkZGF0YSgpKTtcbiAgICAgICAgICAgIHRoaXMuJGRhdGFFcnJvcigpO1xuICAgICAgICAgICAgaWYgKHZhbGlkICE9PSBjb2RlZ2VuXzEubmlsKVxuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBnZW4uZWxzZSgpO1xuICAgIH1cbiAgICBpbnZhbGlkJGRhdGEoKSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWFDb2RlLCBzY2hlbWFUeXBlLCBkZWYsIGl0IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gY29kZWdlbl8xLm9yKHdyb25nJERhdGFUeXBlKCksIGludmFsaWQkRGF0YVNjaGVtYSgpKTtcbiAgICAgICAgZnVuY3Rpb24gd3JvbmckRGF0YVR5cGUoKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hVHlwZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoIShzY2hlbWFDb2RlIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3QgPSBBcnJheS5pc0FycmF5KHNjaGVtYVR5cGUpID8gc2NoZW1hVHlwZSA6IFtzY2hlbWFUeXBlXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLl8gYCR7ZGF0YVR5cGVfMi5jaGVja0RhdGFUeXBlcyhzdCwgc2NoZW1hQ29kZSwgaXQub3B0cy5zdHJpY3ROdW1iZXJzLCBkYXRhVHlwZV8yLkRhdGFUeXBlLldyb25nKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5uaWw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW52YWxpZCREYXRhU2NoZW1hKCkge1xuICAgICAgICAgICAgaWYgKGRlZi52YWxpZGF0ZVNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRlU2NoZW1hUmVmID0gZ2VuLnNjb3BlVmFsdWUoXCJ2YWxpZGF0ZSRkYXRhXCIsIHsgcmVmOiBkZWYudmFsaWRhdGVTY2hlbWEgfSk7IC8vIFRPRE8gdmFsdWUuY29kZSBmb3Igc3RhbmRhbG9uZVxuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgISR7dmFsaWRhdGVTY2hlbWFSZWZ9KCR7c2NoZW1hQ29kZX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEubmlsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN1YnNjaGVtYShhcHBsLCB2YWxpZCkge1xuICAgICAgICBjb25zdCBzdWJzY2hlbWEgPSBzdWJzY2hlbWFfMS5nZXRTdWJzY2hlbWEodGhpcy5pdCwgYXBwbCk7XG4gICAgICAgIHN1YnNjaGVtYV8xLmV4dGVuZFN1YnNjaGVtYURhdGEoc3Vic2NoZW1hLCB0aGlzLml0LCBhcHBsKTtcbiAgICAgICAgc3Vic2NoZW1hXzEuZXh0ZW5kU3Vic2NoZW1hTW9kZShzdWJzY2hlbWEsIGFwcGwpO1xuICAgICAgICBjb25zdCBuZXh0Q29udGV4dCA9IHsgLi4udGhpcy5pdCwgLi4uc3Vic2NoZW1hLCBpdGVtczogdW5kZWZpbmVkLCBwcm9wczogdW5kZWZpbmVkIH07XG4gICAgICAgIHN1YnNjaGVtYUNvZGUobmV4dENvbnRleHQsIHZhbGlkKTtcbiAgICAgICAgcmV0dXJuIG5leHRDb250ZXh0O1xuICAgIH1cbiAgICBtZXJnZUV2YWx1YXRlZChzY2hlbWFDeHQsIHRvTmFtZSkge1xuICAgICAgICBjb25zdCB7IGl0LCBnZW4gfSA9IHRoaXM7XG4gICAgICAgIGlmICghaXQub3B0cy51bmV2YWx1YXRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGl0LnByb3BzICE9PSB0cnVlICYmIHNjaGVtYUN4dC5wcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpdC5wcm9wcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5wcm9wcyhnZW4sIHNjaGVtYUN4dC5wcm9wcywgaXQucHJvcHMsIHRvTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0Lml0ZW1zICE9PSB0cnVlICYmIHNjaGVtYUN4dC5pdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpdC5pdGVtcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5pdGVtcyhnZW4sIHNjaGVtYUN4dC5pdGVtcywgaXQuaXRlbXMsIHRvTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hlbWFDeHQsIHZhbGlkKSB7XG4gICAgICAgIGNvbnN0IHsgaXQsIGdlbiB9ID0gdGhpcztcbiAgICAgICAgaWYgKGl0Lm9wdHMudW5ldmFsdWF0ZWQgJiYgKGl0LnByb3BzICE9PSB0cnVlIHx8IGl0Lml0ZW1zICE9PSB0cnVlKSkge1xuICAgICAgICAgICAgZ2VuLmlmKHZhbGlkLCAoKSA9PiB0aGlzLm1lcmdlRXZhbHVhdGVkKHNjaGVtYUN4dCwgY29kZWdlbl8xLk5hbWUpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5LZXl3b3JkQ3h0ID0gS2V5d29yZEN4dDtcbmZ1bmN0aW9uIGtleXdvcmRDb2RlKGl0LCBrZXl3b3JkLCBkZWYsIHJ1bGVUeXBlKSB7XG4gICAgY29uc3QgY3h0ID0gbmV3IEtleXdvcmRDeHQoaXQsIGRlZiwga2V5d29yZCk7XG4gICAgaWYgKFwiY29kZVwiIGluIGRlZikge1xuICAgICAgICBkZWYuY29kZShjeHQsIHJ1bGVUeXBlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3h0LiRkYXRhICYmIGRlZi52YWxpZGF0ZSkge1xuICAgICAgICBrZXl3b3JkXzEuZnVuY0tleXdvcmRDb2RlKGN4dCwgZGVmKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXCJtYWNyb1wiIGluIGRlZikge1xuICAgICAgICBrZXl3b3JkXzEubWFjcm9LZXl3b3JkQ29kZShjeHQsIGRlZik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlZi5jb21waWxlIHx8IGRlZi52YWxpZGF0ZSkge1xuICAgICAgICBrZXl3b3JkXzEuZnVuY0tleXdvcmRDb2RlKGN4dCwgZGVmKTtcbiAgICB9XG59XG5jb25zdCBKU09OX1BPSU5URVIgPSAvXlxcLyg/Oltefl18fjB8fjEpKiQvO1xuY29uc3QgUkVMQVRJVkVfSlNPTl9QT0lOVEVSID0gL14oWzAtOV0rKSgjfFxcLyg/Oltefl18fjB8fjEpKik/JC87XG5mdW5jdGlvbiBnZXREYXRhKCRkYXRhLCB7IGRhdGFMZXZlbCwgZGF0YU5hbWVzLCBkYXRhUGF0aEFyciB9KSB7XG4gICAgbGV0IGpzb25Qb2ludGVyO1xuICAgIGxldCBkYXRhO1xuICAgIGlmICgkZGF0YSA9PT0gXCJcIilcbiAgICAgICAgcmV0dXJuIG5hbWVzXzEuZGVmYXVsdC5yb290RGF0YTtcbiAgICBpZiAoJGRhdGFbMF0gPT09IFwiL1wiKSB7XG4gICAgICAgIGlmICghSlNPTl9QT0lOVEVSLnRlc3QoJGRhdGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEpTT04tcG9pbnRlcjogJHskZGF0YX1gKTtcbiAgICAgICAganNvblBvaW50ZXIgPSAkZGF0YTtcbiAgICAgICAgZGF0YSA9IG5hbWVzXzEuZGVmYXVsdC5yb290RGF0YTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBSRUxBVElWRV9KU09OX1BPSU5URVIuZXhlYygkZGF0YSk7XG4gICAgICAgIGlmICghbWF0Y2hlcylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBKU09OLXBvaW50ZXI6ICR7JGRhdGF9YCk7XG4gICAgICAgIGNvbnN0IHVwID0gK21hdGNoZXNbMV07XG4gICAgICAgIGpzb25Qb2ludGVyID0gbWF0Y2hlc1syXTtcbiAgICAgICAgaWYgKGpzb25Qb2ludGVyID09PSBcIiNcIikge1xuICAgICAgICAgICAgaWYgKHVwID49IGRhdGFMZXZlbClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2coXCJwcm9wZXJ0eS9pbmRleFwiLCB1cCkpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFQYXRoQXJyW2RhdGFMZXZlbCAtIHVwXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXAgPiBkYXRhTGV2ZWwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2coXCJkYXRhXCIsIHVwKSk7XG4gICAgICAgIGRhdGEgPSBkYXRhTmFtZXNbZGF0YUxldmVsIC0gdXBdO1xuICAgICAgICBpZiAoIWpzb25Qb2ludGVyKVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGxldCBleHByID0gZGF0YTtcbiAgICBjb25zdCBzZWdtZW50cyA9IGpzb25Qb2ludGVyLnNwbGl0KFwiL1wiKTtcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgICAgIGRhdGEgPSBjb2RlZ2VuXzEuXyBgJHtkYXRhfSR7Y29kZWdlbl8xLmdldFByb3BlcnR5KHV0aWxfMS51bmVzY2FwZUpzb25Qb2ludGVyKHNlZ21lbnQpKX1gO1xuICAgICAgICAgICAgZXhwciA9IGNvZGVnZW5fMS5fIGAke2V4cHJ9ICYmICR7ZGF0YX1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHByO1xuICAgIGZ1bmN0aW9uIGVycm9yTXNnKHBvaW50ZXJUeXBlLCB1cCkge1xuICAgICAgICByZXR1cm4gYENhbm5vdCBhY2Nlc3MgJHtwb2ludGVyVHlwZX0gJHt1cH0gbGV2ZWxzIHVwLCBjdXJyZW50IGxldmVsIGlzICR7ZGF0YUxldmVsfWA7XG4gICAgfVxufVxuZXhwb3J0cy5nZXREYXRhID0gZ2V0RGF0YTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGVycm9ycykge1xuICAgICAgICBzdXBlcihcInZhbGlkYXRpb24gZmFpbGVkXCIpO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhpcy5hanYgPSB0aGlzLnZhbGlkYXRpb24gPSB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFZhbGlkYXRpb25FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRpb25fZXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByZXNvbHZlXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlXCIpO1xuY2xhc3MgTWlzc2luZ1JlZkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGJhc2VJZCwgcmVmLCBtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnIHx8IGBjYW4ndCByZXNvbHZlIHJlZmVyZW5jZSAke3JlZn0gZnJvbSBpZCAke2Jhc2VJZH1gKTtcbiAgICAgICAgdGhpcy5taXNzaW5nUmVmID0gcmVzb2x2ZV8xLnJlc29sdmVVcmwoYmFzZUlkLCByZWYpO1xuICAgICAgICB0aGlzLm1pc3NpbmdTY2hlbWEgPSByZXNvbHZlXzEubm9ybWFsaXplSWQocmVzb2x2ZV8xLmdldEZ1bGxQYXRoKHRoaXMubWlzc2luZ1JlZikpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IE1pc3NpbmdSZWZFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZl9lcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVzb2x2ZVNjaGVtYSA9IGV4cG9ydHMuZ2V0Q29tcGlsaW5nU2NoZW1hID0gZXhwb3J0cy5yZXNvbHZlUmVmID0gZXhwb3J0cy5jb21waWxlU2NoZW1hID0gZXhwb3J0cy5TY2hlbWFFbnYgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgdmFsaWRhdGlvbl9lcnJvcl8xID0gcmVxdWlyZShcIi4uL3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi9uYW1lc1wiKTtcbmNvbnN0IHJlc29sdmVfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRlXCIpO1xuY29uc3QgVVJJID0gcmVxdWlyZShcInVyaS1qc1wiKTtcbmNsYXNzIFNjaGVtYUVudiB7XG4gICAgY29uc3RydWN0b3IoZW52KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5yZWZzID0ge307XG4gICAgICAgIHRoaXMuZHluYW1pY0FuY2hvcnMgPSB7fTtcbiAgICAgICAgbGV0IHNjaGVtYTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnYuc2NoZW1hID09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICBzY2hlbWEgPSBlbnYuc2NoZW1hO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IGVudi5zY2hlbWE7XG4gICAgICAgIHRoaXMuc2NoZW1hSWQgPSBlbnYuc2NoZW1hSWQ7XG4gICAgICAgIHRoaXMucm9vdCA9IGVudi5yb290IHx8IHRoaXM7XG4gICAgICAgIHRoaXMuYmFzZUlkID0gKF9hID0gZW52LmJhc2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKHNjaGVtYSA9PT0gbnVsbCB8fCBzY2hlbWEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaGVtYVtlbnYuc2NoZW1hSWQgfHwgXCIkaWRcIl0pO1xuICAgICAgICB0aGlzLnNjaGVtYVBhdGggPSBlbnYuc2NoZW1hUGF0aDtcbiAgICAgICAgdGhpcy5sb2NhbFJlZnMgPSBlbnYubG9jYWxSZWZzO1xuICAgICAgICB0aGlzLm1ldGEgPSBlbnYubWV0YTtcbiAgICAgICAgdGhpcy4kYXN5bmMgPSBzY2hlbWEgPT09IG51bGwgfHwgc2NoZW1hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2hlbWEuJGFzeW5jO1xuICAgICAgICB0aGlzLnJlZnMgPSB7fTtcbiAgICB9XG59XG5leHBvcnRzLlNjaGVtYUVudiA9IFNjaGVtYUVudjtcbi8vIGxldCBjb2RlU2l6ZSA9IDBcbi8vIGxldCBub2RlQ291bnQgPSAwXG4vLyBDb21waWxlcyBzY2hlbWEgaW4gU2NoZW1hRW52XG5mdW5jdGlvbiBjb21waWxlU2NoZW1hKHNjaCkge1xuICAgIC8vIFRPRE8gcmVmYWN0b3IgLSByZW1vdmUgY29tcGlsYXRpb25zXG4gICAgY29uc3QgX3NjaCA9IGdldENvbXBpbGluZ1NjaGVtYS5jYWxsKHRoaXMsIHNjaCk7XG4gICAgaWYgKF9zY2gpXG4gICAgICAgIHJldHVybiBfc2NoO1xuICAgIGNvbnN0IHJvb3RJZCA9IHJlc29sdmVfMS5nZXRGdWxsUGF0aChzY2gucm9vdC5iYXNlSWQpOyAvLyBUT0RPIGlmIGdldEZ1bGxQYXRoIHJlbW92ZWQgMSB0ZXN0cyBmYWlsc1xuICAgIGNvbnN0IHsgZXM1LCBsaW5lcyB9ID0gdGhpcy5vcHRzLmNvZGU7XG4gICAgY29uc3QgeyBvd25Qcm9wZXJ0aWVzIH0gPSB0aGlzLm9wdHM7XG4gICAgY29uc3QgZ2VuID0gbmV3IGNvZGVnZW5fMS5Db2RlR2VuKHRoaXMuc2NvcGUsIHsgZXM1LCBsaW5lcywgb3duUHJvcGVydGllcyB9KTtcbiAgICBsZXQgX1ZhbGlkYXRpb25FcnJvcjtcbiAgICBpZiAoc2NoLiRhc3luYykge1xuICAgICAgICBfVmFsaWRhdGlvbkVycm9yID0gZ2VuLnNjb3BlVmFsdWUoXCJFcnJvclwiLCB7XG4gICAgICAgICAgICByZWY6IHZhbGlkYXRpb25fZXJyb3JfMS5kZWZhdWx0LFxuICAgICAgICAgICAgY29kZTogY29kZWdlbl8xLl8gYHJlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIikuZGVmYXVsdGAsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZGF0ZU5hbWUgPSBnZW4uc2NvcGVOYW1lKFwidmFsaWRhdGVcIik7XG4gICAgc2NoLnZhbGlkYXRlTmFtZSA9IHZhbGlkYXRlTmFtZTtcbiAgICBjb25zdCBzY2hlbWFDeHQgPSB7XG4gICAgICAgIGdlbixcbiAgICAgICAgYWxsRXJyb3JzOiB0aGlzLm9wdHMuYWxsRXJyb3JzLFxuICAgICAgICBkYXRhOiBuYW1lc18xLmRlZmF1bHQuZGF0YSxcbiAgICAgICAgcGFyZW50RGF0YTogbmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGEsXG4gICAgICAgIHBhcmVudERhdGFQcm9wZXJ0eTogbmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSxcbiAgICAgICAgZGF0YU5hbWVzOiBbbmFtZXNfMS5kZWZhdWx0LmRhdGFdLFxuICAgICAgICBkYXRhUGF0aEFycjogW2NvZGVnZW5fMS5uaWxdLFxuICAgICAgICBkYXRhTGV2ZWw6IDAsXG4gICAgICAgIGRhdGFUeXBlczogW10sXG4gICAgICAgIGRlZmluZWRQcm9wZXJ0aWVzOiBuZXcgU2V0KCksXG4gICAgICAgIHRvcFNjaGVtYVJlZjogZ2VuLnNjb3BlVmFsdWUoXCJzY2hlbWFcIiwgdGhpcy5vcHRzLmNvZGUuc291cmNlID09PSB0cnVlXG4gICAgICAgICAgICA/IHsgcmVmOiBzY2guc2NoZW1hLCBjb2RlOiBjb2RlZ2VuXzEuc3RyaW5naWZ5KHNjaC5zY2hlbWEpIH1cbiAgICAgICAgICAgIDogeyByZWY6IHNjaC5zY2hlbWEgfSksXG4gICAgICAgIHZhbGlkYXRlTmFtZSxcbiAgICAgICAgVmFsaWRhdGlvbkVycm9yOiBfVmFsaWRhdGlvbkVycm9yLFxuICAgICAgICBzY2hlbWE6IHNjaC5zY2hlbWEsXG4gICAgICAgIHNjaGVtYUVudjogc2NoLFxuICAgICAgICByb290SWQsXG4gICAgICAgIGJhc2VJZDogc2NoLmJhc2VJZCB8fCByb290SWQsXG4gICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5uaWwsXG4gICAgICAgIGVyclNjaGVtYVBhdGg6IHNjaC5zY2hlbWFQYXRoIHx8ICh0aGlzLm9wdHMuanRkID8gXCJcIiA6IFwiI1wiKSxcbiAgICAgICAgZXJyb3JQYXRoOiBjb2RlZ2VuXzEuXyBgXCJcImAsXG4gICAgICAgIG9wdHM6IHRoaXMub3B0cyxcbiAgICAgICAgc2VsZjogdGhpcyxcbiAgICB9O1xuICAgIGxldCBzb3VyY2VDb2RlO1xuICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGF0aW9ucy5hZGQoc2NoKTtcbiAgICAgICAgdmFsaWRhdGVfMS52YWxpZGF0ZUZ1bmN0aW9uQ29kZShzY2hlbWFDeHQpO1xuICAgICAgICBnZW4ub3B0aW1pemUodGhpcy5vcHRzLmNvZGUub3B0aW1pemUpO1xuICAgICAgICAvLyBnZW4ub3B0aW1pemUoMSlcbiAgICAgICAgY29uc3QgdmFsaWRhdGVDb2RlID0gZ2VuLnRvU3RyaW5nKCk7XG4gICAgICAgIHNvdXJjZUNvZGUgPSBgJHtnZW4uc2NvcGVSZWZzKG5hbWVzXzEuZGVmYXVsdC5zY29wZSl9cmV0dXJuICR7dmFsaWRhdGVDb2RlfWA7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKChjb2RlU2l6ZSArPSBzb3VyY2VDb2RlLmxlbmd0aCksIChub2RlQ291bnQgKz0gZ2VuLm5vZGVDb3VudCkpXG4gICAgICAgIGlmICh0aGlzLm9wdHMuY29kZS5wcm9jZXNzKVxuICAgICAgICAgICAgc291cmNlQ29kZSA9IHRoaXMub3B0cy5jb2RlLnByb2Nlc3Moc291cmNlQ29kZSwgc2NoKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJcXG5cXG5cXG4gKioqIFxcblwiLCBzb3VyY2VDb2RlKVxuICAgICAgICBjb25zdCBtYWtlVmFsaWRhdGUgPSBuZXcgRnVuY3Rpb24oYCR7bmFtZXNfMS5kZWZhdWx0LnNlbGZ9YCwgYCR7bmFtZXNfMS5kZWZhdWx0LnNjb3BlfWAsIHNvdXJjZUNvZGUpO1xuICAgICAgICBjb25zdCB2YWxpZGF0ZSA9IG1ha2VWYWxpZGF0ZSh0aGlzLCB0aGlzLnNjb3BlLmdldCgpKTtcbiAgICAgICAgdGhpcy5zY29wZS52YWx1ZSh2YWxpZGF0ZU5hbWUsIHsgcmVmOiB2YWxpZGF0ZSB9KTtcbiAgICAgICAgdmFsaWRhdGUuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgdmFsaWRhdGUuc2NoZW1hID0gc2NoLnNjaGVtYTtcbiAgICAgICAgdmFsaWRhdGUuc2NoZW1hRW52ID0gc2NoO1xuICAgICAgICBpZiAoc2NoLiRhc3luYylcbiAgICAgICAgICAgIHZhbGlkYXRlLiRhc3luYyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuY29kZS5zb3VyY2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlLnNvdXJjZSA9IHsgdmFsaWRhdGVOYW1lLCB2YWxpZGF0ZUNvZGUsIHNjb3BlVmFsdWVzOiBnZW4uX3ZhbHVlcyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdHMudW5ldmFsdWF0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMsIGl0ZW1zIH0gPSBzY2hlbWFDeHQ7XG4gICAgICAgICAgICB2YWxpZGF0ZS5ldmFsdWF0ZWQgPSB7XG4gICAgICAgICAgICAgICAgcHJvcHM6IHByb3BzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUgPyB1bmRlZmluZWQgOiBwcm9wcyxcbiAgICAgICAgICAgICAgICBpdGVtczogaXRlbXMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSA/IHVuZGVmaW5lZCA6IGl0ZW1zLFxuICAgICAgICAgICAgICAgIGR5bmFtaWNQcm9wczogcHJvcHMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSxcbiAgICAgICAgICAgICAgICBkeW5hbWljSXRlbXM6IGl0ZW1zIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRlLnNvdXJjZSlcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZS5zb3VyY2UuZXZhbHVhdGVkID0gY29kZWdlbl8xLnN0cmluZ2lmeSh2YWxpZGF0ZS5ldmFsdWF0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHNjaC52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuICAgICAgICByZXR1cm4gc2NoO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBkZWxldGUgc2NoLnZhbGlkYXRlO1xuICAgICAgICBkZWxldGUgc2NoLnZhbGlkYXRlTmFtZTtcbiAgICAgICAgaWYgKHNvdXJjZUNvZGUpXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIkVycm9yIGNvbXBpbGluZyBzY2hlbWEsIGZ1bmN0aW9uIGNvZGU6XCIsIHNvdXJjZUNvZGUpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlxcblxcblxcbiAqKiogXFxuXCIsIHNvdXJjZUNvZGUsIHRoaXMub3B0cylcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGF0aW9ucy5kZWxldGUoc2NoKTtcbiAgICB9XG59XG5leHBvcnRzLmNvbXBpbGVTY2hlbWEgPSBjb21waWxlU2NoZW1hO1xuZnVuY3Rpb24gcmVzb2x2ZVJlZihyb290LCBiYXNlSWQsIHJlZikge1xuICAgIHZhciBfYTtcbiAgICByZWYgPSByZXNvbHZlXzEucmVzb2x2ZVVybChiYXNlSWQsIHJlZik7XG4gICAgY29uc3Qgc2NoT3JGdW5jID0gcm9vdC5yZWZzW3JlZl07XG4gICAgaWYgKHNjaE9yRnVuYylcbiAgICAgICAgcmV0dXJuIHNjaE9yRnVuYztcbiAgICBsZXQgX3NjaCA9IHJlc29sdmUuY2FsbCh0aGlzLCByb290LCByZWYpO1xuICAgIGlmIChfc2NoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gKF9hID0gcm9vdC5sb2NhbFJlZnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtyZWZdOyAvLyBUT0RPIG1heWJlIGxvY2FsUmVmcyBzaG91bGQgaG9sZCBTY2hlbWFFbnZcbiAgICAgICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICBpZiAoc2NoZW1hKVxuICAgICAgICAgICAgX3NjaCA9IG5ldyBTY2hlbWFFbnYoeyBzY2hlbWEsIHNjaGVtYUlkLCByb290LCBiYXNlSWQgfSk7XG4gICAgfVxuICAgIGlmIChfc2NoID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICByZXR1cm4gKHJvb3QucmVmc1tyZWZdID0gaW5saW5lT3JDb21waWxlLmNhbGwodGhpcywgX3NjaCkpO1xufVxuZXhwb3J0cy5yZXNvbHZlUmVmID0gcmVzb2x2ZVJlZjtcbmZ1bmN0aW9uIGlubGluZU9yQ29tcGlsZShzY2gpIHtcbiAgICBpZiAocmVzb2x2ZV8xLmlubGluZVJlZihzY2guc2NoZW1hLCB0aGlzLm9wdHMuaW5saW5lUmVmcykpXG4gICAgICAgIHJldHVybiBzY2guc2NoZW1hO1xuICAgIHJldHVybiBzY2gudmFsaWRhdGUgPyBzY2ggOiBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbn1cbi8vIEluZGV4IG9mIHNjaGVtYSBjb21waWxhdGlvbiBpbiB0aGUgY3VycmVudGx5IGNvbXBpbGVkIGxpc3RcbmZ1bmN0aW9uIGdldENvbXBpbGluZ1NjaGVtYShzY2hFbnYpIHtcbiAgICBmb3IgKGNvbnN0IHNjaCBvZiB0aGlzLl9jb21waWxhdGlvbnMpIHtcbiAgICAgICAgaWYgKHNhbWVTY2hlbWFFbnYoc2NoLCBzY2hFbnYpKVxuICAgICAgICAgICAgcmV0dXJuIHNjaDtcbiAgICB9XG59XG5leHBvcnRzLmdldENvbXBpbGluZ1NjaGVtYSA9IGdldENvbXBpbGluZ1NjaGVtYTtcbmZ1bmN0aW9uIHNhbWVTY2hlbWFFbnYoczEsIHMyKSB7XG4gICAgcmV0dXJuIHMxLnNjaGVtYSA9PT0gczIuc2NoZW1hICYmIHMxLnJvb3QgPT09IHMyLnJvb3QgJiYgczEuYmFzZUlkID09PSBzMi5iYXNlSWQ7XG59XG4vLyByZXNvbHZlIGFuZCBjb21waWxlIHRoZSByZWZlcmVuY2VzICgkcmVmKVxuLy8gVE9ETyByZXR1cm5zIEFueVNjaGVtYU9iamVjdCAoaWYgdGhlIHNjaGVtYSBjYW4gYmUgaW5saW5lZCkgb3IgdmFsaWRhdGlvbiBmdW5jdGlvblxuZnVuY3Rpb24gcmVzb2x2ZShyb290LCAvLyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcm9vdCBzY2hlbWEgZm9yIHRoZSBjdXJyZW50IHNjaGVtYVxucmVmIC8vIHJlZmVyZW5jZSB0byByZXNvbHZlXG4pIHtcbiAgICBsZXQgc2NoO1xuICAgIHdoaWxlICh0eXBlb2YgKHNjaCA9IHRoaXMucmVmc1tyZWZdKSA9PSBcInN0cmluZ1wiKVxuICAgICAgICByZWYgPSBzY2g7XG4gICAgcmV0dXJuIHNjaCB8fCB0aGlzLnNjaGVtYXNbcmVmXSB8fCByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgcmVmKTtcbn1cbi8vIFJlc29sdmUgc2NoZW1hLCBpdHMgcm9vdCBhbmQgYmFzZUlkXG5mdW5jdGlvbiByZXNvbHZlU2NoZW1hKHJvb3QsIC8vIHJvb3Qgb2JqZWN0IHdpdGggcHJvcGVydGllcyBzY2hlbWEsIHJlZnMgVE9ETyBiZWxvdyBTY2hlbWFFbnYgaXMgYXNzaWduZWQgdG8gaXRcbnJlZiAvLyByZWZlcmVuY2UgdG8gcmVzb2x2ZVxuKSB7XG4gICAgY29uc3QgcCA9IFVSSS5wYXJzZShyZWYpO1xuICAgIGNvbnN0IHJlZlBhdGggPSByZXNvbHZlXzEuX2dldEZ1bGxQYXRoKHApO1xuICAgIGxldCBiYXNlSWQgPSByZXNvbHZlXzEuZ2V0RnVsbFBhdGgocm9vdC5iYXNlSWQpO1xuICAgIC8vIFRPRE8gYE9iamVjdC5rZXlzKHJvb3Quc2NoZW1hKS5sZW5ndGggPiAwYCBzaG91bGQgbm90IGJlIG5lZWRlZCAtIGJ1dCByZW1vdmluZyBicmVha3MgMiB0ZXN0c1xuICAgIGlmIChPYmplY3Qua2V5cyhyb290LnNjaGVtYSkubGVuZ3RoID4gMCAmJiByZWZQYXRoID09PSBiYXNlSWQpIHtcbiAgICAgICAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcCwgcm9vdCk7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKHJlZlBhdGgpO1xuICAgIGNvbnN0IHNjaE9yUmVmID0gdGhpcy5yZWZzW2lkXSB8fCB0aGlzLnNjaGVtYXNbaWRdO1xuICAgIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBzY2ggPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgc2NoT3JSZWYpO1xuICAgICAgICBpZiAodHlwZW9mIChzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2guc2NoZW1hKSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcCwgc2NoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoc2NoT3JSZWYgPT09IG51bGwgfHwgc2NoT3JSZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaE9yUmVmLnNjaGVtYSkgIT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIXNjaE9yUmVmLnZhbGlkYXRlKVxuICAgICAgICBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoT3JSZWYpO1xuICAgIGlmIChpZCA9PT0gcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKHJlZikpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEgfSA9IHNjaE9yUmVmO1xuICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIGNvbnN0IHNjaElkID0gc2NoZW1hW3NjaGVtYUlkXTtcbiAgICAgICAgaWYgKHNjaElkKVxuICAgICAgICAgICAgYmFzZUlkID0gcmVzb2x2ZV8xLnJlc29sdmVVcmwoYmFzZUlkLCBzY2hJZCk7XG4gICAgICAgIHJldHVybiBuZXcgU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCBzY2hPclJlZik7XG59XG5leHBvcnRzLnJlc29sdmVTY2hlbWEgPSByZXNvbHZlU2NoZW1hO1xuY29uc3QgUFJFVkVOVF9TQ09QRV9DSEFOR0UgPSBuZXcgU2V0KFtcbiAgICBcInByb3BlcnRpZXNcIixcbiAgICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgXCJlbnVtXCIsXG4gICAgXCJkZXBlbmRlbmNpZXNcIixcbiAgICBcImRlZmluaXRpb25zXCIsXG5dKTtcbmZ1bmN0aW9uIGdldEpzb25Qb2ludGVyKHBhcnNlZFJlZiwgeyBiYXNlSWQsIHNjaGVtYSwgcm9vdCB9KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICgoKF9hID0gcGFyc2VkUmVmLmZyYWdtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pICE9PSBcIi9cIilcbiAgICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJzZWRSZWYuZnJhZ21lbnQuc2xpY2UoMSkuc3BsaXQoXCIvXCIpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzY2hlbWEgPSBzY2hlbWFbdXRpbF8xLnVuZXNjYXBlRnJhZ21lbnQocGFydCldO1xuICAgICAgICBpZiAoc2NoZW1hID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIFRPRE8gUFJFVkVOVF9TQ09QRV9DSEFOR0UgY291bGQgYmUgZGVmaW5lZCBpbiBrZXl3b3JkIGRlZj9cbiAgICAgICAgY29uc3Qgc2NoSWQgPSB0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgc2NoZW1hW3RoaXMub3B0cy5zY2hlbWFJZF07XG4gICAgICAgIGlmICghUFJFVkVOVF9TQ09QRV9DSEFOR0UuaGFzKHBhcnQpICYmIHNjaElkKSB7XG4gICAgICAgICAgICBiYXNlSWQgPSByZXNvbHZlXzEucmVzb2x2ZVVybChiYXNlSWQsIHNjaElkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgZW52O1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hICE9IFwiYm9vbGVhblwiICYmIHNjaGVtYS4kcmVmICYmICF1dGlsXzEuc2NoZW1hSGFzUnVsZXNCdXRSZWYoc2NoZW1hLCB0aGlzLlJVTEVTKSkge1xuICAgICAgICBjb25zdCAkcmVmID0gcmVzb2x2ZV8xLnJlc29sdmVVcmwoYmFzZUlkLCBzY2hlbWEuJHJlZik7XG4gICAgICAgIGVudiA9IHJlc29sdmVTY2hlbWEuY2FsbCh0aGlzLCByb290LCAkcmVmKTtcbiAgICB9XG4gICAgLy8gZXZlbiB0aG91Z2ggcmVzb2x1dGlvbiBmYWlsZWQgd2UgbmVlZCB0byByZXR1cm4gU2NoZW1hRW52IHRvIHRocm93IGV4Y2VwdGlvblxuICAgIC8vIHNvIHRoYXQgY29tcGlsZUFzeW5jIGxvYWRzIG1pc3Npbmcgc2NoZW1hLlxuICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICBlbnYgPSBlbnYgfHwgbmV3IFNjaGVtYUVudih7IHNjaGVtYSwgc2NoZW1hSWQsIHJvb3QsIGJhc2VJZCB9KTtcbiAgICBpZiAoZW52LnNjaGVtYSAhPT0gZW52LnJvb3Quc2NoZW1hKVxuICAgICAgICByZXR1cm4gZW52O1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29kZUdlbiA9IGV4cG9ydHMuTmFtZSA9IGV4cG9ydHMubmlsID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuXyA9IGV4cG9ydHMuS2V5d29yZEN4dCA9IHZvaWQgMDtcbnZhciB2YWxpZGF0ZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS92YWxpZGF0ZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIktleXdvcmRDeHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRlXzEuS2V5d29yZEN4dDsgfSB9KTtcbnZhciBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL2NvZGVnZW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuXzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0clwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cmluZ2lmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5pbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLm5pbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5OYW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29kZUdlblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLkNvZGVHZW47IH0gfSk7XG5jb25zdCB2YWxpZGF0aW9uX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIik7XG5jb25zdCByZWZfZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvcmVmX2Vycm9yXCIpO1xuY29uc3QgcnVsZXNfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvcnVsZXNcIik7XG5jb25zdCBjb21waWxlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlXCIpO1xuY29uc3QgY29kZWdlbl8yID0gcmVxdWlyZShcIi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgcmVzb2x2ZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9yZXNvbHZlXCIpO1xuY29uc3QgZGF0YVR5cGVfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCAkZGF0YVJlZlNjaGVtYSA9IHJlcXVpcmUoXCIuL3JlZnMvZGF0YS5qc29uXCIpO1xuY29uc3QgTUVUQV9JR05PUkVfT1BUSU9OUyA9IFtcInJlbW92ZUFkZGl0aW9uYWxcIiwgXCJ1c2VEZWZhdWx0c1wiLCBcImNvZXJjZVR5cGVzXCJdO1xuY29uc3QgRVhUX1NDT1BFX05BTUVTID0gbmV3IFNldChbXG4gICAgXCJ2YWxpZGF0ZVwiLFxuICAgIFwic2VyaWFsaXplXCIsXG4gICAgXCJwYXJzZVwiLFxuICAgIFwid3JhcHBlclwiLFxuICAgIFwicm9vdFwiLFxuICAgIFwic2NoZW1hXCIsXG4gICAgXCJrZXl3b3JkXCIsXG4gICAgXCJwYXR0ZXJuXCIsXG4gICAgXCJmb3JtYXRzXCIsXG4gICAgXCJ2YWxpZGF0ZSRkYXRhXCIsXG4gICAgXCJmdW5jXCIsXG4gICAgXCJvYmpcIixcbiAgICBcIkVycm9yXCIsXG5dKTtcbmNvbnN0IHJlbW92ZWRPcHRpb25zID0ge1xuICAgIGVycm9yRGF0YVBhdGg6IFwiXCIsXG4gICAgZm9ybWF0OiBcImB2YWxpZGF0ZUZvcm1hdHM6IGZhbHNlYCBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICAgIG51bGxhYmxlOiAnXCJudWxsYWJsZVwiIGtleXdvcmQgaXMgc3VwcG9ydGVkIGJ5IGRlZmF1bHQuJyxcbiAgICBqc29uUG9pbnRlcnM6IFwiRGVwcmVjYXRlZCBqc1Byb3BlcnR5U3ludGF4IGNhbiBiZSB1c2VkIGluc3RlYWQuXCIsXG4gICAgZXh0ZW5kUmVmczogXCJEZXByZWNhdGVkIGlnbm9yZUtleXdvcmRzV2l0aFJlZiBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICAgIG1pc3NpbmdSZWZzOiBcIlBhc3MgZW1wdHkgc2NoZW1hIHdpdGggJGlkIHRoYXQgc2hvdWxkIGJlIGlnbm9yZWQgdG8gYWp2LmFkZFNjaGVtYS5cIixcbiAgICBwcm9jZXNzQ29kZTogXCJVc2Ugb3B0aW9uIGBjb2RlOiB7cHJvY2VzczogKGNvZGUsIHNjaGVtYUVudjogb2JqZWN0KSA9PiBzdHJpbmd9YFwiLFxuICAgIHNvdXJjZUNvZGU6IFwiVXNlIG9wdGlvbiBgY29kZToge3NvdXJjZTogdHJ1ZX1gXCIsXG4gICAgc3RyaWN0RGVmYXVsdHM6IFwiSXQgaXMgZGVmYXVsdCBub3csIHNlZSBvcHRpb24gYHN0cmljdGAuXCIsXG4gICAgc3RyaWN0S2V5d29yZHM6IFwiSXQgaXMgZGVmYXVsdCBub3csIHNlZSBvcHRpb24gYHN0cmljdGAuXCIsXG4gICAgdW5pcXVlSXRlbXM6ICdcInVuaXF1ZUl0ZW1zXCIga2V5d29yZCBpcyBhbHdheXMgdmFsaWRhdGVkLicsXG4gICAgdW5rbm93bkZvcm1hdHM6IFwiRGlzYWJsZSBzdHJpY3QgbW9kZSBvciBwYXNzIGB0cnVlYCB0byBgYWp2LmFkZEZvcm1hdGAgKG9yIGBmb3JtYXRzYCBvcHRpb24pLlwiLFxuICAgIGNhY2hlOiBcIk1hcCBpcyB1c2VkIGFzIGNhY2hlLCBzY2hlbWEgb2JqZWN0IGFzIGtleS5cIixcbiAgICBzZXJpYWxpemU6IFwiTWFwIGlzIHVzZWQgYXMgY2FjaGUsIHNjaGVtYSBvYmplY3QgYXMga2V5LlwiLFxuICAgIGFqdkVycm9yczogXCJJdCBpcyBkZWZhdWx0IG5vdy5cIixcbn07XG5jb25zdCBkZXByZWNhdGVkT3B0aW9ucyA9IHtcbiAgICBpZ25vcmVLZXl3b3Jkc1dpdGhSZWY6IFwiXCIsXG4gICAganNQcm9wZXJ0eVN5bnRheDogXCJcIixcbiAgICB1bmljb2RlOiAnXCJtaW5MZW5ndGhcIi9cIm1heExlbmd0aFwiIGFjY291bnQgZm9yIHVuaWNvZGUgY2hhcmFjdGVycyBieSBkZWZhdWx0LicsXG59O1xuY29uc3QgTUFYX0VYUFJFU1NJT04gPSAyMDA7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gcmVxdWlyZWRPcHRpb25zKG8pIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbSwgX28sIF9wLCBfcSwgX3IsIF9zLCBfdCwgX3UsIF92LCBfdywgX3g7XG4gICAgY29uc3QgcyA9IG8uc3RyaWN0O1xuICAgIGNvbnN0IF9vcHR6ID0gKF9hID0gby5jb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW1pemU7XG4gICAgY29uc3Qgb3B0aW1pemUgPSBfb3B0eiA9PT0gdHJ1ZSB8fCBfb3B0eiA9PT0gdW5kZWZpbmVkID8gMSA6IF9vcHR6IHx8IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RyaWN0U2NoZW1hOiAoX2MgPSAoX2IgPSBvLnN0cmljdFNjaGVtYSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogcykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdHJ1ZSxcbiAgICAgICAgc3RyaWN0TnVtYmVyczogKF9lID0gKF9kID0gby5zdHJpY3ROdW1iZXJzKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBzKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB0cnVlLFxuICAgICAgICBzdHJpY3RUeXBlczogKF9nID0gKF9mID0gby5zdHJpY3RUeXBlcykgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogcykgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogXCJsb2dcIixcbiAgICAgICAgc3RyaWN0VHVwbGVzOiAoX2ogPSAoX2ggPSBvLnN0cmljdFR1cGxlcykgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogcykgIT09IG51bGwgJiYgX2ogIT09IHZvaWQgMCA/IF9qIDogXCJsb2dcIixcbiAgICAgICAgc3RyaWN0UmVxdWlyZWQ6IChfbCA9IChfayA9IG8uc3RyaWN0UmVxdWlyZWQpICE9PSBudWxsICYmIF9rICE9PSB2b2lkIDAgPyBfayA6IHMpICE9PSBudWxsICYmIF9sICE9PSB2b2lkIDAgPyBfbCA6IGZhbHNlLFxuICAgICAgICBjb2RlOiBvLmNvZGUgPyB7IC4uLm8uY29kZSwgb3B0aW1pemUgfSA6IHsgb3B0aW1pemUgfSxcbiAgICAgICAgbG9vcFJlcXVpcmVkOiAoX20gPSBvLmxvb3BSZXF1aXJlZCkgIT09IG51bGwgJiYgX20gIT09IHZvaWQgMCA/IF9tIDogTUFYX0VYUFJFU1NJT04sXG4gICAgICAgIGxvb3BFbnVtOiAoX28gPSBvLmxvb3BFbnVtKSAhPT0gbnVsbCAmJiBfbyAhPT0gdm9pZCAwID8gX28gOiBNQVhfRVhQUkVTU0lPTixcbiAgICAgICAgbWV0YTogKF9wID0gby5tZXRhKSAhPT0gbnVsbCAmJiBfcCAhPT0gdm9pZCAwID8gX3AgOiB0cnVlLFxuICAgICAgICBtZXNzYWdlczogKF9xID0gby5tZXNzYWdlcykgIT09IG51bGwgJiYgX3EgIT09IHZvaWQgMCA/IF9xIDogdHJ1ZSxcbiAgICAgICAgaW5saW5lUmVmczogKF9yID0gby5pbmxpbmVSZWZzKSAhPT0gbnVsbCAmJiBfciAhPT0gdm9pZCAwID8gX3IgOiB0cnVlLFxuICAgICAgICBzY2hlbWFJZDogKF9zID0gby5zY2hlbWFJZCkgIT09IG51bGwgJiYgX3MgIT09IHZvaWQgMCA/IF9zIDogXCIkaWRcIixcbiAgICAgICAgYWRkVXNlZFNjaGVtYTogKF90ID0gby5hZGRVc2VkU2NoZW1hKSAhPT0gbnVsbCAmJiBfdCAhPT0gdm9pZCAwID8gX3QgOiB0cnVlLFxuICAgICAgICB2YWxpZGF0ZVNjaGVtYTogKF91ID0gby52YWxpZGF0ZVNjaGVtYSkgIT09IG51bGwgJiYgX3UgIT09IHZvaWQgMCA/IF91IDogdHJ1ZSxcbiAgICAgICAgdmFsaWRhdGVGb3JtYXRzOiAoX3YgPSBvLnZhbGlkYXRlRm9ybWF0cykgIT09IG51bGwgJiYgX3YgIT09IHZvaWQgMCA/IF92IDogdHJ1ZSxcbiAgICAgICAgdW5pY29kZVJlZ0V4cDogKF93ID0gby51bmljb2RlUmVnRXhwKSAhPT0gbnVsbCAmJiBfdyAhPT0gdm9pZCAwID8gX3cgOiB0cnVlLFxuICAgICAgICBpbnQzMnJhbmdlOiAoX3ggPSBvLmludDMycmFuZ2UpICE9PSBudWxsICYmIF94ICE9PSB2b2lkIDAgPyBfeCA6IHRydWUsXG4gICAgfTtcbn1cbmNsYXNzIEFqdiB7XG4gICAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgICAgIHRoaXMuc2NoZW1hcyA9IHt9O1xuICAgICAgICB0aGlzLnJlZnMgPSB7fTtcbiAgICAgICAgdGhpcy5mb3JtYXRzID0ge307XG4gICAgICAgIHRoaXMuX2NvbXBpbGF0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5fbG9hZGluZyA9IHt9O1xuICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgb3B0cyA9IHRoaXMub3B0cyA9IHsgLi4ub3B0cywgLi4ucmVxdWlyZWRPcHRpb25zKG9wdHMpIH07XG4gICAgICAgIGNvbnN0IHsgZXM1LCBsaW5lcyB9ID0gdGhpcy5vcHRzLmNvZGU7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBuZXcgY29kZWdlbl8yLlZhbHVlU2NvcGUoeyBzY29wZToge30sIHByZWZpeGVzOiBFWFRfU0NPUEVfTkFNRVMsIGVzNSwgbGluZXMgfSk7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gZ2V0TG9nZ2VyKG9wdHMubG9nZ2VyKTtcbiAgICAgICAgY29uc3QgZm9ybWF0T3B0ID0gb3B0cy52YWxpZGF0ZUZvcm1hdHM7XG4gICAgICAgIG9wdHMudmFsaWRhdGVGb3JtYXRzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuUlVMRVMgPSBydWxlc18xLmdldFJ1bGVzKCk7XG4gICAgICAgIGNoZWNrT3B0aW9ucy5jYWxsKHRoaXMsIHJlbW92ZWRPcHRpb25zLCBvcHRzLCBcIk5PVCBTVVBQT1JURURcIik7XG4gICAgICAgIGNoZWNrT3B0aW9ucy5jYWxsKHRoaXMsIGRlcHJlY2F0ZWRPcHRpb25zLCBvcHRzLCBcIkRFUFJFQ0FURURcIiwgXCJ3YXJuXCIpO1xuICAgICAgICB0aGlzLl9tZXRhT3B0cyA9IGdldE1ldGFTY2hlbWFPcHRpb25zLmNhbGwodGhpcyk7XG4gICAgICAgIGlmIChvcHRzLmZvcm1hdHMpXG4gICAgICAgICAgICBhZGRJbml0aWFsRm9ybWF0cy5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9hZGRWb2NhYnVsYXJpZXMoKTtcbiAgICAgICAgdGhpcy5fYWRkRGVmYXVsdE1ldGFTY2hlbWEoKTtcbiAgICAgICAgaWYgKG9wdHMua2V5d29yZHMpXG4gICAgICAgICAgICBhZGRJbml0aWFsS2V5d29yZHMuY2FsbCh0aGlzLCBvcHRzLmtleXdvcmRzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLm1ldGEgPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHRoaXMuYWRkTWV0YVNjaGVtYShvcHRzLm1ldGEpO1xuICAgICAgICBhZGRJbml0aWFsU2NoZW1hcy5jYWxsKHRoaXMpO1xuICAgICAgICBvcHRzLnZhbGlkYXRlRm9ybWF0cyA9IGZvcm1hdE9wdDtcbiAgICB9XG4gICAgX2FkZFZvY2FidWxhcmllcygpIHtcbiAgICAgICAgdGhpcy5hZGRLZXl3b3JkKFwiJGFzeW5jXCIpO1xuICAgIH1cbiAgICBfYWRkRGVmYXVsdE1ldGFTY2hlbWEoKSB7XG4gICAgICAgIGNvbnN0IHsgJGRhdGEsIG1ldGEsIHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIGxldCBfZGF0YVJlZlNjaGVtYSA9ICRkYXRhUmVmU2NoZW1hO1xuICAgICAgICBpZiAoc2NoZW1hSWQgPT09IFwiaWRcIikge1xuICAgICAgICAgICAgX2RhdGFSZWZTY2hlbWEgPSB7IC4uLiRkYXRhUmVmU2NoZW1hIH07XG4gICAgICAgICAgICBfZGF0YVJlZlNjaGVtYS5pZCA9IF9kYXRhUmVmU2NoZW1hLiRpZDtcbiAgICAgICAgICAgIGRlbGV0ZSBfZGF0YVJlZlNjaGVtYS4kaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEgJiYgJGRhdGEpXG4gICAgICAgICAgICB0aGlzLmFkZE1ldGFTY2hlbWEoX2RhdGFSZWZTY2hlbWEsIF9kYXRhUmVmU2NoZW1hW3NjaGVtYUlkXSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0TWV0YSgpIHtcbiAgICAgICAgY29uc3QgeyBtZXRhLCBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICByZXR1cm4gKHRoaXMub3B0cy5kZWZhdWx0TWV0YSA9IHR5cGVvZiBtZXRhID09IFwib2JqZWN0XCIgPyBtZXRhW3NjaGVtYUlkXSB8fCBtZXRhIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgdmFsaWRhdGUoc2NoZW1hS2V5UmVmLCAvLyBrZXksIHJlZiBvciBzY2hlbWEgb2JqZWN0XG4gICAgZGF0YSAvLyB0byBiZSB2YWxpZGF0ZWRcbiAgICApIHtcbiAgICAgICAgbGV0IHY7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hS2V5UmVmID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLmdldFNjaGVtYShzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgaWYgKCF2KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gc2NoZW1hIHdpdGgga2V5IG9yIHJlZiBcIiR7c2NoZW1hS2V5UmVmfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2ID0gdGhpcy5jb21waWxlKHNjaGVtYUtleVJlZik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWQgPSB2KGRhdGEpO1xuICAgICAgICBpZiAoIShcIiRhc3luY1wiIGluIHYpKVxuICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSB2LmVycm9ycztcbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cbiAgICBjb21waWxlKHNjaGVtYSwgX21ldGEpIHtcbiAgICAgICAgY29uc3Qgc2NoID0gdGhpcy5fYWRkU2NoZW1hKHNjaGVtYSwgX21ldGEpO1xuICAgICAgICByZXR1cm4gKHNjaC52YWxpZGF0ZSB8fCB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaCkpO1xuICAgIH1cbiAgICBjb21waWxlQXN5bmMoc2NoZW1hLCBtZXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRzLmxvYWRTY2hlbWEgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zLmxvYWRTY2hlbWEgc2hvdWxkIGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBsb2FkU2NoZW1hIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIHJldHVybiBydW5Db21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2hlbWEsIG1ldGEpO1xuICAgICAgICBhc3luYyBmdW5jdGlvbiBydW5Db21waWxlQXN5bmMoX3NjaGVtYSwgX21ldGEpIHtcbiAgICAgICAgICAgIGF3YWl0IGxvYWRNZXRhU2NoZW1hLmNhbGwodGhpcywgX3NjaGVtYS4kc2NoZW1hKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaCA9IHRoaXMuX2FkZFNjaGVtYShfc2NoZW1hLCBfbWV0YSk7XG4gICAgICAgICAgICByZXR1cm4gc2NoLnZhbGlkYXRlIHx8IF9jb21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRNZXRhU2NoZW1hKCRyZWYpIHtcbiAgICAgICAgICAgIGlmICgkcmVmICYmICF0aGlzLmdldFNjaGVtYSgkcmVmKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJ1bkNvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHsgJHJlZiB9LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBfY29tcGlsZUFzeW5jKHNjaCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcGlsZVNjaGVtYUVudihzY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgcmVmX2Vycm9yXzEuZGVmYXVsdCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgY2hlY2tMb2FkZWQuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBsb2FkTWlzc2luZ1NjaGVtYS5jYWxsKHRoaXMsIGUubWlzc2luZ1NjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTG9hZGVkKHsgbWlzc2luZ1NjaGVtYTogcmVmLCBtaXNzaW5nUmVmIH0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlZnNbcmVmXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW55U2NoZW1hICR7cmVmfSBpcyBsb2FkZWQgYnV0ICR7bWlzc2luZ1JlZn0gY2Fubm90IGJlIHJlc29sdmVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gbG9hZE1pc3NpbmdTY2hlbWEocmVmKSB7XG4gICAgICAgICAgICBjb25zdCBfc2NoZW1hID0gYXdhaXQgX2xvYWRTY2hlbWEuY2FsbCh0aGlzLCByZWYpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlZnNbcmVmXSlcbiAgICAgICAgICAgICAgICBhd2FpdCBsb2FkTWV0YVNjaGVtYS5jYWxsKHRoaXMsIF9zY2hlbWEuJHNjaGVtYSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVmc1tyZWZdKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hKF9zY2hlbWEsIHJlZiwgbWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gX2xvYWRTY2hlbWEocmVmKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gdGhpcy5fbG9hZGluZ1tyZWZdO1xuICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCAodGhpcy5fbG9hZGluZ1tyZWZdID0gbG9hZFNjaGVtYShyZWYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9sb2FkaW5nW3JlZl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQWRkcyBzY2hlbWEgdG8gdGhlIGluc3RhbmNlXG4gICAgYWRkU2NoZW1hKHNjaGVtYSwgLy8gSWYgYXJyYXkgaXMgcGFzc2VkLCBga2V5YCB3aWxsIGJlIGlnbm9yZWRcbiAgICBrZXksIC8vIE9wdGlvbmFsIHNjaGVtYSBrZXkuIENhbiBiZSBwYXNzZWQgdG8gYHZhbGlkYXRlYCBtZXRob2QgaW5zdGVhZCBvZiBzY2hlbWEgb2JqZWN0IG9yIGlkL3JlZi4gT25lIHNjaGVtYSBwZXIgaW5zdGFuY2UgY2FuIGhhdmUgZW1wdHkgYGlkYCBhbmQgYGtleWAuXG4gICAgX21ldGEsIC8vIHRydWUgaWYgc2NoZW1hIGlzIGEgbWV0YS1zY2hlbWEuIFVzZWQgaW50ZXJuYWxseSwgYWRkTWV0YVNjaGVtYSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgIF92YWxpZGF0ZVNjaGVtYSA9IHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSAvLyBmYWxzZSB0byBza2lwIHNjaGVtYSB2YWxpZGF0aW9uLiBVc2VkIGludGVybmFsbHksIG9wdGlvbiB2YWxpZGF0ZVNjaGVtYSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNjaCBvZiBzY2hlbWEpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWEoc2NoLCB1bmRlZmluZWQsIF9tZXRhLCBfdmFsaWRhdGVTY2hlbWEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICAgICAgaWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGlkICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNjaGVtYSAke3NjaGVtYUlkfSBtdXN0IGJlIHN0cmluZ2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGtleSA9IHJlc29sdmVfMS5ub3JtYWxpemVJZChrZXkgfHwgaWQpO1xuICAgICAgICB0aGlzLl9jaGVja1VuaXF1ZShrZXkpO1xuICAgICAgICB0aGlzLnNjaGVtYXNba2V5XSA9IHRoaXMuX2FkZFNjaGVtYShzY2hlbWEsIF9tZXRhLCBrZXksIF92YWxpZGF0ZVNjaGVtYSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBBZGQgc2NoZW1hIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIG90aGVyIHNjaGVtYXNcbiAgICAvLyBvcHRpb25zIGluIE1FVEFfSUdOT1JFX09QVElPTlMgYXJlIGFsd2F5IHNldCB0byBmYWxzZVxuICAgIGFkZE1ldGFTY2hlbWEoc2NoZW1hLCBrZXksIC8vIHNjaGVtYSBrZXlcbiAgICBfdmFsaWRhdGVTY2hlbWEgPSB0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEgLy8gZmFsc2UgdG8gc2tpcCBzY2hlbWEgdmFsaWRhdGlvbiwgY2FuIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdmFsaWRhdGVTY2hlbWEgb3B0aW9uIGZvciBtZXRhLXNjaGVtYVxuICAgICkge1xuICAgICAgICB0aGlzLmFkZFNjaGVtYShzY2hlbWEsIGtleSwgdHJ1ZSwgX3ZhbGlkYXRlU2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vICBWYWxpZGF0ZSBzY2hlbWEgYWdhaW5zdCBpdHMgbWV0YS1zY2hlbWFcbiAgICB2YWxpZGF0ZVNjaGVtYShzY2hlbWEsIHRocm93T3JMb2dFcnJvcikge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgJHNjaGVtYTtcbiAgICAgICAgJHNjaGVtYSA9IHNjaGVtYS4kc2NoZW1hO1xuICAgICAgICBpZiAoJHNjaGVtYSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiAkc2NoZW1hICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIiRzY2hlbWEgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICAkc2NoZW1hID0gJHNjaGVtYSB8fCB0aGlzLm9wdHMuZGVmYXVsdE1ldGEgfHwgdGhpcy5kZWZhdWx0TWV0YSgpO1xuICAgICAgICBpZiAoISRzY2hlbWEpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJtZXRhLXNjaGVtYSBub3QgYXZhaWxhYmxlXCIpO1xuICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWQgPSB0aGlzLnZhbGlkYXRlKCRzY2hlbWEsIHNjaGVtYSk7XG4gICAgICAgIGlmICghdmFsaWQgJiYgdGhyb3dPckxvZ0Vycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gXCJzY2hlbWEgaXMgaW52YWxpZDogXCIgKyB0aGlzLmVycm9yc1RleHQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEgPT09IFwibG9nXCIpXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9XG4gICAgLy8gR2V0IGNvbXBpbGVkIHNjaGVtYSBieSBga2V5YCBvciBgcmVmYC5cbiAgICAvLyAoYGtleWAgdGhhdCB3YXMgcGFzc2VkIHRvIGBhZGRTY2hlbWFgIG9yIGZ1bGwgc2NoZW1hIHJlZmVyZW5jZSAtIGBzY2hlbWEuJGlkYCBvciByZXNvbHZlZCBpZClcbiAgICBnZXRTY2hlbWEoa2V5UmVmKSB7XG4gICAgICAgIGxldCBzY2g7XG4gICAgICAgIHdoaWxlICh0eXBlb2YgKHNjaCA9IGdldFNjaEVudi5jYWxsKHRoaXMsIGtleVJlZikpID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBrZXlSZWYgPSBzY2g7XG4gICAgICAgIGlmIChzY2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IG5ldyBjb21waWxlXzEuU2NoZW1hRW52KHsgc2NoZW1hOiB7fSwgc2NoZW1hSWQgfSk7XG4gICAgICAgICAgICBzY2ggPSBjb21waWxlXzEucmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsIGtleVJlZik7XG4gICAgICAgICAgICBpZiAoIXNjaClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnJlZnNba2V5UmVmXSA9IHNjaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHNjaC52YWxpZGF0ZSB8fCB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaCkpO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgY2FjaGVkIHNjaGVtYShzKS5cbiAgICAvLyBJZiBubyBwYXJhbWV0ZXIgaXMgcGFzc2VkIGFsbCBzY2hlbWFzIGJ1dCBtZXRhLXNjaGVtYXMgYXJlIHJlbW92ZWQuXG4gICAgLy8gSWYgUmVnRXhwIGlzIHBhc3NlZCBhbGwgc2NoZW1hcyB3aXRoIGtleS9pZCBtYXRjaGluZyBwYXR0ZXJuIGJ1dCBtZXRhLXNjaGVtYXMgYXJlIHJlbW92ZWQuXG4gICAgLy8gRXZlbiBpZiBzY2hlbWEgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBzY2hlbWFzIGl0IHN0aWxsIGNhbiBiZSByZW1vdmVkIGFzIG90aGVyIHNjaGVtYXMgaGF2ZSBsb2NhbCByZWZlcmVuY2VzLlxuICAgIHJlbW92ZVNjaGVtYShzY2hlbWFLZXlSZWYpIHtcbiAgICAgICAgaWYgKHNjaGVtYUtleVJlZiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnNjaGVtYXMsIHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMucmVmcywgc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHNjaGVtYUtleVJlZikge1xuICAgICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5zY2hlbWFzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMucmVmcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaCA9IGdldFNjaEVudi5jYWxsKHRoaXMsIHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2ggPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuZGVsZXRlKHNjaC5zY2hlbWEpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNjaGVtYXNbc2NoZW1hS2V5UmVmXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5yZWZzW3NjaGVtYUtleVJlZl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZUtleSA9IHNjaGVtYUtleVJlZjtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5kZWxldGUoY2FjaGVLZXkpO1xuICAgICAgICAgICAgICAgIGxldCBpZCA9IHNjaGVtYUtleVJlZlt0aGlzLm9wdHMuc2NoZW1hSWRdO1xuICAgICAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgICAgICBpZCA9IHJlc29sdmVfMS5ub3JtYWxpemVJZChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNjaGVtYXNbaWRdO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5yZWZzW2lkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdi5yZW1vdmVTY2hlbWE6IGludmFsaWQgcGFyYW1ldGVyXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFkZCBcInZvY2FidWxhcnlcIiAtIGEgY29sbGVjdGlvbiBvZiBrZXl3b3Jkc1xuICAgIGFkZFZvY2FidWxhcnkoZGVmaW5pdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBkZWYgb2YgZGVmaW5pdGlvbnMpXG4gICAgICAgICAgICB0aGlzLmFkZEtleXdvcmQoZGVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkZEtleXdvcmQoa3dkT3JEZWYsIGRlZiAvLyBkZXByZWNhdGVkXG4gICAgKSB7XG4gICAgICAgIGxldCBrZXl3b3JkO1xuICAgICAgICBpZiAodHlwZW9mIGt3ZE9yRGVmID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGtleXdvcmQgPSBrd2RPckRlZjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwidGhlc2UgcGFyYW1ldGVycyBhcmUgZGVwcmVjYXRlZCwgc2VlIGRvY3MgZm9yIGFkZEtleXdvcmRcIik7XG4gICAgICAgICAgICAgICAgZGVmLmtleXdvcmQgPSBrZXl3b3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBrd2RPckRlZiA9PSBcIm9iamVjdFwiICYmIGRlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWYgPSBrd2RPckRlZjtcbiAgICAgICAgICAgIGtleXdvcmQgPSBkZWYua2V5d29yZDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGtleXdvcmQpICYmICFrZXl3b3JkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZEtleXdvcmRzOiBrZXl3b3JkIG11c3QgYmUgc3RyaW5nIG9yIG5vbi1lbXB0eSBhcnJheVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYWRkS2V5d29yZHMgcGFyYW1ldGVyc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja0tleXdvcmQuY2FsbCh0aGlzLCBrZXl3b3JkLCBkZWYpO1xuICAgICAgICBpZiAoIWRlZikge1xuICAgICAgICAgICAgdXRpbF8xLmVhY2hJdGVtKGtleXdvcmQsIChrd2QpID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrd2QpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGtleXdvcmRNZXRhc2NoZW1hLmNhbGwodGhpcywgZGVmKTtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIC4uLmRlZixcbiAgICAgICAgICAgIHR5cGU6IGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKGRlZi50eXBlKSxcbiAgICAgICAgICAgIHNjaGVtYVR5cGU6IGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKGRlZi5zY2hlbWFUeXBlKSxcbiAgICAgICAgfTtcbiAgICAgICAgdXRpbF8xLmVhY2hJdGVtKGtleXdvcmQsIGRlZmluaXRpb24udHlwZS5sZW5ndGggPT09IDBcbiAgICAgICAgICAgID8gKGspID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrLCBkZWZpbml0aW9uKVxuICAgICAgICAgICAgOiAoaykgPT4gZGVmaW5pdGlvbi50eXBlLmZvckVhY2goKHQpID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrLCBkZWZpbml0aW9uLCB0KSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0S2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSB0aGlzLlJVTEVTLmFsbFtrZXl3b3JkXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBydWxlID09IFwib2JqZWN0XCIgPyBydWxlLmRlZmluaXRpb24gOiAhIXJ1bGU7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBrZXl3b3JkXG4gICAgcmVtb3ZlS2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIC8vIFRPRE8gcmV0dXJuIHR5cGUgc2hvdWxkIGJlIEFqdlxuICAgICAgICBjb25zdCB7IFJVTEVTIH0gPSB0aGlzO1xuICAgICAgICBkZWxldGUgUlVMRVMua2V5d29yZHNba2V5d29yZF07XG4gICAgICAgIGRlbGV0ZSBSVUxFUy5hbGxba2V5d29yZF07XG4gICAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgUlVMRVMucnVsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBncm91cC5ydWxlcy5maW5kSW5kZXgoKHJ1bGUpID0+IHJ1bGUua2V5d29yZCA9PT0ga2V5d29yZCk7XG4gICAgICAgICAgICBpZiAoaSA+PSAwKVxuICAgICAgICAgICAgICAgIGdyb3VwLnJ1bGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gQWRkIGZvcm1hdFxuICAgIGFkZEZvcm1hdChuYW1lLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGZvcm1hdCA9IG5ldyBSZWdFeHAoZm9ybWF0KTtcbiAgICAgICAgdGhpcy5mb3JtYXRzW25hbWVdID0gZm9ybWF0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZXJyb3JzVGV4dChlcnJvcnMgPSB0aGlzLmVycm9ycywgLy8gb3B0aW9uYWwgYXJyYXkgb2YgdmFsaWRhdGlvbiBlcnJvcnNcbiAgICB7IHNlcGFyYXRvciA9IFwiLCBcIiwgZGF0YVZhciA9IFwiZGF0YVwiIH0gPSB7fSAvLyBvcHRpb25hbCBvcHRpb25zIHdpdGggcHJvcGVydGllcyBgc2VwYXJhdG9yYCBhbmQgYGRhdGFWYXJgXG4gICAgKSB7XG4gICAgICAgIGlmICghZXJyb3JzIHx8IGVycm9ycy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gXCJObyBlcnJvcnNcIjtcbiAgICAgICAgcmV0dXJuIGVycm9yc1xuICAgICAgICAgICAgLm1hcCgoZSkgPT4gYCR7ZGF0YVZhcn0ke2UuaW5zdGFuY2VQYXRofSAke2UubWVzc2FnZX1gKVxuICAgICAgICAgICAgLnJlZHVjZSgodGV4dCwgbXNnKSA9PiB0ZXh0ICsgc2VwYXJhdG9yICsgbXNnKTtcbiAgICB9XG4gICAgJGRhdGFNZXRhU2NoZW1hKG1ldGFTY2hlbWEsIGtleXdvcmRzSnNvblBvaW50ZXJzKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVzID0gdGhpcy5SVUxFUy5hbGw7XG4gICAgICAgIG1ldGFTY2hlbWEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1ldGFTY2hlbWEpKTtcbiAgICAgICAgZm9yIChjb25zdCBqc29uUG9pbnRlciBvZiBrZXl3b3Jkc0pzb25Qb2ludGVycykge1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBqc29uUG9pbnRlci5zcGxpdChcIi9cIikuc2xpY2UoMSk7IC8vIGZpcnN0IHNlZ21lbnQgaXMgYW4gZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICBsZXQga2V5d29yZHMgPSBtZXRhU2NoZW1hO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzZWcgb2Ygc2VnbWVudHMpXG4gICAgICAgICAgICAgICAga2V5d29yZHMgPSBrZXl3b3Jkc1tzZWddO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcnVsZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBydWxlID0gcnVsZXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJ1bGUgIT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgeyAkZGF0YSB9ID0gcnVsZS5kZWZpbml0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IGtleXdvcmRzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKCRkYXRhICYmIHNjaGVtYSlcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZHNba2V5XSA9IHNjaGVtYU9yRGF0YShzY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRhU2NoZW1hO1xuICAgIH1cbiAgICBfcmVtb3ZlQWxsU2NoZW1hcyhzY2hlbWFzLCByZWdleCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleVJlZiBpbiBzY2hlbWFzKSB7XG4gICAgICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFzW2tleVJlZl07XG4gICAgICAgICAgICBpZiAoIXJlZ2V4IHx8IHJlZ2V4LnRlc3Qoa2V5UmVmKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYXNba2V5UmVmXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoICYmICFzY2gubWV0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5kZWxldGUoc2NoLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFzW2tleVJlZl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9hZGRTY2hlbWEoc2NoZW1hLCBtZXRhLCBiYXNlSWQsIHZhbGlkYXRlU2NoZW1hID0gdGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hLCBhZGRTY2hlbWEgPSB0aGlzLm9wdHMuYWRkVXNlZFNjaGVtYSkge1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5qdGQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2NoZW1hIG11c3QgYmUgb2JqZWN0XCIpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNjaGVtYSAhPSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgbXVzdCBiZSBvYmplY3Qgb3IgYm9vbGVhblwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2NoID0gdGhpcy5fY2FjaGUuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGlmIChzY2ggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBzY2g7XG4gICAgICAgIGNvbnN0IGxvY2FsUmVmcyA9IHJlc29sdmVfMS5nZXRTY2hlbWFSZWZzLmNhbGwodGhpcywgc2NoZW1hKTtcbiAgICAgICAgYmFzZUlkID0gcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKGlkIHx8IGJhc2VJZCk7XG4gICAgICAgIHNjaCA9IG5ldyBjb21waWxlXzEuU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgbWV0YSwgYmFzZUlkLCBsb2NhbFJlZnMgfSk7XG4gICAgICAgIHRoaXMuX2NhY2hlLnNldChzY2guc2NoZW1hLCBzY2gpO1xuICAgICAgICBpZiAoYWRkU2NoZW1hICYmICFiYXNlSWQuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gYXRtIGl0IGlzIGFsbG93ZWQgdG8gb3ZlcndyaXRlIHNjaGVtYXMgd2l0aG91dCBpZCAoaW5zdGVhZCBvZiBub3QgYWRkaW5nIHRoZW0pXG4gICAgICAgICAgICBpZiAoYmFzZUlkKVxuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrVW5pcXVlKGJhc2VJZCk7XG4gICAgICAgICAgICB0aGlzLnJlZnNbYmFzZUlkXSA9IHNjaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsaWRhdGVTY2hlbWEpXG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlU2NoZW1hKHNjaGVtYSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBzY2g7XG4gICAgfVxuICAgIF9jaGVja1VuaXF1ZShpZCkge1xuICAgICAgICBpZiAodGhpcy5zY2hlbWFzW2lkXSB8fCB0aGlzLnJlZnNbaWRdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNjaGVtYSB3aXRoIGtleSBvciBpZCBcIiR7aWR9XCIgYWxyZWFkeSBleGlzdHNgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY29tcGlsZVNjaGVtYUVudihzY2gpIHtcbiAgICAgICAgaWYgKHNjaC5tZXRhKVxuICAgICAgICAgICAgdGhpcy5fY29tcGlsZU1ldGFTY2hlbWEoc2NoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29tcGlsZV8xLmNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFzY2gudmFsaWRhdGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgIHJldHVybiBzY2gudmFsaWRhdGU7XG4gICAgfVxuICAgIF9jb21waWxlTWV0YVNjaGVtYShzY2gpIHtcbiAgICAgICAgY29uc3QgY3VycmVudE9wdHMgPSB0aGlzLm9wdHM7XG4gICAgICAgIHRoaXMub3B0cyA9IHRoaXMuX21ldGFPcHRzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29tcGlsZV8xLmNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5vcHRzID0gY3VycmVudE9wdHM7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBBanY7XG5BanYuVmFsaWRhdGlvbkVycm9yID0gdmFsaWRhdGlvbl9lcnJvcl8xLmRlZmF1bHQ7XG5BanYuTWlzc2luZ1JlZkVycm9yID0gcmVmX2Vycm9yXzEuZGVmYXVsdDtcbmZ1bmN0aW9uIGNoZWNrT3B0aW9ucyhjaGVja09wdHMsIG9wdGlvbnMsIG1zZywgbG9nID0gXCJlcnJvclwiKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY2hlY2tPcHRzKSB7XG4gICAgICAgIGNvbnN0IG9wdCA9IGtleTtcbiAgICAgICAgaWYgKG9wdCBpbiBvcHRpb25zKVxuICAgICAgICAgICAgdGhpcy5sb2dnZXJbbG9nXShgJHttc2d9OiBvcHRpb24gJHtrZXl9LiAke2NoZWNrT3B0c1tvcHRdfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNjaEVudihrZXlSZWYpIHtcbiAgICBrZXlSZWYgPSByZXNvbHZlXzEubm9ybWFsaXplSWQoa2V5UmVmKTsgLy8gVE9ETyB0ZXN0cyBmYWlsIHdpdGhvdXQgdGhpcyBsaW5lXG4gICAgcmV0dXJuIHRoaXMuc2NoZW1hc1trZXlSZWZdIHx8IHRoaXMucmVmc1trZXlSZWZdO1xufVxuZnVuY3Rpb24gYWRkSW5pdGlhbFNjaGVtYXMoKSB7XG4gICAgY29uc3Qgb3B0c1NjaGVtYXMgPSB0aGlzLm9wdHMuc2NoZW1hcztcbiAgICBpZiAoIW9wdHNTY2hlbWFzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0c1NjaGVtYXMpKVxuICAgICAgICB0aGlzLmFkZFNjaGVtYShvcHRzU2NoZW1hcyk7XG4gICAgZWxzZVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRzU2NoZW1hcylcbiAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hKG9wdHNTY2hlbWFzW2tleV0sIGtleSk7XG59XG5mdW5jdGlvbiBhZGRJbml0aWFsRm9ybWF0cygpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5vcHRzLmZvcm1hdHMpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gdGhpcy5vcHRzLmZvcm1hdHNbbmFtZV07XG4gICAgICAgIGlmIChmb3JtYXQpXG4gICAgICAgICAgICB0aGlzLmFkZEZvcm1hdChuYW1lLCBmb3JtYXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZEluaXRpYWxLZXl3b3JkcyhkZWZzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmcykpIHtcbiAgICAgICAgdGhpcy5hZGRWb2NhYnVsYXJ5KGRlZnMpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyLndhcm4oXCJrZXl3b3JkcyBvcHRpb24gYXMgbWFwIGlzIGRlcHJlY2F0ZWQsIHBhc3MgYXJyYXlcIik7XG4gICAgZm9yIChjb25zdCBrZXl3b3JkIGluIGRlZnMpIHtcbiAgICAgICAgY29uc3QgZGVmID0gZGVmc1trZXl3b3JkXTtcbiAgICAgICAgaWYgKCFkZWYua2V5d29yZClcbiAgICAgICAgICAgIGRlZi5rZXl3b3JkID0ga2V5d29yZDtcbiAgICAgICAgdGhpcy5hZGRLZXl3b3JkKGRlZik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0TWV0YVNjaGVtYU9wdGlvbnMoKSB7XG4gICAgY29uc3QgbWV0YU9wdHMgPSB7IC4uLnRoaXMub3B0cyB9O1xuICAgIGZvciAoY29uc3Qgb3B0IG9mIE1FVEFfSUdOT1JFX09QVElPTlMpXG4gICAgICAgIGRlbGV0ZSBtZXRhT3B0c1tvcHRdO1xuICAgIHJldHVybiBtZXRhT3B0cztcbn1cbmNvbnN0IG5vTG9ncyA9IHsgbG9nKCkgeyB9LCB3YXJuKCkgeyB9LCBlcnJvcigpIHsgfSB9O1xuZnVuY3Rpb24gZ2V0TG9nZ2VyKGxvZ2dlcikge1xuICAgIGlmIChsb2dnZXIgPT09IGZhbHNlKVxuICAgICAgICByZXR1cm4gbm9Mb2dzO1xuICAgIGlmIChsb2dnZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIGNvbnNvbGU7XG4gICAgaWYgKGxvZ2dlci5sb2cgJiYgbG9nZ2VyLndhcm4gJiYgbG9nZ2VyLmVycm9yKVxuICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgIHRocm93IG5ldyBFcnJvcihcImxvZ2dlciBtdXN0IGltcGxlbWVudCBsb2csIHdhcm4gYW5kIGVycm9yIG1ldGhvZHNcIik7XG59XG5jb25zdCBLRVlXT1JEX05BTUUgPSAvXlthLXpfJF1bYS16MC05XyQ6LV0qJC9pO1xuZnVuY3Rpb24gY2hlY2tLZXl3b3JkKGtleXdvcmQsIGRlZikge1xuICAgIGNvbnN0IHsgUlVMRVMgfSA9IHRoaXM7XG4gICAgdXRpbF8xLmVhY2hJdGVtKGtleXdvcmQsIChrd2QpID0+IHtcbiAgICAgICAgaWYgKFJVTEVTLmtleXdvcmRzW2t3ZF0pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleXdvcmQgJHtrd2R9IGlzIGFscmVhZHkgZGVmaW5lZGApO1xuICAgICAgICBpZiAoIUtFWVdPUkRfTkFNRS50ZXN0KGt3ZCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleXdvcmQgJHtrd2R9IGhhcyBpbnZhbGlkIG5hbWVgKTtcbiAgICB9KTtcbiAgICBpZiAoIWRlZilcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChkZWYuJGRhdGEgJiYgIShcImNvZGVcIiBpbiBkZWYgfHwgXCJ2YWxpZGF0ZVwiIGluIGRlZikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCckZGF0YSBrZXl3b3JkIG11c3QgaGF2ZSBcImNvZGVcIiBvciBcInZhbGlkYXRlXCIgZnVuY3Rpb24nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRSdWxlKGtleXdvcmQsIGRlZmluaXRpb24sIGRhdGFUeXBlKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHBvc3QgPSBkZWZpbml0aW9uID09PSBudWxsIHx8IGRlZmluaXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlZmluaXRpb24ucG9zdDtcbiAgICBpZiAoZGF0YVR5cGUgJiYgcG9zdClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXl3b3JkIHdpdGggXCJwb3N0XCIgZmxhZyBjYW5ub3QgaGF2ZSBcInR5cGVcIicpO1xuICAgIGNvbnN0IHsgUlVMRVMgfSA9IHRoaXM7XG4gICAgbGV0IHJ1bGVHcm91cCA9IHBvc3QgPyBSVUxFUy5wb3N0IDogUlVMRVMucnVsZXMuZmluZCgoeyB0eXBlOiB0IH0pID0+IHQgPT09IGRhdGFUeXBlKTtcbiAgICBpZiAoIXJ1bGVHcm91cCkge1xuICAgICAgICBydWxlR3JvdXAgPSB7IHR5cGU6IGRhdGFUeXBlLCBydWxlczogW10gfTtcbiAgICAgICAgUlVMRVMucnVsZXMucHVzaChydWxlR3JvdXApO1xuICAgIH1cbiAgICBSVUxFUy5rZXl3b3Jkc1trZXl3b3JkXSA9IHRydWU7XG4gICAgaWYgKCFkZWZpbml0aW9uKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgcnVsZSA9IHtcbiAgICAgICAga2V5d29yZCxcbiAgICAgICAgZGVmaW5pdGlvbjoge1xuICAgICAgICAgICAgLi4uZGVmaW5pdGlvbixcbiAgICAgICAgICAgIHR5cGU6IGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKGRlZmluaXRpb24udHlwZSksXG4gICAgICAgICAgICBzY2hlbWFUeXBlOiBkYXRhVHlwZV8xLmdldEpTT05UeXBlcyhkZWZpbml0aW9uLnNjaGVtYVR5cGUpLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgaWYgKGRlZmluaXRpb24uYmVmb3JlKVxuICAgICAgICBhZGRCZWZvcmVSdWxlLmNhbGwodGhpcywgcnVsZUdyb3VwLCBydWxlLCBkZWZpbml0aW9uLmJlZm9yZSk7XG4gICAgZWxzZVxuICAgICAgICBydWxlR3JvdXAucnVsZXMucHVzaChydWxlKTtcbiAgICBSVUxFUy5hbGxba2V5d29yZF0gPSBydWxlO1xuICAgIChfYSA9IGRlZmluaXRpb24uaW1wbGVtZW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGt3ZCkgPT4gdGhpcy5hZGRLZXl3b3JkKGt3ZCkpO1xufVxuZnVuY3Rpb24gYWRkQmVmb3JlUnVsZShydWxlR3JvdXAsIHJ1bGUsIGJlZm9yZSkge1xuICAgIGNvbnN0IGkgPSBydWxlR3JvdXAucnVsZXMuZmluZEluZGV4KChfcnVsZSkgPT4gX3J1bGUua2V5d29yZCA9PT0gYmVmb3JlKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgIHJ1bGVHcm91cC5ydWxlcy5zcGxpY2UoaSwgMCwgcnVsZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBydWxlR3JvdXAucnVsZXMucHVzaChydWxlKTtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgcnVsZSAke2JlZm9yZX0gaXMgbm90IGRlZmluZWRgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBrZXl3b3JkTWV0YXNjaGVtYShkZWYpIHtcbiAgICBsZXQgeyBtZXRhU2NoZW1hIH0gPSBkZWY7XG4gICAgaWYgKG1ldGFTY2hlbWEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChkZWYuJGRhdGEgJiYgdGhpcy5vcHRzLiRkYXRhKVxuICAgICAgICBtZXRhU2NoZW1hID0gc2NoZW1hT3JEYXRhKG1ldGFTY2hlbWEpO1xuICAgIGRlZi52YWxpZGF0ZVNjaGVtYSA9IHRoaXMuY29tcGlsZShtZXRhU2NoZW1hLCB0cnVlKTtcbn1cbmNvbnN0ICRkYXRhUmVmID0ge1xuICAgICRyZWY6IFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Fqdi12YWxpZGF0b3IvYWp2L21hc3Rlci9saWIvcmVmcy9kYXRhLmpzb24jXCIsXG59O1xuZnVuY3Rpb24gc2NoZW1hT3JEYXRhKHNjaGVtYSkge1xuICAgIHJldHVybiB7IGFueU9mOiBbc2NoZW1hLCAkZGF0YVJlZl0gfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpZFwiLFxuICAgIGNvZGUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTk9UIFNVUFBPUlRFRDoga2V5d29yZCBcImlkXCIsIHVzZSBcIiRpZFwiIGZvciBzY2hlbWEgSUQnKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYWxsUmVmID0gZXhwb3J0cy5nZXRWYWxpZGF0ZSA9IHZvaWQgMDtcbmNvbnN0IHJlZl9lcnJvcl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvcmVmX2Vycm9yXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL25hbWVzXCIpO1xuY29uc3QgY29tcGlsZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiJHJlZlwiLFxuICAgIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYTogJHJlZiwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBiYXNlSWQsIHNjaGVtYUVudjogZW52LCB2YWxpZGF0ZU5hbWUsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgICAgICBjb25zdCB7IHJvb3QgfSA9IGVudjtcbiAgICAgICAgaWYgKCgkcmVmID09PSBcIiNcIiB8fCAkcmVmID09PSBcIiMvXCIpICYmIGJhc2VJZCA9PT0gcm9vdC5iYXNlSWQpXG4gICAgICAgICAgICByZXR1cm4gY2FsbFJvb3RSZWYoKTtcbiAgICAgICAgY29uc3Qgc2NoT3JFbnYgPSBjb21waWxlXzEucmVzb2x2ZVJlZi5jYWxsKHNlbGYsIHJvb3QsIGJhc2VJZCwgJHJlZik7XG4gICAgICAgIGlmIChzY2hPckVudiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IHJlZl9lcnJvcl8xLmRlZmF1bHQoYmFzZUlkLCAkcmVmKTtcbiAgICAgICAgaWYgKHNjaE9yRW52IGluc3RhbmNlb2YgY29tcGlsZV8xLlNjaGVtYUVudilcbiAgICAgICAgICAgIHJldHVybiBjYWxsVmFsaWRhdGUoc2NoT3JFbnYpO1xuICAgICAgICByZXR1cm4gaW5saW5lUmVmU2NoZW1hKHNjaE9yRW52KTtcbiAgICAgICAgZnVuY3Rpb24gY2FsbFJvb3RSZWYoKSB7XG4gICAgICAgICAgICBpZiAoZW52ID09PSByb290KVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsUmVmKGN4dCwgdmFsaWRhdGVOYW1lLCBlbnYsIGVudi4kYXN5bmMpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdE5hbWUgPSBnZW4uc2NvcGVWYWx1ZShcInJvb3RcIiwgeyByZWY6IHJvb3QgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbFJlZihjeHQsIGNvZGVnZW5fMS5fIGAke3Jvb3ROYW1lfS52YWxpZGF0ZWAsIHJvb3QsIHJvb3QuJGFzeW5jKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYWxsVmFsaWRhdGUoc2NoKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gZ2V0VmFsaWRhdGUoY3h0LCBzY2gpO1xuICAgICAgICAgICAgY2FsbFJlZihjeHQsIHYsIHNjaCwgc2NoLiRhc3luYyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW5saW5lUmVmU2NoZW1hKHNjaCkge1xuICAgICAgICAgICAgY29uc3Qgc2NoTmFtZSA9IGdlbi5zY29wZVZhbHVlKFwic2NoZW1hXCIsIG9wdHMuY29kZS5zb3VyY2UgPT09IHRydWUgPyB7IHJlZjogc2NoLCBjb2RlOiBjb2RlZ2VuXzEuc3RyaW5naWZ5KHNjaCkgfSA6IHsgcmVmOiBzY2ggfSk7XG4gICAgICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHNjaCxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZXM6IFtdLFxuICAgICAgICAgICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5uaWwsXG4gICAgICAgICAgICAgICAgdG9wU2NoZW1hUmVmOiBzY2hOYW1lLFxuICAgICAgICAgICAgICAgIGVyclNjaGVtYVBhdGg6ICRyZWYsXG4gICAgICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0KTtcbiAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmZ1bmN0aW9uIGdldFZhbGlkYXRlKGN4dCwgc2NoKSB7XG4gICAgY29uc3QgeyBnZW4gfSA9IGN4dDtcbiAgICByZXR1cm4gc2NoLnZhbGlkYXRlXG4gICAgICAgID8gZ2VuLnNjb3BlVmFsdWUoXCJ2YWxpZGF0ZVwiLCB7IHJlZjogc2NoLnZhbGlkYXRlIH0pXG4gICAgICAgIDogY29kZWdlbl8xLl8gYCR7Z2VuLnNjb3BlVmFsdWUoXCJ3cmFwcGVyXCIsIHsgcmVmOiBzY2ggfSl9LnZhbGlkYXRlYDtcbn1cbmV4cG9ydHMuZ2V0VmFsaWRhdGUgPSBnZXRWYWxpZGF0ZTtcbmZ1bmN0aW9uIGNhbGxSZWYoY3h0LCB2LCBzY2gsICRhc3luYykge1xuICAgIGNvbnN0IHsgZ2VuLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHsgYWxsRXJyb3JzLCBzY2hlbWFFbnY6IGVudiwgb3B0cyB9ID0gaXQ7XG4gICAgY29uc3QgcGFzc0N4dCA9IG9wdHMucGFzc0NvbnRleHQgPyBuYW1lc18xLmRlZmF1bHQudGhpcyA6IGNvZGVnZW5fMS5uaWw7XG4gICAgaWYgKCRhc3luYylcbiAgICAgICAgY2FsbEFzeW5jUmVmKCk7XG4gICAgZWxzZVxuICAgICAgICBjYWxsU3luY1JlZigpO1xuICAgIGZ1bmN0aW9uIGNhbGxBc3luY1JlZigpIHtcbiAgICAgICAgaWYgKCFlbnYuJGFzeW5jKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMgc2NoZW1hIHJlZmVyZW5jZWQgYnkgc3luYyBzY2hlbWFcIik7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgICAgICBnZW4udHJ5KCgpID0+IHtcbiAgICAgICAgICAgIGdlbi5jb2RlKGNvZGVnZW5fMS5fIGBhd2FpdCAke2NvZGVfMS5jYWxsVmFsaWRhdGVDb2RlKGN4dCwgdiwgcGFzc0N4dCl9YCk7XG4gICAgICAgICAgICBhZGRFdmFsdWF0ZWRGcm9tKHYpOyAvLyBUT0RPIHdpbGwgbm90IHdvcmsgd2l0aCBhc3luYywgaXQgaGFzIHRvIGJlIHJldHVybmVkIHdpdGggdGhlIHJlc3VsdFxuICAgICAgICAgICAgaWYgKCFhbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgIH0sIChlKSA9PiB7XG4gICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCEoJHtlfSBpbnN0YW5jZW9mICR7aXQuVmFsaWRhdGlvbkVycm9yfSlgLCAoKSA9PiBnZW4udGhyb3coZSkpO1xuICAgICAgICAgICAgYWRkRXJyb3JzRnJvbShlKTtcbiAgICAgICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbGxTeW5jUmVmKCkge1xuICAgICAgICBjeHQucmVzdWx0KGNvZGVfMS5jYWxsVmFsaWRhdGVDb2RlKGN4dCwgdiwgcGFzc0N4dCksICgpID0+IGFkZEV2YWx1YXRlZEZyb20odiksICgpID0+IGFkZEVycm9yc0Zyb20odikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRFcnJvcnNGcm9tKHNvdXJjZSkge1xuICAgICAgICBjb25zdCBlcnJzID0gY29kZWdlbl8xLl8gYCR7c291cmNlfS5lcnJvcnNgO1xuICAgICAgICBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30gPT09IG51bGwgPyAke2VycnN9IDogJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30uY29uY2F0KCR7ZXJyc30pYCk7IC8vIFRPRE8gdGFnZ2VkXG4gICAgICAgIGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LmVycm9ycywgY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9Lmxlbmd0aGApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRFdmFsdWF0ZWRGcm9tKHNvdXJjZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghaXQub3B0cy51bmV2YWx1YXRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgc2NoRXZhbHVhdGVkID0gKF9hID0gc2NoID09PSBudWxsIHx8IHNjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoLnZhbGlkYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXZhbHVhdGVkO1xuICAgICAgICAvLyBUT0RPIHJlZmFjdG9yXG4gICAgICAgIGlmIChpdC5wcm9wcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHNjaEV2YWx1YXRlZCAmJiAhc2NoRXZhbHVhdGVkLmR5bmFtaWNQcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChzY2hFdmFsdWF0ZWQucHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpdC5wcm9wcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5wcm9wcyhnZW4sIHNjaEV2YWx1YXRlZC5wcm9wcywgaXQucHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzID0gZ2VuLnZhcihcInByb3BzXCIsIGNvZGVnZW5fMS5fIGAke3NvdXJjZX0uZXZhbHVhdGVkLnByb3BzYCk7XG4gICAgICAgICAgICAgICAgaXQucHJvcHMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCBwcm9wcywgaXQucHJvcHMsIGNvZGVnZW5fMS5OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQuaXRlbXMgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChzY2hFdmFsdWF0ZWQgJiYgIXNjaEV2YWx1YXRlZC5keW5hbWljSXRlbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NoRXZhbHVhdGVkLml0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXQuaXRlbXMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBzY2hFdmFsdWF0ZWQuaXRlbXMsIGl0Lml0ZW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtcyA9IGdlbi52YXIoXCJpdGVtc1wiLCBjb2RlZ2VuXzEuXyBgJHtzb3VyY2V9LmV2YWx1YXRlZC5pdGVtc2ApO1xuICAgICAgICAgICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgaXRlbXMsIGl0Lml0ZW1zLCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmNhbGxSZWYgPSBjYWxsUmVmO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgaWRfMSA9IHJlcXVpcmUoXCIuL2lkXCIpO1xuY29uc3QgcmVmXzEgPSByZXF1aXJlKFwiLi9yZWZcIik7XG5jb25zdCBjb3JlID0gW1xuICAgIFwiJHNjaGVtYVwiLFxuICAgIFwiJGlkXCIsXG4gICAgXCIkZGVmc1wiLFxuICAgIFwiJHZvY2FidWxhcnlcIixcbiAgICB7IGtleXdvcmQ6IFwiJGNvbW1lbnRcIiB9LFxuICAgIFwiZGVmaW5pdGlvbnNcIixcbiAgICBpZF8xLmRlZmF1bHQsXG4gICAgcmVmXzEuZGVmYXVsdCxcbl07XG5leHBvcnRzLmRlZmF1bHQgPSBjb3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3Qgb3BzID0gY29kZWdlbl8xLm9wZXJhdG9ycztcbmNvbnN0IEtXRHMgPSB7XG4gICAgbWF4aW11bTogeyBva1N0cjogXCI8PVwiLCBvazogb3BzLkxURSwgZmFpbDogb3BzLkdUIH0sXG4gICAgbWluaW11bTogeyBva1N0cjogXCI+PVwiLCBvazogb3BzLkdURSwgZmFpbDogb3BzLkxUIH0sXG4gICAgZXhjbHVzaXZlTWF4aW11bTogeyBva1N0cjogXCI8XCIsIG9rOiBvcHMuTFQsIGZhaWw6IG9wcy5HVEUgfSxcbiAgICBleGNsdXNpdmVNaW5pbXVtOiB7IG9rU3RyOiBcIj5cIiwgb2s6IG9wcy5HVCwgZmFpbDogb3BzLkxURSB9LFxufTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLnN0ciBgbXVzdCBiZSAke0tXRHNba2V5d29yZF0ub2tTdHJ9ICR7c2NoZW1hQ29kZX1gLFxuICAgIHBhcmFtczogKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuXyBge2NvbXBhcmlzb246ICR7S1dEc1trZXl3b3JkXS5va1N0cn0sIGxpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IE9iamVjdC5rZXlzKEtXRHMpLFxuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGtleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGUgfSA9IGN4dDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YShjb2RlZ2VuXzEuXyBgJHtkYXRhfSAke0tXRHNba2V5d29yZF0uZmFpbH0gJHtzY2hlbWFDb2RlfSB8fCBpc05hTigke2RhdGF9KWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXROdW1iZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBtdXN0IGJlIG11bHRpcGxlIG9mICR7c2NoZW1hQ29kZX1gLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuXyBge211bHRpcGxlT2Y6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICAvLyBjb25zdCBiZHQgPSBiYWQkRGF0YVR5cGUoc2NoZW1hQ29kZSwgPHN0cmluZz5kZWYuc2NoZW1hVHlwZSwgJGRhdGEpXG4gICAgICAgIGNvbnN0IHByZWMgPSBpdC5vcHRzLm11bHRpcGxlT2ZQcmVjaXNpb247XG4gICAgICAgIGNvbnN0IHJlcyA9IGdlbi5sZXQoXCJyZXNcIik7XG4gICAgICAgIGNvbnN0IGludmFsaWQgPSBwcmVjXG4gICAgICAgICAgICA/IGNvZGVnZW5fMS5fIGBNYXRoLmFicyhNYXRoLnJvdW5kKCR7cmVzfSkgLSAke3Jlc30pID4gMWUtJHtwcmVjfWBcbiAgICAgICAgICAgIDogY29kZWdlbl8xLl8gYCR7cmVzfSAhPT0gcGFyc2VJbnQoJHtyZXN9KWA7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoY29kZWdlbl8xLl8gYCgke3NjaGVtYUNvZGV9ID09PSAwIHx8ICgke3Jlc30gPSAke2RhdGF9LyR7c2NoZW1hQ29kZX0sICR7aW52YWxpZH0pKWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVsdGlwbGVPZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYmVzdGllanMvcHVueWNvZGUuanMgLSBwdW55Y29kZS51Y3MyLmRlY29kZVxuZnVuY3Rpb24gdWNzMmxlbmd0aChzdHIpIHtcbiAgICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGxldCB2YWx1ZTtcbiAgICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgICAgIGxlbmd0aCsrO1xuICAgICAgICB2YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KHBvcysrKTtcbiAgICAgICAgaWYgKHZhbHVlID49IDB4ZDgwMCAmJiB2YWx1ZSA8PSAweGRiZmYgJiYgcG9zIDwgbGVuKSB7XG4gICAgICAgICAgICAvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHZhbHVlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgICAgIGlmICgodmFsdWUgJiAweGZjMDApID09PSAweGRjMDApXG4gICAgICAgICAgICAgICAgcG9zKys7IC8vIGxvdyBzdXJyb2dhdGVcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gdWNzMmxlbmd0aDtcbnVjczJsZW5ndGguY29kZSA9ICdyZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS91Y3MybGVuZ3RoXCIpLmRlZmF1bHQnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dWNzMmxlbmd0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgdWNzMmxlbmd0aF8xID0gcmVxdWlyZShcIi4uLy4uL3J1bnRpbWUvdWNzMmxlbmd0aFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2UoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pIHtcbiAgICAgICAgY29uc3QgY29tcCA9IGtleXdvcmQgPT09IFwibWF4TGVuZ3RoXCIgPyBcIm1vcmVcIiA6IFwiZmV3ZXJcIjtcbiAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5zdHIgYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gY2hhcmFjdGVyc2A7XG4gICAgfSxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLl8gYHtsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBbXCJtYXhMZW5ndGhcIiwgXCJtaW5MZW5ndGhcIl0sXG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3Qgb3AgPSBrZXl3b3JkID09PSBcIm1heExlbmd0aFwiID8gY29kZWdlbl8xLm9wZXJhdG9ycy5HVCA6IGNvZGVnZW5fMS5vcGVyYXRvcnMuTFQ7XG4gICAgICAgIGNvbnN0IGxlbiA9IGl0Lm9wdHMudW5pY29kZSA9PT0gZmFsc2UgPyBjb2RlZ2VuXzEuXyBgJHtkYXRhfS5sZW5ndGhgIDogY29kZWdlbl8xLl8gYCR7dXRpbF8xLnVzZUZ1bmMoY3h0LmdlbiwgdWNzMmxlbmd0aF8xLmRlZmF1bHQpfSgke2RhdGF9KWA7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoY29kZWdlbl8xLl8gYCR7bGVufSAke29wfSAke3NjaGVtYUNvZGV9YCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW1pdExlbmd0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLnN0ciBgbXVzdCBtYXRjaCBwYXR0ZXJuIFwiJHtzY2hlbWFDb2RlfVwiYCxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLl8gYHtwYXR0ZXJuOiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicGF0dGVyblwiLFxuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGRhdGEsICRkYXRhLCBzY2hlbWEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIC8vIFRPRE8gcmVnZXhwIHNob3VsZCBiZSB3cmFwcGVkIGluIHRyeS9jYXRjaHNcbiAgICAgICAgY29uc3QgdSA9IGl0Lm9wdHMudW5pY29kZVJlZ0V4cCA/IFwidVwiIDogXCJcIjtcbiAgICAgICAgY29uc3QgcmVnRXhwID0gJGRhdGEgPyBjb2RlZ2VuXzEuXyBgKG5ldyBSZWdFeHAoJHtzY2hlbWFDb2RlfSwgJHt1fSkpYCA6IGNvZGVfMS51c2VQYXR0ZXJuKGN4dCwgc2NoZW1hKTtcbiAgICAgICAgY3h0LmZhaWwkZGF0YShjb2RlZ2VuXzEuXyBgISR7cmVnRXhwfS50ZXN0KCR7ZGF0YX0pYCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXR0ZXJuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2UoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pIHtcbiAgICAgICAgY29uc3QgY29tcCA9IGtleXdvcmQgPT09IFwibWF4UHJvcGVydGllc1wiID8gXCJtb3JlXCIgOiBcImZld2VyXCI7XG4gICAgICAgIHJldHVybiBjb2RlZ2VuXzEuc3RyIGBtdXN0IE5PVCBoYXZlICR7Y29tcH0gdGhhbiAke3NjaGVtYUNvZGV9IGl0ZW1zYDtcbiAgICB9LFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuXyBge2xpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFtcIm1heFByb3BlcnRpZXNcIiwgXCJtaW5Qcm9wZXJ0aWVzXCJdLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGtleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGUgfSA9IGN4dDtcbiAgICAgICAgY29uc3Qgb3AgPSBrZXl3b3JkID09PSBcIm1heFByb3BlcnRpZXNcIiA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuR1QgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLkxUO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKGNvZGVnZW5fMS5fIGBPYmplY3Qua2V5cygke2RhdGF9KS5sZW5ndGggJHtvcH0gJHtzY2hlbWFDb2RlfWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXRQcm9wZXJ0aWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBtaXNzaW5nUHJvcGVydHkgfSB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBtdXN0IGhhdmUgcmVxdWlyZWQgcHJvcGVydHkgJyR7bWlzc2luZ1Byb3BlcnR5fSdgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eSB9IH0pID0+IGNvZGVnZW5fMS5fIGB7bWlzc2luZ1Byb3BlcnR5OiAke21pc3NpbmdQcm9wZXJ0eX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJyZXF1aXJlZFwiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHNjaGVtYUNvZGUsIGRhdGEsICRkYXRhLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMgfSA9IGl0O1xuICAgICAgICBpZiAoISRkYXRhICYmIHNjaGVtYS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHVzZUxvb3AgPSBzY2hlbWEubGVuZ3RoID49IG9wdHMubG9vcFJlcXVpcmVkO1xuICAgICAgICBpZiAoaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgYWxsRXJyb3JzTW9kZSgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBleGl0T25FcnJvck1vZGUoKTtcbiAgICAgICAgaWYgKG9wdHMuc3RyaWN0UmVxdWlyZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gY3h0LnBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgY29uc3QgeyBkZWZpbmVkUHJvcGVydGllcyB9ID0gY3h0Lml0O1xuICAgICAgICAgICAgZm9yIChjb25zdCByZXF1aXJlZEtleSBvZiBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHByb3BzID09PSBudWxsIHx8IHByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wc1tyZXF1aXJlZEtleV0pID09PSB1bmRlZmluZWQgJiYgIWRlZmluZWRQcm9wZXJ0aWVzLmhhcyhyZXF1aXJlZEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hUGF0aCA9IGl0LnNjaGVtYUVudi5iYXNlSWQgKyBpdC5lcnJTY2hlbWFQYXRoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBgcmVxdWlyZWQgcHJvcGVydHkgXCIke3JlcXVpcmVkS2V5fVwiIGlzIG5vdCBkZWZpbmVkIGF0IFwiJHtzY2hlbWFQYXRofVwiIChzdHJpY3RSZXF1aXJlZClgO1xuICAgICAgICAgICAgICAgICAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCBtc2csIGl0Lm9wdHMuc3RyaWN0UmVxdWlyZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhbGxFcnJvcnNNb2RlKCkge1xuICAgICAgICAgICAgaWYgKHVzZUxvb3AgfHwgJGRhdGEpIHtcbiAgICAgICAgICAgICAgICBjeHQuYmxvY2skZGF0YShjb2RlZ2VuXzEubmlsLCBsb29wQWxsUmVxdWlyZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlXzEuY2hlY2tSZXBvcnRNaXNzaW5nUHJvcChjeHQsIHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBleGl0T25FcnJvck1vZGUoKSB7XG4gICAgICAgICAgICBjb25zdCBtaXNzaW5nID0gZ2VuLmxldChcIm1pc3NpbmdcIik7XG4gICAgICAgICAgICBpZiAodXNlTG9vcCB8fCAkZGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCAoKSA9PiBsb29wVW50aWxNaXNzaW5nKG1pc3NpbmcsIHZhbGlkKSk7XG4gICAgICAgICAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlXzEuY2hlY2tNaXNzaW5nUHJvcChjeHQsIHNjaGVtYSwgbWlzc2luZykpO1xuICAgICAgICAgICAgICAgIGNvZGVfMS5yZXBvcnRNaXNzaW5nUHJvcChjeHQsIG1pc3NpbmcpO1xuICAgICAgICAgICAgICAgIGdlbi5lbHNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG9vcEFsbFJlcXVpcmVkKCkge1xuICAgICAgICAgICAgZ2VuLmZvck9mKFwicHJvcFwiLCBzY2hlbWFDb2RlLCAocHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBtaXNzaW5nUHJvcGVydHk6IHByb3AgfSk7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVfMS5ub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgb3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4gY3h0LmVycm9yKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG9vcFVudGlsTWlzc2luZyhtaXNzaW5nLCB2YWxpZCkge1xuICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IG1pc3NpbmdQcm9wZXJ0eTogbWlzc2luZyB9KTtcbiAgICAgICAgICAgIGdlbi5mb3JPZihtaXNzaW5nLCBzY2hlbWFDb2RlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgY29kZV8xLnByb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgbWlzc2luZywgb3B0cy5vd25Qcm9wZXJ0aWVzKSk7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5ub3QodmFsaWQpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGN4dC5lcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uYnJlYWsoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGNvZGVnZW5fMS5uaWwpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1aXJlZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSB7XG4gICAgICAgIGNvbnN0IGNvbXAgPSBrZXl3b3JkID09PSBcIm1heEl0ZW1zXCIgPyBcIm1vcmVcIiA6IFwiZmV3ZXJcIjtcbiAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5zdHIgYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gaXRlbXNgO1xuICAgIH0sXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+IGNvZGVnZW5fMS5fIGB7bGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogW1wibWF4SXRlbXNcIiwgXCJtaW5JdGVtc1wiXSxcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGtleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGUgfSA9IGN4dDtcbiAgICAgICAgY29uc3Qgb3AgPSBrZXl3b3JkID09PSBcIm1heEl0ZW1zXCIgPyBjb2RlZ2VuXzEub3BlcmF0b3JzLkdUIDogY29kZWdlbl8xLm9wZXJhdG9ycy5MVDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YShjb2RlZ2VuXzEuXyBgJHtkYXRhfS5sZW5ndGggJHtvcH0gJHtzY2hlbWFDb2RlfWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXRJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hanYtdmFsaWRhdG9yL2Fqdi9pc3N1ZXMvODg5XG5jb25zdCBlcXVhbCA9IHJlcXVpcmUoXCJmYXN0LWRlZXAtZXF1YWxcIik7XG5lcXVhbC5jb2RlID0gJ3JlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL2VxdWFsXCIpLmRlZmF1bHQnO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXF1YWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcXVhbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGRhdGFUeXBlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZS9kYXRhVHlwZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXF1YWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL2VxdWFsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IGksIGogfSB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBtdXN0IE5PVCBoYXZlIGR1cGxpY2F0ZSBpdGVtcyAoaXRlbXMgIyMgJHtqfSBhbmQgJHtpfSBhcmUgaWRlbnRpY2FsKWAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgaSwgaiB9IH0pID0+IGNvZGVnZW5fMS5fIGB7aTogJHtpfSwgajogJHtqfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYm9vbGVhblwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmICghJGRhdGEgJiYgIXNjaGVtYSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIik7XG4gICAgICAgIGNvbnN0IGl0ZW1UeXBlcyA9IHBhcmVudFNjaGVtYS5pdGVtcyA/IGRhdGFUeXBlXzEuZ2V0U2NoZW1hVHlwZXMocGFyZW50U2NoZW1hLml0ZW1zKSA6IFtdO1xuICAgICAgICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgdmFsaWRhdGVVbmlxdWVJdGVtcywgY29kZWdlbl8xLl8gYCR7c2NoZW1hQ29kZX0gPT09IGZhbHNlYCk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlVW5pcXVlSXRlbXMoKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gZ2VuLmxldChcImlcIiwgY29kZWdlbl8xLl8gYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgICAgICAgICBjb25zdCBqID0gZ2VuLmxldChcImpcIik7XG4gICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgaSwgaiB9KTtcbiAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2l9ID4gMWAsICgpID0+IChjYW5PcHRpbWl6ZSgpID8gbG9vcE4gOiBsb29wTjIpKGksIGopKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYW5PcHRpbWl6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtVHlwZXMubGVuZ3RoID4gMCAmJiAhaXRlbVR5cGVzLnNvbWUoKHQpID0+IHQgPT09IFwib2JqZWN0XCIgfHwgdCA9PT0gXCJhcnJheVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb29wTihpLCBqKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gZ2VuLm5hbWUoXCJpdGVtXCIpO1xuICAgICAgICAgICAgY29uc3Qgd3JvbmdUeXBlID0gZGF0YVR5cGVfMS5jaGVja0RhdGFUeXBlcyhpdGVtVHlwZXMsIGl0ZW0sIGl0Lm9wdHMuc3RyaWN0TnVtYmVycywgZGF0YVR5cGVfMS5EYXRhVHlwZS5Xcm9uZyk7XG4gICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gZ2VuLmNvbnN0KFwiaW5kaWNlc1wiLCBjb2RlZ2VuXzEuXyBge31gKTtcbiAgICAgICAgICAgIGdlbi5mb3IoY29kZWdlbl8xLl8gYDske2l9LS07YCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGdlbi5sZXQoaXRlbSwgY29kZWdlbl8xLl8gYCR7ZGF0YX1bJHtpfV1gKTtcbiAgICAgICAgICAgICAgICBnZW4uaWYod3JvbmdUeXBlLCBjb2RlZ2VuXzEuXyBgY29udGludWVgKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbVR5cGVzLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgdHlwZW9mICR7aXRlbX0gPT0gXCJzdHJpbmdcImAsIGNvZGVnZW5fMS5fIGAke2l0ZW19ICs9IFwiX1wiYCk7XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5pZihjb2RlZ2VuXzEuXyBgdHlwZW9mICR7aW5kaWNlc31bJHtpdGVtfV0gPT0gXCJudW1iZXJcImAsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihqLCBjb2RlZ2VuXzEuXyBgJHtpbmRpY2VzfVske2l0ZW19XWApO1xuICAgICAgICAgICAgICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmJyZWFrKCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNvZGUoY29kZWdlbl8xLl8gYCR7aW5kaWNlc31bJHtpdGVtfV0gPSAke2l9YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb29wTjIoaSwgaikge1xuICAgICAgICAgICAgY29uc3QgZXFsID0gdXRpbF8xLnVzZUZ1bmMoZ2VuLCBlcXVhbF8xLmRlZmF1bHQpO1xuICAgICAgICAgICAgY29uc3Qgb3V0ZXIgPSBnZW4ubmFtZShcIm91dGVyXCIpO1xuICAgICAgICAgICAgZ2VuLmxhYmVsKG91dGVyKS5mb3IoY29kZWdlbl8xLl8gYDske2l9LS07YCwgKCkgPT4gZ2VuLmZvcihjb2RlZ2VuXzEuXyBgJHtqfSA9ICR7aX07ICR7an0tLTtgLCAoKSA9PiBnZW4uaWYoY29kZWdlbl8xLl8gYCR7ZXFsfSgke2RhdGF9WyR7aX1dLCAke2RhdGF9WyR7an1dKWAsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuYnJlYWsob3V0ZXIpO1xuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5pcXVlSXRlbXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVxdWFsXzEgPSByZXF1aXJlKFwiLi4vLi4vcnVudGltZS9lcXVhbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwibXVzdCBiZSBlcXVhbCB0byBjb25zdGFudFwiLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuXyBge2FsbG93ZWRWYWx1ZTogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImNvbnN0XCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWFDb2RlLCBzY2hlbWEgfSA9IGN4dDtcbiAgICAgICAgaWYgKCRkYXRhIHx8IChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgY3h0LmZhaWwkZGF0YShjb2RlZ2VuXzEuXyBgISR7dXRpbF8xLnVzZUZ1bmMoZ2VuLCBlcXVhbF8xLmRlZmF1bHQpfSgke2RhdGF9LCAke3NjaGVtYUNvZGV9KWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3h0LmZhaWwoY29kZWdlbl8xLl8gYCR7c2NoZW1hfSAhPT0gJHtkYXRhfWApO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXF1YWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL2VxdWFsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IGJlIGVxdWFsIHRvIG9uZSBvZiB0aGUgYWxsb3dlZCB2YWx1ZXNcIixcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLl8gYHthbGxvd2VkVmFsdWVzOiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZW51bVwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKCEkZGF0YSAmJiBzY2hlbWEubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW51bSBtdXN0IGhhdmUgbm9uLWVtcHR5IGFycmF5XCIpO1xuICAgICAgICBjb25zdCB1c2VMb29wID0gc2NoZW1hLmxlbmd0aCA+PSBpdC5vcHRzLmxvb3BFbnVtO1xuICAgICAgICBjb25zdCBlcWwgPSB1dGlsXzEudXNlRnVuYyhnZW4sIGVxdWFsXzEuZGVmYXVsdCk7XG4gICAgICAgIGxldCB2YWxpZDtcbiAgICAgICAgaWYgKHVzZUxvb3AgfHwgJGRhdGEpIHtcbiAgICAgICAgICAgIHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgICAgICAgICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsIGxvb3BFbnVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICAgICAgY29uc3QgdlNjaGVtYSA9IGdlbi5jb25zdChcInZTY2hlbWFcIiwgc2NoZW1hQ29kZSk7XG4gICAgICAgICAgICB2YWxpZCA9IGNvZGVnZW5fMS5vciguLi5zY2hlbWEubWFwKChfeCwgaSkgPT4gZXF1YWxDb2RlKHZTY2hlbWEsIGkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3h0LnBhc3ModmFsaWQpO1xuICAgICAgICBmdW5jdGlvbiBsb29wRW51bSgpIHtcbiAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKTtcbiAgICAgICAgICAgIGdlbi5mb3JPZihcInZcIiwgc2NoZW1hQ29kZSwgKHYpID0+IGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtlcWx9KCR7ZGF0YX0sICR7dn0pYCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkuYnJlYWsoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVxdWFsQ29kZSh2U2NoZW1hLCBpKSB7XG4gICAgICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFbaV07XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHNjaCA9PT0gXCJvYmplY3RcIiAmJiBzY2ggIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGNvZGVnZW5fMS5fIGAke2VxbH0oJHtkYXRhfSwgJHt2U2NoZW1hfVske2l9XSlgXG4gICAgICAgICAgICAgICAgOiBjb2RlZ2VuXzEuXyBgJHtkYXRhfSA9PT0gJHtzY2h9YDtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW51bS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGxpbWl0TnVtYmVyXzEgPSByZXF1aXJlKFwiLi9saW1pdE51bWJlclwiKTtcbmNvbnN0IG11bHRpcGxlT2ZfMSA9IHJlcXVpcmUoXCIuL211bHRpcGxlT2ZcIik7XG5jb25zdCBsaW1pdExlbmd0aF8xID0gcmVxdWlyZShcIi4vbGltaXRMZW5ndGhcIik7XG5jb25zdCBwYXR0ZXJuXzEgPSByZXF1aXJlKFwiLi9wYXR0ZXJuXCIpO1xuY29uc3QgbGltaXRQcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9saW1pdFByb3BlcnRpZXNcIik7XG5jb25zdCByZXF1aXJlZF8xID0gcmVxdWlyZShcIi4vcmVxdWlyZWRcIik7XG5jb25zdCBsaW1pdEl0ZW1zXzEgPSByZXF1aXJlKFwiLi9saW1pdEl0ZW1zXCIpO1xuY29uc3QgdW5pcXVlSXRlbXNfMSA9IHJlcXVpcmUoXCIuL3VuaXF1ZUl0ZW1zXCIpO1xuY29uc3QgY29uc3RfMSA9IHJlcXVpcmUoXCIuL2NvbnN0XCIpO1xuY29uc3QgZW51bV8xID0gcmVxdWlyZShcIi4vZW51bVwiKTtcbmNvbnN0IHZhbGlkYXRpb24gPSBbXG4gICAgLy8gbnVtYmVyXG4gICAgbGltaXROdW1iZXJfMS5kZWZhdWx0LFxuICAgIG11bHRpcGxlT2ZfMS5kZWZhdWx0LFxuICAgIC8vIHN0cmluZ1xuICAgIGxpbWl0TGVuZ3RoXzEuZGVmYXVsdCxcbiAgICBwYXR0ZXJuXzEuZGVmYXVsdCxcbiAgICAvLyBvYmplY3RcbiAgICBsaW1pdFByb3BlcnRpZXNfMS5kZWZhdWx0LFxuICAgIHJlcXVpcmVkXzEuZGVmYXVsdCxcbiAgICAvLyBhcnJheVxuICAgIGxpbWl0SXRlbXNfMS5kZWZhdWx0LFxuICAgIHVuaXF1ZUl0ZW1zXzEuZGVmYXVsdCxcbiAgICAvLyBhbnlcbiAgICB7IGtleXdvcmQ6IFwidHlwZVwiLCBzY2hlbWFUeXBlOiBbXCJzdHJpbmdcIiwgXCJhcnJheVwiXSB9LFxuICAgIHsga2V5d29yZDogXCJudWxsYWJsZVwiLCBzY2hlbWFUeXBlOiBcImJvb2xlYW5cIiB9LFxuICAgIGNvbnN0XzEuZGVmYXVsdCxcbiAgICBlbnVtXzEuZGVmYXVsdCxcbl07XG5leHBvcnRzLmRlZmF1bHQgPSB2YWxpZGF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gY29kZWdlbl8xLnN0ciBgbXVzdCBOT1QgaGF2ZSBtb3JlIHRoYW4gJHtsZW59IGl0ZW1zYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBsZW4gfSB9KSA9PiBjb2RlZ2VuXzEuXyBge2xpbWl0OiAke2xlbn19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJhZGRpdGlvbmFsSXRlbXNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogW1wiYm9vbGVhblwiLCBcIm9iamVjdFwiXSxcbiAgICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBpdGVtcyB9ID0gcGFyZW50U2NoZW1hO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCAnXCJhZGRpdGlvbmFsSXRlbXNcIiBpcyBpZ25vcmVkIHdoZW4gXCJpdGVtc1wiIGlzIG5vdCBhbiBhcnJheSBvZiBzY2hlbWFzJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMoY3h0LCBpdGVtcyk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyhjeHQsIGl0ZW1zKSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICBpdC5pdGVtcyA9IHRydWU7XG4gICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsIGNvZGVnZW5fMS5fIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBsZW46IGl0ZW1zLmxlbmd0aCB9KTtcbiAgICAgICAgY3h0LnBhc3MoY29kZWdlbl8xLl8gYCR7bGVufSA8PSAke2l0ZW1zLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmICF1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4udmFyKFwidmFsaWRcIiwgY29kZWdlbl8xLl8gYCR7bGVufSA8PSAke2l0ZW1zLmxlbmd0aH1gKTsgLy8gVE9ETyB2YXJcbiAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5ub3QodmFsaWQpLCAoKSA9PiB2YWxpZGF0ZUl0ZW1zKHZhbGlkKSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXModmFsaWQpIHtcbiAgICAgICAgZ2VuLmZvclJhbmdlKFwiaVwiLCBpdGVtcy5sZW5ndGgsIGxlbiwgKGkpID0+IHtcbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoeyBrZXl3b3JkLCBkYXRhUHJvcDogaSwgZGF0YVByb3BUeXBlOiB1dGlsXzEuVHlwZS5OdW0gfSwgdmFsaWQpO1xuICAgICAgICAgICAgaWYgKCFpdC5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5ub3QodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMgPSB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcztcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZGl0aW9uYWxJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVUdXBsZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJhcnJheVwiLCBcImJvb2xlYW5cIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVUdXBsZShjeHQsIFwiYWRkaXRpb25hbEl0ZW1zXCIsIHNjaGVtYSk7XG4gICAgICAgIGl0Lml0ZW1zID0gdHJ1ZTtcbiAgICAgICAgaWYgKHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY3h0Lm9rKGNvZGVfMS52YWxpZGF0ZUFycmF5KGN4dCkpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gdmFsaWRhdGVUdXBsZShjeHQsIGV4dHJhSXRlbXMsIHNjaEFyciA9IGN4dC5zY2hlbWEpIHtcbiAgICBjb25zdCB7IGdlbiwgcGFyZW50U2NoZW1hLCBkYXRhLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgIGNoZWNrU3RyaWN0VHVwbGUocGFyZW50U2NoZW1hKTtcbiAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBzY2hBcnIubGVuZ3RoICYmIGl0Lml0ZW1zICE9PSB0cnVlKSB7XG4gICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgc2NoQXJyLmxlbmd0aCwgaXQuaXRlbXMpO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsIGNvZGVnZW5fMS5fIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgIHNjaEFyci5mb3JFYWNoKChzY2gsIGkpID0+IHtcbiAgICAgICAgaWYgKHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2xlbn0gPiAke2l9YCwgKCkgPT4gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgICAgc2NoZW1hUHJvcDogaSxcbiAgICAgICAgICAgIGRhdGFQcm9wOiBpLFxuICAgICAgICB9LCB2YWxpZCkpO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGNoZWNrU3RyaWN0VHVwbGUoc2NoKSB7XG4gICAgICAgIGNvbnN0IHsgb3B0cywgZXJyU2NoZW1hUGF0aCB9ID0gaXQ7XG4gICAgICAgIGNvbnN0IGwgPSBzY2hBcnIubGVuZ3RoO1xuICAgICAgICBjb25zdCBmdWxsVHVwbGUgPSBsID09PSBzY2gubWluSXRlbXMgJiYgKGwgPT09IHNjaC5tYXhJdGVtcyB8fCBzY2hbZXh0cmFJdGVtc10gPT09IGZhbHNlKTtcbiAgICAgICAgaWYgKG9wdHMuc3RyaWN0VHVwbGVzICYmICFmdWxsVHVwbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBcIiR7a2V5d29yZH1cIiBpcyAke2x9LXR1cGxlLCBidXQgbWluSXRlbXMgb3IgbWF4SXRlbXMvJHtleHRyYUl0ZW1zfSBhcmUgbm90IHNwZWNpZmllZCBvciBkaWZmZXJlbnQgYXQgcGF0aCBcIiR7ZXJyU2NoZW1hUGF0aH1cImA7XG4gICAgICAgICAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCBtc2csIG9wdHMuc3RyaWN0VHVwbGVzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVUdXBsZSA9IHZhbGlkYXRlVHVwbGU7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGl0ZW1zXzEgPSByZXF1aXJlKFwiLi9pdGVtc1wiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInByZWZpeEl0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcImFycmF5XCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGNvZGU6IChjeHQpID0+IGl0ZW1zXzEudmFsaWRhdGVUdXBsZShjeHQsIFwiaXRlbXNcIiksXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJlZml4SXRlbXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgYWRkaXRpb25hbEl0ZW1zXzEgPSByZXF1aXJlKFwiLi9hZGRpdGlvbmFsSXRlbXNcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gY29kZWdlbl8xLnN0ciBgbXVzdCBOT1QgaGF2ZSBtb3JlIHRoYW4gJHtsZW59IGl0ZW1zYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBsZW4gfSB9KSA9PiBjb2RlZ2VuXzEuXyBge2xpbWl0OiAke2xlbn19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4SXRlbXMgfSA9IHBhcmVudFNjaGVtYTtcbiAgICAgICAgaXQuaXRlbXMgPSB0cnVlO1xuICAgICAgICBpZiAodXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAocHJlZml4SXRlbXMpXG4gICAgICAgICAgICBhZGRpdGlvbmFsSXRlbXNfMS52YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyhjeHQsIHByZWZpeEl0ZW1zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY3h0Lm9rKGNvZGVfMS52YWxpZGF0ZUFycmF5KGN4dCkpO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXRlbXMyMDIwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbWluLCBtYXggfSB9KSA9PiBtYXggPT09IHVuZGVmaW5lZFxuICAgICAgICA/IGNvZGVnZW5fMS5zdHIgYG11c3QgY29udGFpbiBhdCBsZWFzdCAke21pbn0gdmFsaWQgaXRlbShzKWBcbiAgICAgICAgOiBjb2RlZ2VuXzEuc3RyIGBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgJHttaW59IGFuZCBubyBtb3JlIHRoYW4gJHttYXh9IHZhbGlkIGl0ZW0ocylgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IG1pbiwgbWF4IH0gfSkgPT4gbWF4ID09PSB1bmRlZmluZWQgPyBjb2RlZ2VuXzEuXyBge21pbkNvbnRhaW5zOiAke21pbn19YCA6IGNvZGVnZW5fMS5fIGB7bWluQ29udGFpbnM6ICR7bWlufSwgbWF4Q29udGFpbnM6ICR7bWF4fX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImNvbnRhaW5zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgICAgICBsZXQgbWluO1xuICAgICAgICBsZXQgbWF4O1xuICAgICAgICBjb25zdCB7IG1pbkNvbnRhaW5zLCBtYXhDb250YWlucyB9ID0gcGFyZW50U2NoZW1hO1xuICAgICAgICBpZiAoaXQub3B0cy5uZXh0KSB7XG4gICAgICAgICAgICBtaW4gPSBtaW5Db250YWlucyA9PT0gdW5kZWZpbmVkID8gMSA6IG1pbkNvbnRhaW5zO1xuICAgICAgICAgICAgbWF4ID0gbWF4Q29udGFpbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtaW4gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCBjb2RlZ2VuXzEuXyBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7IG1pbiwgbWF4IH0pO1xuICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQgJiYgbWluID09PSAwKSB7XG4gICAgICAgICAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCBgXCJtaW5Db250YWluc1wiID09IDAgd2l0aG91dCBcIm1heENvbnRhaW5zXCI6IFwiY29udGFpbnNcIiBrZXl3b3JkIGlnbm9yZWRgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQgJiYgbWluID4gbWF4KSB7XG4gICAgICAgICAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCBgXCJtaW5Db250YWluc1wiID4gXCJtYXhDb250YWluc1wiIGlzIGFsd2F5cyBpbnZhbGlkYCk7XG4gICAgICAgICAgICBjeHQuZmFpbCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGxldCBjb25kID0gY29kZWdlbl8xLl8gYCR7bGVufSA+PSAke21pbn1gO1xuICAgICAgICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbmQgPSBjb2RlZ2VuXzEuXyBgJHtjb25kfSAmJiAke2xlbn0gPD0gJHttYXh9YDtcbiAgICAgICAgICAgIGN4dC5wYXNzKGNvbmQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGl0Lml0ZW1zID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQgJiYgbWluID09PSAxKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUl0ZW1zKHZhbGlkLCAoKSA9PiBnZW4uaWYodmFsaWQsICgpID0+IGdlbi5icmVhaygpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZW4ubGV0KHZhbGlkLCBmYWxzZSk7XG4gICAgICAgICAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSBnZW4ubGV0KFwiY291bnRcIiwgMCk7XG4gICAgICAgICAgICB2YWxpZGF0ZUl0ZW1zKHNjaFZhbGlkLCAoKSA9PiBnZW4uaWYoc2NoVmFsaWQsICgpID0+IGNoZWNrTGltaXRzKGNvdW50KSkpO1xuICAgICAgICB9XG4gICAgICAgIGN4dC5yZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyhfdmFsaWQsIGJsb2NrKSB7XG4gICAgICAgICAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIDAsIGxlbiwgKGkpID0+IHtcbiAgICAgICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZDogXCJjb250YWluc1wiLFxuICAgICAgICAgICAgICAgICAgICBkYXRhUHJvcDogaSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVByb3BUeXBlOiB1dGlsXzEuVHlwZS5OdW0sXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSwgX3ZhbGlkKTtcbiAgICAgICAgICAgICAgICBibG9jaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tMaW1pdHMoY291bnQpIHtcbiAgICAgICAgICAgIGdlbi5jb2RlKGNvZGVnZW5fMS5fIGAke2NvdW50fSsrYCk7XG4gICAgICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7Y291bnR9ID49ICR7bWlufWAsICgpID0+IGdlbi5hc3NpZ24odmFsaWQsIHRydWUpLmJyZWFrKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2NvdW50fSA+ICR7bWF4fWAsICgpID0+IGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhaygpKTtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSAxKVxuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtjb3VudH0gPj0gJHttaW59YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250YWlucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVTY2hlbWFEZXBzID0gZXhwb3J0cy52YWxpZGF0ZVByb3BlcnR5RGVwcyA9IGV4cG9ydHMuZXJyb3IgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuZXhwb3J0cy5lcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgcHJvcGVydHksIGRlcHNDb3VudCwgZGVwcyB9IH0pID0+IHtcbiAgICAgICAgY29uc3QgcHJvcGVydHlfaWVzID0gZGVwc0NvdW50ID09PSAxID8gXCJwcm9wZXJ0eVwiIDogXCJwcm9wZXJ0aWVzXCI7XG4gICAgICAgIHJldHVybiBjb2RlZ2VuXzEuc3RyIGBtdXN0IGhhdmUgJHtwcm9wZXJ0eV9pZXN9ICR7ZGVwc30gd2hlbiBwcm9wZXJ0eSAke3Byb3BlcnR5fSBpcyBwcmVzZW50YDtcbiAgICB9LFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IHByb3BlcnR5LCBkZXBzQ291bnQsIGRlcHMsIG1pc3NpbmdQcm9wZXJ0eSB9IH0pID0+IGNvZGVnZW5fMS5fIGB7cHJvcGVydHk6ICR7cHJvcGVydHl9LFxuICAgIG1pc3NpbmdQcm9wZXJ0eTogJHttaXNzaW5nUHJvcGVydHl9LFxuICAgIGRlcHNDb3VudDogJHtkZXBzQ291bnR9LFxuICAgIGRlcHM6ICR7ZGVwc319YCwgLy8gVE9ETyBjaGFuZ2UgdG8gcmVmZXJlbmNlXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZGVwZW5kZW5jaWVzXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICAgIGVycm9yOiBleHBvcnRzLmVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IFtwcm9wRGVwcywgc2NoRGVwc10gPSBzcGxpdERlcGVuZGVuY2llcyhjeHQpO1xuICAgICAgICB2YWxpZGF0ZVByb3BlcnR5RGVwcyhjeHQsIHByb3BEZXBzKTtcbiAgICAgICAgdmFsaWRhdGVTY2hlbWFEZXBzKGN4dCwgc2NoRGVwcyk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBzcGxpdERlcGVuZGVuY2llcyh7IHNjaGVtYSB9KSB7XG4gICAgY29uc3QgcHJvcGVydHlEZXBzID0ge307XG4gICAgY29uc3Qgc2NoZW1hRGVwcyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBpZiAoa2V5ID09PSBcIl9fcHJvdG9fX1wiKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGRlcHMgPSBBcnJheS5pc0FycmF5KHNjaGVtYVtrZXldKSA/IHByb3BlcnR5RGVwcyA6IHNjaGVtYURlcHM7XG4gICAgICAgIGRlcHNba2V5XSA9IHNjaGVtYVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gW3Byb3BlcnR5RGVwcywgc2NoZW1hRGVwc107XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5RGVwcyhjeHQsIHByb3BlcnR5RGVwcyA9IGN4dC5zY2hlbWEpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICBpZiAoT2JqZWN0LmtleXMocHJvcGVydHlEZXBzKS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBtaXNzaW5nID0gZ2VuLmxldChcIm1pc3NpbmdcIik7XG4gICAgZm9yIChjb25zdCBwcm9wIGluIHByb3BlcnR5RGVwcykge1xuICAgICAgICBjb25zdCBkZXBzID0gcHJvcGVydHlEZXBzW3Byb3BdO1xuICAgICAgICBpZiAoZGVwcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgaGFzUHJvcGVydHkgPSBjb2RlXzEucHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpO1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHtcbiAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgZGVwc0NvdW50OiBkZXBzLmxlbmd0aCxcbiAgICAgICAgICAgIGRlcHM6IGRlcHMuam9pbihcIiwgXCIpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgICAgICAgICAgZ2VuLmlmKGhhc1Byb3BlcnR5LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkZXBQcm9wIG9mIGRlcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZV8xLmNoZWNrUmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBkZXBQcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtoYXNQcm9wZXJ0eX0gJiYgKCR7Y29kZV8xLmNoZWNrTWlzc2luZ1Byb3AoY3h0LCBkZXBzLCBtaXNzaW5nKX0pYCk7XG4gICAgICAgICAgICBjb2RlXzEucmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBtaXNzaW5nKTtcbiAgICAgICAgICAgIGdlbi5lbHNlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlUHJvcGVydHlEZXBzID0gdmFsaWRhdGVQcm9wZXJ0eURlcHM7XG5mdW5jdGlvbiB2YWxpZGF0ZVNjaGVtYURlcHMoY3h0LCBzY2hlbWFEZXBzID0gY3h0LnNjaGVtYSkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gc2NoZW1hRGVwcykge1xuICAgICAgICBpZiAodXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWFEZXBzW3Byb3BdKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBnZW4uaWYoY29kZV8xLnByb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQsIHNjaGVtYVByb3A6IHByb3AgfSwgdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoQ3h0LCB2YWxpZCk7XG4gICAgICAgIH0sICgpID0+IGdlbi52YXIodmFsaWQsIHRydWUpIC8vIFRPRE8gdmFyXG4gICAgICAgICk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVNjaGVtYURlcHMgPSB2YWxpZGF0ZVNjaGVtYURlcHM7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXBlbmRlbmNpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwicHJvcGVydHkgbmFtZSBtdXN0IGJlIHZhbGlkXCIsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXMgfSkgPT4gY29kZWdlbl8xLl8gYHtwcm9wZXJ0eU5hbWU6ICR7cGFyYW1zLnByb3BlcnR5TmFtZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJwcm9wZXJ0eU5hbWVzXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmICh1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgZ2VuLmZvckluKFwia2V5XCIsIGRhdGEsIChrZXkpID0+IHtcbiAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBwcm9wZXJ0eU5hbWU6IGtleSB9KTtcbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwicHJvcGVydHlOYW1lc1wiLFxuICAgICAgICAgICAgICAgIGRhdGE6IGtleSxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZXM6IFtcInN0cmluZ1wiXSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWU6IGtleSxcbiAgICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5ub3QodmFsaWQpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LmVycm9yKHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICBnZW4uYnJlYWsoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BlcnR5TmFtZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvbmFtZXNcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IE5PVCBoYXZlIGFkZGl0aW9uYWwgcHJvcGVydGllc1wiLFxuICAgIHBhcmFtczogKHsgcGFyYW1zIH0pID0+IGNvZGVnZW5fMS5fIGB7YWRkaXRpb25hbFByb3BlcnR5OiAke3BhcmFtcy5hZGRpdGlvbmFsUHJvcGVydHl9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIixcbiAgICB0eXBlOiBbXCJvYmplY3RcIl0sXG4gICAgc2NoZW1hVHlwZTogW1wiYm9vbGVhblwiLCBcIm9iamVjdFwiXSxcbiAgICBhbGxvd1VuZGVmaW5lZDogdHJ1ZSxcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGVycnNDb3VudCwgaXQgfSA9IGN4dDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghZXJyc0NvdW50KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICBjb25zdCB7IGFsbEVycm9ycywgb3B0cyB9ID0gaXQ7XG4gICAgICAgIGl0LnByb3BzID0gdHJ1ZTtcbiAgICAgICAgaWYgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCAhPT0gXCJhbGxcIiAmJiB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHByb3BzID0gY29kZV8xLmFsbFNjaGVtYVByb3BlcnRpZXMocGFyZW50U2NoZW1hLnByb3BlcnRpZXMpO1xuICAgICAgICBjb25zdCBwYXRQcm9wcyA9IGNvZGVfMS5hbGxTY2hlbWFQcm9wZXJ0aWVzKHBhcmVudFNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcyk7XG4gICAgICAgIGNoZWNrQWRkaXRpb25hbFByb3BlcnRpZXMoKTtcbiAgICAgICAgY3h0Lm9rKGNvZGVnZW5fMS5fIGAke2VycnNDb3VudH0gPT09ICR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc31gKTtcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tBZGRpdGlvbmFsUHJvcGVydGllcygpIHtcbiAgICAgICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wcy5sZW5ndGggJiYgIXBhdFByb3BzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnR5Q29kZShrZXkpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKGlzQWRkaXRpb25hbChrZXkpLCAoKSA9PiBhZGRpdGlvbmFsUHJvcGVydHlDb2RlKGtleSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNBZGRpdGlvbmFsKGtleSkge1xuICAgICAgICAgICAgbGV0IGRlZmluZWRQcm9wO1xuICAgICAgICAgICAgaWYgKHByb3BzLmxlbmd0aCA+IDgpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIG1heWJlIGFuIG9wdGlvbiBpbnN0ZWFkIG9mIGhhcmQtY29kZWQgOD9cbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wc1NjaGVtYSA9IHV0aWxfMS5zY2hlbWFSZWZPclZhbChpdCwgcGFyZW50U2NoZW1hLnByb3BlcnRpZXMsIFwicHJvcGVydGllc1wiKTtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9IGNvZGVfMS5pc093blByb3BlcnR5KGdlbiwgcHJvcHNTY2hlbWEsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9IGNvZGVnZW5fMS5vciguLi5wcm9wcy5tYXAoKHApID0+IGNvZGVnZW5fMS5fIGAke2tleX0gPT09ICR7cH1gKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9IGNvZGVnZW5fMS5uaWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0UHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lZFByb3AgPSBjb2RlZ2VuXzEub3IoZGVmaW5lZFByb3AsIC4uLnBhdFByb3BzLm1hcCgocCkgPT4gY29kZWdlbl8xLl8gYCR7Y29kZV8xLnVzZVBhdHRlcm4oY3h0LCBwKX0udGVzdCgke2tleX0pYCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5ub3QoZGVmaW5lZFByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlbGV0ZUFkZGl0aW9uYWwoa2V5KSB7XG4gICAgICAgICAgICBnZW4uY29kZShjb2RlZ2VuXzEuXyBgZGVsZXRlICR7ZGF0YX1bJHtrZXl9XWApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFkZGl0aW9uYWxQcm9wZXJ0eUNvZGUoa2V5KSB7XG4gICAgICAgICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImFsbFwiIHx8IChvcHRzLnJlbW92ZUFkZGl0aW9uYWwgJiYgc2NoZW1hID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGVBZGRpdGlvbmFsKGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgYWRkaXRpb25hbFByb3BlcnR5OiBrZXkgfSk7XG4gICAgICAgICAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFhbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5icmVhaygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgIXV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImZhaWxpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBhcHBseUFkZGl0aW9uYWxTY2hlbWEoa2V5LCB2YWxpZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLm5vdCh2YWxpZCksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4dC5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlQWRkaXRpb25hbChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5QWRkaXRpb25hbFNjaGVtYShrZXksIHZhbGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLm5vdCh2YWxpZCksICgpID0+IGdlbi5icmVhaygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXBwbHlBZGRpdGlvbmFsU2NoZW1hKGtleSwgdmFsaWQsIGVycm9ycykge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NoZW1hID0ge1xuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICBkYXRhUHJvcDoga2V5LFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuU3RyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChlcnJvcnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzdWJzY2hlbWEsIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoc3Vic2NoZW1hLCB2YWxpZCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZGl0aW9uYWxQcm9wZXJ0aWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgYWRkaXRpb25hbFByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL2FkZGl0aW9uYWxQcm9wZXJ0aWVzXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicHJvcGVydGllc1wiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmIChpdC5vcHRzLnJlbW92ZUFkZGl0aW9uYWwgPT09IFwiYWxsXCIgJiYgcGFyZW50U2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEuZGVmYXVsdC5jb2RlKG5ldyB2YWxpZGF0ZV8xLktleXdvcmRDeHQoaXQsIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEuZGVmYXVsdCwgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsUHJvcHMgPSBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcyhzY2hlbWEpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgYWxsUHJvcHMpIHtcbiAgICAgICAgICAgIGl0LmRlZmluZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBhbGxQcm9wcy5sZW5ndGggJiYgaXQucHJvcHMgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgdXRpbF8xLnRvSGFzaChhbGxQcm9wcyksIGl0LnByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gYWxsUHJvcHMuZmlsdGVyKChwKSA9PiAhdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWFbcF0pKTtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAoaGFzRGVmYXVsdChwcm9wKSkge1xuICAgICAgICAgICAgICAgIGFwcGx5UHJvcGVydHlTY2hlbWEocHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoY29kZV8xLnByb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSk7XG4gICAgICAgICAgICAgICAgYXBwbHlQcm9wZXJ0eVNjaGVtYShwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0LmFsbEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmVsc2UoKS52YXIodmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGdlbi5lbmRJZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3h0Lml0LmRlZmluZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFzRGVmYXVsdChwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gaXQub3B0cy51c2VEZWZhdWx0cyAmJiAhaXQuY29tcG9zaXRlUnVsZSAmJiBzY2hlbWFbcHJvcF0uZGVmYXVsdCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5UHJvcGVydHlTY2hlbWEocHJvcCkge1xuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJwcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgc2NoZW1hUHJvcDogcHJvcCxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcDogcHJvcCxcbiAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCB1dGlsXzIgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMgfSA9IGl0O1xuICAgICAgICBjb25zdCBwYXR0ZXJucyA9IGNvZGVfMS5hbGxTY2hlbWFQcm9wZXJ0aWVzKHNjaGVtYSk7XG4gICAgICAgIGNvbnN0IGFsd2F5c1ZhbGlkUGF0dGVybnMgPSBwYXR0ZXJucy5maWx0ZXIoKHApID0+IHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hW3BdKSk7XG4gICAgICAgIGlmIChwYXR0ZXJucy5sZW5ndGggPT09IDAgfHxcbiAgICAgICAgICAgIChhbHdheXNWYWxpZFBhdHRlcm5zLmxlbmd0aCA9PT0gcGF0dGVybnMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgKCFpdC5vcHRzLnVuZXZhbHVhdGVkIHx8IGl0LnByb3BzID09PSB0cnVlKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGVja1Byb3BlcnRpZXMgPSBvcHRzLnN0cmljdFNjaGVtYSAmJiAhb3B0cy5hbGxvd01hdGNoaW5nUHJvcGVydGllcyAmJiBwYXJlbnRTY2hlbWEucHJvcGVydGllcztcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBpZiAoaXQucHJvcHMgIT09IHRydWUgJiYgIShpdC5wcm9wcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKSkge1xuICAgICAgICAgICAgaXQucHJvcHMgPSB1dGlsXzIuZXZhbHVhdGVkUHJvcHNUb05hbWUoZ2VuLCBpdC5wcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gaXQ7XG4gICAgICAgIHZhbGlkYXRlUGF0dGVyblByb3BlcnRpZXMoKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVQYXR0ZXJuUHJvcGVydGllcygpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGF0IG9mIHBhdHRlcm5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrUHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tNYXRjaGluZ1Byb3BlcnRpZXMocGF0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLnZhcih2YWxpZCwgdHJ1ZSk7IC8vIFRPRE8gdmFyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uaWYodmFsaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGVja01hdGNoaW5nUHJvcGVydGllcyhwYXQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBjaGVja1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3IFJlZ0V4cChwYXQpLnRlc3QocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZShpdCwgYHByb3BlcnR5ICR7cHJvcH0gbWF0Y2hlcyBwYXR0ZXJuICR7cGF0fSAodXNlIGFsbG93TWF0Y2hpbmdQcm9wZXJ0aWVzKWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMocGF0KSB7XG4gICAgICAgICAgICBnZW4uZm9ySW4oXCJrZXlcIiwgZGF0YSwgKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtjb2RlXzEudXNlUGF0dGVybihjeHQsIHBhdCl9LnRlc3QoJHtrZXl9KWAsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWx3YXlzVmFsaWQgPSBhbHdheXNWYWxpZFBhdHRlcm5zLmluY2x1ZGVzKHBhdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWx3YXlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFQcm9wOiBwYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByb3A6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IHV0aWxfMi5UeXBlLlN0cixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBwcm9wcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHtwcm9wc31bJHtrZXl9XWAsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFhbHdheXNWYWxpZCAmJiAhaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW4gc2hvcnQtY2lyY3VpdCBpZiBgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzYCBpcyBub3Qgc3VwcG9ydGVkIChvcHRzLm5leHQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3IgaWYgYWxsIHByb3BlcnRpZXMgd2VyZSBldmFsdWF0ZWQgKHByb3BzID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5ub3QodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXR0ZXJuUHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJub3RcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmICh1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGN4dC5mYWlsKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgIGtleXdvcmQ6IFwibm90XCIsXG4gICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgIGFsbEVycm9yczogZmFsc2UsXG4gICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgY3h0LmZhaWxSZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IoKSk7XG4gICAgfSxcbiAgICBlcnJvcjogeyBtZXNzYWdlOiBcIm11c3QgTk9UIGJlIHZhbGlkXCIgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImFueU9mXCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGNvZGU6IGNvZGVfMS52YWxpZGF0ZVVuaW9uLFxuICAgIGVycm9yOiB7IG1lc3NhZ2U6IFwibXVzdCBtYXRjaCBhIHNjaGVtYSBpbiBhbnlPZlwiIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW55T2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwibXVzdCBtYXRjaCBleGFjdGx5IG9uZSBzY2hlbWEgaW4gb25lT2ZcIixcbiAgICBwYXJhbXM6ICh7IHBhcmFtcyB9KSA9PiBjb2RlZ2VuXzEuXyBge3Bhc3NpbmdTY2hlbWFzOiAke3BhcmFtcy5wYXNzaW5nfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIm9uZU9mXCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICBpZiAoaXQub3B0cy5kaXNjcmltaW5hdG9yICYmIHBhcmVudFNjaGVtYS5kaXNjcmltaW5hdG9yKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBzY2hBcnIgPSBzY2hlbWE7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIGZhbHNlKTtcbiAgICAgICAgY29uc3QgcGFzc2luZyA9IGdlbi5sZXQoXCJwYXNzaW5nXCIsIG51bGwpO1xuICAgICAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHsgcGFzc2luZyB9KTtcbiAgICAgICAgLy8gVE9ETyBwb3NzaWJseSBmYWlsIHN0cmFpZ2h0IGF3YXkgKHdpdGggd2FybmluZyBvciBleGNlcHRpb24pIGlmIHRoZXJlIGFyZSB0d28gZW1wdHkgYWx3YXlzIHZhbGlkIHNjaGVtYXNcbiAgICAgICAgZ2VuLmJsb2NrKHZhbGlkYXRlT25lT2YpO1xuICAgICAgICBjeHQucmVzdWx0KHZhbGlkLCAoKSA9PiBjeHQucmVzZXQoKSwgKCkgPT4gY3h0LmVycm9yKHRydWUpKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVPbmVPZigpIHtcbiAgICAgICAgICAgIHNjaEFyci5mb3JFYWNoKChzY2gsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgc2NoQ3h0O1xuICAgICAgICAgICAgICAgIGlmICh1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLnZhcihzY2hWYWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwib25lT2ZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYVByb3A6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9LCBzY2hWYWxpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC5pZihjb2RlZ2VuXzEuXyBgJHtzY2hWYWxpZH0gJiYgJHt2YWxpZH1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFzc2lnbih2YWxpZCwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXNzaWduKHBhc3NpbmcsIGNvZGVnZW5fMS5fIGBbJHtwYXNzaW5nfSwgJHtpfV1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmVsc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2VuLmlmKHNjaFZhbGlkLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHBhc3NpbmcsIGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoQ3h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCwgY29kZWdlbl8xLk5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uZU9mLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImFsbE9mXCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBzY2hlbWEuZm9yRWFjaCgoc2NoLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAodXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2gpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoeyBrZXl3b3JkOiBcImFsbE9mXCIsIHNjaGVtYVByb3A6IGkgfSwgdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQpO1xuICAgICAgICB9KTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFsbE9mLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXMgfSkgPT4gY29kZWdlbl8xLnN0ciBgbXVzdCBtYXRjaCBcIiR7cGFyYW1zLmlmQ2xhdXNlfVwiIHNjaGVtYWAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXMgfSkgPT4gY29kZWdlbl8xLl8gYHtmYWlsaW5nS2V5d29yZDogJHtwYXJhbXMuaWZDbGF1c2V9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiaWZcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmIChwYXJlbnRTY2hlbWEudGhlbiA9PT0gdW5kZWZpbmVkICYmIHBhcmVudFNjaGVtYS5lbHNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHV0aWxfMS5jaGVja1N0cmljdE1vZGUoaXQsICdcImlmXCIgd2l0aG91dCBcInRoZW5cIiBhbmQgXCJlbHNlXCIgaXMgaWdub3JlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc1RoZW4gPSBoYXNTY2hlbWEoaXQsIFwidGhlblwiKTtcbiAgICAgICAgY29uc3QgaGFzRWxzZSA9IGhhc1NjaGVtYShpdCwgXCJlbHNlXCIpO1xuICAgICAgICBpZiAoIWhhc1RoZW4gJiYgIWhhc0Vsc2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpO1xuICAgICAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgICAgICB2YWxpZGF0ZUlmKCk7XG4gICAgICAgIGN4dC5yZXNldCgpO1xuICAgICAgICBpZiAoaGFzVGhlbiAmJiBoYXNFbHNlKSB7XG4gICAgICAgICAgICBjb25zdCBpZkNsYXVzZSA9IGdlbi5sZXQoXCJpZkNsYXVzZVwiKTtcbiAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBpZkNsYXVzZSB9KTtcbiAgICAgICAgICAgIGdlbi5pZihzY2hWYWxpZCwgdmFsaWRhdGVDbGF1c2UoXCJ0aGVuXCIsIGlmQ2xhdXNlKSwgdmFsaWRhdGVDbGF1c2UoXCJlbHNlXCIsIGlmQ2xhdXNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzVGhlbikge1xuICAgICAgICAgICAgZ2VuLmlmKHNjaFZhbGlkLCB2YWxpZGF0ZUNsYXVzZShcInRoZW5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5ub3Qoc2NoVmFsaWQpLCB2YWxpZGF0ZUNsYXVzZShcImVsc2VcIikpO1xuICAgICAgICB9XG4gICAgICAgIGN4dC5wYXNzKHZhbGlkLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUlmKCkge1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJpZlwiLFxuICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhbGxFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgfSwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVDbGF1c2Uoa2V5d29yZCwgaWZDbGF1c2UpIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQgfSwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHNjaFZhbGlkKTtcbiAgICAgICAgICAgICAgICBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHZhbGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoaWZDbGF1c2UpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oaWZDbGF1c2UsIGNvZGVnZW5fMS5fIGAke2tleXdvcmR9YCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgaWZDbGF1c2U6IGtleXdvcmQgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcbn07XG5mdW5jdGlvbiBoYXNTY2hlbWEoaXQsIGtleXdvcmQpIHtcbiAgICBjb25zdCBzY2hlbWEgPSBpdC5zY2hlbWFba2V5d29yZF07XG4gICAgcmV0dXJuIHNjaGVtYSAhPT0gdW5kZWZpbmVkICYmICF1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogW1widGhlblwiLCBcImVsc2VcIl0sXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICBjb2RlKHsga2V5d29yZCwgcGFyZW50U2NoZW1hLCBpdCB9KSB7XG4gICAgICAgIGlmIChwYXJlbnRTY2hlbWEuaWYgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHV0aWxfMS5jaGVja1N0cmljdE1vZGUoaXQsIGBcIiR7a2V5d29yZH1cIiB3aXRob3V0IFwiaWZcIiBpcyBpZ25vcmVkYCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aGVuRWxzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGFkZGl0aW9uYWxJdGVtc18xID0gcmVxdWlyZShcIi4vYWRkaXRpb25hbEl0ZW1zXCIpO1xuY29uc3QgcHJlZml4SXRlbXNfMSA9IHJlcXVpcmUoXCIuL3ByZWZpeEl0ZW1zXCIpO1xuY29uc3QgaXRlbXNfMSA9IHJlcXVpcmUoXCIuL2l0ZW1zXCIpO1xuY29uc3QgaXRlbXMyMDIwXzEgPSByZXF1aXJlKFwiLi9pdGVtczIwMjBcIik7XG5jb25zdCBjb250YWluc18xID0gcmVxdWlyZShcIi4vY29udGFpbnNcIik7XG5jb25zdCBkZXBlbmRlbmNpZXNfMSA9IHJlcXVpcmUoXCIuL2RlcGVuZGVuY2llc1wiKTtcbmNvbnN0IHByb3BlcnR5TmFtZXNfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnR5TmFtZXNcIik7XG5jb25zdCBhZGRpdGlvbmFsUHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vYWRkaXRpb25hbFByb3BlcnRpZXNcIik7XG5jb25zdCBwcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9wcm9wZXJ0aWVzXCIpO1xuY29uc3QgcGF0dGVyblByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL3BhdHRlcm5Qcm9wZXJ0aWVzXCIpO1xuY29uc3Qgbm90XzEgPSByZXF1aXJlKFwiLi9ub3RcIik7XG5jb25zdCBhbnlPZl8xID0gcmVxdWlyZShcIi4vYW55T2ZcIik7XG5jb25zdCBvbmVPZl8xID0gcmVxdWlyZShcIi4vb25lT2ZcIik7XG5jb25zdCBhbGxPZl8xID0gcmVxdWlyZShcIi4vYWxsT2ZcIik7XG5jb25zdCBpZl8xID0gcmVxdWlyZShcIi4vaWZcIik7XG5jb25zdCB0aGVuRWxzZV8xID0gcmVxdWlyZShcIi4vdGhlbkVsc2VcIik7XG5mdW5jdGlvbiBnZXRBcHBsaWNhdG9yKGRyYWZ0MjAyMCA9IGZhbHNlKSB7XG4gICAgY29uc3QgYXBwbGljYXRvciA9IFtcbiAgICAgICAgLy8gYW55XG4gICAgICAgIG5vdF8xLmRlZmF1bHQsXG4gICAgICAgIGFueU9mXzEuZGVmYXVsdCxcbiAgICAgICAgb25lT2ZfMS5kZWZhdWx0LFxuICAgICAgICBhbGxPZl8xLmRlZmF1bHQsXG4gICAgICAgIGlmXzEuZGVmYXVsdCxcbiAgICAgICAgdGhlbkVsc2VfMS5kZWZhdWx0LFxuICAgICAgICAvLyBvYmplY3RcbiAgICAgICAgcHJvcGVydHlOYW1lc18xLmRlZmF1bHQsXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICAgICAgZGVwZW5kZW5jaWVzXzEuZGVmYXVsdCxcbiAgICAgICAgcHJvcGVydGllc18xLmRlZmF1bHQsXG4gICAgICAgIHBhdHRlcm5Qcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICBdO1xuICAgIC8vIGFycmF5XG4gICAgaWYgKGRyYWZ0MjAyMClcbiAgICAgICAgYXBwbGljYXRvci5wdXNoKHByZWZpeEl0ZW1zXzEuZGVmYXVsdCwgaXRlbXMyMDIwXzEuZGVmYXVsdCk7XG4gICAgZWxzZVxuICAgICAgICBhcHBsaWNhdG9yLnB1c2goYWRkaXRpb25hbEl0ZW1zXzEuZGVmYXVsdCwgaXRlbXNfMS5kZWZhdWx0KTtcbiAgICBhcHBsaWNhdG9yLnB1c2goY29udGFpbnNfMS5kZWZhdWx0KTtcbiAgICByZXR1cm4gYXBwbGljYXRvcjtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGdldEFwcGxpY2F0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBzY2hlbWFDb2RlIH0pID0+IGNvZGVnZW5fMS5zdHIgYG11c3QgbWF0Y2ggZm9ybWF0IFwiJHtzY2hlbWFDb2RlfVwiYCxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLl8gYHtmb3JtYXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJmb3JtYXRcIixcbiAgICB0eXBlOiBbXCJudW1iZXJcIiwgXCJzdHJpbmdcIl0sXG4gICAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCwgcnVsZVR5cGUpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgb3B0cywgZXJyU2NoZW1hUGF0aCwgc2NoZW1hRW52LCBzZWxmIH0gPSBpdDtcbiAgICAgICAgaWYgKCFvcHRzLnZhbGlkYXRlRm9ybWF0cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCRkYXRhKVxuICAgICAgICAgICAgdmFsaWRhdGUkRGF0YUZvcm1hdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2YWxpZGF0ZUZvcm1hdCgpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZSREYXRhRm9ybWF0KCkge1xuICAgICAgICAgICAgY29uc3QgZm10cyA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7XG4gICAgICAgICAgICAgICAgcmVmOiBzZWxmLmZvcm1hdHMsXG4gICAgICAgICAgICAgICAgY29kZTogb3B0cy5jb2RlLmZvcm1hdHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGZEZWYgPSBnZW4uY29uc3QoXCJmRGVmXCIsIGNvZGVnZW5fMS5fIGAke2ZtdHN9WyR7c2NoZW1hQ29kZX1dYCk7XG4gICAgICAgICAgICBjb25zdCBmVHlwZSA9IGdlbi5sZXQoXCJmVHlwZVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IGdlbi5sZXQoXCJmb3JtYXRcIik7XG4gICAgICAgICAgICAvLyBUT0RPIHNpbXBsaWZ5XG4gICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYHR5cGVvZiAke2ZEZWZ9ID09IFwib2JqZWN0XCIgJiYgISgke2ZEZWZ9IGluc3RhbmNlb2YgUmVnRXhwKWAsICgpID0+IGdlbi5hc3NpZ24oZlR5cGUsIGNvZGVnZW5fMS5fIGAke2ZEZWZ9LnR5cGUgfHwgXCJzdHJpbmdcImApLmFzc2lnbihmb3JtYXQsIGNvZGVnZW5fMS5fIGAke2ZEZWZ9LnZhbGlkYXRlYCksICgpID0+IGdlbi5hc3NpZ24oZlR5cGUsIGNvZGVnZW5fMS5fIGBcInN0cmluZ1wiYCkuYXNzaWduKGZvcm1hdCwgZkRlZikpO1xuICAgICAgICAgICAgY3h0LmZhaWwkZGF0YShjb2RlZ2VuXzEub3IodW5rbm93bkZtdCgpLCBpbnZhbGlkRm10KCkpKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHVua25vd25GbXQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMuc3RyaWN0U2NoZW1hID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5uaWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5fIGAke3NjaGVtYUNvZGV9ICYmICEke2Zvcm1hdH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gaW52YWxpZEZtdCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsRm9ybWF0ID0gc2NoZW1hRW52LiRhc3luY1xuICAgICAgICAgICAgICAgICAgICA/IGNvZGVnZW5fMS5fIGAoJHtmRGVmfS5hc3luYyA/IGF3YWl0ICR7Zm9ybWF0fSgke2RhdGF9KSA6ICR7Zm9ybWF0fSgke2RhdGF9KSlgXG4gICAgICAgICAgICAgICAgICAgIDogY29kZWdlbl8xLl8gYCR7Zm9ybWF0fSgke2RhdGF9KWA7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWREYXRhID0gY29kZWdlbl8xLl8gYCh0eXBlb2YgJHtmb3JtYXR9ID09IFwiZnVuY3Rpb25cIiA/ICR7Y2FsbEZvcm1hdH0gOiAke2Zvcm1hdH0udGVzdCgke2RhdGF9KSlgO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgJHtmb3JtYXR9ICYmICR7Zm9ybWF0fSAhPT0gdHJ1ZSAmJiAke2ZUeXBlfSA9PT0gJHtydWxlVHlwZX0gJiYgISR7dmFsaWREYXRhfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoKSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXREZWYgPSBzZWxmLmZvcm1hdHNbc2NoZW1hXTtcbiAgICAgICAgICAgIGlmICghZm9ybWF0RGVmKSB7XG4gICAgICAgICAgICAgICAgdW5rbm93bkZvcm1hdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXREZWYgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgW2ZtdFR5cGUsIGZvcm1hdCwgZm10UmVmXSA9IGdldEZvcm1hdChmb3JtYXREZWYpO1xuICAgICAgICAgICAgaWYgKGZtdFR5cGUgPT09IHJ1bGVUeXBlKVxuICAgICAgICAgICAgICAgIGN4dC5wYXNzKHZhbGlkQ29uZGl0aW9uKCkpO1xuICAgICAgICAgICAgZnVuY3Rpb24gdW5rbm93bkZvcm1hdCgpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5zdHJpY3RTY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubG9nZ2VyLndhcm4odW5rbm93bk1zZygpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodW5rbm93bk1zZygpKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1bmtub3duTXNnKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYHVua25vd24gZm9ybWF0IFwiJHtzY2hlbWF9XCIgaWdub3JlZCBpbiBzY2hlbWEgYXQgcGF0aCBcIiR7ZXJyU2NoZW1hUGF0aH1cImA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Rm9ybWF0KGZtdERlZikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBmbXREZWYgaW5zdGFuY2VvZiBSZWdFeHBcbiAgICAgICAgICAgICAgICAgICAgPyBjb2RlZ2VuXzEucmVnZXhwQ29kZShmbXREZWYpXG4gICAgICAgICAgICAgICAgICAgIDogb3B0cy5jb2RlLmZvcm1hdHNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29kZWdlbl8xLl8gYCR7b3B0cy5jb2RlLmZvcm1hdHN9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkoc2NoZW1hKX1gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBjb25zdCBmbXQgPSBnZW4uc2NvcGVWYWx1ZShcImZvcm1hdHNcIiwgeyBrZXk6IHNjaGVtYSwgcmVmOiBmbXREZWYsIGNvZGUgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbXREZWYgPT0gXCJvYmplY3RcIiAmJiAhKGZtdERlZiBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtmbXREZWYudHlwZSB8fCBcInN0cmluZ1wiLCBmbXREZWYudmFsaWRhdGUsIGNvZGVnZW5fMS5fIGAke2ZtdH0udmFsaWRhdGVgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcInN0cmluZ1wiLCBmbXREZWYsIGZtdF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiB2YWxpZENvbmRpdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdERlZiA9PSBcIm9iamVjdFwiICYmICEoZm9ybWF0RGVmIGluc3RhbmNlb2YgUmVnRXhwKSAmJiBmb3JtYXREZWYuYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzY2hlbWFFbnYuJGFzeW5jKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMgZm9ybWF0IGluIHN5bmMgc2NoZW1hXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLl8gYGF3YWl0ICR7Zm10UmVmfSgke2RhdGF9KWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZm9ybWF0ID09IFwiZnVuY3Rpb25cIiA/IGNvZGVnZW5fMS5fIGAke2ZtdFJlZn0oJHtkYXRhfSlgIDogY29kZWdlbl8xLl8gYCR7Zm10UmVmfS50ZXN0KCR7ZGF0YX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZm9ybWF0XzEgPSByZXF1aXJlKFwiLi9mb3JtYXRcIik7XG5jb25zdCBmb3JtYXQgPSBbZm9ybWF0XzEuZGVmYXVsdF07XG5leHBvcnRzLmRlZmF1bHQgPSBmb3JtYXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29udGVudFZvY2FidWxhcnkgPSBleHBvcnRzLm1ldGFkYXRhVm9jYWJ1bGFyeSA9IHZvaWQgMDtcbmV4cG9ydHMubWV0YWRhdGFWb2NhYnVsYXJ5ID0gW1xuICAgIFwidGl0bGVcIixcbiAgICBcImRlc2NyaXB0aW9uXCIsXG4gICAgXCJkZWZhdWx0XCIsXG4gICAgXCJkZXByZWNhdGVkXCIsXG4gICAgXCJyZWFkT25seVwiLFxuICAgIFwid3JpdGVPbmx5XCIsXG4gICAgXCJleGFtcGxlc1wiLFxuXTtcbmV4cG9ydHMuY29udGVudFZvY2FidWxhcnkgPSBbXG4gICAgXCJjb250ZW50TWVkaWFUeXBlXCIsXG4gICAgXCJjb250ZW50RW5jb2RpbmdcIixcbiAgICBcImNvbnRlbnRTY2hlbWFcIixcbl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRhZGF0YS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5jb25zdCB2YWxpZGF0aW9uXzEgPSByZXF1aXJlKFwiLi92YWxpZGF0aW9uXCIpO1xuY29uc3QgYXBwbGljYXRvcl8xID0gcmVxdWlyZShcIi4vYXBwbGljYXRvclwiKTtcbmNvbnN0IGZvcm1hdF8xID0gcmVxdWlyZShcIi4vZm9ybWF0XCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgZHJhZnQ3Vm9jYWJ1bGFyaWVzID0gW1xuICAgIGNvcmVfMS5kZWZhdWx0LFxuICAgIHZhbGlkYXRpb25fMS5kZWZhdWx0LFxuICAgIGFwcGxpY2F0b3JfMS5kZWZhdWx0KCksXG4gICAgZm9ybWF0XzEuZGVmYXVsdCxcbiAgICBtZXRhZGF0YV8xLm1ldGFkYXRhVm9jYWJ1bGFyeSxcbiAgICBtZXRhZGF0YV8xLmNvbnRlbnRWb2NhYnVsYXJ5LFxuXTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRyYWZ0N1ZvY2FidWxhcmllcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyYWZ0Ny5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGlzY3JFcnJvciA9IHZvaWQgMDtcbnZhciBEaXNjckVycm9yO1xuKGZ1bmN0aW9uIChEaXNjckVycm9yKSB7XG4gICAgRGlzY3JFcnJvcltcIlRhZ1wiXSA9IFwidGFnXCI7XG4gICAgRGlzY3JFcnJvcltcIk1hcHBpbmdcIl0gPSBcIm1hcHBpbmdcIjtcbn0pKERpc2NyRXJyb3IgPSBleHBvcnRzLkRpc2NyRXJyb3IgfHwgKGV4cG9ydHMuRGlzY3JFcnJvciA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uL2Rpc2NyaW1pbmF0b3IvdHlwZXNcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgZGlzY3JFcnJvciwgdGFnTmFtZSB9IH0pID0+IGRpc2NyRXJyb3IgPT09IHR5cGVzXzEuRGlzY3JFcnJvci5UYWdcbiAgICAgICAgPyBgdGFnIFwiJHt0YWdOYW1lfVwiIG11c3QgYmUgc3RyaW5nYFxuICAgICAgICA6IGB2YWx1ZSBvZiB0YWcgXCIke3RhZ05hbWV9XCIgbXVzdCBiZSBpbiBvbmVPZmAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgZGlzY3JFcnJvciwgdGFnLCB0YWdOYW1lIH0gfSkgPT4gY29kZWdlbl8xLl8gYHtlcnJvcjogJHtkaXNjckVycm9yfSwgdGFnOiAke3RhZ05hbWV9LCB0YWdWYWx1ZTogJHt0YWd9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZGlzY3JpbWluYXRvclwiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgb25lT2YgfSA9IHBhcmVudFNjaGVtYTtcbiAgICAgICAgaWYgKCFpdC5vcHRzLmRpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRpc2NyaW1pbmF0b3I6IHJlcXVpcmVzIGRpc2NyaW1pbmF0b3Igb3B0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSBzY2hlbWEucHJvcGVydHlOYW1lO1xuICAgICAgICBpZiAodHlwZW9mIHRhZ05hbWUgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRpc2NyaW1pbmF0b3I6IHJlcXVpcmVzIHByb3BlcnR5TmFtZVwiKTtcbiAgICAgICAgaWYgKHNjaGVtYS5tYXBwaW5nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogbWFwcGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICBpZiAoIW9uZU9mKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgb25lT2Yga2V5d29yZFwiKTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgZmFsc2UpO1xuICAgICAgICBjb25zdCB0YWcgPSBnZW4uY29uc3QoXCJ0YWdcIiwgY29kZWdlbl8xLl8gYCR7ZGF0YX0ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eSh0YWdOYW1lKX1gKTtcbiAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGB0eXBlb2YgJHt0YWd9ID09IFwic3RyaW5nXCJgLCAoKSA9PiB2YWxpZGF0ZU1hcHBpbmcoKSwgKCkgPT4gY3h0LmVycm9yKGZhbHNlLCB7IGRpc2NyRXJyb3I6IHR5cGVzXzEuRGlzY3JFcnJvci5UYWcsIHRhZywgdGFnTmFtZSB9KSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlTWFwcGluZygpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcHBpbmcgPSBnZXRNYXBwaW5nKCk7XG4gICAgICAgICAgICBnZW4uaWYoZmFsc2UpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0YWdWYWx1ZSBpbiBtYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgZ2VuLmVsc2VJZihjb2RlZ2VuXzEuXyBgJHt0YWd9ID09PSAke3RhZ1ZhbHVlfWApO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGFwcGx5VGFnU2NoZW1hKG1hcHBpbmdbdGFnVmFsdWVdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZW4uZWxzZSgpO1xuICAgICAgICAgICAgY3h0LmVycm9yKGZhbHNlLCB7IGRpc2NyRXJyb3I6IHR5cGVzXzEuRGlzY3JFcnJvci5NYXBwaW5nLCB0YWcsIHRhZ05hbWUgfSk7XG4gICAgICAgICAgICBnZW4uZW5kSWYoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcHBseVRhZ1NjaGVtYShzY2hlbWFQcm9wKSB7XG4gICAgICAgICAgICBjb25zdCBfdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQ6IFwib25lT2ZcIiwgc2NoZW1hUHJvcCB9LCBfdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCwgY29kZWdlbl8xLk5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIF92YWxpZDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRNYXBwaW5nKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3Qgb25lT2ZNYXBwaW5nID0ge307XG4gICAgICAgICAgICBjb25zdCB0b3BSZXF1aXJlZCA9IGhhc1JlcXVpcmVkKHBhcmVudFNjaGVtYSk7XG4gICAgICAgICAgICBsZXQgdGFnUmVxdWlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvbmVPZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaCA9IG9uZU9mW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BTY2ggPSAoX2EgPSBzY2gucHJvcGVydGllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3RhZ05hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcFNjaCAhPSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogb25lT2Ygc2NoZW1hcyBtdXN0IGhhdmUgXCJwcm9wZXJ0aWVzLyR7dGFnTmFtZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YWdSZXF1aXJlZCA9IHRhZ1JlcXVpcmVkICYmICh0b3BSZXF1aXJlZCB8fCBoYXNSZXF1aXJlZChzY2gpKTtcbiAgICAgICAgICAgICAgICBhZGRNYXBwaW5ncyhwcm9wU2NoLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGFnUmVxdWlyZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBcIiR7dGFnTmFtZX1cIiBtdXN0IGJlIHJlcXVpcmVkYCk7XG4gICAgICAgICAgICByZXR1cm4gb25lT2ZNYXBwaW5nO1xuICAgICAgICAgICAgZnVuY3Rpb24gaGFzUmVxdWlyZWQoeyByZXF1aXJlZCB9KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocmVxdWlyZWQpICYmIHJlcXVpcmVkLmluY2x1ZGVzKHRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkTWFwcGluZ3Moc2NoLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaC5jb25zdCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRNYXBwaW5nKHNjaC5jb25zdCwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaC5lbnVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdGFnVmFsdWUgb2Ygc2NoLmVudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1hcHBpbmcodGFnVmFsdWUsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IFwicHJvcGVydGllcy8ke3RhZ05hbWV9XCIgbXVzdCBoYXZlIFwiY29uc3RcIiBvciBcImVudW1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmcodGFnVmFsdWUsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhZ1ZhbHVlICE9IFwic3RyaW5nXCIgfHwgdGFnVmFsdWUgaW4gb25lT2ZNYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogXCIke3RhZ05hbWV9XCIgdmFsdWVzIG11c3QgYmUgdW5pcXVlIHN0cmluZ3NgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25lT2ZNYXBwaW5nW3RhZ1ZhbHVlXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db2RlR2VuID0gZXhwb3J0cy5OYW1lID0gZXhwb3J0cy5uaWwgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyID0gZXhwb3J0cy5fID0gZXhwb3J0cy5LZXl3b3JkQ3h0ID0gdm9pZCAwO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbmNvbnN0IGRyYWZ0N18xID0gcmVxdWlyZShcIi4vdm9jYWJ1bGFyaWVzL2RyYWZ0N1wiKTtcbmNvbnN0IGRpc2NyaW1pbmF0b3JfMSA9IHJlcXVpcmUoXCIuL3ZvY2FidWxhcmllcy9kaXNjcmltaW5hdG9yXCIpO1xuY29uc3QgZHJhZnQ3TWV0YVNjaGVtYSA9IHJlcXVpcmUoXCIuL3JlZnMvanNvbi1zY2hlbWEtZHJhZnQtMDcuanNvblwiKTtcbmNvbnN0IE1FVEFfU1VQUE9SVF9EQVRBID0gW1wiL3Byb3BlcnRpZXNcIl07XG5jb25zdCBNRVRBX1NDSEVNQV9JRCA9IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWFcIjtcbmNsYXNzIEFqdiBleHRlbmRzIGNvcmVfMS5kZWZhdWx0IHtcbiAgICBfYWRkVm9jYWJ1bGFyaWVzKCkge1xuICAgICAgICBzdXBlci5fYWRkVm9jYWJ1bGFyaWVzKCk7XG4gICAgICAgIGRyYWZ0N18xLmRlZmF1bHQuZm9yRWFjaCgodikgPT4gdGhpcy5hZGRWb2NhYnVsYXJ5KHYpKTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5kaXNjcmltaW5hdG9yKVxuICAgICAgICAgICAgdGhpcy5hZGRLZXl3b3JkKGRpc2NyaW1pbmF0b3JfMS5kZWZhdWx0KTtcbiAgICB9XG4gICAgX2FkZERlZmF1bHRNZXRhU2NoZW1hKCkge1xuICAgICAgICBzdXBlci5fYWRkRGVmYXVsdE1ldGFTY2hlbWEoKTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdHMubWV0YSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbWV0YVNjaGVtYSA9IHRoaXMub3B0cy4kZGF0YVxuICAgICAgICAgICAgPyB0aGlzLiRkYXRhTWV0YVNjaGVtYShkcmFmdDdNZXRhU2NoZW1hLCBNRVRBX1NVUFBPUlRfREFUQSlcbiAgICAgICAgICAgIDogZHJhZnQ3TWV0YVNjaGVtYTtcbiAgICAgICAgdGhpcy5hZGRNZXRhU2NoZW1hKG1ldGFTY2hlbWEsIE1FVEFfU0NIRU1BX0lELCBmYWxzZSk7XG4gICAgICAgIHRoaXMucmVmc1tcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvc2NoZW1hXCJdID0gTUVUQV9TQ0hFTUFfSUQ7XG4gICAgfVxuICAgIGRlZmF1bHRNZXRhKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMub3B0cy5kZWZhdWx0TWV0YSA9XG4gICAgICAgICAgICBzdXBlci5kZWZhdWx0TWV0YSgpIHx8ICh0aGlzLmdldFNjaGVtYShNRVRBX1NDSEVNQV9JRCkgPyBNRVRBX1NDSEVNQV9JRCA6IHVuZGVmaW5lZCkpO1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEFqdjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEFqdjtcbnZhciB2YWxpZGF0ZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS92YWxpZGF0ZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIktleXdvcmRDeHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRlXzEuS2V5d29yZEN4dDsgfSB9KTtcbnZhciBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL2NvZGVnZW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuXzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0clwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cmluZ2lmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5pbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLm5pbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5OYW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29kZUdlblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLkNvZGVHZW47IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hanYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZvcm1hdE5hbWVzID0gZXhwb3J0cy5mYXN0Rm9ybWF0cyA9IGV4cG9ydHMuZnVsbEZvcm1hdHMgPSB2b2lkIDA7XG5mdW5jdGlvbiBmbXREZWYodmFsaWRhdGUsIGNvbXBhcmUpIHtcbiAgICByZXR1cm4geyB2YWxpZGF0ZSwgY29tcGFyZSB9O1xufVxuZXhwb3J0cy5mdWxsRm9ybWF0cyA9IHtcbiAgICAvLyBkYXRlOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgZGF0ZTogZm10RGVmKGRhdGUsIGNvbXBhcmVEYXRlKSxcbiAgICAvLyBkYXRlLXRpbWU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICB0aW1lOiBmbXREZWYodGltZSwgY29tcGFyZVRpbWUpLFxuICAgIFwiZGF0ZS10aW1lXCI6IGZtdERlZihkYXRlX3RpbWUsIGNvbXBhcmVEYXRlVGltZSksXG4gICAgLy8gZHVyYXRpb246IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I2FwcGVuZGl4LUFcbiAgICBkdXJhdGlvbjogL15QKD8hJCkoKFxcZCtZKT8oXFxkK00pPyhcXGQrRCk/KFQoPz1cXGQpKFxcZCtIKT8oXFxkK00pPyhcXGQrUyk/KT98KFxcZCtXKT8pJC8sXG4gICAgdXJpLFxuICAgIFwidXJpLXJlZmVyZW5jZVwiOiAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KT8oPzpcXC8/XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol18JVswLTlhLWZdezJ9KSpAKT8oPzpcXFsoPzooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7Nn18OjooPzpbMC05YS1mXXsxLDR9Oil7NX18KD86WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7NH18KD86KD86WzAtOWEtZl17MSw0fTopezAsMX1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXszfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwyfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezJ9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDN9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9OnwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw0fVswLTlhLWZdezEsNH0pPzo6KSg/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykpfCg/Oig/OlswLTlhLWZdezEsNH06KXswLDV9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDZ9WzAtOWEtZl17MSw0fSk/OjopfFtWdl1bMC05YS1mXStcXC5bYS16MC05XFwtLl9+ISQmJygpKissOz06XSspXFxdfCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KXwoPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PV18JVswLTlhLWZdezJ9KSopKD86OlxcZCopPyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSp8XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT98KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT8oPzpcXD8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8oPzojKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/JC9pLFxuICAgIC8vIHVyaS10ZW1wbGF0ZTogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY1NzBcbiAgICBcInVyaS10ZW1wbGF0ZVwiOiAvXig/Oig/OlteXFx4MDAtXFx4MjBcIic8PiVcXFxcXmB7fH1dfCVbMC05YS1mXXsyfSl8XFx7WysjLi87PyY9LCFAfF0/KD86W2EtejAtOV9dfCVbMC05YS1mXXsyfSkrKD86OlsxLTldWzAtOV17MCwzfXxcXCopPyg/OiwoPzpbYS16MC05X118JVswLTlhLWZdezJ9KSsoPzo6WzEtOV1bMC05XXswLDN9fFxcKik/KSpcXH0pKiQvaSxcbiAgICAvLyBGb3IgdGhlIHNvdXJjZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZHBlcmluaS83MjkyOTRcbiAgICAvLyBGb3IgdGVzdCBjYXNlczogaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL2RlbW8vdXJsLXJlZ2V4XG4gICAgdXJsOiAvXig/Omh0dHBzP3xmdHApOlxcL1xcLyg/OlxcUysoPzo6XFxTKik/QCk/KD86KD8hKD86MTB8MTI3KSg/OlxcLlxcZHsxLDN9KXszfSkoPyEoPzoxNjlcXC4yNTR8MTkyXFwuMTY4KSg/OlxcLlxcZHsxLDN9KXsyfSkoPyExNzJcXC4oPzoxWzYtOV18MlxcZHwzWzAtMV0pKD86XFwuXFxkezEsM30pezJ9KSg/OlsxLTldXFxkP3wxXFxkXFxkfDJbMDFdXFxkfDIyWzAtM10pKD86XFwuKD86MT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkpezJ9KD86XFwuKD86WzEtOV1cXGQ/fDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNF0pKXwoPzooPzpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rLSkqW2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKykoPzpcXC4oPzpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rLSkqW2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKykqKD86XFwuKD86W2EtelxcdXswMGExfS1cXHV7ZmZmZn1dezIsfSkpKSg/OjpcXGR7Miw1fSk/KD86XFwvW15cXHNdKik/JC9pdSxcbiAgICBlbWFpbDogL15bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqQCg/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT8kL2ksXG4gICAgaG9zdG5hbWU6IC9eKD89LnsxLDI1M31cXC4/JClbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8oPzpcXC5bYS16MC05XSg/OlstMC05YS16XXswLDYxfVswLTlhLXpdKT8pKlxcLj8kL2ksXG4gICAgLy8gb3B0aW1pemVkIGh0dHBzOi8vd3d3LnNhZmFyaWJvb2tzb25saW5lLmNvbS9saWJyYXJ5L3ZpZXcvcmVndWxhci1leHByZXNzaW9ucy1jb29rYm9vay85NzgwNTk2ODAyODM3L2NoMDdzMTYuaHRtbFxuICAgIGlwdjQ6IC9eKD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pJC8sXG4gICAgaXB2NjogL14oKChbMC05YS1mXXsxLDR9Oil7N30oWzAtOWEtZl17MSw0fXw6KSl8KChbMC05YS1mXXsxLDR9Oil7Nn0oOlswLTlhLWZdezEsNH18KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlhLWZdezEsNH06KXs1fSgoKDpbMC05YS1mXXsxLDR9KXsxLDJ9KXw6KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlhLWZdezEsNH06KXs0fSgoKDpbMC05YS1mXXsxLDR9KXsxLDN9KXwoKDpbMC05YS1mXXsxLDR9KT86KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7M30oKCg6WzAtOWEtZl17MSw0fSl7MSw0fSl8KCg6WzAtOWEtZl17MSw0fSl7MCwyfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXsyfSgoKDpbMC05YS1mXXsxLDR9KXsxLDV9KXwoKDpbMC05YS1mXXsxLDR9KXswLDN9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezF9KCgoOlswLTlhLWZdezEsNH0pezEsNn0pfCgoOlswLTlhLWZdezEsNH0pezAsNH06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KDooKCg6WzAtOWEtZl17MSw0fSl7MSw3fSl8KCg6WzAtOWEtZl17MSw0fSl7MCw1fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKSkkL2ksXG4gICAgcmVnZXgsXG4gICAgLy8gdXVpZDogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDEyMlxuICAgIHV1aWQ6IC9eKD86dXJuOnV1aWQ6KT9bMC05YS1mXXs4fS0oPzpbMC05YS1mXXs0fS0pezN9WzAtOWEtZl17MTJ9JC9pLFxuICAgIC8vIEpTT04tcG9pbnRlcjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5MDFcbiAgICAvLyB1cmkgZnJhZ21lbnQ6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I2FwcGVuZGl4LUFcbiAgICBcImpzb24tcG9pbnRlclwiOiAvXig/OlxcLyg/Oltefi9dfH4wfH4xKSopKiQvLFxuICAgIFwianNvbi1wb2ludGVyLXVyaS1mcmFnbWVudFwiOiAvXiMoPzpcXC8oPzpbYS16MC05X1xcLS4hJCYnKCkqKyw7Oj1AXXwlWzAtOWEtZl17Mn18fjB8fjEpKikqJC9pLFxuICAgIC8vIHJlbGF0aXZlIEpTT04tcG9pbnRlcjogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtbHVmZi1yZWxhdGl2ZS1qc29uLXBvaW50ZXItMDBcbiAgICBcInJlbGF0aXZlLWpzb24tcG9pbnRlclwiOiAvXig/OjB8WzEtOV1bMC05XSopKD86I3woPzpcXC8oPzpbXn4vXXx+MHx+MSkqKSopJC8sXG4gICAgLy8gdGhlIGZvbGxvd2luZyBmb3JtYXRzIGFyZSB1c2VkIGJ5IHRoZSBvcGVuYXBpIHNwZWNpZmljYXRpb246IGh0dHBzOi8vc3BlYy5vcGVuYXBpcy5vcmcvb2FzL3YzLjAuMCNkYXRhLXR5cGVzXG4gICAgLy8gYnl0ZTogaHR0cHM6Ly9naXRodWIuY29tL21pZ3VlbG1vdGEvaXMtYmFzZTY0XG4gICAgYnl0ZSxcbiAgICAvLyBzaWduZWQgMzIgYml0IGludGVnZXJcbiAgICBpbnQzMjogeyB0eXBlOiBcIm51bWJlclwiLCB2YWxpZGF0ZTogdmFsaWRhdGVJbnQzMiB9LFxuICAgIC8vIHNpZ25lZCA2NCBiaXQgaW50ZWdlclxuICAgIGludDY0OiB7IHR5cGU6IFwibnVtYmVyXCIsIHZhbGlkYXRlOiB2YWxpZGF0ZUludDY0IH0sXG4gICAgLy8gQy10eXBlIGZsb2F0XG4gICAgZmxvYXQ6IHsgdHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlTnVtYmVyIH0sXG4gICAgLy8gQy10eXBlIGRvdWJsZVxuICAgIGRvdWJsZTogeyB0eXBlOiBcIm51bWJlclwiLCB2YWxpZGF0ZTogdmFsaWRhdGVOdW1iZXIgfSxcbiAgICAvLyBoaW50IHRvIHRoZSBVSSB0byBoaWRlIGlucHV0IHN0cmluZ3NcbiAgICBwYXNzd29yZDogdHJ1ZSxcbiAgICAvLyB1bmNoZWNrZWQgc3RyaW5nIHBheWxvYWRcbiAgICBiaW5hcnk6IHRydWUsXG59O1xuZXhwb3J0cy5mYXN0Rm9ybWF0cyA9IHtcbiAgICAuLi5leHBvcnRzLmZ1bGxGb3JtYXRzLFxuICAgIGRhdGU6IGZtdERlZigvXlxcZFxcZFxcZFxcZC1bMC0xXVxcZC1bMC0zXVxcZCQvLCBjb21wYXJlRGF0ZSksXG4gICAgdGltZTogZm10RGVmKC9eKD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPyk/JC9pLCBjb21wYXJlVGltZSksXG4gICAgXCJkYXRlLXRpbWVcIjogZm10RGVmKC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkW3RcXHNdKD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPykkL2ksIGNvbXBhcmVEYXRlVGltZSksXG4gICAgLy8gdXJpOiBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL2lzLW15LWpzb24tdmFsaWQvYmxvYi9tYXN0ZXIvZm9ybWF0cy5qc1xuICAgIHVyaTogL14oPzpbYS16XVthLXowLTkrXFwtLl0qOikoPzpcXC8/XFwvKT9bXlxcc10qJC9pLFxuICAgIFwidXJpLXJlZmVyZW5jZVwiOiAvXig/Oig/OlthLXpdW2EtejAtOStcXC0uXSo6KT9cXC8/XFwvKT8oPzpbXlxcXFxcXHMjXVteXFxzI10qKT8oPzojW15cXFxcXFxzXSopPyQvaSxcbiAgICAvLyBlbWFpbCAoc291cmNlcyBmcm9tIGpzZW4gdmFsaWRhdG9yKTpcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwMTMyMy91c2luZy1hLXJlZ3VsYXItZXhwcmVzc2lvbi10by12YWxpZGF0ZS1hbi1lbWFpbC1hZGRyZXNzI2Fuc3dlci04ODI5MzYzXG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCN2YWxpZC1lLW1haWwtYWRkcmVzcyAoc2VhcmNoIGZvciAnd2lsZnVsIHZpb2xhdGlvbicpXG4gICAgZW1haWw6IC9eW2EtejAtOS4hIyQlJicqKy89P15fYHt8fX4tXStAW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KD86XFwuW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KSokL2ksXG59O1xuZXhwb3J0cy5mb3JtYXROYW1lcyA9IE9iamVjdC5rZXlzKGV4cG9ydHMuZnVsbEZvcm1hdHMpO1xuZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjYXBwZW5kaXgtQ1xuICAgIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbn1cbmNvbnN0IERBVEUgPSAvXihcXGRcXGRcXGRcXGQpLShcXGRcXGQpLShcXGRcXGQpJC87XG5jb25zdCBEQVlTID0gWzAsIDMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xuZnVuY3Rpb24gZGF0ZShzdHIpIHtcbiAgICAvLyBmdWxsLWRhdGUgZnJvbSBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgY29uc3QgbWF0Y2hlcyA9IERBVEUuZXhlYyhzdHIpO1xuICAgIGlmICghbWF0Y2hlcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHllYXIgPSArbWF0Y2hlc1sxXTtcbiAgICBjb25zdCBtb250aCA9ICttYXRjaGVzWzJdO1xuICAgIGNvbnN0IGRheSA9ICttYXRjaGVzWzNdO1xuICAgIHJldHVybiAobW9udGggPj0gMSAmJlxuICAgICAgICBtb250aCA8PSAxMiAmJlxuICAgICAgICBkYXkgPj0gMSAmJlxuICAgICAgICBkYXkgPD0gKG1vbnRoID09PSAyICYmIGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IERBWVNbbW9udGhdKSk7XG59XG5mdW5jdGlvbiBjb21wYXJlRGF0ZShkMSwgZDIpIHtcbiAgICBpZiAoIShkMSAmJiBkMikpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKGQxID4gZDIpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmIChkMSA8IGQyKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgcmV0dXJuIDA7XG59XG5jb25zdCBUSU1FID0gL14oXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKShcXC5cXGQrKT8oenxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPyk/JC9pO1xuZnVuY3Rpb24gdGltZShzdHIsIHdpdGhUaW1lWm9uZSkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBUSU1FLmV4ZWMoc3RyKTtcbiAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBob3VyID0gK21hdGNoZXNbMV07XG4gICAgY29uc3QgbWludXRlID0gK21hdGNoZXNbMl07XG4gICAgY29uc3Qgc2Vjb25kID0gK21hdGNoZXNbM107XG4gICAgY29uc3QgdGltZVpvbmUgPSBtYXRjaGVzWzVdO1xuICAgIHJldHVybiAoKChob3VyIDw9IDIzICYmIG1pbnV0ZSA8PSA1OSAmJiBzZWNvbmQgPD0gNTkpIHx8XG4gICAgICAgIChob3VyID09PSAyMyAmJiBtaW51dGUgPT09IDU5ICYmIHNlY29uZCA9PT0gNjApKSAmJlxuICAgICAgICAoIXdpdGhUaW1lWm9uZSB8fCB0aW1lWm9uZSAhPT0gXCJcIikpO1xufVxuZnVuY3Rpb24gY29tcGFyZVRpbWUodDEsIHQyKSB7XG4gICAgaWYgKCEodDEgJiYgdDIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGExID0gVElNRS5leGVjKHQxKTtcbiAgICBjb25zdCBhMiA9IFRJTUUuZXhlYyh0Mik7XG4gICAgaWYgKCEoYTEgJiYgYTIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHQxID0gYTFbMV0gKyBhMVsyXSArIGExWzNdICsgKGExWzRdIHx8IFwiXCIpO1xuICAgIHQyID0gYTJbMV0gKyBhMlsyXSArIGEyWzNdICsgKGEyWzRdIHx8IFwiXCIpO1xuICAgIGlmICh0MSA+IHQyKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAodDEgPCB0MilcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xufVxuY29uc3QgREFURV9USU1FX1NFUEFSQVRPUiA9IC90fFxccy9pO1xuZnVuY3Rpb24gZGF0ZV90aW1lKHN0cikge1xuICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICBjb25zdCBkYXRlVGltZSA9IHN0ci5zcGxpdChEQVRFX1RJTUVfU0VQQVJBVE9SKTtcbiAgICByZXR1cm4gZGF0ZVRpbWUubGVuZ3RoID09PSAyICYmIGRhdGUoZGF0ZVRpbWVbMF0pICYmIHRpbWUoZGF0ZVRpbWVbMV0sIHRydWUpO1xufVxuZnVuY3Rpb24gY29tcGFyZURhdGVUaW1lKGR0MSwgZHQyKSB7XG4gICAgaWYgKCEoZHQxICYmIGR0MikpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgW2QxLCB0MV0gPSBkdDEuc3BsaXQoREFURV9USU1FX1NFUEFSQVRPUik7XG4gICAgY29uc3QgW2QyLCB0Ml0gPSBkdDIuc3BsaXQoREFURV9USU1FX1NFUEFSQVRPUik7XG4gICAgY29uc3QgcmVzID0gY29tcGFyZURhdGUoZDEsIGQyKTtcbiAgICBpZiAocmVzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlcyB8fCBjb21wYXJlVGltZSh0MSwgdDIpO1xufVxuY29uc3QgTk9UX1VSSV9GUkFHTUVOVCA9IC9cXC98Oi87XG5jb25zdCBVUkkgPSAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KSg/OlxcLz9cXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06XXwlWzAtOWEtZl17Mn0pKkApPyg/OlxcWyg/Oig/Oig/Oig/OlswLTlhLWZdezEsNH06KXs2fXw6Oig/OlswLTlhLWZdezEsNH06KXs1fXwoPzpbMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXs0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwxfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezN9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDJ9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7Mn18KD86KD86WzAtOWEtZl17MSw0fTopezAsM31bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH06fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDR9WzAtOWEtZl17MSw0fSk/OjopKD86WzAtOWEtZl17MSw0fTpbMC05YS1mXXsxLDR9fCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSl8KD86KD86WzAtOWEtZl17MSw0fTopezAsNX1bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH18KD86KD86WzAtOWEtZl17MSw0fTopezAsNn1bMC05YS1mXXsxLDR9KT86Oil8W1Z2XVswLTlhLWZdK1xcLlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdKylcXF18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pfCg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PV18JVswLTlhLWZdezJ9KSopKD86OlxcZCopPyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqfFxcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT98KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopKD86XFw/KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyg/OiMoPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/JC9pO1xuZnVuY3Rpb24gdXJpKHN0cikge1xuICAgIC8vIGh0dHA6Ly9qbXJ3YXJlLmNvbS9hcnRpY2xlcy8yMDA5L3VyaV9yZWdleHAvVVJJX3JlZ2V4Lmh0bWwgKyBvcHRpb25hbCBwcm90b2NvbCArIHJlcXVpcmVkIFwiLlwiXG4gICAgcmV0dXJuIE5PVF9VUklfRlJBR01FTlQudGVzdChzdHIpICYmIFVSSS50ZXN0KHN0cik7XG59XG5jb25zdCBCWVRFID0gL14oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezJ9PT18W0EtWmEtejAtOSsvXXszfT0pPyQvZ207XG5mdW5jdGlvbiBieXRlKHN0cikge1xuICAgIEJZVEUubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gQllURS50ZXN0KHN0cik7XG59XG5jb25zdCBNSU5fSU5UMzIgPSAtKDIgKiogMzEpO1xuY29uc3QgTUFYX0lOVDMyID0gMiAqKiAzMSAtIDE7XG5mdW5jdGlvbiB2YWxpZGF0ZUludDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIodmFsdWUpICYmIHZhbHVlIDw9IE1BWF9JTlQzMiAmJiB2YWx1ZSA+PSBNSU5fSU5UMzI7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUludDY0KHZhbHVlKSB7XG4gICAgLy8gSlNPTiBhbmQgamF2YXNjcmlwdCBtYXggSW50IGlzIDIqKjUzLCBzbyBhbnkgaW50IHRoYXQgcGFzc2VzIGlzSW50ZWdlciBpcyB2YWxpZCBmb3IgSW50NjRcbiAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlcigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IFpfQU5DSE9SID0gL1teXFxcXF1cXFxcWi87XG5mdW5jdGlvbiByZWdleChzdHIpIHtcbiAgICBpZiAoWl9BTkNIT1IudGVzdChzdHIpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IFJlZ0V4cChzdHIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZvcm1hdExpbWl0RGVmaW5pdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGFqdl8xID0gcmVxdWlyZShcImFqdlwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCJhanYvZGlzdC9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBvcHMgPSBjb2RlZ2VuXzEub3BlcmF0b3JzO1xuY29uc3QgS1dEcyA9IHtcbiAgICBmb3JtYXRNYXhpbXVtOiB7IG9rU3RyOiBcIjw9XCIsIG9rOiBvcHMuTFRFLCBmYWlsOiBvcHMuR1QgfSxcbiAgICBmb3JtYXRNaW5pbXVtOiB7IG9rU3RyOiBcIj49XCIsIG9rOiBvcHMuR1RFLCBmYWlsOiBvcHMuTFQgfSxcbiAgICBmb3JtYXRFeGNsdXNpdmVNYXhpbXVtOiB7IG9rU3RyOiBcIjxcIiwgb2s6IG9wcy5MVCwgZmFpbDogb3BzLkdURSB9LFxuICAgIGZvcm1hdEV4Y2x1c2l2ZU1pbmltdW06IHsgb2tTdHI6IFwiPlwiLCBvazogb3BzLkdULCBmYWlsOiBvcHMuTFRFIH0sXG59O1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBzaG91bGQgYmUgJHtLV0RzW2tleXdvcmRdLm9rU3RyfSAke3NjaGVtYUNvZGV9YCxcbiAgICBwYXJhbXM6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLl8gYHtjb21wYXJpc29uOiAke0tXRHNba2V5d29yZF0ub2tTdHJ9LCBsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmV4cG9ydHMuZm9ybWF0TGltaXREZWZpbml0aW9uID0ge1xuICAgIGtleXdvcmQ6IE9iamVjdC5rZXlzKEtXRHMpLFxuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgc2NoZW1hQ29kZSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICAgICAgaWYgKCFvcHRzLnZhbGlkYXRlRm9ybWF0cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZkN4dCA9IG5ldyBhanZfMS5LZXl3b3JkQ3h0KGl0LCBzZWxmLlJVTEVTLmFsbC5mb3JtYXQuZGVmaW5pdGlvbiwgXCJmb3JtYXRcIik7XG4gICAgICAgIGlmIChmQ3h0LiRkYXRhKVxuICAgICAgICAgICAgdmFsaWRhdGUkRGF0YUZvcm1hdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2YWxpZGF0ZUZvcm1hdCgpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZSREYXRhRm9ybWF0KCkge1xuICAgICAgICAgICAgY29uc3QgZm10cyA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7XG4gICAgICAgICAgICAgICAgcmVmOiBzZWxmLmZvcm1hdHMsXG4gICAgICAgICAgICAgICAgY29kZTogb3B0cy5jb2RlLmZvcm1hdHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGZtdCA9IGdlbi5jb25zdChcImZtdFwiLCBjb2RlZ2VuXzEuXyBgJHtmbXRzfVske2ZDeHQuc2NoZW1hQ29kZX1dYCk7XG4gICAgICAgICAgICBjeHQuZmFpbCRkYXRhKGNvZGVnZW5fMS5vcihjb2RlZ2VuXzEuXyBgdHlwZW9mICR7Zm10fSAhPSBcIm9iamVjdFwiYCwgY29kZWdlbl8xLl8gYCR7Zm10fSBpbnN0YW5jZW9mIFJlZ0V4cGAsIGNvZGVnZW5fMS5fIGB0eXBlb2YgJHtmbXR9LmNvbXBhcmUgIT0gXCJmdW5jdGlvblwiYCwgY29tcGFyZUNvZGUoZm10KSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KCkge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gZkN4dC5zY2hlbWE7XG4gICAgICAgICAgICBjb25zdCBmbXREZWYgPSBzZWxmLmZvcm1hdHNbZm9ybWF0XTtcbiAgICAgICAgICAgIGlmICghZm10RGVmIHx8IGZtdERlZiA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZtdERlZiAhPSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICAgICAgZm10RGVmIGluc3RhbmNlb2YgUmVnRXhwIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIGZtdERlZi5jb21wYXJlICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke2tleXdvcmR9XCI6IGZvcm1hdCBcIiR7Zm9ybWF0fVwiIGRvZXMgbm90IGRlZmluZSBcImNvbXBhcmVcIiBmdW5jdGlvbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZm10ID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAgICAgICAgICBrZXk6IGZvcm1hdCxcbiAgICAgICAgICAgICAgICByZWY6IGZtdERlZixcbiAgICAgICAgICAgICAgICBjb2RlOiBvcHRzLmNvZGUuZm9ybWF0cyA/IGNvZGVnZW5fMS5fIGAke29wdHMuY29kZS5mb3JtYXRzfSR7Y29kZWdlbl8xLmdldFByb3BlcnR5KGZvcm1hdCl9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3h0LmZhaWwkZGF0YShjb21wYXJlQ29kZShmbXQpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb21wYXJlQ29kZShmbXQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgJHtmbXR9LmNvbXBhcmUoJHtkYXRhfSwgJHtzY2hlbWFDb2RlfSkgJHtLV0RzW2tleXdvcmRdLmZhaWx9IDBgO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFtcImZvcm1hdFwiXSxcbn07XG5jb25zdCBmb3JtYXRMaW1pdFBsdWdpbiA9IChhanYpID0+IHtcbiAgICBhanYuYWRkS2V5d29yZChleHBvcnRzLmZvcm1hdExpbWl0RGVmaW5pdGlvbik7XG4gICAgcmV0dXJuIGFqdjtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBmb3JtYXRMaW1pdFBsdWdpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZm9ybWF0c18xID0gcmVxdWlyZShcIi4vZm9ybWF0c1wiKTtcbmNvbnN0IGxpbWl0XzEgPSByZXF1aXJlKFwiLi9saW1pdFwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCJhanYvZGlzdC9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBmdWxsTmFtZSA9IG5ldyBjb2RlZ2VuXzEuTmFtZShcImZ1bGxGb3JtYXRzXCIpO1xuY29uc3QgZmFzdE5hbWUgPSBuZXcgY29kZWdlbl8xLk5hbWUoXCJmYXN0Rm9ybWF0c1wiKTtcbmNvbnN0IGZvcm1hdHNQbHVnaW4gPSAoYWp2LCBvcHRzID0geyBrZXl3b3JkczogdHJ1ZSB9KSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0cykpIHtcbiAgICAgICAgYWRkRm9ybWF0cyhhanYsIG9wdHMsIGZvcm1hdHNfMS5mdWxsRm9ybWF0cywgZnVsbE5hbWUpO1xuICAgICAgICByZXR1cm4gYWp2O1xuICAgIH1cbiAgICBjb25zdCBbZm9ybWF0cywgZXhwb3J0TmFtZV0gPSBvcHRzLm1vZGUgPT09IFwiZmFzdFwiID8gW2Zvcm1hdHNfMS5mYXN0Rm9ybWF0cywgZmFzdE5hbWVdIDogW2Zvcm1hdHNfMS5mdWxsRm9ybWF0cywgZnVsbE5hbWVdO1xuICAgIGNvbnN0IGxpc3QgPSBvcHRzLmZvcm1hdHMgfHwgZm9ybWF0c18xLmZvcm1hdE5hbWVzO1xuICAgIGFkZEZvcm1hdHMoYWp2LCBsaXN0LCBmb3JtYXRzLCBleHBvcnROYW1lKTtcbiAgICBpZiAob3B0cy5rZXl3b3JkcylcbiAgICAgICAgbGltaXRfMS5kZWZhdWx0KGFqdik7XG4gICAgcmV0dXJuIGFqdjtcbn07XG5mb3JtYXRzUGx1Z2luLmdldCA9IChuYW1lLCBtb2RlID0gXCJmdWxsXCIpID0+IHtcbiAgICBjb25zdCBmb3JtYXRzID0gbW9kZSA9PT0gXCJmYXN0XCIgPyBmb3JtYXRzXzEuZmFzdEZvcm1hdHMgOiBmb3JtYXRzXzEuZnVsbEZvcm1hdHM7XG4gICAgY29uc3QgZiA9IGZvcm1hdHNbbmFtZV07XG4gICAgaWYgKCFmKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZm9ybWF0IFwiJHtuYW1lfVwiYCk7XG4gICAgcmV0dXJuIGY7XG59O1xuZnVuY3Rpb24gYWRkRm9ybWF0cyhhanYsIGxpc3QsIGZzLCBleHBvcnROYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBfYjtcbiAgICAoX2EgPSAoX2IgPSBhanYub3B0cy5jb2RlKS5mb3JtYXRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2IuZm9ybWF0cyA9IGNvZGVnZW5fMS5fIGByZXF1aXJlKFwiYWp2LWZvcm1hdHMvZGlzdC9mb3JtYXRzXCIpLiR7ZXhwb3J0TmFtZX1gKTtcbiAgICBmb3IgKGNvbnN0IGYgb2YgbGlzdClcbiAgICAgICAgYWp2LmFkZEZvcm1hdChmLCBmc1tmXSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmb3JtYXRzUGx1Z2luO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZm9ybWF0c1BsdWdpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY29weVByb3BlcnR5ID0gKHRvLCBmcm9tLCBwcm9wZXJ0eSwgaWdub3JlTm9uQ29uZmlndXJhYmxlKSA9PiB7XG5cdC8vIGBGdW5jdGlvbiNsZW5ndGhgIHNob3VsZCByZWZsZWN0IHRoZSBwYXJhbWV0ZXJzIG9mIGB0b2Agbm90IGBmcm9tYCBzaW5jZSB3ZSBrZWVwIGl0cyBib2R5LlxuXHQvLyBgRnVuY3Rpb24jcHJvdG90eXBlYCBpcyBub24td3JpdGFibGUgYW5kIG5vbi1jb25maWd1cmFibGUgc28gY2FuIG5ldmVyIGJlIG1vZGlmaWVkLlxuXHRpZiAocHJvcGVydHkgPT09ICdsZW5ndGgnIHx8IHByb3BlcnR5ID09PSAncHJvdG90eXBlJykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIGBGdW5jdGlvbiNhcmd1bWVudHNgIGFuZCBgRnVuY3Rpb24jY2FsbGVyYCBzaG91bGQgbm90IGJlIGNvcGllZC4gVGhleSB3ZXJlIHJlcG9ydGVkIHRvIGJlIHByZXNlbnQgaW4gYFJlZmxlY3Qub3duS2V5c2AgZm9yIHNvbWUgZGV2aWNlcyBpbiBSZWFjdCBOYXRpdmUgKCM0MSksIHNvIHdlIGV4cGxpY2l0bHkgaWdub3JlIHRoZW0gaGVyZS5cblx0aWYgKHByb3BlcnR5ID09PSAnYXJndW1lbnRzJyB8fCBwcm9wZXJ0eSA9PT0gJ2NhbGxlcicpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCB0b0Rlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvLCBwcm9wZXJ0eSk7XG5cdGNvbnN0IGZyb21EZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihmcm9tLCBwcm9wZXJ0eSk7XG5cblx0aWYgKCFjYW5Db3B5UHJvcGVydHkodG9EZXNjcmlwdG9yLCBmcm9tRGVzY3JpcHRvcikgJiYgaWdub3JlTm9uQ29uZmlndXJhYmxlKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCBwcm9wZXJ0eSwgZnJvbURlc2NyaXB0b3IpO1xufTtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpYCB0aHJvd3MgaWYgdGhlIHByb3BlcnR5IGV4aXN0cywgaXMgbm90IGNvbmZpZ3VyYWJsZSBhbmQgZWl0aGVyOlxuLy8gIC0gb25lIGl0cyBkZXNjcmlwdG9ycyBpcyBjaGFuZ2VkXG4vLyAgLSBpdCBpcyBub24td3JpdGFibGUgYW5kIGl0cyB2YWx1ZSBpcyBjaGFuZ2VkXG5jb25zdCBjYW5Db3B5UHJvcGVydHkgPSBmdW5jdGlvbiAodG9EZXNjcmlwdG9yLCBmcm9tRGVzY3JpcHRvcikge1xuXHRyZXR1cm4gdG9EZXNjcmlwdG9yID09PSB1bmRlZmluZWQgfHwgdG9EZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSB8fCAoXG5cdFx0dG9EZXNjcmlwdG9yLndyaXRhYmxlID09PSBmcm9tRGVzY3JpcHRvci53cml0YWJsZSAmJlxuXHRcdHRvRGVzY3JpcHRvci5lbnVtZXJhYmxlID09PSBmcm9tRGVzY3JpcHRvci5lbnVtZXJhYmxlICYmXG5cdFx0dG9EZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9PT0gZnJvbURlc2NyaXB0b3IuY29uZmlndXJhYmxlICYmXG5cdFx0KHRvRGVzY3JpcHRvci53cml0YWJsZSB8fCB0b0Rlc2NyaXB0b3IudmFsdWUgPT09IGZyb21EZXNjcmlwdG9yLnZhbHVlKVxuXHQpO1xufTtcblxuY29uc3QgY2hhbmdlUHJvdG90eXBlID0gKHRvLCBmcm9tKSA9PiB7XG5cdGNvbnN0IGZyb21Qcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnJvbSk7XG5cdGlmIChmcm9tUHJvdG90eXBlID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodG8pKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0T2JqZWN0LnNldFByb3RvdHlwZU9mKHRvLCBmcm9tUHJvdG90eXBlKTtcbn07XG5cbmNvbnN0IHdyYXBwZWRUb1N0cmluZyA9ICh3aXRoTmFtZSwgZnJvbUJvZHkpID0+IGAvKiBXcmFwcGVkICR7d2l0aE5hbWV9Ki9cXG4ke2Zyb21Cb2R5fWA7XG5cbmNvbnN0IHRvU3RyaW5nRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRnVuY3Rpb24ucHJvdG90eXBlLCAndG9TdHJpbmcnKTtcbmNvbnN0IHRvU3RyaW5nTmFtZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLCAnbmFtZScpO1xuXG4vLyBXZSBjYWxsIGBmcm9tLnRvU3RyaW5nKClgIGVhcmx5IChub3QgbGF6aWx5KSB0byBlbnN1cmUgYGZyb21gIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cbi8vIFdlIHVzZSBgYmluZCgpYCBpbnN0ZWFkIG9mIGEgY2xvc3VyZSBmb3IgdGhlIHNhbWUgcmVhc29uLlxuLy8gQ2FsbGluZyBgZnJvbS50b1N0cmluZygpYCBlYXJseSBhbHNvIGFsbG93cyBjYWNoaW5nIGl0IGluIGNhc2UgYHRvLnRvU3RyaW5nKClgIGlzIGNhbGxlZCBzZXZlcmFsIHRpbWVzLlxuY29uc3QgY2hhbmdlVG9TdHJpbmcgPSAodG8sIGZyb20sIG5hbWUpID0+IHtcblx0Y29uc3Qgd2l0aE5hbWUgPSBuYW1lID09PSAnJyA/ICcnIDogYHdpdGggJHtuYW1lLnRyaW0oKX0oKSBgO1xuXHRjb25zdCBuZXdUb1N0cmluZyA9IHdyYXBwZWRUb1N0cmluZy5iaW5kKG51bGwsIHdpdGhOYW1lLCBmcm9tLnRvU3RyaW5nKCkpO1xuXHQvLyBFbnN1cmUgYHRvLnRvU3RyaW5nLnRvU3RyaW5nYCBpcyBub24tZW51bWVyYWJsZSBhbmQgaGFzIHRoZSBzYW1lIGBzYW1lYFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3VG9TdHJpbmcsICduYW1lJywgdG9TdHJpbmdOYW1lKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCAndG9TdHJpbmcnLCB7Li4udG9TdHJpbmdEZXNjcmlwdG9yLCB2YWx1ZTogbmV3VG9TdHJpbmd9KTtcbn07XG5cbmNvbnN0IG1pbWljRm4gPSAodG8sIGZyb20sIHtpZ25vcmVOb25Db25maWd1cmFibGUgPSBmYWxzZX0gPSB7fSkgPT4ge1xuXHRjb25zdCB7bmFtZX0gPSB0bztcblxuXHRmb3IgKGNvbnN0IHByb3BlcnR5IG9mIFJlZmxlY3Qub3duS2V5cyhmcm9tKSkge1xuXHRcdGNvcHlQcm9wZXJ0eSh0bywgZnJvbSwgcHJvcGVydHksIGlnbm9yZU5vbkNvbmZpZ3VyYWJsZSk7XG5cdH1cblxuXHRjaGFuZ2VQcm90b3R5cGUodG8sIGZyb20pO1xuXHRjaGFuZ2VUb1N0cmluZyh0bywgZnJvbSwgbmFtZSk7XG5cblx0cmV0dXJuIHRvO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtaW1pY0ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgbWltaWNGbiA9IHJlcXVpcmUoJ21pbWljLWZuJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGlucHV0RnVuY3Rpb24sIG9wdGlvbnMgPSB7fSkgPT4ge1xuXHRpZiAodHlwZW9mIGlucHV0RnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiwgZ290IFxcYCR7dHlwZW9mIGlucHV0RnVuY3Rpb259XFxgYCk7XG5cdH1cblxuXHRjb25zdCB7XG5cdFx0d2FpdCA9IDAsXG5cdFx0YmVmb3JlID0gZmFsc2UsXG5cdFx0YWZ0ZXIgPSB0cnVlXG5cdH0gPSBvcHRpb25zO1xuXG5cdGlmICghYmVmb3JlICYmICFhZnRlcikge1xuXHRcdHRocm93IG5ldyBFcnJvcignQm90aCBgYmVmb3JlYCBhbmQgYGFmdGVyYCBhcmUgZmFsc2UsIGZ1bmN0aW9uIHdvdWxkblxcJ3QgYmUgY2FsbGVkLicpO1xuXHR9XG5cblx0bGV0IHRpbWVvdXQ7XG5cdGxldCByZXN1bHQ7XG5cblx0Y29uc3QgZGVib3VuY2VkRnVuY3Rpb24gPSBmdW5jdGlvbiAoLi4uYXJndW1lbnRzXykge1xuXHRcdGNvbnN0IGNvbnRleHQgPSB0aGlzO1xuXG5cdFx0Y29uc3QgbGF0ZXIgPSAoKSA9PiB7XG5cdFx0XHR0aW1lb3V0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoYWZ0ZXIpIHtcblx0XHRcdFx0cmVzdWx0ID0gaW5wdXRGdW5jdGlvbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHNfKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Y29uc3Qgc2hvdWxkQ2FsbE5vdyA9IGJlZm9yZSAmJiAhdGltZW91dDtcblx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0dGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuXG5cdFx0aWYgKHNob3VsZENhbGxOb3cpIHtcblx0XHRcdHJlc3VsdCA9IGlucHV0RnVuY3Rpb24uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzXyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRtaW1pY0ZuKGRlYm91bmNlZEZ1bmN0aW9uLCBpbnB1dEZ1bmN0aW9uKTtcblxuXHRkZWJvdW5jZWRGdW5jdGlvbi5jYW5jZWwgPSAoKSA9PiB7XG5cdFx0aWYgKHRpbWVvdXQpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHRcdHRpbWVvdXQgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBkZWJvdW5jZWRGdW5jdGlvbjtcbn07XG4iLCIvLyBOb3RlOiB0aGlzIGlzIHRoZSBzZW12ZXIub3JnIHZlcnNpb24gb2YgdGhlIHNwZWMgdGhhdCBpdCBpbXBsZW1lbnRzXG4vLyBOb3QgbmVjZXNzYXJpbHkgdGhlIHBhY2thZ2UgdmVyc2lvbiBvZiB0aGlzIGNvZGUuXG5jb25zdCBTRU1WRVJfU1BFQ19WRVJTSU9OID0gJzIuMC4wJ1xuXG5jb25zdCBNQVhfTEVOR1RIID0gMjU2XG5jb25zdCBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHxcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gOTAwNzE5OTI1NDc0MDk5MVxuXG4vLyBNYXggc2FmZSBzZWdtZW50IGxlbmd0aCBmb3IgY29lcmNpb24uXG5jb25zdCBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIID0gMTZcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFNFTVZFUl9TUEVDX1ZFUlNJT04sXG4gIE1BWF9MRU5HVEgsXG4gIE1BWF9TQUZFX0lOVEVHRVIsXG4gIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEhcbn1cbiIsImNvbnN0IGRlYnVnID0gKFxuICB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiZcbiAgcHJvY2Vzcy5lbnYgJiZcbiAgcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyAmJlxuICAvXFxic2VtdmVyXFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKVxuKSA/ICguLi5hcmdzKSA9PiBjb25zb2xlLmVycm9yKCdTRU1WRVInLCAuLi5hcmdzKVxuICA6ICgpID0+IHt9XG5cbm1vZHVsZS5leHBvcnRzID0gZGVidWdcbiIsImNvbnN0IHsgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuL2RlYnVnJylcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9XG5cbi8vIFRoZSBhY3R1YWwgcmVnZXhwcyBnbyBvbiBleHBvcnRzLnJlXG5jb25zdCByZSA9IGV4cG9ydHMucmUgPSBbXVxuY29uc3Qgc3JjID0gZXhwb3J0cy5zcmMgPSBbXVxuY29uc3QgdCA9IGV4cG9ydHMudCA9IHt9XG5sZXQgUiA9IDBcblxuY29uc3QgY3JlYXRlVG9rZW4gPSAobmFtZSwgdmFsdWUsIGlzR2xvYmFsKSA9PiB7XG4gIGNvbnN0IGluZGV4ID0gUisrXG4gIGRlYnVnKGluZGV4LCB2YWx1ZSlcbiAgdFtuYW1lXSA9IGluZGV4XG4gIHNyY1tpbmRleF0gPSB2YWx1ZVxuICByZVtpbmRleF0gPSBuZXcgUmVnRXhwKHZhbHVlLCBpc0dsb2JhbCA/ICdnJyA6IHVuZGVmaW5lZClcbn1cblxuLy8gVGhlIGZvbGxvd2luZyBSZWd1bGFyIEV4cHJlc3Npb25zIGNhbiBiZSB1c2VkIGZvciB0b2tlbml6aW5nLFxuLy8gdmFsaWRhdGluZywgYW5kIHBhcnNpbmcgU2VtVmVyIHZlcnNpb24gc3RyaW5ncy5cblxuLy8gIyMgTnVtZXJpYyBJZGVudGlmaWVyXG4vLyBBIHNpbmdsZSBgMGAsIG9yIGEgbm9uLXplcm8gZGlnaXQgZm9sbG93ZWQgYnkgemVybyBvciBtb3JlIGRpZ2l0cy5cblxuY3JlYXRlVG9rZW4oJ05VTUVSSUNJREVOVElGSUVSJywgJzB8WzEtOV1cXFxcZConKVxuY3JlYXRlVG9rZW4oJ05VTUVSSUNJREVOVElGSUVSTE9PU0UnLCAnWzAtOV0rJylcblxuLy8gIyMgTm9uLW51bWVyaWMgSWRlbnRpZmllclxuLy8gWmVybyBvciBtb3JlIGRpZ2l0cywgZm9sbG93ZWQgYnkgYSBsZXR0ZXIgb3IgaHlwaGVuLCBhbmQgdGhlbiB6ZXJvIG9yXG4vLyBtb3JlIGxldHRlcnMsIGRpZ2l0cywgb3IgaHlwaGVucy5cblxuY3JlYXRlVG9rZW4oJ05PTk5VTUVSSUNJREVOVElGSUVSJywgJ1xcXFxkKlthLXpBLVotXVthLXpBLVowLTktXSonKVxuXG4vLyAjIyBNYWluIFZlcnNpb25cbi8vIFRocmVlIGRvdC1zZXBhcmF0ZWQgbnVtZXJpYyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ01BSU5WRVJTSU9OJywgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KWApXG5cbmNyZWF0ZVRva2VuKCdNQUlOVkVSU0lPTkxPT1NFJywgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlgKVxuXG4vLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uIElkZW50aWZpZXJcbi8vIEEgbnVtZXJpYyBpZGVudGlmaWVyLCBvciBhIG5vbi1udW1lcmljIGlkZW50aWZpZXIuXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFSURFTlRJRklFUicsIGAoPzoke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXVxufXwke3NyY1t0Lk5PTk5VTUVSSUNJREVOVElGSUVSXX0pYClcblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0VJREVOVElGSUVSTE9PU0UnLCBgKD86JHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXVxufXwke3NyY1t0Lk5PTk5VTUVSSUNJREVOVElGSUVSXX0pYClcblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvblxuLy8gSHlwaGVuLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBkb3Qtc2VwYXJhdGVkIHByZS1yZWxlYXNlIHZlcnNpb25cbi8vIGlkZW50aWZpZXJzLlxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRScsIGAoPzotKCR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJdXG59KD86XFxcXC4ke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSXX0pKikpYClcblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0VMT09TRScsIGAoPzotPygke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdXG59KD86XFxcXC4ke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdfSkqKSlgKVxuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YSBJZGVudGlmaWVyXG4vLyBBbnkgY29tYmluYXRpb24gb2YgZGlnaXRzLCBsZXR0ZXJzLCBvciBoeXBoZW5zLlxuXG5jcmVhdGVUb2tlbignQlVJTERJREVOVElGSUVSJywgJ1swLTlBLVphLXotXSsnKVxuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YVxuLy8gUGx1cyBzaWduLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBwZXJpb2Qtc2VwYXJhdGVkIGJ1aWxkIG1ldGFkYXRhXG4vLyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ0JVSUxEJywgYCg/OlxcXFwrKCR7c3JjW3QuQlVJTERJREVOVElGSUVSXVxufSg/OlxcXFwuJHtzcmNbdC5CVUlMRElERU5USUZJRVJdfSkqKSlgKVxuXG4vLyAjIyBGdWxsIFZlcnNpb24gU3RyaW5nXG4vLyBBIG1haW4gdmVyc2lvbiwgZm9sbG93ZWQgb3B0aW9uYWxseSBieSBhIHByZS1yZWxlYXNlIHZlcnNpb24gYW5kXG4vLyBidWlsZCBtZXRhZGF0YS5cblxuLy8gTm90ZSB0aGF0IHRoZSBvbmx5IG1ham9yLCBtaW5vciwgcGF0Y2gsIGFuZCBwcmUtcmVsZWFzZSBzZWN0aW9ucyBvZlxuLy8gdGhlIHZlcnNpb24gc3RyaW5nIGFyZSBjYXB0dXJpbmcgZ3JvdXBzLiAgVGhlIGJ1aWxkIG1ldGFkYXRhIGlzIG5vdCBhXG4vLyBjYXB0dXJpbmcgZ3JvdXAsIGJlY2F1c2UgaXQgc2hvdWxkIG5vdCBldmVyIGJlIHVzZWQgaW4gdmVyc2lvblxuLy8gY29tcGFyaXNvbi5cblxuY3JlYXRlVG9rZW4oJ0ZVTExQTEFJTicsIGB2PyR7c3JjW3QuTUFJTlZFUlNJT05dXG59JHtzcmNbdC5QUkVSRUxFQVNFXX0/JHtcbiAgc3JjW3QuQlVJTERdfT9gKVxuXG5jcmVhdGVUb2tlbignRlVMTCcsIGBeJHtzcmNbdC5GVUxMUExBSU5dfSRgKVxuXG4vLyBsaWtlIGZ1bGwsIGJ1dCBhbGxvd3MgdjEuMi4zIGFuZCA9MS4yLjMsIHdoaWNoIHBlb3BsZSBkbyBzb21ldGltZXMuXG4vLyBhbHNvLCAxLjAuMGFscGhhMSAocHJlcmVsZWFzZSB3aXRob3V0IHRoZSBoeXBoZW4pIHdoaWNoIGlzIHByZXR0eVxuLy8gY29tbW9uIGluIHRoZSBucG0gcmVnaXN0cnkuXG5jcmVhdGVUb2tlbignTE9PU0VQTEFJTicsIGBbdj1cXFxcc10qJHtzcmNbdC5NQUlOVkVSU0lPTkxPT1NFXVxufSR7c3JjW3QuUFJFUkVMRUFTRUxPT1NFXX0/JHtcbiAgc3JjW3QuQlVJTERdfT9gKVxuXG5jcmVhdGVUb2tlbignTE9PU0UnLCBgXiR7c3JjW3QuTE9PU0VQTEFJTl19JGApXG5cbmNyZWF0ZVRva2VuKCdHVExUJywgJygoPzo8fD4pPz0/KScpXG5cbi8vIFNvbWV0aGluZyBsaWtlIFwiMi4qXCIgb3IgXCIxLjIueFwiLlxuLy8gTm90ZSB0aGF0IFwieC54XCIgaXMgYSB2YWxpZCB4UmFuZ2UgaWRlbnRpZmVyLCBtZWFuaW5nIFwiYW55IHZlcnNpb25cIlxuLy8gT25seSB0aGUgZmlyc3QgaXRlbSBpcyBzdHJpY3RseSByZXF1aXJlZC5cbmNyZWF0ZVRva2VuKCdYUkFOR0VJREVOVElGSUVSTE9PU0UnLCBgJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX18eHxYfFxcXFwqYClcbmNyZWF0ZVRva2VuKCdYUkFOR0VJREVOVElGSUVSJywgYCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfXx4fFh8XFxcXCpgKVxuXG5jcmVhdGVUb2tlbignWFJBTkdFUExBSU4nLCBgW3Y9XFxcXHNdKigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJdfSlgICtcbiAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGAoPzoke3NyY1t0LlBSRVJFTEVBU0VdfSk/JHtcbiAgICAgICAgICAgICAgICAgICAgIHNyY1t0LkJVSUxEXX0/YCArXG4gICAgICAgICAgICAgICAgICAgYCk/KT9gKVxuXG5jcmVhdGVUb2tlbignWFJBTkdFUExBSU5MT09TRScsIGBbdj1cXFxcc10qKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCg/OiR7c3JjW3QuUFJFUkVMRUFTRUxPT1NFXX0pPyR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1t0LkJVSUxEXX0/YCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKT8pP2ApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqJHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignWFJBTkdFTE9PU0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqJHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQ29lcmNpb24uXG4vLyBFeHRyYWN0IGFueXRoaW5nIHRoYXQgY291bGQgY29uY2VpdmFibHkgYmUgYSBwYXJ0IG9mIGEgdmFsaWQgc2VtdmVyXG5jcmVhdGVUb2tlbignQ09FUkNFJywgYCR7JyhefFteXFxcXGRdKScgK1xuICAgICAgICAgICAgICAnKFxcXFxkezEsJ30ke01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEh9fSlgICtcbiAgICAgICAgICAgICAgYCg/OlxcXFwuKFxcXFxkezEsJHtNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIfX0pKT9gICtcbiAgICAgICAgICAgICAgYCg/OlxcXFwuKFxcXFxkezEsJHtNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIfX0pKT9gICtcbiAgICAgICAgICAgICAgYCg/OiR8W15cXFxcZF0pYClcbmNyZWF0ZVRva2VuKCdDT0VSQ0VSVEwnLCBzcmNbdC5DT0VSQ0VdLCB0cnVlKVxuXG4vLyBUaWxkZSByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwicmVhc29uYWJseSBhdCBvciBncmVhdGVyIHRoYW5cIlxuY3JlYXRlVG9rZW4oJ0xPTkVUSUxERScsICcoPzp+Pj8pJylcblxuY3JlYXRlVG9rZW4oJ1RJTERFVFJJTScsIGAoXFxcXHMqKSR7c3JjW3QuTE9ORVRJTERFXX1cXFxccytgLCB0cnVlKVxuZXhwb3J0cy50aWxkZVRyaW1SZXBsYWNlID0gJyQxfidcblxuY3JlYXRlVG9rZW4oJ1RJTERFJywgYF4ke3NyY1t0LkxPTkVUSUxERV19JHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignVElMREVMT09TRScsIGBeJHtzcmNbdC5MT05FVElMREVdfSR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19JGApXG5cbi8vIENhcmV0IHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJhdCBsZWFzdCBhbmQgYmFja3dhcmRzIGNvbXBhdGlibGUgd2l0aFwiXG5jcmVhdGVUb2tlbignTE9ORUNBUkVUJywgJyg/OlxcXFxeKScpXG5cbmNyZWF0ZVRva2VuKCdDQVJFVFRSSU0nLCBgKFxcXFxzKikke3NyY1t0LkxPTkVDQVJFVF19XFxcXHMrYCwgdHJ1ZSlcbmV4cG9ydHMuY2FyZXRUcmltUmVwbGFjZSA9ICckMV4nXG5cbmNyZWF0ZVRva2VuKCdDQVJFVCcsIGBeJHtzcmNbdC5MT05FQ0FSRVRdfSR7c3JjW3QuWFJBTkdFUExBSU5dfSRgKVxuY3JlYXRlVG9rZW4oJ0NBUkVUTE9PU0UnLCBgXiR7c3JjW3QuTE9ORUNBUkVUXX0ke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKVxuXG4vLyBBIHNpbXBsZSBndC9sdC9lcSB0aGluZywgb3IganVzdCBcIlwiIHRvIGluZGljYXRlIFwiYW55IHZlcnNpb25cIlxuY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1JMT09TRScsIGBeJHtzcmNbdC5HVExUXX1cXFxccyooJHtzcmNbdC5MT09TRVBMQUlOXX0pJHxeJGApXG5jcmVhdGVUb2tlbignQ09NUEFSQVRPUicsIGBeJHtzcmNbdC5HVExUXX1cXFxccyooJHtzcmNbdC5GVUxMUExBSU5dfSkkfF4kYClcblxuLy8gQW4gZXhwcmVzc2lvbiB0byBzdHJpcCBhbnkgd2hpdGVzcGFjZSBiZXR3ZWVuIHRoZSBndGx0IGFuZCB0aGUgdGhpbmdcbi8vIGl0IG1vZGlmaWVzLCBzbyB0aGF0IGA+IDEuMi4zYCA9PT4gYD4xLjIuM2BcbmNyZWF0ZVRva2VuKCdDT01QQVJBVE9SVFJJTScsIGAoXFxcXHMqKSR7c3JjW3QuR1RMVF1cbn1cXFxccyooJHtzcmNbdC5MT09TRVBMQUlOXX18JHtzcmNbdC5YUkFOR0VQTEFJTl19KWAsIHRydWUpXG5leHBvcnRzLmNvbXBhcmF0b3JUcmltUmVwbGFjZSA9ICckMSQyJDMnXG5cbi8vIFNvbWV0aGluZyBsaWtlIGAxLjIuMyAtIDEuMi40YFxuLy8gTm90ZSB0aGF0IHRoZXNlIGFsbCB1c2UgdGhlIGxvb3NlIGZvcm0sIGJlY2F1c2UgdGhleSdsbCBiZVxuLy8gY2hlY2tlZCBhZ2FpbnN0IGVpdGhlciB0aGUgc3RyaWN0IG9yIGxvb3NlIGNvbXBhcmF0b3IgZm9ybVxuLy8gbGF0ZXIuXG5jcmVhdGVUb2tlbignSFlQSEVOUkFOR0UnLCBgXlxcXFxzKigke3NyY1t0LlhSQU5HRVBMQUlOXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYFxcXFxzKy1cXFxccytgICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuWFJBTkdFUExBSU5dfSlgICtcbiAgICAgICAgICAgICAgICAgICBgXFxcXHMqJGApXG5cbmNyZWF0ZVRva2VuKCdIWVBIRU5SQU5HRUxPT1NFJywgYF5cXFxccyooJHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgXFxcXHMrLVxcXFxzK2AgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCgke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcXFxccyokYClcblxuLy8gU3RhciByYW5nZXMgYmFzaWNhbGx5IGp1c3QgYWxsb3cgYW55dGhpbmcgYXQgYWxsLlxuY3JlYXRlVG9rZW4oJ1NUQVInLCAnKDx8Pik/PT9cXFxccypcXFxcKicpXG4vLyA+PTAuMC4wIGlzIGxpa2UgYSBzdGFyXG5jcmVhdGVUb2tlbignR1RFMCcsICdeXFxcXHMqPj1cXFxccyowXFwuMFxcLjBcXFxccyokJylcbmNyZWF0ZVRva2VuKCdHVEUwUFJFJywgJ15cXFxccyo+PVxcXFxzKjBcXC4wXFwuMC0wXFxcXHMqJCcpXG4iLCIvLyBwYXJzZSBvdXQganVzdCB0aGUgb3B0aW9ucyB3ZSBjYXJlIGFib3V0IHNvIHdlIGFsd2F5cyBnZXQgYSBjb25zaXN0ZW50XG4vLyBvYmogd2l0aCBrZXlzIGluIGEgY29uc2lzdGVudCBvcmRlci5cbmNvbnN0IG9wdHMgPSBbJ2luY2x1ZGVQcmVyZWxlYXNlJywgJ2xvb3NlJywgJ3J0bCddXG5jb25zdCBwYXJzZU9wdGlvbnMgPSBvcHRpb25zID0+XG4gICFvcHRpb25zID8ge31cbiAgOiB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgPyB7IGxvb3NlOiB0cnVlIH1cbiAgOiBvcHRzLmZpbHRlcihrID0+IG9wdGlvbnNba10pLnJlZHVjZSgob3B0aW9ucywgaykgPT4ge1xuICAgIG9wdGlvbnNba10gPSB0cnVlXG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfSwge30pXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlT3B0aW9uc1xuIiwiY29uc3QgbnVtZXJpYyA9IC9eWzAtOV0rJC9cbmNvbnN0IGNvbXBhcmVJZGVudGlmaWVycyA9IChhLCBiKSA9PiB7XG4gIGNvbnN0IGFudW0gPSBudW1lcmljLnRlc3QoYSlcbiAgY29uc3QgYm51bSA9IG51bWVyaWMudGVzdChiKVxuXG4gIGlmIChhbnVtICYmIGJudW0pIHtcbiAgICBhID0gK2FcbiAgICBiID0gK2JcbiAgfVxuXG4gIHJldHVybiBhID09PSBiID8gMFxuICAgIDogKGFudW0gJiYgIWJudW0pID8gLTFcbiAgICA6IChibnVtICYmICFhbnVtKSA/IDFcbiAgICA6IGEgPCBiID8gLTFcbiAgICA6IDFcbn1cblxuY29uc3QgcmNvbXBhcmVJZGVudGlmaWVycyA9IChhLCBiKSA9PiBjb21wYXJlSWRlbnRpZmllcnMoYiwgYSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXBhcmVJZGVudGlmaWVycyxcbiAgcmNvbXBhcmVJZGVudGlmaWVyc1xufVxuIiwiY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCB7IE1BWF9MRU5HVEgsIE1BWF9TQUZFX0lOVEVHRVIgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NvbnN0YW50cycpXG5jb25zdCB7IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgeyBjb21wYXJlSWRlbnRpZmllcnMgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lkZW50aWZpZXJzJylcbmNsYXNzIFNlbVZlciB7XG4gIGNvbnN0cnVjdG9yICh2ZXJzaW9uLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICAgIGlmICh2ZXJzaW9uLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UgJiZcbiAgICAgICAgICB2ZXJzaW9uLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgICAgcmV0dXJuIHZlcnNpb25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnZlcnNpb25cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBWZXJzaW9uOiAke3ZlcnNpb259YClcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBgdmVyc2lvbiBpcyBsb25nZXIgdGhhbiAke01BWF9MRU5HVEh9IGNoYXJhY3RlcnNgXG4gICAgICApXG4gICAgfVxuXG4gICAgZGVidWcoJ1NlbVZlcicsIHZlcnNpb24sIG9wdGlvbnMpXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgICAvLyB0aGlzIGlzbid0IGFjdHVhbGx5IHJlbGV2YW50IGZvciB2ZXJzaW9ucywgYnV0IGtlZXAgaXQgc28gdGhhdCB3ZVxuICAgIC8vIGRvbid0IHJ1biBpbnRvIHRyb3VibGUgcGFzc2luZyB0aGlzLm9wdGlvbnMgYXJvdW5kLlxuICAgIHRoaXMuaW5jbHVkZVByZXJlbGVhc2UgPSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcblxuICAgIGNvbnN0IG0gPSB2ZXJzaW9uLnRyaW0oKS5tYXRjaChvcHRpb25zLmxvb3NlID8gcmVbdC5MT09TRV0gOiByZVt0LkZVTExdKVxuXG4gICAgaWYgKCFtKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFZlcnNpb246ICR7dmVyc2lvbn1gKVxuICAgIH1cblxuICAgIHRoaXMucmF3ID0gdmVyc2lvblxuXG4gICAgLy8gdGhlc2UgYXJlIGFjdHVhbGx5IG51bWJlcnNcbiAgICB0aGlzLm1ham9yID0gK21bMV1cbiAgICB0aGlzLm1pbm9yID0gK21bMl1cbiAgICB0aGlzLnBhdGNoID0gK21bM11cblxuICAgIGlmICh0aGlzLm1ham9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1ham9yIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWpvciB2ZXJzaW9uJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5taW5vciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5taW5vciA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWlub3IgdmVyc2lvbicpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGF0Y2ggPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMucGF0Y2ggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHBhdGNoIHZlcnNpb24nKVxuICAgIH1cblxuICAgIC8vIG51bWJlcmlmeSBhbnkgcHJlcmVsZWFzZSBudW1lcmljIGlkc1xuICAgIGlmICghbVs0XSkge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gbVs0XS5zcGxpdCgnLicpLm1hcCgoaWQpID0+IHtcbiAgICAgICAgaWYgKC9eWzAtOV0rJC8udGVzdChpZCkpIHtcbiAgICAgICAgICBjb25zdCBudW0gPSAraWRcbiAgICAgICAgICBpZiAobnVtID49IDAgJiYgbnVtIDwgTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgcmV0dXJuIG51bVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5idWlsZCA9IG1bNV0gPyBtWzVdLnNwbGl0KCcuJykgOiBbXVxuICAgIHRoaXMuZm9ybWF0KClcbiAgfVxuXG4gIGZvcm1hdCAoKSB7XG4gICAgdGhpcy52ZXJzaW9uID0gYCR7dGhpcy5tYWpvcn0uJHt0aGlzLm1pbm9yfS4ke3RoaXMucGF0Y2h9YFxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICB0aGlzLnZlcnNpb24gKz0gYC0ke3RoaXMucHJlcmVsZWFzZS5qb2luKCcuJyl9YFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy52ZXJzaW9uXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVyc2lvblxuICB9XG5cbiAgY29tcGFyZSAob3RoZXIpIHtcbiAgICBkZWJ1ZygnU2VtVmVyLmNvbXBhcmUnLCB0aGlzLnZlcnNpb24sIHRoaXMub3B0aW9ucywgb3RoZXIpXG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBpZiAodHlwZW9mIG90aGVyID09PSAnc3RyaW5nJyAmJiBvdGhlciA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICBpZiAob3RoZXIudmVyc2lvbiA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbXBhcmVNYWluKG90aGVyKSB8fCB0aGlzLmNvbXBhcmVQcmUob3RoZXIpXG4gIH1cblxuICBjb21wYXJlTWFpbiAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5tYWpvciwgb3RoZXIubWFqb3IpIHx8XG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5taW5vciwgb3RoZXIubWlub3IpIHx8XG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5wYXRjaCwgb3RoZXIucGF0Y2gpXG4gICAgKVxuICB9XG5cbiAgY29tcGFyZVByZSAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIC8vIE5PVCBoYXZpbmcgYSBwcmVyZWxlYXNlIGlzID4gaGF2aW5nIG9uZVxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfSBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiBvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICBsZXQgaSA9IDBcbiAgICBkbyB7XG4gICAgICBjb25zdCBhID0gdGhpcy5wcmVyZWxlYXNlW2ldXG4gICAgICBjb25zdCBiID0gb3RoZXIucHJlcmVsZWFzZVtpXVxuICAgICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgY29tcGFyZUJ1aWxkIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgbGV0IGkgPSAwXG4gICAgZG8ge1xuICAgICAgY29uc3QgYSA9IHRoaXMuYnVpbGRbaV1cbiAgICAgIGNvbnN0IGIgPSBvdGhlci5idWlsZFtpXVxuICAgICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgLy8gcHJlbWlub3Igd2lsbCBidW1wIHRoZSB2ZXJzaW9uIHVwIHRvIHRoZSBuZXh0IG1pbm9yIHJlbGVhc2UsIGFuZCBpbW1lZGlhdGVseVxuICAvLyBkb3duIHRvIHByZS1yZWxlYXNlLiBwcmVtYWpvciBhbmQgcHJlcGF0Y2ggd29yayB0aGUgc2FtZSB3YXkuXG4gIGluYyAocmVsZWFzZSwgaWRlbnRpZmllcikge1xuICAgIHN3aXRjaCAocmVsZWFzZSkge1xuICAgICAgY2FzZSAncHJlbWFqb3InOlxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLm1pbm9yID0gMFxuICAgICAgICB0aGlzLm1ham9yKytcbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwcmVtaW5vcic6XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMubWlub3IrK1xuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3ByZXBhdGNoJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhbHJlYWR5IGEgcHJlcmVsZWFzZSwgaXQgd2lsbCBidW1wIHRvIHRoZSBuZXh0IHZlcnNpb25cbiAgICAgICAgLy8gZHJvcCBhbnkgcHJlcmVsZWFzZXMgdGhhdCBtaWdodCBhbHJlYWR5IGV4aXN0LCBzaW5jZSB0aGV5IGFyZSBub3RcbiAgICAgICAgLy8gcmVsZXZhbnQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcilcbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpXG4gICAgICAgIGJyZWFrXG4gICAgICAvLyBJZiB0aGUgaW5wdXQgaXMgYSBub24tcHJlcmVsZWFzZSB2ZXJzaW9uLCB0aGlzIGFjdHMgdGhlIHNhbWUgYXNcbiAgICAgIC8vIHByZXBhdGNoLlxuICAgICAgY2FzZSAncHJlcmVsZWFzZSc6XG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcilcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnbWFqb3InOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1ham9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWFqb3IgdmVyc2lvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtYWpvci5cbiAgICAgICAgLy8gMS4wLjAtNSBidW1wcyB0byAxLjAuMFxuICAgICAgICAvLyAxLjEuMCBidW1wcyB0byAyLjAuMFxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5taW5vciAhPT0gMCB8fFxuICAgICAgICAgIHRoaXMucGF0Y2ggIT09IDAgfHxcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMubWFqb3IrK1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWlub3IgPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdtaW5vcic6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmUtbWlub3IgdmVyc2lvbiwgYnVtcCB1cCB0byB0aGUgc2FtZSBtaW5vciB2ZXJzaW9uLlxuICAgICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1pbm9yLlxuICAgICAgICAvLyAxLjIuMC01IGJ1bXBzIHRvIDEuMi4wXG4gICAgICAgIC8vIDEuMi4xIGJ1bXBzIHRvIDEuMy4wXG4gICAgICAgIGlmICh0aGlzLnBhdGNoICE9PSAwIHx8IHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLm1pbm9yKytcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncGF0Y2gnOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIG5vdCBhIHByZS1yZWxlYXNlIHZlcnNpb24sIGl0IHdpbGwgaW5jcmVtZW50IHRoZSBwYXRjaC5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSBwcmUtcmVsZWFzZSBpdCB3aWxsIGJ1bXAgdXAgdG8gdGhlIHNhbWUgcGF0Y2ggdmVyc2lvbi5cbiAgICAgICAgLy8gMS4yLjAtNSBwYXRjaGVzIHRvIDEuMi4wXG4gICAgICAgIC8vIDEuMi4wIHBhdGNoZXMgdG8gMS4yLjFcbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnBhdGNoKytcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgICAgICBicmVha1xuICAgICAgLy8gVGhpcyBwcm9iYWJseSBzaG91bGRuJ3QgYmUgdXNlZCBwdWJsaWNseS5cbiAgICAgIC8vIDEuMC4wICdwcmUnIHdvdWxkIGJlY29tZSAxLjAuMC0wIHdoaWNoIGlzIHRoZSB3cm9uZyBkaXJlY3Rpb24uXG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFswXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBpID0gdGhpcy5wcmVyZWxlYXNlLmxlbmd0aFxuICAgICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByZXJlbGVhc2VbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZVtpXSsrXG4gICAgICAgICAgICAgIGkgPSAtMlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGRpZG4ndCBpbmNyZW1lbnQgYW55dGhpbmdcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZS5wdXNoKDApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpZGVudGlmaWVyKSB7XG4gICAgICAgICAgLy8gMS4yLjAtYmV0YS4xIGJ1bXBzIHRvIDEuMi4wLWJldGEuMixcbiAgICAgICAgICAvLyAxLjIuMC1iZXRhLmZvb2JseiBvciAxLjIuMC1iZXRhIGJ1bXBzIHRvIDEuMi4wLWJldGEuMFxuICAgICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2VbMF0gPT09IGlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGlmIChpc05hTih0aGlzLnByZXJlbGVhc2VbMV0pKSB7XG4gICAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCAwXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgMF1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGluY3JlbWVudCBhcmd1bWVudDogJHtyZWxlYXNlfWApXG4gICAgfVxuICAgIHRoaXMuZm9ybWF0KClcbiAgICB0aGlzLnJhdyA9IHRoaXMudmVyc2lvblxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZW1WZXJcbiIsImNvbnN0IHtNQVhfTEVOR1RIfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NvbnN0YW50cycpXG5jb25zdCB7IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgcGFyc2UgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICByZXR1cm4gdmVyc2lvblxuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5MT09TRV0gOiByZVt0LkZVTExdXG4gIGlmICghci50ZXN0KHZlcnNpb24pKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VcbiIsImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCB2YWxpZCA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHYgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKVxuICByZXR1cm4gdiA/IHYudmVyc2lvbiA6IG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRcbiIsImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCBjbGVhbiA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHMgPSBwYXJzZSh2ZXJzaW9uLnRyaW0oKS5yZXBsYWNlKC9eWz12XSsvLCAnJyksIG9wdGlvbnMpXG4gIHJldHVybiBzID8gcy52ZXJzaW9uIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBjbGVhblxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuXG5jb25zdCBpbmMgPSAodmVyc2lvbiwgcmVsZWFzZSwgb3B0aW9ucywgaWRlbnRpZmllcikgPT4ge1xuICBpZiAodHlwZW9mIChvcHRpb25zKSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZGVudGlmaWVyID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWRcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucykuaW5jKHJlbGVhc2UsIGlkZW50aWZpZXIpLnZlcnNpb25cbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluY1xuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgY29tcGFyZSA9IChhLCBiLCBsb29zZSkgPT5cbiAgbmV3IFNlbVZlcihhLCBsb29zZSkuY29tcGFyZShuZXcgU2VtVmVyKGIsIGxvb3NlKSlcblxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGVxID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA9PT0gMFxubW9kdWxlLmV4cG9ydHMgPSBlcVxuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IGVxID0gcmVxdWlyZSgnLi9lcScpXG5cbmNvbnN0IGRpZmYgPSAodmVyc2lvbjEsIHZlcnNpb24yKSA9PiB7XG4gIGlmIChlcSh2ZXJzaW9uMSwgdmVyc2lvbjIpKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB2MSA9IHBhcnNlKHZlcnNpb24xKVxuICAgIGNvbnN0IHYyID0gcGFyc2UodmVyc2lvbjIpXG4gICAgY29uc3QgaGFzUHJlID0gdjEucHJlcmVsZWFzZS5sZW5ndGggfHwgdjIucHJlcmVsZWFzZS5sZW5ndGhcbiAgICBjb25zdCBwcmVmaXggPSBoYXNQcmUgPyAncHJlJyA6ICcnXG4gICAgY29uc3QgZGVmYXVsdFJlc3VsdCA9IGhhc1ByZSA/ICdwcmVyZWxlYXNlJyA6ICcnXG4gICAgZm9yIChjb25zdCBrZXkgaW4gdjEpIHtcbiAgICAgIGlmIChrZXkgPT09ICdtYWpvcicgfHwga2V5ID09PSAnbWlub3InIHx8IGtleSA9PT0gJ3BhdGNoJykge1xuICAgICAgICBpZiAodjFba2V5XSAhPT0gdjJba2V5XSkge1xuICAgICAgICAgIHJldHVybiBwcmVmaXggKyBrZXlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFJlc3VsdCAvLyBtYXkgYmUgdW5kZWZpbmVkXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gZGlmZlxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgbWFqb3IgPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1ham9yXG5tb2R1bGUuZXhwb3J0cyA9IG1ham9yXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBtaW5vciA9IChhLCBsb29zZSkgPT4gbmV3IFNlbVZlcihhLCBsb29zZSkubWlub3Jcbm1vZHVsZS5leHBvcnRzID0gbWlub3JcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IHBhdGNoID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5wYXRjaFxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaFxuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHByZXJlbGVhc2UgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBwYXJzZWQgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKVxuICByZXR1cm4gKHBhcnNlZCAmJiBwYXJzZWQucHJlcmVsZWFzZS5sZW5ndGgpID8gcGFyc2VkLnByZXJlbGVhc2UgOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IHByZXJlbGVhc2VcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgcmNvbXBhcmUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYiwgYSwgbG9vc2UpXG5tb2R1bGUuZXhwb3J0cyA9IHJjb21wYXJlXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGNvbXBhcmVMb29zZSA9IChhLCBiKSA9PiBjb21wYXJlKGEsIGIsIHRydWUpXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVMb29zZVxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgY29tcGFyZUJ1aWxkID0gKGEsIGIsIGxvb3NlKSA9PiB7XG4gIGNvbnN0IHZlcnNpb25BID0gbmV3IFNlbVZlcihhLCBsb29zZSlcbiAgY29uc3QgdmVyc2lvbkIgPSBuZXcgU2VtVmVyKGIsIGxvb3NlKVxuICByZXR1cm4gdmVyc2lvbkEuY29tcGFyZSh2ZXJzaW9uQikgfHwgdmVyc2lvbkEuY29tcGFyZUJ1aWxkKHZlcnNpb25CKVxufVxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlQnVpbGRcbiIsImNvbnN0IGNvbXBhcmVCdWlsZCA9IHJlcXVpcmUoJy4vY29tcGFyZS1idWlsZCcpXG5jb25zdCBzb3J0ID0gKGxpc3QsIGxvb3NlKSA9PiBsaXN0LnNvcnQoKGEsIGIpID0+IGNvbXBhcmVCdWlsZChhLCBiLCBsb29zZSkpXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnRcbiIsImNvbnN0IGNvbXBhcmVCdWlsZCA9IHJlcXVpcmUoJy4vY29tcGFyZS1idWlsZCcpXG5jb25zdCByc29ydCA9IChsaXN0LCBsb29zZSkgPT4gbGlzdC5zb3J0KChhLCBiKSA9PiBjb21wYXJlQnVpbGQoYiwgYSwgbG9vc2UpKVxubW9kdWxlLmV4cG9ydHMgPSByc29ydFxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBndCA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPiAwXG5tb2R1bGUuZXhwb3J0cyA9IGd0XG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGx0ID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8IDBcbm1vZHVsZS5leHBvcnRzID0gbHRcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbmVxID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSAhPT0gMFxubW9kdWxlLmV4cG9ydHMgPSBuZXFcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZ3RlID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGd0ZVxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBsdGUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpIDw9IDBcbm1vZHVsZS5leHBvcnRzID0gbHRlXG4iLCJjb25zdCBlcSA9IHJlcXVpcmUoJy4vZXEnKVxuY29uc3QgbmVxID0gcmVxdWlyZSgnLi9uZXEnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuL2d0JylcbmNvbnN0IGd0ZSA9IHJlcXVpcmUoJy4vZ3RlJylcbmNvbnN0IGx0ID0gcmVxdWlyZSgnLi9sdCcpXG5jb25zdCBsdGUgPSByZXF1aXJlKCcuL2x0ZScpXG5cbmNvbnN0IGNtcCA9IChhLCBvcCwgYiwgbG9vc2UpID0+IHtcbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgJz09PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKVxuICAgICAgICBhID0gYS52ZXJzaW9uXG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdvYmplY3QnKVxuICAgICAgICBiID0gYi52ZXJzaW9uXG4gICAgICByZXR1cm4gYSA9PT0gYlxuXG4gICAgY2FzZSAnIT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpXG4gICAgICAgIGEgPSBhLnZlcnNpb25cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpXG4gICAgICAgIGIgPSBiLnZlcnNpb25cbiAgICAgIHJldHVybiBhICE9PSBiXG5cbiAgICBjYXNlICcnOlxuICAgIGNhc2UgJz0nOlxuICAgIGNhc2UgJz09JzpcbiAgICAgIHJldHVybiBlcShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJyE9JzpcbiAgICAgIHJldHVybiBuZXEoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc+JzpcbiAgICAgIHJldHVybiBndChhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJz49JzpcbiAgICAgIHJldHVybiBndGUoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc8JzpcbiAgICAgIHJldHVybiBsdChhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJzw9JzpcbiAgICAgIHJldHVybiBsdGUoYSwgYiwgbG9vc2UpXG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBvcGVyYXRvcjogJHtvcH1gKVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGNtcFxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHtyZSwgdH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IGNvZXJjZSA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgcmV0dXJuIHZlcnNpb25cbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ251bWJlcicpIHtcbiAgICB2ZXJzaW9uID0gU3RyaW5nKHZlcnNpb24pXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgbGV0IG1hdGNoID0gbnVsbFxuICBpZiAoIW9wdGlvbnMucnRsKSB7XG4gICAgbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKHJlW3QuQ09FUkNFXSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5kIHRoZSByaWdodC1tb3N0IGNvZXJjaWJsZSBzdHJpbmcgdGhhdCBkb2VzIG5vdCBzaGFyZVxuICAgIC8vIGEgdGVybWludXMgd2l0aCBhIG1vcmUgbGVmdC13YXJkIGNvZXJjaWJsZSBzdHJpbmcuXG4gICAgLy8gRWcsICcxLjIuMy40JyB3YW50cyB0byBjb2VyY2UgJzIuMy40Jywgbm90ICczLjQnIG9yICc0J1xuICAgIC8vXG4gICAgLy8gV2FsayB0aHJvdWdoIHRoZSBzdHJpbmcgY2hlY2tpbmcgd2l0aCBhIC9nIHJlZ2V4cFxuICAgIC8vIE1hbnVhbGx5IHNldCB0aGUgaW5kZXggc28gYXMgdG8gcGljayB1cCBvdmVybGFwcGluZyBtYXRjaGVzLlxuICAgIC8vIFN0b3Agd2hlbiB3ZSBnZXQgYSBtYXRjaCB0aGF0IGVuZHMgYXQgdGhlIHN0cmluZyBlbmQsIHNpbmNlIG5vXG4gICAgLy8gY29lcmNpYmxlIHN0cmluZyBjYW4gYmUgbW9yZSByaWdodC13YXJkIHdpdGhvdXQgdGhlIHNhbWUgdGVybWludXMuXG4gICAgbGV0IG5leHRcbiAgICB3aGlsZSAoKG5leHQgPSByZVt0LkNPRVJDRVJUTF0uZXhlYyh2ZXJzaW9uKSkgJiZcbiAgICAgICAgKCFtYXRjaCB8fCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCAhPT0gdmVyc2lvbi5sZW5ndGgpXG4gICAgKSB7XG4gICAgICBpZiAoIW1hdGNoIHx8XG4gICAgICAgICAgICBuZXh0LmluZGV4ICsgbmV4dFswXS5sZW5ndGggIT09IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSB7XG4gICAgICAgIG1hdGNoID0gbmV4dFxuICAgICAgfVxuICAgICAgcmVbdC5DT0VSQ0VSVExdLmxhc3RJbmRleCA9IG5leHQuaW5kZXggKyBuZXh0WzFdLmxlbmd0aCArIG5leHRbMl0ubGVuZ3RoXG4gICAgfVxuICAgIC8vIGxlYXZlIGl0IGluIGEgY2xlYW4gc3RhdGVcbiAgICByZVt0LkNPRVJDRVJUTF0ubGFzdEluZGV4ID0gLTFcbiAgfVxuXG4gIGlmIChtYXRjaCA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbFxuXG4gIHJldHVybiBwYXJzZShgJHttYXRjaFsyXX0uJHttYXRjaFszXSB8fCAnMCd9LiR7bWF0Y2hbNF0gfHwgJzAnfWAsIG9wdGlvbnMpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGNvZXJjZVxuIiwiLy8gaG9pc3RlZCBjbGFzcyBmb3IgY3ljbGljIGRlcGVuZGVuY3lcbmNsYXNzIFJhbmdlIHtcbiAgY29uc3RydWN0b3IgKHJhbmdlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgaWYgKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpIHtcbiAgICAgIGlmIChcbiAgICAgICAgcmFuZ2UubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSAmJlxuICAgICAgICByYW5nZS5pbmNsdWRlUHJlcmVsZWFzZSA9PT0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLnJhdywgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgICAvLyBqdXN0IHB1dCBpdCBpbiB0aGUgc2V0IGFuZCByZXR1cm5cbiAgICAgIHRoaXMucmF3ID0gcmFuZ2UudmFsdWVcbiAgICAgIHRoaXMuc2V0ID0gW1tyYW5nZV1dXG4gICAgICB0aGlzLmZvcm1hdCgpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG4gICAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuXG4gICAgLy8gRmlyc3QsIHNwbGl0IGJhc2VkIG9uIGJvb2xlYW4gb3IgfHxcbiAgICB0aGlzLnJhdyA9IHJhbmdlXG4gICAgdGhpcy5zZXQgPSByYW5nZVxuICAgICAgLnNwbGl0KC9cXHMqXFx8XFx8XFxzKi8pXG4gICAgICAvLyBtYXAgdGhlIHJhbmdlIHRvIGEgMmQgYXJyYXkgb2YgY29tcGFyYXRvcnNcbiAgICAgIC5tYXAocmFuZ2UgPT4gdGhpcy5wYXJzZVJhbmdlKHJhbmdlLnRyaW0oKSkpXG4gICAgICAvLyB0aHJvdyBvdXQgYW55IGNvbXBhcmF0b3IgbGlzdHMgdGhhdCBhcmUgZW1wdHlcbiAgICAgIC8vIHRoaXMgZ2VuZXJhbGx5IG1lYW5zIHRoYXQgaXQgd2FzIG5vdCBhIHZhbGlkIHJhbmdlLCB3aGljaCBpcyBhbGxvd2VkXG4gICAgICAvLyBpbiBsb29zZSBtb2RlLCBidXQgd2lsbCBzdGlsbCB0aHJvdyBpZiB0aGUgV0hPTEUgcmFuZ2UgaXMgaW52YWxpZC5cbiAgICAgIC5maWx0ZXIoYyA9PiBjLmxlbmd0aClcblxuICAgIGlmICghdGhpcy5zZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFNlbVZlciBSYW5nZTogJHtyYW5nZX1gKVxuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmUgYW55IHRoYXQgYXJlIG5vdCB0aGUgbnVsbCBzZXQsIHRocm93IG91dCBudWxsIHNldHMuXG4gICAgaWYgKHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIGtlZXAgdGhlIGZpcnN0IG9uZSwgaW4gY2FzZSB0aGV5J3JlIGFsbCBudWxsIHNldHNcbiAgICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5zZXRbMF1cbiAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXQuZmlsdGVyKGMgPT4gIWlzTnVsbFNldChjWzBdKSlcbiAgICAgIGlmICh0aGlzLnNldC5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMuc2V0ID0gW2ZpcnN0XVxuICAgICAgZWxzZSBpZiAodGhpcy5zZXQubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGFueSB0aGF0IGFyZSAqLCB0aGVuIHRoZSByYW5nZSBpcyBqdXN0ICpcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHRoaXMuc2V0KSB7XG4gICAgICAgICAgaWYgKGMubGVuZ3RoID09PSAxICYmIGlzQW55KGNbMF0pKSB7XG4gICAgICAgICAgICB0aGlzLnNldCA9IFtjXVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZvcm1hdCgpXG4gIH1cblxuICBmb3JtYXQgKCkge1xuICAgIHRoaXMucmFuZ2UgPSB0aGlzLnNldFxuICAgICAgLm1hcCgoY29tcHMpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbXBzLmpvaW4oJyAnKS50cmltKClcbiAgICAgIH0pXG4gICAgICAuam9pbignfHwnKVxuICAgICAgLnRyaW0oKVxuICAgIHJldHVybiB0aGlzLnJhbmdlXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2VcbiAgfVxuXG4gIHBhcnNlUmFuZ2UgKHJhbmdlKSB7XG4gICAgcmFuZ2UgPSByYW5nZS50cmltKClcblxuICAgIC8vIG1lbW9pemUgcmFuZ2UgcGFyc2luZyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgLy8gdGhpcyBpcyBhIHZlcnkgaG90IHBhdGgsIGFuZCBmdWxseSBkZXRlcm1pbmlzdGljLlxuICAgIGNvbnN0IG1lbW9PcHRzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zKS5qb2luKCcsJylcbiAgICBjb25zdCBtZW1vS2V5ID0gYHBhcnNlUmFuZ2U6JHttZW1vT3B0c306JHtyYW5nZX1gXG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KG1lbW9LZXkpXG4gICAgaWYgKGNhY2hlZClcbiAgICAgIHJldHVybiBjYWNoZWRcblxuICAgIGNvbnN0IGxvb3NlID0gdGhpcy5vcHRpb25zLmxvb3NlXG4gICAgLy8gYDEuMi4zIC0gMS4yLjRgID0+IGA+PTEuMi4zIDw9MS4yLjRgXG4gICAgY29uc3QgaHIgPSBsb29zZSA/IHJlW3QuSFlQSEVOUkFOR0VMT09TRV0gOiByZVt0LkhZUEhFTlJBTkdFXVxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShociwgaHlwaGVuUmVwbGFjZSh0aGlzLm9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpKVxuICAgIGRlYnVnKCdoeXBoZW4gcmVwbGFjZScsIHJhbmdlKVxuICAgIC8vIGA+IDEuMi4zIDwgMS4yLjVgID0+IGA+MS4yLjMgPDEuMi41YFxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LkNPTVBBUkFUT1JUUklNXSwgY29tcGFyYXRvclRyaW1SZXBsYWNlKVxuICAgIGRlYnVnKCdjb21wYXJhdG9yIHRyaW0nLCByYW5nZSwgcmVbdC5DT01QQVJBVE9SVFJJTV0pXG5cbiAgICAvLyBgfiAxLjIuM2AgPT4gYH4xLjIuM2BcbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5USUxERVRSSU1dLCB0aWxkZVRyaW1SZXBsYWNlKVxuXG4gICAgLy8gYF4gMS4yLjNgID0+IGBeMS4yLjNgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuQ0FSRVRUUklNXSwgY2FyZXRUcmltUmVwbGFjZSlcblxuICAgIC8vIG5vcm1hbGl6ZSBzcGFjZXNcbiAgICByYW5nZSA9IHJhbmdlLnNwbGl0KC9cXHMrLykuam9pbignICcpXG5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSB0cmltbWVkIGFuZFxuICAgIC8vIHJlYWR5IHRvIGJlIHNwbGl0IGludG8gY29tcGFyYXRvcnMuXG5cbiAgICBjb25zdCBjb21wUmUgPSBsb29zZSA/IHJlW3QuQ09NUEFSQVRPUkxPT1NFXSA6IHJlW3QuQ09NUEFSQVRPUl1cbiAgICBjb25zdCByYW5nZUxpc3QgPSByYW5nZVxuICAgICAgLnNwbGl0KCcgJylcbiAgICAgIC5tYXAoY29tcCA9PiBwYXJzZUNvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKSlcbiAgICAgIC5qb2luKCcgJylcbiAgICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgICAvLyA+PTAuMC4wIGlzIGVxdWl2YWxlbnQgdG8gKlxuICAgICAgLm1hcChjb21wID0+IHJlcGxhY2VHVEUwKGNvbXAsIHRoaXMub3B0aW9ucykpXG4gICAgICAvLyBpbiBsb29zZSBtb2RlLCB0aHJvdyBvdXQgYW55IHRoYXQgYXJlIG5vdCB2YWxpZCBjb21wYXJhdG9yc1xuICAgICAgLmZpbHRlcih0aGlzLm9wdGlvbnMubG9vc2UgPyBjb21wID0+ICEhY29tcC5tYXRjaChjb21wUmUpIDogKCkgPT4gdHJ1ZSlcbiAgICAgIC5tYXAoY29tcCA9PiBuZXcgQ29tcGFyYXRvcihjb21wLCB0aGlzLm9wdGlvbnMpKVxuXG4gICAgLy8gaWYgYW55IGNvbXBhcmF0b3JzIGFyZSB0aGUgbnVsbCBzZXQsIHRoZW4gcmVwbGFjZSB3aXRoIEpVU1QgbnVsbCBzZXRcbiAgICAvLyBpZiBtb3JlIHRoYW4gb25lIGNvbXBhcmF0b3IsIHJlbW92ZSBhbnkgKiBjb21wYXJhdG9yc1xuICAgIC8vIGFsc28sIGRvbid0IGluY2x1ZGUgdGhlIHNhbWUgY29tcGFyYXRvciBtb3JlIHRoYW4gb25jZVxuICAgIGNvbnN0IGwgPSByYW5nZUxpc3QubGVuZ3RoXG4gICAgY29uc3QgcmFuZ2VNYXAgPSBuZXcgTWFwKClcbiAgICBmb3IgKGNvbnN0IGNvbXAgb2YgcmFuZ2VMaXN0KSB7XG4gICAgICBpZiAoaXNOdWxsU2V0KGNvbXApKVxuICAgICAgICByZXR1cm4gW2NvbXBdXG4gICAgICByYW5nZU1hcC5zZXQoY29tcC52YWx1ZSwgY29tcClcbiAgICB9XG4gICAgaWYgKHJhbmdlTWFwLnNpemUgPiAxICYmIHJhbmdlTWFwLmhhcygnJykpXG4gICAgICByYW5nZU1hcC5kZWxldGUoJycpXG5cbiAgICBjb25zdCByZXN1bHQgPSBbLi4ucmFuZ2VNYXAudmFsdWVzKCldXG4gICAgY2FjaGUuc2V0KG1lbW9LZXksIHJlc3VsdClcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBpbnRlcnNlY3RzIChyYW5nZSwgb3B0aW9ucykge1xuICAgIGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIFJhbmdlIGlzIHJlcXVpcmVkJylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXQuc29tZSgodGhpc0NvbXBhcmF0b3JzKSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBpc1NhdGlzZmlhYmxlKHRoaXNDb21wYXJhdG9ycywgb3B0aW9ucykgJiZcbiAgICAgICAgcmFuZ2Uuc2V0LnNvbWUoKHJhbmdlQ29tcGFyYXRvcnMpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXNTYXRpc2ZpYWJsZShyYW5nZUNvbXBhcmF0b3JzLCBvcHRpb25zKSAmJlxuICAgICAgICAgICAgdGhpc0NvbXBhcmF0b3JzLmV2ZXJ5KCh0aGlzQ29tcGFyYXRvcikgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VDb21wYXJhdG9ycy5ldmVyeSgocmFuZ2VDb21wYXJhdG9yKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNDb21wYXJhdG9yLmludGVyc2VjdHMocmFuZ2VDb21wYXJhdG9yLCBvcHRpb25zKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfSlcbiAgfVxuXG4gIC8vIGlmIEFOWSBvZiB0aGUgc2V0cyBtYXRjaCBBTEwgb2YgaXRzIGNvbXBhcmF0b3JzLCB0aGVuIHBhc3NcbiAgdGVzdCAodmVyc2lvbikge1xuICAgIGlmICghdmVyc2lvbikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNldC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRlc3RTZXQodGhpcy5zZXRbaV0sIHZlcnNpb24sIHRoaXMub3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gUmFuZ2VcblxuY29uc3QgTFJVID0gcmVxdWlyZSgnbHJ1LWNhY2hlJylcbmNvbnN0IGNhY2hlID0gbmV3IExSVSh7IG1heDogMTAwMCB9KVxuXG5jb25zdCBwYXJzZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9wYXJzZS1vcHRpb25zJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuL2NvbXBhcmF0b3InKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuL3NlbXZlcicpXG5jb25zdCB7XG4gIHJlLFxuICB0LFxuICBjb21wYXJhdG9yVHJpbVJlcGxhY2UsXG4gIHRpbGRlVHJpbVJlcGxhY2UsXG4gIGNhcmV0VHJpbVJlcGxhY2Vcbn0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IGlzTnVsbFNldCA9IGMgPT4gYy52YWx1ZSA9PT0gJzwwLjAuMC0wJ1xuY29uc3QgaXNBbnkgPSBjID0+IGMudmFsdWUgPT09ICcnXG5cbi8vIHRha2UgYSBzZXQgb2YgY29tcGFyYXRvcnMgYW5kIGRldGVybWluZSB3aGV0aGVyIHRoZXJlXG4vLyBleGlzdHMgYSB2ZXJzaW9uIHdoaWNoIGNhbiBzYXRpc2Z5IGl0XG5jb25zdCBpc1NhdGlzZmlhYmxlID0gKGNvbXBhcmF0b3JzLCBvcHRpb25zKSA9PiB7XG4gIGxldCByZXN1bHQgPSB0cnVlXG4gIGNvbnN0IHJlbWFpbmluZ0NvbXBhcmF0b3JzID0gY29tcGFyYXRvcnMuc2xpY2UoKVxuICBsZXQgdGVzdENvbXBhcmF0b3IgPSByZW1haW5pbmdDb21wYXJhdG9ycy5wb3AoKVxuXG4gIHdoaWxlIChyZXN1bHQgJiYgcmVtYWluaW5nQ29tcGFyYXRvcnMubGVuZ3RoKSB7XG4gICAgcmVzdWx0ID0gcmVtYWluaW5nQ29tcGFyYXRvcnMuZXZlcnkoKG90aGVyQ29tcGFyYXRvcikgPT4ge1xuICAgICAgcmV0dXJuIHRlc3RDb21wYXJhdG9yLmludGVyc2VjdHMob3RoZXJDb21wYXJhdG9yLCBvcHRpb25zKVxuICAgIH0pXG5cbiAgICB0ZXN0Q29tcGFyYXRvciA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLnBvcCgpXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIGNvbXByaXNlZCBvZiB4cmFuZ2VzLCB0aWxkZXMsIHN0YXJzLCBhbmQgZ3RsdCdzIGF0IHRoaXMgcG9pbnQuXG4vLyBhbHJlYWR5IHJlcGxhY2VkIHRoZSBoeXBoZW4gcmFuZ2VzXG4vLyB0dXJuIGludG8gYSBzZXQgb2YgSlVTVCBjb21wYXJhdG9ycy5cbmNvbnN0IHBhcnNlQ29tcGFyYXRvciA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdjb21wJywgY29tcCwgb3B0aW9ucylcbiAgY29tcCA9IHJlcGxhY2VDYXJldHMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ2NhcmV0JywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VUaWxkZXMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3RpbGRlcycsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlWFJhbmdlcyhjb21wLCBvcHRpb25zKVxuICBkZWJ1ZygneHJhbmdlJywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VTdGFycyhjb21wLCBvcHRpb25zKVxuICBkZWJ1Zygnc3RhcnMnLCBjb21wKVxuICByZXR1cm4gY29tcFxufVxuXG5jb25zdCBpc1ggPSBpZCA9PiAhaWQgfHwgaWQudG9Mb3dlckNhc2UoKSA9PT0gJ3gnIHx8IGlkID09PSAnKidcblxuLy8gfiwgfj4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyB+MiwgfjIueCwgfjIueC54LCB+PjIsIH4+Mi54IH4+Mi54LnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIH4yLjAsIH4yLjAueCwgfj4yLjAsIH4+Mi4wLnggLS0+ID49Mi4wLjAgPDIuMS4wLTBcbi8vIH4xLjIsIH4xLjIueCwgfj4xLjIsIH4+MS4yLnggLS0+ID49MS4yLjAgPDEuMy4wLTBcbi8vIH4xLjIuMywgfj4xLjIuMyAtLT4gPj0xLjIuMyA8MS4zLjAtMFxuLy8gfjEuMi4wLCB+PjEuMi4wIC0tPiA+PTEuMi4wIDwxLjMuMC0wXG5jb25zdCByZXBsYWNlVGlsZGVzID0gKGNvbXAsIG9wdGlvbnMpID0+XG4gIGNvbXAudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKChjb21wKSA9PiB7XG4gICAgcmV0dXJuIHJlcGxhY2VUaWxkZShjb21wLCBvcHRpb25zKVxuICB9KS5qb2luKCcgJylcblxuY29uc3QgcmVwbGFjZVRpbGRlID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LlRJTERFTE9PU0VdIDogcmVbdC5USUxERV1cbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCAoXywgTSwgbSwgcCwgcHIpID0+IHtcbiAgICBkZWJ1ZygndGlsZGUnLCBjb21wLCBfLCBNLCBtLCBwLCBwcilcbiAgICBsZXQgcmV0XG5cbiAgICBpZiAoaXNYKE0pKSB7XG4gICAgICByZXQgPSAnJ1xuICAgIH0gZWxzZSBpZiAoaXNYKG0pKSB7XG4gICAgICByZXQgPSBgPj0ke019LjAuMCA8JHsrTSArIDF9LjAuMC0wYFxuICAgIH0gZWxzZSBpZiAoaXNYKHApKSB7XG4gICAgICAvLyB+MS4yID09ID49MS4yLjAgPDEuMy4wLTBcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wIDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgfSBlbHNlIGlmIChwcikge1xuICAgICAgZGVidWcoJ3JlcGxhY2VUaWxkZSBwcicsIHByKVxuICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwclxuICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB+MS4yLjMgPT0gPj0xLjIuMyA8MS4zLjAtMFxuICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH1cblxuICAgIGRlYnVnKCd0aWxkZSByZXR1cm4nLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG4vLyBeIC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gXjIsIF4yLngsIF4yLngueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuLy8gXjIuMCwgXjIuMC54IC0tPiA+PTIuMC4wIDwzLjAuMC0wXG4vLyBeMS4yLCBeMS4yLnggLS0+ID49MS4yLjAgPDIuMC4wLTBcbi8vIF4xLjIuMyAtLT4gPj0xLjIuMyA8Mi4wLjAtMFxuLy8gXjEuMi4wIC0tPiA+PTEuMi4wIDwyLjAuMC0wXG5jb25zdCByZXBsYWNlQ2FyZXRzID0gKGNvbXAsIG9wdGlvbnMpID0+XG4gIGNvbXAudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKChjb21wKSA9PiB7XG4gICAgcmV0dXJuIHJlcGxhY2VDYXJldChjb21wLCBvcHRpb25zKVxuICB9KS5qb2luKCcgJylcblxuY29uc3QgcmVwbGFjZUNhcmV0ID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ2NhcmV0JywgY29tcCwgb3B0aW9ucylcbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LkNBUkVUTE9PU0VdIDogcmVbdC5DQVJFVF1cbiAgY29uc3QgeiA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyAnLTAnIDogJydcbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCAoXywgTSwgbSwgcCwgcHIpID0+IHtcbiAgICBkZWJ1ZygnY2FyZXQnLCBjb21wLCBfLCBNLCBtLCBwLCBwcilcbiAgICBsZXQgcmV0XG5cbiAgICBpZiAoaXNYKE0pKSB7XG4gICAgICByZXQgPSAnJ1xuICAgIH0gZWxzZSBpZiAoaXNYKG0pKSB7XG4gICAgICByZXQgPSBgPj0ke019LjAuMCR7en0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKGlzWChwKSkge1xuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7en0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wJHt6fSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlQ2FyZXQgcHInLCBwcilcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgaWYgKG0gPT09ICcwJykge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgICB9IDwke019LiR7bX0uJHsrcCArIDF9LTBgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwclxuICAgICAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwclxuICAgICAgICB9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdubyBwcicpXG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwXG4gICAgICAgICAgfSR7en0gPCR7TX0uJHttfS4keytwICsgMX0tMGBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwXG4gICAgICAgICAgfSR7en0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICB9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVidWcoJ2NhcmV0IHJldHVybicsIHJldClcbiAgICByZXR1cm4gcmV0XG4gIH0pXG59XG5cbmNvbnN0IHJlcGxhY2VYUmFuZ2VzID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ3JlcGxhY2VYUmFuZ2VzJywgY29tcCwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAuc3BsaXQoL1xccysvKS5tYXAoKGNvbXApID0+IHtcbiAgICByZXR1cm4gcmVwbGFjZVhSYW5nZShjb21wLCBvcHRpb25zKVxuICB9KS5qb2luKCcgJylcbn1cblxuY29uc3QgcmVwbGFjZVhSYW5nZSA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGNvbXAgPSBjb21wLnRyaW0oKVxuICBjb25zdCByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuWFJBTkdFTE9PU0VdIDogcmVbdC5YUkFOR0VdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpID0+IHtcbiAgICBkZWJ1ZygneFJhbmdlJywgY29tcCwgcmV0LCBndGx0LCBNLCBtLCBwLCBwcilcbiAgICBjb25zdCB4TSA9IGlzWChNKVxuICAgIGNvbnN0IHhtID0geE0gfHwgaXNYKG0pXG4gICAgY29uc3QgeHAgPSB4bSB8fCBpc1gocClcbiAgICBjb25zdCBhbnlYID0geHBcblxuICAgIGlmIChndGx0ID09PSAnPScgJiYgYW55WCkge1xuICAgICAgZ3RsdCA9ICcnXG4gICAgfVxuXG4gICAgLy8gaWYgd2UncmUgaW5jbHVkaW5nIHByZXJlbGVhc2VzIGluIHRoZSBtYXRjaCwgdGhlbiB3ZSBuZWVkXG4gICAgLy8gdG8gZml4IHRoaXMgdG8gLTAsIHRoZSBsb3dlc3QgcG9zc2libGUgcHJlcmVsZWFzZSB2YWx1ZVxuICAgIHByID0gb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/ICctMCcgOiAnJ1xuXG4gICAgaWYgKHhNKSB7XG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nIHx8IGd0bHQgPT09ICc8Jykge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGFsbG93ZWRcbiAgICAgICAgcmV0ID0gJzwwLjAuMC0wJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBmb3JiaWRkZW5cbiAgICAgICAgcmV0ID0gJyonXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChndGx0ICYmIGFueVgpIHtcbiAgICAgIC8vIHdlIGtub3cgcGF0Y2ggaXMgYW4geCwgYmVjYXVzZSB3ZSBoYXZlIGFueSB4IGF0IGFsbC5cbiAgICAgIC8vIHJlcGxhY2UgWCB3aXRoIDBcbiAgICAgIGlmICh4bSkge1xuICAgICAgICBtID0gMFxuICAgICAgfVxuICAgICAgcCA9IDBcblxuICAgICAgaWYgKGd0bHQgPT09ICc+Jykge1xuICAgICAgICAvLyA+MSA9PiA+PTIuMC4wXG4gICAgICAgIC8vID4xLjIgPT4gPj0xLjMuMFxuICAgICAgICBndGx0ID0gJz49J1xuICAgICAgICBpZiAoeG0pIHtcbiAgICAgICAgICBNID0gK00gKyAxXG4gICAgICAgICAgbSA9IDBcbiAgICAgICAgICBwID0gMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSArbSArIDFcbiAgICAgICAgICBwID0gMFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGd0bHQgPT09ICc8PScpIHtcbiAgICAgICAgLy8gPD0wLjcueCBpcyBhY3R1YWxseSA8MC44LjAsIHNpbmNlIGFueSAwLjcueCBzaG91bGRcbiAgICAgICAgLy8gcGFzcy4gIFNpbWlsYXJseSwgPD03LnggaXMgYWN0dWFsbHkgPDguMC4wLCBldGMuXG4gICAgICAgIGd0bHQgPSAnPCdcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSArbSArIDFcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZ3RsdCA9PT0gJzwnKVxuICAgICAgICBwciA9ICctMCdcblxuICAgICAgcmV0ID0gYCR7Z3RsdCArIE19LiR7bX0uJHtwfSR7cHJ9YFxuICAgIH0gZWxzZSBpZiAoeG0pIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uMC4wJHtwcn0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKHhwKSB7XG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7cHJcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9XG5cbiAgICBkZWJ1ZygneFJhbmdlIHJldHVybicsIHJldClcblxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuLy8gQmVjYXVzZSAqIGlzIEFORC1lZCB3aXRoIGV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgY29tcGFyYXRvcixcbi8vIGFuZCAnJyBtZWFucyBcImFueSB2ZXJzaW9uXCIsIGp1c3QgcmVtb3ZlIHRoZSAqcyBlbnRpcmVseS5cbmNvbnN0IHJlcGxhY2VTdGFycyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlU3RhcnMnLCBjb21wLCBvcHRpb25zKVxuICAvLyBMb29zZW5lc3MgaXMgaWdub3JlZCBoZXJlLiAgc3RhciBpcyBhbHdheXMgYXMgbG9vc2UgYXMgaXQgZ2V0cyFcbiAgcmV0dXJuIGNvbXAudHJpbSgpLnJlcGxhY2UocmVbdC5TVEFSXSwgJycpXG59XG5cbmNvbnN0IHJlcGxhY2VHVEUwID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ3JlcGxhY2VHVEUwJywgY29tcCwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAudHJpbSgpXG4gICAgLnJlcGxhY2UocmVbb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/IHQuR1RFMFBSRSA6IHQuR1RFMF0sICcnKVxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHBhc3NlZCB0byBzdHJpbmcucmVwbGFjZShyZVt0LkhZUEhFTlJBTkdFXSlcbi8vIE0sIG0sIHBhdGNoLCBwcmVyZWxlYXNlLCBidWlsZFxuLy8gMS4yIC0gMy40LjUgPT4gPj0xLjIuMCA8PTMuNC41XG4vLyAxLjIuMyAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMC0wIEFueSAzLjQueCB3aWxsIGRvXG4vLyAxLjIgLSAzLjQgPT4gPj0xLjIuMCA8My41LjAtMFxuY29uc3QgaHlwaGVuUmVwbGFjZSA9IGluY1ByID0+ICgkMCxcbiAgZnJvbSwgZk0sIGZtLCBmcCwgZnByLCBmYixcbiAgdG8sIHRNLCB0bSwgdHAsIHRwciwgdGIpID0+IHtcbiAgaWYgKGlzWChmTSkpIHtcbiAgICBmcm9tID0gJydcbiAgfSBlbHNlIGlmIChpc1goZm0pKSB7XG4gICAgZnJvbSA9IGA+PSR7Zk19LjAuMCR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9IGVsc2UgaWYgKGlzWChmcCkpIHtcbiAgICBmcm9tID0gYD49JHtmTX0uJHtmbX0uMCR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9IGVsc2UgaWYgKGZwcikge1xuICAgIGZyb20gPSBgPj0ke2Zyb219YFxuICB9IGVsc2Uge1xuICAgIGZyb20gPSBgPj0ke2Zyb219JHtpbmNQciA/ICctMCcgOiAnJ31gXG4gIH1cblxuICBpZiAoaXNYKHRNKSkge1xuICAgIHRvID0gJydcbiAgfSBlbHNlIGlmIChpc1godG0pKSB7XG4gICAgdG8gPSBgPCR7K3RNICsgMX0uMC4wLTBgXG4gIH0gZWxzZSBpZiAoaXNYKHRwKSkge1xuICAgIHRvID0gYDwke3RNfS4keyt0bSArIDF9LjAtMGBcbiAgfSBlbHNlIGlmICh0cHIpIHtcbiAgICB0byA9IGA8PSR7dE19LiR7dG19LiR7dHB9LSR7dHByfWBcbiAgfSBlbHNlIGlmIChpbmNQcikge1xuICAgIHRvID0gYDwke3RNfS4ke3RtfS4keyt0cCArIDF9LTBgXG4gIH0gZWxzZSB7XG4gICAgdG8gPSBgPD0ke3RvfWBcbiAgfVxuXG4gIHJldHVybiAoYCR7ZnJvbX0gJHt0b31gKS50cmltKClcbn1cblxuY29uc3QgdGVzdFNldCA9IChzZXQsIHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXNldFtpXS50ZXN0KHZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBpZiAodmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgIC8vIEZpbmQgdGhlIHNldCBvZiB2ZXJzaW9ucyB0aGF0IGFyZSBhbGxvd2VkIHRvIGhhdmUgcHJlcmVsZWFzZXNcbiAgICAvLyBGb3IgZXhhbXBsZSwgXjEuMi4zLXByLjEgZGVzdWdhcnMgdG8gPj0xLjIuMy1wci4xIDwyLjAuMFxuICAgIC8vIFRoYXQgc2hvdWxkIGFsbG93IGAxLjIuMy1wci4yYCB0byBwYXNzLlxuICAgIC8vIEhvd2V2ZXIsIGAxLjIuNC1hbHBoYS5ub3RyZWFkeWAgc2hvdWxkIE5PVCBiZSBhbGxvd2VkLFxuICAgIC8vIGV2ZW4gdGhvdWdoIGl0J3Mgd2l0aGluIHRoZSByYW5nZSBzZXQgYnkgdGhlIGNvbXBhcmF0b3JzLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWJ1ZyhzZXRbaV0uc2VtdmVyKVxuICAgICAgaWYgKHNldFtpXS5zZW12ZXIgPT09IENvbXBhcmF0b3IuQU5ZKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBhbGxvd2VkID0gc2V0W2ldLnNlbXZlclxuICAgICAgICBpZiAoYWxsb3dlZC5tYWpvciA9PT0gdmVyc2lvbi5tYWpvciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5taW5vciA9PT0gdmVyc2lvbi5taW5vciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5wYXRjaCA9PT0gdmVyc2lvbi5wYXRjaCkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWZXJzaW9uIGhhcyBhIC1wcmUsIGJ1dCBpdCdzIG5vdCBvbmUgb2YgdGhlIG9uZXMgd2UgbGlrZS5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCJjb25zdCBBTlkgPSBTeW1ib2woJ1NlbVZlciBBTlknKVxuLy8gaG9pc3RlZCBjbGFzcyBmb3IgY3ljbGljIGRlcGVuZGVuY3lcbmNsYXNzIENvbXBhcmF0b3Ige1xuICBzdGF0aWMgZ2V0IEFOWSAoKSB7XG4gICAgcmV0dXJuIEFOWVxuICB9XG4gIGNvbnN0cnVjdG9yIChjb21wLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgaWYgKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgICBpZiAoY29tcC5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlKSB7XG4gICAgICAgIHJldHVybiBjb21wXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wID0gY29tcC52YWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGRlYnVnKCdjb21wYXJhdG9yJywgY29tcCwgb3B0aW9ucylcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICAgIHRoaXMucGFyc2UoY29tcClcblxuICAgIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICB0aGlzLnZhbHVlID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMub3BlcmF0b3IgKyB0aGlzLnNlbXZlci52ZXJzaW9uXG4gICAgfVxuXG4gICAgZGVidWcoJ2NvbXAnLCB0aGlzKVxuICB9XG5cbiAgcGFyc2UgKGNvbXApIHtcbiAgICBjb25zdCByID0gdGhpcy5vcHRpb25zLmxvb3NlID8gcmVbdC5DT01QQVJBVE9STE9PU0VdIDogcmVbdC5DT01QQVJBVE9SXVxuICAgIGNvbnN0IG0gPSBjb21wLm1hdGNoKHIpXG5cbiAgICBpZiAoIW0pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgY29tcGFyYXRvcjogJHtjb21wfWApXG4gICAgfVxuXG4gICAgdGhpcy5vcGVyYXRvciA9IG1bMV0gIT09IHVuZGVmaW5lZCA/IG1bMV0gOiAnJ1xuICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSAnPScpIHtcbiAgICAgIHRoaXMub3BlcmF0b3IgPSAnJ1xuICAgIH1cblxuICAgIC8vIGlmIGl0IGxpdGVyYWxseSBpcyBqdXN0ICc+JyBvciAnJyB0aGVuIGFsbG93IGFueXRoaW5nLlxuICAgIGlmICghbVsyXSkge1xuICAgICAgdGhpcy5zZW12ZXIgPSBBTllcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW12ZXIgPSBuZXcgU2VtVmVyKG1bMl0sIHRoaXMub3B0aW9ucy5sb29zZSlcbiAgICB9XG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVcbiAgfVxuXG4gIHRlc3QgKHZlcnNpb24pIHtcbiAgICBkZWJ1ZygnQ29tcGFyYXRvci50ZXN0JywgdmVyc2lvbiwgdGhpcy5vcHRpb25zLmxvb3NlKVxuXG4gICAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkgfHwgdmVyc2lvbiA9PT0gQU5ZKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMub3B0aW9ucylcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbXAodmVyc2lvbiwgdGhpcy5vcGVyYXRvciwgdGhpcy5zZW12ZXIsIHRoaXMub3B0aW9ucylcbiAgfVxuXG4gIGludGVyc2VjdHMgKGNvbXAsIG9wdGlvbnMpIHtcbiAgICBpZiAoIShjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgQ29tcGFyYXRvciBpcyByZXF1aXJlZCcpXG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgbG9vc2U6ICEhb3B0aW9ucyxcbiAgICAgICAgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgICBpZiAodGhpcy52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmFuZ2UoY29tcC52YWx1ZSwgb3B0aW9ucykudGVzdCh0aGlzLnZhbHVlKVxuICAgIH0gZWxzZSBpZiAoY29tcC5vcGVyYXRvciA9PT0gJycpIHtcbiAgICAgIGlmIChjb21wLnZhbHVlID09PSAnJykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYW5nZSh0aGlzLnZhbHVlLCBvcHRpb25zKS50ZXN0KGNvbXAuc2VtdmVyKVxuICAgIH1cblxuICAgIGNvbnN0IHNhbWVEaXJlY3Rpb25JbmNyZWFzaW5nID1cbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiZcbiAgICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc+JylcbiAgICBjb25zdCBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyA9XG4gICAgICAodGhpcy5vcGVyYXRvciA9PT0gJzw9JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPCcpICYmXG4gICAgICAoY29tcC5vcGVyYXRvciA9PT0gJzw9JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPCcpXG4gICAgY29uc3Qgc2FtZVNlbVZlciA9IHRoaXMuc2VtdmVyLnZlcnNpb24gPT09IGNvbXAuc2VtdmVyLnZlcnNpb25cbiAgICBjb25zdCBkaWZmZXJlbnREaXJlY3Rpb25zSW5jbHVzaXZlID1cbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8PScpICYmXG4gICAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPD0nKVxuICAgIGNvbnN0IG9wcG9zaXRlRGlyZWN0aW9uc0xlc3NUaGFuID1cbiAgICAgIGNtcCh0aGlzLnNlbXZlciwgJzwnLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiZcbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiZcbiAgICAgICAgKGNvbXAub3BlcmF0b3IgPT09ICc8PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzwnKVxuICAgIGNvbnN0IG9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuID1cbiAgICAgIGNtcCh0aGlzLnNlbXZlciwgJz4nLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiZcbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPD0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8JykgJiZcbiAgICAgICAgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJz4nKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIHNhbWVEaXJlY3Rpb25JbmNyZWFzaW5nIHx8XG4gICAgICBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyB8fFxuICAgICAgKHNhbWVTZW1WZXIgJiYgZGlmZmVyZW50RGlyZWN0aW9uc0luY2x1c2l2ZSkgfHxcbiAgICAgIG9wcG9zaXRlRGlyZWN0aW9uc0xlc3NUaGFuIHx8XG4gICAgICBvcHBvc2l0ZURpcmVjdGlvbnNHcmVhdGVyVGhhblxuICAgIClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBhcmF0b3JcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCB7cmUsIHR9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuY29uc3QgY21wID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NtcCcpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4vc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi9yYW5nZScpXG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3Qgc2F0aXNmaWVzID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIHRyeSB7XG4gICAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHJhbmdlLnRlc3QodmVyc2lvbilcbn1cbm1vZHVsZS5leHBvcnRzID0gc2F0aXNmaWVzXG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuXG4vLyBNb3N0bHkganVzdCBmb3IgdGVzdGluZyBhbmQgbGVnYWN5IEFQSSByZWFzb25zXG5jb25zdCB0b0NvbXBhcmF0b3JzID0gKHJhbmdlLCBvcHRpb25zKSA9PlxuICBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpLnNldFxuICAgIC5tYXAoY29tcCA9PiBjb21wLm1hcChjID0+IGMudmFsdWUpLmpvaW4oJyAnKS50cmltKCkuc3BsaXQoJyAnKSlcblxubW9kdWxlLmV4cG9ydHMgPSB0b0NvbXBhcmF0b3JzXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuXG5jb25zdCBtYXhTYXRpc2Z5aW5nID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBsZXQgbWF4ID0gbnVsbFxuICBsZXQgbWF4U1YgPSBudWxsXG4gIGxldCByYW5nZU9iaiA9IG51bGxcbiAgdHJ5IHtcbiAgICByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZlcnNpb25zLmZvckVhY2goKHYpID0+IHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkge1xuICAgICAgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtYXggfHwgbWF4U1YuY29tcGFyZSh2KSA9PT0gLTEpIHtcbiAgICAgICAgLy8gY29tcGFyZShtYXgsIHYsIHRydWUpXG4gICAgICAgIG1heCA9IHZcbiAgICAgICAgbWF4U1YgPSBuZXcgU2VtVmVyKG1heCwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBtYXhcbn1cbm1vZHVsZS5leHBvcnRzID0gbWF4U2F0aXNmeWluZ1xuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IG1pblNhdGlzZnlpbmcgPSAodmVyc2lvbnMsIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIGxldCBtaW4gPSBudWxsXG4gIGxldCBtaW5TViA9IG51bGxcbiAgbGV0IHJhbmdlT2JqID0gbnVsbFxuICB0cnkge1xuICAgIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmVyc2lvbnMuZm9yRWFjaCgodikgPT4ge1xuICAgIGlmIChyYW5nZU9iai50ZXN0KHYpKSB7XG4gICAgICAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgICBpZiAoIW1pbiB8fCBtaW5TVi5jb21wYXJlKHYpID09PSAxKSB7XG4gICAgICAgIC8vIGNvbXBhcmUobWluLCB2LCB0cnVlKVxuICAgICAgICBtaW4gPSB2XG4gICAgICAgIG1pblNWID0gbmV3IFNlbVZlcihtaW4sIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWluXG59XG5tb2R1bGUuZXhwb3J0cyA9IG1pblNhdGlzZnlpbmdcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9ndCcpXG5cbmNvbnN0IG1pblZlcnNpb24gPSAocmFuZ2UsIGxvb3NlKSA9PiB7XG4gIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSlcblxuICBsZXQgbWludmVyID0gbmV3IFNlbVZlcignMC4wLjAnKVxuICBpZiAocmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgbWludmVyID0gbmV3IFNlbVZlcignMC4wLjAtMCcpXG4gIGlmIChyYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICBtaW52ZXIgPSBudWxsXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV1cblxuICAgIGxldCBzZXRNaW4gPSBudWxsXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaCgoY29tcGFyYXRvcikgPT4ge1xuICAgICAgLy8gQ2xvbmUgdG8gYXZvaWQgbWFuaXB1bGF0aW5nIHRoZSBjb21wYXJhdG9yJ3Mgc2VtdmVyIG9iamVjdC5cbiAgICAgIGNvbnN0IGNvbXB2ZXIgPSBuZXcgU2VtVmVyKGNvbXBhcmF0b3Iuc2VtdmVyLnZlcnNpb24pXG4gICAgICBzd2l0Y2ggKGNvbXBhcmF0b3Iub3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgaWYgKGNvbXB2ZXIucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbXB2ZXIucGF0Y2grK1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wdmVyLnByZXJlbGVhc2UucHVzaCgwKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb21wdmVyLnJhdyA9IGNvbXB2ZXIuZm9ybWF0KClcbiAgICAgICAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICcnOlxuICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgaWYgKCFzZXRNaW4gfHwgZ3QoY29tcHZlciwgc2V0TWluKSkge1xuICAgICAgICAgICAgc2V0TWluID0gY29tcHZlclxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgIC8qIElnbm9yZSBtYXhpbXVtIHZlcnNpb25zICovXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgb3BlcmF0aW9uOiAke2NvbXBhcmF0b3Iub3BlcmF0b3J9YClcbiAgICAgIH1cbiAgICB9KVxuICAgIGlmIChzZXRNaW4gJiYgKCFtaW52ZXIgfHwgZ3QobWludmVyLCBzZXRNaW4pKSlcbiAgICAgIG1pbnZlciA9IHNldE1pblxuICB9XG5cbiAgaWYgKG1pbnZlciAmJiByYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBtaW5WZXJzaW9uXG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgdmFsaWRSYW5nZSA9IChyYW5nZSwgb3B0aW9ucykgPT4ge1xuICB0cnkge1xuICAgIC8vIFJldHVybiAnKicgaW5zdGVhZCBvZiAnJyBzbyB0aGF0IHRydXRoaW5lc3Mgd29ya3MuXG4gICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIGl0J3MgaW52YWxpZCBhbnl3YXlcbiAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKS5yYW5nZSB8fCAnKidcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkUmFuZ2VcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuLi9jbGFzc2VzL2NvbXBhcmF0b3InKVxuY29uc3Qge0FOWX0gPSBDb21wYXJhdG9yXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcycpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9ndCcpXG5jb25zdCBsdCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9sdCcpXG5jb25zdCBsdGUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvbHRlJylcbmNvbnN0IGd0ZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9ndGUnKVxuXG5jb25zdCBvdXRzaWRlID0gKHZlcnNpb24sIHJhbmdlLCBoaWxvLCBvcHRpb25zKSA9PiB7XG4gIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpXG4gIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuXG4gIGxldCBndGZuLCBsdGVmbiwgbHRmbiwgY29tcCwgZWNvbXBcbiAgc3dpdGNoIChoaWxvKSB7XG4gICAgY2FzZSAnPic6XG4gICAgICBndGZuID0gZ3RcbiAgICAgIGx0ZWZuID0gbHRlXG4gICAgICBsdGZuID0gbHRcbiAgICAgIGNvbXAgPSAnPidcbiAgICAgIGVjb21wID0gJz49J1xuICAgICAgYnJlYWtcbiAgICBjYXNlICc8JzpcbiAgICAgIGd0Zm4gPSBsdFxuICAgICAgbHRlZm4gPSBndGVcbiAgICAgIGx0Zm4gPSBndFxuICAgICAgY29tcCA9ICc8J1xuICAgICAgZWNvbXAgPSAnPD0nXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNdXN0IHByb3ZpZGUgYSBoaWxvIHZhbCBvZiBcIjxcIiBvciBcIj5cIicpXG4gIH1cblxuICAvLyBJZiBpdCBzYXRpc2ZpZXMgdGhlIHJhbmdlIGl0IGlzIG5vdCBvdXRzaWRlXG4gIGlmIChzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBGcm9tIG5vdyBvbiwgdmFyaWFibGUgdGVybXMgYXJlIGFzIGlmIHdlJ3JlIGluIFwiZ3RyXCIgbW9kZS5cbiAgLy8gYnV0IG5vdGUgdGhhdCBldmVyeXRoaW5nIGlzIGZsaXBwZWQgZm9yIHRoZSBcImx0clwiIGZ1bmN0aW9uLlxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV1cblxuICAgIGxldCBoaWdoID0gbnVsbFxuICAgIGxldCBsb3cgPSBudWxsXG5cbiAgICBjb21wYXJhdG9ycy5mb3JFYWNoKChjb21wYXJhdG9yKSA9PiB7XG4gICAgICBpZiAoY29tcGFyYXRvci5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgICBjb21wYXJhdG9yID0gbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKVxuICAgICAgfVxuICAgICAgaGlnaCA9IGhpZ2ggfHwgY29tcGFyYXRvclxuICAgICAgbG93ID0gbG93IHx8IGNvbXBhcmF0b3JcbiAgICAgIGlmIChndGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBoaWdoLnNlbXZlciwgb3B0aW9ucykpIHtcbiAgICAgICAgaGlnaCA9IGNvbXBhcmF0b3JcbiAgICAgIH0gZWxzZSBpZiAobHRmbihjb21wYXJhdG9yLnNlbXZlciwgbG93LnNlbXZlciwgb3B0aW9ucykpIHtcbiAgICAgICAgbG93ID0gY29tcGFyYXRvclxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBJZiB0aGUgZWRnZSB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGEgb3BlcmF0b3IgdGhlbiBvdXIgdmVyc2lvblxuICAgIC8vIGlzbid0IG91dHNpZGUgaXRcbiAgICBpZiAoaGlnaC5vcGVyYXRvciA9PT0gY29tcCB8fCBoaWdoLm9wZXJhdG9yID09PSBlY29tcCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGxvd2VzdCB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGFuIG9wZXJhdG9yIGFuZCBvdXIgdmVyc2lvblxuICAgIC8vIGlzIGxlc3MgdGhhbiBpdCB0aGVuIGl0IGlzbid0IGhpZ2hlciB0aGFuIHRoZSByYW5nZVxuICAgIGlmICgoIWxvdy5vcGVyYXRvciB8fCBsb3cub3BlcmF0b3IgPT09IGNvbXApICYmXG4gICAgICAgIGx0ZWZuKHZlcnNpb24sIGxvdy5zZW12ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2UgaWYgKGxvdy5vcGVyYXRvciA9PT0gZWNvbXAgJiYgbHRmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3V0c2lkZVxuIiwiLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlLlxuY29uc3Qgb3V0c2lkZSA9IHJlcXVpcmUoJy4vb3V0c2lkZScpXG5jb25zdCBndHIgPSAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpID0+IG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc+Jywgb3B0aW9ucylcbm1vZHVsZS5leHBvcnRzID0gZ3RyXG4iLCJjb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9vdXRzaWRlJylcbi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGxlc3MgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZVxuY29uc3QgbHRyID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPCcsIG9wdGlvbnMpXG5tb2R1bGUuZXhwb3J0cyA9IGx0clxuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IGludGVyc2VjdHMgPSAocjEsIHIyLCBvcHRpb25zKSA9PiB7XG4gIHIxID0gbmV3IFJhbmdlKHIxLCBvcHRpb25zKVxuICByMiA9IG5ldyBSYW5nZShyMiwgb3B0aW9ucylcbiAgcmV0dXJuIHIxLmludGVyc2VjdHMocjIpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGludGVyc2VjdHNcbiIsIi8vIGdpdmVuIGEgc2V0IG9mIHZlcnNpb25zIGFuZCBhIHJhbmdlLCBjcmVhdGUgYSBcInNpbXBsaWZpZWRcIiByYW5nZVxuLy8gdGhhdCBpbmNsdWRlcyB0aGUgc2FtZSB2ZXJzaW9ucyB0aGF0IHRoZSBvcmlnaW5hbCByYW5nZSBkb2VzXG4vLyBJZiB0aGUgb3JpZ2luYWwgcmFuZ2UgaXMgc2hvcnRlciB0aGFuIHRoZSBzaW1wbGlmaWVkIG9uZSwgcmV0dXJuIHRoYXQuXG5jb25zdCBzYXRpc2ZpZXMgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzJylcbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvY29tcGFyZS5qcycpXG5tb2R1bGUuZXhwb3J0cyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgc2V0ID0gW11cbiAgbGV0IG1pbiA9IG51bGxcbiAgbGV0IHByZXYgPSBudWxsXG4gIGNvbnN0IHYgPSB2ZXJzaW9ucy5zb3J0KChhLCBiKSA9PiBjb21wYXJlKGEsIGIsIG9wdGlvbnMpKVxuICBmb3IgKGNvbnN0IHZlcnNpb24gb2Ygdikge1xuICAgIGNvbnN0IGluY2x1ZGVkID0gc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKVxuICAgIGlmIChpbmNsdWRlZCkge1xuICAgICAgcHJldiA9IHZlcnNpb25cbiAgICAgIGlmICghbWluKVxuICAgICAgICBtaW4gPSB2ZXJzaW9uXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgIHNldC5wdXNoKFttaW4sIHByZXZdKVxuICAgICAgfVxuICAgICAgcHJldiA9IG51bGxcbiAgICAgIG1pbiA9IG51bGxcbiAgICB9XG4gIH1cbiAgaWYgKG1pbilcbiAgICBzZXQucHVzaChbbWluLCBudWxsXSlcblxuICBjb25zdCByYW5nZXMgPSBbXVxuICBmb3IgKGNvbnN0IFttaW4sIG1heF0gb2Ygc2V0KSB7XG4gICAgaWYgKG1pbiA9PT0gbWF4KVxuICAgICAgcmFuZ2VzLnB1c2gobWluKVxuICAgIGVsc2UgaWYgKCFtYXggJiYgbWluID09PSB2WzBdKVxuICAgICAgcmFuZ2VzLnB1c2goJyonKVxuICAgIGVsc2UgaWYgKCFtYXgpXG4gICAgICByYW5nZXMucHVzaChgPj0ke21pbn1gKVxuICAgIGVsc2UgaWYgKG1pbiA9PT0gdlswXSlcbiAgICAgIHJhbmdlcy5wdXNoKGA8PSR7bWF4fWApXG4gICAgZWxzZVxuICAgICAgcmFuZ2VzLnB1c2goYCR7bWlufSAtICR7bWF4fWApXG4gIH1cbiAgY29uc3Qgc2ltcGxpZmllZCA9IHJhbmdlcy5qb2luKCcgfHwgJylcbiAgY29uc3Qgb3JpZ2luYWwgPSB0eXBlb2YgcmFuZ2UucmF3ID09PSAnc3RyaW5nJyA/IHJhbmdlLnJhdyA6IFN0cmluZyhyYW5nZSlcbiAgcmV0dXJuIHNpbXBsaWZpZWQubGVuZ3RoIDwgb3JpZ2luYWwubGVuZ3RoID8gc2ltcGxpZmllZCA6IHJhbmdlXG59XG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UuanMnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvY29tcGFyYXRvci5qcycpXG5jb25zdCB7IEFOWSB9ID0gQ29tcGFyYXRvclxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcy5qcycpXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NvbXBhcmUuanMnKVxuXG4vLyBDb21wbGV4IHJhbmdlIGByMSB8fCByMiB8fCAuLi5gIGlzIGEgc3Vic2V0IG9mIGBSMSB8fCBSMiB8fCAuLi5gIGlmZjpcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgaXMgYSBudWxsIHNldCwgT1Jcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgd2hpY2ggaXMgbm90IGEgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2Zcbi8vICAgc29tZSBgUjEsIFIyLCAuLi5gXG4vL1xuLy8gU2ltcGxlIHJhbmdlIGBjMSBjMiAuLi5gIGlzIGEgc3Vic2V0IG9mIHNpbXBsZSByYW5nZSBgQzEgQzIgLi4uYCBpZmY6XG4vLyAtIElmIGMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBJZiBDIGlzIG9ubHkgdGhlIEFOWSBjb21wYXJhdG9yLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgaWYgaW4gcHJlcmVsZWFzZSBtb2RlLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBlbHNlIHJlcGxhY2UgYyB3aXRoIGBbPj0wLjAuMF1gXG4vLyAtIElmIEMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBpZiBpbiBwcmVyZWxlYXNlIG1vZGUsIHJldHVybiB0cnVlXG4vLyAgIC0gZWxzZSByZXBsYWNlIEMgd2l0aCBgWz49MC4wLjBdYFxuLy8gLSBMZXQgRVEgYmUgdGhlIHNldCBvZiA9IGNvbXBhcmF0b3JzIGluIGNcbi8vIC0gSWYgRVEgaXMgbW9yZSB0aGFuIG9uZSwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gLSBMZXQgR1QgYmUgdGhlIGhpZ2hlc3QgPiBvciA+PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gTGV0IExUIGJlIHRoZSBsb3dlc3QgPCBvciA8PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gSWYgR1QgYW5kIExULCBhbmQgR1Quc2VtdmVyID4gTFQuc2VtdmVyLCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAtIElmIGFueSBDIGlzIGEgPSByYW5nZSwgYW5kIEdUIG9yIExUIGFyZSBzZXQsIHJldHVybiBmYWxzZVxuLy8gLSBJZiBFUVxuLy8gICAtIElmIEdULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBHVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIExULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBMVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIEVRIHNhdGlzZmllcyBldmVyeSBDLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgcmV0dXJuIGZhbHNlXG4vLyAtIElmIEdUXG4vLyAgIC0gSWYgR1Quc2VtdmVyIGlzIGxvd2VyIHRoYW4gYW55ID4gb3IgPj0gY29tcCBpbiBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVCBpcyA+PSwgYW5kIEdULnNlbXZlciBkb2VzIG5vdCBzYXRpc2Z5IGV2ZXJ5IEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIEdULnNlbXZlciBoYXMgYSBwcmVyZWxlYXNlLCBhbmQgbm90IGluIHByZXJlbGVhc2UgbW9kZVxuLy8gICAgIC0gSWYgbm8gQyBoYXMgYSBwcmVyZWxlYXNlIGFuZCB0aGUgR1Quc2VtdmVyIHR1cGxlLCByZXR1cm4gZmFsc2Vcbi8vIC0gSWYgTFRcbi8vICAgLSBJZiBMVC5zZW12ZXIgaXMgZ3JlYXRlciB0aGFuIGFueSA8IG9yIDw9IGNvbXAgaW4gQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgTFQgaXMgPD0sIGFuZCBMVC5zZW12ZXIgZG9lcyBub3Qgc2F0aXNmeSBldmVyeSBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVC5zZW12ZXIgaGFzIGEgcHJlcmVsZWFzZSwgYW5kIG5vdCBpbiBwcmVyZWxlYXNlIG1vZGVcbi8vICAgICAtIElmIG5vIEMgaGFzIGEgcHJlcmVsZWFzZSBhbmQgdGhlIExULnNlbXZlciB0dXBsZSwgcmV0dXJuIGZhbHNlXG4vLyAtIEVsc2UgcmV0dXJuIHRydWVcblxuY29uc3Qgc3Vic2V0ID0gKHN1YiwgZG9tLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKHN1YiA9PT0gZG9tKVxuICAgIHJldHVybiB0cnVlXG5cbiAgc3ViID0gbmV3IFJhbmdlKHN1Yiwgb3B0aW9ucylcbiAgZG9tID0gbmV3IFJhbmdlKGRvbSwgb3B0aW9ucylcbiAgbGV0IHNhd05vbk51bGwgPSBmYWxzZVxuXG4gIE9VVEVSOiBmb3IgKGNvbnN0IHNpbXBsZVN1YiBvZiBzdWIuc2V0KSB7XG4gICAgZm9yIChjb25zdCBzaW1wbGVEb20gb2YgZG9tLnNldCkge1xuICAgICAgY29uc3QgaXNTdWIgPSBzaW1wbGVTdWJzZXQoc2ltcGxlU3ViLCBzaW1wbGVEb20sIG9wdGlvbnMpXG4gICAgICBzYXdOb25OdWxsID0gc2F3Tm9uTnVsbCB8fCBpc1N1YiAhPT0gbnVsbFxuICAgICAgaWYgKGlzU3ViKVxuICAgICAgICBjb250aW51ZSBPVVRFUlxuICAgIH1cbiAgICAvLyB0aGUgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2YgZXZlcnl0aGluZywgYnV0IG51bGwgc2ltcGxlIHJhbmdlcyBpblxuICAgIC8vIGEgY29tcGxleCByYW5nZSBzaG91bGQgYmUgaWdub3JlZC4gIHNvIGlmIHdlIHNhdyBhIG5vbi1udWxsIHJhbmdlLFxuICAgIC8vIHRoZW4gd2Uga25vdyB0aGlzIGlzbid0IGEgc3Vic2V0LCBidXQgaWYgRVZFUlkgc2ltcGxlIHJhbmdlIHdhcyBudWxsLFxuICAgIC8vIHRoZW4gaXQgaXMgYSBzdWJzZXQuXG4gICAgaWYgKHNhd05vbk51bGwpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5jb25zdCBzaW1wbGVTdWJzZXQgPSAoc3ViLCBkb20sIG9wdGlvbnMpID0+IHtcbiAgaWYgKHN1YiA9PT0gZG9tKVxuICAgIHJldHVybiB0cnVlXG5cbiAgaWYgKHN1Yi5sZW5ndGggPT09IDEgJiYgc3ViWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgaWYgKGRvbS5sZW5ndGggPT09IDEgJiYgZG9tWzBdLnNlbXZlciA9PT0gQU5ZKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICBlbHNlIGlmIChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKVxuICAgICAgc3ViID0gWyBuZXcgQ29tcGFyYXRvcignPj0wLjAuMC0wJykgXVxuICAgIGVsc2VcbiAgICAgIHN1YiA9IFsgbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKSBdXG4gIH1cblxuICBpZiAoZG9tLmxlbmd0aCA9PT0gMSAmJiBkb21bMF0uc2VtdmVyID09PSBBTlkpIHtcbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSlcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZWxzZVxuICAgICAgZG9tID0gWyBuZXcgQ29tcGFyYXRvcignPj0wLjAuMCcpIF1cbiAgfVxuXG4gIGNvbnN0IGVxU2V0ID0gbmV3IFNldCgpXG4gIGxldCBndCwgbHRcbiAgZm9yIChjb25zdCBjIG9mIHN1Yikge1xuICAgIGlmIChjLm9wZXJhdG9yID09PSAnPicgfHwgYy5vcGVyYXRvciA9PT0gJz49JylcbiAgICAgIGd0ID0gaGlnaGVyR1QoZ3QsIGMsIG9wdGlvbnMpXG4gICAgZWxzZSBpZiAoYy5vcGVyYXRvciA9PT0gJzwnIHx8IGMub3BlcmF0b3IgPT09ICc8PScpXG4gICAgICBsdCA9IGxvd2VyTFQobHQsIGMsIG9wdGlvbnMpXG4gICAgZWxzZVxuICAgICAgZXFTZXQuYWRkKGMuc2VtdmVyKVxuICB9XG5cbiAgaWYgKGVxU2V0LnNpemUgPiAxKVxuICAgIHJldHVybiBudWxsXG5cbiAgbGV0IGd0bHRDb21wXG4gIGlmIChndCAmJiBsdCkge1xuICAgIGd0bHRDb21wID0gY29tcGFyZShndC5zZW12ZXIsIGx0LnNlbXZlciwgb3B0aW9ucylcbiAgICBpZiAoZ3RsdENvbXAgPiAwKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICBlbHNlIGlmIChndGx0Q29tcCA9PT0gMCAmJiAoZ3Qub3BlcmF0b3IgIT09ICc+PScgfHwgbHQub3BlcmF0b3IgIT09ICc8PScpKVxuICAgICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIHdpbGwgaXRlcmF0ZSBvbmUgb3IgemVybyB0aW1lc1xuICBmb3IgKGNvbnN0IGVxIG9mIGVxU2V0KSB7XG4gICAgaWYgKGd0ICYmICFzYXRpc2ZpZXMoZXEsIFN0cmluZyhndCksIG9wdGlvbnMpKVxuICAgICAgcmV0dXJuIG51bGxcblxuICAgIGlmIChsdCAmJiAhc2F0aXNmaWVzKGVxLCBTdHJpbmcobHQpLCBvcHRpb25zKSlcbiAgICAgIHJldHVybiBudWxsXG5cbiAgICBmb3IgKGNvbnN0IGMgb2YgZG9tKSB7XG4gICAgICBpZiAoIXNhdGlzZmllcyhlcSwgU3RyaW5nKGMpLCBvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGxldCBoaWdoZXIsIGxvd2VyXG4gIGxldCBoYXNEb21MVCwgaGFzRG9tR1RcbiAgLy8gaWYgdGhlIHN1YnNldCBoYXMgYSBwcmVyZWxlYXNlLCB3ZSBuZWVkIGEgY29tcGFyYXRvciBpbiB0aGUgc3VwZXJzZXRcbiAgLy8gd2l0aCB0aGUgc2FtZSB0dXBsZSBhbmQgYSBwcmVyZWxlYXNlLCBvciBpdCdzIG5vdCBhIHN1YnNldFxuICBsZXQgbmVlZERvbUxUUHJlID0gbHQgJiZcbiAgICAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJlxuICAgIGx0LnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA/IGx0LnNlbXZlciA6IGZhbHNlXG4gIGxldCBuZWVkRG9tR1RQcmUgPSBndCAmJlxuICAgICFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgZ3Quc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID8gZ3Quc2VtdmVyIDogZmFsc2VcbiAgLy8gZXhjZXB0aW9uOiA8MS4yLjMtMCBpcyB0aGUgc2FtZSBhcyA8MS4yLjNcbiAgaWYgKG5lZWREb21MVFByZSAmJiBuZWVkRG9tTFRQcmUucHJlcmVsZWFzZS5sZW5ndGggPT09IDEgJiZcbiAgICAgIGx0Lm9wZXJhdG9yID09PSAnPCcgJiYgbmVlZERvbUxUUHJlLnByZXJlbGVhc2VbMF0gPT09IDApIHtcbiAgICBuZWVkRG9tTFRQcmUgPSBmYWxzZVxuICB9XG5cbiAgZm9yIChjb25zdCBjIG9mIGRvbSkge1xuICAgIGhhc0RvbUdUID0gaGFzRG9tR1QgfHwgYy5vcGVyYXRvciA9PT0gJz4nIHx8IGMub3BlcmF0b3IgPT09ICc+PSdcbiAgICBoYXNEb21MVCA9IGhhc0RvbUxUIHx8IGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nXG4gICAgaWYgKGd0KSB7XG4gICAgICBpZiAobmVlZERvbUdUUHJlKSB7XG4gICAgICAgIGlmIChjLnNlbXZlci5wcmVyZWxlYXNlICYmIGMuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICBjLnNlbXZlci5tYWpvciA9PT0gbmVlZERvbUdUUHJlLm1ham9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5taW5vciA9PT0gbmVlZERvbUdUUHJlLm1pbm9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5wYXRjaCA9PT0gbmVlZERvbUdUUHJlLnBhdGNoKSB7XG4gICAgICAgICAgbmVlZERvbUdUUHJlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGMub3BlcmF0b3IgPT09ICc+JyB8fCBjLm9wZXJhdG9yID09PSAnPj0nKSB7XG4gICAgICAgIGhpZ2hlciA9IGhpZ2hlckdUKGd0LCBjLCBvcHRpb25zKVxuICAgICAgICBpZiAoaGlnaGVyID09PSBjICYmIGhpZ2hlciAhPT0gZ3QpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9IGVsc2UgaWYgKGd0Lm9wZXJhdG9yID09PSAnPj0nICYmICFzYXRpc2ZpZXMoZ3Quc2VtdmVyLCBTdHJpbmcoYyksIG9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKGx0KSB7XG4gICAgICBpZiAobmVlZERvbUxUUHJlKSB7XG4gICAgICAgIGlmIChjLnNlbXZlci5wcmVyZWxlYXNlICYmIGMuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICBjLnNlbXZlci5tYWpvciA9PT0gbmVlZERvbUxUUHJlLm1ham9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5taW5vciA9PT0gbmVlZERvbUxUUHJlLm1pbm9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5wYXRjaCA9PT0gbmVlZERvbUxUUHJlLnBhdGNoKSB7XG4gICAgICAgICAgbmVlZERvbUxUUHJlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nKSB7XG4gICAgICAgIGxvd2VyID0gbG93ZXJMVChsdCwgYywgb3B0aW9ucylcbiAgICAgICAgaWYgKGxvd2VyID09PSBjICYmIGxvd2VyICE9PSBsdClcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0gZWxzZSBpZiAobHQub3BlcmF0b3IgPT09ICc8PScgJiYgIXNhdGlzZmllcyhsdC5zZW12ZXIsIFN0cmluZyhjKSwgb3B0aW9ucykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAoIWMub3BlcmF0b3IgJiYgKGx0IHx8IGd0KSAmJiBndGx0Q29tcCAhPT0gMClcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gaWYgdGhlcmUgd2FzIGEgPCBvciA+LCBhbmQgbm90aGluZyBpbiB0aGUgZG9tLCB0aGVuIG11c3QgYmUgZmFsc2VcbiAgLy8gVU5MRVNTIGl0IHdhcyBsaW1pdGVkIGJ5IGFub3RoZXIgcmFuZ2UgaW4gdGhlIG90aGVyIGRpcmVjdGlvbi5cbiAgLy8gRWcsID4xLjAuMCA8MS4wLjEgaXMgc3RpbGwgYSBzdWJzZXQgb2YgPDIuMC4wXG4gIGlmIChndCAmJiBoYXNEb21MVCAmJiAhbHQgJiYgZ3RsdENvbXAgIT09IDApXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgaWYgKGx0ICYmIGhhc0RvbUdUICYmICFndCAmJiBndGx0Q29tcCAhPT0gMClcbiAgICByZXR1cm4gZmFsc2VcblxuICAvLyB3ZSBuZWVkZWQgYSBwcmVyZWxlYXNlIHJhbmdlIGluIGEgc3BlY2lmaWMgdHVwbGUsIGJ1dCBkaWRuJ3QgZ2V0IG9uZVxuICAvLyB0aGVuIHRoaXMgaXNuJ3QgYSBzdWJzZXQuICBlZyA+PTEuMi4zLXByZSBpcyBub3QgYSBzdWJzZXQgb2YgPj0xLjAuMCxcbiAgLy8gYmVjYXVzZSBpdCBpbmNsdWRlcyBwcmVyZWxlYXNlcyBpbiB0aGUgMS4yLjMgdHVwbGVcbiAgaWYgKG5lZWREb21HVFByZSB8fCBuZWVkRG9tTFRQcmUpXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gPj0xLjIuMyBpcyBsb3dlciB0aGFuID4xLjIuM1xuY29uc3QgaGlnaGVyR1QgPSAoYSwgYiwgb3B0aW9ucykgPT4ge1xuICBpZiAoIWEpXG4gICAgcmV0dXJuIGJcbiAgY29uc3QgY29tcCA9IGNvbXBhcmUoYS5zZW12ZXIsIGIuc2VtdmVyLCBvcHRpb25zKVxuICByZXR1cm4gY29tcCA+IDAgPyBhXG4gICAgOiBjb21wIDwgMCA/IGJcbiAgICA6IGIub3BlcmF0b3IgPT09ICc+JyAmJiBhLm9wZXJhdG9yID09PSAnPj0nID8gYlxuICAgIDogYVxufVxuXG4vLyA8PTEuMi4zIGlzIGhpZ2hlciB0aGFuIDwxLjIuM1xuY29uc3QgbG93ZXJMVCA9IChhLCBiLCBvcHRpb25zKSA9PiB7XG4gIGlmICghYSlcbiAgICByZXR1cm4gYlxuICBjb25zdCBjb21wID0gY29tcGFyZShhLnNlbXZlciwgYi5zZW12ZXIsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wIDwgMCA/IGFcbiAgICA6IGNvbXAgPiAwID8gYlxuICAgIDogYi5vcGVyYXRvciA9PT0gJzwnICYmIGEub3BlcmF0b3IgPT09ICc8PScgPyBiXG4gICAgOiBhXG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3Vic2V0XG4iLCIvLyBqdXN0IHByZS1sb2FkIGFsbCB0aGUgc3R1ZmYgdGhhdCBpbmRleC5qcyBsYXppbHkgZXhwb3J0c1xuY29uc3QgaW50ZXJuYWxSZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvcmUnKVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlOiBpbnRlcm5hbFJlLnJlLFxuICBzcmM6IGludGVybmFsUmUuc3JjLFxuICB0b2tlbnM6IGludGVybmFsUmUudCxcbiAgU0VNVkVSX1NQRUNfVkVSU0lPTjogcmVxdWlyZSgnLi9pbnRlcm5hbC9jb25zdGFudHMnKS5TRU1WRVJfU1BFQ19WRVJTSU9OLFxuICBTZW1WZXI6IHJlcXVpcmUoJy4vY2xhc3Nlcy9zZW12ZXInKSxcbiAgY29tcGFyZUlkZW50aWZpZXJzOiByZXF1aXJlKCcuL2ludGVybmFsL2lkZW50aWZpZXJzJykuY29tcGFyZUlkZW50aWZpZXJzLFxuICByY29tcGFyZUlkZW50aWZpZXJzOiByZXF1aXJlKCcuL2ludGVybmFsL2lkZW50aWZpZXJzJykucmNvbXBhcmVJZGVudGlmaWVycyxcbiAgcGFyc2U6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3BhcnNlJyksXG4gIHZhbGlkOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy92YWxpZCcpLFxuICBjbGVhbjogcmVxdWlyZSgnLi9mdW5jdGlvbnMvY2xlYW4nKSxcbiAgaW5jOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9pbmMnKSxcbiAgZGlmZjogcmVxdWlyZSgnLi9mdW5jdGlvbnMvZGlmZicpLFxuICBtYWpvcjogcmVxdWlyZSgnLi9mdW5jdGlvbnMvbWFqb3InKSxcbiAgbWlub3I6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL21pbm9yJyksXG4gIHBhdGNoOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wYXRjaCcpLFxuICBwcmVyZWxlYXNlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wcmVyZWxlYXNlJyksXG4gIGNvbXBhcmU6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvbXBhcmUnKSxcbiAgcmNvbXBhcmU6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3Jjb21wYXJlJyksXG4gIGNvbXBhcmVMb29zZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29tcGFyZS1sb29zZScpLFxuICBjb21wYXJlQnVpbGQ6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvbXBhcmUtYnVpbGQnKSxcbiAgc29ydDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvc29ydCcpLFxuICByc29ydDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvcnNvcnQnKSxcbiAgZ3Q6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2d0JyksXG4gIGx0OiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9sdCcpLFxuICBlcTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvZXEnKSxcbiAgbmVxOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9uZXEnKSxcbiAgZ3RlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9ndGUnKSxcbiAgbHRlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9sdGUnKSxcbiAgY21wOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jbXAnKSxcbiAgY29lcmNlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb2VyY2UnKSxcbiAgQ29tcGFyYXRvcjogcmVxdWlyZSgnLi9jbGFzc2VzL2NvbXBhcmF0b3InKSxcbiAgUmFuZ2U6IHJlcXVpcmUoJy4vY2xhc3Nlcy9yYW5nZScpLFxuICBzYXRpc2ZpZXM6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3NhdGlzZmllcycpLFxuICB0b0NvbXBhcmF0b3JzOiByZXF1aXJlKCcuL3Jhbmdlcy90by1jb21wYXJhdG9ycycpLFxuICBtYXhTYXRpc2Z5aW5nOiByZXF1aXJlKCcuL3Jhbmdlcy9tYXgtc2F0aXNmeWluZycpLFxuICBtaW5TYXRpc2Z5aW5nOiByZXF1aXJlKCcuL3Jhbmdlcy9taW4tc2F0aXNmeWluZycpLFxuICBtaW5WZXJzaW9uOiByZXF1aXJlKCcuL3Jhbmdlcy9taW4tdmVyc2lvbicpLFxuICB2YWxpZFJhbmdlOiByZXF1aXJlKCcuL3Jhbmdlcy92YWxpZCcpLFxuICBvdXRzaWRlOiByZXF1aXJlKCcuL3Jhbmdlcy9vdXRzaWRlJyksXG4gIGd0cjogcmVxdWlyZSgnLi9yYW5nZXMvZ3RyJyksXG4gIGx0cjogcmVxdWlyZSgnLi9yYW5nZXMvbHRyJyksXG4gIGludGVyc2VjdHM6IHJlcXVpcmUoJy4vcmFuZ2VzL2ludGVyc2VjdHMnKSxcbiAgc2ltcGxpZnlSYW5nZTogcmVxdWlyZSgnLi9yYW5nZXMvc2ltcGxpZnknKSxcbiAgc3Vic2V0OiByZXF1aXJlKCcuL3Jhbmdlcy9zdWJzZXQnKSxcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgbWltaWNGbiA9ICh0bywgZnJvbSkgPT4ge1xuXHRmb3IgKGNvbnN0IHByb3Agb2YgUmVmbGVjdC5vd25LZXlzKGZyb20pKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCBwcm9wLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGZyb20sIHByb3ApKTtcblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWltaWNGbjtcbi8vIFRPRE86IFJlbW92ZSB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbWltaWNGbjtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IG1pbWljRm4gPSByZXF1aXJlKCdtaW1pYy1mbicpO1xuXG5jb25zdCBjYWxsZWRGdW5jdGlvbnMgPSBuZXcgV2Vha01hcCgpO1xuXG5jb25zdCBvbmV0aW1lID0gKGZ1bmN0aW9uXywgb3B0aW9ucyA9IHt9KSA9PiB7XG5cdGlmICh0eXBlb2YgZnVuY3Rpb25fICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBmdW5jdGlvbicpO1xuXHR9XG5cblx0bGV0IHJldHVyblZhbHVlO1xuXHRsZXQgY2FsbENvdW50ID0gMDtcblx0Y29uc3QgZnVuY3Rpb25OYW1lID0gZnVuY3Rpb25fLmRpc3BsYXlOYW1lIHx8IGZ1bmN0aW9uXy5uYW1lIHx8ICc8YW5vbnltb3VzPic7XG5cblx0Y29uc3Qgb25ldGltZSA9IGZ1bmN0aW9uICguLi5hcmd1bWVudHNfKSB7XG5cdFx0Y2FsbGVkRnVuY3Rpb25zLnNldChvbmV0aW1lLCArK2NhbGxDb3VudCk7XG5cblx0XHRpZiAoY2FsbENvdW50ID09PSAxKSB7XG5cdFx0XHRyZXR1cm5WYWx1ZSA9IGZ1bmN0aW9uXy5hcHBseSh0aGlzLCBhcmd1bWVudHNfKTtcblx0XHRcdGZ1bmN0aW9uXyA9IG51bGw7XG5cdFx0fSBlbHNlIGlmIChvcHRpb25zLnRocm93ID09PSB0cnVlKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEZ1bmN0aW9uIFxcYCR7ZnVuY3Rpb25OYW1lfVxcYCBjYW4gb25seSBiZSBjYWxsZWQgb25jZWApO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0fTtcblxuXHRtaW1pY0ZuKG9uZXRpbWUsIGZ1bmN0aW9uXyk7XG5cdGNhbGxlZEZ1bmN0aW9ucy5zZXQob25ldGltZSwgY2FsbENvdW50KTtcblxuXHRyZXR1cm4gb25ldGltZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gb25ldGltZTtcbi8vIFRPRE86IFJlbW92ZSB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gb25ldGltZTtcblxubW9kdWxlLmV4cG9ydHMuY2FsbENvdW50ID0gZnVuY3Rpb25fID0+IHtcblx0aWYgKCFjYWxsZWRGdW5jdGlvbnMuaGFzKGZ1bmN0aW9uXykpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYFRoZSBnaXZlbiBmdW5jdGlvbiBcXGAke2Z1bmN0aW9uXy5uYW1lfVxcYCBpcyBub3Qgd3JhcHBlZCBieSB0aGUgXFxgb25ldGltZVxcYCBwYWNrYWdlYCk7XG5cdH1cblxuXHRyZXR1cm4gY2FsbGVkRnVuY3Rpb25zLmdldChmdW5jdGlvbl8pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9hLCBfYjtcbnZhciBfQ29uZl92YWxpZGF0b3IsIF9Db25mX2VuY3J5cHRpb25LZXksIF9Db25mX29wdGlvbnMsIF9Db25mX2RlZmF1bHRWYWx1ZXM7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBkb3RQcm9wID0gcmVxdWlyZShcImRvdC1wcm9wXCIpO1xuY29uc3QgcGtnVXAgPSByZXF1aXJlKFwicGtnLXVwXCIpO1xuY29uc3QgZW52UGF0aHMgPSByZXF1aXJlKFwiZW52LXBhdGhzXCIpO1xuY29uc3QgYXRvbWljYWxseSA9IHJlcXVpcmUoXCJhdG9taWNhbGx5XCIpO1xuY29uc3QgYWp2XzEgPSByZXF1aXJlKFwiYWp2XCIpO1xuY29uc3QgYWp2X2Zvcm1hdHNfMSA9IHJlcXVpcmUoXCJhanYtZm9ybWF0c1wiKTtcbmNvbnN0IGRlYm91bmNlRm4gPSByZXF1aXJlKFwiZGVib3VuY2UtZm5cIik7XG5jb25zdCBzZW12ZXIgPSByZXF1aXJlKFwic2VtdmVyXCIpO1xuY29uc3Qgb25ldGltZSA9IHJlcXVpcmUoXCJvbmV0aW1lXCIpO1xuY29uc3QgZW5jcnlwdGlvbkFsZ29yaXRobSA9ICdhZXMtMjU2LWNiYyc7XG5jb25zdCBjcmVhdGVQbGFpbk9iamVjdCA9ICgpID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn07XG5jb25zdCBpc0V4aXN0ID0gKGRhdGEpID0+IHtcbiAgICByZXR1cm4gZGF0YSAhPT0gdW5kZWZpbmVkICYmIGRhdGEgIT09IG51bGw7XG59O1xubGV0IHBhcmVudERpciA9ICcnO1xudHJ5IHtcbiAgICAvLyBQcmV2ZW50IGNhY2hpbmcgb2YgdGhpcyBtb2R1bGUgc28gbW9kdWxlLnBhcmVudCBpcyBhbHdheXMgYWNjdXJhdGUuXG4gICAgLy8gTm90ZTogVGhpcyB0cmljayB3b24ndCB3b3JrIHdpdGggRVNNIG9yIGluc2lkZSBhIHdlYndvcmtlclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGVcbiAgICBkZWxldGUgcmVxdWlyZS5jYWNoZVtfX2ZpbGVuYW1lXTtcbiAgICBwYXJlbnREaXIgPSBwYXRoLmRpcm5hbWUoKF9iID0gKF9hID0gbW9kdWxlLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbGVuYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnLicpO1xufVxuY2F0Y2ggKF9jKSB7IH1cbmNvbnN0IGNoZWNrVmFsdWVUeXBlID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICBjb25zdCBub25Kc29uVHlwZXMgPSBuZXcgU2V0KFtcbiAgICAgICAgJ3VuZGVmaW5lZCcsXG4gICAgICAgICdzeW1ib2wnLFxuICAgICAgICAnZnVuY3Rpb24nXG4gICAgXSk7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBpZiAobm9uSnNvblR5cGVzLmhhcyh0eXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBTZXR0aW5nIGEgdmFsdWUgb2YgdHlwZSBcXGAke3R5cGV9XFxgIGZvciBrZXkgXFxgJHtrZXl9XFxgIGlzIG5vdCBhbGxvd2VkIGFzIGl0J3Mgbm90IHN1cHBvcnRlZCBieSBKU09OYCk7XG4gICAgfVxufTtcbmNvbnN0IElOVEVSTkFMX0tFWSA9ICdfX2ludGVybmFsX18nO1xuY29uc3QgTUlHUkFUSU9OX0tFWSA9IGAke0lOVEVSTkFMX0tFWX0ubWlncmF0aW9ucy52ZXJzaW9uYDtcbmNsYXNzIENvbmYge1xuICAgIGNvbnN0cnVjdG9yKHBhcnRpYWxPcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBfQ29uZl92YWxpZGF0b3Iuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Db25mX2VuY3J5cHRpb25LZXkuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Db25mX29wdGlvbnMuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Db25mX2RlZmF1bHRWYWx1ZXMuc2V0KHRoaXMsIHt9KTtcbiAgICAgICAgdGhpcy5fZGVzZXJpYWxpemUgPSB2YWx1ZSA9PiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgdGhpcy5fc2VyaWFsaXplID0gdmFsdWUgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIHVuZGVmaW5lZCwgJ1xcdCcpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgY29uZmlnTmFtZTogJ2NvbmZpZycsXG4gICAgICAgICAgICBmaWxlRXh0ZW5zaW9uOiAnanNvbicsXG4gICAgICAgICAgICBwcm9qZWN0U3VmZml4OiAnbm9kZWpzJyxcbiAgICAgICAgICAgIGNsZWFySW52YWxpZENvbmZpZzogZmFsc2UsXG4gICAgICAgICAgICBhY2Nlc3NQcm9wZXJ0aWVzQnlEb3ROb3RhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIC4uLnBhcnRpYWxPcHRpb25zXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGdldFBhY2thZ2VEYXRhID0gb25ldGltZSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYWNrYWdlUGF0aCA9IHBrZ1VwLnN5bmMoeyBjd2Q6IHBhcmVudERpciB9KTtcbiAgICAgICAgICAgIC8vIENhbid0IHVzZSBgcmVxdWlyZWAgYmVjYXVzZSBvZiBXZWJwYWNrIGJlaW5nIGFubm95aW5nOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay9pc3N1ZXMvMTk2XG4gICAgICAgICAgICBjb25zdCBwYWNrYWdlRGF0YSA9IHBhY2thZ2VQYXRoICYmIEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKHBhY2thZ2VQYXRoLCAndXRmOCcpKTtcbiAgICAgICAgICAgIHJldHVybiBwYWNrYWdlRGF0YSAhPT0gbnVsbCAmJiBwYWNrYWdlRGF0YSAhPT0gdm9pZCAwID8gcGFja2FnZURhdGEgOiB7fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghb3B0aW9ucy5jd2QpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wcm9qZWN0TmFtZSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucHJvamVjdE5hbWUgPSBnZXRQYWNrYWdlRGF0YSgpLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMucHJvamVjdE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3QgbmFtZSBjb3VsZCBub3QgYmUgaW5mZXJyZWQuIFBsZWFzZSBzcGVjaWZ5IHRoZSBgcHJvamVjdE5hbWVgIG9wdGlvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMuY3dkID0gZW52UGF0aHMob3B0aW9ucy5wcm9qZWN0TmFtZSwgeyBzdWZmaXg6IG9wdGlvbnMucHJvamVjdFN1ZmZpeCB9KS5jb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ29uZl9vcHRpb25zLCBvcHRpb25zLCBcImZcIik7XG4gICAgICAgIGlmIChvcHRpb25zLnNjaGVtYSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnNjaGVtYSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgYHNjaGVtYWAgb3B0aW9uIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWp2ID0gbmV3IGFqdl8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgICAgIGFsbEVycm9yczogdHJ1ZSxcbiAgICAgICAgICAgICAgICB1c2VEZWZhdWx0czogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhanZfZm9ybWF0c18xLmRlZmF1bHQoYWp2KTtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBvcHRpb25zLnNjaGVtYVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NvbmZfdmFsaWRhdG9yLCBhanYuY29tcGlsZShzY2hlbWEpLCBcImZcIik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zLnNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9kZWZhdWx0VmFsdWVzLCBcImZcIilba2V5XSA9IHZhbHVlLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Db25mX2RlZmF1bHRWYWx1ZXMsIHtcbiAgICAgICAgICAgICAgICAuLi5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX2RlZmF1bHRWYWx1ZXMsIFwiZlwiKSxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLmRlZmF1bHRzXG4gICAgICAgICAgICB9LCBcImZcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc2VyaWFsaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXJpYWxpemUgPSBvcHRpb25zLnNlcmlhbGl6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5kZXNlcmlhbGl6ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGVzZXJpYWxpemUgPSBvcHRpb25zLmRlc2VyaWFsaXplO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRzID0gbmV3IGV2ZW50c18xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Db25mX2VuY3J5cHRpb25LZXksIG9wdGlvbnMuZW5jcnlwdGlvbktleSwgXCJmXCIpO1xuICAgICAgICBjb25zdCBmaWxlRXh0ZW5zaW9uID0gb3B0aW9ucy5maWxlRXh0ZW5zaW9uID8gYC4ke29wdGlvbnMuZmlsZUV4dGVuc2lvbn1gIDogJyc7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGgucmVzb2x2ZShvcHRpb25zLmN3ZCwgYCR7KF9hID0gb3B0aW9ucy5jb25maWdOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnY29uZmlnJ30ke2ZpbGVFeHRlbnNpb259YCk7XG4gICAgICAgIGNvbnN0IGZpbGVTdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gT2JqZWN0LmFzc2lnbihjcmVhdGVQbGFpbk9iamVjdCgpLCBvcHRpb25zLmRlZmF1bHRzLCBmaWxlU3RvcmUpO1xuICAgICAgICB0aGlzLl92YWxpZGF0ZShzdG9yZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKGZpbGVTdG9yZSwgc3RvcmUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYikge1xuICAgICAgICAgICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLndhdGNoKSB7XG4gICAgICAgICAgICB0aGlzLl93YXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm1pZ3JhdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wcm9qZWN0VmVyc2lvbikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucHJvamVjdFZlcnNpb24gPSBnZXRQYWNrYWdlRGF0YSgpLnZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMucHJvamVjdFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3QgdmVyc2lvbiBjb3VsZCBub3QgYmUgaW5mZXJyZWQuIFBsZWFzZSBzcGVjaWZ5IHRoZSBgcHJvamVjdFZlcnNpb25gIG9wdGlvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21pZ3JhdGUob3B0aW9ucy5taWdyYXRpb25zLCBvcHRpb25zLnByb2plY3RWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfb3B0aW9ucywgXCJmXCIpLmFjY2Vzc1Byb3BlcnRpZXNCeURvdE5vdGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0KGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0b3JlIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ga2V5IGluIHN0b3JlID8gc3RvcmVba2V5XSA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBrZXkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBrZXlcXGAgdG8gYmUgb2YgdHlwZSBcXGBzdHJpbmdcXGAgb3IgXFxgb2JqZWN0XFxgLCBnb3QgJHt0eXBlb2Yga2V5fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnb2JqZWN0JyAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVc2UgYGRlbGV0ZSgpYCB0byBjbGVhciB2YWx1ZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY29udGFpbnNSZXNlcnZlZEtleShrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQbGVhc2UgZG9uJ3QgdXNlIHRoZSAke0lOVEVSTkFMX0tFWX0ga2V5LCBhcyBpdCdzIHVzZWQgdG8gbWFuYWdlIHRoaXMgbW9kdWxlIGludGVybmFsIG9wZXJhdGlvbnMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdG9yZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc2V0ID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNoZWNrVmFsdWVUeXBlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfb3B0aW9ucywgXCJmXCIpLmFjY2Vzc1Byb3BlcnRpZXNCeURvdE5vdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZG90UHJvcC5zZXQoc3RvcmUsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RvcmVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdCA9IGtleTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICBzZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayBpZiBhbiBpdGVtIGV4aXN0cy5cblxuICAgIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIGNoZWNrLlxuICAgICovXG4gICAgaGFzKGtleSkge1xuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9vcHRpb25zLCBcImZcIikuYWNjZXNzUHJvcGVydGllc0J5RG90Tm90YXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBkb3RQcm9wLmhhcyh0aGlzLnN0b3JlLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXkgaW4gdGhpcy5zdG9yZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVzZXQgaXRlbXMgdG8gdGhlaXIgZGVmYXVsdCB2YWx1ZXMsIGFzIGRlZmluZWQgYnkgdGhlIGBkZWZhdWx0c2Agb3IgYHNjaGVtYWAgb3B0aW9uLlxuXG4gICAgQHNlZSBgY2xlYXIoKWAgdG8gcmVzZXQgYWxsIGl0ZW1zLlxuXG4gICAgQHBhcmFtIGtleXMgLSBUaGUga2V5cyBvZiB0aGUgaXRlbXMgdG8gcmVzZXQuXG4gICAgKi9cbiAgICByZXNldCguLi5rZXlzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIGlmIChpc0V4aXN0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZGVmYXVsdFZhbHVlcywgXCJmXCIpW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX2RlZmF1bHRWYWx1ZXMsIFwiZlwiKVtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBEZWxldGUgYW4gaXRlbS5cblxuICAgIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIGRlbGV0ZS5cbiAgICAqL1xuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgY29uc3QgeyBzdG9yZSB9ID0gdGhpcztcbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfb3B0aW9ucywgXCJmXCIpLmFjY2Vzc1Byb3BlcnRpZXNCeURvdE5vdGF0aW9uKSB7XG4gICAgICAgICAgICBkb3RQcm9wLmRlbGV0ZShzdG9yZSwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGVcbiAgICAgICAgICAgIGRlbGV0ZSBzdG9yZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVsZXRlIGFsbCBpdGVtcy5cblxuICAgIFRoaXMgcmVzZXRzIGtub3duIGl0ZW1zIHRvIHRoZWlyIGRlZmF1bHQgdmFsdWVzLCBpZiBkZWZpbmVkIGJ5IHRoZSBgZGVmYXVsdHNgIG9yIGBzY2hlbWFgIG9wdGlvbi5cbiAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnN0b3JlID0gY3JlYXRlUGxhaW5PYmplY3QoKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9kZWZhdWx0VmFsdWVzLCBcImZcIikpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgV2F0Y2hlcyB0aGUgZ2l2ZW4gYGtleWAsIGNhbGxpbmcgYGNhbGxiYWNrYCBvbiBhbnkgY2hhbmdlcy5cblxuICAgIEBwYXJhbSBrZXkgLSBUaGUga2V5IHdvIHdhdGNoLlxuICAgIEBwYXJhbSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgb24gYW55IGNoYW5nZXMuIFdoZW4gYSBga2V5YCBpcyBmaXJzdCBzZXQgYG9sZFZhbHVlYCB3aWxsIGJlIGB1bmRlZmluZWRgLCBhbmQgd2hlbiBhIGtleSBpcyBkZWxldGVkIGBuZXdWYWx1ZWAgd2lsbCBiZSBgdW5kZWZpbmVkYC5cbiAgICBAcmV0dXJucyBBIGZ1bmN0aW9uLCB0aGF0IHdoZW4gY2FsbGVkLCB3aWxsIHVuc3Vic2NyaWJlLlxuICAgICovXG4gICAgb25EaWRDaGFuZ2Uoa2V5LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFxcYGtleVxcYCB0byBiZSBvZiB0eXBlIFxcYHN0cmluZ1xcYCwgZ290ICR7dHlwZW9mIGtleX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBjYWxsYmFja1xcYCB0byBiZSBvZiB0eXBlIFxcYGZ1bmN0aW9uXFxgLCBnb3QgJHt0eXBlb2YgY2FsbGJhY2t9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUNoYW5nZSgoKSA9PiB0aGlzLmdldChrZXkpLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgIFdhdGNoZXMgdGhlIHdob2xlIGNvbmZpZyBvYmplY3QsIGNhbGxpbmcgYGNhbGxiYWNrYCBvbiBhbnkgY2hhbmdlcy5cblxuICAgIEBwYXJhbSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgb24gYW55IGNoYW5nZXMuIFdoZW4gYSBga2V5YCBpcyBmaXJzdCBzZXQgYG9sZFZhbHVlYCB3aWxsIGJlIGB1bmRlZmluZWRgLCBhbmQgd2hlbiBhIGtleSBpcyBkZWxldGVkIGBuZXdWYWx1ZWAgd2lsbCBiZSBgdW5kZWZpbmVkYC5cbiAgICBAcmV0dXJucyBBIGZ1bmN0aW9uLCB0aGF0IHdoZW4gY2FsbGVkLCB3aWxsIHVuc3Vic2NyaWJlLlxuICAgICovXG4gICAgb25EaWRBbnlDaGFuZ2UoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgY2FsbGJhY2tcXGAgdG8gYmUgb2YgdHlwZSBcXGBmdW5jdGlvblxcYCwgZ290ICR7dHlwZW9mIGNhbGxiYWNrfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVDaGFuZ2UoKCkgPT4gdGhpcy5zdG9yZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc3RvcmUpLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0IHN0b3JlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGZzLnJlYWRGaWxlU3luYyh0aGlzLnBhdGgsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZW5jcnlwdGlvbktleSwgXCJmXCIpID8gbnVsbCA6ICd1dGY4Jyk7XG4gICAgICAgICAgICBjb25zdCBkYXRhU3RyaW5nID0gdGhpcy5fZW5jcnlwdERhdGEoZGF0YSk7XG4gICAgICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZWREYXRhID0gdGhpcy5fZGVzZXJpYWxpemUoZGF0YVN0cmluZyk7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0ZShkZXNlcmlhbGl6ZWREYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGNyZWF0ZVBsYWluT2JqZWN0KCksIGRlc2VyaWFsaXplZERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5zdXJlRGlyZWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVBsYWluT2JqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9vcHRpb25zLCBcImZcIikuY2xlYXJJbnZhbGlkQ29uZmlnICYmIGVycm9yLm5hbWUgPT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUGxhaW5PYmplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldCBzdG9yZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9lbnN1cmVEaXJlY3RvcnkoKTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGUodmFsdWUpO1xuICAgICAgICB0aGlzLl93cml0ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ2NoYW5nZScpO1xuICAgIH1cbiAgICAqWyhfQ29uZl92YWxpZGF0b3IgPSBuZXcgV2Vha01hcCgpLCBfQ29uZl9lbmNyeXB0aW9uS2V5ID0gbmV3IFdlYWtNYXAoKSwgX0NvbmZfb3B0aW9ucyA9IG5ldyBXZWFrTWFwKCksIF9Db25mX2RlZmF1bHRWYWx1ZXMgPSBuZXcgV2Vha01hcCgpLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5zdG9yZSkpIHtcbiAgICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZW5jcnlwdERhdGEoZGF0YSkge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZW5jcnlwdGlvbktleSwgXCJmXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBhbiBpbml0aWFsaXphdGlvbiB2ZWN0b3IgaGFzIGJlZW4gdXNlZCB0byBlbmNyeXB0IHRoZSBkYXRhXG4gICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBcImZcIikpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5zbGljZSgxNiwgMTcpLnRvU3RyaW5nKCkgPT09ICc6Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhbGl6YXRpb25WZWN0b3IgPSBkYXRhLnNsaWNlKDAsIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhc3N3b3JkID0gY3J5cHRvLnBia2RmMlN5bmMoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBcImZcIiksIGluaXRpYWxpemF0aW9uVmVjdG9yLnRvU3RyaW5nKCksIDEwMDAwLCAzMiwgJ3NoYTUxMicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihlbmNyeXB0aW9uQWxnb3JpdGhtLCBwYXNzd29yZCwgaW5pdGlhbGl6YXRpb25WZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IEJ1ZmZlci5jb25jYXQoW2RlY2lwaGVyLnVwZGF0ZShCdWZmZXIuZnJvbShkYXRhLnNsaWNlKDE3KSkpLCBkZWNpcGhlci5maW5hbCgpXSkudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyKGVuY3J5cHRpb25BbGdvcml0aG0sIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZW5jcnlwdGlvbktleSwgXCJmXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBCdWZmZXIuY29uY2F0KFtkZWNpcGhlci51cGRhdGUoQnVmZmVyLmZyb20oZGF0YSkpLCBkZWNpcGhlci5maW5hbCgpXSkudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYikgeyB9XG4gICAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIF9oYW5kbGVDaGFuZ2UoZ2V0dGVyLCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgY3VycmVudFZhbHVlID0gZ2V0dGVyKCk7XG4gICAgICAgIGNvbnN0IG9uQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGdldHRlcigpO1xuICAgICAgICAgICAgaWYgKHV0aWxfMS5pc0RlZXBTdHJpY3RFcXVhbChuZXdWYWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB0aGlzLmV2ZW50cy5yZW1vdmVMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIH1cbiAgICBfdmFsaWRhdGUoZGF0YSkge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfdmFsaWRhdG9yLCBcImZcIikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfdmFsaWRhdG9yLCBcImZcIikuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICAgICAgaWYgKHZhbGlkIHx8ICFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX3ZhbGlkYXRvciwgXCJmXCIpLmVycm9ycykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfdmFsaWRhdG9yLCBcImZcIikuZXJyb3JzXG4gICAgICAgICAgICAubWFwKCh7IGluc3RhbmNlUGF0aCwgbWVzc2FnZSA9ICcnIH0pID0+IGBcXGAke2luc3RhbmNlUGF0aC5zbGljZSgxKX1cXGAgJHttZXNzYWdlfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmZpZyBzY2hlbWEgdmlvbGF0aW9uOiAnICsgZXJyb3JzLmpvaW4oJzsgJykpO1xuICAgIH1cbiAgICBfZW5zdXJlRGlyZWN0b3J5KCkge1xuICAgICAgICAvLyBFbnN1cmUgdGhlIGRpcmVjdG9yeSBleGlzdHMgYXMgaXQgY291bGQgaGF2ZSBiZWVuIGRlbGV0ZWQgaW4gdGhlIG1lYW50aW1lLlxuICAgICAgICBmcy5ta2RpclN5bmMocGF0aC5kaXJuYW1lKHRoaXMucGF0aCksIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIH1cbiAgICBfd3JpdGUodmFsdWUpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLl9zZXJpYWxpemUodmFsdWUpO1xuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBcImZcIikpIHtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxpemF0aW9uVmVjdG9yID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KTtcbiAgICAgICAgICAgIGNvbnN0IHBhc3N3b3JkID0gY3J5cHRvLnBia2RmMlN5bmMoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBcImZcIiksIGluaXRpYWxpemF0aW9uVmVjdG9yLnRvU3RyaW5nKCksIDEwMDAwLCAzMiwgJ3NoYTUxMicpO1xuICAgICAgICAgICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KGVuY3J5cHRpb25BbGdvcml0aG0sIHBhc3N3b3JkLCBpbml0aWFsaXphdGlvblZlY3Rvcik7XG4gICAgICAgICAgICBkYXRhID0gQnVmZmVyLmNvbmNhdChbaW5pdGlhbGl6YXRpb25WZWN0b3IsIEJ1ZmZlci5mcm9tKCc6JyksIGNpcGhlci51cGRhdGUoQnVmZmVyLmZyb20oZGF0YSkpLCBjaXBoZXIuZmluYWwoKV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlbXBvcmFyeSB3b3JrYXJvdW5kIGZvciBDb25mIGJlaW5nIHBhY2thZ2VkIGluIGEgVWJ1bnR1IFNuYXAgYXBwLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9jb25mL3B1bGwvODJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52LlNOQVApIHtcbiAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmModGhpcy5wYXRoLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXRvbWljYWxseS53cml0ZUZpbGVTeW5jKHRoaXMucGF0aCwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBGaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvZWxlY3Ryb24tc3RvcmUvaXNzdWVzLzEwNlxuICAgICAgICAgICAgICAgIC8vIFNvbWV0aW1lcyBvbiBXaW5kb3dzLCB3ZSB3aWxsIGdldCBhbiBFWERFViBlcnJvciB3aGVuIGF0b21pYyB3cml0aW5nXG4gICAgICAgICAgICAgICAgLy8gKGV2ZW4gdGhvdWdoIHRvIHRoZSBzYW1lIGRpcmVjdG9yeSksIHNvIHdlIGZhbGwgYmFjayB0byBub24gYXRvbWljIHdyaXRlXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICdFWERFVicpIHtcbiAgICAgICAgICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyh0aGlzLnBhdGgsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF93YXRjaCgpIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlRGlyZWN0b3J5KCk7XG4gICAgICAgIGlmICghZnMuZXhpc3RzU3luYyh0aGlzLnBhdGgpKSB7XG4gICAgICAgICAgICB0aGlzLl93cml0ZShjcmVhdGVQbGFpbk9iamVjdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgICAgICAgICAgZnMud2F0Y2godGhpcy5wYXRoLCB7IHBlcnNpc3RlbnQ6IGZhbHNlIH0sIGRlYm91bmNlRm4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIE9uIExpbnV4IGFuZCBXaW5kb3dzLCB3cml0aW5nIHRvIHRoZSBjb25maWcgZmlsZSBlbWl0cyBhIGByZW5hbWVgIGV2ZW50LCBzbyB3ZSBza2lwIGNoZWNraW5nIHRoZSBldmVudCB0eXBlLlxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ2NoYW5nZScpO1xuICAgICAgICAgICAgfSwgeyB3YWl0OiAxMDAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnMud2F0Y2hGaWxlKHRoaXMucGF0aCwgeyBwZXJzaXN0ZW50OiBmYWxzZSB9LCBkZWJvdW5jZUZuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KCdjaGFuZ2UnKTtcbiAgICAgICAgICAgIH0sIHsgd2FpdDogNTAwMCB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX21pZ3JhdGUobWlncmF0aW9ucywgdmVyc2lvblRvTWlncmF0ZSkge1xuICAgICAgICBsZXQgcHJldmlvdXNNaWdyYXRlZFZlcnNpb24gPSB0aGlzLl9nZXQoTUlHUkFUSU9OX0tFWSwgJzAuMC4wJyk7XG4gICAgICAgIGNvbnN0IG5ld2VyVmVyc2lvbnMgPSBPYmplY3Qua2V5cyhtaWdyYXRpb25zKVxuICAgICAgICAgICAgLmZpbHRlcihjYW5kaWRhdGVWZXJzaW9uID0+IHRoaXMuX3Nob3VsZFBlcmZvcm1NaWdyYXRpb24oY2FuZGlkYXRlVmVyc2lvbiwgcHJldmlvdXNNaWdyYXRlZFZlcnNpb24sIHZlcnNpb25Ub01pZ3JhdGUpKTtcbiAgICAgICAgbGV0IHN0b3JlQmFja3VwID0geyAuLi50aGlzLnN0b3JlIH07XG4gICAgICAgIGZvciAoY29uc3QgdmVyc2lvbiBvZiBuZXdlclZlcnNpb25zKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pZ3JhdGlvbiA9IG1pZ3JhdGlvbnNbdmVyc2lvbl07XG4gICAgICAgICAgICAgICAgbWlncmF0aW9uKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldChNSUdSQVRJT05fS0VZLCB2ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c01pZ3JhdGVkVmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgICAgICAgc3RvcmVCYWNrdXAgPSB7IC4uLnRoaXMuc3RvcmUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZUJhY2t1cDtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyB0aGUgbWlncmF0aW9uISBDaGFuZ2VzIGFwcGxpZWQgdG8gdGhlIHN0b3JlIHVudGlsIHRoaXMgZmFpbGVkIG1pZ3JhdGlvbiB3aWxsIGJlIHJlc3RvcmVkLiAke2Vycm9yfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pc1ZlcnNpb25JblJhbmdlRm9ybWF0KHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uKSB8fCAhc2VtdmVyLmVxKHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uLCB2ZXJzaW9uVG9NaWdyYXRlKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0KE1JR1JBVElPTl9LRVksIHZlcnNpb25Ub01pZ3JhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jb250YWluc1Jlc2VydmVkS2V5KGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnNLZXkgPSBPYmplY3Qua2V5cyhrZXkpWzBdO1xuICAgICAgICAgICAgaWYgKGZpcnNLZXkgPT09IElOVEVSTkFMX0tFWSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX29wdGlvbnMsIFwiZlwiKS5hY2Nlc3NQcm9wZXJ0aWVzQnlEb3ROb3RhdGlvbikge1xuICAgICAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKGAke0lOVEVSTkFMX0tFWX0uYCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9pc1ZlcnNpb25JblJhbmdlRm9ybWF0KHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHNlbXZlci5jbGVhbih2ZXJzaW9uKSA9PT0gbnVsbDtcbiAgICB9XG4gICAgX3Nob3VsZFBlcmZvcm1NaWdyYXRpb24oY2FuZGlkYXRlVmVyc2lvbiwgcHJldmlvdXNNaWdyYXRlZFZlcnNpb24sIHZlcnNpb25Ub01pZ3JhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVmVyc2lvbkluUmFuZ2VGb3JtYXQoY2FuZGlkYXRlVmVyc2lvbikpIHtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c01pZ3JhdGVkVmVyc2lvbiAhPT0gJzAuMC4wJyAmJiBzZW12ZXIuc2F0aXNmaWVzKHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uLCBjYW5kaWRhdGVWZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZW12ZXIuc2F0aXNmaWVzKHZlcnNpb25Ub01pZ3JhdGUsIGNhbmRpZGF0ZVZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZW12ZXIubHRlKGNhbmRpZGF0ZVZlcnNpb24sIHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZW12ZXIuZ3QoY2FuZGlkYXRlVmVyc2lvbiwgdmVyc2lvblRvTWlncmF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX2dldChrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gZG90UHJvcC5nZXQodGhpcy5zdG9yZSwga2V5LCBkZWZhdWx0VmFsdWUpO1xuICAgIH1cbiAgICBfc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgeyBzdG9yZSB9ID0gdGhpcztcbiAgICAgICAgZG90UHJvcC5zZXQoc3RvcmUsIGtleSwgdmFsdWUpO1xuICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ29uZjtcbi8vIEZvciBDb21tb25KUyBkZWZhdWx0IGV4cG9ydCBzdXBwb3J0XG5tb2R1bGUuZXhwb3J0cyA9IENvbmY7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQ29uZjtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCB7YXBwLCBpcGNNYWluLCBpcGNSZW5kZXJlciwgc2hlbGx9ID0gcmVxdWlyZSgnZWxlY3Ryb24nKTtcbmNvbnN0IENvbmYgPSByZXF1aXJlKCdjb25mJyk7XG5cbmxldCBpc0luaXRpYWxpemVkID0gZmFsc2U7XG5cbi8vIFNldCB1cCB0aGUgYGlwY01haW5gIGhhbmRsZXIgZm9yIGNvbW11bmljYXRpb24gYmV0d2VlbiByZW5kZXJlciBhbmQgbWFpbiBwcm9jZXNzLlxuY29uc3QgaW5pdERhdGFMaXN0ZW5lciA9ICgpID0+IHtcblx0aWYgKCFpcGNNYWluIHx8ICFhcHApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0VsZWN0cm9uIFN0b3JlOiBZb3UgbmVlZCB0byBjYWxsIGAuaW5pdFJlbmRlcmVyKClgIGZyb20gdGhlIG1haW4gcHJvY2Vzcy4nKTtcblx0fVxuXG5cdGNvbnN0IGFwcERhdGEgPSB7XG5cdFx0ZGVmYXVsdEN3ZDogYXBwLmdldFBhdGgoJ3VzZXJEYXRhJyksXG5cdFx0YXBwVmVyc2lvbjogYXBwLmdldFZlcnNpb24oKVxuXHR9O1xuXG5cdGlmIChpc0luaXRpYWxpemVkKSB7XG5cdFx0cmV0dXJuIGFwcERhdGE7XG5cdH1cblxuXHRpcGNNYWluLm9uKCdlbGVjdHJvbi1zdG9yZS1nZXQtZGF0YScsIGV2ZW50ID0+IHtcblx0XHRldmVudC5yZXR1cm5WYWx1ZSA9IGFwcERhdGE7XG5cdH0pO1xuXG5cdGlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG5cdHJldHVybiBhcHBEYXRhO1xufTtcblxuY2xhc3MgRWxlY3Ryb25TdG9yZSBleHRlbmRzIENvbmYge1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0bGV0IGRlZmF1bHRDd2Q7XG5cdFx0bGV0IGFwcFZlcnNpb247XG5cblx0XHQvLyBJZiB3ZSBhcmUgaW4gdGhlIHJlbmRlcmVyIHByb2Nlc3MsIHdlIGNvbW11bmljYXRlIHdpdGggdGhlIG1haW4gcHJvY2Vzc1xuXHRcdC8vIHRvIGdldCB0aGUgcmVxdWlyZWQgZGF0YSBmb3IgdGhlIG1vZHVsZSBvdGhlcndpc2UsIHdlIHB1bGwgZnJvbSB0aGUgbWFpbiBwcm9jZXNzLlxuXHRcdGlmIChpcGNSZW5kZXJlcikge1xuXHRcdFx0Y29uc3QgYXBwRGF0YSA9IGlwY1JlbmRlcmVyLnNlbmRTeW5jKCdlbGVjdHJvbi1zdG9yZS1nZXQtZGF0YScpO1xuXG5cdFx0XHRpZiAoIWFwcERhdGEpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFbGVjdHJvbiBTdG9yZTogWW91IG5lZWQgdG8gY2FsbCBgLmluaXRSZW5kZXJlcigpYCBmcm9tIHRoZSBtYWluIHByb2Nlc3MuJyk7XG5cdFx0XHR9XG5cblx0XHRcdCh7ZGVmYXVsdEN3ZCwgYXBwVmVyc2lvbn0gPSBhcHBEYXRhKTtcblx0XHR9IGVsc2UgaWYgKGlwY01haW4gJiYgYXBwKSB7XG5cdFx0XHQoe2RlZmF1bHRDd2QsIGFwcFZlcnNpb259ID0gaW5pdERhdGFMaXN0ZW5lcigpKTtcblx0XHR9XG5cblx0XHRvcHRpb25zID0ge1xuXHRcdFx0bmFtZTogJ2NvbmZpZycsXG5cdFx0XHQuLi5vcHRpb25zXG5cdFx0fTtcblxuXHRcdGlmICghb3B0aW9ucy5wcm9qZWN0VmVyc2lvbikge1xuXHRcdFx0b3B0aW9ucy5wcm9qZWN0VmVyc2lvbiA9IGFwcFZlcnNpb247XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuY3dkKSB7XG5cdFx0XHRvcHRpb25zLmN3ZCA9IHBhdGguaXNBYnNvbHV0ZShvcHRpb25zLmN3ZCkgPyBvcHRpb25zLmN3ZCA6IHBhdGguam9pbihkZWZhdWx0Q3dkLCBvcHRpb25zLmN3ZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9wdGlvbnMuY3dkID0gZGVmYXVsdEN3ZDtcblx0XHR9XG5cblx0XHRvcHRpb25zLmNvbmZpZ05hbWUgPSBvcHRpb25zLm5hbWU7XG5cdFx0ZGVsZXRlIG9wdGlvbnMubmFtZTtcblxuXHRcdHN1cGVyKG9wdGlvbnMpO1xuXHR9XG5cblx0c3RhdGljIGluaXRSZW5kZXJlcigpIHtcblx0XHRpbml0RGF0YUxpc3RlbmVyKCk7XG5cdH1cblxuXHRvcGVuSW5FZGl0b3IoKSB7XG5cdFx0c2hlbGwub3BlblBhdGgodGhpcy5wYXRoKTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVsZWN0cm9uU3RvcmU7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1taXhlZC1zcGFjZXMtYW5kLXRhYnMgKi9cbmltcG9ydCBTdG9yZSBmcm9tICdlbGVjdHJvbi1zdG9yZSc7XG5cbmNvbnN0IHNjaGVtYSA9IHtcblx0bm90ZXM6IHtcblx0XHR0eXBlOiAnb2JqZWN0JyxcbiAgICBwYXR0ZXJuUHJvcGVydGllczoge1xuICAgICAgJ1tBLVphLXowLTlfLV0nOiB7XG4gICAgICBcdHR5cGU6ICdvYmplY3QnLFxuICAgICAgXHRwcm9wZXJ0aWVzOiB7XG4gICAgICBcdFx0aWQ6IHsgdHlwZTogJ3N0cmluZycsIGRlZmF1bHQ6ICcnIH0sXG4gICAgICBcdFx0dGl0bGU6IHsgdHlwZTogJ3N0cmluZycsIGRlZmF1bHQ6ICcnIH0sXG4gICAgICBcdFx0Y29udGVudDogeyB0eXBlOiAnb2JqZWN0JywgZGVmYXVsdDogeyB0eXBlOiAnZG9jJywgY29udGVudDogW10gfSB9LFxuICAgICAgXHRcdGxhYmVsczogeyB0eXBlOiAnYXJyYXknLCBkZWZhdWx0OiBbXSB9LFxuICAgICAgXHRcdGNyZWF0ZWRBdDogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogRGF0ZS5ub3coKSB9LFxuICAgICAgXHRcdHVwZGF0ZWRBdDogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogRGF0ZS5ub3coKSB9LFxuICAgICAgXHRcdGlzQm9va21hcmtlZDogeyB0eXBlOiAnYm9vbGVhbicsIGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICBcdFx0aXNBcmNoaXZlZDogeyB0eXBlOiAnYm9vbGVhbicsIGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgICAgbGFzdEN1cnNvclBvc2l0aW9uOiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAwIH0sXG4gICAgICBcdH0sXG4gICAgICB9LFxuICAgIH0sXG5cdH0sXG4gIGxhYmVsczoge1xuICAgIHR5cGU6ICdhcnJheScsXG4gIH0sXG59O1xuXG5jb25zdCBzdG9yZSA9IG5ldyBTdG9yZSh7XG5cdHNjaGVtYSxcbiAgZW5jcnlwdGlvbktleTogaW1wb3J0Lm1ldGEuZW52LlZJVEVfRU5DUllQVF9LRVksXG59KTtcblxuLy8gc3RvcmUub25EaWRDaGFuZ2UoJ25vdGVzJywgKHZhbHVlKSA9PiB7XG4vLyAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbi8vIH0pO1xuXG5leHBvcnQgZGVmYXVsdCBzdG9yZTtcbiIsImltcG9ydCBTdG9yZSBmcm9tICdlbGVjdHJvbi1zdG9yZSc7XG5pbXBvcnQgeyBhcHAgfSBmcm9tICdlbGVjdHJvbic7XG5cbmNvbnN0IHNjaGVtYSA9IHtcblx0ZGF0YURpcjoge1xuXHRcdHR5cGU6ICdzdHJpbmcnLFxuXHRcdGRlZmF1bHQ6IGFwcC5nZXRQYXRoKCd1c2VyRGF0YScpLFxuXHR9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgbmV3IFN0b3JlKHsgbmFtZTogJ3NldHRpbmdzJywgc2NoZW1hLCBlbmNyeXB0aW9uS2V5OiBwcm9jZXNzLmVudi5WSVRFX0VOQ1JZUFRfS0VZIH0pO1xuIiwiaW1wb3J0IGRhdGEgZnJvbSAnLi9tb2R1bGVzL2RhdGEuc3RvcmUnO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4vbW9kdWxlcy9zZXR0aW5ncy5zdG9yZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblx0ZGF0YSxcblx0c2V0dGluZ3MsXG59O1xuIiwiaW1wb3J0IHsgYXBwLCBCcm93c2VyV2luZG93LCBkaWFsb2csIHByb3RvY29sLCBuYXRpdmVUaGVtZSwgc2hlbGwgfSBmcm9tICdlbGVjdHJvbic7XG5pbXBvcnQgeyBpcGNNYWluIH0gZnJvbSAnZWxlY3Ryb24tYmV0dGVyLWlwYyc7XG5pbXBvcnQgeyBqb2luLCBub3JtYWxpemUgfSBmcm9tICdwYXRoJztcbmltcG9ydCB7IFVSTCB9IGZyb20gJ3VybCc7XG5pbXBvcnQgeyByZW1vdmUsIHJlYWRKc29uLCBlbnN1cmVEaXIsIGNvcHksIG91dHB1dEpzb24sIHBhdGhFeGlzdHNTeW5jIH0gZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHsgYXV0b1VwZGF0ZXIgfSBmcm9tICdlbGVjdHJvbi11cGRhdGVyJztcbmltcG9ydCBzdG9yZSBmcm9tICcuL3N0b3JlJztcblxuY29uc3QgaXNTaW5nbGVJbnN0YW5jZSA9IGFwcC5yZXF1ZXN0U2luZ2xlSW5zdGFuY2VMb2NrKCk7XG5cbmlmICghaXNTaW5nbGVJbnN0YW5jZSkge1xuICBhcHAucXVpdCgpO1xuICBwcm9jZXNzLmV4aXQoMCk7XG59XG5cbmFwcC5kaXNhYmxlSGFyZHdhcmVBY2NlbGVyYXRpb24oKTtcblxuLyoqXG4gKiBXb3JrYXJvdW5kIGZvciBUeXBlU2NyaXB0IGJ1Z1xuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzQxNDY4I2lzc3VlY29tbWVudC03Mjc1NDM0MDBcbiAqL1xuY29uc3QgZW52ID0gaW1wb3J0Lm1ldGEuZW52O1xuXG5cbi8vIEluc3RhbGwgXCJWdWUuanMgZGV2dG9vbHNcIlxuaWYgKGVudi5NT0RFID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gIGFwcC53aGVuUmVhZHkoKVxuICAgIC50aGVuKCgpID0+IGltcG9ydCgnZWxlY3Ryb24tZGV2dG9vbHMtaW5zdGFsbGVyJykpXG4gICAgLnRoZW4oKHtkZWZhdWx0OiBpbnN0YWxsRXh0ZW5zaW9uLCBWVUVKUzNfREVWVE9PTFN9KSA9PiBpbnN0YWxsRXh0ZW5zaW9uKFZVRUpTM19ERVZUT09MUywge1xuICAgICAgbG9hZEV4dGVuc2lvbk9wdGlvbnM6IHtcbiAgICAgICAgYWxsb3dGaWxlQWNjZXNzOiB0cnVlLFxuICAgICAgfSxcbiAgICB9KSlcbiAgICAuY2F0Y2goZSA9PiBjb25zb2xlLmVycm9yKCdGYWlsZWQgaW5zdGFsbCBleHRlbnNpb246JywgZSkpO1xufVxuXG5sZXQgbWFpbldpbmRvdyA9IG51bGw7XG5cbmNvbnN0IGNyZWF0ZVdpbmRvdyA9IGFzeW5jICgpID0+IHtcbiAgbWFpbldpbmRvdyA9IG5ldyBCcm93c2VyV2luZG93KHtcbiAgICBzaG93OiBmYWxzZSwgLy8gVXNlICdyZWFkeS10by1zaG93JyBldmVudCB0byBzaG93IHdpbmRvd1xuICAgIHdpZHRoOiA5NTAsXG4gICAgaGVpZ2h0OiA2MDAsXG4gICAgd2ViUHJlZmVyZW5jZXM6IHtcbiAgICAgIHByZWxvYWQ6IGpvaW4oX19kaXJuYW1lLCAnLi4vLi4vcHJlbG9hZC9kaXN0L2luZGV4LmNqcycpLFxuICAgICAgY29udGV4dElzb2xhdGlvbjogZW52Lk1PREUgIT09ICd0ZXN0JywgICAvLyBTcGVjdHJvbiB0ZXN0cyBjYW4ndCB3b3JrIHdpdGggY29udGV4dElzb2xhdGlvbjogdHJ1ZVxuICAgICAgZW5hYmxlUmVtb3RlTW9kdWxlOiBlbnYuTU9ERSA9PT0gJ3Rlc3QnLCAvLyBTcGVjdHJvbiB0ZXN0cyBjYW4ndCB3b3JrIHdpdGggZW5hYmxlUmVtb3RlTW9kdWxlOiBmYWxzZVxuICAgIH0sXG4gIH0pO1xuXG4gIG1haW5XaW5kb3cuc2V0TWVudUJhclZpc2liaWxpdHkoZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBJZiB5b3UgaW5zdGFsbCBgc2hvdzogdHJ1ZWAgdGhlbiBpdCBjYW4gY2F1c2UgaXNzdWVzIHdoZW4gdHJ5aW5nIHRvIGNsb3NlIHRoZSB3aW5kb3cuXG4gICAqIFVzZSBgc2hvdzogZmFsc2VgIGFuZCBsaXN0ZW5lciBldmVudHMgYHJlYWR5LXRvLXNob3dgIHRvIGZpeCB0aGVzZSBpc3N1ZXMuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uL2VsZWN0cm9uL2lzc3Vlcy8yNTAxMlxuICAgKi9cbiAgbWFpbldpbmRvdy5vbigncmVhZHktdG8tc2hvdycsICgpID0+IHtcbiAgICBtYWluV2luZG93Py5zaG93KCk7XG5cbiAgICBpZiAoZW52Lk1PREUgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIG1haW5XaW5kb3c/LndlYkNvbnRlbnRzLm9wZW5EZXZUb29scygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdXRvVXBkYXRlci5jaGVja0ZvclVwZGF0ZXNBbmROb3RpZnkoKTtcbiAgICB9XG4gIH0pO1xuXG4gIG1haW5XaW5kb3c/LndlYkNvbnRlbnRzLm9uKCduZXctd2luZG93JywgZnVuY3Rpb24oZXZlbnQsIHVybCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJ25vdGU6Ly8nKSkgcmV0dXJuO1xuXG4gICAgc2hlbGwub3BlbkV4dGVybmFsKHVybCk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBVUkwgZm9yIG1haW4gd2luZG93LlxuICAgKiBWaXRlIGRldiBzZXJ2ZXIgZm9yIGRldmVsb3BtZW50LlxuICAgKiBgZmlsZTovLy4uL3JlbmRlcmVyL2luZGV4Lmh0bWxgIGZvciBwcm9kdWN0aW9uIGFuZCB0ZXN0XG4gICAqL1xuICBjb25zdCBwYWdlVXJsID0gZW52Lk1PREUgPT09ICdkZXZlbG9wbWVudCdcbiAgICA/IGVudi5WSVRFX0RFVl9TRVJWRVJfVVJMXG4gICAgOiBuZXcgVVJMKCcuLi9yZW5kZXJlci9kaXN0L2luZGV4Lmh0bWwnLCAnZmlsZTovLycgKyBfX2Rpcm5hbWUpLnRvU3RyaW5nKCk7XG5cblxuICBhd2FpdCBtYWluV2luZG93LmxvYWRVUkwocGFnZVVybCk7XG59O1xuXG5cbmFwcC5vbignc2Vjb25kLWluc3RhbmNlJywgKCkgPT4ge1xuICAvLyBTb21lb25lIHRyaWVkIHRvIHJ1biBhIHNlY29uZCBpbnN0YW5jZSwgd2Ugc2hvdWxkIGZvY3VzIG91ciB3aW5kb3cuXG4gIGlmIChtYWluV2luZG93KSB7XG4gICAgaWYgKG1haW5XaW5kb3cuaXNNaW5pbWl6ZWQoKSkgbWFpbldpbmRvdy5yZXN0b3JlKCk7XG4gICAgbWFpbldpbmRvdy5mb2N1cygpO1xuICB9XG59KTtcblxuXG5hcHAub24oJ3dpbmRvdy1hbGwtY2xvc2VkJywgKCkgPT4ge1xuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSAhPT0gJ2RhcndpbicpIHtcbiAgICBhcHAucXVpdCgpO1xuICB9XG59KTtcblxuXG5hcHAud2hlblJlYWR5KClcbiAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgIHByb3RvY29sLnJlZ2lzdGVyRmlsZVByb3RvY29sKCdhc3NldHMnLCAocmVxdWVzdCwgY2FsbGJhY2spID0+IHtcbiAgICAgIGNvbnN0IHVybCA9IHJlcXVlc3QudXJsLnN1YnN0cig5KTtcblxuICAgICAgY29uc3QgZGlyID0gc3RvcmUuc2V0dGluZ3MuZ2V0KCdkYXRhRGlyJyk7XG4gICAgICBjb25zdCBpbWdQYXRoID0gYCR7ZGlyfS9ub3Rlcy1hc3NldHMvJHt1cmx9YDtcblxuICAgICAgY2FsbGJhY2soeyBwYXRoOiBub3JtYWxpemUoaW1nUGF0aCkgfSk7XG4gICAgfSk7XG5cbiAgICBhd2FpdCBlbnN1cmVEaXIoam9pbihhcHAuZ2V0UGF0aCgndXNlckRhdGEnKSwgJ25vdGVzLWFzc2V0cycpKTtcbiAgICBhd2FpdCBjcmVhdGVXaW5kb3coKTtcbiAgfSlcbiAgLmNhdGNoKChlKSA9PiBjb25zb2xlLmVycm9yKCdGYWlsZWQgY3JlYXRlIHdpbmRvdzonLCBlKSk7XG5cblxuLy8gQXV0by11cGRhdGVzXG5pZiAoZW52LlBST0QpIHtcbiAgYXBwLndoZW5SZWFkeSgpXG4gICAgLnRoZW4oKCkgPT4gaW1wb3J0KCdlbGVjdHJvbi11cGRhdGVyJykpXG4gICAgLnRoZW4oKHsgYXV0b1VwZGF0ZXIgfSkgPT4gYXV0b1VwZGF0ZXIuY2hlY2tGb3JVcGRhdGVzQW5kTm90aWZ5KCkpXG4gICAgLmNhdGNoKChlKSA9PiBjb25zb2xlLmVycm9yKCdGYWlsZWQgY2hlY2sgdXBkYXRlczonLCBlKSk7XG59XG5cbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2FwcDppbmZvJywgKCkgPT4gKHtcbiAgbmFtZTogYXBwLmdldE5hbWUoKSxcbiAgdmVyc2lvbjogYXBwLmdldFZlcnNpb24oKSxcbn0pKTtcblxuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignZGlhbG9nOm9wZW4nLCAocHJvcHMpID0+IGRpYWxvZy5zaG93T3BlbkRpYWxvZyhwcm9wcykpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignZGlhbG9nOm1lc3NhZ2UnLCAocHJvcHMpID0+IGRpYWxvZy5zaG93TWVzc2FnZUJveChwcm9wcykpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignZGlhbG9nOnNhdmUnLCAocHJvcHMpID0+IGRpYWxvZy5zaG93U2F2ZURpYWxvZyhwcm9wcykpO1xuXG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdmczpjb3B5JywgKHsgcGF0aCwgZGVzdCB9KSA9PiBjb3B5KHBhdGgsIGRlc3QpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2ZzOm91dHB1dC1qc29uJywgKHsgcGF0aCwgZGF0YSB9KSA9PiBvdXRwdXRKc29uKHBhdGgsIGRhdGEpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2ZzOnJlYWQtanNvbicsIChwYXRoKSA9PiByZWFkSnNvbihwYXRoKSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdmczplbnN1cmVEaXInLCAocGF0aCkgPT4gZW5zdXJlRGlyKHBhdGgpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2ZzOnBhdGhFeGlzdHMnLCAocGF0aCkgPT4gcGF0aEV4aXN0c1N5bmMocGF0aCkpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignZnM6cmVtb3ZlJywgKHBhdGgpID0+IHJlbW92ZShwYXRoKSk7XG5cbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2hlbHBlcjpyZWxhdW5jaCcsIChvcHRpb25zID0ge30pID0+IHtcbiAgYXBwLnJlbGF1bmNoKHsgYXJnczogcHJvY2Vzcy5hcmd2LnNsaWNlKDEpLmNvbmNhdChbJy0tcmVsYXVuY2gnXSksIC4uLm9wdGlvbnMgfSk7XG4gIGFwcC5leGl0KDApO1xufSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdoZWxwZXI6Z2V0LXBhdGgnLCAobmFtZSkgPT4gYXBwLmdldFBhdGgobmFtZSkpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignaGVscGVyOmlzLWRhcmstdGhlbWUnLCAoKSA9PiBuYXRpdmVUaGVtZS5zaG91bGRVc2VEYXJrQ29sb3JzKTtcblxuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignc3RvcmFnZTpzdG9yZScsIChuYW1lKSA9PiBzdG9yZVtuYW1lXT8uc3RvcmUpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignc3RvcmFnZTpyZXBsYWNlJywgKHsgbmFtZSwgZGF0YSB9KSA9PiAoc3RvcmVbbmFtZV0uc3RvcmUgPSBkYXRhKSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdzdG9yYWdlOmdldCcsICh7IG5hbWUsIGtleSwgZGVmIH0pID0+IHN0b3JlW25hbWVdPy5nZXQoa2V5LCBkZWYpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ3N0b3JhZ2U6c2V0JywgKHsgbmFtZSwga2V5LCB2YWx1ZSB9KSA9PiBzdG9yZVtuYW1lXT8uc2V0KGtleSwgdmFsdWUpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ3N0b3JhZ2U6ZGVsZXRlJywgKHsgbmFtZSwga2V5IH0pID0+IHN0b3JlW25hbWVdPy5kZWxldGUoa2V5KSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdzdG9yYWdlOmhhcycsICh7IG5hbWUsIGtleSB9KSA9PiBzdG9yZVtuYW1lXT8uaGFzKGtleSkpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignc3RvcmFnZTpjbGVhcicsIChuYW1lKSA9PiBzdG9yZVtuYW1lXT8uY2xlYXIoKSk7XG4iXSwibmFtZXMiOlsic2VyaWFsaXplRXJyb3IiLCJkZXNlcmlhbGl6ZUVycm9yIiwiZWxlY3Ryb24iLCJyZXF1aXJlJCQwIiwicmVxdWlyZSQkMSIsInV0aWwiLCJyZXF1aXJlJCQyIiwiaXBjUmVuZGVyZXIiLCJpcGMiLCJpcGNNYWluIiwibWFpbiIsImNvbnN0YW50cyIsInBvbHlmaWxscyIsInBhdGNoIiwibGVnYWN5IiwiY2xvbmUiLCJmcyIsInJlcXVpcmUkJDMiLCJyZXF1aXJlJCQ0IiwiZGVidWciLCJnbG9iYWwiLCJyZXF1aXJlJCQ1IiwicGF0aCIsImNoZWNrUGF0aCIsImdldE1vZGUiLCJ1IiwiX21ha2VEaXIiLCJtYWtlRGlyU3luYyIsIm1ha2VEaXIiLCJta2RpcnMiLCJ1dGltZXMiLCJ1dGltZXNNaWxsaXMiLCJ1dGltZXNNaWxsaXNTeW5jIiwiZ2V0U3RhdHMiLCJhcmVJZGVudGljYWwiLCJpc1NyY1N1YmRpciIsImVyck1zZyIsImdldFN0YXRzU3luYyIsImNoZWNrUGFyZW50UGF0aHMiLCJjaGVja1BhcmVudFBhdGhzU3luYyIsInN0YXQiLCJjaGVja1BhdGhzIiwiY2hlY2tQYXRoc1N5bmMiLCJta2RpcnNTeW5jIiwiaGFuZGxlRmlsdGVyQW5kQ29weSIsIm9uRGlyIiwib25GaWxlIiwib25MaW5rIiwiY29weUZpbGUiLCJtYXlDb3B5RmlsZSIsImhhbmRsZVRpbWVzdGFtcHMiLCJzZXREZXN0TW9kZSIsImZpbGVJc05vdFdyaXRhYmxlIiwibWFrZUZpbGVXcml0YWJsZSIsInNldERlc3RUaW1lc3RhbXBzIiwibWtEaXJBbmRDb3B5IiwiY29weURpciIsImNvcHlEaXJJdGVtIiwic3RhcnRDb3B5IiwiY29weUxpbmsiLCJjb3B5U3luY18xIiwiY29weVN5bmMiLCJwYXRoRXhpc3RzXzEiLCJwYXRoRXhpc3RzIiwiaGFuZGxlRmlsdGVyIiwiY2hlY2tQYXJlbnREaXIiLCJoYW5kbGVUaW1lc3RhbXBzQW5kTW9kZSIsInNldERlc3RUaW1lc3RhbXBzQW5kTW9kZSIsImNvcHlEaXJJdGVtcyIsImNvcHlfMSIsImNvcHkiLCJhc3NlcnQiLCJpc1dpbmRvd3MiLCJkZWZhdWx0cyIsInJpbXJhZl8iLCJmaXhXaW5FUEVSTSIsInJtZGlyIiwicm1kaXJTeW5jIiwicm1raWRzIiwicmltcmFmIiwiZml4V2luRVBFUk1TeW5jIiwicm1raWRzU3luYyIsInJpbXJhZlN5bmMiLCJyaW1yYWZfMSIsInJlbW92ZV8xIiwicmVtb3ZlIiwicmVtb3ZlU3luYyIsIm1rZGlyIiwiZW1wdHlEaXIiLCJlbXB0eSIsImVtcHR5RGlyU3luYyIsImZpbGUiLCJjcmVhdGVGaWxlIiwiY3JlYXRlRmlsZVN5bmMiLCJsaW5rIiwiY3JlYXRlTGluayIsImNyZWF0ZUxpbmtTeW5jIiwic3ltbGlua1BhdGhzXzEiLCJzeW1saW5rUGF0aHMiLCJzeW1saW5rUGF0aHNTeW5jIiwic3ltbGlua1R5cGVfMSIsInN5bWxpbmtUeXBlIiwic3ltbGlua1R5cGVTeW5jIiwiX21rZGlycyIsIl9zeW1saW5rUGF0aHMiLCJfc3ltbGlua1R5cGUiLCJyZXF1aXJlJCQ2IiwicmVxdWlyZSQkNyIsIl9jcmVhdGVTeW1saW5rIiwic3ltbGluayIsImNyZWF0ZVN5bWxpbmsiLCJjcmVhdGVTeW1saW5rU3luYyIsImVuc3VyZSIsInV0aWxzIiwic3RyaW5naWZ5Iiwic3RyaXBCb20iLCJyZWFkRmlsZSIsIndyaXRlRmlsZSIsImpzb25maWxlIiwicmVhZEZpbGVTeW5jIiwid3JpdGVGaWxlU3luYyIsImpzb25GaWxlIiwib3V0cHV0RmlsZSIsIm91dHB1dEZpbGVTeW5jIiwib3V0cHV0SnNvbl8xIiwib3V0cHV0SnNvbiIsIm91dHB1dEpzb25TeW5jXzEiLCJvdXRwdXRKc29uU3luYyIsImpzb24iLCJta2RpcnBTeW5jIiwiaXNQYXJlbnRSb290IiwiZG9SZW5hbWUiLCJyZW5hbWUiLCJtb3ZlQWNyb3NzRGV2aWNlIiwibW92ZVN5bmNfMSIsIm1vdmVTeW5jIiwibWtkaXJwIiwibW92ZV8xIiwibW92ZSIsImxpYiIsInJlcXVpcmUkJDgiLCJyZXF1aXJlJCQ5IiwicmVxdWlyZSQkMTAiLCJyZXF1aXJlJCQxMSIsIkNhbmNlbGxhdGlvblRva2VuXzEiLCJldmVudHNfMSIsInBhcnNlIiwiY29tbW9uIiwiUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybV8xIiwic3RyZWFtXzEiLCJjcnlwdG9fMSIsImRlYnVnXzEiLCJmc18xIiwidXJsXzEiLCJpbmRleF8xIiwiWUFNTEV4Y2VwdGlvbiIsIm1ha2VTbmlwcGV0IiwidHlwZSIsIlR5cGUiLCJTY2hlbWEiLCJzY2hlbWEiLCJjb3JlIiwiX2hhc093blByb3BlcnR5IiwiX3RvU3RyaW5nIiwiREVGQVVMVF9TQ0hFTUEiLCJTdGF0ZSIsInJlcXVpcmUkJDEyIiwiU0VNVkVSX1NQRUNfVkVSU0lPTiIsIk1BWF9MRU5HVEgiLCJNQVhfU0FGRV9JTlRFR0VSIiwiTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCIsInBhcnNlT3B0aW9ucyIsInBhcnNlT3B0aW9uc18xIiwibnVtZXJpYyIsImNvbXBhcmVJZGVudGlmaWVycyIsInJjb21wYXJlSWRlbnRpZmllcnMiLCJpZGVudGlmaWVycyIsInJlIiwidCIsIlNlbVZlciIsInNlbXZlciIsInBhcnNlXzEiLCJ2YWxpZCIsInZhbGlkXzEiLCJjbGVhbiIsImNsZWFuXzEiLCJpbmMiLCJpbmNfMSIsImRpZmYiLCJkaWZmXzEiLCJtYWpvciIsIm1ham9yXzEiLCJtaW5vciIsIm1pbm9yXzEiLCJwYXRjaF8xIiwicHJlcmVsZWFzZSIsInByZXJlbGVhc2VfMSIsImNvbXBhcmUiLCJjb21wYXJlXzEiLCJyY29tcGFyZSIsInJjb21wYXJlXzEiLCJjb21wYXJlTG9vc2UiLCJjb21wYXJlTG9vc2VfMSIsImNvbXBhcmVCdWlsZCIsImNvbXBhcmVCdWlsZF8xIiwic29ydCIsInNvcnRfMSIsInJzb3J0IiwicnNvcnRfMSIsImd0IiwiZ3RfMSIsImx0IiwibHRfMSIsImVxIiwiZXFfMSIsIm5lcSIsIm5lcV8xIiwiZ3RlIiwiZ3RlXzEiLCJsdGUiLCJsdGVfMSIsImNtcCIsImNtcF8xIiwiY29lcmNlIiwiY29lcmNlXzEiLCJZYWxsaXN0IiwiUmFuZ2UiLCJDb21wYXJhdG9yIiwiaXNOdWxsU2V0IiwiaXNBbnkiLCJjYWNoZSIsImh5cGhlblJlcGxhY2UiLCJjb21wYXJhdG9yVHJpbVJlcGxhY2UiLCJ0aWxkZVRyaW1SZXBsYWNlIiwiY2FyZXRUcmltUmVwbGFjZSIsInBhcnNlQ29tcGFyYXRvciIsInJlcGxhY2VHVEUwIiwiaXNTYXRpc2ZpYWJsZSIsInRlc3RTZXQiLCJyYW5nZSIsIkxSVSIsInJlcGxhY2VDYXJldHMiLCJyZXBsYWNlVGlsZGVzIiwicmVwbGFjZVhSYW5nZXMiLCJyZXBsYWNlU3RhcnMiLCJpc1giLCJyZXBsYWNlVGlsZGUiLCJyZXBsYWNlQ2FyZXQiLCJyZXBsYWNlWFJhbmdlIiwiQU5ZIiwiY29tcGFyYXRvciIsInNhdGlzZmllcyIsInNhdGlzZmllc18xIiwidG9Db21wYXJhdG9ycyIsInRvQ29tcGFyYXRvcnNfMSIsIm1heFNhdGlzZnlpbmciLCJtYXhTYXRpc2Z5aW5nXzEiLCJtaW5TYXRpc2Z5aW5nIiwibWluU2F0aXNmeWluZ18xIiwibWluVmVyc2lvbiIsIm1pblZlcnNpb25fMSIsInZhbGlkUmFuZ2UiLCJvdXRzaWRlIiwib3V0c2lkZV8xIiwiZ3RyIiwiZ3RyXzEiLCJsdHIiLCJsdHJfMSIsImludGVyc2VjdHMiLCJpbnRlcnNlY3RzXzEiLCJzaW1wbGlmeSIsInN1YnNldCIsInNpbXBsZVN1YnNldCIsImhpZ2hlckdUIiwibG93ZXJMVCIsInN1YnNldF8xIiwiaW50ZXJuYWxSZSIsInJlcXVpcmUkJDEzIiwicmVxdWlyZSQkMTQiLCJyZXF1aXJlJCQxNSIsInJlcXVpcmUkJDE2IiwicmVxdWlyZSQkMTciLCJyZXF1aXJlJCQxOCIsInJlcXVpcmUkJDE5IiwicmVxdWlyZSQkMjAiLCJyZXF1aXJlJCQyMSIsInJlcXVpcmUkJDIyIiwicmVxdWlyZSQkMjMiLCJyZXF1aXJlJCQyNCIsInJlcXVpcmUkJDI1IiwicmVxdWlyZSQkMjYiLCJyZXF1aXJlJCQyNyIsInJlcXVpcmUkJDI4IiwicmVxdWlyZSQkMjkiLCJyZXF1aXJlJCQzMCIsInJlcXVpcmUkJDMxIiwicmVxdWlyZSQkMzIiLCJyZXF1aXJlJCQzMyIsInJlcXVpcmUkJDM0IiwicmVxdWlyZSQkMzUiLCJyZXF1aXJlJCQzNiIsInJlcXVpcmUkJDM3IiwicmVxdWlyZSQkMzgiLCJyZXF1aXJlJCQzOSIsInJlcXVpcmUkJDQwIiwiRG93bmxvYWRlZFVwZGF0ZUhlbHBlcl8xIiwiZnNfZXh0cmFfMSIsIkVsZWN0cm9uQXBwQWRhcHRlcl8xIiwiU3ltYm9sIiwiZXNjYXBlUmVnRXhwIiwiUHJvdmlkZXJfMSIsImJ1aWxkZXJfdXRpbF9ydW50aW1lXzEiLCJqc195YW1sXzEiLCJ1dGlsXzEiLCJHZW5lcmljUHJvdmlkZXJfMSIsIkJpdGJ1Y2tldFByb3ZpZGVyXzEiLCJHaXRIdWJQcm92aWRlcl8xIiwiS2V5Z2VuUHJvdmlkZXJfMSIsIlByaXZhdGVHaXRIdWJQcm92aWRlcl8xIiwiQXBwVXBkYXRlcl8xIiwibWFpbl8xIiwiQmFzZVVwZGF0ZXJfMSIsImNoaWxkX3Byb2Nlc3NfMSIsIkRhdGFTcGxpdHRlcl8xIiwiZG93bmxvYWRQbGFuQnVpbGRlcl8xIiwiUHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZENhbGxiYWNrVHJhbnNmb3JtXzEiLCJEaWZmZXJlbnRpYWxEb3dubG9hZGVyXzEiLCJGaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyXzEiLCJ6bGliXzEiLCJBcHBJbWFnZVVwZGF0ZXJfMSIsIkRlYlVwZGF0ZXJfMSIsIlJwbVVwZGF0ZXJfMSIsIk1hY1VwZGF0ZXJfMSIsIkdlbmVyaWNEaWZmZXJlbnRpYWxEb3dubG9hZGVyXzEiLCJvcyIsIk5zaXNVcGRhdGVyXzEiLCJpc09iaiIsInBhdGhFeGlzdHNNb2R1bGUiLCJwVHJ5IiwicFRyeU1vZHVsZSIsInBMaW1pdCIsInBMaW1pdE1vZHVsZSIsInBMb2NhdGUiLCJsb2NhdGVQYXRoTW9kdWxlIiwiZmluZFVwTW9kdWxlIiwicGtnVXBNb2R1bGUiLCJlbnYiLCJlbnZQYXRoc01vZHVsZSIsImNvbnN0c18xIiwiZGlzdCIsIm5hbWVzXzEiLCJjb2RlZ2VuXzEiLCJlcnJvcnNfMSIsImNvZGVfMSIsInRyYXZlcnNlIiwianNvblNjaGVtYVRyYXZlcnNlTW9kdWxlIiwidGhpcyIsInJlc29sdmUiLCJlcXVhbCIsIlVSSSIsImRhdGFUeXBlXzEiLCJyZXNvbHZlXzEiLCJ2YWxpZGF0ZV8xIiwiZGVmIiwiY29yZV8xIiwiZXJyb3IiLCJ1Y3MybGVuZ3RoXzEiLCJlcXVhbF8xIiwidmFsaWRhdGlvbl8xIiwiaXRlbXNfMSIsImFkZGl0aW9uYWxJdGVtc18xIiwicHJvcGVydGllcyIsImFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEiLCJmb3JtYXQiLCJmb3JtYXRfMiIsImZvcm1hdF8xIiwibWltaWNGbiIsIm1pbWljRm5Nb2R1bGUiLCJvbmV0aW1lTW9kdWxlIiwiZG90UHJvcCIsInBrZ1VwIiwiZGVib3VuY2VGbiIsInN0b3JlIiwiU3RvcmUiLCJhcHAiLCJkYXRhIiwiQnJvd3NlcldpbmRvdyIsImpvaW4iLCJzaGVsbCIsInByb3RvY29sIiwibm9ybWFsaXplIiwiZW5zdXJlRGlyIiwiZGlhbG9nIiwicmVhZEpzb24iLCJwYXRoRXhpc3RzU3luYyIsIm5hdGl2ZVRoZW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLHVCQUF1QixNQUFNO0FBQUEsRUFDNUIsWUFBWSxTQUFTO0FBQ3BCLFVBQU0sU0FBUyxxQkFBcUI7QUFDcEMsV0FBTyxlQUFlLE1BQU0sUUFBUTtBQUFBLE1BQ25DLE9BQU87QUFBQSxNQUNQLGNBQWM7QUFBQSxNQUNkLFVBQVU7QUFBQTtB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QVU7QUFBQSxNQUNWLFVBQVU7QUFBQSxNQUNWLFFBQVE7QUFBQSxNQUNSLFNBQVM7QUFBQSxNQUNULFVBQVU7QUFBQSxNQUNWLFNBQVM7QUFBQSxNQUNULFVBQVU7QUFBQSxNQUNWLFFBQVE7QUFBQSxNQUNSLFVBQVU7QUFBQSxNQUNWLFVBQVU7QUFBQSxNQUNWLFNBQVM7QUFBQSxNQUNULFNBQVM7QUFBQSxNQUNULFVBQVU7QUFBQSxNQUNWLFNBQVM7QUFBQSxNQUNULFVBQVU7QUFBQSxNQUNWLFFBQVE7QUFBQSxNQUNSLFVBQVU7QUFBQSxNQUNWLFVBQVU7QUFBQSxNQUNWLFNBQVM7QUFBQSxNQUNULFVBQVU7QUFBQSxNQUNWLE9BQU87QUFBQSxNQUNQLFFBQVE7QUFBQSxNQUNSLFVBQVU7QUFBQSxNQUNWLFNBQVM7QUFBQSxNQUNULFVBQVU7QUFBQSxNQUNWLFFBQVE7QUFBQSxNQUNSLFVBQVU7QUFBQSxNQUNWLFVBQVU7QUFBQSxNQUNWLFNBQVM7QUFBQSxNQUNULFVBQVU7QUFBQSxNQUNWLFVBQVU7QUFBQSxNQUNWLFVBQVU7QUFBQSxNQUNWLFFBQVE7QUFBQSxNQUNSLFNBQVM7QUFBQSxNQUNULFNBQVM7QUFBQSxNQUNULFVBQVU7QUFBQSxNQUNWLFNBQVM7QUFBQSxNQUNULFVBQVU7QUFBQSxNQUNWLFFBQVE7QUFBQSxNQUNSLFVBQVU7QUFBQSxNQUNWLFFBQVE7QUFBQSxNQUNSLFFBQVE7QUFBQSxNQUNSLE9BQU87QUFBQSxNQUNQLFFBQVE7QUFBQSxNQUNSLFNBQVM7QUFBQSxNQUNULFFBQVE7QUFBQSxNQUNSLFNBQVM7QUFBQSxNQUNULFVBQVU7QUFBQSxNQUNWLE9BQU87QUFBQSxNQUNQLFVBQVU7QUFBQSxNQUNWLFFBQVE7QUFBQSxNQUNSLE9BQU87QUFBQSxNQUNQLFFBQVE7QUFBQSxNQUNSLFNBQVM7QUFBQSxNQUNULE9BQU87QUFBQSxNQUNQLE9BQU87QUFBQSxNQUNQLFFBQVE7QUFBQSxNQUNSLE9BQU87QUFBQSxNQUNQLFVBQVU7QUFBQSxNQUNWLFFBQVE7QUFBQSxNQUNSLFFBQVE7QUFBQSxNQUNSLFFBQVE7QUFBQSxNQUNSLFNBQVM7QUFBQSxNQUNULFNBQVM7QUFBQSxNQUNULFFBQVE7QUFBQSxNQUNSLFVBQVU7QUFBQSxNQUNWLFNBQVM7QUFBQSxNQUNULFFBQVE7QUFBQSxNQUNSLFNBQVM7QUFBQSxNQUNULFVBQVU7QUFBQSxNQUNWLFVBQVU7QUFBQSxNQUNWLFVBQVU7QUFBQSxNQUNWLFVBQVU7QUFBQSxNQUNWLFNBQVM7QUFBQSxNQUNULFVBQVU7QUFBQSxNQUNWLFNBQVM7QUFBQSxNQUNULFNBQVM7QUFBQSxNQUNULFVBQVU7QUFBQSxNQUNWLFVBQVU7QUFBQSxNQUNWLFFBQVE7QUFBQSxNQUNSLFFBQVE7QUFBQSxNQUNSLFFBQVE7QUFBQSxNQUNSLFNBQVM7QUFBQSxNQUNULFNBQVM7QUFBQSxNQUNULFFBQVE7QUFBQSxNQUNSLFNBQVM7QUFBQSxNQUNULFNBQVM7QUFBQSxNQUNULFdBQVc7QUFBQSxNQUNYLFFBQVE7QUFBQSxNQUNSLE9BQU87QUFBQSxNQUNQLFNBQVM7QUFBQSxNQUNULFFBQVE7QUFBQSxNQUNSLFNBQVM7QUFBQSxNQUNULFVBQVU7QUFBQSxNQUNWLE1BQU07QUFBQSxNQUNOLE1BQU07QUFBQSxNQUNOLE1BQU07QUFBQSxNQUNOLFdBQVc7QUFBQSxNQUNYLE1BQU07QUFBQSxNQUNOLE9BQU87QUFBQSxNQUNQLFNBQVM7QUFBQSxNQUNULE9BQU87QUFBQSxNQUNQLFdBQVc7QUFBQSxNQUNYLE9BQU87QUFBQSxNQUNQLE9BQU87QUFBQSxNQUNQLE9BQU87QUFBQSxNQUNQLFNBQVM7QUFBQSxNQUNULFNBQVM7QUFBQSxNQUNULFFBQVE7QUFBQSxNQUNSLFNBQVM7QUFBQSxNQUNULFNBQVM7QUFBQSxNQUNULFdBQVc7QUFBQSxNQUNYLFFBQVE7QUFBQSxNQUNSLE9BQU87QUFBQSxNQUNQLFNBQVM7QUFBQSxNQUNULFFBQVE7QUFBQSxNQUNSLFNBQVM7QUFBQSxNQUNULFVBQVU7QUFBQSxNQUNWLE1BQU07QUFBQSxNQUNOLE1BQU07QUFBQSxNQUNOLE1BQU07QUFBQSxNQUNOLFdBQVc7QUFBQSxNQUNYLE1BQU07QUFBQSxNQUNOLE9BQU87QUFBQSxNQUNQLFVBQVU7QUFBQSxNQUNWLFNBQVM7QUFBQSxNQUNULE9BQU87QUFBQSxNQUNQLFdBQVc7QUFBQSxNQUNYLE9BQU87QUFBQSxNQUNQLE9BQU87QUFBQSxNQUNQLE9BQU87QUFBQSxNQUNQLFNBQVM7QUFBQSxNQUNULFlBQVk7QUFBQSxNQUNaLFNBQVM7QUFBQSxNQUNULE9BQU87QUFBQSxNQUNQLFFBQVE7QUFBQSxNQUNSLFFBQVE7QUFBQSxNQUNSLFVBQVU7QUFBQSxNQUNWLFFBQVE7QUFBQSxNQUNSLE9BQU87QUFBQSxNQUNQLE9BQU87QUFBQSxNQUNQLE9BQU87QUFBQSxNQUNQLFNBQVM7QUFBQSxNQUNULFNBQVM7QUFBQSxNQUNULFNBQVM7QUFBQSxNQUNULFNBQVM7QUFBQSxNQUNULFNBQVM7QUFBQSxNQUNULFNBQVM7QUFBQSxNQUNULFNBQVM7QUFBQSxNQUNULFNBQVM7QUFBQSxNQUNULFVBQVU7QUFBQSxNQUNWLFVBQVU7QUFBQSxNQUNWLFFBQVE7QUFBQSxNQUNSLFVBQVU7QUFBQSxNQUNWLFVBQVU7QUFBQSxNQUNWLFNBQVM7QUFBQSxNQUNULFNBQVM7QUFBQSxNQUNULFVBQVU7QUFBQSxNQUNWLFVBQVU7QUFBQSxNQUNWLFNBQVM7QUFBQSxNQUNULFNBQVM7QUFBQSxNQUNULFFBQVE7QUFBQSxNQUNSLFNBQVM7QUFBQSxNQUNULFVBQVU7QUFBQSxNQUNWLFFBQVE7QUFBQSxNQUNSLFNBQVM7QUFBQSxNQUNULFdBQVc7QUFBQSxNQUNYLFFBQVE7QUFBQSxNQUNSLFFBQVE7QUFBQSxNQUNSLFFBQVE7QUFBQSxNQUNSLFFBQVE7QUFBQSxNQUNSLFFBQVE7QUFBQSxNQUNSLFNBQVM7QUFBQSxNQUNULFFBQVE7QUFBQSxNQUNSLFFBQVE7QUFBQSxNQUNSLFFBQVE7QUFBQSxNQUNSLFFBQVE7QUFBQSxNQUNSLFFBQVE7QUFBQSxNQUNSLFVBQVU7QUFBQSxNQUNWLFFBQVE7QUFBQSxNQUNSLFNBQVM7QUFBQSxNQUNULFNBQVM7QUFBQSxNQUNULFNBQVM7QUFBQSxNQUNULFFBQVE7QUFBQSxNQUNSLFNBQVM7QUFBQSxNQUNULE1BQU07QUFBQSxNQUNOLFFBQVE7QUFBQSxNQUNSLE9BQU87QUFBQSxNQUNQLFNBQVM7QUFBQSxNQUNULFVBQVU7QUFBQSxNQUNWLFNBQVM7QUFBQSxNQUNULFFBQVE7QUFBQSxNQUNSLFNBQVM7QUFBQSxNQUNULE9BQU87QUFBQSxNQUNQLE9BQU87QUFBQSxNQUNQLE1BQU07QUFBQSxNQUNOLE9BQU87QUFBQSxNQUNQLE9BQU87QUFBQSxNQUNQLE9BQU87QUFBQSxNQUNQLFVBQVU7QUFBQSxNQUNWLE9BQU87QUFBQSxNQUNQLFFBQVE7QUFBQSxNQUNSLFNBQVM7QUFBQSxNQUNULE1BQU07QUFBQSxNQUNOLFNBQVM7QUFBQSxNQUNULE1BQU07QUFBQSxNQUNOLE1BQU07QUFBQSxNQUNOLE9BQU87QUFBQSxNQUNQLE9BQU87QUFBQSxNQUNQLFFBQVE7QUFBQSxNQUNSLFFBQVE7QUFBQSxNQUNSLFFBQVE7QUFBQSxNQUNSLFNBQVM7QUFBQSxNQUNULFVBQVU7QUFBQSxNQUNWLFFBQVE7QUFBQSxNQUNSLFFBQVE7QUFBQSxNQUNSLFNBQVM7QUFBQSxNQUNULFNBQVM7QUFBQSxNQUNULFVBQVU7QUFBQSxNQUNWLFVBQVU7QUFBQSxNQUNWLFFBQVE7QUFBQSxNQUNSLFFBQVE7QUFBQSxNQUNSLE9BQU87QUFBQSxNQUNQLFVBQVU7QUFBQSxNQUNWLFNBQVM7QUFBQSxNQUNULFVBQVU7QUFBQSxNQUNWLFNBQVM7QUFBQTtBQUdYLFdBQU8sS0FBSyxLQUFJLFVBQVUsUUFBUSxTQUFVLEtBQUs7QUFDL0MsVUFBSSxJQUFJLEtBQUksU0FBUztBQUNyQixVQUFJLEtBQUksT0FBTyxNQUFNLFdBQVcsT0FBTyxhQUFhLEtBQUs7QUFDekQsV0FBSSxTQUFTLE9BQU87QUFBQTtBQUd0QixhQUFTLE1BQUssS0FBSSxPQUFPO0FBQ3ZCLFdBQUksTUFBTSxLQUFJLE1BQU0sT0FBTTtBQUFBO0FB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
