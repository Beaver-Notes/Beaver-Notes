"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var require$$0 = require("electron");
var require$$1 = require("path");
require("url");
var require$$0$3 = require("fs");
var require$$0$1 = require("constants");
var require$$0$2 = require("stream");
var require$$4 = require("util");
var require$$5 = require("assert");
var require$$3$1 = require("crypto");
var require$$5$1 = require("events");
var require$$1$1 = require("os");
function _interopDefaultLegacy(e) {
  return e && typeof e === "object" && "default" in e ? e : { "default": e };
}
function _interopNamespace(e) {
  if (e && e.__esModule)
    return e;
  var n = { __proto__: null, [Symbol.toStringTag]: "Module" };
  if (e) {
    Object.keys(e).forEach(function(k) {
      if (k !== "default") {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function() {
            return e[k];
          }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}
var require$$0__default = /* @__PURE__ */ _interopDefaultLegacy(require$$0);
var require$$1__default = /* @__PURE__ */ _interopDefaultLegacy(require$$1);
var require$$0__default$3 = /* @__PURE__ */ _interopDefaultLegacy(require$$0$3);
var require$$0__default$1 = /* @__PURE__ */ _interopDefaultLegacy(require$$0$1);
var require$$0__default$2 = /* @__PURE__ */ _interopDefaultLegacy(require$$0$2);
var require$$4__default = /* @__PURE__ */ _interopDefaultLegacy(require$$4);
var require$$5__default = /* @__PURE__ */ _interopDefaultLegacy(require$$5);
var require$$3__default = /* @__PURE__ */ _interopDefaultLegacy(require$$3$1);
var require$$5__default$1 = /* @__PURE__ */ _interopDefaultLegacy(require$$5$1);
var require$$1__default$1 = /* @__PURE__ */ _interopDefaultLegacy(require$$1$1);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
class NonError extends Error {
  constructor(message) {
    super(NonError._prepareSuperMessage(message));
    Object.defineProperty(this, "name", {
      value: "NonError",
      configurable: true,
      writable: true
    });
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, NonError);
    }
  }
  static _prepareSuperMessage(message) {
    try {
      return JSON.stringify(message);
    } catch {
      return String(message);
    }
  }
}
const commonProperties = [
  { property: "name", enumerable: false },
  { property: "message", enumerable: false },
  { property: "stack", enumerable: false },
  { property: "code", enumerable: true }
];
const isCalled = Symbol(".toJSON called");
const toJSON = (from) => {
  from[isCalled] = true;
  const json2 = from.toJSON();
  delete from[isCalled];
  return json2;
};
const destroyCircular = ({
  from,
  seen,
  to_,
  forceEnumerable,
  maxDepth,
  depth
}) => {
  const to = to_ || (Array.isArray(from) ? [] : {});
  seen.push(from);
  if (depth >= maxDepth) {
    return to;
  }
  if (typeof from.toJSON === "function" && from[isCalled] !== true) {
    return toJSON(from);
  }
  for (const [key, value] of Object.entries(from)) {
    if (typeof Buffer === "function" && Buffer.isBuffer(value)) {
      to[key] = "[object Buffer]";
      continue;
    }
    if (typeof value === "function") {
      continue;
    }
    if (!value || typeof value !== "object") {
      to[key] = value;
      continue;
    }
    if (!seen.includes(from[key])) {
      depth++;
      to[key] = destroyCircular({
        from: from[key],
        seen: seen.slice(),
        forceEnumerable,
        maxDepth,
        depth
      });
      continue;
    }
    to[key] = "[Circular]";
  }
  for (const { property, enumerable } of commonProperties) {
    if (typeof from[property] === "string") {
      Object.defineProperty(to, property, {
        value: from[property],
        enumerable: forceEnumerable ? true : enumerable,
        configurable: true,
        writable: true
      });
    }
  }
  return to;
};
const serializeError$2 = (value, options = {}) => {
  const { maxDepth = Number.POSITIVE_INFINITY } = options;
  if (typeof value === "object" && value !== null) {
    return destroyCircular({
      from: value,
      seen: [],
      forceEnumerable: true,
      maxDepth,
      depth: 0
    });
  }
  if (typeof value === "function") {
    return `[Function: ${value.name || "anonymous"}]`;
  }
  return value;
};
const deserializeError$2 = (value, options = {}) => {
  const { maxDepth = Number.POSITIVE_INFINITY } = options;
  if (value instanceof Error) {
    return value;
  }
  if (typeof value === "object" && value !== null && !Array.isArray(value)) {
    const newError = new Error();
    destroyCircular({
      from: value,
      seen: [],
      to_: newError,
      maxDepth,
      depth: 0
    });
    return newError;
  }
  return new NonError(value);
};
var serializeError_1 = {
  serializeError: serializeError$2,
  deserializeError: deserializeError$2
};
var util$5 = {};
const getUniqueId = () => `${Date.now()}-${Math.random()}`;
const getSendChannel = (channel) => `%better-ipc-send-channel-${channel}`;
const getRendererSendChannel = (channel) => `%better-ipc-send-channel-${channel}`;
util$5.currentWindowChannel = "%better-ipc-current-window";
util$5.getSendChannel = getSendChannel;
util$5.getRendererSendChannel = getRendererSendChannel;
util$5.getResponseChannels = (channel) => {
  const id2 = getUniqueId();
  return {
    sendChannel: getSendChannel(channel),
    dataChannel: `%better-ipc-response-data-channel-${channel}-${id2}`,
    errorChannel: `%better-ipc-response-error-channel-${channel}-${id2}`
  };
};
util$5.getRendererResponseChannels = (channel) => {
  const id2 = getUniqueId();
  return {
    sendChannel: getRendererSendChannel(channel),
    dataChannel: `%better-ipc-response-data-channel-${channel}-${id2}`,
    errorChannel: `%better-ipc-response-error-channel-${channel}-${id2}`
  };
};
const electron$1 = require$$0__default["default"];
const { serializeError: serializeError$1, deserializeError: deserializeError$1 } = serializeError_1;
const util$4 = util$5;
const { ipcRenderer: ipcRenderer$1 } = electron$1;
const ipc$1 = Object.create(ipcRenderer$1 || {});
ipc$1.callMain = (channel, data) => new Promise((resolve2, reject) => {
  const { sendChannel, dataChannel, errorChannel } = util$4.getResponseChannels(channel);
  const cleanup = () => {
    ipcRenderer$1.off(dataChannel, onData);
    ipcRenderer$1.off(errorChannel, onError);
  };
  const onData = (_event, result) => {
    cleanup();
    resolve2(result);
  };
  const onError = (_event, error2) => {
    cleanup();
    reject(deserializeError$1(error2));
  };
  ipcRenderer$1.once(dataChannel, onData);
  ipcRenderer$1.once(errorChannel, onError);
  const completeData = {
    dataChannel,
    errorChannel,
    userData: data
  };
  ipcRenderer$1.send(sendChannel, completeData);
});
ipc$1.answerMain = (channel, callback) => {
  const sendChannel = util$4.getRendererSendChannel(channel);
  const listener = async (_event, data) => {
    const { dataChannel, errorChannel, userData } = data;
    try {
      ipcRenderer$1.send(dataChannel, await callback(userData));
    } catch (error2) {
      ipcRenderer$1.send(errorChannel, serializeError$1(error2));
    }
  };
  ipcRenderer$1.on(sendChannel, listener);
  return () => {
    ipcRenderer$1.off(sendChannel, listener);
  };
};
const electron = require$$0__default["default"];
const { serializeError, deserializeError } = serializeError_1;
const util$3 = util$5;
const { ipcMain: ipcMain$2, BrowserWindow } = electron;
const ipc = Object.create(ipcMain$2 || {});
ipc.callRenderer = (browserWindow, channel, data) => new Promise((resolve2, reject) => {
  if (!browserWindow) {
    throw new Error("Browser window required");
  }
  const { sendChannel, dataChannel, errorChannel } = util$3.getRendererResponseChannels(channel);
  const cleanup = () => {
    ipcMain$2.off(dataChannel, onData);
    ipcMain$2.off(errorChannel, onError);
  };
  const onData = (event, result) => {
    const window2 = BrowserWindow.fromWebContents(event.sender);
    if (window2.id === browserWindow.id) {
      cleanup();
      resolve2(result);
    }
  };
  const onError = (event, error2) => {
    const window2 = BrowserWindow.fromWebContents(event.sender);
    if (window2.id === browserWindow.id) {
      cleanup();
      reject(deserializeError(error2));
    }
  };
  ipcMain$2.on(dataChannel, onData);
  ipcMain$2.on(errorChannel, onError);
  const completeData = {
    dataChannel,
    errorChannel,
    userData: data
  };
  if (browserWindow.webContents) {
    browserWindow.webContents.send(sendChannel, completeData);
  }
});
ipc.callFocusedRenderer = async (...args) => {
  const focusedWindow = BrowserWindow.getFocusedWindow();
  if (!focusedWindow) {
    throw new Error("No browser window in focus");
  }
  return ipc.callRenderer(focusedWindow, ...args);
};
ipc.answerRenderer = (browserWindowOrChannel, channelOrCallback, callbackOrNothing) => {
  let window2;
  let channel;
  let callback;
  if (callbackOrNothing === void 0) {
    channel = browserWindowOrChannel;
    callback = channelOrCallback;
  } else {
    window2 = browserWindowOrChannel;
    channel = channelOrCallback;
    callback = callbackOrNothing;
    if (!window2) {
      throw new Error("Browser window required");
    }
  }
  const sendChannel = util$3.getSendChannel(channel);
  const listener = async (event, data) => {
    const browserWindow = BrowserWindow.fromWebContents(event.sender);
    if (window2 && window2.id !== browserWindow.id) {
      return;
    }
    const send = (channel2, data2) => {
      if (!(browserWindow && browserWindow.isDestroyed())) {
        event.sender.send(channel2, data2);
      }
    };
    const { dataChannel, errorChannel, userData } = data;
    try {
      send(dataChannel, await callback(userData, browserWindow));
    } catch (error2) {
      send(errorChannel, serializeError(error2));
    }
  };
  ipcMain$2.on(sendChannel, listener);
  return () => {
    ipcMain$2.off(sendChannel, listener);
  };
};
ipc.sendToRenderers = (channel, data) => {
  for (const browserWindow of BrowserWindow.getAllWindows()) {
    if (browserWindow.webContents) {
      browserWindow.webContents.send(channel, data);
    }
  }
};
var main = ipc;
var ipcMain$1;
if (process.type === "renderer")
  ;
else {
  ipcMain$1 = main;
}
var fs$l = {};
var universalify$1 = {};
universalify$1.fromCallback = function(fn) {
  return Object.defineProperty(function(...args) {
    if (typeof args[args.length - 1] === "function")
      fn.apply(this, args);
    else {
      return new Promise((resolve2, reject) => {
        fn.call(this, ...args, (err, res) => err != null ? reject(err) : resolve2(res));
      });
    }
  }, "name", { value: fn.name });
};
universalify$1.fromPromise = function(fn) {
  return Object.defineProperty(function(...args) {
    const cb = args[args.length - 1];
    if (typeof cb !== "function")
      return fn.apply(this, args);
    else
      fn.apply(this, args.slice(0, -1)).then((r) => cb(null, r), cb);
  }, "name", { value: fn.name });
};
var constants$1 = require$$0__default$1["default"];
var origCwd = process.cwd;
var cwd = null;
var platform = process.platform;
process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process);
  return cwd;
};
try {
  process.cwd();
} catch (er) {
}
if (typeof process.chdir === "function") {
  var chdir = process.chdir;
  process.chdir = function(d) {
    cwd = null;
    chdir.call(process, d);
  };
  if (Object.setPrototypeOf)
    Object.setPrototypeOf(process.chdir, chdir);
}
var polyfills$1 = patch$2;
function patch$2(fs2) {
  if (constants$1.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs2);
  }
  if (!fs2.lutimes) {
    patchLutimes(fs2);
  }
  fs2.chown = chownFix(fs2.chown);
  fs2.fchown = chownFix(fs2.fchown);
  fs2.lchown = chownFix(fs2.lchown);
  fs2.chmod = chmodFix(fs2.chmod);
  fs2.fchmod = chmodFix(fs2.fchmod);
  fs2.lchmod = chmodFix(fs2.lchmod);
  fs2.chownSync = chownFixSync(fs2.chownSync);
  fs2.fchownSync = chownFixSync(fs2.fchownSync);
  fs2.lchownSync = chownFixSync(fs2.lchownSync);
  fs2.chmodSync = chmodFixSync(fs2.chmodSync);
  fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
  fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
  fs2.stat = statFix(fs2.stat);
  fs2.fstat = statFix(fs2.fstat);
  fs2.lstat = statFix(fs2.lstat);
  fs2.statSync = statFixSync(fs2.statSync);
  fs2.fstatSync = statFixSync(fs2.fstatSync);
  fs2.lstatSync = statFixSync(fs2.lstatSync);
  if (!fs2.lchmod) {
    fs2.lchmod = function(path2, mode, cb) {
      if (cb)
        process.nextTick(cb);
    };
    fs2.lchmodSync = function() {
    };
  }
  if (!fs2.lchown) {
    fs2.lchown = function(path2, uid, gid, cb) {
      if (cb)
        process.nextTick(cb);
    };
    fs2.lchownSync = function() {
    };
  }
  if (platform === "win32") {
    fs2.rename = function(fs$rename) {
      return function(from, to, cb) {
        var start = Date.now();
        var backoff = 0;
        fs$rename(from, to, function CB(er) {
          if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
            setTimeout(function() {
              fs2.stat(to, function(stater, st) {
                if (stater && stater.code === "ENOENT")
                  fs$rename(from, to, CB);
                else
                  cb(er);
              });
            }, backoff);
            if (backoff < 100)
              backoff += 10;
            return;
          }
          if (cb)
            cb(er);
        });
      };
    }(fs2.rename);
  }
  fs2.read = function(fs$read) {
    function read(fd, buffer, offset, length, position, callback_) {
      var callback;
      if (callback_ && typeof callback_ === "function") {
        var eagCounter = 0;
        callback = function(er, _, __) {
          if (er && er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
          }
          callback_.apply(this, arguments);
        };
      }
      return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
    }
    if (Object.setPrototypeOf)
      Object.setPrototypeOf(read, fs$read);
    return read;
  }(fs2.read);
  fs2.readSync = function(fs$readSync) {
    return function(fd, buffer, offset, length, position) {
      var eagCounter = 0;
      while (true) {
        try {
          return fs$readSync.call(fs2, fd, buffer, offset, length, position);
        } catch (er) {
          if (er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            continue;
          }
          throw er;
        }
      }
    };
  }(fs2.readSync);
  function patchLchmod(fs3) {
    fs3.lchmod = function(path2, mode, callback) {
      fs3.open(path2, constants$1.O_WRONLY | constants$1.O_SYMLINK, mode, function(err, fd) {
        if (err) {
          if (callback)
            callback(err);
          return;
        }
        fs3.fchmod(fd, mode, function(err2) {
          fs3.close(fd, function(err22) {
            if (callback)
              callback(err2 || err22);
          });
        });
      });
    };
    fs3.lchmodSync = function(path2, mode) {
      var fd = fs3.openSync(path2, constants$1.O_WRONLY | constants$1.O_SYMLINK, mode);
      var threw = true;
      var ret;
      try {
        ret = fs3.fchmodSync(fd, mode);
        threw = false;
      } finally {
        if (threw) {
          try {
            fs3.closeSync(fd);
          } catch (er) {
          }
        } else {
          fs3.closeSync(fd);
        }
      }
      return ret;
    };
  }
  function patchLutimes(fs3) {
    if (constants$1.hasOwnProperty("O_SYMLINK")) {
      fs3.lutimes = function(path2, at, mt, cb) {
        fs3.open(path2, constants$1.O_SYMLINK, function(er, fd) {
          if (er) {
            if (cb)
              cb(er);
            return;
          }
          fs3.futimes(fd, at, mt, function(er2) {
            fs3.close(fd, function(er22) {
              if (cb)
                cb(er2 || er22);
            });
          });
        });
      };
      fs3.lutimesSync = function(path2, at, mt) {
        var fd = fs3.openSync(path2, constants$1.O_SYMLINK);
        var ret;
        var threw = true;
        try {
          ret = fs3.futimesSync(fd, at, mt);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs3.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs3.closeSync(fd);
          }
        }
        return ret;
      };
    } else {
      fs3.lutimes = function(_a, _b, _c, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs3.lutimesSync = function() {
      };
    }
  }
  function chmodFix(orig) {
    if (!orig)
      return orig;
    return function(target, mode, cb) {
      return orig.call(fs2, target, mode, function(er) {
        if (chownErOk(er))
          er = null;
        if (cb)
          cb.apply(this, arguments);
      });
    };
  }
  function chmodFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, mode) {
      try {
        return orig.call(fs2, target, mode);
      } catch (er) {
        if (!chownErOk(er))
          throw er;
      }
    };
  }
  function chownFix(orig) {
    if (!orig)
      return orig;
    return function(target, uid, gid, cb) {
      return orig.call(fs2, target, uid, gid, function(er) {
        if (chownErOk(er))
          er = null;
        if (cb)
          cb.apply(this, arguments);
      });
    };
  }
  function chownFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, uid, gid) {
      try {
        return orig.call(fs2, target, uid, gid);
      } catch (er) {
        if (!chownErOk(er))
          throw er;
      }
    };
  }
  function statFix(orig) {
    if (!orig)
      return orig;
    return function(target, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      function callback(er, stats) {
        if (stats) {
          if (stats.uid < 0)
            stats.uid += 4294967296;
          if (stats.gid < 0)
            stats.gid += 4294967296;
        }
        if (cb)
          cb.apply(this, arguments);
      }
      return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
    };
  }
  function statFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, options) {
      var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
      if (stats.uid < 0)
        stats.uid += 4294967296;
      if (stats.gid < 0)
        stats.gid += 4294967296;
      return stats;
    };
  }
  function chownErOk(er) {
    if (!er)
      return true;
    if (er.code === "ENOSYS")
      return true;
    var nonroot = !process.getuid || process.getuid() !== 0;
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true;
    }
    return false;
  }
}
var Stream = require$$0__default$2["default"].Stream;
var legacyStreams = legacy$1;
function legacy$1(fs2) {
  return {
    ReadStream,
    WriteStream
  };
  function ReadStream(path2, options) {
    if (!(this instanceof ReadStream))
      return new ReadStream(path2, options);
    Stream.call(this);
    var self2 = this;
    this.path = path2;
    this.fd = null;
    this.readable = true;
    this.paused = false;
    this.flags = "r";
    this.mode = 438;
    this.bufferSize = 64 * 1024;
    options = options || {};
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }
    if (this.encoding)
      this.setEncoding(this.encoding);
    if (this.start !== void 0) {
      if (typeof this.start !== "number") {
        throw TypeError("start must be a Number");
      }
      if (this.end === void 0) {
        this.end = Infinity;
      } else if (typeof this.end !== "number") {
        throw TypeError("end must be a Number");
      }
      if (this.start > this.end) {
        throw new Error("start must be <= end");
      }
      this.pos = this.start;
    }
    if (this.fd !== null) {
      process.nextTick(function() {
        self2._read();
      });
      return;
    }
    fs2.open(this.path, this.flags, this.mode, function(err, fd) {
      if (err) {
        self2.emit("error", err);
        self2.readable = false;
        return;
      }
      self2.fd = fd;
      self2.emit("open", fd);
      self2._read();
    });
  }
  function WriteStream(path2, options) {
    if (!(this instanceof WriteStream))
      return new WriteStream(path2, options);
    Stream.call(this);
    this.path = path2;
    this.fd = null;
    this.writable = true;
    this.flags = "w";
    this.encoding = "binary";
    this.mode = 438;
    this.bytesWritten = 0;
    options = options || {};
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }
    if (this.start !== void 0) {
      if (typeof this.start !== "number") {
        throw TypeError("start must be a Number");
      }
      if (this.start < 0) {
        throw new Error("start must be >= zero");
      }
      this.pos = this.start;
    }
    this.busy = false;
    this._queue = [];
    if (this.fd === null) {
      this._open = fs2.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
      this.flush();
    }
  }
}
var clone_1 = clone$1;
var getPrototypeOf = Object.getPrototypeOf || function(obj) {
  return obj.__proto__;
};
function clone$1(obj) {
  if (obj === null || typeof obj !== "object")
    return obj;
  if (obj instanceof Object)
    var copy2 = { __proto__: getPrototypeOf(obj) };
  else
    var copy2 = Object.create(null);
  Object.getOwnPropertyNames(obj).forEach(function(key) {
    Object.defineProperty(copy2, key, Object.getOwnPropertyDescriptor(obj, key));
  });
  return copy2;
}
var fs$k = require$$0__default$3["default"];
var polyfills = polyfills$1;
var legacy = legacyStreams;
var clone = clone_1;
var util$2 = require$$4__default["default"];
var gracefulQueue;
var previousSymbol;
if (typeof Symbol === "function" && typeof Symbol.for === "function") {
  gracefulQueue = Symbol.for("graceful-fs.queue");
  previousSymbol = Symbol.for("graceful-fs.previous");
} else {
  gracefulQueue = "___graceful-fs.queue";
  previousSymbol = "___graceful-fs.previous";
}
function noop() {
}
function publishQueue(context, queue2) {
  Object.defineProperty(context, gracefulQueue, {
    get: function() {
      return queue2;
    }
  });
}
var debug$4 = noop;
if (util$2.debuglog)
  debug$4 = util$2.debuglog("gfs4");
else if (/\bgfs4\b/i.test(""))
  debug$4 = function() {
    var m = util$2.format.apply(util$2, arguments);
    m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
    console.error(m);
  };
if (!fs$k[gracefulQueue]) {
  var queue = commonjsGlobal[gracefulQueue] || [];
  publishQueue(fs$k, queue);
  fs$k.close = function(fs$close) {
    function close(fd, cb) {
      return fs$close.call(fs$k, fd, function(err) {
        if (!err) {
          resetQueue();
        }
        if (typeof cb === "function")
          cb.apply(this, arguments);
      });
    }
    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    });
    return close;
  }(fs$k.close);
  fs$k.closeSync = function(fs$closeSync) {
    function closeSync(fd) {
      fs$closeSync.apply(fs$k, arguments);
      resetQueue();
    }
    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    });
    return closeSync;
  }(fs$k.closeSync);
  if (/\bgfs4\b/i.test("")) {
    process.on("exit", function() {
      debug$4(fs$k[gracefulQueue]);
      require$$5__default["default"].equal(fs$k[gracefulQueue].length, 0);
    });
  }
}
if (!commonjsGlobal[gracefulQueue]) {
  publishQueue(commonjsGlobal, fs$k[gracefulQueue]);
}
var gracefulFs = patch$1(clone(fs$k));
function patch$1(fs2) {
  polyfills(fs2);
  fs2.gracefulify = patch$1;
  fs2.createReadStream = createReadStream;
  fs2.createWriteStream = createWriteStream;
  var fs$readFile = fs2.readFile;
  fs2.readFile = readFile2;
  function readFile2(path2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$readFile(path2, options, cb);
    function go$readFile(path3, options2, cb2, startTime) {
      return fs$readFile(path3, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$readFile, [path3, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$writeFile = fs2.writeFile;
  fs2.writeFile = writeFile2;
  function writeFile2(path2, data, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$writeFile(path2, data, options, cb);
    function go$writeFile(path3, data2, options2, cb2, startTime) {
      return fs$writeFile(path3, data2, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$writeFile, [path3, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$appendFile = fs2.appendFile;
  if (fs$appendFile)
    fs2.appendFile = appendFile;
  function appendFile(path2, data, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$appendFile(path2, data, options, cb);
    function go$appendFile(path3, data2, options2, cb2, startTime) {
      return fs$appendFile(path3, data2, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$appendFile, [path3, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$copyFile = fs2.copyFile;
  if (fs$copyFile)
    fs2.copyFile = copyFile2;
  function copyFile2(src, dest, flags, cb) {
    if (typeof flags === "function") {
      cb = flags;
      flags = 0;
    }
    return go$copyFile(src, dest, flags, cb);
    function go$copyFile(src2, dest2, flags2, cb2, startTime) {
      return fs$copyFile(src2, dest2, flags2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$readdir = fs2.readdir;
  fs2.readdir = readdir;
  function readdir(path2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$readdir(path2, options, cb);
    function go$readdir(path3, options2, cb2, startTime) {
      return fs$readdir(path3, options2, function(err, files) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$readdir, [path3, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (files && files.sort)
            files.sort();
          if (typeof cb2 === "function")
            cb2.call(this, err, files);
        }
      });
    }
  }
  if (process.version.substr(0, 4) === "v0.8") {
    var legStreams = legacy(fs2);
    ReadStream = legStreams.ReadStream;
    WriteStream = legStreams.WriteStream;
  }
  var fs$ReadStream = fs2.ReadStream;
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype);
    ReadStream.prototype.open = ReadStream$open;
  }
  var fs$WriteStream = fs2.WriteStream;
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype);
    WriteStream.prototype.open = WriteStream$open;
  }
  Object.defineProperty(fs2, "ReadStream", {
    get: function() {
      return ReadStream;
    },
    set: function(val) {
      ReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(fs2, "WriteStream", {
    get: function() {
      return WriteStream;
    },
    set: function(val) {
      WriteStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileReadStream = ReadStream;
  Object.defineProperty(fs2, "FileReadStream", {
    get: function() {
      return FileReadStream;
    },
    set: function(val) {
      FileReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileWriteStream = WriteStream;
  Object.defineProperty(fs2, "FileWriteStream", {
    get: function() {
      return FileWriteStream;
    },
    set: function(val) {
      FileWriteStream = val;
    },
    enumerable: true,
    configurable: true
  });
  function ReadStream(path2, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this;
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
  }
  function ReadStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function(err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy();
        that.emit("error", err);
      } else {
        that.fd = fd;
        that.emit("open", fd);
        that.read();
      }
    });
  }
  function WriteStream(path2, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this;
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
  }
  function WriteStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function(err, fd) {
      if (err) {
        that.destroy();
        that.emit("error", err);
      } else {
        that.fd = fd;
        that.emit("open", fd);
      }
    });
  }
  function createReadStream(path2, options) {
    return new fs2.ReadStream(path2, options);
  }
  function createWriteStream(path2, options) {
    return new fs2.WriteStream(path2, options);
  }
  var fs$open = fs2.open;
  fs2.open = open;
  function open(path2, flags, mode, cb) {
    if (typeof mode === "function")
      cb = mode, mode = null;
    return go$open(path2, flags, mode, cb);
    function go$open(path3, flags2, mode2, cb2, startTime) {
      return fs$open(path3, flags2, mode2, function(err, fd) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$open, [path3, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  return fs2;
}
function enqueue(elem) {
  debug$4("ENQUEUE", elem[0].name, elem[1]);
  fs$k[gracefulQueue].push(elem);
  retry();
}
var retryTimer;
function resetQueue() {
  var now = Date.now();
  for (var i = 0; i < fs$k[gracefulQueue].length; ++i) {
    if (fs$k[gracefulQueue][i].length > 2) {
      fs$k[gracefulQueue][i][3] = now;
      fs$k[gracefulQueue][i][4] = now;
    }
  }
  retry();
}
function retry() {
  clearTimeout(retryTimer);
  retryTimer = void 0;
  if (fs$k[gracefulQueue].length === 0)
    return;
  var elem = fs$k[gracefulQueue].shift();
  var fn = elem[0];
  var args = elem[1];
  var err = elem[2];
  var startTime = elem[3];
  var lastTime = elem[4];
  if (startTime === void 0) {
    debug$4("RETRY", fn.name, args);
    fn.apply(null, args);
  } else if (Date.now() - startTime >= 6e4) {
    debug$4("TIMEOUT", fn.name, args);
    var cb = args.pop();
    if (typeof cb === "function")
      cb.call(null, err);
  } else {
    var sinceAttempt = Date.now() - lastTime;
    var sinceStart = Math.max(lastTime - startTime, 1);
    var desiredDelay = Math.min(sinceStart * 1.2, 100);
    if (sinceAttempt >= desiredDelay) {
      debug$4("RETRY", fn.name, args);
      fn.apply(null, args.concat([startTime]));
    } else {
      fs$k[gracefulQueue].push(elem);
    }
  }
  if (retryTimer === void 0) {
    retryTimer = setTimeout(retry, 0);
  }
}
(function(exports) {
  const u2 = universalify$1.fromCallback;
  const fs2 = gracefulFs;
  const api = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((key) => {
    return typeof fs2[key] === "function";
  });
  Object.assign(exports, fs2);
  api.forEach((method) => {
    exports[method] = u2(fs2[method]);
  });
  exports.realpath.native = u2(fs2.realpath.native);
  exports.exists = function(filename, callback) {
    if (typeof callback === "function") {
      return fs2.exists(filename, callback);
    }
    return new Promise((resolve2) => {
      return fs2.exists(filename, resolve2);
    });
  };
  exports.read = function(fd, buffer, offset, length, position, callback) {
    if (typeof callback === "function") {
      return fs2.read(fd, buffer, offset, length, position, callback);
    }
    return new Promise((resolve2, reject) => {
      fs2.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
        if (err)
          return reject(err);
        resolve2({ bytesRead, buffer: buffer2 });
      });
    });
  };
  exports.write = function(fd, buffer, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs2.write(fd, buffer, ...args);
    }
    return new Promise((resolve2, reject) => {
      fs2.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
        if (err)
          return reject(err);
        resolve2({ bytesWritten, buffer: buffer2 });
      });
    });
  };
  if (typeof fs2.writev === "function") {
    exports.writev = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs2.writev(fd, buffers, ...args);
      }
      return new Promise((resolve2, reject) => {
        fs2.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
          if (err)
            return reject(err);
          resolve2({ bytesWritten, buffers: buffers2 });
        });
      });
    };
  }
})(fs$l);
var makeDir$1 = {};
var utils$1 = {};
const path$i = require$$1__default["default"];
utils$1.checkPath = function checkPath2(pth) {
  if (process.platform === "win32") {
    const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path$i.parse(pth).root, ""));
    if (pathHasInvalidWinCharacters) {
      const error2 = new Error(`Path contains invalid characters: ${pth}`);
      error2.code = "EINVAL";
      throw error2;
    }
  }
};
const fs$j = fs$l;
const { checkPath } = utils$1;
const getMode = (options) => {
  const defaults2 = { mode: 511 };
  if (typeof options === "number")
    return options;
  return __spreadValues(__spreadValues({}, defaults2), options).mode;
};
makeDir$1.makeDir = async (dir, options) => {
  checkPath(dir);
  return fs$j.mkdir(dir, {
    mode: getMode(options),
    recursive: true
  });
};
makeDir$1.makeDirSync = (dir, options) => {
  checkPath(dir);
  return fs$j.mkdirSync(dir, {
    mode: getMode(options),
    recursive: true
  });
};
const u$a = universalify$1.fromPromise;
const { makeDir: _makeDir, makeDirSync } = makeDir$1;
const makeDir = u$a(_makeDir);
var mkdirs$2 = {
  mkdirs: makeDir,
  mkdirsSync: makeDirSync,
  mkdirp: makeDir,
  mkdirpSync: makeDirSync,
  ensureDir: makeDir,
  ensureDirSync: makeDirSync
};
const fs$i = gracefulFs;
function utimesMillis$1(path2, atime, mtime, callback) {
  fs$i.open(path2, "r+", (err, fd) => {
    if (err)
      return callback(err);
    fs$i.futimes(fd, atime, mtime, (futimesErr) => {
      fs$i.close(fd, (closeErr) => {
        if (callback)
          callback(futimesErr || closeErr);
      });
    });
  });
}
function utimesMillisSync$1(path2, atime, mtime) {
  const fd = fs$i.openSync(path2, "r+");
  fs$i.futimesSync(fd, atime, mtime);
  return fs$i.closeSync(fd);
}
var utimes = {
  utimesMillis: utimesMillis$1,
  utimesMillisSync: utimesMillisSync$1
};
const fs$h = fs$l;
const path$h = require$$1__default["default"];
const util$1 = require$$4__default["default"];
function getStats$2(src, dest, opts2) {
  const statFunc = opts2.dereference ? (file2) => fs$h.stat(file2, { bigint: true }) : (file2) => fs$h.lstat(file2, { bigint: true });
  return Promise.all([
    statFunc(src),
    statFunc(dest).catch((err) => {
      if (err.code === "ENOENT")
        return null;
      throw err;
    })
  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
}
function getStatsSync(src, dest, opts2) {
  let destStat;
  const statFunc = opts2.dereference ? (file2) => fs$h.statSync(file2, { bigint: true }) : (file2) => fs$h.lstatSync(file2, { bigint: true });
  const srcStat = statFunc(src);
  try {
    destStat = statFunc(dest);
  } catch (err) {
    if (err.code === "ENOENT")
      return { srcStat, destStat: null };
    throw err;
  }
  return { srcStat, destStat };
}
function checkPaths(src, dest, funcName, opts2, cb) {
  util$1.callbackify(getStats$2)(src, dest, opts2, (err, stats) => {
    if (err)
      return cb(err);
    const { srcStat, destStat } = stats;
    if (destStat) {
      if (areIdentical$2(srcStat, destStat)) {
        const srcBaseName = path$h.basename(src);
        const destBaseName = path$h.basename(dest);
        if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
          return cb(null, { srcStat, destStat, isChangingCase: true });
        }
        return cb(new Error("Source and destination must not be the same."));
      }
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
      }
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`));
      }
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      return cb(new Error(errMsg(src, dest, funcName)));
    }
    return cb(null, { srcStat, destStat });
  });
}
function checkPathsSync(src, dest, funcName, opts2) {
  const { srcStat, destStat } = getStatsSync(src, dest, opts2);
  if (destStat) {
    if (areIdentical$2(srcStat, destStat)) {
      const srcBaseName = path$h.basename(src);
      const destBaseName = path$h.basename(dest);
      if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
        return { srcStat, destStat, isChangingCase: true };
      }
      throw new Error("Source and destination must not be the same.");
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
    }
  }
  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new Error(errMsg(src, dest, funcName));
  }
  return { srcStat, destStat };
}
function checkParentPaths(src, srcStat, dest, funcName, cb) {
  const srcParent = path$h.resolve(path$h.dirname(src));
  const destParent = path$h.resolve(path$h.dirname(dest));
  if (destParent === srcParent || destParent === path$h.parse(destParent).root)
    return cb();
  fs$h.stat(destParent, { bigint: true }, (err, destStat) => {
    if (err) {
      if (err.code === "ENOENT")
        return cb();
      return cb(err);
    }
    if (areIdentical$2(srcStat, destStat)) {
      return cb(new Error(errMsg(src, dest, funcName)));
    }
    return checkParentPaths(src, srcStat, destParent, funcName, cb);
  });
}
function checkParentPathsSync(src, srcStat, dest, funcName) {
  const srcParent = path$h.resolve(path$h.dirname(src));
  const destParent = path$h.resolve(path$h.dirname(dest));
  if (destParent === srcParent || destParent === path$h.parse(destParent).root)
    return;
  let destStat;
  try {
    destStat = fs$h.statSync(destParent, { bigint: true });
  } catch (err) {
    if (err.code === "ENOENT")
      return;
    throw err;
  }
  if (areIdentical$2(srcStat, destStat)) {
    throw new Error(errMsg(src, dest, funcName));
  }
  return checkParentPathsSync(src, srcStat, destParent, funcName);
}
function areIdentical$2(srcStat, destStat) {
  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
}
function isSrcSubdir(src, dest) {
  const srcArr = path$h.resolve(src).split(path$h.sep).filter((i) => i);
  const destArr = path$h.resolve(dest).split(path$h.sep).filter((i) => i);
  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
}
function errMsg(src, dest, funcName) {
  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
}
var stat$4 = {
  checkPaths,
  checkPathsSync,
  checkParentPaths,
  checkParentPathsSync,
  isSrcSubdir,
  areIdentical: areIdentical$2
};
const fs$g = gracefulFs;
const path$g = require$$1__default["default"];
const mkdirsSync$1 = mkdirs$2.mkdirsSync;
const utimesMillisSync = utimes.utimesMillisSync;
const stat$3 = stat$4;
function copySync$2(src, dest, opts2) {
  if (typeof opts2 === "function") {
    opts2 = { filter: opts2 };
  }
  opts2 = opts2 || {};
  opts2.clobber = "clobber" in opts2 ? !!opts2.clobber : true;
  opts2.overwrite = "overwrite" in opts2 ? !!opts2.overwrite : opts2.clobber;
  if (opts2.preserveTimestamps && process.arch === "ia32") {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
  }
  const { srcStat, destStat } = stat$3.checkPathsSync(src, dest, "copy", opts2);
  stat$3.checkParentPathsSync(src, srcStat, dest, "copy");
  return handleFilterAndCopy(destStat, src, dest, opts2);
}
function handleFilterAndCopy(destStat, src, dest, opts2) {
  if (opts2.filter && !opts2.filter(src, dest))
    return;
  const destParent = path$g.dirname(dest);
  if (!fs$g.existsSync(destParent))
    mkdirsSync$1(destParent);
  return getStats$1(destStat, src, dest, opts2);
}
function startCopy$1(destStat, src, dest, opts2) {
  if (opts2.filter && !opts2.filter(src, dest))
    return;
  return getStats$1(destStat, src, dest, opts2);
}
function getStats$1(destStat, src, dest, opts2) {
  const statSync = opts2.dereference ? fs$g.statSync : fs$g.lstatSync;
  const srcStat = statSync(src);
  if (srcStat.isDirectory())
    return onDir$1(srcStat, destStat, src, dest, opts2);
  else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
    return onFile$1(srcStat, destStat, src, dest, opts2);
  else if (srcStat.isSymbolicLink())
    return onLink$1(destStat, src, dest, opts2);
  else if (srcStat.isSocket())
    throw new Error(`Cannot copy a socket file: ${src}`);
  else if (srcStat.isFIFO())
    throw new Error(`Cannot copy a FIFO pipe: ${src}`);
  throw new Error(`Unknown file: ${src}`);
}
function onFile$1(srcStat, destStat, src, dest, opts2) {
  if (!destStat)
    return copyFile$1(srcStat, src, dest, opts2);
  return mayCopyFile$1(srcStat, src, dest, opts2);
}
function mayCopyFile$1(srcStat, src, dest, opts2) {
  if (opts2.overwrite) {
    fs$g.unlinkSync(dest);
    return copyFile$1(srcStat, src, dest, opts2);
  } else if (opts2.errorOnExist) {
    throw new Error(`'${dest}' already exists`);
  }
}
function copyFile$1(srcStat, src, dest, opts2) {
  fs$g.copyFileSync(src, dest);
  if (opts2.preserveTimestamps)
    handleTimestamps(srcStat.mode, src, dest);
  return setDestMode$1(dest, srcStat.mode);
}
function handleTimestamps(srcMode, src, dest) {
  if (fileIsNotWritable$1(srcMode))
    makeFileWritable$1(dest, srcMode);
  return setDestTimestamps$1(src, dest);
}
function fileIsNotWritable$1(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable$1(dest, srcMode) {
  return setDestMode$1(dest, srcMode | 128);
}
function setDestMode$1(dest, srcMode) {
  return fs$g.chmodSync(dest, srcMode);
}
function setDestTimestamps$1(src, dest) {
  const updatedSrcStat = fs$g.statSync(src);
  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
}
function onDir$1(srcStat, destStat, src, dest, opts2) {
  if (!destStat)
    return mkDirAndCopy$1(srcStat.mode, src, dest, opts2);
  return copyDir$1(src, dest, opts2);
}
function mkDirAndCopy$1(srcMode, src, dest, opts2) {
  fs$g.mkdirSync(dest);
  copyDir$1(src, dest, opts2);
  return setDestMode$1(dest, srcMode);
}
function copyDir$1(src, dest, opts2) {
  fs$g.readdirSync(src).forEach((item) => copyDirItem$1(item, src, dest, opts2));
}
function copyDirItem$1(item, src, dest, opts2) {
  const srcItem = path$g.join(src, item);
  const destItem = path$g.join(dest, item);
  const { destStat } = stat$3.checkPathsSync(srcItem, destItem, "copy", opts2);
  return startCopy$1(destStat, srcItem, destItem, opts2);
}
function onLink$1(destStat, src, dest, opts2) {
  let resolvedSrc = fs$g.readlinkSync(src);
  if (opts2.dereference) {
    resolvedSrc = path$g.resolve(process.cwd(), resolvedSrc);
  }
  if (!destStat) {
    return fs$g.symlinkSync(resolvedSrc, dest);
  } else {
    let resolvedDest;
    try {
      resolvedDest = fs$g.readlinkSync(dest);
    } catch (err) {
      if (err.code === "EINVAL" || err.code === "UNKNOWN")
        return fs$g.symlinkSync(resolvedSrc, dest);
      throw err;
    }
    if (opts2.dereference) {
      resolvedDest = path$g.resolve(process.cwd(), resolvedDest);
    }
    if (stat$3.isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
    }
    if (fs$g.statSync(dest).isDirectory() && stat$3.isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
    }
    return copyLink$1(resolvedSrc, dest);
  }
}
function copyLink$1(resolvedSrc, dest) {
  fs$g.unlinkSync(dest);
  return fs$g.symlinkSync(resolvedSrc, dest);
}
var copySync_1 = copySync$2;
var copySync$1 = {
  copySync: copySync_1
};
const u$9 = universalify$1.fromPromise;
const fs$f = fs$l;
function pathExists$8(path2) {
  return fs$f.access(path2).then(() => true).catch(() => false);
}
var pathExists_1 = {
  pathExists: u$9(pathExists$8),
  pathExistsSync: fs$f.existsSync
};
const fs$e = gracefulFs;
const path$f = require$$1__default["default"];
const mkdirs$1 = mkdirs$2.mkdirs;
const pathExists$7 = pathExists_1.pathExists;
const utimesMillis = utimes.utimesMillis;
const stat$2 = stat$4;
function copy$2(src, dest, opts2, cb) {
  if (typeof opts2 === "function" && !cb) {
    cb = opts2;
    opts2 = {};
  } else if (typeof opts2 === "function") {
    opts2 = { filter: opts2 };
  }
  cb = cb || function() {
  };
  opts2 = opts2 || {};
  opts2.clobber = "clobber" in opts2 ? !!opts2.clobber : true;
  opts2.overwrite = "overwrite" in opts2 ? !!opts2.overwrite : opts2.clobber;
  if (opts2.preserveTimestamps && process.arch === "ia32") {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
  }
  stat$2.checkPaths(src, dest, "copy", opts2, (err, stats) => {
    if (err)
      return cb(err);
    const { srcStat, destStat } = stats;
    stat$2.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
      if (err2)
        return cb(err2);
      if (opts2.filter)
        return handleFilter(checkParentDir, destStat, src, dest, opts2, cb);
      return checkParentDir(destStat, src, dest, opts2, cb);
    });
  });
}
function checkParentDir(destStat, src, dest, opts2, cb) {
  const destParent = path$f.dirname(dest);
  pathExists$7(destParent, (err, dirExists) => {
    if (err)
      return cb(err);
    if (dirExists)
      return getStats(destStat, src, dest, opts2, cb);
    mkdirs$1(destParent, (err2) => {
      if (err2)
        return cb(err2);
      return getStats(destStat, src, dest, opts2, cb);
    });
  });
}
function handleFilter(onInclude, destStat, src, dest, opts2, cb) {
  Promise.resolve(opts2.filter(src, dest)).then((include) => {
    if (include)
      return onInclude(destStat, src, dest, opts2, cb);
    return cb();
  }, (error2) => cb(error2));
}
function startCopy(destStat, src, dest, opts2, cb) {
  if (opts2.filter)
    return handleFilter(getStats, destStat, src, dest, opts2, cb);
  return getStats(destStat, src, dest, opts2, cb);
}
function getStats(destStat, src, dest, opts2, cb) {
  const stat2 = opts2.dereference ? fs$e.stat : fs$e.lstat;
  stat2(src, (err, srcStat) => {
    if (err)
      return cb(err);
    if (srcStat.isDirectory())
      return onDir(srcStat, destStat, src, dest, opts2, cb);
    else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
      return onFile(srcStat, destStat, src, dest, opts2, cb);
    else if (srcStat.isSymbolicLink())
      return onLink(destStat, src, dest, opts2, cb);
    else if (srcStat.isSocket())
      return cb(new Error(`Cannot copy a socket file: ${src}`));
    else if (srcStat.isFIFO())
      return cb(new Error(`Cannot copy a FIFO pipe: ${src}`));
    return cb(new Error(`Unknown file: ${src}`));
  });
}
function onFile(srcStat, destStat, src, dest, opts2, cb) {
  if (!destStat)
    return copyFile(srcStat, src, dest, opts2, cb);
  return mayCopyFile(srcStat, src, dest, opts2, cb);
}
function mayCopyFile(srcStat, src, dest, opts2, cb) {
  if (opts2.overwrite) {
    fs$e.unlink(dest, (err) => {
      if (err)
        return cb(err);
      return copyFile(srcStat, src, dest, opts2, cb);
    });
  } else if (opts2.errorOnExist) {
    return cb(new Error(`'${dest}' already exists`));
  } else
    return cb();
}
function copyFile(srcStat, src, dest, opts2, cb) {
  fs$e.copyFile(src, dest, (err) => {
    if (err)
      return cb(err);
    if (opts2.preserveTimestamps)
      return handleTimestampsAndMode(srcStat.mode, src, dest, cb);
    return setDestMode(dest, srcStat.mode, cb);
  });
}
function handleTimestampsAndMode(srcMode, src, dest, cb) {
  if (fileIsNotWritable(srcMode)) {
    return makeFileWritable(dest, srcMode, (err) => {
      if (err)
        return cb(err);
      return setDestTimestampsAndMode(srcMode, src, dest, cb);
    });
  }
  return setDestTimestampsAndMode(srcMode, src, dest, cb);
}
function fileIsNotWritable(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable(dest, srcMode, cb) {
  return setDestMode(dest, srcMode | 128, cb);
}
function setDestTimestampsAndMode(srcMode, src, dest, cb) {
  setDestTimestamps(src, dest, (err) => {
    if (err)
      return cb(err);
    return setDestMode(dest, srcMode, cb);
  });
}
function setDestMode(dest, srcMode, cb) {
  return fs$e.chmod(dest, srcMode, cb);
}
function setDestTimestamps(src, dest, cb) {
  fs$e.stat(src, (err, updatedSrcStat) => {
    if (err)
      return cb(err);
    return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
  });
}
function onDir(srcStat, destStat, src, dest, opts2, cb) {
  if (!destStat)
    return mkDirAndCopy(srcStat.mode, src, dest, opts2, cb);
  return copyDir(src, dest, opts2, cb);
}
function mkDirAndCopy(srcMode, src, dest, opts2, cb) {
  fs$e.mkdir(dest, (err) => {
    if (err)
      return cb(err);
    copyDir(src, dest, opts2, (err2) => {
      if (err2)
        return cb(err2);
      return setDestMode(dest, srcMode, cb);
    });
  });
}
function copyDir(src, dest, opts2, cb) {
  fs$e.readdir(src, (err, items2) => {
    if (err)
      return cb(err);
    return copyDirItems(items2, src, dest, opts2, cb);
  });
}
function copyDirItems(items2, src, dest, opts2, cb) {
  const item = items2.pop();
  if (!item)
    return cb();
  return copyDirItem(items2, item, src, dest, opts2, cb);
}
function copyDirItem(items2, item, src, dest, opts2, cb) {
  const srcItem = path$f.join(src, item);
  const destItem = path$f.join(dest, item);
  stat$2.checkPaths(srcItem, destItem, "copy", opts2, (err, stats) => {
    if (err)
      return cb(err);
    const { destStat } = stats;
    startCopy(destStat, srcItem, destItem, opts2, (err2) => {
      if (err2)
        return cb(err2);
      return copyDirItems(items2, src, dest, opts2, cb);
    });
  });
}
function onLink(destStat, src, dest, opts2, cb) {
  fs$e.readlink(src, (err, resolvedSrc) => {
    if (err)
      return cb(err);
    if (opts2.dereference) {
      resolvedSrc = path$f.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
      return fs$e.symlink(resolvedSrc, dest, cb);
    } else {
      fs$e.readlink(dest, (err2, resolvedDest) => {
        if (err2) {
          if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
            return fs$e.symlink(resolvedSrc, dest, cb);
          return cb(err2);
        }
        if (opts2.dereference) {
          resolvedDest = path$f.resolve(process.cwd(), resolvedDest);
        }
        if (stat$2.isSrcSubdir(resolvedSrc, resolvedDest)) {
          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
        }
        if (destStat.isDirectory() && stat$2.isSrcSubdir(resolvedDest, resolvedSrc)) {
          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
        }
        return copyLink(resolvedSrc, dest, cb);
      });
    }
  });
}
function copyLink(resolvedSrc, dest, cb) {
  fs$e.unlink(dest, (err) => {
    if (err)
      return cb(err);
    return fs$e.symlink(resolvedSrc, dest, cb);
  });
}
var copy_1 = copy$2;
const u$8 = universalify$1.fromCallback;
var copy$1 = {
  copy: u$8(copy_1)
};
const fs$d = gracefulFs;
const path$e = require$$1__default["default"];
const assert = require$$5__default["default"];
const isWindows = process.platform === "win32";
function defaults$1(options) {
  const methods = [
    "unlink",
    "chmod",
    "stat",
    "lstat",
    "rmdir",
    "readdir"
  ];
  methods.forEach((m) => {
    options[m] = options[m] || fs$d[m];
    m = m + "Sync";
    options[m] = options[m] || fs$d[m];
  });
  options.maxBusyTries = options.maxBusyTries || 3;
}
function rimraf$1(p, options, cb) {
  let busyTries = 0;
  if (typeof options === "function") {
    cb = options;
    options = {};
  }
  assert(p, "rimraf: missing path");
  assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
  assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
  assert(options, "rimraf: invalid options argument provided");
  assert.strictEqual(typeof options, "object", "rimraf: options should be object");
  defaults$1(options);
  rimraf_(p, options, function CB(er) {
    if (er) {
      if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
        busyTries++;
        const time = busyTries * 100;
        return setTimeout(() => rimraf_(p, options, CB), time);
      }
      if (er.code === "ENOENT")
        er = null;
    }
    cb(er);
  });
}
function rimraf_(p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.lstat(p, (er, st) => {
    if (er && er.code === "ENOENT") {
      return cb(null);
    }
    if (er && er.code === "EPERM" && isWindows) {
      return fixWinEPERM(p, options, er, cb);
    }
    if (st && st.isDirectory()) {
      return rmdir(p, options, er, cb);
    }
    options.unlink(p, (er2) => {
      if (er2) {
        if (er2.code === "ENOENT") {
          return cb(null);
        }
        if (er2.code === "EPERM") {
          return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
        }
        if (er2.code === "EISDIR") {
          return rmdir(p, options, er2, cb);
        }
      }
      return cb(er2);
    });
  });
}
function fixWinEPERM(p, options, er, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.chmod(p, 438, (er2) => {
    if (er2) {
      cb(er2.code === "ENOENT" ? null : er);
    } else {
      options.stat(p, (er3, stats) => {
        if (er3) {
          cb(er3.code === "ENOENT" ? null : er);
        } else if (stats.isDirectory()) {
          rmdir(p, options, er, cb);
        } else {
          options.unlink(p, cb);
        }
      });
    }
  });
}
function fixWinEPERMSync(p, options, er) {
  let stats;
  assert(p);
  assert(options);
  try {
    options.chmodSync(p, 438);
  } catch (er2) {
    if (er2.code === "ENOENT") {
      return;
    } else {
      throw er;
    }
  }
  try {
    stats = options.statSync(p);
  } catch (er3) {
    if (er3.code === "ENOENT") {
      return;
    } else {
      throw er;
    }
  }
  if (stats.isDirectory()) {
    rmdirSync(p, options, er);
  } else {
    options.unlinkSync(p);
  }
}
function rmdir(p, options, originalEr, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.rmdir(p, (er) => {
    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
      rmkids(p, options, cb);
    } else if (er && er.code === "ENOTDIR") {
      cb(originalEr);
    } else {
      cb(er);
    }
  });
}
function rmkids(p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.readdir(p, (er, files) => {
    if (er)
      return cb(er);
    let n = files.length;
    let errState;
    if (n === 0)
      return options.rmdir(p, cb);
    files.forEach((f) => {
      rimraf$1(path$e.join(p, f), options, (er2) => {
        if (errState) {
          return;
        }
        if (er2)
          return cb(errState = er2);
        if (--n === 0) {
          options.rmdir(p, cb);
        }
      });
    });
  });
}
function rimrafSync(p, options) {
  let st;
  options = options || {};
  defaults$1(options);
  assert(p, "rimraf: missing path");
  assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
  assert(options, "rimraf: missing options");
  assert.strictEqual(typeof options, "object", "rimraf: options should be object");
  try {
    st = options.lstatSync(p);
  } catch (er) {
    if (er.code === "ENOENT") {
      return;
    }
    if (er.code === "EPERM" && isWindows) {
      fixWinEPERMSync(p, options, er);
    }
  }
  try {
    if (st && st.isDirectory()) {
      rmdirSync(p, options, null);
    } else {
      options.unlinkSync(p);
    }
  } catch (er) {
    if (er.code === "ENOENT") {
      return;
    } else if (er.code === "EPERM") {
      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
    } else if (er.code !== "EISDIR") {
      throw er;
    }
    rmdirSync(p, options, er);
  }
}
function rmdirSync(p, options, originalEr) {
  assert(p);
  assert(options);
  try {
    options.rmdirSync(p);
  } catch (er) {
    if (er.code === "ENOTDIR") {
      throw originalEr;
    } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
      rmkidsSync(p, options);
    } else if (er.code !== "ENOENT") {
      throw er;
    }
  }
}
function rmkidsSync(p, options) {
  assert(p);
  assert(options);
  options.readdirSync(p).forEach((f) => rimrafSync(path$e.join(p, f), options));
  if (isWindows) {
    const startTime = Date.now();
    do {
      try {
        const ret = options.rmdirSync(p, options);
        return ret;
      } catch {
      }
    } while (Date.now() - startTime < 500);
  } else {
    const ret = options.rmdirSync(p, options);
    return ret;
  }
}
var rimraf_1 = rimraf$1;
rimraf$1.sync = rimrafSync;
const fs$c = gracefulFs;
const u$7 = universalify$1.fromCallback;
const rimraf = rimraf_1;
function remove$2(path2, callback) {
  if (fs$c.rm)
    return fs$c.rm(path2, { recursive: true, force: true }, callback);
  rimraf(path2, callback);
}
function removeSync$1(path2) {
  if (fs$c.rmSync)
    return fs$c.rmSync(path2, { recursive: true, force: true });
  rimraf.sync(path2);
}
var remove_1 = {
  remove: u$7(remove$2),
  removeSync: removeSync$1
};
const u$6 = universalify$1.fromPromise;
const fs$b = fs$l;
const path$d = require$$1__default["default"];
const mkdir$3 = mkdirs$2;
const remove$1 = remove_1;
const emptyDir = u$6(async function emptyDir2(dir) {
  let items2;
  try {
    items2 = await fs$b.readdir(dir);
  } catch {
    return mkdir$3.mkdirs(dir);
  }
  return Promise.all(items2.map((item) => remove$1.remove(path$d.join(dir, item))));
});
function emptyDirSync(dir) {
  let items2;
  try {
    items2 = fs$b.readdirSync(dir);
  } catch {
    return mkdir$3.mkdirsSync(dir);
  }
  items2.forEach((item) => {
    item = path$d.join(dir, item);
    remove$1.removeSync(item);
  });
}
var empty = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
};
const u$5 = universalify$1.fromCallback;
const path$c = require$$1__default["default"];
const fs$a = gracefulFs;
const mkdir$2 = mkdirs$2;
function createFile(file2, callback) {
  function makeFile() {
    fs$a.writeFile(file2, "", (err) => {
      if (err)
        return callback(err);
      callback();
    });
  }
  fs$a.stat(file2, (err, stats) => {
    if (!err && stats.isFile())
      return callback();
    const dir = path$c.dirname(file2);
    fs$a.stat(dir, (err2, stats2) => {
      if (err2) {
        if (err2.code === "ENOENT") {
          return mkdir$2.mkdirs(dir, (err3) => {
            if (err3)
              return callback(err3);
            makeFile();
          });
        }
        return callback(err2);
      }
      if (stats2.isDirectory())
        makeFile();
      else {
        fs$a.readdir(dir, (err3) => {
          if (err3)
            return callback(err3);
        });
      }
    });
  });
}
function createFileSync(file2) {
  let stats;
  try {
    stats = fs$a.statSync(file2);
  } catch {
  }
  if (stats && stats.isFile())
    return;
  const dir = path$c.dirname(file2);
  try {
    if (!fs$a.statSync(dir).isDirectory()) {
      fs$a.readdirSync(dir);
    }
  } catch (err) {
    if (err && err.code === "ENOENT")
      mkdir$2.mkdirsSync(dir);
    else
      throw err;
  }
  fs$a.writeFileSync(file2, "");
}
var file$1 = {
  createFile: u$5(createFile),
  createFileSync
};
const u$4 = universalify$1.fromCallback;
const path$b = require$$1__default["default"];
const fs$9 = gracefulFs;
const mkdir$1 = mkdirs$2;
const pathExists$6 = pathExists_1.pathExists;
const { areIdentical: areIdentical$1 } = stat$4;
function createLink(srcpath, dstpath, callback) {
  function makeLink(srcpath2, dstpath2) {
    fs$9.link(srcpath2, dstpath2, (err) => {
      if (err)
        return callback(err);
      callback(null);
    });
  }
  fs$9.lstat(dstpath, (_, dstStat) => {
    fs$9.lstat(srcpath, (err, srcStat) => {
      if (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        return callback(err);
      }
      if (dstStat && areIdentical$1(srcStat, dstStat))
        return callback(null);
      const dir = path$b.dirname(dstpath);
      pathExists$6(dir, (err2, dirExists) => {
        if (err2)
          return callback(err2);
        if (dirExists)
          return makeLink(srcpath, dstpath);
        mkdir$1.mkdirs(dir, (err3) => {
          if (err3)
            return callback(err3);
          makeLink(srcpath, dstpath);
        });
      });
    });
  });
}
function createLinkSync(srcpath, dstpath) {
  let dstStat;
  try {
    dstStat = fs$9.lstatSync(dstpath);
  } catch {
  }
  try {
    const srcStat = fs$9.lstatSync(srcpath);
    if (dstStat && areIdentical$1(srcStat, dstStat))
      return;
  } catch (err) {
    err.message = err.message.replace("lstat", "ensureLink");
    throw err;
  }
  const dir = path$b.dirname(dstpath);
  const dirExists = fs$9.existsSync(dir);
  if (dirExists)
    return fs$9.linkSync(srcpath, dstpath);
  mkdir$1.mkdirsSync(dir);
  return fs$9.linkSync(srcpath, dstpath);
}
var link$1 = {
  createLink: u$4(createLink),
  createLinkSync
};
const path$a = require$$1__default["default"];
const fs$8 = gracefulFs;
const pathExists$5 = pathExists_1.pathExists;
function symlinkPaths$1(srcpath, dstpath, callback) {
  if (path$a.isAbsolute(srcpath)) {
    return fs$8.lstat(srcpath, (err) => {
      if (err) {
        err.message = err.message.replace("lstat", "ensureSymlink");
        return callback(err);
      }
      return callback(null, {
        toCwd: srcpath,
        toDst: srcpath
      });
    });
  } else {
    const dstdir = path$a.dirname(dstpath);
    const relativeToDst = path$a.join(dstdir, srcpath);
    return pathExists$5(relativeToDst, (err, exists) => {
      if (err)
        return callback(err);
      if (exists) {
        return callback(null, {
          toCwd: relativeToDst,
          toDst: srcpath
        });
      } else {
        return fs$8.lstat(srcpath, (err2) => {
          if (err2) {
            err2.message = err2.message.replace("lstat", "ensureSymlink");
            return callback(err2);
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: path$a.relative(dstdir, srcpath)
          });
        });
      }
    });
  }
}
function symlinkPathsSync$1(srcpath, dstpath) {
  let exists;
  if (path$a.isAbsolute(srcpath)) {
    exists = fs$8.existsSync(srcpath);
    if (!exists)
      throw new Error("absolute srcpath does not exist");
    return {
      toCwd: srcpath,
      toDst: srcpath
    };
  } else {
    const dstdir = path$a.dirname(dstpath);
    const relativeToDst = path$a.join(dstdir, srcpath);
    exists = fs$8.existsSync(relativeToDst);
    if (exists) {
      return {
        toCwd: relativeToDst,
        toDst: srcpath
      };
    } else {
      exists = fs$8.existsSync(srcpath);
      if (!exists)
        throw new Error("relative srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: path$a.relative(dstdir, srcpath)
      };
    }
  }
}
var symlinkPaths_1 = {
  symlinkPaths: symlinkPaths$1,
  symlinkPathsSync: symlinkPathsSync$1
};
const fs$7 = gracefulFs;
function symlinkType$1(srcpath, type2, callback) {
  callback = typeof type2 === "function" ? type2 : callback;
  type2 = typeof type2 === "function" ? false : type2;
  if (type2)
    return callback(null, type2);
  fs$7.lstat(srcpath, (err, stats) => {
    if (err)
      return callback(null, "file");
    type2 = stats && stats.isDirectory() ? "dir" : "file";
    callback(null, type2);
  });
}
function symlinkTypeSync$1(srcpath, type2) {
  let stats;
  if (type2)
    return type2;
  try {
    stats = fs$7.lstatSync(srcpath);
  } catch {
    return "file";
  }
  return stats && stats.isDirectory() ? "dir" : "file";
}
var symlinkType_1 = {
  symlinkType: symlinkType$1,
  symlinkTypeSync: symlinkTypeSync$1
};
const u$3 = universalify$1.fromCallback;
const path$9 = require$$1__default["default"];
const fs$6 = fs$l;
const _mkdirs = mkdirs$2;
const mkdirs = _mkdirs.mkdirs;
const mkdirsSync = _mkdirs.mkdirsSync;
const _symlinkPaths = symlinkPaths_1;
const symlinkPaths = _symlinkPaths.symlinkPaths;
const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
const _symlinkType = symlinkType_1;
const symlinkType = _symlinkType.symlinkType;
const symlinkTypeSync = _symlinkType.symlinkTypeSync;
const pathExists$4 = pathExists_1.pathExists;
const { areIdentical } = stat$4;
function createSymlink(srcpath, dstpath, type2, callback) {
  callback = typeof type2 === "function" ? type2 : callback;
  type2 = typeof type2 === "function" ? false : type2;
  fs$6.lstat(dstpath, (err, stats) => {
    if (!err && stats.isSymbolicLink()) {
      Promise.all([
        fs$6.stat(srcpath),
        fs$6.stat(dstpath)
      ]).then(([srcStat, dstStat]) => {
        if (areIdentical(srcStat, dstStat))
          return callback(null);
        _createSymlink(srcpath, dstpath, type2, callback);
      });
    } else
      _createSymlink(srcpath, dstpath, type2, callback);
  });
}
function _createSymlink(srcpath, dstpath, type2, callback) {
  symlinkPaths(srcpath, dstpath, (err, relative) => {
    if (err)
      return callback(err);
    srcpath = relative.toDst;
    symlinkType(relative.toCwd, type2, (err2, type3) => {
      if (err2)
        return callback(err2);
      const dir = path$9.dirname(dstpath);
      pathExists$4(dir, (err3, dirExists) => {
        if (err3)
          return callback(err3);
        if (dirExists)
          return fs$6.symlink(srcpath, dstpath, type3, callback);
        mkdirs(dir, (err4) => {
          if (err4)
            return callback(err4);
          fs$6.symlink(srcpath, dstpath, type3, callback);
        });
      });
    });
  });
}
function createSymlinkSync(srcpath, dstpath, type2) {
  let stats;
  try {
    stats = fs$6.lstatSync(dstpath);
  } catch {
  }
  if (stats && stats.isSymbolicLink()) {
    const srcStat = fs$6.statSync(srcpath);
    const dstStat = fs$6.statSync(dstpath);
    if (areIdentical(srcStat, dstStat))
      return;
  }
  const relative = symlinkPathsSync(srcpath, dstpath);
  srcpath = relative.toDst;
  type2 = symlinkTypeSync(relative.toCwd, type2);
  const dir = path$9.dirname(dstpath);
  const exists = fs$6.existsSync(dir);
  if (exists)
    return fs$6.symlinkSync(srcpath, dstpath, type2);
  mkdirsSync(dir);
  return fs$6.symlinkSync(srcpath, dstpath, type2);
}
var symlink$1 = {
  createSymlink: u$3(createSymlink),
  createSymlinkSync
};
const file = file$1;
const link = link$1;
const symlink = symlink$1;
var ensure = {
  createFile: file.createFile,
  createFileSync: file.createFileSync,
  ensureFile: file.createFile,
  ensureFileSync: file.createFileSync,
  createLink: link.createLink,
  createLinkSync: link.createLinkSync,
  ensureLink: link.createLink,
  ensureLinkSync: link.createLinkSync,
  createSymlink: symlink.createSymlink,
  createSymlinkSync: symlink.createSymlinkSync,
  ensureSymlink: symlink.createSymlink,
  ensureSymlinkSync: symlink.createSymlinkSync
};
function stringify$3(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
  const EOF = finalEOL ? EOL : "";
  const str = JSON.stringify(obj, replacer, spaces);
  return str.replace(/\n/g, EOL) + EOF;
}
function stripBom$1(content) {
  if (Buffer.isBuffer(content))
    content = content.toString("utf8");
  return content.replace(/^\uFEFF/, "");
}
var utils = { stringify: stringify$3, stripBom: stripBom$1 };
let _fs;
try {
  _fs = gracefulFs;
} catch (_) {
  _fs = require$$0__default$3["default"];
}
const universalify = universalify$1;
const { stringify: stringify$2, stripBom } = utils;
async function _readFile(file2, options = {}) {
  if (typeof options === "string") {
    options = { encoding: options };
  }
  const fs2 = options.fs || _fs;
  const shouldThrow = "throws" in options ? options.throws : true;
  let data = await universalify.fromCallback(fs2.readFile)(file2, options);
  data = stripBom(data);
  let obj;
  try {
    obj = JSON.parse(data, options ? options.reviver : null);
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file2}: ${err.message}`;
      throw err;
    } else {
      return null;
    }
  }
  return obj;
}
const readFile$1 = universalify.fromPromise(_readFile);
function readFileSync$1(file2, options = {}) {
  if (typeof options === "string") {
    options = { encoding: options };
  }
  const fs2 = options.fs || _fs;
  const shouldThrow = "throws" in options ? options.throws : true;
  try {
    let content = fs2.readFileSync(file2, options);
    content = stripBom(content);
    return JSON.parse(content, options.reviver);
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file2}: ${err.message}`;
      throw err;
    } else {
      return null;
    }
  }
}
async function _writeFile(file2, obj, options = {}) {
  const fs2 = options.fs || _fs;
  const str = stringify$2(obj, options);
  await universalify.fromCallback(fs2.writeFile)(file2, str, options);
}
const writeFile$1 = universalify.fromPromise(_writeFile);
function writeFileSync$1(file2, obj, options = {}) {
  const fs2 = options.fs || _fs;
  const str = stringify$2(obj, options);
  return fs2.writeFileSync(file2, str, options);
}
const jsonfile$1 = {
  readFile: readFile$1,
  readFileSync: readFileSync$1,
  writeFile: writeFile$1,
  writeFileSync: writeFileSync$1
};
var jsonfile_1 = jsonfile$1;
const jsonFile$1 = jsonfile_1;
var jsonfile = {
  readJson: jsonFile$1.readFile,
  readJsonSync: jsonFile$1.readFileSync,
  writeJson: jsonFile$1.writeFile,
  writeJsonSync: jsonFile$1.writeFileSync
};
const u$2 = universalify$1.fromCallback;
const fs$5 = gracefulFs;
const path$8 = require$$1__default["default"];
const mkdir = mkdirs$2;
const pathExists$3 = pathExists_1.pathExists;
function outputFile$1(file2, data, encoding, callback) {
  if (typeof encoding === "function") {
    callback = encoding;
    encoding = "utf8";
  }
  const dir = path$8.dirname(file2);
  pathExists$3(dir, (err, itDoes) => {
    if (err)
      return callback(err);
    if (itDoes)
      return fs$5.writeFile(file2, data, encoding, callback);
    mkdir.mkdirs(dir, (err2) => {
      if (err2)
        return callback(err2);
      fs$5.writeFile(file2, data, encoding, callback);
    });
  });
}
function outputFileSync$1(file2, ...args) {
  const dir = path$8.dirname(file2);
  if (fs$5.existsSync(dir)) {
    return fs$5.writeFileSync(file2, ...args);
  }
  mkdir.mkdirsSync(dir);
  fs$5.writeFileSync(file2, ...args);
}
var output = {
  outputFile: u$2(outputFile$1),
  outputFileSync: outputFileSync$1
};
const { stringify: stringify$1 } = utils;
const { outputFile } = output;
async function outputJson(file2, data, options = {}) {
  const str = stringify$1(data, options);
  await outputFile(file2, str, options);
}
var outputJson_1 = outputJson;
const { stringify } = utils;
const { outputFileSync } = output;
function outputJsonSync(file2, data, options) {
  const str = stringify(data, options);
  outputFileSync(file2, str, options);
}
var outputJsonSync_1 = outputJsonSync;
const u$1 = universalify$1.fromPromise;
const jsonFile = jsonfile;
jsonFile.outputJson = u$1(outputJson_1);
jsonFile.outputJsonSync = outputJsonSync_1;
jsonFile.outputJSON = jsonFile.outputJson;
jsonFile.outputJSONSync = jsonFile.outputJsonSync;
jsonFile.writeJSON = jsonFile.writeJson;
jsonFile.writeJSONSync = jsonFile.writeJsonSync;
jsonFile.readJSON = jsonFile.readJson;
jsonFile.readJSONSync = jsonFile.readJsonSync;
var json = jsonFile;
const fs$4 = gracefulFs;
const path$7 = require$$1__default["default"];
const copySync = copySync$1.copySync;
const removeSync = remove_1.removeSync;
const mkdirpSync = mkdirs$2.mkdirpSync;
const stat$1 = stat$4;
function moveSync$1(src, dest, opts2) {
  opts2 = opts2 || {};
  const overwrite = opts2.overwrite || opts2.clobber || false;
  const { srcStat, isChangingCase = false } = stat$1.checkPathsSync(src, dest, "move", opts2);
  stat$1.checkParentPathsSync(src, srcStat, dest, "move");
  if (!isParentRoot$1(dest))
    mkdirpSync(path$7.dirname(dest));
  return doRename$1(src, dest, overwrite, isChangingCase);
}
function isParentRoot$1(dest) {
  const parent = path$7.dirname(dest);
  const parsedPath = path$7.parse(parent);
  return parsedPath.root === parent;
}
function doRename$1(src, dest, overwrite, isChangingCase) {
  if (isChangingCase)
    return rename$1(src, dest, overwrite);
  if (overwrite) {
    removeSync(dest);
    return rename$1(src, dest, overwrite);
  }
  if (fs$4.existsSync(dest))
    throw new Error("dest already exists.");
  return rename$1(src, dest, overwrite);
}
function rename$1(src, dest, overwrite) {
  try {
    fs$4.renameSync(src, dest);
  } catch (err) {
    if (err.code !== "EXDEV")
      throw err;
    return moveAcrossDevice$1(src, dest, overwrite);
  }
}
function moveAcrossDevice$1(src, dest, overwrite) {
  const opts2 = {
    overwrite,
    errorOnExist: true
  };
  copySync(src, dest, opts2);
  return removeSync(src);
}
var moveSync_1 = moveSync$1;
var moveSync = {
  moveSync: moveSync_1
};
const fs$3 = gracefulFs;
const path$6 = require$$1__default["default"];
const copy = copy$1.copy;
const remove = remove_1.remove;
const mkdirp = mkdirs$2.mkdirp;
const pathExists$2 = pathExists_1.pathExists;
const stat = stat$4;
function move$1(src, dest, opts2, cb) {
  if (typeof opts2 === "function") {
    cb = opts2;
    opts2 = {};
  }
  const overwrite = opts2.overwrite || opts2.clobber || false;
  stat.checkPaths(src, dest, "move", opts2, (err, stats) => {
    if (err)
      return cb(err);
    const { srcStat, isChangingCase = false } = stats;
    stat.checkParentPaths(src, srcStat, dest, "move", (err2) => {
      if (err2)
        return cb(err2);
      if (isParentRoot(dest))
        return doRename(src, dest, overwrite, isChangingCase, cb);
      mkdirp(path$6.dirname(dest), (err3) => {
        if (err3)
          return cb(err3);
        return doRename(src, dest, overwrite, isChangingCase, cb);
      });
    });
  });
}
function isParentRoot(dest) {
  const parent = path$6.dirname(dest);
  const parsedPath = path$6.parse(parent);
  return parsedPath.root === parent;
}
function doRename(src, dest, overwrite, isChangingCase, cb) {
  if (isChangingCase)
    return rename(src, dest, overwrite, cb);
  if (overwrite) {
    return remove(dest, (err) => {
      if (err)
        return cb(err);
      return rename(src, dest, overwrite, cb);
    });
  }
  pathExists$2(dest, (err, destExists) => {
    if (err)
      return cb(err);
    if (destExists)
      return cb(new Error("dest already exists."));
    return rename(src, dest, overwrite, cb);
  });
}
function rename(src, dest, overwrite, cb) {
  fs$3.rename(src, dest, (err) => {
    if (!err)
      return cb();
    if (err.code !== "EXDEV")
      return cb(err);
    return moveAcrossDevice(src, dest, overwrite, cb);
  });
}
function moveAcrossDevice(src, dest, overwrite, cb) {
  const opts2 = {
    overwrite,
    errorOnExist: true
  };
  copy(src, dest, opts2, (err) => {
    if (err)
      return cb(err);
    return remove(src, cb);
  });
}
var move_1 = move$1;
const u = universalify$1.fromCallback;
var move = {
  move: u(move_1)
};
var lib = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, fs$l), copySync$1), copy$1), empty), ensure), json), mkdirs$2), moveSync), move), output), pathExists_1), remove_1);
var source = { exports: {} };
var isObj$1 = (value) => {
  const type2 = typeof value;
  return value !== null && (type2 === "object" || type2 === "function");
};
const isObj = isObj$1;
const disallowedKeys = new Set([
  "__proto__",
  "prototype",
  "constructor"
]);
const isValidPath = (pathSegments) => !pathSegments.some((segment) => disallowedKeys.has(segment));
function getPathSegments(path2) {
  const pathArray = path2.split(".");
  const parts = [];
  for (let i = 0; i < pathArray.length; i++) {
    let p = pathArray[i];
    while (p[p.length - 1] === "\\" && pathArray[i + 1] !== void 0) {
      p = p.slice(0, -1) + ".";
      p += pathArray[++i];
    }
    parts.push(p);
  }
  if (!isValidPath(parts)) {
    return [];
  }
  return parts;
}
var dotProp = {
  get(object, path2, value) {
    if (!isObj(object) || typeof path2 !== "string") {
      return value === void 0 ? object : value;
    }
    const pathArray = getPathSegments(path2);
    if (pathArray.length === 0) {
      return;
    }
    for (let i = 0; i < pathArray.length; i++) {
      object = object[pathArray[i]];
      if (object === void 0 || object === null) {
        if (i !== pathArray.length - 1) {
          return value;
        }
        break;
      }
    }
    return object === void 0 ? value : object;
  },
  set(object, path2, value) {
    if (!isObj(object) || typeof path2 !== "string") {
      return object;
    }
    const root = object;
    const pathArray = getPathSegments(path2);
    for (let i = 0; i < pathArray.length; i++) {
      const p = pathArray[i];
      if (!isObj(object[p])) {
        object[p] = {};
      }
      if (i === pathArray.length - 1) {
        object[p] = value;
      }
      object = object[p];
    }
    return root;
  },
  delete(object, path2) {
    if (!isObj(object) || typeof path2 !== "string") {
      return false;
    }
    const pathArray = getPathSegments(path2);
    for (let i = 0; i < pathArray.length; i++) {
      const p = pathArray[i];
      if (i === pathArray.length - 1) {
        delete object[p];
        return true;
      }
      object = object[p];
      if (!isObj(object)) {
        return false;
      }
    }
  },
  has(object, path2) {
    if (!isObj(object) || typeof path2 !== "string") {
      return false;
    }
    const pathArray = getPathSegments(path2);
    if (pathArray.length === 0) {
      return false;
    }
    for (let i = 0; i < pathArray.length; i++) {
      if (isObj(object)) {
        if (!(pathArray[i] in object)) {
          return false;
        }
        object = object[pathArray[i]];
      } else {
        return false;
      }
    }
    return true;
  }
};
var pkgUp = { exports: {} };
var findUp$1 = { exports: {} };
var locatePath$1 = { exports: {} };
var pathExists$1 = { exports: {} };
const fs$2 = require$$0__default$3["default"];
pathExists$1.exports = (fp) => new Promise((resolve2) => {
  fs$2.access(fp, (err) => {
    resolve2(!err);
  });
});
pathExists$1.exports.sync = (fp) => {
  try {
    fs$2.accessSync(fp);
    return true;
  } catch (err) {
    return false;
  }
};
var pLimit$2 = { exports: {} };
var pTry$2 = { exports: {} };
const pTry$1 = (fn, ...arguments_) => new Promise((resolve2) => {
  resolve2(fn(...arguments_));
});
pTry$2.exports = pTry$1;
pTry$2.exports.default = pTry$1;
const pTry = pTry$2.exports;
const pLimit$1 = (concurrency) => {
  if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
    return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
  }
  const queue2 = [];
  let activeCount = 0;
  const next = () => {
    activeCount--;
    if (queue2.length > 0) {
      queue2.shift()();
    }
  };
  const run = (fn, resolve2, ...args) => {
    activeCount++;
    const result = pTry(fn, ...args);
    resolve2(result);
    result.then(next, next);
  };
  const enqueue2 = (fn, resolve2, ...args) => {
    if (activeCount < concurrency) {
      run(fn, resolve2, ...args);
    } else {
      queue2.push(run.bind(null, fn, resolve2, ...args));
    }
  };
  const generator = (fn, ...args) => new Promise((resolve2) => enqueue2(fn, resolve2, ...args));
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue2.length
    },
    clearQueue: {
      value: () => {
        queue2.length = 0;
      }
    }
  });
  return generator;
};
pLimit$2.exports = pLimit$1;
pLimit$2.exports.default = pLimit$1;
const pLimit = pLimit$2.exports;
class EndError extends Error {
  constructor(value) {
    super();
    this.value = value;
  }
}
const testElement = (el, tester) => Promise.resolve(el).then(tester);
const finder = (el) => Promise.all(el).then((val) => val[1] === true && Promise.reject(new EndError(val[0])));
var pLocate$1 = (iterable, tester, opts2) => {
  opts2 = Object.assign({
    concurrency: Infinity,
    preserveOrder: true
  }, opts2);
  const limit2 = pLimit(opts2.concurrency);
  const items2 = [...iterable].map((el) => [el, limit2(testElement, el, tester)]);
  const checkLimit = pLimit(opts2.preserveOrder ? 1 : Infinity);
  return Promise.all(items2.map((el) => checkLimit(finder, el))).then(() => {
  }).catch((err) => err instanceof EndError ? err.value : Promise.reject(err));
};
const path$5 = require$$1__default["default"];
const pathExists = pathExists$1.exports;
const pLocate = pLocate$1;
locatePath$1.exports = (iterable, options) => {
  options = Object.assign({
    cwd: process.cwd()
  }, options);
  return pLocate(iterable, (el) => pathExists(path$5.resolve(options.cwd, el)), options);
};
locatePath$1.exports.sync = (iterable, options) => {
  options = Object.assign({
    cwd: process.cwd()
  }, options);
  for (const el of iterable) {
    if (pathExists.sync(path$5.resolve(options.cwd, el))) {
      return el;
    }
  }
};
const path$4 = require$$1__default["default"];
const locatePath = locatePath$1.exports;
findUp$1.exports = (filename, opts2 = {}) => {
  const startDir = path$4.resolve(opts2.cwd || "");
  const { root } = path$4.parse(startDir);
  const filenames = [].concat(filename);
  return new Promise((resolve2) => {
    (function find(dir) {
      locatePath(filenames, { cwd: dir }).then((file2) => {
        if (file2) {
          resolve2(path$4.join(dir, file2));
        } else if (dir === root) {
          resolve2(null);
        } else {
          find(path$4.dirname(dir));
        }
      });
    })(startDir);
  });
};
findUp$1.exports.sync = (filename, opts2 = {}) => {
  let dir = path$4.resolve(opts2.cwd || "");
  const { root } = path$4.parse(dir);
  const filenames = [].concat(filename);
  while (true) {
    const file2 = locatePath.sync(filenames, { cwd: dir });
    if (file2) {
      return path$4.join(dir, file2);
    }
    if (dir === root) {
      return null;
    }
    dir = path$4.dirname(dir);
  }
};
const findUp = findUp$1.exports;
pkgUp.exports = async ({ cwd: cwd2 } = {}) => findUp("package.json", { cwd: cwd2 });
pkgUp.exports.sync = ({ cwd: cwd2 } = {}) => findUp.sync("package.json", { cwd: cwd2 });
var envPaths$1 = { exports: {} };
const path$3 = require$$1__default["default"];
const os = require$$1__default$1["default"];
const homedir = os.homedir();
const tmpdir = os.tmpdir();
const { env: env$1 } = process;
const macos = (name) => {
  const library = path$3.join(homedir, "Library");
  return {
    data: path$3.join(library, "Application Support", name),
    config: path$3.join(library, "Preferences", name),
    cache: path$3.join(library, "Caches", name),
    log: path$3.join(library, "Logs", name),
    temp: path$3.join(tmpdir, name)
  };
};
const windows = (name) => {
  const appData = env$1.APPDATA || path$3.join(homedir, "AppData", "Roaming");
  const localAppData = env$1.LOCALAPPDATA || path$3.join(homedir, "AppData", "Local");
  return {
    data: path$3.join(localAppData, name, "Data"),
    config: path$3.join(appData, name, "Config"),
    cache: path$3.join(localAppData, name, "Cache"),
    log: path$3.join(localAppData, name, "Log"),
    temp: path$3.join(tmpdir, name)
  };
};
const linux = (name) => {
  const username = path$3.basename(homedir);
  return {
    data: path$3.join(env$1.XDG_DATA_HOME || path$3.join(homedir, ".local", "share"), name),
    config: path$3.join(env$1.XDG_CONFIG_HOME || path$3.join(homedir, ".config"), name),
    cache: path$3.join(env$1.XDG_CACHE_HOME || path$3.join(homedir, ".cache"), name),
    log: path$3.join(env$1.XDG_STATE_HOME || path$3.join(homedir, ".local", "state"), name),
    temp: path$3.join(tmpdir, username, name)
  };
};
const envPaths = (name, options) => {
  if (typeof name !== "string") {
    throw new TypeError(`Expected string, got ${typeof name}`);
  }
  options = Object.assign({ suffix: "nodejs" }, options);
  if (options.suffix) {
    name += `-${options.suffix}`;
  }
  if (process.platform === "darwin") {
    return macos(name);
  }
  if (process.platform === "win32") {
    return windows(name);
  }
  return linux(name);
};
envPaths$1.exports = envPaths;
envPaths$1.exports.default = envPaths;
var dist$1 = {};
var consts = {};
Object.defineProperty(consts, "__esModule", { value: true });
consts.NOOP = consts.LIMIT_FILES_DESCRIPTORS = consts.LIMIT_BASENAME_LENGTH = consts.IS_USER_ROOT = consts.IS_POSIX = consts.DEFAULT_TIMEOUT_SYNC = consts.DEFAULT_TIMEOUT_ASYNC = consts.DEFAULT_WRITE_OPTIONS = consts.DEFAULT_READ_OPTIONS = consts.DEFAULT_FOLDER_MODE = consts.DEFAULT_FILE_MODE = consts.DEFAULT_ENCODING = void 0;
const DEFAULT_ENCODING = "utf8";
consts.DEFAULT_ENCODING = DEFAULT_ENCODING;
const DEFAULT_FILE_MODE = 438;
consts.DEFAULT_FILE_MODE = DEFAULT_FILE_MODE;
const DEFAULT_FOLDER_MODE = 511;
consts.DEFAULT_FOLDER_MODE = DEFAULT_FOLDER_MODE;
const DEFAULT_READ_OPTIONS = {};
consts.DEFAULT_READ_OPTIONS = DEFAULT_READ_OPTIONS;
const DEFAULT_WRITE_OPTIONS = {};
consts.DEFAULT_WRITE_OPTIONS = DEFAULT_WRITE_OPTIONS;
const DEFAULT_TIMEOUT_ASYNC = 5e3;
consts.DEFAULT_TIMEOUT_ASYNC = DEFAULT_TIMEOUT_ASYNC;
const DEFAULT_TIMEOUT_SYNC = 100;
consts.DEFAULT_TIMEOUT_SYNC = DEFAULT_TIMEOUT_SYNC;
const IS_POSIX = !!process.getuid;
consts.IS_POSIX = IS_POSIX;
const IS_USER_ROOT = process.getuid ? !process.getuid() : false;
consts.IS_USER_ROOT = IS_USER_ROOT;
const LIMIT_BASENAME_LENGTH = 128;
consts.LIMIT_BASENAME_LENGTH = LIMIT_BASENAME_LENGTH;
const LIMIT_FILES_DESCRIPTORS = 1e4;
consts.LIMIT_FILES_DESCRIPTORS = LIMIT_FILES_DESCRIPTORS;
const NOOP = () => {
};
consts.NOOP = NOOP;
var fs$1 = {};
var attemptify = {};
Object.defineProperty(attemptify, "__esModule", { value: true });
attemptify.attemptifySync = attemptify.attemptifyAsync = void 0;
const consts_1$4 = consts;
const attemptifyAsync = (fn, onError = consts_1$4.NOOP) => {
  return function() {
    return fn.apply(void 0, arguments).catch(onError);
  };
};
attemptify.attemptifyAsync = attemptifyAsync;
const attemptifySync = (fn, onError = consts_1$4.NOOP) => {
  return function() {
    try {
      return fn.apply(void 0, arguments);
    } catch (error2) {
      return onError(error2);
    }
  };
};
attemptify.attemptifySync = attemptifySync;
var fs_handlers = {};
Object.defineProperty(fs_handlers, "__esModule", { value: true });
const consts_1$3 = consts;
const Handlers = {
  isChangeErrorOk: (error2) => {
    const { code: code2 } = error2;
    if (code2 === "ENOSYS")
      return true;
    if (!consts_1$3.IS_USER_ROOT && (code2 === "EINVAL" || code2 === "EPERM"))
      return true;
    return false;
  },
  isRetriableError: (error2) => {
    const { code: code2 } = error2;
    if (code2 === "EMFILE" || code2 === "ENFILE" || code2 === "EAGAIN" || code2 === "EBUSY" || code2 === "EACCESS" || code2 === "EACCS" || code2 === "EPERM")
      return true;
    return false;
  },
  onChangeError: (error2) => {
    if (Handlers.isChangeErrorOk(error2))
      return;
    throw error2;
  }
};
fs_handlers.default = Handlers;
var retryify = {};
var retryify_queue = {};
Object.defineProperty(retryify_queue, "__esModule", { value: true });
const consts_1$2 = consts;
const RetryfyQueue = {
  interval: 25,
  intervalId: void 0,
  limit: consts_1$2.LIMIT_FILES_DESCRIPTORS,
  queueActive: new Set(),
  queueWaiting: new Set(),
  init: () => {
    if (RetryfyQueue.intervalId)
      return;
    RetryfyQueue.intervalId = setInterval(RetryfyQueue.tick, RetryfyQueue.interval);
  },
  reset: () => {
    if (!RetryfyQueue.intervalId)
      return;
    clearInterval(RetryfyQueue.intervalId);
    delete RetryfyQueue.intervalId;
  },
  add: (fn) => {
    RetryfyQueue.queueWaiting.add(fn);
    if (RetryfyQueue.queueActive.size < RetryfyQueue.limit / 2) {
      RetryfyQueue.tick();
    } else {
      RetryfyQueue.init();
    }
  },
  remove: (fn) => {
    RetryfyQueue.queueWaiting.delete(fn);
    RetryfyQueue.queueActive.delete(fn);
  },
  schedule: () => {
    return new Promise((resolve2) => {
      const cleanup = () => RetryfyQueue.remove(resolver);
      const resolver = () => resolve2(cleanup);
      RetryfyQueue.add(resolver);
    });
  },
  tick: () => {
    if (RetryfyQueue.queueActive.size >= RetryfyQueue.limit)
      return;
    if (!RetryfyQueue.queueWaiting.size)
      return RetryfyQueue.reset();
    for (const fn of RetryfyQueue.queueWaiting) {
      if (RetryfyQueue.queueActive.size >= RetryfyQueue.limit)
        break;
      RetryfyQueue.queueWaiting.delete(fn);
      RetryfyQueue.queueActive.add(fn);
      fn();
    }
  }
};
retryify_queue.default = RetryfyQueue;
Object.defineProperty(retryify, "__esModule", { value: true });
retryify.retryifySync = retryify.retryifyAsync = void 0;
const retryify_queue_1 = retryify_queue;
const retryifyAsync = (fn, isRetriableError) => {
  return function(timestamp) {
    return function attempt() {
      return retryify_queue_1.default.schedule().then((cleanup) => {
        return fn.apply(void 0, arguments).then((result) => {
          cleanup();
          return result;
        }, (error2) => {
          cleanup();
          if (Date.now() >= timestamp)
            throw error2;
          if (isRetriableError(error2)) {
            const delay = Math.round(100 + 400 * Math.random()), delayPromise = new Promise((resolve2) => setTimeout(resolve2, delay));
            return delayPromise.then(() => attempt.apply(void 0, arguments));
          }
          throw error2;
        });
      });
    };
  };
};
retryify.retryifyAsync = retryifyAsync;
const retryifySync = (fn, isRetriableError) => {
  return function(timestamp) {
    return function attempt() {
      try {
        return fn.apply(void 0, arguments);
      } catch (error2) {
        if (Date.now() > timestamp)
          throw error2;
        if (isRetriableError(error2))
          return attempt.apply(void 0, arguments);
        throw error2;
      }
    };
  };
};
retryify.retryifySync = retryifySync;
Object.defineProperty(fs$1, "__esModule", { value: true });
const fs = require$$0__default$3["default"];
const util_1$p = require$$4__default["default"];
const attemptify_1 = attemptify;
const fs_handlers_1 = fs_handlers;
const retryify_1 = retryify;
const FS = {
  chmodAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.chmod), fs_handlers_1.default.onChangeError),
  chownAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.chown), fs_handlers_1.default.onChangeError),
  closeAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.close)),
  fsyncAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.fsync)),
  mkdirAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.mkdir)),
  realpathAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.realpath)),
  statAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.stat)),
  unlinkAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.unlink)),
  closeRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.close), fs_handlers_1.default.isRetriableError),
  fsyncRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.fsync), fs_handlers_1.default.isRetriableError),
  openRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.open), fs_handlers_1.default.isRetriableError),
  readFileRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.readFile), fs_handlers_1.default.isRetriableError),
  renameRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.rename), fs_handlers_1.default.isRetriableError),
  statRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.stat), fs_handlers_1.default.isRetriableError),
  writeRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.write), fs_handlers_1.default.isRetriableError),
  chmodSyncAttempt: attemptify_1.attemptifySync(fs.chmodSync, fs_handlers_1.default.onChangeError),
  chownSyncAttempt: attemptify_1.attemptifySync(fs.chownSync, fs_handlers_1.default.onChangeError),
  closeSyncAttempt: attemptify_1.attemptifySync(fs.closeSync),
  mkdirSyncAttempt: attemptify_1.attemptifySync(fs.mkdirSync),
  realpathSyncAttempt: attemptify_1.attemptifySync(fs.realpathSync),
  statSyncAttempt: attemptify_1.attemptifySync(fs.statSync),
  unlinkSyncAttempt: attemptify_1.attemptifySync(fs.unlinkSync),
  closeSyncRetry: retryify_1.retryifySync(fs.closeSync, fs_handlers_1.default.isRetriableError),
  fsyncSyncRetry: retryify_1.retryifySync(fs.fsyncSync, fs_handlers_1.default.isRetriableError),
  openSyncRetry: retryify_1.retryifySync(fs.openSync, fs_handlers_1.default.isRetriableError),
  readFileSyncRetry: retryify_1.retryifySync(fs.readFileSync, fs_handlers_1.default.isRetriableError),
  renameSyncRetry: retryify_1.retryifySync(fs.renameSync, fs_handlers_1.default.isRetriableError),
  statSyncRetry: retryify_1.retryifySync(fs.statSync, fs_handlers_1.default.isRetriableError),
  writeSyncRetry: retryify_1.retryifySync(fs.writeSync, fs_handlers_1.default.isRetriableError)
};
fs$1.default = FS;
var lang = {};
Object.defineProperty(lang, "__esModule", { value: true });
const Lang = {
  isFunction: (x) => {
    return typeof x === "function";
  },
  isString: (x) => {
    return typeof x === "string";
  },
  isUndefined: (x) => {
    return typeof x === "undefined";
  }
};
lang.default = Lang;
var scheduler = {};
Object.defineProperty(scheduler, "__esModule", { value: true });
const Queues = {};
const Scheduler = {
  next: (id2) => {
    const queue2 = Queues[id2];
    if (!queue2)
      return;
    queue2.shift();
    const job = queue2[0];
    if (job) {
      job(() => Scheduler.next(id2));
    } else {
      delete Queues[id2];
    }
  },
  schedule: (id2) => {
    return new Promise((resolve2) => {
      let queue2 = Queues[id2];
      if (!queue2)
        queue2 = Queues[id2] = [];
      queue2.push(resolve2);
      if (queue2.length > 1)
        return;
      resolve2(() => Scheduler.next(id2));
    });
  }
};
scheduler.default = Scheduler;
var temp = {};
Object.defineProperty(temp, "__esModule", { value: true });
const path$2 = require$$1__default["default"];
const consts_1$1 = consts;
const fs_1$1 = fs$1;
const Temp = {
  store: {},
  create: (filePath) => {
    const randomness = `000000${Math.floor(Math.random() * 16777215).toString(16)}`.slice(-6), timestamp = Date.now().toString().slice(-10), prefix = "tmp-", suffix = `.${prefix}${timestamp}${randomness}`, tempPath = `${filePath}${suffix}`;
    return tempPath;
  },
  get: (filePath, creator, purge = true) => {
    const tempPath = Temp.truncate(creator(filePath));
    if (tempPath in Temp.store)
      return Temp.get(filePath, creator, purge);
    Temp.store[tempPath] = purge;
    const disposer = () => delete Temp.store[tempPath];
    return [tempPath, disposer];
  },
  purge: (filePath) => {
    if (!Temp.store[filePath])
      return;
    delete Temp.store[filePath];
    fs_1$1.default.unlinkAttempt(filePath);
  },
  purgeSync: (filePath) => {
    if (!Temp.store[filePath])
      return;
    delete Temp.store[filePath];
    fs_1$1.default.unlinkSyncAttempt(filePath);
  },
  purgeSyncAll: () => {
    for (const filePath in Temp.store) {
      Temp.purgeSync(filePath);
    }
  },
  truncate: (filePath) => {
    const basename = path$2.basename(filePath);
    if (basename.length <= consts_1$1.LIMIT_BASENAME_LENGTH)
      return filePath;
    const truncable = /^(\.?)(.*?)((?:\.[^.]+)?(?:\.tmp-\d{10}[a-f0-9]{6})?)$/.exec(basename);
    if (!truncable)
      return filePath;
    const truncationLength = basename.length - consts_1$1.LIMIT_BASENAME_LENGTH;
    return `${filePath.slice(0, -basename.length)}${truncable[1]}${truncable[2].slice(0, -truncationLength)}${truncable[3]}`;
  }
};
process.on("exit", Temp.purgeSyncAll);
temp.default = Temp;
Object.defineProperty(dist$1, "__esModule", { value: true });
dist$1.writeFileSync = dist$1.writeFile = dist$1.readFileSync = dist$1.readFile = void 0;
const path$1 = require$$1__default["default"];
const consts_1 = consts;
const fs_1 = fs$1;
const lang_1 = lang;
const scheduler_1 = scheduler;
const temp_1 = temp;
function readFile(filePath, options = consts_1.DEFAULT_READ_OPTIONS) {
  var _a;
  if (lang_1.default.isString(options))
    return readFile(filePath, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_ASYNC);
  return fs_1.default.readFileRetry(timeout)(filePath, options);
}
dist$1.readFile = readFile;
function readFileSync(filePath, options = consts_1.DEFAULT_READ_OPTIONS) {
  var _a;
  if (lang_1.default.isString(options))
    return readFileSync(filePath, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_SYNC);
  return fs_1.default.readFileSyncRetry(timeout)(filePath, options);
}
dist$1.readFileSync = readFileSync;
const writeFile = (filePath, data, options, callback) => {
  if (lang_1.default.isFunction(options))
    return writeFile(filePath, data, consts_1.DEFAULT_WRITE_OPTIONS, options);
  const promise = writeFileAsync(filePath, data, options);
  if (callback)
    promise.then(callback, callback);
  return promise;
};
dist$1.writeFile = writeFile;
const writeFileAsync = async (filePath, data, options = consts_1.DEFAULT_WRITE_OPTIONS) => {
  var _a;
  if (lang_1.default.isString(options))
    return writeFileAsync(filePath, data, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_ASYNC);
  let schedulerCustomDisposer = null, schedulerDisposer = null, tempDisposer = null, tempPath = null, fd = null;
  try {
    if (options.schedule)
      schedulerCustomDisposer = await options.schedule(filePath);
    schedulerDisposer = await scheduler_1.default.schedule(filePath);
    filePath = await fs_1.default.realpathAttempt(filePath) || filePath;
    [tempPath, tempDisposer] = temp_1.default.get(filePath, options.tmpCreate || temp_1.default.create, !(options.tmpPurge === false));
    const useStatChown = consts_1.IS_POSIX && lang_1.default.isUndefined(options.chown), useStatMode = lang_1.default.isUndefined(options.mode);
    if (useStatChown || useStatMode) {
      const stat2 = await fs_1.default.statAttempt(filePath);
      if (stat2) {
        options = __spreadValues({}, options);
        if (useStatChown)
          options.chown = { uid: stat2.uid, gid: stat2.gid };
        if (useStatMode)
          options.mode = stat2.mode;
      }
    }
    const parentPath = path$1.dirname(filePath);
    await fs_1.default.mkdirAttempt(parentPath, {
      mode: consts_1.DEFAULT_FOLDER_MODE,
      recursive: true
    });
    fd = await fs_1.default.openRetry(timeout)(tempPath, "w", options.mode || consts_1.DEFAULT_FILE_MODE);
    if (options.tmpCreated)
      options.tmpCreated(tempPath);
    if (lang_1.default.isString(data)) {
      await fs_1.default.writeRetry(timeout)(fd, data, 0, options.encoding || consts_1.DEFAULT_ENCODING);
    } else if (!lang_1.default.isUndefined(data)) {
      await fs_1.default.writeRetry(timeout)(fd, data, 0, data.length, 0);
    }
    if (options.fsync !== false) {
      if (options.fsyncWait !== false) {
        await fs_1.default.fsyncRetry(timeout)(fd);
      } else {
        fs_1.default.fsyncAttempt(fd);
      }
    }
    await fs_1.default.closeRetry(timeout)(fd);
    fd = null;
    if (options.chown)
      await fs_1.default.chownAttempt(tempPath, options.chown.uid, options.chown.gid);
    if (options.mode)
      await fs_1.default.chmodAttempt(tempPath, options.mode);
    try {
      await fs_1.default.renameRetry(timeout)(tempPath, filePath);
    } catch (error2) {
      if (error2.code !== "ENAMETOOLONG")
        throw error2;
      await fs_1.default.renameRetry(timeout)(tempPath, temp_1.default.truncate(filePath));
    }
    tempDisposer();
    tempPath = null;
  } finally {
    if (fd)
      await fs_1.default.closeAttempt(fd);
    if (tempPath)
      temp_1.default.purge(tempPath);
    if (schedulerCustomDisposer)
      schedulerCustomDisposer();
    if (schedulerDisposer)
      schedulerDisposer();
  }
};
const writeFileSync = (filePath, data, options = consts_1.DEFAULT_WRITE_OPTIONS) => {
  var _a;
  if (lang_1.default.isString(options))
    return writeFileSync(filePath, data, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_SYNC);
  let tempDisposer = null, tempPath = null, fd = null;
  try {
    filePath = fs_1.default.realpathSyncAttempt(filePath) || filePath;
    [tempPath, tempDisposer] = temp_1.default.get(filePath, options.tmpCreate || temp_1.default.create, !(options.tmpPurge === false));
    const useStatChown = consts_1.IS_POSIX && lang_1.default.isUndefined(options.chown), useStatMode = lang_1.default.isUndefined(options.mode);
    if (useStatChown || useStatMode) {
      const stat2 = fs_1.default.statSyncAttempt(filePath);
      if (stat2) {
        options = __spreadValues({}, options);
        if (useStatChown)
          options.chown = { uid: stat2.uid, gid: stat2.gid };
        if (useStatMode)
          options.mode = stat2.mode;
      }
    }
    const parentPath = path$1.dirname(filePath);
    fs_1.default.mkdirSyncAttempt(parentPath, {
      mode: consts_1.DEFAULT_FOLDER_MODE,
      recursive: true
    });
    fd = fs_1.default.openSyncRetry(timeout)(tempPath, "w", options.mode || consts_1.DEFAULT_FILE_MODE);
    if (options.tmpCreated)
      options.tmpCreated(tempPath);
    if (lang_1.default.isString(data)) {
      fs_1.default.writeSyncRetry(timeout)(fd, data, 0, options.encoding || consts_1.DEFAULT_ENCODING);
    } else if (!lang_1.default.isUndefined(data)) {
      fs_1.default.writeSyncRetry(timeout)(fd, data, 0, data.length, 0);
    }
    if (options.fsync !== false) {
      if (options.fsyncWait !== false) {
        fs_1.default.fsyncSyncRetry(timeout)(fd);
      } else {
        fs_1.default.fsyncAttempt(fd);
      }
    }
    fs_1.default.closeSyncRetry(timeout)(fd);
    fd = null;
    if (options.chown)
      fs_1.default.chownSyncAttempt(tempPath, options.chown.uid, options.chown.gid);
    if (options.mode)
      fs_1.default.chmodSyncAttempt(tempPath, options.mode);
    try {
      fs_1.default.renameSyncRetry(timeout)(tempPath, filePath);
    } catch (error2) {
      if (error2.code !== "ENAMETOOLONG")
        throw error2;
      fs_1.default.renameSyncRetry(timeout)(tempPath, temp_1.default.truncate(filePath));
    }
    tempDisposer();
    tempPath = null;
  } finally {
    if (fd)
      fs_1.default.closeSyncAttempt(fd);
    if (tempPath)
      temp_1.default.purge(tempPath);
  }
};
dist$1.writeFileSync = writeFileSync;
var ajv = { exports: {} };
var core$2 = {};
var validate = {};
var boolSchema = {};
var errors = {};
var codegen = {};
var code$1 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.regexpCode = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
  class _CodeOrName {
  }
  exports._CodeOrName = _CodeOrName;
  exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class Name extends _CodeOrName {
    constructor(s) {
      super();
      if (!exports.IDENTIFIER.test(s))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = s;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  exports.Name = Name;
  class _Code extends _CodeOrName {
    constructor(code2) {
      super();
      this._items = typeof code2 === "string" ? [code2] : code2;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return false;
      const item = this._items[0];
      return item === "" || item === '""';
    }
    get str() {
      var _a;
      return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
    }
    get names() {
      var _a;
      return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names2, c) => {
        if (c instanceof Name)
          names2[c.str] = (names2[c.str] || 0) + 1;
        return names2;
      }, {});
    }
  }
  exports._Code = _Code;
  exports.nil = new _Code("");
  function _(strs, ...args) {
    const code2 = [strs[0]];
    let i = 0;
    while (i < args.length) {
      addCodeArg(code2, args[i]);
      code2.push(strs[++i]);
    }
    return new _Code(code2);
  }
  exports._ = _;
  const plus = new _Code("+");
  function str(strs, ...args) {
    const expr = [safeStringify(strs[0])];
    let i = 0;
    while (i < args.length) {
      expr.push(plus);
      addCodeArg(expr, args[i]);
      expr.push(plus, safeStringify(strs[++i]));
    }
    optimize(expr);
    return new _Code(expr);
  }
  exports.str = str;
  function addCodeArg(code2, arg) {
    if (arg instanceof _Code)
      code2.push(...arg._items);
    else if (arg instanceof Name)
      code2.push(arg);
    else
      code2.push(interpolate(arg));
  }
  exports.addCodeArg = addCodeArg;
  function optimize(expr) {
    let i = 1;
    while (i < expr.length - 1) {
      if (expr[i] === plus) {
        const res = mergeExprItems(expr[i - 1], expr[i + 1]);
        if (res !== void 0) {
          expr.splice(i - 1, 3, res);
          continue;
        }
        expr[i++] = "+";
      }
      i++;
    }
  }
  function mergeExprItems(a, b) {
    if (b === '""')
      return a;
    if (a === '""')
      return b;
    if (typeof a == "string") {
      if (b instanceof Name || a[a.length - 1] !== '"')
        return;
      if (typeof b != "string")
        return `${a.slice(0, -1)}${b}"`;
      if (b[0] === '"')
        return a.slice(0, -1) + b.slice(1);
      return;
    }
    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
      return `"${a}${b.slice(1)}`;
    return;
  }
  function strConcat(c1, c2) {
    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
  }
  exports.strConcat = strConcat;
  function interpolate(x) {
    return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
  }
  function stringify2(x) {
    return new _Code(safeStringify(x));
  }
  exports.stringify = stringify2;
  function safeStringify(x) {
    return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  exports.safeStringify = safeStringify;
  function getProperty(key) {
    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
  }
  exports.getProperty = getProperty;
  function regexpCode(rx) {
    return new _Code(rx.toString());
  }
  exports.regexpCode = regexpCode;
})(code$1);
var scope = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
  const code_12 = code$1;
  class ValueError extends Error {
    constructor(name) {
      super(`CodeGen: "code" for ${name} not defined`);
      this.value = name.value;
    }
  }
  var UsedValueState;
  (function(UsedValueState2) {
    UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
    UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
  })(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));
  exports.varKinds = {
    const: new code_12.Name("const"),
    let: new code_12.Name("let"),
    var: new code_12.Name("var")
  };
  class Scope {
    constructor({ prefixes, parent } = {}) {
      this._names = {};
      this._prefixes = prefixes;
      this._parent = parent;
    }
    toName(nameOrPrefix) {
      return nameOrPrefix instanceof code_12.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix) {
      return new code_12.Name(this._newName(prefix));
    }
    _newName(prefix) {
      const ng = this._names[prefix] || this._nameGroup(prefix);
      return `${prefix}${ng.index++}`;
    }
    _nameGroup(prefix) {
      var _a, _b;
      if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
        throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
      }
      return this._names[prefix] = { prefix, index: 0 };
    }
  }
  exports.Scope = Scope;
  class ValueScopeName extends code_12.Name {
    constructor(prefix, nameStr) {
      super(nameStr);
      this.prefix = prefix;
    }
    setValue(value, { property, itemIndex }) {
      this.value = value;
      this.scopePath = code_12._`.${new code_12.Name(property)}[${itemIndex}]`;
    }
  }
  exports.ValueScopeName = ValueScopeName;
  const line = code_12._`\n`;
  class ValueScope extends Scope {
    constructor(opts2) {
      super(opts2);
      this._values = {};
      this._scope = opts2.scope;
      this.opts = __spreadProps(__spreadValues({}, opts2), { _n: opts2.lines ? line : code_12.nil });
    }
    get() {
      return this._scope;
    }
    name(prefix) {
      return new ValueScopeName(prefix, this._newName(prefix));
    }
    value(nameOrPrefix, value) {
      var _a;
      if (value.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const name = this.toName(nameOrPrefix);
      const { prefix } = name;
      const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
      let vs = this._values[prefix];
      if (vs) {
        const _name = vs.get(valueKey);
        if (_name)
          return _name;
      } else {
        vs = this._values[prefix] = new Map();
      }
      vs.set(valueKey, name);
      const s = this._scope[prefix] || (this._scope[prefix] = []);
      const itemIndex = s.length;
      s[itemIndex] = value.ref;
      name.setValue(value, { property: prefix, itemIndex });
      return name;
    }
    getValue(prefix, keyOrRef) {
      const vs = this._values[prefix];
      if (!vs)
        return;
      return vs.get(keyOrRef);
    }
    scopeRefs(scopeName, values = this._values) {
      return this._reduceValues(values, (name) => {
        if (name.scopePath === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return code_12._`${scopeName}${name.scopePath}`;
      });
    }
    scopeCode(values = this._values, usedValues, getCode) {
      return this._reduceValues(values, (name) => {
        if (name.value === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return name.value.code;
      }, usedValues, getCode);
    }
    _reduceValues(values, valueCode, usedValues = {}, getCode) {
      let code2 = code_12.nil;
      for (const prefix in values) {
        const vs = values[prefix];
        if (!vs)
          continue;
        const nameSet = usedValues[prefix] = usedValues[prefix] || new Map();
        vs.forEach((name) => {
          if (nameSet.has(name))
            return;
          nameSet.set(name, UsedValueState.Started);
          let c = valueCode(name);
          if (c) {
            const def2 = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
            code2 = code_12._`${code2}${def2} ${name} = ${c};${this.opts._n}`;
          } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
            code2 = code_12._`${code2}${c}${this.opts._n}`;
          } else {
            throw new ValueError(name);
          }
          nameSet.set(name, UsedValueState.Completed);
        });
      }
      return code2;
    }
  }
  exports.ValueScope = ValueScope;
})(scope);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
  const code_12 = code$1;
  const scope_1 = scope;
  var code_2 = code$1;
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return code_2._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return code_2.str;
  } });
  Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
    return code_2.strConcat;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return code_2.nil;
  } });
  Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
    return code_2.getProperty;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return code_2.stringify;
  } });
  Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
    return code_2.regexpCode;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return code_2.Name;
  } });
  var scope_2 = scope;
  Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
    return scope_2.Scope;
  } });
  Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
    return scope_2.ValueScope;
  } });
  Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
    return scope_2.ValueScopeName;
  } });
  Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
    return scope_2.varKinds;
  } });
  exports.operators = {
    GT: new code_12._Code(">"),
    GTE: new code_12._Code(">="),
    LT: new code_12._Code("<"),
    LTE: new code_12._Code("<="),
    EQ: new code_12._Code("==="),
    NEQ: new code_12._Code("!=="),
    NOT: new code_12._Code("!"),
    OR: new code_12._Code("||"),
    AND: new code_12._Code("&&"),
    ADD: new code_12._Code("+")
  };
  class Node2 {
    optimizeNodes() {
      return this;
    }
    optimizeNames(_names, _constants) {
      return this;
    }
  }
  class Def extends Node2 {
    constructor(varKind, name, rhs) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.rhs = rhs;
    }
    render({ es5, _n }) {
      const varKind = es5 ? scope_1.varKinds.var : this.varKind;
      const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${varKind} ${this.name}${rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (!names2[this.name.str])
        return;
      if (this.rhs)
        this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      return this.rhs instanceof code_12._CodeOrName ? this.rhs.names : {};
    }
  }
  class Assign extends Node2 {
    constructor(lhs, rhs, sideEffects) {
      super();
      this.lhs = lhs;
      this.rhs = rhs;
      this.sideEffects = sideEffects;
    }
    render({ _n }) {
      return `${this.lhs} = ${this.rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (this.lhs instanceof code_12.Name && !names2[this.lhs.str] && !this.sideEffects)
        return;
      this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      const names2 = this.lhs instanceof code_12.Name ? {} : __spreadValues({}, this.lhs.names);
      return addExprNames(names2, this.rhs);
    }
  }
  class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
      super(lhs, rhs, sideEffects);
      this.op = op;
    }
    render({ _n }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
    }
  }
  class Label extends Node2 {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      return `${this.label}:` + _n;
    }
  }
  class Break extends Node2 {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      const label = this.label ? ` ${this.label}` : "";
      return `break${label};` + _n;
    }
  }
  class Throw extends Node2 {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render({ _n }) {
      return `throw ${this.error};` + _n;
    }
    get names() {
      return this.error.names;
    }
  }
  class AnyCode extends Node2 {
    constructor(code2) {
      super();
      this.code = code2;
    }
    render({ _n }) {
      return `${this.code};` + _n;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      this.code = optimizeExpr(this.code, names2, constants2);
      return this;
    }
    get names() {
      return this.code instanceof code_12._CodeOrName ? this.code.names : {};
    }
  }
  class ParentNode extends Node2 {
    constructor(nodes = []) {
      super();
      this.nodes = nodes;
    }
    render(opts2) {
      return this.nodes.reduce((code2, n) => code2 + n.render(opts2), "");
    }
    optimizeNodes() {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i].optimizeNodes();
        if (Array.isArray(n))
          nodes.splice(i, 1, ...n);
        else if (n)
          nodes[i] = n;
        else
          nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i];
        if (n.optimizeNames(names2, constants2))
          continue;
        subtractNames(names2, n.names);
        nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((names2, n) => addNames(names2, n.names), {});
    }
  }
  class BlockNode extends ParentNode {
    render(opts2) {
      return "{" + opts2._n + super.render(opts2) + "}" + opts2._n;
    }
  }
  class Root extends ParentNode {
  }
  class Else extends BlockNode {
  }
  Else.kind = "else";
  class If extends BlockNode {
    constructor(condition, nodes) {
      super(nodes);
      this.condition = condition;
    }
    render(opts2) {
      let code2 = `if(${this.condition})` + super.render(opts2);
      if (this.else)
        code2 += "else " + this.else.render(opts2);
      return code2;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const cond = this.condition;
      if (cond === true)
        return this.nodes;
      let e = this.else;
      if (e) {
        const ns = e.optimizeNodes();
        e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
      }
      if (e) {
        if (cond === false)
          return e instanceof If ? e : e.nodes;
        if (this.nodes.length)
          return this;
        return new If(not2(cond), e instanceof If ? [e] : e.nodes);
      }
      if (cond === false || !this.nodes.length)
        return void 0;
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a;
      this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants2);
      if (!(super.optimizeNames(names2, constants2) || this.else))
        return;
      this.condition = optimizeExpr(this.condition, names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      addExprNames(names2, this.condition);
      if (this.else)
        addNames(names2, this.else.names);
      return names2;
    }
  }
  If.kind = "if";
  class For extends BlockNode {
  }
  For.kind = "for";
  class ForLoop extends For {
    constructor(iteration) {
      super();
      this.iteration = iteration;
    }
    render(opts2) {
      return `for(${this.iteration})` + super.render(opts2);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iteration = optimizeExpr(this.iteration, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iteration.names);
    }
  }
  class ForRange extends For {
    constructor(varKind, name, from, to) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.from = from;
      this.to = to;
    }
    render(opts2) {
      const varKind = opts2.es5 ? scope_1.varKinds.var : this.varKind;
      const { name, from, to } = this;
      return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts2);
    }
    get names() {
      const names2 = addExprNames(super.names, this.from);
      return addExprNames(names2, this.to);
    }
  }
  class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
      super();
      this.loop = loop;
      this.varKind = varKind;
      this.name = name;
      this.iterable = iterable;
    }
    render(opts2) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts2);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iterable = optimizeExpr(this.iterable, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iterable.names);
    }
  }
  class Func extends BlockNode {
    constructor(name, args, async) {
      super();
      this.name = name;
      this.args = args;
      this.async = async;
    }
    render(opts2) {
      const _async = this.async ? "async " : "";
      return `${_async}function ${this.name}(${this.args})` + super.render(opts2);
    }
  }
  Func.kind = "func";
  class Return extends ParentNode {
    render(opts2) {
      return "return " + super.render(opts2);
    }
  }
  Return.kind = "return";
  class Try extends BlockNode {
    render(opts2) {
      let code2 = "try" + super.render(opts2);
      if (this.catch)
        code2 += this.catch.render(opts2);
      if (this.finally)
        code2 += this.finally.render(opts2);
      return code2;
    }
    optimizeNodes() {
      var _a, _b;
      super.optimizeNodes();
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a, _b;
      super.optimizeNames(names2, constants2);
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants2);
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      if (this.catch)
        addNames(names2, this.catch.names);
      if (this.finally)
        addNames(names2, this.finally.names);
      return names2;
    }
  }
  class Catch extends BlockNode {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render(opts2) {
      return `catch(${this.error})` + super.render(opts2);
    }
  }
  Catch.kind = "catch";
  class Finally extends BlockNode {
    render(opts2) {
      return "finally" + super.render(opts2);
    }
  }
  Finally.kind = "finally";
  class CodeGen {
    constructor(extScope, opts2 = {}) {
      this._values = {};
      this._blockStarts = [];
      this._constants = {};
      this.opts = __spreadProps(__spreadValues({}, opts2), { _n: opts2.lines ? "\n" : "" });
      this._extScope = extScope;
      this._scope = new scope_1.Scope({ parent: extScope });
      this._nodes = [new Root()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    name(prefix) {
      return this._scope.name(prefix);
    }
    scopeName(prefix) {
      return this._extScope.name(prefix);
    }
    scopeValue(prefixOrName, value) {
      const name = this._extScope.value(prefixOrName, value);
      const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
      vs.add(name);
      return name;
    }
    getScopeValue(prefix, keyOrRef) {
      return this._extScope.getValue(prefix, keyOrRef);
    }
    scopeRefs(scopeName) {
      return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant) {
      const name = this._scope.toName(nameOrPrefix);
      if (rhs !== void 0 && constant)
        this._constants[name.str] = rhs;
      this._leafNode(new Def(varKind, name, rhs));
      return name;
    }
    const(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    let(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    var(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    assign(lhs, rhs, sideEffects) {
      return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    add(lhs, rhs) {
      return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
    }
    code(c) {
      if (typeof c == "function")
        c();
      else if (c !== code_12.nil)
        this._leafNode(new AnyCode(c));
      return this;
    }
    object(...keyValues) {
      const code2 = ["{"];
      for (const [key, value] of keyValues) {
        if (code2.length > 1)
          code2.push(",");
        code2.push(key);
        if (key !== value || this.opts.es5) {
          code2.push(":");
          code_12.addCodeArg(code2, value);
        }
      }
      code2.push("}");
      return new code_12._Code(code2);
    }
    if(condition, thenBody, elseBody) {
      this._blockNode(new If(condition));
      if (thenBody && elseBody) {
        this.code(thenBody).else().code(elseBody).endIf();
      } else if (thenBody) {
        this.code(thenBody).endIf();
      } else if (elseBody) {
        throw new Error('CodeGen: "else" body without "then" body');
      }
      return this;
    }
    elseIf(condition) {
      return this._elseNode(new If(condition));
    }
    else() {
      return this._elseNode(new Else());
    }
    endIf() {
      return this._endBlockNode(If, Else);
    }
    _for(node, forBody) {
      this._blockNode(node);
      if (forBody)
        this.code(forBody).endFor();
      return this;
    }
    for(iteration, forBody) {
      return this._for(new ForLoop(iteration), forBody);
    }
    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
    }
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
      const name = this._scope.toName(nameOrPrefix);
      if (this.opts.es5) {
        const arr = iterable instanceof code_12.Name ? iterable : this.var("_arr", iterable);
        return this.forRange("_i", 0, code_12._`${arr}.length`, (i) => {
          this.var(name, code_12._`${arr}[${i}]`);
          forBody(name);
        });
      }
      return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    }
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
      if (this.opts.ownProperties) {
        return this.forOf(nameOrPrefix, code_12._`Object.keys(${obj})`, forBody);
      }
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    }
    endFor() {
      return this._endBlockNode(For);
    }
    label(label) {
      return this._leafNode(new Label(label));
    }
    break(label) {
      return this._leafNode(new Break(label));
    }
    return(value) {
      const node = new Return();
      this._blockNode(node);
      this.code(value);
      if (node.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(Return);
    }
    try(tryBody, catchCode, finallyCode) {
      if (!catchCode && !finallyCode)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const node = new Try();
      this._blockNode(node);
      this.code(tryBody);
      if (catchCode) {
        const error2 = this.name("e");
        this._currNode = node.catch = new Catch(error2);
        catchCode(error2);
      }
      if (finallyCode) {
        this._currNode = node.finally = new Finally();
        this.code(finallyCode);
      }
      return this._endBlockNode(Catch, Finally);
    }
    throw(error2) {
      return this._leafNode(new Throw(error2));
    }
    block(body, nodeCount) {
      this._blockStarts.push(this._nodes.length);
      if (body)
        this.code(body).endBlock(nodeCount);
      return this;
    }
    endBlock(nodeCount) {
      const len = this._blockStarts.pop();
      if (len === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const toClose = this._nodes.length - len;
      if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
        throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
      }
      this._nodes.length = len;
      return this;
    }
    func(name, args = code_12.nil, async, funcBody) {
      this._blockNode(new Func(name, args, async));
      if (funcBody)
        this.code(funcBody).endFunc();
      return this;
    }
    endFunc() {
      return this._endBlockNode(Func);
    }
    optimize(n = 1) {
      while (n-- > 0) {
        this._root.optimizeNodes();
        this._root.optimizeNames(this._root.names, this._constants);
      }
    }
    _leafNode(node) {
      this._currNode.nodes.push(node);
      return this;
    }
    _blockNode(node) {
      this._currNode.nodes.push(node);
      this._nodes.push(node);
    }
    _endBlockNode(N1, N2) {
      const n = this._currNode;
      if (n instanceof N1 || N2 && n instanceof N2) {
        this._nodes.pop();
        return this;
      }
      throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
    }
    _elseNode(node) {
      const n = this._currNode;
      if (!(n instanceof If)) {
        throw new Error('CodeGen: "else" without "if"');
      }
      this._currNode = n.else = node;
      return this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const ns = this._nodes;
      return ns[ns.length - 1];
    }
    set _currNode(node) {
      const ns = this._nodes;
      ns[ns.length - 1] = node;
    }
  }
  exports.CodeGen = CodeGen;
  function addNames(names2, from) {
    for (const n in from)
      names2[n] = (names2[n] || 0) + (from[n] || 0);
    return names2;
  }
  function addExprNames(names2, from) {
    return from instanceof code_12._CodeOrName ? addNames(names2, from.names) : names2;
  }
  function optimizeExpr(expr, names2, constants2) {
    if (expr instanceof code_12.Name)
      return replaceName(expr);
    if (!canOptimize(expr))
      return expr;
    return new code_12._Code(expr._items.reduce((items2, c) => {
      if (c instanceof code_12.Name)
        c = replaceName(c);
      if (c instanceof code_12._Code)
        items2.push(...c._items);
      else
        items2.push(c);
      return items2;
    }, []));
    function replaceName(n) {
      const c = constants2[n.str];
      if (c === void 0 || names2[n.str] !== 1)
        return n;
      delete names2[n.str];
      return c;
    }
    function canOptimize(e) {
      return e instanceof code_12._Code && e._items.some((c) => c instanceof code_12.Name && names2[c.str] === 1 && constants2[c.str] !== void 0);
    }
  }
  function subtractNames(names2, from) {
    for (const n in from)
      names2[n] = (names2[n] || 0) - (from[n] || 0);
  }
  function not2(x) {
    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : code_12._`!${par(x)}`;
  }
  exports.not = not2;
  const andCode = mappend(exports.operators.AND);
  function and(...args) {
    return args.reduce(andCode);
  }
  exports.and = and;
  const orCode = mappend(exports.operators.OR);
  function or(...args) {
    return args.reduce(orCode);
  }
  exports.or = or;
  function mappend(op) {
    return (x, y) => x === code_12.nil ? y : y === code_12.nil ? x : code_12._`${par(x)} ${op} ${par(y)}`;
  }
  function par(x) {
    return x instanceof code_12.Name ? x : code_12._`(${x})`;
  }
})(codegen);
var util = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
  const codegen_12 = codegen;
  const code_12 = code$1;
  function toHash(arr) {
    const hash = {};
    for (const item of arr)
      hash[item] = true;
    return hash;
  }
  exports.toHash = toHash;
  function alwaysValidSchema(it, schema2) {
    if (typeof schema2 == "boolean")
      return schema2;
    if (Object.keys(schema2).length === 0)
      return true;
    checkUnknownRules(it, schema2);
    return !schemaHasRules(schema2, it.self.RULES.all);
  }
  exports.alwaysValidSchema = alwaysValidSchema;
  function checkUnknownRules(it, schema2 = it.schema) {
    const { opts: opts2, self: self2 } = it;
    if (!opts2.strictSchema)
      return;
    if (typeof schema2 === "boolean")
      return;
    const rules2 = self2.RULES.keywords;
    for (const key in schema2) {
      if (!rules2[key])
        checkStrictMode(it, `unknown keyword: "${key}"`);
    }
  }
  exports.checkUnknownRules = checkUnknownRules;
  function schemaHasRules(schema2, rules2) {
    if (typeof schema2 == "boolean")
      return !schema2;
    for (const key in schema2)
      if (rules2[key])
        return true;
    return false;
  }
  exports.schemaHasRules = schemaHasRules;
  function schemaHasRulesButRef(schema2, RULES) {
    if (typeof schema2 == "boolean")
      return !schema2;
    for (const key in schema2)
      if (key !== "$ref" && RULES.all[key])
        return true;
    return false;
  }
  exports.schemaHasRulesButRef = schemaHasRulesButRef;
  function schemaRefOrVal({ topSchemaRef, schemaPath }, schema2, keyword2, $data) {
    if (!$data) {
      if (typeof schema2 == "number" || typeof schema2 == "boolean")
        return schema2;
      if (typeof schema2 == "string")
        return codegen_12._`${schema2}`;
    }
    return codegen_12._`${topSchemaRef}${schemaPath}${codegen_12.getProperty(keyword2)}`;
  }
  exports.schemaRefOrVal = schemaRefOrVal;
  function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
  }
  exports.unescapeFragment = unescapeFragment;
  function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
  }
  exports.escapeFragment = escapeFragment;
  function escapeJsonPointer(str) {
    if (typeof str == "number")
      return `${str}`;
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  exports.escapeJsonPointer = escapeJsonPointer;
  function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  exports.unescapeJsonPointer = unescapeJsonPointer;
  function eachItem(xs, f) {
    if (Array.isArray(xs)) {
      for (const x of xs)
        f(x);
    } else {
      f(xs);
    }
  }
  exports.eachItem = eachItem;
  function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
    return (gen, from, to, toName) => {
      const res = to === void 0 ? from : to instanceof codegen_12.Name ? (from instanceof codegen_12.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_12.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
      return toName === codegen_12.Name && !(res instanceof codegen_12.Name) ? resultToName(gen, res) : res;
    };
  }
  exports.mergeEvaluated = {
    props: makeMergeEvaluated({
      mergeNames: (gen, from, to) => gen.if(codegen_12._`${to} !== true && ${from} !== undefined`, () => {
        gen.if(codegen_12._`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, codegen_12._`${to} || {}`).code(codegen_12._`Object.assign(${to}, ${from})`));
      }),
      mergeToName: (gen, from, to) => gen.if(codegen_12._`${to} !== true`, () => {
        if (from === true) {
          gen.assign(to, true);
        } else {
          gen.assign(to, codegen_12._`${to} || {}`);
          setEvaluated(gen, to, from);
        }
      }),
      mergeValues: (from, to) => from === true ? true : __spreadValues(__spreadValues({}, from), to),
      resultToName: evaluatedPropsToName
    }),
    items: makeMergeEvaluated({
      mergeNames: (gen, from, to) => gen.if(codegen_12._`${to} !== true && ${from} !== undefined`, () => gen.assign(to, codegen_12._`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
      mergeToName: (gen, from, to) => gen.if(codegen_12._`${to} !== true`, () => gen.assign(to, from === true ? true : codegen_12._`${to} > ${from} ? ${to} : ${from}`)),
      mergeValues: (from, to) => from === true ? true : Math.max(from, to),
      resultToName: (gen, items2) => gen.var("items", items2)
    })
  };
  function evaluatedPropsToName(gen, ps) {
    if (ps === true)
      return gen.var("props", true);
    const props = gen.var("props", codegen_12._`{}`);
    if (ps !== void 0)
      setEvaluated(gen, props, ps);
    return props;
  }
  exports.evaluatedPropsToName = evaluatedPropsToName;
  function setEvaluated(gen, props, ps) {
    Object.keys(ps).forEach((p) => gen.assign(codegen_12._`${props}${codegen_12.getProperty(p)}`, true));
  }
  exports.setEvaluated = setEvaluated;
  const snippets = {};
  function useFunc(gen, f) {
    return gen.scopeValue("func", {
      ref: f,
      code: snippets[f.code] || (snippets[f.code] = new code_12._Code(f.code))
    });
  }
  exports.useFunc = useFunc;
  var Type;
  (function(Type2) {
    Type2[Type2["Num"] = 0] = "Num";
    Type2[Type2["Str"] = 1] = "Str";
  })(Type = exports.Type || (exports.Type = {}));
  function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
    if (dataProp instanceof codegen_12.Name) {
      const isNumber = dataPropType === Type.Num;
      return jsPropertySyntax ? isNumber ? codegen_12._`"[" + ${dataProp} + "]"` : codegen_12._`"['" + ${dataProp} + "']"` : isNumber ? codegen_12._`"/" + ${dataProp}` : codegen_12._`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return jsPropertySyntax ? codegen_12.getProperty(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
  }
  exports.getErrorPath = getErrorPath;
  function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
    if (!mode)
      return;
    msg = `strict mode: ${msg}`;
    if (mode === true)
      throw new Error(msg);
    it.self.logger.warn(msg);
  }
  exports.checkStrictMode = checkStrictMode;
})(util);
var names$1 = {};
Object.defineProperty(names$1, "__esModule", { value: true });
const codegen_1$t = codegen;
const names = {
  data: new codegen_1$t.Name("data"),
  valCxt: new codegen_1$t.Name("valCxt"),
  instancePath: new codegen_1$t.Name("instancePath"),
  parentData: new codegen_1$t.Name("parentData"),
  parentDataProperty: new codegen_1$t.Name("parentDataProperty"),
  rootData: new codegen_1$t.Name("rootData"),
  dynamicAnchors: new codegen_1$t.Name("dynamicAnchors"),
  vErrors: new codegen_1$t.Name("vErrors"),
  errors: new codegen_1$t.Name("errors"),
  this: new codegen_1$t.Name("this"),
  self: new codegen_1$t.Name("self"),
  scope: new codegen_1$t.Name("scope"),
  json: new codegen_1$t.Name("json"),
  jsonPos: new codegen_1$t.Name("jsonPos"),
  jsonLen: new codegen_1$t.Name("jsonLen"),
  jsonPart: new codegen_1$t.Name("jsonPart")
};
names$1.default = names;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
  const codegen_12 = codegen;
  const util_12 = util;
  const names_12 = names$1;
  exports.keywordError = {
    message: ({ keyword: keyword2 }) => codegen_12.str`must pass "${keyword2}" keyword validation`
  };
  exports.keyword$DataError = {
    message: ({ keyword: keyword2, schemaType }) => schemaType ? codegen_12.str`"${keyword2}" keyword must be ${schemaType} ($data)` : codegen_12.str`"${keyword2}" keyword is invalid ($data)`
  };
  function reportError(cxt, error2 = exports.keywordError, errorPaths, overrideAllErrors) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
      addError(gen, errObj);
    } else {
      returnErrors(it, codegen_12._`[${errObj}]`);
    }
  }
  exports.reportError = reportError;
  function reportExtraError(cxt, error2 = exports.keywordError, errorPaths) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
      returnErrors(it, names_12.default.vErrors);
    }
  }
  exports.reportExtraError = reportExtraError;
  function resetErrorsCount(gen, errsCount) {
    gen.assign(names_12.default.errors, errsCount);
    gen.if(codegen_12._`${names_12.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign(codegen_12._`${names_12.default.vErrors}.length`, errsCount), () => gen.assign(names_12.default.vErrors, null)));
  }
  exports.resetErrorsCount = resetErrorsCount;
  function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it }) {
    if (errsCount === void 0)
      throw new Error("ajv implementation error");
    const err = gen.name("err");
    gen.forRange("i", errsCount, names_12.default.errors, (i) => {
      gen.const(err, codegen_12._`${names_12.default.vErrors}[${i}]`);
      gen.if(codegen_12._`${err}.instancePath === undefined`, () => gen.assign(codegen_12._`${err}.instancePath`, codegen_12.strConcat(names_12.default.instancePath, it.errorPath)));
      gen.assign(codegen_12._`${err}.schemaPath`, codegen_12.str`${it.errSchemaPath}/${keyword2}`);
      if (it.opts.verbose) {
        gen.assign(codegen_12._`${err}.schema`, schemaValue);
        gen.assign(codegen_12._`${err}.data`, data);
      }
    });
  }
  exports.extendErrors = extendErrors;
  function addError(gen, errObj) {
    const err = gen.const("err", errObj);
    gen.if(codegen_12._`${names_12.default.vErrors} === null`, () => gen.assign(names_12.default.vErrors, codegen_12._`[${err}]`), codegen_12._`${names_12.default.vErrors}.push(${err})`);
    gen.code(codegen_12._`${names_12.default.errors}++`);
  }
  function returnErrors(it, errs) {
    const { gen, validateName, schemaEnv } = it;
    if (schemaEnv.$async) {
      gen.throw(codegen_12._`new ${it.ValidationError}(${errs})`);
    } else {
      gen.assign(codegen_12._`${validateName}.errors`, errs);
      gen.return(false);
    }
  }
  const E = {
    keyword: new codegen_12.Name("keyword"),
    schemaPath: new codegen_12.Name("schemaPath"),
    params: new codegen_12.Name("params"),
    propertyName: new codegen_12.Name("propertyName"),
    message: new codegen_12.Name("message"),
    schema: new codegen_12.Name("schema"),
    parentSchema: new codegen_12.Name("parentSchema")
  };
  function errorObjectCode(cxt, error2, errorPaths) {
    const { createErrors } = cxt.it;
    if (createErrors === false)
      return codegen_12._`{}`;
    return errorObject(cxt, error2, errorPaths);
  }
  function errorObject(cxt, error2, errorPaths = {}) {
    const { gen, it } = cxt;
    const keyValues = [
      errorInstancePath(it, errorPaths),
      errorSchemaPath(cxt, errorPaths)
    ];
    extraErrorProps(cxt, error2, keyValues);
    return gen.object(...keyValues);
  }
  function errorInstancePath({ errorPath }, { instancePath }) {
    const instPath = instancePath ? codegen_12.str`${errorPath}${util_12.getErrorPath(instancePath, util_12.Type.Str)}` : errorPath;
    return [names_12.default.instancePath, codegen_12.strConcat(names_12.default.instancePath, instPath)];
  }
  function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
    let schPath = parentSchema ? errSchemaPath : codegen_12.str`${errSchemaPath}/${keyword2}`;
    if (schemaPath) {
      schPath = codegen_12.str`${schPath}${util_12.getErrorPath(schemaPath, util_12.Type.Str)}`;
    }
    return [E.schemaPath, schPath];
  }
  function extraErrorProps(cxt, { params, message }, keyValues) {
    const { keyword: keyword2, data, schemaValue, it } = cxt;
    const { opts: opts2, propertyName, topSchemaRef, schemaPath } = it;
    keyValues.push([E.keyword, keyword2], [E.params, typeof params == "function" ? params(cxt) : params || codegen_12._`{}`]);
    if (opts2.messages) {
      keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts2.verbose) {
      keyValues.push([E.schema, schemaValue], [E.parentSchema, codegen_12._`${topSchemaRef}${schemaPath}`], [names_12.default.data, data]);
    }
    if (propertyName)
      keyValues.push([E.propertyName, propertyName]);
  }
})(errors);
Object.defineProperty(boolSchema, "__esModule", { value: true });
boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
const errors_1$2 = errors;
const codegen_1$s = codegen;
const names_1$6 = names$1;
const boolError = {
  message: "boolean schema is false"
};
function topBoolOrEmptySchema(it) {
  const { gen, schema: schema2, validateName } = it;
  if (schema2 === false) {
    falseSchemaError(it, false);
  } else if (typeof schema2 == "object" && schema2.$async === true) {
    gen.return(names_1$6.default.data);
  } else {
    gen.assign(codegen_1$s._`${validateName}.errors`, null);
    gen.return(true);
  }
}
boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
function boolOrEmptySchema(it, valid2) {
  const { gen, schema: schema2 } = it;
  if (schema2 === false) {
    gen.var(valid2, false);
    falseSchemaError(it);
  } else {
    gen.var(valid2, true);
  }
}
boolSchema.boolOrEmptySchema = boolOrEmptySchema;
function falseSchemaError(it, overrideAllErrors) {
  const { gen, data } = it;
  const cxt = {
    gen,
    keyword: "false schema",
    data,
    schema: false,
    schemaCode: false,
    schemaValue: false,
    params: {},
    it
  };
  errors_1$2.reportError(cxt, boolError, void 0, overrideAllErrors);
}
var dataType = {};
var rules = {};
Object.defineProperty(rules, "__esModule", { value: true });
rules.getRules = rules.isJSONType = void 0;
const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
const jsonTypes = new Set(_jsonTypes);
function isJSONType(x) {
  return typeof x == "string" && jsonTypes.has(x);
}
rules.isJSONType = isJSONType;
function getRules() {
  const groups = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: __spreadProps(__spreadValues({}, groups), { integer: true, boolean: true, null: true }),
    rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
rules.getRules = getRules;
var applicability = {};
Object.defineProperty(applicability, "__esModule", { value: true });
applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
function schemaHasRulesForType({ schema: schema2, self: self2 }, type2) {
  const group = self2.RULES.types[type2];
  return group && group !== true && shouldUseGroup(schema2, group);
}
applicability.schemaHasRulesForType = schemaHasRulesForType;
function shouldUseGroup(schema2, group) {
  return group.rules.some((rule) => shouldUseRule(schema2, rule));
}
applicability.shouldUseGroup = shouldUseGroup;
function shouldUseRule(schema2, rule) {
  var _a;
  return schema2[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema2[kwd] !== void 0));
}
applicability.shouldUseRule = shouldUseRule;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
  const rules_1 = rules;
  const applicability_12 = applicability;
  const errors_12 = errors;
  const codegen_12 = codegen;
  const util_12 = util;
  var DataType;
  (function(DataType2) {
    DataType2[DataType2["Correct"] = 0] = "Correct";
    DataType2[DataType2["Wrong"] = 1] = "Wrong";
  })(DataType = exports.DataType || (exports.DataType = {}));
  function getSchemaTypes(schema2) {
    const types2 = getJSONTypes(schema2.type);
    const hasNull = types2.includes("null");
    if (hasNull) {
      if (schema2.nullable === false)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!types2.length && schema2.nullable !== void 0) {
        throw new Error('"nullable" cannot be used without "type"');
      }
      if (schema2.nullable === true)
        types2.push("null");
    }
    return types2;
  }
  exports.getSchemaTypes = getSchemaTypes;
  function getJSONTypes(ts) {
    const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
    if (types2.every(rules_1.isJSONType))
      return types2;
    throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
  }
  exports.getJSONTypes = getJSONTypes;
  function coerceAndCheckDataType(it, types2) {
    const { gen, data, opts: opts2 } = it;
    const coerceTo = coerceToTypes(types2, opts2.coerceTypes);
    const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && applicability_12.schemaHasRulesForType(it, types2[0]));
    if (checkTypes) {
      const wrongType = checkDataTypes(types2, data, opts2.strictNumbers, DataType.Wrong);
      gen.if(wrongType, () => {
        if (coerceTo.length)
          coerceData(it, types2, coerceTo);
        else
          reportTypeError(it);
      });
    }
    return checkTypes;
  }
  exports.coerceAndCheckDataType = coerceAndCheckDataType;
  const COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
  function coerceToTypes(types2, coerceTypes) {
    return coerceTypes ? types2.filter((t2) => COERCIBLE.has(t2) || coerceTypes === "array" && t2 === "array") : [];
  }
  function coerceData(it, types2, coerceTo) {
    const { gen, data, opts: opts2 } = it;
    const dataType2 = gen.let("dataType", codegen_12._`typeof ${data}`);
    const coerced = gen.let("coerced", codegen_12._`undefined`);
    if (opts2.coerceTypes === "array") {
      gen.if(codegen_12._`${dataType2} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, codegen_12._`${data}[0]`).assign(dataType2, codegen_12._`typeof ${data}`).if(checkDataTypes(types2, data, opts2.strictNumbers), () => gen.assign(coerced, data)));
    }
    gen.if(codegen_12._`${coerced} !== undefined`);
    for (const t2 of coerceTo) {
      if (COERCIBLE.has(t2) || t2 === "array" && opts2.coerceTypes === "array") {
        coerceSpecificType(t2);
      }
    }
    gen.else();
    reportTypeError(it);
    gen.endIf();
    gen.if(codegen_12._`${coerced} !== undefined`, () => {
      gen.assign(data, coerced);
      assignParentData(it, coerced);
    });
    function coerceSpecificType(t2) {
      switch (t2) {
        case "string":
          gen.elseIf(codegen_12._`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, codegen_12._`"" + ${data}`).elseIf(codegen_12._`${data} === null`).assign(coerced, codegen_12._`""`);
          return;
        case "number":
          gen.elseIf(codegen_12._`${dataType2} == "boolean" || ${data} === null
              || (${dataType2} == "string" && ${data} && ${data} == +${data})`).assign(coerced, codegen_12._`+${data}`);
          return;
        case "integer":
          gen.elseIf(codegen_12._`${dataType2} === "boolean" || ${data} === null
              || (${dataType2} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, codegen_12._`+${data}`);
          return;
        case "boolean":
          gen.elseIf(codegen_12._`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf(codegen_12._`${data} === "true" || ${data} === 1`).assign(coerced, true);
          return;
        case "null":
          gen.elseIf(codegen_12._`${data} === "" || ${data} === 0 || ${data} === false`);
          gen.assign(coerced, null);
          return;
        case "array":
          gen.elseIf(codegen_12._`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data} === null`).assign(coerced, codegen_12._`[${data}]`);
      }
    }
  }
  function assignParentData({ gen, parentData, parentDataProperty }, expr) {
    gen.if(codegen_12._`${parentData} !== undefined`, () => gen.assign(codegen_12._`${parentData}[${parentDataProperty}]`, expr));
  }
  function checkDataType(dataType2, data, strictNums, correct = DataType.Correct) {
    const EQ = correct === DataType.Correct ? codegen_12.operators.EQ : codegen_12.operators.NEQ;
    let cond;
    switch (dataType2) {
      case "null":
        return codegen_12._`${data} ${EQ} null`;
      case "array":
        cond = codegen_12._`Array.isArray(${data})`;
        break;
      case "object":
        cond = codegen_12._`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
        break;
      case "integer":
        cond = numCond(codegen_12._`!(${data} % 1) && !isNaN(${data})`);
        break;
      case "number":
        cond = numCond();
        break;
      default:
        return codegen_12._`typeof ${data} ${EQ} ${dataType2}`;
    }
    return correct === DataType.Correct ? cond : codegen_12.not(cond);
    function numCond(_cond = codegen_12.nil) {
      return codegen_12.and(codegen_12._`typeof ${data} == "number"`, _cond, strictNums ? codegen_12._`isFinite(${data})` : codegen_12.nil);
    }
  }
  exports.checkDataType = checkDataType;
  function checkDataTypes(dataTypes, data, strictNums, correct) {
    if (dataTypes.length === 1) {
      return checkDataType(dataTypes[0], data, strictNums, correct);
    }
    let cond;
    const types2 = util_12.toHash(dataTypes);
    if (types2.array && types2.object) {
      const notObj = codegen_12._`typeof ${data} != "object"`;
      cond = types2.null ? notObj : codegen_12._`!${data} || ${notObj}`;
      delete types2.null;
      delete types2.array;
      delete types2.object;
    } else {
      cond = codegen_12.nil;
    }
    if (types2.number)
      delete types2.integer;
    for (const t2 in types2)
      cond = codegen_12.and(cond, checkDataType(t2, data, strictNums, correct));
    return cond;
  }
  exports.checkDataTypes = checkDataTypes;
  const typeError = {
    message: ({ schema: schema2 }) => `must be ${schema2}`,
    params: ({ schema: schema2, schemaValue }) => typeof schema2 == "string" ? codegen_12._`{type: ${schema2}}` : codegen_12._`{type: ${schemaValue}}`
  };
  function reportTypeError(it) {
    const cxt = getTypeErrorContext(it);
    errors_12.reportError(cxt, typeError);
  }
  exports.reportTypeError = reportTypeError;
  function getTypeErrorContext(it) {
    const { gen, data, schema: schema2 } = it;
    const schemaCode = util_12.schemaRefOrVal(it, schema2, "type");
    return {
      gen,
      keyword: "type",
      data,
      schema: schema2.type,
      schemaCode,
      schemaValue: schemaCode,
      parentSchema: schema2,
      params: {},
      it
    };
  }
})(dataType);
var defaults = {};
Object.defineProperty(defaults, "__esModule", { value: true });
defaults.assignDefaults = void 0;
const codegen_1$r = codegen;
const util_1$o = util;
function assignDefaults(it, ty) {
  const { properties: properties2, items: items2 } = it.schema;
  if (ty === "object" && properties2) {
    for (const key in properties2) {
      assignDefault(it, key, properties2[key].default);
    }
  } else if (ty === "array" && Array.isArray(items2)) {
    items2.forEach((sch, i) => assignDefault(it, i, sch.default));
  }
}
defaults.assignDefaults = assignDefaults;
function assignDefault(it, prop, defaultValue) {
  const { gen, compositeRule, data, opts: opts2 } = it;
  if (defaultValue === void 0)
    return;
  const childData = codegen_1$r._`${data}${codegen_1$r.getProperty(prop)}`;
  if (compositeRule) {
    util_1$o.checkStrictMode(it, `default is ignored for: ${childData}`);
    return;
  }
  let condition = codegen_1$r._`${childData} === undefined`;
  if (opts2.useDefaults === "empty") {
    condition = codegen_1$r._`${condition} || ${childData} === null || ${childData} === ""`;
  }
  gen.if(condition, codegen_1$r._`${childData} = ${codegen_1$r.stringify(defaultValue)}`);
}
var keyword = {};
var code = {};
Object.defineProperty(code, "__esModule", { value: true });
code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
const codegen_1$q = codegen;
const util_1$n = util;
const names_1$5 = names$1;
function checkReportMissingProp(cxt, prop) {
  const { gen, data, it } = cxt;
  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
    cxt.setParams({ missingProperty: codegen_1$q._`${prop}` }, true);
    cxt.error();
  });
}
code.checkReportMissingProp = checkReportMissingProp;
function checkMissingProp({ gen, data, it: { opts: opts2 } }, properties2, missing) {
  return codegen_1$q.or(...properties2.map((prop) => codegen_1$q.and(noPropertyInData(gen, data, prop, opts2.ownProperties), codegen_1$q._`${missing} = ${prop}`)));
}
code.checkMissingProp = checkMissingProp;
function reportMissingProp(cxt, missing) {
  cxt.setParams({ missingProperty: missing }, true);
  cxt.error();
}
code.reportMissingProp = reportMissingProp;
function hasPropFunc(gen) {
  return gen.scopeValue("func", {
    ref: Object.prototype.hasOwnProperty,
    code: codegen_1$q._`Object.prototype.hasOwnProperty`
  });
}
code.hasPropFunc = hasPropFunc;
function isOwnProperty(gen, data, property) {
  return codegen_1$q._`${hasPropFunc(gen)}.call(${data}, ${property})`;
}
code.isOwnProperty = isOwnProperty;
function propertyInData(gen, data, property, ownProperties) {
  const cond = codegen_1$q._`${data}${codegen_1$q.getProperty(property)} !== undefined`;
  return ownProperties ? codegen_1$q._`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
}
code.propertyInData = propertyInData;
function noPropertyInData(gen, data, property, ownProperties) {
  const cond = codegen_1$q._`${data}${codegen_1$q.getProperty(property)} === undefined`;
  return ownProperties ? codegen_1$q.or(cond, codegen_1$q.not(isOwnProperty(gen, data, property))) : cond;
}
code.noPropertyInData = noPropertyInData;
function allSchemaProperties(schemaMap) {
  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
}
code.allSchemaProperties = allSchemaProperties;
function schemaProperties(it, schemaMap) {
  return allSchemaProperties(schemaMap).filter((p) => !util_1$n.alwaysValidSchema(it, schemaMap[p]));
}
code.schemaProperties = schemaProperties;
function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
  const dataAndSchema = passSchema ? codegen_1$q._`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
  const valCxt = [
    [names_1$5.default.instancePath, codegen_1$q.strConcat(names_1$5.default.instancePath, errorPath)],
    [names_1$5.default.parentData, it.parentData],
    [names_1$5.default.parentDataProperty, it.parentDataProperty],
    [names_1$5.default.rootData, names_1$5.default.rootData]
  ];
  if (it.opts.dynamicRef)
    valCxt.push([names_1$5.default.dynamicAnchors, names_1$5.default.dynamicAnchors]);
  const args = codegen_1$q._`${dataAndSchema}, ${gen.object(...valCxt)}`;
  return context !== codegen_1$q.nil ? codegen_1$q._`${func}.call(${context}, ${args})` : codegen_1$q._`${func}(${args})`;
}
code.callValidateCode = callValidateCode;
function usePattern({ gen, it: { opts: opts2 } }, pattern2) {
  const u2 = opts2.unicodeRegExp ? "u" : "";
  return gen.scopeValue("pattern", {
    key: pattern2,
    ref: new RegExp(pattern2, u2),
    code: codegen_1$q._`new RegExp(${pattern2}, ${u2})`
  });
}
code.usePattern = usePattern;
function validateArray(cxt) {
  const { gen, data, keyword: keyword2, it } = cxt;
  const valid2 = gen.name("valid");
  if (it.allErrors) {
    const validArr = gen.let("valid", true);
    validateItems(() => gen.assign(validArr, false));
    return validArr;
  }
  gen.var(valid2, true);
  validateItems(() => gen.break());
  return valid2;
  function validateItems(notValid) {
    const len = gen.const("len", codegen_1$q._`${data}.length`);
    gen.forRange("i", 0, len, (i) => {
      cxt.subschema({
        keyword: keyword2,
        dataProp: i,
        dataPropType: util_1$n.Type.Num
      }, valid2);
      gen.if(codegen_1$q.not(valid2), notValid);
    });
  }
}
code.validateArray = validateArray;
function validateUnion(cxt) {
  const { gen, schema: schema2, keyword: keyword2, it } = cxt;
  if (!Array.isArray(schema2))
    throw new Error("ajv implementation error");
  const alwaysValid = schema2.some((sch) => util_1$n.alwaysValidSchema(it, sch));
  if (alwaysValid && !it.opts.unevaluated)
    return;
  const valid2 = gen.let("valid", false);
  const schValid = gen.name("_valid");
  gen.block(() => schema2.forEach((_sch, i) => {
    const schCxt = cxt.subschema({
      keyword: keyword2,
      schemaProp: i,
      compositeRule: true
    }, schValid);
    gen.assign(valid2, codegen_1$q._`${valid2} || ${schValid}`);
    const merged = cxt.mergeValidEvaluated(schCxt, schValid);
    if (!merged)
      gen.if(codegen_1$q.not(valid2));
  }));
  cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
}
code.validateUnion = validateUnion;
Object.defineProperty(keyword, "__esModule", { value: true });
keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
const codegen_1$p = codegen;
const names_1$4 = names$1;
const code_1$9 = code;
const errors_1$1 = errors;
function macroKeywordCode(cxt, def2) {
  const { gen, keyword: keyword2, schema: schema2, parentSchema, it } = cxt;
  const macroSchema = def2.macro.call(it.self, schema2, parentSchema, it);
  const schemaRef = useKeyword(gen, keyword2, macroSchema);
  if (it.opts.validateSchema !== false)
    it.self.validateSchema(macroSchema, true);
  const valid2 = gen.name("valid");
  cxt.subschema({
    schema: macroSchema,
    schemaPath: codegen_1$p.nil,
    errSchemaPath: `${it.errSchemaPath}/${keyword2}`,
    topSchemaRef: schemaRef,
    compositeRule: true
  }, valid2);
  cxt.pass(valid2, () => cxt.error(true));
}
keyword.macroKeywordCode = macroKeywordCode;
function funcKeywordCode(cxt, def2) {
  var _a;
  const { gen, keyword: keyword2, schema: schema2, parentSchema, $data, it } = cxt;
  checkAsyncKeyword(it, def2);
  const validate2 = !$data && def2.compile ? def2.compile.call(it.self, schema2, parentSchema, it) : def2.validate;
  const validateRef = useKeyword(gen, keyword2, validate2);
  const valid2 = gen.let("valid");
  cxt.block$data(valid2, validateKeyword);
  cxt.ok((_a = def2.valid) !== null && _a !== void 0 ? _a : valid2);
  function validateKeyword() {
    if (def2.errors === false) {
      assignValid();
      if (def2.modifying)
        modifyData(cxt);
      reportErrs(() => cxt.error());
    } else {
      const ruleErrs = def2.async ? validateAsync() : validateSync();
      if (def2.modifying)
        modifyData(cxt);
      reportErrs(() => addErrs(cxt, ruleErrs));
    }
  }
  function validateAsync() {
    const ruleErrs = gen.let("ruleErrs", null);
    gen.try(() => assignValid(codegen_1$p._`await `), (e) => gen.assign(valid2, false).if(codegen_1$p._`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, codegen_1$p._`${e}.errors`), () => gen.throw(e)));
    return ruleErrs;
  }
  function validateSync() {
    const validateErrs = codegen_1$p._`${validateRef}.errors`;
    gen.assign(validateErrs, null);
    assignValid(codegen_1$p.nil);
    return validateErrs;
  }
  function assignValid(_await = def2.async ? codegen_1$p._`await ` : codegen_1$p.nil) {
    const passCxt = it.opts.passContext ? names_1$4.default.this : names_1$4.default.self;
    const passSchema = !("compile" in def2 && !$data || def2.schema === false);
    gen.assign(valid2, codegen_1$p._`${_await}${code_1$9.callValidateCode(cxt, validateRef, passCxt, passSchema)}`, def2.modifying);
  }
  function reportErrs(errors2) {
    var _a2;
    gen.if(codegen_1$p.not((_a2 = def2.valid) !== null && _a2 !== void 0 ? _a2 : valid2), errors2);
  }
}
keyword.funcKeywordCode = funcKeywordCode;
function modifyData(cxt) {
  const { gen, data, it } = cxt;
  gen.if(it.parentData, () => gen.assign(data, codegen_1$p._`${it.parentData}[${it.parentDataProperty}]`));
}
function addErrs(cxt, errs) {
  const { gen } = cxt;
  gen.if(codegen_1$p._`Array.isArray(${errs})`, () => {
    gen.assign(names_1$4.default.vErrors, codegen_1$p._`${names_1$4.default.vErrors} === null ? ${errs} : ${names_1$4.default.vErrors}.concat(${errs})`).assign(names_1$4.default.errors, codegen_1$p._`${names_1$4.default.vErrors}.length`);
    errors_1$1.extendErrors(cxt);
  }, () => cxt.error());
}
function checkAsyncKeyword({ schemaEnv }, def2) {
  if (def2.async && !schemaEnv.$async)
    throw new Error("async keyword in sync schema");
}
function useKeyword(gen, keyword2, result) {
  if (result === void 0)
    throw new Error(`keyword "${keyword2}" failed to compile`);
  return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: codegen_1$p.stringify(result) });
}
function validSchemaType(schema2, schemaType, allowUndefined = false) {
  return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema2) : st === "object" ? schema2 && typeof schema2 == "object" && !Array.isArray(schema2) : typeof schema2 == st || allowUndefined && typeof schema2 == "undefined");
}
keyword.validSchemaType = validSchemaType;
function validateKeywordUsage({ schema: schema2, opts: opts2, self: self2, errSchemaPath }, def2, keyword2) {
  if (Array.isArray(def2.keyword) ? !def2.keyword.includes(keyword2) : def2.keyword !== keyword2) {
    throw new Error("ajv implementation error");
  }
  const deps = def2.dependencies;
  if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema2, kwd))) {
    throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
  }
  if (def2.validateSchema) {
    const valid2 = def2.validateSchema(schema2[keyword2]);
    if (!valid2) {
      const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def2.validateSchema.errors);
      if (opts2.validateSchema === "log")
        self2.logger.error(msg);
      else
        throw new Error(msg);
    }
  }
}
keyword.validateKeywordUsage = validateKeywordUsage;
var subschema = {};
Object.defineProperty(subschema, "__esModule", { value: true });
subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
const codegen_1$o = codegen;
const util_1$m = util;
function getSubschema(it, { keyword: keyword2, schemaProp, schema: schema2, schemaPath, errSchemaPath, topSchemaRef }) {
  if (keyword2 !== void 0 && schema2 !== void 0) {
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  }
  if (keyword2 !== void 0) {
    const sch = it.schema[keyword2];
    return schemaProp === void 0 ? {
      schema: sch,
      schemaPath: codegen_1$o._`${it.schemaPath}${codegen_1$o.getProperty(keyword2)}`,
      errSchemaPath: `${it.errSchemaPath}/${keyword2}`
    } : {
      schema: sch[schemaProp],
      schemaPath: codegen_1$o._`${it.schemaPath}${codegen_1$o.getProperty(keyword2)}${codegen_1$o.getProperty(schemaProp)}`,
      errSchemaPath: `${it.errSchemaPath}/${keyword2}/${util_1$m.escapeFragment(schemaProp)}`
    };
  }
  if (schema2 !== void 0) {
    if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    }
    return {
      schema: schema2,
      schemaPath,
      topSchemaRef,
      errSchemaPath
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
subschema.getSubschema = getSubschema;
function extendSubschemaData(subschema2, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
  if (data !== void 0 && dataProp !== void 0) {
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  }
  const { gen } = it;
  if (dataProp !== void 0) {
    const { errorPath, dataPathArr, opts: opts2 } = it;
    const nextData = gen.let("data", codegen_1$o._`${it.data}${codegen_1$o.getProperty(dataProp)}`, true);
    dataContextProps(nextData);
    subschema2.errorPath = codegen_1$o.str`${errorPath}${util_1$m.getErrorPath(dataProp, dpType, opts2.jsPropertySyntax)}`;
    subschema2.parentDataProperty = codegen_1$o._`${dataProp}`;
    subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
  }
  if (data !== void 0) {
    const nextData = data instanceof codegen_1$o.Name ? data : gen.let("data", data, true);
    dataContextProps(nextData);
    if (propertyName !== void 0)
      subschema2.propertyName = propertyName;
  }
  if (dataTypes)
    subschema2.dataTypes = dataTypes;
  function dataContextProps(_nextData) {
    subschema2.data = _nextData;
    subschema2.dataLevel = it.dataLevel + 1;
    subschema2.dataTypes = [];
    it.definedProperties = new Set();
    subschema2.parentData = it.data;
    subschema2.dataNames = [...it.dataNames, _nextData];
  }
}
subschema.extendSubschemaData = extendSubschemaData;
function extendSubschemaMode(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
  if (compositeRule !== void 0)
    subschema2.compositeRule = compositeRule;
  if (createErrors !== void 0)
    subschema2.createErrors = createErrors;
  if (allErrors !== void 0)
    subschema2.allErrors = allErrors;
  subschema2.jtdDiscriminator = jtdDiscriminator;
  subschema2.jtdMetadata = jtdMetadata;
}
subschema.extendSubschemaMode = extendSubschemaMode;
var resolve$1 = {};
var fastDeepEqual = function equal2(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    if (a.constructor !== b.constructor)
      return false;
    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!equal2(a[i], b[i]))
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
        return false;
    for (i = length; i-- !== 0; ) {
      var key = keys[i];
      if (!equal2(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
};
var jsonSchemaTraverse = { exports: {} };
var traverse$1 = jsonSchemaTraverse.exports = function(schema2, opts2, cb) {
  if (typeof opts2 == "function") {
    cb = opts2;
    opts2 = {};
  }
  cb = opts2.cb || cb;
  var pre = typeof cb == "function" ? cb : cb.pre || function() {
  };
  var post = cb.post || function() {
  };
  _traverse(opts2, pre, post, schema2, "", schema2);
};
traverse$1.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true,
  if: true,
  then: true,
  else: true
};
traverse$1.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};
traverse$1.propsKeywords = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};
traverse$1.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};
function _traverse(opts2, pre, post, schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema2 && typeof schema2 == "object" && !Array.isArray(schema2)) {
    pre(schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema2) {
      var sch = schema2[key];
      if (Array.isArray(sch)) {
        if (key in traverse$1.arrayKeywords) {
          for (var i = 0; i < sch.length; i++)
            _traverse(opts2, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema2, i);
        }
      } else if (key in traverse$1.propsKeywords) {
        if (sch && typeof sch == "object") {
          for (var prop in sch)
            _traverse(opts2, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema2, prop);
        }
      } else if (key in traverse$1.keywords || opts2.allKeys && !(key in traverse$1.skipKeywords)) {
        _traverse(opts2, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema2);
      }
    }
    post(schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}
function escapeJsonPtr(str) {
  return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
var uri_all = { exports: {} };
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function(module, exports) {
  (function(global2, factory) {
    factory(exports);
  })(commonjsGlobal, function(exports2) {
    function merge() {
      for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
        sets[_key] = arguments[_key];
      }
      if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
          sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join("");
      } else {
        return sets[0];
      }
    }
    function subexp(str) {
      return "(?:" + str + ")";
    }
    function typeOf(o) {
      return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
    }
    function toUpperCase(str) {
      return str.toUpperCase();
    }
    function toArray(obj) {
      return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
    }
    function assign(target, source2) {
      var obj = target;
      if (source2) {
        for (var key in source2) {
          obj[key] = source2[key];
        }
      }
      return obj;
    }
    function buildExps(isIRI) {
      var ALPHA$$ = "[A-Za-z]", DIGIT$$ = "[0-9]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$);
      subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*");
      subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*");
      var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+");
      subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+");
      subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*");
      var PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]"));
      subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+");
      subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*");
      return {
        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
      };
    }
    var URI_PROTOCOL = buildExps(false);
    var IRI_PROTOCOL = buildExps(true);
    var slicedToArray = function() {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"])
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    var toConsumableArray = function(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
          arr2[i] = arr[i];
        return arr2;
      } else {
        return Array.from(arr);
      }
    };
    var maxInt = 2147483647;
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter = "-";
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7E]/;
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    var errors2 = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    function error$12(type2) {
      throw new RangeError(errors2[type2]);
    }
    function map(array, fn) {
      var result = [];
      var length = array.length;
      while (length--) {
        result[length] = fn(array[length]);
      }
      return result;
    }
    function mapDomain(string, fn) {
      var parts = string.split("@");
      var result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string = parts[1];
      }
      string = string.replace(regexSeparators, ".");
      var labels = string.split(".");
      var encoded = map(labels, fn).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      var output2 = [];
      var counter = 0;
      var length = string.length;
      while (counter < length) {
        var value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          var extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output2.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output2.push(value);
            counter--;
          }
        } else {
          output2.push(value);
        }
      }
      return output2;
    }
    var ucs2encode = function ucs2encode2(array) {
      return String.fromCodePoint.apply(String, toConsumableArray(array));
    };
    var basicToDigit = function basicToDigit2(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    };
    var digitToBasic = function digitToBasic2(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    var adapt = function adapt2(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var decode = function decode2(input) {
      var output2 = [];
      var inputLength = input.length;
      var i = 0;
      var n = initialN;
      var bias = initialBias;
      var basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (var j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error$12("not-basic");
        }
        output2.push(input.charCodeAt(j));
      }
      for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        var oldi = i;
        for (var w = 1, k = base; ; k += base) {
          if (index >= inputLength) {
            error$12("invalid-input");
          }
          var digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base || digit > floor((maxInt - i) / w)) {
            error$12("overflow");
          }
          i += digit * w;
          var t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t2) {
            break;
          }
          var baseMinusT = base - t2;
          if (w > floor(maxInt / baseMinusT)) {
            error$12("overflow");
          }
          w *= baseMinusT;
        }
        var out = output2.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error$12("overflow");
        }
        n += floor(i / out);
        i %= out;
        output2.splice(i++, 0, n);
      }
      return String.fromCodePoint.apply(String, output2);
    };
    var encode = function encode2(input) {
      var output2 = [];
      input = ucs2decode(input);
      var inputLength = input.length;
      var n = initialN;
      var delta = 0;
      var bias = initialBias;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _currentValue2 = _step.value;
          if (_currentValue2 < 128) {
            output2.push(stringFromCharCode(_currentValue2));
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      var basicLength = output2.length;
      var handledCPCount = basicLength;
      if (basicLength) {
        output2.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        var m = maxInt;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = void 0;
        try {
          for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var currentValue = _step2.value;
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
        var handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error$12("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = void 0;
        try {
          for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _currentValue = _step3.value;
            if (_currentValue < n && ++delta > maxInt) {
              error$12("overflow");
            }
            if (_currentValue == n) {
              var q = delta;
              for (var k = base; ; k += base) {
                var t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t2) {
                  break;
                }
                var qMinusT = q - t2;
                var baseMinusT = base - t2;
                output2.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
                q = floor(qMinusT / baseMinusT);
              }
              output2.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
        ++delta;
        ++n;
      }
      return output2.join("");
    };
    var toUnicode = function toUnicode2(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    var toASCII = function toASCII2(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    var punycode = {
      "version": "2.1.0",
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode,
      "encode": encode,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    var SCHEMES = {};
    function pctEncChar(chr) {
      var c = chr.charCodeAt(0);
      var e = void 0;
      if (c < 16)
        e = "%0" + c.toString(16).toUpperCase();
      else if (c < 128)
        e = "%" + c.toString(16).toUpperCase();
      else if (c < 2048)
        e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      else
        e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      return e;
    }
    function pctDecChars(str) {
      var newStr = "";
      var i = 0;
      var il = str.length;
      while (i < il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
          newStr += String.fromCharCode(c);
          i += 3;
        } else if (c >= 194 && c < 224) {
          if (il - i >= 6) {
            var c2 = parseInt(str.substr(i + 4, 2), 16);
            newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
          } else {
            newStr += str.substr(i, 6);
          }
          i += 6;
        } else if (c >= 224) {
          if (il - i >= 9) {
            var _c = parseInt(str.substr(i + 4, 2), 16);
            var c3 = parseInt(str.substr(i + 7, 2), 16);
            newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
          } else {
            newStr += str.substr(i, 9);
          }
          i += 9;
        } else {
          newStr += str.substr(i, 3);
          i += 3;
        }
      }
      return newStr;
    }
    function _normalizeComponentEncoding(components, protocol) {
      function decodeUnreserved2(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
      }
      if (components.scheme)
        components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
      if (components.userinfo !== void 0)
        components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.host !== void 0)
        components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.path !== void 0)
        components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.query !== void 0)
        components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.fragment !== void 0)
        components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      return components;
    }
    function _stripLeadingZeros(str) {
      return str.replace(/^0*(.*)/, "$1") || "0";
    }
    function _normalizeIPv4(host, protocol) {
      var matches = host.match(protocol.IPV4ADDRESS) || [];
      var _matches = slicedToArray(matches, 2), address = _matches[1];
      if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
      } else {
        return host;
      }
    }
    function _normalizeIPv6(host, protocol) {
      var matches = host.match(protocol.IPV6ADDRESS) || [];
      var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
      if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
          fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
        }
        if (isLastFieldIPv4Address) {
          fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function(acc, field, index) {
          if (!field || field === "0") {
            var lastLongest = acc[acc.length - 1];
            if (lastLongest && lastLongest.index + lastLongest.length === index) {
              lastLongest.length++;
            } else {
              acc.push({ index, length: 1 });
            }
          }
          return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function(a, b) {
          return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
          var newFirst = fields.slice(0, longestZeroFields.index);
          var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
          newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
          newHost = fields.join(":");
        }
        if (zone) {
          newHost += "%" + zone;
        }
        return newHost;
      } else {
        return host;
      }
    }
    var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
    var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
    function parse2(uriString) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var components = {};
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      if (options.reference === "suffix")
        uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
      var matches = uriString.match(URI_PARSE);
      if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
          components.scheme = matches[1];
          components.userinfo = matches[3];
          components.host = matches[4];
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = matches[7];
          components.fragment = matches[8];
          if (isNaN(components.port)) {
            components.port = matches[5];
          }
        } else {
          components.scheme = matches[1] || void 0;
          components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
          components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
          components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
          if (isNaN(components.port)) {
            components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
          }
        }
        if (components.host) {
          components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
          components.reference = "same-document";
        } else if (components.scheme === void 0) {
          components.reference = "relative";
        } else if (components.fragment === void 0) {
          components.reference = "absolute";
        } else {
          components.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
          components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
            try {
              components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
            }
          }
          _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
          _normalizeComponentEncoding(components, protocol);
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(components, options);
        }
      } else {
        components.error = components.error || "URI can not be parsed.";
      }
      return components;
    }
    function _recomposeAuthority(components, options) {
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
          return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    var RDS1 = /^\.\.?\//;
    var RDS2 = /^\/\.(\/|$)/;
    var RDS3 = /^\/\.\.(\/|$)/;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
    function removeDotSegments(input) {
      var output2 = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output2.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          var im = input.match(RDS5);
          if (im) {
            var s = im[0];
            input = input.slice(s.length);
            output2.push(s);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output2.join("");
    }
    function serialize(components) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize)
        schemeHandler.serialize(components, options);
      if (components.host) {
        if (protocol.IPV6ADDRESS.test(components.host))
          ;
        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
          try {
            components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
          } catch (e) {
            components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
          }
        }
      }
      _normalizeComponentEncoding(components, protocol);
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
      }
      var authority = _recomposeAuthority(components, options);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        var s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0) {
          s = s.replace(/^\/\//, "/%2F");
        }
        uriTokens.push(s);
      }
      if (components.query !== void 0) {
        uriTokens.push("?");
        uriTokens.push(components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
      }
      return uriTokens.join("");
    }
    function resolveComponents(base2, relative) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var skipNormalization = arguments[3];
      var target = {};
      if (!skipNormalization) {
        base2 = parse2(serialize(base2, options), options);
        relative = parse2(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base2.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base2.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                target.path = "/" + relative.path;
              } else if (!base2.path) {
                target.path = relative.path;
              } else {
                target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base2.userinfo;
          target.host = base2.host;
          target.port = base2.port;
        }
        target.scheme = base2.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function resolve2(baseURI, relativeURI, options) {
      var schemelessOptions = assign({ scheme: "null" }, options);
      return serialize(resolveComponents(parse2(baseURI, schemelessOptions), parse2(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
    }
    function normalize(uri, options) {
      if (typeof uri === "string") {
        uri = serialize(parse2(uri, options), options);
      } else if (typeOf(uri) === "object") {
        uri = parse2(serialize(uri, options), options);
      }
      return uri;
    }
    function equal3(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = serialize(parse2(uriA, options), options);
      } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
      }
      if (typeof uriB === "string") {
        uriB = serialize(parse2(uriB, options), options);
      } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
      }
      return uriA === uriB;
    }
    function escapeComponent(str, options) {
      return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
    }
    function unescapeComponent(str, options) {
      return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
    }
    var handler = {
      scheme: "http",
      domainHost: true,
      parse: function parse3(components, options) {
        if (!components.host) {
          components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
      },
      serialize: function serialize2(components, options) {
        var secure = String(components.scheme).toLowerCase() === "https";
        if (components.port === (secure ? 443 : 80) || components.port === "") {
          components.port = void 0;
        }
        if (!components.path) {
          components.path = "/";
        }
        return components;
      }
    };
    var handler$1 = {
      scheme: "https",
      domainHost: handler.domainHost,
      parse: handler.parse,
      serialize: handler.serialize
    };
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    var handler$2 = {
      scheme: "ws",
      domainHost: true,
      parse: function parse3(components, options) {
        var wsComponents = components;
        wsComponents.secure = isSecure(wsComponents);
        wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
        wsComponents.path = void 0;
        wsComponents.query = void 0;
        return wsComponents;
      },
      serialize: function serialize2(wsComponents, options) {
        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
          wsComponents.port = void 0;
        }
        if (typeof wsComponents.secure === "boolean") {
          wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
          wsComponents.secure = void 0;
        }
        if (wsComponents.resourceName) {
          var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path2 = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
          wsComponents.path = path2 && path2 !== "/" ? path2 : void 0;
          wsComponents.query = query;
          wsComponents.resourceName = void 0;
        }
        wsComponents.fragment = void 0;
        return wsComponents;
      }
    };
    var handler$3 = {
      scheme: "wss",
      domainHost: handler$2.domainHost,
      parse: handler$2.parse,
      serialize: handler$2.serialize
    };
    var O = {};
    var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]";
    var HEXDIG$$ = "[0-9A-Fa-f]";
    var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
    var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
    var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
    var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
    var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
    var UNRESERVED = new RegExp(UNRESERVED$$, "g");
    var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
    var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
    var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
    var NOT_HFVALUE = NOT_HFNAME;
    function decodeUnreserved(str) {
      var decStr = pctDecChars(str);
      return !decStr.match(UNRESERVED) ? str : decStr;
    }
    var handler$4 = {
      scheme: "mailto",
      parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = void 0;
        if (mailtoComponents.query) {
          var unknownHeaders = false;
          var headers = {};
          var hfields = mailtoComponents.query.split("&");
          for (var x = 0, xl = hfields.length; x < xl; ++x) {
            var hfield = hfields[x].split("=");
            switch (hfield[0]) {
              case "to":
                var toAddrs = hfield[1].split(",");
                for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                  to.push(toAddrs[_x]);
                }
                break;
              case "subject":
                mailtoComponents.subject = unescapeComponent(hfield[1], options);
                break;
              case "body":
                mailtoComponents.body = unescapeComponent(hfield[1], options);
                break;
              default:
                unknownHeaders = true;
                headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                break;
            }
          }
          if (unknownHeaders)
            mailtoComponents.headers = headers;
        }
        mailtoComponents.query = void 0;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
          var addr = to[_x2].split("@");
          addr[0] = unescapeComponent(addr[0]);
          if (!options.unicodeSupport) {
            try {
              addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
            } catch (e) {
              mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
            }
          } else {
            addr[1] = unescapeComponent(addr[1], options).toLowerCase();
          }
          to[_x2] = addr.join("@");
        }
        return mailtoComponents;
      },
      serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray(mailtoComponents.to);
        if (to) {
          for (var x = 0, xl = to.length; x < xl; ++x) {
            var toAddr = String(to[x]);
            var atIdx = toAddr.lastIndexOf("@");
            var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
            var domain = toAddr.slice(atIdx + 1);
            try {
              domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
            } catch (e) {
              components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
            to[x] = localPart + "@" + domain;
          }
          components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject)
          headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body)
          headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
          if (headers[name] !== O[name]) {
            fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
          }
        }
        if (fields.length) {
          components.query = fields.join("&");
        }
        return components;
      }
    };
    var URN_PARSE = /^([^\:]+)\:(.*)/;
    var handler$5 = {
      scheme: "urn",
      parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = matches[1].toLowerCase();
          var nss = matches[2];
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          urnComponents.nid = nid;
          urnComponents.nss = nss;
          urnComponents.path = void 0;
          if (schemeHandler) {
            urnComponents = schemeHandler.parse(urnComponents, options);
          }
        } else {
          urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
      },
      serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
          urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
      }
    };
    var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
    var handler$6 = {
      scheme: "urn:uuid",
      parse: function parse3(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = void 0;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
          uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
      },
      serialize: function serialize2(uuidComponents, options) {
        var urnComponents = uuidComponents;
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
      }
    };
    SCHEMES[handler.scheme] = handler;
    SCHEMES[handler$1.scheme] = handler$1;
    SCHEMES[handler$2.scheme] = handler$2;
    SCHEMES[handler$3.scheme] = handler$3;
    SCHEMES[handler$4.scheme] = handler$4;
    SCHEMES[handler$5.scheme] = handler$5;
    SCHEMES[handler$6.scheme] = handler$6;
    exports2.SCHEMES = SCHEMES;
    exports2.pctEncChar = pctEncChar;
    exports2.pctDecChars = pctDecChars;
    exports2.parse = parse2;
    exports2.removeDotSegments = removeDotSegments;
    exports2.serialize = serialize;
    exports2.resolveComponents = resolveComponents;
    exports2.resolve = resolve2;
    exports2.normalize = normalize;
    exports2.equal = equal3;
    exports2.escapeComponent = escapeComponent;
    exports2.unescapeComponent = unescapeComponent;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
})(uri_all, uri_all.exports);
Object.defineProperty(resolve$1, "__esModule", { value: true });
resolve$1.getSchemaRefs = resolve$1.resolveUrl = resolve$1.normalizeId = resolve$1._getFullPath = resolve$1.getFullPath = resolve$1.inlineRef = void 0;
const util_1$l = util;
const equal$2 = fastDeepEqual;
const traverse = jsonSchemaTraverse.exports;
const URI$1 = uri_all.exports;
const SIMPLE_INLINED = new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function inlineRef(schema2, limit2 = true) {
  if (typeof schema2 == "boolean")
    return true;
  if (limit2 === true)
    return !hasRef(schema2);
  if (!limit2)
    return false;
  return countKeys(schema2) <= limit2;
}
resolve$1.inlineRef = inlineRef;
const REF_KEYWORDS = new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function hasRef(schema2) {
  for (const key in schema2) {
    if (REF_KEYWORDS.has(key))
      return true;
    const sch = schema2[key];
    if (Array.isArray(sch) && sch.some(hasRef))
      return true;
    if (typeof sch == "object" && hasRef(sch))
      return true;
  }
  return false;
}
function countKeys(schema2) {
  let count = 0;
  for (const key in schema2) {
    if (key === "$ref")
      return Infinity;
    count++;
    if (SIMPLE_INLINED.has(key))
      continue;
    if (typeof schema2[key] == "object") {
      util_1$l.eachItem(schema2[key], (sch) => count += countKeys(sch));
    }
    if (count === Infinity)
      return Infinity;
  }
  return count;
}
function getFullPath(id2 = "", normalize) {
  if (normalize !== false)
    id2 = normalizeId(id2);
  const p = URI$1.parse(id2);
  return _getFullPath(p);
}
resolve$1.getFullPath = getFullPath;
function _getFullPath(p) {
  return URI$1.serialize(p).split("#")[0] + "#";
}
resolve$1._getFullPath = _getFullPath;
const TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id2) {
  return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
}
resolve$1.normalizeId = normalizeId;
function resolveUrl(baseId, id2) {
  id2 = normalizeId(id2);
  return URI$1.resolve(baseId, id2);
}
resolve$1.resolveUrl = resolveUrl;
const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
function getSchemaRefs(schema2) {
  if (typeof schema2 == "boolean")
    return {};
  const { schemaId } = this.opts;
  const schId = normalizeId(schema2[schemaId]);
  const baseIds = { "": schId };
  const pathPrefix = getFullPath(schId, false);
  const localRefs = {};
  const schemaRefs = new Set();
  traverse(schema2, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
    if (parentJsonPtr === void 0)
      return;
    const fullPath = pathPrefix + jsonPtr;
    let baseId = baseIds[parentJsonPtr];
    if (typeof sch[schemaId] == "string")
      baseId = addRef.call(this, sch[schemaId]);
    addAnchor.call(this, sch.$anchor);
    addAnchor.call(this, sch.$dynamicAnchor);
    baseIds[jsonPtr] = baseId;
    function addRef(ref2) {
      ref2 = normalizeId(baseId ? URI$1.resolve(baseId, ref2) : ref2);
      if (schemaRefs.has(ref2))
        throw ambiguos(ref2);
      schemaRefs.add(ref2);
      let schOrRef = this.refs[ref2];
      if (typeof schOrRef == "string")
        schOrRef = this.refs[schOrRef];
      if (typeof schOrRef == "object") {
        checkAmbiguosRef(sch, schOrRef.schema, ref2);
      } else if (ref2 !== normalizeId(fullPath)) {
        if (ref2[0] === "#") {
          checkAmbiguosRef(sch, localRefs[ref2], ref2);
          localRefs[ref2] = sch;
        } else {
          this.refs[ref2] = fullPath;
        }
      }
      return ref2;
    }
    function addAnchor(anchor) {
      if (typeof anchor == "string") {
        if (!ANCHOR.test(anchor))
          throw new Error(`invalid anchor "${anchor}"`);
        addRef.call(this, `#${anchor}`);
      }
    }
  });
  return localRefs;
  function checkAmbiguosRef(sch1, sch2, ref2) {
    if (sch2 !== void 0 && !equal$2(sch1, sch2))
      throw ambiguos(ref2);
  }
  function ambiguos(ref2) {
    return new Error(`reference "${ref2}" resolves to more than one schema`);
  }
}
resolve$1.getSchemaRefs = getSchemaRefs;
Object.defineProperty(validate, "__esModule", { value: true });
validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
const boolSchema_1 = boolSchema;
const dataType_1$1 = dataType;
const applicability_1 = applicability;
const dataType_2 = dataType;
const defaults_1 = defaults;
const keyword_1 = keyword;
const subschema_1 = subschema;
const codegen_1$n = codegen;
const names_1$3 = names$1;
const resolve_1$2 = resolve$1;
const util_1$k = util;
const errors_1 = errors;
function validateFunctionCode(it) {
  if (isSchemaObj(it)) {
    checkKeywords(it);
    if (schemaCxtHasRules(it)) {
      topSchemaObjCode(it);
      return;
    }
  }
  validateFunction(it, () => boolSchema_1.topBoolOrEmptySchema(it));
}
validate.validateFunctionCode = validateFunctionCode;
function validateFunction({ gen, validateName, schema: schema2, schemaEnv, opts: opts2 }, body) {
  if (opts2.code.es5) {
    gen.func(validateName, codegen_1$n._`${names_1$3.default.data}, ${names_1$3.default.valCxt}`, schemaEnv.$async, () => {
      gen.code(codegen_1$n._`"use strict"; ${funcSourceUrl(schema2, opts2)}`);
      destructureValCxtES5(gen, opts2);
      gen.code(body);
    });
  } else {
    gen.func(validateName, codegen_1$n._`${names_1$3.default.data}, ${destructureValCxt(opts2)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema2, opts2)).code(body));
  }
}
function destructureValCxt(opts2) {
  return codegen_1$n._`{${names_1$3.default.instancePath}="", ${names_1$3.default.parentData}, ${names_1$3.default.parentDataProperty}, ${names_1$3.default.rootData}=${names_1$3.default.data}${opts2.dynamicRef ? codegen_1$n._`, ${names_1$3.default.dynamicAnchors}={}` : codegen_1$n.nil}}={}`;
}
function destructureValCxtES5(gen, opts2) {
  gen.if(names_1$3.default.valCxt, () => {
    gen.var(names_1$3.default.instancePath, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.instancePath}`);
    gen.var(names_1$3.default.parentData, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.parentData}`);
    gen.var(names_1$3.default.parentDataProperty, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.parentDataProperty}`);
    gen.var(names_1$3.default.rootData, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.rootData}`);
    if (opts2.dynamicRef)
      gen.var(names_1$3.default.dynamicAnchors, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.dynamicAnchors}`);
  }, () => {
    gen.var(names_1$3.default.instancePath, codegen_1$n._`""`);
    gen.var(names_1$3.default.parentData, codegen_1$n._`undefined`);
    gen.var(names_1$3.default.parentDataProperty, codegen_1$n._`undefined`);
    gen.var(names_1$3.default.rootData, names_1$3.default.data);
    if (opts2.dynamicRef)
      gen.var(names_1$3.default.dynamicAnchors, codegen_1$n._`{}`);
  });
}
function topSchemaObjCode(it) {
  const { schema: schema2, opts: opts2, gen } = it;
  validateFunction(it, () => {
    if (opts2.$comment && schema2.$comment)
      commentKeyword(it);
    checkNoDefault(it);
    gen.let(names_1$3.default.vErrors, null);
    gen.let(names_1$3.default.errors, 0);
    if (opts2.unevaluated)
      resetEvaluated(it);
    typeAndKeywords(it);
    returnResults(it);
  });
  return;
}
function resetEvaluated(it) {
  const { gen, validateName } = it;
  it.evaluated = gen.const("evaluated", codegen_1$n._`${validateName}.evaluated`);
  gen.if(codegen_1$n._`${it.evaluated}.dynamicProps`, () => gen.assign(codegen_1$n._`${it.evaluated}.props`, codegen_1$n._`undefined`));
  gen.if(codegen_1$n._`${it.evaluated}.dynamicItems`, () => gen.assign(codegen_1$n._`${it.evaluated}.items`, codegen_1$n._`undefined`));
}
function funcSourceUrl(schema2, opts2) {
  const schId = typeof schema2 == "object" && schema2[opts2.schemaId];
  return schId && (opts2.code.source || opts2.code.process) ? codegen_1$n._`/*# sourceURL=${schId} */` : codegen_1$n.nil;
}
function subschemaCode(it, valid2) {
  if (isSchemaObj(it)) {
    checkKeywords(it);
    if (schemaCxtHasRules(it)) {
      subSchemaObjCode(it, valid2);
      return;
    }
  }
  boolSchema_1.boolOrEmptySchema(it, valid2);
}
function schemaCxtHasRules({ schema: schema2, self: self2 }) {
  if (typeof schema2 == "boolean")
    return !schema2;
  for (const key in schema2)
    if (self2.RULES.all[key])
      return true;
  return false;
}
function isSchemaObj(it) {
  return typeof it.schema != "boolean";
}
function subSchemaObjCode(it, valid2) {
  const { schema: schema2, gen, opts: opts2 } = it;
  if (opts2.$comment && schema2.$comment)
    commentKeyword(it);
  updateContext(it);
  checkAsyncSchema(it);
  const errsCount = gen.const("_errs", names_1$3.default.errors);
  typeAndKeywords(it, errsCount);
  gen.var(valid2, codegen_1$n._`${errsCount} === ${names_1$3.default.errors}`);
}
function checkKeywords(it) {
  util_1$k.checkUnknownRules(it);
  checkRefsAndKeywords(it);
}
function typeAndKeywords(it, errsCount) {
  if (it.opts.jtd)
    return schemaKeywords(it, [], false, errsCount);
  const types2 = dataType_1$1.getSchemaTypes(it.schema);
  const checkedTypes = dataType_1$1.coerceAndCheckDataType(it, types2);
  schemaKeywords(it, types2, !checkedTypes, errsCount);
}
function checkRefsAndKeywords(it) {
  const { schema: schema2, errSchemaPath, opts: opts2, self: self2 } = it;
  if (schema2.$ref && opts2.ignoreKeywordsWithRef && util_1$k.schemaHasRulesButRef(schema2, self2.RULES)) {
    self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
  }
}
function checkNoDefault(it) {
  const { schema: schema2, opts: opts2 } = it;
  if (schema2.default !== void 0 && opts2.useDefaults && opts2.strictSchema) {
    util_1$k.checkStrictMode(it, "default is ignored in the schema root");
  }
}
function updateContext(it) {
  const schId = it.schema[it.opts.schemaId];
  if (schId)
    it.baseId = resolve_1$2.resolveUrl(it.baseId, schId);
}
function checkAsyncSchema(it) {
  if (it.schema.$async && !it.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function commentKeyword({ gen, schemaEnv, schema: schema2, errSchemaPath, opts: opts2 }) {
  const msg = schema2.$comment;
  if (opts2.$comment === true) {
    gen.code(codegen_1$n._`${names_1$3.default.self}.logger.log(${msg})`);
  } else if (typeof opts2.$comment == "function") {
    const schemaPath = codegen_1$n.str`${errSchemaPath}/$comment`;
    const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
    gen.code(codegen_1$n._`${names_1$3.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
  }
}
function returnResults(it) {
  const { gen, schemaEnv, validateName, ValidationError: ValidationError2, opts: opts2 } = it;
  if (schemaEnv.$async) {
    gen.if(codegen_1$n._`${names_1$3.default.errors} === 0`, () => gen.return(names_1$3.default.data), () => gen.throw(codegen_1$n._`new ${ValidationError2}(${names_1$3.default.vErrors})`));
  } else {
    gen.assign(codegen_1$n._`${validateName}.errors`, names_1$3.default.vErrors);
    if (opts2.unevaluated)
      assignEvaluated(it);
    gen.return(codegen_1$n._`${names_1$3.default.errors} === 0`);
  }
}
function assignEvaluated({ gen, evaluated, props, items: items2 }) {
  if (props instanceof codegen_1$n.Name)
    gen.assign(codegen_1$n._`${evaluated}.props`, props);
  if (items2 instanceof codegen_1$n.Name)
    gen.assign(codegen_1$n._`${evaluated}.items`, items2);
}
function schemaKeywords(it, types2, typeErrors, errsCount) {
  const { gen, schema: schema2, data, allErrors, opts: opts2, self: self2 } = it;
  const { RULES } = self2;
  if (schema2.$ref && (opts2.ignoreKeywordsWithRef || !util_1$k.schemaHasRulesButRef(schema2, RULES))) {
    gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
    return;
  }
  if (!opts2.jtd)
    checkStrictTypes(it, types2);
  gen.block(() => {
    for (const group of RULES.rules)
      groupKeywords(group);
    groupKeywords(RULES.post);
  });
  function groupKeywords(group) {
    if (!applicability_1.shouldUseGroup(schema2, group))
      return;
    if (group.type) {
      gen.if(dataType_2.checkDataType(group.type, data, opts2.strictNumbers));
      iterateKeywords(it, group);
      if (types2.length === 1 && types2[0] === group.type && typeErrors) {
        gen.else();
        dataType_2.reportTypeError(it);
      }
      gen.endIf();
    } else {
      iterateKeywords(it, group);
    }
    if (!allErrors)
      gen.if(codegen_1$n._`${names_1$3.default.errors} === ${errsCount || 0}`);
  }
}
function iterateKeywords(it, group) {
  const { gen, schema: schema2, opts: { useDefaults } } = it;
  if (useDefaults)
    defaults_1.assignDefaults(it, group.type);
  gen.block(() => {
    for (const rule of group.rules) {
      if (applicability_1.shouldUseRule(schema2, rule)) {
        keywordCode(it, rule.keyword, rule.definition, group.type);
      }
    }
  });
}
function checkStrictTypes(it, types2) {
  if (it.schemaEnv.meta || !it.opts.strictTypes)
    return;
  checkContextTypes(it, types2);
  if (!it.opts.allowUnionTypes)
    checkMultipleTypes(it, types2);
  checkKeywordTypes(it, it.dataTypes);
}
function checkContextTypes(it, types2) {
  if (!types2.length)
    return;
  if (!it.dataTypes.length) {
    it.dataTypes = types2;
    return;
  }
  types2.forEach((t2) => {
    if (!includesType(it.dataTypes, t2)) {
      strictTypesError(it, `type "${t2}" not allowed by context "${it.dataTypes.join(",")}"`);
    }
  });
  it.dataTypes = it.dataTypes.filter((t2) => includesType(types2, t2));
}
function checkMultipleTypes(it, ts) {
  if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
    strictTypesError(it, "use allowUnionTypes to allow union type keyword");
  }
}
function checkKeywordTypes(it, ts) {
  const rules2 = it.self.RULES.all;
  for (const keyword2 in rules2) {
    const rule = rules2[keyword2];
    if (typeof rule == "object" && applicability_1.shouldUseRule(it.schema, rule)) {
      const { type: type2 } = rule.definition;
      if (type2.length && !type2.some((t2) => hasApplicableType(ts, t2))) {
        strictTypesError(it, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
      }
    }
  }
}
function hasApplicableType(schTs, kwdT) {
  return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
}
function includesType(ts, t2) {
  return ts.includes(t2) || t2 === "integer" && ts.includes("number");
}
function strictTypesError(it, msg) {
  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
  msg += ` at "${schemaPath}" (strictTypes)`;
  util_1$k.checkStrictMode(it, msg, it.opts.strictTypes);
}
class KeywordCxt {
  constructor(it, def2, keyword2) {
    keyword_1.validateKeywordUsage(it, def2, keyword2);
    this.gen = it.gen;
    this.allErrors = it.allErrors;
    this.keyword = keyword2;
    this.data = it.data;
    this.schema = it.schema[keyword2];
    this.$data = def2.$data && it.opts.$data && this.schema && this.schema.$data;
    this.schemaValue = util_1$k.schemaRefOrVal(it, this.schema, keyword2, this.$data);
    this.schemaType = def2.schemaType;
    this.parentSchema = it.schema;
    this.params = {};
    this.it = it;
    this.def = def2;
    if (this.$data) {
      this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
    } else {
      this.schemaCode = this.schemaValue;
      if (!keyword_1.validSchemaType(this.schema, def2.schemaType, def2.allowUndefined)) {
        throw new Error(`${keyword2} value must be ${JSON.stringify(def2.schemaType)}`);
      }
    }
    if ("code" in def2 ? def2.trackErrors : def2.errors !== false) {
      this.errsCount = it.gen.const("_errs", names_1$3.default.errors);
    }
  }
  result(condition, successAction, failAction) {
    this.failResult(codegen_1$n.not(condition), successAction, failAction);
  }
  failResult(condition, successAction, failAction) {
    this.gen.if(condition);
    if (failAction)
      failAction();
    else
      this.error();
    if (successAction) {
      this.gen.else();
      successAction();
      if (this.allErrors)
        this.gen.endIf();
    } else {
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
  }
  pass(condition, failAction) {
    this.failResult(codegen_1$n.not(condition), void 0, failAction);
  }
  fail(condition) {
    if (condition === void 0) {
      this.error();
      if (!this.allErrors)
        this.gen.if(false);
      return;
    }
    this.gen.if(condition);
    this.error();
    if (this.allErrors)
      this.gen.endIf();
    else
      this.gen.else();
  }
  fail$data(condition) {
    if (!this.$data)
      return this.fail(condition);
    const { schemaCode } = this;
    this.fail(codegen_1$n._`${schemaCode} !== undefined && (${codegen_1$n.or(this.invalid$data(), condition)})`);
  }
  error(append, errorParams, errorPaths) {
    if (errorParams) {
      this.setParams(errorParams);
      this._error(append, errorPaths);
      this.setParams({});
      return;
    }
    this._error(append, errorPaths);
  }
  _error(append, errorPaths) {
    (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
  }
  $dataError() {
    errors_1.reportError(this, this.def.$dataError || errors_1.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    errors_1.resetErrorsCount(this.gen, this.errsCount);
  }
  ok(cond) {
    if (!this.allErrors)
      this.gen.if(cond);
  }
  setParams(obj, assign) {
    if (assign)
      Object.assign(this.params, obj);
    else
      this.params = obj;
  }
  block$data(valid2, codeBlock, $dataValid = codegen_1$n.nil) {
    this.gen.block(() => {
      this.check$data(valid2, $dataValid);
      codeBlock();
    });
  }
  check$data(valid2 = codegen_1$n.nil, $dataValid = codegen_1$n.nil) {
    if (!this.$data)
      return;
    const { gen, schemaCode, schemaType, def: def2 } = this;
    gen.if(codegen_1$n.or(codegen_1$n._`${schemaCode} === undefined`, $dataValid));
    if (valid2 !== codegen_1$n.nil)
      gen.assign(valid2, true);
    if (schemaType.length || def2.validateSchema) {
      gen.elseIf(this.invalid$data());
      this.$dataError();
      if (valid2 !== codegen_1$n.nil)
        gen.assign(valid2, false);
    }
    gen.else();
  }
  invalid$data() {
    const { gen, schemaCode, schemaType, def: def2, it } = this;
    return codegen_1$n.or(wrong$DataType(), invalid$DataSchema());
    function wrong$DataType() {
      if (schemaType.length) {
        if (!(schemaCode instanceof codegen_1$n.Name))
          throw new Error("ajv implementation error");
        const st = Array.isArray(schemaType) ? schemaType : [schemaType];
        return codegen_1$n._`${dataType_2.checkDataTypes(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
      }
      return codegen_1$n.nil;
    }
    function invalid$DataSchema() {
      if (def2.validateSchema) {
        const validateSchemaRef = gen.scopeValue("validate$data", { ref: def2.validateSchema });
        return codegen_1$n._`!${validateSchemaRef}(${schemaCode})`;
      }
      return codegen_1$n.nil;
    }
  }
  subschema(appl, valid2) {
    const subschema2 = subschema_1.getSubschema(this.it, appl);
    subschema_1.extendSubschemaData(subschema2, this.it, appl);
    subschema_1.extendSubschemaMode(subschema2, appl);
    const nextContext = __spreadProps(__spreadValues(__spreadValues({}, this.it), subschema2), { items: void 0, props: void 0 });
    subschemaCode(nextContext, valid2);
    return nextContext;
  }
  mergeEvaluated(schemaCxt, toName) {
    const { it, gen } = this;
    if (!it.opts.unevaluated)
      return;
    if (it.props !== true && schemaCxt.props !== void 0) {
      it.props = util_1$k.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
    }
    if (it.items !== true && schemaCxt.items !== void 0) {
      it.items = util_1$k.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
    }
  }
  mergeValidEvaluated(schemaCxt, valid2) {
    const { it, gen } = this;
    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
      gen.if(valid2, () => this.mergeEvaluated(schemaCxt, codegen_1$n.Name));
      return true;
    }
  }
}
validate.KeywordCxt = KeywordCxt;
function keywordCode(it, keyword2, def2, ruleType) {
  const cxt = new KeywordCxt(it, def2, keyword2);
  if ("code" in def2) {
    def2.code(cxt, ruleType);
  } else if (cxt.$data && def2.validate) {
    keyword_1.funcKeywordCode(cxt, def2);
  } else if ("macro" in def2) {
    keyword_1.macroKeywordCode(cxt, def2);
  } else if (def2.compile || def2.validate) {
    keyword_1.funcKeywordCode(cxt, def2);
  }
}
const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, { dataLevel, dataNames, dataPathArr }) {
  let jsonPointer;
  let data;
  if ($data === "")
    return names_1$3.default.rootData;
  if ($data[0] === "/") {
    if (!JSON_POINTER.test($data))
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    jsonPointer = $data;
    data = names_1$3.default.rootData;
  } else {
    const matches = RELATIVE_JSON_POINTER.exec($data);
    if (!matches)
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    const up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer === "#") {
      if (up >= dataLevel)
        throw new Error(errorMsg("property/index", up));
      return dataPathArr[dataLevel - up];
    }
    if (up > dataLevel)
      throw new Error(errorMsg("data", up));
    data = dataNames[dataLevel - up];
    if (!jsonPointer)
      return data;
  }
  let expr = data;
  const segments = jsonPointer.split("/");
  for (const segment of segments) {
    if (segment) {
      data = codegen_1$n._`${data}${codegen_1$n.getProperty(util_1$k.unescapeJsonPointer(segment))}`;
      expr = codegen_1$n._`${expr} && ${data}`;
    }
  }
  return expr;
  function errorMsg(pointerType, up) {
    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
  }
}
validate.getData = getData;
var validation_error = {};
Object.defineProperty(validation_error, "__esModule", { value: true });
class ValidationError extends Error {
  constructor(errors2) {
    super("validation failed");
    this.errors = errors2;
    this.ajv = this.validation = true;
  }
}
validation_error.default = ValidationError;
var ref_error = {};
Object.defineProperty(ref_error, "__esModule", { value: true });
const resolve_1$1 = resolve$1;
class MissingRefError extends Error {
  constructor(baseId, ref2, msg) {
    super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
    this.missingRef = resolve_1$1.resolveUrl(baseId, ref2);
    this.missingSchema = resolve_1$1.normalizeId(resolve_1$1.getFullPath(this.missingRef));
  }
}
ref_error.default = MissingRefError;
var compile = {};
Object.defineProperty(compile, "__esModule", { value: true });
compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
const codegen_1$m = codegen;
const validation_error_1 = validation_error;
const names_1$2 = names$1;
const resolve_1 = resolve$1;
const util_1$j = util;
const validate_1$1 = validate;
const URI = uri_all.exports;
class SchemaEnv {
  constructor(env2) {
    var _a;
    this.refs = {};
    this.dynamicAnchors = {};
    let schema2;
    if (typeof env2.schema == "object")
      schema2 = env2.schema;
    this.schema = env2.schema;
    this.schemaId = env2.schemaId;
    this.root = env2.root || this;
    this.baseId = (_a = env2.baseId) !== null && _a !== void 0 ? _a : resolve_1.normalizeId(schema2 === null || schema2 === void 0 ? void 0 : schema2[env2.schemaId || "$id"]);
    this.schemaPath = env2.schemaPath;
    this.localRefs = env2.localRefs;
    this.meta = env2.meta;
    this.$async = schema2 === null || schema2 === void 0 ? void 0 : schema2.$async;
    this.refs = {};
  }
}
compile.SchemaEnv = SchemaEnv;
function compileSchema(sch) {
  const _sch = getCompilingSchema.call(this, sch);
  if (_sch)
    return _sch;
  const rootId = resolve_1.getFullPath(sch.root.baseId);
  const { es5, lines } = this.opts.code;
  const { ownProperties } = this.opts;
  const gen = new codegen_1$m.CodeGen(this.scope, { es5, lines, ownProperties });
  let _ValidationError;
  if (sch.$async) {
    _ValidationError = gen.scopeValue("Error", {
      ref: validation_error_1.default,
      code: codegen_1$m._`require("ajv/dist/runtime/validation_error").default`
    });
  }
  const validateName = gen.scopeName("validate");
  sch.validateName = validateName;
  const schemaCxt = {
    gen,
    allErrors: this.opts.allErrors,
    data: names_1$2.default.data,
    parentData: names_1$2.default.parentData,
    parentDataProperty: names_1$2.default.parentDataProperty,
    dataNames: [names_1$2.default.data],
    dataPathArr: [codegen_1$m.nil],
    dataLevel: 0,
    dataTypes: [],
    definedProperties: new Set(),
    topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: codegen_1$m.stringify(sch.schema) } : { ref: sch.schema }),
    validateName,
    ValidationError: _ValidationError,
    schema: sch.schema,
    schemaEnv: sch,
    rootId,
    baseId: sch.baseId || rootId,
    schemaPath: codegen_1$m.nil,
    errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: codegen_1$m._`""`,
    opts: this.opts,
    self: this
  };
  let sourceCode;
  try {
    this._compilations.add(sch);
    validate_1$1.validateFunctionCode(schemaCxt);
    gen.optimize(this.opts.code.optimize);
    const validateCode = gen.toString();
    sourceCode = `${gen.scopeRefs(names_1$2.default.scope)}return ${validateCode}`;
    if (this.opts.code.process)
      sourceCode = this.opts.code.process(sourceCode, sch);
    const makeValidate = new Function(`${names_1$2.default.self}`, `${names_1$2.default.scope}`, sourceCode);
    const validate2 = makeValidate(this, this.scope.get());
    this.scope.value(validateName, { ref: validate2 });
    validate2.errors = null;
    validate2.schema = sch.schema;
    validate2.schemaEnv = sch;
    if (sch.$async)
      validate2.$async = true;
    if (this.opts.code.source === true) {
      validate2.source = { validateName, validateCode, scopeValues: gen._values };
    }
    if (this.opts.unevaluated) {
      const { props, items: items2 } = schemaCxt;
      validate2.evaluated = {
        props: props instanceof codegen_1$m.Name ? void 0 : props,
        items: items2 instanceof codegen_1$m.Name ? void 0 : items2,
        dynamicProps: props instanceof codegen_1$m.Name,
        dynamicItems: items2 instanceof codegen_1$m.Name
      };
      if (validate2.source)
        validate2.source.evaluated = codegen_1$m.stringify(validate2.evaluated);
    }
    sch.validate = validate2;
    return sch;
  } catch (e) {
    delete sch.validate;
    delete sch.validateName;
    if (sourceCode)
      this.logger.error("Error compiling schema, function code:", sourceCode);
    throw e;
  } finally {
    this._compilations.delete(sch);
  }
}
compile.compileSchema = compileSchema;
function resolveRef(root, baseId, ref2) {
  var _a;
  ref2 = resolve_1.resolveUrl(baseId, ref2);
  const schOrFunc = root.refs[ref2];
  if (schOrFunc)
    return schOrFunc;
  let _sch = resolve.call(this, root, ref2);
  if (_sch === void 0) {
    const schema2 = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref2];
    const { schemaId } = this.opts;
    if (schema2)
      _sch = new SchemaEnv({ schema: schema2, schemaId, root, baseId });
  }
  if (_sch === void 0)
    return;
  return root.refs[ref2] = inlineOrCompile.call(this, _sch);
}
compile.resolveRef = resolveRef;
function inlineOrCompile(sch) {
  if (resolve_1.inlineRef(sch.schema, this.opts.inlineRefs))
    return sch.schema;
  return sch.validate ? sch : compileSchema.call(this, sch);
}
function getCompilingSchema(schEnv) {
  for (const sch of this._compilations) {
    if (sameSchemaEnv(sch, schEnv))
      return sch;
  }
}
compile.getCompilingSchema = getCompilingSchema;
function sameSchemaEnv(s1, s2) {
  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
}
function resolve(root, ref2) {
  let sch;
  while (typeof (sch = this.refs[ref2]) == "string")
    ref2 = sch;
  return sch || this.schemas[ref2] || resolveSchema.call(this, root, ref2);
}
function resolveSchema(root, ref2) {
  const p = URI.parse(ref2);
  const refPath = resolve_1._getFullPath(p);
  let baseId = resolve_1.getFullPath(root.baseId);
  if (Object.keys(root.schema).length > 0 && refPath === baseId) {
    return getJsonPointer.call(this, p, root);
  }
  const id2 = resolve_1.normalizeId(refPath);
  const schOrRef = this.refs[id2] || this.schemas[id2];
  if (typeof schOrRef == "string") {
    const sch = resolveSchema.call(this, root, schOrRef);
    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
      return;
    return getJsonPointer.call(this, p, sch);
  }
  if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
    return;
  if (!schOrRef.validate)
    compileSchema.call(this, schOrRef);
  if (id2 === resolve_1.normalizeId(ref2)) {
    const { schema: schema2 } = schOrRef;
    const { schemaId } = this.opts;
    const schId = schema2[schemaId];
    if (schId)
      baseId = resolve_1.resolveUrl(baseId, schId);
    return new SchemaEnv({ schema: schema2, schemaId, root, baseId });
  }
  return getJsonPointer.call(this, p, schOrRef);
}
compile.resolveSchema = resolveSchema;
const PREVENT_SCOPE_CHANGE = new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function getJsonPointer(parsedRef, { baseId, schema: schema2, root }) {
  var _a;
  if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
    return;
  for (const part of parsedRef.fragment.slice(1).split("/")) {
    if (typeof schema2 == "boolean")
      return;
    schema2 = schema2[util_1$j.unescapeFragment(part)];
    if (schema2 === void 0)
      return;
    const schId = typeof schema2 == "object" && schema2[this.opts.schemaId];
    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
      baseId = resolve_1.resolveUrl(baseId, schId);
    }
  }
  let env2;
  if (typeof schema2 != "boolean" && schema2.$ref && !util_1$j.schemaHasRulesButRef(schema2, this.RULES)) {
    const $ref = resolve_1.resolveUrl(baseId, schema2.$ref);
    env2 = resolveSchema.call(this, root, $ref);
  }
  const { schemaId } = this.opts;
  env2 = env2 || new SchemaEnv({ schema: schema2, schemaId, root, baseId });
  if (env2.schema !== env2.root.schema)
    return env2;
  return void 0;
}
const $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
const type$1 = "object";
const required$1 = [
  "$data"
];
const properties$2 = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
};
const additionalProperties$1 = false;
var require$$9 = {
  $id: $id$1,
  description,
  type: type$1,
  required: required$1,
  properties: properties$2,
  additionalProperties: additionalProperties$1
};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
  var validate_12 = validate;
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  const validation_error_12 = validation_error;
  const ref_error_12 = ref_error;
  const rules_1 = rules;
  const compile_12 = compile;
  const codegen_2 = codegen;
  const resolve_12 = resolve$1;
  const dataType_12 = dataType;
  const util_12 = util;
  const $dataRefSchema = require$$9;
  const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
  const EXT_SCOPE_NAMES = new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]);
  const removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  };
  const deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  };
  const MAX_EXPRESSION = 200;
  function requiredOptions(o) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
    const s = o.strict;
    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
    const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
    return {
      strictSchema: (_c = (_b = o.strictSchema) !== null && _b !== void 0 ? _b : s) !== null && _c !== void 0 ? _c : true,
      strictNumbers: (_e = (_d = o.strictNumbers) !== null && _d !== void 0 ? _d : s) !== null && _e !== void 0 ? _e : true,
      strictTypes: (_g = (_f = o.strictTypes) !== null && _f !== void 0 ? _f : s) !== null && _g !== void 0 ? _g : "log",
      strictTuples: (_j = (_h = o.strictTuples) !== null && _h !== void 0 ? _h : s) !== null && _j !== void 0 ? _j : "log",
      strictRequired: (_l = (_k = o.strictRequired) !== null && _k !== void 0 ? _k : s) !== null && _l !== void 0 ? _l : false,
      code: o.code ? __spreadProps(__spreadValues({}, o.code), { optimize }) : { optimize },
      loopRequired: (_m = o.loopRequired) !== null && _m !== void 0 ? _m : MAX_EXPRESSION,
      loopEnum: (_o = o.loopEnum) !== null && _o !== void 0 ? _o : MAX_EXPRESSION,
      meta: (_p = o.meta) !== null && _p !== void 0 ? _p : true,
      messages: (_q = o.messages) !== null && _q !== void 0 ? _q : true,
      inlineRefs: (_r = o.inlineRefs) !== null && _r !== void 0 ? _r : true,
      schemaId: (_s = o.schemaId) !== null && _s !== void 0 ? _s : "$id",
      addUsedSchema: (_t = o.addUsedSchema) !== null && _t !== void 0 ? _t : true,
      validateSchema: (_u = o.validateSchema) !== null && _u !== void 0 ? _u : true,
      validateFormats: (_v = o.validateFormats) !== null && _v !== void 0 ? _v : true,
      unicodeRegExp: (_w = o.unicodeRegExp) !== null && _w !== void 0 ? _w : true,
      int32range: (_x = o.int32range) !== null && _x !== void 0 ? _x : true
    };
  }
  class Ajv {
    constructor(opts2 = {}) {
      this.schemas = {};
      this.refs = {};
      this.formats = {};
      this._compilations = new Set();
      this._loading = {};
      this._cache = new Map();
      opts2 = this.opts = __spreadValues(__spreadValues({}, opts2), requiredOptions(opts2));
      const { es5, lines } = this.opts.code;
      this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
      this.logger = getLogger(opts2.logger);
      const formatOpt = opts2.validateFormats;
      opts2.validateFormats = false;
      this.RULES = rules_1.getRules();
      checkOptions.call(this, removedOptions, opts2, "NOT SUPPORTED");
      checkOptions.call(this, deprecatedOptions, opts2, "DEPRECATED", "warn");
      this._metaOpts = getMetaSchemaOptions.call(this);
      if (opts2.formats)
        addInitialFormats.call(this);
      this._addVocabularies();
      this._addDefaultMetaSchema();
      if (opts2.keywords)
        addInitialKeywords.call(this, opts2.keywords);
      if (typeof opts2.meta == "object")
        this.addMetaSchema(opts2.meta);
      addInitialSchemas.call(this);
      opts2.validateFormats = formatOpt;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data, meta, schemaId } = this.opts;
      let _dataRefSchema = $dataRefSchema;
      if (schemaId === "id") {
        _dataRefSchema = __spreadValues({}, $dataRefSchema);
        _dataRefSchema.id = _dataRefSchema.$id;
        delete _dataRefSchema.$id;
      }
      if (meta && $data)
        this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
      const { meta, schemaId } = this.opts;
      return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
    }
    validate(schemaKeyRef, data) {
      let v;
      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v)
          throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
      } else {
        v = this.compile(schemaKeyRef);
      }
      const valid2 = v(data);
      if (!("$async" in v))
        this.errors = v.errors;
      return valid2;
    }
    compile(schema2, _meta) {
      const sch = this._addSchema(schema2, _meta);
      return sch.validate || this._compileSchemaEnv(sch);
    }
    compileAsync(schema2, meta) {
      if (typeof this.opts.loadSchema != "function") {
        throw new Error("options.loadSchema should be a function");
      }
      const { loadSchema } = this.opts;
      return runCompileAsync.call(this, schema2, meta);
      async function runCompileAsync(_schema, _meta) {
        await loadMetaSchema.call(this, _schema.$schema);
        const sch = this._addSchema(_schema, _meta);
        return sch.validate || _compileAsync.call(this, sch);
      }
      async function loadMetaSchema($ref) {
        if ($ref && !this.getSchema($ref)) {
          await runCompileAsync.call(this, { $ref }, true);
        }
      }
      async function _compileAsync(sch) {
        try {
          return this._compileSchemaEnv(sch);
        } catch (e) {
          if (!(e instanceof ref_error_12.default))
            throw e;
          checkLoaded.call(this, e);
          await loadMissingSchema.call(this, e.missingSchema);
          return _compileAsync.call(this, sch);
        }
      }
      function checkLoaded({ missingSchema: ref2, missingRef }) {
        if (this.refs[ref2]) {
          throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
        }
      }
      async function loadMissingSchema(ref2) {
        const _schema = await _loadSchema.call(this, ref2);
        if (!this.refs[ref2])
          await loadMetaSchema.call(this, _schema.$schema);
        if (!this.refs[ref2])
          this.addSchema(_schema, ref2, meta);
      }
      async function _loadSchema(ref2) {
        const p = this._loading[ref2];
        if (p)
          return p;
        try {
          return await (this._loading[ref2] = loadSchema(ref2));
        } finally {
          delete this._loading[ref2];
        }
      }
    }
    addSchema(schema2, key, _meta, _validateSchema = this.opts.validateSchema) {
      if (Array.isArray(schema2)) {
        for (const sch of schema2)
          this.addSchema(sch, void 0, _meta, _validateSchema);
        return this;
      }
      let id2;
      if (typeof schema2 === "object") {
        const { schemaId } = this.opts;
        id2 = schema2[schemaId];
        if (id2 !== void 0 && typeof id2 != "string") {
          throw new Error(`schema ${schemaId} must be string`);
        }
      }
      key = resolve_12.normalizeId(key || id2);
      this._checkUnique(key);
      this.schemas[key] = this._addSchema(schema2, _meta, key, _validateSchema, true);
      return this;
    }
    addMetaSchema(schema2, key, _validateSchema = this.opts.validateSchema) {
      this.addSchema(schema2, key, true, _validateSchema);
      return this;
    }
    validateSchema(schema2, throwOrLogError) {
      if (typeof schema2 == "boolean")
        return true;
      let $schema2;
      $schema2 = schema2.$schema;
      if ($schema2 !== void 0 && typeof $schema2 != "string") {
        throw new Error("$schema must be a string");
      }
      $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
      if (!$schema2) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      const valid2 = this.validate($schema2, schema2);
      if (!valid2 && throwOrLogError) {
        const message = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid2;
    }
    getSchema(keyRef) {
      let sch;
      while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
        keyRef = sch;
      if (sch === void 0) {
        const { schemaId } = this.opts;
        const root = new compile_12.SchemaEnv({ schema: {}, schemaId });
        sch = compile_12.resolveSchema.call(this, root, keyRef);
        if (!sch)
          return;
        this.refs[keyRef] = sch;
      }
      return sch.validate || this._compileSchemaEnv(sch);
    }
    removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        this._removeAllSchemas(this.schemas, schemaKeyRef);
        this._removeAllSchemas(this.refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          this._removeAllSchemas(this.schemas);
          this._removeAllSchemas(this.refs);
          this._cache.clear();
          return this;
        case "string": {
          const sch = getSchEnv.call(this, schemaKeyRef);
          if (typeof sch == "object")
            this._cache.delete(sch.schema);
          delete this.schemas[schemaKeyRef];
          delete this.refs[schemaKeyRef];
          return this;
        }
        case "object": {
          const cacheKey = schemaKeyRef;
          this._cache.delete(cacheKey);
          let id2 = schemaKeyRef[this.opts.schemaId];
          if (id2) {
            id2 = resolve_12.normalizeId(id2);
            delete this.schemas[id2];
            delete this.refs[id2];
          }
          return this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    addVocabulary(definitions2) {
      for (const def2 of definitions2)
        this.addKeyword(def2);
      return this;
    }
    addKeyword(kwdOrDef, def2) {
      let keyword2;
      if (typeof kwdOrDef == "string") {
        keyword2 = kwdOrDef;
        if (typeof def2 == "object") {
          this.logger.warn("these parameters are deprecated, see docs for addKeyword");
          def2.keyword = keyword2;
        }
      } else if (typeof kwdOrDef == "object" && def2 === void 0) {
        def2 = kwdOrDef;
        keyword2 = def2.keyword;
        if (Array.isArray(keyword2) && !keyword2.length) {
          throw new Error("addKeywords: keyword must be string or non-empty array");
        }
      } else {
        throw new Error("invalid addKeywords parameters");
      }
      checkKeyword.call(this, keyword2, def2);
      if (!def2) {
        util_12.eachItem(keyword2, (kwd) => addRule.call(this, kwd));
        return this;
      }
      keywordMetaschema.call(this, def2);
      const definition = __spreadProps(__spreadValues({}, def2), {
        type: dataType_12.getJSONTypes(def2.type),
        schemaType: dataType_12.getJSONTypes(def2.schemaType)
      });
      util_12.eachItem(keyword2, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t2) => addRule.call(this, k, definition, t2)));
      return this;
    }
    getKeyword(keyword2) {
      const rule = this.RULES.all[keyword2];
      return typeof rule == "object" ? rule.definition : !!rule;
    }
    removeKeyword(keyword2) {
      const { RULES } = this;
      delete RULES.keywords[keyword2];
      delete RULES.all[keyword2];
      for (const group of RULES.rules) {
        const i = group.rules.findIndex((rule) => rule.keyword === keyword2);
        if (i >= 0)
          group.rules.splice(i, 1);
      }
      return this;
    }
    addFormat(name, format2) {
      if (typeof format2 == "string")
        format2 = new RegExp(format2);
      this.formats[name] = format2;
      return this;
    }
    errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
      if (!errors2 || errors2.length === 0)
        return "No errors";
      return errors2.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
      const rules2 = this.RULES.all;
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      for (const jsonPointer of keywordsJsonPointers) {
        const segments = jsonPointer.split("/").slice(1);
        let keywords = metaSchema;
        for (const seg of segments)
          keywords = keywords[seg];
        for (const key in rules2) {
          const rule = rules2[key];
          if (typeof rule != "object")
            continue;
          const { $data } = rule.definition;
          const schema2 = keywords[key];
          if ($data && schema2)
            keywords[key] = schemaOrData(schema2);
        }
      }
      return metaSchema;
    }
    _removeAllSchemas(schemas, regex) {
      for (const keyRef in schemas) {
        const sch = schemas[keyRef];
        if (!regex || regex.test(keyRef)) {
          if (typeof sch == "string") {
            delete schemas[keyRef];
          } else if (sch && !sch.meta) {
            this._cache.delete(sch.schema);
            delete schemas[keyRef];
          }
        }
      }
    }
    _addSchema(schema2, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
      let id2;
      const { schemaId } = this.opts;
      if (typeof schema2 == "object") {
        id2 = schema2[schemaId];
      } else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        else if (typeof schema2 != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let sch = this._cache.get(schema2);
      if (sch !== void 0)
        return sch;
      const localRefs = resolve_12.getSchemaRefs.call(this, schema2);
      baseId = resolve_12.normalizeId(id2 || baseId);
      sch = new compile_12.SchemaEnv({ schema: schema2, schemaId, meta, baseId, localRefs });
      this._cache.set(sch.schema, sch);
      if (addSchema && !baseId.startsWith("#")) {
        if (baseId)
          this._checkUnique(baseId);
        this.refs[baseId] = sch;
      }
      if (validateSchema)
        this.validateSchema(schema2, true);
      return sch;
    }
    _checkUnique(id2) {
      if (this.schemas[id2] || this.refs[id2]) {
        throw new Error(`schema with key or id "${id2}" already exists`);
      }
    }
    _compileSchemaEnv(sch) {
      if (sch.meta)
        this._compileMetaSchema(sch);
      else
        compile_12.compileSchema.call(this, sch);
      if (!sch.validate)
        throw new Error("ajv implementation error");
      return sch.validate;
    }
    _compileMetaSchema(sch) {
      const currentOpts = this.opts;
      this.opts = this._metaOpts;
      try {
        compile_12.compileSchema.call(this, sch);
      } finally {
        this.opts = currentOpts;
      }
    }
  }
  exports.default = Ajv;
  Ajv.ValidationError = validation_error_12.default;
  Ajv.MissingRefError = ref_error_12.default;
  function checkOptions(checkOpts, options, msg, log = "error") {
    for (const key in checkOpts) {
      const opt = key;
      if (opt in options)
        this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
    }
  }
  function getSchEnv(keyRef) {
    keyRef = resolve_12.normalizeId(keyRef);
    return this.schemas[keyRef] || this.refs[keyRef];
  }
  function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
      return;
    if (Array.isArray(optsSchemas))
      this.addSchema(optsSchemas);
    else
      for (const key in optsSchemas)
        this.addSchema(optsSchemas[key], key);
  }
  function addInitialFormats() {
    for (const name in this.opts.formats) {
      const format2 = this.opts.formats[name];
      if (format2)
        this.addFormat(name, format2);
    }
  }
  function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
      this.addVocabulary(defs);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword2 in defs) {
      const def2 = defs[keyword2];
      if (!def2.keyword)
        def2.keyword = keyword2;
      this.addKeyword(def2);
    }
  }
  function getMetaSchemaOptions() {
    const metaOpts = __spreadValues({}, this.opts);
    for (const opt of META_IGNORE_OPTIONS)
      delete metaOpts[opt];
    return metaOpts;
  }
  const noLogs = { log() {
  }, warn() {
  }, error() {
  } };
  function getLogger(logger) {
    if (logger === false)
      return noLogs;
    if (logger === void 0)
      return console;
    if (logger.log && logger.warn && logger.error)
      return logger;
    throw new Error("logger must implement log, warn and error methods");
  }
  const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
  function checkKeyword(keyword2, def2) {
    const { RULES } = this;
    util_12.eachItem(keyword2, (kwd) => {
      if (RULES.keywords[kwd])
        throw new Error(`Keyword ${kwd} is already defined`);
      if (!KEYWORD_NAME.test(kwd))
        throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def2)
      return;
    if (def2.$data && !("code" in def2 || "validate" in def2)) {
      throw new Error('$data keyword must have "code" or "validate" function');
    }
  }
  function addRule(keyword2, definition, dataType2) {
    var _a;
    const post = definition === null || definition === void 0 ? void 0 : definition.post;
    if (dataType2 && post)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t2 }) => t2 === dataType2);
    if (!ruleGroup) {
      ruleGroup = { type: dataType2, rules: [] };
      RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword2] = true;
    if (!definition)
      return;
    const rule = {
      keyword: keyword2,
      definition: __spreadProps(__spreadValues({}, definition), {
        type: dataType_12.getJSONTypes(definition.type),
        schemaType: dataType_12.getJSONTypes(definition.schemaType)
      })
    };
    if (definition.before)
      addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
      ruleGroup.rules.push(rule);
    RULES.all[keyword2] = rule;
    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
  }
  function addBeforeRule(ruleGroup, rule, before) {
    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i >= 0) {
      ruleGroup.rules.splice(i, 0, rule);
    } else {
      ruleGroup.rules.push(rule);
      this.logger.warn(`rule ${before} is not defined`);
    }
  }
  function keywordMetaschema(def2) {
    let { metaSchema } = def2;
    if (metaSchema === void 0)
      return;
    if (def2.$data && this.opts.$data)
      metaSchema = schemaOrData(metaSchema);
    def2.validateSchema = this.compile(metaSchema, true);
  }
  const $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function schemaOrData(schema2) {
    return { anyOf: [schema2, $dataRef] };
  }
})(core$2);
var draft7 = {};
var core$1 = {};
var id = {};
Object.defineProperty(id, "__esModule", { value: true });
const def$s = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
id.default = def$s;
var ref = {};
Object.defineProperty(ref, "__esModule", { value: true });
ref.callRef = ref.getValidate = void 0;
const ref_error_1 = ref_error;
const code_1$8 = code;
const codegen_1$l = codegen;
const names_1$1 = names$1;
const compile_1 = compile;
const util_1$i = util;
const def$r = {
  keyword: "$ref",
  schemaType: "string",
  code(cxt) {
    const { gen, schema: $ref, it } = cxt;
    const { baseId, schemaEnv: env2, validateName, opts: opts2, self: self2 } = it;
    const { root } = env2;
    if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
      return callRootRef();
    const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
    if (schOrEnv === void 0)
      throw new ref_error_1.default(baseId, $ref);
    if (schOrEnv instanceof compile_1.SchemaEnv)
      return callValidate(schOrEnv);
    return inlineRefSchema(schOrEnv);
    function callRootRef() {
      if (env2 === root)
        return callRef(cxt, validateName, env2, env2.$async);
      const rootName = gen.scopeValue("root", { ref: root });
      return callRef(cxt, codegen_1$l._`${rootName}.validate`, root, root.$async);
    }
    function callValidate(sch) {
      const v = getValidate(cxt, sch);
      callRef(cxt, v, sch, sch.$async);
    }
    function inlineRefSchema(sch) {
      const schName = gen.scopeValue("schema", opts2.code.source === true ? { ref: sch, code: codegen_1$l.stringify(sch) } : { ref: sch });
      const valid2 = gen.name("valid");
      const schCxt = cxt.subschema({
        schema: sch,
        dataTypes: [],
        schemaPath: codegen_1$l.nil,
        topSchemaRef: schName,
        errSchemaPath: $ref
      }, valid2);
      cxt.mergeEvaluated(schCxt);
      cxt.ok(valid2);
    }
  }
};
function getValidate(cxt, sch) {
  const { gen } = cxt;
  return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : codegen_1$l._`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
}
ref.getValidate = getValidate;
function callRef(cxt, v, sch, $async) {
  const { gen, it } = cxt;
  const { allErrors, schemaEnv: env2, opts: opts2 } = it;
  const passCxt = opts2.passContext ? names_1$1.default.this : codegen_1$l.nil;
  if ($async)
    callAsyncRef();
  else
    callSyncRef();
  function callAsyncRef() {
    if (!env2.$async)
      throw new Error("async schema referenced by sync schema");
    const valid2 = gen.let("valid");
    gen.try(() => {
      gen.code(codegen_1$l._`await ${code_1$8.callValidateCode(cxt, v, passCxt)}`);
      addEvaluatedFrom(v);
      if (!allErrors)
        gen.assign(valid2, true);
    }, (e) => {
      gen.if(codegen_1$l._`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
      addErrorsFrom(e);
      if (!allErrors)
        gen.assign(valid2, false);
    });
    cxt.ok(valid2);
  }
  function callSyncRef() {
    cxt.result(code_1$8.callValidateCode(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
  }
  function addErrorsFrom(source2) {
    const errs = codegen_1$l._`${source2}.errors`;
    gen.assign(names_1$1.default.vErrors, codegen_1$l._`${names_1$1.default.vErrors} === null ? ${errs} : ${names_1$1.default.vErrors}.concat(${errs})`);
    gen.assign(names_1$1.default.errors, codegen_1$l._`${names_1$1.default.vErrors}.length`);
  }
  function addEvaluatedFrom(source2) {
    var _a;
    if (!it.opts.unevaluated)
      return;
    const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
    if (it.props !== true) {
      if (schEvaluated && !schEvaluated.dynamicProps) {
        if (schEvaluated.props !== void 0) {
          it.props = util_1$i.mergeEvaluated.props(gen, schEvaluated.props, it.props);
        }
      } else {
        const props = gen.var("props", codegen_1$l._`${source2}.evaluated.props`);
        it.props = util_1$i.mergeEvaluated.props(gen, props, it.props, codegen_1$l.Name);
      }
    }
    if (it.items !== true) {
      if (schEvaluated && !schEvaluated.dynamicItems) {
        if (schEvaluated.items !== void 0) {
          it.items = util_1$i.mergeEvaluated.items(gen, schEvaluated.items, it.items);
        }
      } else {
        const items2 = gen.var("items", codegen_1$l._`${source2}.evaluated.items`);
        it.items = util_1$i.mergeEvaluated.items(gen, items2, it.items, codegen_1$l.Name);
      }
    }
  }
}
ref.callRef = callRef;
ref.default = def$r;
Object.defineProperty(core$1, "__esModule", { value: true });
const id_1 = id;
const ref_1 = ref;
const core = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  id_1.default,
  ref_1.default
];
core$1.default = core;
var validation$1 = {};
var limitNumber = {};
Object.defineProperty(limitNumber, "__esModule", { value: true });
const codegen_1$k = codegen;
const ops = codegen_1$k.operators;
const KWDs = {
  maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
  minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
  exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
  exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
};
const error$i = {
  message: ({ keyword: keyword2, schemaCode }) => codegen_1$k.str`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
  params: ({ keyword: keyword2, schemaCode }) => codegen_1$k._`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
};
const def$q = {
  keyword: Object.keys(KWDs),
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$i,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    cxt.fail$data(codegen_1$k._`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
  }
};
limitNumber.default = def$q;
var multipleOf = {};
Object.defineProperty(multipleOf, "__esModule", { value: true });
const codegen_1$j = codegen;
const error$h = {
  message: ({ schemaCode }) => codegen_1$j.str`must be multiple of ${schemaCode}`,
  params: ({ schemaCode }) => codegen_1$j._`{multipleOf: ${schemaCode}}`
};
const def$p = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$h,
  code(cxt) {
    const { gen, data, schemaCode, it } = cxt;
    const prec = it.opts.multipleOfPrecision;
    const res = gen.let("res");
    const invalid = prec ? codegen_1$j._`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : codegen_1$j._`${res} !== parseInt(${res})`;
    cxt.fail$data(codegen_1$j._`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
  }
};
multipleOf.default = def$p;
var limitLength = {};
var ucs2length$1 = {};
Object.defineProperty(ucs2length$1, "__esModule", { value: true });
function ucs2length(str) {
  const len = str.length;
  let length = 0;
  let pos = 0;
  let value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 55296 && value <= 56319 && pos < len) {
      value = str.charCodeAt(pos);
      if ((value & 64512) === 56320)
        pos++;
    }
  }
  return length;
}
ucs2length$1.default = ucs2length;
ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(limitLength, "__esModule", { value: true });
const codegen_1$i = codegen;
const util_1$h = util;
const ucs2length_1 = ucs2length$1;
const error$g = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxLength" ? "more" : "fewer";
    return codegen_1$i.str`must NOT have ${comp} than ${schemaCode} characters`;
  },
  params: ({ schemaCode }) => codegen_1$i._`{limit: ${schemaCode}}`
};
const def$o = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: true,
  error: error$g,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode, it } = cxt;
    const op = keyword2 === "maxLength" ? codegen_1$i.operators.GT : codegen_1$i.operators.LT;
    const len = it.opts.unicode === false ? codegen_1$i._`${data}.length` : codegen_1$i._`${util_1$h.useFunc(cxt.gen, ucs2length_1.default)}(${data})`;
    cxt.fail$data(codegen_1$i._`${len} ${op} ${schemaCode}`);
  }
};
limitLength.default = def$o;
var pattern = {};
Object.defineProperty(pattern, "__esModule", { value: true });
const code_1$7 = code;
const codegen_1$h = codegen;
const error$f = {
  message: ({ schemaCode }) => codegen_1$h.str`must match pattern "${schemaCode}"`,
  params: ({ schemaCode }) => codegen_1$h._`{pattern: ${schemaCode}}`
};
const def$n = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: true,
  error: error$f,
  code(cxt) {
    const { data, $data, schema: schema2, schemaCode, it } = cxt;
    const u2 = it.opts.unicodeRegExp ? "u" : "";
    const regExp = $data ? codegen_1$h._`(new RegExp(${schemaCode}, ${u2}))` : code_1$7.usePattern(cxt, schema2);
    cxt.fail$data(codegen_1$h._`!${regExp}.test(${data})`);
  }
};
pattern.default = def$n;
var limitProperties = {};
Object.defineProperty(limitProperties, "__esModule", { value: true });
const codegen_1$g = codegen;
const error$e = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxProperties" ? "more" : "fewer";
    return codegen_1$g.str`must NOT have ${comp} than ${schemaCode} items`;
  },
  params: ({ schemaCode }) => codegen_1$g._`{limit: ${schemaCode}}`
};
const def$m = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: true,
  error: error$e,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxProperties" ? codegen_1$g.operators.GT : codegen_1$g.operators.LT;
    cxt.fail$data(codegen_1$g._`Object.keys(${data}).length ${op} ${schemaCode}`);
  }
};
limitProperties.default = def$m;
var required = {};
Object.defineProperty(required, "__esModule", { value: true });
const code_1$6 = code;
const codegen_1$f = codegen;
const util_1$g = util;
const error$d = {
  message: ({ params: { missingProperty } }) => codegen_1$f.str`must have required property '${missingProperty}'`,
  params: ({ params: { missingProperty } }) => codegen_1$f._`{missingProperty: ${missingProperty}}`
};
const def$l = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: true,
  error: error$d,
  code(cxt) {
    const { gen, schema: schema2, schemaCode, data, $data, it } = cxt;
    const { opts: opts2 } = it;
    if (!$data && schema2.length === 0)
      return;
    const useLoop = schema2.length >= opts2.loopRequired;
    if (it.allErrors)
      allErrorsMode();
    else
      exitOnErrorMode();
    if (opts2.strictRequired) {
      const props = cxt.parentSchema.properties;
      const { definedProperties } = cxt.it;
      for (const requiredKey of schema2) {
        if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
          const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
          util_1$g.checkStrictMode(it, msg, it.opts.strictRequired);
        }
      }
    }
    function allErrorsMode() {
      if (useLoop || $data) {
        cxt.block$data(codegen_1$f.nil, loopAllRequired);
      } else {
        for (const prop of schema2) {
          code_1$6.checkReportMissingProp(cxt, prop);
        }
      }
    }
    function exitOnErrorMode() {
      const missing = gen.let("missing");
      if (useLoop || $data) {
        const valid2 = gen.let("valid", true);
        cxt.block$data(valid2, () => loopUntilMissing(missing, valid2));
        cxt.ok(valid2);
      } else {
        gen.if(code_1$6.checkMissingProp(cxt, schema2, missing));
        code_1$6.reportMissingProp(cxt, missing);
        gen.else();
      }
    }
    function loopAllRequired() {
      gen.forOf("prop", schemaCode, (prop) => {
        cxt.setParams({ missingProperty: prop });
        gen.if(code_1$6.noPropertyInData(gen, data, prop, opts2.ownProperties), () => cxt.error());
      });
    }
    function loopUntilMissing(missing, valid2) {
      cxt.setParams({ missingProperty: missing });
      gen.forOf(missing, schemaCode, () => {
        gen.assign(valid2, code_1$6.propertyInData(gen, data, missing, opts2.ownProperties));
        gen.if(codegen_1$f.not(valid2), () => {
          cxt.error();
          gen.break();
        });
      }, codegen_1$f.nil);
    }
  }
};
required.default = def$l;
var limitItems = {};
Object.defineProperty(limitItems, "__esModule", { value: true });
const codegen_1$e = codegen;
const error$c = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxItems" ? "more" : "fewer";
    return codegen_1$e.str`must NOT have ${comp} than ${schemaCode} items`;
  },
  params: ({ schemaCode }) => codegen_1$e._`{limit: ${schemaCode}}`
};
const def$k = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: true,
  error: error$c,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxItems" ? codegen_1$e.operators.GT : codegen_1$e.operators.LT;
    cxt.fail$data(codegen_1$e._`${data}.length ${op} ${schemaCode}`);
  }
};
limitItems.default = def$k;
var uniqueItems = {};
var equal$1 = {};
Object.defineProperty(equal$1, "__esModule", { value: true });
const equal = fastDeepEqual;
equal.code = 'require("ajv/dist/runtime/equal").default';
equal$1.default = equal;
Object.defineProperty(uniqueItems, "__esModule", { value: true });
const dataType_1 = dataType;
const codegen_1$d = codegen;
const util_1$f = util;
const equal_1$2 = equal$1;
const error$b = {
  message: ({ params: { i, j } }) => codegen_1$d.str`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
  params: ({ params: { i, j } }) => codegen_1$d._`{i: ${i}, j: ${j}}`
};
const def$j = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: true,
  error: error$b,
  code(cxt) {
    const { gen, data, $data, schema: schema2, parentSchema, schemaCode, it } = cxt;
    if (!$data && !schema2)
      return;
    const valid2 = gen.let("valid");
    const itemTypes = parentSchema.items ? dataType_1.getSchemaTypes(parentSchema.items) : [];
    cxt.block$data(valid2, validateUniqueItems, codegen_1$d._`${schemaCode} === false`);
    cxt.ok(valid2);
    function validateUniqueItems() {
      const i = gen.let("i", codegen_1$d._`${data}.length`);
      const j = gen.let("j");
      cxt.setParams({ i, j });
      gen.assign(valid2, true);
      gen.if(codegen_1$d._`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
    }
    function canOptimize() {
      return itemTypes.length > 0 && !itemTypes.some((t2) => t2 === "object" || t2 === "array");
    }
    function loopN(i, j) {
      const item = gen.name("item");
      const wrongType = dataType_1.checkDataTypes(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
      const indices = gen.const("indices", codegen_1$d._`{}`);
      gen.for(codegen_1$d._`;${i}--;`, () => {
        gen.let(item, codegen_1$d._`${data}[${i}]`);
        gen.if(wrongType, codegen_1$d._`continue`);
        if (itemTypes.length > 1)
          gen.if(codegen_1$d._`typeof ${item} == "string"`, codegen_1$d._`${item} += "_"`);
        gen.if(codegen_1$d._`typeof ${indices}[${item}] == "number"`, () => {
          gen.assign(j, codegen_1$d._`${indices}[${item}]`);
          cxt.error();
          gen.assign(valid2, false).break();
        }).code(codegen_1$d._`${indices}[${item}] = ${i}`);
      });
    }
    function loopN2(i, j) {
      const eql = util_1$f.useFunc(gen, equal_1$2.default);
      const outer = gen.name("outer");
      gen.label(outer).for(codegen_1$d._`;${i}--;`, () => gen.for(codegen_1$d._`${j} = ${i}; ${j}--;`, () => gen.if(codegen_1$d._`${eql}(${data}[${i}], ${data}[${j}])`, () => {
        cxt.error();
        gen.assign(valid2, false).break(outer);
      })));
    }
  }
};
uniqueItems.default = def$j;
var _const = {};
Object.defineProperty(_const, "__esModule", { value: true });
const codegen_1$c = codegen;
const util_1$e = util;
const equal_1$1 = equal$1;
const error$a = {
  message: "must be equal to constant",
  params: ({ schemaCode }) => codegen_1$c._`{allowedValue: ${schemaCode}}`
};
const def$i = {
  keyword: "const",
  $data: true,
  error: error$a,
  code(cxt) {
    const { gen, data, $data, schemaCode, schema: schema2 } = cxt;
    if ($data || schema2 && typeof schema2 == "object") {
      cxt.fail$data(codegen_1$c._`!${util_1$e.useFunc(gen, equal_1$1.default)}(${data}, ${schemaCode})`);
    } else {
      cxt.fail(codegen_1$c._`${schema2} !== ${data}`);
    }
  }
};
_const.default = def$i;
var _enum = {};
Object.defineProperty(_enum, "__esModule", { value: true });
const codegen_1$b = codegen;
const util_1$d = util;
const equal_1 = equal$1;
const error$9 = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode }) => codegen_1$b._`{allowedValues: ${schemaCode}}`
};
const def$h = {
  keyword: "enum",
  schemaType: "array",
  $data: true,
  error: error$9,
  code(cxt) {
    const { gen, data, $data, schema: schema2, schemaCode, it } = cxt;
    if (!$data && schema2.length === 0)
      throw new Error("enum must have non-empty array");
    const useLoop = schema2.length >= it.opts.loopEnum;
    const eql = util_1$d.useFunc(gen, equal_1.default);
    let valid2;
    if (useLoop || $data) {
      valid2 = gen.let("valid");
      cxt.block$data(valid2, loopEnum);
    } else {
      if (!Array.isArray(schema2))
        throw new Error("ajv implementation error");
      const vSchema = gen.const("vSchema", schemaCode);
      valid2 = codegen_1$b.or(...schema2.map((_x, i) => equalCode(vSchema, i)));
    }
    cxt.pass(valid2);
    function loopEnum() {
      gen.assign(valid2, false);
      gen.forOf("v", schemaCode, (v) => gen.if(codegen_1$b._`${eql}(${data}, ${v})`, () => gen.assign(valid2, true).break()));
    }
    function equalCode(vSchema, i) {
      const sch = schema2[i];
      return typeof sch === "object" && sch !== null ? codegen_1$b._`${eql}(${data}, ${vSchema}[${i}])` : codegen_1$b._`${data} === ${sch}`;
    }
  }
};
_enum.default = def$h;
Object.defineProperty(validation$1, "__esModule", { value: true });
const limitNumber_1 = limitNumber;
const multipleOf_1 = multipleOf;
const limitLength_1 = limitLength;
const pattern_1 = pattern;
const limitProperties_1 = limitProperties;
const required_1 = required;
const limitItems_1 = limitItems;
const uniqueItems_1 = uniqueItems;
const const_1 = _const;
const enum_1 = _enum;
const validation = [
  limitNumber_1.default,
  multipleOf_1.default,
  limitLength_1.default,
  pattern_1.default,
  limitProperties_1.default,
  required_1.default,
  limitItems_1.default,
  uniqueItems_1.default,
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  const_1.default,
  enum_1.default
];
validation$1.default = validation;
var applicator = {};
var additionalItems = {};
Object.defineProperty(additionalItems, "__esModule", { value: true });
additionalItems.validateAdditionalItems = void 0;
const codegen_1$a = codegen;
const util_1$c = util;
const error$8 = {
  message: ({ params: { len } }) => codegen_1$a.str`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => codegen_1$a._`{limit: ${len}}`
};
const def$g = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: error$8,
  code(cxt) {
    const { parentSchema, it } = cxt;
    const { items: items2 } = parentSchema;
    if (!Array.isArray(items2)) {
      util_1$c.checkStrictMode(it, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    validateAdditionalItems(cxt, items2);
  }
};
function validateAdditionalItems(cxt, items2) {
  const { gen, schema: schema2, data, keyword: keyword2, it } = cxt;
  it.items = true;
  const len = gen.const("len", codegen_1$a._`${data}.length`);
  if (schema2 === false) {
    cxt.setParams({ len: items2.length });
    cxt.pass(codegen_1$a._`${len} <= ${items2.length}`);
  } else if (typeof schema2 == "object" && !util_1$c.alwaysValidSchema(it, schema2)) {
    const valid2 = gen.var("valid", codegen_1$a._`${len} <= ${items2.length}`);
    gen.if(codegen_1$a.not(valid2), () => validateItems(valid2));
    cxt.ok(valid2);
  }
  function validateItems(valid2) {
    gen.forRange("i", items2.length, len, (i) => {
      cxt.subschema({ keyword: keyword2, dataProp: i, dataPropType: util_1$c.Type.Num }, valid2);
      if (!it.allErrors)
        gen.if(codegen_1$a.not(valid2), () => gen.break());
    });
  }
}
additionalItems.validateAdditionalItems = validateAdditionalItems;
additionalItems.default = def$g;
var prefixItems = {};
var items = {};
Object.defineProperty(items, "__esModule", { value: true });
items.validateTuple = void 0;
const codegen_1$9 = codegen;
const util_1$b = util;
const code_1$5 = code;
const def$f = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(cxt) {
    const { schema: schema2, it } = cxt;
    if (Array.isArray(schema2))
      return validateTuple(cxt, "additionalItems", schema2);
    it.items = true;
    if (util_1$b.alwaysValidSchema(it, schema2))
      return;
    cxt.ok(code_1$5.validateArray(cxt));
  }
};
function validateTuple(cxt, extraItems, schArr = cxt.schema) {
  const { gen, parentSchema, data, keyword: keyword2, it } = cxt;
  checkStrictTuple(parentSchema);
  if (it.opts.unevaluated && schArr.length && it.items !== true) {
    it.items = util_1$b.mergeEvaluated.items(gen, schArr.length, it.items);
  }
  const valid2 = gen.name("valid");
  const len = gen.const("len", codegen_1$9._`${data}.length`);
  schArr.forEach((sch, i) => {
    if (util_1$b.alwaysValidSchema(it, sch))
      return;
    gen.if(codegen_1$9._`${len} > ${i}`, () => cxt.subschema({
      keyword: keyword2,
      schemaProp: i,
      dataProp: i
    }, valid2));
    cxt.ok(valid2);
  });
  function checkStrictTuple(sch) {
    const { opts: opts2, errSchemaPath } = it;
    const l = schArr.length;
    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
    if (opts2.strictTuples && !fullTuple) {
      const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
      util_1$b.checkStrictMode(it, msg, opts2.strictTuples);
    }
  }
}
items.validateTuple = validateTuple;
items.default = def$f;
Object.defineProperty(prefixItems, "__esModule", { value: true });
const items_1$1 = items;
const def$e = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (cxt) => items_1$1.validateTuple(cxt, "items")
};
prefixItems.default = def$e;
var items2020 = {};
Object.defineProperty(items2020, "__esModule", { value: true });
const codegen_1$8 = codegen;
const util_1$a = util;
const code_1$4 = code;
const additionalItems_1$1 = additionalItems;
const error$7 = {
  message: ({ params: { len } }) => codegen_1$8.str`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => codegen_1$8._`{limit: ${len}}`
};
const def$d = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: error$7,
  code(cxt) {
    const { schema: schema2, parentSchema, it } = cxt;
    const { prefixItems: prefixItems2 } = parentSchema;
    it.items = true;
    if (util_1$a.alwaysValidSchema(it, schema2))
      return;
    if (prefixItems2)
      additionalItems_1$1.validateAdditionalItems(cxt, prefixItems2);
    else
      cxt.ok(code_1$4.validateArray(cxt));
  }
};
items2020.default = def$d;
var contains = {};
Object.defineProperty(contains, "__esModule", { value: true });
const codegen_1$7 = codegen;
const util_1$9 = util;
const error$6 = {
  message: ({ params: { min, max } }) => max === void 0 ? codegen_1$7.str`must contain at least ${min} valid item(s)` : codegen_1$7.str`must contain at least ${min} and no more than ${max} valid item(s)`,
  params: ({ params: { min, max } }) => max === void 0 ? codegen_1$7._`{minContains: ${min}}` : codegen_1$7._`{minContains: ${min}, maxContains: ${max}}`
};
const def$c = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: true,
  error: error$6,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, it } = cxt;
    let min;
    let max;
    const { minContains, maxContains } = parentSchema;
    if (it.opts.next) {
      min = minContains === void 0 ? 1 : minContains;
      max = maxContains;
    } else {
      min = 1;
    }
    const len = gen.const("len", codegen_1$7._`${data}.length`);
    cxt.setParams({ min, max });
    if (max === void 0 && min === 0) {
      util_1$9.checkStrictMode(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
      return;
    }
    if (max !== void 0 && min > max) {
      util_1$9.checkStrictMode(it, `"minContains" > "maxContains" is always invalid`);
      cxt.fail();
      return;
    }
    if (util_1$9.alwaysValidSchema(it, schema2)) {
      let cond = codegen_1$7._`${len} >= ${min}`;
      if (max !== void 0)
        cond = codegen_1$7._`${cond} && ${len} <= ${max}`;
      cxt.pass(cond);
      return;
    }
    it.items = true;
    const valid2 = gen.name("valid");
    if (max === void 0 && min === 1) {
      validateItems(valid2, () => gen.if(valid2, () => gen.break()));
    } else {
      gen.let(valid2, false);
      const schValid = gen.name("_valid");
      const count = gen.let("count", 0);
      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
    }
    cxt.result(valid2, () => cxt.reset());
    function validateItems(_valid, block) {
      gen.forRange("i", 0, len, (i) => {
        cxt.subschema({
          keyword: "contains",
          dataProp: i,
          dataPropType: util_1$9.Type.Num,
          compositeRule: true
        }, _valid);
        block();
      });
    }
    function checkLimits(count) {
      gen.code(codegen_1$7._`${count}++`);
      if (max === void 0) {
        gen.if(codegen_1$7._`${count} >= ${min}`, () => gen.assign(valid2, true).break());
      } else {
        gen.if(codegen_1$7._`${count} > ${max}`, () => gen.assign(valid2, false).break());
        if (min === 1)
          gen.assign(valid2, true);
        else
          gen.if(codegen_1$7._`${count} >= ${min}`, () => gen.assign(valid2, true));
      }
    }
  }
};
contains.default = def$c;
var dependencies = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
  const codegen_12 = codegen;
  const util_12 = util;
  const code_12 = code;
  exports.error = {
    message: ({ params: { property, depsCount, deps } }) => {
      const property_ies = depsCount === 1 ? "property" : "properties";
      return codegen_12.str`must have ${property_ies} ${deps} when property ${property} is present`;
    },
    params: ({ params: { property, depsCount, deps, missingProperty } }) => codegen_12._`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
  };
  const def2 = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports.error,
    code(cxt) {
      const [propDeps, schDeps] = splitDependencies(cxt);
      validatePropertyDeps(cxt, propDeps);
      validateSchemaDeps(cxt, schDeps);
    }
  };
  function splitDependencies({ schema: schema2 }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key in schema2) {
      if (key === "__proto__")
        continue;
      const deps = Array.isArray(schema2[key]) ? propertyDeps : schemaDeps;
      deps[key] = schema2[key];
    }
    return [propertyDeps, schemaDeps];
  }
  function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
    const { gen, data, it } = cxt;
    if (Object.keys(propertyDeps).length === 0)
      return;
    const missing = gen.let("missing");
    for (const prop in propertyDeps) {
      const deps = propertyDeps[prop];
      if (deps.length === 0)
        continue;
      const hasProperty = code_12.propertyInData(gen, data, prop, it.opts.ownProperties);
      cxt.setParams({
        property: prop,
        depsCount: deps.length,
        deps: deps.join(", ")
      });
      if (it.allErrors) {
        gen.if(hasProperty, () => {
          for (const depProp of deps) {
            code_12.checkReportMissingProp(cxt, depProp);
          }
        });
      } else {
        gen.if(codegen_12._`${hasProperty} && (${code_12.checkMissingProp(cxt, deps, missing)})`);
        code_12.reportMissingProp(cxt, missing);
        gen.else();
      }
    }
  }
  exports.validatePropertyDeps = validatePropertyDeps;
  function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
    const { gen, data, keyword: keyword2, it } = cxt;
    const valid2 = gen.name("valid");
    for (const prop in schemaDeps) {
      if (util_12.alwaysValidSchema(it, schemaDeps[prop]))
        continue;
      gen.if(code_12.propertyInData(gen, data, prop, it.opts.ownProperties), () => {
        const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid2);
        cxt.mergeValidEvaluated(schCxt, valid2);
      }, () => gen.var(valid2, true));
      cxt.ok(valid2);
    }
  }
  exports.validateSchemaDeps = validateSchemaDeps;
  exports.default = def2;
})(dependencies);
var propertyNames = {};
Object.defineProperty(propertyNames, "__esModule", { value: true });
const codegen_1$6 = codegen;
const util_1$8 = util;
const error$5 = {
  message: "property name must be valid",
  params: ({ params }) => codegen_1$6._`{propertyName: ${params.propertyName}}`
};
const def$b = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: error$5,
  code(cxt) {
    const { gen, schema: schema2, data, it } = cxt;
    if (util_1$8.alwaysValidSchema(it, schema2))
      return;
    const valid2 = gen.name("valid");
    gen.forIn("key", data, (key) => {
      cxt.setParams({ propertyName: key });
      cxt.subschema({
        keyword: "propertyNames",
        data: key,
        dataTypes: ["string"],
        propertyName: key,
        compositeRule: true
      }, valid2);
      gen.if(codegen_1$6.not(valid2), () => {
        cxt.error(true);
        if (!it.allErrors)
          gen.break();
      });
    });
    cxt.ok(valid2);
  }
};
propertyNames.default = def$b;
var additionalProperties = {};
Object.defineProperty(additionalProperties, "__esModule", { value: true });
const code_1$3 = code;
const codegen_1$5 = codegen;
const names_1 = names$1;
const util_1$7 = util;
const error$4 = {
  message: "must NOT have additional properties",
  params: ({ params }) => codegen_1$5._`{additionalProperty: ${params.additionalProperty}}`
};
const def$a = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: true,
  trackErrors: true,
  error: error$4,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, errsCount, it } = cxt;
    if (!errsCount)
      throw new Error("ajv implementation error");
    const { allErrors, opts: opts2 } = it;
    it.props = true;
    if (opts2.removeAdditional !== "all" && util_1$7.alwaysValidSchema(it, schema2))
      return;
    const props = code_1$3.allSchemaProperties(parentSchema.properties);
    const patProps = code_1$3.allSchemaProperties(parentSchema.patternProperties);
    checkAdditionalProperties();
    cxt.ok(codegen_1$5._`${errsCount} === ${names_1.default.errors}`);
    function checkAdditionalProperties() {
      gen.forIn("key", data, (key) => {
        if (!props.length && !patProps.length)
          additionalPropertyCode(key);
        else
          gen.if(isAdditional(key), () => additionalPropertyCode(key));
      });
    }
    function isAdditional(key) {
      let definedProp;
      if (props.length > 8) {
        const propsSchema = util_1$7.schemaRefOrVal(it, parentSchema.properties, "properties");
        definedProp = code_1$3.isOwnProperty(gen, propsSchema, key);
      } else if (props.length) {
        definedProp = codegen_1$5.or(...props.map((p) => codegen_1$5._`${key} === ${p}`));
      } else {
        definedProp = codegen_1$5.nil;
      }
      if (patProps.length) {
        definedProp = codegen_1$5.or(definedProp, ...patProps.map((p) => codegen_1$5._`${code_1$3.usePattern(cxt, p)}.test(${key})`));
      }
      return codegen_1$5.not(definedProp);
    }
    function deleteAdditional(key) {
      gen.code(codegen_1$5._`delete ${data}[${key}]`);
    }
    function additionalPropertyCode(key) {
      if (opts2.removeAdditional === "all" || opts2.removeAdditional && schema2 === false) {
        deleteAdditional(key);
        return;
      }
      if (schema2 === false) {
        cxt.setParams({ additionalProperty: key });
        cxt.error();
        if (!allErrors)
          gen.break();
        return;
      }
      if (typeof schema2 == "object" && !util_1$7.alwaysValidSchema(it, schema2)) {
        const valid2 = gen.name("valid");
        if (opts2.removeAdditional === "failing") {
          applyAdditionalSchema(key, valid2, false);
          gen.if(codegen_1$5.not(valid2), () => {
            cxt.reset();
            deleteAdditional(key);
          });
        } else {
          applyAdditionalSchema(key, valid2);
          if (!allErrors)
            gen.if(codegen_1$5.not(valid2), () => gen.break());
        }
      }
    }
    function applyAdditionalSchema(key, valid2, errors2) {
      const subschema2 = {
        keyword: "additionalProperties",
        dataProp: key,
        dataPropType: util_1$7.Type.Str
      };
      if (errors2 === false) {
        Object.assign(subschema2, {
          compositeRule: true,
          createErrors: false,
          allErrors: false
        });
      }
      cxt.subschema(subschema2, valid2);
    }
  }
};
additionalProperties.default = def$a;
var properties$1 = {};
Object.defineProperty(properties$1, "__esModule", { value: true });
const validate_1 = validate;
const code_1$2 = code;
const util_1$6 = util;
const additionalProperties_1$1 = additionalProperties;
const def$9 = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, it } = cxt;
    if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
      additionalProperties_1$1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1$1.default, "additionalProperties"));
    }
    const allProps = code_1$2.allSchemaProperties(schema2);
    for (const prop of allProps) {
      it.definedProperties.add(prop);
    }
    if (it.opts.unevaluated && allProps.length && it.props !== true) {
      it.props = util_1$6.mergeEvaluated.props(gen, util_1$6.toHash(allProps), it.props);
    }
    const properties2 = allProps.filter((p) => !util_1$6.alwaysValidSchema(it, schema2[p]));
    if (properties2.length === 0)
      return;
    const valid2 = gen.name("valid");
    for (const prop of properties2) {
      if (hasDefault(prop)) {
        applyPropertySchema(prop);
      } else {
        gen.if(code_1$2.propertyInData(gen, data, prop, it.opts.ownProperties));
        applyPropertySchema(prop);
        if (!it.allErrors)
          gen.else().var(valid2, true);
        gen.endIf();
      }
      cxt.it.definedProperties.add(prop);
      cxt.ok(valid2);
    }
    function hasDefault(prop) {
      return it.opts.useDefaults && !it.compositeRule && schema2[prop].default !== void 0;
    }
    function applyPropertySchema(prop) {
      cxt.subschema({
        keyword: "properties",
        schemaProp: prop,
        dataProp: prop
      }, valid2);
    }
  }
};
properties$1.default = def$9;
var patternProperties = {};
Object.defineProperty(patternProperties, "__esModule", { value: true });
const code_1$1 = code;
const codegen_1$4 = codegen;
const util_1$5 = util;
const util_2 = util;
const def$8 = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema: schema2, data, parentSchema, it } = cxt;
    const { opts: opts2 } = it;
    const patterns = code_1$1.allSchemaProperties(schema2);
    const alwaysValidPatterns = patterns.filter((p) => util_1$5.alwaysValidSchema(it, schema2[p]));
    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
      return;
    }
    const checkProperties = opts2.strictSchema && !opts2.allowMatchingProperties && parentSchema.properties;
    const valid2 = gen.name("valid");
    if (it.props !== true && !(it.props instanceof codegen_1$4.Name)) {
      it.props = util_2.evaluatedPropsToName(gen, it.props);
    }
    const { props } = it;
    validatePatternProperties();
    function validatePatternProperties() {
      for (const pat of patterns) {
        if (checkProperties)
          checkMatchingProperties(pat);
        if (it.allErrors) {
          validateProperties(pat);
        } else {
          gen.var(valid2, true);
          validateProperties(pat);
          gen.if(valid2);
        }
      }
    }
    function checkMatchingProperties(pat) {
      for (const prop in checkProperties) {
        if (new RegExp(pat).test(prop)) {
          util_1$5.checkStrictMode(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
        }
      }
    }
    function validateProperties(pat) {
      gen.forIn("key", data, (key) => {
        gen.if(codegen_1$4._`${code_1$1.usePattern(cxt, pat)}.test(${key})`, () => {
          const alwaysValid = alwaysValidPatterns.includes(pat);
          if (!alwaysValid) {
            cxt.subschema({
              keyword: "patternProperties",
              schemaProp: pat,
              dataProp: key,
              dataPropType: util_2.Type.Str
            }, valid2);
          }
          if (it.opts.unevaluated && props !== true) {
            gen.assign(codegen_1$4._`${props}[${key}]`, true);
          } else if (!alwaysValid && !it.allErrors) {
            gen.if(codegen_1$4.not(valid2), () => gen.break());
          }
        });
      });
    }
  }
};
patternProperties.default = def$8;
var not = {};
Object.defineProperty(not, "__esModule", { value: true });
const util_1$4 = util;
const def$7 = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  code(cxt) {
    const { gen, schema: schema2, it } = cxt;
    if (util_1$4.alwaysValidSchema(it, schema2)) {
      cxt.fail();
      return;
    }
    const valid2 = gen.name("valid");
    cxt.subschema({
      keyword: "not",
      compositeRule: true,
      createErrors: false,
      allErrors: false
    }, valid2);
    cxt.failResult(valid2, () => cxt.reset(), () => cxt.error());
  },
  error: { message: "must NOT be valid" }
};
not.default = def$7;
var anyOf = {};
Object.defineProperty(anyOf, "__esModule", { value: true });
const code_1 = code;
const def$6 = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: true,
  code: code_1.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
anyOf.default = def$6;
var oneOf = {};
Object.defineProperty(oneOf, "__esModule", { value: true });
const codegen_1$3 = codegen;
const util_1$3 = util;
const error$3 = {
  message: "must match exactly one schema in oneOf",
  params: ({ params }) => codegen_1$3._`{passingSchemas: ${params.passing}}`
};
const def$5 = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: true,
  error: error$3,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, it } = cxt;
    if (!Array.isArray(schema2))
      throw new Error("ajv implementation error");
    if (it.opts.discriminator && parentSchema.discriminator)
      return;
    const schArr = schema2;
    const valid2 = gen.let("valid", false);
    const passing = gen.let("passing", null);
    const schValid = gen.name("_valid");
    cxt.setParams({ passing });
    gen.block(validateOneOf);
    cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
    function validateOneOf() {
      schArr.forEach((sch, i) => {
        let schCxt;
        if (util_1$3.alwaysValidSchema(it, sch)) {
          gen.var(schValid, true);
        } else {
          schCxt = cxt.subschema({
            keyword: "oneOf",
            schemaProp: i,
            compositeRule: true
          }, schValid);
        }
        if (i > 0) {
          gen.if(codegen_1$3._`${schValid} && ${valid2}`).assign(valid2, false).assign(passing, codegen_1$3._`[${passing}, ${i}]`).else();
        }
        gen.if(schValid, () => {
          gen.assign(valid2, true);
          gen.assign(passing, i);
          if (schCxt)
            cxt.mergeEvaluated(schCxt, codegen_1$3.Name);
        });
      });
    }
  }
};
oneOf.default = def$5;
var allOf = {};
Object.defineProperty(allOf, "__esModule", { value: true });
const util_1$2 = util;
const def$4 = {
  keyword: "allOf",
  schemaType: "array",
  code(cxt) {
    const { gen, schema: schema2, it } = cxt;
    if (!Array.isArray(schema2))
      throw new Error("ajv implementation error");
    const valid2 = gen.name("valid");
    schema2.forEach((sch, i) => {
      if (util_1$2.alwaysValidSchema(it, sch))
        return;
      const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid2);
      cxt.ok(valid2);
      cxt.mergeEvaluated(schCxt);
    });
  }
};
allOf.default = def$4;
var _if = {};
Object.defineProperty(_if, "__esModule", { value: true });
const codegen_1$2 = codegen;
const util_1$1 = util;
const error$2 = {
  message: ({ params }) => codegen_1$2.str`must match "${params.ifClause}" schema`,
  params: ({ params }) => codegen_1$2._`{failingKeyword: ${params.ifClause}}`
};
const def$3 = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  error: error$2,
  code(cxt) {
    const { gen, parentSchema, it } = cxt;
    if (parentSchema.then === void 0 && parentSchema.else === void 0) {
      util_1$1.checkStrictMode(it, '"if" without "then" and "else" is ignored');
    }
    const hasThen = hasSchema(it, "then");
    const hasElse = hasSchema(it, "else");
    if (!hasThen && !hasElse)
      return;
    const valid2 = gen.let("valid", true);
    const schValid = gen.name("_valid");
    validateIf();
    cxt.reset();
    if (hasThen && hasElse) {
      const ifClause = gen.let("ifClause");
      cxt.setParams({ ifClause });
      gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
    } else if (hasThen) {
      gen.if(schValid, validateClause("then"));
    } else {
      gen.if(codegen_1$2.not(schValid), validateClause("else"));
    }
    cxt.pass(valid2, () => cxt.error(true));
    function validateIf() {
      const schCxt = cxt.subschema({
        keyword: "if",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, schValid);
      cxt.mergeEvaluated(schCxt);
    }
    function validateClause(keyword2, ifClause) {
      return () => {
        const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
        gen.assign(valid2, schValid);
        cxt.mergeValidEvaluated(schCxt, valid2);
        if (ifClause)
          gen.assign(ifClause, codegen_1$2._`${keyword2}`);
        else
          cxt.setParams({ ifClause: keyword2 });
      };
    }
  }
};
function hasSchema(it, keyword2) {
  const schema2 = it.schema[keyword2];
  return schema2 !== void 0 && !util_1$1.alwaysValidSchema(it, schema2);
}
_if.default = def$3;
var thenElse = {};
Object.defineProperty(thenElse, "__esModule", { value: true });
const util_1 = util;
const def$2 = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: keyword2, parentSchema, it }) {
    if (parentSchema.if === void 0)
      util_1.checkStrictMode(it, `"${keyword2}" without "if" is ignored`);
  }
};
thenElse.default = def$2;
Object.defineProperty(applicator, "__esModule", { value: true });
const additionalItems_1 = additionalItems;
const prefixItems_1 = prefixItems;
const items_1 = items;
const items2020_1 = items2020;
const contains_1 = contains;
const dependencies_1 = dependencies;
const propertyNames_1 = propertyNames;
const additionalProperties_1 = additionalProperties;
const properties_1 = properties$1;
const patternProperties_1 = patternProperties;
const not_1 = not;
const anyOf_1 = anyOf;
const oneOf_1 = oneOf;
const allOf_1 = allOf;
const if_1 = _if;
const thenElse_1 = thenElse;
function getApplicator(draft2020 = false) {
  const applicator2 = [
    not_1.default,
    anyOf_1.default,
    oneOf_1.default,
    allOf_1.default,
    if_1.default,
    thenElse_1.default,
    propertyNames_1.default,
    additionalProperties_1.default,
    dependencies_1.default,
    properties_1.default,
    patternProperties_1.default
  ];
  if (draft2020)
    applicator2.push(prefixItems_1.default, items2020_1.default);
  else
    applicator2.push(additionalItems_1.default, items_1.default);
  applicator2.push(contains_1.default);
  return applicator2;
}
applicator.default = getApplicator;
var format$2 = {};
var format$1 = {};
Object.defineProperty(format$1, "__esModule", { value: true });
const codegen_1$1 = codegen;
const error$1 = {
  message: ({ schemaCode }) => codegen_1$1.str`must match format "${schemaCode}"`,
  params: ({ schemaCode }) => codegen_1$1._`{format: ${schemaCode}}`
};
const def$1 = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: true,
  error: error$1,
  code(cxt, ruleType) {
    const { gen, data, $data, schema: schema2, schemaCode, it } = cxt;
    const { opts: opts2, errSchemaPath, schemaEnv, self: self2 } = it;
    if (!opts2.validateFormats)
      return;
    if ($data)
      validate$DataFormat();
    else
      validateFormat();
    function validate$DataFormat() {
      const fmts = gen.scopeValue("formats", {
        ref: self2.formats,
        code: opts2.code.formats
      });
      const fDef = gen.const("fDef", codegen_1$1._`${fmts}[${schemaCode}]`);
      const fType = gen.let("fType");
      const format2 = gen.let("format");
      gen.if(codegen_1$1._`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, codegen_1$1._`${fDef}.type || "string"`).assign(format2, codegen_1$1._`${fDef}.validate`), () => gen.assign(fType, codegen_1$1._`"string"`).assign(format2, fDef));
      cxt.fail$data(codegen_1$1.or(unknownFmt(), invalidFmt()));
      function unknownFmt() {
        if (opts2.strictSchema === false)
          return codegen_1$1.nil;
        return codegen_1$1._`${schemaCode} && !${format2}`;
      }
      function invalidFmt() {
        const callFormat = schemaEnv.$async ? codegen_1$1._`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : codegen_1$1._`${format2}(${data})`;
        const validData = codegen_1$1._`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
        return codegen_1$1._`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
      }
    }
    function validateFormat() {
      const formatDef = self2.formats[schema2];
      if (!formatDef) {
        unknownFormat();
        return;
      }
      if (formatDef === true)
        return;
      const [fmtType, format2, fmtRef] = getFormat(formatDef);
      if (fmtType === ruleType)
        cxt.pass(validCondition());
      function unknownFormat() {
        if (opts2.strictSchema === false) {
          self2.logger.warn(unknownMsg());
          return;
        }
        throw new Error(unknownMsg());
        function unknownMsg() {
          return `unknown format "${schema2}" ignored in schema at path "${errSchemaPath}"`;
        }
      }
      function getFormat(fmtDef) {
        const code2 = fmtDef instanceof RegExp ? codegen_1$1.regexpCode(fmtDef) : opts2.code.formats ? codegen_1$1._`${opts2.code.formats}${codegen_1$1.getProperty(schema2)}` : void 0;
        const fmt = gen.scopeValue("formats", { key: schema2, ref: fmtDef, code: code2 });
        if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
          return [fmtDef.type || "string", fmtDef.validate, codegen_1$1._`${fmt}.validate`];
        }
        return ["string", fmtDef, fmt];
      }
      function validCondition() {
        if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
          if (!schemaEnv.$async)
            throw new Error("async format in sync schema");
          return codegen_1$1._`await ${fmtRef}(${data})`;
        }
        return typeof format2 == "function" ? codegen_1$1._`${fmtRef}(${data})` : codegen_1$1._`${fmtRef}.test(${data})`;
      }
    }
  }
};
format$1.default = def$1;
Object.defineProperty(format$2, "__esModule", { value: true });
const format_1$1 = format$1;
const format = [format_1$1.default];
format$2.default = format;
var metadata = {};
Object.defineProperty(metadata, "__esModule", { value: true });
metadata.contentVocabulary = metadata.metadataVocabulary = void 0;
metadata.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
metadata.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(draft7, "__esModule", { value: true });
const core_1 = core$1;
const validation_1 = validation$1;
const applicator_1 = applicator;
const format_1 = format$2;
const metadata_1 = metadata;
const draft7Vocabularies = [
  core_1.default,
  validation_1.default,
  applicator_1.default(),
  format_1.default,
  metadata_1.metadataVocabulary,
  metadata_1.contentVocabulary
];
draft7.default = draft7Vocabularies;
var discriminator = {};
var types = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiscrError = void 0;
  (function(DiscrError) {
    DiscrError["Tag"] = "tag";
    DiscrError["Mapping"] = "mapping";
  })(exports.DiscrError || (exports.DiscrError = {}));
})(types);
Object.defineProperty(discriminator, "__esModule", { value: true });
const codegen_1 = codegen;
const types_1 = types;
const error = {
  message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
  params: ({ params: { discrError, tag, tagName } }) => codegen_1._`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
};
const def = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error,
  code(cxt) {
    const { gen, data, schema: schema2, parentSchema, it } = cxt;
    const { oneOf: oneOf2 } = parentSchema;
    if (!it.opts.discriminator) {
      throw new Error("discriminator: requires discriminator option");
    }
    const tagName = schema2.propertyName;
    if (typeof tagName != "string")
      throw new Error("discriminator: requires propertyName");
    if (schema2.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!oneOf2)
      throw new Error("discriminator: requires oneOf keyword");
    const valid2 = gen.let("valid", false);
    const tag = gen.const("tag", codegen_1._`${data}${codegen_1.getProperty(tagName)}`);
    gen.if(codegen_1._`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
    cxt.ok(valid2);
    function validateMapping() {
      const mapping = getMapping();
      gen.if(false);
      for (const tagValue in mapping) {
        gen.elseIf(codegen_1._`${tag} === ${tagValue}`);
        gen.assign(valid2, applyTagSchema(mapping[tagValue]));
      }
      gen.else();
      cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
      gen.endIf();
    }
    function applyTagSchema(schemaProp) {
      const _valid = gen.name("valid");
      const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
      cxt.mergeEvaluated(schCxt, codegen_1.Name);
      return _valid;
    }
    function getMapping() {
      var _a;
      const oneOfMapping = {};
      const topRequired = hasRequired(parentSchema);
      let tagRequired = true;
      for (let i = 0; i < oneOf2.length; i++) {
        const sch = oneOf2[i];
        const propSch = (_a = sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
        if (typeof propSch != "object") {
          throw new Error(`discriminator: oneOf schemas must have "properties/${tagName}"`);
        }
        tagRequired = tagRequired && (topRequired || hasRequired(sch));
        addMappings(propSch, i);
      }
      if (!tagRequired)
        throw new Error(`discriminator: "${tagName}" must be required`);
      return oneOfMapping;
      function hasRequired({ required: required2 }) {
        return Array.isArray(required2) && required2.includes(tagName);
      }
      function addMappings(sch, i) {
        if (sch.const) {
          addMapping(sch.const, i);
        } else if (sch.enum) {
          for (const tagValue of sch.enum) {
            addMapping(tagValue, i);
          }
        } else {
          throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
        }
      }
      function addMapping(tagValue, i) {
        if (typeof tagValue != "string" || tagValue in oneOfMapping) {
          throw new Error(`discriminator: "${tagName}" values must be unique strings`);
        }
        oneOfMapping[tagValue] = i;
      }
    }
  }
};
discriminator.default = def;
const $schema = "http://json-schema.org/draft-07/schema#";
const $id = "http://json-schema.org/draft-07/schema#";
const title = "Core schema meta-schema";
const definitions = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        "default": 0
      }
    ]
  },
  simpleTypes: {
    "enum": [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: true,
    "default": []
  }
};
const type = [
  "object",
  "boolean"
];
const properties = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  "default": true,
  readOnly: {
    type: "boolean",
    "default": false
  },
  examples: {
    type: "array",
    items: true
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    "default": true
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    "default": false
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    "default": {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  "const": true,
  "enum": {
    type: "array",
    items: true,
    minItems: 1,
    uniqueItems: true
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: true
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  "if": {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  "else": {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
};
var require$$3 = {
  $schema,
  $id,
  title,
  definitions,
  type,
  properties,
  "default": true
};
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
  const core_12 = core$2;
  const draft7_1 = draft7;
  const discriminator_1 = discriminator;
  const draft7MetaSchema = require$$3;
  const META_SUPPORT_DATA = ["/properties"];
  const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
  class Ajv extends core_12.default {
    _addVocabularies() {
      super._addVocabularies();
      draft7_1.default.forEach((v) => this.addVocabulary(v));
      if (this.opts.discriminator)
        this.addKeyword(discriminator_1.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      if (!this.opts.meta)
        return;
      const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
      this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
      this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
    }
  }
  module.exports = exports = Ajv;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = Ajv;
  var validate_12 = validate;
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
})(ajv, ajv.exports);
var dist = { exports: {} };
var formats = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
  function fmtDef(validate2, compare2) {
    return { validate: validate2, compare: compare2 };
  }
  exports.fullFormats = {
    date: fmtDef(date, compareDate),
    time: fmtDef(time, compareTime),
    "date-time": fmtDef(date_time, compareDateTime),
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex,
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    byte,
    int32: { type: "number", validate: validateInt32 },
    int64: { type: "number", validate: validateInt64 },
    float: { type: "number", validate: validateNumber },
    double: { type: "number", validate: validateNumber },
    password: true,
    binary: true
  };
  exports.fastFormats = __spreadProps(__spreadValues({}, exports.fullFormats), {
    date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
    time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
    "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
  });
  exports.formatNames = Object.keys(exports.fullFormats);
  function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function date(str) {
    const matches = DATE.exec(str);
    if (!matches)
      return false;
    const year = +matches[1];
    const month = +matches[2];
    const day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
  }
  function compareDate(d1, d2) {
    if (!(d1 && d2))
      return void 0;
    if (d1 > d2)
      return 1;
    if (d1 < d2)
      return -1;
    return 0;
  }
  const TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
  function time(str, withTimeZone) {
    const matches = TIME.exec(str);
    if (!matches)
      return false;
    const hour = +matches[1];
    const minute = +matches[2];
    const second = +matches[3];
    const timeZone = matches[5];
    return (hour <= 23 && minute <= 59 && second <= 59 || hour === 23 && minute === 59 && second === 60) && (!withTimeZone || timeZone !== "");
  }
  function compareTime(t1, t2) {
    if (!(t1 && t2))
      return void 0;
    const a1 = TIME.exec(t1);
    const a2 = TIME.exec(t2);
    if (!(a1 && a2))
      return void 0;
    t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
    t2 = a2[1] + a2[2] + a2[3] + (a2[4] || "");
    if (t1 > t2)
      return 1;
    if (t1 < t2)
      return -1;
    return 0;
  }
  const DATE_TIME_SEPARATOR = /t|\s/i;
  function date_time(str) {
    const dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true);
  }
  function compareDateTime(dt1, dt2) {
    if (!(dt1 && dt2))
      return void 0;
    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
    const res = compareDate(d1, d2);
    if (res === void 0)
      return void 0;
    return res || compareTime(t1, t2);
  }
  const NOT_URI_FRAGMENT = /\/|:/;
  const URI2 = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function uri(str) {
    return NOT_URI_FRAGMENT.test(str) && URI2.test(str);
  }
  const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function byte(str) {
    BYTE.lastIndex = 0;
    return BYTE.test(str);
  }
  const MIN_INT32 = -(2 ** 31);
  const MAX_INT32 = 2 ** 31 - 1;
  function validateInt32(value) {
    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
  }
  function validateInt64(value) {
    return Number.isInteger(value);
  }
  function validateNumber() {
    return true;
  }
  const Z_ANCHOR = /[^\\]\\Z/;
  function regex(str) {
    if (Z_ANCHOR.test(str))
      return false;
    try {
      new RegExp(str);
      return true;
    } catch (e) {
      return false;
    }
  }
})(formats);
var limit = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatLimitDefinition = void 0;
  const ajv_1 = ajv.exports;
  const codegen_12 = codegen;
  const ops2 = codegen_12.operators;
  const KWDs2 = {
    formatMaximum: { okStr: "<=", ok: ops2.LTE, fail: ops2.GT },
    formatMinimum: { okStr: ">=", ok: ops2.GTE, fail: ops2.LT },
    formatExclusiveMaximum: { okStr: "<", ok: ops2.LT, fail: ops2.GTE },
    formatExclusiveMinimum: { okStr: ">", ok: ops2.GT, fail: ops2.LTE }
  };
  const error2 = {
    message: ({ keyword: keyword2, schemaCode }) => codegen_12.str`should be ${KWDs2[keyword2].okStr} ${schemaCode}`,
    params: ({ keyword: keyword2, schemaCode }) => codegen_12._`{comparison: ${KWDs2[keyword2].okStr}, limit: ${schemaCode}}`
  };
  exports.formatLimitDefinition = {
    keyword: Object.keys(KWDs2),
    type: "string",
    schemaType: "string",
    $data: true,
    error: error2,
    code(cxt) {
      const { gen, data, schemaCode, keyword: keyword2, it } = cxt;
      const { opts: opts2, self: self2 } = it;
      if (!opts2.validateFormats)
        return;
      const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
      if (fCxt.$data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen.scopeValue("formats", {
          ref: self2.formats,
          code: opts2.code.formats
        });
        const fmt = gen.const("fmt", codegen_12._`${fmts}[${fCxt.schemaCode}]`);
        cxt.fail$data(codegen_12.or(codegen_12._`typeof ${fmt} != "object"`, codegen_12._`${fmt} instanceof RegExp`, codegen_12._`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
      }
      function validateFormat() {
        const format2 = fCxt.schema;
        const fmtDef = self2.formats[format2];
        if (!fmtDef || fmtDef === true)
          return;
        if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
          throw new Error(`"${keyword2}": format "${format2}" does not define "compare" function`);
        }
        const fmt = gen.scopeValue("formats", {
          key: format2,
          ref: fmtDef,
          code: opts2.code.formats ? codegen_12._`${opts2.code.formats}${codegen_12.getProperty(format2)}` : void 0
        });
        cxt.fail$data(compareCode(fmt));
      }
      function compareCode(fmt) {
        return codegen_12._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs2[keyword2].fail} 0`;
      }
    },
    dependencies: ["format"]
  };
  const formatLimitPlugin = (ajv2) => {
    ajv2.addKeyword(exports.formatLimitDefinition);
    return ajv2;
  };
  exports.default = formatLimitPlugin;
})(limit);
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const formats_1 = formats;
  const limit_1 = limit;
  const codegen_12 = codegen;
  const fullName = new codegen_12.Name("fullFormats");
  const fastName = new codegen_12.Name("fastFormats");
  const formatsPlugin = (ajv2, opts2 = { keywords: true }) => {
    if (Array.isArray(opts2)) {
      addFormats(ajv2, opts2, formats_1.fullFormats, fullName);
      return ajv2;
    }
    const [formats2, exportName] = opts2.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
    const list = opts2.formats || formats_1.formatNames;
    addFormats(ajv2, list, formats2, exportName);
    if (opts2.keywords)
      limit_1.default(ajv2);
    return ajv2;
  };
  formatsPlugin.get = (name, mode = "full") => {
    const formats2 = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
    const f = formats2[name];
    if (!f)
      throw new Error(`Unknown format "${name}"`);
    return f;
  };
  function addFormats(ajv2, list, fs2, exportName) {
    var _a;
    var _b;
    (_a = (_b = ajv2.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = codegen_12._`require("ajv-formats/dist/formats").${exportName}`;
    for (const f of list)
      ajv2.addFormat(f, fs2[f]);
  }
  module.exports = exports = formatsPlugin;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = formatsPlugin;
})(dist, dist.exports);
const copyProperty = (to, from, property, ignoreNonConfigurable) => {
  if (property === "length" || property === "prototype") {
    return;
  }
  if (property === "arguments" || property === "caller") {
    return;
  }
  const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
  const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
    return;
  }
  Object.defineProperty(to, property, fromDescriptor);
};
const canCopyProperty = function(toDescriptor, fromDescriptor) {
  return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
};
const changePrototype = (to, from) => {
  const fromPrototype = Object.getPrototypeOf(from);
  if (fromPrototype === Object.getPrototypeOf(to)) {
    return;
  }
  Object.setPrototypeOf(to, fromPrototype);
};
const wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
const toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
const toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
const changeToString = (to, from, name) => {
  const withName = name === "" ? "" : `with ${name.trim()}() `;
  const newToString = wrappedToString.bind(null, withName, from.toString());
  Object.defineProperty(newToString, "name", toStringName);
  Object.defineProperty(to, "toString", __spreadProps(__spreadValues({}, toStringDescriptor), { value: newToString }));
};
const mimicFn$4 = (to, from, { ignoreNonConfigurable = false } = {}) => {
  const { name } = to;
  for (const property of Reflect.ownKeys(from)) {
    copyProperty(to, from, property, ignoreNonConfigurable);
  }
  changePrototype(to, from);
  changeToString(to, from, name);
  return to;
};
var mimicFn_1 = mimicFn$4;
const mimicFn$3 = mimicFn_1;
var debounceFn = (inputFunction, options = {}) => {
  if (typeof inputFunction !== "function") {
    throw new TypeError(`Expected the first argument to be a function, got \`${typeof inputFunction}\``);
  }
  const {
    wait = 0,
    before = false,
    after = true
  } = options;
  if (!before && !after) {
    throw new Error("Both `before` and `after` are false, function wouldn't be called.");
  }
  let timeout;
  let result;
  const debouncedFunction = function(...arguments_) {
    const context = this;
    const later = () => {
      timeout = void 0;
      if (after) {
        result = inputFunction.apply(context, arguments_);
      }
    };
    const shouldCallNow = before && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (shouldCallNow) {
      result = inputFunction.apply(context, arguments_);
    }
    return result;
  };
  mimicFn$3(debouncedFunction, inputFunction);
  debouncedFunction.cancel = () => {
    if (timeout) {
      clearTimeout(timeout);
      timeout = void 0;
    }
  };
  return debouncedFunction;
};
var re$5 = { exports: {} };
const SEMVER_SPEC_VERSION = "2.0.0";
const MAX_LENGTH$2 = 256;
const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;
const MAX_SAFE_COMPONENT_LENGTH = 16;
var constants = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH: MAX_LENGTH$2,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  MAX_SAFE_COMPONENT_LENGTH
};
const debug$3 = typeof process === "object" && process.env && {}.NODE_DEBUG && /\bsemver\b/i.test({}.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
};
var debug_1 = debug$3;
(function(module, exports) {
  const { MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2 } = constants;
  const debug2 = debug_1;
  exports = module.exports = {};
  const re2 = exports.re = [];
  const src = exports.src = [];
  const t2 = exports.t = {};
  let R = 0;
  const createToken = (name, value, isGlobal) => {
    const index = R++;
    debug2(index, value);
    t2[name] = index;
    src[index] = value;
    re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
  createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
  createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NUMERICIDENTIFIER]}|${src[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NUMERICIDENTIFIERLOOSE]}|${src[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
  createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`);
  createToken("FULL", `^${src[t2.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`);
  createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:$|[^\\d])`);
  createToken("COERCERTL", src[t2.COERCE], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
})(re$5, re$5.exports);
const opts = ["includePrerelease", "loose", "rtl"];
const parseOptions$4 = (options) => !options ? {} : typeof options !== "object" ? { loose: true } : opts.filter((k) => options[k]).reduce((options2, k) => {
  options2[k] = true;
  return options2;
}, {});
var parseOptions_1 = parseOptions$4;
const numeric = /^[0-9]+$/;
const compareIdentifiers$1 = (a, b) => {
  const anum = numeric.test(a);
  const bnum = numeric.test(b);
  if (anum && bnum) {
    a = +a;
    b = +b;
  }
  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);
var identifiers = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
const debug$2 = debug_1;
const { MAX_LENGTH: MAX_LENGTH$1, MAX_SAFE_INTEGER } = constants;
const { re: re$4, t: t$4 } = re$5.exports;
const parseOptions$3 = parseOptions_1;
const { compareIdentifiers } = identifiers;
class SemVer$e {
  constructor(version, options) {
    options = parseOptions$3(options);
    if (version instanceof SemVer$e) {
      if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError(`Invalid Version: ${version}`);
    }
    if (version.length > MAX_LENGTH$1) {
      throw new TypeError(`version is longer than ${MAX_LENGTH$1} characters`);
    }
    debug$2("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    const m = version.trim().match(options.loose ? re$4[t$4.LOOSE] : re$4[t$4.FULL]);
    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`);
    }
    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map((id2) => {
        if (/^[0-9]+$/.test(id2)) {
          const num = +id2;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id2;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join(".")}`;
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug$2("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer$e)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer$e(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer$e)) {
      other = new SemVer$e(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  }
  comparePre(other) {
    if (!(other instanceof SemVer$e)) {
      other = new SemVer$e(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    let i = 0;
    do {
      const a = this.prerelease[i];
      const b = other.prerelease[i];
      debug$2("prerelease compare", i, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer$e)) {
      other = new SemVer$e(other, this.options);
    }
    let i = 0;
    do {
      const a = this.build[i];
      const b = other.build[i];
      debug$2("prerelease compare", i, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  inc(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          let i = this.prerelease.length;
          while (--i >= 0) {
            if (typeof this.prerelease[i] === "number") {
              this.prerelease[i]++;
              i = -2;
            }
          }
          if (i === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error(`invalid increment argument: ${release}`);
    }
    this.format();
    this.raw = this.version;
    return this;
  }
}
var semver$1 = SemVer$e;
const { MAX_LENGTH } = constants;
const { re: re$3, t: t$3 } = re$5.exports;
const SemVer$d = semver$1;
const parseOptions$2 = parseOptions_1;
const parse$5 = (version, options) => {
  options = parseOptions$2(options);
  if (version instanceof SemVer$d) {
    return version;
  }
  if (typeof version !== "string") {
    return null;
  }
  if (version.length > MAX_LENGTH) {
    return null;
  }
  const r = options.loose ? re$3[t$3.LOOSE] : re$3[t$3.FULL];
  if (!r.test(version)) {
    return null;
  }
  try {
    return new SemVer$d(version, options);
  } catch (er) {
    return null;
  }
};
var parse_1 = parse$5;
const parse$4 = parse_1;
const valid$1 = (version, options) => {
  const v = parse$4(version, options);
  return v ? v.version : null;
};
var valid_1 = valid$1;
const parse$3 = parse_1;
const clean = (version, options) => {
  const s = parse$3(version.trim().replace(/^[=v]+/, ""), options);
  return s ? s.version : null;
};
var clean_1 = clean;
const SemVer$c = semver$1;
const inc = (version, release, options, identifier) => {
  if (typeof options === "string") {
    identifier = options;
    options = void 0;
  }
  try {
    return new SemVer$c(version, options).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
};
var inc_1 = inc;
const SemVer$b = semver$1;
const compare$a = (a, b, loose) => new SemVer$b(a, loose).compare(new SemVer$b(b, loose));
var compare_1 = compare$a;
const compare$9 = compare_1;
const eq$2 = (a, b, loose) => compare$9(a, b, loose) === 0;
var eq_1 = eq$2;
const parse$2 = parse_1;
const eq$1 = eq_1;
const diff = (version1, version2) => {
  if (eq$1(version1, version2)) {
    return null;
  } else {
    const v1 = parse$2(version1);
    const v2 = parse$2(version2);
    const hasPre = v1.prerelease.length || v2.prerelease.length;
    const prefix = hasPre ? "pre" : "";
    const defaultResult = hasPre ? "prerelease" : "";
    for (const key in v1) {
      if (key === "major" || key === "minor" || key === "patch") {
        if (v1[key] !== v2[key]) {
          return prefix + key;
        }
      }
    }
    return defaultResult;
  }
};
var diff_1 = diff;
const SemVer$a = semver$1;
const major = (a, loose) => new SemVer$a(a, loose).major;
var major_1 = major;
const SemVer$9 = semver$1;
const minor = (a, loose) => new SemVer$9(a, loose).minor;
var minor_1 = minor;
const SemVer$8 = semver$1;
const patch = (a, loose) => new SemVer$8(a, loose).patch;
var patch_1 = patch;
const parse$1 = parse_1;
const prerelease = (version, options) => {
  const parsed = parse$1(version, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
var prerelease_1 = prerelease;
const compare$8 = compare_1;
const rcompare = (a, b, loose) => compare$8(b, a, loose);
var rcompare_1 = rcompare;
const compare$7 = compare_1;
const compareLoose = (a, b) => compare$7(a, b, true);
var compareLoose_1 = compareLoose;
const SemVer$7 = semver$1;
const compareBuild$2 = (a, b, loose) => {
  const versionA = new SemVer$7(a, loose);
  const versionB = new SemVer$7(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
var compareBuild_1 = compareBuild$2;
const compareBuild$1 = compareBuild_1;
const sort = (list, loose) => list.sort((a, b) => compareBuild$1(a, b, loose));
var sort_1 = sort;
const compareBuild = compareBuild_1;
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
var rsort_1 = rsort;
const compare$6 = compare_1;
const gt$3 = (a, b, loose) => compare$6(a, b, loose) > 0;
var gt_1 = gt$3;
const compare$5 = compare_1;
const lt$2 = (a, b, loose) => compare$5(a, b, loose) < 0;
var lt_1 = lt$2;
const compare$4 = compare_1;
const neq$1 = (a, b, loose) => compare$4(a, b, loose) !== 0;
var neq_1 = neq$1;
const compare$3 = compare_1;
const gte$2 = (a, b, loose) => compare$3(a, b, loose) >= 0;
var gte_1 = gte$2;
const compare$2 = compare_1;
const lte$2 = (a, b, loose) => compare$2(a, b, loose) <= 0;
var lte_1 = lte$2;
const eq = eq_1;
const neq = neq_1;
const gt$2 = gt_1;
const gte$1 = gte_1;
const lt$1 = lt_1;
const lte$1 = lte_1;
const cmp$1 = (a, op, b, loose) => {
  switch (op) {
    case "===":
      if (typeof a === "object")
        a = a.version;
      if (typeof b === "object")
        b = b.version;
      return a === b;
    case "!==":
      if (typeof a === "object")
        a = a.version;
      if (typeof b === "object")
        b = b.version;
      return a !== b;
    case "":
    case "=":
    case "==":
      return eq(a, b, loose);
    case "!=":
      return neq(a, b, loose);
    case ">":
      return gt$2(a, b, loose);
    case ">=":
      return gte$1(a, b, loose);
    case "<":
      return lt$1(a, b, loose);
    case "<=":
      return lte$1(a, b, loose);
    default:
      throw new TypeError(`Invalid operator: ${op}`);
  }
};
var cmp_1 = cmp$1;
const SemVer$6 = semver$1;
const parse = parse_1;
const { re: re$2, t: t$2 } = re$5.exports;
const coerce = (version, options) => {
  if (version instanceof SemVer$6) {
    return version;
  }
  if (typeof version === "number") {
    version = String(version);
  }
  if (typeof version !== "string") {
    return null;
  }
  options = options || {};
  let match = null;
  if (!options.rtl) {
    match = version.match(re$2[t$2.COERCE]);
  } else {
    let next;
    while ((next = re$2[t$2.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      re$2[t$2.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
    }
    re$2[t$2.COERCERTL].lastIndex = -1;
  }
  if (match === null)
    return null;
  return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
};
var coerce_1 = coerce;
var iterator = function(Yallist2) {
  Yallist2.prototype[Symbol.iterator] = function* () {
    for (let walker = this.head; walker; walker = walker.next) {
      yield walker.value;
    }
  };
};
var yallist = Yallist$1;
Yallist$1.Node = Node;
Yallist$1.create = Yallist$1;
function Yallist$1(list) {
  var self2 = this;
  if (!(self2 instanceof Yallist$1)) {
    self2 = new Yallist$1();
  }
  self2.tail = null;
  self2.head = null;
  self2.length = 0;
  if (list && typeof list.forEach === "function") {
    list.forEach(function(item) {
      self2.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self2.push(arguments[i]);
    }
  }
  return self2;
}
Yallist$1.prototype.removeNode = function(node) {
  if (node.list !== this) {
    throw new Error("removing node which does not belong to this list");
  }
  var next = node.next;
  var prev = node.prev;
  if (next) {
    next.prev = prev;
  }
  if (prev) {
    prev.next = next;
  }
  if (node === this.head) {
    this.head = next;
  }
  if (node === this.tail) {
    this.tail = prev;
  }
  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;
  return next;
};
Yallist$1.prototype.unshiftNode = function(node) {
  if (node === this.head) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var head = this.head;
  node.list = this;
  node.next = head;
  if (head) {
    head.prev = node;
  }
  this.head = node;
  if (!this.tail) {
    this.tail = node;
  }
  this.length++;
};
Yallist$1.prototype.pushNode = function(node) {
  if (node === this.tail) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var tail = this.tail;
  node.list = this;
  node.prev = tail;
  if (tail) {
    tail.next = node;
  }
  this.tail = node;
  if (!this.head) {
    this.head = node;
  }
  this.length++;
};
Yallist$1.prototype.push = function() {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i]);
  }
  return this.length;
};
Yallist$1.prototype.unshift = function() {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i]);
  }
  return this.length;
};
Yallist$1.prototype.pop = function() {
  if (!this.tail) {
    return void 0;
  }
  var res = this.tail.value;
  this.tail = this.tail.prev;
  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.shift = function() {
  if (!this.head) {
    return void 0;
  }
  var res = this.head.value;
  this.head = this.head.next;
  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.forEach = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.next;
  }
};
Yallist$1.prototype.forEachReverse = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.prev;
  }
};
Yallist$1.prototype.get = function(n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    walker = walker.next;
  }
  if (i === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.getReverse = function(n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    walker = walker.prev;
  }
  if (i === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.map = function(fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.head; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }
  return res;
};
Yallist$1.prototype.mapReverse = function(fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.tail; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }
  return res;
};
Yallist$1.prototype.reduce = function(fn, initial) {
  var acc;
  var walker = this.head;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i);
    walker = walker.next;
  }
  return acc;
};
Yallist$1.prototype.reduceReverse = function(fn, initial) {
  var acc;
  var walker = this.tail;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i);
    walker = walker.prev;
  }
  return acc;
};
Yallist$1.prototype.toArray = function() {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.next;
  }
  return arr;
};
Yallist$1.prototype.toArrayReverse = function() {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.prev;
  }
  return arr;
};
Yallist$1.prototype.slice = function(from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next;
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.sliceReverse = function(from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev;
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.splice = function(start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1;
  }
  if (start < 0) {
    start = this.length + start;
  }
  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next;
  }
  var ret = [];
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }
  if (walker === null) {
    walker = this.tail;
  }
  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }
  for (var i = 0; i < nodes.length; i++) {
    walker = insert(this, walker, nodes[i]);
  }
  return ret;
};
Yallist$1.prototype.reverse = function() {
  var head = this.head;
  var tail = this.tail;
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }
  this.head = tail;
  this.tail = head;
  return this;
};
function insert(self2, node, value) {
  var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
  if (inserted.next === null) {
    self2.tail = inserted;
  }
  if (inserted.prev === null) {
    self2.head = inserted;
  }
  self2.length++;
  return inserted;
}
function push(self2, item) {
  self2.tail = new Node(item, self2.tail, null, self2);
  if (!self2.head) {
    self2.head = self2.tail;
  }
  self2.length++;
}
function unshift(self2, item) {
  self2.head = new Node(item, null, self2.head, self2);
  if (!self2.tail) {
    self2.tail = self2.head;
  }
  self2.length++;
}
function Node(value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list);
  }
  this.list = list;
  this.value = value;
  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }
  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}
try {
  iterator(Yallist$1);
} catch (er) {
}
const Yallist = yallist;
const MAX = Symbol("max");
const LENGTH = Symbol("length");
const LENGTH_CALCULATOR = Symbol("lengthCalculator");
const ALLOW_STALE = Symbol("allowStale");
const MAX_AGE = Symbol("maxAge");
const DISPOSE = Symbol("dispose");
const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
const LRU_LIST = Symbol("lruList");
const CACHE = Symbol("cache");
const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
const naiveLength = () => 1;
class LRUCache {
  constructor(options) {
    if (typeof options === "number")
      options = { max: options };
    if (!options)
      options = {};
    if (options.max && (typeof options.max !== "number" || options.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[MAX] = options.max || Infinity;
    const lc = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  }
  set max(mL) {
    if (typeof mL !== "number" || mL < 0)
      throw new TypeError("max must be a non-negative number");
    this[MAX] = mL || Infinity;
    trim(this);
  }
  get max() {
    return this[MAX];
  }
  set allowStale(allowStale) {
    this[ALLOW_STALE] = !!allowStale;
  }
  get allowStale() {
    return this[ALLOW_STALE];
  }
  set maxAge(mA) {
    if (typeof mA !== "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[MAX_AGE] = mA;
    trim(this);
  }
  get maxAge() {
    return this[MAX_AGE];
  }
  set lengthCalculator(lC) {
    if (typeof lC !== "function")
      lC = naiveLength;
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC;
      this[LENGTH] = 0;
      this[LRU_LIST].forEach((hit) => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
        this[LENGTH] += hit.length;
      });
    }
    trim(this);
  }
  get lengthCalculator() {
    return this[LENGTH_CALCULATOR];
  }
  get length() {
    return this[LENGTH];
  }
  get itemCount() {
    return this[LRU_LIST].length;
  }
  rforEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].tail; walker !== null; ) {
      const prev = walker.prev;
      forEachStep(this, fn, walker, thisp);
      walker = prev;
    }
  }
  forEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].head; walker !== null; ) {
      const next = walker.next;
      forEachStep(this, fn, walker, thisp);
      walker = next;
    }
  }
  keys() {
    return this[LRU_LIST].toArray().map((k) => k.key);
  }
  values() {
    return this[LRU_LIST].toArray().map((k) => k.value);
  }
  reset() {
    if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
      this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
    }
    this[CACHE] = new Map();
    this[LRU_LIST] = new Yallist();
    this[LENGTH] = 0;
  }
  dump() {
    return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
      k: hit.key,
      v: hit.value,
      e: hit.now + (hit.maxAge || 0)
    }).toArray().filter((h) => h);
  }
  dumpLru() {
    return this[LRU_LIST];
  }
  set(key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE];
    if (maxAge && typeof maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    const now = maxAge ? Date.now() : 0;
    const len = this[LENGTH_CALCULATOR](value, key);
    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key));
        return false;
      }
      const node = this[CACHE].get(key);
      const item = node.value;
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value);
      }
      item.now = now;
      item.maxAge = maxAge;
      item.value = value;
      this[LENGTH] += len - item.length;
      item.length = len;
      this.get(key);
      trim(this);
      return true;
    }
    const hit = new Entry(key, value, len, now, maxAge);
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value);
      return false;
    }
    this[LENGTH] += hit.length;
    this[LRU_LIST].unshift(hit);
    this[CACHE].set(key, this[LRU_LIST].head);
    trim(this);
    return true;
  }
  has(key) {
    if (!this[CACHE].has(key))
      return false;
    const hit = this[CACHE].get(key).value;
    return !isStale(this, hit);
  }
  get(key) {
    return get(this, key, true);
  }
  peek(key) {
    return get(this, key, false);
  }
  pop() {
    const node = this[LRU_LIST].tail;
    if (!node)
      return null;
    del(this, node);
    return node.value;
  }
  del(key) {
    del(this, this[CACHE].get(key));
  }
  load(arr) {
    this.reset();
    const now = Date.now();
    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l];
      const expiresAt = hit.e || 0;
      if (expiresAt === 0)
        this.set(hit.k, hit.v);
      else {
        const maxAge = expiresAt - now;
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge);
        }
      }
    }
  }
  prune() {
    this[CACHE].forEach((value, key) => get(this, key, false));
  }
}
const get = (self2, key, doUse) => {
  const node = self2[CACHE].get(key);
  if (node) {
    const hit = node.value;
    if (isStale(self2, hit)) {
      del(self2, node);
      if (!self2[ALLOW_STALE])
        return void 0;
    } else {
      if (doUse) {
        if (self2[UPDATE_AGE_ON_GET])
          node.value.now = Date.now();
        self2[LRU_LIST].unshiftNode(node);
      }
    }
    return hit.value;
  }
};
const isStale = (self2, hit) => {
  if (!hit || !hit.maxAge && !self2[MAX_AGE])
    return false;
  const diff2 = Date.now() - hit.now;
  return hit.maxAge ? diff2 > hit.maxAge : self2[MAX_AGE] && diff2 > self2[MAX_AGE];
};
const trim = (self2) => {
  if (self2[LENGTH] > self2[MAX]) {
    for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
      const prev = walker.prev;
      del(self2, walker);
      walker = prev;
    }
  }
};
const del = (self2, node) => {
  if (node) {
    const hit = node.value;
    if (self2[DISPOSE])
      self2[DISPOSE](hit.key, hit.value);
    self2[LENGTH] -= hit.length;
    self2[CACHE].delete(hit.key);
    self2[LRU_LIST].removeNode(node);
  }
};
class Entry {
  constructor(key, value, length, now, maxAge) {
    this.key = key;
    this.value = value;
    this.length = length;
    this.now = now;
    this.maxAge = maxAge || 0;
  }
}
const forEachStep = (self2, fn, node, thisp) => {
  let hit = node.value;
  if (isStale(self2, hit)) {
    del(self2, node);
    if (!self2[ALLOW_STALE])
      hit = void 0;
  }
  if (hit)
    fn.call(thisp, hit.value, hit.key, self2);
};
var lruCache = LRUCache;
class Range$a {
  constructor(range2, options) {
    options = parseOptions$1(options);
    if (range2 instanceof Range$a) {
      if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
        return range2;
      } else {
        return new Range$a(range2.raw, options);
      }
    }
    if (range2 instanceof Comparator$3) {
      this.raw = range2.value;
      this.set = [[range2]];
      this.format();
      return this;
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range2;
    this.set = range2.split(/\s*\|\|\s*/).map((range3) => this.parseRange(range3.trim())).filter((c) => c.length);
    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${range2}`);
    }
    if (this.set.length > 1) {
      const first = this.set[0];
      this.set = this.set.filter((c) => !isNullSet(c[0]));
      if (this.set.length === 0)
        this.set = [first];
      else if (this.set.length > 1) {
        for (const c of this.set) {
          if (c.length === 1 && isAny(c[0])) {
            this.set = [c];
            break;
          }
        }
      }
    }
    this.format();
  }
  format() {
    this.range = this.set.map((comps) => {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  }
  toString() {
    return this.range;
  }
  parseRange(range2) {
    range2 = range2.trim();
    const memoOpts = Object.keys(this.options).join(",");
    const memoKey = `parseRange:${memoOpts}:${range2}`;
    const cached = cache.get(memoKey);
    if (cached)
      return cached;
    const loose = this.options.loose;
    const hr = loose ? re$1[t$1.HYPHENRANGELOOSE] : re$1[t$1.HYPHENRANGE];
    range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
    debug$1("hyphen replace", range2);
    range2 = range2.replace(re$1[t$1.COMPARATORTRIM], comparatorTrimReplace);
    debug$1("comparator trim", range2, re$1[t$1.COMPARATORTRIM]);
    range2 = range2.replace(re$1[t$1.TILDETRIM], tildeTrimReplace);
    range2 = range2.replace(re$1[t$1.CARETTRIM], caretTrimReplace);
    range2 = range2.split(/\s+/).join(" ");
    const compRe = loose ? re$1[t$1.COMPARATORLOOSE] : re$1[t$1.COMPARATOR];
    const rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator$3(comp, this.options));
    rangeList.length;
    const rangeMap = new Map();
    for (const comp of rangeList) {
      if (isNullSet(comp))
        return [comp];
      rangeMap.set(comp.value, comp);
    }
    if (rangeMap.size > 1 && rangeMap.has(""))
      rangeMap.delete("");
    const result = [...rangeMap.values()];
    cache.set(memoKey, result);
    return result;
  }
  intersects(range2, options) {
    if (!(range2 instanceof Range$a)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some((thisComparators) => {
      return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
        return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
          return rangeComparators.every((rangeComparator) => {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  }
  test(version) {
    if (!version) {
      return false;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer$5(version, this.options);
      } catch (er) {
        return false;
      }
    }
    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true;
      }
    }
    return false;
  }
}
var range = Range$a;
const LRU = lruCache;
const cache = new LRU({ max: 1e3 });
const parseOptions$1 = parseOptions_1;
const Comparator$3 = comparator;
const debug$1 = debug_1;
const SemVer$5 = semver$1;
const {
  re: re$1,
  t: t$1,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace
} = re$5.exports;
const isNullSet = (c) => c.value === "<0.0.0-0";
const isAny = (c) => c.value === "";
const isSatisfiable = (comparators, options) => {
  let result = true;
  const remainingComparators = comparators.slice();
  let testComparator = remainingComparators.pop();
  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options);
    });
    testComparator = remainingComparators.pop();
  }
  return result;
};
const parseComparator = (comp, options) => {
  debug$1("comp", comp, options);
  comp = replaceCarets(comp, options);
  debug$1("caret", comp);
  comp = replaceTildes(comp, options);
  debug$1("tildes", comp);
  comp = replaceXRanges(comp, options);
  debug$1("xrange", comp);
  comp = replaceStars(comp, options);
  debug$1("stars", comp);
  return comp;
};
const isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
const replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
  return replaceTilde(comp2, options);
}).join(" ");
const replaceTilde = (comp, options) => {
  const r = options.loose ? re$1[t$1.TILDELOOSE] : re$1[t$1.TILDE];
  return comp.replace(r, (_, M, m, p, pr) => {
    debug$1("tilde", comp, _, M, m, p, pr);
    let ret;
    if (isX(M)) {
      ret = "";
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
    } else if (isX(p)) {
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
    } else if (pr) {
      debug$1("replaceTilde pr", pr);
      ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
    } else {
      ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
    }
    debug$1("tilde return", ret);
    return ret;
  });
};
const replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
  return replaceCaret(comp2, options);
}).join(" ");
const replaceCaret = (comp, options) => {
  debug$1("caret", comp, options);
  const r = options.loose ? re$1[t$1.CARETLOOSE] : re$1[t$1.CARET];
  const z = options.includePrerelease ? "-0" : "";
  return comp.replace(r, (_, M, m, p, pr) => {
    debug$1("caret", comp, _, M, m, p, pr);
    let ret;
    if (isX(M)) {
      ret = "";
    } else if (isX(m)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
    } else if (isX(p)) {
      if (M === "0") {
        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
      }
    } else if (pr) {
      debug$1("replaceCaret pr", pr);
      if (M === "0") {
        if (m === "0") {
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
      }
    } else {
      debug$1("no pr");
      if (M === "0") {
        if (m === "0") {
          ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
        } else {
          ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
        }
      } else {
        ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
      }
    }
    debug$1("caret return", ret);
    return ret;
  });
};
const replaceXRanges = (comp, options) => {
  debug$1("replaceXRanges", comp, options);
  return comp.split(/\s+/).map((comp2) => {
    return replaceXRange(comp2, options);
  }).join(" ");
};
const replaceXRange = (comp, options) => {
  comp = comp.trim();
  const r = options.loose ? re$1[t$1.XRANGELOOSE] : re$1[t$1.XRANGE];
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug$1("xRange", comp, ret, gtlt, M, m, p, pr);
    const xM = isX(M);
    const xm = xM || isX(m);
    const xp = xm || isX(p);
    const anyX = xp;
    if (gtlt === "=" && anyX) {
      gtlt = "";
    }
    pr = options.includePrerelease ? "-0" : "";
    if (xM) {
      if (gtlt === ">" || gtlt === "<") {
        ret = "<0.0.0-0";
      } else {
        ret = "*";
      }
    } else if (gtlt && anyX) {
      if (xm) {
        m = 0;
      }
      p = 0;
      if (gtlt === ">") {
        gtlt = ">=";
        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === "<=") {
        gtlt = "<";
        if (xm) {
          M = +M + 1;
        } else {
          m = +m + 1;
        }
      }
      if (gtlt === "<")
        pr = "-0";
      ret = `${gtlt + M}.${m}.${p}${pr}`;
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
    }
    debug$1("xRange return", ret);
    return ret;
  });
};
const replaceStars = (comp, options) => {
  debug$1("replaceStars", comp, options);
  return comp.trim().replace(re$1[t$1.STAR], "");
};
const replaceGTE0 = (comp, options) => {
  debug$1("replaceGTE0", comp, options);
  return comp.trim().replace(re$1[options.includePrerelease ? t$1.GTE0PRE : t$1.GTE0], "");
};
const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
  if (isX(fM)) {
    from = "";
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
  } else if (fpr) {
    from = `>=${from}`;
  } else {
    from = `>=${from}${incPr ? "-0" : ""}`;
  }
  if (isX(tM)) {
    to = "";
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`;
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`;
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`;
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`;
  } else {
    to = `<=${to}`;
  }
  return `${from} ${to}`.trim();
};
const testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false;
    }
  }
  if (version.prerelease.length && !options.includePrerelease) {
    for (let i = 0; i < set.length; i++) {
      debug$1(set[i].semver);
      if (set[i].semver === Comparator$3.ANY) {
        continue;
      }
      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver;
        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
          return true;
        }
      }
    }
    return false;
  }
  return true;
};
const ANY$2 = Symbol("SemVer ANY");
class Comparator$2 {
  static get ANY() {
    return ANY$2;
  }
  constructor(comp, options) {
    options = parseOptions(options);
    if (comp instanceof Comparator$2) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    debug("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY$2) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug("comp", this);
  }
  parse(comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
    const m = comp.match(r);
    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp}`);
    }
    this.operator = m[1] !== void 0 ? m[1] : "";
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m[2]) {
      this.semver = ANY$2;
    } else {
      this.semver = new SemVer$4(m[2], this.options.loose);
    }
  }
  toString() {
    return this.value;
  }
  test(version) {
    debug("Comparator.test", version, this.options.loose);
    if (this.semver === ANY$2 || version === ANY$2) {
      return true;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer$4(version, this.options);
      } catch (er) {
        return false;
      }
    }
    return cmp(version, this.operator, this.semver, this.options);
  }
  intersects(comp, options) {
    if (!(comp instanceof Comparator$2)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (this.operator === "") {
      if (this.value === "") {
        return true;
      }
      return new Range$9(comp.value, options).test(this.value);
    } else if (comp.operator === "") {
      if (comp.value === "") {
        return true;
      }
      return new Range$9(this.value, options).test(comp.semver);
    }
    const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    const sameSemVer = this.semver.version === comp.semver.version;
    const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
    const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  }
}
var comparator = Comparator$2;
const parseOptions = parseOptions_1;
const { re, t } = re$5.exports;
const cmp = cmp_1;
const debug = debug_1;
const SemVer$4 = semver$1;
const Range$9 = range;
const Range$8 = range;
const satisfies$3 = (version, range2, options) => {
  try {
    range2 = new Range$8(range2, options);
  } catch (er) {
    return false;
  }
  return range2.test(version);
};
var satisfies_1 = satisfies$3;
const Range$7 = range;
const toComparators = (range2, options) => new Range$7(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
var toComparators_1 = toComparators;
const SemVer$3 = semver$1;
const Range$6 = range;
const maxSatisfying = (versions, range2, options) => {
  let max = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$6(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!max || maxSV.compare(v) === -1) {
        max = v;
        maxSV = new SemVer$3(max, options);
      }
    }
  });
  return max;
};
var maxSatisfying_1 = maxSatisfying;
const SemVer$2 = semver$1;
const Range$5 = range;
const minSatisfying = (versions, range2, options) => {
  let min = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$5(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!min || minSV.compare(v) === 1) {
        min = v;
        minSV = new SemVer$2(min, options);
      }
    }
  });
  return min;
};
var minSatisfying_1 = minSatisfying;
const SemVer$1 = semver$1;
const Range$4 = range;
const gt$1 = gt_1;
const minVersion = (range2, loose) => {
  range2 = new Range$4(range2, loose);
  let minver = new SemVer$1("0.0.0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = new SemVer$1("0.0.0-0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = null;
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let setMin = null;
    comparators.forEach((comparator2) => {
      const compver = new SemVer$1(comparator2.semver.version);
      switch (comparator2.operator) {
        case ">":
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
        case "":
        case ">=":
          if (!setMin || gt$1(compver, setMin)) {
            setMin = compver;
          }
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${comparator2.operator}`);
      }
    });
    if (setMin && (!minver || gt$1(minver, setMin)))
      minver = setMin;
  }
  if (minver && range2.test(minver)) {
    return minver;
  }
  return null;
};
var minVersion_1 = minVersion;
const Range$3 = range;
const validRange = (range2, options) => {
  try {
    return new Range$3(range2, options).range || "*";
  } catch (er) {
    return null;
  }
};
var valid = validRange;
const SemVer = semver$1;
const Comparator$1 = comparator;
const { ANY: ANY$1 } = Comparator$1;
const Range$2 = range;
const satisfies$2 = satisfies_1;
const gt = gt_1;
const lt = lt_1;
const lte = lte_1;
const gte = gte_1;
const outside$2 = (version, range2, hilo, options) => {
  version = new SemVer(version, options);
  range2 = new Range$2(range2, options);
  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case ">":
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = ">";
      ecomp = ">=";
      break;
    case "<":
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = "<";
      ecomp = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (satisfies$2(version, range2, options)) {
    return false;
  }
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let high = null;
    let low = null;
    comparators.forEach((comparator2) => {
      if (comparator2.semver === ANY$1) {
        comparator2 = new Comparator$1(">=0.0.0");
      }
      high = high || comparator2;
      low = low || comparator2;
      if (gtfn(comparator2.semver, high.semver, options)) {
        high = comparator2;
      } else if (ltfn(comparator2.semver, low.semver, options)) {
        low = comparator2;
      }
    });
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }
    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }
  return true;
};
var outside_1 = outside$2;
const outside$1 = outside_1;
const gtr = (version, range2, options) => outside$1(version, range2, ">", options);
var gtr_1 = gtr;
const outside = outside_1;
const ltr = (version, range2, options) => outside(version, range2, "<", options);
var ltr_1 = ltr;
const Range$1 = range;
const intersects = (r1, r2, options) => {
  r1 = new Range$1(r1, options);
  r2 = new Range$1(r2, options);
  return r1.intersects(r2);
};
var intersects_1 = intersects;
const satisfies$1 = satisfies_1;
const compare$1 = compare_1;
var simplify = (versions, range2, options) => {
  const set = [];
  let min = null;
  let prev = null;
  const v = versions.sort((a, b) => compare$1(a, b, options));
  for (const version of v) {
    const included = satisfies$1(version, range2, options);
    if (included) {
      prev = version;
      if (!min)
        min = version;
    } else {
      if (prev) {
        set.push([min, prev]);
      }
      prev = null;
      min = null;
    }
  }
  if (min)
    set.push([min, null]);
  const ranges = [];
  for (const [min2, max] of set) {
    if (min2 === max)
      ranges.push(min2);
    else if (!max && min2 === v[0])
      ranges.push("*");
    else if (!max)
      ranges.push(`>=${min2}`);
    else if (min2 === v[0])
      ranges.push(`<=${max}`);
    else
      ranges.push(`${min2} - ${max}`);
  }
  const simplified = ranges.join(" || ");
  const original = typeof range2.raw === "string" ? range2.raw : String(range2);
  return simplified.length < original.length ? simplified : range2;
};
const Range = range;
const Comparator = comparator;
const { ANY } = Comparator;
const satisfies = satisfies_1;
const compare = compare_1;
const subset = (sub, dom, options = {}) => {
  if (sub === dom)
    return true;
  sub = new Range(sub, options);
  dom = new Range(dom, options);
  let sawNonNull = false;
  OUTER:
    for (const simpleSub of sub.set) {
      for (const simpleDom of dom.set) {
        const isSub = simpleSubset(simpleSub, simpleDom, options);
        sawNonNull = sawNonNull || isSub !== null;
        if (isSub)
          continue OUTER;
      }
      if (sawNonNull)
        return false;
    }
  return true;
};
const simpleSubset = (sub, dom, options) => {
  if (sub === dom)
    return true;
  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY)
      return true;
    else if (options.includePrerelease)
      sub = [new Comparator(">=0.0.0-0")];
    else
      sub = [new Comparator(">=0.0.0")];
  }
  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease)
      return true;
    else
      dom = [new Comparator(">=0.0.0")];
  }
  const eqSet = new Set();
  let gt2, lt2;
  for (const c of sub) {
    if (c.operator === ">" || c.operator === ">=")
      gt2 = higherGT(gt2, c, options);
    else if (c.operator === "<" || c.operator === "<=")
      lt2 = lowerLT(lt2, c, options);
    else
      eqSet.add(c.semver);
  }
  if (eqSet.size > 1)
    return null;
  let gtltComp;
  if (gt2 && lt2) {
    gtltComp = compare(gt2.semver, lt2.semver, options);
    if (gtltComp > 0)
      return null;
    else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<="))
      return null;
  }
  for (const eq2 of eqSet) {
    if (gt2 && !satisfies(eq2, String(gt2), options))
      return null;
    if (lt2 && !satisfies(eq2, String(lt2), options))
      return null;
    for (const c of dom) {
      if (!satisfies(eq2, String(c), options))
        return false;
    }
    return true;
  }
  let higher, lower;
  let hasDomLT, hasDomGT;
  let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
  let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }
  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
    hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
    if (gt2) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false;
        }
      }
      if (c.operator === ">" || c.operator === ">=") {
        higher = higherGT(gt2, c, options);
        if (higher === c && higher !== gt2)
          return false;
      } else if (gt2.operator === ">=" && !satisfies(gt2.semver, String(c), options))
        return false;
    }
    if (lt2) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false;
        }
      }
      if (c.operator === "<" || c.operator === "<=") {
        lower = lowerLT(lt2, c, options);
        if (lower === c && lower !== lt2)
          return false;
      } else if (lt2.operator === "<=" && !satisfies(lt2.semver, String(c), options))
        return false;
    }
    if (!c.operator && (lt2 || gt2) && gtltComp !== 0)
      return false;
  }
  if (gt2 && hasDomLT && !lt2 && gtltComp !== 0)
    return false;
  if (lt2 && hasDomGT && !gt2 && gtltComp !== 0)
    return false;
  if (needDomGTPre || needDomLTPre)
    return false;
  return true;
};
const higherGT = (a, b, options) => {
  if (!a)
    return b;
  const comp = compare(a.semver, b.semver, options);
  return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
};
const lowerLT = (a, b, options) => {
  if (!a)
    return b;
  const comp = compare(a.semver, b.semver, options);
  return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
};
var subset_1 = subset;
const internalRe = re$5.exports;
var semver = {
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  SemVer: semver$1,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers,
  parse: parse_1,
  valid: valid_1,
  clean: clean_1,
  inc: inc_1,
  diff: diff_1,
  major: major_1,
  minor: minor_1,
  patch: patch_1,
  prerelease: prerelease_1,
  compare: compare_1,
  rcompare: rcompare_1,
  compareLoose: compareLoose_1,
  compareBuild: compareBuild_1,
  sort: sort_1,
  rsort: rsort_1,
  gt: gt_1,
  lt: lt_1,
  eq: eq_1,
  neq: neq_1,
  gte: gte_1,
  lte: lte_1,
  cmp: cmp_1,
  coerce: coerce_1,
  Comparator: comparator,
  Range: range,
  satisfies: satisfies_1,
  toComparators: toComparators_1,
  maxSatisfying: maxSatisfying_1,
  minSatisfying: minSatisfying_1,
  minVersion: minVersion_1,
  validRange: valid,
  outside: outside_1,
  gtr: gtr_1,
  ltr: ltr_1,
  intersects: intersects_1,
  simplifyRange: simplify,
  subset: subset_1
};
var onetime$1 = { exports: {} };
var mimicFn$2 = { exports: {} };
const mimicFn$1 = (to, from) => {
  for (const prop of Reflect.ownKeys(from)) {
    Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
  }
  return to;
};
mimicFn$2.exports = mimicFn$1;
mimicFn$2.exports.default = mimicFn$1;
const mimicFn = mimicFn$2.exports;
const calledFunctions = new WeakMap();
const onetime = (function_, options = {}) => {
  if (typeof function_ !== "function") {
    throw new TypeError("Expected a function");
  }
  let returnValue;
  let callCount = 0;
  const functionName = function_.displayName || function_.name || "<anonymous>";
  const onetime2 = function(...arguments_) {
    calledFunctions.set(onetime2, ++callCount);
    if (callCount === 1) {
      returnValue = function_.apply(this, arguments_);
      function_ = null;
    } else if (options.throw === true) {
      throw new Error(`Function \`${functionName}\` can only be called once`);
    }
    return returnValue;
  };
  mimicFn(onetime2, function_);
  calledFunctions.set(onetime2, callCount);
  return onetime2;
};
onetime$1.exports = onetime;
onetime$1.exports.default = onetime;
onetime$1.exports.callCount = (function_) => {
  if (!calledFunctions.has(function_)) {
    throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
  }
  return calledFunctions.get(function_);
};
(function(module, exports) {
  var __classPrivateFieldSet = commonjsGlobal && commonjsGlobal.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = commonjsGlobal && commonjsGlobal.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _a, _b;
  var _Conf_validator, _Conf_encryptionKey, _Conf_options, _Conf_defaultValues;
  Object.defineProperty(exports, "__esModule", { value: true });
  const util_12 = require$$4__default["default"];
  const fs2 = require$$0__default$3["default"];
  const path2 = require$$1__default["default"];
  const crypto = require$$3__default["default"];
  const assert2 = require$$5__default["default"];
  const events_1 = require$$5__default$1["default"];
  const dotProp$1 = dotProp;
  const pkgUp$1 = pkgUp.exports;
  const envPaths2 = envPaths$1.exports;
  const atomically = dist$1;
  const ajv_1 = ajv.exports;
  const ajv_formats_1 = dist.exports;
  const debounceFn$1 = debounceFn;
  const semver$12 = semver;
  const onetime2 = onetime$1.exports;
  const encryptionAlgorithm = "aes-256-cbc";
  const createPlainObject = () => {
    return Object.create(null);
  };
  const isExist = (data) => {
    return data !== void 0 && data !== null;
  };
  let parentDir = "";
  try {
    delete require.cache[__filename];
    parentDir = path2.dirname((_b = (_a = module.parent) === null || _a === void 0 ? void 0 : _a.filename) !== null && _b !== void 0 ? _b : ".");
  } catch (_c) {
  }
  const checkValueType = (key, value) => {
    const nonJsonTypes = new Set([
      "undefined",
      "symbol",
      "function"
    ]);
    const type2 = typeof value;
    if (nonJsonTypes.has(type2)) {
      throw new TypeError(`Setting a value of type \`${type2}\` for key \`${key}\` is not allowed as it's not supported by JSON`);
    }
  };
  const INTERNAL_KEY = "__internal__";
  const MIGRATION_KEY = `${INTERNAL_KEY}.migrations.version`;
  class Conf2 {
    constructor(partialOptions = {}) {
      var _a2;
      _Conf_validator.set(this, void 0);
      _Conf_encryptionKey.set(this, void 0);
      _Conf_options.set(this, void 0);
      _Conf_defaultValues.set(this, {});
      this._deserialize = (value) => JSON.parse(value);
      this._serialize = (value) => JSON.stringify(value, void 0, "	");
      const options = __spreadValues({
        configName: "config",
        fileExtension: "json",
        projectSuffix: "nodejs",
        clearInvalidConfig: false,
        accessPropertiesByDotNotation: true
      }, partialOptions);
      const getPackageData = onetime2(() => {
        const packagePath = pkgUp$1.sync({ cwd: parentDir });
        const packageData = packagePath && JSON.parse(fs2.readFileSync(packagePath, "utf8"));
        return packageData !== null && packageData !== void 0 ? packageData : {};
      });
      if (!options.cwd) {
        if (!options.projectName) {
          options.projectName = getPackageData().name;
        }
        if (!options.projectName) {
          throw new Error("Project name could not be inferred. Please specify the `projectName` option.");
        }
        options.cwd = envPaths2(options.projectName, { suffix: options.projectSuffix }).config;
      }
      __classPrivateFieldSet(this, _Conf_options, options, "f");
      if (options.schema) {
        if (typeof options.schema !== "object") {
          throw new TypeError("The `schema` option must be an object.");
        }
        const ajv2 = new ajv_1.default({
          allErrors: true,
          useDefaults: true
        });
        ajv_formats_1.default(ajv2);
        const schema2 = {
          type: "object",
          properties: options.schema
        };
        __classPrivateFieldSet(this, _Conf_validator, ajv2.compile(schema2), "f");
        for (const [key, value] of Object.entries(options.schema)) {
          if (value === null || value === void 0 ? void 0 : value.default) {
            __classPrivateFieldGet(this, _Conf_defaultValues, "f")[key] = value.default;
          }
        }
      }
      if (options.defaults) {
        __classPrivateFieldSet(this, _Conf_defaultValues, __spreadValues(__spreadValues({}, __classPrivateFieldGet(this, _Conf_defaultValues, "f")), options.defaults), "f");
      }
      if (options.serialize) {
        this._serialize = options.serialize;
      }
      if (options.deserialize) {
        this._deserialize = options.deserialize;
      }
      this.events = new events_1.EventEmitter();
      __classPrivateFieldSet(this, _Conf_encryptionKey, options.encryptionKey, "f");
      const fileExtension = options.fileExtension ? `.${options.fileExtension}` : "";
      this.path = path2.resolve(options.cwd, `${(_a2 = options.configName) !== null && _a2 !== void 0 ? _a2 : "config"}${fileExtension}`);
      const fileStore = this.store;
      const store2 = Object.assign(createPlainObject(), options.defaults, fileStore);
      this._validate(store2);
      try {
        assert2.deepEqual(fileStore, store2);
      } catch (_b2) {
        this.store = store2;
      }
      if (options.watch) {
        this._watch();
      }
      if (options.migrations) {
        if (!options.projectVersion) {
          options.projectVersion = getPackageData().version;
        }
        if (!options.projectVersion) {
          throw new Error("Project version could not be inferred. Please specify the `projectVersion` option.");
        }
        this._migrate(options.migrations, options.projectVersion);
      }
    }
    get(key, defaultValue) {
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        return this._get(key, defaultValue);
      }
      const { store: store2 } = this;
      return key in store2 ? store2[key] : defaultValue;
    }
    set(key, value) {
      if (typeof key !== "string" && typeof key !== "object") {
        throw new TypeError(`Expected \`key\` to be of type \`string\` or \`object\`, got ${typeof key}`);
      }
      if (typeof key !== "object" && value === void 0) {
        throw new TypeError("Use `delete()` to clear values");
      }
      if (this._containsReservedKey(key)) {
        throw new TypeError(`Please don't use the ${INTERNAL_KEY} key, as it's used to manage this module internal operations.`);
      }
      const { store: store2 } = this;
      const set = (key2, value2) => {
        checkValueType(key2, value2);
        if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
          dotProp$1.set(store2, key2, value2);
        } else {
          store2[key2] = value2;
        }
      };
      if (typeof key === "object") {
        const object = key;
        for (const [key2, value2] of Object.entries(object)) {
          set(key2, value2);
        }
      } else {
        set(key, value);
      }
      this.store = store2;
    }
    has(key) {
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        return dotProp$1.has(this.store, key);
      }
      return key in this.store;
    }
    reset(...keys) {
      for (const key of keys) {
        if (isExist(__classPrivateFieldGet(this, _Conf_defaultValues, "f")[key])) {
          this.set(key, __classPrivateFieldGet(this, _Conf_defaultValues, "f")[key]);
        }
      }
    }
    delete(key) {
      const { store: store2 } = this;
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        dotProp$1.delete(store2, key);
      } else {
        delete store2[key];
      }
      this.store = store2;
    }
    clear() {
      this.store = createPlainObject();
      for (const key of Object.keys(__classPrivateFieldGet(this, _Conf_defaultValues, "f"))) {
        this.reset(key);
      }
    }
    onDidChange(key, callback) {
      if (typeof key !== "string") {
        throw new TypeError(`Expected \`key\` to be of type \`string\`, got ${typeof key}`);
      }
      if (typeof callback !== "function") {
        throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof callback}`);
      }
      return this._handleChange(() => this.get(key), callback);
    }
    onDidAnyChange(callback) {
      if (typeof callback !== "function") {
        throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof callback}`);
      }
      return this._handleChange(() => this.store, callback);
    }
    get size() {
      return Object.keys(this.store).length;
    }
    get store() {
      try {
        const data = fs2.readFileSync(this.path, __classPrivateFieldGet(this, _Conf_encryptionKey, "f") ? null : "utf8");
        const dataString = this._encryptData(data);
        const deserializedData = this._deserialize(dataString);
        this._validate(deserializedData);
        return Object.assign(createPlainObject(), deserializedData);
      } catch (error2) {
        if (error2.code === "ENOENT") {
          this._ensureDirectory();
          return createPlainObject();
        }
        if (__classPrivateFieldGet(this, _Conf_options, "f").clearInvalidConfig && error2.name === "SyntaxError") {
          return createPlainObject();
        }
        throw error2;
      }
    }
    set store(value) {
      this._ensureDirectory();
      this._validate(value);
      this._write(value);
      this.events.emit("change");
    }
    *[(_Conf_validator = new WeakMap(), _Conf_encryptionKey = new WeakMap(), _Conf_options = new WeakMap(), _Conf_defaultValues = new WeakMap(), Symbol.iterator)]() {
      for (const [key, value] of Object.entries(this.store)) {
        yield [key, value];
      }
    }
    _encryptData(data) {
      if (!__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
        return data.toString();
      }
      try {
        if (__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
          try {
            if (data.slice(16, 17).toString() === ":") {
              const initializationVector = data.slice(0, 16);
              const password = crypto.pbkdf2Sync(__classPrivateFieldGet(this, _Conf_encryptionKey, "f"), initializationVector.toString(), 1e4, 32, "sha512");
              const decipher = crypto.createDecipheriv(encryptionAlgorithm, password, initializationVector);
              data = Buffer.concat([decipher.update(Buffer.from(data.slice(17))), decipher.final()]).toString("utf8");
            } else {
              const decipher = crypto.createDecipher(encryptionAlgorithm, __classPrivateFieldGet(this, _Conf_encryptionKey, "f"));
              data = Buffer.concat([decipher.update(Buffer.from(data)), decipher.final()]).toString("utf8");
            }
          } catch (_a2) {
          }
        }
      } catch (_b2) {
      }
      return data.toString();
    }
    _handleChange(getter, callback) {
      let currentValue = getter();
      const onChange = () => {
        const oldValue = currentValue;
        const newValue = getter();
        if (util_12.isDeepStrictEqual(newValue, oldValue)) {
          return;
        }
        currentValue = newValue;
        callback.call(this, newValue, oldValue);
      };
      this.events.on("change", onChange);
      return () => this.events.removeListener("change", onChange);
    }
    _validate(data) {
      if (!__classPrivateFieldGet(this, _Conf_validator, "f")) {
        return;
      }
      const valid2 = __classPrivateFieldGet(this, _Conf_validator, "f").call(this, data);
      if (valid2 || !__classPrivateFieldGet(this, _Conf_validator, "f").errors) {
        return;
      }
      const errors2 = __classPrivateFieldGet(this, _Conf_validator, "f").errors.map(({ instancePath, message = "" }) => `\`${instancePath.slice(1)}\` ${message}`);
      throw new Error("Config schema violation: " + errors2.join("; "));
    }
    _ensureDirectory() {
      fs2.mkdirSync(path2.dirname(this.path), { recursive: true });
    }
    _write(value) {
      let data = this._serialize(value);
      if (__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
        const initializationVector = crypto.randomBytes(16);
        const password = crypto.pbkdf2Sync(__classPrivateFieldGet(this, _Conf_encryptionKey, "f"), initializationVector.toString(), 1e4, 32, "sha512");
        const cipher = crypto.createCipheriv(encryptionAlgorithm, password, initializationVector);
        data = Buffer.concat([initializationVector, Buffer.from(":"), cipher.update(Buffer.from(data)), cipher.final()]);
      }
      {
        try {
          atomically.writeFileSync(this.path, data);
        } catch (error2) {
          if (error2.code === "EXDEV") {
            fs2.writeFileSync(this.path, data);
            return;
          }
          throw error2;
        }
      }
    }
    _watch() {
      this._ensureDirectory();
      if (!fs2.existsSync(this.path)) {
        this._write(createPlainObject());
      }
      if (process.platform === "win32") {
        fs2.watch(this.path, { persistent: false }, debounceFn$1(() => {
          this.events.emit("change");
        }, { wait: 100 }));
      } else {
        fs2.watchFile(this.path, { persistent: false }, debounceFn$1(() => {
          this.events.emit("change");
        }, { wait: 5e3 }));
      }
    }
    _migrate(migrations, versionToMigrate) {
      let previousMigratedVersion = this._get(MIGRATION_KEY, "0.0.0");
      const newerVersions = Object.keys(migrations).filter((candidateVersion) => this._shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate));
      let storeBackup = __spreadValues({}, this.store);
      for (const version of newerVersions) {
        try {
          const migration = migrations[version];
          migration(this);
          this._set(MIGRATION_KEY, version);
          previousMigratedVersion = version;
          storeBackup = __spreadValues({}, this.store);
        } catch (error2) {
          this.store = storeBackup;
          throw new Error(`Something went wrong during the migration! Changes applied to the store until this failed migration will be restored. ${error2}`);
        }
      }
      if (this._isVersionInRangeFormat(previousMigratedVersion) || !semver$12.eq(previousMigratedVersion, versionToMigrate)) {
        this._set(MIGRATION_KEY, versionToMigrate);
      }
    }
    _containsReservedKey(key) {
      if (typeof key === "object") {
        const firsKey = Object.keys(key)[0];
        if (firsKey === INTERNAL_KEY) {
          return true;
        }
      }
      if (typeof key !== "string") {
        return false;
      }
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        if (key.startsWith(`${INTERNAL_KEY}.`)) {
          return true;
        }
        return false;
      }
      return false;
    }
    _isVersionInRangeFormat(version) {
      return semver$12.clean(version) === null;
    }
    _shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate) {
      if (this._isVersionInRangeFormat(candidateVersion)) {
        if (previousMigratedVersion !== "0.0.0" && semver$12.satisfies(previousMigratedVersion, candidateVersion)) {
          return false;
        }
        return semver$12.satisfies(versionToMigrate, candidateVersion);
      }
      if (semver$12.lte(candidateVersion, previousMigratedVersion)) {
        return false;
      }
      if (semver$12.gt(candidateVersion, versionToMigrate)) {
        return false;
      }
      return true;
    }
    _get(key, defaultValue) {
      return dotProp$1.get(this.store, key, defaultValue);
    }
    _set(key, value) {
      const { store: store2 } = this;
      dotProp$1.set(store2, key, value);
      this.store = store2;
    }
  }
  exports.default = Conf2;
  module.exports = Conf2;
  module.exports.default = Conf2;
})(source, source.exports);
const path = require$$1__default["default"];
const { app, ipcMain, ipcRenderer, shell } = require$$0__default["default"];
const Conf = source.exports;
let isInitialized = false;
const initDataListener = () => {
  if (!ipcMain || !app) {
    throw new Error("Electron Store: You need to call `.initRenderer()` from the main process.");
  }
  const appData = {
    defaultCwd: app.getPath("userData"),
    appVersion: app.getVersion()
  };
  if (isInitialized) {
    return appData;
  }
  ipcMain.on("electron-store-get-data", (event) => {
    event.returnValue = appData;
  });
  isInitialized = true;
  return appData;
};
class ElectronStore extends Conf {
  constructor(options) {
    let defaultCwd;
    let appVersion;
    if (ipcRenderer) {
      const appData = ipcRenderer.sendSync("electron-store-get-data");
      if (!appData) {
        throw new Error("Electron Store: You need to call `.initRenderer()` from the main process.");
      }
      ({ defaultCwd, appVersion } = appData);
    } else if (ipcMain && app) {
      ({ defaultCwd, appVersion } = initDataListener());
    }
    options = __spreadValues({
      name: "config"
    }, options);
    if (!options.projectVersion) {
      options.projectVersion = appVersion;
    }
    if (options.cwd) {
      options.cwd = path.isAbsolute(options.cwd) ? options.cwd : path.join(defaultCwd, options.cwd);
    } else {
      options.cwd = defaultCwd;
    }
    options.configName = options.name;
    delete options.name;
    super(options);
  }
  static initRenderer() {
    initDataListener();
  }
  openInEditor() {
    shell.openPath(this.path);
  }
}
var electronStore = ElectronStore;
const schema$1 = {
  notes: {
    type: "object",
    patternProperties: {
      "[A-Za-z0-9_-]": {
        type: "object",
        properties: {
          id: { type: "string", default: "" },
          title: { type: "string", default: "" },
          content: { type: "object", default: { type: "doc", content: [] } },
          labels: { type: "array", default: [] },
          createdAt: { type: "number", default: Date.now() },
          updatedAt: { type: "number", default: Date.now() },
          isBookmarked: { type: "boolean", default: false },
          isArchived: { type: "boolean", default: false },
          lastCursorPosition: { type: "number", default: 0 }
        }
      }
    }
  },
  labels: {
    type: "array"
  }
};
const store$1 = new electronStore({
  schema: schema$1,
  encryptionKey: {}.VITE_ENCRYPT_KEY
});
const schema = {
  dataDir: {
    type: "string",
    default: require$$0.app.getPath("userData")
  }
};
var settings = new electronStore({ name: "settings", schema, encryptionKey: {}.VITE_ENCRYPT_KEY });
var store = {
  data: store$1,
  settings
};
const isSingleInstance = require$$0.app.requestSingleInstanceLock();
if (!isSingleInstance) {
  require$$0.app.quit();
  process.exit(0);
}
require$$0.app.disableHardwareAcceleration();
const env = { "VITE_DEV_SERVER_URL": "http://localhost:3000/", "BASE_URL": "/", "MODE": "development", "DEV": true, "PROD": false };
{
  require$$0.app.whenReady().then(() => Promise.resolve().then(function() {
    return /* @__PURE__ */ _interopNamespace(require("electron-devtools-installer"));
  })).then(({ default: installExtension, VUEJS3_DEVTOOLS }) => installExtension(VUEJS3_DEVTOOLS, {
    loadExtensionOptions: {
      allowFileAccess: true
    }
  })).catch((e) => console.error("Failed install extension:", e));
}
let mainWindow = null;
const createWindow = async () => {
  mainWindow = new require$$0.BrowserWindow({
    show: false,
    width: 950,
    height: 600,
    webPreferences: {
      preload: require$$1.join(__dirname, "../../preload/dist/index.cjs"),
      contextIsolation: env.MODE !== "test",
      enableRemoteModule: env.MODE === "test"
    }
  });
  mainWindow.setMenuBarVisibility(false);
  mainWindow.on("ready-to-show", () => {
    mainWindow == null ? void 0 : mainWindow.show();
    {
      mainWindow == null ? void 0 : mainWindow.webContents.openDevTools();
    }
  });
  mainWindow == null ? void 0 : mainWindow.webContents.on("new-window", function(event, url) {
    event.preventDefault();
    if (url.startsWith("note://"))
      return;
    require$$0.shell.openExternal(url);
  });
  const pageUrl = env.VITE_DEV_SERVER_URL;
  await mainWindow.loadURL(pageUrl);
};
require$$0.app.on("second-instance", () => {
  if (mainWindow) {
    if (mainWindow.isMinimized())
      mainWindow.restore();
    mainWindow.focus();
  }
});
require$$0.app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    require$$0.app.quit();
  }
});
require$$0.app.whenReady().then(async () => {
  require$$0.protocol.registerFileProtocol("assets", (request, callback) => {
    const url = request.url.substr(9);
    const dir = store.settings.get("dataDir");
    const imgPath = `${dir}/notes-assets/${url}`;
    callback({ path: require$$1.normalize(imgPath) });
  });
  await lib.ensureDir(require$$1.join(require$$0.app.getPath("userData"), "notes-assets"));
  await createWindow();
}).catch((e) => console.error("Failed create window:", e));
ipcMain$1.answerRenderer("app:info", () => ({
  name: require$$0.app.getName(),
  version: require$$0.app.getVersion()
}));
ipcMain$1.answerRenderer("dialog:open", (props) => require$$0.dialog.showOpenDialog(props));
ipcMain$1.answerRenderer("dialog:message", (props) => require$$0.dialog.showMessageBox(props));
ipcMain$1.answerRenderer("dialog:save", (props) => require$$0.dialog.showSaveDialog(props));
ipcMain$1.answerRenderer("fs:copy", ({ path: path2, dest }) => lib.copy(path2, dest));
ipcMain$1.answerRenderer("fs:output-json", ({ path: path2, data }) => lib.outputJson(path2, data));
ipcMain$1.answerRenderer("fs:read-json", (path2) => lib.readJson(path2));
ipcMain$1.answerRenderer("fs:ensureDir", (path2) => lib.ensureDir(path2));
ipcMain$1.answerRenderer("fs:pathExists", (path2) => lib.pathExistsSync(path2));
ipcMain$1.answerRenderer("fs:remove", (path2) => lib.remove(path2));
ipcMain$1.answerRenderer("helper:relaunch", (options = {}) => {
  require$$0.app.relaunch(__spreadValues({ args: process.argv.slice(1).concat(["--relaunch"]) }, options));
  require$$0.app.exit(0);
});
ipcMain$1.answerRenderer("helper:get-path", (name) => require$$0.app.getPath(name));
ipcMain$1.answerRenderer("helper:is-dark-theme", () => require$$0.nativeTheme.shouldUseDarkColors);
ipcMain$1.answerRenderer("storage:store", (name) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.store;
});
ipcMain$1.answerRenderer("storage:replace", ({ name, data }) => store[name].store = data);
ipcMain$1.answerRenderer("storage:get", ({ name, key, def: def2 }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.get(key, def2);
});
ipcMain$1.answerRenderer("storage:set", ({ name, key, value }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.set(key, value);
});
ipcMain$1.answerRenderer("storage:delete", ({ name, key }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.delete(key);
});
ipcMain$1.answerRenderer("storage:has", ({ name, key }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.has(key);
});
ipcMain$1.answerRenderer("storage:clear", (name) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.clear();
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguY2pzIiwic291cmNlcyI6WyIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VyaWFsaXplLWVycm9yL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWJldHRlci1pcGMvc291cmNlL3V0aWwuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tYmV0dGVyLWlwYy9zb3VyY2UvcmVuZGVyZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tYmV0dGVyLWlwYy9zb3VyY2UvbWFpbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1iZXR0ZXItaXBjL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3VuaXZlcnNhbGlmeS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9wb2x5ZmlsbHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvbGVnYWN5LXN0cmVhbXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvY2xvbmUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvZ3JhY2VmdWwtZnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2ZzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9ta2RpcnMvdXRpbHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21rZGlycy9tYWtlLWRpci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvbWtkaXJzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi91dGlsL3V0aW1lcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvdXRpbC9zdGF0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5LXN5bmMvY29weS1zeW5jLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5LXN5bmMvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3BhdGgtZXhpc3RzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5L2NvcHkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2NvcHkvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3JlbW92ZS9yaW1yYWYuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3JlbW92ZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW1wdHkvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9maWxlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvbGluay5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL3N5bWxpbmstcGF0aHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9zeW1saW5rLXR5cGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9zeW1saW5rLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanNvbmZpbGUvdXRpbHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanNvbmZpbGUvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2pzb24vanNvbmZpbGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL291dHB1dC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvanNvbi9vdXRwdXQtanNvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvanNvbi9vdXRwdXQtanNvbi1zeW5jLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9qc29uL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9tb3ZlLXN5bmMvbW92ZS1zeW5jLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9tb3ZlLXN5bmMvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21vdmUvbW92ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvbW92ZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvaXMtb2JqL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RvdC1wcm9wL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3BhdGgtZXhpc3RzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3AtdHJ5L2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3AtbGltaXQvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcC1sb2NhdGUvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9jYXRlLXBhdGgvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZmluZC11cC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wa2ctdXAvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZW52LXBhdGhzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC9jb25zdHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL2F0dGVtcHRpZnkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL2ZzX2hhbmRsZXJzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC91dGlscy9yZXRyeWlmeV9xdWV1ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hdG9taWNhbGx5L2Rpc3QvdXRpbHMvcmV0cnlpZnkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL2ZzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC91dGlscy9sYW5nLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC91dGlscy9zY2hlZHVsZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL3RlbXAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvY29kZWdlbi9jb2RlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvY29kZWdlbi9zY29wZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2NvZGVnZW4vaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS91dGlsLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvbmFtZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9lcnJvcnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9ib29sU2NoZW1hLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvcnVsZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9hcHBsaWNhYmlsaXR5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9kZWZhdWx0cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvY29kZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2tleXdvcmQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9zdWJzY2hlbWEuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZmFzdC1kZWVwLWVxdWFsL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLXRyYXZlcnNlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3VyaS1qcy9kaXN0L2VzNS91cmkuYWxsLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvcmVzb2x2ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3JlZl9lcnJvci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvcmUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvcmUvaWQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvcmUvcmVmLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9jb3JlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0TnVtYmVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL211bHRpcGxlT2YuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS91Y3MybGVuZ3RoLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0TGVuZ3RoLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL3BhdHRlcm4uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbGltaXRQcm9wZXJ0aWVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL3JlcXVpcmVkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0SXRlbXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS9lcXVhbC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi91bmlxdWVJdGVtcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9jb25zdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9lbnVtLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FkZGl0aW9uYWxJdGVtcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pdGVtcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wcmVmaXhJdGVtcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pdGVtczIwMjAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvY29udGFpbnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvZGVwZW5kZW5jaWVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3Byb3BlcnR5TmFtZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWRkaXRpb25hbFByb3BlcnRpZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJvcGVydGllcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wYXR0ZXJuUHJvcGVydGllcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9ub3QuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYW55T2YuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3Ivb25lT2YuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWxsT2YuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaWYuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvdGhlbkVsc2UuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Zvcm1hdC9mb3JtYXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Zvcm1hdC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvbWV0YWRhdGEuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2RyYWZ0Ny5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvci90eXBlcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvci9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9hanYuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvZGlzdC9mb3JtYXRzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi1mb3JtYXRzL2Rpc3QvbGltaXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvZGlzdC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZWJvdW5jZS1mbi9ub2RlX21vZHVsZXMvbWltaWMtZm4vaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGVib3VuY2UtZm4vaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2NvbnN0YW50cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvZGVidWcuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL3JlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9wYXJzZS1vcHRpb25zLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9pZGVudGlmaWVycy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9zZW12ZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wYXJzZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3ZhbGlkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY2xlYW4uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9pbmMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZXEuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9kaWZmLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbWFqb3IuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9taW5vci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3BhdGNoLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcHJlcmVsZWFzZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3Jjb21wYXJlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS1sb29zZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUtYnVpbGQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zb3J0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcnNvcnQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9ndC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbmVxLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZ3RlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbHRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY21wLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29lcmNlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3lhbGxpc3QvaXRlcmF0b3IuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMveWFsbGlzdC95YWxsaXN0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9yYW5nZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9jb21wYXJhdG9yLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvdG8tY29tcGFyYXRvcnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9tYXgtc2F0aXNmeWluZy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21pbi1zYXRpc2Z5aW5nLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWluLXZlcnNpb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy92YWxpZC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL291dHNpZGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9ndHIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9sdHIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9pbnRlcnNlY3RzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvc2ltcGxpZnkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zdWJzZXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21pbWljLWZuL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29uZXRpbWUvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9kaXN0L3NvdXJjZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1zdG9yZS9pbmRleC5qcyIsIi4uL3NyYy9zdG9yZS9tb2R1bGVzL2RhdGEuc3RvcmUuanMiLCIuLi9zcmMvc3RvcmUvbW9kdWxlcy9zZXR0aW5ncy5zdG9yZS5qcyIsIi4uL3NyYy9zdG9yZS9pbmRleC5qcyIsIi4uL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNsYXNzIE5vbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG5cdFx0c3VwZXIoTm9uRXJyb3IuX3ByZXBhcmVTdXBlck1lc3NhZ2UobWVzc2FnZSkpO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmFtZScsIHtcblx0XHRcdHZhbHVlOiAnTm9uRXJyb3InLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0d3JpdGFibGU6IHRydWVcblx0XHR9KTtcblxuXHRcdGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuXHRcdFx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgTm9uRXJyb3IpO1xuXHRcdH1cblx0fVxuXG5cdHN0YXRpYyBfcHJlcGFyZVN1cGVyTWVzc2FnZShtZXNzYWdlKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShtZXNzYWdlKTtcblx0XHR9IGNhdGNoIHtcblx0XHRcdHJldHVybiBTdHJpbmcobWVzc2FnZSk7XG5cdFx0fVxuXHR9XG59XG5cbmNvbnN0IGNvbW1vblByb3BlcnRpZXMgPSBbXG5cdHtwcm9wZXJ0eTogJ25hbWUnLCBlbnVtZXJhYmxlOiBmYWxzZX0sXG5cdHtwcm9wZXJ0eTogJ21lc3NhZ2UnLCBlbnVtZXJhYmxlOiBmYWxzZX0sXG5cdHtwcm9wZXJ0eTogJ3N0YWNrJywgZW51bWVyYWJsZTogZmFsc2V9LFxuXHR7cHJvcGVydHk6ICdjb2RlJywgZW51bWVyYWJsZTogdHJ1ZX1cbl07XG5cbmNvbnN0IGlzQ2FsbGVkID0gU3ltYm9sKCcudG9KU09OIGNhbGxlZCcpO1xuXG5jb25zdCB0b0pTT04gPSBmcm9tID0+IHtcblx0ZnJvbVtpc0NhbGxlZF0gPSB0cnVlO1xuXHRjb25zdCBqc29uID0gZnJvbS50b0pTT04oKTtcblx0ZGVsZXRlIGZyb21baXNDYWxsZWRdO1xuXHRyZXR1cm4ganNvbjtcbn07XG5cbmNvbnN0IGRlc3Ryb3lDaXJjdWxhciA9ICh7XG5cdGZyb20sXG5cdHNlZW4sXG5cdHRvXyxcblx0Zm9yY2VFbnVtZXJhYmxlLFxuXHRtYXhEZXB0aCxcblx0ZGVwdGhcbn0pID0+IHtcblx0Y29uc3QgdG8gPSB0b18gfHwgKEFycmF5LmlzQXJyYXkoZnJvbSkgPyBbXSA6IHt9KTtcblxuXHRzZWVuLnB1c2goZnJvbSk7XG5cblx0aWYgKGRlcHRoID49IG1heERlcHRoKSB7XG5cdFx0cmV0dXJuIHRvO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBmcm9tLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJyAmJiBmcm9tW2lzQ2FsbGVkXSAhPT0gdHJ1ZSkge1xuXHRcdHJldHVybiB0b0pTT04oZnJvbSk7XG5cdH1cblxuXHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmcm9tKSkge1xuXHRcdGlmICh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcblx0XHRcdHRvW2tleV0gPSAnW29iamVjdCBCdWZmZXJdJztcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0dG9ba2V5XSA9IHZhbHVlO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0aWYgKCFzZWVuLmluY2x1ZGVzKGZyb21ba2V5XSkpIHtcblx0XHRcdGRlcHRoKys7XG5cblx0XHRcdHRvW2tleV0gPSBkZXN0cm95Q2lyY3VsYXIoe1xuXHRcdFx0XHRmcm9tOiBmcm9tW2tleV0sXG5cdFx0XHRcdHNlZW46IHNlZW4uc2xpY2UoKSxcblx0XHRcdFx0Zm9yY2VFbnVtZXJhYmxlLFxuXHRcdFx0XHRtYXhEZXB0aCxcblx0XHRcdFx0ZGVwdGhcblx0XHRcdH0pO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0dG9ba2V5XSA9ICdbQ2lyY3VsYXJdJztcblx0fVxuXG5cdGZvciAoY29uc3Qge3Byb3BlcnR5LCBlbnVtZXJhYmxlfSBvZiBjb21tb25Qcm9wZXJ0aWVzKSB7XG5cdFx0aWYgKHR5cGVvZiBmcm9tW3Byb3BlcnR5XSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0bywgcHJvcGVydHksIHtcblx0XHRcdFx0dmFsdWU6IGZyb21bcHJvcGVydHldLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiBmb3JjZUVudW1lcmFibGUgPyB0cnVlIDogZW51bWVyYWJsZSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuY29uc3Qgc2VyaWFsaXplRXJyb3IgPSAodmFsdWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuXHRjb25zdCB7bWF4RGVwdGggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFl9ID0gb3B0aW9ucztcblxuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuXHRcdHJldHVybiBkZXN0cm95Q2lyY3VsYXIoe1xuXHRcdFx0ZnJvbTogdmFsdWUsXG5cdFx0XHRzZWVuOiBbXSxcblx0XHRcdGZvcmNlRW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdG1heERlcHRoLFxuXHRcdFx0ZGVwdGg6IDBcblx0XHR9KTtcblx0fVxuXG5cdC8vIFBlb3BsZSBzb21ldGltZXMgdGhyb3cgdGhpbmdzIGJlc2lkZXMgRXJyb3Igb2JqZWN0c+KAplxuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Ly8gYEpTT04uc3RyaW5naWZ5KClgIGRpc2NhcmRzIGZ1bmN0aW9ucy4gV2UgZG8gdG9vLCB1bmxlc3MgYSBmdW5jdGlvbiBpcyB0aHJvd24gZGlyZWN0bHkuXG5cdFx0cmV0dXJuIGBbRnVuY3Rpb246ICR7KHZhbHVlLm5hbWUgfHwgJ2Fub255bW91cycpfV1gO1xuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufTtcblxuY29uc3QgZGVzZXJpYWxpemVFcnJvciA9ICh2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG5cdGNvbnN0IHttYXhEZXB0aCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWX0gPSBvcHRpb25zO1xuXG5cdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0Y29uc3QgbmV3RXJyb3IgPSBuZXcgRXJyb3IoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSB1bmljb3JuL2Vycm9yLW1lc3NhZ2Vcblx0XHRkZXN0cm95Q2lyY3VsYXIoe1xuXHRcdFx0ZnJvbTogdmFsdWUsXG5cdFx0XHRzZWVuOiBbXSxcblx0XHRcdHRvXzogbmV3RXJyb3IsXG5cdFx0XHRtYXhEZXB0aCxcblx0XHRcdGRlcHRoOiAwXG5cdFx0fSk7XG5cdFx0cmV0dXJuIG5ld0Vycm9yO1xuXHR9XG5cblx0cmV0dXJuIG5ldyBOb25FcnJvcih2YWx1ZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0c2VyaWFsaXplRXJyb3IsXG5cdGRlc2VyaWFsaXplRXJyb3Jcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGdldFVuaXF1ZUlkID0gKCkgPT4gYCR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpfWA7XG5cbmNvbnN0IGdldFNlbmRDaGFubmVsID0gY2hhbm5lbCA9PiBgJWJldHRlci1pcGMtc2VuZC1jaGFubmVsLSR7Y2hhbm5lbH1gO1xuY29uc3QgZ2V0UmVuZGVyZXJTZW5kQ2hhbm5lbCA9IGNoYW5uZWwgPT4gYCViZXR0ZXItaXBjLXNlbmQtY2hhbm5lbC0ke2NoYW5uZWx9YDtcblxubW9kdWxlLmV4cG9ydHMuY3VycmVudFdpbmRvd0NoYW5uZWwgPSAnJWJldHRlci1pcGMtY3VycmVudC13aW5kb3cnO1xuXG5tb2R1bGUuZXhwb3J0cy5nZXRTZW5kQ2hhbm5lbCA9IGdldFNlbmRDaGFubmVsO1xubW9kdWxlLmV4cG9ydHMuZ2V0UmVuZGVyZXJTZW5kQ2hhbm5lbCA9IGdldFJlbmRlcmVyU2VuZENoYW5uZWw7XG5cbm1vZHVsZS5leHBvcnRzLmdldFJlc3BvbnNlQ2hhbm5lbHMgPSBjaGFubmVsID0+IHtcblx0Y29uc3QgaWQgPSBnZXRVbmlxdWVJZCgpO1xuXHRyZXR1cm4ge1xuXHRcdHNlbmRDaGFubmVsOiBnZXRTZW5kQ2hhbm5lbChjaGFubmVsKSxcblx0XHRkYXRhQ2hhbm5lbDogYCViZXR0ZXItaXBjLXJlc3BvbnNlLWRhdGEtY2hhbm5lbC0ke2NoYW5uZWx9LSR7aWR9YCxcblx0XHRlcnJvckNoYW5uZWw6IGAlYmV0dGVyLWlwYy1yZXNwb25zZS1lcnJvci1jaGFubmVsLSR7Y2hhbm5lbH0tJHtpZH1gXG5cdH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5nZXRSZW5kZXJlclJlc3BvbnNlQ2hhbm5lbHMgPSBjaGFubmVsID0+IHtcblx0Y29uc3QgaWQgPSBnZXRVbmlxdWVJZCgpO1xuXHRyZXR1cm4ge1xuXHRcdHNlbmRDaGFubmVsOiBnZXRSZW5kZXJlclNlbmRDaGFubmVsKGNoYW5uZWwpLFxuXHRcdGRhdGFDaGFubmVsOiBgJWJldHRlci1pcGMtcmVzcG9uc2UtZGF0YS1jaGFubmVsLSR7Y2hhbm5lbH0tJHtpZH1gLFxuXHRcdGVycm9yQ2hhbm5lbDogYCViZXR0ZXItaXBjLXJlc3BvbnNlLWVycm9yLWNoYW5uZWwtJHtjaGFubmVsfS0ke2lkfWBcblx0fTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBlbGVjdHJvbiA9IHJlcXVpcmUoJ2VsZWN0cm9uJyk7XG5jb25zdCB7c2VyaWFsaXplRXJyb3IsIGRlc2VyaWFsaXplRXJyb3J9ID0gcmVxdWlyZSgnc2VyaWFsaXplLWVycm9yJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsLmpzJyk7XG5cbmNvbnN0IHtpcGNSZW5kZXJlcn0gPSBlbGVjdHJvbjtcbmNvbnN0IGlwYyA9IE9iamVjdC5jcmVhdGUoaXBjUmVuZGVyZXIgfHwge30pO1xuXG5pcGMuY2FsbE1haW4gPSAoY2hhbm5lbCwgZGF0YSkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRjb25zdCB7c2VuZENoYW5uZWwsIGRhdGFDaGFubmVsLCBlcnJvckNoYW5uZWx9ID0gdXRpbC5nZXRSZXNwb25zZUNoYW5uZWxzKGNoYW5uZWwpO1xuXG5cdGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG5cdFx0aXBjUmVuZGVyZXIub2ZmKGRhdGFDaGFubmVsLCBvbkRhdGEpO1xuXHRcdGlwY1JlbmRlcmVyLm9mZihlcnJvckNoYW5uZWwsIG9uRXJyb3IpO1xuXHR9O1xuXG5cdGNvbnN0IG9uRGF0YSA9IChfZXZlbnQsIHJlc3VsdCkgPT4ge1xuXHRcdGNsZWFudXAoKTtcblx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cdH07XG5cblx0Y29uc3Qgb25FcnJvciA9IChfZXZlbnQsIGVycm9yKSA9PiB7XG5cdFx0Y2xlYW51cCgpO1xuXHRcdHJlamVjdChkZXNlcmlhbGl6ZUVycm9yKGVycm9yKSk7XG5cdH07XG5cblx0aXBjUmVuZGVyZXIub25jZShkYXRhQ2hhbm5lbCwgb25EYXRhKTtcblx0aXBjUmVuZGVyZXIub25jZShlcnJvckNoYW5uZWwsIG9uRXJyb3IpO1xuXG5cdGNvbnN0IGNvbXBsZXRlRGF0YSA9IHtcblx0XHRkYXRhQ2hhbm5lbCxcblx0XHRlcnJvckNoYW5uZWwsXG5cdFx0dXNlckRhdGE6IGRhdGFcblx0fTtcblxuXHRpcGNSZW5kZXJlci5zZW5kKHNlbmRDaGFubmVsLCBjb21wbGV0ZURhdGEpO1xufSk7XG5cbmlwYy5hbnN3ZXJNYWluID0gKGNoYW5uZWwsIGNhbGxiYWNrKSA9PiB7XG5cdGNvbnN0IHNlbmRDaGFubmVsID0gdXRpbC5nZXRSZW5kZXJlclNlbmRDaGFubmVsKGNoYW5uZWwpO1xuXG5cdGNvbnN0IGxpc3RlbmVyID0gYXN5bmMgKF9ldmVudCwgZGF0YSkgPT4ge1xuXHRcdGNvbnN0IHtkYXRhQ2hhbm5lbCwgZXJyb3JDaGFubmVsLCB1c2VyRGF0YX0gPSBkYXRhO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGlwY1JlbmRlcmVyLnNlbmQoZGF0YUNoYW5uZWwsIGF3YWl0IGNhbGxiYWNrKHVzZXJEYXRhKSk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlwY1JlbmRlcmVyLnNlbmQoZXJyb3JDaGFubmVsLCBzZXJpYWxpemVFcnJvcihlcnJvcikpO1xuXHRcdH1cblx0fTtcblxuXHRpcGNSZW5kZXJlci5vbihzZW5kQ2hhbm5lbCwgbGlzdGVuZXIpO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aXBjUmVuZGVyZXIub2ZmKHNlbmRDaGFubmVsLCBsaXN0ZW5lcik7XG5cdH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlwYztcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IGVsZWN0cm9uID0gcmVxdWlyZSgnZWxlY3Ryb24nKTtcbmNvbnN0IHtzZXJpYWxpemVFcnJvciwgZGVzZXJpYWxpemVFcnJvcn0gPSByZXF1aXJlKCdzZXJpYWxpemUtZXJyb3InKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwuanMnKTtcblxuY29uc3Qge2lwY01haW4sIEJyb3dzZXJXaW5kb3d9ID0gZWxlY3Ryb247XG5jb25zdCBpcGMgPSBPYmplY3QuY3JlYXRlKGlwY01haW4gfHwge30pO1xuXG5pcGMuY2FsbFJlbmRlcmVyID0gKGJyb3dzZXJXaW5kb3csIGNoYW5uZWwsIGRhdGEpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0aWYgKCFicm93c2VyV2luZG93KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdCcm93c2VyIHdpbmRvdyByZXF1aXJlZCcpO1xuXHR9XG5cblx0Y29uc3Qge3NlbmRDaGFubmVsLCBkYXRhQ2hhbm5lbCwgZXJyb3JDaGFubmVsfSA9IHV0aWwuZ2V0UmVuZGVyZXJSZXNwb25zZUNoYW5uZWxzKGNoYW5uZWwpO1xuXG5cdGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG5cdFx0aXBjTWFpbi5vZmYoZGF0YUNoYW5uZWwsIG9uRGF0YSk7XG5cdFx0aXBjTWFpbi5vZmYoZXJyb3JDaGFubmVsLCBvbkVycm9yKTtcblx0fTtcblxuXHRjb25zdCBvbkRhdGEgPSAoZXZlbnQsIHJlc3VsdCkgPT4ge1xuXHRcdGNvbnN0IHdpbmRvdyA9IEJyb3dzZXJXaW5kb3cuZnJvbVdlYkNvbnRlbnRzKGV2ZW50LnNlbmRlcik7XG5cdFx0aWYgKHdpbmRvdy5pZCA9PT0gYnJvd3NlcldpbmRvdy5pZCkge1xuXHRcdFx0Y2xlYW51cCgpO1xuXHRcdFx0cmVzb2x2ZShyZXN1bHQpO1xuXHRcdH1cblx0fTtcblxuXHRjb25zdCBvbkVycm9yID0gKGV2ZW50LCBlcnJvcikgPT4ge1xuXHRcdGNvbnN0IHdpbmRvdyA9IEJyb3dzZXJXaW5kb3cuZnJvbVdlYkNvbnRlbnRzKGV2ZW50LnNlbmRlcik7XG5cdFx0aWYgKHdpbmRvdy5pZCA9PT0gYnJvd3NlcldpbmRvdy5pZCkge1xuXHRcdFx0Y2xlYW51cCgpO1xuXHRcdFx0cmVqZWN0KGRlc2VyaWFsaXplRXJyb3IoZXJyb3IpKTtcblx0XHR9XG5cdH07XG5cblx0aXBjTWFpbi5vbihkYXRhQ2hhbm5lbCwgb25EYXRhKTtcblx0aXBjTWFpbi5vbihlcnJvckNoYW5uZWwsIG9uRXJyb3IpO1xuXG5cdGNvbnN0IGNvbXBsZXRlRGF0YSA9IHtcblx0XHRkYXRhQ2hhbm5lbCxcblx0XHRlcnJvckNoYW5uZWwsXG5cdFx0dXNlckRhdGE6IGRhdGFcblx0fTtcblxuXHRpZiAoYnJvd3NlcldpbmRvdy53ZWJDb250ZW50cykge1xuXHRcdGJyb3dzZXJXaW5kb3cud2ViQ29udGVudHMuc2VuZChzZW5kQ2hhbm5lbCwgY29tcGxldGVEYXRhKTtcblx0fVxufSk7XG5cbmlwYy5jYWxsRm9jdXNlZFJlbmRlcmVyID0gYXN5bmMgKC4uLmFyZ3MpID0+IHtcblx0Y29uc3QgZm9jdXNlZFdpbmRvdyA9IEJyb3dzZXJXaW5kb3cuZ2V0Rm9jdXNlZFdpbmRvdygpO1xuXHRpZiAoIWZvY3VzZWRXaW5kb3cpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ05vIGJyb3dzZXIgd2luZG93IGluIGZvY3VzJyk7XG5cdH1cblxuXHRyZXR1cm4gaXBjLmNhbGxSZW5kZXJlcihmb2N1c2VkV2luZG93LCAuLi5hcmdzKTtcbn07XG5cbmlwYy5hbnN3ZXJSZW5kZXJlciA9IChicm93c2VyV2luZG93T3JDaGFubmVsLCBjaGFubmVsT3JDYWxsYmFjaywgY2FsbGJhY2tPck5vdGhpbmcpID0+IHtcblx0bGV0IHdpbmRvdztcblx0bGV0IGNoYW5uZWw7XG5cdGxldCBjYWxsYmFjaztcblxuXHRpZiAoY2FsbGJhY2tPck5vdGhpbmcgPT09IHVuZGVmaW5lZCkge1xuXHRcdGNoYW5uZWwgPSBicm93c2VyV2luZG93T3JDaGFubmVsO1xuXHRcdGNhbGxiYWNrID0gY2hhbm5lbE9yQ2FsbGJhY2s7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93ID0gYnJvd3NlcldpbmRvd09yQ2hhbm5lbDtcblx0XHRjaGFubmVsID0gY2hhbm5lbE9yQ2FsbGJhY2s7XG5cdFx0Y2FsbGJhY2sgPSBjYWxsYmFja09yTm90aGluZztcblxuXHRcdGlmICghd2luZG93KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Jyb3dzZXIgd2luZG93IHJlcXVpcmVkJyk7XG5cdFx0fVxuXHR9XG5cblx0Y29uc3Qgc2VuZENoYW5uZWwgPSB1dGlsLmdldFNlbmRDaGFubmVsKGNoYW5uZWwpO1xuXG5cdGNvbnN0IGxpc3RlbmVyID0gYXN5bmMgKGV2ZW50LCBkYXRhKSA9PiB7XG5cdFx0Y29uc3QgYnJvd3NlcldpbmRvdyA9IEJyb3dzZXJXaW5kb3cuZnJvbVdlYkNvbnRlbnRzKGV2ZW50LnNlbmRlcik7XG5cblx0XHRpZiAod2luZG93ICYmIHdpbmRvdy5pZCAhPT0gYnJvd3NlcldpbmRvdy5pZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IHNlbmQgPSAoY2hhbm5lbCwgZGF0YSkgPT4ge1xuXHRcdFx0aWYgKCEoYnJvd3NlcldpbmRvdyAmJiBicm93c2VyV2luZG93LmlzRGVzdHJveWVkKCkpKSB7XG5cdFx0XHRcdGV2ZW50LnNlbmRlci5zZW5kKGNoYW5uZWwsIGRhdGEpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRjb25zdCB7ZGF0YUNoYW5uZWwsIGVycm9yQ2hhbm5lbCwgdXNlckRhdGF9ID0gZGF0YTtcblxuXHRcdHRyeSB7XG5cdFx0XHRzZW5kKGRhdGFDaGFubmVsLCBhd2FpdCBjYWxsYmFjayh1c2VyRGF0YSwgYnJvd3NlcldpbmRvdykpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRzZW5kKGVycm9yQ2hhbm5lbCwgc2VyaWFsaXplRXJyb3IoZXJyb3IpKTtcblx0XHR9XG5cdH07XG5cblx0aXBjTWFpbi5vbihzZW5kQ2hhbm5lbCwgbGlzdGVuZXIpO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aXBjTWFpbi5vZmYoc2VuZENoYW5uZWwsIGxpc3RlbmVyKTtcblx0fTtcbn07XG5cbmlwYy5zZW5kVG9SZW5kZXJlcnMgPSAoY2hhbm5lbCwgZGF0YSkgPT4ge1xuXHRmb3IgKGNvbnN0IGJyb3dzZXJXaW5kb3cgb2YgQnJvd3NlcldpbmRvdy5nZXRBbGxXaW5kb3dzKCkpIHtcblx0XHRpZiAoYnJvd3NlcldpbmRvdy53ZWJDb250ZW50cykge1xuXHRcdFx0YnJvd3NlcldpbmRvdy53ZWJDb250ZW50cy5zZW5kKGNoYW5uZWwsIGRhdGEpO1xuXHRcdH1cblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpcGM7XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcblx0bW9kdWxlLmV4cG9ydHMuaXBjUmVuZGVyZXIgPSByZXF1aXJlKCcuL3NvdXJjZS9yZW5kZXJlci5qcycpO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMuaXBjTWFpbiA9IHJlcXVpcmUoJy4vc291cmNlL21haW4uanMnKTtcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmZyb21DYWxsYmFjayA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIGZuLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBmbi5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICAoZXJyLCByZXMpID0+IChlcnIgIT0gbnVsbCkgPyByZWplY3QoZXJyKSA6IHJlc29sdmUocmVzKVxuICAgICAgICApXG4gICAgICB9KVxuICAgIH1cbiAgfSwgJ25hbWUnLCB7IHZhbHVlOiBmbi5uYW1lIH0pXG59XG5cbmV4cG9ydHMuZnJvbVByb21pc2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIGNvbnN0IGNiID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdXG4gICAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgZWxzZSBmbi5hcHBseSh0aGlzLCBhcmdzLnNsaWNlKDAsIC0xKSkudGhlbihyID0+IGNiKG51bGwsIHIpLCBjYilcbiAgfSwgJ25hbWUnLCB7IHZhbHVlOiBmbi5uYW1lIH0pXG59XG4iLCJ2YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnY29uc3RhbnRzJylcblxudmFyIG9yaWdDd2QgPSBwcm9jZXNzLmN3ZFxudmFyIGN3ZCA9IG51bGxcblxudmFyIHBsYXRmb3JtID0gcHJvY2Vzcy5lbnYuR1JBQ0VGVUxfRlNfUExBVEZPUk0gfHwgcHJvY2Vzcy5wbGF0Zm9ybVxuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIWN3ZClcbiAgICBjd2QgPSBvcmlnQ3dkLmNhbGwocHJvY2VzcylcbiAgcmV0dXJuIGN3ZFxufVxudHJ5IHtcbiAgcHJvY2Vzcy5jd2QoKVxufSBjYXRjaCAoZXIpIHt9XG5cbi8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHVudGlsIG5vZGUuanMgMTIgaXMgcmVxdWlyZWRcbmlmICh0eXBlb2YgcHJvY2Vzcy5jaGRpciA9PT0gJ2Z1bmN0aW9uJykge1xuICB2YXIgY2hkaXIgPSBwcm9jZXNzLmNoZGlyXG4gIHByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZCkge1xuICAgIGN3ZCA9IG51bGxcbiAgICBjaGRpci5jYWxsKHByb2Nlc3MsIGQpXG4gIH1cbiAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb2Nlc3MuY2hkaXIsIGNoZGlyKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoXG5cbmZ1bmN0aW9uIHBhdGNoIChmcykge1xuICAvLyAocmUtKWltcGxlbWVudCBzb21lIHRoaW5ncyB0aGF0IGFyZSBrbm93biBidXN0ZWQgb3IgbWlzc2luZy5cblxuICAvLyBsY2htb2QsIGJyb2tlbiBwcmlvciB0byAwLjYuMlxuICAvLyBiYWNrLXBvcnQgdGhlIGZpeCBoZXJlLlxuICBpZiAoY29uc3RhbnRzLmhhc093blByb3BlcnR5KCdPX1NZTUxJTksnKSAmJlxuICAgICAgcHJvY2Vzcy52ZXJzaW9uLm1hdGNoKC9edjBcXC42XFwuWzAtMl18XnYwXFwuNVxcLi8pKSB7XG4gICAgcGF0Y2hMY2htb2QoZnMpXG4gIH1cblxuICAvLyBsdXRpbWVzIGltcGxlbWVudGF0aW9uLCBvciBuby1vcFxuICBpZiAoIWZzLmx1dGltZXMpIHtcbiAgICBwYXRjaEx1dGltZXMoZnMpXG4gIH1cblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL25vZGUtZ3JhY2VmdWwtZnMvaXNzdWVzLzRcbiAgLy8gQ2hvd24gc2hvdWxkIG5vdCBmYWlsIG9uIGVpbnZhbCBvciBlcGVybSBpZiBub24tcm9vdC5cbiAgLy8gSXQgc2hvdWxkIG5vdCBmYWlsIG9uIGVub3N5cyBldmVyLCBhcyB0aGlzIGp1c3QgaW5kaWNhdGVzXG4gIC8vIHRoYXQgYSBmcyBkb2Vzbid0IHN1cHBvcnQgdGhlIGludGVuZGVkIG9wZXJhdGlvbi5cblxuICBmcy5jaG93biA9IGNob3duRml4KGZzLmNob3duKVxuICBmcy5mY2hvd24gPSBjaG93bkZpeChmcy5mY2hvd24pXG4gIGZzLmxjaG93biA9IGNob3duRml4KGZzLmxjaG93bilcblxuICBmcy5jaG1vZCA9IGNobW9kRml4KGZzLmNobW9kKVxuICBmcy5mY2htb2QgPSBjaG1vZEZpeChmcy5mY2htb2QpXG4gIGZzLmxjaG1vZCA9IGNobW9kRml4KGZzLmxjaG1vZClcblxuICBmcy5jaG93blN5bmMgPSBjaG93bkZpeFN5bmMoZnMuY2hvd25TeW5jKVxuICBmcy5mY2hvd25TeW5jID0gY2hvd25GaXhTeW5jKGZzLmZjaG93blN5bmMpXG4gIGZzLmxjaG93blN5bmMgPSBjaG93bkZpeFN5bmMoZnMubGNob3duU3luYylcblxuICBmcy5jaG1vZFN5bmMgPSBjaG1vZEZpeFN5bmMoZnMuY2htb2RTeW5jKVxuICBmcy5mY2htb2RTeW5jID0gY2htb2RGaXhTeW5jKGZzLmZjaG1vZFN5bmMpXG4gIGZzLmxjaG1vZFN5bmMgPSBjaG1vZEZpeFN5bmMoZnMubGNobW9kU3luYylcblxuICBmcy5zdGF0ID0gc3RhdEZpeChmcy5zdGF0KVxuICBmcy5mc3RhdCA9IHN0YXRGaXgoZnMuZnN0YXQpXG4gIGZzLmxzdGF0ID0gc3RhdEZpeChmcy5sc3RhdClcblxuICBmcy5zdGF0U3luYyA9IHN0YXRGaXhTeW5jKGZzLnN0YXRTeW5jKVxuICBmcy5mc3RhdFN5bmMgPSBzdGF0Rml4U3luYyhmcy5mc3RhdFN5bmMpXG4gIGZzLmxzdGF0U3luYyA9IHN0YXRGaXhTeW5jKGZzLmxzdGF0U3luYylcblxuICAvLyBpZiBsY2htb2QvbGNob3duIGRvIG5vdCBleGlzdCwgdGhlbiBtYWtlIHRoZW0gbm8tb3BzXG4gIGlmICghZnMubGNobW9kKSB7XG4gICAgZnMubGNobW9kID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUsIGNiKSB7XG4gICAgICBpZiAoY2IpIHByb2Nlc3MubmV4dFRpY2soY2IpXG4gICAgfVxuICAgIGZzLmxjaG1vZFN5bmMgPSBmdW5jdGlvbiAoKSB7fVxuICB9XG4gIGlmICghZnMubGNob3duKSB7XG4gICAgZnMubGNob3duID0gZnVuY3Rpb24gKHBhdGgsIHVpZCwgZ2lkLCBjYikge1xuICAgICAgaWYgKGNiKSBwcm9jZXNzLm5leHRUaWNrKGNiKVxuICAgIH1cbiAgICBmcy5sY2hvd25TeW5jID0gZnVuY3Rpb24gKCkge31cbiAgfVxuXG4gIC8vIG9uIFdpbmRvd3MsIEEvViBzb2Z0d2FyZSBjYW4gbG9jayB0aGUgZGlyZWN0b3J5LCBjYXVzaW5nIHRoaXNcbiAgLy8gdG8gZmFpbCB3aXRoIGFuIEVBQ0NFUyBvciBFUEVSTSBpZiB0aGUgZGlyZWN0b3J5IGNvbnRhaW5zIG5ld2x5XG4gIC8vIGNyZWF0ZWQgZmlsZXMuICBUcnkgYWdhaW4gb24gZmFpbHVyZSwgZm9yIHVwIHRvIDYwIHNlY29uZHMuXG5cbiAgLy8gU2V0IHRoZSB0aW1lb3V0IHRoaXMgbG9uZyBiZWNhdXNlIHNvbWUgV2luZG93cyBBbnRpLVZpcnVzLCBzdWNoIGFzIFBhcml0eVxuICAvLyBiaXQ5LCBtYXkgbG9jayBmaWxlcyBmb3IgdXAgdG8gYSBtaW51dGUsIGNhdXNpbmcgbnBtIHBhY2thZ2UgaW5zdGFsbFxuICAvLyBmYWlsdXJlcy4gQWxzbywgdGFrZSBjYXJlIHRvIHlpZWxkIHRoZSBzY2hlZHVsZXIuIFdpbmRvd3Mgc2NoZWR1bGluZyBnaXZlc1xuICAvLyBDUFUgdG8gYSBidXN5IGxvb3BpbmcgcHJvY2Vzcywgd2hpY2ggY2FuIGNhdXNlIHRoZSBwcm9ncmFtIGNhdXNpbmcgdGhlIGxvY2tcbiAgLy8gY29udGVudGlvbiB0byBiZSBzdGFydmVkIG9mIENQVSBieSBub2RlLCBzbyB0aGUgY29udGVudGlvbiBkb2Vzbid0IHJlc29sdmUuXG4gIGlmIChwbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgZnMucmVuYW1lID0gKGZ1bmN0aW9uIChmcyRyZW5hbWUpIHsgcmV0dXJuIGZ1bmN0aW9uIChmcm9tLCB0bywgY2IpIHtcbiAgICAgIHZhciBzdGFydCA9IERhdGUubm93KClcbiAgICAgIHZhciBiYWNrb2ZmID0gMDtcbiAgICAgIGZzJHJlbmFtZShmcm9tLCB0bywgZnVuY3Rpb24gQ0IgKGVyKSB7XG4gICAgICAgIGlmIChlclxuICAgICAgICAgICAgJiYgKGVyLmNvZGUgPT09IFwiRUFDQ0VTXCIgfHwgZXIuY29kZSA9PT0gXCJFUEVSTVwiKVxuICAgICAgICAgICAgJiYgRGF0ZS5ub3coKSAtIHN0YXJ0IDwgNjAwMDApIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZnMuc3RhdCh0bywgZnVuY3Rpb24gKHN0YXRlciwgc3QpIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlciAmJiBzdGF0ZXIuY29kZSA9PT0gXCJFTk9FTlRcIilcbiAgICAgICAgICAgICAgICBmcyRyZW5hbWUoZnJvbSwgdG8sIENCKTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNiKGVyKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LCBiYWNrb2ZmKVxuICAgICAgICAgIGlmIChiYWNrb2ZmIDwgMTAwKVxuICAgICAgICAgICAgYmFja29mZiArPSAxMDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNiKSBjYihlcilcbiAgICAgIH0pXG4gICAgfX0pKGZzLnJlbmFtZSlcbiAgfVxuXG4gIC8vIGlmIHJlYWQoKSByZXR1cm5zIEVBR0FJTiwgdGhlbiBqdXN0IHRyeSBpdCBhZ2Fpbi5cbiAgZnMucmVhZCA9IChmdW5jdGlvbiAoZnMkcmVhZCkge1xuICAgIGZ1bmN0aW9uIHJlYWQgKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2tfKSB7XG4gICAgICB2YXIgY2FsbGJhY2tcbiAgICAgIGlmIChjYWxsYmFja18gJiYgdHlwZW9mIGNhbGxiYWNrXyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgZWFnQ291bnRlciA9IDBcbiAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoZXIsIF8sIF9fKSB7XG4gICAgICAgICAgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFQUdBSU4nICYmIGVhZ0NvdW50ZXIgPCAxMCkge1xuICAgICAgICAgICAgZWFnQ291bnRlciArK1xuICAgICAgICAgICAgcmV0dXJuIGZzJHJlYWQuY2FsbChmcywgZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaylcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2tfLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZzJHJlYWQuY2FsbChmcywgZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaylcbiAgICB9XG5cbiAgICAvLyBUaGlzIGVuc3VyZXMgYHV0aWwucHJvbWlzaWZ5YCB3b3JrcyBhcyBpdCBkb2VzIGZvciBuYXRpdmUgYGZzLnJlYWRgLlxuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIE9iamVjdC5zZXRQcm90b3R5cGVPZihyZWFkLCBmcyRyZWFkKVxuICAgIHJldHVybiByZWFkXG4gIH0pKGZzLnJlYWQpXG5cbiAgZnMucmVhZFN5bmMgPSAoZnVuY3Rpb24gKGZzJHJlYWRTeW5jKSB7IHJldHVybiBmdW5jdGlvbiAoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XG4gICAgdmFyIGVhZ0NvdW50ZXIgPSAwXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmcyRyZWFkU3luYy5jYWxsKGZzLCBmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBpZiAoZXIuY29kZSA9PT0gJ0VBR0FJTicgJiYgZWFnQ291bnRlciA8IDEwKSB7XG4gICAgICAgICAgZWFnQ291bnRlciArK1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJcbiAgICAgIH1cbiAgICB9XG4gIH19KShmcy5yZWFkU3luYylcblxuICBmdW5jdGlvbiBwYXRjaExjaG1vZCAoZnMpIHtcbiAgICBmcy5sY2htb2QgPSBmdW5jdGlvbiAocGF0aCwgbW9kZSwgY2FsbGJhY2spIHtcbiAgICAgIGZzLm9wZW4oIHBhdGhcbiAgICAgICAgICAgICAsIGNvbnN0YW50cy5PX1dST05MWSB8IGNvbnN0YW50cy5PX1NZTUxJTktcbiAgICAgICAgICAgICAsIG1vZGVcbiAgICAgICAgICAgICAsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVycilcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICAvLyBwcmVmZXIgdG8gcmV0dXJuIHRoZSBjaG1vZCBlcnJvciwgaWYgb25lIG9jY3VycyxcbiAgICAgICAgLy8gYnV0IHN0aWxsIHRyeSB0byBjbG9zZSwgYW5kIHJlcG9ydCBjbG9zaW5nIGVycm9ycyBpZiB0aGV5IG9jY3VyLlxuICAgICAgICBmcy5mY2htb2QoZmQsIG1vZGUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBmcy5jbG9zZShmZCwgZnVuY3Rpb24oZXJyMikge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIgfHwgZXJyMilcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmcy5sY2htb2RTeW5jID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUpIHtcbiAgICAgIHZhciBmZCA9IGZzLm9wZW5TeW5jKHBhdGgsIGNvbnN0YW50cy5PX1dST05MWSB8IGNvbnN0YW50cy5PX1NZTUxJTkssIG1vZGUpXG5cbiAgICAgIC8vIHByZWZlciB0byByZXR1cm4gdGhlIGNobW9kIGVycm9yLCBpZiBvbmUgb2NjdXJzLFxuICAgICAgLy8gYnV0IHN0aWxsIHRyeSB0byBjbG9zZSwgYW5kIHJlcG9ydCBjbG9zaW5nIGVycm9ycyBpZiB0aGV5IG9jY3VyLlxuICAgICAgdmFyIHRocmV3ID0gdHJ1ZVxuICAgICAgdmFyIHJldFxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0ID0gZnMuZmNobW9kU3luYyhmZCwgbW9kZSlcbiAgICAgICAgdGhyZXcgPSBmYWxzZVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRocmV3KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgICB9IGNhdGNoIChlcikge31cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXRcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaEx1dGltZXMgKGZzKSB7XG4gICAgaWYgKGNvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eShcIk9fU1lNTElOS1wiKSkge1xuICAgICAgZnMubHV0aW1lcyA9IGZ1bmN0aW9uIChwYXRoLCBhdCwgbXQsIGNiKSB7XG4gICAgICAgIGZzLm9wZW4ocGF0aCwgY29uc3RhbnRzLk9fU1lNTElOSywgZnVuY3Rpb24gKGVyLCBmZCkge1xuICAgICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgaWYgKGNiKSBjYihlcilcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBmcy5mdXRpbWVzKGZkLCBhdCwgbXQsIGZ1bmN0aW9uIChlcikge1xuICAgICAgICAgICAgZnMuY2xvc2UoZmQsIGZ1bmN0aW9uIChlcjIpIHtcbiAgICAgICAgICAgICAgaWYgKGNiKSBjYihlciB8fCBlcjIpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGZzLmx1dGltZXNTeW5jID0gZnVuY3Rpb24gKHBhdGgsIGF0LCBtdCkge1xuICAgICAgICB2YXIgZmQgPSBmcy5vcGVuU3luYyhwYXRoLCBjb25zdGFudHMuT19TWU1MSU5LKVxuICAgICAgICB2YXIgcmV0XG4gICAgICAgIHZhciB0aHJldyA9IHRydWVcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXQgPSBmcy5mdXRpbWVzU3luYyhmZCwgYXQsIG10KVxuICAgICAgICAgIHRocmV3ID0gZmFsc2VcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAodGhyZXcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVyKSB7fVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXRcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBmcy5sdXRpbWVzID0gZnVuY3Rpb24gKF9hLCBfYiwgX2MsIGNiKSB7IGlmIChjYikgcHJvY2Vzcy5uZXh0VGljayhjYikgfVxuICAgICAgZnMubHV0aW1lc1N5bmMgPSBmdW5jdGlvbiAoKSB7fVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNobW9kRml4IChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBtb2RlLCBjYikge1xuICAgICAgcmV0dXJuIG9yaWcuY2FsbChmcywgdGFyZ2V0LCBtb2RlLCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgICAgaWYgKGNob3duRXJPayhlcikpIGVyID0gbnVsbFxuICAgICAgICBpZiAoY2IpIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2htb2RGaXhTeW5jIChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBtb2RlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIG1vZGUpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBpZiAoIWNob3duRXJPayhlcikpIHRocm93IGVyXG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICBmdW5jdGlvbiBjaG93bkZpeCAob3JpZykge1xuICAgIGlmICghb3JpZykgcmV0dXJuIG9yaWdcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgdWlkLCBnaWQsIGNiKSB7XG4gICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIHVpZCwgZ2lkLCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgICAgaWYgKGNob3duRXJPayhlcikpIGVyID0gbnVsbFxuICAgICAgICBpZiAoY2IpIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hvd25GaXhTeW5jIChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCB1aWQsIGdpZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG9yaWcuY2FsbChmcywgdGFyZ2V0LCB1aWQsIGdpZClcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGlmICghY2hvd25Fck9rKGVyKSkgdGhyb3cgZXJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdGF0Rml4IChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIC8vIE9sZGVyIHZlcnNpb25zIG9mIE5vZGUgZXJyb25lb3VzbHkgcmV0dXJuZWQgc2lnbmVkIGludGVnZXJzIGZvclxuICAgIC8vIHVpZCArIGdpZC5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucywgY2IpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYiA9IG9wdGlvbnNcbiAgICAgICAgb3B0aW9ucyA9IG51bGxcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrIChlciwgc3RhdHMpIHtcbiAgICAgICAgaWYgKHN0YXRzKSB7XG4gICAgICAgICAgaWYgKHN0YXRzLnVpZCA8IDApIHN0YXRzLnVpZCArPSAweDEwMDAwMDAwMFxuICAgICAgICAgIGlmIChzdGF0cy5naWQgPCAwKSBzdGF0cy5naWQgKz0gMHgxMDAwMDAwMDBcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2IpIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zID8gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgICAgICA6IG9yaWcuY2FsbChmcywgdGFyZ2V0LCBjYWxsYmFjaylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdGF0Rml4U3luYyAob3JpZykge1xuICAgIGlmICghb3JpZykgcmV0dXJuIG9yaWdcbiAgICAvLyBPbGRlciB2ZXJzaW9ucyBvZiBOb2RlIGVycm9uZW91c2x5IHJldHVybmVkIHNpZ25lZCBpbnRlZ2VycyBmb3JcbiAgICAvLyB1aWQgKyBnaWQuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzdGF0cyA9IG9wdGlvbnMgPyBvcmlnLmNhbGwoZnMsIHRhcmdldCwgb3B0aW9ucylcbiAgICAgICAgOiBvcmlnLmNhbGwoZnMsIHRhcmdldClcbiAgICAgIGlmIChzdGF0cy51aWQgPCAwKSBzdGF0cy51aWQgKz0gMHgxMDAwMDAwMDBcbiAgICAgIGlmIChzdGF0cy5naWQgPCAwKSBzdGF0cy5naWQgKz0gMHgxMDAwMDAwMDBcbiAgICAgIHJldHVybiBzdGF0cztcbiAgICB9XG4gIH1cblxuICAvLyBFTk9TWVMgbWVhbnMgdGhhdCB0aGUgZnMgZG9lc24ndCBzdXBwb3J0IHRoZSBvcC4gSnVzdCBpZ25vcmVcbiAgLy8gdGhhdCwgYmVjYXVzZSBpdCBkb2Vzbid0IG1hdHRlci5cbiAgLy9cbiAgLy8gaWYgdGhlcmUncyBubyBnZXR1aWQsIG9yIGlmIGdldHVpZCgpIGlzIHNvbWV0aGluZyBvdGhlclxuICAvLyB0aGFuIDAsIGFuZCB0aGUgZXJyb3IgaXMgRUlOVkFMIG9yIEVQRVJNLCB0aGVuIGp1c3QgaWdub3JlXG4gIC8vIGl0LlxuICAvL1xuICAvLyBUaGlzIHNwZWNpZmljIGNhc2UgaXMgYSBzaWxlbnQgZmFpbHVyZSBpbiBjcCwgaW5zdGFsbCwgdGFyLFxuICAvLyBhbmQgbW9zdCBvdGhlciB1bml4IHRvb2xzIHRoYXQgbWFuYWdlIHBlcm1pc3Npb25zLlxuICAvL1xuICAvLyBXaGVuIHJ1bm5pbmcgYXMgcm9vdCwgb3IgaWYgb3RoZXIgdHlwZXMgb2YgZXJyb3JzIGFyZVxuICAvLyBlbmNvdW50ZXJlZCwgdGhlbiBpdCdzIHN0cmljdC5cbiAgZnVuY3Rpb24gY2hvd25Fck9rIChlcikge1xuICAgIGlmICghZXIpXG4gICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgaWYgKGVyLmNvZGUgPT09IFwiRU5PU1lTXCIpXG4gICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgdmFyIG5vbnJvb3QgPSAhcHJvY2Vzcy5nZXR1aWQgfHwgcHJvY2Vzcy5nZXR1aWQoKSAhPT0gMFxuICAgIGlmIChub25yb290KSB7XG4gICAgICBpZiAoZXIuY29kZSA9PT0gXCJFSU5WQUxcIiB8fCBlci5jb2RlID09PSBcIkVQRVJNXCIpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbiIsInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW1cblxubW9kdWxlLmV4cG9ydHMgPSBsZWdhY3lcblxuZnVuY3Rpb24gbGVnYWN5IChmcykge1xuICByZXR1cm4ge1xuICAgIFJlYWRTdHJlYW06IFJlYWRTdHJlYW0sXG4gICAgV3JpdGVTdHJlYW06IFdyaXRlU3RyZWFtXG4gIH1cblxuICBmdW5jdGlvbiBSZWFkU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRTdHJlYW0pKSByZXR1cm4gbmV3IFJlYWRTdHJlYW0ocGF0aCwgb3B0aW9ucyk7XG5cbiAgICBTdHJlYW0uY2FsbCh0aGlzKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5mZCA9IG51bGw7XG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuZmxhZ3MgPSAncic7XG4gICAgdGhpcy5tb2RlID0gNDM4OyAvKj0wNjY2Ki9cbiAgICB0aGlzLmJ1ZmZlclNpemUgPSA2NCAqIDEwMjQ7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIE1peGluIG9wdGlvbnMgaW50byB0aGlzXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVuY29kaW5nKSB0aGlzLnNldEVuY29kaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgaWYgKHRoaXMuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdGhpcy5zdGFydCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ3N0YXJ0IG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZW5kID0gSW5maW5pdHk7XG4gICAgICB9IGVsc2UgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdGhpcy5lbmQpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdlbmQgbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdGFydCA+IHRoaXMuZW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQgbXVzdCBiZSA8PSBlbmQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZkICE9PSBudWxsKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLl9yZWFkKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmcy5vcGVuKHRoaXMucGF0aCwgdGhpcy5mbGFncywgdGhpcy5tb2RlLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgc2VsZi5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNlbGYuZmQgPSBmZDtcbiAgICAgIHNlbGYuZW1pdCgnb3BlbicsIGZkKTtcbiAgICAgIHNlbGYuX3JlYWQoKTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gV3JpdGVTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGVTdHJlYW0pKSByZXR1cm4gbmV3IFdyaXRlU3RyZWFtKHBhdGgsIG9wdGlvbnMpO1xuXG4gICAgU3RyZWFtLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuZmQgPSBudWxsO1xuICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gICAgdGhpcy5mbGFncyA9ICd3JztcbiAgICB0aGlzLmVuY29kaW5nID0gJ2JpbmFyeSc7XG4gICAgdGhpcy5tb2RlID0gNDM4OyAvKj0wNjY2Ki9cbiAgICB0aGlzLmJ5dGVzV3JpdHRlbiA9IDA7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIE1peGluIG9wdGlvbnMgaW50byB0aGlzXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIHRoaXMuc3RhcnQpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdzdGFydCBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGFydCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydCBtdXN0IGJlID49IHplcm8nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0O1xuICAgIH1cblxuICAgIHRoaXMuYnVzeSA9IGZhbHNlO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG5cbiAgICBpZiAodGhpcy5mZCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fb3BlbiA9IGZzLm9wZW47XG4gICAgICB0aGlzLl9xdWV1ZS5wdXNoKFt0aGlzLl9vcGVuLCB0aGlzLnBhdGgsIHRoaXMuZmxhZ3MsIHRoaXMubW9kZSwgdW5kZWZpbmVkXSk7XG4gICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVxuXG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqLl9fcHJvdG9fX1xufVxuXG5mdW5jdGlvbiBjbG9uZSAob2JqKSB7XG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpXG4gICAgcmV0dXJuIG9ialxuXG4gIGlmIChvYmogaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgdmFyIGNvcHkgPSB7IF9fcHJvdG9fXzogZ2V0UHJvdG90eXBlT2Yob2JqKSB9XG4gIGVsc2VcbiAgICB2YXIgY29weSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb3B5LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpKVxuICB9KVxuXG4gIHJldHVybiBjb3B5XG59XG4iLCJ2YXIgZnMgPSByZXF1aXJlKCdmcycpXG52YXIgcG9seWZpbGxzID0gcmVxdWlyZSgnLi9wb2x5ZmlsbHMuanMnKVxudmFyIGxlZ2FjeSA9IHJlcXVpcmUoJy4vbGVnYWN5LXN0cmVhbXMuanMnKVxudmFyIGNsb25lID0gcmVxdWlyZSgnLi9jbG9uZS5qcycpXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gbm9kZSAwLnggcG9seWZpbGwgKi9cbnZhciBncmFjZWZ1bFF1ZXVlXG52YXIgcHJldmlvdXNTeW1ib2xcblxuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgLSBub2RlIDAueCBwb2x5ZmlsbCAqL1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5mb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgZ3JhY2VmdWxRdWV1ZSA9IFN5bWJvbC5mb3IoJ2dyYWNlZnVsLWZzLnF1ZXVlJylcbiAgLy8gVGhpcyBpcyB1c2VkIGluIHRlc3RpbmcgYnkgZnV0dXJlIHZlcnNpb25zXG4gIHByZXZpb3VzU3ltYm9sID0gU3ltYm9sLmZvcignZ3JhY2VmdWwtZnMucHJldmlvdXMnKVxufSBlbHNlIHtcbiAgZ3JhY2VmdWxRdWV1ZSA9ICdfX19ncmFjZWZ1bC1mcy5xdWV1ZSdcbiAgcHJldmlvdXNTeW1ib2wgPSAnX19fZ3JhY2VmdWwtZnMucHJldmlvdXMnXG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuZnVuY3Rpb24gcHVibGlzaFF1ZXVlKGNvbnRleHQsIHF1ZXVlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb250ZXh0LCBncmFjZWZ1bFF1ZXVlLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBxdWV1ZVxuICAgIH1cbiAgfSlcbn1cblxudmFyIGRlYnVnID0gbm9vcFxuaWYgKHV0aWwuZGVidWdsb2cpXG4gIGRlYnVnID0gdXRpbC5kZWJ1Z2xvZygnZ2ZzNCcpXG5lbHNlIGlmICgvXFxiZ2ZzNFxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJykpXG4gIGRlYnVnID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG0gPSB1dGlsLmZvcm1hdC5hcHBseSh1dGlsLCBhcmd1bWVudHMpXG4gICAgbSA9ICdHRlM0OiAnICsgbS5zcGxpdCgvXFxuLykuam9pbignXFxuR0ZTNDogJylcbiAgICBjb25zb2xlLmVycm9yKG0pXG4gIH1cblxuLy8gT25jZSB0aW1lIGluaXRpYWxpemF0aW9uXG5pZiAoIWZzW2dyYWNlZnVsUXVldWVdKSB7XG4gIC8vIFRoaXMgcXVldWUgY2FuIGJlIHNoYXJlZCBieSBtdWx0aXBsZSBsb2FkZWQgaW5zdGFuY2VzXG4gIHZhciBxdWV1ZSA9IGdsb2JhbFtncmFjZWZ1bFF1ZXVlXSB8fCBbXVxuICBwdWJsaXNoUXVldWUoZnMsIHF1ZXVlKVxuXG4gIC8vIFBhdGNoIGZzLmNsb3NlL2Nsb3NlU3luYyB0byBzaGFyZWQgcXVldWUgdmVyc2lvbiwgYmVjYXVzZSB3ZSBuZWVkXG4gIC8vIHRvIHJldHJ5KCkgd2hlbmV2ZXIgYSBjbG9zZSBoYXBwZW5zICphbnl3aGVyZSogaW4gdGhlIHByb2dyYW0uXG4gIC8vIFRoaXMgaXMgZXNzZW50aWFsIHdoZW4gbXVsdGlwbGUgZ3JhY2VmdWwtZnMgaW5zdGFuY2VzIGFyZVxuICAvLyBpbiBwbGF5IGF0IHRoZSBzYW1lIHRpbWUuXG4gIGZzLmNsb3NlID0gKGZ1bmN0aW9uIChmcyRjbG9zZSkge1xuICAgIGZ1bmN0aW9uIGNsb3NlIChmZCwgY2IpIHtcbiAgICAgIHJldHVybiBmcyRjbG9zZS5jYWxsKGZzLCBmZCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIHVzZXMgdGhlIGdyYWNlZnVsLWZzIHNoYXJlZCBxdWV1ZVxuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIHJlc2V0UXVldWUoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9KVxuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbG9zZSwgcHJldmlvdXNTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmcyRjbG9zZVxuICAgIH0pXG4gICAgcmV0dXJuIGNsb3NlXG4gIH0pKGZzLmNsb3NlKVxuXG4gIGZzLmNsb3NlU3luYyA9IChmdW5jdGlvbiAoZnMkY2xvc2VTeW5jKSB7XG4gICAgZnVuY3Rpb24gY2xvc2VTeW5jIChmZCkge1xuICAgICAgLy8gVGhpcyBmdW5jdGlvbiB1c2VzIHRoZSBncmFjZWZ1bC1mcyBzaGFyZWQgcXVldWVcbiAgICAgIGZzJGNsb3NlU3luYy5hcHBseShmcywgYXJndW1lbnRzKVxuICAgICAgcmVzZXRRdWV1ZSgpXG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb3NlU3luYywgcHJldmlvdXNTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmcyRjbG9zZVN5bmNcbiAgICB9KVxuICAgIHJldHVybiBjbG9zZVN5bmNcbiAgfSkoZnMuY2xvc2VTeW5jKVxuXG4gIGlmICgvXFxiZ2ZzNFxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJykpIHtcbiAgICBwcm9jZXNzLm9uKCdleGl0JywgZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zyhmc1tncmFjZWZ1bFF1ZXVlXSlcbiAgICAgIHJlcXVpcmUoJ2Fzc2VydCcpLmVxdWFsKGZzW2dyYWNlZnVsUXVldWVdLmxlbmd0aCwgMClcbiAgICB9KVxuICB9XG59XG5cbmlmICghZ2xvYmFsW2dyYWNlZnVsUXVldWVdKSB7XG4gIHB1Ymxpc2hRdWV1ZShnbG9iYWwsIGZzW2dyYWNlZnVsUXVldWVdKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaChjbG9uZShmcykpXG5pZiAocHJvY2Vzcy5lbnYuVEVTVF9HUkFDRUZVTF9GU19HTE9CQUxfUEFUQ0ggJiYgIWZzLl9fcGF0Y2hlZCkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcGF0Y2goZnMpXG4gICAgZnMuX19wYXRjaGVkID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcGF0Y2ggKGZzKSB7XG4gIC8vIEV2ZXJ5dGhpbmcgdGhhdCByZWZlcmVuY2VzIHRoZSBvcGVuKCkgZnVuY3Rpb24gbmVlZHMgdG8gYmUgaW4gaGVyZVxuICBwb2x5ZmlsbHMoZnMpXG4gIGZzLmdyYWNlZnVsaWZ5ID0gcGF0Y2hcblxuICBmcy5jcmVhdGVSZWFkU3RyZWFtID0gY3JlYXRlUmVhZFN0cmVhbVxuICBmcy5jcmVhdGVXcml0ZVN0cmVhbSA9IGNyZWF0ZVdyaXRlU3RyZWFtXG4gIHZhciBmcyRyZWFkRmlsZSA9IGZzLnJlYWRGaWxlXG4gIGZzLnJlYWRGaWxlID0gcmVhZEZpbGVcbiAgZnVuY3Rpb24gcmVhZEZpbGUgKHBhdGgsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBvcHRpb25zLCBvcHRpb25zID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJHJlYWRGaWxlKHBhdGgsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kcmVhZEZpbGUgKHBhdGgsIG9wdGlvbnMsIGNiLCBzdGFydFRpbWUpIHtcbiAgICAgIHJldHVybiBmcyRyZWFkRmlsZShwYXRoLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJHJlYWRGaWxlLCBbcGF0aCwgb3B0aW9ucywgY2JdLCBlcnIsIHN0YXJ0VGltZSB8fCBEYXRlLm5vdygpLCBEYXRlLm5vdygpXSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICB2YXIgZnMkd3JpdGVGaWxlID0gZnMud3JpdGVGaWxlXG4gIGZzLndyaXRlRmlsZSA9IHdyaXRlRmlsZVxuICBmdW5jdGlvbiB3cml0ZUZpbGUgKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBvcHRpb25zLCBvcHRpb25zID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJHdyaXRlRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBjYilcblxuICAgIGZ1bmN0aW9uIGdvJHdyaXRlRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IsIHN0YXJ0VGltZSkge1xuICAgICAgcmV0dXJuIGZzJHdyaXRlRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJHdyaXRlRmlsZSwgW3BhdGgsIGRhdGEsIG9wdGlvbnMsIGNiXSwgZXJyLCBzdGFydFRpbWUgfHwgRGF0ZS5ub3coKSwgRGF0ZS5ub3coKV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgdmFyIGZzJGFwcGVuZEZpbGUgPSBmcy5hcHBlbmRGaWxlXG4gIGlmIChmcyRhcHBlbmRGaWxlKVxuICAgIGZzLmFwcGVuZEZpbGUgPSBhcHBlbmRGaWxlXG4gIGZ1bmN0aW9uIGFwcGVuZEZpbGUgKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBvcHRpb25zLCBvcHRpb25zID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJGFwcGVuZEZpbGUocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpXG5cbiAgICBmdW5jdGlvbiBnbyRhcHBlbmRGaWxlIChwYXRoLCBkYXRhLCBvcHRpb25zLCBjYiwgc3RhcnRUaW1lKSB7XG4gICAgICByZXR1cm4gZnMkYXBwZW5kRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJGFwcGVuZEZpbGUsIFtwYXRoLCBkYXRhLCBvcHRpb25zLCBjYl0sIGVyciwgc3RhcnRUaW1lIHx8IERhdGUubm93KCksIERhdGUubm93KCldKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyRjb3B5RmlsZSA9IGZzLmNvcHlGaWxlXG4gIGlmIChmcyRjb3B5RmlsZSlcbiAgICBmcy5jb3B5RmlsZSA9IGNvcHlGaWxlXG4gIGZ1bmN0aW9uIGNvcHlGaWxlIChzcmMsIGRlc3QsIGZsYWdzLCBjYikge1xuICAgIGlmICh0eXBlb2YgZmxhZ3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gZmxhZ3NcbiAgICAgIGZsYWdzID0gMFxuICAgIH1cbiAgICByZXR1cm4gZ28kY29weUZpbGUoc3JjLCBkZXN0LCBmbGFncywgY2IpXG5cbiAgICBmdW5jdGlvbiBnbyRjb3B5RmlsZSAoc3JjLCBkZXN0LCBmbGFncywgY2IsIHN0YXJ0VGltZSkge1xuICAgICAgcmV0dXJuIGZzJGNvcHlGaWxlKHNyYywgZGVzdCwgZmxhZ3MsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kY29weUZpbGUsIFtzcmMsIGRlc3QsIGZsYWdzLCBjYl0sIGVyciwgc3RhcnRUaW1lIHx8IERhdGUubm93KCksIERhdGUubm93KCldKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyRyZWFkZGlyID0gZnMucmVhZGRpclxuICBmcy5yZWFkZGlyID0gcmVhZGRpclxuICBmdW5jdGlvbiByZWFkZGlyIChwYXRoLCBvcHRpb25zLCBjYikge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gb3B0aW9ucywgb3B0aW9ucyA9IG51bGxcblxuICAgIHJldHVybiBnbyRyZWFkZGlyKHBhdGgsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kcmVhZGRpciAocGF0aCwgb3B0aW9ucywgY2IsIHN0YXJ0VGltZSkge1xuICAgICAgcmV0dXJuIGZzJHJlYWRkaXIocGF0aCwgb3B0aW9ucywgZnVuY3Rpb24gKGVyciwgZmlsZXMpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kcmVhZGRpciwgW3BhdGgsIG9wdGlvbnMsIGNiXSwgZXJyLCBzdGFydFRpbWUgfHwgRGF0ZS5ub3coKSwgRGF0ZS5ub3coKV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChmaWxlcyAmJiBmaWxlcy5zb3J0KVxuICAgICAgICAgICAgZmlsZXMuc29ydCgpXG5cbiAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IuY2FsbCh0aGlzLCBlcnIsIGZpbGVzKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLnZlcnNpb24uc3Vic3RyKDAsIDQpID09PSAndjAuOCcpIHtcbiAgICB2YXIgbGVnU3RyZWFtcyA9IGxlZ2FjeShmcylcbiAgICBSZWFkU3RyZWFtID0gbGVnU3RyZWFtcy5SZWFkU3RyZWFtXG4gICAgV3JpdGVTdHJlYW0gPSBsZWdTdHJlYW1zLldyaXRlU3RyZWFtXG4gIH1cblxuICB2YXIgZnMkUmVhZFN0cmVhbSA9IGZzLlJlYWRTdHJlYW1cbiAgaWYgKGZzJFJlYWRTdHJlYW0pIHtcbiAgICBSZWFkU3RyZWFtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZnMkUmVhZFN0cmVhbS5wcm90b3R5cGUpXG4gICAgUmVhZFN0cmVhbS5wcm90b3R5cGUub3BlbiA9IFJlYWRTdHJlYW0kb3BlblxuICB9XG5cbiAgdmFyIGZzJFdyaXRlU3RyZWFtID0gZnMuV3JpdGVTdHJlYW1cbiAgaWYgKGZzJFdyaXRlU3RyZWFtKSB7XG4gICAgV3JpdGVTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShmcyRXcml0ZVN0cmVhbS5wcm90b3R5cGUpXG4gICAgV3JpdGVTdHJlYW0ucHJvdG90eXBlLm9wZW4gPSBXcml0ZVN0cmVhbSRvcGVuXG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnMsICdSZWFkU3RyZWFtJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFJlYWRTdHJlYW1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgUmVhZFN0cmVhbSA9IHZhbFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZzLCAnV3JpdGVTdHJlYW0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gV3JpdGVTdHJlYW1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgV3JpdGVTdHJlYW0gPSB2YWxcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG5cbiAgLy8gbGVnYWN5IG5hbWVzXG4gIHZhciBGaWxlUmVhZFN0cmVhbSA9IFJlYWRTdHJlYW1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZzLCAnRmlsZVJlYWRTdHJlYW0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gRmlsZVJlYWRTdHJlYW1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgRmlsZVJlYWRTdHJlYW0gPSB2YWxcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG4gIHZhciBGaWxlV3JpdGVTdHJlYW0gPSBXcml0ZVN0cmVhbVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnMsICdGaWxlV3JpdGVTdHJlYW0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gRmlsZVdyaXRlU3RyZWFtXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIEZpbGVXcml0ZVN0cmVhbSA9IHZhbFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcblxuICBmdW5jdGlvbiBSZWFkU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBSZWFkU3RyZWFtKVxuICAgICAgcmV0dXJuIGZzJFJlYWRTdHJlYW0uYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdGhpc1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBSZWFkU3RyZWFtLmFwcGx5KE9iamVjdC5jcmVhdGUoUmVhZFN0cmVhbS5wcm90b3R5cGUpLCBhcmd1bWVudHMpXG4gIH1cblxuICBmdW5jdGlvbiBSZWFkU3RyZWFtJG9wZW4gKCkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIG9wZW4odGhhdC5wYXRoLCB0aGF0LmZsYWdzLCB0aGF0Lm1vZGUsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmICh0aGF0LmF1dG9DbG9zZSlcbiAgICAgICAgICB0aGF0LmRlc3Ryb3koKVxuXG4gICAgICAgIHRoYXQuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGF0LmZkID0gZmRcbiAgICAgICAgdGhhdC5lbWl0KCdvcGVuJywgZmQpXG4gICAgICAgIHRoYXQucmVhZCgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIFdyaXRlU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBXcml0ZVN0cmVhbSlcbiAgICAgIHJldHVybiBmcyRXcml0ZVN0cmVhbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0aGlzXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIFdyaXRlU3RyZWFtLmFwcGx5KE9iamVjdC5jcmVhdGUoV3JpdGVTdHJlYW0ucHJvdG90eXBlKSwgYXJndW1lbnRzKVxuICB9XG5cbiAgZnVuY3Rpb24gV3JpdGVTdHJlYW0kb3BlbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgb3Blbih0aGF0LnBhdGgsIHRoYXQuZmxhZ3MsIHRoYXQubW9kZSwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhhdC5kZXN0cm95KClcbiAgICAgICAgdGhhdC5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoYXQuZmQgPSBmZFxuICAgICAgICB0aGF0LmVtaXQoJ29wZW4nLCBmZClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUmVhZFN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgZnMuUmVhZFN0cmVhbShwYXRoLCBvcHRpb25zKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlV3JpdGVTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IGZzLldyaXRlU3RyZWFtKHBhdGgsIG9wdGlvbnMpXG4gIH1cblxuICB2YXIgZnMkb3BlbiA9IGZzLm9wZW5cbiAgZnMub3BlbiA9IG9wZW5cbiAgZnVuY3Rpb24gb3BlbiAocGF0aCwgZmxhZ3MsIG1vZGUsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBtb2RlID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBtb2RlLCBtb2RlID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJG9wZW4ocGF0aCwgZmxhZ3MsIG1vZGUsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kb3BlbiAocGF0aCwgZmxhZ3MsIG1vZGUsIGNiLCBzdGFydFRpbWUpIHtcbiAgICAgIHJldHVybiBmcyRvcGVuKHBhdGgsIGZsYWdzLCBtb2RlLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgICBpZiAoZXJyICYmIChlcnIuY29kZSA9PT0gJ0VNRklMRScgfHwgZXJyLmNvZGUgPT09ICdFTkZJTEUnKSlcbiAgICAgICAgICBlbnF1ZXVlKFtnbyRvcGVuLCBbcGF0aCwgZmxhZ3MsIG1vZGUsIGNiXSwgZXJyLCBzdGFydFRpbWUgfHwgRGF0ZS5ub3coKSwgRGF0ZS5ub3coKV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZzXG59XG5cbmZ1bmN0aW9uIGVucXVldWUgKGVsZW0pIHtcbiAgZGVidWcoJ0VOUVVFVUUnLCBlbGVtWzBdLm5hbWUsIGVsZW1bMV0pXG4gIGZzW2dyYWNlZnVsUXVldWVdLnB1c2goZWxlbSlcbiAgcmV0cnkoKVxufVxuXG4vLyBrZWVwIHRyYWNrIG9mIHRoZSB0aW1lb3V0IGJldHdlZW4gcmV0cnkoKSBjYWxsc1xudmFyIHJldHJ5VGltZXJcblxuLy8gcmVzZXQgdGhlIHN0YXJ0VGltZSBhbmQgbGFzdFRpbWUgdG8gbm93XG4vLyB0aGlzIHJlc2V0cyB0aGUgc3RhcnQgb2YgdGhlIDYwIHNlY29uZCBvdmVyYWxsIHRpbWVvdXQgYXMgd2VsbCBhcyB0aGVcbi8vIGRlbGF5IGJldHdlZW4gYXR0ZW1wdHMgc28gdGhhdCB3ZSdsbCByZXRyeSB0aGVzZSBqb2JzIHNvb25lclxuZnVuY3Rpb24gcmVzZXRRdWV1ZSAoKSB7XG4gIHZhciBub3cgPSBEYXRlLm5vdygpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnNbZ3JhY2VmdWxRdWV1ZV0ubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBlbnRyaWVzIHRoYXQgYXJlIG9ubHkgYSBsZW5ndGggb2YgMiBhcmUgZnJvbSBhbiBvbGRlciB2ZXJzaW9uLCBkb24ndFxuICAgIC8vIGJvdGhlciBtb2RpZnlpbmcgdGhvc2Ugc2luY2UgdGhleSdsbCBiZSByZXRyaWVkIGFueXdheS5cbiAgICBpZiAoZnNbZ3JhY2VmdWxRdWV1ZV1baV0ubGVuZ3RoID4gMikge1xuICAgICAgZnNbZ3JhY2VmdWxRdWV1ZV1baV1bM10gPSBub3cgLy8gc3RhcnRUaW1lXG4gICAgICBmc1tncmFjZWZ1bFF1ZXVlXVtpXVs0XSA9IG5vdyAvLyBsYXN0VGltZVxuICAgIH1cbiAgfVxuICAvLyBjYWxsIHJldHJ5IHRvIG1ha2Ugc3VyZSB3ZSdyZSBhY3RpdmVseSBwcm9jZXNzaW5nIHRoZSBxdWV1ZVxuICByZXRyeSgpXG59XG5cbmZ1bmN0aW9uIHJldHJ5ICgpIHtcbiAgLy8gY2xlYXIgdGhlIHRpbWVyIGFuZCByZW1vdmUgaXQgdG8gaGVscCBwcmV2ZW50IHVuaW50ZW5kZWQgY29uY3VycmVuY3lcbiAgY2xlYXJUaW1lb3V0KHJldHJ5VGltZXIpXG4gIHJldHJ5VGltZXIgPSB1bmRlZmluZWRcblxuICBpZiAoZnNbZ3JhY2VmdWxRdWV1ZV0ubGVuZ3RoID09PSAwKVxuICAgIHJldHVyblxuXG4gIHZhciBlbGVtID0gZnNbZ3JhY2VmdWxRdWV1ZV0uc2hpZnQoKVxuICB2YXIgZm4gPSBlbGVtWzBdXG4gIHZhciBhcmdzID0gZWxlbVsxXVxuICAvLyB0aGVzZSBpdGVtcyBtYXkgYmUgdW5zZXQgaWYgdGhleSB3ZXJlIGFkZGVkIGJ5IGFuIG9sZGVyIGdyYWNlZnVsLWZzXG4gIHZhciBlcnIgPSBlbGVtWzJdXG4gIHZhciBzdGFydFRpbWUgPSBlbGVtWzNdXG4gIHZhciBsYXN0VGltZSA9IGVsZW1bNF1cblxuICAvLyBpZiB3ZSBkb24ndCBoYXZlIGEgc3RhcnRUaW1lIHdlIGhhdmUgbm8gd2F5IG9mIGtub3dpbmcgaWYgd2UndmUgd2FpdGVkXG4gIC8vIGxvbmcgZW5vdWdoLCBzbyBnbyBhaGVhZCBhbmQgcmV0cnkgdGhpcyBpdGVtIG5vd1xuICBpZiAoc3RhcnRUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICBkZWJ1ZygnUkVUUlknLCBmbi5uYW1lLCBhcmdzKVxuICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpXG4gIH0gZWxzZSBpZiAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA+PSA2MDAwMCkge1xuICAgIC8vIGl0J3MgYmVlbiBtb3JlIHRoYW4gNjAgc2Vjb25kcyB0b3RhbCwgYmFpbCBub3dcbiAgICBkZWJ1ZygnVElNRU9VVCcsIGZuLm5hbWUsIGFyZ3MpXG4gICAgdmFyIGNiID0gYXJncy5wb3AoKVxuICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYi5jYWxsKG51bGwsIGVycilcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgYW1vdW50IG9mIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBhdHRlbXB0IGFuZCByaWdodCBub3dcbiAgICB2YXIgc2luY2VBdHRlbXB0ID0gRGF0ZS5ub3coKSAtIGxhc3RUaW1lXG4gICAgLy8gdGhlIGFtb3VudCBvZiB0aW1lIGJldHdlZW4gd2hlbiB3ZSBmaXJzdCB0cmllZCwgYW5kIHdoZW4gd2UgbGFzdCB0cmllZFxuICAgIC8vIHJvdW5kZWQgdXAgdG8gYXQgbGVhc3QgMVxuICAgIHZhciBzaW5jZVN0YXJ0ID0gTWF0aC5tYXgobGFzdFRpbWUgLSBzdGFydFRpbWUsIDEpXG4gICAgLy8gYmFja29mZi4gd2FpdCBsb25nZXIgdGhhbiB0aGUgdG90YWwgdGltZSB3ZSd2ZSBiZWVuIHJldHJ5aW5nLCBidXQgb25seVxuICAgIC8vIHVwIHRvIGEgbWF4aW11bSBvZiAxMDBtc1xuICAgIHZhciBkZXNpcmVkRGVsYXkgPSBNYXRoLm1pbihzaW5jZVN0YXJ0ICogMS4yLCAxMDApXG4gICAgLy8gaXQncyBiZWVuIGxvbmcgZW5vdWdoIHNpbmNlIHRoZSBsYXN0IHJldHJ5LCBkbyBpdCBhZ2FpblxuICAgIGlmIChzaW5jZUF0dGVtcHQgPj0gZGVzaXJlZERlbGF5KSB7XG4gICAgICBkZWJ1ZygnUkVUUlknLCBmbi5uYW1lLCBhcmdzKVxuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoW3N0YXJ0VGltZV0pKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiB3ZSBjYW4ndCBkbyB0aGlzIGpvYiB5ZXQsIHB1c2ggaXQgdG8gdGhlIGVuZCBvZiB0aGUgcXVldWVcbiAgICAgIC8vIGFuZCBsZXQgdGhlIG5leHQgaXRlcmF0aW9uIGNoZWNrIGFnYWluXG4gICAgICBmc1tncmFjZWZ1bFF1ZXVlXS5wdXNoKGVsZW0pXG4gICAgfVxuICB9XG5cbiAgLy8gc2NoZWR1bGUgb3VyIG5leHQgcnVuIGlmIG9uZSBpc24ndCBhbHJlYWR5IHNjaGVkdWxlZFxuICBpZiAocmV0cnlUaW1lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0cnlUaW1lciA9IHNldFRpbWVvdXQocmV0cnksIDApXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuLy8gVGhpcyBpcyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL25vcm1hbGl6ZS9telxuLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTYgSm9uYXRoYW4gT25nIG1lQGpvbmdsZWJlcnJ5LmNvbSBhbmQgQ29udHJpYnV0b3JzXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcblxuY29uc3QgYXBpID0gW1xuICAnYWNjZXNzJyxcbiAgJ2FwcGVuZEZpbGUnLFxuICAnY2htb2QnLFxuICAnY2hvd24nLFxuICAnY2xvc2UnLFxuICAnY29weUZpbGUnLFxuICAnZmNobW9kJyxcbiAgJ2ZjaG93bicsXG4gICdmZGF0YXN5bmMnLFxuICAnZnN0YXQnLFxuICAnZnN5bmMnLFxuICAnZnRydW5jYXRlJyxcbiAgJ2Z1dGltZXMnLFxuICAnbGNobW9kJyxcbiAgJ2xjaG93bicsXG4gICdsaW5rJyxcbiAgJ2xzdGF0JyxcbiAgJ21rZGlyJyxcbiAgJ21rZHRlbXAnLFxuICAnb3BlbicsXG4gICdvcGVuZGlyJyxcbiAgJ3JlYWRkaXInLFxuICAncmVhZEZpbGUnLFxuICAncmVhZGxpbmsnLFxuICAncmVhbHBhdGgnLFxuICAncmVuYW1lJyxcbiAgJ3JtJyxcbiAgJ3JtZGlyJyxcbiAgJ3N0YXQnLFxuICAnc3ltbGluaycsXG4gICd0cnVuY2F0ZScsXG4gICd1bmxpbmsnLFxuICAndXRpbWVzJyxcbiAgJ3dyaXRlRmlsZSdcbl0uZmlsdGVyKGtleSA9PiB7XG4gIC8vIFNvbWUgY29tbWFuZHMgYXJlIG5vdCBhdmFpbGFibGUgb24gc29tZSBzeXN0ZW1zLiBFeDpcbiAgLy8gZnMub3BlbmRpciB3YXMgYWRkZWQgaW4gTm9kZS5qcyB2MTIuMTIuMFxuICAvLyBmcy5ybSB3YXMgYWRkZWQgaW4gTm9kZS5qcyB2MTQuMTQuMFxuICAvLyBmcy5sY2hvd24gaXMgbm90IGF2YWlsYWJsZSBvbiBhdCBsZWFzdCBzb21lIExpbnV4XG4gIHJldHVybiB0eXBlb2YgZnNba2V5XSA9PT0gJ2Z1bmN0aW9uJ1xufSlcblxuLy8gRXhwb3J0IGNsb25lZCBmczpcbk9iamVjdC5hc3NpZ24oZXhwb3J0cywgZnMpXG5cbi8vIFVuaXZlcnNhbGlmeSBhc3luYyBtZXRob2RzOlxuYXBpLmZvckVhY2gobWV0aG9kID0+IHtcbiAgZXhwb3J0c1ttZXRob2RdID0gdShmc1ttZXRob2RdKVxufSlcbmV4cG9ydHMucmVhbHBhdGgubmF0aXZlID0gdShmcy5yZWFscGF0aC5uYXRpdmUpXG5cbi8vIFdlIGRpZmZlciBmcm9tIG16L2ZzIGluIHRoYXQgd2Ugc3RpbGwgc2hpcCB0aGUgb2xkLCBicm9rZW4sIGZzLmV4aXN0cygpXG4vLyBzaW5jZSB3ZSBhcmUgYSBkcm9wLWluIHJlcGxhY2VtZW50IGZvciB0aGUgbmF0aXZlIG1vZHVsZVxuZXhwb3J0cy5leGlzdHMgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnMuZXhpc3RzKGZpbGVuYW1lLCBjYWxsYmFjaylcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgcmV0dXJuIGZzLmV4aXN0cyhmaWxlbmFtZSwgcmVzb2x2ZSlcbiAgfSlcbn1cblxuLy8gZnMucmVhZCgpLCBmcy53cml0ZSgpLCAmIGZzLndyaXRldigpIG5lZWQgc3BlY2lhbCB0cmVhdG1lbnQgZHVlIHRvIG11bHRpcGxlIGNhbGxiYWNrIGFyZ3NcblxuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmcy5yZWFkKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spXG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmcy5yZWFkKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgKGVyciwgYnl0ZXNSZWFkLCBidWZmZXIpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgcmVzb2x2ZSh7IGJ5dGVzUmVhZCwgYnVmZmVyIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuLy8gRnVuY3Rpb24gc2lnbmF0dXJlIGNhbiBiZVxuLy8gZnMud3JpdGUoZmQsIGJ1ZmZlclssIG9mZnNldFssIGxlbmd0aFssIHBvc2l0aW9uXV1dLCBjYWxsYmFjaylcbi8vIE9SXG4vLyBmcy53cml0ZShmZCwgc3RyaW5nWywgcG9zaXRpb25bLCBlbmNvZGluZ11dLCBjYWxsYmFjaylcbi8vIFdlIG5lZWQgdG8gaGFuZGxlIGJvdGggY2FzZXMsIHNvIHdlIHVzZSAuLi5hcmdzXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGZkLCBidWZmZXIsIC4uLmFyZ3MpIHtcbiAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnMud3JpdGUoZmQsIGJ1ZmZlciwgLi4uYXJncylcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnMud3JpdGUoZmQsIGJ1ZmZlciwgLi4uYXJncywgKGVyciwgYnl0ZXNXcml0dGVuLCBidWZmZXIpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgcmVzb2x2ZSh7IGJ5dGVzV3JpdHRlbiwgYnVmZmVyIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuLy8gZnMud3JpdGV2IG9ubHkgYXZhaWxhYmxlIGluIE5vZGUgdjEyLjkuMCtcbmlmICh0eXBlb2YgZnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIEZ1bmN0aW9uIHNpZ25hdHVyZSBpc1xuICAvLyBzLndyaXRldihmZCwgYnVmZmVyc1ssIHBvc2l0aW9uXSwgY2FsbGJhY2spXG4gIC8vIFdlIG5lZWQgdG8gaGFuZGxlIHRoZSBvcHRpb25hbCBhcmcsIHNvIHdlIHVzZSAuLi5hcmdzXG4gIGV4cG9ydHMud3JpdGV2ID0gZnVuY3Rpb24gKGZkLCBidWZmZXJzLCAuLi5hcmdzKSB7XG4gICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBmcy53cml0ZXYoZmQsIGJ1ZmZlcnMsIC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGZzLndyaXRldihmZCwgYnVmZmVycywgLi4uYXJncywgKGVyciwgYnl0ZXNXcml0dGVuLCBidWZmZXJzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgICByZXNvbHZlKHsgYnl0ZXNXcml0dGVuLCBidWZmZXJzIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cbiIsIi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL21ha2UtZGlyXG4vLyBDb3B5cmlnaHQgKGMpIFNpbmRyZSBTb3JodXMgPHNpbmRyZXNvcmh1c0BnbWFpbC5jb20+IChzaW5kcmVzb3JodXMuY29tKVxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4ndXNlIHN0cmljdCdcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy84OTg3XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbGlidXYvbGlidXYvcHVsbC8xMDg4XG5tb2R1bGUuZXhwb3J0cy5jaGVja1BhdGggPSBmdW5jdGlvbiBjaGVja1BhdGggKHB0aCkge1xuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgIGNvbnN0IHBhdGhIYXNJbnZhbGlkV2luQ2hhcmFjdGVycyA9IC9bPD46XCJ8PypdLy50ZXN0KHB0aC5yZXBsYWNlKHBhdGgucGFyc2UocHRoKS5yb290LCAnJykpXG5cbiAgICBpZiAocGF0aEhhc0ludmFsaWRXaW5DaGFyYWN0ZXJzKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgUGF0aCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnM6ICR7cHRofWApXG4gICAgICBlcnJvci5jb2RlID0gJ0VJTlZBTCdcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vZnMnKVxuY29uc3QgeyBjaGVja1BhdGggfSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuXG5jb25zdCBnZXRNb2RlID0gb3B0aW9ucyA9PiB7XG4gIGNvbnN0IGRlZmF1bHRzID0geyBtb2RlOiAwbzc3NyB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHJldHVybiBvcHRpb25zXG4gIHJldHVybiAoeyAuLi5kZWZhdWx0cywgLi4ub3B0aW9ucyB9KS5tb2RlXG59XG5cbm1vZHVsZS5leHBvcnRzLm1ha2VEaXIgPSBhc3luYyAoZGlyLCBvcHRpb25zKSA9PiB7XG4gIGNoZWNrUGF0aChkaXIpXG5cbiAgcmV0dXJuIGZzLm1rZGlyKGRpciwge1xuICAgIG1vZGU6IGdldE1vZGUob3B0aW9ucyksXG4gICAgcmVjdXJzaXZlOiB0cnVlXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzLm1ha2VEaXJTeW5jID0gKGRpciwgb3B0aW9ucykgPT4ge1xuICBjaGVja1BhdGgoZGlyKVxuXG4gIHJldHVybiBmcy5ta2RpclN5bmMoZGlyLCB7XG4gICAgbW9kZTogZ2V0TW9kZShvcHRpb25zKSxcbiAgICByZWN1cnNpdmU6IHRydWVcbiAgfSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21Qcm9taXNlXG5jb25zdCB7IG1ha2VEaXI6IF9tYWtlRGlyLCBtYWtlRGlyU3luYyB9ID0gcmVxdWlyZSgnLi9tYWtlLWRpcicpXG5jb25zdCBtYWtlRGlyID0gdShfbWFrZURpcilcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1rZGlyczogbWFrZURpcixcbiAgbWtkaXJzU3luYzogbWFrZURpclN5bmMsXG4gIC8vIGFsaWFzXG4gIG1rZGlycDogbWFrZURpcixcbiAgbWtkaXJwU3luYzogbWFrZURpclN5bmMsXG4gIGVuc3VyZURpcjogbWFrZURpcixcbiAgZW5zdXJlRGlyU3luYzogbWFrZURpclN5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcblxuZnVuY3Rpb24gdXRpbWVzTWlsbGlzIChwYXRoLCBhdGltZSwgbXRpbWUsIGNhbGxiYWNrKSB7XG4gIC8vIGlmICghSEFTX01JTExJU19SRVMpIHJldHVybiBmcy51dGltZXMocGF0aCwgYXRpbWUsIG10aW1lLCBjYWxsYmFjaylcbiAgZnMub3BlbihwYXRoLCAncisnLCAoZXJyLCBmZCkgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgZnMuZnV0aW1lcyhmZCwgYXRpbWUsIG10aW1lLCBmdXRpbWVzRXJyID0+IHtcbiAgICAgIGZzLmNsb3NlKGZkLCBjbG9zZUVyciA9PiB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZnV0aW1lc0VyciB8fCBjbG9zZUVycilcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gdXRpbWVzTWlsbGlzU3luYyAocGF0aCwgYXRpbWUsIG10aW1lKSB7XG4gIGNvbnN0IGZkID0gZnMub3BlblN5bmMocGF0aCwgJ3IrJylcbiAgZnMuZnV0aW1lc1N5bmMoZmQsIGF0aW1lLCBtdGltZSlcbiAgcmV0dXJuIGZzLmNsb3NlU3luYyhmZClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHV0aW1lc01pbGxpcyxcbiAgdXRpbWVzTWlsbGlzU3luY1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuXG5mdW5jdGlvbiBnZXRTdGF0cyAoc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGNvbnN0IHN0YXRGdW5jID0gb3B0cy5kZXJlZmVyZW5jZVxuICAgID8gKGZpbGUpID0+IGZzLnN0YXQoZmlsZSwgeyBiaWdpbnQ6IHRydWUgfSlcbiAgICA6IChmaWxlKSA9PiBmcy5sc3RhdChmaWxlLCB7IGJpZ2ludDogdHJ1ZSB9KVxuICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgIHN0YXRGdW5jKHNyYyksXG4gICAgc3RhdEZ1bmMoZGVzdCkuY2F0Y2goZXJyID0+IHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHJldHVybiBudWxsXG4gICAgICB0aHJvdyBlcnJcbiAgICB9KVxuICBdKS50aGVuKChbc3JjU3RhdCwgZGVzdFN0YXRdKSA9PiAoeyBzcmNTdGF0LCBkZXN0U3RhdCB9KSlcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdHNTeW5jIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgbGV0IGRlc3RTdGF0XG4gIGNvbnN0IHN0YXRGdW5jID0gb3B0cy5kZXJlZmVyZW5jZVxuICAgID8gKGZpbGUpID0+IGZzLnN0YXRTeW5jKGZpbGUsIHsgYmlnaW50OiB0cnVlIH0pXG4gICAgOiAoZmlsZSkgPT4gZnMubHN0YXRTeW5jKGZpbGUsIHsgYmlnaW50OiB0cnVlIH0pXG4gIGNvbnN0IHNyY1N0YXQgPSBzdGF0RnVuYyhzcmMpXG4gIHRyeSB7XG4gICAgZGVzdFN0YXQgPSBzdGF0RnVuYyhkZXN0KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgPT09ICdFTk9FTlQnKSByZXR1cm4geyBzcmNTdGF0LCBkZXN0U3RhdDogbnVsbCB9XG4gICAgdGhyb3cgZXJyXG4gIH1cbiAgcmV0dXJuIHsgc3JjU3RhdCwgZGVzdFN0YXQgfVxufVxuXG5mdW5jdGlvbiBjaGVja1BhdGhzIChzcmMsIGRlc3QsIGZ1bmNOYW1lLCBvcHRzLCBjYikge1xuICB1dGlsLmNhbGxiYWNraWZ5KGdldFN0YXRzKShzcmMsIGRlc3QsIG9wdHMsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBjb25zdCB7IHNyY1N0YXQsIGRlc3RTdGF0IH0gPSBzdGF0c1xuXG4gICAgaWYgKGRlc3RTdGF0KSB7XG4gICAgICBpZiAoYXJlSWRlbnRpY2FsKHNyY1N0YXQsIGRlc3RTdGF0KSkge1xuICAgICAgICBjb25zdCBzcmNCYXNlTmFtZSA9IHBhdGguYmFzZW5hbWUoc3JjKVxuICAgICAgICBjb25zdCBkZXN0QmFzZU5hbWUgPSBwYXRoLmJhc2VuYW1lKGRlc3QpXG4gICAgICAgIGlmIChmdW5jTmFtZSA9PT0gJ21vdmUnICYmXG4gICAgICAgICAgc3JjQmFzZU5hbWUgIT09IGRlc3RCYXNlTmFtZSAmJlxuICAgICAgICAgIHNyY0Jhc2VOYW1lLnRvTG93ZXJDYXNlKCkgPT09IGRlc3RCYXNlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKG51bGwsIHsgc3JjU3RhdCwgZGVzdFN0YXQsIGlzQ2hhbmdpbmdDYXNlOiB0cnVlIH0pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignU291cmNlIGFuZCBkZXN0aW5hdGlvbiBtdXN0IG5vdCBiZSB0aGUgc2FtZS4nKSlcbiAgICAgIH1cbiAgICAgIGlmIChzcmNTdGF0LmlzRGlyZWN0b3J5KCkgJiYgIWRlc3RTdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihgQ2Fubm90IG92ZXJ3cml0ZSBub24tZGlyZWN0b3J5ICcke2Rlc3R9JyB3aXRoIGRpcmVjdG9yeSAnJHtzcmN9Jy5gKSlcbiAgICAgIH1cbiAgICAgIGlmICghc3JjU3RhdC5pc0RpcmVjdG9yeSgpICYmIGRlc3RTdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihgQ2Fubm90IG92ZXJ3cml0ZSBkaXJlY3RvcnkgJyR7ZGVzdH0nIHdpdGggbm9uLWRpcmVjdG9yeSAnJHtzcmN9Jy5gKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3JjU3RhdC5pc0RpcmVjdG9yeSgpICYmIGlzU3JjU3ViZGlyKHNyYywgZGVzdCkpIHtcbiAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoZXJyTXNnKHNyYywgZGVzdCwgZnVuY05hbWUpKSlcbiAgICB9XG4gICAgcmV0dXJuIGNiKG51bGwsIHsgc3JjU3RhdCwgZGVzdFN0YXQgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gY2hlY2tQYXRoc1N5bmMgKHNyYywgZGVzdCwgZnVuY05hbWUsIG9wdHMpIHtcbiAgY29uc3QgeyBzcmNTdGF0LCBkZXN0U3RhdCB9ID0gZ2V0U3RhdHNTeW5jKHNyYywgZGVzdCwgb3B0cylcblxuICBpZiAoZGVzdFN0YXQpIHtcbiAgICBpZiAoYXJlSWRlbnRpY2FsKHNyY1N0YXQsIGRlc3RTdGF0KSkge1xuICAgICAgY29uc3Qgc3JjQmFzZU5hbWUgPSBwYXRoLmJhc2VuYW1lKHNyYylcbiAgICAgIGNvbnN0IGRlc3RCYXNlTmFtZSA9IHBhdGguYmFzZW5hbWUoZGVzdClcbiAgICAgIGlmIChmdW5jTmFtZSA9PT0gJ21vdmUnICYmXG4gICAgICAgIHNyY0Jhc2VOYW1lICE9PSBkZXN0QmFzZU5hbWUgJiZcbiAgICAgICAgc3JjQmFzZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gZGVzdEJhc2VOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgcmV0dXJuIHsgc3JjU3RhdCwgZGVzdFN0YXQsIGlzQ2hhbmdpbmdDYXNlOiB0cnVlIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignU291cmNlIGFuZCBkZXN0aW5hdGlvbiBtdXN0IG5vdCBiZSB0aGUgc2FtZS4nKVxuICAgIH1cbiAgICBpZiAoc3JjU3RhdC5pc0RpcmVjdG9yeSgpICYmICFkZXN0U3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBvdmVyd3JpdGUgbm9uLWRpcmVjdG9yeSAnJHtkZXN0fScgd2l0aCBkaXJlY3RvcnkgJyR7c3JjfScuYClcbiAgICB9XG4gICAgaWYgKCFzcmNTdGF0LmlzRGlyZWN0b3J5KCkgJiYgZGVzdFN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgb3ZlcndyaXRlIGRpcmVjdG9yeSAnJHtkZXN0fScgd2l0aCBub24tZGlyZWN0b3J5ICcke3NyY30nLmApXG4gICAgfVxuICB9XG5cbiAgaWYgKHNyY1N0YXQuaXNEaXJlY3RvcnkoKSAmJiBpc1NyY1N1YmRpcihzcmMsIGRlc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyhzcmMsIGRlc3QsIGZ1bmNOYW1lKSlcbiAgfVxuICByZXR1cm4geyBzcmNTdGF0LCBkZXN0U3RhdCB9XG59XG5cbi8vIHJlY3Vyc2l2ZWx5IGNoZWNrIGlmIGRlc3QgcGFyZW50IGlzIGEgc3ViZGlyZWN0b3J5IG9mIHNyYy5cbi8vIEl0IHdvcmtzIGZvciBhbGwgZmlsZSB0eXBlcyBpbmNsdWRpbmcgc3ltbGlua3Mgc2luY2UgaXRcbi8vIGNoZWNrcyB0aGUgc3JjIGFuZCBkZXN0IGlub2Rlcy4gSXQgc3RhcnRzIGZyb20gdGhlIGRlZXBlc3Rcbi8vIHBhcmVudCBhbmQgc3RvcHMgb25jZSBpdCByZWFjaGVzIHRoZSBzcmMgcGFyZW50IG9yIHRoZSByb290IHBhdGguXG5mdW5jdGlvbiBjaGVja1BhcmVudFBhdGhzIChzcmMsIHNyY1N0YXQsIGRlc3QsIGZ1bmNOYW1lLCBjYikge1xuICBjb25zdCBzcmNQYXJlbnQgPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKHNyYykpXG4gIGNvbnN0IGRlc3RQYXJlbnQgPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKGRlc3QpKVxuICBpZiAoZGVzdFBhcmVudCA9PT0gc3JjUGFyZW50IHx8IGRlc3RQYXJlbnQgPT09IHBhdGgucGFyc2UoZGVzdFBhcmVudCkucm9vdCkgcmV0dXJuIGNiKClcbiAgZnMuc3RhdChkZXN0UGFyZW50LCB7IGJpZ2ludDogdHJ1ZSB9LCAoZXJyLCBkZXN0U3RhdCkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHJldHVybiBjYigpXG4gICAgICByZXR1cm4gY2IoZXJyKVxuICAgIH1cbiAgICBpZiAoYXJlSWRlbnRpY2FsKHNyY1N0YXQsIGRlc3RTdGF0KSkge1xuICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihlcnJNc2coc3JjLCBkZXN0LCBmdW5jTmFtZSkpKVxuICAgIH1cbiAgICByZXR1cm4gY2hlY2tQYXJlbnRQYXRocyhzcmMsIHNyY1N0YXQsIGRlc3RQYXJlbnQsIGZ1bmNOYW1lLCBjYilcbiAgfSlcbn1cblxuZnVuY3Rpb24gY2hlY2tQYXJlbnRQYXRoc1N5bmMgKHNyYywgc3JjU3RhdCwgZGVzdCwgZnVuY05hbWUpIHtcbiAgY29uc3Qgc3JjUGFyZW50ID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShzcmMpKVxuICBjb25zdCBkZXN0UGFyZW50ID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShkZXN0KSlcbiAgaWYgKGRlc3RQYXJlbnQgPT09IHNyY1BhcmVudCB8fCBkZXN0UGFyZW50ID09PSBwYXRoLnBhcnNlKGRlc3RQYXJlbnQpLnJvb3QpIHJldHVyblxuICBsZXQgZGVzdFN0YXRcbiAgdHJ5IHtcbiAgICBkZXN0U3RhdCA9IGZzLnN0YXRTeW5jKGRlc3RQYXJlbnQsIHsgYmlnaW50OiB0cnVlIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHJldHVyblxuICAgIHRocm93IGVyclxuICB9XG4gIGlmIChhcmVJZGVudGljYWwoc3JjU3RhdCwgZGVzdFN0YXQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyhzcmMsIGRlc3QsIGZ1bmNOYW1lKSlcbiAgfVxuICByZXR1cm4gY2hlY2tQYXJlbnRQYXRoc1N5bmMoc3JjLCBzcmNTdGF0LCBkZXN0UGFyZW50LCBmdW5jTmFtZSlcbn1cblxuZnVuY3Rpb24gYXJlSWRlbnRpY2FsIChzcmNTdGF0LCBkZXN0U3RhdCkge1xuICByZXR1cm4gZGVzdFN0YXQuaW5vICYmIGRlc3RTdGF0LmRldiAmJiBkZXN0U3RhdC5pbm8gPT09IHNyY1N0YXQuaW5vICYmIGRlc3RTdGF0LmRldiA9PT0gc3JjU3RhdC5kZXZcbn1cblxuLy8gcmV0dXJuIHRydWUgaWYgZGVzdCBpcyBhIHN1YmRpciBvZiBzcmMsIG90aGVyd2lzZSBmYWxzZS5cbi8vIEl0IG9ubHkgY2hlY2tzIHRoZSBwYXRoIHN0cmluZ3MuXG5mdW5jdGlvbiBpc1NyY1N1YmRpciAoc3JjLCBkZXN0KSB7XG4gIGNvbnN0IHNyY0FyciA9IHBhdGgucmVzb2x2ZShzcmMpLnNwbGl0KHBhdGguc2VwKS5maWx0ZXIoaSA9PiBpKVxuICBjb25zdCBkZXN0QXJyID0gcGF0aC5yZXNvbHZlKGRlc3QpLnNwbGl0KHBhdGguc2VwKS5maWx0ZXIoaSA9PiBpKVxuICByZXR1cm4gc3JjQXJyLnJlZHVjZSgoYWNjLCBjdXIsIGkpID0+IGFjYyAmJiBkZXN0QXJyW2ldID09PSBjdXIsIHRydWUpXG59XG5cbmZ1bmN0aW9uIGVyck1zZyAoc3JjLCBkZXN0LCBmdW5jTmFtZSkge1xuICByZXR1cm4gYENhbm5vdCAke2Z1bmNOYW1lfSAnJHtzcmN9JyB0byBhIHN1YmRpcmVjdG9yeSBvZiBpdHNlbGYsICcke2Rlc3R9Jy5gXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjaGVja1BhdGhzLFxuICBjaGVja1BhdGhzU3luYyxcbiAgY2hlY2tQYXJlbnRQYXRocyxcbiAgY2hlY2tQYXJlbnRQYXRoc1N5bmMsXG4gIGlzU3JjU3ViZGlyLFxuICBhcmVJZGVudGljYWxcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlyc1N5bmMgPSByZXF1aXJlKCcuLi9ta2RpcnMnKS5ta2RpcnNTeW5jXG5jb25zdCB1dGltZXNNaWxsaXNTeW5jID0gcmVxdWlyZSgnLi4vdXRpbC91dGltZXMnKS51dGltZXNNaWxsaXNTeW5jXG5jb25zdCBzdGF0ID0gcmVxdWlyZSgnLi4vdXRpbC9zdGF0JylcblxuZnVuY3Rpb24gY29weVN5bmMgKHNyYywgZGVzdCwgb3B0cykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRzID0geyBmaWx0ZXI6IG9wdHMgfVxuICB9XG5cbiAgb3B0cyA9IG9wdHMgfHwge31cbiAgb3B0cy5jbG9iYmVyID0gJ2Nsb2JiZXInIGluIG9wdHMgPyAhIW9wdHMuY2xvYmJlciA6IHRydWUgLy8gZGVmYXVsdCB0byB0cnVlIGZvciBub3dcbiAgb3B0cy5vdmVyd3JpdGUgPSAnb3ZlcndyaXRlJyBpbiBvcHRzID8gISFvcHRzLm92ZXJ3cml0ZSA6IG9wdHMuY2xvYmJlciAvLyBvdmVyd3JpdGUgZmFsbHMgYmFjayB0byBjbG9iYmVyXG5cbiAgLy8gV2FybiBhYm91dCB1c2luZyBwcmVzZXJ2ZVRpbWVzdGFtcHMgb24gMzItYml0IG5vZGVcbiAgaWYgKG9wdHMucHJlc2VydmVUaW1lc3RhbXBzICYmIHByb2Nlc3MuYXJjaCA9PT0gJ2lhMzInKSB7XG4gICAgY29uc29sZS53YXJuKGBmcy1leHRyYTogVXNpbmcgdGhlIHByZXNlcnZlVGltZXN0YW1wcyBvcHRpb24gaW4gMzItYml0IG5vZGUgaXMgbm90IHJlY29tbWVuZGVkO1xcblxuICAgIHNlZSBodHRwczovL2dpdGh1Yi5jb20vanByaWNoYXJkc29uL25vZGUtZnMtZXh0cmEvaXNzdWVzLzI2OWApXG4gIH1cblxuICBjb25zdCB7IHNyY1N0YXQsIGRlc3RTdGF0IH0gPSBzdGF0LmNoZWNrUGF0aHNTeW5jKHNyYywgZGVzdCwgJ2NvcHknLCBvcHRzKVxuICBzdGF0LmNoZWNrUGFyZW50UGF0aHNTeW5jKHNyYywgc3JjU3RhdCwgZGVzdCwgJ2NvcHknKVxuICByZXR1cm4gaGFuZGxlRmlsdGVyQW5kQ29weShkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxufVxuXG5mdW5jdGlvbiBoYW5kbGVGaWx0ZXJBbmRDb3B5IChkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmIChvcHRzLmZpbHRlciAmJiAhb3B0cy5maWx0ZXIoc3JjLCBkZXN0KSkgcmV0dXJuXG4gIGNvbnN0IGRlc3RQYXJlbnQgPSBwYXRoLmRpcm5hbWUoZGVzdClcbiAgaWYgKCFmcy5leGlzdHNTeW5jKGRlc3RQYXJlbnQpKSBta2RpcnNTeW5jKGRlc3RQYXJlbnQpXG4gIHJldHVybiBnZXRTdGF0cyhkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxufVxuXG5mdW5jdGlvbiBzdGFydENvcHkgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgaWYgKG9wdHMuZmlsdGVyICYmICFvcHRzLmZpbHRlcihzcmMsIGRlc3QpKSByZXR1cm5cbiAgcmV0dXJuIGdldFN0YXRzKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG59XG5cbmZ1bmN0aW9uIGdldFN0YXRzIChkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGNvbnN0IHN0YXRTeW5jID0gb3B0cy5kZXJlZmVyZW5jZSA/IGZzLnN0YXRTeW5jIDogZnMubHN0YXRTeW5jXG4gIGNvbnN0IHNyY1N0YXQgPSBzdGF0U3luYyhzcmMpXG5cbiAgaWYgKHNyY1N0YXQuaXNEaXJlY3RvcnkoKSkgcmV0dXJuIG9uRGlyKHNyY1N0YXQsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIGVsc2UgaWYgKHNyY1N0YXQuaXNGaWxlKCkgfHxcbiAgICAgICAgICAgc3JjU3RhdC5pc0NoYXJhY3RlckRldmljZSgpIHx8XG4gICAgICAgICAgIHNyY1N0YXQuaXNCbG9ja0RldmljZSgpKSByZXR1cm4gb25GaWxlKHNyY1N0YXQsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIGVsc2UgaWYgKHNyY1N0YXQuaXNTeW1ib2xpY0xpbmsoKSkgcmV0dXJuIG9uTGluayhkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxuICBlbHNlIGlmIChzcmNTdGF0LmlzU29ja2V0KCkpIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvcHkgYSBzb2NrZXQgZmlsZTogJHtzcmN9YClcbiAgZWxzZSBpZiAoc3JjU3RhdC5pc0ZJRk8oKSkgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29weSBhIEZJRk8gcGlwZTogJHtzcmN9YClcbiAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGZpbGU6ICR7c3JjfWApXG59XG5cbmZ1bmN0aW9uIG9uRmlsZSAoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBpZiAoIWRlc3RTdGF0KSByZXR1cm4gY29weUZpbGUoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxuICByZXR1cm4gbWF5Q29weUZpbGUoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxufVxuXG5mdW5jdGlvbiBtYXlDb3B5RmlsZSAoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmIChvcHRzLm92ZXJ3cml0ZSkge1xuICAgIGZzLnVubGlua1N5bmMoZGVzdClcbiAgICByZXR1cm4gY29weUZpbGUoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxuICB9IGVsc2UgaWYgKG9wdHMuZXJyb3JPbkV4aXN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAnJHtkZXN0fScgYWxyZWFkeSBleGlzdHNgKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHlGaWxlIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgZnMuY29weUZpbGVTeW5jKHNyYywgZGVzdClcbiAgaWYgKG9wdHMucHJlc2VydmVUaW1lc3RhbXBzKSBoYW5kbGVUaW1lc3RhbXBzKHNyY1N0YXQubW9kZSwgc3JjLCBkZXN0KVxuICByZXR1cm4gc2V0RGVzdE1vZGUoZGVzdCwgc3JjU3RhdC5tb2RlKVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUaW1lc3RhbXBzIChzcmNNb2RlLCBzcmMsIGRlc3QpIHtcbiAgLy8gTWFrZSBzdXJlIHRoZSBmaWxlIGlzIHdyaXRhYmxlIGJlZm9yZSBzZXR0aW5nIHRoZSB0aW1lc3RhbXBcbiAgLy8gb3RoZXJ3aXNlIG9wZW4gZmFpbHMgd2l0aCBFUEVSTSB3aGVuIGludm9rZWQgd2l0aCAncisnXG4gIC8vICh0aHJvdWdoIHV0aW1lcyBjYWxsKVxuICBpZiAoZmlsZUlzTm90V3JpdGFibGUoc3JjTW9kZSkpIG1ha2VGaWxlV3JpdGFibGUoZGVzdCwgc3JjTW9kZSlcbiAgcmV0dXJuIHNldERlc3RUaW1lc3RhbXBzKHNyYywgZGVzdClcbn1cblxuZnVuY3Rpb24gZmlsZUlzTm90V3JpdGFibGUgKHNyY01vZGUpIHtcbiAgcmV0dXJuIChzcmNNb2RlICYgMG8yMDApID09PSAwXG59XG5cbmZ1bmN0aW9uIG1ha2VGaWxlV3JpdGFibGUgKGRlc3QsIHNyY01vZGUpIHtcbiAgcmV0dXJuIHNldERlc3RNb2RlKGRlc3QsIHNyY01vZGUgfCAwbzIwMClcbn1cblxuZnVuY3Rpb24gc2V0RGVzdE1vZGUgKGRlc3QsIHNyY01vZGUpIHtcbiAgcmV0dXJuIGZzLmNobW9kU3luYyhkZXN0LCBzcmNNb2RlKVxufVxuXG5mdW5jdGlvbiBzZXREZXN0VGltZXN0YW1wcyAoc3JjLCBkZXN0KSB7XG4gIC8vIFRoZSBpbml0aWFsIHNyY1N0YXQuYXRpbWUgY2Fubm90IGJlIHRydXN0ZWRcbiAgLy8gYmVjYXVzZSBpdCBpcyBtb2RpZmllZCBieSB0aGUgcmVhZCgyKSBzeXN0ZW0gY2FsbFxuICAvLyAoU2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZnMuaHRtbCNmc19zdGF0X3RpbWVfdmFsdWVzKVxuICBjb25zdCB1cGRhdGVkU3JjU3RhdCA9IGZzLnN0YXRTeW5jKHNyYylcbiAgcmV0dXJuIHV0aW1lc01pbGxpc1N5bmMoZGVzdCwgdXBkYXRlZFNyY1N0YXQuYXRpbWUsIHVwZGF0ZWRTcmNTdGF0Lm10aW1lKVxufVxuXG5mdW5jdGlvbiBvbkRpciAoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBpZiAoIWRlc3RTdGF0KSByZXR1cm4gbWtEaXJBbmRDb3B5KHNyY1N0YXQubW9kZSwgc3JjLCBkZXN0LCBvcHRzKVxuICByZXR1cm4gY29weURpcihzcmMsIGRlc3QsIG9wdHMpXG59XG5cbmZ1bmN0aW9uIG1rRGlyQW5kQ29weSAoc3JjTW9kZSwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGZzLm1rZGlyU3luYyhkZXN0KVxuICBjb3B5RGlyKHNyYywgZGVzdCwgb3B0cylcbiAgcmV0dXJuIHNldERlc3RNb2RlKGRlc3QsIHNyY01vZGUpXG59XG5cbmZ1bmN0aW9uIGNvcHlEaXIgKHNyYywgZGVzdCwgb3B0cykge1xuICBmcy5yZWFkZGlyU3luYyhzcmMpLmZvckVhY2goaXRlbSA9PiBjb3B5RGlySXRlbShpdGVtLCBzcmMsIGRlc3QsIG9wdHMpKVxufVxuXG5mdW5jdGlvbiBjb3B5RGlySXRlbSAoaXRlbSwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGNvbnN0IHNyY0l0ZW0gPSBwYXRoLmpvaW4oc3JjLCBpdGVtKVxuICBjb25zdCBkZXN0SXRlbSA9IHBhdGguam9pbihkZXN0LCBpdGVtKVxuICBjb25zdCB7IGRlc3RTdGF0IH0gPSBzdGF0LmNoZWNrUGF0aHNTeW5jKHNyY0l0ZW0sIGRlc3RJdGVtLCAnY29weScsIG9wdHMpXG4gIHJldHVybiBzdGFydENvcHkoZGVzdFN0YXQsIHNyY0l0ZW0sIGRlc3RJdGVtLCBvcHRzKVxufVxuXG5mdW5jdGlvbiBvbkxpbmsgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgbGV0IHJlc29sdmVkU3JjID0gZnMucmVhZGxpbmtTeW5jKHNyYylcbiAgaWYgKG9wdHMuZGVyZWZlcmVuY2UpIHtcbiAgICByZXNvbHZlZFNyYyA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCByZXNvbHZlZFNyYylcbiAgfVxuXG4gIGlmICghZGVzdFN0YXQpIHtcbiAgICByZXR1cm4gZnMuc3ltbGlua1N5bmMocmVzb2x2ZWRTcmMsIGRlc3QpXG4gIH0gZWxzZSB7XG4gICAgbGV0IHJlc29sdmVkRGVzdFxuICAgIHRyeSB7XG4gICAgICByZXNvbHZlZERlc3QgPSBmcy5yZWFkbGlua1N5bmMoZGVzdClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIGRlc3QgZXhpc3RzIGFuZCBpcyBhIHJlZ3VsYXIgZmlsZSBvciBkaXJlY3RvcnksXG4gICAgICAvLyBXaW5kb3dzIG1heSB0aHJvdyBVTktOT1dOIGVycm9yLiBJZiBkZXN0IGFscmVhZHkgZXhpc3RzLFxuICAgICAgLy8gZnMgdGhyb3dzIGVycm9yIGFueXdheSwgc28gbm8gbmVlZCB0byBndWFyZCBhZ2FpbnN0IGl0IGhlcmUuXG4gICAgICBpZiAoZXJyLmNvZGUgPT09ICdFSU5WQUwnIHx8IGVyci5jb2RlID09PSAnVU5LTk9XTicpIHJldHVybiBmcy5zeW1saW5rU3luYyhyZXNvbHZlZFNyYywgZGVzdClcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgICBpZiAob3B0cy5kZXJlZmVyZW5jZSkge1xuICAgICAgcmVzb2x2ZWREZXN0ID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIHJlc29sdmVkRGVzdClcbiAgICB9XG4gICAgaWYgKHN0YXQuaXNTcmNTdWJkaXIocmVzb2x2ZWRTcmMsIHJlc29sdmVkRGVzdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvcHkgJyR7cmVzb2x2ZWRTcmN9JyB0byBhIHN1YmRpcmVjdG9yeSBvZiBpdHNlbGYsICcke3Jlc29sdmVkRGVzdH0nLmApXG4gICAgfVxuXG4gICAgLy8gcHJldmVudCBjb3B5IGlmIHNyYyBpcyBhIHN1YmRpciBvZiBkZXN0IHNpbmNlIHVubGlua2luZ1xuICAgIC8vIGRlc3QgaW4gdGhpcyBjYXNlIHdvdWxkIHJlc3VsdCBpbiByZW1vdmluZyBzcmMgY29udGVudHNcbiAgICAvLyBhbmQgdGhlcmVmb3JlIGEgYnJva2VuIHN5bWxpbmsgd291bGQgYmUgY3JlYXRlZC5cbiAgICBpZiAoZnMuc3RhdFN5bmMoZGVzdCkuaXNEaXJlY3RvcnkoKSAmJiBzdGF0LmlzU3JjU3ViZGlyKHJlc29sdmVkRGVzdCwgcmVzb2x2ZWRTcmMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBvdmVyd3JpdGUgJyR7cmVzb2x2ZWREZXN0fScgd2l0aCAnJHtyZXNvbHZlZFNyY30nLmApXG4gICAgfVxuICAgIHJldHVybiBjb3B5TGluayhyZXNvbHZlZFNyYywgZGVzdClcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5TGluayAocmVzb2x2ZWRTcmMsIGRlc3QpIHtcbiAgZnMudW5saW5rU3luYyhkZXN0KVxuICByZXR1cm4gZnMuc3ltbGlua1N5bmMocmVzb2x2ZWRTcmMsIGRlc3QpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bmNcbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29weVN5bmM6IHJlcXVpcmUoJy4vY29weS1zeW5jJylcbn1cbiIsIid1c2Ugc3RyaWN0J1xuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21Qcm9taXNlXG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL2ZzJylcblxuZnVuY3Rpb24gcGF0aEV4aXN0cyAocGF0aCkge1xuICByZXR1cm4gZnMuYWNjZXNzKHBhdGgpLnRoZW4oKCkgPT4gdHJ1ZSkuY2F0Y2goKCkgPT4gZmFsc2UpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXRoRXhpc3RzOiB1KHBhdGhFeGlzdHMpLFxuICBwYXRoRXhpc3RzU3luYzogZnMuZXhpc3RzU3luY1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgbWtkaXJzID0gcmVxdWlyZSgnLi4vbWtkaXJzJykubWtkaXJzXG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKS5wYXRoRXhpc3RzXG5jb25zdCB1dGltZXNNaWxsaXMgPSByZXF1aXJlKCcuLi91dGlsL3V0aW1lcycpLnV0aW1lc01pbGxpc1xuY29uc3Qgc3RhdCA9IHJlcXVpcmUoJy4uL3V0aWwvc3RhdCcpXG5cbmZ1bmN0aW9uIGNvcHkgKHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nICYmICFjYikge1xuICAgIGNiID0gb3B0c1xuICAgIG9wdHMgPSB7fVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0cyA9IHsgZmlsdGVyOiBvcHRzIH1cbiAgfVxuXG4gIGNiID0gY2IgfHwgZnVuY3Rpb24gKCkge31cbiAgb3B0cyA9IG9wdHMgfHwge31cblxuICBvcHRzLmNsb2JiZXIgPSAnY2xvYmJlcicgaW4gb3B0cyA/ICEhb3B0cy5jbG9iYmVyIDogdHJ1ZSAvLyBkZWZhdWx0IHRvIHRydWUgZm9yIG5vd1xuICBvcHRzLm92ZXJ3cml0ZSA9ICdvdmVyd3JpdGUnIGluIG9wdHMgPyAhIW9wdHMub3ZlcndyaXRlIDogb3B0cy5jbG9iYmVyIC8vIG92ZXJ3cml0ZSBmYWxscyBiYWNrIHRvIGNsb2JiZXJcblxuICAvLyBXYXJuIGFib3V0IHVzaW5nIHByZXNlcnZlVGltZXN0YW1wcyBvbiAzMi1iaXQgbm9kZVxuICBpZiAob3B0cy5wcmVzZXJ2ZVRpbWVzdGFtcHMgJiYgcHJvY2Vzcy5hcmNoID09PSAnaWEzMicpIHtcbiAgICBjb25zb2xlLndhcm4oYGZzLWV4dHJhOiBVc2luZyB0aGUgcHJlc2VydmVUaW1lc3RhbXBzIG9wdGlvbiBpbiAzMi1iaXQgbm9kZSBpcyBub3QgcmVjb21tZW5kZWQ7XFxuXG4gICAgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcHJpY2hhcmRzb24vbm9kZS1mcy1leHRyYS9pc3N1ZXMvMjY5YClcbiAgfVxuXG4gIHN0YXQuY2hlY2tQYXRocyhzcmMsIGRlc3QsICdjb3B5Jywgb3B0cywgKGVyciwgc3RhdHMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGNvbnN0IHsgc3JjU3RhdCwgZGVzdFN0YXQgfSA9IHN0YXRzXG4gICAgc3RhdC5jaGVja1BhcmVudFBhdGhzKHNyYywgc3JjU3RhdCwgZGVzdCwgJ2NvcHknLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIGlmIChvcHRzLmZpbHRlcikgcmV0dXJuIGhhbmRsZUZpbHRlcihjaGVja1BhcmVudERpciwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgICByZXR1cm4gY2hlY2tQYXJlbnREaXIoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gY2hlY2tQYXJlbnREaXIgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGNvbnN0IGRlc3RQYXJlbnQgPSBwYXRoLmRpcm5hbWUoZGVzdClcbiAgcGF0aEV4aXN0cyhkZXN0UGFyZW50LCAoZXJyLCBkaXJFeGlzdHMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGlmIChkaXJFeGlzdHMpIHJldHVybiBnZXRTdGF0cyhkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICBta2RpcnMoZGVzdFBhcmVudCwgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICByZXR1cm4gZ2V0U3RhdHMoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gaGFuZGxlRmlsdGVyIChvbkluY2x1ZGUsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIFByb21pc2UucmVzb2x2ZShvcHRzLmZpbHRlcihzcmMsIGRlc3QpKS50aGVuKGluY2x1ZGUgPT4ge1xuICAgIGlmIChpbmNsdWRlKSByZXR1cm4gb25JbmNsdWRlKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIHJldHVybiBjYigpXG4gIH0sIGVycm9yID0+IGNiKGVycm9yKSlcbn1cblxuZnVuY3Rpb24gc3RhcnRDb3B5IChkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBpZiAob3B0cy5maWx0ZXIpIHJldHVybiBoYW5kbGVGaWx0ZXIoZ2V0U3RhdHMsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICByZXR1cm4gZ2V0U3RhdHMoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG59XG5cbmZ1bmN0aW9uIGdldFN0YXRzIChkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBjb25zdCBzdGF0ID0gb3B0cy5kZXJlZmVyZW5jZSA/IGZzLnN0YXQgOiBmcy5sc3RhdFxuICBzdGF0KHNyYywgKGVyciwgc3JjU3RhdCkgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG5cbiAgICBpZiAoc3JjU3RhdC5pc0RpcmVjdG9yeSgpKSByZXR1cm4gb25EaXIoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgZWxzZSBpZiAoc3JjU3RhdC5pc0ZpbGUoKSB8fFxuICAgICAgICAgICAgIHNyY1N0YXQuaXNDaGFyYWN0ZXJEZXZpY2UoKSB8fFxuICAgICAgICAgICAgIHNyY1N0YXQuaXNCbG9ja0RldmljZSgpKSByZXR1cm4gb25GaWxlKHNyY1N0YXQsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIGVsc2UgaWYgKHNyY1N0YXQuaXNTeW1ib2xpY0xpbmsoKSkgcmV0dXJuIG9uTGluayhkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICBlbHNlIGlmIChzcmNTdGF0LmlzU29ja2V0KCkpIHJldHVybiBjYihuZXcgRXJyb3IoYENhbm5vdCBjb3B5IGEgc29ja2V0IGZpbGU6ICR7c3JjfWApKVxuICAgIGVsc2UgaWYgKHNyY1N0YXQuaXNGSUZPKCkpIHJldHVybiBjYihuZXcgRXJyb3IoYENhbm5vdCBjb3B5IGEgRklGTyBwaXBlOiAke3NyY31gKSlcbiAgICByZXR1cm4gY2IobmV3IEVycm9yKGBVbmtub3duIGZpbGU6ICR7c3JjfWApKVxuICB9KVxufVxuXG5mdW5jdGlvbiBvbkZpbGUgKHNyY1N0YXQsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGlmICghZGVzdFN0YXQpIHJldHVybiBjb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICByZXR1cm4gbWF5Q29weUZpbGUoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbn1cblxuZnVuY3Rpb24gbWF5Q29weUZpbGUgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgaWYgKG9wdHMub3ZlcndyaXRlKSB7XG4gICAgZnMudW5saW5rKGRlc3QsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgcmV0dXJuIGNvcHlGaWxlKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgfSlcbiAgfSBlbHNlIGlmIChvcHRzLmVycm9yT25FeGlzdCkge1xuICAgIHJldHVybiBjYihuZXcgRXJyb3IoYCcke2Rlc3R9JyBhbHJlYWR5IGV4aXN0c2ApKVxuICB9IGVsc2UgcmV0dXJuIGNiKClcbn1cblxuZnVuY3Rpb24gY29weUZpbGUgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgZnMuY29weUZpbGUoc3JjLCBkZXN0LCBlcnIgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgaWYgKG9wdHMucHJlc2VydmVUaW1lc3RhbXBzKSByZXR1cm4gaGFuZGxlVGltZXN0YW1wc0FuZE1vZGUoc3JjU3RhdC5tb2RlLCBzcmMsIGRlc3QsIGNiKVxuICAgIHJldHVybiBzZXREZXN0TW9kZShkZXN0LCBzcmNTdGF0Lm1vZGUsIGNiKVxuICB9KVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUaW1lc3RhbXBzQW5kTW9kZSAoc3JjTW9kZSwgc3JjLCBkZXN0LCBjYikge1xuICAvLyBNYWtlIHN1cmUgdGhlIGZpbGUgaXMgd3JpdGFibGUgYmVmb3JlIHNldHRpbmcgdGhlIHRpbWVzdGFtcFxuICAvLyBvdGhlcndpc2Ugb3BlbiBmYWlscyB3aXRoIEVQRVJNIHdoZW4gaW52b2tlZCB3aXRoICdyKydcbiAgLy8gKHRocm91Z2ggdXRpbWVzIGNhbGwpXG4gIGlmIChmaWxlSXNOb3RXcml0YWJsZShzcmNNb2RlKSkge1xuICAgIHJldHVybiBtYWtlRmlsZVdyaXRhYmxlKGRlc3QsIHNyY01vZGUsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgcmV0dXJuIHNldERlc3RUaW1lc3RhbXBzQW5kTW9kZShzcmNNb2RlLCBzcmMsIGRlc3QsIGNiKVxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIHNldERlc3RUaW1lc3RhbXBzQW5kTW9kZShzcmNNb2RlLCBzcmMsIGRlc3QsIGNiKVxufVxuXG5mdW5jdGlvbiBmaWxlSXNOb3RXcml0YWJsZSAoc3JjTW9kZSkge1xuICByZXR1cm4gKHNyY01vZGUgJiAwbzIwMCkgPT09IDBcbn1cblxuZnVuY3Rpb24gbWFrZUZpbGVXcml0YWJsZSAoZGVzdCwgc3JjTW9kZSwgY2IpIHtcbiAgcmV0dXJuIHNldERlc3RNb2RlKGRlc3QsIHNyY01vZGUgfCAwbzIwMCwgY2IpXG59XG5cbmZ1bmN0aW9uIHNldERlc3RUaW1lc3RhbXBzQW5kTW9kZSAoc3JjTW9kZSwgc3JjLCBkZXN0LCBjYikge1xuICBzZXREZXN0VGltZXN0YW1wcyhzcmMsIGRlc3QsIGVyciA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICByZXR1cm4gc2V0RGVzdE1vZGUoZGVzdCwgc3JjTW9kZSwgY2IpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHNldERlc3RNb2RlIChkZXN0LCBzcmNNb2RlLCBjYikge1xuICByZXR1cm4gZnMuY2htb2QoZGVzdCwgc3JjTW9kZSwgY2IpXG59XG5cbmZ1bmN0aW9uIHNldERlc3RUaW1lc3RhbXBzIChzcmMsIGRlc3QsIGNiKSB7XG4gIC8vIFRoZSBpbml0aWFsIHNyY1N0YXQuYXRpbWUgY2Fubm90IGJlIHRydXN0ZWRcbiAgLy8gYmVjYXVzZSBpdCBpcyBtb2RpZmllZCBieSB0aGUgcmVhZCgyKSBzeXN0ZW0gY2FsbFxuICAvLyAoU2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZnMuaHRtbCNmc19zdGF0X3RpbWVfdmFsdWVzKVxuICBmcy5zdGF0KHNyYywgKGVyciwgdXBkYXRlZFNyY1N0YXQpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHJldHVybiB1dGltZXNNaWxsaXMoZGVzdCwgdXBkYXRlZFNyY1N0YXQuYXRpbWUsIHVwZGF0ZWRTcmNTdGF0Lm10aW1lLCBjYilcbiAgfSlcbn1cblxuZnVuY3Rpb24gb25EaXIgKHNyY1N0YXQsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGlmICghZGVzdFN0YXQpIHJldHVybiBta0RpckFuZENvcHkoc3JjU3RhdC5tb2RlLCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICByZXR1cm4gY29weURpcihzcmMsIGRlc3QsIG9wdHMsIGNiKVxufVxuXG5mdW5jdGlvbiBta0RpckFuZENvcHkgKHNyY01vZGUsIHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgZnMubWtkaXIoZGVzdCwgZXJyID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGNvcHlEaXIoc3JjLCBkZXN0LCBvcHRzLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIHJldHVybiBzZXREZXN0TW9kZShkZXN0LCBzcmNNb2RlLCBjYilcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjb3B5RGlyIChzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGZzLnJlYWRkaXIoc3JjLCAoZXJyLCBpdGVtcykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgcmV0dXJuIGNvcHlEaXJJdGVtcyhpdGVtcywgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgfSlcbn1cblxuZnVuY3Rpb24gY29weURpckl0ZW1zIChpdGVtcywgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBjb25zdCBpdGVtID0gaXRlbXMucG9wKClcbiAgaWYgKCFpdGVtKSByZXR1cm4gY2IoKVxuICByZXR1cm4gY29weURpckl0ZW0oaXRlbXMsIGl0ZW0sIHNyYywgZGVzdCwgb3B0cywgY2IpXG59XG5cbmZ1bmN0aW9uIGNvcHlEaXJJdGVtIChpdGVtcywgaXRlbSwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBjb25zdCBzcmNJdGVtID0gcGF0aC5qb2luKHNyYywgaXRlbSlcbiAgY29uc3QgZGVzdEl0ZW0gPSBwYXRoLmpvaW4oZGVzdCwgaXRlbSlcbiAgc3RhdC5jaGVja1BhdGhzKHNyY0l0ZW0sIGRlc3RJdGVtLCAnY29weScsIG9wdHMsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBjb25zdCB7IGRlc3RTdGF0IH0gPSBzdGF0c1xuICAgIHN0YXJ0Q29weShkZXN0U3RhdCwgc3JjSXRlbSwgZGVzdEl0ZW0sIG9wdHMsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgcmV0dXJuIGNvcHlEaXJJdGVtcyhpdGVtcywgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBvbkxpbmsgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGZzLnJlYWRsaW5rKHNyYywgKGVyciwgcmVzb2x2ZWRTcmMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGlmIChvcHRzLmRlcmVmZXJlbmNlKSB7XG4gICAgICByZXNvbHZlZFNyYyA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCByZXNvbHZlZFNyYylcbiAgICB9XG5cbiAgICBpZiAoIWRlc3RTdGF0KSB7XG4gICAgICByZXR1cm4gZnMuc3ltbGluayhyZXNvbHZlZFNyYywgZGVzdCwgY2IpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZzLnJlYWRsaW5rKGRlc3QsIChlcnIsIHJlc29sdmVkRGVzdCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgLy8gZGVzdCBleGlzdHMgYW5kIGlzIGEgcmVndWxhciBmaWxlIG9yIGRpcmVjdG9yeSxcbiAgICAgICAgICAvLyBXaW5kb3dzIG1heSB0aHJvdyBVTktOT1dOIGVycm9yLiBJZiBkZXN0IGFscmVhZHkgZXhpc3RzLFxuICAgICAgICAgIC8vIGZzIHRocm93cyBlcnJvciBhbnl3YXksIHNvIG5vIG5lZWQgdG8gZ3VhcmQgYWdhaW5zdCBpdCBoZXJlLlxuICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VJTlZBTCcgfHwgZXJyLmNvZGUgPT09ICdVTktOT1dOJykgcmV0dXJuIGZzLnN5bWxpbmsocmVzb2x2ZWRTcmMsIGRlc3QsIGNiKVxuICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuZGVyZWZlcmVuY2UpIHtcbiAgICAgICAgICByZXNvbHZlZERlc3QgPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgcmVzb2x2ZWREZXN0KVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0LmlzU3JjU3ViZGlyKHJlc29sdmVkU3JjLCByZXNvbHZlZERlc3QpKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihgQ2Fubm90IGNvcHkgJyR7cmVzb2x2ZWRTcmN9JyB0byBhIHN1YmRpcmVjdG9yeSBvZiBpdHNlbGYsICcke3Jlc29sdmVkRGVzdH0nLmApKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG8gbm90IGNvcHkgaWYgc3JjIGlzIGEgc3ViZGlyIG9mIGRlc3Qgc2luY2UgdW5saW5raW5nXG4gICAgICAgIC8vIGRlc3QgaW4gdGhpcyBjYXNlIHdvdWxkIHJlc3VsdCBpbiByZW1vdmluZyBzcmMgY29udGVudHNcbiAgICAgICAgLy8gYW5kIHRoZXJlZm9yZSBhIGJyb2tlbiBzeW1saW5rIHdvdWxkIGJlIGNyZWF0ZWQuXG4gICAgICAgIGlmIChkZXN0U3RhdC5pc0RpcmVjdG9yeSgpICYmIHN0YXQuaXNTcmNTdWJkaXIocmVzb2x2ZWREZXN0LCByZXNvbHZlZFNyYykpIHtcbiAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKGBDYW5ub3Qgb3ZlcndyaXRlICcke3Jlc29sdmVkRGVzdH0nIHdpdGggJyR7cmVzb2x2ZWRTcmN9Jy5gKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weUxpbmsocmVzb2x2ZWRTcmMsIGRlc3QsIGNiKVxuICAgICAgfSlcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNvcHlMaW5rIChyZXNvbHZlZFNyYywgZGVzdCwgY2IpIHtcbiAgZnMudW5saW5rKGRlc3QsIGVyciA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICByZXR1cm4gZnMuc3ltbGluayhyZXNvbHZlZFNyYywgZGVzdCwgY2IpXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb3B5OiB1KHJlcXVpcmUoJy4vY29weScpKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcblxuY29uc3QgaXNXaW5kb3dzID0gKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpXG5cbmZ1bmN0aW9uIGRlZmF1bHRzIChvcHRpb25zKSB7XG4gIGNvbnN0IG1ldGhvZHMgPSBbXG4gICAgJ3VubGluaycsXG4gICAgJ2NobW9kJyxcbiAgICAnc3RhdCcsXG4gICAgJ2xzdGF0JyxcbiAgICAncm1kaXInLFxuICAgICdyZWFkZGlyJ1xuICBdXG4gIG1ldGhvZHMuZm9yRWFjaChtID0+IHtcbiAgICBvcHRpb25zW21dID0gb3B0aW9uc1ttXSB8fCBmc1ttXVxuICAgIG0gPSBtICsgJ1N5bmMnXG4gICAgb3B0aW9uc1ttXSA9IG9wdGlvbnNbbV0gfHwgZnNbbV1cbiAgfSlcblxuICBvcHRpb25zLm1heEJ1c3lUcmllcyA9IG9wdGlvbnMubWF4QnVzeVRyaWVzIHx8IDNcbn1cblxuZnVuY3Rpb24gcmltcmFmIChwLCBvcHRpb25zLCBjYikge1xuICBsZXQgYnVzeVRyaWVzID0gMFxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG5cbiAgYXNzZXJ0KHAsICdyaW1yYWY6IG1pc3NpbmcgcGF0aCcpXG4gIGFzc2VydC5zdHJpY3RFcXVhbCh0eXBlb2YgcCwgJ3N0cmluZycsICdyaW1yYWY6IHBhdGggc2hvdWxkIGJlIGEgc3RyaW5nJylcbiAgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiBjYiwgJ2Z1bmN0aW9uJywgJ3JpbXJhZjogY2FsbGJhY2sgZnVuY3Rpb24gcmVxdWlyZWQnKVxuICBhc3NlcnQob3B0aW9ucywgJ3JpbXJhZjogaW52YWxpZCBvcHRpb25zIGFyZ3VtZW50IHByb3ZpZGVkJylcbiAgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiBvcHRpb25zLCAnb2JqZWN0JywgJ3JpbXJhZjogb3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0JylcblxuICBkZWZhdWx0cyhvcHRpb25zKVxuXG4gIHJpbXJhZl8ocCwgb3B0aW9ucywgZnVuY3Rpb24gQ0IgKGVyKSB7XG4gICAgaWYgKGVyKSB7XG4gICAgICBpZiAoKGVyLmNvZGUgPT09ICdFQlVTWScgfHwgZXIuY29kZSA9PT0gJ0VOT1RFTVBUWScgfHwgZXIuY29kZSA9PT0gJ0VQRVJNJykgJiZcbiAgICAgICAgICBidXN5VHJpZXMgPCBvcHRpb25zLm1heEJ1c3lUcmllcykge1xuICAgICAgICBidXN5VHJpZXMrK1xuICAgICAgICBjb25zdCB0aW1lID0gYnVzeVRyaWVzICogMTAwXG4gICAgICAgIC8vIHRyeSBhZ2Fpbiwgd2l0aCB0aGUgc2FtZSBleGFjdCBjYWxsYmFjayBhcyB0aGlzIG9uZS5cbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKCkgPT4gcmltcmFmXyhwLCBvcHRpb25zLCBDQiksIHRpbWUpXG4gICAgICB9XG5cbiAgICAgIC8vIGFscmVhZHkgZ29uZVxuICAgICAgaWYgKGVyLmNvZGUgPT09ICdFTk9FTlQnKSBlciA9IG51bGxcbiAgICB9XG5cbiAgICBjYihlcilcbiAgfSlcbn1cblxuLy8gVHdvIHBvc3NpYmxlIHN0cmF0ZWdpZXMuXG4vLyAxLiBBc3N1bWUgaXQncyBhIGZpbGUuICB1bmxpbmsgaXQsIHRoZW4gZG8gdGhlIGRpciBzdHVmZiBvbiBFUEVSTSBvciBFSVNESVJcbi8vIDIuIEFzc3VtZSBpdCdzIGEgZGlyZWN0b3J5LiAgcmVhZGRpciwgdGhlbiBkbyB0aGUgZmlsZSBzdHVmZiBvbiBFTk9URElSXG4vL1xuLy8gQm90aCByZXN1bHQgaW4gYW4gZXh0cmEgc3lzY2FsbCB3aGVuIHlvdSBndWVzcyB3cm9uZy4gIEhvd2V2ZXIsIHRoZXJlXG4vLyBhcmUgbGlrZWx5IGZhciBtb3JlIG5vcm1hbCBmaWxlcyBpbiB0aGUgd29ybGQgdGhhbiBkaXJlY3Rvcmllcy4gIFRoaXNcbi8vIGlzIGJhc2VkIG9uIHRoZSBhc3N1bXB0aW9uIHRoYXQgYSB0aGUgYXZlcmFnZSBudW1iZXIgb2YgZmlsZXMgcGVyXG4vLyBkaXJlY3RvcnkgaXMgPj0gMS5cbi8vXG4vLyBJZiBhbnlvbmUgZXZlciBjb21wbGFpbnMgYWJvdXQgdGhpcywgdGhlbiBJIGd1ZXNzIHRoZSBzdHJhdGVneSBjb3VsZFxuLy8gYmUgbWFkZSBjb25maWd1cmFibGUgc29tZWhvdy4gIEJ1dCB1bnRpbCB0aGVuLCBZQUdOSS5cbmZ1bmN0aW9uIHJpbXJhZl8gKHAsIG9wdGlvbnMsIGNiKSB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgYXNzZXJ0KHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcblxuICAvLyBzdW5vcyBsZXRzIHRoZSByb290IHVzZXIgdW5saW5rIGRpcmVjdG9yaWVzLCB3aGljaCBpcy4uLiB3ZWlyZC5cbiAgLy8gc28gd2UgaGF2ZSB0byBsc3RhdCBoZXJlIGFuZCBtYWtlIHN1cmUgaXQncyBub3QgYSBkaXIuXG4gIG9wdGlvbnMubHN0YXQocCwgKGVyLCBzdCkgPT4ge1xuICAgIGlmIChlciAmJiBlci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgcmV0dXJuIGNiKG51bGwpXG4gICAgfVxuXG4gICAgLy8gV2luZG93cyBjYW4gRVBFUk0gb24gc3RhdC4gIExpZmUgaXMgc3VmZmVyaW5nLlxuICAgIGlmIChlciAmJiBlci5jb2RlID09PSAnRVBFUk0nICYmIGlzV2luZG93cykge1xuICAgICAgcmV0dXJuIGZpeFdpbkVQRVJNKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICB9XG5cbiAgICBpZiAoc3QgJiYgc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgcmV0dXJuIHJtZGlyKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICB9XG5cbiAgICBvcHRpb25zLnVubGluayhwLCBlciA9PiB7XG4gICAgICBpZiAoZXIpIHtcbiAgICAgICAgaWYgKGVyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKG51bGwpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVyLmNvZGUgPT09ICdFUEVSTScpIHtcbiAgICAgICAgICByZXR1cm4gKGlzV2luZG93cylcbiAgICAgICAgICAgID8gZml4V2luRVBFUk0ocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgICAgICAgICAgOiBybWRpcihwLCBvcHRpb25zLCBlciwgY2IpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVyLmNvZGUgPT09ICdFSVNESVInKSB7XG4gICAgICAgICAgcmV0dXJuIHJtZGlyKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNiKGVyKVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGZpeFdpbkVQRVJNIChwLCBvcHRpb25zLCBlciwgY2IpIHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBhc3NlcnQodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuXG4gIG9wdGlvbnMuY2htb2QocCwgMG82NjYsIGVyMiA9PiB7XG4gICAgaWYgKGVyMikge1xuICAgICAgY2IoZXIyLmNvZGUgPT09ICdFTk9FTlQnID8gbnVsbCA6IGVyKVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLnN0YXQocCwgKGVyMywgc3RhdHMpID0+IHtcbiAgICAgICAgaWYgKGVyMykge1xuICAgICAgICAgIGNiKGVyMy5jb2RlID09PSAnRU5PRU5UJyA/IG51bGwgOiBlcilcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgcm1kaXIocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMudW5saW5rKHAsIGNiKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gZml4V2luRVBFUk1TeW5jIChwLCBvcHRpb25zLCBlcikge1xuICBsZXQgc3RhdHNcblxuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG5cbiAgdHJ5IHtcbiAgICBvcHRpb25zLmNobW9kU3luYyhwLCAwbzY2NilcbiAgfSBjYXRjaCAoZXIyKSB7XG4gICAgaWYgKGVyMi5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyXG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICBzdGF0cyA9IG9wdGlvbnMuc3RhdFN5bmMocClcbiAgfSBjYXRjaCAoZXIzKSB7XG4gICAgaWYgKGVyMy5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyXG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICBybWRpclN5bmMocCwgb3B0aW9ucywgZXIpXG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy51bmxpbmtTeW5jKHApXG4gIH1cbn1cblxuZnVuY3Rpb24gcm1kaXIgKHAsIG9wdGlvbnMsIG9yaWdpbmFsRXIsIGNiKSB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgYXNzZXJ0KHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcblxuICAvLyB0cnkgdG8gcm1kaXIgZmlyc3QsIGFuZCBvbmx5IHJlYWRkaXIgb24gRU5PVEVNUFRZIG9yIEVFWElTVCAoU3VuT1MpXG4gIC8vIGlmIHdlIGd1ZXNzZWQgd3JvbmcsIGFuZCBpdCdzIG5vdCBhIGRpcmVjdG9yeSwgdGhlblxuICAvLyByYWlzZSB0aGUgb3JpZ2luYWwgZXJyb3IuXG4gIG9wdGlvbnMucm1kaXIocCwgZXIgPT4ge1xuICAgIGlmIChlciAmJiAoZXIuY29kZSA9PT0gJ0VOT1RFTVBUWScgfHwgZXIuY29kZSA9PT0gJ0VFWElTVCcgfHwgZXIuY29kZSA9PT0gJ0VQRVJNJykpIHtcbiAgICAgIHJta2lkcyhwLCBvcHRpb25zLCBjYilcbiAgICB9IGVsc2UgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFTk9URElSJykge1xuICAgICAgY2Iob3JpZ2luYWxFcilcbiAgICB9IGVsc2Uge1xuICAgICAgY2IoZXIpXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBybWtpZHMgKHAsIG9wdGlvbnMsIGNiKSB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgYXNzZXJ0KHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcblxuICBvcHRpb25zLnJlYWRkaXIocCwgKGVyLCBmaWxlcykgPT4ge1xuICAgIGlmIChlcikgcmV0dXJuIGNiKGVyKVxuXG4gICAgbGV0IG4gPSBmaWxlcy5sZW5ndGhcbiAgICBsZXQgZXJyU3RhdGVcblxuICAgIGlmIChuID09PSAwKSByZXR1cm4gb3B0aW9ucy5ybWRpcihwLCBjYilcblxuICAgIGZpbGVzLmZvckVhY2goZiA9PiB7XG4gICAgICByaW1yYWYocGF0aC5qb2luKHAsIGYpLCBvcHRpb25zLCBlciA9PiB7XG4gICAgICAgIGlmIChlcnJTdGF0ZSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmIChlcikgcmV0dXJuIGNiKGVyclN0YXRlID0gZXIpXG4gICAgICAgIGlmICgtLW4gPT09IDApIHtcbiAgICAgICAgICBvcHRpb25zLnJtZGlyKHAsIGNiKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbi8vIHRoaXMgbG9va3Mgc2ltcGxlciwgYW5kIGlzIHN0cmljdGx5ICpmYXN0ZXIqLCBidXQgd2lsbFxuLy8gdGllIHVwIHRoZSBKYXZhU2NyaXB0IHRocmVhZCBhbmQgZmFpbCBvbiBleGNlc3NpdmVseVxuLy8gZGVlcCBkaXJlY3RvcnkgdHJlZXMuXG5mdW5jdGlvbiByaW1yYWZTeW5jIChwLCBvcHRpb25zKSB7XG4gIGxldCBzdFxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIGRlZmF1bHRzKG9wdGlvbnMpXG5cbiAgYXNzZXJ0KHAsICdyaW1yYWY6IG1pc3NpbmcgcGF0aCcpXG4gIGFzc2VydC5zdHJpY3RFcXVhbCh0eXBlb2YgcCwgJ3N0cmluZycsICdyaW1yYWY6IHBhdGggc2hvdWxkIGJlIGEgc3RyaW5nJylcbiAgYXNzZXJ0KG9wdGlvbnMsICdyaW1yYWY6IG1pc3Npbmcgb3B0aW9ucycpXG4gIGFzc2VydC5zdHJpY3RFcXVhbCh0eXBlb2Ygb3B0aW9ucywgJ29iamVjdCcsICdyaW1yYWY6IG9wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCcpXG5cbiAgdHJ5IHtcbiAgICBzdCA9IG9wdGlvbnMubHN0YXRTeW5jKHApXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgaWYgKGVyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBXaW5kb3dzIGNhbiBFUEVSTSBvbiBzdGF0LiAgTGlmZSBpcyBzdWZmZXJpbmcuXG4gICAgaWYgKGVyLmNvZGUgPT09ICdFUEVSTScgJiYgaXNXaW5kb3dzKSB7XG4gICAgICBmaXhXaW5FUEVSTVN5bmMocCwgb3B0aW9ucywgZXIpXG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBzdW5vcyBsZXRzIHRoZSByb290IHVzZXIgdW5saW5rIGRpcmVjdG9yaWVzLCB3aGljaCBpcy4uLiB3ZWlyZC5cbiAgICBpZiAoc3QgJiYgc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgcm1kaXJTeW5jKHAsIG9wdGlvbnMsIG51bGwpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMudW5saW5rU3luYyhwKVxuICAgIH1cbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSBpZiAoZXIuY29kZSA9PT0gJ0VQRVJNJykge1xuICAgICAgcmV0dXJuIGlzV2luZG93cyA/IGZpeFdpbkVQRVJNU3luYyhwLCBvcHRpb25zLCBlcikgOiBybWRpclN5bmMocCwgb3B0aW9ucywgZXIpXG4gICAgfSBlbHNlIGlmIChlci5jb2RlICE9PSAnRUlTRElSJykge1xuICAgICAgdGhyb3cgZXJcbiAgICB9XG4gICAgcm1kaXJTeW5jKHAsIG9wdGlvbnMsIGVyKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJtZGlyU3luYyAocCwgb3B0aW9ucywgb3JpZ2luYWxFcikge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG5cbiAgdHJ5IHtcbiAgICBvcHRpb25zLnJtZGlyU3luYyhwKVxuICB9IGNhdGNoIChlcikge1xuICAgIGlmIChlci5jb2RlID09PSAnRU5PVERJUicpIHtcbiAgICAgIHRocm93IG9yaWdpbmFsRXJcbiAgICB9IGVsc2UgaWYgKGVyLmNvZGUgPT09ICdFTk9URU1QVFknIHx8IGVyLmNvZGUgPT09ICdFRVhJU1QnIHx8IGVyLmNvZGUgPT09ICdFUEVSTScpIHtcbiAgICAgIHJta2lkc1N5bmMocCwgb3B0aW9ucylcbiAgICB9IGVsc2UgaWYgKGVyLmNvZGUgIT09ICdFTk9FTlQnKSB7XG4gICAgICB0aHJvdyBlclxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBybWtpZHNTeW5jIChwLCBvcHRpb25zKSB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgb3B0aW9ucy5yZWFkZGlyU3luYyhwKS5mb3JFYWNoKGYgPT4gcmltcmFmU3luYyhwYXRoLmpvaW4ocCwgZiksIG9wdGlvbnMpKVxuXG4gIGlmIChpc1dpbmRvd3MpIHtcbiAgICAvLyBXZSBvbmx5IGVuZCB1cCBoZXJlIG9uY2Ugd2UgZ290IEVOT1RFTVBUWSBhdCBsZWFzdCBvbmNlLCBhbmRcbiAgICAvLyBhdCB0aGlzIHBvaW50LCB3ZSBhcmUgZ3VhcmFudGVlZCB0byBoYXZlIHJlbW92ZWQgYWxsIHRoZSBraWRzLlxuICAgIC8vIFNvLCB3ZSBrbm93IHRoYXQgaXQgd29uJ3QgYmUgRU5PRU5UIG9yIEVOT1RESVIgb3IgYW55dGhpbmcgZWxzZS5cbiAgICAvLyB0cnkgcmVhbGx5IGhhcmQgdG8gZGVsZXRlIHN0dWZmIG9uIHdpbmRvd3MsIGJlY2F1c2UgaXQgaGFzIGFcbiAgICAvLyBQUk9GT1VORExZIGFubm95aW5nIGhhYml0IG9mIG5vdCBjbG9zaW5nIGhhbmRsZXMgcHJvbXB0bHkgd2hlblxuICAgIC8vIGZpbGVzIGFyZSBkZWxldGVkLCByZXN1bHRpbmcgaW4gc3B1cmlvdXMgRU5PVEVNUFRZIGVycm9ycy5cbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpXG4gICAgZG8ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0ID0gb3B0aW9ucy5ybWRpclN5bmMocCwgb3B0aW9ucylcbiAgICAgICAgcmV0dXJuIHJldFxuICAgICAgfSBjYXRjaCB7fVxuICAgIH0gd2hpbGUgKERhdGUubm93KCkgLSBzdGFydFRpbWUgPCA1MDApIC8vIGdpdmUgdXAgYWZ0ZXIgNTAwbXNcbiAgfSBlbHNlIHtcbiAgICBjb25zdCByZXQgPSBvcHRpb25zLnJtZGlyU3luYyhwLCBvcHRpb25zKVxuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJpbXJhZlxucmltcmFmLnN5bmMgPSByaW1yYWZTeW5jXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCByaW1yYWYgPSByZXF1aXJlKCcuL3JpbXJhZicpXG5cbmZ1bmN0aW9uIHJlbW92ZSAocGF0aCwgY2FsbGJhY2spIHtcbiAgLy8gTm9kZSAxNC4xNC4wK1xuICBpZiAoZnMucm0pIHJldHVybiBmcy5ybShwYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSwgY2FsbGJhY2spXG4gIHJpbXJhZihwYXRoLCBjYWxsYmFjaylcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3luYyAocGF0aCkge1xuICAvLyBOb2RlIDE0LjE0LjArXG4gIGlmIChmcy5ybVN5bmMpIHJldHVybiBmcy5ybVN5bmMocGF0aCwgeyByZWN1cnNpdmU6IHRydWUsIGZvcmNlOiB0cnVlIH0pXG4gIHJpbXJhZi5zeW5jKHBhdGgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZW1vdmU6IHUocmVtb3ZlKSxcbiAgcmVtb3ZlU3luY1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tUHJvbWlzZVxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBta2RpciA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5jb25zdCByZW1vdmUgPSByZXF1aXJlKCcuLi9yZW1vdmUnKVxuXG5jb25zdCBlbXB0eURpciA9IHUoYXN5bmMgZnVuY3Rpb24gZW1wdHlEaXIgKGRpcikge1xuICBsZXQgaXRlbXNcbiAgdHJ5IHtcbiAgICBpdGVtcyA9IGF3YWl0IGZzLnJlYWRkaXIoZGlyKVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbWtkaXIubWtkaXJzKGRpcilcbiAgfVxuXG4gIHJldHVybiBQcm9taXNlLmFsbChpdGVtcy5tYXAoaXRlbSA9PiByZW1vdmUucmVtb3ZlKHBhdGguam9pbihkaXIsIGl0ZW0pKSkpXG59KVxuXG5mdW5jdGlvbiBlbXB0eURpclN5bmMgKGRpcikge1xuICBsZXQgaXRlbXNcbiAgdHJ5IHtcbiAgICBpdGVtcyA9IGZzLnJlYWRkaXJTeW5jKGRpcilcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG1rZGlyLm1rZGlyc1N5bmMoZGlyKVxuICB9XG5cbiAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICBpdGVtID0gcGF0aC5qb2luKGRpciwgaXRlbSlcbiAgICByZW1vdmUucmVtb3ZlU3luYyhpdGVtKVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZW1wdHlEaXJTeW5jLFxuICBlbXB0eWRpclN5bmM6IGVtcHR5RGlyU3luYyxcbiAgZW1wdHlEaXIsXG4gIGVtcHR5ZGlyOiBlbXB0eURpclxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgbWtkaXIgPSByZXF1aXJlKCcuLi9ta2RpcnMnKVxuXG5mdW5jdGlvbiBjcmVhdGVGaWxlIChmaWxlLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBtYWtlRmlsZSAoKSB7XG4gICAgZnMud3JpdGVGaWxlKGZpbGUsICcnLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9KVxuICB9XG5cbiAgZnMuc3RhdChmaWxlLCAoZXJyLCBzdGF0cykgPT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGhhbmRsZS1jYWxsYmFjay1lcnJcbiAgICBpZiAoIWVyciAmJiBzdGF0cy5pc0ZpbGUoKSkgcmV0dXJuIGNhbGxiYWNrKClcbiAgICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZmlsZSlcbiAgICBmcy5zdGF0KGRpciwgKGVyciwgc3RhdHMpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgLy8gaWYgdGhlIGRpcmVjdG9yeSBkb2Vzbid0IGV4aXN0LCBtYWtlIGl0XG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICByZXR1cm4gbWtkaXIubWtkaXJzKGRpciwgZXJyID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgICBtYWtlRmlsZSgpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkgbWFrZUZpbGUoKVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHBhcmVudCBpcyBub3QgYSBkaXJlY3RvcnlcbiAgICAgICAgLy8gVGhpcyBpcyBqdXN0IHRvIGNhdXNlIGFuIGludGVybmFsIEVOT1RESVIgZXJyb3IgdG8gYmUgdGhyb3duXG4gICAgICAgIGZzLnJlYWRkaXIoZGlyLCBlcnIgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmlsZVN5bmMgKGZpbGUpIHtcbiAgbGV0IHN0YXRzXG4gIHRyeSB7XG4gICAgc3RhdHMgPSBmcy5zdGF0U3luYyhmaWxlKVxuICB9IGNhdGNoIHt9XG4gIGlmIChzdGF0cyAmJiBzdGF0cy5pc0ZpbGUoKSkgcmV0dXJuXG5cbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGUpXG4gIHRyeSB7XG4gICAgaWYgKCFmcy5zdGF0U3luYyhkaXIpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIC8vIHBhcmVudCBpcyBub3QgYSBkaXJlY3RvcnlcbiAgICAgIC8vIFRoaXMgaXMganVzdCB0byBjYXVzZSBhbiBpbnRlcm5hbCBFTk9URElSIGVycm9yIHRvIGJlIHRocm93blxuICAgICAgZnMucmVhZGRpclN5bmMoZGlyKVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gSWYgdGhlIHN0YXQgY2FsbCBhYm92ZSBmYWlsZWQgYmVjYXVzZSB0aGUgZGlyZWN0b3J5IGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBpdFxuICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09ICdFTk9FTlQnKSBta2Rpci5ta2RpcnNTeW5jKGRpcilcbiAgICBlbHNlIHRocm93IGVyclxuICB9XG5cbiAgZnMud3JpdGVGaWxlU3luYyhmaWxlLCAnJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZUZpbGU6IHUoY3JlYXRlRmlsZSksXG4gIGNyZWF0ZUZpbGVTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBta2RpciA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKS5wYXRoRXhpc3RzXG5jb25zdCB7IGFyZUlkZW50aWNhbCB9ID0gcmVxdWlyZSgnLi4vdXRpbC9zdGF0JylcblxuZnVuY3Rpb24gY3JlYXRlTGluayAoc3JjcGF0aCwgZHN0cGF0aCwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gbWFrZUxpbmsgKHNyY3BhdGgsIGRzdHBhdGgpIHtcbiAgICBmcy5saW5rKHNyY3BhdGgsIGRzdHBhdGgsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgY2FsbGJhY2sobnVsbClcbiAgICB9KVxuICB9XG5cbiAgZnMubHN0YXQoZHN0cGF0aCwgKF8sIGRzdFN0YXQpID0+IHtcbiAgICBmcy5sc3RhdChzcmNwYXRoLCAoZXJyLCBzcmNTdGF0KSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGVyci5tZXNzYWdlID0gZXJyLm1lc3NhZ2UucmVwbGFjZSgnbHN0YXQnLCAnZW5zdXJlTGluaycpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG4gICAgICBpZiAoZHN0U3RhdCAmJiBhcmVJZGVudGljYWwoc3JjU3RhdCwgZHN0U3RhdCkpIHJldHVybiBjYWxsYmFjayhudWxsKVxuXG4gICAgICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgICAgIHBhdGhFeGlzdHMoZGlyLCAoZXJyLCBkaXJFeGlzdHMpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgaWYgKGRpckV4aXN0cykgcmV0dXJuIG1ha2VMaW5rKHNyY3BhdGgsIGRzdHBhdGgpXG4gICAgICAgIG1rZGlyLm1rZGlycyhkaXIsIGVyciA9PiB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgICBtYWtlTGluayhzcmNwYXRoLCBkc3RwYXRoKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rU3luYyAoc3JjcGF0aCwgZHN0cGF0aCkge1xuICBsZXQgZHN0U3RhdFxuICB0cnkge1xuICAgIGRzdFN0YXQgPSBmcy5sc3RhdFN5bmMoZHN0cGF0aClcbiAgfSBjYXRjaCB7fVxuXG4gIHRyeSB7XG4gICAgY29uc3Qgc3JjU3RhdCA9IGZzLmxzdGF0U3luYyhzcmNwYXRoKVxuICAgIGlmIChkc3RTdGF0ICYmIGFyZUlkZW50aWNhbChzcmNTdGF0LCBkc3RTdGF0KSkgcmV0dXJuXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5tZXNzYWdlID0gZXJyLm1lc3NhZ2UucmVwbGFjZSgnbHN0YXQnLCAnZW5zdXJlTGluaycpXG4gICAgdGhyb3cgZXJyXG4gIH1cblxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgY29uc3QgZGlyRXhpc3RzID0gZnMuZXhpc3RzU3luYyhkaXIpXG4gIGlmIChkaXJFeGlzdHMpIHJldHVybiBmcy5saW5rU3luYyhzcmNwYXRoLCBkc3RwYXRoKVxuICBta2Rpci5ta2RpcnNTeW5jKGRpcilcblxuICByZXR1cm4gZnMubGlua1N5bmMoc3JjcGF0aCwgZHN0cGF0aClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZUxpbms6IHUoY3JlYXRlTGluayksXG4gIGNyZWF0ZUxpbmtTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKS5wYXRoRXhpc3RzXG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCByZXR1cm5zIHR3byB0eXBlcyBvZiBwYXRocywgb25lIHJlbGF0aXZlIHRvIHN5bWxpbmssIGFuZCBvbmVcbiAqIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LiBDaGVja3MgaWYgcGF0aCBpcyBhYnNvbHV0ZSBvclxuICogcmVsYXRpdmUuIElmIHRoZSBwYXRoIGlzIHJlbGF0aXZlLCB0aGlzIGZ1bmN0aW9uIGNoZWNrcyBpZiB0aGUgcGF0aCBpc1xuICogcmVsYXRpdmUgdG8gc3ltbGluayBvciByZWxhdGl2ZSB0byBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LiBUaGlzIGlzIGFuXG4gKiBpbml0aWF0aXZlIHRvIGZpbmQgYSBzbWFydGVyIGBzcmNwYXRoYCB0byBzdXBwbHkgd2hlbiBidWlsZGluZyBzeW1saW5rcy5cbiAqIFRoaXMgYWxsb3dzIHlvdSB0byBkZXRlcm1pbmUgd2hpY2ggcGF0aCB0byB1c2Ugb3V0IG9mIG9uZSBvZiB0aHJlZSBwb3NzaWJsZVxuICogdHlwZXMgb2Ygc291cmNlIHBhdGhzLiBUaGUgZmlyc3QgaXMgYW4gYWJzb2x1dGUgcGF0aC4gVGhpcyBpcyBkZXRlY3RlZCBieVxuICogYHBhdGguaXNBYnNvbHV0ZSgpYC4gV2hlbiBhbiBhYnNvbHV0ZSBwYXRoIGlzIHByb3ZpZGVkLCBpdCBpcyBjaGVja2VkIHRvXG4gKiBzZWUgaWYgaXQgZXhpc3RzLiBJZiBpdCBkb2VzIGl0J3MgdXNlZCwgaWYgbm90IGFuIGVycm9yIGlzIHJldHVybmVkXG4gKiAoY2FsbGJhY2spLyB0aHJvd24gKHN5bmMpLiBUaGUgb3RoZXIgdHdvIG9wdGlvbnMgZm9yIGBzcmNwYXRoYCBhcmUgYVxuICogcmVsYXRpdmUgdXJsLiBCeSBkZWZhdWx0IE5vZGUncyBgZnMuc3ltbGlua2Agd29ya3MgYnkgY3JlYXRpbmcgYSBzeW1saW5rXG4gKiB1c2luZyBgZHN0cGF0aGAgYW5kIGV4cGVjdHMgdGhlIGBzcmNwYXRoYCB0byBiZSByZWxhdGl2ZSB0byB0aGUgbmV3bHlcbiAqIGNyZWF0ZWQgc3ltbGluay4gSWYgeW91IHByb3ZpZGUgYSBgc3JjcGF0aGAgdGhhdCBkb2VzIG5vdCBleGlzdCBvbiB0aGUgZmlsZVxuICogc3lzdGVtIGl0IHJlc3VsdHMgaW4gYSBicm9rZW4gc3ltbGluay4gVG8gbWluaW1pemUgdGhpcywgdGhlIGZ1bmN0aW9uXG4gKiBjaGVja3MgdG8gc2VlIGlmIHRoZSAncmVsYXRpdmUgdG8gc3ltbGluaycgc291cmNlIGZpbGUgZXhpc3RzLCBhbmQgaWYgaXRcbiAqIGRvZXMgaXQgd2lsbCB1c2UgaXQuIElmIGl0IGRvZXMgbm90LCBpdCBjaGVja3MgaWYgdGhlcmUncyBhIGZpbGUgdGhhdFxuICogZXhpc3RzIHRoYXQgaXMgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnksIGlmIGRvZXMgaXRzIHVzZWQuXG4gKiBUaGlzIHByZXNlcnZlcyB0aGUgZXhwZWN0YXRpb25zIG9mIHRoZSBvcmlnaW5hbCBmcy5zeW1saW5rIHNwZWMgYW5kIGFkZHNcbiAqIHRoZSBhYmlsaXR5IHRvIHBhc3MgaW4gYHJlbGF0aXZlIHRvIGN1cnJlbnQgd29ya2luZyBkaXJlY290cnlgIHBhdGhzLlxuICovXG5cbmZ1bmN0aW9uIHN5bWxpbmtQYXRocyAoc3JjcGF0aCwgZHN0cGF0aCwgY2FsbGJhY2spIHtcbiAgaWYgKHBhdGguaXNBYnNvbHV0ZShzcmNwYXRoKSkge1xuICAgIHJldHVybiBmcy5sc3RhdChzcmNwYXRoLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGVyci5tZXNzYWdlID0gZXJyLm1lc3NhZ2UucmVwbGFjZSgnbHN0YXQnLCAnZW5zdXJlU3ltbGluaycpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwge1xuICAgICAgICB0b0N3ZDogc3JjcGF0aCxcbiAgICAgICAgdG9Ec3Q6IHNyY3BhdGhcbiAgICAgIH0pXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBkc3RkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgICBjb25zdCByZWxhdGl2ZVRvRHN0ID0gcGF0aC5qb2luKGRzdGRpciwgc3JjcGF0aClcbiAgICByZXR1cm4gcGF0aEV4aXN0cyhyZWxhdGl2ZVRvRHN0LCAoZXJyLCBleGlzdHMpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICBpZiAoZXhpc3RzKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgdG9Dd2Q6IHJlbGF0aXZlVG9Ec3QsXG4gICAgICAgICAgdG9Ec3Q6IHNyY3BhdGhcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmcy5sc3RhdChzcmNwYXRoLCAoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBlcnIubWVzc2FnZS5yZXBsYWNlKCdsc3RhdCcsICdlbnN1cmVTeW1saW5rJylcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgICB0b0N3ZDogc3JjcGF0aCxcbiAgICAgICAgICAgIHRvRHN0OiBwYXRoLnJlbGF0aXZlKGRzdGRpciwgc3JjcGF0aClcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gc3ltbGlua1BhdGhzU3luYyAoc3JjcGF0aCwgZHN0cGF0aCkge1xuICBsZXQgZXhpc3RzXG4gIGlmIChwYXRoLmlzQWJzb2x1dGUoc3JjcGF0aCkpIHtcbiAgICBleGlzdHMgPSBmcy5leGlzdHNTeW5jKHNyY3BhdGgpXG4gICAgaWYgKCFleGlzdHMpIHRocm93IG5ldyBFcnJvcignYWJzb2x1dGUgc3JjcGF0aCBkb2VzIG5vdCBleGlzdCcpXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvQ3dkOiBzcmNwYXRoLFxuICAgICAgdG9Ec3Q6IHNyY3BhdGhcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZHN0ZGlyID0gcGF0aC5kaXJuYW1lKGRzdHBhdGgpXG4gICAgY29uc3QgcmVsYXRpdmVUb0RzdCA9IHBhdGguam9pbihkc3RkaXIsIHNyY3BhdGgpXG4gICAgZXhpc3RzID0gZnMuZXhpc3RzU3luYyhyZWxhdGl2ZVRvRHN0KVxuICAgIGlmIChleGlzdHMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvQ3dkOiByZWxhdGl2ZVRvRHN0LFxuICAgICAgICB0b0RzdDogc3JjcGF0aFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdHMgPSBmcy5leGlzdHNTeW5jKHNyY3BhdGgpXG4gICAgICBpZiAoIWV4aXN0cykgdGhyb3cgbmV3IEVycm9yKCdyZWxhdGl2ZSBzcmNwYXRoIGRvZXMgbm90IGV4aXN0JylcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvQ3dkOiBzcmNwYXRoLFxuICAgICAgICB0b0RzdDogcGF0aC5yZWxhdGl2ZShkc3RkaXIsIHNyY3BhdGgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzeW1saW5rUGF0aHMsXG4gIHN5bWxpbmtQYXRoc1N5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcblxuZnVuY3Rpb24gc3ltbGlua1R5cGUgKHNyY3BhdGgsIHR5cGUsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSA/IHR5cGUgOiBjYWxsYmFja1xuICB0eXBlID0gKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSA/IGZhbHNlIDogdHlwZVxuICBpZiAodHlwZSkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHR5cGUpXG4gIGZzLmxzdGF0KHNyY3BhdGgsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKG51bGwsICdmaWxlJylcbiAgICB0eXBlID0gKHN0YXRzICYmIHN0YXRzLmlzRGlyZWN0b3J5KCkpID8gJ2RpcicgOiAnZmlsZSdcbiAgICBjYWxsYmFjayhudWxsLCB0eXBlKVxuICB9KVxufVxuXG5mdW5jdGlvbiBzeW1saW5rVHlwZVN5bmMgKHNyY3BhdGgsIHR5cGUpIHtcbiAgbGV0IHN0YXRzXG5cbiAgaWYgKHR5cGUpIHJldHVybiB0eXBlXG4gIHRyeSB7XG4gICAgc3RhdHMgPSBmcy5sc3RhdFN5bmMoc3JjcGF0aClcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICdmaWxlJ1xuICB9XG4gIHJldHVybiAoc3RhdHMgJiYgc3RhdHMuaXNEaXJlY3RvcnkoKSkgPyAnZGlyJyA6ICdmaWxlJ1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3ltbGlua1R5cGUsXG4gIHN5bWxpbmtUeXBlU3luY1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vZnMnKVxuY29uc3QgX21rZGlycyA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5jb25zdCBta2RpcnMgPSBfbWtkaXJzLm1rZGlyc1xuY29uc3QgbWtkaXJzU3luYyA9IF9ta2RpcnMubWtkaXJzU3luY1xuXG5jb25zdCBfc3ltbGlua1BhdGhzID0gcmVxdWlyZSgnLi9zeW1saW5rLXBhdGhzJylcbmNvbnN0IHN5bWxpbmtQYXRocyA9IF9zeW1saW5rUGF0aHMuc3ltbGlua1BhdGhzXG5jb25zdCBzeW1saW5rUGF0aHNTeW5jID0gX3N5bWxpbmtQYXRocy5zeW1saW5rUGF0aHNTeW5jXG5cbmNvbnN0IF9zeW1saW5rVHlwZSA9IHJlcXVpcmUoJy4vc3ltbGluay10eXBlJylcbmNvbnN0IHN5bWxpbmtUeXBlID0gX3N5bWxpbmtUeXBlLnN5bWxpbmtUeXBlXG5jb25zdCBzeW1saW5rVHlwZVN5bmMgPSBfc3ltbGlua1R5cGUuc3ltbGlua1R5cGVTeW5jXG5cbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpLnBhdGhFeGlzdHNcblxuY29uc3QgeyBhcmVJZGVudGljYWwgfSA9IHJlcXVpcmUoJy4uL3V0aWwvc3RhdCcpXG5cbmZ1bmN0aW9uIGNyZWF0ZVN5bWxpbmsgKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSA/IHR5cGUgOiBjYWxsYmFja1xuICB0eXBlID0gKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSA/IGZhbHNlIDogdHlwZVxuXG4gIGZzLmxzdGF0KGRzdHBhdGgsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgaWYgKCFlcnIgJiYgc3RhdHMuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICBmcy5zdGF0KHNyY3BhdGgpLFxuICAgICAgICBmcy5zdGF0KGRzdHBhdGgpXG4gICAgICBdKS50aGVuKChbc3JjU3RhdCwgZHN0U3RhdF0pID0+IHtcbiAgICAgICAgaWYgKGFyZUlkZW50aWNhbChzcmNTdGF0LCBkc3RTdGF0KSkgcmV0dXJuIGNhbGxiYWNrKG51bGwpXG4gICAgICAgIF9jcmVhdGVTeW1saW5rKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUsIGNhbGxiYWNrKVxuICAgICAgfSlcbiAgICB9IGVsc2UgX2NyZWF0ZVN5bWxpbmsoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSwgY2FsbGJhY2spXG4gIH0pXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTeW1saW5rIChzcmNwYXRoLCBkc3RwYXRoLCB0eXBlLCBjYWxsYmFjaykge1xuICBzeW1saW5rUGF0aHMoc3JjcGF0aCwgZHN0cGF0aCwgKGVyciwgcmVsYXRpdmUpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIHNyY3BhdGggPSByZWxhdGl2ZS50b0RzdFxuICAgIHN5bWxpbmtUeXBlKHJlbGF0aXZlLnRvQ3dkLCB0eXBlLCAoZXJyLCB0eXBlKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGRzdHBhdGgpXG4gICAgICBwYXRoRXhpc3RzKGRpciwgKGVyciwgZGlyRXhpc3RzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIGlmIChkaXJFeGlzdHMpIHJldHVybiBmcy5zeW1saW5rKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUsIGNhbGxiYWNrKVxuICAgICAgICBta2RpcnMoZGlyLCBlcnIgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgZnMuc3ltbGluayhzcmNwYXRoLCBkc3RwYXRoLCB0eXBlLCBjYWxsYmFjaylcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3ltbGlua1N5bmMgKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUpIHtcbiAgbGV0IHN0YXRzXG4gIHRyeSB7XG4gICAgc3RhdHMgPSBmcy5sc3RhdFN5bmMoZHN0cGF0aClcbiAgfSBjYXRjaCB7fVxuICBpZiAoc3RhdHMgJiYgc3RhdHMuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgIGNvbnN0IHNyY1N0YXQgPSBmcy5zdGF0U3luYyhzcmNwYXRoKVxuICAgIGNvbnN0IGRzdFN0YXQgPSBmcy5zdGF0U3luYyhkc3RwYXRoKVxuICAgIGlmIChhcmVJZGVudGljYWwoc3JjU3RhdCwgZHN0U3RhdCkpIHJldHVyblxuICB9XG5cbiAgY29uc3QgcmVsYXRpdmUgPSBzeW1saW5rUGF0aHNTeW5jKHNyY3BhdGgsIGRzdHBhdGgpXG4gIHNyY3BhdGggPSByZWxhdGl2ZS50b0RzdFxuICB0eXBlID0gc3ltbGlua1R5cGVTeW5jKHJlbGF0aXZlLnRvQ3dkLCB0eXBlKVxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgY29uc3QgZXhpc3RzID0gZnMuZXhpc3RzU3luYyhkaXIpXG4gIGlmIChleGlzdHMpIHJldHVybiBmcy5zeW1saW5rU3luYyhzcmNwYXRoLCBkc3RwYXRoLCB0eXBlKVxuICBta2RpcnNTeW5jKGRpcilcbiAgcmV0dXJuIGZzLnN5bWxpbmtTeW5jKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVTeW1saW5rOiB1KGNyZWF0ZVN5bWxpbmspLFxuICBjcmVhdGVTeW1saW5rU3luY1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZpbGUgPSByZXF1aXJlKCcuL2ZpbGUnKVxuY29uc3QgbGluayA9IHJlcXVpcmUoJy4vbGluaycpXG5jb25zdCBzeW1saW5rID0gcmVxdWlyZSgnLi9zeW1saW5rJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGZpbGVcbiAgY3JlYXRlRmlsZTogZmlsZS5jcmVhdGVGaWxlLFxuICBjcmVhdGVGaWxlU3luYzogZmlsZS5jcmVhdGVGaWxlU3luYyxcbiAgZW5zdXJlRmlsZTogZmlsZS5jcmVhdGVGaWxlLFxuICBlbnN1cmVGaWxlU3luYzogZmlsZS5jcmVhdGVGaWxlU3luYyxcbiAgLy8gbGlua1xuICBjcmVhdGVMaW5rOiBsaW5rLmNyZWF0ZUxpbmssXG4gIGNyZWF0ZUxpbmtTeW5jOiBsaW5rLmNyZWF0ZUxpbmtTeW5jLFxuICBlbnN1cmVMaW5rOiBsaW5rLmNyZWF0ZUxpbmssXG4gIGVuc3VyZUxpbmtTeW5jOiBsaW5rLmNyZWF0ZUxpbmtTeW5jLFxuICAvLyBzeW1saW5rXG4gIGNyZWF0ZVN5bWxpbms6IHN5bWxpbmsuY3JlYXRlU3ltbGluayxcbiAgY3JlYXRlU3ltbGlua1N5bmM6IHN5bWxpbmsuY3JlYXRlU3ltbGlua1N5bmMsXG4gIGVuc3VyZVN5bWxpbms6IHN5bWxpbmsuY3JlYXRlU3ltbGluayxcbiAgZW5zdXJlU3ltbGlua1N5bmM6IHN5bWxpbmsuY3JlYXRlU3ltbGlua1N5bmNcbn1cbiIsImZ1bmN0aW9uIHN0cmluZ2lmeSAob2JqLCB7IEVPTCA9ICdcXG4nLCBmaW5hbEVPTCA9IHRydWUsIHJlcGxhY2VyID0gbnVsbCwgc3BhY2VzIH0gPSB7fSkge1xuICBjb25zdCBFT0YgPSBmaW5hbEVPTCA/IEVPTCA6ICcnXG4gIGNvbnN0IHN0ciA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlcylcblxuICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcbi9nLCBFT0wpICsgRU9GXG59XG5cbmZ1bmN0aW9uIHN0cmlwQm9tIChjb250ZW50KSB7XG4gIC8vIHdlIGRvIHRoaXMgYmVjYXVzZSBKU09OLnBhcnNlIHdvdWxkIGNvbnZlcnQgaXQgdG8gYSB1dGY4IHN0cmluZyBpZiBlbmNvZGluZyB3YXNuJ3Qgc3BlY2lmaWVkXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY29udGVudCkpIGNvbnRlbnQgPSBjb250ZW50LnRvU3RyaW5nKCd1dGY4JylcbiAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZSgvXlxcdUZFRkYvLCAnJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IHN0cmluZ2lmeSwgc3RyaXBCb20gfVxuIiwibGV0IF9mc1xudHJ5IHtcbiAgX2ZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxufSBjYXRjaCAoXykge1xuICBfZnMgPSByZXF1aXJlKCdmcycpXG59XG5jb25zdCB1bml2ZXJzYWxpZnkgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKVxuY29uc3QgeyBzdHJpbmdpZnksIHN0cmlwQm9tIH0gPSByZXF1aXJlKCcuL3V0aWxzJylcblxuYXN5bmMgZnVuY3Rpb24gX3JlYWRGaWxlIChmaWxlLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7IGVuY29kaW5nOiBvcHRpb25zIH1cbiAgfVxuXG4gIGNvbnN0IGZzID0gb3B0aW9ucy5mcyB8fCBfZnNcblxuICBjb25zdCBzaG91bGRUaHJvdyA9ICd0aHJvd3MnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRocm93cyA6IHRydWVcblxuICBsZXQgZGF0YSA9IGF3YWl0IHVuaXZlcnNhbGlmeS5mcm9tQ2FsbGJhY2soZnMucmVhZEZpbGUpKGZpbGUsIG9wdGlvbnMpXG5cbiAgZGF0YSA9IHN0cmlwQm9tKGRhdGEpXG5cbiAgbGV0IG9ialxuICB0cnkge1xuICAgIG9iaiA9IEpTT04ucGFyc2UoZGF0YSwgb3B0aW9ucyA/IG9wdGlvbnMucmV2aXZlciA6IG51bGwpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgZXJyLm1lc3NhZ2UgPSBgJHtmaWxlfTogJHtlcnIubWVzc2FnZX1gXG4gICAgICB0aHJvdyBlcnJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqXG59XG5cbmNvbnN0IHJlYWRGaWxlID0gdW5pdmVyc2FsaWZ5LmZyb21Qcm9taXNlKF9yZWFkRmlsZSlcblxuZnVuY3Rpb24gcmVhZEZpbGVTeW5jIChmaWxlLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7IGVuY29kaW5nOiBvcHRpb25zIH1cbiAgfVxuXG4gIGNvbnN0IGZzID0gb3B0aW9ucy5mcyB8fCBfZnNcblxuICBjb25zdCBzaG91bGRUaHJvdyA9ICd0aHJvd3MnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRocm93cyA6IHRydWVcblxuICB0cnkge1xuICAgIGxldCBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGZpbGUsIG9wdGlvbnMpXG4gICAgY29udGVudCA9IHN0cmlwQm9tKGNvbnRlbnQpXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoY29udGVudCwgb3B0aW9ucy5yZXZpdmVyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoc2hvdWxkVGhyb3cpIHtcbiAgICAgIGVyci5tZXNzYWdlID0gYCR7ZmlsZX06ICR7ZXJyLm1lc3NhZ2V9YFxuICAgICAgdGhyb3cgZXJyXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIF93cml0ZUZpbGUgKGZpbGUsIG9iaiwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGZzID0gb3B0aW9ucy5mcyB8fCBfZnNcblxuICBjb25zdCBzdHIgPSBzdHJpbmdpZnkob2JqLCBvcHRpb25zKVxuXG4gIGF3YWl0IHVuaXZlcnNhbGlmeS5mcm9tQ2FsbGJhY2soZnMud3JpdGVGaWxlKShmaWxlLCBzdHIsIG9wdGlvbnMpXG59XG5cbmNvbnN0IHdyaXRlRmlsZSA9IHVuaXZlcnNhbGlmeS5mcm9tUHJvbWlzZShfd3JpdGVGaWxlKVxuXG5mdW5jdGlvbiB3cml0ZUZpbGVTeW5jIChmaWxlLCBvYmosIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBmcyA9IG9wdGlvbnMuZnMgfHwgX2ZzXG5cbiAgY29uc3Qgc3RyID0gc3RyaW5naWZ5KG9iaiwgb3B0aW9ucylcbiAgLy8gbm90IHN1cmUgaWYgZnMud3JpdGVGaWxlU3luYyByZXR1cm5zIGFueXRoaW5nLCBidXQganVzdCBpbiBjYXNlXG4gIHJldHVybiBmcy53cml0ZUZpbGVTeW5jKGZpbGUsIHN0ciwgb3B0aW9ucylcbn1cblxuY29uc3QganNvbmZpbGUgPSB7XG4gIHJlYWRGaWxlLFxuICByZWFkRmlsZVN5bmMsXG4gIHdyaXRlRmlsZSxcbiAgd3JpdGVGaWxlU3luY1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGpzb25maWxlXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QganNvbkZpbGUgPSByZXF1aXJlKCdqc29uZmlsZScpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBqc29uZmlsZSBleHBvcnRzXG4gIHJlYWRKc29uOiBqc29uRmlsZS5yZWFkRmlsZSxcbiAgcmVhZEpzb25TeW5jOiBqc29uRmlsZS5yZWFkRmlsZVN5bmMsXG4gIHdyaXRlSnNvbjoganNvbkZpbGUud3JpdGVGaWxlLFxuICB3cml0ZUpzb25TeW5jOiBqc29uRmlsZS53cml0ZUZpbGVTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBta2RpciA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKS5wYXRoRXhpc3RzXG5cbmZ1bmN0aW9uIG91dHB1dEZpbGUgKGZpbGUsIGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZmlsZSlcbiAgcGF0aEV4aXN0cyhkaXIsIChlcnIsIGl0RG9lcykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgaWYgKGl0RG9lcykgcmV0dXJuIGZzLndyaXRlRmlsZShmaWxlLCBkYXRhLCBlbmNvZGluZywgY2FsbGJhY2spXG5cbiAgICBta2Rpci5ta2RpcnMoZGlyLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcblxuICAgICAgZnMud3JpdGVGaWxlKGZpbGUsIGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaylcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBvdXRwdXRGaWxlU3luYyAoZmlsZSwgLi4uYXJncykge1xuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZmlsZSlcbiAgaWYgKGZzLmV4aXN0c1N5bmMoZGlyKSkge1xuICAgIHJldHVybiBmcy53cml0ZUZpbGVTeW5jKGZpbGUsIC4uLmFyZ3MpXG4gIH1cbiAgbWtkaXIubWtkaXJzU3luYyhkaXIpXG4gIGZzLndyaXRlRmlsZVN5bmMoZmlsZSwgLi4uYXJncylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG91dHB1dEZpbGU6IHUob3V0cHV0RmlsZSksXG4gIG91dHB1dEZpbGVTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBzdHJpbmdpZnkgfSA9IHJlcXVpcmUoJ2pzb25maWxlL3V0aWxzJylcbmNvbnN0IHsgb3V0cHV0RmlsZSB9ID0gcmVxdWlyZSgnLi4vb3V0cHV0JylcblxuYXN5bmMgZnVuY3Rpb24gb3V0cHV0SnNvbiAoZmlsZSwgZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHN0ciA9IHN0cmluZ2lmeShkYXRhLCBvcHRpb25zKVxuXG4gIGF3YWl0IG91dHB1dEZpbGUoZmlsZSwgc3RyLCBvcHRpb25zKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG91dHB1dEpzb25cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHN0cmluZ2lmeSB9ID0gcmVxdWlyZSgnanNvbmZpbGUvdXRpbHMnKVxuY29uc3QgeyBvdXRwdXRGaWxlU3luYyB9ID0gcmVxdWlyZSgnLi4vb3V0cHV0JylcblxuZnVuY3Rpb24gb3V0cHV0SnNvblN5bmMgKGZpbGUsIGRhdGEsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc3RyID0gc3RyaW5naWZ5KGRhdGEsIG9wdGlvbnMpXG5cbiAgb3V0cHV0RmlsZVN5bmMoZmlsZSwgc3RyLCBvcHRpb25zKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG91dHB1dEpzb25TeW5jXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21Qcm9taXNlXG5jb25zdCBqc29uRmlsZSA9IHJlcXVpcmUoJy4vanNvbmZpbGUnKVxuXG5qc29uRmlsZS5vdXRwdXRKc29uID0gdShyZXF1aXJlKCcuL291dHB1dC1qc29uJykpXG5qc29uRmlsZS5vdXRwdXRKc29uU3luYyA9IHJlcXVpcmUoJy4vb3V0cHV0LWpzb24tc3luYycpXG4vLyBhbGlhc2VzXG5qc29uRmlsZS5vdXRwdXRKU09OID0ganNvbkZpbGUub3V0cHV0SnNvblxuanNvbkZpbGUub3V0cHV0SlNPTlN5bmMgPSBqc29uRmlsZS5vdXRwdXRKc29uU3luY1xuanNvbkZpbGUud3JpdGVKU09OID0ganNvbkZpbGUud3JpdGVKc29uXG5qc29uRmlsZS53cml0ZUpTT05TeW5jID0ganNvbkZpbGUud3JpdGVKc29uU3luY1xuanNvbkZpbGUucmVhZEpTT04gPSBqc29uRmlsZS5yZWFkSnNvblxuanNvbkZpbGUucmVhZEpTT05TeW5jID0ganNvbkZpbGUucmVhZEpzb25TeW5jXG5cbm1vZHVsZS5leHBvcnRzID0ganNvbkZpbGVcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGNvcHlTeW5jID0gcmVxdWlyZSgnLi4vY29weS1zeW5jJykuY29weVN5bmNcbmNvbnN0IHJlbW92ZVN5bmMgPSByZXF1aXJlKCcuLi9yZW1vdmUnKS5yZW1vdmVTeW5jXG5jb25zdCBta2RpcnBTeW5jID0gcmVxdWlyZSgnLi4vbWtkaXJzJykubWtkaXJwU3luY1xuY29uc3Qgc3RhdCA9IHJlcXVpcmUoJy4uL3V0aWwvc3RhdCcpXG5cbmZ1bmN0aW9uIG1vdmVTeW5jIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge31cbiAgY29uc3Qgb3ZlcndyaXRlID0gb3B0cy5vdmVyd3JpdGUgfHwgb3B0cy5jbG9iYmVyIHx8IGZhbHNlXG5cbiAgY29uc3QgeyBzcmNTdGF0LCBpc0NoYW5naW5nQ2FzZSA9IGZhbHNlIH0gPSBzdGF0LmNoZWNrUGF0aHNTeW5jKHNyYywgZGVzdCwgJ21vdmUnLCBvcHRzKVxuICBzdGF0LmNoZWNrUGFyZW50UGF0aHNTeW5jKHNyYywgc3JjU3RhdCwgZGVzdCwgJ21vdmUnKVxuICBpZiAoIWlzUGFyZW50Um9vdChkZXN0KSkgbWtkaXJwU3luYyhwYXRoLmRpcm5hbWUoZGVzdCkpXG4gIHJldHVybiBkb1JlbmFtZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgaXNDaGFuZ2luZ0Nhc2UpXG59XG5cbmZ1bmN0aW9uIGlzUGFyZW50Um9vdCAoZGVzdCkge1xuICBjb25zdCBwYXJlbnQgPSBwYXRoLmRpcm5hbWUoZGVzdClcbiAgY29uc3QgcGFyc2VkUGF0aCA9IHBhdGgucGFyc2UocGFyZW50KVxuICByZXR1cm4gcGFyc2VkUGF0aC5yb290ID09PSBwYXJlbnRcbn1cblxuZnVuY3Rpb24gZG9SZW5hbWUgKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBpc0NoYW5naW5nQ2FzZSkge1xuICBpZiAoaXNDaGFuZ2luZ0Nhc2UpIHJldHVybiByZW5hbWUoc3JjLCBkZXN0LCBvdmVyd3JpdGUpXG4gIGlmIChvdmVyd3JpdGUpIHtcbiAgICByZW1vdmVTeW5jKGRlc3QpXG4gICAgcmV0dXJuIHJlbmFtZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSlcbiAgfVxuICBpZiAoZnMuZXhpc3RzU3luYyhkZXN0KSkgdGhyb3cgbmV3IEVycm9yKCdkZXN0IGFscmVhZHkgZXhpc3RzLicpXG4gIHJldHVybiByZW5hbWUoc3JjLCBkZXN0LCBvdmVyd3JpdGUpXG59XG5cbmZ1bmN0aW9uIHJlbmFtZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUpIHtcbiAgdHJ5IHtcbiAgICBmcy5yZW5hbWVTeW5jKHNyYywgZGVzdClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlICE9PSAnRVhERVYnKSB0aHJvdyBlcnJcbiAgICByZXR1cm4gbW92ZUFjcm9zc0RldmljZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBtb3ZlQWNyb3NzRGV2aWNlIChzcmMsIGRlc3QsIG92ZXJ3cml0ZSkge1xuICBjb25zdCBvcHRzID0ge1xuICAgIG92ZXJ3cml0ZSxcbiAgICBlcnJvck9uRXhpc3Q6IHRydWVcbiAgfVxuICBjb3B5U3luYyhzcmMsIGRlc3QsIG9wdHMpXG4gIHJldHVybiByZW1vdmVTeW5jKHNyYylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtb3ZlU3luY1xuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtb3ZlU3luYzogcmVxdWlyZSgnLi9tb3ZlLXN5bmMnKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgY29weSA9IHJlcXVpcmUoJy4uL2NvcHknKS5jb3B5XG5jb25zdCByZW1vdmUgPSByZXF1aXJlKCcuLi9yZW1vdmUnKS5yZW1vdmVcbmNvbnN0IG1rZGlycCA9IHJlcXVpcmUoJy4uL21rZGlycycpLm1rZGlycFxuY29uc3QgcGF0aEV4aXN0cyA9IHJlcXVpcmUoJy4uL3BhdGgtZXhpc3RzJykucGF0aEV4aXN0c1xuY29uc3Qgc3RhdCA9IHJlcXVpcmUoJy4uL3V0aWwvc3RhdCcpXG5cbmZ1bmN0aW9uIG1vdmUgKHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBvcHRzXG4gICAgb3B0cyA9IHt9XG4gIH1cblxuICBjb25zdCBvdmVyd3JpdGUgPSBvcHRzLm92ZXJ3cml0ZSB8fCBvcHRzLmNsb2JiZXIgfHwgZmFsc2VcblxuICBzdGF0LmNoZWNrUGF0aHMoc3JjLCBkZXN0LCAnbW92ZScsIG9wdHMsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBjb25zdCB7IHNyY1N0YXQsIGlzQ2hhbmdpbmdDYXNlID0gZmFsc2UgfSA9IHN0YXRzXG4gICAgc3RhdC5jaGVja1BhcmVudFBhdGhzKHNyYywgc3JjU3RhdCwgZGVzdCwgJ21vdmUnLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIGlmIChpc1BhcmVudFJvb3QoZGVzdCkpIHJldHVybiBkb1JlbmFtZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgaXNDaGFuZ2luZ0Nhc2UsIGNiKVxuICAgICAgbWtkaXJwKHBhdGguZGlybmFtZShkZXN0KSwgZXJyID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgICAgcmV0dXJuIGRvUmVuYW1lKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBpc0NoYW5naW5nQ2FzZSwgY2IpXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGlzUGFyZW50Um9vdCAoZGVzdCkge1xuICBjb25zdCBwYXJlbnQgPSBwYXRoLmRpcm5hbWUoZGVzdClcbiAgY29uc3QgcGFyc2VkUGF0aCA9IHBhdGgucGFyc2UocGFyZW50KVxuICByZXR1cm4gcGFyc2VkUGF0aC5yb290ID09PSBwYXJlbnRcbn1cblxuZnVuY3Rpb24gZG9SZW5hbWUgKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBpc0NoYW5naW5nQ2FzZSwgY2IpIHtcbiAgaWYgKGlzQ2hhbmdpbmdDYXNlKSByZXR1cm4gcmVuYW1lKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBjYilcbiAgaWYgKG92ZXJ3cml0ZSkge1xuICAgIHJldHVybiByZW1vdmUoZGVzdCwgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICByZXR1cm4gcmVuYW1lKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBjYilcbiAgICB9KVxuICB9XG4gIHBhdGhFeGlzdHMoZGVzdCwgKGVyciwgZGVzdEV4aXN0cykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgaWYgKGRlc3RFeGlzdHMpIHJldHVybiBjYihuZXcgRXJyb3IoJ2Rlc3QgYWxyZWFkeSBleGlzdHMuJykpXG4gICAgcmV0dXJuIHJlbmFtZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgY2IpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJlbmFtZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGNiKSB7XG4gIGZzLnJlbmFtZShzcmMsIGRlc3QsIGVyciA9PiB7XG4gICAgaWYgKCFlcnIpIHJldHVybiBjYigpXG4gICAgaWYgKGVyci5jb2RlICE9PSAnRVhERVYnKSByZXR1cm4gY2IoZXJyKVxuICAgIHJldHVybiBtb3ZlQWNyb3NzRGV2aWNlKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBjYilcbiAgfSlcbn1cblxuZnVuY3Rpb24gbW92ZUFjcm9zc0RldmljZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGNiKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgb3ZlcndyaXRlLFxuICAgIGVycm9yT25FeGlzdDogdHJ1ZVxuICB9XG4gIGNvcHkoc3JjLCBkZXN0LCBvcHRzLCBlcnIgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgcmV0dXJuIHJlbW92ZShzcmMsIGNiKVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1vdmVcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbW92ZTogdShyZXF1aXJlKCcuL21vdmUnKSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gRXhwb3J0IHByb21pc2VpZmllZCBncmFjZWZ1bC1mczpcbiAgLi4ucmVxdWlyZSgnLi9mcycpLFxuICAvLyBFeHBvcnQgZXh0cmEgbWV0aG9kczpcbiAgLi4ucmVxdWlyZSgnLi9jb3B5LXN5bmMnKSxcbiAgLi4ucmVxdWlyZSgnLi9jb3B5JyksXG4gIC4uLnJlcXVpcmUoJy4vZW1wdHknKSxcbiAgLi4ucmVxdWlyZSgnLi9lbnN1cmUnKSxcbiAgLi4ucmVxdWlyZSgnLi9qc29uJyksXG4gIC4uLnJlcXVpcmUoJy4vbWtkaXJzJyksXG4gIC4uLnJlcXVpcmUoJy4vbW92ZS1zeW5jJyksXG4gIC4uLnJlcXVpcmUoJy4vbW92ZScpLFxuICAuLi5yZXF1aXJlKCcuL291dHB1dCcpLFxuICAuLi5yZXF1aXJlKCcuL3BhdGgtZXhpc3RzJyksXG4gIC4uLnJlcXVpcmUoJy4vcmVtb3ZlJylcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB2YWx1ZSA9PiB7XG5cdGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cdHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgaXNPYmogPSByZXF1aXJlKCdpcy1vYmonKTtcblxuY29uc3QgZGlzYWxsb3dlZEtleXMgPSBuZXcgU2V0KFtcblx0J19fcHJvdG9fXycsXG5cdCdwcm90b3R5cGUnLFxuXHQnY29uc3RydWN0b3InXG5dKTtcblxuY29uc3QgaXNWYWxpZFBhdGggPSBwYXRoU2VnbWVudHMgPT4gIXBhdGhTZWdtZW50cy5zb21lKHNlZ21lbnQgPT4gZGlzYWxsb3dlZEtleXMuaGFzKHNlZ21lbnQpKTtcblxuZnVuY3Rpb24gZ2V0UGF0aFNlZ21lbnRzKHBhdGgpIHtcblx0Y29uc3QgcGF0aEFycmF5ID0gcGF0aC5zcGxpdCgnLicpO1xuXHRjb25zdCBwYXJ0cyA9IFtdO1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aEFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0bGV0IHAgPSBwYXRoQXJyYXlbaV07XG5cblx0XHR3aGlsZSAocFtwLmxlbmd0aCAtIDFdID09PSAnXFxcXCcgJiYgcGF0aEFycmF5W2kgKyAxXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRwID0gcC5zbGljZSgwLCAtMSkgKyAnLic7XG5cdFx0XHRwICs9IHBhdGhBcnJheVsrK2ldO1xuXHRcdH1cblxuXHRcdHBhcnRzLnB1c2gocCk7XG5cdH1cblxuXHRpZiAoIWlzVmFsaWRQYXRoKHBhcnRzKSkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXG5cdHJldHVybiBwYXJ0cztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGdldChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG5cdFx0aWYgKCFpc09iaihvYmplY3QpIHx8IHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyBvYmplY3QgOiB2YWx1ZTtcblx0XHR9XG5cblx0XHRjb25zdCBwYXRoQXJyYXkgPSBnZXRQYXRoU2VnbWVudHMocGF0aCk7XG5cdFx0aWYgKHBhdGhBcnJheS5sZW5ndGggPT09IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhBcnJheS5sZW5ndGg7IGkrKykge1xuXHRcdFx0b2JqZWN0ID0gb2JqZWN0W3BhdGhBcnJheVtpXV07XG5cblx0XHRcdGlmIChvYmplY3QgPT09IHVuZGVmaW5lZCB8fCBvYmplY3QgPT09IG51bGwpIHtcblx0XHRcdFx0Ly8gYG9iamVjdGAgaXMgZWl0aGVyIGB1bmRlZmluZWRgIG9yIGBudWxsYCBzbyB3ZSB3YW50IHRvIHN0b3AgdGhlIGxvb3AsIGFuZFxuXHRcdFx0XHQvLyBpZiB0aGlzIGlzIG5vdCB0aGUgbGFzdCBiaXQgb2YgdGhlIHBhdGgsIGFuZFxuXHRcdFx0XHQvLyBpZiBpdCBkaWQndCByZXR1cm4gYHVuZGVmaW5lZGBcblx0XHRcdFx0Ly8gaXQgd291bGQgcmV0dXJuIGBudWxsYCBpZiBgb2JqZWN0YCBpcyBgbnVsbGBcblx0XHRcdFx0Ly8gYnV0IHdlIHdhbnQgYGdldCh7Zm9vOiBudWxsfSwgJ2Zvby5iYXInKWAgdG8gZXF1YWwgYHVuZGVmaW5lZGAsIG9yIHRoZSBzdXBwbGllZCB2YWx1ZSwgbm90IGBudWxsYFxuXHRcdFx0XHRpZiAoaSAhPT0gcGF0aEFycmF5Lmxlbmd0aCAtIDEpIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqZWN0ID09PSB1bmRlZmluZWQgPyB2YWx1ZSA6IG9iamVjdDtcblx0fSxcblxuXHRzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuXHRcdGlmICghaXNPYmoob2JqZWN0KSB8fCB0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBvYmplY3Q7XG5cdFx0fVxuXG5cdFx0Y29uc3Qgcm9vdCA9IG9iamVjdDtcblx0XHRjb25zdCBwYXRoQXJyYXkgPSBnZXRQYXRoU2VnbWVudHMocGF0aCk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhBcnJheS5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgcCA9IHBhdGhBcnJheVtpXTtcblxuXHRcdFx0aWYgKCFpc09iaihvYmplY3RbcF0pKSB7XG5cdFx0XHRcdG9iamVjdFtwXSA9IHt9O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaSA9PT0gcGF0aEFycmF5Lmxlbmd0aCAtIDEpIHtcblx0XHRcdFx0b2JqZWN0W3BdID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdG9iamVjdCA9IG9iamVjdFtwXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcm9vdDtcblx0fSxcblxuXHRkZWxldGUob2JqZWN0LCBwYXRoKSB7XG5cdFx0aWYgKCFpc09iaihvYmplY3QpIHx8IHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGNvbnN0IHBhdGhBcnJheSA9IGdldFBhdGhTZWdtZW50cyhwYXRoKTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aEFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBwID0gcGF0aEFycmF5W2ldO1xuXG5cdFx0XHRpZiAoaSA9PT0gcGF0aEFycmF5Lmxlbmd0aCAtIDEpIHtcblx0XHRcdFx0ZGVsZXRlIG9iamVjdFtwXTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdG9iamVjdCA9IG9iamVjdFtwXTtcblxuXHRcdFx0aWYgKCFpc09iaihvYmplY3QpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0aGFzKG9iamVjdCwgcGF0aCkge1xuXHRcdGlmICghaXNPYmoob2JqZWN0KSB8fCB0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRjb25zdCBwYXRoQXJyYXkgPSBnZXRQYXRoU2VnbWVudHMocGF0aCk7XG5cdFx0aWYgKHBhdGhBcnJheS5sZW5ndGggPT09IDApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby1mb3ItbG9vcFxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aEFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoaXNPYmoob2JqZWN0KSkge1xuXHRcdFx0XHRpZiAoIShwYXRoQXJyYXlbaV0gaW4gb2JqZWN0KSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9iamVjdCA9IG9iamVjdFtwYXRoQXJyYXlbaV1dO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZwID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuXHRmcy5hY2Nlc3MoZnAsIGVyciA9PiB7XG5cdFx0cmVzb2x2ZSghZXJyKTtcblx0fSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMuc3luYyA9IGZwID0+IHtcblx0dHJ5IHtcblx0XHRmcy5hY2Nlc3NTeW5jKGZwKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBwVHJ5ID0gKGZuLCAuLi5hcmd1bWVudHNfKSA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcblx0cmVzb2x2ZShmbiguLi5hcmd1bWVudHNfKSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwVHJ5O1xuLy8gVE9ETzogcmVtb3ZlIHRoaXMgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvblxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IHBUcnk7XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBwVHJ5ID0gcmVxdWlyZSgncC10cnknKTtcblxuY29uc3QgcExpbWl0ID0gY29uY3VycmVuY3kgPT4ge1xuXHRpZiAoISgoTnVtYmVyLmlzSW50ZWdlcihjb25jdXJyZW5jeSkgfHwgY29uY3VycmVuY3kgPT09IEluZmluaXR5KSAmJiBjb25jdXJyZW5jeSA+IDApKSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBjb25jdXJyZW5jeWAgdG8gYmUgYSBudW1iZXIgZnJvbSAxIGFuZCB1cCcpKTtcblx0fVxuXG5cdGNvbnN0IHF1ZXVlID0gW107XG5cdGxldCBhY3RpdmVDb3VudCA9IDA7XG5cblx0Y29uc3QgbmV4dCA9ICgpID0+IHtcblx0XHRhY3RpdmVDb3VudC0tO1xuXG5cdFx0aWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcblx0XHRcdHF1ZXVlLnNoaWZ0KCkoKTtcblx0XHR9XG5cdH07XG5cblx0Y29uc3QgcnVuID0gKGZuLCByZXNvbHZlLCAuLi5hcmdzKSA9PiB7XG5cdFx0YWN0aXZlQ291bnQrKztcblxuXHRcdGNvbnN0IHJlc3VsdCA9IHBUcnkoZm4sIC4uLmFyZ3MpO1xuXG5cdFx0cmVzb2x2ZShyZXN1bHQpO1xuXG5cdFx0cmVzdWx0LnRoZW4obmV4dCwgbmV4dCk7XG5cdH07XG5cblx0Y29uc3QgZW5xdWV1ZSA9IChmbiwgcmVzb2x2ZSwgLi4uYXJncykgPT4ge1xuXHRcdGlmIChhY3RpdmVDb3VudCA8IGNvbmN1cnJlbmN5KSB7XG5cdFx0XHRydW4oZm4sIHJlc29sdmUsIC4uLmFyZ3MpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRxdWV1ZS5wdXNoKHJ1bi5iaW5kKG51bGwsIGZuLCByZXNvbHZlLCAuLi5hcmdzKSk7XG5cdFx0fVxuXHR9O1xuXG5cdGNvbnN0IGdlbmVyYXRvciA9IChmbiwgLi4uYXJncykgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBlbnF1ZXVlKGZuLCByZXNvbHZlLCAuLi5hcmdzKSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGdlbmVyYXRvciwge1xuXHRcdGFjdGl2ZUNvdW50OiB7XG5cdFx0XHRnZXQ6ICgpID0+IGFjdGl2ZUNvdW50XG5cdFx0fSxcblx0XHRwZW5kaW5nQ291bnQ6IHtcblx0XHRcdGdldDogKCkgPT4gcXVldWUubGVuZ3RoXG5cdFx0fSxcblx0XHRjbGVhclF1ZXVlOiB7XG5cdFx0XHR2YWx1ZTogKCkgPT4ge1xuXHRcdFx0XHRxdWV1ZS5sZW5ndGggPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIGdlbmVyYXRvcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcExpbWl0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IHBMaW1pdDtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHBMaW1pdCA9IHJlcXVpcmUoJ3AtbGltaXQnKTtcblxuY2xhc3MgRW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKHZhbHVlKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdH1cbn1cblxuLy8gVGhlIGlucHV0IGNhbiBhbHNvIGJlIGEgcHJvbWlzZSwgc28gd2UgYFByb21pc2UucmVzb2x2ZSgpYCBpdFxuY29uc3QgdGVzdEVsZW1lbnQgPSAoZWwsIHRlc3RlcikgPT4gUHJvbWlzZS5yZXNvbHZlKGVsKS50aGVuKHRlc3Rlcik7XG5cbi8vIFRoZSBpbnB1dCBjYW4gYWxzbyBiZSBhIHByb21pc2UsIHNvIHdlIGBQcm9taXNlLmFsbCgpYCB0aGVtIGJvdGhcbmNvbnN0IGZpbmRlciA9IGVsID0+IFByb21pc2UuYWxsKGVsKS50aGVuKHZhbCA9PiB2YWxbMV0gPT09IHRydWUgJiYgUHJvbWlzZS5yZWplY3QobmV3IEVuZEVycm9yKHZhbFswXSkpKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoaXRlcmFibGUsIHRlc3Rlciwgb3B0cykgPT4ge1xuXHRvcHRzID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0Y29uY3VycmVuY3k6IEluZmluaXR5LFxuXHRcdHByZXNlcnZlT3JkZXI6IHRydWVcblx0fSwgb3B0cyk7XG5cblx0Y29uc3QgbGltaXQgPSBwTGltaXQob3B0cy5jb25jdXJyZW5jeSk7XG5cblx0Ly8gU3RhcnQgYWxsIHRoZSBwcm9taXNlcyBjb25jdXJyZW50bHkgd2l0aCBvcHRpb25hbCBsaW1pdFxuXHRjb25zdCBpdGVtcyA9IFsuLi5pdGVyYWJsZV0ubWFwKGVsID0+IFtlbCwgbGltaXQodGVzdEVsZW1lbnQsIGVsLCB0ZXN0ZXIpXSk7XG5cblx0Ly8gQ2hlY2sgdGhlIHByb21pc2VzIGVpdGhlciBzZXJpYWxseSBvciBjb25jdXJyZW50bHlcblx0Y29uc3QgY2hlY2tMaW1pdCA9IHBMaW1pdChvcHRzLnByZXNlcnZlT3JkZXIgPyAxIDogSW5maW5pdHkpO1xuXG5cdHJldHVybiBQcm9taXNlLmFsbChpdGVtcy5tYXAoZWwgPT4gY2hlY2tMaW1pdChmaW5kZXIsIGVsKSkpXG5cdFx0LnRoZW4oKCkgPT4ge30pXG5cdFx0LmNhdGNoKGVyciA9PiBlcnIgaW5zdGFuY2VvZiBFbmRFcnJvciA/IGVyci52YWx1ZSA6IFByb21pc2UucmVqZWN0KGVycikpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgncGF0aC1leGlzdHMnKTtcbmNvbnN0IHBMb2NhdGUgPSByZXF1aXJlKCdwLWxvY2F0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChpdGVyYWJsZSwgb3B0aW9ucykgPT4ge1xuXHRvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0Y3dkOiBwcm9jZXNzLmN3ZCgpXG5cdH0sIG9wdGlvbnMpO1xuXG5cdHJldHVybiBwTG9jYXRlKGl0ZXJhYmxlLCBlbCA9PiBwYXRoRXhpc3RzKHBhdGgucmVzb2x2ZShvcHRpb25zLmN3ZCwgZWwpKSwgb3B0aW9ucyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5zeW5jID0gKGl0ZXJhYmxlLCBvcHRpb25zKSA9PiB7XG5cdG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRjd2Q6IHByb2Nlc3MuY3dkKClcblx0fSwgb3B0aW9ucyk7XG5cblx0Zm9yIChjb25zdCBlbCBvZiBpdGVyYWJsZSkge1xuXHRcdGlmIChwYXRoRXhpc3RzLnN5bmMocGF0aC5yZXNvbHZlKG9wdGlvbnMuY3dkLCBlbCkpKSB7XG5cdFx0XHRyZXR1cm4gZWw7XG5cdFx0fVxuXHR9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IGxvY2F0ZVBhdGggPSByZXF1aXJlKCdsb2NhdGUtcGF0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmaWxlbmFtZSwgb3B0cyA9IHt9KSA9PiB7XG5cdGNvbnN0IHN0YXJ0RGlyID0gcGF0aC5yZXNvbHZlKG9wdHMuY3dkIHx8ICcnKTtcblx0Y29uc3Qge3Jvb3R9ID0gcGF0aC5wYXJzZShzdGFydERpcik7XG5cblx0Y29uc3QgZmlsZW5hbWVzID0gW10uY29uY2F0KGZpbGVuYW1lKTtcblxuXHRyZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG5cdFx0KGZ1bmN0aW9uIGZpbmQoZGlyKSB7XG5cdFx0XHRsb2NhdGVQYXRoKGZpbGVuYW1lcywge2N3ZDogZGlyfSkudGhlbihmaWxlID0+IHtcblx0XHRcdFx0aWYgKGZpbGUpIHtcblx0XHRcdFx0XHRyZXNvbHZlKHBhdGguam9pbihkaXIsIGZpbGUpKTtcblx0XHRcdFx0fSBlbHNlIGlmIChkaXIgPT09IHJvb3QpIHtcblx0XHRcdFx0XHRyZXNvbHZlKG51bGwpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZpbmQocGF0aC5kaXJuYW1lKGRpcikpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KShzdGFydERpcik7XG5cdH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMuc3luYyA9IChmaWxlbmFtZSwgb3B0cyA9IHt9KSA9PiB7XG5cdGxldCBkaXIgPSBwYXRoLnJlc29sdmUob3B0cy5jd2QgfHwgJycpO1xuXHRjb25zdCB7cm9vdH0gPSBwYXRoLnBhcnNlKGRpcik7XG5cblx0Y29uc3QgZmlsZW5hbWVzID0gW10uY29uY2F0KGZpbGVuYW1lKTtcblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG5cdHdoaWxlICh0cnVlKSB7XG5cdFx0Y29uc3QgZmlsZSA9IGxvY2F0ZVBhdGguc3luYyhmaWxlbmFtZXMsIHtjd2Q6IGRpcn0pO1xuXG5cdFx0aWYgKGZpbGUpIHtcblx0XHRcdHJldHVybiBwYXRoLmpvaW4oZGlyLCBmaWxlKTtcblx0XHR9XG5cblx0XHRpZiAoZGlyID09PSByb290KSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRkaXIgPSBwYXRoLmRpcm5hbWUoZGlyKTtcblx0fVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IGZpbmRVcCA9IHJlcXVpcmUoJ2ZpbmQtdXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc3luYyAoe2N3ZH0gPSB7fSkgPT4gZmluZFVwKCdwYWNrYWdlLmpzb24nLCB7Y3dkfSk7XG5tb2R1bGUuZXhwb3J0cy5zeW5jID0gKHtjd2R9ID0ge30pID0+IGZpbmRVcC5zeW5jKCdwYWNrYWdlLmpzb24nLCB7Y3dkfSk7XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuXG5jb25zdCBob21lZGlyID0gb3MuaG9tZWRpcigpO1xuY29uc3QgdG1wZGlyID0gb3MudG1wZGlyKCk7XG5jb25zdCB7ZW52fSA9IHByb2Nlc3M7XG5cbmNvbnN0IG1hY29zID0gbmFtZSA9PiB7XG5cdGNvbnN0IGxpYnJhcnkgPSBwYXRoLmpvaW4oaG9tZWRpciwgJ0xpYnJhcnknKTtcblxuXHRyZXR1cm4ge1xuXHRcdGRhdGE6IHBhdGguam9pbihsaWJyYXJ5LCAnQXBwbGljYXRpb24gU3VwcG9ydCcsIG5hbWUpLFxuXHRcdGNvbmZpZzogcGF0aC5qb2luKGxpYnJhcnksICdQcmVmZXJlbmNlcycsIG5hbWUpLFxuXHRcdGNhY2hlOiBwYXRoLmpvaW4obGlicmFyeSwgJ0NhY2hlcycsIG5hbWUpLFxuXHRcdGxvZzogcGF0aC5qb2luKGxpYnJhcnksICdMb2dzJywgbmFtZSksXG5cdFx0dGVtcDogcGF0aC5qb2luKHRtcGRpciwgbmFtZSlcblx0fTtcbn07XG5cbmNvbnN0IHdpbmRvd3MgPSBuYW1lID0+IHtcblx0Y29uc3QgYXBwRGF0YSA9IGVudi5BUFBEQVRBIHx8IHBhdGguam9pbihob21lZGlyLCAnQXBwRGF0YScsICdSb2FtaW5nJyk7XG5cdGNvbnN0IGxvY2FsQXBwRGF0YSA9IGVudi5MT0NBTEFQUERBVEEgfHwgcGF0aC5qb2luKGhvbWVkaXIsICdBcHBEYXRhJywgJ0xvY2FsJyk7XG5cblx0cmV0dXJuIHtcblx0XHQvLyBEYXRhL2NvbmZpZy9jYWNoZS9sb2cgYXJlIGludmVudGVkIGJ5IG1lIGFzIFdpbmRvd3MgaXNuJ3Qgb3BpbmlvbmF0ZWQgYWJvdXQgdGhpc1xuXHRcdGRhdGE6IHBhdGguam9pbihsb2NhbEFwcERhdGEsIG5hbWUsICdEYXRhJyksXG5cdFx0Y29uZmlnOiBwYXRoLmpvaW4oYXBwRGF0YSwgbmFtZSwgJ0NvbmZpZycpLFxuXHRcdGNhY2hlOiBwYXRoLmpvaW4obG9jYWxBcHBEYXRhLCBuYW1lLCAnQ2FjaGUnKSxcblx0XHRsb2c6IHBhdGguam9pbihsb2NhbEFwcERhdGEsIG5hbWUsICdMb2cnKSxcblx0XHR0ZW1wOiBwYXRoLmpvaW4odG1wZGlyLCBuYW1lKVxuXHR9O1xufTtcblxuLy8gaHR0cHM6Ly9zcGVjaWZpY2F0aW9ucy5mcmVlZGVza3RvcC5vcmcvYmFzZWRpci1zcGVjL2Jhc2VkaXItc3BlYy1sYXRlc3QuaHRtbFxuY29uc3QgbGludXggPSBuYW1lID0+IHtcblx0Y29uc3QgdXNlcm5hbWUgPSBwYXRoLmJhc2VuYW1lKGhvbWVkaXIpO1xuXG5cdHJldHVybiB7XG5cdFx0ZGF0YTogcGF0aC5qb2luKGVudi5YREdfREFUQV9IT01FIHx8IHBhdGguam9pbihob21lZGlyLCAnLmxvY2FsJywgJ3NoYXJlJyksIG5hbWUpLFxuXHRcdGNvbmZpZzogcGF0aC5qb2luKGVudi5YREdfQ09ORklHX0hPTUUgfHwgcGF0aC5qb2luKGhvbWVkaXIsICcuY29uZmlnJyksIG5hbWUpLFxuXHRcdGNhY2hlOiBwYXRoLmpvaW4oZW52LlhER19DQUNIRV9IT01FIHx8IHBhdGguam9pbihob21lZGlyLCAnLmNhY2hlJyksIG5hbWUpLFxuXHRcdC8vIGh0dHBzOi8vd2lraS5kZWJpYW4ub3JnL1hER0Jhc2VEaXJlY3RvcnlTcGVjaWZpY2F0aW9uI3N0YXRlXG5cdFx0bG9nOiBwYXRoLmpvaW4oZW52LlhER19TVEFURV9IT01FIHx8IHBhdGguam9pbihob21lZGlyLCAnLmxvY2FsJywgJ3N0YXRlJyksIG5hbWUpLFxuXHRcdHRlbXA6IHBhdGguam9pbih0bXBkaXIsIHVzZXJuYW1lLCBuYW1lKVxuXHR9O1xufTtcblxuY29uc3QgZW52UGF0aHMgPSAobmFtZSwgb3B0aW9ucykgPT4ge1xuXHRpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2YgbmFtZX1gKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtzdWZmaXg6ICdub2RlanMnfSwgb3B0aW9ucyk7XG5cblx0aWYgKG9wdGlvbnMuc3VmZml4KSB7XG5cdFx0Ly8gQWRkIHN1ZmZpeCB0byBwcmV2ZW50IHBvc3NpYmxlIGNvbmZsaWN0IHdpdGggbmF0aXZlIGFwcHNcblx0XHRuYW1lICs9IGAtJHtvcHRpb25zLnN1ZmZpeH1gO1xuXHR9XG5cblx0aWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG5cdFx0cmV0dXJuIG1hY29zKG5hbWUpO1xuXHR9XG5cblx0aWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcblx0XHRyZXR1cm4gd2luZG93cyhuYW1lKTtcblx0fVxuXG5cdHJldHVybiBsaW51eChuYW1lKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW52UGF0aHM7XG4vLyBUT0RPOiBSZW1vdmUgdGhpcyBmb3IgdGhlIG5leHQgbWFqb3IgcmVsZWFzZVxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGVudlBhdGhzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBDT05TVFMgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTk9PUCA9IGV4cG9ydHMuTElNSVRfRklMRVNfREVTQ1JJUFRPUlMgPSBleHBvcnRzLkxJTUlUX0JBU0VOQU1FX0xFTkdUSCA9IGV4cG9ydHMuSVNfVVNFUl9ST09UID0gZXhwb3J0cy5JU19QT1NJWCA9IGV4cG9ydHMuREVGQVVMVF9USU1FT1VUX1NZTkMgPSBleHBvcnRzLkRFRkFVTFRfVElNRU9VVF9BU1lOQyA9IGV4cG9ydHMuREVGQVVMVF9XUklURV9PUFRJT05TID0gZXhwb3J0cy5ERUZBVUxUX1JFQURfT1BUSU9OUyA9IGV4cG9ydHMuREVGQVVMVF9GT0xERVJfTU9ERSA9IGV4cG9ydHMuREVGQVVMVF9GSUxFX01PREUgPSBleHBvcnRzLkRFRkFVTFRfRU5DT0RJTkcgPSB2b2lkIDA7XG5jb25zdCBERUZBVUxUX0VOQ09ESU5HID0gJ3V0ZjgnO1xuZXhwb3J0cy5ERUZBVUxUX0VOQ09ESU5HID0gREVGQVVMVF9FTkNPRElORztcbmNvbnN0IERFRkFVTFRfRklMRV9NT0RFID0gMG82NjY7XG5leHBvcnRzLkRFRkFVTFRfRklMRV9NT0RFID0gREVGQVVMVF9GSUxFX01PREU7XG5jb25zdCBERUZBVUxUX0ZPTERFUl9NT0RFID0gMG83Nzc7XG5leHBvcnRzLkRFRkFVTFRfRk9MREVSX01PREUgPSBERUZBVUxUX0ZPTERFUl9NT0RFO1xuY29uc3QgREVGQVVMVF9SRUFEX09QVElPTlMgPSB7fTtcbmV4cG9ydHMuREVGQVVMVF9SRUFEX09QVElPTlMgPSBERUZBVUxUX1JFQURfT1BUSU9OUztcbmNvbnN0IERFRkFVTFRfV1JJVEVfT1BUSU9OUyA9IHt9O1xuZXhwb3J0cy5ERUZBVUxUX1dSSVRFX09QVElPTlMgPSBERUZBVUxUX1dSSVRFX09QVElPTlM7XG5jb25zdCBERUZBVUxUX1RJTUVPVVRfQVNZTkMgPSA1MDAwO1xuZXhwb3J0cy5ERUZBVUxUX1RJTUVPVVRfQVNZTkMgPSBERUZBVUxUX1RJTUVPVVRfQVNZTkM7XG5jb25zdCBERUZBVUxUX1RJTUVPVVRfU1lOQyA9IDEwMDtcbmV4cG9ydHMuREVGQVVMVF9USU1FT1VUX1NZTkMgPSBERUZBVUxUX1RJTUVPVVRfU1lOQztcbmNvbnN0IElTX1BPU0lYID0gISFwcm9jZXNzLmdldHVpZDtcbmV4cG9ydHMuSVNfUE9TSVggPSBJU19QT1NJWDtcbmNvbnN0IElTX1VTRVJfUk9PVCA9IHByb2Nlc3MuZ2V0dWlkID8gIXByb2Nlc3MuZ2V0dWlkKCkgOiBmYWxzZTtcbmV4cG9ydHMuSVNfVVNFUl9ST09UID0gSVNfVVNFUl9ST09UO1xuY29uc3QgTElNSVRfQkFTRU5BTUVfTEVOR1RIID0gMTI4OyAvL1RPRE86IGZldGNoIHRoZSByZWFsIGxpbWl0IGZyb20gdGhlIGZpbGVzeXN0ZW0gLy9UT0RPOiBmZXRjaCB0aGUgd2hvbGUtcGF0aCBsZW5ndGggbGltaXQgdG9vXG5leHBvcnRzLkxJTUlUX0JBU0VOQU1FX0xFTkdUSCA9IExJTUlUX0JBU0VOQU1FX0xFTkdUSDtcbmNvbnN0IExJTUlUX0ZJTEVTX0RFU0NSSVBUT1JTID0gMTAwMDA7IC8vVE9ETzogZmV0Y2ggdGhlIHJlYWwgbGltaXQgZnJvbSB0aGUgZmlsZXN5c3RlbVxuZXhwb3J0cy5MSU1JVF9GSUxFU19ERVNDUklQVE9SUyA9IExJTUlUX0ZJTEVTX0RFU0NSSVBUT1JTO1xuY29uc3QgTk9PUCA9ICgpID0+IHsgfTtcbmV4cG9ydHMuTk9PUCA9IE5PT1A7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIElNUE9SVCAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hdHRlbXB0aWZ5U3luYyA9IGV4cG9ydHMuYXR0ZW1wdGlmeUFzeW5jID0gdm9pZCAwO1xuY29uc3QgY29uc3RzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RzXCIpO1xuLyogQVRURU1QVElGWSAqL1xuLy9UT0RPOiBNYXliZSBwdWJsaXNoIHRoaXMgYXMgYSBzdGFuZGFsb25lIHBhY2thZ2Vcbi8vRklYTUU6IFRoZSB0eXBlIGNhc3RpbmdzIGhlcmUgYXJlbid0IGV4YWN0bHkgY29ycmVjdFxuY29uc3QgYXR0ZW1wdGlmeUFzeW5jID0gKGZuLCBvbkVycm9yID0gY29uc3RzXzEuTk9PUCkgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykuY2F0Y2gob25FcnJvcik7XG4gICAgfTtcbn07XG5leHBvcnRzLmF0dGVtcHRpZnlBc3luYyA9IGF0dGVtcHRpZnlBc3luYztcbmNvbnN0IGF0dGVtcHRpZnlTeW5jID0gKGZuLCBvbkVycm9yID0gY29uc3RzXzEuTk9PUCkgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5leHBvcnRzLmF0dGVtcHRpZnlTeW5jID0gYXR0ZW1wdGlmeVN5bmM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIElNUE9SVCAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29uc3RzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RzXCIpO1xuLyogRlMgSEFORExFUlMgKi9cbmNvbnN0IEhhbmRsZXJzID0ge1xuICAgIGlzQ2hhbmdlRXJyb3JPazogKGVycm9yKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY29kZSB9ID0gZXJyb3I7XG4gICAgICAgIGlmIChjb2RlID09PSAnRU5PU1lTJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoIWNvbnN0c18xLklTX1VTRVJfUk9PVCAmJiAoY29kZSA9PT0gJ0VJTlZBTCcgfHwgY29kZSA9PT0gJ0VQRVJNJykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgaXNSZXRyaWFibGVFcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY29kZSB9ID0gZXJyb3I7XG4gICAgICAgIGlmIChjb2RlID09PSAnRU1GSUxFJyB8fCBjb2RlID09PSAnRU5GSUxFJyB8fCBjb2RlID09PSAnRUFHQUlOJyB8fCBjb2RlID09PSAnRUJVU1knIHx8IGNvZGUgPT09ICdFQUNDRVNTJyB8fCBjb2RlID09PSAnRUFDQ1MnIHx8IGNvZGUgPT09ICdFUEVSTScpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgb25DaGFuZ2VFcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgIGlmIChIYW5kbGVycy5pc0NoYW5nZUVycm9yT2soZXJyb3IpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59O1xuLyogRVhQT1JUICovXG5leHBvcnRzLmRlZmF1bHQgPSBIYW5kbGVycztcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogSU1QT1JUICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb25zdHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdHNcIik7XG4vKiBSRVRSWUlGWSBRVUVVRSAqL1xuY29uc3QgUmV0cnlmeVF1ZXVlID0ge1xuICAgIGludGVydmFsOiAyNSxcbiAgICBpbnRlcnZhbElkOiB1bmRlZmluZWQsXG4gICAgbGltaXQ6IGNvbnN0c18xLkxJTUlUX0ZJTEVTX0RFU0NSSVBUT1JTLFxuICAgIHF1ZXVlQWN0aXZlOiBuZXcgU2V0KCksXG4gICAgcXVldWVXYWl0aW5nOiBuZXcgU2V0KCksXG4gICAgaW5pdDogKCkgPT4ge1xuICAgICAgICBpZiAoUmV0cnlmeVF1ZXVlLmludGVydmFsSWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIFJldHJ5ZnlRdWV1ZS5pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoUmV0cnlmeVF1ZXVlLnRpY2ssIFJldHJ5ZnlRdWV1ZS5pbnRlcnZhbCk7XG4gICAgfSxcbiAgICByZXNldDogKCkgPT4ge1xuICAgICAgICBpZiAoIVJldHJ5ZnlRdWV1ZS5pbnRlcnZhbElkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjbGVhckludGVydmFsKFJldHJ5ZnlRdWV1ZS5pbnRlcnZhbElkKTtcbiAgICAgICAgZGVsZXRlIFJldHJ5ZnlRdWV1ZS5pbnRlcnZhbElkO1xuICAgIH0sXG4gICAgYWRkOiAoZm4pID0+IHtcbiAgICAgICAgUmV0cnlmeVF1ZXVlLnF1ZXVlV2FpdGluZy5hZGQoZm4pO1xuICAgICAgICBpZiAoUmV0cnlmeVF1ZXVlLnF1ZXVlQWN0aXZlLnNpemUgPCAoUmV0cnlmeVF1ZXVlLmxpbWl0IC8gMikpIHsgLy8gQWN0aXZlIHF1ZXVlIG5vdCB1bmRlciBwcmVhc3N1cmUsIGV4ZWN1dGluZyBpbW1lZGlhdGVseVxuICAgICAgICAgICAgUmV0cnlmeVF1ZXVlLnRpY2soKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFJldHJ5ZnlRdWV1ZS5pbml0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZTogKGZuKSA9PiB7XG4gICAgICAgIFJldHJ5ZnlRdWV1ZS5xdWV1ZVdhaXRpbmcuZGVsZXRlKGZuKTtcbiAgICAgICAgUmV0cnlmeVF1ZXVlLnF1ZXVlQWN0aXZlLmRlbGV0ZShmbik7XG4gICAgfSxcbiAgICBzY2hlZHVsZTogKCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4gUmV0cnlmeVF1ZXVlLnJlbW92ZShyZXNvbHZlcik7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlciA9ICgpID0+IHJlc29sdmUoY2xlYW51cCk7XG4gICAgICAgICAgICBSZXRyeWZ5UXVldWUuYWRkKHJlc29sdmVyKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICB0aWNrOiAoKSA9PiB7XG4gICAgICAgIGlmIChSZXRyeWZ5UXVldWUucXVldWVBY3RpdmUuc2l6ZSA+PSBSZXRyeWZ5UXVldWUubGltaXQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghUmV0cnlmeVF1ZXVlLnF1ZXVlV2FpdGluZy5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIFJldHJ5ZnlRdWV1ZS5yZXNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGZuIG9mIFJldHJ5ZnlRdWV1ZS5xdWV1ZVdhaXRpbmcpIHtcbiAgICAgICAgICAgIGlmIChSZXRyeWZ5UXVldWUucXVldWVBY3RpdmUuc2l6ZSA+PSBSZXRyeWZ5UXVldWUubGltaXQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBSZXRyeWZ5UXVldWUucXVldWVXYWl0aW5nLmRlbGV0ZShmbik7XG4gICAgICAgICAgICBSZXRyeWZ5UXVldWUucXVldWVBY3RpdmUuYWRkKGZuKTtcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyogRVhQT1JUICovXG5leHBvcnRzLmRlZmF1bHQgPSBSZXRyeWZ5UXVldWU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIElNUE9SVCAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXRyeWlmeVN5bmMgPSBleHBvcnRzLnJldHJ5aWZ5QXN5bmMgPSB2b2lkIDA7XG5jb25zdCByZXRyeWlmeV9xdWV1ZV8xID0gcmVxdWlyZShcIi4vcmV0cnlpZnlfcXVldWVcIik7XG4vKiBSRVRSWUlGWSAqL1xuY29uc3QgcmV0cnlpZnlBc3luYyA9IChmbiwgaXNSZXRyaWFibGVFcnJvcikgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGltZXN0YW1wKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhdHRlbXB0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHJ5aWZ5X3F1ZXVlXzEuZGVmYXVsdC5zY2hlZHVsZSgpLnRoZW4oY2xlYW51cCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKERhdGUubm93KCkgPj0gdGltZXN0YW1wKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1JldHJpYWJsZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsYXkgPSBNYXRoLnJvdW5kKDEwMCArICg0MDAgKiBNYXRoLnJhbmRvbSgpKSksIGRlbGF5UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGF5UHJvbWlzZS50aGVuKCgpID0+IGF0dGVtcHQuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG59O1xuZXhwb3J0cy5yZXRyeWlmeUFzeW5jID0gcmV0cnlpZnlBc3luYztcbmNvbnN0IHJldHJ5aWZ5U3luYyA9IChmbiwgaXNSZXRyaWFibGVFcnJvcikgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGltZXN0YW1wKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhdHRlbXB0KCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKERhdGUubm93KCkgPiB0aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIGlmIChpc1JldHJpYWJsZUVycm9yKGVycm9yKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dGVtcHQuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG59O1xuZXhwb3J0cy5yZXRyeWlmeVN5bmMgPSByZXRyeWlmeVN5bmM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIElNUE9SVCAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IGF0dGVtcHRpZnlfMSA9IHJlcXVpcmUoXCIuL2F0dGVtcHRpZnlcIik7XG5jb25zdCBmc19oYW5kbGVyc18xID0gcmVxdWlyZShcIi4vZnNfaGFuZGxlcnNcIik7XG5jb25zdCByZXRyeWlmeV8xID0gcmVxdWlyZShcIi4vcmV0cnlpZnlcIik7XG4vKiBGUyAqL1xuY29uc3QgRlMgPSB7XG4gICAgY2htb2RBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMuY2htb2QpLCBmc19oYW5kbGVyc18xLmRlZmF1bHQub25DaGFuZ2VFcnJvciksXG4gICAgY2hvd25BdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMuY2hvd24pLCBmc19oYW5kbGVyc18xLmRlZmF1bHQub25DaGFuZ2VFcnJvciksXG4gICAgY2xvc2VBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMuY2xvc2UpKSxcbiAgICBmc3luY0F0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5mc3luYykpLFxuICAgIG1rZGlyQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLm1rZGlyKSksXG4gICAgcmVhbHBhdGhBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMucmVhbHBhdGgpKSxcbiAgICBzdGF0QXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLnN0YXQpKSxcbiAgICB1bmxpbmtBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMudW5saW5rKSksXG4gICAgY2xvc2VSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMuY2xvc2UpLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgZnN5bmNSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMuZnN5bmMpLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgb3BlblJldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5vcGVuKSwgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIHJlYWRGaWxlUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLnJlYWRGaWxlKSwgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIHJlbmFtZVJldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5yZW5hbWUpLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgc3RhdFJldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5zdGF0KSwgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIHdyaXRlUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLndyaXRlKSwgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIGNobW9kU3luY0F0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5U3luYyhmcy5jaG1vZFN5bmMsIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5vbkNoYW5nZUVycm9yKSxcbiAgICBjaG93blN5bmNBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeVN5bmMoZnMuY2hvd25TeW5jLCBmc19oYW5kbGVyc18xLmRlZmF1bHQub25DaGFuZ2VFcnJvciksXG4gICAgY2xvc2VTeW5jQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlTeW5jKGZzLmNsb3NlU3luYyksXG4gICAgbWtkaXJTeW5jQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlTeW5jKGZzLm1rZGlyU3luYyksXG4gICAgcmVhbHBhdGhTeW5jQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlTeW5jKGZzLnJlYWxwYXRoU3luYyksXG4gICAgc3RhdFN5bmNBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeVN5bmMoZnMuc3RhdFN5bmMpLFxuICAgIHVubGlua1N5bmNBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeVN5bmMoZnMudW5saW5rU3luYyksXG4gICAgY2xvc2VTeW5jUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlTeW5jKGZzLmNsb3NlU3luYywgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIGZzeW5jU3luY1JldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5U3luYyhmcy5mc3luY1N5bmMsIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICBvcGVuU3luY1JldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5U3luYyhmcy5vcGVuU3luYywgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIHJlYWRGaWxlU3luY1JldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5U3luYyhmcy5yZWFkRmlsZVN5bmMsIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICByZW5hbWVTeW5jUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlTeW5jKGZzLnJlbmFtZVN5bmMsIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICBzdGF0U3luY1JldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5U3luYyhmcy5zdGF0U3luYywgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIHdyaXRlU3luY1JldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5U3luYyhmcy53cml0ZVN5bmMsIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKVxufTtcbi8qIEVYUE9SVCAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gRlM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIExBTkcgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IExhbmcgPSB7XG4gICAgaXNGdW5jdGlvbjogKHgpID0+IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xuICAgIH0sXG4gICAgaXNTdHJpbmc6ICh4KSA9PiB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ3N0cmluZyc7XG4gICAgfSxcbiAgICBpc1VuZGVmaW5lZDogKHgpID0+IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAndW5kZWZpbmVkJztcbiAgICB9XG59O1xuLyogRVhQT1JUICovXG5leHBvcnRzLmRlZmF1bHQgPSBMYW5nO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBJTVBPUlQgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qIFZBUklBQkxFUyAqL1xuY29uc3QgUXVldWVzID0ge307XG4vKiBTQ0hFRFVMRVIgKi9cbi8vVE9ETzogTWF5YmUgcHVibGlzaCB0aGlzIGFzIGEgc3RhbmRhbG9uZSBwYWNrYWdlXG5jb25zdCBTY2hlZHVsZXIgPSB7XG4gICAgbmV4dDogKGlkKSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gUXVldWVzW2lkXTtcbiAgICAgICAgaWYgKCFxdWV1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcXVldWUuc2hpZnQoKTtcbiAgICAgICAgY29uc3Qgam9iID0gcXVldWVbMF07XG4gICAgICAgIGlmIChqb2IpIHtcbiAgICAgICAgICAgIGpvYigoKSA9PiBTY2hlZHVsZXIubmV4dChpZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIFF1ZXVlc1tpZF07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNjaGVkdWxlOiAoaWQpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgbGV0IHF1ZXVlID0gUXVldWVzW2lkXTtcbiAgICAgICAgICAgIGlmICghcXVldWUpXG4gICAgICAgICAgICAgICAgcXVldWUgPSBRdWV1ZXNbaWRdID0gW107XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKHJlc29sdmUpO1xuICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcmVzb2x2ZSgoKSA9PiBTY2hlZHVsZXIubmV4dChpZCkpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuLyogRVhQT1JUICovXG5leHBvcnRzLmRlZmF1bHQgPSBTY2hlZHVsZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIElNUE9SVCAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgY29uc3RzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RzXCIpO1xuY29uc3QgZnNfMSA9IHJlcXVpcmUoXCIuL2ZzXCIpO1xuLyogVEVNUCAqL1xuLy9UT0RPOiBNYXliZSBwdWJsaXNoIHRoaXMgYXMgYSBzdGFuZGFsb25lIHBhY2thZ2VcbmNvbnN0IFRlbXAgPSB7XG4gICAgc3RvcmU6IHt9LFxuICAgIGNyZWF0ZTogKGZpbGVQYXRoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJhbmRvbW5lc3MgPSBgMDAwMDAwJHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxNjc3NzIxNSkudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTYpLCAvLyA2IHJhbmRvbS1lbm91Z2ggaGV4IGNoYXJhY3RlcnNcbiAgICAgICAgdGltZXN0YW1wID0gRGF0ZS5ub3coKS50b1N0cmluZygpLnNsaWNlKC0xMCksIC8vIDEwIHByZWNpc2UgdGltZXN0YW1wIGRpZ2l0c1xuICAgICAgICBwcmVmaXggPSAndG1wLScsIHN1ZmZpeCA9IGAuJHtwcmVmaXh9JHt0aW1lc3RhbXB9JHtyYW5kb21uZXNzfWAsIHRlbXBQYXRoID0gYCR7ZmlsZVBhdGh9JHtzdWZmaXh9YDtcbiAgICAgICAgcmV0dXJuIHRlbXBQYXRoO1xuICAgIH0sXG4gICAgZ2V0OiAoZmlsZVBhdGgsIGNyZWF0b3IsIHB1cmdlID0gdHJ1ZSkgPT4ge1xuICAgICAgICBjb25zdCB0ZW1wUGF0aCA9IFRlbXAudHJ1bmNhdGUoY3JlYXRvcihmaWxlUGF0aCkpO1xuICAgICAgICBpZiAodGVtcFBhdGggaW4gVGVtcC5zdG9yZSlcbiAgICAgICAgICAgIHJldHVybiBUZW1wLmdldChmaWxlUGF0aCwgY3JlYXRvciwgcHVyZ2UpOyAvLyBDb2xsaXNpb24gZm91bmQsIHRyeSBhZ2FpblxuICAgICAgICBUZW1wLnN0b3JlW3RlbXBQYXRoXSA9IHB1cmdlO1xuICAgICAgICBjb25zdCBkaXNwb3NlciA9ICgpID0+IGRlbGV0ZSBUZW1wLnN0b3JlW3RlbXBQYXRoXTtcbiAgICAgICAgcmV0dXJuIFt0ZW1wUGF0aCwgZGlzcG9zZXJdO1xuICAgIH0sXG4gICAgcHVyZ2U6IChmaWxlUGF0aCkgPT4ge1xuICAgICAgICBpZiAoIVRlbXAuc3RvcmVbZmlsZVBhdGhdKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBkZWxldGUgVGVtcC5zdG9yZVtmaWxlUGF0aF07XG4gICAgICAgIGZzXzEuZGVmYXVsdC51bmxpbmtBdHRlbXB0KGZpbGVQYXRoKTtcbiAgICB9LFxuICAgIHB1cmdlU3luYzogKGZpbGVQYXRoKSA9PiB7XG4gICAgICAgIGlmICghVGVtcC5zdG9yZVtmaWxlUGF0aF0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRlbGV0ZSBUZW1wLnN0b3JlW2ZpbGVQYXRoXTtcbiAgICAgICAgZnNfMS5kZWZhdWx0LnVubGlua1N5bmNBdHRlbXB0KGZpbGVQYXRoKTtcbiAgICB9LFxuICAgIHB1cmdlU3luY0FsbDogKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGZpbGVQYXRoIGluIFRlbXAuc3RvcmUpIHtcbiAgICAgICAgICAgIFRlbXAucHVyZ2VTeW5jKGZpbGVQYXRoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdHJ1bmNhdGU6IChmaWxlUGF0aCkgPT4ge1xuICAgICAgICBjb25zdCBiYXNlbmFtZSA9IHBhdGguYmFzZW5hbWUoZmlsZVBhdGgpO1xuICAgICAgICBpZiAoYmFzZW5hbWUubGVuZ3RoIDw9IGNvbnN0c18xLkxJTUlUX0JBU0VOQU1FX0xFTkdUSClcbiAgICAgICAgICAgIHJldHVybiBmaWxlUGF0aDsgLy9GSVhNRTogUm91Z2ggYW5kIHF1aWNrIGF0dGVtcHQgYXQgZGV0ZWN0aW5nIG9rIGxlbmd0aHNcbiAgICAgICAgY29uc3QgdHJ1bmNhYmxlID0gL14oXFwuPykoLio/KSgoPzpcXC5bXi5dKyk/KD86XFwudG1wLVxcZHsxMH1bYS1mMC05XXs2fSk/KSQvLmV4ZWMoYmFzZW5hbWUpO1xuICAgICAgICBpZiAoIXRydW5jYWJsZSlcbiAgICAgICAgICAgIHJldHVybiBmaWxlUGF0aDsgLy9GSVhNRTogTm8gdHJ1bmNhYmxlIHBhcnQgZGV0ZWN0ZWQsIGNhbid0IHJlYWxseSBkbyBtdWNoIHdpdGhvdXQgYWxzbyBjaGFuZ2luZyB0aGUgcGFyZW50IHBhdGgsIHdoaWNoIGlzIHVuc2FmZSwgaG9waW5nIGZvciB0aGUgYmVzdCBoZXJlXG4gICAgICAgIGNvbnN0IHRydW5jYXRpb25MZW5ndGggPSBiYXNlbmFtZS5sZW5ndGggLSBjb25zdHNfMS5MSU1JVF9CQVNFTkFNRV9MRU5HVEg7XG4gICAgICAgIHJldHVybiBgJHtmaWxlUGF0aC5zbGljZSgwLCAtYmFzZW5hbWUubGVuZ3RoKX0ke3RydW5jYWJsZVsxXX0ke3RydW5jYWJsZVsyXS5zbGljZSgwLCAtdHJ1bmNhdGlvbkxlbmd0aCl9JHt0cnVuY2FibGVbM119YDsgLy9GSVhNRTogVGhlIHRydW5jYWJsZSBwYXJ0IG1pZ2h0IGJlIHNob3J0ZXIgdGhhbiBuZWVkZWQgaGVyZVxuICAgIH1cbn07XG4vKiBJTklUICovXG5wcm9jZXNzLm9uKCdleGl0JywgVGVtcC5wdXJnZVN5bmNBbGwpOyAvLyBFbnN1cmluZyBwdXJnZWFibGUgdGVtcCBmaWxlcyBhcmUgcHVyZ2VkIG9uIGV4aXRcbi8qIEVYUE9SVCAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gVGVtcDtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogSU1QT1JUICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndyaXRlRmlsZVN5bmMgPSBleHBvcnRzLndyaXRlRmlsZSA9IGV4cG9ydHMucmVhZEZpbGVTeW5jID0gZXhwb3J0cy5yZWFkRmlsZSA9IHZvaWQgMDtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IGNvbnN0c18xID0gcmVxdWlyZShcIi4vY29uc3RzXCIpO1xuY29uc3QgZnNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2ZzXCIpO1xuY29uc3QgbGFuZ18xID0gcmVxdWlyZShcIi4vdXRpbHMvbGFuZ1wiKTtcbmNvbnN0IHNjaGVkdWxlcl8xID0gcmVxdWlyZShcIi4vdXRpbHMvc2NoZWR1bGVyXCIpO1xuY29uc3QgdGVtcF8xID0gcmVxdWlyZShcIi4vdXRpbHMvdGVtcFwiKTtcbmZ1bmN0aW9uIHJlYWRGaWxlKGZpbGVQYXRoLCBvcHRpb25zID0gY29uc3RzXzEuREVGQVVMVF9SRUFEX09QVElPTlMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGxhbmdfMS5kZWZhdWx0LmlzU3RyaW5nKG9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gcmVhZEZpbGUoZmlsZVBhdGgsIHsgZW5jb2Rpbmc6IG9wdGlvbnMgfSk7XG4gICAgY29uc3QgdGltZW91dCA9IERhdGUubm93KCkgKyAoKF9hID0gb3B0aW9ucy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb25zdHNfMS5ERUZBVUxUX1RJTUVPVVRfQVNZTkMpO1xuICAgIHJldHVybiBmc18xLmRlZmF1bHQucmVhZEZpbGVSZXRyeSh0aW1lb3V0KShmaWxlUGF0aCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLnJlYWRGaWxlID0gcmVhZEZpbGU7XG47XG5mdW5jdGlvbiByZWFkRmlsZVN5bmMoZmlsZVBhdGgsIG9wdGlvbnMgPSBjb25zdHNfMS5ERUZBVUxUX1JFQURfT1BUSU9OUykge1xuICAgIHZhciBfYTtcbiAgICBpZiAobGFuZ18xLmRlZmF1bHQuaXNTdHJpbmcob3B0aW9ucykpXG4gICAgICAgIHJldHVybiByZWFkRmlsZVN5bmMoZmlsZVBhdGgsIHsgZW5jb2Rpbmc6IG9wdGlvbnMgfSk7XG4gICAgY29uc3QgdGltZW91dCA9IERhdGUubm93KCkgKyAoKF9hID0gb3B0aW9ucy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb25zdHNfMS5ERUZBVUxUX1RJTUVPVVRfU1lOQyk7XG4gICAgcmV0dXJuIGZzXzEuZGVmYXVsdC5yZWFkRmlsZVN5bmNSZXRyeSh0aW1lb3V0KShmaWxlUGF0aCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLnJlYWRGaWxlU3luYyA9IHJlYWRGaWxlU3luYztcbjtcbmNvbnN0IHdyaXRlRmlsZSA9IChmaWxlUGF0aCwgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgICBpZiAobGFuZ18xLmRlZmF1bHQuaXNGdW5jdGlvbihvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIHdyaXRlRmlsZShmaWxlUGF0aCwgZGF0YSwgY29uc3RzXzEuREVGQVVMVF9XUklURV9PUFRJT05TLCBvcHRpb25zKTtcbiAgICBjb25zdCBwcm9taXNlID0gd3JpdGVGaWxlQXN5bmMoZmlsZVBhdGgsIGRhdGEsIG9wdGlvbnMpO1xuICAgIGlmIChjYWxsYmFjaylcbiAgICAgICAgcHJvbWlzZS50aGVuKGNhbGxiYWNrLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59O1xuZXhwb3J0cy53cml0ZUZpbGUgPSB3cml0ZUZpbGU7XG5jb25zdCB3cml0ZUZpbGVBc3luYyA9IGFzeW5jIChmaWxlUGF0aCwgZGF0YSwgb3B0aW9ucyA9IGNvbnN0c18xLkRFRkFVTFRfV1JJVEVfT1BUSU9OUykgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAobGFuZ18xLmRlZmF1bHQuaXNTdHJpbmcob3B0aW9ucykpXG4gICAgICAgIHJldHVybiB3cml0ZUZpbGVBc3luYyhmaWxlUGF0aCwgZGF0YSwgeyBlbmNvZGluZzogb3B0aW9ucyB9KTtcbiAgICBjb25zdCB0aW1lb3V0ID0gRGF0ZS5ub3coKSArICgoX2EgPSBvcHRpb25zLnRpbWVvdXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbnN0c18xLkRFRkFVTFRfVElNRU9VVF9BU1lOQyk7XG4gICAgbGV0IHNjaGVkdWxlckN1c3RvbURpc3Bvc2VyID0gbnVsbCwgc2NoZWR1bGVyRGlzcG9zZXIgPSBudWxsLCB0ZW1wRGlzcG9zZXIgPSBudWxsLCB0ZW1wUGF0aCA9IG51bGwsIGZkID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgICBpZiAob3B0aW9ucy5zY2hlZHVsZSlcbiAgICAgICAgICAgIHNjaGVkdWxlckN1c3RvbURpc3Bvc2VyID0gYXdhaXQgb3B0aW9ucy5zY2hlZHVsZShmaWxlUGF0aCk7XG4gICAgICAgIHNjaGVkdWxlckRpc3Bvc2VyID0gYXdhaXQgc2NoZWR1bGVyXzEuZGVmYXVsdC5zY2hlZHVsZShmaWxlUGF0aCk7XG4gICAgICAgIGZpbGVQYXRoID0gYXdhaXQgZnNfMS5kZWZhdWx0LnJlYWxwYXRoQXR0ZW1wdChmaWxlUGF0aCkgfHwgZmlsZVBhdGg7XG4gICAgICAgIFt0ZW1wUGF0aCwgdGVtcERpc3Bvc2VyXSA9IHRlbXBfMS5kZWZhdWx0LmdldChmaWxlUGF0aCwgb3B0aW9ucy50bXBDcmVhdGUgfHwgdGVtcF8xLmRlZmF1bHQuY3JlYXRlLCAhKG9wdGlvbnMudG1wUHVyZ2UgPT09IGZhbHNlKSk7XG4gICAgICAgIGNvbnN0IHVzZVN0YXRDaG93biA9IGNvbnN0c18xLklTX1BPU0lYICYmIGxhbmdfMS5kZWZhdWx0LmlzVW5kZWZpbmVkKG9wdGlvbnMuY2hvd24pLCB1c2VTdGF0TW9kZSA9IGxhbmdfMS5kZWZhdWx0LmlzVW5kZWZpbmVkKG9wdGlvbnMubW9kZSk7XG4gICAgICAgIGlmICh1c2VTdGF0Q2hvd24gfHwgdXNlU3RhdE1vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXQgPSBhd2FpdCBmc18xLmRlZmF1bHQuc3RhdEF0dGVtcHQoZmlsZVBhdGgpO1xuICAgICAgICAgICAgaWYgKHN0YXQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICAgICAgaWYgKHVzZVN0YXRDaG93bilcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jaG93biA9IHsgdWlkOiBzdGF0LnVpZCwgZ2lkOiBzdGF0LmdpZCB9O1xuICAgICAgICAgICAgICAgIGlmICh1c2VTdGF0TW9kZSlcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tb2RlID0gc3RhdC5tb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBwYXRoLmRpcm5hbWUoZmlsZVBhdGgpO1xuICAgICAgICBhd2FpdCBmc18xLmRlZmF1bHQubWtkaXJBdHRlbXB0KHBhcmVudFBhdGgsIHtcbiAgICAgICAgICAgIG1vZGU6IGNvbnN0c18xLkRFRkFVTFRfRk9MREVSX01PREUsXG4gICAgICAgICAgICByZWN1cnNpdmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGZkID0gYXdhaXQgZnNfMS5kZWZhdWx0Lm9wZW5SZXRyeSh0aW1lb3V0KSh0ZW1wUGF0aCwgJ3cnLCBvcHRpb25zLm1vZGUgfHwgY29uc3RzXzEuREVGQVVMVF9GSUxFX01PREUpO1xuICAgICAgICBpZiAob3B0aW9ucy50bXBDcmVhdGVkKVxuICAgICAgICAgICAgb3B0aW9ucy50bXBDcmVhdGVkKHRlbXBQYXRoKTtcbiAgICAgICAgaWYgKGxhbmdfMS5kZWZhdWx0LmlzU3RyaW5nKGRhdGEpKSB7XG4gICAgICAgICAgICBhd2FpdCBmc18xLmRlZmF1bHQud3JpdGVSZXRyeSh0aW1lb3V0KShmZCwgZGF0YSwgMCwgb3B0aW9ucy5lbmNvZGluZyB8fCBjb25zdHNfMS5ERUZBVUxUX0VOQ09ESU5HKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbGFuZ18xLmRlZmF1bHQuaXNVbmRlZmluZWQoZGF0YSkpIHtcbiAgICAgICAgICAgIGF3YWl0IGZzXzEuZGVmYXVsdC53cml0ZVJldHJ5KHRpbWVvdXQpKGZkLCBkYXRhLCAwLCBkYXRhLmxlbmd0aCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZnN5bmMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5mc3luY1dhaXQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZnNfMS5kZWZhdWx0LmZzeW5jUmV0cnkodGltZW91dCkoZmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZnNfMS5kZWZhdWx0LmZzeW5jQXR0ZW1wdChmZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZnNfMS5kZWZhdWx0LmNsb3NlUmV0cnkodGltZW91dCkoZmQpO1xuICAgICAgICBmZCA9IG51bGw7XG4gICAgICAgIGlmIChvcHRpb25zLmNob3duKVxuICAgICAgICAgICAgYXdhaXQgZnNfMS5kZWZhdWx0LmNob3duQXR0ZW1wdCh0ZW1wUGF0aCwgb3B0aW9ucy5jaG93bi51aWQsIG9wdGlvbnMuY2hvd24uZ2lkKTtcbiAgICAgICAgaWYgKG9wdGlvbnMubW9kZSlcbiAgICAgICAgICAgIGF3YWl0IGZzXzEuZGVmYXVsdC5jaG1vZEF0dGVtcHQodGVtcFBhdGgsIG9wdGlvbnMubW9kZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBmc18xLmRlZmF1bHQucmVuYW1lUmV0cnkodGltZW91dCkodGVtcFBhdGgsIGZpbGVQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlICE9PSAnRU5BTUVUT09MT05HJylcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIGF3YWl0IGZzXzEuZGVmYXVsdC5yZW5hbWVSZXRyeSh0aW1lb3V0KSh0ZW1wUGF0aCwgdGVtcF8xLmRlZmF1bHQudHJ1bmNhdGUoZmlsZVBhdGgpKTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wRGlzcG9zZXIoKTtcbiAgICAgICAgdGVtcFBhdGggPSBudWxsO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGZkKVxuICAgICAgICAgICAgYXdhaXQgZnNfMS5kZWZhdWx0LmNsb3NlQXR0ZW1wdChmZCk7XG4gICAgICAgIGlmICh0ZW1wUGF0aClcbiAgICAgICAgICAgIHRlbXBfMS5kZWZhdWx0LnB1cmdlKHRlbXBQYXRoKTtcbiAgICAgICAgaWYgKHNjaGVkdWxlckN1c3RvbURpc3Bvc2VyKVxuICAgICAgICAgICAgc2NoZWR1bGVyQ3VzdG9tRGlzcG9zZXIoKTtcbiAgICAgICAgaWYgKHNjaGVkdWxlckRpc3Bvc2VyKVxuICAgICAgICAgICAgc2NoZWR1bGVyRGlzcG9zZXIoKTtcbiAgICB9XG59O1xuY29uc3Qgd3JpdGVGaWxlU3luYyA9IChmaWxlUGF0aCwgZGF0YSwgb3B0aW9ucyA9IGNvbnN0c18xLkRFRkFVTFRfV1JJVEVfT1BUSU9OUykgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAobGFuZ18xLmRlZmF1bHQuaXNTdHJpbmcob3B0aW9ucykpXG4gICAgICAgIHJldHVybiB3cml0ZUZpbGVTeW5jKGZpbGVQYXRoLCBkYXRhLCB7IGVuY29kaW5nOiBvcHRpb25zIH0pO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBEYXRlLm5vdygpICsgKChfYSA9IG9wdGlvbnMudGltZW91dCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29uc3RzXzEuREVGQVVMVF9USU1FT1VUX1NZTkMpO1xuICAgIGxldCB0ZW1wRGlzcG9zZXIgPSBudWxsLCB0ZW1wUGF0aCA9IG51bGwsIGZkID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgICBmaWxlUGF0aCA9IGZzXzEuZGVmYXVsdC5yZWFscGF0aFN5bmNBdHRlbXB0KGZpbGVQYXRoKSB8fCBmaWxlUGF0aDtcbiAgICAgICAgW3RlbXBQYXRoLCB0ZW1wRGlzcG9zZXJdID0gdGVtcF8xLmRlZmF1bHQuZ2V0KGZpbGVQYXRoLCBvcHRpb25zLnRtcENyZWF0ZSB8fCB0ZW1wXzEuZGVmYXVsdC5jcmVhdGUsICEob3B0aW9ucy50bXBQdXJnZSA9PT0gZmFsc2UpKTtcbiAgICAgICAgY29uc3QgdXNlU3RhdENob3duID0gY29uc3RzXzEuSVNfUE9TSVggJiYgbGFuZ18xLmRlZmF1bHQuaXNVbmRlZmluZWQob3B0aW9ucy5jaG93biksIHVzZVN0YXRNb2RlID0gbGFuZ18xLmRlZmF1bHQuaXNVbmRlZmluZWQob3B0aW9ucy5tb2RlKTtcbiAgICAgICAgaWYgKHVzZVN0YXRDaG93biB8fCB1c2VTdGF0TW9kZSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdCA9IGZzXzEuZGVmYXVsdC5zdGF0U3luY0F0dGVtcHQoZmlsZVBhdGgpO1xuICAgICAgICAgICAgaWYgKHN0YXQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICAgICAgaWYgKHVzZVN0YXRDaG93bilcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jaG93biA9IHsgdWlkOiBzdGF0LnVpZCwgZ2lkOiBzdGF0LmdpZCB9O1xuICAgICAgICAgICAgICAgIGlmICh1c2VTdGF0TW9kZSlcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tb2RlID0gc3RhdC5tb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBwYXRoLmRpcm5hbWUoZmlsZVBhdGgpO1xuICAgICAgICBmc18xLmRlZmF1bHQubWtkaXJTeW5jQXR0ZW1wdChwYXJlbnRQYXRoLCB7XG4gICAgICAgICAgICBtb2RlOiBjb25zdHNfMS5ERUZBVUxUX0ZPTERFUl9NT0RFLFxuICAgICAgICAgICAgcmVjdXJzaXZlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBmZCA9IGZzXzEuZGVmYXVsdC5vcGVuU3luY1JldHJ5KHRpbWVvdXQpKHRlbXBQYXRoLCAndycsIG9wdGlvbnMubW9kZSB8fCBjb25zdHNfMS5ERUZBVUxUX0ZJTEVfTU9ERSk7XG4gICAgICAgIGlmIChvcHRpb25zLnRtcENyZWF0ZWQpXG4gICAgICAgICAgICBvcHRpb25zLnRtcENyZWF0ZWQodGVtcFBhdGgpO1xuICAgICAgICBpZiAobGFuZ18xLmRlZmF1bHQuaXNTdHJpbmcoZGF0YSkpIHtcbiAgICAgICAgICAgIGZzXzEuZGVmYXVsdC53cml0ZVN5bmNSZXRyeSh0aW1lb3V0KShmZCwgZGF0YSwgMCwgb3B0aW9ucy5lbmNvZGluZyB8fCBjb25zdHNfMS5ERUZBVUxUX0VOQ09ESU5HKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbGFuZ18xLmRlZmF1bHQuaXNVbmRlZmluZWQoZGF0YSkpIHtcbiAgICAgICAgICAgIGZzXzEuZGVmYXVsdC53cml0ZVN5bmNSZXRyeSh0aW1lb3V0KShmZCwgZGF0YSwgMCwgZGF0YS5sZW5ndGgsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmZzeW5jICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZnN5bmNXYWl0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGZzXzEuZGVmYXVsdC5mc3luY1N5bmNSZXRyeSh0aW1lb3V0KShmZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmc18xLmRlZmF1bHQuZnN5bmNBdHRlbXB0KGZkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmc18xLmRlZmF1bHQuY2xvc2VTeW5jUmV0cnkodGltZW91dCkoZmQpO1xuICAgICAgICBmZCA9IG51bGw7XG4gICAgICAgIGlmIChvcHRpb25zLmNob3duKVxuICAgICAgICAgICAgZnNfMS5kZWZhdWx0LmNob3duU3luY0F0dGVtcHQodGVtcFBhdGgsIG9wdGlvbnMuY2hvd24udWlkLCBvcHRpb25zLmNob3duLmdpZCk7XG4gICAgICAgIGlmIChvcHRpb25zLm1vZGUpXG4gICAgICAgICAgICBmc18xLmRlZmF1bHQuY2htb2RTeW5jQXR0ZW1wdCh0ZW1wUGF0aCwgb3B0aW9ucy5tb2RlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZzXzEuZGVmYXVsdC5yZW5hbWVTeW5jUmV0cnkodGltZW91dCkodGVtcFBhdGgsIGZpbGVQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlICE9PSAnRU5BTUVUT09MT05HJylcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIGZzXzEuZGVmYXVsdC5yZW5hbWVTeW5jUmV0cnkodGltZW91dCkodGVtcFBhdGgsIHRlbXBfMS5kZWZhdWx0LnRydW5jYXRlKGZpbGVQYXRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcERpc3Bvc2VyKCk7XG4gICAgICAgIHRlbXBQYXRoID0gbnVsbDtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGlmIChmZClcbiAgICAgICAgICAgIGZzXzEuZGVmYXVsdC5jbG9zZVN5bmNBdHRlbXB0KGZkKTtcbiAgICAgICAgaWYgKHRlbXBQYXRoKVxuICAgICAgICAgICAgdGVtcF8xLmRlZmF1bHQucHVyZ2UodGVtcFBhdGgpO1xuICAgIH1cbn07XG5leHBvcnRzLndyaXRlRmlsZVN5bmMgPSB3cml0ZUZpbGVTeW5jO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlZ2V4cENvZGUgPSBleHBvcnRzLmdldFByb3BlcnR5ID0gZXhwb3J0cy5zYWZlU3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLnN0ckNvbmNhdCA9IGV4cG9ydHMuYWRkQ29kZUFyZyA9IGV4cG9ydHMuc3RyID0gZXhwb3J0cy5fID0gZXhwb3J0cy5uaWwgPSBleHBvcnRzLl9Db2RlID0gZXhwb3J0cy5OYW1lID0gZXhwb3J0cy5JREVOVElGSUVSID0gZXhwb3J0cy5fQ29kZU9yTmFtZSA9IHZvaWQgMDtcbmNsYXNzIF9Db2RlT3JOYW1lIHtcbn1cbmV4cG9ydHMuX0NvZGVPck5hbWUgPSBfQ29kZU9yTmFtZTtcbmV4cG9ydHMuSURFTlRJRklFUiA9IC9eW2EteiRfXVthLXokXzAtOV0qJC9pO1xuY2xhc3MgTmFtZSBleHRlbmRzIF9Db2RlT3JOYW1lIHtcbiAgICBjb25zdHJ1Y3RvcihzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmICghZXhwb3J0cy5JREVOVElGSUVSLnRlc3QocykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb2RlR2VuOiBuYW1lIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXCIpO1xuICAgICAgICB0aGlzLnN0ciA9IHM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHI7XG4gICAgfVxuICAgIGVtcHR5U3RyKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHsgW3RoaXMuc3RyXTogMSB9O1xuICAgIH1cbn1cbmV4cG9ydHMuTmFtZSA9IE5hbWU7XG5jbGFzcyBfQ29kZSBleHRlbmRzIF9Db2RlT3JOYW1lIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gdHlwZW9mIGNvZGUgPT09IFwic3RyaW5nXCIgPyBbY29kZV0gOiBjb2RlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyO1xuICAgIH1cbiAgICBlbXB0eVN0cigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2l0ZW1zLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pdGVtc1swXTtcbiAgICAgICAgcmV0dXJuIGl0ZW0gPT09IFwiXCIgfHwgaXRlbSA9PT0gJ1wiXCInO1xuICAgIH1cbiAgICBnZXQgc3RyKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5fc3RyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAodGhpcy5fc3RyID0gdGhpcy5faXRlbXMucmVkdWNlKChzLCBjKSA9PiBgJHtzfSR7Y31gLCBcIlwiKSkpO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLl9uYW1lcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHRoaXMuX25hbWVzID0gdGhpcy5faXRlbXMucmVkdWNlKChuYW1lcywgYykgPT4ge1xuICAgICAgICAgICAgaWYgKGMgaW5zdGFuY2VvZiBOYW1lKVxuICAgICAgICAgICAgICAgIG5hbWVzW2Muc3RyXSA9IChuYW1lc1tjLnN0cl0gfHwgMCkgKyAxO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWVzO1xuICAgICAgICB9LCB7fSkpKTtcbiAgICB9XG59XG5leHBvcnRzLl9Db2RlID0gX0NvZGU7XG5leHBvcnRzLm5pbCA9IG5ldyBfQ29kZShcIlwiKTtcbmZ1bmN0aW9uIF8oc3RycywgLi4uYXJncykge1xuICAgIGNvbnN0IGNvZGUgPSBbc3Ryc1swXV07XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgYWRkQ29kZUFyZyhjb2RlLCBhcmdzW2ldKTtcbiAgICAgICAgY29kZS5wdXNoKHN0cnNbKytpXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX0NvZGUoY29kZSk7XG59XG5leHBvcnRzLl8gPSBfO1xuY29uc3QgcGx1cyA9IG5ldyBfQ29kZShcIitcIik7XG5mdW5jdGlvbiBzdHIoc3RycywgLi4uYXJncykge1xuICAgIGNvbnN0IGV4cHIgPSBbc2FmZVN0cmluZ2lmeShzdHJzWzBdKV07XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgZXhwci5wdXNoKHBsdXMpO1xuICAgICAgICBhZGRDb2RlQXJnKGV4cHIsIGFyZ3NbaV0pO1xuICAgICAgICBleHByLnB1c2gocGx1cywgc2FmZVN0cmluZ2lmeShzdHJzWysraV0pKTtcbiAgICB9XG4gICAgb3B0aW1pemUoZXhwcik7XG4gICAgcmV0dXJuIG5ldyBfQ29kZShleHByKTtcbn1cbmV4cG9ydHMuc3RyID0gc3RyO1xuZnVuY3Rpb24gYWRkQ29kZUFyZyhjb2RlLCBhcmcpIHtcbiAgICBpZiAoYXJnIGluc3RhbmNlb2YgX0NvZGUpXG4gICAgICAgIGNvZGUucHVzaCguLi5hcmcuX2l0ZW1zKTtcbiAgICBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBOYW1lKVxuICAgICAgICBjb2RlLnB1c2goYXJnKTtcbiAgICBlbHNlXG4gICAgICAgIGNvZGUucHVzaChpbnRlcnBvbGF0ZShhcmcpKTtcbn1cbmV4cG9ydHMuYWRkQ29kZUFyZyA9IGFkZENvZGVBcmc7XG5mdW5jdGlvbiBvcHRpbWl6ZShleHByKSB7XG4gICAgbGV0IGkgPSAxO1xuICAgIHdoaWxlIChpIDwgZXhwci5sZW5ndGggLSAxKSB7XG4gICAgICAgIGlmIChleHByW2ldID09PSBwbHVzKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBtZXJnZUV4cHJJdGVtcyhleHByW2kgLSAxXSwgZXhwcltpICsgMV0pO1xuICAgICAgICAgICAgaWYgKHJlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZXhwci5zcGxpY2UoaSAtIDEsIDMsIHJlcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHByW2krK10gPSBcIitcIjtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxufVxuZnVuY3Rpb24gbWVyZ2VFeHBySXRlbXMoYSwgYikge1xuICAgIGlmIChiID09PSAnXCJcIicpXG4gICAgICAgIHJldHVybiBhO1xuICAgIGlmIChhID09PSAnXCJcIicpXG4gICAgICAgIHJldHVybiBiO1xuICAgIGlmICh0eXBlb2YgYSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChiIGluc3RhbmNlb2YgTmFtZSB8fCBhW2EubGVuZ3RoIC0gMV0gIT09ICdcIicpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIGAke2Euc2xpY2UoMCwgLTEpfSR7Yn1cImA7XG4gICAgICAgIGlmIChiWzBdID09PSAnXCInKVxuICAgICAgICAgICAgcmV0dXJuIGEuc2xpY2UoMCwgLTEpICsgYi5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGIgPT0gXCJzdHJpbmdcIiAmJiBiWzBdID09PSAnXCInICYmICEoYSBpbnN0YW5jZW9mIE5hbWUpKVxuICAgICAgICByZXR1cm4gYFwiJHthfSR7Yi5zbGljZSgxKX1gO1xuICAgIHJldHVybjtcbn1cbmZ1bmN0aW9uIHN0ckNvbmNhdChjMSwgYzIpIHtcbiAgICByZXR1cm4gYzIuZW1wdHlTdHIoKSA/IGMxIDogYzEuZW1wdHlTdHIoKSA/IGMyIDogc3RyIGAke2MxfSR7YzJ9YDtcbn1cbmV4cG9ydHMuc3RyQ29uY2F0ID0gc3RyQ29uY2F0O1xuLy8gVE9ETyBkbyBub3QgYWxsb3cgYXJyYXlzIGhlcmVcbmZ1bmN0aW9uIGludGVycG9sYXRlKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgeCA9PSBcImJvb2xlYW5cIiB8fCB4ID09PSBudWxsXG4gICAgICAgID8geFxuICAgICAgICA6IHNhZmVTdHJpbmdpZnkoQXJyYXkuaXNBcnJheSh4KSA/IHguam9pbihcIixcIikgOiB4KTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeSh4KSB7XG4gICAgcmV0dXJuIG5ldyBfQ29kZShzYWZlU3RyaW5naWZ5KHgpKTtcbn1cbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuZnVuY3Rpb24gc2FmZVN0cmluZ2lmeSh4KSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHgpXG4gICAgICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csIFwiXFxcXHUyMDI4XCIpXG4gICAgICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csIFwiXFxcXHUyMDI5XCIpO1xufVxuZXhwb3J0cy5zYWZlU3RyaW5naWZ5ID0gc2FmZVN0cmluZ2lmeTtcbmZ1bmN0aW9uIGdldFByb3BlcnR5KGtleSkge1xuICAgIHJldHVybiB0eXBlb2Yga2V5ID09IFwic3RyaW5nXCIgJiYgZXhwb3J0cy5JREVOVElGSUVSLnRlc3Qoa2V5KSA/IG5ldyBfQ29kZShgLiR7a2V5fWApIDogXyBgWyR7a2V5fV1gO1xufVxuZXhwb3J0cy5nZXRQcm9wZXJ0eSA9IGdldFByb3BlcnR5O1xuZnVuY3Rpb24gcmVnZXhwQ29kZShyeCkge1xuICAgIHJldHVybiBuZXcgX0NvZGUocngudG9TdHJpbmcoKSk7XG59XG5leHBvcnRzLnJlZ2V4cENvZGUgPSByZWdleHBDb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmFsdWVTY29wZSA9IGV4cG9ydHMuVmFsdWVTY29wZU5hbWUgPSBleHBvcnRzLlNjb3BlID0gZXhwb3J0cy52YXJLaW5kcyA9IGV4cG9ydHMuVXNlZFZhbHVlU3RhdGUgPSB2b2lkIDA7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi9jb2RlXCIpO1xuY2xhc3MgVmFsdWVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHN1cGVyKGBDb2RlR2VuOiBcImNvZGVcIiBmb3IgJHtuYW1lfSBub3QgZGVmaW5lZGApO1xuICAgICAgICB0aGlzLnZhbHVlID0gbmFtZS52YWx1ZTtcbiAgICB9XG59XG52YXIgVXNlZFZhbHVlU3RhdGU7XG4oZnVuY3Rpb24gKFVzZWRWYWx1ZVN0YXRlKSB7XG4gICAgVXNlZFZhbHVlU3RhdGVbVXNlZFZhbHVlU3RhdGVbXCJTdGFydGVkXCJdID0gMF0gPSBcIlN0YXJ0ZWRcIjtcbiAgICBVc2VkVmFsdWVTdGF0ZVtVc2VkVmFsdWVTdGF0ZVtcIkNvbXBsZXRlZFwiXSA9IDFdID0gXCJDb21wbGV0ZWRcIjtcbn0pKFVzZWRWYWx1ZVN0YXRlID0gZXhwb3J0cy5Vc2VkVmFsdWVTdGF0ZSB8fCAoZXhwb3J0cy5Vc2VkVmFsdWVTdGF0ZSA9IHt9KSk7XG5leHBvcnRzLnZhcktpbmRzID0ge1xuICAgIGNvbnN0OiBuZXcgY29kZV8xLk5hbWUoXCJjb25zdFwiKSxcbiAgICBsZXQ6IG5ldyBjb2RlXzEuTmFtZShcImxldFwiKSxcbiAgICB2YXI6IG5ldyBjb2RlXzEuTmFtZShcInZhclwiKSxcbn07XG5jbGFzcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3IoeyBwcmVmaXhlcywgcGFyZW50IH0gPSB7fSkge1xuICAgICAgICB0aGlzLl9uYW1lcyA9IHt9O1xuICAgICAgICB0aGlzLl9wcmVmaXhlcyA9IHByZWZpeGVzO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHRvTmFtZShuYW1lT3JQcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVPclByZWZpeCBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lID8gbmFtZU9yUHJlZml4IDogdGhpcy5uYW1lKG5hbWVPclByZWZpeCk7XG4gICAgfVxuICAgIG5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBuZXcgY29kZV8xLk5hbWUodGhpcy5fbmV3TmFtZShwcmVmaXgpKTtcbiAgICB9XG4gICAgX25ld05hbWUocHJlZml4KSB7XG4gICAgICAgIGNvbnN0IG5nID0gdGhpcy5fbmFtZXNbcHJlZml4XSB8fCB0aGlzLl9uYW1lR3JvdXAocHJlZml4KTtcbiAgICAgICAgcmV0dXJuIGAke3ByZWZpeH0ke25nLmluZGV4Kyt9YDtcbiAgICB9XG4gICAgX25hbWVHcm91cChwcmVmaXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCgoX2IgPSAoX2EgPSB0aGlzLl9wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fcHJlZml4ZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oYXMocHJlZml4KSkgfHwgKHRoaXMuX3ByZWZpeGVzICYmICF0aGlzLl9wcmVmaXhlcy5oYXMocHJlZml4KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogcHJlZml4IFwiJHtwcmVmaXh9XCIgaXMgbm90IGFsbG93ZWQgaW4gdGhpcyBzY29wZWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5fbmFtZXNbcHJlZml4XSA9IHsgcHJlZml4LCBpbmRleDogMCB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNjb3BlID0gU2NvcGU7XG5jbGFzcyBWYWx1ZVNjb3BlTmFtZSBleHRlbmRzIGNvZGVfMS5OYW1lIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXgsIG5hbWVTdHIpIHtcbiAgICAgICAgc3VwZXIobmFtZVN0cik7XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSwgeyBwcm9wZXJ0eSwgaXRlbUluZGV4IH0pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNjb3BlUGF0aCA9IGNvZGVfMS5fIGAuJHtuZXcgY29kZV8xLk5hbWUocHJvcGVydHkpfVske2l0ZW1JbmRleH1dYDtcbiAgICB9XG59XG5leHBvcnRzLlZhbHVlU2NvcGVOYW1lID0gVmFsdWVTY29wZU5hbWU7XG5jb25zdCBsaW5lID0gY29kZV8xLl8gYFxcbmA7XG5jbGFzcyBWYWx1ZVNjb3BlIGV4dGVuZHMgU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IHt9O1xuICAgICAgICB0aGlzLl9zY29wZSA9IG9wdHMuc2NvcGU7XG4gICAgICAgIHRoaXMub3B0cyA9IHsgLi4ub3B0cywgX246IG9wdHMubGluZXMgPyBsaW5lIDogY29kZV8xLm5pbCB9O1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY29wZTtcbiAgICB9XG4gICAgbmFtZShwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZVNjb3BlTmFtZShwcmVmaXgsIHRoaXMuX25ld05hbWUocHJlZml4KSk7XG4gICAgfVxuICAgIHZhbHVlKG5hbWVPclByZWZpeCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodmFsdWUucmVmID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb2RlR2VuOiByZWYgbXVzdCBiZSBwYXNzZWQgaW4gdmFsdWVcIik7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLnRvTmFtZShuYW1lT3JQcmVmaXgpO1xuICAgICAgICBjb25zdCB7IHByZWZpeCB9ID0gbmFtZTtcbiAgICAgICAgY29uc3QgdmFsdWVLZXkgPSAoX2EgPSB2YWx1ZS5rZXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbHVlLnJlZjtcbiAgICAgICAgbGV0IHZzID0gdGhpcy5fdmFsdWVzW3ByZWZpeF07XG4gICAgICAgIGlmICh2cykge1xuICAgICAgICAgICAgY29uc3QgX25hbWUgPSB2cy5nZXQodmFsdWVLZXkpO1xuICAgICAgICAgICAgaWYgKF9uYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiBfbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZzID0gdGhpcy5fdmFsdWVzW3ByZWZpeF0gPSBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdnMuc2V0KHZhbHVlS2V5LCBuYW1lKTtcbiAgICAgICAgY29uc3QgcyA9IHRoaXMuX3Njb3BlW3ByZWZpeF0gfHwgKHRoaXMuX3Njb3BlW3ByZWZpeF0gPSBbXSk7XG4gICAgICAgIGNvbnN0IGl0ZW1JbmRleCA9IHMubGVuZ3RoO1xuICAgICAgICBzW2l0ZW1JbmRleF0gPSB2YWx1ZS5yZWY7XG4gICAgICAgIG5hbWUuc2V0VmFsdWUodmFsdWUsIHsgcHJvcGVydHk6IHByZWZpeCwgaXRlbUluZGV4IH0pO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgZ2V0VmFsdWUocHJlZml4LCBrZXlPclJlZikge1xuICAgICAgICBjb25zdCB2cyA9IHRoaXMuX3ZhbHVlc1twcmVmaXhdO1xuICAgICAgICBpZiAoIXZzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gdnMuZ2V0KGtleU9yUmVmKTtcbiAgICB9XG4gICAgc2NvcGVSZWZzKHNjb3BlTmFtZSwgdmFsdWVzID0gdGhpcy5fdmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWR1Y2VWYWx1ZXModmFsdWVzLCAobmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWUuc2NvcGVQYXRoID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBuYW1lIFwiJHtuYW1lfVwiIGhhcyBubyB2YWx1ZWApO1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVfMS5fIGAke3Njb3BlTmFtZX0ke25hbWUuc2NvcGVQYXRofWA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzY29wZUNvZGUodmFsdWVzID0gdGhpcy5fdmFsdWVzLCB1c2VkVmFsdWVzLCBnZXRDb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWR1Y2VWYWx1ZXModmFsdWVzLCAobmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWUudmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IG5hbWUgXCIke25hbWV9XCIgaGFzIG5vIHZhbHVlYCk7XG4gICAgICAgICAgICByZXR1cm4gbmFtZS52YWx1ZS5jb2RlO1xuICAgICAgICB9LCB1c2VkVmFsdWVzLCBnZXRDb2RlKTtcbiAgICB9XG4gICAgX3JlZHVjZVZhbHVlcyh2YWx1ZXMsIHZhbHVlQ29kZSwgdXNlZFZhbHVlcyA9IHt9LCBnZXRDb2RlKSB7XG4gICAgICAgIGxldCBjb2RlID0gY29kZV8xLm5pbDtcbiAgICAgICAgZm9yIChjb25zdCBwcmVmaXggaW4gdmFsdWVzKSB7XG4gICAgICAgICAgICBjb25zdCB2cyA9IHZhbHVlc1twcmVmaXhdO1xuICAgICAgICAgICAgaWYgKCF2cylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVTZXQgPSAodXNlZFZhbHVlc1twcmVmaXhdID0gdXNlZFZhbHVlc1twcmVmaXhdIHx8IG5ldyBNYXAoKSk7XG4gICAgICAgICAgICB2cy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVTZXQuaGFzKG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgbmFtZVNldC5zZXQobmFtZSwgVXNlZFZhbHVlU3RhdGUuU3RhcnRlZCk7XG4gICAgICAgICAgICAgICAgbGV0IGMgPSB2YWx1ZUNvZGUobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmID0gdGhpcy5vcHRzLmVzNSA/IGV4cG9ydHMudmFyS2luZHMudmFyIDogZXhwb3J0cy52YXJLaW5kcy5jb25zdDtcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvZGVfMS5fIGAke2NvZGV9JHtkZWZ9ICR7bmFtZX0gPSAke2N9OyR7dGhpcy5vcHRzLl9ufWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChjID0gZ2V0Q29kZSA9PT0gbnVsbCB8fCBnZXRDb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZXRDb2RlKG5hbWUpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29kZV8xLl8gYCR7Y29kZX0ke2N9JHt0aGlzLm9wdHMuX259YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuYW1lU2V0LnNldChuYW1lLCBVc2VkVmFsdWVTdGF0ZS5Db21wbGV0ZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxufVxuZXhwb3J0cy5WYWx1ZVNjb3BlID0gVmFsdWVTY29wZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjb3BlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vciA9IGV4cG9ydHMuYW5kID0gZXhwb3J0cy5ub3QgPSBleHBvcnRzLkNvZGVHZW4gPSBleHBvcnRzLm9wZXJhdG9ycyA9IGV4cG9ydHMudmFyS2luZHMgPSBleHBvcnRzLlZhbHVlU2NvcGVOYW1lID0gZXhwb3J0cy5WYWx1ZVNjb3BlID0gZXhwb3J0cy5TY29wZSA9IGV4cG9ydHMuTmFtZSA9IGV4cG9ydHMucmVnZXhwQ29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZXhwb3J0cy5nZXRQcm9wZXJ0eSA9IGV4cG9ydHMubmlsID0gZXhwb3J0cy5zdHJDb25jYXQgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuXyA9IHZvaWQgMDtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuL2NvZGVcIik7XG5jb25zdCBzY29wZV8xID0gcmVxdWlyZShcIi4vc2NvcGVcIik7XG52YXIgY29kZV8yID0gcmVxdWlyZShcIi4vY29kZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5fOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuc3RyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyQ29uY2F0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuc3RyQ29uY2F0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmlsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIubmlsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0UHJvcGVydHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5nZXRQcm9wZXJ0eTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLnN0cmluZ2lmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlZ2V4cENvZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5yZWdleHBDb2RlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLk5hbWU7IH0gfSk7XG52YXIgc2NvcGVfMiA9IHJlcXVpcmUoXCIuL3Njb3BlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2NvcGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjb3BlXzIuU2NvcGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWYWx1ZVNjb3BlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY29wZV8yLlZhbHVlU2NvcGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWYWx1ZVNjb3BlTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NvcGVfMi5WYWx1ZVNjb3BlTmFtZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZhcktpbmRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY29wZV8yLnZhcktpbmRzOyB9IH0pO1xuZXhwb3J0cy5vcGVyYXRvcnMgPSB7XG4gICAgR1Q6IG5ldyBjb2RlXzEuX0NvZGUoXCI+XCIpLFxuICAgIEdURTogbmV3IGNvZGVfMS5fQ29kZShcIj49XCIpLFxuICAgIExUOiBuZXcgY29kZV8xLl9Db2RlKFwiPFwiKSxcbiAgICBMVEU6IG5ldyBjb2RlXzEuX0NvZGUoXCI8PVwiKSxcbiAgICBFUTogbmV3IGNvZGVfMS5fQ29kZShcIj09PVwiKSxcbiAgICBORVE6IG5ldyBjb2RlXzEuX0NvZGUoXCIhPT1cIiksXG4gICAgTk9UOiBuZXcgY29kZV8xLl9Db2RlKFwiIVwiKSxcbiAgICBPUjogbmV3IGNvZGVfMS5fQ29kZShcInx8XCIpLFxuICAgIEFORDogbmV3IGNvZGVfMS5fQ29kZShcIiYmXCIpLFxuICAgIEFERDogbmV3IGNvZGVfMS5fQ29kZShcIitcIiksXG59O1xuY2xhc3MgTm9kZSB7XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMoX25hbWVzLCBfY29uc3RhbnRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmNsYXNzIERlZiBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKHZhcktpbmQsIG5hbWUsIHJocykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhcktpbmQgPSB2YXJLaW5kO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnJocyA9IHJocztcbiAgICB9XG4gICAgcmVuZGVyKHsgZXM1LCBfbiB9KSB7XG4gICAgICAgIGNvbnN0IHZhcktpbmQgPSBlczUgPyBzY29wZV8xLnZhcktpbmRzLnZhciA6IHRoaXMudmFyS2luZDtcbiAgICAgICAgY29uc3QgcmhzID0gdGhpcy5yaHMgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBgID0gJHt0aGlzLnJoc31gO1xuICAgICAgICByZXR1cm4gYCR7dmFyS2luZH0gJHt0aGlzLm5hbWV9JHtyaHN9O2AgKyBfbjtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGlmICghbmFtZXNbdGhpcy5uYW1lLnN0cl0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnJocylcbiAgICAgICAgICAgIHRoaXMucmhzID0gb3B0aW1pemVFeHByKHRoaXMucmhzLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmhzIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlT3JOYW1lID8gdGhpcy5yaHMubmFtZXMgOiB7fTtcbiAgICB9XG59XG5jbGFzcyBBc3NpZ24gZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihsaHMsIHJocywgc2lkZUVmZmVjdHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5saHMgPSBsaHM7XG4gICAgICAgIHRoaXMucmhzID0gcmhzO1xuICAgICAgICB0aGlzLnNpZGVFZmZlY3RzID0gc2lkZUVmZmVjdHM7XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubGhzfSA9ICR7dGhpcy5yaHN9O2AgKyBfbjtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGlmICh0aGlzLmxocyBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lICYmICFuYW1lc1t0aGlzLmxocy5zdHJdICYmICF0aGlzLnNpZGVFZmZlY3RzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJocyA9IG9wdGltaXplRXhwcih0aGlzLnJocywgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gdGhpcy5saHMgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSA/IHt9IDogeyAuLi50aGlzLmxocy5uYW1lcyB9O1xuICAgICAgICByZXR1cm4gYWRkRXhwck5hbWVzKG5hbWVzLCB0aGlzLnJocyk7XG4gICAgfVxufVxuY2xhc3MgQXNzaWduT3AgZXh0ZW5kcyBBc3NpZ24ge1xuICAgIGNvbnN0cnVjdG9yKGxocywgb3AsIHJocywgc2lkZUVmZmVjdHMpIHtcbiAgICAgICAgc3VwZXIobGhzLCByaHMsIHNpZGVFZmZlY3RzKTtcbiAgICAgICAgdGhpcy5vcCA9IG9wO1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmxoc30gJHt0aGlzLm9wfT0gJHt0aGlzLnJoc307YCArIF9uO1xuICAgIH1cbn1cbmNsYXNzIExhYmVsIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IobGFiZWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgICB0aGlzLm5hbWVzID0ge307XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubGFiZWx9OmAgKyBfbjtcbiAgICB9XG59XG5jbGFzcyBCcmVhayBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGxhYmVsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgdGhpcy5uYW1lcyA9IHt9O1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy5sYWJlbCA/IGAgJHt0aGlzLmxhYmVsfWAgOiBcIlwiO1xuICAgICAgICByZXR1cm4gYGJyZWFrJHtsYWJlbH07YCArIF9uO1xuICAgIH1cbn1cbmNsYXNzIFRocm93IGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IoZXJyb3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgdGhyb3cgJHt0aGlzLmVycm9yfTtgICsgX247XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IubmFtZXM7XG4gICAgfVxufVxuY2xhc3MgQW55Q29kZSBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb2RlfTtgICsgX247XG4gICAgfVxuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvZGV9YCA/IHRoaXMgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICB0aGlzLmNvZGUgPSBvcHRpbWl6ZUV4cHIodGhpcy5jb2RlLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZSBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZU9yTmFtZSA/IHRoaXMuY29kZS5uYW1lcyA6IHt9O1xuICAgIH1cbn1cbmNsYXNzIFBhcmVudE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlcyA9IFtdKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXMucmVkdWNlKChjb2RlLCBuKSA9PiBjb2RlICsgbi5yZW5kZXIob3B0cyksIFwiXCIpO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICBjb25zdCB7IG5vZGVzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgY29uc3QgbiA9IG5vZGVzW2ldLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG4pKVxuICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxLCAuLi5uKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG4pXG4gICAgICAgICAgICAgICAgbm9kZXNbaV0gPSBuO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXMubGVuZ3RoID4gMCA/IHRoaXMgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBjb25zdCB7IG5vZGVzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgLy8gaXRlcmF0aW5nIGJhY2t3YXJkcyBpbXByb3ZlcyAxLXBhc3Mgb3B0aW1pemF0aW9uXG4gICAgICAgICAgICBjb25zdCBuID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAobi5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgc3VidHJhY3ROYW1lcyhuYW1lcywgbi5uYW1lcyk7XG4gICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzLmxlbmd0aCA+IDAgPyB0aGlzIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLnJlZHVjZSgobmFtZXMsIG4pID0+IGFkZE5hbWVzKG5hbWVzLCBuLm5hbWVzKSwge30pO1xuICAgIH1cbn1cbmNsYXNzIEJsb2NrTm9kZSBleHRlbmRzIFBhcmVudE5vZGUge1xuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBcIntcIiArIG9wdHMuX24gKyBzdXBlci5yZW5kZXIob3B0cykgKyBcIn1cIiArIG9wdHMuX247XG4gICAgfVxufVxuY2xhc3MgUm9vdCBleHRlbmRzIFBhcmVudE5vZGUge1xufVxuY2xhc3MgRWxzZSBleHRlbmRzIEJsb2NrTm9kZSB7XG59XG5FbHNlLmtpbmQgPSBcImVsc2VcIjtcbmNsYXNzIElmIGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25kaXRpb24sIG5vZGVzKSB7XG4gICAgICAgIHN1cGVyKG5vZGVzKTtcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIGxldCBjb2RlID0gYGlmKCR7dGhpcy5jb25kaXRpb259KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgICAgIGlmICh0aGlzLmVsc2UpXG4gICAgICAgICAgICBjb2RlICs9IFwiZWxzZSBcIiArIHRoaXMuZWxzZS5yZW5kZXIob3B0cyk7XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICBzdXBlci5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgIGNvbnN0IGNvbmQgPSB0aGlzLmNvbmRpdGlvbjtcbiAgICAgICAgaWYgKGNvbmQgPT09IHRydWUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlczsgLy8gZWxzZSBpcyBpZ25vcmVkIGhlcmVcbiAgICAgICAgbGV0IGUgPSB0aGlzLmVsc2U7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBjb25zdCBucyA9IGUub3B0aW1pemVOb2RlcygpO1xuICAgICAgICAgICAgZSA9IHRoaXMuZWxzZSA9IEFycmF5LmlzQXJyYXkobnMpID8gbmV3IEVsc2UobnMpIDogbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIGlmIChjb25kID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIElmID8gZSA6IGUubm9kZXM7XG4gICAgICAgICAgICBpZiAodGhpcy5ub2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gbmV3IElmKG5vdChjb25kKSwgZSBpbnN0YW5jZW9mIElmID8gW2VdIDogZS5ub2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmQgPT09IGZhbHNlIHx8ICF0aGlzLm5vZGVzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmVsc2UgPSAoX2EgPSB0aGlzLmVsc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICBpZiAoIShzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHx8IHRoaXMuZWxzZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gb3B0aW1pemVFeHByKHRoaXMuY29uZGl0aW9uLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBzdXBlci5uYW1lcztcbiAgICAgICAgYWRkRXhwck5hbWVzKG5hbWVzLCB0aGlzLmNvbmRpdGlvbik7XG4gICAgICAgIGlmICh0aGlzLmVsc2UpXG4gICAgICAgICAgICBhZGROYW1lcyhuYW1lcywgdGhpcy5lbHNlLm5hbWVzKTtcbiAgICAgICAgcmV0dXJuIG5hbWVzO1xuICAgIH1cbn1cbklmLmtpbmQgPSBcImlmXCI7XG5jbGFzcyBGb3IgZXh0ZW5kcyBCbG9ja05vZGUge1xufVxuRm9yLmtpbmQgPSBcImZvclwiO1xuY2xhc3MgRm9yTG9vcCBleHRlbmRzIEZvciB7XG4gICAgY29uc3RydWN0b3IoaXRlcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaXRlcmF0aW9uID0gaXRlcmF0aW9uO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gYGZvcigke3RoaXMuaXRlcmF0aW9ufSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgaWYgKCFzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLml0ZXJhdGlvbiA9IG9wdGltaXplRXhwcih0aGlzLml0ZXJhdGlvbiwgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiBhZGROYW1lcyhzdXBlci5uYW1lcywgdGhpcy5pdGVyYXRpb24ubmFtZXMpO1xuICAgIH1cbn1cbmNsYXNzIEZvclJhbmdlIGV4dGVuZHMgRm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YXJLaW5kLCBuYW1lLCBmcm9tLCB0bykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhcktpbmQgPSB2YXJLaW5kO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIGNvbnN0IHZhcktpbmQgPSBvcHRzLmVzNSA/IHNjb3BlXzEudmFyS2luZHMudmFyIDogdGhpcy52YXJLaW5kO1xuICAgICAgICBjb25zdCB7IG5hbWUsIGZyb20sIHRvIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gYGZvcigke3ZhcktpbmR9ICR7bmFtZX09JHtmcm9tfTsgJHtuYW1lfTwke3RvfTsgJHtuYW1lfSsrKWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBhZGRFeHByTmFtZXMoc3VwZXIubmFtZXMsIHRoaXMuZnJvbSk7XG4gICAgICAgIHJldHVybiBhZGRFeHByTmFtZXMobmFtZXMsIHRoaXMudG8pO1xuICAgIH1cbn1cbmNsYXNzIEZvckl0ZXIgZXh0ZW5kcyBGb3Ige1xuICAgIGNvbnN0cnVjdG9yKGxvb3AsIHZhcktpbmQsIG5hbWUsIGl0ZXJhYmxlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubG9vcCA9IGxvb3A7XG4gICAgICAgIHRoaXMudmFyS2luZCA9IHZhcktpbmQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaXRlcmFibGUgPSBpdGVyYWJsZTtcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGBmb3IoJHt0aGlzLnZhcktpbmR9ICR7dGhpcy5uYW1lfSAke3RoaXMubG9vcH0gJHt0aGlzLml0ZXJhYmxlfSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgaWYgKCFzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLml0ZXJhYmxlID0gb3B0aW1pemVFeHByKHRoaXMuaXRlcmFibGUsIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gYWRkTmFtZXMoc3VwZXIubmFtZXMsIHRoaXMuaXRlcmFibGUubmFtZXMpO1xuICAgIH1cbn1cbmNsYXNzIEZ1bmMgZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGFyZ3MsIGFzeW5jKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMuYXN5bmMgPSBhc3luYztcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgY29uc3QgX2FzeW5jID0gdGhpcy5hc3luYyA/IFwiYXN5bmMgXCIgOiBcIlwiO1xuICAgICAgICByZXR1cm4gYCR7X2FzeW5jfWZ1bmN0aW9uICR7dGhpcy5uYW1lfSgke3RoaXMuYXJnc30pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG59XG5GdW5jLmtpbmQgPSBcImZ1bmNcIjtcbmNsYXNzIFJldHVybiBleHRlbmRzIFBhcmVudE5vZGUge1xuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBcInJldHVybiBcIiArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG59XG5SZXR1cm4ua2luZCA9IFwicmV0dXJuXCI7XG5jbGFzcyBUcnkgZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIGxldCBjb2RlID0gXCJ0cnlcIiArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICAgICAgaWYgKHRoaXMuY2F0Y2gpXG4gICAgICAgICAgICBjb2RlICs9IHRoaXMuY2F0Y2gucmVuZGVyKG9wdHMpO1xuICAgICAgICBpZiAodGhpcy5maW5hbGx5KVxuICAgICAgICAgICAgY29kZSArPSB0aGlzLmZpbmFsbHkucmVuZGVyKG9wdHMpO1xuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgc3VwZXIub3B0aW1pemVOb2RlcygpO1xuICAgICAgICAoX2EgPSB0aGlzLmNhdGNoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW1pemVOb2RlcygpO1xuICAgICAgICAoX2IgPSB0aGlzLmZpbmFsbHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgKF9hID0gdGhpcy5jYXRjaCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIChfYiA9IHRoaXMuZmluYWxseSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gc3VwZXIubmFtZXM7XG4gICAgICAgIGlmICh0aGlzLmNhdGNoKVxuICAgICAgICAgICAgYWRkTmFtZXMobmFtZXMsIHRoaXMuY2F0Y2gubmFtZXMpO1xuICAgICAgICBpZiAodGhpcy5maW5hbGx5KVxuICAgICAgICAgICAgYWRkTmFtZXMobmFtZXMsIHRoaXMuZmluYWxseS5uYW1lcyk7XG4gICAgICAgIHJldHVybiBuYW1lcztcbiAgICB9XG59XG5jbGFzcyBDYXRjaCBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgY29uc3RydWN0b3IoZXJyb3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gYGNhdGNoKCR7dGhpcy5lcnJvcn0pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG59XG5DYXRjaC5raW5kID0gXCJjYXRjaFwiO1xuY2xhc3MgRmluYWxseSBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIFwiZmluYWxseVwiICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbn1cbkZpbmFsbHkua2luZCA9IFwiZmluYWxseVwiO1xuY2xhc3MgQ29kZUdlbiB7XG4gICAgY29uc3RydWN0b3IoZXh0U2NvcGUsIG9wdHMgPSB7fSkge1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fYmxvY2tTdGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5fY29uc3RhbnRzID0ge307XG4gICAgICAgIHRoaXMub3B0cyA9IHsgLi4ub3B0cywgX246IG9wdHMubGluZXMgPyBcIlxcblwiIDogXCJcIiB9O1xuICAgICAgICB0aGlzLl9leHRTY29wZSA9IGV4dFNjb3BlO1xuICAgICAgICB0aGlzLl9zY29wZSA9IG5ldyBzY29wZV8xLlNjb3BlKHsgcGFyZW50OiBleHRTY29wZSB9KTtcbiAgICAgICAgdGhpcy5fbm9kZXMgPSBbbmV3IFJvb3QoKV07XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdC5yZW5kZXIodGhpcy5vcHRzKTtcbiAgICB9XG4gICAgLy8gcmV0dXJucyB1bmlxdWUgbmFtZSBpbiB0aGUgaW50ZXJuYWwgc2NvcGVcbiAgICBuYW1lKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NvcGUubmFtZShwcmVmaXgpO1xuICAgIH1cbiAgICAvLyByZXNlcnZlcyB1bmlxdWUgbmFtZSBpbiB0aGUgZXh0ZXJuYWwgc2NvcGVcbiAgICBzY29wZU5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5uYW1lKHByZWZpeCk7XG4gICAgfVxuICAgIC8vIHJlc2VydmVzIHVuaXF1ZSBuYW1lIGluIHRoZSBleHRlcm5hbCBzY29wZSBhbmQgYXNzaWducyB2YWx1ZSB0byBpdFxuICAgIHNjb3BlVmFsdWUocHJlZml4T3JOYW1lLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fZXh0U2NvcGUudmFsdWUocHJlZml4T3JOYW1lLCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHZzID0gdGhpcy5fdmFsdWVzW25hbWUucHJlZml4XSB8fCAodGhpcy5fdmFsdWVzW25hbWUucHJlZml4XSA9IG5ldyBTZXQoKSk7XG4gICAgICAgIHZzLmFkZChuYW1lKTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIGdldFNjb3BlVmFsdWUocHJlZml4LCBrZXlPclJlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUuZ2V0VmFsdWUocHJlZml4LCBrZXlPclJlZik7XG4gICAgfVxuICAgIC8vIHJldHVybiBjb2RlIHRoYXQgYXNzaWducyB2YWx1ZXMgaW4gdGhlIGV4dGVybmFsIHNjb3BlIHRvIHRoZSBuYW1lcyB0aGF0IGFyZSB1c2VkIGludGVybmFsbHlcbiAgICAvLyAoc2FtZSBuYW1lcyB0aGF0IHdlcmUgcmV0dXJuZWQgYnkgZ2VuLnNjb3BlTmFtZSBvciBnZW4uc2NvcGVWYWx1ZSlcbiAgICBzY29wZVJlZnMoc2NvcGVOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5zY29wZVJlZnMoc2NvcGVOYW1lLCB0aGlzLl92YWx1ZXMpO1xuICAgIH1cbiAgICBzY29wZUNvZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5zY29wZUNvZGUodGhpcy5fdmFsdWVzKTtcbiAgICB9XG4gICAgX2RlZih2YXJLaW5kLCBuYW1lT3JQcmVmaXgsIHJocywgY29uc3RhbnQpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX3Njb3BlLnRvTmFtZShuYW1lT3JQcmVmaXgpO1xuICAgICAgICBpZiAocmhzICE9PSB1bmRlZmluZWQgJiYgY29uc3RhbnQpXG4gICAgICAgICAgICB0aGlzLl9jb25zdGFudHNbbmFtZS5zdHJdID0gcmhzO1xuICAgICAgICB0aGlzLl9sZWFmTm9kZShuZXcgRGVmKHZhcktpbmQsIG5hbWUsIHJocykpO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgLy8gYGNvbnN0YCBkZWNsYXJhdGlvbiAoYHZhcmAgaW4gZXM1IG1vZGUpXG4gICAgY29uc3QobmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmKHNjb3BlXzEudmFyS2luZHMuY29uc3QsIG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpO1xuICAgIH1cbiAgICAvLyBgbGV0YCBkZWNsYXJhdGlvbiB3aXRoIG9wdGlvbmFsIGFzc2lnbm1lbnQgKGB2YXJgIGluIGVzNSBtb2RlKVxuICAgIGxldChuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYoc2NvcGVfMS52YXJLaW5kcy5sZXQsIG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpO1xuICAgIH1cbiAgICAvLyBgdmFyYCBkZWNsYXJhdGlvbiB3aXRoIG9wdGlvbmFsIGFzc2lnbm1lbnRcbiAgICB2YXIobmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmKHNjb3BlXzEudmFyS2luZHMudmFyLCBuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KTtcbiAgICB9XG4gICAgLy8gYXNzaWdubWVudCBjb2RlXG4gICAgYXNzaWduKGxocywgcmhzLCBzaWRlRWZmZWN0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IEFzc2lnbihsaHMsIHJocywgc2lkZUVmZmVjdHMpKTtcbiAgICB9XG4gICAgLy8gYCs9YCBjb2RlXG4gICAgYWRkKGxocywgcmhzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgQXNzaWduT3AobGhzLCBleHBvcnRzLm9wZXJhdG9ycy5BREQsIHJocykpO1xuICAgIH1cbiAgICAvLyBhcHBlbmRzIHBhc3NlZCBTYWZlRXhwciB0byBjb2RlIG9yIGV4ZWN1dGVzIEJsb2NrXG4gICAgY29kZShjKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBjKCk7XG4gICAgICAgIGVsc2UgaWYgKGMgIT09IGNvZGVfMS5uaWwpXG4gICAgICAgICAgICB0aGlzLl9sZWFmTm9kZShuZXcgQW55Q29kZShjKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyByZXR1cm5zIGNvZGUgZm9yIG9iamVjdCBsaXRlcmFsIGZvciB0aGUgcGFzc2VkIGFyZ3VtZW50IGxpc3Qgb2Yga2V5LXZhbHVlIHBhaXJzXG4gICAgb2JqZWN0KC4uLmtleVZhbHVlcykge1xuICAgICAgICBjb25zdCBjb2RlID0gW1wie1wiXTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Yga2V5VmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAoY29kZS5sZW5ndGggPiAxKVxuICAgICAgICAgICAgICAgIGNvZGUucHVzaChcIixcIik7XG4gICAgICAgICAgICBjb2RlLnB1c2goa2V5KTtcbiAgICAgICAgICAgIGlmIChrZXkgIT09IHZhbHVlIHx8IHRoaXMub3B0cy5lczUpIHtcbiAgICAgICAgICAgICAgICBjb2RlLnB1c2goXCI6XCIpO1xuICAgICAgICAgICAgICAgIGNvZGVfMS5hZGRDb2RlQXJnKGNvZGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb2RlLnB1c2goXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbmV3IGNvZGVfMS5fQ29kZShjb2RlKTtcbiAgICB9XG4gICAgLy8gYGlmYCBjbGF1c2UgKG9yIHN0YXRlbWVudCBpZiBgdGhlbkJvZHlgIGFuZCwgb3B0aW9uYWxseSwgYGVsc2VCb2R5YCBhcmUgcGFzc2VkKVxuICAgIGlmKGNvbmRpdGlvbiwgdGhlbkJvZHksIGVsc2VCb2R5KSB7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShuZXcgSWYoY29uZGl0aW9uKSk7XG4gICAgICAgIGlmICh0aGVuQm9keSAmJiBlbHNlQm9keSkge1xuICAgICAgICAgICAgdGhpcy5jb2RlKHRoZW5Cb2R5KS5lbHNlKCkuY29kZShlbHNlQm9keSkuZW5kSWYoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGVuQm9keSkge1xuICAgICAgICAgICAgdGhpcy5jb2RlKHRoZW5Cb2R5KS5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsc2VCb2R5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwiZWxzZVwiIGJvZHkgd2l0aG91dCBcInRoZW5cIiBib2R5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGBlbHNlIGlmYCBjbGF1c2UgLSBpbnZhbGlkIHdpdGhvdXQgYGlmYCBvciBhZnRlciBgZWxzZWAgY2xhdXNlc1xuICAgIGVsc2VJZihjb25kaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vsc2VOb2RlKG5ldyBJZihjb25kaXRpb24pKTtcbiAgICB9XG4gICAgLy8gYGVsc2VgIGNsYXVzZSAtIG9ubHkgdmFsaWQgYWZ0ZXIgYGlmYCBvciBgZWxzZSBpZmAgY2xhdXNlc1xuICAgIGVsc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbHNlTm9kZShuZXcgRWxzZSgpKTtcbiAgICB9XG4gICAgLy8gZW5kIGBpZmAgc3RhdGVtZW50IChuZWVkZWQgaWYgZ2VuLmlmIHdhcyB1c2VkIG9ubHkgd2l0aCBjb25kaXRpb24pXG4gICAgZW5kSWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoSWYsIEVsc2UpO1xuICAgIH1cbiAgICBfZm9yKG5vZGUsIGZvckJvZHkpIHtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5vZGUpO1xuICAgICAgICBpZiAoZm9yQm9keSlcbiAgICAgICAgICAgIHRoaXMuY29kZShmb3JCb2R5KS5lbmRGb3IoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGEgZ2VuZXJpYyBgZm9yYCBjbGF1c2UgKG9yIHN0YXRlbWVudCBpZiBgZm9yQm9keWAgaXMgcGFzc2VkKVxuICAgIGZvcihpdGVyYXRpb24sIGZvckJvZHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9yTG9vcChpdGVyYXRpb24pLCBmb3JCb2R5KTtcbiAgICB9XG4gICAgLy8gYGZvcmAgc3RhdGVtZW50IGZvciBhIHJhbmdlIG9mIHZhbHVlc1xuICAgIGZvclJhbmdlKG5hbWVPclByZWZpeCwgZnJvbSwgdG8sIGZvckJvZHksIHZhcktpbmQgPSB0aGlzLm9wdHMuZXM1ID8gc2NvcGVfMS52YXJLaW5kcy52YXIgOiBzY29wZV8xLnZhcktpbmRzLmxldCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvclJhbmdlKHZhcktpbmQsIG5hbWUsIGZyb20sIHRvKSwgKCkgPT4gZm9yQm9keShuYW1lKSk7XG4gICAgfVxuICAgIC8vIGBmb3Itb2ZgIHN0YXRlbWVudCAoaW4gZXM1IG1vZGUgcmVwbGFjZSB3aXRoIGEgbm9ybWFsIGZvciBsb29wKVxuICAgIGZvck9mKG5hbWVPclByZWZpeCwgaXRlcmFibGUsIGZvckJvZHksIHZhcktpbmQgPSBzY29wZV8xLnZhcktpbmRzLmNvbnN0KSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5lczUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyciA9IGl0ZXJhYmxlIGluc3RhbmNlb2YgY29kZV8xLk5hbWUgPyBpdGVyYWJsZSA6IHRoaXMudmFyKFwiX2FyclwiLCBpdGVyYWJsZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JSYW5nZShcIl9pXCIsIDAsIGNvZGVfMS5fIGAke2Fycn0ubGVuZ3RoYCwgKGkpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhcihuYW1lLCBjb2RlXzEuXyBgJHthcnJ9WyR7aX1dYCk7XG4gICAgICAgICAgICAgICAgZm9yQm9keShuYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvckl0ZXIoXCJvZlwiLCB2YXJLaW5kLCBuYW1lLCBpdGVyYWJsZSksICgpID0+IGZvckJvZHkobmFtZSkpO1xuICAgIH1cbiAgICAvLyBgZm9yLWluYCBzdGF0ZW1lbnQuXG4gICAgLy8gV2l0aCBvcHRpb24gYG93blByb3BlcnRpZXNgIHJlcGxhY2VkIHdpdGggYSBgZm9yLW9mYCBsb29wIGZvciBvYmplY3Qga2V5c1xuICAgIGZvckluKG5hbWVPclByZWZpeCwgb2JqLCBmb3JCb2R5LCB2YXJLaW5kID0gdGhpcy5vcHRzLmVzNSA/IHNjb3BlXzEudmFyS2luZHMudmFyIDogc2NvcGVfMS52YXJLaW5kcy5jb25zdCkge1xuICAgICAgICBpZiAodGhpcy5vcHRzLm93blByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvck9mKG5hbWVPclByZWZpeCwgY29kZV8xLl8gYE9iamVjdC5rZXlzKCR7b2JqfSlgLCBmb3JCb2R5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvckl0ZXIoXCJpblwiLCB2YXJLaW5kLCBuYW1lLCBvYmopLCAoKSA9PiBmb3JCb2R5KG5hbWUpKTtcbiAgICB9XG4gICAgLy8gZW5kIGBmb3JgIGxvb3BcbiAgICBlbmRGb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoRm9yKTtcbiAgICB9XG4gICAgLy8gYGxhYmVsYCBzdGF0ZW1lbnRcbiAgICBsYWJlbChsYWJlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IExhYmVsKGxhYmVsKSk7XG4gICAgfVxuICAgIC8vIGBicmVha2Agc3RhdGVtZW50XG4gICAgYnJlYWsobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBCcmVhayhsYWJlbCkpO1xuICAgIH1cbiAgICAvLyBgcmV0dXJuYCBzdGF0ZW1lbnRcbiAgICByZXR1cm4odmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBSZXR1cm4oKTtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5vZGUpO1xuICAgICAgICB0aGlzLmNvZGUodmFsdWUpO1xuICAgICAgICBpZiAobm9kZS5ub2Rlcy5sZW5ndGggIT09IDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwicmV0dXJuXCIgc2hvdWxkIGhhdmUgb25lIG5vZGUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShSZXR1cm4pO1xuICAgIH1cbiAgICAvLyBgdHJ5YCBzdGF0ZW1lbnRcbiAgICB0cnkodHJ5Qm9keSwgY2F0Y2hDb2RlLCBmaW5hbGx5Q29kZSkge1xuICAgICAgICBpZiAoIWNhdGNoQ29kZSAmJiAhZmluYWxseUNvZGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwidHJ5XCIgd2l0aG91dCBcImNhdGNoXCIgYW5kIFwiZmluYWxseVwiJyk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgVHJ5KCk7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShub2RlKTtcbiAgICAgICAgdGhpcy5jb2RlKHRyeUJvZHkpO1xuICAgICAgICBpZiAoY2F0Y2hDb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMubmFtZShcImVcIik7XG4gICAgICAgICAgICB0aGlzLl9jdXJyTm9kZSA9IG5vZGUuY2F0Y2ggPSBuZXcgQ2F0Y2goZXJyb3IpO1xuICAgICAgICAgICAgY2F0Y2hDb2RlKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmluYWxseUNvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJOb2RlID0gbm9kZS5maW5hbGx5ID0gbmV3IEZpbmFsbHkoKTtcbiAgICAgICAgICAgIHRoaXMuY29kZShmaW5hbGx5Q29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShDYXRjaCwgRmluYWxseSk7XG4gICAgfVxuICAgIC8vIGB0aHJvd2Agc3RhdGVtZW50XG4gICAgdGhyb3coZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBUaHJvdyhlcnJvcikpO1xuICAgIH1cbiAgICAvLyBzdGFydCBzZWxmLWJhbGFuY2luZyBibG9ja1xuICAgIGJsb2NrKGJvZHksIG5vZGVDb3VudCkge1xuICAgICAgICB0aGlzLl9ibG9ja1N0YXJ0cy5wdXNoKHRoaXMuX25vZGVzLmxlbmd0aCk7XG4gICAgICAgIGlmIChib2R5KVxuICAgICAgICAgICAgdGhpcy5jb2RlKGJvZHkpLmVuZEJsb2NrKG5vZGVDb3VudCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBlbmQgdGhlIGN1cnJlbnQgc2VsZi1iYWxhbmNpbmcgYmxvY2tcbiAgICBlbmRCbG9jayhub2RlQ291bnQpIHtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5fYmxvY2tTdGFydHMucG9wKCk7XG4gICAgICAgIGlmIChsZW4gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvZGVHZW46IG5vdCBpbiBzZWxmLWJhbGFuY2luZyBibG9ja1wiKTtcbiAgICAgICAgY29uc3QgdG9DbG9zZSA9IHRoaXMuX25vZGVzLmxlbmd0aCAtIGxlbjtcbiAgICAgICAgaWYgKHRvQ2xvc2UgPCAwIHx8IChub2RlQ291bnQgIT09IHVuZGVmaW5lZCAmJiB0b0Nsb3NlICE9PSBub2RlQ291bnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IHdyb25nIG51bWJlciBvZiBub2RlczogJHt0b0Nsb3NlfSB2cyAke25vZGVDb3VudH0gZXhwZWN0ZWRgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ub2Rlcy5sZW5ndGggPSBsZW47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBgZnVuY3Rpb25gIGhlYWRpbmcgKG9yIGRlZmluaXRpb24gaWYgZnVuY0JvZHkgaXMgcGFzc2VkKVxuICAgIGZ1bmMobmFtZSwgYXJncyA9IGNvZGVfMS5uaWwsIGFzeW5jLCBmdW5jQm9keSkge1xuICAgICAgICB0aGlzLl9ibG9ja05vZGUobmV3IEZ1bmMobmFtZSwgYXJncywgYXN5bmMpKTtcbiAgICAgICAgaWYgKGZ1bmNCb2R5KVxuICAgICAgICAgICAgdGhpcy5jb2RlKGZ1bmNCb2R5KS5lbmRGdW5jKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBlbmQgZnVuY3Rpb24gZGVmaW5pdGlvblxuICAgIGVuZEZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoRnVuYyk7XG4gICAgfVxuICAgIG9wdGltaXplKG4gPSAxKSB7XG4gICAgICAgIHdoaWxlIChuLS0gPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yb290Lm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3Qub3B0aW1pemVOYW1lcyh0aGlzLl9yb290Lm5hbWVzLCB0aGlzLl9jb25zdGFudHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9sZWFmTm9kZShub2RlKSB7XG4gICAgICAgIHRoaXMuX2N1cnJOb2RlLm5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBfYmxvY2tOb2RlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5fY3Vyck5vZGUubm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy5fbm9kZXMucHVzaChub2RlKTtcbiAgICB9XG4gICAgX2VuZEJsb2NrTm9kZShOMSwgTjIpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX2N1cnJOb2RlO1xuICAgICAgICBpZiAobiBpbnN0YW5jZW9mIE4xIHx8IChOMiAmJiBuIGluc3RhbmNlb2YgTjIpKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2Rlcy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogbm90IGluIGJsb2NrIFwiJHtOMiA/IGAke04xLmtpbmR9LyR7TjIua2luZH1gIDogTjEua2luZH1cImApO1xuICAgIH1cbiAgICBfZWxzZU5vZGUobm9kZSkge1xuICAgICAgICBjb25zdCBuID0gdGhpcy5fY3Vyck5vZGU7XG4gICAgICAgIGlmICghKG4gaW5zdGFuY2VvZiBJZikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJlbHNlXCIgd2l0aG91dCBcImlmXCInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJyTm9kZSA9IG4uZWxzZSA9IG5vZGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgX3Jvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub2Rlc1swXTtcbiAgICB9XG4gICAgZ2V0IF9jdXJyTm9kZSgpIHtcbiAgICAgICAgY29uc3QgbnMgPSB0aGlzLl9ub2RlcztcbiAgICAgICAgcmV0dXJuIG5zW25zLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBzZXQgX2N1cnJOb2RlKG5vZGUpIHtcbiAgICAgICAgY29uc3QgbnMgPSB0aGlzLl9ub2RlcztcbiAgICAgICAgbnNbbnMubGVuZ3RoIC0gMV0gPSBub2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29kZUdlbiA9IENvZGVHZW47XG5mdW5jdGlvbiBhZGROYW1lcyhuYW1lcywgZnJvbSkge1xuICAgIGZvciAoY29uc3QgbiBpbiBmcm9tKVxuICAgICAgICBuYW1lc1tuXSA9IChuYW1lc1tuXSB8fCAwKSArIChmcm9tW25dIHx8IDApO1xuICAgIHJldHVybiBuYW1lcztcbn1cbmZ1bmN0aW9uIGFkZEV4cHJOYW1lcyhuYW1lcywgZnJvbSkge1xuICAgIHJldHVybiBmcm9tIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlT3JOYW1lID8gYWRkTmFtZXMobmFtZXMsIGZyb20ubmFtZXMpIDogbmFtZXM7XG59XG5mdW5jdGlvbiBvcHRpbWl6ZUV4cHIoZXhwciwgbmFtZXMsIGNvbnN0YW50cykge1xuICAgIGlmIChleHByIGluc3RhbmNlb2YgY29kZV8xLk5hbWUpXG4gICAgICAgIHJldHVybiByZXBsYWNlTmFtZShleHByKTtcbiAgICBpZiAoIWNhbk9wdGltaXplKGV4cHIpKVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICByZXR1cm4gbmV3IGNvZGVfMS5fQ29kZShleHByLl9pdGVtcy5yZWR1Y2UoKGl0ZW1zLCBjKSA9PiB7XG4gICAgICAgIGlmIChjIGluc3RhbmNlb2YgY29kZV8xLk5hbWUpXG4gICAgICAgICAgICBjID0gcmVwbGFjZU5hbWUoYyk7XG4gICAgICAgIGlmIChjIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlKVxuICAgICAgICAgICAgaXRlbXMucHVzaCguLi5jLl9pdGVtcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goYyk7XG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9LCBbXSkpO1xuICAgIGZ1bmN0aW9uIHJlcGxhY2VOYW1lKG4pIHtcbiAgICAgICAgY29uc3QgYyA9IGNvbnN0YW50c1tuLnN0cl07XG4gICAgICAgIGlmIChjID09PSB1bmRlZmluZWQgfHwgbmFtZXNbbi5zdHJdICE9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIGRlbGV0ZSBuYW1lc1tuLnN0cl07XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5PcHRpbWl6ZShlKSB7XG4gICAgICAgIHJldHVybiAoZSBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZSAmJlxuICAgICAgICAgICAgZS5faXRlbXMuc29tZSgoYykgPT4gYyBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lICYmIG5hbWVzW2Muc3RyXSA9PT0gMSAmJiBjb25zdGFudHNbYy5zdHJdICE9PSB1bmRlZmluZWQpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJ0cmFjdE5hbWVzKG5hbWVzLCBmcm9tKSB7XG4gICAgZm9yIChjb25zdCBuIGluIGZyb20pXG4gICAgICAgIG5hbWVzW25dID0gKG5hbWVzW25dIHx8IDApIC0gKGZyb21bbl0gfHwgMCk7XG59XG5mdW5jdGlvbiBub3QoeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PSBcImJvb2xlYW5cIiB8fCB0eXBlb2YgeCA9PSBcIm51bWJlclwiIHx8IHggPT09IG51bGwgPyAheCA6IGNvZGVfMS5fIGAhJHtwYXIoeCl9YDtcbn1cbmV4cG9ydHMubm90ID0gbm90O1xuY29uc3QgYW5kQ29kZSA9IG1hcHBlbmQoZXhwb3J0cy5vcGVyYXRvcnMuQU5EKTtcbi8vIGJvb2xlYW4gQU5EICgmJikgZXhwcmVzc2lvbiB3aXRoIHRoZSBwYXNzZWQgYXJndW1lbnRzXG5mdW5jdGlvbiBhbmQoLi4uYXJncykge1xuICAgIHJldHVybiBhcmdzLnJlZHVjZShhbmRDb2RlKTtcbn1cbmV4cG9ydHMuYW5kID0gYW5kO1xuY29uc3Qgb3JDb2RlID0gbWFwcGVuZChleHBvcnRzLm9wZXJhdG9ycy5PUik7XG4vLyBib29sZWFuIE9SICh8fCkgZXhwcmVzc2lvbiB3aXRoIHRoZSBwYXNzZWQgYXJndW1lbnRzXG5mdW5jdGlvbiBvciguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGFyZ3MucmVkdWNlKG9yQ29kZSk7XG59XG5leHBvcnRzLm9yID0gb3I7XG5mdW5jdGlvbiBtYXBwZW5kKG9wKSB7XG4gICAgcmV0dXJuICh4LCB5KSA9PiAoeCA9PT0gY29kZV8xLm5pbCA/IHkgOiB5ID09PSBjb2RlXzEubmlsID8geCA6IGNvZGVfMS5fIGAke3Bhcih4KX0gJHtvcH0gJHtwYXIoeSl9YCk7XG59XG5mdW5jdGlvbiBwYXIoeCkge1xuICAgIHJldHVybiB4IGluc3RhbmNlb2YgY29kZV8xLk5hbWUgPyB4IDogY29kZV8xLl8gYCgke3h9KWA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hlY2tTdHJpY3RNb2RlID0gZXhwb3J0cy5nZXRFcnJvclBhdGggPSBleHBvcnRzLlR5cGUgPSBleHBvcnRzLnVzZUZ1bmMgPSBleHBvcnRzLnNldEV2YWx1YXRlZCA9IGV4cG9ydHMuZXZhbHVhdGVkUHJvcHNUb05hbWUgPSBleHBvcnRzLm1lcmdlRXZhbHVhdGVkID0gZXhwb3J0cy5lYWNoSXRlbSA9IGV4cG9ydHMudW5lc2NhcGVKc29uUG9pbnRlciA9IGV4cG9ydHMuZXNjYXBlSnNvblBvaW50ZXIgPSBleHBvcnRzLmVzY2FwZUZyYWdtZW50ID0gZXhwb3J0cy51bmVzY2FwZUZyYWdtZW50ID0gZXhwb3J0cy5zY2hlbWFSZWZPclZhbCA9IGV4cG9ydHMuc2NoZW1hSGFzUnVsZXNCdXRSZWYgPSBleHBvcnRzLnNjaGVtYUhhc1J1bGVzID0gZXhwb3J0cy5jaGVja1Vua25vd25SdWxlcyA9IGV4cG9ydHMuYWx3YXlzVmFsaWRTY2hlbWEgPSBleHBvcnRzLnRvSGFzaCA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW5cIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuL2NvZGVcIik7XG4vLyBUT0RPIHJlZmFjdG9yIHRvIHVzZSBTZXRcbmZ1bmN0aW9uIHRvSGFzaChhcnIpIHtcbiAgICBjb25zdCBoYXNoID0ge307XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFycilcbiAgICAgICAgaGFzaFtpdGVtXSA9IHRydWU7XG4gICAgcmV0dXJuIGhhc2g7XG59XG5leHBvcnRzLnRvSGFzaCA9IHRvSGFzaDtcbmZ1bmN0aW9uIGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICBpZiAoT2JqZWN0LmtleXMoc2NoZW1hKS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGNoZWNrVW5rbm93blJ1bGVzKGl0LCBzY2hlbWEpO1xuICAgIHJldHVybiAhc2NoZW1hSGFzUnVsZXMoc2NoZW1hLCBpdC5zZWxmLlJVTEVTLmFsbCk7XG59XG5leHBvcnRzLmFsd2F5c1ZhbGlkU2NoZW1hID0gYWx3YXlzVmFsaWRTY2hlbWE7XG5mdW5jdGlvbiBjaGVja1Vua25vd25SdWxlcyhpdCwgc2NoZW1hID0gaXQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICBpZiAoIW9wdHMuc3RyaWN0U2NoZW1hKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgcnVsZXMgPSBzZWxmLlJVTEVTLmtleXdvcmRzO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBpZiAoIXJ1bGVzW2tleV0pXG4gICAgICAgICAgICBjaGVja1N0cmljdE1vZGUoaXQsIGB1bmtub3duIGtleXdvcmQ6IFwiJHtrZXl9XCJgKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrVW5rbm93blJ1bGVzID0gY2hlY2tVbmtub3duUnVsZXM7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlcyhzY2hlbWEsIHJ1bGVzKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiAhc2NoZW1hO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSlcbiAgICAgICAgaWYgKHJ1bGVzW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzID0gc2NoZW1hSGFzUnVsZXM7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlc0J1dFJlZihzY2hlbWEsIFJVTEVTKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiAhc2NoZW1hO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSlcbiAgICAgICAgaWYgKGtleSAhPT0gXCIkcmVmXCIgJiYgUlVMRVMuYWxsW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzQnV0UmVmID0gc2NoZW1hSGFzUnVsZXNCdXRSZWY7XG5mdW5jdGlvbiBzY2hlbWFSZWZPclZhbCh7IHRvcFNjaGVtYVJlZiwgc2NoZW1hUGF0aCB9LCBzY2hlbWEsIGtleXdvcmQsICRkYXRhKSB7XG4gICAgaWYgKCEkZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm51bWJlclwiIHx8IHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5fIGAke3NjaGVtYX1gO1xuICAgIH1cbiAgICByZXR1cm4gY29kZWdlbl8xLl8gYCR7dG9wU2NoZW1hUmVmfSR7c2NoZW1hUGF0aH0ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eShrZXl3b3JkKX1gO1xufVxuZXhwb3J0cy5zY2hlbWFSZWZPclZhbCA9IHNjaGVtYVJlZk9yVmFsO1xuZnVuY3Rpb24gdW5lc2NhcGVGcmFnbWVudChzdHIpIHtcbiAgICByZXR1cm4gdW5lc2NhcGVKc29uUG9pbnRlcihkZWNvZGVVUklDb21wb25lbnQoc3RyKSk7XG59XG5leHBvcnRzLnVuZXNjYXBlRnJhZ21lbnQgPSB1bmVzY2FwZUZyYWdtZW50O1xuZnVuY3Rpb24gZXNjYXBlRnJhZ21lbnQoc3RyKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlc2NhcGVKc29uUG9pbnRlcihzdHIpKTtcbn1cbmV4cG9ydHMuZXNjYXBlRnJhZ21lbnQgPSBlc2NhcGVGcmFnbWVudDtcbmZ1bmN0aW9uIGVzY2FwZUpzb25Qb2ludGVyKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyID09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBgJHtzdHJ9YDtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXC8vZywgXCJ+MVwiKTtcbn1cbmV4cG9ydHMuZXNjYXBlSnNvblBvaW50ZXIgPSBlc2NhcGVKc29uUG9pbnRlcjtcbmZ1bmN0aW9uIHVuZXNjYXBlSnNvblBvaW50ZXIoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+MS9nLCBcIi9cIikucmVwbGFjZSgvfjAvZywgXCJ+XCIpO1xufVxuZXhwb3J0cy51bmVzY2FwZUpzb25Qb2ludGVyID0gdW5lc2NhcGVKc29uUG9pbnRlcjtcbmZ1bmN0aW9uIGVhY2hJdGVtKHhzLCBmKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoeHMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgeCBvZiB4cylcbiAgICAgICAgICAgIGYoeCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmKHhzKTtcbiAgICB9XG59XG5leHBvcnRzLmVhY2hJdGVtID0gZWFjaEl0ZW07XG5mdW5jdGlvbiBtYWtlTWVyZ2VFdmFsdWF0ZWQoeyBtZXJnZU5hbWVzLCBtZXJnZVRvTmFtZSwgbWVyZ2VWYWx1ZXMsIHJlc3VsdFRvTmFtZSwgfSkge1xuICAgIHJldHVybiAoZ2VuLCBmcm9tLCB0bywgdG9OYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRvID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gZnJvbVxuICAgICAgICAgICAgOiB0byBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lXG4gICAgICAgICAgICAgICAgPyAoZnJvbSBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lID8gbWVyZ2VOYW1lcyhnZW4sIGZyb20sIHRvKSA6IG1lcmdlVG9OYW1lKGdlbiwgZnJvbSwgdG8pLCB0bylcbiAgICAgICAgICAgICAgICA6IGZyb20gaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZVxuICAgICAgICAgICAgICAgICAgICA/IChtZXJnZVRvTmFtZShnZW4sIHRvLCBmcm9tKSwgZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgOiBtZXJnZVZhbHVlcyhmcm9tLCB0byk7XG4gICAgICAgIHJldHVybiB0b05hbWUgPT09IGNvZGVnZW5fMS5OYW1lICYmICEocmVzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpID8gcmVzdWx0VG9OYW1lKGdlbiwgcmVzKSA6IHJlcztcbiAgICB9O1xufVxuZXhwb3J0cy5tZXJnZUV2YWx1YXRlZCA9IHtcbiAgICBwcm9wczogbWFrZU1lcmdlRXZhbHVhdGVkKHtcbiAgICAgICAgbWVyZ2VOYW1lczogKGdlbiwgZnJvbSwgdG8pID0+IGdlbi5pZihjb2RlZ2VuXzEuXyBgJHt0b30gIT09IHRydWUgJiYgJHtmcm9tfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4ge1xuICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2Zyb219ID09PSB0cnVlYCwgKCkgPT4gZ2VuLmFzc2lnbih0bywgdHJ1ZSksICgpID0+IGdlbi5hc3NpZ24odG8sIGNvZGVnZW5fMS5fIGAke3RvfSB8fCB7fWApLmNvZGUoY29kZWdlbl8xLl8gYE9iamVjdC5hc3NpZ24oJHt0b30sICR7ZnJvbX0pYCkpO1xuICAgICAgICB9KSxcbiAgICAgICAgbWVyZ2VUb05hbWU6IChnZW4sIGZyb20sIHRvKSA9PiBnZW4uaWYoY29kZWdlbl8xLl8gYCR7dG99ICE9PSB0cnVlYCwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZyb20gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHRvLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odG8sIGNvZGVnZW5fMS5fIGAke3RvfSB8fCB7fWApO1xuICAgICAgICAgICAgICAgIHNldEV2YWx1YXRlZChnZW4sIHRvLCBmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIG1lcmdlVmFsdWVzOiAoZnJvbSwgdG8pID0+IChmcm9tID09PSB0cnVlID8gdHJ1ZSA6IHsgLi4uZnJvbSwgLi4udG8gfSksXG4gICAgICAgIHJlc3VsdFRvTmFtZTogZXZhbHVhdGVkUHJvcHNUb05hbWUsXG4gICAgfSksXG4gICAgaXRlbXM6IG1ha2VNZXJnZUV2YWx1YXRlZCh7XG4gICAgICAgIG1lcmdlTmFtZXM6IChnZW4sIGZyb20sIHRvKSA9PiBnZW4uaWYoY29kZWdlbl8xLl8gYCR7dG99ICE9PSB0cnVlICYmICR7ZnJvbX0gIT09IHVuZGVmaW5lZGAsICgpID0+IGdlbi5hc3NpZ24odG8sIGNvZGVnZW5fMS5fIGAke2Zyb219ID09PSB0cnVlID8gdHJ1ZSA6ICR7dG99ID4gJHtmcm9tfSA/ICR7dG99IDogJHtmcm9tfWApKSxcbiAgICAgICAgbWVyZ2VUb05hbWU6IChnZW4sIGZyb20sIHRvKSA9PiBnZW4uaWYoY29kZWdlbl8xLl8gYCR7dG99ICE9PSB0cnVlYCwgKCkgPT4gZ2VuLmFzc2lnbih0bywgZnJvbSA9PT0gdHJ1ZSA/IHRydWUgOiBjb2RlZ2VuXzEuXyBgJHt0b30gPiAke2Zyb219ID8gJHt0b30gOiAke2Zyb219YCkpLFxuICAgICAgICBtZXJnZVZhbHVlczogKGZyb20sIHRvKSA9PiAoZnJvbSA9PT0gdHJ1ZSA/IHRydWUgOiBNYXRoLm1heChmcm9tLCB0bykpLFxuICAgICAgICByZXN1bHRUb05hbWU6IChnZW4sIGl0ZW1zKSA9PiBnZW4udmFyKFwiaXRlbXNcIiwgaXRlbXMpLFxuICAgIH0pLFxufTtcbmZ1bmN0aW9uIGV2YWx1YXRlZFByb3BzVG9OYW1lKGdlbiwgcHMpIHtcbiAgICBpZiAocHMgPT09IHRydWUpXG4gICAgICAgIHJldHVybiBnZW4udmFyKFwicHJvcHNcIiwgdHJ1ZSk7XG4gICAgY29uc3QgcHJvcHMgPSBnZW4udmFyKFwicHJvcHNcIiwgY29kZWdlbl8xLl8gYHt9YCk7XG4gICAgaWYgKHBzICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHNldEV2YWx1YXRlZChnZW4sIHByb3BzLCBwcyk7XG4gICAgcmV0dXJuIHByb3BzO1xufVxuZXhwb3J0cy5ldmFsdWF0ZWRQcm9wc1RvTmFtZSA9IGV2YWx1YXRlZFByb3BzVG9OYW1lO1xuZnVuY3Rpb24gc2V0RXZhbHVhdGVkKGdlbiwgcHJvcHMsIHBzKSB7XG4gICAgT2JqZWN0LmtleXMocHMpLmZvckVhY2goKHApID0+IGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7cHJvcHN9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkocCl9YCwgdHJ1ZSkpO1xufVxuZXhwb3J0cy5zZXRFdmFsdWF0ZWQgPSBzZXRFdmFsdWF0ZWQ7XG5jb25zdCBzbmlwcGV0cyA9IHt9O1xuZnVuY3Rpb24gdXNlRnVuYyhnZW4sIGYpIHtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJmdW5jXCIsIHtcbiAgICAgICAgcmVmOiBmLFxuICAgICAgICBjb2RlOiBzbmlwcGV0c1tmLmNvZGVdIHx8IChzbmlwcGV0c1tmLmNvZGVdID0gbmV3IGNvZGVfMS5fQ29kZShmLmNvZGUpKSxcbiAgICB9KTtcbn1cbmV4cG9ydHMudXNlRnVuYyA9IHVzZUZ1bmM7XG52YXIgVHlwZTtcbihmdW5jdGlvbiAoVHlwZSkge1xuICAgIFR5cGVbVHlwZVtcIk51bVwiXSA9IDBdID0gXCJOdW1cIjtcbiAgICBUeXBlW1R5cGVbXCJTdHJcIl0gPSAxXSA9IFwiU3RyXCI7XG59KShUeXBlID0gZXhwb3J0cy5UeXBlIHx8IChleHBvcnRzLlR5cGUgPSB7fSkpO1xuZnVuY3Rpb24gZ2V0RXJyb3JQYXRoKGRhdGFQcm9wLCBkYXRhUHJvcFR5cGUsIGpzUHJvcGVydHlTeW50YXgpIHtcbiAgICAvLyBsZXQgcGF0aFxuICAgIGlmIChkYXRhUHJvcCBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKSB7XG4gICAgICAgIGNvbnN0IGlzTnVtYmVyID0gZGF0YVByb3BUeXBlID09PSBUeXBlLk51bTtcbiAgICAgICAgcmV0dXJuIGpzUHJvcGVydHlTeW50YXhcbiAgICAgICAgICAgID8gaXNOdW1iZXJcbiAgICAgICAgICAgICAgICA/IGNvZGVnZW5fMS5fIGBcIltcIiArICR7ZGF0YVByb3B9ICsgXCJdXCJgXG4gICAgICAgICAgICAgICAgOiBjb2RlZ2VuXzEuXyBgXCJbJ1wiICsgJHtkYXRhUHJvcH0gKyBcIiddXCJgXG4gICAgICAgICAgICA6IGlzTnVtYmVyXG4gICAgICAgICAgICAgICAgPyBjb2RlZ2VuXzEuXyBgXCIvXCIgKyAke2RhdGFQcm9wfWBcbiAgICAgICAgICAgICAgICA6IGNvZGVnZW5fMS5fIGBcIi9cIiArICR7ZGF0YVByb3B9LnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXFxcLy9nLCBcIn4xXCIpYDsgLy8gVE9ETyBtYXliZSB1c2UgZ2xvYmFsIGVzY2FwZVBvaW50ZXJcbiAgICB9XG4gICAgcmV0dXJuIGpzUHJvcGVydHlTeW50YXggPyBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkoZGF0YVByb3ApLnRvU3RyaW5nKCkgOiBcIi9cIiArIGVzY2FwZUpzb25Qb2ludGVyKGRhdGFQcm9wKTtcbn1cbmV4cG9ydHMuZ2V0RXJyb3JQYXRoID0gZ2V0RXJyb3JQYXRoO1xuZnVuY3Rpb24gY2hlY2tTdHJpY3RNb2RlKGl0LCBtc2csIG1vZGUgPSBpdC5vcHRzLnN0cmljdFNjaGVtYSkge1xuICAgIGlmICghbW9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIG1zZyA9IGBzdHJpY3QgbW9kZTogJHttc2d9YDtcbiAgICBpZiAobW9kZSA9PT0gdHJ1ZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgaXQuc2VsZi5sb2dnZXIud2Fybihtc2cpO1xufVxuZXhwb3J0cy5jaGVja1N0cmljdE1vZGUgPSBjaGVja1N0cmljdE1vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4vY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzID0ge1xuICAgIC8vIHZhbGlkYXRpb24gZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgZGF0YTogbmV3IGNvZGVnZW5fMS5OYW1lKFwiZGF0YVwiKSxcbiAgICAvLyBhcmdzIHBhc3NlZCBmcm9tIHJlZmVyZW5jaW5nIHNjaGVtYVxuICAgIHZhbEN4dDogbmV3IGNvZGVnZW5fMS5OYW1lKFwidmFsQ3h0XCIpLFxuICAgIGluc3RhbmNlUGF0aDogbmV3IGNvZGVnZW5fMS5OYW1lKFwiaW5zdGFuY2VQYXRoXCIpLFxuICAgIHBhcmVudERhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmVudERhdGFcIiksXG4gICAgcGFyZW50RGF0YVByb3BlcnR5OiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwYXJlbnREYXRhUHJvcGVydHlcIiksXG4gICAgcm9vdERhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInJvb3REYXRhXCIpLFxuICAgIGR5bmFtaWNBbmNob3JzOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJkeW5hbWljQW5jaG9yc1wiKSxcbiAgICAvLyBmdW5jdGlvbiBzY29wZWQgdmFyaWFibGVzXG4gICAgdkVycm9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwidkVycm9yc1wiKSxcbiAgICBlcnJvcnM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImVycm9yc1wiKSxcbiAgICB0aGlzOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJ0aGlzXCIpLFxuICAgIC8vIFwiZ2xvYmFsc1wiXG4gICAgc2VsZjogbmV3IGNvZGVnZW5fMS5OYW1lKFwic2VsZlwiKSxcbiAgICBzY29wZTogbmV3IGNvZGVnZW5fMS5OYW1lKFwic2NvcGVcIiksXG4gICAgLy8gSlREIHNlcmlhbGl6ZS9wYXJzZSBuYW1lIGZvciBKU09OIHN0cmluZyBhbmQgcG9zaXRpb25cbiAgICBqc29uOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJqc29uXCIpLFxuICAgIGpzb25Qb3M6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImpzb25Qb3NcIiksXG4gICAganNvbkxlbjogbmV3IGNvZGVnZW5fMS5OYW1lKFwianNvbkxlblwiKSxcbiAgICBqc29uUGFydDogbmV3IGNvZGVnZW5fMS5OYW1lKFwianNvblBhcnRcIiksXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gbmFtZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYW1lcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0ZW5kRXJyb3JzID0gZXhwb3J0cy5yZXNldEVycm9yc0NvdW50ID0gZXhwb3J0cy5yZXBvcnRFeHRyYUVycm9yID0gZXhwb3J0cy5yZXBvcnRFcnJvciA9IGV4cG9ydHMua2V5d29yZCREYXRhRXJyb3IgPSBleHBvcnRzLmtleXdvcmRFcnJvciA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuL25hbWVzXCIpO1xuZXhwb3J0cy5rZXl3b3JkRXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsga2V5d29yZCB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBtdXN0IHBhc3MgXCIke2tleXdvcmR9XCIga2V5d29yZCB2YWxpZGF0aW9uYCxcbn07XG5leHBvcnRzLmtleXdvcmQkRGF0YUVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQsIHNjaGVtYVR5cGUgfSkgPT4gc2NoZW1hVHlwZVxuICAgICAgICA/IGNvZGVnZW5fMS5zdHIgYFwiJHtrZXl3b3JkfVwiIGtleXdvcmQgbXVzdCBiZSAke3NjaGVtYVR5cGV9ICgkZGF0YSlgXG4gICAgICAgIDogY29kZWdlbl8xLnN0ciBgXCIke2tleXdvcmR9XCIga2V5d29yZCBpcyBpbnZhbGlkICgkZGF0YSlgLFxufTtcbmZ1bmN0aW9uIHJlcG9ydEVycm9yKGN4dCwgZXJyb3IgPSBleHBvcnRzLmtleXdvcmRFcnJvciwgZXJyb3JQYXRocywgb3ZlcnJpZGVBbGxFcnJvcnMpIHtcbiAgICBjb25zdCB7IGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgeyBnZW4sIGNvbXBvc2l0ZVJ1bGUsIGFsbEVycm9ycyB9ID0gaXQ7XG4gICAgY29uc3QgZXJyT2JqID0gZXJyb3JPYmplY3RDb2RlKGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpO1xuICAgIGlmIChvdmVycmlkZUFsbEVycm9ycyAhPT0gbnVsbCAmJiBvdmVycmlkZUFsbEVycm9ycyAhPT0gdm9pZCAwID8gb3ZlcnJpZGVBbGxFcnJvcnMgOiAoY29tcG9zaXRlUnVsZSB8fCBhbGxFcnJvcnMpKSB7XG4gICAgICAgIGFkZEVycm9yKGdlbiwgZXJyT2JqKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybkVycm9ycyhpdCwgY29kZWdlbl8xLl8gYFske2Vyck9ian1dYCk7XG4gICAgfVxufVxuZXhwb3J0cy5yZXBvcnRFcnJvciA9IHJlcG9ydEVycm9yO1xuZnVuY3Rpb24gcmVwb3J0RXh0cmFFcnJvcihjeHQsIGVycm9yID0gZXhwb3J0cy5rZXl3b3JkRXJyb3IsIGVycm9yUGF0aHMpIHtcbiAgICBjb25zdCB7IGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgeyBnZW4sIGNvbXBvc2l0ZVJ1bGUsIGFsbEVycm9ycyB9ID0gaXQ7XG4gICAgY29uc3QgZXJyT2JqID0gZXJyb3JPYmplY3RDb2RlKGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpO1xuICAgIGFkZEVycm9yKGdlbiwgZXJyT2JqKTtcbiAgICBpZiAoIShjb21wb3NpdGVSdWxlIHx8IGFsbEVycm9ycykpIHtcbiAgICAgICAgcmV0dXJuRXJyb3JzKGl0LCBuYW1lc18xLmRlZmF1bHQudkVycm9ycyk7XG4gICAgfVxufVxuZXhwb3J0cy5yZXBvcnRFeHRyYUVycm9yID0gcmVwb3J0RXh0cmFFcnJvcjtcbmZ1bmN0aW9uIHJlc2V0RXJyb3JzQ291bnQoZ2VuLCBlcnJzQ291bnQpIHtcbiAgICBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsIGVycnNDb3VudCk7XG4gICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfSAhPT0gbnVsbGAsICgpID0+IGdlbi5pZihlcnJzQ291bnQsICgpID0+IGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9Lmxlbmd0aGAsIGVycnNDb3VudCksICgpID0+IGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIG51bGwpKSk7XG59XG5leHBvcnRzLnJlc2V0RXJyb3JzQ291bnQgPSByZXNldEVycm9yc0NvdW50O1xuZnVuY3Rpb24gZXh0ZW5kRXJyb3JzKHsgZ2VuLCBrZXl3b3JkLCBzY2hlbWFWYWx1ZSwgZGF0YSwgZXJyc0NvdW50LCBpdCwgfSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChlcnJzQ291bnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgIGNvbnN0IGVyciA9IGdlbi5uYW1lKFwiZXJyXCIpO1xuICAgIGdlbi5mb3JSYW5nZShcImlcIiwgZXJyc0NvdW50LCBuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCAoaSkgPT4ge1xuICAgICAgICBnZW4uY29uc3QoZXJyLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc31bJHtpfV1gKTtcbiAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2Vycn0uaW5zdGFuY2VQYXRoID09PSB1bmRlZmluZWRgLCAoKSA9PiBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke2Vycn0uaW5zdGFuY2VQYXRoYCwgY29kZWdlbl8xLnN0ckNvbmNhdChuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBpdC5lcnJvclBhdGgpKSk7XG4gICAgICAgIGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7ZXJyfS5zY2hlbWFQYXRoYCwgY29kZWdlbl8xLnN0ciBgJHtpdC5lcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9YCk7XG4gICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7ZXJyfS5zY2hlbWFgLCBzY2hlbWFWYWx1ZSk7XG4gICAgICAgICAgICBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke2Vycn0uZGF0YWAsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLmV4dGVuZEVycm9ycyA9IGV4dGVuZEVycm9ycztcbmZ1bmN0aW9uIGFkZEVycm9yKGdlbiwgZXJyT2JqKSB7XG4gICAgY29uc3QgZXJyID0gZ2VuLmNvbnN0KFwiZXJyXCIsIGVyck9iaik7XG4gICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfSA9PT0gbnVsbGAsICgpID0+IGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIGNvZGVnZW5fMS5fIGBbJHtlcnJ9XWApLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30ucHVzaCgke2Vycn0pYCk7XG4gICAgZ2VuLmNvZGUoY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc30rK2ApO1xufVxuZnVuY3Rpb24gcmV0dXJuRXJyb3JzKGl0LCBlcnJzKSB7XG4gICAgY29uc3QgeyBnZW4sIHZhbGlkYXRlTmFtZSwgc2NoZW1hRW52IH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hRW52LiRhc3luYykge1xuICAgICAgICBnZW4udGhyb3coY29kZWdlbl8xLl8gYG5ldyAke2l0LlZhbGlkYXRpb25FcnJvcn0oJHtlcnJzfSlgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7dmFsaWRhdGVOYW1lfS5lcnJvcnNgLCBlcnJzKTtcbiAgICAgICAgZ2VuLnJldHVybihmYWxzZSk7XG4gICAgfVxufVxuY29uc3QgRSA9IHtcbiAgICBrZXl3b3JkOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJrZXl3b3JkXCIpLFxuICAgIHNjaGVtYVBhdGg6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNjaGVtYVBhdGhcIiksXG4gICAgcGFyYW1zOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwYXJhbXNcIiksXG4gICAgcHJvcGVydHlOYW1lOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwcm9wZXJ0eU5hbWVcIiksXG4gICAgbWVzc2FnZTogbmV3IGNvZGVnZW5fMS5OYW1lKFwibWVzc2FnZVwiKSxcbiAgICBzY2hlbWE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNjaGVtYVwiKSxcbiAgICBwYXJlbnRTY2hlbWE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmVudFNjaGVtYVwiKSxcbn07XG5mdW5jdGlvbiBlcnJvck9iamVjdENvZGUoY3h0LCBlcnJvciwgZXJyb3JQYXRocykge1xuICAgIGNvbnN0IHsgY3JlYXRlRXJyb3JzIH0gPSBjeHQuaXQ7XG4gICAgaWYgKGNyZWF0ZUVycm9ycyA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybiBjb2RlZ2VuXzEuXyBge31gO1xuICAgIHJldHVybiBlcnJvck9iamVjdChjeHQsIGVycm9yLCBlcnJvclBhdGhzKTtcbn1cbmZ1bmN0aW9uIGVycm9yT2JqZWN0KGN4dCwgZXJyb3IsIGVycm9yUGF0aHMgPSB7fSkge1xuICAgIGNvbnN0IHsgZ2VuLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IGtleVZhbHVlcyA9IFtcbiAgICAgICAgZXJyb3JJbnN0YW5jZVBhdGgoaXQsIGVycm9yUGF0aHMpLFxuICAgICAgICBlcnJvclNjaGVtYVBhdGgoY3h0LCBlcnJvclBhdGhzKSxcbiAgICBdO1xuICAgIGV4dHJhRXJyb3JQcm9wcyhjeHQsIGVycm9yLCBrZXlWYWx1ZXMpO1xuICAgIHJldHVybiBnZW4ub2JqZWN0KC4uLmtleVZhbHVlcyk7XG59XG5mdW5jdGlvbiBlcnJvckluc3RhbmNlUGF0aCh7IGVycm9yUGF0aCB9LCB7IGluc3RhbmNlUGF0aCB9KSB7XG4gICAgY29uc3QgaW5zdFBhdGggPSBpbnN0YW5jZVBhdGhcbiAgICAgICAgPyBjb2RlZ2VuXzEuc3RyIGAke2Vycm9yUGF0aH0ke3V0aWxfMS5nZXRFcnJvclBhdGgoaW5zdGFuY2VQYXRoLCB1dGlsXzEuVHlwZS5TdHIpfWBcbiAgICAgICAgOiBlcnJvclBhdGg7XG4gICAgcmV0dXJuIFtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBjb2RlZ2VuXzEuc3RyQ29uY2F0KG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsIGluc3RQYXRoKV07XG59XG5mdW5jdGlvbiBlcnJvclNjaGVtYVBhdGgoeyBrZXl3b3JkLCBpdDogeyBlcnJTY2hlbWFQYXRoIH0gfSwgeyBzY2hlbWFQYXRoLCBwYXJlbnRTY2hlbWEgfSkge1xuICAgIGxldCBzY2hQYXRoID0gcGFyZW50U2NoZW1hID8gZXJyU2NoZW1hUGF0aCA6IGNvZGVnZW5fMS5zdHIgYCR7ZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWA7XG4gICAgaWYgKHNjaGVtYVBhdGgpIHtcbiAgICAgICAgc2NoUGF0aCA9IGNvZGVnZW5fMS5zdHIgYCR7c2NoUGF0aH0ke3V0aWxfMS5nZXRFcnJvclBhdGgoc2NoZW1hUGF0aCwgdXRpbF8xLlR5cGUuU3RyKX1gO1xuICAgIH1cbiAgICByZXR1cm4gW0Uuc2NoZW1hUGF0aCwgc2NoUGF0aF07XG59XG5mdW5jdGlvbiBleHRyYUVycm9yUHJvcHMoY3h0LCB7IHBhcmFtcywgbWVzc2FnZSB9LCBrZXlWYWx1ZXMpIHtcbiAgICBjb25zdCB7IGtleXdvcmQsIGRhdGEsIHNjaGVtYVZhbHVlLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHsgb3B0cywgcHJvcGVydHlOYW1lLCB0b3BTY2hlbWFSZWYsIHNjaGVtYVBhdGggfSA9IGl0O1xuICAgIGtleVZhbHVlcy5wdXNoKFtFLmtleXdvcmQsIGtleXdvcmRdLCBbRS5wYXJhbXMsIHR5cGVvZiBwYXJhbXMgPT0gXCJmdW5jdGlvblwiID8gcGFyYW1zKGN4dCkgOiBwYXJhbXMgfHwgY29kZWdlbl8xLl8gYHt9YF0pO1xuICAgIGlmIChvcHRzLm1lc3NhZ2VzKSB7XG4gICAgICAgIGtleVZhbHVlcy5wdXNoKFtFLm1lc3NhZ2UsIHR5cGVvZiBtZXNzYWdlID09IFwiZnVuY3Rpb25cIiA/IG1lc3NhZ2UoY3h0KSA6IG1lc3NhZ2VdKTtcbiAgICB9XG4gICAgaWYgKG9wdHMudmVyYm9zZSkge1xuICAgICAgICBrZXlWYWx1ZXMucHVzaChbRS5zY2hlbWEsIHNjaGVtYVZhbHVlXSwgW0UucGFyZW50U2NoZW1hLCBjb2RlZ2VuXzEuXyBgJHt0b3BTY2hlbWFSZWZ9JHtzY2hlbWFQYXRofWBdLCBbbmFtZXNfMS5kZWZhdWx0LmRhdGEsIGRhdGFdKTtcbiAgICB9XG4gICAgaWYgKHByb3BlcnR5TmFtZSlcbiAgICAgICAga2V5VmFsdWVzLnB1c2goW0UucHJvcGVydHlOYW1lLCBwcm9wZXJ0eU5hbWVdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYm9vbE9yRW1wdHlTY2hlbWEgPSBleHBvcnRzLnRvcEJvb2xPckVtcHR5U2NoZW1hID0gdm9pZCAwO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uL25hbWVzXCIpO1xuY29uc3QgYm9vbEVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwiYm9vbGVhbiBzY2hlbWEgaXMgZmFsc2VcIixcbn07XG5mdW5jdGlvbiB0b3BCb29sT3JFbXB0eVNjaGVtYShpdCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHZhbGlkYXRlTmFtZSB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZmFsc2VTY2hlbWFFcnJvcihpdCwgZmFsc2UpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgc2NoZW1hLiRhc3luYyA9PT0gdHJ1ZSkge1xuICAgICAgICBnZW4ucmV0dXJuKG5hbWVzXzEuZGVmYXVsdC5kYXRhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7dmFsaWRhdGVOYW1lfS5lcnJvcnNgLCBudWxsKTtcbiAgICAgICAgZ2VuLnJldHVybih0cnVlKTtcbiAgICB9XG59XG5leHBvcnRzLnRvcEJvb2xPckVtcHR5U2NoZW1hID0gdG9wQm9vbE9yRW1wdHlTY2hlbWE7XG5mdW5jdGlvbiBib29sT3JFbXB0eVNjaGVtYShpdCwgdmFsaWQpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICBnZW4udmFyKHZhbGlkLCBmYWxzZSk7IC8vIFRPRE8gdmFyXG4gICAgICAgIGZhbHNlU2NoZW1hRXJyb3IoaXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2VuLnZhcih2YWxpZCwgdHJ1ZSk7IC8vIFRPRE8gdmFyXG4gICAgfVxufVxuZXhwb3J0cy5ib29sT3JFbXB0eVNjaGVtYSA9IGJvb2xPckVtcHR5U2NoZW1hO1xuZnVuY3Rpb24gZmFsc2VTY2hlbWFFcnJvcihpdCwgb3ZlcnJpZGVBbGxFcnJvcnMpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSB9ID0gaXQ7XG4gICAgLy8gVE9ETyBtYXliZSBzb21lIG90aGVyIGludGVyZmFjZSBzaG91bGQgYmUgdXNlZCBmb3Igbm9uLWtleXdvcmQgdmFsaWRhdGlvbiBlcnJvcnMuLi5cbiAgICBjb25zdCBjeHQgPSB7XG4gICAgICAgIGdlbixcbiAgICAgICAga2V5d29yZDogXCJmYWxzZSBzY2hlbWFcIixcbiAgICAgICAgZGF0YSxcbiAgICAgICAgc2NoZW1hOiBmYWxzZSxcbiAgICAgICAgc2NoZW1hQ29kZTogZmFsc2UsXG4gICAgICAgIHNjaGVtYVZhbHVlOiBmYWxzZSxcbiAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgaXQsXG4gICAgfTtcbiAgICBlcnJvcnNfMS5yZXBvcnRFcnJvcihjeHQsIGJvb2xFcnJvciwgdW5kZWZpbmVkLCBvdmVycmlkZUFsbEVycm9ycyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib29sU2NoZW1hLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRSdWxlcyA9IGV4cG9ydHMuaXNKU09OVHlwZSA9IHZvaWQgMDtcbmNvbnN0IF9qc29uVHlwZXMgPSBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJpbnRlZ2VyXCIsIFwiYm9vbGVhblwiLCBcIm51bGxcIiwgXCJvYmplY3RcIiwgXCJhcnJheVwiXTtcbmNvbnN0IGpzb25UeXBlcyA9IG5ldyBTZXQoX2pzb25UeXBlcyk7XG5mdW5jdGlvbiBpc0pTT05UeXBlKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT0gXCJzdHJpbmdcIiAmJiBqc29uVHlwZXMuaGFzKHgpO1xufVxuZXhwb3J0cy5pc0pTT05UeXBlID0gaXNKU09OVHlwZTtcbmZ1bmN0aW9uIGdldFJ1bGVzKCkge1xuICAgIGNvbnN0IGdyb3VwcyA9IHtcbiAgICAgICAgbnVtYmVyOiB7IHR5cGU6IFwibnVtYmVyXCIsIHJ1bGVzOiBbXSB9LFxuICAgICAgICBzdHJpbmc6IHsgdHlwZTogXCJzdHJpbmdcIiwgcnVsZXM6IFtdIH0sXG4gICAgICAgIGFycmF5OiB7IHR5cGU6IFwiYXJyYXlcIiwgcnVsZXM6IFtdIH0sXG4gICAgICAgIG9iamVjdDogeyB0eXBlOiBcIm9iamVjdFwiLCBydWxlczogW10gfSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVzOiB7IC4uLmdyb3VwcywgaW50ZWdlcjogdHJ1ZSwgYm9vbGVhbjogdHJ1ZSwgbnVsbDogdHJ1ZSB9LFxuICAgICAgICBydWxlczogW3sgcnVsZXM6IFtdIH0sIGdyb3Vwcy5udW1iZXIsIGdyb3Vwcy5zdHJpbmcsIGdyb3Vwcy5hcnJheSwgZ3JvdXBzLm9iamVjdF0sXG4gICAgICAgIHBvc3Q6IHsgcnVsZXM6IFtdIH0sXG4gICAgICAgIGFsbDoge30sXG4gICAgICAgIGtleXdvcmRzOiB7fSxcbiAgICB9O1xufVxuZXhwb3J0cy5nZXRSdWxlcyA9IGdldFJ1bGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnVsZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNob3VsZFVzZVJ1bGUgPSBleHBvcnRzLnNob3VsZFVzZUdyb3VwID0gZXhwb3J0cy5zY2hlbWFIYXNSdWxlc0ZvclR5cGUgPSB2b2lkIDA7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlc0ZvclR5cGUoeyBzY2hlbWEsIHNlbGYgfSwgdHlwZSkge1xuICAgIGNvbnN0IGdyb3VwID0gc2VsZi5SVUxFUy50eXBlc1t0eXBlXTtcbiAgICByZXR1cm4gZ3JvdXAgJiYgZ3JvdXAgIT09IHRydWUgJiYgc2hvdWxkVXNlR3JvdXAoc2NoZW1hLCBncm91cCk7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzRm9yVHlwZSA9IHNjaGVtYUhhc1J1bGVzRm9yVHlwZTtcbmZ1bmN0aW9uIHNob3VsZFVzZUdyb3VwKHNjaGVtYSwgZ3JvdXApIHtcbiAgICByZXR1cm4gZ3JvdXAucnVsZXMuc29tZSgocnVsZSkgPT4gc2hvdWxkVXNlUnVsZShzY2hlbWEsIHJ1bGUpKTtcbn1cbmV4cG9ydHMuc2hvdWxkVXNlR3JvdXAgPSBzaG91bGRVc2VHcm91cDtcbmZ1bmN0aW9uIHNob3VsZFVzZVJ1bGUoc2NoZW1hLCBydWxlKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoc2NoZW1hW3J1bGUua2V5d29yZF0gIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAoKF9hID0gcnVsZS5kZWZpbml0aW9uLmltcGxlbWVudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKChrd2QpID0+IHNjaGVtYVtrd2RdICE9PSB1bmRlZmluZWQpKSk7XG59XG5leHBvcnRzLnNob3VsZFVzZVJ1bGUgPSBzaG91bGRVc2VSdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwbGljYWJpbGl0eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVwb3J0VHlwZUVycm9yID0gZXhwb3J0cy5jaGVja0RhdGFUeXBlcyA9IGV4cG9ydHMuY2hlY2tEYXRhVHlwZSA9IGV4cG9ydHMuY29lcmNlQW5kQ2hlY2tEYXRhVHlwZSA9IGV4cG9ydHMuZ2V0SlNPTlR5cGVzID0gZXhwb3J0cy5nZXRTY2hlbWFUeXBlcyA9IGV4cG9ydHMuRGF0YVR5cGUgPSB2b2lkIDA7XG5jb25zdCBydWxlc18xID0gcmVxdWlyZShcIi4uL3J1bGVzXCIpO1xuY29uc3QgYXBwbGljYWJpbGl0eV8xID0gcmVxdWlyZShcIi4vYXBwbGljYWJpbGl0eVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgRGF0YVR5cGU7XG4oZnVuY3Rpb24gKERhdGFUeXBlKSB7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJDb3JyZWN0XCJdID0gMF0gPSBcIkNvcnJlY3RcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIldyb25nXCJdID0gMV0gPSBcIldyb25nXCI7XG59KShEYXRhVHlwZSA9IGV4cG9ydHMuRGF0YVR5cGUgfHwgKGV4cG9ydHMuRGF0YVR5cGUgPSB7fSkpO1xuZnVuY3Rpb24gZ2V0U2NoZW1hVHlwZXMoc2NoZW1hKSB7XG4gICAgY29uc3QgdHlwZXMgPSBnZXRKU09OVHlwZXMoc2NoZW1hLnR5cGUpO1xuICAgIGNvbnN0IGhhc051bGwgPSB0eXBlcy5pbmNsdWRlcyhcIm51bGxcIik7XG4gICAgaWYgKGhhc051bGwpIHtcbiAgICAgICAgaWYgKHNjaGVtYS5udWxsYWJsZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0eXBlOiBudWxsIGNvbnRyYWRpY3RzIG51bGxhYmxlOiBmYWxzZVwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghdHlwZXMubGVuZ3RoICYmIHNjaGVtYS5udWxsYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibnVsbGFibGVcIiBjYW5ub3QgYmUgdXNlZCB3aXRob3V0IFwidHlwZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5udWxsYWJsZSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHR5cGVzLnB1c2goXCJudWxsXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZXM7XG59XG5leHBvcnRzLmdldFNjaGVtYVR5cGVzID0gZ2V0U2NoZW1hVHlwZXM7XG5mdW5jdGlvbiBnZXRKU09OVHlwZXModHMpIHtcbiAgICBjb25zdCB0eXBlcyA9IEFycmF5LmlzQXJyYXkodHMpID8gdHMgOiB0cyA/IFt0c10gOiBbXTtcbiAgICBpZiAodHlwZXMuZXZlcnkocnVsZXNfMS5pc0pTT05UeXBlKSlcbiAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIHRocm93IG5ldyBFcnJvcihcInR5cGUgbXVzdCBiZSBKU09OVHlwZSBvciBKU09OVHlwZVtdOiBcIiArIHR5cGVzLmpvaW4oXCIsXCIpKTtcbn1cbmV4cG9ydHMuZ2V0SlNPTlR5cGVzID0gZ2V0SlNPTlR5cGVzO1xuZnVuY3Rpb24gY29lcmNlQW5kQ2hlY2tEYXRhVHlwZShpdCwgdHlwZXMpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgb3B0cyB9ID0gaXQ7XG4gICAgY29uc3QgY29lcmNlVG8gPSBjb2VyY2VUb1R5cGVzKHR5cGVzLCBvcHRzLmNvZXJjZVR5cGVzKTtcbiAgICBjb25zdCBjaGVja1R5cGVzID0gdHlwZXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAhKGNvZXJjZVRvLmxlbmd0aCA9PT0gMCAmJiB0eXBlcy5sZW5ndGggPT09IDEgJiYgYXBwbGljYWJpbGl0eV8xLnNjaGVtYUhhc1J1bGVzRm9yVHlwZShpdCwgdHlwZXNbMF0pKTtcbiAgICBpZiAoY2hlY2tUeXBlcykge1xuICAgICAgICBjb25zdCB3cm9uZ1R5cGUgPSBjaGVja0RhdGFUeXBlcyh0eXBlcywgZGF0YSwgb3B0cy5zdHJpY3ROdW1iZXJzLCBEYXRhVHlwZS5Xcm9uZyk7XG4gICAgICAgIGdlbi5pZih3cm9uZ1R5cGUsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChjb2VyY2VUby5sZW5ndGgpXG4gICAgICAgICAgICAgICAgY29lcmNlRGF0YShpdCwgdHlwZXMsIGNvZXJjZVRvKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXBvcnRUeXBlRXJyb3IoaXQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNoZWNrVHlwZXM7XG59XG5leHBvcnRzLmNvZXJjZUFuZENoZWNrRGF0YVR5cGUgPSBjb2VyY2VBbmRDaGVja0RhdGFUeXBlO1xuY29uc3QgQ09FUkNJQkxFID0gbmV3IFNldChbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJpbnRlZ2VyXCIsIFwiYm9vbGVhblwiLCBcIm51bGxcIl0pO1xuZnVuY3Rpb24gY29lcmNlVG9UeXBlcyh0eXBlcywgY29lcmNlVHlwZXMpIHtcbiAgICByZXR1cm4gY29lcmNlVHlwZXNcbiAgICAgICAgPyB0eXBlcy5maWx0ZXIoKHQpID0+IENPRVJDSUJMRS5oYXModCkgfHwgKGNvZXJjZVR5cGVzID09PSBcImFycmF5XCIgJiYgdCA9PT0gXCJhcnJheVwiKSlcbiAgICAgICAgOiBbXTtcbn1cbmZ1bmN0aW9uIGNvZXJjZURhdGEoaXQsIHR5cGVzLCBjb2VyY2VUbykge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBvcHRzIH0gPSBpdDtcbiAgICBjb25zdCBkYXRhVHlwZSA9IGdlbi5sZXQoXCJkYXRhVHlwZVwiLCBjb2RlZ2VuXzEuXyBgdHlwZW9mICR7ZGF0YX1gKTtcbiAgICBjb25zdCBjb2VyY2VkID0gZ2VuLmxldChcImNvZXJjZWRcIiwgY29kZWdlbl8xLl8gYHVuZGVmaW5lZGApO1xuICAgIGlmIChvcHRzLmNvZXJjZVR5cGVzID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2RhdGFUeXBlfSA9PSAnb2JqZWN0JyAmJiBBcnJheS5pc0FycmF5KCR7ZGF0YX0pICYmICR7ZGF0YX0ubGVuZ3RoID09IDFgLCAoKSA9PiBnZW5cbiAgICAgICAgICAgIC5hc3NpZ24oZGF0YSwgY29kZWdlbl8xLl8gYCR7ZGF0YX1bMF1gKVxuICAgICAgICAgICAgLmFzc2lnbihkYXRhVHlwZSwgY29kZWdlbl8xLl8gYHR5cGVvZiAke2RhdGF9YClcbiAgICAgICAgICAgIC5pZihjaGVja0RhdGFUeXBlcyh0eXBlcywgZGF0YSwgb3B0cy5zdHJpY3ROdW1iZXJzKSwgKCkgPT4gZ2VuLmFzc2lnbihjb2VyY2VkLCBkYXRhKSkpO1xuICAgIH1cbiAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7Y29lcmNlZH0gIT09IHVuZGVmaW5lZGApO1xuICAgIGZvciAoY29uc3QgdCBvZiBjb2VyY2VUbykge1xuICAgICAgICBpZiAoQ09FUkNJQkxFLmhhcyh0KSB8fCAodCA9PT0gXCJhcnJheVwiICYmIG9wdHMuY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIikpIHtcbiAgICAgICAgICAgIGNvZXJjZVNwZWNpZmljVHlwZSh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZW4uZWxzZSgpO1xuICAgIHJlcG9ydFR5cGVFcnJvcihpdCk7XG4gICAgZ2VuLmVuZElmKCk7XG4gICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2NvZXJjZWR9ICE9PSB1bmRlZmluZWRgLCAoKSA9PiB7XG4gICAgICAgIGdlbi5hc3NpZ24oZGF0YSwgY29lcmNlZCk7XG4gICAgICAgIGFzc2lnblBhcmVudERhdGEoaXQsIGNvZXJjZWQpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGNvZXJjZVNwZWNpZmljVHlwZSh0KSB7XG4gICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKGNvZGVnZW5fMS5fIGAke2RhdGFUeXBlfSA9PSBcIm51bWJlclwiIHx8ICR7ZGF0YVR5cGV9ID09IFwiYm9vbGVhblwiYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBjb2RlZ2VuXzEuXyBgXCJcIiArICR7ZGF0YX1gKVxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKGNvZGVnZW5fMS5fIGAke2RhdGF9ID09PSBudWxsYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBjb2RlZ2VuXzEuXyBgXCJcImApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZihjb2RlZ2VuXzEuXyBgJHtkYXRhVHlwZX0gPT0gXCJib29sZWFuXCIgfHwgJHtkYXRhfSA9PT0gbnVsbFxuICAgICAgICAgICAgICB8fCAoJHtkYXRhVHlwZX0gPT0gXCJzdHJpbmdcIiAmJiAke2RhdGF9ICYmICR7ZGF0YX0gPT0gKyR7ZGF0YX0pYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBjb2RlZ2VuXzEuXyBgKyR7ZGF0YX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiaW50ZWdlclwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKGNvZGVnZW5fMS5fIGAke2RhdGFUeXBlfSA9PT0gXCJib29sZWFuXCIgfHwgJHtkYXRhfSA9PT0gbnVsbFxuICAgICAgICAgICAgICB8fCAoJHtkYXRhVHlwZX0gPT09IFwic3RyaW5nXCIgJiYgJHtkYXRhfSAmJiAke2RhdGF9ID09ICske2RhdGF9ICYmICEoJHtkYXRhfSAlIDEpKWApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgY29kZWdlbl8xLl8gYCske2RhdGF9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZihjb2RlZ2VuXzEuXyBgJHtkYXRhfSA9PT0gXCJmYWxzZVwiIHx8ICR7ZGF0YX0gPT09IDAgfHwgJHtkYXRhfSA9PT0gbnVsbGApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoY29kZWdlbl8xLl8gYCR7ZGF0YX0gPT09IFwidHJ1ZVwiIHx8ICR7ZGF0YX0gPT09IDFgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICAgICAgZ2VuLmVsc2VJZihjb2RlZ2VuXzEuXyBgJHtkYXRhfSA9PT0gXCJcIiB8fCAke2RhdGF9ID09PSAwIHx8ICR7ZGF0YX0gPT09IGZhbHNlYCk7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihjb2VyY2VkLCBudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZihjb2RlZ2VuXzEuXyBgJHtkYXRhVHlwZX0gPT09IFwic3RyaW5nXCIgfHwgJHtkYXRhVHlwZX0gPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgfHwgJHtkYXRhVHlwZX0gPT09IFwiYm9vbGVhblwiIHx8ICR7ZGF0YX0gPT09IG51bGxgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIGNvZGVnZW5fMS5fIGBbJHtkYXRhfV1gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2lnblBhcmVudERhdGEoeyBnZW4sIHBhcmVudERhdGEsIHBhcmVudERhdGFQcm9wZXJ0eSB9LCBleHByKSB7XG4gICAgLy8gVE9ETyB1c2UgZ2VuLnByb3BlcnR5XG4gICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke3BhcmVudERhdGF9ICE9PSB1bmRlZmluZWRgLCAoKSA9PiBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke3BhcmVudERhdGF9WyR7cGFyZW50RGF0YVByb3BlcnR5fV1gLCBleHByKSk7XG59XG5mdW5jdGlvbiBjaGVja0RhdGFUeXBlKGRhdGFUeXBlLCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0ID0gRGF0YVR5cGUuQ29ycmVjdCkge1xuICAgIGNvbnN0IEVRID0gY29ycmVjdCA9PT0gRGF0YVR5cGUuQ29ycmVjdCA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuRVEgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLk5FUTtcbiAgICBsZXQgY29uZDtcbiAgICBzd2l0Y2ggKGRhdGFUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLl8gYCR7ZGF0YX0gJHtFUX0gbnVsbGA7XG4gICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgY29uZCA9IGNvZGVnZW5fMS5fIGBBcnJheS5pc0FycmF5KCR7ZGF0YX0pYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICBjb25kID0gY29kZWdlbl8xLl8gYCR7ZGF0YX0gJiYgdHlwZW9mICR7ZGF0YX0gPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSgke2RhdGF9KWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImludGVnZXJcIjpcbiAgICAgICAgICAgIGNvbmQgPSBudW1Db25kKGNvZGVnZW5fMS5fIGAhKCR7ZGF0YX0gJSAxKSAmJiAhaXNOYU4oJHtkYXRhfSlgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBjb25kID0gbnVtQ29uZCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLl8gYHR5cGVvZiAke2RhdGF9ICR7RVF9ICR7ZGF0YVR5cGV9YDtcbiAgICB9XG4gICAgcmV0dXJuIGNvcnJlY3QgPT09IERhdGFUeXBlLkNvcnJlY3QgPyBjb25kIDogY29kZWdlbl8xLm5vdChjb25kKTtcbiAgICBmdW5jdGlvbiBudW1Db25kKF9jb25kID0gY29kZWdlbl8xLm5pbCkge1xuICAgICAgICByZXR1cm4gY29kZWdlbl8xLmFuZChjb2RlZ2VuXzEuXyBgdHlwZW9mICR7ZGF0YX0gPT0gXCJudW1iZXJcImAsIF9jb25kLCBzdHJpY3ROdW1zID8gY29kZWdlbl8xLl8gYGlzRmluaXRlKCR7ZGF0YX0pYCA6IGNvZGVnZW5fMS5uaWwpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tEYXRhVHlwZSA9IGNoZWNrRGF0YVR5cGU7XG5mdW5jdGlvbiBjaGVja0RhdGFUeXBlcyhkYXRhVHlwZXMsIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QpIHtcbiAgICBpZiAoZGF0YVR5cGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gY2hlY2tEYXRhVHlwZShkYXRhVHlwZXNbMF0sIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QpO1xuICAgIH1cbiAgICBsZXQgY29uZDtcbiAgICBjb25zdCB0eXBlcyA9IHV0aWxfMS50b0hhc2goZGF0YVR5cGVzKTtcbiAgICBpZiAodHlwZXMuYXJyYXkgJiYgdHlwZXMub2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG5vdE9iaiA9IGNvZGVnZW5fMS5fIGB0eXBlb2YgJHtkYXRhfSAhPSBcIm9iamVjdFwiYDtcbiAgICAgICAgY29uZCA9IHR5cGVzLm51bGwgPyBub3RPYmogOiBjb2RlZ2VuXzEuXyBgISR7ZGF0YX0gfHwgJHtub3RPYmp9YDtcbiAgICAgICAgZGVsZXRlIHR5cGVzLm51bGw7XG4gICAgICAgIGRlbGV0ZSB0eXBlcy5hcnJheTtcbiAgICAgICAgZGVsZXRlIHR5cGVzLm9iamVjdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbmQgPSBjb2RlZ2VuXzEubmlsO1xuICAgIH1cbiAgICBpZiAodHlwZXMubnVtYmVyKVxuICAgICAgICBkZWxldGUgdHlwZXMuaW50ZWdlcjtcbiAgICBmb3IgKGNvbnN0IHQgaW4gdHlwZXMpXG4gICAgICAgIGNvbmQgPSBjb2RlZ2VuXzEuYW5kKGNvbmQsIGNoZWNrRGF0YVR5cGUodCwgZGF0YSwgc3RyaWN0TnVtcywgY29ycmVjdCkpO1xuICAgIHJldHVybiBjb25kO1xufVxuZXhwb3J0cy5jaGVja0RhdGFUeXBlcyA9IGNoZWNrRGF0YVR5cGVzO1xuY29uc3QgdHlwZUVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHNjaGVtYSB9KSA9PiBgbXVzdCBiZSAke3NjaGVtYX1gLFxuICAgIHBhcmFtczogKHsgc2NoZW1hLCBzY2hlbWFWYWx1ZSB9KSA9PiB0eXBlb2Ygc2NoZW1hID09IFwic3RyaW5nXCIgPyBjb2RlZ2VuXzEuXyBge3R5cGU6ICR7c2NoZW1hfX1gIDogY29kZWdlbl8xLl8gYHt0eXBlOiAke3NjaGVtYVZhbHVlfX1gLFxufTtcbmZ1bmN0aW9uIHJlcG9ydFR5cGVFcnJvcihpdCkge1xuICAgIGNvbnN0IGN4dCA9IGdldFR5cGVFcnJvckNvbnRleHQoaXQpO1xuICAgIGVycm9yc18xLnJlcG9ydEVycm9yKGN4dCwgdHlwZUVycm9yKTtcbn1cbmV4cG9ydHMucmVwb3J0VHlwZUVycm9yID0gcmVwb3J0VHlwZUVycm9yO1xuZnVuY3Rpb24gZ2V0VHlwZUVycm9yQ29udGV4dChpdCkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWEgfSA9IGl0O1xuICAgIGNvbnN0IHNjaGVtYUNvZGUgPSB1dGlsXzEuc2NoZW1hUmVmT3JWYWwoaXQsIHNjaGVtYSwgXCJ0eXBlXCIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGdlbixcbiAgICAgICAga2V5d29yZDogXCJ0eXBlXCIsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hLnR5cGUsXG4gICAgICAgIHNjaGVtYUNvZGUsXG4gICAgICAgIHNjaGVtYVZhbHVlOiBzY2hlbWFDb2RlLFxuICAgICAgICBwYXJlbnRTY2hlbWE6IHNjaGVtYSxcbiAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgaXQsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGFUeXBlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3NpZ25EZWZhdWx0cyA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5mdW5jdGlvbiBhc3NpZ25EZWZhdWx0cyhpdCwgdHkpIHtcbiAgICBjb25zdCB7IHByb3BlcnRpZXMsIGl0ZW1zIH0gPSBpdC5zY2hlbWE7XG4gICAgaWYgKHR5ID09PSBcIm9iamVjdFwiICYmIHByb3BlcnRpZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgYXNzaWduRGVmYXVsdChpdCwga2V5LCBwcm9wZXJ0aWVzW2tleV0uZGVmYXVsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHkgPT09IFwiYXJyYXlcIiAmJiBBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICBpdGVtcy5mb3JFYWNoKChzY2gsIGkpID0+IGFzc2lnbkRlZmF1bHQoaXQsIGksIHNjaC5kZWZhdWx0KSk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NpZ25EZWZhdWx0cyA9IGFzc2lnbkRlZmF1bHRzO1xuZnVuY3Rpb24gYXNzaWduRGVmYXVsdChpdCwgcHJvcCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgY29uc3QgeyBnZW4sIGNvbXBvc2l0ZVJ1bGUsIGRhdGEsIG9wdHMgfSA9IGl0O1xuICAgIGlmIChkZWZhdWx0VmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGNoaWxkRGF0YSA9IGNvZGVnZW5fMS5fIGAke2RhdGF9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkocHJvcCl9YDtcbiAgICBpZiAoY29tcG9zaXRlUnVsZSkge1xuICAgICAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCBgZGVmYXVsdCBpcyBpZ25vcmVkIGZvcjogJHtjaGlsZERhdGF9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGNvbmRpdGlvbiA9IGNvZGVnZW5fMS5fIGAke2NoaWxkRGF0YX0gPT09IHVuZGVmaW5lZGA7XG4gICAgaWYgKG9wdHMudXNlRGVmYXVsdHMgPT09IFwiZW1wdHlcIikge1xuICAgICAgICBjb25kaXRpb24gPSBjb2RlZ2VuXzEuXyBgJHtjb25kaXRpb259IHx8ICR7Y2hpbGREYXRhfSA9PT0gbnVsbCB8fCAke2NoaWxkRGF0YX0gPT09IFwiXCJgO1xuICAgIH1cbiAgICAvLyBgJHtjaGlsZERhdGF9ID09PSB1bmRlZmluZWRgICtcbiAgICAvLyAob3B0cy51c2VEZWZhdWx0cyA9PT0gXCJlbXB0eVwiID8gYCB8fCAke2NoaWxkRGF0YX0gPT09IG51bGwgfHwgJHtjaGlsZERhdGF9ID09PSBcIlwiYCA6IFwiXCIpXG4gICAgZ2VuLmlmKGNvbmRpdGlvbiwgY29kZWdlbl8xLl8gYCR7Y2hpbGREYXRhfSA9ICR7Y29kZWdlbl8xLnN0cmluZ2lmeShkZWZhdWx0VmFsdWUpfWApO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlVW5pb24gPSBleHBvcnRzLnZhbGlkYXRlQXJyYXkgPSBleHBvcnRzLnVzZVBhdHRlcm4gPSBleHBvcnRzLmNhbGxWYWxpZGF0ZUNvZGUgPSBleHBvcnRzLnNjaGVtYVByb3BlcnRpZXMgPSBleHBvcnRzLmFsbFNjaGVtYVByb3BlcnRpZXMgPSBleHBvcnRzLm5vUHJvcGVydHlJbkRhdGEgPSBleHBvcnRzLnByb3BlcnR5SW5EYXRhID0gZXhwb3J0cy5pc093blByb3BlcnR5ID0gZXhwb3J0cy5oYXNQcm9wRnVuYyA9IGV4cG9ydHMucmVwb3J0TWlzc2luZ1Byb3AgPSBleHBvcnRzLmNoZWNrTWlzc2luZ1Byb3AgPSBleHBvcnRzLmNoZWNrUmVwb3J0TWlzc2luZ1Byb3AgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vY29tcGlsZS9uYW1lc1wiKTtcbmZ1bmN0aW9uIGNoZWNrUmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBwcm9wKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgZ2VuLmlmKG5vUHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpLCAoKSA9PiB7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBtaXNzaW5nUHJvcGVydHk6IGNvZGVnZW5fMS5fIGAke3Byb3B9YCB9LCB0cnVlKTtcbiAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmNoZWNrUmVwb3J0TWlzc2luZ1Byb3AgPSBjaGVja1JlcG9ydE1pc3NpbmdQcm9wO1xuZnVuY3Rpb24gY2hlY2tNaXNzaW5nUHJvcCh7IGdlbiwgZGF0YSwgaXQ6IHsgb3B0cyB9IH0sIHByb3BlcnRpZXMsIG1pc3NpbmcpIHtcbiAgICByZXR1cm4gY29kZWdlbl8xLm9yKC4uLnByb3BlcnRpZXMubWFwKChwcm9wKSA9PiBjb2RlZ2VuXzEuYW5kKG5vUHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBvcHRzLm93blByb3BlcnRpZXMpLCBjb2RlZ2VuXzEuXyBgJHttaXNzaW5nfSA9ICR7cHJvcH1gKSkpO1xufVxuZXhwb3J0cy5jaGVja01pc3NpbmdQcm9wID0gY2hlY2tNaXNzaW5nUHJvcDtcbmZ1bmN0aW9uIHJlcG9ydE1pc3NpbmdQcm9wKGN4dCwgbWlzc2luZykge1xuICAgIGN4dC5zZXRQYXJhbXMoeyBtaXNzaW5nUHJvcGVydHk6IG1pc3NpbmcgfSwgdHJ1ZSk7XG4gICAgY3h0LmVycm9yKCk7XG59XG5leHBvcnRzLnJlcG9ydE1pc3NpbmdQcm9wID0gcmVwb3J0TWlzc2luZ1Byb3A7XG5mdW5jdGlvbiBoYXNQcm9wRnVuYyhnZW4pIHtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJmdW5jXCIsIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICByZWY6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICAgIGNvZGU6IGNvZGVnZW5fMS5fIGBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5YCxcbiAgICB9KTtcbn1cbmV4cG9ydHMuaGFzUHJvcEZ1bmMgPSBoYXNQcm9wRnVuYztcbmZ1bmN0aW9uIGlzT3duUHJvcGVydHkoZ2VuLCBkYXRhLCBwcm9wZXJ0eSkge1xuICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgJHtoYXNQcm9wRnVuYyhnZW4pfS5jYWxsKCR7ZGF0YX0sICR7cHJvcGVydHl9KWA7XG59XG5leHBvcnRzLmlzT3duUHJvcGVydHkgPSBpc093blByb3BlcnR5O1xuZnVuY3Rpb24gcHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wZXJ0eSwgb3duUHJvcGVydGllcykge1xuICAgIGNvbnN0IGNvbmQgPSBjb2RlZ2VuXzEuXyBgJHtkYXRhfSR7Y29kZWdlbl8xLmdldFByb3BlcnR5KHByb3BlcnR5KX0gIT09IHVuZGVmaW5lZGA7XG4gICAgcmV0dXJuIG93blByb3BlcnRpZXMgPyBjb2RlZ2VuXzEuXyBgJHtjb25kfSAmJiAke2lzT3duUHJvcGVydHkoZ2VuLCBkYXRhLCBwcm9wZXJ0eSl9YCA6IGNvbmQ7XG59XG5leHBvcnRzLnByb3BlcnR5SW5EYXRhID0gcHJvcGVydHlJbkRhdGE7XG5mdW5jdGlvbiBub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcGVydHksIG93blByb3BlcnRpZXMpIHtcbiAgICBjb25zdCBjb25kID0gY29kZWdlbl8xLl8gYCR7ZGF0YX0ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eShwcm9wZXJ0eSl9ID09PSB1bmRlZmluZWRgO1xuICAgIHJldHVybiBvd25Qcm9wZXJ0aWVzID8gY29kZWdlbl8xLm9yKGNvbmQsIGNvZGVnZW5fMS5ub3QoaXNPd25Qcm9wZXJ0eShnZW4sIGRhdGEsIHByb3BlcnR5KSkpIDogY29uZDtcbn1cbmV4cG9ydHMubm9Qcm9wZXJ0eUluRGF0YSA9IG5vUHJvcGVydHlJbkRhdGE7XG5mdW5jdGlvbiBhbGxTY2hlbWFQcm9wZXJ0aWVzKHNjaGVtYU1hcCkge1xuICAgIHJldHVybiBzY2hlbWFNYXAgPyBPYmplY3Qua2V5cyhzY2hlbWFNYXApLmZpbHRlcigocCkgPT4gcCAhPT0gXCJfX3Byb3RvX19cIikgOiBbXTtcbn1cbmV4cG9ydHMuYWxsU2NoZW1hUHJvcGVydGllcyA9IGFsbFNjaGVtYVByb3BlcnRpZXM7XG5mdW5jdGlvbiBzY2hlbWFQcm9wZXJ0aWVzKGl0LCBzY2hlbWFNYXApIHtcbiAgICByZXR1cm4gYWxsU2NoZW1hUHJvcGVydGllcyhzY2hlbWFNYXApLmZpbHRlcigocCkgPT4gIXV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hTWFwW3BdKSk7XG59XG5leHBvcnRzLnNjaGVtYVByb3BlcnRpZXMgPSBzY2hlbWFQcm9wZXJ0aWVzO1xuZnVuY3Rpb24gY2FsbFZhbGlkYXRlQ29kZSh7IHNjaGVtYUNvZGUsIGRhdGEsIGl0OiB7IGdlbiwgdG9wU2NoZW1hUmVmLCBzY2hlbWFQYXRoLCBlcnJvclBhdGggfSwgaXQgfSwgZnVuYywgY29udGV4dCwgcGFzc1NjaGVtYSkge1xuICAgIGNvbnN0IGRhdGFBbmRTY2hlbWEgPSBwYXNzU2NoZW1hID8gY29kZWdlbl8xLl8gYCR7c2NoZW1hQ29kZX0sICR7ZGF0YX0sICR7dG9wU2NoZW1hUmVmfSR7c2NoZW1hUGF0aH1gIDogZGF0YTtcbiAgICBjb25zdCB2YWxDeHQgPSBbXG4gICAgICAgIFtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBjb2RlZ2VuXzEuc3RyQ29uY2F0KG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsIGVycm9yUGF0aCldLFxuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGEsIGl0LnBhcmVudERhdGFdLFxuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSwgaXQucGFyZW50RGF0YVByb3BlcnR5XSxcbiAgICAgICAgW25hbWVzXzEuZGVmYXVsdC5yb290RGF0YSwgbmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhXSxcbiAgICBdO1xuICAgIGlmIChpdC5vcHRzLmR5bmFtaWNSZWYpXG4gICAgICAgIHZhbEN4dC5wdXNoKFtuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnMsIG5hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9yc10pO1xuICAgIGNvbnN0IGFyZ3MgPSBjb2RlZ2VuXzEuXyBgJHtkYXRhQW5kU2NoZW1hfSwgJHtnZW4ub2JqZWN0KC4uLnZhbEN4dCl9YDtcbiAgICByZXR1cm4gY29udGV4dCAhPT0gY29kZWdlbl8xLm5pbCA/IGNvZGVnZW5fMS5fIGAke2Z1bmN9LmNhbGwoJHtjb250ZXh0fSwgJHthcmdzfSlgIDogY29kZWdlbl8xLl8gYCR7ZnVuY30oJHthcmdzfSlgO1xufVxuZXhwb3J0cy5jYWxsVmFsaWRhdGVDb2RlID0gY2FsbFZhbGlkYXRlQ29kZTtcbmZ1bmN0aW9uIHVzZVBhdHRlcm4oeyBnZW4sIGl0OiB7IG9wdHMgfSB9LCBwYXR0ZXJuKSB7XG4gICAgY29uc3QgdSA9IG9wdHMudW5pY29kZVJlZ0V4cCA/IFwidVwiIDogXCJcIjtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJwYXR0ZXJuXCIsIHtcbiAgICAgICAga2V5OiBwYXR0ZXJuLFxuICAgICAgICByZWY6IG5ldyBSZWdFeHAocGF0dGVybiwgdSksXG4gICAgICAgIGNvZGU6IGNvZGVnZW5fMS5fIGBuZXcgUmVnRXhwKCR7cGF0dGVybn0sICR7dX0pYCxcbiAgICB9KTtcbn1cbmV4cG9ydHMudXNlUGF0dGVybiA9IHVzZVBhdHRlcm47XG5mdW5jdGlvbiB2YWxpZGF0ZUFycmF5KGN4dCkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICBpZiAoaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkQXJyID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpO1xuICAgICAgICB2YWxpZGF0ZUl0ZW1zKCgpID0+IGdlbi5hc3NpZ24odmFsaWRBcnIsIGZhbHNlKSk7XG4gICAgICAgIHJldHVybiB2YWxpZEFycjtcbiAgICB9XG4gICAgZ2VuLnZhcih2YWxpZCwgdHJ1ZSk7XG4gICAgdmFsaWRhdGVJdGVtcygoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgcmV0dXJuIHZhbGlkO1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXMobm90VmFsaWQpIHtcbiAgICAgICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsIGNvZGVnZW5fMS5fIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgICAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIDAsIGxlbiwgKGkpID0+IHtcbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgICAgICAgZGF0YVByb3A6IGksXG4gICAgICAgICAgICAgICAgZGF0YVByb3BUeXBlOiB1dGlsXzEuVHlwZS5OdW0sXG4gICAgICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLm5vdCh2YWxpZCksIG5vdFZhbGlkKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUFycmF5ID0gdmFsaWRhdGVBcnJheTtcbmZ1bmN0aW9uIHZhbGlkYXRlVW5pb24oY3h0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgIGNvbnN0IGFsd2F5c1ZhbGlkID0gc2NoZW1hLnNvbWUoKHNjaCkgPT4gdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2gpKTtcbiAgICBpZiAoYWx3YXlzVmFsaWQgJiYgIWl0Lm9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCBmYWxzZSk7XG4gICAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKTtcbiAgICBnZW4uYmxvY2soKCkgPT4gc2NoZW1hLmZvckVhY2goKF9zY2gsIGkpID0+IHtcbiAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgICAgc2NoZW1hUHJvcDogaSxcbiAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgIH0sIHNjaFZhbGlkKTtcbiAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgY29kZWdlbl8xLl8gYCR7dmFsaWR9IHx8ICR7c2NoVmFsaWR9YCk7XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IGN4dC5tZXJnZVZhbGlkRXZhbHVhdGVkKHNjaEN4dCwgc2NoVmFsaWQpO1xuICAgICAgICAvLyBjYW4gc2hvcnQtY2lyY3VpdCBpZiBgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzL0l0ZW1zYCBub3Qgc3VwcG9ydGVkIChvcHRzLnVuZXZhbHVhdGVkICE9PSB0cnVlKVxuICAgICAgICAvLyBvciBpZiBhbGwgcHJvcGVydGllcyBhbmQgaXRlbXMgd2VyZSBldmFsdWF0ZWQgKGl0LnByb3BzID09PSB0cnVlICYmIGl0Lml0ZW1zID09PSB0cnVlKVxuICAgICAgICBpZiAoIW1lcmdlZClcbiAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEubm90KHZhbGlkKSk7XG4gICAgfSkpO1xuICAgIGN4dC5yZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xufVxuZXhwb3J0cy52YWxpZGF0ZVVuaW9uID0gdmFsaWRhdGVVbmlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlS2V5d29yZFVzYWdlID0gZXhwb3J0cy52YWxpZFNjaGVtYVR5cGUgPSBleHBvcnRzLmZ1bmNLZXl3b3JkQ29kZSA9IGV4cG9ydHMubWFjcm9LZXl3b3JkQ29kZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi9uYW1lc1wiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi8uLi92b2NhYnVsYXJpZXMvY29kZVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmZ1bmN0aW9uIG1hY3JvS2V5d29yZENvZGUoY3h0LCBkZWYpIHtcbiAgICBjb25zdCB7IGdlbiwga2V5d29yZCwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgbWFjcm9TY2hlbWEgPSBkZWYubWFjcm8uY2FsbChpdC5zZWxmLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQpO1xuICAgIGNvbnN0IHNjaGVtYVJlZiA9IHVzZUtleXdvcmQoZ2VuLCBrZXl3b3JkLCBtYWNyb1NjaGVtYSk7XG4gICAgaWYgKGl0Lm9wdHMudmFsaWRhdGVTY2hlbWEgIT09IGZhbHNlKVxuICAgICAgICBpdC5zZWxmLnZhbGlkYXRlU2NoZW1hKG1hY3JvU2NoZW1hLCB0cnVlKTtcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgIHNjaGVtYTogbWFjcm9TY2hlbWEsXG4gICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5uaWwsXG4gICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gLFxuICAgICAgICB0b3BTY2hlbWFSZWY6IHNjaGVtYVJlZixcbiAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICB9LCB2YWxpZCk7XG4gICAgY3h0LnBhc3ModmFsaWQsICgpID0+IGN4dC5lcnJvcih0cnVlKSk7XG59XG5leHBvcnRzLm1hY3JvS2V5d29yZENvZGUgPSBtYWNyb0tleXdvcmRDb2RlO1xuZnVuY3Rpb24gZnVuY0tleXdvcmRDb2RlKGN4dCwgZGVmKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgZ2VuLCBrZXl3b3JkLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgJGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgY2hlY2tBc3luY0tleXdvcmQoaXQsIGRlZik7XG4gICAgY29uc3QgdmFsaWRhdGUgPSAhJGRhdGEgJiYgZGVmLmNvbXBpbGUgPyBkZWYuY29tcGlsZS5jYWxsKGl0LnNlbGYsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCkgOiBkZWYudmFsaWRhdGU7XG4gICAgY29uc3QgdmFsaWRhdGVSZWYgPSB1c2VLZXl3b3JkKGdlbiwga2V5d29yZCwgdmFsaWRhdGUpO1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCB2YWxpZGF0ZUtleXdvcmQpO1xuICAgIGN4dC5vaygoX2EgPSBkZWYudmFsaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbGlkKTtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUtleXdvcmQoKSB7XG4gICAgICAgIGlmIChkZWYuZXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYXNzaWduVmFsaWQoKTtcbiAgICAgICAgICAgIGlmIChkZWYubW9kaWZ5aW5nKVxuICAgICAgICAgICAgICAgIG1vZGlmeURhdGEoY3h0KTtcbiAgICAgICAgICAgIHJlcG9ydEVycnMoKCkgPT4gY3h0LmVycm9yKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcnVsZUVycnMgPSBkZWYuYXN5bmMgPyB2YWxpZGF0ZUFzeW5jKCkgOiB2YWxpZGF0ZVN5bmMoKTtcbiAgICAgICAgICAgIGlmIChkZWYubW9kaWZ5aW5nKVxuICAgICAgICAgICAgICAgIG1vZGlmeURhdGEoY3h0KTtcbiAgICAgICAgICAgIHJlcG9ydEVycnMoKCkgPT4gYWRkRXJycyhjeHQsIHJ1bGVFcnJzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVBc3luYygpIHtcbiAgICAgICAgY29uc3QgcnVsZUVycnMgPSBnZW4ubGV0KFwicnVsZUVycnNcIiwgbnVsbCk7XG4gICAgICAgIGdlbi50cnkoKCkgPT4gYXNzaWduVmFsaWQoY29kZWdlbl8xLl8gYGF3YWl0IGApLCAoZSkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmlmKGNvZGVnZW5fMS5fIGAke2V9IGluc3RhbmNlb2YgJHtpdC5WYWxpZGF0aW9uRXJyb3J9YCwgKCkgPT4gZ2VuLmFzc2lnbihydWxlRXJycywgY29kZWdlbl8xLl8gYCR7ZX0uZXJyb3JzYCksICgpID0+IGdlbi50aHJvdyhlKSkpO1xuICAgICAgICByZXR1cm4gcnVsZUVycnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU3luYygpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVFcnJzID0gY29kZWdlbl8xLl8gYCR7dmFsaWRhdGVSZWZ9LmVycm9yc2A7XG4gICAgICAgIGdlbi5hc3NpZ24odmFsaWRhdGVFcnJzLCBudWxsKTtcbiAgICAgICAgYXNzaWduVmFsaWQoY29kZWdlbl8xLm5pbCk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZUVycnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2lnblZhbGlkKF9hd2FpdCA9IGRlZi5hc3luYyA/IGNvZGVnZW5fMS5fIGBhd2FpdCBgIDogY29kZWdlbl8xLm5pbCkge1xuICAgICAgICBjb25zdCBwYXNzQ3h0ID0gaXQub3B0cy5wYXNzQ29udGV4dCA/IG5hbWVzXzEuZGVmYXVsdC50aGlzIDogbmFtZXNfMS5kZWZhdWx0LnNlbGY7XG4gICAgICAgIGNvbnN0IHBhc3NTY2hlbWEgPSAhKChcImNvbXBpbGVcIiBpbiBkZWYgJiYgISRkYXRhKSB8fCBkZWYuc2NoZW1hID09PSBmYWxzZSk7XG4gICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGNvZGVnZW5fMS5fIGAke19hd2FpdH0ke2NvZGVfMS5jYWxsVmFsaWRhdGVDb2RlKGN4dCwgdmFsaWRhdGVSZWYsIHBhc3NDeHQsIHBhc3NTY2hlbWEpfWAsIGRlZi5tb2RpZnlpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXBvcnRFcnJzKGVycm9ycykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGdlbi5pZihjb2RlZ2VuXzEubm90KChfYSA9IGRlZi52YWxpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFsaWQpLCBlcnJvcnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuZnVuY0tleXdvcmRDb2RlID0gZnVuY0tleXdvcmRDb2RlO1xuZnVuY3Rpb24gbW9kaWZ5RGF0YShjeHQpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICBnZW4uaWYoaXQucGFyZW50RGF0YSwgKCkgPT4gZ2VuLmFzc2lnbihkYXRhLCBjb2RlZ2VuXzEuXyBgJHtpdC5wYXJlbnREYXRhfVske2l0LnBhcmVudERhdGFQcm9wZXJ0eX1dYCkpO1xufVxuZnVuY3Rpb24gYWRkRXJycyhjeHQsIGVycnMpIHtcbiAgICBjb25zdCB7IGdlbiB9ID0gY3h0O1xuICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgQXJyYXkuaXNBcnJheSgke2VycnN9KWAsICgpID0+IHtcbiAgICAgICAgZ2VuXG4gICAgICAgICAgICAuYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30gPT09IG51bGwgPyAke2VycnN9IDogJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30uY29uY2F0KCR7ZXJyc30pYClcbiAgICAgICAgICAgIC5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LmVycm9ycywgY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9Lmxlbmd0aGApO1xuICAgICAgICBlcnJvcnNfMS5leHRlbmRFcnJvcnMoY3h0KTtcbiAgICB9LCAoKSA9PiBjeHQuZXJyb3IoKSk7XG59XG5mdW5jdGlvbiBjaGVja0FzeW5jS2V5d29yZCh7IHNjaGVtYUVudiB9LCBkZWYpIHtcbiAgICBpZiAoZGVmLmFzeW5jICYmICFzY2hlbWFFbnYuJGFzeW5jKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBrZXl3b3JkIGluIHN5bmMgc2NoZW1hXCIpO1xufVxuZnVuY3Rpb24gdXNlS2V5d29yZChnZW4sIGtleXdvcmQsIHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBrZXl3b3JkIFwiJHtrZXl3b3JkfVwiIGZhaWxlZCB0byBjb21waWxlYCk7XG4gICAgcmV0dXJuIGdlbi5zY29wZVZhbHVlKFwia2V5d29yZFwiLCB0eXBlb2YgcmVzdWx0ID09IFwiZnVuY3Rpb25cIiA/IHsgcmVmOiByZXN1bHQgfSA6IHsgcmVmOiByZXN1bHQsIGNvZGU6IGNvZGVnZW5fMS5zdHJpbmdpZnkocmVzdWx0KSB9KTtcbn1cbmZ1bmN0aW9uIHZhbGlkU2NoZW1hVHlwZShzY2hlbWEsIHNjaGVtYVR5cGUsIGFsbG93VW5kZWZpbmVkID0gZmFsc2UpIHtcbiAgICAvLyBUT0RPIGFkZCB0ZXN0c1xuICAgIHJldHVybiAoIXNjaGVtYVR5cGUubGVuZ3RoIHx8XG4gICAgICAgIHNjaGVtYVR5cGUuc29tZSgoc3QpID0+IHN0ID09PSBcImFycmF5XCJcbiAgICAgICAgICAgID8gQXJyYXkuaXNBcnJheShzY2hlbWEpXG4gICAgICAgICAgICA6IHN0ID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICAgICAgPyBzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHNjaGVtYSlcbiAgICAgICAgICAgICAgICA6IHR5cGVvZiBzY2hlbWEgPT0gc3QgfHwgKGFsbG93VW5kZWZpbmVkICYmIHR5cGVvZiBzY2hlbWEgPT0gXCJ1bmRlZmluZWRcIikpKTtcbn1cbmV4cG9ydHMudmFsaWRTY2hlbWFUeXBlID0gdmFsaWRTY2hlbWFUeXBlO1xuZnVuY3Rpb24gdmFsaWRhdGVLZXl3b3JkVXNhZ2UoeyBzY2hlbWEsIG9wdHMsIHNlbGYsIGVyclNjaGVtYVBhdGggfSwgZGVmLCBrZXl3b3JkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmLmtleXdvcmQpID8gIWRlZi5rZXl3b3JkLmluY2x1ZGVzKGtleXdvcmQpIDogZGVmLmtleXdvcmQgIT09IGtleXdvcmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgIH1cbiAgICBjb25zdCBkZXBzID0gZGVmLmRlcGVuZGVuY2llcztcbiAgICBpZiAoZGVwcyA9PT0gbnVsbCB8fCBkZXBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZXBzLnNvbWUoKGt3ZCkgPT4gIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzY2hlbWEsIGt3ZCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFyZW50IHNjaGVtYSBtdXN0IGhhdmUgZGVwZW5kZW5jaWVzIG9mICR7a2V5d29yZH06ICR7ZGVwcy5qb2luKFwiLFwiKX1gKTtcbiAgICB9XG4gICAgaWYgKGRlZi52YWxpZGF0ZVNjaGVtYSkge1xuICAgICAgICBjb25zdCB2YWxpZCA9IGRlZi52YWxpZGF0ZVNjaGVtYShzY2hlbWFba2V5d29yZF0pO1xuICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBga2V5d29yZCBcIiR7a2V5d29yZH1cIiB2YWx1ZSBpcyBpbnZhbGlkIGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCI6IGAgK1xuICAgICAgICAgICAgICAgIHNlbGYuZXJyb3JzVGV4dChkZWYudmFsaWRhdGVTY2hlbWEuZXJyb3JzKTtcbiAgICAgICAgICAgIGlmIChvcHRzLnZhbGlkYXRlU2NoZW1hID09PSBcImxvZ1wiKVxuICAgICAgICAgICAgICAgIHNlbGYubG9nZ2VyLmVycm9yKG1zZyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlS2V5d29yZFVzYWdlID0gdmFsaWRhdGVLZXl3b3JkVXNhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXl3b3JkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHRlbmRTdWJzY2hlbWFNb2RlID0gZXhwb3J0cy5leHRlbmRTdWJzY2hlbWFEYXRhID0gZXhwb3J0cy5nZXRTdWJzY2hlbWEgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuZnVuY3Rpb24gZ2V0U3Vic2NoZW1hKGl0LCB7IGtleXdvcmQsIHNjaGVtYVByb3AsIHNjaGVtYSwgc2NoZW1hUGF0aCwgZXJyU2NoZW1hUGF0aCwgdG9wU2NoZW1hUmVmIH0pIHtcbiAgICBpZiAoa2V5d29yZCAhPT0gdW5kZWZpbmVkICYmIHNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYm90aCBcImtleXdvcmRcIiBhbmQgXCJzY2hlbWFcIiBwYXNzZWQsIG9ubHkgb25lIGFsbG93ZWQnKTtcbiAgICB9XG4gICAgaWYgKGtleXdvcmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBzY2ggPSBpdC5zY2hlbWFba2V5d29yZF07XG4gICAgICAgIHJldHVybiBzY2hlbWFQcm9wID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoLFxuICAgICAgICAgICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5fIGAke2l0LnNjaGVtYVBhdGh9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkoa2V5d29yZCl9YCxcbiAgICAgICAgICAgICAgICBlcnJTY2hlbWFQYXRoOiBgJHtpdC5lcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9YCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoW3NjaGVtYVByb3BdLFxuICAgICAgICAgICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5fIGAke2l0LnNjaGVtYVBhdGh9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkoa2V5d29yZCl9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkoc2NoZW1hUHJvcCl9YCxcbiAgICAgICAgICAgICAgICBlcnJTY2hlbWFQYXRoOiBgJHtpdC5lcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9LyR7dXRpbF8xLmVzY2FwZUZyYWdtZW50KHNjaGVtYVByb3ApfWAsXG4gICAgICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoc2NoZW1hICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHNjaGVtYVBhdGggPT09IHVuZGVmaW5lZCB8fCBlcnJTY2hlbWFQYXRoID09PSB1bmRlZmluZWQgfHwgdG9wU2NoZW1hUmVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJzY2hlbWFQYXRoXCIsIFwiZXJyU2NoZW1hUGF0aFwiIGFuZCBcInRvcFNjaGVtYVJlZlwiIGFyZSByZXF1aXJlZCB3aXRoIFwic2NoZW1hXCInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgc2NoZW1hUGF0aCxcbiAgICAgICAgICAgIHRvcFNjaGVtYVJlZixcbiAgICAgICAgICAgIGVyclNjaGVtYVBhdGgsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignZWl0aGVyIFwia2V5d29yZFwiIG9yIFwic2NoZW1hXCIgbXVzdCBiZSBwYXNzZWQnKTtcbn1cbmV4cG9ydHMuZ2V0U3Vic2NoZW1hID0gZ2V0U3Vic2NoZW1hO1xuZnVuY3Rpb24gZXh0ZW5kU3Vic2NoZW1hRGF0YShzdWJzY2hlbWEsIGl0LCB7IGRhdGFQcm9wLCBkYXRhUHJvcFR5cGU6IGRwVHlwZSwgZGF0YSwgZGF0YVR5cGVzLCBwcm9wZXJ0eU5hbWUgfSkge1xuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQgJiYgZGF0YVByb3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGggXCJkYXRhXCIgYW5kIFwiZGF0YVByb3BcIiBwYXNzZWQsIG9ubHkgb25lIGFsbG93ZWQnKTtcbiAgICB9XG4gICAgY29uc3QgeyBnZW4gfSA9IGl0O1xuICAgIGlmIChkYXRhUHJvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHsgZXJyb3JQYXRoLCBkYXRhUGF0aEFyciwgb3B0cyB9ID0gaXQ7XG4gICAgICAgIGNvbnN0IG5leHREYXRhID0gZ2VuLmxldChcImRhdGFcIiwgY29kZWdlbl8xLl8gYCR7aXQuZGF0YX0ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eShkYXRhUHJvcCl9YCwgdHJ1ZSk7XG4gICAgICAgIGRhdGFDb250ZXh0UHJvcHMobmV4dERhdGEpO1xuICAgICAgICBzdWJzY2hlbWEuZXJyb3JQYXRoID0gY29kZWdlbl8xLnN0ciBgJHtlcnJvclBhdGh9JHt1dGlsXzEuZ2V0RXJyb3JQYXRoKGRhdGFQcm9wLCBkcFR5cGUsIG9wdHMuanNQcm9wZXJ0eVN5bnRheCl9YDtcbiAgICAgICAgc3Vic2NoZW1hLnBhcmVudERhdGFQcm9wZXJ0eSA9IGNvZGVnZW5fMS5fIGAke2RhdGFQcm9wfWA7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhUGF0aEFyciA9IFsuLi5kYXRhUGF0aEFyciwgc3Vic2NoZW1hLnBhcmVudERhdGFQcm9wZXJ0eV07XG4gICAgfVxuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgbmV4dERhdGEgPSBkYXRhIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUgPyBkYXRhIDogZ2VuLmxldChcImRhdGFcIiwgZGF0YSwgdHJ1ZSk7IC8vIHJlcGxhY2VhYmxlIGlmIHVzZWQgb25jZT9cbiAgICAgICAgZGF0YUNvbnRleHRQcm9wcyhuZXh0RGF0YSk7XG4gICAgICAgIGlmIChwcm9wZXJ0eU5hbWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHN1YnNjaGVtYS5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG4gICAgICAgIC8vIFRPRE8gc29tZXRoaW5nIGlzIHBvc3NpYmx5IHdyb25nIGhlcmUgd2l0aCBub3QgY2hhbmdpbmcgcGFyZW50RGF0YVByb3BlcnR5IGFuZCBub3QgYXBwZW5kaW5nIGRhdGFQYXRoQXJyXG4gICAgfVxuICAgIGlmIChkYXRhVHlwZXMpXG4gICAgICAgIHN1YnNjaGVtYS5kYXRhVHlwZXMgPSBkYXRhVHlwZXM7XG4gICAgZnVuY3Rpb24gZGF0YUNvbnRleHRQcm9wcyhfbmV4dERhdGEpIHtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGEgPSBfbmV4dERhdGE7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhTGV2ZWwgPSBpdC5kYXRhTGV2ZWwgKyAxO1xuICAgICAgICBzdWJzY2hlbWEuZGF0YVR5cGVzID0gW107XG4gICAgICAgIGl0LmRlZmluZWRQcm9wZXJ0aWVzID0gbmV3IFNldCgpO1xuICAgICAgICBzdWJzY2hlbWEucGFyZW50RGF0YSA9IGl0LmRhdGE7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhTmFtZXMgPSBbLi4uaXQuZGF0YU5hbWVzLCBfbmV4dERhdGFdO1xuICAgIH1cbn1cbmV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hRGF0YSA9IGV4dGVuZFN1YnNjaGVtYURhdGE7XG5mdW5jdGlvbiBleHRlbmRTdWJzY2hlbWFNb2RlKHN1YnNjaGVtYSwgeyBqdGREaXNjcmltaW5hdG9yLCBqdGRNZXRhZGF0YSwgY29tcG9zaXRlUnVsZSwgY3JlYXRlRXJyb3JzLCBhbGxFcnJvcnMgfSkge1xuICAgIGlmIChjb21wb3NpdGVSdWxlICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHN1YnNjaGVtYS5jb21wb3NpdGVSdWxlID0gY29tcG9zaXRlUnVsZTtcbiAgICBpZiAoY3JlYXRlRXJyb3JzICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHN1YnNjaGVtYS5jcmVhdGVFcnJvcnMgPSBjcmVhdGVFcnJvcnM7XG4gICAgaWYgKGFsbEVycm9ycyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBzdWJzY2hlbWEuYWxsRXJyb3JzID0gYWxsRXJyb3JzO1xuICAgIHN1YnNjaGVtYS5qdGREaXNjcmltaW5hdG9yID0ganRkRGlzY3JpbWluYXRvcjsgLy8gbm90IGluaGVyaXRlZFxuICAgIHN1YnNjaGVtYS5qdGRNZXRhZGF0YSA9IGp0ZE1ldGFkYXRhOyAvLyBub3QgaW5oZXJpdGVkXG59XG5leHBvcnRzLmV4dGVuZFN1YnNjaGVtYU1vZGUgPSBleHRlbmRTdWJzY2hlbWFNb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NoZW1hLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuLy8gZG8gbm90IGVkaXQgLmpzIGZpbGVzIGRpcmVjdGx5IC0gZWRpdCBzcmMvaW5kZXguanN0XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxlbmd0aCwgaSwga2V5cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgIGlmICghZXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG5cbiAgICBpZiAoYS5jb25zdHJ1Y3RvciA9PT0gUmVnRXhwKSByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XG4gICAgaWYgKGEudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSByZXR1cm4gYS52YWx1ZU9mKCkgPT09IGIudmFsdWVPZigpO1xuICAgIGlmIChhLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZVxuICByZXR1cm4gYSE9PWEgJiYgYiE9PWI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHJhdmVyc2UgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzY2hlbWEsIG9wdHMsIGNiKSB7XG4gIC8vIExlZ2FjeSBzdXBwb3J0IGZvciB2MC4zLjEgYW5kIGVhcmxpZXIuXG4gIGlmICh0eXBlb2Ygb3B0cyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIGNiID0gb3B0cy5jYiB8fCBjYjtcbiAgdmFyIHByZSA9ICh0eXBlb2YgY2IgPT0gJ2Z1bmN0aW9uJykgPyBjYiA6IGNiLnByZSB8fCBmdW5jdGlvbigpIHt9O1xuICB2YXIgcG9zdCA9IGNiLnBvc3QgfHwgZnVuY3Rpb24oKSB7fTtcblxuICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hlbWEsICcnLCBzY2hlbWEpO1xufTtcblxuXG50cmF2ZXJzZS5rZXl3b3JkcyA9IHtcbiAgYWRkaXRpb25hbEl0ZW1zOiB0cnVlLFxuICBpdGVtczogdHJ1ZSxcbiAgY29udGFpbnM6IHRydWUsXG4gIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiB0cnVlLFxuICBwcm9wZXJ0eU5hbWVzOiB0cnVlLFxuICBub3Q6IHRydWUsXG4gIGlmOiB0cnVlLFxuICB0aGVuOiB0cnVlLFxuICBlbHNlOiB0cnVlXG59O1xuXG50cmF2ZXJzZS5hcnJheUtleXdvcmRzID0ge1xuICBpdGVtczogdHJ1ZSxcbiAgYWxsT2Y6IHRydWUsXG4gIGFueU9mOiB0cnVlLFxuICBvbmVPZjogdHJ1ZVxufTtcblxudHJhdmVyc2UucHJvcHNLZXl3b3JkcyA9IHtcbiAgJGRlZnM6IHRydWUsXG4gIGRlZmluaXRpb25zOiB0cnVlLFxuICBwcm9wZXJ0aWVzOiB0cnVlLFxuICBwYXR0ZXJuUHJvcGVydGllczogdHJ1ZSxcbiAgZGVwZW5kZW5jaWVzOiB0cnVlXG59O1xuXG50cmF2ZXJzZS5za2lwS2V5d29yZHMgPSB7XG4gIGRlZmF1bHQ6IHRydWUsXG4gIGVudW06IHRydWUsXG4gIGNvbnN0OiB0cnVlLFxuICByZXF1aXJlZDogdHJ1ZSxcbiAgbWF4aW11bTogdHJ1ZSxcbiAgbWluaW11bTogdHJ1ZSxcbiAgZXhjbHVzaXZlTWF4aW11bTogdHJ1ZSxcbiAgZXhjbHVzaXZlTWluaW11bTogdHJ1ZSxcbiAgbXVsdGlwbGVPZjogdHJ1ZSxcbiAgbWF4TGVuZ3RoOiB0cnVlLFxuICBtaW5MZW5ndGg6IHRydWUsXG4gIHBhdHRlcm46IHRydWUsXG4gIGZvcm1hdDogdHJ1ZSxcbiAgbWF4SXRlbXM6IHRydWUsXG4gIG1pbkl0ZW1zOiB0cnVlLFxuICB1bmlxdWVJdGVtczogdHJ1ZSxcbiAgbWF4UHJvcGVydGllczogdHJ1ZSxcbiAgbWluUHJvcGVydGllczogdHJ1ZVxufTtcblxuXG5mdW5jdGlvbiBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpIHtcbiAgaWYgKHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hID09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICBwcmUoc2NoZW1hLCBqc29uUHRyLCByb290U2NoZW1hLCBwYXJlbnRKc29uUHRyLCBwYXJlbnRLZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGtleUluZGV4KTtcbiAgICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICB2YXIgc2NoID0gc2NoZW1hW2tleV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2gpKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdHJhdmVyc2UuYXJyYXlLZXl3b3Jkcykge1xuICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxzY2gubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hbaV0sIGpzb25QdHIgKyAnLycgKyBrZXkgKyAnLycgKyBpLCByb290U2NoZW1hLCBqc29uUHRyLCBrZXksIHNjaGVtYSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5IGluIHRyYXZlcnNlLnByb3BzS2V5d29yZHMpIHtcbiAgICAgICAgaWYgKHNjaCAmJiB0eXBlb2Ygc2NoID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzY2gpXG4gICAgICAgICAgICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hbcHJvcF0sIGpzb25QdHIgKyAnLycgKyBrZXkgKyAnLycgKyBlc2NhcGVKc29uUHRyKHByb3ApLCByb290U2NoZW1hLCBqc29uUHRyLCBrZXksIHNjaGVtYSwgcHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5IGluIHRyYXZlcnNlLmtleXdvcmRzIHx8IChvcHRzLmFsbEtleXMgJiYgIShrZXkgaW4gdHJhdmVyc2Uuc2tpcEtleXdvcmRzKSkpIHtcbiAgICAgICAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoLCBqc29uUHRyICsgJy8nICsga2V5LCByb290U2NoZW1hLCBqc29uUHRyLCBrZXksIHNjaGVtYSk7XG4gICAgICB9XG4gICAgfVxuICAgIHBvc3Qoc2NoZW1hLCBqc29uUHRyLCByb290U2NoZW1hLCBwYXJlbnRKc29uUHRyLCBwYXJlbnRLZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGtleUluZGV4KTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGVzY2FwZUpzb25QdHIoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvfi9nLCAnfjAnKS5yZXBsYWNlKC9cXC8vZywgJ34xJyk7XG59XG4iLCIvKiogQGxpY2Vuc2UgVVJJLmpzIHY0LjQuMSAoYykgMjAxMSBHYXJ5IENvdXJ0LiBMaWNlbnNlOiBodHRwOi8vZ2l0aHViLmNvbS9nYXJ5Y291cnQvdXJpLWpzICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwuVVJJID0gZ2xvYmFsLlVSSSB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gbWVyZ2UoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNldHMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgc2V0c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAoc2V0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHNldHNbMF0gPSBzZXRzWzBdLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgdmFyIHhsID0gc2V0cy5sZW5ndGggLSAxO1xuICAgICAgICBmb3IgKHZhciB4ID0gMTsgeCA8IHhsOyArK3gpIHtcbiAgICAgICAgICAgIHNldHNbeF0gPSBzZXRzW3hdLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRzW3hsXSA9IHNldHNbeGxdLnNsaWNlKDEpO1xuICAgICAgICByZXR1cm4gc2V0cy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2V0c1swXTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJleHAoc3RyKSB7XG4gICAgcmV0dXJuIFwiKD86XCIgKyBzdHIgKyBcIilcIjtcbn1cbmZ1bmN0aW9uIHR5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8gPT09IHVuZGVmaW5lZCA/IFwidW5kZWZpbmVkXCIgOiBvID09PSBudWxsID8gXCJudWxsXCIgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc3BsaXQoXCIgXCIpLnBvcCgpLnNwbGl0KFwiXVwiKS5zaGlmdCgpLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiB0b1VwcGVyQ2FzZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRvVXBwZXJDYXNlKCk7XG59XG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICAgIHJldHVybiBvYmogIT09IHVuZGVmaW5lZCAmJiBvYmogIT09IG51bGwgPyBvYmogaW5zdGFuY2VvZiBBcnJheSA/IG9iaiA6IHR5cGVvZiBvYmoubGVuZ3RoICE9PSBcIm51bWJlclwiIHx8IG9iai5zcGxpdCB8fCBvYmouc2V0SW50ZXJ2YWwgfHwgb2JqLmNhbGwgPyBbb2JqXSA6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaikgOiBbXTtcbn1cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuICAgIHZhciBvYmogPSB0YXJnZXQ7XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRXhwcyhpc0lSSSkge1xuICAgIHZhciBBTFBIQSQkID0gXCJbQS1aYS16XVwiLFxuICAgICAgICBDUiQgPSBcIltcXFxceDBEXVwiLFxuICAgICAgICBESUdJVCQkID0gXCJbMC05XVwiLFxuICAgICAgICBEUVVPVEUkJCA9IFwiW1xcXFx4MjJdXCIsXG4gICAgICAgIEhFWERJRyQkID0gbWVyZ2UoRElHSVQkJCwgXCJbQS1GYS1mXVwiKSxcbiAgICAgICAgLy9jYXNlLWluc2Vuc2l0aXZlXG4gICAgTEYkJCA9IFwiW1xcXFx4MEFdXCIsXG4gICAgICAgIFNQJCQgPSBcIltcXFxceDIwXVwiLFxuICAgICAgICBQQ1RfRU5DT0RFRCQgPSBzdWJleHAoc3ViZXhwKFwiJVtFRmVmXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlWzg5QS1GYS1mXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSksXG4gICAgICAgIC8vZXhwYW5kZWRcbiAgICBHRU5fREVMSU1TJCQgPSBcIltcXFxcOlxcXFwvXFxcXD9cXFxcI1xcXFxbXFxcXF1cXFxcQF1cIixcbiAgICAgICAgU1VCX0RFTElNUyQkID0gXCJbXFxcXCFcXFxcJFxcXFwmXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXDtcXFxcPV1cIixcbiAgICAgICAgUkVTRVJWRUQkJCA9IG1lcmdlKEdFTl9ERUxJTVMkJCwgU1VCX0RFTElNUyQkKSxcbiAgICAgICAgVUNTQ0hBUiQkID0gaXNJUkkgPyBcIltcXFxceEEwLVxcXFx1MjAwRFxcXFx1MjAxMC1cXFxcdTIwMjlcXFxcdTIwMkYtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdXCIgOiBcIltdXCIsXG4gICAgICAgIC8vc3Vic2V0LCBleGNsdWRlcyBiaWRpIGNvbnRyb2wgY2hhcmFjdGVyc1xuICAgIElQUklWQVRFJCQgPSBpc0lSSSA/IFwiW1xcXFx1RTAwMC1cXFxcdUY4RkZdXCIgOiBcIltdXCIsXG4gICAgICAgIC8vc3Vic2V0XG4gICAgVU5SRVNFUlZFRCQkID0gbWVyZ2UoQUxQSEEkJCwgRElHSVQkJCwgXCJbXFxcXC1cXFxcLlxcXFxfXFxcXH5dXCIsIFVDU0NIQVIkJCksXG4gICAgICAgIFNDSEVNRSQgPSBzdWJleHAoQUxQSEEkJCArIG1lcmdlKEFMUEhBJCQsIERJR0lUJCQsIFwiW1xcXFwrXFxcXC1cXFxcLl1cIikgKyBcIipcIiksXG4gICAgICAgIFVTRVJJTkZPJCA9IHN1YmV4cChzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpdXCIpKSArIFwiKlwiKSxcbiAgICAgICAgREVDX09DVEVUJCA9IHN1YmV4cChzdWJleHAoXCIyNVswLTVdXCIpICsgXCJ8XCIgKyBzdWJleHAoXCIyWzAtNF1cIiArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIxXCIgKyBESUdJVCQkICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIlsxLTldXCIgKyBESUdJVCQkKSArIFwifFwiICsgRElHSVQkJCksXG4gICAgICAgIERFQ19PQ1RFVF9SRUxBWEVEJCA9IHN1YmV4cChzdWJleHAoXCIyNVswLTVdXCIpICsgXCJ8XCIgKyBzdWJleHAoXCIyWzAtNF1cIiArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIxXCIgKyBESUdJVCQkICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIjA/WzEtOV1cIiArIERJR0lUJCQpICsgXCJ8MD8wP1wiICsgRElHSVQkJCksXG4gICAgICAgIC8vcmVsYXhlZCBwYXJzaW5nIHJ1bGVzXG4gICAgSVBWNEFERFJFU1MkID0gc3ViZXhwKERFQ19PQ1RFVF9SRUxBWEVEJCArIFwiXFxcXC5cIiArIERFQ19PQ1RFVF9SRUxBWEVEJCArIFwiXFxcXC5cIiArIERFQ19PQ1RFVF9SRUxBWEVEJCArIFwiXFxcXC5cIiArIERFQ19PQ1RFVF9SRUxBWEVEJCksXG4gICAgICAgIEgxNiQgPSBzdWJleHAoSEVYRElHJCQgKyBcInsxLDR9XCIpLFxuICAgICAgICBMUzMyJCA9IHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIiArIEgxNiQpICsgXCJ8XCIgKyBJUFY0QUREUkVTUyQpLFxuICAgICAgICBJUFY2QUREUkVTUzEkID0gc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezZ9XCIgKyBMUzMyJCksXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgNiggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTMiQgPSBzdWJleHAoXCJcXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcIns1fVwiICsgTFMzMiQpLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICBcIjo6XCIgNSggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTMyQgPSBzdWJleHAoc3ViZXhwKEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7NH1cIiArIExTMzIkKSxcbiAgICAgICAgLy9bICAgICAgICAgICAgICAgaDE2IF0gXCI6OlwiIDQoIGgxNiBcIjpcIiApIGxzMzJcbiAgICBJUFY2QUREUkVTUzQkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDF9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezN9XCIgKyBMUzMyJCksXG4gICAgICAgIC8vWyAqMSggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiIDMoIGgxNiBcIjpcIiApIGxzMzJcbiAgICBJUFY2QUREUkVTUzUkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDJ9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezJ9XCIgKyBMUzMyJCksXG4gICAgICAgIC8vWyAqMiggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiIDIoIGgxNiBcIjpcIiApIGxzMzJcbiAgICBJUFY2QUREUkVTUzYkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDN9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIEgxNiQgKyBcIlxcXFw6XCIgKyBMUzMyJCksXG4gICAgICAgIC8vWyAqMyggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgIGgxNiBcIjpcIiAgIGxzMzJcbiAgICBJUFY2QUREUkVTUzckID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDR9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIExTMzIkKSxcbiAgICAgICAgLy9bICo0KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgICAgICAgICAgIGxzMzJcbiAgICBJUFY2QUREUkVTUzgkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDV9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIEgxNiQpLFxuICAgICAgICAvL1sgKjUoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICAgICAgICAgICAgaDE2XG4gICAgSVBWNkFERFJFU1M5JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCw2fVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIpLFxuICAgICAgICAvL1sgKjYoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIlxuICAgIElQVjZBRERSRVNTJCA9IHN1YmV4cChbSVBWNkFERFJFU1MxJCwgSVBWNkFERFJFU1MyJCwgSVBWNkFERFJFU1MzJCwgSVBWNkFERFJFU1M0JCwgSVBWNkFERFJFU1M1JCwgSVBWNkFERFJFU1M2JCwgSVBWNkFERFJFU1M3JCwgSVBWNkFERFJFU1M4JCwgSVBWNkFERFJFU1M5JF0uam9pbihcInxcIikpLFxuICAgICAgICBaT05FSUQkID0gc3ViZXhwKHN1YmV4cChVTlJFU0VSVkVEJCQgKyBcInxcIiArIFBDVF9FTkNPREVEJCkgKyBcIitcIiksXG4gICAgICAgIC8vUkZDIDY4NzRcbiAgICBJUFY2QUREUlokID0gc3ViZXhwKElQVjZBRERSRVNTJCArIFwiXFxcXCUyNVwiICsgWk9ORUlEJCksXG4gICAgICAgIC8vUkZDIDY4NzRcbiAgICBJUFY2QUREUlpfUkVMQVhFRCQgPSBzdWJleHAoSVBWNkFERFJFU1MkICsgc3ViZXhwKFwiXFxcXCUyNXxcXFxcJSg/IVwiICsgSEVYRElHJCQgKyBcInsyfSlcIikgKyBaT05FSUQkKSxcbiAgICAgICAgLy9SRkMgNjg3NCwgd2l0aCByZWxheGVkIHBhcnNpbmcgcnVsZXNcbiAgICBJUFZGVVRVUkUkID0gc3ViZXhwKFwiW3ZWXVwiICsgSEVYRElHJCQgKyBcIitcXFxcLlwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XVwiKSArIFwiK1wiKSxcbiAgICAgICAgSVBfTElURVJBTCQgPSBzdWJleHAoXCJcXFxcW1wiICsgc3ViZXhwKElQVjZBRERSWl9SRUxBWEVEJCArIFwifFwiICsgSVBWNkFERFJFU1MkICsgXCJ8XCIgKyBJUFZGVVRVUkUkKSArIFwiXFxcXF1cIiksXG4gICAgICAgIC8vUkZDIDY4NzRcbiAgICBSRUdfTkFNRSQgPSBzdWJleHAoc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpKSArIFwiKlwiKSxcbiAgICAgICAgSE9TVCQgPSBzdWJleHAoSVBfTElURVJBTCQgKyBcInxcIiArIElQVjRBRERSRVNTJCArIFwiKD8hXCIgKyBSRUdfTkFNRSQgKyBcIilcIiArIFwifFwiICsgUkVHX05BTUUkKSxcbiAgICAgICAgUE9SVCQgPSBzdWJleHAoRElHSVQkJCArIFwiKlwiKSxcbiAgICAgICAgQVVUSE9SSVRZJCA9IHN1YmV4cChzdWJleHAoVVNFUklORk8kICsgXCJAXCIpICsgXCI/XCIgKyBIT1NUJCArIHN1YmV4cChcIlxcXFw6XCIgKyBQT1JUJCkgKyBcIj9cIiksXG4gICAgICAgIFBDSEFSJCA9IHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOlxcXFxAXVwiKSksXG4gICAgICAgIFNFR01FTlQkID0gc3ViZXhwKFBDSEFSJCArIFwiKlwiKSxcbiAgICAgICAgU0VHTUVOVF9OWiQgPSBzdWJleHAoUENIQVIkICsgXCIrXCIpLFxuICAgICAgICBTRUdNRU5UX05aX05DJCA9IHN1YmV4cChzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXEBdXCIpKSArIFwiK1wiKSxcbiAgICAgICAgUEFUSF9BQkVNUFRZJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1wiICsgU0VHTUVOVCQpICsgXCIqXCIpLFxuICAgICAgICBQQVRIX0FCU09MVVRFJCA9IHN1YmV4cChcIlxcXFwvXCIgKyBzdWJleHAoU0VHTUVOVF9OWiQgKyBQQVRIX0FCRU1QVFkkKSArIFwiP1wiKSxcbiAgICAgICAgLy9zaW1wbGlmaWVkXG4gICAgUEFUSF9OT1NDSEVNRSQgPSBzdWJleHAoU0VHTUVOVF9OWl9OQyQgKyBQQVRIX0FCRU1QVFkkKSxcbiAgICAgICAgLy9zaW1wbGlmaWVkXG4gICAgUEFUSF9ST09UTEVTUyQgPSBzdWJleHAoU0VHTUVOVF9OWiQgKyBQQVRIX0FCRU1QVFkkKSxcbiAgICAgICAgLy9zaW1wbGlmaWVkXG4gICAgUEFUSF9FTVBUWSQgPSBcIig/IVwiICsgUENIQVIkICsgXCIpXCIsXG4gICAgICAgIFBBVEgkID0gc3ViZXhwKFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSxcbiAgICAgICAgUVVFUlkkID0gc3ViZXhwKHN1YmV4cChQQ0hBUiQgKyBcInxcIiArIG1lcmdlKFwiW1xcXFwvXFxcXD9dXCIsIElQUklWQVRFJCQpKSArIFwiKlwiKSxcbiAgICAgICAgRlJBR01FTlQkID0gc3ViZXhwKHN1YmV4cChQQ0hBUiQgKyBcInxbXFxcXC9cXFxcP11cIikgKyBcIipcIiksXG4gICAgICAgIEhJRVJfUEFSVCQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcL1wiICsgQVVUSE9SSVRZJCArIFBBVEhfQUJFTVBUWSQpICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSxcbiAgICAgICAgVVJJJCA9IHN1YmV4cChTQ0hFTUUkICsgXCJcXFxcOlwiICsgSElFUl9QQVJUJCArIHN1YmV4cChcIlxcXFw/XCIgKyBRVUVSWSQpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcI1wiICsgRlJBR01FTlQkKSArIFwiP1wiKSxcbiAgICAgICAgUkVMQVRJVkVfUEFSVCQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcL1wiICsgQVVUSE9SSVRZJCArIFBBVEhfQUJFTVBUWSQpICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9OT1NDSEVNRSQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSxcbiAgICAgICAgUkVMQVRJVkUkID0gc3ViZXhwKFJFTEFUSVZFX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjXCIgKyBGUkFHTUVOVCQpICsgXCI/XCIpLFxuICAgICAgICBVUklfUkVGRVJFTkNFJCA9IHN1YmV4cChVUkkkICsgXCJ8XCIgKyBSRUxBVElWRSQpLFxuICAgICAgICBBQlNPTFVURV9VUkkkID0gc3ViZXhwKFNDSEVNRSQgKyBcIlxcXFw6XCIgKyBISUVSX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiksXG4gICAgICAgIEdFTkVSSUNfUkVGJCA9IFwiXihcIiArIFNDSEVNRSQgKyBcIilcXFxcOlwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC8oXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8pXCIpICsgXCI/KFwiICsgUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfUk9PVExFU1MkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCArIFwiKVwiKSArIHN1YmV4cChcIlxcXFw/KFwiICsgUVVFUlkkICsgXCIpXCIpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcIyhcIiArIEZSQUdNRU5UJCArIFwiKVwiKSArIFwiPyRcIixcbiAgICAgICAgUkVMQVRJVkVfUkVGJCA9IFwiXigpezB9XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9OT1NDSEVNRSQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjKFwiICsgRlJBR01FTlQkICsgXCIpXCIpICsgXCI/JFwiLFxuICAgICAgICBBQlNPTFVURV9SRUYkID0gXCJeKFwiICsgU0NIRU1FJCArIFwiKVxcXFw6XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj8kXCIsXG4gICAgICAgIFNBTUVET0NfUkVGJCA9IFwiXlwiICsgc3ViZXhwKFwiXFxcXCMoXCIgKyBGUkFHTUVOVCQgKyBcIilcIikgKyBcIj8kXCIsXG4gICAgICAgIEFVVEhPUklUWV9SRUYkID0gXCJeXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8kXCI7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgTk9UX1NDSEVNRTogbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBBTFBIQSQkLCBESUdJVCQkLCBcIltcXFxcK1xcXFwtXFxcXC5dXCIpLCBcImdcIiksXG4gICAgICAgIE5PVF9VU0VSSU5GTzogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcOl1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9IT1NUOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFxbXFxcXF1cXFxcOl1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9QQVRIOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFwvXFxcXDpcXFxcQF1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9QQVRIX05PU0NIRU1FOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFwvXFxcXEBdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuICAgICAgICBOT1RfUVVFUlk6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpcXFxcQFxcXFwvXFxcXD9dXCIsIElQUklWQVRFJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9GUkFHTUVOVDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOlxcXFxAXFxcXC9cXFxcP11cIiksIFwiZ1wiKSxcbiAgICAgICAgRVNDQVBFOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuICAgICAgICBVTlJFU0VSVkVEOiBuZXcgUmVnRXhwKFVOUkVTRVJWRUQkJCwgXCJnXCIpLFxuICAgICAgICBPVEhFUl9DSEFSUzogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVdXCIsIFVOUkVTRVJWRUQkJCwgUkVTRVJWRUQkJCksIFwiZ1wiKSxcbiAgICAgICAgUENUX0VOQ09ERUQ6IG5ldyBSZWdFeHAoUENUX0VOQ09ERUQkLCBcImdcIiksXG4gICAgICAgIElQVjRBRERSRVNTOiBuZXcgUmVnRXhwKFwiXihcIiArIElQVjRBRERSRVNTJCArIFwiKSRcIiksXG4gICAgICAgIElQVjZBRERSRVNTOiBuZXcgUmVnRXhwKFwiXlxcXFxbPyhcIiArIElQVjZBRERSRVNTJCArIFwiKVwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwlMjV8XFxcXCUoPyFcIiArIEhFWERJRyQkICsgXCJ7Mn0pXCIpICsgXCIoXCIgKyBaT05FSUQkICsgXCIpXCIpICsgXCI/XFxcXF0/JFwiKSAvL1JGQyA2ODc0LCB3aXRoIHJlbGF4ZWQgcGFyc2luZyBydWxlc1xuICAgIH07XG59XG52YXIgVVJJX1BST1RPQ09MID0gYnVpbGRFeHBzKGZhbHNlKTtcblxudmFyIElSSV9QUk9UT0NPTCA9IGJ1aWxkRXhwcyh0cnVlKTtcblxudmFyIHNsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7XG4gICAgdmFyIF9hcnIgPSBbXTtcbiAgICB2YXIgX24gPSB0cnVlO1xuICAgIHZhciBfZCA9IGZhbHNlO1xuICAgIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2QgPSB0cnVlO1xuICAgICAgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfYXJyO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7XG4gICAgICByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgICB9XG4gIH07XG59KCk7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciB0b0NvbnN1bWFibGVBcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShhcnIpO1xuICB9XG59O1xuXG4vKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cbnZhciBtYXhJbnQgPSAyMTQ3NDgzNjQ3OyAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cbi8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cbnZhciBiYXNlID0gMzY7XG52YXIgdE1pbiA9IDE7XG52YXIgdE1heCA9IDI2O1xudmFyIHNrZXcgPSAzODtcbnZhciBkYW1wID0gNzAwO1xudmFyIGluaXRpYWxCaWFzID0gNzI7XG52YXIgaW5pdGlhbE4gPSAxMjg7IC8vIDB4ODBcbnZhciBkZWxpbWl0ZXIgPSAnLSc7IC8vICdcXHgyRCdcblxuLyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cbnZhciByZWdleFB1bnljb2RlID0gL154bi0tLztcbnZhciByZWdleE5vbkFTQ0lJID0gL1teXFwwLVxceDdFXS87IC8vIG5vbi1BU0NJSSBjaGFyc1xudmFyIHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2c7IC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuLyoqIEVycm9yIG1lc3NhZ2VzICovXG52YXIgZXJyb3JzID0ge1xuXHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xufTtcblxuLyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xudmFyIGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbjtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8qKlxuICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGVycm9yJDEodHlwZSkge1xuXHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xufVxuXG4vKipcbiAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcbiAqIGl0ZW0uXG4gKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0dmFyIHJlc3VsdCA9IFtdO1xuXHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG4gKiBhZGRyZXNzZXMuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuICogY2hhcmFjdGVyLlxuICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0dmFyIHJlc3VsdCA9ICcnO1xuXHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHR9XG5cdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcbiAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcbiAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG4gKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcbiAqIG1hdGNoaW5nIFVURi0xNi5cbiAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG4gKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuICogQG5hbWUgZGVjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuICovXG5mdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHR2YXIgb3V0cHV0ID0gW107XG5cdHZhciBjb3VudGVyID0gMDtcblx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0dmFyIHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHQvLyBJdCdzIGEgaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyLlxuXHRcdFx0dmFyIGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkge1xuXHRcdFx0XHQvLyBMb3cgc3Vycm9nYXRlLlxuXHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSXQncyBhbiB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGVcblx0XHRcdFx0Ly8gbmV4dCBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXIuXG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG4gKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuICogQG5hbWUgZW5jb2RlXG4gKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuICovXG52YXIgdWNzMmVuY29kZSA9IGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0cmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KFN0cmluZywgdG9Db25zdW1hYmxlQXJyYXkoYXJyYXkpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG4gKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG4gKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cbiAqL1xudmFyIGJhc2ljVG9EaWdpdCA9IGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0aWYgKGNvZGVQb2ludCAtIDB4MzAgPCAweDBBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4MTY7XG5cdH1cblx0aWYgKGNvZGVQb2ludCAtIDB4NDEgPCAweDFBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4NDE7XG5cdH1cblx0aWYgKGNvZGVQb2ludCAtIDB4NjEgPCAweDFBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4NjE7XG5cdH1cblx0cmV0dXJuIGJhc2U7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2VcbiAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcbiAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG4gKi9cbnZhciBkaWdpdFRvQmFzaWMgPSBmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG59O1xuXG4vKipcbiAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuICogQHByaXZhdGVcbiAqL1xudmFyIGFkYXB0ID0gZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdHZhciBrID0gMDtcblx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRmb3IgKDsgLyogbm8gaW5pdGlhbGl6YXRpb24gKi9kZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0fVxuXHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcbiAqIHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqL1xudmFyIGRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHQvLyBEb24ndCB1c2UgVUNTLTIuXG5cdHZhciBvdXRwdXQgPSBbXTtcblx0dmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXHR2YXIgaSA9IDA7XG5cdHZhciBuID0gaW5pdGlhbE47XG5cdHZhciBiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdHZhciBiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdGlmIChiYXNpYyA8IDApIHtcblx0XHRiYXNpYyA9IDA7XG5cdH1cblxuXHRmb3IgKHZhciBqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRlcnJvciQxKCdub3QtYmFzaWMnKTtcblx0XHR9XG5cdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdH1cblxuXHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0Zm9yICh2YXIgaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOykgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqL3tcblxuXHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0dmFyIG9sZGkgPSBpO1xuXHRcdGZvciAodmFyIHcgPSAxLCBrID0gYmFzZTs7IC8qIG5vIGNvbmRpdGlvbiAqL2sgKz0gYmFzZSkge1xuXG5cdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0ZXJyb3IkMSgnaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHR2YXIgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiBrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzO1xuXG5cdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRlcnJvciQxKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cdFx0fVxuXG5cdFx0dmFyIG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdGVycm9yJDEoJ292ZXJmbG93Jyk7XG5cdFx0fVxuXG5cdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRpICU9IG91dDtcblxuXHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXQuXG5cdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXHR9XG5cblx0cmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KFN0cmluZywgb3V0cHV0KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcbiAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqL1xudmFyIGVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHR2YXIgb3V0cHV0ID0gW107XG5cblx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gYW4gYXJyYXkgb2YgVW5pY29kZSBjb2RlIHBvaW50cy5cblx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHQvLyBDYWNoZSB0aGUgbGVuZ3RoLlxuXHR2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGUuXG5cdHZhciBuID0gaW5pdGlhbE47XG5cdHZhciBkZWx0YSA9IDA7XG5cdHZhciBiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50cy5cblx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuXHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcblx0dmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG5cdHRyeSB7XG5cdFx0Zm9yICh2YXIgX2l0ZXJhdG9yID0gaW5wdXRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG5cdFx0XHR2YXIgX2N1cnJlbnRWYWx1ZTIgPSBfc3RlcC52YWx1ZTtcblxuXHRcdFx0aWYgKF9jdXJyZW50VmFsdWUyIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoX2N1cnJlbnRWYWx1ZTIpKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcblx0XHRfaXRlcmF0b3JFcnJvciA9IGVycjtcblx0fSBmaW5hbGx5IHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcblx0XHRcdFx0X2l0ZXJhdG9yLnJldHVybigpO1xuXHRcdFx0fVxuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcblx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dmFyIGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblx0dmFyIGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGg7XG5cblx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyB3aXRoIGEgZGVsaW1pdGVyIHVubGVzcyBpdCdzIGVtcHR5LlxuXHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHR9XG5cblx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0dmFyIG0gPSBtYXhJbnQ7XG5cdFx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcblx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG5cdFx0dmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuXHRcdHRyeSB7XG5cdFx0XHRmb3IgKHZhciBfaXRlcmF0b3IyID0gaW5wdXRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcblx0XHRcdFx0dmFyIGN1cnJlbnRWYWx1ZSA9IF9zdGVwMi52YWx1ZTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3cuXG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuXHRcdFx0X2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG5cdFx0XHRcdFx0X2l0ZXJhdG9yMi5yZXR1cm4oKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuXHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yMjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdGVycm9yJDEoJ292ZXJmbG93Jyk7XG5cdFx0fVxuXG5cdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRuID0gbTtcblxuXHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7XG5cdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuXHRcdHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7XG5cblx0XHR0cnkge1xuXHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yMyA9IGlucHV0W1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7XG5cdFx0XHRcdHZhciBfY3VycmVudFZhbHVlID0gX3N0ZXAzLnZhbHVlO1xuXG5cdFx0XHRcdGlmIChfY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoX2N1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXG5cdFx0XHRcdFx0dmFyIHEgPSBkZWx0YTtcblx0XHRcdFx0XHRmb3IgKHZhciBrID0gYmFzZTs7IC8qIG5vIGNvbmRpdGlvbiAqL2sgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dmFyIHQgPSBrIDw9IGJpYXMgPyB0TWluIDogayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcztcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHZhciBxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHR2YXIgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKSk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlO1xuXHRcdFx0X2l0ZXJhdG9yRXJyb3IzID0gZXJyO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuKSB7XG5cdFx0XHRcdFx0X2l0ZXJhdG9yMy5yZXR1cm4oKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yMykge1xuXHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yMztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdCsrZGVsdGE7XG5cdFx0KytuO1xuXHR9XG5cdHJldHVybiBvdXRwdXQuam9pbignJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3NcbiAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cbiAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuICogY29udmVydGVkIHRvIFVuaWNvZGUuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cbiAqIGNvbnZlcnQgdG8gVW5pY29kZS5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuICogc3RyaW5nLlxuICovXG52YXIgdG9Vbmljb2RlID0gZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uIChzdHJpbmcpIHtcblx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZykgPyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpIDogc3RyaW5nO1xuXHR9KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG4gKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcbiAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuICogQVNDSUkuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG4gKiBVbmljb2RlIHN0cmluZy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3JcbiAqIGVtYWlsIGFkZHJlc3MuXG4gKi9cbnZhciB0b0FTQ0lJID0gZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpID8gJ3huLS0nICsgZW5jb2RlKHN0cmluZykgOiBzdHJpbmc7XG5cdH0pO1xufTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cbnZhciBwdW55Y29kZSA9IHtcblx0LyoqXG4gICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuICAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICAqIEB0eXBlIFN0cmluZ1xuICAqL1xuXHQndmVyc2lvbic6ICcyLjEuMCcsXG5cdC8qKlxuICAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG4gICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cbiAgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAgKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAgKiBAdHlwZSBPYmplY3RcbiAgKi9cblx0J3VjczInOiB7XG5cdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0fSxcblx0J2RlY29kZSc6IGRlY29kZSxcblx0J2VuY29kZSc6IGVuY29kZSxcblx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG59O1xuXG4vKipcbiAqIFVSSS5qc1xuICpcbiAqIEBmaWxlb3ZlcnZpZXcgQW4gUkZDIDM5ODYgY29tcGxpYW50LCBzY2hlbWUgZXh0ZW5kYWJsZSBVUkkgcGFyc2luZy92YWxpZGF0aW5nL3Jlc29sdmluZyBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0LlxuICogQGF1dGhvciA8YSBocmVmPVwibWFpbHRvOmdhcnkuY291cnRAZ21haWwuY29tXCI+R2FyeSBDb3VydDwvYT5cbiAqIEBzZWUgaHR0cDovL2dpdGh1Yi5jb20vZ2FyeWNvdXJ0L3VyaS1qc1xuICovXG4vKipcbiAqIENvcHlyaWdodCAyMDExIEdhcnkgQ291cnQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgYXJlXG4gKiBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZlxuICogICAgICAgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0XG4gKiAgICAgICBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICogICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgR0FSWSBDT1VSVCBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRURcbiAqIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkRcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBHQVJZIENPVVJUIE9SXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUlxuICogU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuICogQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGXG4gKiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqXG4gKiBUaGUgdmlld3MgYW5kIGNvbmNsdXNpb25zIGNvbnRhaW5lZCBpbiB0aGUgc29mdHdhcmUgYW5kIGRvY3VtZW50YXRpb24gYXJlIHRob3NlIG9mIHRoZVxuICogYXV0aG9ycyBhbmQgc2hvdWxkIG5vdCBiZSBpbnRlcnByZXRlZCBhcyByZXByZXNlbnRpbmcgb2ZmaWNpYWwgcG9saWNpZXMsIGVpdGhlciBleHByZXNzZWRcbiAqIG9yIGltcGxpZWQsIG9mIEdhcnkgQ291cnQuXG4gKi9cbnZhciBTQ0hFTUVTID0ge307XG5mdW5jdGlvbiBwY3RFbmNDaGFyKGNocikge1xuICAgIHZhciBjID0gY2hyLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIGUgPSB2b2lkIDA7XG4gICAgaWYgKGMgPCAxNikgZSA9IFwiJTBcIiArIGMudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7ZWxzZSBpZiAoYyA8IDEyOCkgZSA9IFwiJVwiICsgYy50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtlbHNlIGlmIChjIDwgMjA0OCkgZSA9IFwiJVwiICsgKGMgPj4gNiB8IDE5MikudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBcIiVcIiArIChjICYgNjMgfCAxMjgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO2Vsc2UgZSA9IFwiJVwiICsgKGMgPj4gMTIgfCAyMjQpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCIlXCIgKyAoYyA+PiA2ICYgNjMgfCAxMjgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCIlXCIgKyAoYyAmIDYzIHwgMTI4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHBjdERlY0NoYXJzKHN0cikge1xuICAgIHZhciBuZXdTdHIgPSBcIlwiO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgaWwgPSBzdHIubGVuZ3RoO1xuICAgIHdoaWxlIChpIDwgaWwpIHtcbiAgICAgICAgdmFyIGMgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyAxLCAyKSwgMTYpO1xuICAgICAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgICAgICAgbmV3U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgICAgICBpICs9IDM7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA+PSAxOTQgJiYgYyA8IDIyNCkge1xuICAgICAgICAgICAgaWYgKGlsIC0gaSA+PSA2KSB7XG4gICAgICAgICAgICAgICAgdmFyIGMyID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgNCwgMiksIDE2KTtcbiAgICAgICAgICAgICAgICBuZXdTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDMxKSA8PCA2IHwgYzIgJiA2Myk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSArPSA2O1xuICAgICAgICB9IGVsc2UgaWYgKGMgPj0gMjI0KSB7XG4gICAgICAgICAgICBpZiAoaWwgLSBpID49IDkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2MgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyA0LCAyKSwgMTYpO1xuICAgICAgICAgICAgICAgIHZhciBjMyA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDcsIDIpLCAxNik7XG4gICAgICAgICAgICAgICAgbmV3U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiAxNSkgPDwgMTIgfCAoX2MgJiA2MykgPDwgNiB8IGMzICYgNjMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdTdHIgKz0gc3RyLnN1YnN0cihpLCA5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgKz0gOTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDMpO1xuICAgICAgICAgICAgaSArPSAzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdTdHI7XG59XG5mdW5jdGlvbiBfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgcHJvdG9jb2wpIHtcbiAgICBmdW5jdGlvbiBkZWNvZGVVbnJlc2VydmVkKHN0cikge1xuICAgICAgICB2YXIgZGVjU3RyID0gcGN0RGVjQ2hhcnMoc3RyKTtcbiAgICAgICAgcmV0dXJuICFkZWNTdHIubWF0Y2gocHJvdG9jb2wuVU5SRVNFUlZFRCkgPyBzdHIgOiBkZWNTdHI7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRzLnNjaGVtZSkgY29tcG9uZW50cy5zY2hlbWUgPSBTdHJpbmcoY29tcG9uZW50cy5zY2hlbWUpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShwcm90b2NvbC5OT1RfU0NIRU1FLCBcIlwiKTtcbiAgICBpZiAoY29tcG9uZW50cy51c2VyaW5mbyAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLnVzZXJpbmZvID0gU3RyaW5nKGNvbXBvbmVudHMudXNlcmluZm8pLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UocHJvdG9jb2wuTk9UX1VTRVJJTkZPLCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG4gICAgaWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLmhvc3QgPSBTdHJpbmcoY29tcG9uZW50cy5ob3N0KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UocHJvdG9jb2wuTk9UX0hPU1QsIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICBpZiAoY29tcG9uZW50cy5wYXRoICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMucGF0aCA9IFN0cmluZyhjb21wb25lbnRzLnBhdGgpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoY29tcG9uZW50cy5zY2hlbWUgPyBwcm90b2NvbC5OT1RfUEFUSCA6IHByb3RvY29sLk5PVF9QQVRIX05PU0NIRU1FLCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG4gICAgaWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5xdWVyeSA9IFN0cmluZyhjb21wb25lbnRzLnF1ZXJ5KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKHByb3RvY29sLk5PVF9RVUVSWSwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgIGlmIChjb21wb25lbnRzLmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMuZnJhZ21lbnQgPSBTdHJpbmcoY29tcG9uZW50cy5mcmFnbWVudCkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShwcm90b2NvbC5OT1RfRlJBR01FTlQsIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICByZXR1cm4gY29tcG9uZW50cztcbn1cblxuZnVuY3Rpb24gX3N0cmlwTGVhZGluZ1plcm9zKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXjAqKC4qKS8sIFwiJDFcIikgfHwgXCIwXCI7XG59XG5mdW5jdGlvbiBfbm9ybWFsaXplSVB2NChob3N0LCBwcm90b2NvbCkge1xuICAgIHZhciBtYXRjaGVzID0gaG9zdC5tYXRjaChwcm90b2NvbC5JUFY0QUREUkVTUykgfHwgW107XG5cbiAgICB2YXIgX21hdGNoZXMgPSBzbGljZWRUb0FycmF5KG1hdGNoZXMsIDIpLFxuICAgICAgICBhZGRyZXNzID0gX21hdGNoZXNbMV07XG5cbiAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gYWRkcmVzcy5zcGxpdChcIi5cIikubWFwKF9zdHJpcExlYWRpbmdaZXJvcykuam9pbihcIi5cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGhvc3Q7XG4gICAgfVxufVxuZnVuY3Rpb24gX25vcm1hbGl6ZUlQdjYoaG9zdCwgcHJvdG9jb2wpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IGhvc3QubWF0Y2gocHJvdG9jb2wuSVBWNkFERFJFU1MpIHx8IFtdO1xuXG4gICAgdmFyIF9tYXRjaGVzMiA9IHNsaWNlZFRvQXJyYXkobWF0Y2hlcywgMyksXG4gICAgICAgIGFkZHJlc3MgPSBfbWF0Y2hlczJbMV0sXG4gICAgICAgIHpvbmUgPSBfbWF0Y2hlczJbMl07XG5cbiAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICB2YXIgX2FkZHJlc3MkdG9Mb3dlckNhc2UkID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpLnNwbGl0KCc6OicpLnJldmVyc2UoKSxcbiAgICAgICAgICAgIF9hZGRyZXNzJHRvTG93ZXJDYXNlJDIgPSBzbGljZWRUb0FycmF5KF9hZGRyZXNzJHRvTG93ZXJDYXNlJCwgMiksXG4gICAgICAgICAgICBsYXN0ID0gX2FkZHJlc3MkdG9Mb3dlckNhc2UkMlswXSxcbiAgICAgICAgICAgIGZpcnN0ID0gX2FkZHJlc3MkdG9Mb3dlckNhc2UkMlsxXTtcblxuICAgICAgICB2YXIgZmlyc3RGaWVsZHMgPSBmaXJzdCA/IGZpcnN0LnNwbGl0KFwiOlwiKS5tYXAoX3N0cmlwTGVhZGluZ1plcm9zKSA6IFtdO1xuICAgICAgICB2YXIgbGFzdEZpZWxkcyA9IGxhc3Quc3BsaXQoXCI6XCIpLm1hcChfc3RyaXBMZWFkaW5nWmVyb3MpO1xuICAgICAgICB2YXIgaXNMYXN0RmllbGRJUHY0QWRkcmVzcyA9IHByb3RvY29sLklQVjRBRERSRVNTLnRlc3QobGFzdEZpZWxkc1tsYXN0RmllbGRzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgdmFyIGZpZWxkQ291bnQgPSBpc0xhc3RGaWVsZElQdjRBZGRyZXNzID8gNyA6IDg7XG4gICAgICAgIHZhciBsYXN0RmllbGRzU3RhcnQgPSBsYXN0RmllbGRzLmxlbmd0aCAtIGZpZWxkQ291bnQ7XG4gICAgICAgIHZhciBmaWVsZHMgPSBBcnJheShmaWVsZENvdW50KTtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBmaWVsZENvdW50OyArK3gpIHtcbiAgICAgICAgICAgIGZpZWxkc1t4XSA9IGZpcnN0RmllbGRzW3hdIHx8IGxhc3RGaWVsZHNbbGFzdEZpZWxkc1N0YXJ0ICsgeF0gfHwgJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGFzdEZpZWxkSVB2NEFkZHJlc3MpIHtcbiAgICAgICAgICAgIGZpZWxkc1tmaWVsZENvdW50IC0gMV0gPSBfbm9ybWFsaXplSVB2NChmaWVsZHNbZmllbGRDb3VudCAtIDFdLCBwcm90b2NvbCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFsbFplcm9GaWVsZHMgPSBmaWVsZHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGZpZWxkLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKCFmaWVsZCB8fCBmaWVsZCA9PT0gXCIwXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdExvbmdlc3QgPSBhY2NbYWNjLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0TG9uZ2VzdCAmJiBsYXN0TG9uZ2VzdC5pbmRleCArIGxhc3RMb25nZXN0Lmxlbmd0aCA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdExvbmdlc3QubGVuZ3RoKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjLnB1c2goeyBpbmRleDogaW5kZXgsIGxlbmd0aDogMSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHZhciBsb25nZXN0WmVyb0ZpZWxkcyA9IGFsbFplcm9GaWVsZHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH0pWzBdO1xuICAgICAgICB2YXIgbmV3SG9zdCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGxvbmdlc3RaZXJvRmllbGRzICYmIGxvbmdlc3RaZXJvRmllbGRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBuZXdGaXJzdCA9IGZpZWxkcy5zbGljZSgwLCBsb25nZXN0WmVyb0ZpZWxkcy5pbmRleCk7XG4gICAgICAgICAgICB2YXIgbmV3TGFzdCA9IGZpZWxkcy5zbGljZShsb25nZXN0WmVyb0ZpZWxkcy5pbmRleCArIGxvbmdlc3RaZXJvRmllbGRzLmxlbmd0aCk7XG4gICAgICAgICAgICBuZXdIb3N0ID0gbmV3Rmlyc3Quam9pbihcIjpcIikgKyBcIjo6XCIgKyBuZXdMYXN0LmpvaW4oXCI6XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3SG9zdCA9IGZpZWxkcy5qb2luKFwiOlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoem9uZSkge1xuICAgICAgICAgICAgbmV3SG9zdCArPSBcIiVcIiArIHpvbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0hvc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGhvc3Q7XG4gICAgfVxufVxudmFyIFVSSV9QQVJTRSA9IC9eKD86KFteOlxcLz8jXSspOik/KD86XFwvXFwvKCg/OihbXlxcLz8jQF0qKUApPyhcXFtbXlxcLz8jXFxdXStcXF18W15cXC8/IzpdKikoPzpcXDooXFxkKikpPykpPyhbXj8jXSopKD86XFw/KFteI10qKSk/KD86IygoPzoufFxcbnxcXHIpKikpPy9pO1xudmFyIE5PX01BVENIX0lTX1VOREVGSU5FRCA9IFwiXCIubWF0Y2goLygpezB9LylbMV0gPT09IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIHBhcnNlKHVyaVN0cmluZykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHZhciBjb21wb25lbnRzID0ge307XG4gICAgdmFyIHByb3RvY29sID0gb3B0aW9ucy5pcmkgIT09IGZhbHNlID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MO1xuICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSA9PT0gXCJzdWZmaXhcIikgdXJpU3RyaW5nID0gKG9wdGlvbnMuc2NoZW1lID8gb3B0aW9ucy5zY2hlbWUgKyBcIjpcIiA6IFwiXCIpICsgXCIvL1wiICsgdXJpU3RyaW5nO1xuICAgIHZhciBtYXRjaGVzID0gdXJpU3RyaW5nLm1hdGNoKFVSSV9QQVJTRSk7XG4gICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgaWYgKE5PX01BVENIX0lTX1VOREVGSU5FRCkge1xuICAgICAgICAgICAgLy9zdG9yZSBlYWNoIGNvbXBvbmVudFxuICAgICAgICAgICAgY29tcG9uZW50cy5zY2hlbWUgPSBtYXRjaGVzWzFdO1xuICAgICAgICAgICAgY29tcG9uZW50cy51c2VyaW5mbyA9IG1hdGNoZXNbM107XG4gICAgICAgICAgICBjb21wb25lbnRzLmhvc3QgPSBtYXRjaGVzWzRdO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wYXRoID0gbWF0Y2hlc1s2XSB8fCBcIlwiO1xuICAgICAgICAgICAgY29tcG9uZW50cy5xdWVyeSA9IG1hdGNoZXNbN107XG4gICAgICAgICAgICBjb21wb25lbnRzLmZyYWdtZW50ID0gbWF0Y2hlc1s4XTtcbiAgICAgICAgICAgIC8vZml4IHBvcnQgbnVtYmVyXG4gICAgICAgICAgICBpZiAoaXNOYU4oY29tcG9uZW50cy5wb3J0KSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucG9ydCA9IG1hdGNoZXNbNV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL0lFIEZJWCBmb3IgaW1wcm9wZXIgUmVnRXhwIG1hdGNoaW5nXG4gICAgICAgICAgICAvL3N0b3JlIGVhY2ggY29tcG9uZW50XG4gICAgICAgICAgICBjb21wb25lbnRzLnNjaGVtZSA9IG1hdGNoZXNbMV0gfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29tcG9uZW50cy51c2VyaW5mbyA9IHVyaVN0cmluZy5pbmRleE9mKFwiQFwiKSAhPT0gLTEgPyBtYXRjaGVzWzNdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gdXJpU3RyaW5nLmluZGV4T2YoXCIvL1wiKSAhPT0gLTEgPyBtYXRjaGVzWzRdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wYXRoID0gbWF0Y2hlc1s2XSB8fCBcIlwiO1xuICAgICAgICAgICAgY29tcG9uZW50cy5xdWVyeSA9IHVyaVN0cmluZy5pbmRleE9mKFwiP1wiKSAhPT0gLTEgPyBtYXRjaGVzWzddIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29tcG9uZW50cy5mcmFnbWVudCA9IHVyaVN0cmluZy5pbmRleE9mKFwiI1wiKSAhPT0gLTEgPyBtYXRjaGVzWzhdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy9maXggcG9ydCBudW1iZXJcbiAgICAgICAgICAgIGlmIChpc05hTihjb21wb25lbnRzLnBvcnQpKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gdXJpU3RyaW5nLm1hdGNoKC9cXC9cXC8oPzoufFxcbikqXFw6KD86XFwvfFxcP3xcXCN8JCkvKSA/IG1hdGNoZXNbNF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBvbmVudHMuaG9zdCkge1xuICAgICAgICAgICAgLy9ub3JtYWxpemUgSVAgaG9zdHNcbiAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9IF9ub3JtYWxpemVJUHY2KF9ub3JtYWxpemVJUHY0KGNvbXBvbmVudHMuaG9zdCwgcHJvdG9jb2wpLCBwcm90b2NvbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy9kZXRlcm1pbmUgcmVmZXJlbmNlIHR5cGVcbiAgICAgICAgaWYgKGNvbXBvbmVudHMuc2NoZW1lID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy51c2VyaW5mbyA9PT0gdW5kZWZpbmVkICYmIGNvbXBvbmVudHMuaG9zdCA9PT0gdW5kZWZpbmVkICYmIGNvbXBvbmVudHMucG9ydCA9PT0gdW5kZWZpbmVkICYmICFjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5xdWVyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwic2FtZS1kb2N1bWVudFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvbmVudHMuc2NoZW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5yZWZlcmVuY2UgPSBcImFic29sdXRlXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwidXJpXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy9jaGVjayBmb3IgcmVmZXJlbmNlIGVycm9yc1xuICAgICAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgJiYgb3B0aW9ucy5yZWZlcmVuY2UgIT09IFwic3VmZml4XCIgJiYgb3B0aW9ucy5yZWZlcmVuY2UgIT09IGNvbXBvbmVudHMucmVmZXJlbmNlKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIlVSSSBpcyBub3QgYSBcIiArIG9wdGlvbnMucmVmZXJlbmNlICsgXCIgcmVmZXJlbmNlLlwiO1xuICAgICAgICB9XG4gICAgICAgIC8vZmluZCBzY2hlbWUgaGFuZGxlclxuICAgICAgICB2YXIgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbKG9wdGlvbnMuc2NoZW1lIHx8IGNvbXBvbmVudHMuc2NoZW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAvL2NoZWNrIGlmIHNjaGVtZSBjYW4ndCBoYW5kbGUgSVJJc1xuICAgICAgICBpZiAoIW9wdGlvbnMudW5pY29kZVN1cHBvcnQgJiYgKCFzY2hlbWVIYW5kbGVyIHx8ICFzY2hlbWVIYW5kbGVyLnVuaWNvZGVTdXBwb3J0KSkge1xuICAgICAgICAgICAgLy9pZiBob3N0IGNvbXBvbmVudCBpcyBhIGRvbWFpbiBuYW1lXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50cy5ob3N0ICYmIChvcHRpb25zLmRvbWFpbkhvc3QgfHwgc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLmRvbWFpbkhvc3QpKSB7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IFVuaWNvZGUgSUROIC0+IEFTQ0lJIElETlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9IHB1bnljb2RlLnRvQVNDSUkoY29tcG9uZW50cy5ob3N0LnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHBjdERlY0NoYXJzKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSG9zdCdzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIEFTQ0lJIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY29udmVydCBJUkkgLT4gVVJJXG4gICAgICAgICAgICBfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgVVJJX1BST1RPQ09MKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vbm9ybWFsaXplIGVuY29kaW5nc1xuICAgICAgICAgICAgX25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKGNvbXBvbmVudHMsIHByb3RvY29sKTtcbiAgICAgICAgfVxuICAgICAgICAvL3BlcmZvcm0gc2NoZW1lIHNwZWNpZmljIHBhcnNpbmdcbiAgICAgICAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5wYXJzZSkge1xuICAgICAgICAgICAgc2NoZW1lSGFuZGxlci5wYXJzZShjb21wb25lbnRzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiVVJJIGNhbiBub3QgYmUgcGFyc2VkLlwiO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50cztcbn1cblxuZnVuY3Rpb24gX3JlY29tcG9zZUF1dGhvcml0eShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgdmFyIHByb3RvY29sID0gb3B0aW9ucy5pcmkgIT09IGZhbHNlID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MO1xuICAgIHZhciB1cmlUb2tlbnMgPSBbXTtcbiAgICBpZiAoY29tcG9uZW50cy51c2VyaW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMudXNlcmluZm8pO1xuICAgICAgICB1cmlUb2tlbnMucHVzaChcIkBcIik7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRzLmhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvL25vcm1hbGl6ZSBJUCBob3N0cywgYWRkIGJyYWNrZXRzIGFuZCBlc2NhcGUgem9uZSBzZXBhcmF0b3IgZm9yIElQdjZcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goX25vcm1hbGl6ZUlQdjYoX25vcm1hbGl6ZUlQdjQoU3RyaW5nKGNvbXBvbmVudHMuaG9zdCksIHByb3RvY29sKSwgcHJvdG9jb2wpLnJlcGxhY2UocHJvdG9jb2wuSVBWNkFERFJFU1MsIGZ1bmN0aW9uIChfLCAkMSwgJDIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIltcIiArICQxICsgKCQyID8gXCIlMjVcIiArICQyIDogXCJcIikgKyBcIl1cIjtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudHMucG9ydCA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgY29tcG9uZW50cy5wb3J0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiOlwiKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goU3RyaW5nKGNvbXBvbmVudHMucG9ydCkpO1xuICAgIH1cbiAgICByZXR1cm4gdXJpVG9rZW5zLmxlbmd0aCA/IHVyaVRva2Vucy5qb2luKFwiXCIpIDogdW5kZWZpbmVkO1xufVxuXG52YXIgUkRTMSA9IC9eXFwuXFwuP1xcLy87XG52YXIgUkRTMiA9IC9eXFwvXFwuKFxcL3wkKS87XG52YXIgUkRTMyA9IC9eXFwvXFwuXFwuKFxcL3wkKS87XG52YXIgUkRTNSA9IC9eXFwvPyg/Oi58XFxuKSo/KD89XFwvfCQpLztcbmZ1bmN0aW9uIHJlbW92ZURvdFNlZ21lbnRzKGlucHV0KSB7XG4gICAgdmFyIG91dHB1dCA9IFtdO1xuICAgIHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoKFJEUzEpKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoUkRTMSwgXCJcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQubWF0Y2goUkRTMikpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMyLCBcIi9cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQubWF0Y2goUkRTMykpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMzLCBcIi9cIik7XG4gICAgICAgICAgICBvdXRwdXQucG9wKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQgPT09IFwiLlwiIHx8IGlucHV0ID09PSBcIi4uXCIpIHtcbiAgICAgICAgICAgIGlucHV0ID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbSA9IGlucHV0Lm1hdGNoKFJEUzUpO1xuICAgICAgICAgICAgaWYgKGltKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBpbVswXTtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBkb3Qgc2VnbWVudCBjb25kaXRpb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dC5qb2luKFwiXCIpO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemUoY29tcG9uZW50cykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHZhciBwcm90b2NvbCA9IG9wdGlvbnMuaXJpID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MO1xuICAgIHZhciB1cmlUb2tlbnMgPSBbXTtcbiAgICAvL2ZpbmQgc2NoZW1lIGhhbmRsZXJcbiAgICB2YXIgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbKG9wdGlvbnMuc2NoZW1lIHx8IGNvbXBvbmVudHMuc2NoZW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCldO1xuICAgIC8vcGVyZm9ybSBzY2hlbWUgc3BlY2lmaWMgc2VyaWFsaXphdGlvblxuICAgIGlmIChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZShjb21wb25lbnRzLCBvcHRpb25zKTtcbiAgICBpZiAoY29tcG9uZW50cy5ob3N0KSB7XG4gICAgICAgIC8vaWYgaG9zdCBjb21wb25lbnQgaXMgYW4gSVB2NiBhZGRyZXNzXG4gICAgICAgIGlmIChwcm90b2NvbC5JUFY2QUREUkVTUy50ZXN0KGNvbXBvbmVudHMuaG9zdCkpIHt9XG4gICAgICAgIC8vVE9ETzogbm9ybWFsaXplIElQdjYgYWRkcmVzcyBhcyBwZXIgUkZDIDU5NTJcblxuICAgICAgICAvL2lmIGhvc3QgY29tcG9uZW50IGlzIGEgZG9tYWluIG5hbWVcbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5kb21haW5Ib3N0IHx8IHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5kb21haW5Ib3N0KSB7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IElETiB2aWEgcHVueWNvZGVcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLmhvc3QgPSAhb3B0aW9ucy5pcmkgPyBwdW55Y29kZS50b0FTQ0lJKGNvbXBvbmVudHMuaG9zdC5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBwY3REZWNDaGFycykudG9Mb3dlckNhc2UoKSkgOiBwdW55Y29kZS50b1VuaWNvZGUoY29tcG9uZW50cy5ob3N0KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSG9zdCdzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIFwiICsgKCFvcHRpb25zLmlyaSA/IFwiQVNDSUlcIiA6IFwiVW5pY29kZVwiKSArIFwiIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgLy9ub3JtYWxpemUgZW5jb2RpbmdcbiAgICBfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgcHJvdG9jb2wpO1xuICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAhPT0gXCJzdWZmaXhcIiAmJiBjb21wb25lbnRzLnNjaGVtZSkge1xuICAgICAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnNjaGVtZSk7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiOlwiKTtcbiAgICB9XG4gICAgdmFyIGF1dGhvcml0eSA9IF9yZWNvbXBvc2VBdXRob3JpdHkoY29tcG9uZW50cywgb3B0aW9ucyk7XG4gICAgaWYgKGF1dGhvcml0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAhPT0gXCJzdWZmaXhcIikge1xuICAgICAgICAgICAgdXJpVG9rZW5zLnB1c2goXCIvL1wiKTtcbiAgICAgICAgfVxuICAgICAgICB1cmlUb2tlbnMucHVzaChhdXRob3JpdHkpO1xuICAgICAgICBpZiAoY29tcG9uZW50cy5wYXRoICYmIGNvbXBvbmVudHMucGF0aC5jaGFyQXQoMCkgIT09IFwiL1wiKSB7XG4gICAgICAgICAgICB1cmlUb2tlbnMucHVzaChcIi9cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBzID0gY29tcG9uZW50cy5wYXRoO1xuICAgICAgICBpZiAoIW9wdGlvbnMuYWJzb2x1dGVQYXRoICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci5hYnNvbHV0ZVBhdGgpKSB7XG4gICAgICAgICAgICBzID0gcmVtb3ZlRG90U2VnbWVudHMocyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF1dGhvcml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKC9eXFwvXFwvLywgXCIvJTJGXCIpOyAvL2Rvbid0IGFsbG93IHRoZSBwYXRoIHRvIHN0YXJ0IHdpdGggXCIvL1wiXG4gICAgICAgIH1cbiAgICAgICAgdXJpVG9rZW5zLnB1c2gocyk7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRzLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goXCI/XCIpO1xuICAgICAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnF1ZXJ5KTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cmlUb2tlbnMucHVzaChcIiNcIik7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMuZnJhZ21lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdXJpVG9rZW5zLmpvaW4oXCJcIik7IC8vbWVyZ2UgdG9rZW5zIGludG8gYSBzdHJpbmdcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudHMoYmFzZSwgcmVsYXRpdmUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHNraXBOb3JtYWxpemF0aW9uID0gYXJndW1lbnRzWzNdO1xuXG4gICAgdmFyIHRhcmdldCA9IHt9O1xuICAgIGlmICghc2tpcE5vcm1hbGl6YXRpb24pIHtcbiAgICAgICAgYmFzZSA9IHBhcnNlKHNlcmlhbGl6ZShiYXNlLCBvcHRpb25zKSwgb3B0aW9ucyk7IC8vbm9ybWFsaXplIGJhc2UgY29tcG9uZW50c1xuICAgICAgICByZWxhdGl2ZSA9IHBhcnNlKHNlcmlhbGl6ZShyZWxhdGl2ZSwgb3B0aW9ucyksIG9wdGlvbnMpOyAvL25vcm1hbGl6ZSByZWxhdGl2ZSBjb21wb25lbnRzXG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghb3B0aW9ucy50b2xlcmFudCAmJiByZWxhdGl2ZS5zY2hlbWUpIHtcbiAgICAgICAgdGFyZ2V0LnNjaGVtZSA9IHJlbGF0aXZlLnNjaGVtZTtcbiAgICAgICAgLy90YXJnZXQuYXV0aG9yaXR5ID0gcmVsYXRpdmUuYXV0aG9yaXR5O1xuICAgICAgICB0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mbztcbiAgICAgICAgdGFyZ2V0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICB0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCBcIlwiKTtcbiAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlbGF0aXZlLnVzZXJpbmZvICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUuaG9zdCAhPT0gdW5kZWZpbmVkIHx8IHJlbGF0aXZlLnBvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy90YXJnZXQuYXV0aG9yaXR5ID0gcmVsYXRpdmUuYXV0aG9yaXR5O1xuICAgICAgICAgICAgdGFyZ2V0LnVzZXJpbmZvID0gcmVsYXRpdmUudXNlcmluZm87XG4gICAgICAgICAgICB0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgICAgICB0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGggfHwgXCJcIik7XG4gICAgICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghcmVsYXRpdmUucGF0aCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gYmFzZS5wYXRoO1xuICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5xdWVyeSA9IGJhc2UucXVlcnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmVsYXRpdmUucGF0aC5jaGFyQXQoMCkgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChiYXNlLnVzZXJpbmZvICE9PSB1bmRlZmluZWQgfHwgYmFzZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgYmFzZS5wb3J0ICE9PSB1bmRlZmluZWQpICYmICFiYXNlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gXCIvXCIgKyByZWxhdGl2ZS5wYXRoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFiYXNlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVsYXRpdmUucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKDAsIGJhc2UucGF0aC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKSArIHJlbGF0aXZlLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyh0YXJnZXQucGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy90YXJnZXQuYXV0aG9yaXR5ID0gYmFzZS5hdXRob3JpdHk7XG4gICAgICAgICAgICB0YXJnZXQudXNlcmluZm8gPSBiYXNlLnVzZXJpbmZvO1xuICAgICAgICAgICAgdGFyZ2V0Lmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgICB0YXJnZXQucG9ydCA9IGJhc2UucG9ydDtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuc2NoZW1lID0gYmFzZS5zY2hlbWU7XG4gICAgfVxuICAgIHRhcmdldC5mcmFnbWVudCA9IHJlbGF0aXZlLmZyYWdtZW50O1xuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUoYmFzZVVSSSwgcmVsYXRpdmVVUkksIG9wdGlvbnMpIHtcbiAgICB2YXIgc2NoZW1lbGVzc09wdGlvbnMgPSBhc3NpZ24oeyBzY2hlbWU6ICdudWxsJyB9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gc2VyaWFsaXplKHJlc29sdmVDb21wb25lbnRzKHBhcnNlKGJhc2VVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgcGFyc2UocmVsYXRpdmVVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgc2NoZW1lbGVzc09wdGlvbnMsIHRydWUpLCBzY2hlbWVsZXNzT3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZSh1cmksIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHVyaSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB1cmkgPSBzZXJpYWxpemUocGFyc2UodXJpLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0eXBlT2YodXJpKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB1cmkgPSBwYXJzZShzZXJpYWxpemUodXJpLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB1cmk7XG59XG5cbmZ1bmN0aW9uIGVxdWFsKHVyaUEsIHVyaUIsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHVyaUEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdXJpQSA9IHNlcmlhbGl6ZShwYXJzZSh1cmlBLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0eXBlT2YodXJpQSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdXJpQSA9IHNlcmlhbGl6ZSh1cmlBLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB1cmlCID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHVyaUIgPSBzZXJpYWxpemUocGFyc2UodXJpQiwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAodHlwZU9mKHVyaUIpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHVyaUIgPSBzZXJpYWxpemUodXJpQiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB1cmlBID09PSB1cmlCO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVDb21wb25lbnQoc3RyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHN0ciAmJiBzdHIudG9TdHJpbmcoKS5yZXBsYWNlKCFvcHRpb25zIHx8ICFvcHRpb25zLmlyaSA/IFVSSV9QUk9UT0NPTC5FU0NBUEUgOiBJUklfUFJPVE9DT0wuRVNDQVBFLCBwY3RFbmNDaGFyKTtcbn1cblxuZnVuY3Rpb24gdW5lc2NhcGVDb21wb25lbnQoc3RyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHN0ciAmJiBzdHIudG9TdHJpbmcoKS5yZXBsYWNlKCFvcHRpb25zIHx8ICFvcHRpb25zLmlyaSA/IFVSSV9QUk9UT0NPTC5QQ1RfRU5DT0RFRCA6IElSSV9QUk9UT0NPTC5QQ1RfRU5DT0RFRCwgcGN0RGVjQ2hhcnMpO1xufVxuXG52YXIgaGFuZGxlciA9IHtcbiAgICBzY2hlbWU6IFwiaHR0cFwiLFxuICAgIGRvbWFpbkhvc3Q6IHRydWUsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgLy9yZXBvcnQgbWlzc2luZyBob3N0XG4gICAgICAgIGlmICghY29tcG9uZW50cy5ob3N0KSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIkhUVFAgVVJJcyBtdXN0IGhhdmUgYSBob3N0LlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgc2VjdXJlID0gU3RyaW5nKGNvbXBvbmVudHMuc2NoZW1lKS50b0xvd2VyQ2FzZSgpID09PSBcImh0dHBzXCI7XG4gICAgICAgIC8vbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcbiAgICAgICAgaWYgKGNvbXBvbmVudHMucG9ydCA9PT0gKHNlY3VyZSA/IDQ0MyA6IDgwKSB8fCBjb21wb25lbnRzLnBvcnQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucG9ydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvL25vcm1hbGl6ZSB0aGUgZW1wdHkgcGF0aFxuICAgICAgICBpZiAoIWNvbXBvbmVudHMucGF0aCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5wYXRoID0gXCIvXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy9OT1RFOiBXZSBkbyBub3QgcGFyc2UgcXVlcnkgc3RyaW5ncyBmb3IgSFRUUCBVUklzXG4gICAgICAgIC8vYXMgV1dXIEZvcm0gVXJsIEVuY29kZWQgcXVlcnkgc3RyaW5ncyBhcmUgcGFydCBvZiB0aGUgSFRNTDQrIHNwZWMsXG4gICAgICAgIC8vYW5kIG5vdCB0aGUgSFRUUCBzcGVjLlxuICAgICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9XG59O1xuXG52YXIgaGFuZGxlciQxID0ge1xuICAgIHNjaGVtZTogXCJodHRwc1wiLFxuICAgIGRvbWFpbkhvc3Q6IGhhbmRsZXIuZG9tYWluSG9zdCxcbiAgICBwYXJzZTogaGFuZGxlci5wYXJzZSxcbiAgICBzZXJpYWxpemU6IGhhbmRsZXIuc2VyaWFsaXplXG59O1xuXG5mdW5jdGlvbiBpc1NlY3VyZSh3c0NvbXBvbmVudHMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdzQ29tcG9uZW50cy5zZWN1cmUgPT09ICdib29sZWFuJyA/IHdzQ29tcG9uZW50cy5zZWN1cmUgOiBTdHJpbmcod3NDb21wb25lbnRzLnNjaGVtZSkudG9Mb3dlckNhc2UoKSA9PT0gXCJ3c3NcIjtcbn1cbi8vUkZDIDY0NTVcbnZhciBoYW5kbGVyJDIgPSB7XG4gICAgc2NoZW1lOiBcIndzXCIsXG4gICAgZG9tYWluSG9zdDogdHJ1ZSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgd3NDb21wb25lbnRzID0gY29tcG9uZW50cztcbiAgICAgICAgLy9pbmRpY2F0ZSBpZiB0aGUgc2VjdXJlIGZsYWcgaXMgc2V0XG4gICAgICAgIHdzQ29tcG9uZW50cy5zZWN1cmUgPSBpc1NlY3VyZSh3c0NvbXBvbmVudHMpO1xuICAgICAgICAvL2NvbnN0cnVjdCByZXNvdWNlIG5hbWVcbiAgICAgICAgd3NDb21wb25lbnRzLnJlc291cmNlTmFtZSA9ICh3c0NvbXBvbmVudHMucGF0aCB8fCAnLycpICsgKHdzQ29tcG9uZW50cy5xdWVyeSA/ICc/JyArIHdzQ29tcG9uZW50cy5xdWVyeSA6ICcnKTtcbiAgICAgICAgd3NDb21wb25lbnRzLnBhdGggPSB1bmRlZmluZWQ7XG4gICAgICAgIHdzQ29tcG9uZW50cy5xdWVyeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHdzQ29tcG9uZW50cztcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplKHdzQ29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICAvL25vcm1hbGl6ZSB0aGUgZGVmYXVsdCBwb3J0XG4gICAgICAgIGlmICh3c0NvbXBvbmVudHMucG9ydCA9PT0gKGlzU2VjdXJlKHdzQ29tcG9uZW50cykgPyA0NDMgOiA4MCkgfHwgd3NDb21wb25lbnRzLnBvcnQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vZW5zdXJlIHNjaGVtZSBtYXRjaGVzIHNlY3VyZSBmbGFnXG4gICAgICAgIGlmICh0eXBlb2Ygd3NDb21wb25lbnRzLnNlY3VyZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB3c0NvbXBvbmVudHMuc2NoZW1lID0gd3NDb21wb25lbnRzLnNlY3VyZSA/ICd3c3MnIDogJ3dzJztcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5zZWN1cmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9yZWNvbnN0cnVjdCBwYXRoIGZyb20gcmVzb3VyY2UgbmFtZVxuICAgICAgICBpZiAod3NDb21wb25lbnRzLnJlc291cmNlTmFtZSkge1xuICAgICAgICAgICAgdmFyIF93c0NvbXBvbmVudHMkcmVzb3VyYyA9IHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUuc3BsaXQoJz8nKSxcbiAgICAgICAgICAgICAgICBfd3NDb21wb25lbnRzJHJlc291cmMyID0gc2xpY2VkVG9BcnJheShfd3NDb21wb25lbnRzJHJlc291cmMsIDIpLFxuICAgICAgICAgICAgICAgIHBhdGggPSBfd3NDb21wb25lbnRzJHJlc291cmMyWzBdLFxuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gX3dzQ29tcG9uZW50cyRyZXNvdXJjMlsxXTtcblxuICAgICAgICAgICAgd3NDb21wb25lbnRzLnBhdGggPSBwYXRoICYmIHBhdGggIT09ICcvJyA/IHBhdGggOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB3c0NvbXBvbmVudHMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9mb3JiaWQgZnJhZ21lbnQgY29tcG9uZW50XG4gICAgICAgIHdzQ29tcG9uZW50cy5mcmFnbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHdzQ29tcG9uZW50cztcbiAgICB9XG59O1xuXG52YXIgaGFuZGxlciQzID0ge1xuICAgIHNjaGVtZTogXCJ3c3NcIixcbiAgICBkb21haW5Ib3N0OiBoYW5kbGVyJDIuZG9tYWluSG9zdCxcbiAgICBwYXJzZTogaGFuZGxlciQyLnBhcnNlLFxuICAgIHNlcmlhbGl6ZTogaGFuZGxlciQyLnNlcmlhbGl6ZVxufTtcblxudmFyIE8gPSB7fTtcbnZhciBpc0lSSSA9IHRydWU7XG4vL1JGQyAzOTg2XG52YXIgVU5SRVNFUlZFRCQkID0gXCJbQS1aYS16MC05XFxcXC1cXFxcLlxcXFxfXFxcXH5cIiArIChpc0lSSSA/IFwiXFxcXHhBMC1cXFxcdTIwMERcXFxcdTIwMTAtXFxcXHUyMDI5XFxcXHUyMDJGLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXCIgOiBcIlwiKSArIFwiXVwiO1xudmFyIEhFWERJRyQkID0gXCJbMC05QS1GYS1mXVwiOyAvL2Nhc2UtaW5zZW5zaXRpdmVcbnZhciBQQ1RfRU5DT0RFRCQgPSBzdWJleHAoc3ViZXhwKFwiJVtFRmVmXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlWzg5QS1GYS1mXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSk7IC8vZXhwYW5kZWRcbi8vUkZDIDUzMjIsIGV4Y2VwdCB0aGVzZSBzeW1ib2xzIGFzIHBlciBSRkMgNjA2ODogQCA6IC8gPyAjIFsgXSAmIDsgPVxuLy9jb25zdCBBVEVYVCQkID0gXCJbQS1aYS16MC05XFxcXCFcXFxcI1xcXFwkXFxcXCVcXFxcJlxcXFwnXFxcXCpcXFxcK1xcXFwtXFxcXC9cXFxcPVxcXFw/XFxcXF5cXFxcX1xcXFxgXFxcXHtcXFxcfFxcXFx9XFxcXH5dXCI7XG4vL2NvbnN0IFdTUCQkID0gXCJbXFxcXHgyMFxcXFx4MDldXCI7XG4vL2NvbnN0IE9CU19RVEVYVCQkID0gXCJbXFxcXHgwMS1cXFxceDA4XFxcXHgwQlxcXFx4MENcXFxceDBFLVxcXFx4MUZcXFxceDdGXVwiOyAgLy8oJWQxLTggLyAlZDExLTEyIC8gJWQxNC0zMSAvICVkMTI3KVxuLy9jb25zdCBRVEVYVCQkID0gbWVyZ2UoXCJbXFxcXHgyMVxcXFx4MjMtXFxcXHg1QlxcXFx4NUQtXFxcXHg3RV1cIiwgT0JTX1FURVhUJCQpOyAgLy8lZDMzIC8gJWQzNS05MSAvICVkOTMtMTI2IC8gb2JzLXF0ZXh0XG4vL2NvbnN0IFZDSEFSJCQgPSBcIltcXFxceDIxLVxcXFx4N0VdXCI7XG4vL2NvbnN0IFdTUCQkID0gXCJbXFxcXHgyMFxcXFx4MDldXCI7XG4vL2NvbnN0IE9CU19RUCQgPSBzdWJleHAoXCJcXFxcXFxcXFwiICsgbWVyZ2UoXCJbXFxcXHgwMFxcXFx4MERcXFxceDBBXVwiLCBPQlNfUVRFWFQkJCkpOyAgLy8lZDAgLyBDUiAvIExGIC8gb2JzLXF0ZXh0XG4vL2NvbnN0IEZXUyQgPSBzdWJleHAoc3ViZXhwKFdTUCQkICsgXCIqXCIgKyBcIlxcXFx4MERcXFxceDBBXCIpICsgXCI/XCIgKyBXU1AkJCArIFwiK1wiKTtcbi8vY29uc3QgUVVPVEVEX1BBSVIkID0gc3ViZXhwKHN1YmV4cChcIlxcXFxcXFxcXCIgKyBzdWJleHAoVkNIQVIkJCArIFwifFwiICsgV1NQJCQpKSArIFwifFwiICsgT0JTX1FQJCk7XG4vL2NvbnN0IFFVT1RFRF9TVFJJTkckID0gc3ViZXhwKCdcXFxcXCInICsgc3ViZXhwKEZXUyQgKyBcIj9cIiArIFFDT05URU5UJCkgKyBcIipcIiArIEZXUyQgKyBcIj9cIiArICdcXFxcXCInKTtcbnZhciBBVEVYVCQkID0gXCJbQS1aYS16MC05XFxcXCFcXFxcJFxcXFwlXFxcXCdcXFxcKlxcXFwrXFxcXC1cXFxcXlxcXFxfXFxcXGBcXFxce1xcXFx8XFxcXH1cXFxcfl1cIjtcbnZhciBRVEVYVCQkID0gXCJbXFxcXCFcXFxcJFxcXFwlXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXC1cXFxcLjAtOVxcXFw8XFxcXD5BLVpcXFxceDVFLVxcXFx4N0VdXCI7XG52YXIgVkNIQVIkJCA9IG1lcmdlKFFURVhUJCQsIFwiW1xcXFxcXFwiXFxcXFxcXFxdXCIpO1xudmFyIFNPTUVfREVMSU1TJCQgPSBcIltcXFxcIVxcXFwkXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXDtcXFxcOlxcXFxAXVwiO1xudmFyIFVOUkVTRVJWRUQgPSBuZXcgUmVnRXhwKFVOUkVTRVJWRUQkJCwgXCJnXCIpO1xudmFyIFBDVF9FTkNPREVEID0gbmV3IFJlZ0V4cChQQ1RfRU5DT0RFRCQsIFwiZ1wiKTtcbnZhciBOT1RfTE9DQUxfUEFSVCA9IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgQVRFWFQkJCwgXCJbXFxcXC5dXCIsICdbXFxcXFwiXScsIFZDSEFSJCQpLCBcImdcIik7XG52YXIgTk9UX0hGTkFNRSA9IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgVU5SRVNFUlZFRCQkLCBTT01FX0RFTElNUyQkKSwgXCJnXCIpO1xudmFyIE5PVF9IRlZBTFVFID0gTk9UX0hGTkFNRTtcbmZ1bmN0aW9uIGRlY29kZVVucmVzZXJ2ZWQoc3RyKSB7XG4gICAgdmFyIGRlY1N0ciA9IHBjdERlY0NoYXJzKHN0cik7XG4gICAgcmV0dXJuICFkZWNTdHIubWF0Y2goVU5SRVNFUlZFRCkgPyBzdHIgOiBkZWNTdHI7XG59XG52YXIgaGFuZGxlciQ0ID0ge1xuICAgIHNjaGVtZTogXCJtYWlsdG9cIixcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UkJDEoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgbWFpbHRvQ29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gICAgICAgIHZhciB0byA9IG1haWx0b0NvbXBvbmVudHMudG8gPSBtYWlsdG9Db21wb25lbnRzLnBhdGggPyBtYWlsdG9Db21wb25lbnRzLnBhdGguc3BsaXQoXCIsXCIpIDogW107XG4gICAgICAgIG1haWx0b0NvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1haWx0b0NvbXBvbmVudHMucXVlcnkpIHtcbiAgICAgICAgICAgIHZhciB1bmtub3duSGVhZGVycyA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBoZmllbGRzID0gbWFpbHRvQ29tcG9uZW50cy5xdWVyeS5zcGxpdChcIiZcIik7XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMCwgeGwgPSBoZmllbGRzLmxlbmd0aDsgeCA8IHhsOyArK3gpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGZpZWxkID0gaGZpZWxkc1t4XS5zcGxpdChcIj1cIik7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChoZmllbGRbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9BZGRycyA9IGhmaWVsZFsxXS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfeCA9IDAsIF94bCA9IHRvQWRkcnMubGVuZ3RoOyBfeCA8IF94bDsgKytfeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvLnB1c2godG9BZGRyc1tfeF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdWJqZWN0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWlsdG9Db21wb25lbnRzLnN1YmplY3QgPSB1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWlsdG9Db21wb25lbnRzLmJvZHkgPSB1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmtub3duSGVhZGVycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW3VuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFswXSwgb3B0aW9ucyldID0gdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzFdLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmtub3duSGVhZGVycykgbWFpbHRvQ29tcG9uZW50cy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgfVxuICAgICAgICBtYWlsdG9Db21wb25lbnRzLnF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKHZhciBfeDIgPSAwLCBfeGwyID0gdG8ubGVuZ3RoOyBfeDIgPCBfeGwyOyArK194Mikge1xuICAgICAgICAgICAgdmFyIGFkZHIgPSB0b1tfeDJdLnNwbGl0KFwiQFwiKTtcbiAgICAgICAgICAgIGFkZHJbMF0gPSB1bmVzY2FwZUNvbXBvbmVudChhZGRyWzBdKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCkge1xuICAgICAgICAgICAgICAgIC8vY29udmVydCBVbmljb2RlIElETiAtPiBBU0NJSSBJRE5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhZGRyWzFdID0gcHVueWNvZGUudG9BU0NJSSh1bmVzY2FwZUNvbXBvbmVudChhZGRyWzFdLCBvcHRpb25zKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1haWx0b0NvbXBvbmVudHMuZXJyb3IgPSBtYWlsdG9Db21wb25lbnRzLmVycm9yIHx8IFwiRW1haWwgYWRkcmVzcydzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIEFTQ0lJIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkclsxXSA9IHVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMV0sIG9wdGlvbnMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b1tfeDJdID0gYWRkci5qb2luKFwiQFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFpbHRvQ29tcG9uZW50cztcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplJCQxKG1haWx0b0NvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBtYWlsdG9Db21wb25lbnRzO1xuICAgICAgICB2YXIgdG8gPSB0b0FycmF5KG1haWx0b0NvbXBvbmVudHMudG8pO1xuICAgICAgICBpZiAodG8pIHtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwLCB4bCA9IHRvLmxlbmd0aDsgeCA8IHhsOyArK3gpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9BZGRyID0gU3RyaW5nKHRvW3hdKTtcbiAgICAgICAgICAgICAgICB2YXIgYXRJZHggPSB0b0FkZHIubGFzdEluZGV4T2YoXCJAXCIpO1xuICAgICAgICAgICAgICAgIHZhciBsb2NhbFBhcnQgPSB0b0FkZHIuc2xpY2UoMCwgYXRJZHgpLnJlcGxhY2UoUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKS5yZXBsYWNlKE5PVF9MT0NBTF9QQVJULCBwY3RFbmNDaGFyKTtcbiAgICAgICAgICAgICAgICB2YXIgZG9tYWluID0gdG9BZGRyLnNsaWNlKGF0SWR4ICsgMSk7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IElETiB2aWEgcHVueWNvZGVcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkb21haW4gPSAhb3B0aW9ucy5pcmkgPyBwdW55Y29kZS50b0FTQ0lJKHVuZXNjYXBlQ29tcG9uZW50KGRvbWFpbiwgb3B0aW9ucykudG9Mb3dlckNhc2UoKSkgOiBwdW55Y29kZS50b1VuaWNvZGUoZG9tYWluKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiRW1haWwgYWRkcmVzcydzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIFwiICsgKCFvcHRpb25zLmlyaSA/IFwiQVNDSUlcIiA6IFwiVW5pY29kZVwiKSArIFwiIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b1t4XSA9IGxvY2FsUGFydCArIFwiQFwiICsgZG9tYWluO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcG9uZW50cy5wYXRoID0gdG8uam9pbihcIixcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWRlcnMgPSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgPSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgfHwge307XG4gICAgICAgIGlmIChtYWlsdG9Db21wb25lbnRzLnN1YmplY3QpIGhlYWRlcnNbXCJzdWJqZWN0XCJdID0gbWFpbHRvQ29tcG9uZW50cy5zdWJqZWN0O1xuICAgICAgICBpZiAobWFpbHRvQ29tcG9uZW50cy5ib2R5KSBoZWFkZXJzW1wiYm9keVwiXSA9IG1haWx0b0NvbXBvbmVudHMuYm9keTtcbiAgICAgICAgdmFyIGZpZWxkcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIGlmIChoZWFkZXJzW25hbWVdICE9PSBPW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2gobmFtZS5yZXBsYWNlKFBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfSEZOQU1FLCBwY3RFbmNDaGFyKSArIFwiPVwiICsgaGVhZGVyc1tuYW1lXS5yZXBsYWNlKFBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfSEZWQUxVRSwgcGN0RW5jQ2hhcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnF1ZXJ5ID0gZmllbGRzLmpvaW4oXCImXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbn07XG5cbnZhciBVUk5fUEFSU0UgPSAvXihbXlxcOl0rKVxcOiguKikvO1xuLy9SRkMgMjE0MVxudmFyIGhhbmRsZXIkNSA9IHtcbiAgICBzY2hlbWU6IFwidXJuXCIsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlJCQxKGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5wYXRoLm1hdGNoKFVSTl9QQVJTRSk7XG4gICAgICAgIHZhciB1cm5Db21wb25lbnRzID0gY29tcG9uZW50cztcbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgIHZhciBzY2hlbWUgPSBvcHRpb25zLnNjaGVtZSB8fCB1cm5Db21wb25lbnRzLnNjaGVtZSB8fCBcInVyblwiO1xuICAgICAgICAgICAgdmFyIG5pZCA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBuc3MgPSBtYXRjaGVzWzJdO1xuICAgICAgICAgICAgdmFyIHVyblNjaGVtZSA9IHNjaGVtZSArIFwiOlwiICsgKG9wdGlvbnMubmlkIHx8IG5pZCk7XG4gICAgICAgICAgICB2YXIgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbdXJuU2NoZW1lXTtcbiAgICAgICAgICAgIHVybkNvbXBvbmVudHMubmlkID0gbmlkO1xuICAgICAgICAgICAgdXJuQ29tcG9uZW50cy5uc3MgPSBuc3M7XG4gICAgICAgICAgICB1cm5Db21wb25lbnRzLnBhdGggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoc2NoZW1lSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHVybkNvbXBvbmVudHMgPSBzY2hlbWVIYW5kbGVyLnBhcnNlKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXJuQ29tcG9uZW50cy5lcnJvciA9IHVybkNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUk4gY2FuIG5vdCBiZSBwYXJzZWQuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybkNvbXBvbmVudHM7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSQkMSh1cm5Db21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBzY2hlbWUgPSBvcHRpb25zLnNjaGVtZSB8fCB1cm5Db21wb25lbnRzLnNjaGVtZSB8fCBcInVyblwiO1xuICAgICAgICB2YXIgbmlkID0gdXJuQ29tcG9uZW50cy5uaWQ7XG4gICAgICAgIHZhciB1cm5TY2hlbWUgPSBzY2hlbWUgKyBcIjpcIiArIChvcHRpb25zLm5pZCB8fCBuaWQpO1xuICAgICAgICB2YXIgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbdXJuU2NoZW1lXTtcbiAgICAgICAgaWYgKHNjaGVtZUhhbmRsZXIpIHtcbiAgICAgICAgICAgIHVybkNvbXBvbmVudHMgPSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZSh1cm5Db21wb25lbnRzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXJpQ29tcG9uZW50cyA9IHVybkNvbXBvbmVudHM7XG4gICAgICAgIHZhciBuc3MgPSB1cm5Db21wb25lbnRzLm5zcztcbiAgICAgICAgdXJpQ29tcG9uZW50cy5wYXRoID0gKG5pZCB8fCBvcHRpb25zLm5pZCkgKyBcIjpcIiArIG5zcztcbiAgICAgICAgcmV0dXJuIHVyaUNvbXBvbmVudHM7XG4gICAgfVxufTtcblxudmFyIFVVSUQgPSAvXlswLTlBLUZhLWZdezh9KD86XFwtWzAtOUEtRmEtZl17NH0pezN9XFwtWzAtOUEtRmEtZl17MTJ9JC87XG4vL1JGQyA0MTIyXG52YXIgaGFuZGxlciQ2ID0ge1xuICAgIHNjaGVtZTogXCJ1cm46dXVpZFwiLFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSh1cm5Db21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB1dWlkQ29tcG9uZW50cyA9IHVybkNvbXBvbmVudHM7XG4gICAgICAgIHV1aWRDb21wb25lbnRzLnV1aWQgPSB1dWlkQ29tcG9uZW50cy5uc3M7XG4gICAgICAgIHV1aWRDb21wb25lbnRzLm5zcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFvcHRpb25zLnRvbGVyYW50ICYmICghdXVpZENvbXBvbmVudHMudXVpZCB8fCAhdXVpZENvbXBvbmVudHMudXVpZC5tYXRjaChVVUlEKSkpIHtcbiAgICAgICAgICAgIHV1aWRDb21wb25lbnRzLmVycm9yID0gdXVpZENvbXBvbmVudHMuZXJyb3IgfHwgXCJVVUlEIGlzIG5vdCB2YWxpZC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXVpZENvbXBvbmVudHM7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSh1dWlkQ29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgdXJuQ29tcG9uZW50cyA9IHV1aWRDb21wb25lbnRzO1xuICAgICAgICAvL25vcm1hbGl6ZSBVVUlEXG4gICAgICAgIHVybkNvbXBvbmVudHMubnNzID0gKHV1aWRDb21wb25lbnRzLnV1aWQgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIHVybkNvbXBvbmVudHM7XG4gICAgfVxufTtcblxuU0NIRU1FU1toYW5kbGVyLnNjaGVtZV0gPSBoYW5kbGVyO1xuU0NIRU1FU1toYW5kbGVyJDEuc2NoZW1lXSA9IGhhbmRsZXIkMTtcblNDSEVNRVNbaGFuZGxlciQyLnNjaGVtZV0gPSBoYW5kbGVyJDI7XG5TQ0hFTUVTW2hhbmRsZXIkMy5zY2hlbWVdID0gaGFuZGxlciQzO1xuU0NIRU1FU1toYW5kbGVyJDQuc2NoZW1lXSA9IGhhbmRsZXIkNDtcblNDSEVNRVNbaGFuZGxlciQ1LnNjaGVtZV0gPSBoYW5kbGVyJDU7XG5TQ0hFTUVTW2hhbmRsZXIkNi5zY2hlbWVdID0gaGFuZGxlciQ2O1xuXG5leHBvcnRzLlNDSEVNRVMgPSBTQ0hFTUVTO1xuZXhwb3J0cy5wY3RFbmNDaGFyID0gcGN0RW5jQ2hhcjtcbmV4cG9ydHMucGN0RGVjQ2hhcnMgPSBwY3REZWNDaGFycztcbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmV4cG9ydHMucmVtb3ZlRG90U2VnbWVudHMgPSByZW1vdmVEb3RTZWdtZW50cztcbmV4cG9ydHMuc2VyaWFsaXplID0gc2VyaWFsaXplO1xuZXhwb3J0cy5yZXNvbHZlQ29tcG9uZW50cyA9IHJlc29sdmVDb21wb25lbnRzO1xuZXhwb3J0cy5yZXNvbHZlID0gcmVzb2x2ZTtcbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuZXhwb3J0cy5lcXVhbCA9IGVxdWFsO1xuZXhwb3J0cy5lc2NhcGVDb21wb25lbnQgPSBlc2NhcGVDb21wb25lbnQ7XG5leHBvcnRzLnVuZXNjYXBlQ29tcG9uZW50ID0gdW5lc2NhcGVDb21wb25lbnQ7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmkuYWxsLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFNjaGVtYVJlZnMgPSBleHBvcnRzLnJlc29sdmVVcmwgPSBleHBvcnRzLm5vcm1hbGl6ZUlkID0gZXhwb3J0cy5fZ2V0RnVsbFBhdGggPSBleHBvcnRzLmdldEZ1bGxQYXRoID0gZXhwb3J0cy5pbmxpbmVSZWYgPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgZXF1YWwgPSByZXF1aXJlKFwiZmFzdC1kZWVwLWVxdWFsXCIpO1xuY29uc3QgdHJhdmVyc2UgPSByZXF1aXJlKFwianNvbi1zY2hlbWEtdHJhdmVyc2VcIik7XG5jb25zdCBVUkkgPSByZXF1aXJlKFwidXJpLWpzXCIpO1xuLy8gVE9ETyByZWZhY3RvciB0byB1c2Uga2V5d29yZCBkZWZpbml0aW9uc1xuY29uc3QgU0lNUExFX0lOTElORUQgPSBuZXcgU2V0KFtcbiAgICBcInR5cGVcIixcbiAgICBcImZvcm1hdFwiLFxuICAgIFwicGF0dGVyblwiLFxuICAgIFwibWF4TGVuZ3RoXCIsXG4gICAgXCJtaW5MZW5ndGhcIixcbiAgICBcIm1heFByb3BlcnRpZXNcIixcbiAgICBcIm1pblByb3BlcnRpZXNcIixcbiAgICBcIm1heEl0ZW1zXCIsXG4gICAgXCJtaW5JdGVtc1wiLFxuICAgIFwibWF4aW11bVwiLFxuICAgIFwibWluaW11bVwiLFxuICAgIFwidW5pcXVlSXRlbXNcIixcbiAgICBcIm11bHRpcGxlT2ZcIixcbiAgICBcInJlcXVpcmVkXCIsXG4gICAgXCJlbnVtXCIsXG4gICAgXCJjb25zdFwiLFxuXSk7XG5mdW5jdGlvbiBpbmxpbmVSZWYoc2NoZW1hLCBsaW1pdCA9IHRydWUpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGxpbWl0ID09PSB0cnVlKVxuICAgICAgICByZXR1cm4gIWhhc1JlZihzY2hlbWEpO1xuICAgIGlmICghbGltaXQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gY291bnRLZXlzKHNjaGVtYSkgPD0gbGltaXQ7XG59XG5leHBvcnRzLmlubGluZVJlZiA9IGlubGluZVJlZjtcbmNvbnN0IFJFRl9LRVlXT1JEUyA9IG5ldyBTZXQoW1xuICAgIFwiJHJlZlwiLFxuICAgIFwiJHJlY3Vyc2l2ZVJlZlwiLFxuICAgIFwiJHJlY3Vyc2l2ZUFuY2hvclwiLFxuICAgIFwiJGR5bmFtaWNSZWZcIixcbiAgICBcIiRkeW5hbWljQW5jaG9yXCIsXG5dKTtcbmZ1bmN0aW9uIGhhc1JlZihzY2hlbWEpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKFJFRl9LRVlXT1JEUy5oYXMoa2V5KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFba2V5XTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoKSAmJiBzY2guc29tZShoYXNSZWYpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwib2JqZWN0XCIgJiYgaGFzUmVmKHNjaCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY291bnRLZXlzKHNjaGVtYSkge1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGlmIChrZXkgPT09IFwiJHJlZlwiKVxuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICBjb3VudCsrO1xuICAgICAgICBpZiAoU0lNUExFX0lOTElORUQuaGFzKGtleSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWFba2V5XSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB1dGlsXzEuZWFjaEl0ZW0oc2NoZW1hW2tleV0sIChzY2gpID0+IChjb3VudCArPSBjb3VudEtleXMoc2NoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA9PT0gSW5maW5pdHkpXG4gICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIHJldHVybiBjb3VudDtcbn1cbmZ1bmN0aW9uIGdldEZ1bGxQYXRoKGlkID0gXCJcIiwgbm9ybWFsaXplKSB7XG4gICAgaWYgKG5vcm1hbGl6ZSAhPT0gZmFsc2UpXG4gICAgICAgIGlkID0gbm9ybWFsaXplSWQoaWQpO1xuICAgIGNvbnN0IHAgPSBVUkkucGFyc2UoaWQpO1xuICAgIHJldHVybiBfZ2V0RnVsbFBhdGgocCk7XG59XG5leHBvcnRzLmdldEZ1bGxQYXRoID0gZ2V0RnVsbFBhdGg7XG5mdW5jdGlvbiBfZ2V0RnVsbFBhdGgocCkge1xuICAgIHJldHVybiBVUkkuc2VyaWFsaXplKHApLnNwbGl0KFwiI1wiKVswXSArIFwiI1wiO1xufVxuZXhwb3J0cy5fZ2V0RnVsbFBhdGggPSBfZ2V0RnVsbFBhdGg7XG5jb25zdCBUUkFJTElOR19TTEFTSF9IQVNIID0gLyNcXC8/JC87XG5mdW5jdGlvbiBub3JtYWxpemVJZChpZCkge1xuICAgIHJldHVybiBpZCA/IGlkLnJlcGxhY2UoVFJBSUxJTkdfU0xBU0hfSEFTSCwgXCJcIikgOiBcIlwiO1xufVxuZXhwb3J0cy5ub3JtYWxpemVJZCA9IG5vcm1hbGl6ZUlkO1xuZnVuY3Rpb24gcmVzb2x2ZVVybChiYXNlSWQsIGlkKSB7XG4gICAgaWQgPSBub3JtYWxpemVJZChpZCk7XG4gICAgcmV0dXJuIFVSSS5yZXNvbHZlKGJhc2VJZCwgaWQpO1xufVxuZXhwb3J0cy5yZXNvbHZlVXJsID0gcmVzb2x2ZVVybDtcbmNvbnN0IEFOQ0hPUiA9IC9eW2Etel9dWy1hLXowLTkuX10qJC9pO1xuZnVuY3Rpb24gZ2V0U2NoZW1hUmVmcyhzY2hlbWEpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICBjb25zdCBzY2hJZCA9IG5vcm1hbGl6ZUlkKHNjaGVtYVtzY2hlbWFJZF0pO1xuICAgIGNvbnN0IGJhc2VJZHMgPSB7IFwiXCI6IHNjaElkIH07XG4gICAgY29uc3QgcGF0aFByZWZpeCA9IGdldEZ1bGxQYXRoKHNjaElkLCBmYWxzZSk7XG4gICAgY29uc3QgbG9jYWxSZWZzID0ge307XG4gICAgY29uc3Qgc2NoZW1hUmVmcyA9IG5ldyBTZXQoKTtcbiAgICB0cmF2ZXJzZShzY2hlbWEsIHsgYWxsS2V5czogdHJ1ZSB9LCAoc2NoLCBqc29uUHRyLCBfLCBwYXJlbnRKc29uUHRyKSA9PiB7XG4gICAgICAgIGlmIChwYXJlbnRKc29uUHRyID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aFByZWZpeCArIGpzb25QdHI7XG4gICAgICAgIGxldCBiYXNlSWQgPSBiYXNlSWRzW3BhcmVudEpzb25QdHJdO1xuICAgICAgICBpZiAodHlwZW9mIHNjaFtzY2hlbWFJZF0gPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGJhc2VJZCA9IGFkZFJlZi5jYWxsKHRoaXMsIHNjaFtzY2hlbWFJZF0pO1xuICAgICAgICBhZGRBbmNob3IuY2FsbCh0aGlzLCBzY2guJGFuY2hvcik7XG4gICAgICAgIGFkZEFuY2hvci5jYWxsKHRoaXMsIHNjaC4kZHluYW1pY0FuY2hvcik7XG4gICAgICAgIGJhc2VJZHNbanNvblB0cl0gPSBiYXNlSWQ7XG4gICAgICAgIGZ1bmN0aW9uIGFkZFJlZihyZWYpIHtcbiAgICAgICAgICAgIHJlZiA9IG5vcm1hbGl6ZUlkKGJhc2VJZCA/IFVSSS5yZXNvbHZlKGJhc2VJZCwgcmVmKSA6IHJlZik7XG4gICAgICAgICAgICBpZiAoc2NoZW1hUmVmcy5oYXMocmVmKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBhbWJpZ3VvcyhyZWYpO1xuICAgICAgICAgICAgc2NoZW1hUmVmcy5hZGQocmVmKTtcbiAgICAgICAgICAgIGxldCBzY2hPclJlZiA9IHRoaXMucmVmc1tyZWZdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hPclJlZiA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHNjaE9yUmVmID0gdGhpcy5yZWZzW3NjaE9yUmVmXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGNoZWNrQW1iaWd1b3NSZWYoc2NoLCBzY2hPclJlZi5zY2hlbWEsIHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZWYgIT09IG5vcm1hbGl6ZUlkKGZ1bGxQYXRoKSkge1xuICAgICAgICAgICAgICAgIGlmIChyZWZbMF0gPT09IFwiI1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrQW1iaWd1b3NSZWYoc2NoLCBsb2NhbFJlZnNbcmVmXSwgcmVmKTtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxSZWZzW3JlZl0gPSBzY2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnNbcmVmXSA9IGZ1bGxQYXRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWY7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkQW5jaG9yKGFuY2hvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhbmNob3IgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGlmICghQU5DSE9SLnRlc3QoYW5jaG9yKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGFuY2hvciBcIiR7YW5jaG9yfVwiYCk7XG4gICAgICAgICAgICAgICAgYWRkUmVmLmNhbGwodGhpcywgYCMke2FuY2hvcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBsb2NhbFJlZnM7XG4gICAgZnVuY3Rpb24gY2hlY2tBbWJpZ3Vvc1JlZihzY2gxLCBzY2gyLCByZWYpIHtcbiAgICAgICAgaWYgKHNjaDIgIT09IHVuZGVmaW5lZCAmJiAhZXF1YWwoc2NoMSwgc2NoMikpXG4gICAgICAgICAgICB0aHJvdyBhbWJpZ3VvcyhyZWYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhbWJpZ3VvcyhyZWYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgcmVmZXJlbmNlIFwiJHtyZWZ9XCIgcmVzb2x2ZXMgdG8gbW9yZSB0aGFuIG9uZSBzY2hlbWFgKTtcbiAgICB9XG59XG5leHBvcnRzLmdldFNjaGVtYVJlZnMgPSBnZXRTY2hlbWFSZWZzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0RGF0YSA9IGV4cG9ydHMuS2V5d29yZEN4dCA9IGV4cG9ydHMudmFsaWRhdGVGdW5jdGlvbkNvZGUgPSB2b2lkIDA7XG5jb25zdCBib29sU2NoZW1hXzEgPSByZXF1aXJlKFwiLi9ib29sU2NoZW1hXCIpO1xuY29uc3QgZGF0YVR5cGVfMSA9IHJlcXVpcmUoXCIuL2RhdGFUeXBlXCIpO1xuY29uc3QgYXBwbGljYWJpbGl0eV8xID0gcmVxdWlyZShcIi4vYXBwbGljYWJpbGl0eVwiKTtcbmNvbnN0IGRhdGFUeXBlXzIgPSByZXF1aXJlKFwiLi9kYXRhVHlwZVwiKTtcbmNvbnN0IGRlZmF1bHRzXzEgPSByZXF1aXJlKFwiLi9kZWZhdWx0c1wiKTtcbmNvbnN0IGtleXdvcmRfMSA9IHJlcXVpcmUoXCIuL2tleXdvcmRcIik7XG5jb25zdCBzdWJzY2hlbWFfMSA9IHJlcXVpcmUoXCIuL3N1YnNjaGVtYVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi9uYW1lc1wiKTtcbmNvbnN0IHJlc29sdmVfMSA9IHJlcXVpcmUoXCIuLi9yZXNvbHZlXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG4vLyBzY2hlbWEgY29tcGlsYXRpb24gLSBnZW5lcmF0ZXMgdmFsaWRhdGlvbiBmdW5jdGlvbiwgc3Vic2NoZW1hQ29kZSAoYmVsb3cpIGlzIHVzZWQgZm9yIHN1YnNjaGVtYXNcbmZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25Db2RlKGl0KSB7XG4gICAgaWYgKGlzU2NoZW1hT2JqKGl0KSkge1xuICAgICAgICBjaGVja0tleXdvcmRzKGl0KTtcbiAgICAgICAgaWYgKHNjaGVtYUN4dEhhc1J1bGVzKGl0KSkge1xuICAgICAgICAgICAgdG9wU2NoZW1hT2JqQ29kZShpdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFsaWRhdGVGdW5jdGlvbihpdCwgKCkgPT4gYm9vbFNjaGVtYV8xLnRvcEJvb2xPckVtcHR5U2NoZW1hKGl0KSk7XG59XG5leHBvcnRzLnZhbGlkYXRlRnVuY3Rpb25Db2RlID0gdmFsaWRhdGVGdW5jdGlvbkNvZGU7XG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uKHsgZ2VuLCB2YWxpZGF0ZU5hbWUsIHNjaGVtYSwgc2NoZW1hRW52LCBvcHRzIH0sIGJvZHkpIHtcbiAgICBpZiAob3B0cy5jb2RlLmVzNSkge1xuICAgICAgICBnZW4uZnVuYyh2YWxpZGF0ZU5hbWUsIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC5kYXRhfSwgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fWAsIHNjaGVtYUVudi4kYXN5bmMsICgpID0+IHtcbiAgICAgICAgICAgIGdlbi5jb2RlKGNvZGVnZW5fMS5fIGBcInVzZSBzdHJpY3RcIjsgJHtmdW5jU291cmNlVXJsKHNjaGVtYSwgb3B0cyl9YCk7XG4gICAgICAgICAgICBkZXN0cnVjdHVyZVZhbEN4dEVTNShnZW4sIG9wdHMpO1xuICAgICAgICAgICAgZ2VuLmNvZGUoYm9keSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2VuLmZ1bmModmFsaWRhdGVOYW1lLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQuZGF0YX0sICR7ZGVzdHJ1Y3R1cmVWYWxDeHQob3B0cyl9YCwgc2NoZW1hRW52LiRhc3luYywgKCkgPT4gZ2VuLmNvZGUoZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpKS5jb2RlKGJvZHkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXN0cnVjdHVyZVZhbEN4dChvcHRzKSB7XG4gICAgcmV0dXJuIGNvZGVnZW5fMS5fIGB7JHtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRofT1cIlwiLCAke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhfSwgJHtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5fSwgJHtuYW1lc18xLmRlZmF1bHQucm9vdERhdGF9PSR7bmFtZXNfMS5kZWZhdWx0LmRhdGF9JHtvcHRzLmR5bmFtaWNSZWYgPyBjb2RlZ2VuXzEuXyBgLCAke25hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9yc309e31gIDogY29kZWdlbl8xLm5pbH19PXt9YDtcbn1cbmZ1bmN0aW9uIGRlc3RydWN0dXJlVmFsQ3h0RVM1KGdlbiwgb3B0cykge1xuICAgIGdlbi5pZihuYW1lc18xLmRlZmF1bHQudmFsQ3h0LCAoKSA9PiB7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRofWApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fS4ke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhfWApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHksIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eX1gKTtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQucm9vdERhdGEsIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhfWApO1xuICAgICAgICBpZiAob3B0cy5keW5hbWljUmVmKVxuICAgICAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnMsIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzfWApO1xuICAgIH0sICgpID0+IHtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBjb2RlZ2VuXzEuXyBgXCJcImApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhLCBjb2RlZ2VuXzEuXyBgdW5kZWZpbmVkYCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSwgY29kZWdlbl8xLl8gYHVuZGVmaW5lZGApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5yb290RGF0YSwgbmFtZXNfMS5kZWZhdWx0LmRhdGEpO1xuICAgICAgICBpZiAob3B0cy5keW5hbWljUmVmKVxuICAgICAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnMsIGNvZGVnZW5fMS5fIGB7fWApO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdG9wU2NoZW1hT2JqQ29kZShpdCkge1xuICAgIGNvbnN0IHsgc2NoZW1hLCBvcHRzLCBnZW4gfSA9IGl0O1xuICAgIHZhbGlkYXRlRnVuY3Rpb24oaXQsICgpID0+IHtcbiAgICAgICAgaWYgKG9wdHMuJGNvbW1lbnQgJiYgc2NoZW1hLiRjb21tZW50KVxuICAgICAgICAgICAgY29tbWVudEtleXdvcmQoaXQpO1xuICAgICAgICBjaGVja05vRGVmYXVsdChpdCk7XG4gICAgICAgIGdlbi5sZXQobmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIG51bGwpO1xuICAgICAgICBnZW4ubGV0KG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsIDApO1xuICAgICAgICBpZiAob3B0cy51bmV2YWx1YXRlZClcbiAgICAgICAgICAgIHJlc2V0RXZhbHVhdGVkKGl0KTtcbiAgICAgICAgdHlwZUFuZEtleXdvcmRzKGl0KTtcbiAgICAgICAgcmV0dXJuUmVzdWx0cyhpdCk7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xufVxuZnVuY3Rpb24gcmVzZXRFdmFsdWF0ZWQoaXQpIHtcbiAgICAvLyBUT0RPIG1heWJlIHNvbWUgaG9vayB0byBleGVjdXRlIGl0IGluIHRoZSBlbmQgdG8gY2hlY2sgd2hldGhlciBwcm9wcy9pdGVtcyBhcmUgTmFtZSwgYXMgaW4gYXNzaWduRXZhbHVhdGVkXG4gICAgY29uc3QgeyBnZW4sIHZhbGlkYXRlTmFtZSB9ID0gaXQ7XG4gICAgaXQuZXZhbHVhdGVkID0gZ2VuLmNvbnN0KFwiZXZhbHVhdGVkXCIsIGNvZGVnZW5fMS5fIGAke3ZhbGlkYXRlTmFtZX0uZXZhbHVhdGVkYCk7XG4gICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2l0LmV2YWx1YXRlZH0uZHluYW1pY1Byb3BzYCwgKCkgPT4gZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHtpdC5ldmFsdWF0ZWR9LnByb3BzYCwgY29kZWdlbl8xLl8gYHVuZGVmaW5lZGApKTtcbiAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7aXQuZXZhbHVhdGVkfS5keW5hbWljSXRlbXNgLCAoKSA9PiBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke2l0LmV2YWx1YXRlZH0uaXRlbXNgLCBjb2RlZ2VuXzEuXyBgdW5kZWZpbmVkYCkpO1xufVxuZnVuY3Rpb24gZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpIHtcbiAgICBjb25zdCBzY2hJZCA9IHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBzY2hlbWFbb3B0cy5zY2hlbWFJZF07XG4gICAgcmV0dXJuIHNjaElkICYmIChvcHRzLmNvZGUuc291cmNlIHx8IG9wdHMuY29kZS5wcm9jZXNzKSA/IGNvZGVnZW5fMS5fIGAvKiMgc291cmNlVVJMPSR7c2NoSWR9ICovYCA6IGNvZGVnZW5fMS5uaWw7XG59XG4vLyBzY2hlbWEgY29tcGlsYXRpb24gLSB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgcmVjdXJzaXZlbHkgdG8gZ2VuZXJhdGUgY29kZSBmb3Igc3ViLXNjaGVtYXNcbmZ1bmN0aW9uIHN1YnNjaGVtYUNvZGUoaXQsIHZhbGlkKSB7XG4gICAgaWYgKGlzU2NoZW1hT2JqKGl0KSkge1xuICAgICAgICBjaGVja0tleXdvcmRzKGl0KTtcbiAgICAgICAgaWYgKHNjaGVtYUN4dEhhc1J1bGVzKGl0KSkge1xuICAgICAgICAgICAgc3ViU2NoZW1hT2JqQ29kZShpdCwgdmFsaWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJvb2xTY2hlbWFfMS5ib29sT3JFbXB0eVNjaGVtYShpdCwgdmFsaWQpO1xufVxuZnVuY3Rpb24gc2NoZW1hQ3h0SGFzUnVsZXMoeyBzY2hlbWEsIHNlbGYgfSkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4gIXNjaGVtYTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpXG4gICAgICAgIGlmIChzZWxmLlJVTEVTLmFsbFtrZXldKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNTY2hlbWFPYmooaXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGl0LnNjaGVtYSAhPSBcImJvb2xlYW5cIjtcbn1cbmZ1bmN0aW9uIHN1YlNjaGVtYU9iakNvZGUoaXQsIHZhbGlkKSB7XG4gICAgY29uc3QgeyBzY2hlbWEsIGdlbiwgb3B0cyB9ID0gaXQ7XG4gICAgaWYgKG9wdHMuJGNvbW1lbnQgJiYgc2NoZW1hLiRjb21tZW50KVxuICAgICAgICBjb21tZW50S2V5d29yZChpdCk7XG4gICAgdXBkYXRlQ29udGV4dChpdCk7XG4gICAgY2hlY2tBc3luY1NjaGVtYShpdCk7XG4gICAgY29uc3QgZXJyc0NvdW50ID0gZ2VuLmNvbnN0KFwiX2VycnNcIiwgbmFtZXNfMS5kZWZhdWx0LmVycm9ycyk7XG4gICAgdHlwZUFuZEtleXdvcmRzKGl0LCBlcnJzQ291bnQpO1xuICAgIC8vIFRPRE8gdmFyXG4gICAgZ2VuLnZhcih2YWxpZCwgY29kZWdlbl8xLl8gYCR7ZXJyc0NvdW50fSA9PT0gJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfWApO1xufVxuZnVuY3Rpb24gY2hlY2tLZXl3b3JkcyhpdCkge1xuICAgIHV0aWxfMS5jaGVja1Vua25vd25SdWxlcyhpdCk7XG4gICAgY2hlY2tSZWZzQW5kS2V5d29yZHMoaXQpO1xufVxuZnVuY3Rpb24gdHlwZUFuZEtleXdvcmRzKGl0LCBlcnJzQ291bnQpIHtcbiAgICBpZiAoaXQub3B0cy5qdGQpXG4gICAgICAgIHJldHVybiBzY2hlbWFLZXl3b3JkcyhpdCwgW10sIGZhbHNlLCBlcnJzQ291bnQpO1xuICAgIGNvbnN0IHR5cGVzID0gZGF0YVR5cGVfMS5nZXRTY2hlbWFUeXBlcyhpdC5zY2hlbWEpO1xuICAgIGNvbnN0IGNoZWNrZWRUeXBlcyA9IGRhdGFUeXBlXzEuY29lcmNlQW5kQ2hlY2tEYXRhVHlwZShpdCwgdHlwZXMpO1xuICAgIHNjaGVtYUtleXdvcmRzKGl0LCB0eXBlcywgIWNoZWNrZWRUeXBlcywgZXJyc0NvdW50KTtcbn1cbmZ1bmN0aW9uIGNoZWNrUmVmc0FuZEtleXdvcmRzKGl0KSB7XG4gICAgY29uc3QgeyBzY2hlbWEsIGVyclNjaGVtYVBhdGgsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgIGlmIChzY2hlbWEuJHJlZiAmJiBvcHRzLmlnbm9yZUtleXdvcmRzV2l0aFJlZiAmJiB1dGlsXzEuc2NoZW1hSGFzUnVsZXNCdXRSZWYoc2NoZW1hLCBzZWxmLlJVTEVTKSkge1xuICAgICAgICBzZWxmLmxvZ2dlci53YXJuKGAkcmVmOiBrZXl3b3JkcyBpZ25vcmVkIGluIHNjaGVtYSBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tOb0RlZmF1bHQoaXQpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgb3B0cyB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYS5kZWZhdWx0ICE9PSB1bmRlZmluZWQgJiYgb3B0cy51c2VEZWZhdWx0cyAmJiBvcHRzLnN0cmljdFNjaGVtYSkge1xuICAgICAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCBcImRlZmF1bHQgaXMgaWdub3JlZCBpbiB0aGUgc2NoZW1hIHJvb3RcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlQ29udGV4dChpdCkge1xuICAgIGNvbnN0IHNjaElkID0gaXQuc2NoZW1hW2l0Lm9wdHMuc2NoZW1hSWRdO1xuICAgIGlmIChzY2hJZClcbiAgICAgICAgaXQuYmFzZUlkID0gcmVzb2x2ZV8xLnJlc29sdmVVcmwoaXQuYmFzZUlkLCBzY2hJZCk7XG59XG5mdW5jdGlvbiBjaGVja0FzeW5jU2NoZW1hKGl0KSB7XG4gICAgaWYgKGl0LnNjaGVtYS4kYXN5bmMgJiYgIWl0LnNjaGVtYUVudi4kYXN5bmMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIHNjaGVtYSBpbiBzeW5jIHNjaGVtYVwiKTtcbn1cbmZ1bmN0aW9uIGNvbW1lbnRLZXl3b3JkKHsgZ2VuLCBzY2hlbWFFbnYsIHNjaGVtYSwgZXJyU2NoZW1hUGF0aCwgb3B0cyB9KSB7XG4gICAgY29uc3QgbXNnID0gc2NoZW1hLiRjb21tZW50O1xuICAgIGlmIChvcHRzLiRjb21tZW50ID09PSB0cnVlKSB7XG4gICAgICAgIGdlbi5jb2RlKGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC5zZWxmfS5sb2dnZXIubG9nKCR7bXNnfSlgKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9wdHMuJGNvbW1lbnQgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYVBhdGggPSBjb2RlZ2VuXzEuc3RyIGAke2VyclNjaGVtYVBhdGh9LyRjb21tZW50YDtcbiAgICAgICAgY29uc3Qgcm9vdE5hbWUgPSBnZW4uc2NvcGVWYWx1ZShcInJvb3RcIiwgeyByZWY6IHNjaGVtYUVudi5yb290IH0pO1xuICAgICAgICBnZW4uY29kZShjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQuc2VsZn0ub3B0cy4kY29tbWVudCgke21zZ30sICR7c2NoZW1hUGF0aH0sICR7cm9vdE5hbWV9LnNjaGVtYSlgKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXR1cm5SZXN1bHRzKGl0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYUVudiwgdmFsaWRhdGVOYW1lLCBWYWxpZGF0aW9uRXJyb3IsIG9wdHMgfSA9IGl0O1xuICAgIGlmIChzY2hlbWFFbnYuJGFzeW5jKSB7XG4gICAgICAgIC8vIFRPRE8gYXNzaWduIHVuZXZhbHVhdGVkXG4gICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfSA9PT0gMGAsICgpID0+IGdlbi5yZXR1cm4obmFtZXNfMS5kZWZhdWx0LmRhdGEpLCAoKSA9PiBnZW4udGhyb3coY29kZWdlbl8xLl8gYG5ldyAke1ZhbGlkYXRpb25FcnJvcn0oJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30pYCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzKTtcbiAgICAgICAgaWYgKG9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICBhc3NpZ25FdmFsdWF0ZWQoaXQpO1xuICAgICAgICBnZW4ucmV0dXJuKGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9ID09PSAwYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzaWduRXZhbHVhdGVkKHsgZ2VuLCBldmFsdWF0ZWQsIHByb3BzLCBpdGVtcyB9KSB7XG4gICAgaWYgKHByb3BzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpXG4gICAgICAgIGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7ZXZhbHVhdGVkfS5wcm9wc2AsIHByb3BzKTtcbiAgICBpZiAoaXRlbXMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSlcbiAgICAgICAgZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHtldmFsdWF0ZWR9Lml0ZW1zYCwgaXRlbXMpO1xufVxuZnVuY3Rpb24gc2NoZW1hS2V5d29yZHMoaXQsIHR5cGVzLCB0eXBlRXJyb3JzLCBlcnJzQ291bnQpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBkYXRhLCBhbGxFcnJvcnMsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgIGNvbnN0IHsgUlVMRVMgfSA9IHNlbGY7XG4gICAgaWYgKHNjaGVtYS4kcmVmICYmIChvcHRzLmlnbm9yZUtleXdvcmRzV2l0aFJlZiB8fCAhdXRpbF8xLnNjaGVtYUhhc1J1bGVzQnV0UmVmKHNjaGVtYSwgUlVMRVMpKSkge1xuICAgICAgICBnZW4uYmxvY2soKCkgPT4ga2V5d29yZENvZGUoaXQsIFwiJHJlZlwiLCBSVUxFUy5hbGwuJHJlZi5kZWZpbml0aW9uKSk7IC8vIFRPRE8gdHlwZWNhc3RcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW9wdHMuanRkKVxuICAgICAgICBjaGVja1N0cmljdFR5cGVzKGl0LCB0eXBlcyk7XG4gICAgZ2VuLmJsb2NrKCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBncm91cCBvZiBSVUxFUy5ydWxlcylcbiAgICAgICAgICAgIGdyb3VwS2V5d29yZHMoZ3JvdXApO1xuICAgICAgICBncm91cEtleXdvcmRzKFJVTEVTLnBvc3QpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGdyb3VwS2V5d29yZHMoZ3JvdXApIHtcbiAgICAgICAgaWYgKCFhcHBsaWNhYmlsaXR5XzEuc2hvdWxkVXNlR3JvdXAoc2NoZW1hLCBncm91cCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChncm91cC50eXBlKSB7XG4gICAgICAgICAgICBnZW4uaWYoZGF0YVR5cGVfMi5jaGVja0RhdGFUeXBlKGdyb3VwLnR5cGUsIGRhdGEsIG9wdHMuc3RyaWN0TnVtYmVycykpO1xuICAgICAgICAgICAgaXRlcmF0ZUtleXdvcmRzKGl0LCBncm91cCk7XG4gICAgICAgICAgICBpZiAodHlwZXMubGVuZ3RoID09PSAxICYmIHR5cGVzWzBdID09PSBncm91cC50eXBlICYmIHR5cGVFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBnZW4uZWxzZSgpO1xuICAgICAgICAgICAgICAgIGRhdGFUeXBlXzIucmVwb3J0VHlwZUVycm9yKGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbi5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0ZUtleXdvcmRzKGl0LCBncm91cCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyBtYWtlIGl0IFwib2tcIiBjYWxsP1xuICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfSA9PT0gJHtlcnJzQ291bnQgfHwgMH1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpdGVyYXRlS2V5d29yZHMoaXQsIGdyb3VwKSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgb3B0czogeyB1c2VEZWZhdWx0cyB9LCB9ID0gaXQ7XG4gICAgaWYgKHVzZURlZmF1bHRzKVxuICAgICAgICBkZWZhdWx0c18xLmFzc2lnbkRlZmF1bHRzKGl0LCBncm91cC50eXBlKTtcbiAgICBnZW4uYmxvY2soKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgZ3JvdXAucnVsZXMpIHtcbiAgICAgICAgICAgIGlmIChhcHBsaWNhYmlsaXR5XzEuc2hvdWxkVXNlUnVsZShzY2hlbWEsIHJ1bGUpKSB7XG4gICAgICAgICAgICAgICAga2V5d29yZENvZGUoaXQsIHJ1bGUua2V5d29yZCwgcnVsZS5kZWZpbml0aW9uLCBncm91cC50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gY2hlY2tTdHJpY3RUeXBlcyhpdCwgdHlwZXMpIHtcbiAgICBpZiAoaXQuc2NoZW1hRW52Lm1ldGEgfHwgIWl0Lm9wdHMuc3RyaWN0VHlwZXMpXG4gICAgICAgIHJldHVybjtcbiAgICBjaGVja0NvbnRleHRUeXBlcyhpdCwgdHlwZXMpO1xuICAgIGlmICghaXQub3B0cy5hbGxvd1VuaW9uVHlwZXMpXG4gICAgICAgIGNoZWNrTXVsdGlwbGVUeXBlcyhpdCwgdHlwZXMpO1xuICAgIGNoZWNrS2V5d29yZFR5cGVzKGl0LCBpdC5kYXRhVHlwZXMpO1xufVxuZnVuY3Rpb24gY2hlY2tDb250ZXh0VHlwZXMoaXQsIHR5cGVzKSB7XG4gICAgaWYgKCF0eXBlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIWl0LmRhdGFUeXBlcy5sZW5ndGgpIHtcbiAgICAgICAgaXQuZGF0YVR5cGVzID0gdHlwZXM7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHlwZXMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgICBpZiAoIWluY2x1ZGVzVHlwZShpdC5kYXRhVHlwZXMsIHQpKSB7XG4gICAgICAgICAgICBzdHJpY3RUeXBlc0Vycm9yKGl0LCBgdHlwZSBcIiR7dH1cIiBub3QgYWxsb3dlZCBieSBjb250ZXh0IFwiJHtpdC5kYXRhVHlwZXMuam9pbihcIixcIil9XCJgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGl0LmRhdGFUeXBlcyA9IGl0LmRhdGFUeXBlcy5maWx0ZXIoKHQpID0+IGluY2x1ZGVzVHlwZSh0eXBlcywgdCkpO1xufVxuZnVuY3Rpb24gY2hlY2tNdWx0aXBsZVR5cGVzKGl0LCB0cykge1xuICAgIGlmICh0cy5sZW5ndGggPiAxICYmICEodHMubGVuZ3RoID09PSAyICYmIHRzLmluY2x1ZGVzKFwibnVsbFwiKSkpIHtcbiAgICAgICAgc3RyaWN0VHlwZXNFcnJvcihpdCwgXCJ1c2UgYWxsb3dVbmlvblR5cGVzIHRvIGFsbG93IHVuaW9uIHR5cGUga2V5d29yZFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja0tleXdvcmRUeXBlcyhpdCwgdHMpIHtcbiAgICBjb25zdCBydWxlcyA9IGl0LnNlbGYuUlVMRVMuYWxsO1xuICAgIGZvciAoY29uc3Qga2V5d29yZCBpbiBydWxlcykge1xuICAgICAgICBjb25zdCBydWxlID0gcnVsZXNba2V5d29yZF07XG4gICAgICAgIGlmICh0eXBlb2YgcnVsZSA9PSBcIm9iamVjdFwiICYmIGFwcGxpY2FiaWxpdHlfMS5zaG91bGRVc2VSdWxlKGl0LnNjaGVtYSwgcnVsZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gcnVsZS5kZWZpbml0aW9uO1xuICAgICAgICAgICAgaWYgKHR5cGUubGVuZ3RoICYmICF0eXBlLnNvbWUoKHQpID0+IGhhc0FwcGxpY2FibGVUeXBlKHRzLCB0KSkpIHtcbiAgICAgICAgICAgICAgICBzdHJpY3RUeXBlc0Vycm9yKGl0LCBgbWlzc2luZyB0eXBlIFwiJHt0eXBlLmpvaW4oXCIsXCIpfVwiIGZvciBrZXl3b3JkIFwiJHtrZXl3b3JkfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBoYXNBcHBsaWNhYmxlVHlwZShzY2hUcywga3dkVCkge1xuICAgIHJldHVybiBzY2hUcy5pbmNsdWRlcyhrd2RUKSB8fCAoa3dkVCA9PT0gXCJudW1iZXJcIiAmJiBzY2hUcy5pbmNsdWRlcyhcImludGVnZXJcIikpO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNUeXBlKHRzLCB0KSB7XG4gICAgcmV0dXJuIHRzLmluY2x1ZGVzKHQpIHx8ICh0ID09PSBcImludGVnZXJcIiAmJiB0cy5pbmNsdWRlcyhcIm51bWJlclwiKSk7XG59XG5mdW5jdGlvbiBzdHJpY3RUeXBlc0Vycm9yKGl0LCBtc2cpIHtcbiAgICBjb25zdCBzY2hlbWFQYXRoID0gaXQuc2NoZW1hRW52LmJhc2VJZCArIGl0LmVyclNjaGVtYVBhdGg7XG4gICAgbXNnICs9IGAgYXQgXCIke3NjaGVtYVBhdGh9XCIgKHN0cmljdFR5cGVzKWA7XG4gICAgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZShpdCwgbXNnLCBpdC5vcHRzLnN0cmljdFR5cGVzKTtcbn1cbmNsYXNzIEtleXdvcmRDeHQge1xuICAgIGNvbnN0cnVjdG9yKGl0LCBkZWYsIGtleXdvcmQpIHtcbiAgICAgICAga2V5d29yZF8xLnZhbGlkYXRlS2V5d29yZFVzYWdlKGl0LCBkZWYsIGtleXdvcmQpO1xuICAgICAgICB0aGlzLmdlbiA9IGl0LmdlbjtcbiAgICAgICAgdGhpcy5hbGxFcnJvcnMgPSBpdC5hbGxFcnJvcnM7XG4gICAgICAgIHRoaXMua2V5d29yZCA9IGtleXdvcmQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IGl0LmRhdGE7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gaXQuc2NoZW1hW2tleXdvcmRdO1xuICAgICAgICB0aGlzLiRkYXRhID0gZGVmLiRkYXRhICYmIGl0Lm9wdHMuJGRhdGEgJiYgdGhpcy5zY2hlbWEgJiYgdGhpcy5zY2hlbWEuJGRhdGE7XG4gICAgICAgIHRoaXMuc2NoZW1hVmFsdWUgPSB1dGlsXzEuc2NoZW1hUmVmT3JWYWwoaXQsIHRoaXMuc2NoZW1hLCBrZXl3b3JkLCB0aGlzLiRkYXRhKTtcbiAgICAgICAgdGhpcy5zY2hlbWFUeXBlID0gZGVmLnNjaGVtYVR5cGU7XG4gICAgICAgIHRoaXMucGFyZW50U2NoZW1hID0gaXQuc2NoZW1hO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHt9O1xuICAgICAgICB0aGlzLml0ID0gaXQ7XG4gICAgICAgIHRoaXMuZGVmID0gZGVmO1xuICAgICAgICBpZiAodGhpcy4kZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5zY2hlbWFDb2RlID0gaXQuZ2VuLmNvbnN0KFwidlNjaGVtYVwiLCBnZXREYXRhKHRoaXMuJGRhdGEsIGl0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVtYUNvZGUgPSB0aGlzLnNjaGVtYVZhbHVlO1xuICAgICAgICAgICAgaWYgKCFrZXl3b3JkXzEudmFsaWRTY2hlbWFUeXBlKHRoaXMuc2NoZW1hLCBkZWYuc2NoZW1hVHlwZSwgZGVmLmFsbG93VW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtrZXl3b3JkfSB2YWx1ZSBtdXN0IGJlICR7SlNPTi5zdHJpbmdpZnkoZGVmLnNjaGVtYVR5cGUpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChcImNvZGVcIiBpbiBkZWYgPyBkZWYudHJhY2tFcnJvcnMgOiBkZWYuZXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJzQ291bnQgPSBpdC5nZW4uY29uc3QoXCJfZXJyc1wiLCBuYW1lc18xLmRlZmF1bHQuZXJyb3JzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQoY29uZGl0aW9uLCBzdWNjZXNzQWN0aW9uLCBmYWlsQWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZmFpbFJlc3VsdChjb2RlZ2VuXzEubm90KGNvbmRpdGlvbiksIHN1Y2Nlc3NBY3Rpb24sIGZhaWxBY3Rpb24pO1xuICAgIH1cbiAgICBmYWlsUmVzdWx0KGNvbmRpdGlvbiwgc3VjY2Vzc0FjdGlvbiwgZmFpbEFjdGlvbikge1xuICAgICAgICB0aGlzLmdlbi5pZihjb25kaXRpb24pO1xuICAgICAgICBpZiAoZmFpbEFjdGlvbilcbiAgICAgICAgICAgIGZhaWxBY3Rpb24oKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgICBpZiAoc3VjY2Vzc0FjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5nZW4uZWxzZSgpO1xuICAgICAgICAgICAgc3VjY2Vzc0FjdGlvbigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5nZW4uZW5kSWYoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmdlbi5lbHNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFzcyhjb25kaXRpb24sIGZhaWxBY3Rpb24pIHtcbiAgICAgICAgdGhpcy5mYWlsUmVzdWx0KGNvZGVnZW5fMS5ub3QoY29uZGl0aW9uKSwgdW5kZWZpbmVkLCBmYWlsQWN0aW9uKTtcbiAgICB9XG4gICAgZmFpbChjb25kaXRpb24pIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuLmlmKGZhbHNlKTsgLy8gdGhpcyBicmFuY2ggd2lsbCBiZSByZW1vdmVkIGJ5IGdlbi5vcHRpbWl6ZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2VuLmlmKGNvbmRpdGlvbik7XG4gICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgaWYgKHRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgdGhpcy5nZW4uZW5kSWYoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5nZW4uZWxzZSgpO1xuICAgIH1cbiAgICBmYWlsJGRhdGEoY29uZGl0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy4kZGF0YSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWwoY29uZGl0aW9uKTtcbiAgICAgICAgY29uc3QgeyBzY2hlbWFDb2RlIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmZhaWwoY29kZWdlbl8xLl8gYCR7c2NoZW1hQ29kZX0gIT09IHVuZGVmaW5lZCAmJiAoJHtjb2RlZ2VuXzEub3IodGhpcy5pbnZhbGlkJGRhdGEoKSwgY29uZGl0aW9uKX0pYCk7XG4gICAgfVxuICAgIGVycm9yKGFwcGVuZCwgZXJyb3JQYXJhbXMsIGVycm9yUGF0aHMpIHtcbiAgICAgICAgaWYgKGVycm9yUGFyYW1zKSB7XG4gICAgICAgICAgICB0aGlzLnNldFBhcmFtcyhlcnJvclBhcmFtcyk7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihhcHBlbmQsIGVycm9yUGF0aHMpO1xuICAgICAgICAgICAgdGhpcy5zZXRQYXJhbXMoe30pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Vycm9yKGFwcGVuZCwgZXJyb3JQYXRocyk7XG4gICAgfVxuICAgIF9lcnJvcihhcHBlbmQsIGVycm9yUGF0aHMpIHtcbiAgICAgICAgO1xuICAgICAgICAoYXBwZW5kID8gZXJyb3JzXzEucmVwb3J0RXh0cmFFcnJvciA6IGVycm9yc18xLnJlcG9ydEVycm9yKSh0aGlzLCB0aGlzLmRlZi5lcnJvciwgZXJyb3JQYXRocyk7XG4gICAgfVxuICAgICRkYXRhRXJyb3IoKSB7XG4gICAgICAgIGVycm9yc18xLnJlcG9ydEVycm9yKHRoaXMsIHRoaXMuZGVmLiRkYXRhRXJyb3IgfHwgZXJyb3JzXzEua2V5d29yZCREYXRhRXJyb3IpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyc0NvdW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZCBcInRyYWNrRXJyb3JzXCIgdG8ga2V5d29yZCBkZWZpbml0aW9uJyk7XG4gICAgICAgIGVycm9yc18xLnJlc2V0RXJyb3JzQ291bnQodGhpcy5nZW4sIHRoaXMuZXJyc0NvdW50KTtcbiAgICB9XG4gICAgb2soY29uZCkge1xuICAgICAgICBpZiAoIXRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgdGhpcy5nZW4uaWYoY29uZCk7XG4gICAgfVxuICAgIHNldFBhcmFtcyhvYmosIGFzc2lnbikge1xuICAgICAgICBpZiAoYXNzaWduKVxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnBhcmFtcywgb2JqKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBvYmo7XG4gICAgfVxuICAgIGJsb2NrJGRhdGEodmFsaWQsIGNvZGVCbG9jaywgJGRhdGFWYWxpZCA9IGNvZGVnZW5fMS5uaWwpIHtcbiAgICAgICAgdGhpcy5nZW4uYmxvY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGVjayRkYXRhKHZhbGlkLCAkZGF0YVZhbGlkKTtcbiAgICAgICAgICAgIGNvZGVCbG9jaygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2hlY2skZGF0YSh2YWxpZCA9IGNvZGVnZW5fMS5uaWwsICRkYXRhVmFsaWQgPSBjb2RlZ2VuXzEubmlsKSB7XG4gICAgICAgIGlmICghdGhpcy4kZGF0YSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYUNvZGUsIHNjaGVtYVR5cGUsIGRlZiB9ID0gdGhpcztcbiAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5vcihjb2RlZ2VuXzEuXyBgJHtzY2hlbWFDb2RlfSA9PT0gdW5kZWZpbmVkYCwgJGRhdGFWYWxpZCkpO1xuICAgICAgICBpZiAodmFsaWQgIT09IGNvZGVnZW5fMS5uaWwpXG4gICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgaWYgKHNjaGVtYVR5cGUubGVuZ3RoIHx8IGRlZi52YWxpZGF0ZVNjaGVtYSkge1xuICAgICAgICAgICAgZ2VuLmVsc2VJZih0aGlzLmludmFsaWQkZGF0YSgpKTtcbiAgICAgICAgICAgIHRoaXMuJGRhdGFFcnJvcigpO1xuICAgICAgICAgICAgaWYgKHZhbGlkICE9PSBjb2RlZ2VuXzEubmlsKVxuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBnZW4uZWxzZSgpO1xuICAgIH1cbiAgICBpbnZhbGlkJGRhdGEoKSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWFDb2RlLCBzY2hlbWFUeXBlLCBkZWYsIGl0IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gY29kZWdlbl8xLm9yKHdyb25nJERhdGFUeXBlKCksIGludmFsaWQkRGF0YVNjaGVtYSgpKTtcbiAgICAgICAgZnVuY3Rpb24gd3JvbmckRGF0YVR5cGUoKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hVHlwZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoIShzY2hlbWFDb2RlIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3QgPSBBcnJheS5pc0FycmF5KHNjaGVtYVR5cGUpID8gc2NoZW1hVHlwZSA6IFtzY2hlbWFUeXBlXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLl8gYCR7ZGF0YVR5cGVfMi5jaGVja0RhdGFUeXBlcyhzdCwgc2NoZW1hQ29kZSwgaXQub3B0cy5zdHJpY3ROdW1iZXJzLCBkYXRhVHlwZV8yLkRhdGFUeXBlLldyb25nKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5uaWw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW52YWxpZCREYXRhU2NoZW1hKCkge1xuICAgICAgICAgICAgaWYgKGRlZi52YWxpZGF0ZVNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRlU2NoZW1hUmVmID0gZ2VuLnNjb3BlVmFsdWUoXCJ2YWxpZGF0ZSRkYXRhXCIsIHsgcmVmOiBkZWYudmFsaWRhdGVTY2hlbWEgfSk7IC8vIFRPRE8gdmFsdWUuY29kZSBmb3Igc3RhbmRhbG9uZVxuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgISR7dmFsaWRhdGVTY2hlbWFSZWZ9KCR7c2NoZW1hQ29kZX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEubmlsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN1YnNjaGVtYShhcHBsLCB2YWxpZCkge1xuICAgICAgICBjb25zdCBzdWJzY2hlbWEgPSBzdWJzY2hlbWFfMS5nZXRTdWJzY2hlbWEodGhpcy5pdCwgYXBwbCk7XG4gICAgICAgIHN1YnNjaGVtYV8xLmV4dGVuZFN1YnNjaGVtYURhdGEoc3Vic2NoZW1hLCB0aGlzLml0LCBhcHBsKTtcbiAgICAgICAgc3Vic2NoZW1hXzEuZXh0ZW5kU3Vic2NoZW1hTW9kZShzdWJzY2hlbWEsIGFwcGwpO1xuICAgICAgICBjb25zdCBuZXh0Q29udGV4dCA9IHsgLi4udGhpcy5pdCwgLi4uc3Vic2NoZW1hLCBpdGVtczogdW5kZWZpbmVkLCBwcm9wczogdW5kZWZpbmVkIH07XG4gICAgICAgIHN1YnNjaGVtYUNvZGUobmV4dENvbnRleHQsIHZhbGlkKTtcbiAgICAgICAgcmV0dXJuIG5leHRDb250ZXh0O1xuICAgIH1cbiAgICBtZXJnZUV2YWx1YXRlZChzY2hlbWFDeHQsIHRvTmFtZSkge1xuICAgICAgICBjb25zdCB7IGl0LCBnZW4gfSA9IHRoaXM7XG4gICAgICAgIGlmICghaXQub3B0cy51bmV2YWx1YXRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGl0LnByb3BzICE9PSB0cnVlICYmIHNjaGVtYUN4dC5wcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpdC5wcm9wcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5wcm9wcyhnZW4sIHNjaGVtYUN4dC5wcm9wcywgaXQucHJvcHMsIHRvTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0Lml0ZW1zICE9PSB0cnVlICYmIHNjaGVtYUN4dC5pdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpdC5pdGVtcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5pdGVtcyhnZW4sIHNjaGVtYUN4dC5pdGVtcywgaXQuaXRlbXMsIHRvTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hlbWFDeHQsIHZhbGlkKSB7XG4gICAgICAgIGNvbnN0IHsgaXQsIGdlbiB9ID0gdGhpcztcbiAgICAgICAgaWYgKGl0Lm9wdHMudW5ldmFsdWF0ZWQgJiYgKGl0LnByb3BzICE9PSB0cnVlIHx8IGl0Lml0ZW1zICE9PSB0cnVlKSkge1xuICAgICAgICAgICAgZ2VuLmlmKHZhbGlkLCAoKSA9PiB0aGlzLm1lcmdlRXZhbHVhdGVkKHNjaGVtYUN4dCwgY29kZWdlbl8xLk5hbWUpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5LZXl3b3JkQ3h0ID0gS2V5d29yZEN4dDtcbmZ1bmN0aW9uIGtleXdvcmRDb2RlKGl0LCBrZXl3b3JkLCBkZWYsIHJ1bGVUeXBlKSB7XG4gICAgY29uc3QgY3h0ID0gbmV3IEtleXdvcmRDeHQoaXQsIGRlZiwga2V5d29yZCk7XG4gICAgaWYgKFwiY29kZVwiIGluIGRlZikge1xuICAgICAgICBkZWYuY29kZShjeHQsIHJ1bGVUeXBlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3h0LiRkYXRhICYmIGRlZi52YWxpZGF0ZSkge1xuICAgICAgICBrZXl3b3JkXzEuZnVuY0tleXdvcmRDb2RlKGN4dCwgZGVmKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXCJtYWNyb1wiIGluIGRlZikge1xuICAgICAgICBrZXl3b3JkXzEubWFjcm9LZXl3b3JkQ29kZShjeHQsIGRlZik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlZi5jb21waWxlIHx8IGRlZi52YWxpZGF0ZSkge1xuICAgICAgICBrZXl3b3JkXzEuZnVuY0tleXdvcmRDb2RlKGN4dCwgZGVmKTtcbiAgICB9XG59XG5jb25zdCBKU09OX1BPSU5URVIgPSAvXlxcLyg/Oltefl18fjB8fjEpKiQvO1xuY29uc3QgUkVMQVRJVkVfSlNPTl9QT0lOVEVSID0gL14oWzAtOV0rKSgjfFxcLyg/Oltefl18fjB8fjEpKik/JC87XG5mdW5jdGlvbiBnZXREYXRhKCRkYXRhLCB7IGRhdGFMZXZlbCwgZGF0YU5hbWVzLCBkYXRhUGF0aEFyciB9KSB7XG4gICAgbGV0IGpzb25Qb2ludGVyO1xuICAgIGxldCBkYXRhO1xuICAgIGlmICgkZGF0YSA9PT0gXCJcIilcbiAgICAgICAgcmV0dXJuIG5hbWVzXzEuZGVmYXVsdC5yb290RGF0YTtcbiAgICBpZiAoJGRhdGFbMF0gPT09IFwiL1wiKSB7XG4gICAgICAgIGlmICghSlNPTl9QT0lOVEVSLnRlc3QoJGRhdGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEpTT04tcG9pbnRlcjogJHskZGF0YX1gKTtcbiAgICAgICAganNvblBvaW50ZXIgPSAkZGF0YTtcbiAgICAgICAgZGF0YSA9IG5hbWVzXzEuZGVmYXVsdC5yb290RGF0YTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBSRUxBVElWRV9KU09OX1BPSU5URVIuZXhlYygkZGF0YSk7XG4gICAgICAgIGlmICghbWF0Y2hlcylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBKU09OLXBvaW50ZXI6ICR7JGRhdGF9YCk7XG4gICAgICAgIGNvbnN0IHVwID0gK21hdGNoZXNbMV07XG4gICAgICAgIGpzb25Qb2ludGVyID0gbWF0Y2hlc1syXTtcbiAgICAgICAgaWYgKGpzb25Qb2ludGVyID09PSBcIiNcIikge1xuICAgICAgICAgICAgaWYgKHVwID49IGRhdGFMZXZlbClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2coXCJwcm9wZXJ0eS9pbmRleFwiLCB1cCkpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFQYXRoQXJyW2RhdGFMZXZlbCAtIHVwXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXAgPiBkYXRhTGV2ZWwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2coXCJkYXRhXCIsIHVwKSk7XG4gICAgICAgIGRhdGEgPSBkYXRhTmFtZXNbZGF0YUxldmVsIC0gdXBdO1xuICAgICAgICBpZiAoIWpzb25Qb2ludGVyKVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGxldCBleHByID0gZGF0YTtcbiAgICBjb25zdCBzZWdtZW50cyA9IGpzb25Qb2ludGVyLnNwbGl0KFwiL1wiKTtcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgICAgIGRhdGEgPSBjb2RlZ2VuXzEuXyBgJHtkYXRhfSR7Y29kZWdlbl8xLmdldFByb3BlcnR5KHV0aWxfMS51bmVzY2FwZUpzb25Qb2ludGVyKHNlZ21lbnQpKX1gO1xuICAgICAgICAgICAgZXhwciA9IGNvZGVnZW5fMS5fIGAke2V4cHJ9ICYmICR7ZGF0YX1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHByO1xuICAgIGZ1bmN0aW9uIGVycm9yTXNnKHBvaW50ZXJUeXBlLCB1cCkge1xuICAgICAgICByZXR1cm4gYENhbm5vdCBhY2Nlc3MgJHtwb2ludGVyVHlwZX0gJHt1cH0gbGV2ZWxzIHVwLCBjdXJyZW50IGxldmVsIGlzICR7ZGF0YUxldmVsfWA7XG4gICAgfVxufVxuZXhwb3J0cy5nZXREYXRhID0gZ2V0RGF0YTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGVycm9ycykge1xuICAgICAgICBzdXBlcihcInZhbGlkYXRpb24gZmFpbGVkXCIpO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhpcy5hanYgPSB0aGlzLnZhbGlkYXRpb24gPSB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFZhbGlkYXRpb25FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRpb25fZXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByZXNvbHZlXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlXCIpO1xuY2xhc3MgTWlzc2luZ1JlZkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGJhc2VJZCwgcmVmLCBtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnIHx8IGBjYW4ndCByZXNvbHZlIHJlZmVyZW5jZSAke3JlZn0gZnJvbSBpZCAke2Jhc2VJZH1gKTtcbiAgICAgICAgdGhpcy5taXNzaW5nUmVmID0gcmVzb2x2ZV8xLnJlc29sdmVVcmwoYmFzZUlkLCByZWYpO1xuICAgICAgICB0aGlzLm1pc3NpbmdTY2hlbWEgPSByZXNvbHZlXzEubm9ybWFsaXplSWQocmVzb2x2ZV8xLmdldEZ1bGxQYXRoKHRoaXMubWlzc2luZ1JlZikpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IE1pc3NpbmdSZWZFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZl9lcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVzb2x2ZVNjaGVtYSA9IGV4cG9ydHMuZ2V0Q29tcGlsaW5nU2NoZW1hID0gZXhwb3J0cy5yZXNvbHZlUmVmID0gZXhwb3J0cy5jb21waWxlU2NoZW1hID0gZXhwb3J0cy5TY2hlbWFFbnYgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgdmFsaWRhdGlvbl9lcnJvcl8xID0gcmVxdWlyZShcIi4uL3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi9uYW1lc1wiKTtcbmNvbnN0IHJlc29sdmVfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRlXCIpO1xuY29uc3QgVVJJID0gcmVxdWlyZShcInVyaS1qc1wiKTtcbmNsYXNzIFNjaGVtYUVudiB7XG4gICAgY29uc3RydWN0b3IoZW52KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5yZWZzID0ge307XG4gICAgICAgIHRoaXMuZHluYW1pY0FuY2hvcnMgPSB7fTtcbiAgICAgICAgbGV0IHNjaGVtYTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnYuc2NoZW1hID09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICBzY2hlbWEgPSBlbnYuc2NoZW1hO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IGVudi5zY2hlbWE7XG4gICAgICAgIHRoaXMuc2NoZW1hSWQgPSBlbnYuc2NoZW1hSWQ7XG4gICAgICAgIHRoaXMucm9vdCA9IGVudi5yb290IHx8IHRoaXM7XG4gICAgICAgIHRoaXMuYmFzZUlkID0gKF9hID0gZW52LmJhc2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKHNjaGVtYSA9PT0gbnVsbCB8fCBzY2hlbWEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaGVtYVtlbnYuc2NoZW1hSWQgfHwgXCIkaWRcIl0pO1xuICAgICAgICB0aGlzLnNjaGVtYVBhdGggPSBlbnYuc2NoZW1hUGF0aDtcbiAgICAgICAgdGhpcy5sb2NhbFJlZnMgPSBlbnYubG9jYWxSZWZzO1xuICAgICAgICB0aGlzLm1ldGEgPSBlbnYubWV0YTtcbiAgICAgICAgdGhpcy4kYXN5bmMgPSBzY2hlbWEgPT09IG51bGwgfHwgc2NoZW1hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2hlbWEuJGFzeW5jO1xuICAgICAgICB0aGlzLnJlZnMgPSB7fTtcbiAgICB9XG59XG5leHBvcnRzLlNjaGVtYUVudiA9IFNjaGVtYUVudjtcbi8vIGxldCBjb2RlU2l6ZSA9IDBcbi8vIGxldCBub2RlQ291bnQgPSAwXG4vLyBDb21waWxlcyBzY2hlbWEgaW4gU2NoZW1hRW52XG5mdW5jdGlvbiBjb21waWxlU2NoZW1hKHNjaCkge1xuICAgIC8vIFRPRE8gcmVmYWN0b3IgLSByZW1vdmUgY29tcGlsYXRpb25zXG4gICAgY29uc3QgX3NjaCA9IGdldENvbXBpbGluZ1NjaGVtYS5jYWxsKHRoaXMsIHNjaCk7XG4gICAgaWYgKF9zY2gpXG4gICAgICAgIHJldHVybiBfc2NoO1xuICAgIGNvbnN0IHJvb3RJZCA9IHJlc29sdmVfMS5nZXRGdWxsUGF0aChzY2gucm9vdC5iYXNlSWQpOyAvLyBUT0RPIGlmIGdldEZ1bGxQYXRoIHJlbW92ZWQgMSB0ZXN0cyBmYWlsc1xuICAgIGNvbnN0IHsgZXM1LCBsaW5lcyB9ID0gdGhpcy5vcHRzLmNvZGU7XG4gICAgY29uc3QgeyBvd25Qcm9wZXJ0aWVzIH0gPSB0aGlzLm9wdHM7XG4gICAgY29uc3QgZ2VuID0gbmV3IGNvZGVnZW5fMS5Db2RlR2VuKHRoaXMuc2NvcGUsIHsgZXM1LCBsaW5lcywgb3duUHJvcGVydGllcyB9KTtcbiAgICBsZXQgX1ZhbGlkYXRpb25FcnJvcjtcbiAgICBpZiAoc2NoLiRhc3luYykge1xuICAgICAgICBfVmFsaWRhdGlvbkVycm9yID0gZ2VuLnNjb3BlVmFsdWUoXCJFcnJvclwiLCB7XG4gICAgICAgICAgICByZWY6IHZhbGlkYXRpb25fZXJyb3JfMS5kZWZhdWx0LFxuICAgICAgICAgICAgY29kZTogY29kZWdlbl8xLl8gYHJlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIikuZGVmYXVsdGAsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZGF0ZU5hbWUgPSBnZW4uc2NvcGVOYW1lKFwidmFsaWRhdGVcIik7XG4gICAgc2NoLnZhbGlkYXRlTmFtZSA9IHZhbGlkYXRlTmFtZTtcbiAgICBjb25zdCBzY2hlbWFDeHQgPSB7XG4gICAgICAgIGdlbixcbiAgICAgICAgYWxsRXJyb3JzOiB0aGlzLm9wdHMuYWxsRXJyb3JzLFxuICAgICAgICBkYXRhOiBuYW1lc18xLmRlZmF1bHQuZGF0YSxcbiAgICAgICAgcGFyZW50RGF0YTogbmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGEsXG4gICAgICAgIHBhcmVudERhdGFQcm9wZXJ0eTogbmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSxcbiAgICAgICAgZGF0YU5hbWVzOiBbbmFtZXNfMS5kZWZhdWx0LmRhdGFdLFxuICAgICAgICBkYXRhUGF0aEFycjogW2NvZGVnZW5fMS5uaWxdLFxuICAgICAgICBkYXRhTGV2ZWw6IDAsXG4gICAgICAgIGRhdGFUeXBlczogW10sXG4gICAgICAgIGRlZmluZWRQcm9wZXJ0aWVzOiBuZXcgU2V0KCksXG4gICAgICAgIHRvcFNjaGVtYVJlZjogZ2VuLnNjb3BlVmFsdWUoXCJzY2hlbWFcIiwgdGhpcy5vcHRzLmNvZGUuc291cmNlID09PSB0cnVlXG4gICAgICAgICAgICA/IHsgcmVmOiBzY2guc2NoZW1hLCBjb2RlOiBjb2RlZ2VuXzEuc3RyaW5naWZ5KHNjaC5zY2hlbWEpIH1cbiAgICAgICAgICAgIDogeyByZWY6IHNjaC5zY2hlbWEgfSksXG4gICAgICAgIHZhbGlkYXRlTmFtZSxcbiAgICAgICAgVmFsaWRhdGlvbkVycm9yOiBfVmFsaWRhdGlvbkVycm9yLFxuICAgICAgICBzY2hlbWE6IHNjaC5zY2hlbWEsXG4gICAgICAgIHNjaGVtYUVudjogc2NoLFxuICAgICAgICByb290SWQsXG4gICAgICAgIGJhc2VJZDogc2NoLmJhc2VJZCB8fCByb290SWQsXG4gICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5uaWwsXG4gICAgICAgIGVyclNjaGVtYVBhdGg6IHNjaC5zY2hlbWFQYXRoIHx8ICh0aGlzLm9wdHMuanRkID8gXCJcIiA6IFwiI1wiKSxcbiAgICAgICAgZXJyb3JQYXRoOiBjb2RlZ2VuXzEuXyBgXCJcImAsXG4gICAgICAgIG9wdHM6IHRoaXMub3B0cyxcbiAgICAgICAgc2VsZjogdGhpcyxcbiAgICB9O1xuICAgIGxldCBzb3VyY2VDb2RlO1xuICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGF0aW9ucy5hZGQoc2NoKTtcbiAgICAgICAgdmFsaWRhdGVfMS52YWxpZGF0ZUZ1bmN0aW9uQ29kZShzY2hlbWFDeHQpO1xuICAgICAgICBnZW4ub3B0aW1pemUodGhpcy5vcHRzLmNvZGUub3B0aW1pemUpO1xuICAgICAgICAvLyBnZW4ub3B0aW1pemUoMSlcbiAgICAgICAgY29uc3QgdmFsaWRhdGVDb2RlID0gZ2VuLnRvU3RyaW5nKCk7XG4gICAgICAgIHNvdXJjZUNvZGUgPSBgJHtnZW4uc2NvcGVSZWZzKG5hbWVzXzEuZGVmYXVsdC5zY29wZSl9cmV0dXJuICR7dmFsaWRhdGVDb2RlfWA7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKChjb2RlU2l6ZSArPSBzb3VyY2VDb2RlLmxlbmd0aCksIChub2RlQ291bnQgKz0gZ2VuLm5vZGVDb3VudCkpXG4gICAgICAgIGlmICh0aGlzLm9wdHMuY29kZS5wcm9jZXNzKVxuICAgICAgICAgICAgc291cmNlQ29kZSA9IHRoaXMub3B0cy5jb2RlLnByb2Nlc3Moc291cmNlQ29kZSwgc2NoKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJcXG5cXG5cXG4gKioqIFxcblwiLCBzb3VyY2VDb2RlKVxuICAgICAgICBjb25zdCBtYWtlVmFsaWRhdGUgPSBuZXcgRnVuY3Rpb24oYCR7bmFtZXNfMS5kZWZhdWx0LnNlbGZ9YCwgYCR7bmFtZXNfMS5kZWZhdWx0LnNjb3BlfWAsIHNvdXJjZUNvZGUpO1xuICAgICAgICBjb25zdCB2YWxpZGF0ZSA9IG1ha2VWYWxpZGF0ZSh0aGlzLCB0aGlzLnNjb3BlLmdldCgpKTtcbiAgICAgICAgdGhpcy5zY29wZS52YWx1ZSh2YWxpZGF0ZU5hbWUsIHsgcmVmOiB2YWxpZGF0ZSB9KTtcbiAgICAgICAgdmFsaWRhdGUuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgdmFsaWRhdGUuc2NoZW1hID0gc2NoLnNjaGVtYTtcbiAgICAgICAgdmFsaWRhdGUuc2NoZW1hRW52ID0gc2NoO1xuICAgICAgICBpZiAoc2NoLiRhc3luYylcbiAgICAgICAgICAgIHZhbGlkYXRlLiRhc3luYyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuY29kZS5zb3VyY2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlLnNvdXJjZSA9IHsgdmFsaWRhdGVOYW1lLCB2YWxpZGF0ZUNvZGUsIHNjb3BlVmFsdWVzOiBnZW4uX3ZhbHVlcyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdHMudW5ldmFsdWF0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMsIGl0ZW1zIH0gPSBzY2hlbWFDeHQ7XG4gICAgICAgICAgICB2YWxpZGF0ZS5ldmFsdWF0ZWQgPSB7XG4gICAgICAgICAgICAgICAgcHJvcHM6IHByb3BzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUgPyB1bmRlZmluZWQgOiBwcm9wcyxcbiAgICAgICAgICAgICAgICBpdGVtczogaXRlbXMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSA/IHVuZGVmaW5lZCA6IGl0ZW1zLFxuICAgICAgICAgICAgICAgIGR5bmFtaWNQcm9wczogcHJvcHMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSxcbiAgICAgICAgICAgICAgICBkeW5hbWljSXRlbXM6IGl0ZW1zIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRlLnNvdXJjZSlcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZS5zb3VyY2UuZXZhbHVhdGVkID0gY29kZWdlbl8xLnN0cmluZ2lmeSh2YWxpZGF0ZS5ldmFsdWF0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHNjaC52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuICAgICAgICByZXR1cm4gc2NoO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBkZWxldGUgc2NoLnZhbGlkYXRlO1xuICAgICAgICBkZWxldGUgc2NoLnZhbGlkYXRlTmFtZTtcbiAgICAgICAgaWYgKHNvdXJjZUNvZGUpXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIkVycm9yIGNvbXBpbGluZyBzY2hlbWEsIGZ1bmN0aW9uIGNvZGU6XCIsIHNvdXJjZUNvZGUpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlxcblxcblxcbiAqKiogXFxuXCIsIHNvdXJjZUNvZGUsIHRoaXMub3B0cylcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGF0aW9ucy5kZWxldGUoc2NoKTtcbiAgICB9XG59XG5leHBvcnRzLmNvbXBpbGVTY2hlbWEgPSBjb21waWxlU2NoZW1hO1xuZnVuY3Rpb24gcmVzb2x2ZVJlZihyb290LCBiYXNlSWQsIHJlZikge1xuICAgIHZhciBfYTtcbiAgICByZWYgPSByZXNvbHZlXzEucmVzb2x2ZVVybChiYXNlSWQsIHJlZik7XG4gICAgY29uc3Qgc2NoT3JGdW5jID0gcm9vdC5yZWZzW3JlZl07XG4gICAgaWYgKHNjaE9yRnVuYylcbiAgICAgICAgcmV0dXJuIHNjaE9yRnVuYztcbiAgICBsZXQgX3NjaCA9IHJlc29sdmUuY2FsbCh0aGlzLCByb290LCByZWYpO1xuICAgIGlmIChfc2NoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gKF9hID0gcm9vdC5sb2NhbFJlZnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtyZWZdOyAvLyBUT0RPIG1heWJlIGxvY2FsUmVmcyBzaG91bGQgaG9sZCBTY2hlbWFFbnZcbiAgICAgICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICBpZiAoc2NoZW1hKVxuICAgICAgICAgICAgX3NjaCA9IG5ldyBTY2hlbWFFbnYoeyBzY2hlbWEsIHNjaGVtYUlkLCByb290LCBiYXNlSWQgfSk7XG4gICAgfVxuICAgIGlmIChfc2NoID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICByZXR1cm4gKHJvb3QucmVmc1tyZWZdID0gaW5saW5lT3JDb21waWxlLmNhbGwodGhpcywgX3NjaCkpO1xufVxuZXhwb3J0cy5yZXNvbHZlUmVmID0gcmVzb2x2ZVJlZjtcbmZ1bmN0aW9uIGlubGluZU9yQ29tcGlsZShzY2gpIHtcbiAgICBpZiAocmVzb2x2ZV8xLmlubGluZVJlZihzY2guc2NoZW1hLCB0aGlzLm9wdHMuaW5saW5lUmVmcykpXG4gICAgICAgIHJldHVybiBzY2guc2NoZW1hO1xuICAgIHJldHVybiBzY2gudmFsaWRhdGUgPyBzY2ggOiBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbn1cbi8vIEluZGV4IG9mIHNjaGVtYSBjb21waWxhdGlvbiBpbiB0aGUgY3VycmVudGx5IGNvbXBpbGVkIGxpc3RcbmZ1bmN0aW9uIGdldENvbXBpbGluZ1NjaGVtYShzY2hFbnYpIHtcbiAgICBmb3IgKGNvbnN0IHNjaCBvZiB0aGlzLl9jb21waWxhdGlvbnMpIHtcbiAgICAgICAgaWYgKHNhbWVTY2hlbWFFbnYoc2NoLCBzY2hFbnYpKVxuICAgICAgICAgICAgcmV0dXJuIHNjaDtcbiAgICB9XG59XG5leHBvcnRzLmdldENvbXBpbGluZ1NjaGVtYSA9IGdldENvbXBpbGluZ1NjaGVtYTtcbmZ1bmN0aW9uIHNhbWVTY2hlbWFFbnYoczEsIHMyKSB7XG4gICAgcmV0dXJuIHMxLnNjaGVtYSA9PT0gczIuc2NoZW1hICYmIHMxLnJvb3QgPT09IHMyLnJvb3QgJiYgczEuYmFzZUlkID09PSBzMi5iYXNlSWQ7XG59XG4vLyByZXNvbHZlIGFuZCBjb21waWxlIHRoZSByZWZlcmVuY2VzICgkcmVmKVxuLy8gVE9ETyByZXR1cm5zIEFueVNjaGVtYU9iamVjdCAoaWYgdGhlIHNjaGVtYSBjYW4gYmUgaW5saW5lZCkgb3IgdmFsaWRhdGlvbiBmdW5jdGlvblxuZnVuY3Rpb24gcmVzb2x2ZShyb290LCAvLyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcm9vdCBzY2hlbWEgZm9yIHRoZSBjdXJyZW50IHNjaGVtYVxucmVmIC8vIHJlZmVyZW5jZSB0byByZXNvbHZlXG4pIHtcbiAgICBsZXQgc2NoO1xuICAgIHdoaWxlICh0eXBlb2YgKHNjaCA9IHRoaXMucmVmc1tyZWZdKSA9PSBcInN0cmluZ1wiKVxuICAgICAgICByZWYgPSBzY2g7XG4gICAgcmV0dXJuIHNjaCB8fCB0aGlzLnNjaGVtYXNbcmVmXSB8fCByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgcmVmKTtcbn1cbi8vIFJlc29sdmUgc2NoZW1hLCBpdHMgcm9vdCBhbmQgYmFzZUlkXG5mdW5jdGlvbiByZXNvbHZlU2NoZW1hKHJvb3QsIC8vIHJvb3Qgb2JqZWN0IHdpdGggcHJvcGVydGllcyBzY2hlbWEsIHJlZnMgVE9ETyBiZWxvdyBTY2hlbWFFbnYgaXMgYXNzaWduZWQgdG8gaXRcbnJlZiAvLyByZWZlcmVuY2UgdG8gcmVzb2x2ZVxuKSB7XG4gICAgY29uc3QgcCA9IFVSSS5wYXJzZShyZWYpO1xuICAgIGNvbnN0IHJlZlBhdGggPSByZXNvbHZlXzEuX2dldEZ1bGxQYXRoKHApO1xuICAgIGxldCBiYXNlSWQgPSByZXNvbHZlXzEuZ2V0RnVsbFBhdGgocm9vdC5iYXNlSWQpO1xuICAgIC8vIFRPRE8gYE9iamVjdC5rZXlzKHJvb3Quc2NoZW1hKS5sZW5ndGggPiAwYCBzaG91bGQgbm90IGJlIG5lZWRlZCAtIGJ1dCByZW1vdmluZyBicmVha3MgMiB0ZXN0c1xuICAgIGlmIChPYmplY3Qua2V5cyhyb290LnNjaGVtYSkubGVuZ3RoID4gMCAmJiByZWZQYXRoID09PSBiYXNlSWQpIHtcbiAgICAgICAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcCwgcm9vdCk7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKHJlZlBhdGgpO1xuICAgIGNvbnN0IHNjaE9yUmVmID0gdGhpcy5yZWZzW2lkXSB8fCB0aGlzLnNjaGVtYXNbaWRdO1xuICAgIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBzY2ggPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgc2NoT3JSZWYpO1xuICAgICAgICBpZiAodHlwZW9mIChzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2guc2NoZW1hKSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcCwgc2NoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoc2NoT3JSZWYgPT09IG51bGwgfHwgc2NoT3JSZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaE9yUmVmLnNjaGVtYSkgIT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIXNjaE9yUmVmLnZhbGlkYXRlKVxuICAgICAgICBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoT3JSZWYpO1xuICAgIGlmIChpZCA9PT0gcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKHJlZikpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEgfSA9IHNjaE9yUmVmO1xuICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIGNvbnN0IHNjaElkID0gc2NoZW1hW3NjaGVtYUlkXTtcbiAgICAgICAgaWYgKHNjaElkKVxuICAgICAgICAgICAgYmFzZUlkID0gcmVzb2x2ZV8xLnJlc29sdmVVcmwoYmFzZUlkLCBzY2hJZCk7XG4gICAgICAgIHJldHVybiBuZXcgU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCBzY2hPclJlZik7XG59XG5leHBvcnRzLnJlc29sdmVTY2hlbWEgPSByZXNvbHZlU2NoZW1hO1xuY29uc3QgUFJFVkVOVF9TQ09QRV9DSEFOR0UgPSBuZXcgU2V0KFtcbiAgICBcInByb3BlcnRpZXNcIixcbiAgICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgXCJlbnVtXCIsXG4gICAgXCJkZXBlbmRlbmNpZXNcIixcbiAgICBcImRlZmluaXRpb25zXCIsXG5dKTtcbmZ1bmN0aW9uIGdldEpzb25Qb2ludGVyKHBhcnNlZFJlZiwgeyBiYXNlSWQsIHNjaGVtYSwgcm9vdCB9KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICgoKF9hID0gcGFyc2VkUmVmLmZyYWdtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pICE9PSBcIi9cIilcbiAgICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJzZWRSZWYuZnJhZ21lbnQuc2xpY2UoMSkuc3BsaXQoXCIvXCIpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzY2hlbWEgPSBzY2hlbWFbdXRpbF8xLnVuZXNjYXBlRnJhZ21lbnQocGFydCldO1xuICAgICAgICBpZiAoc2NoZW1hID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIFRPRE8gUFJFVkVOVF9TQ09QRV9DSEFOR0UgY291bGQgYmUgZGVmaW5lZCBpbiBrZXl3b3JkIGRlZj9cbiAgICAgICAgY29uc3Qgc2NoSWQgPSB0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgc2NoZW1hW3RoaXMub3B0cy5zY2hlbWFJZF07XG4gICAgICAgIGlmICghUFJFVkVOVF9TQ09QRV9DSEFOR0UuaGFzKHBhcnQpICYmIHNjaElkKSB7XG4gICAgICAgICAgICBiYXNlSWQgPSByZXNvbHZlXzEucmVzb2x2ZVVybChiYXNlSWQsIHNjaElkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgZW52O1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hICE9IFwiYm9vbGVhblwiICYmIHNjaGVtYS4kcmVmICYmICF1dGlsXzEuc2NoZW1hSGFzUnVsZXNCdXRSZWYoc2NoZW1hLCB0aGlzLlJVTEVTKSkge1xuICAgICAgICBjb25zdCAkcmVmID0gcmVzb2x2ZV8xLnJlc29sdmVVcmwoYmFzZUlkLCBzY2hlbWEuJHJlZik7XG4gICAgICAgIGVudiA9IHJlc29sdmVTY2hlbWEuY2FsbCh0aGlzLCByb290LCAkcmVmKTtcbiAgICB9XG4gICAgLy8gZXZlbiB0aG91Z2ggcmVzb2x1dGlvbiBmYWlsZWQgd2UgbmVlZCB0byByZXR1cm4gU2NoZW1hRW52IHRvIHRocm93IGV4Y2VwdGlvblxuICAgIC8vIHNvIHRoYXQgY29tcGlsZUFzeW5jIGxvYWRzIG1pc3Npbmcgc2NoZW1hLlxuICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICBlbnYgPSBlbnYgfHwgbmV3IFNjaGVtYUVudih7IHNjaGVtYSwgc2NoZW1hSWQsIHJvb3QsIGJhc2VJZCB9KTtcbiAgICBpZiAoZW52LnNjaGVtYSAhPT0gZW52LnJvb3Quc2NoZW1hKVxuICAgICAgICByZXR1cm4gZW52O1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29kZUdlbiA9IGV4cG9ydHMuTmFtZSA9IGV4cG9ydHMubmlsID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuXyA9IGV4cG9ydHMuS2V5d29yZEN4dCA9IHZvaWQgMDtcbnZhciB2YWxpZGF0ZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS92YWxpZGF0ZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIktleXdvcmRDeHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRlXzEuS2V5d29yZEN4dDsgfSB9KTtcbnZhciBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL2NvZGVnZW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuXzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0clwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cmluZ2lmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5pbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLm5pbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5OYW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29kZUdlblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLkNvZGVHZW47IH0gfSk7XG5jb25zdCB2YWxpZGF0aW9uX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIik7XG5jb25zdCByZWZfZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvcmVmX2Vycm9yXCIpO1xuY29uc3QgcnVsZXNfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvcnVsZXNcIik7XG5jb25zdCBjb21waWxlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlXCIpO1xuY29uc3QgY29kZWdlbl8yID0gcmVxdWlyZShcIi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgcmVzb2x2ZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9yZXNvbHZlXCIpO1xuY29uc3QgZGF0YVR5cGVfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCAkZGF0YVJlZlNjaGVtYSA9IHJlcXVpcmUoXCIuL3JlZnMvZGF0YS5qc29uXCIpO1xuY29uc3QgTUVUQV9JR05PUkVfT1BUSU9OUyA9IFtcInJlbW92ZUFkZGl0aW9uYWxcIiwgXCJ1c2VEZWZhdWx0c1wiLCBcImNvZXJjZVR5cGVzXCJdO1xuY29uc3QgRVhUX1NDT1BFX05BTUVTID0gbmV3IFNldChbXG4gICAgXCJ2YWxpZGF0ZVwiLFxuICAgIFwic2VyaWFsaXplXCIsXG4gICAgXCJwYXJzZVwiLFxuICAgIFwid3JhcHBlclwiLFxuICAgIFwicm9vdFwiLFxuICAgIFwic2NoZW1hXCIsXG4gICAgXCJrZXl3b3JkXCIsXG4gICAgXCJwYXR0ZXJuXCIsXG4gICAgXCJmb3JtYXRzXCIsXG4gICAgXCJ2YWxpZGF0ZSRkYXRhXCIsXG4gICAgXCJmdW5jXCIsXG4gICAgXCJvYmpcIixcbiAgICBcIkVycm9yXCIsXG5dKTtcbmNvbnN0IHJlbW92ZWRPcHRpb25zID0ge1xuICAgIGVycm9yRGF0YVBhdGg6IFwiXCIsXG4gICAgZm9ybWF0OiBcImB2YWxpZGF0ZUZvcm1hdHM6IGZhbHNlYCBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICAgIG51bGxhYmxlOiAnXCJudWxsYWJsZVwiIGtleXdvcmQgaXMgc3VwcG9ydGVkIGJ5IGRlZmF1bHQuJyxcbiAgICBqc29uUG9pbnRlcnM6IFwiRGVwcmVjYXRlZCBqc1Byb3BlcnR5U3ludGF4IGNhbiBiZSB1c2VkIGluc3RlYWQuXCIsXG4gICAgZXh0ZW5kUmVmczogXCJEZXByZWNhdGVkIGlnbm9yZUtleXdvcmRzV2l0aFJlZiBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICAgIG1pc3NpbmdSZWZzOiBcIlBhc3MgZW1wdHkgc2NoZW1hIHdpdGggJGlkIHRoYXQgc2hvdWxkIGJlIGlnbm9yZWQgdG8gYWp2LmFkZFNjaGVtYS5cIixcbiAgICBwcm9jZXNzQ29kZTogXCJVc2Ugb3B0aW9uIGBjb2RlOiB7cHJvY2VzczogKGNvZGUsIHNjaGVtYUVudjogb2JqZWN0KSA9PiBzdHJpbmd9YFwiLFxuICAgIHNvdXJjZUNvZGU6IFwiVXNlIG9wdGlvbiBgY29kZToge3NvdXJjZTogdHJ1ZX1gXCIsXG4gICAgc3RyaWN0RGVmYXVsdHM6IFwiSXQgaXMgZGVmYXVsdCBub3csIHNlZSBvcHRpb24gYHN0cmljdGAuXCIsXG4gICAgc3RyaWN0S2V5d29yZHM6IFwiSXQgaXMgZGVmYXVsdCBub3csIHNlZSBvcHRpb24gYHN0cmljdGAuXCIsXG4gICAgdW5pcXVlSXRlbXM6ICdcInVuaXF1ZUl0ZW1zXCIga2V5d29yZCBpcyBhbHdheXMgdmFsaWRhdGVkLicsXG4gICAgdW5rbm93bkZvcm1hdHM6IFwiRGlzYWJsZSBzdHJpY3QgbW9kZSBvciBwYXNzIGB0cnVlYCB0byBgYWp2LmFkZEZvcm1hdGAgKG9yIGBmb3JtYXRzYCBvcHRpb24pLlwiLFxuICAgIGNhY2hlOiBcIk1hcCBpcyB1c2VkIGFzIGNhY2hlLCBzY2hlbWEgb2JqZWN0IGFzIGtleS5cIixcbiAgICBzZXJpYWxpemU6IFwiTWFwIGlzIHVzZWQgYXMgY2FjaGUsIHNjaGVtYSBvYmplY3QgYXMga2V5LlwiLFxuICAgIGFqdkVycm9yczogXCJJdCBpcyBkZWZhdWx0IG5vdy5cIixcbn07XG5jb25zdCBkZXByZWNhdGVkT3B0aW9ucyA9IHtcbiAgICBpZ25vcmVLZXl3b3Jkc1dpdGhSZWY6IFwiXCIsXG4gICAganNQcm9wZXJ0eVN5bnRheDogXCJcIixcbiAgICB1bmljb2RlOiAnXCJtaW5MZW5ndGhcIi9cIm1heExlbmd0aFwiIGFjY291bnQgZm9yIHVuaWNvZGUgY2hhcmFjdGVycyBieSBkZWZhdWx0LicsXG59O1xuY29uc3QgTUFYX0VYUFJFU1NJT04gPSAyMDA7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gcmVxdWlyZWRPcHRpb25zKG8pIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbSwgX28sIF9wLCBfcSwgX3IsIF9zLCBfdCwgX3UsIF92LCBfdywgX3g7XG4gICAgY29uc3QgcyA9IG8uc3RyaWN0O1xuICAgIGNvbnN0IF9vcHR6ID0gKF9hID0gby5jb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW1pemU7XG4gICAgY29uc3Qgb3B0aW1pemUgPSBfb3B0eiA9PT0gdHJ1ZSB8fCBfb3B0eiA9PT0gdW5kZWZpbmVkID8gMSA6IF9vcHR6IHx8IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RyaWN0U2NoZW1hOiAoX2MgPSAoX2IgPSBvLnN0cmljdFNjaGVtYSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogcykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdHJ1ZSxcbiAgICAgICAgc3RyaWN0TnVtYmVyczogKF9lID0gKF9kID0gby5zdHJpY3ROdW1iZXJzKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBzKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB0cnVlLFxuICAgICAgICBzdHJpY3RUeXBlczogKF9nID0gKF9mID0gby5zdHJpY3RUeXBlcykgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogcykgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogXCJsb2dcIixcbiAgICAgICAgc3RyaWN0VHVwbGVzOiAoX2ogPSAoX2ggPSBvLnN0cmljdFR1cGxlcykgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogcykgIT09IG51bGwgJiYgX2ogIT09IHZvaWQgMCA/IF9qIDogXCJsb2dcIixcbiAgICAgICAgc3RyaWN0UmVxdWlyZWQ6IChfbCA9IChfayA9IG8uc3RyaWN0UmVxdWlyZWQpICE9PSBudWxsICYmIF9rICE9PSB2b2lkIDAgPyBfayA6IHMpICE9PSBudWxsICYmIF9sICE9PSB2b2lkIDAgPyBfbCA6IGZhbHNlLFxuICAgICAgICBjb2RlOiBvLmNvZGUgPyB7IC4uLm8uY29kZSwgb3B0aW1pemUgfSA6IHsgb3B0aW1pemUgfSxcbiAgICAgICAgbG9vcFJlcXVpcmVkOiAoX20gPSBvLmxvb3BSZXF1aXJlZCkgIT09IG51bGwgJiYgX20gIT09IHZvaWQgMCA/IF9tIDogTUFYX0VYUFJFU1NJT04sXG4gICAgICAgIGxvb3BFbnVtOiAoX28gPSBvLmxvb3BFbnVtKSAhPT0gbnVsbCAmJiBfbyAhPT0gdm9pZCAwID8gX28gOiBNQVhfRVhQUkVTU0lPTixcbiAgICAgICAgbWV0YTogKF9wID0gby5tZXRhKSAhPT0gbnVsbCAmJiBfcCAhPT0gdm9pZCAwID8gX3AgOiB0cnVlLFxuICAgICAgICBtZXNzYWdlczogKF9xID0gby5tZXNzYWdlcykgIT09IG51bGwgJiYgX3EgIT09IHZvaWQgMCA/IF9xIDogdHJ1ZSxcbiAgICAgICAgaW5saW5lUmVmczogKF9yID0gby5pbmxpbmVSZWZzKSAhPT0gbnVsbCAmJiBfciAhPT0gdm9pZCAwID8gX3IgOiB0cnVlLFxuICAgICAgICBzY2hlbWFJZDogKF9zID0gby5zY2hlbWFJZCkgIT09IG51bGwgJiYgX3MgIT09IHZvaWQgMCA/IF9zIDogXCIkaWRcIixcbiAgICAgICAgYWRkVXNlZFNjaGVtYTogKF90ID0gby5hZGRVc2VkU2NoZW1hKSAhPT0gbnVsbCAmJiBfdCAhPT0gdm9pZCAwID8gX3QgOiB0cnVlLFxuICAgICAgICB2YWxpZGF0ZVNjaGVtYTogKF91ID0gby52YWxpZGF0ZVNjaGVtYSkgIT09IG51bGwgJiYgX3UgIT09IHZvaWQgMCA/IF91IDogdHJ1ZSxcbiAgICAgICAgdmFsaWRhdGVGb3JtYXRzOiAoX3YgPSBvLnZhbGlkYXRlRm9ybWF0cykgIT09IG51bGwgJiYgX3YgIT09IHZvaWQgMCA/IF92IDogdHJ1ZSxcbiAgICAgICAgdW5pY29kZVJlZ0V4cDogKF93ID0gby51bmljb2RlUmVnRXhwKSAhPT0gbnVsbCAmJiBfdyAhPT0gdm9pZCAwID8gX3cgOiB0cnVlLFxuICAgICAgICBpbnQzMnJhbmdlOiAoX3ggPSBvLmludDMycmFuZ2UpICE9PSBudWxsICYmIF94ICE9PSB2b2lkIDAgPyBfeCA6IHRydWUsXG4gICAgfTtcbn1cbmNsYXNzIEFqdiB7XG4gICAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgICAgIHRoaXMuc2NoZW1hcyA9IHt9O1xuICAgICAgICB0aGlzLnJlZnMgPSB7fTtcbiAgICAgICAgdGhpcy5mb3JtYXRzID0ge307XG4gICAgICAgIHRoaXMuX2NvbXBpbGF0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5fbG9hZGluZyA9IHt9O1xuICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgb3B0cyA9IHRoaXMub3B0cyA9IHsgLi4ub3B0cywgLi4ucmVxdWlyZWRPcHRpb25zKG9wdHMpIH07XG4gICAgICAgIGNvbnN0IHsgZXM1LCBsaW5lcyB9ID0gdGhpcy5vcHRzLmNvZGU7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBuZXcgY29kZWdlbl8yLlZhbHVlU2NvcGUoeyBzY29wZToge30sIHByZWZpeGVzOiBFWFRfU0NPUEVfTkFNRVMsIGVzNSwgbGluZXMgfSk7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gZ2V0TG9nZ2VyKG9wdHMubG9nZ2VyKTtcbiAgICAgICAgY29uc3QgZm9ybWF0T3B0ID0gb3B0cy52YWxpZGF0ZUZvcm1hdHM7XG4gICAgICAgIG9wdHMudmFsaWRhdGVGb3JtYXRzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuUlVMRVMgPSBydWxlc18xLmdldFJ1bGVzKCk7XG4gICAgICAgIGNoZWNrT3B0aW9ucy5jYWxsKHRoaXMsIHJlbW92ZWRPcHRpb25zLCBvcHRzLCBcIk5PVCBTVVBQT1JURURcIik7XG4gICAgICAgIGNoZWNrT3B0aW9ucy5jYWxsKHRoaXMsIGRlcHJlY2F0ZWRPcHRpb25zLCBvcHRzLCBcIkRFUFJFQ0FURURcIiwgXCJ3YXJuXCIpO1xuICAgICAgICB0aGlzLl9tZXRhT3B0cyA9IGdldE1ldGFTY2hlbWFPcHRpb25zLmNhbGwodGhpcyk7XG4gICAgICAgIGlmIChvcHRzLmZvcm1hdHMpXG4gICAgICAgICAgICBhZGRJbml0aWFsRm9ybWF0cy5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9hZGRWb2NhYnVsYXJpZXMoKTtcbiAgICAgICAgdGhpcy5fYWRkRGVmYXVsdE1ldGFTY2hlbWEoKTtcbiAgICAgICAgaWYgKG9wdHMua2V5d29yZHMpXG4gICAgICAgICAgICBhZGRJbml0aWFsS2V5d29yZHMuY2FsbCh0aGlzLCBvcHRzLmtleXdvcmRzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLm1ldGEgPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHRoaXMuYWRkTWV0YVNjaGVtYShvcHRzLm1ldGEpO1xuICAgICAgICBhZGRJbml0aWFsU2NoZW1hcy5jYWxsKHRoaXMpO1xuICAgICAgICBvcHRzLnZhbGlkYXRlRm9ybWF0cyA9IGZvcm1hdE9wdDtcbiAgICB9XG4gICAgX2FkZFZvY2FidWxhcmllcygpIHtcbiAgICAgICAgdGhpcy5hZGRLZXl3b3JkKFwiJGFzeW5jXCIpO1xuICAgIH1cbiAgICBfYWRkRGVmYXVsdE1ldGFTY2hlbWEoKSB7XG4gICAgICAgIGNvbnN0IHsgJGRhdGEsIG1ldGEsIHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIGxldCBfZGF0YVJlZlNjaGVtYSA9ICRkYXRhUmVmU2NoZW1hO1xuICAgICAgICBpZiAoc2NoZW1hSWQgPT09IFwiaWRcIikge1xuICAgICAgICAgICAgX2RhdGFSZWZTY2hlbWEgPSB7IC4uLiRkYXRhUmVmU2NoZW1hIH07XG4gICAgICAgICAgICBfZGF0YVJlZlNjaGVtYS5pZCA9IF9kYXRhUmVmU2NoZW1hLiRpZDtcbiAgICAgICAgICAgIGRlbGV0ZSBfZGF0YVJlZlNjaGVtYS4kaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEgJiYgJGRhdGEpXG4gICAgICAgICAgICB0aGlzLmFkZE1ldGFTY2hlbWEoX2RhdGFSZWZTY2hlbWEsIF9kYXRhUmVmU2NoZW1hW3NjaGVtYUlkXSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0TWV0YSgpIHtcbiAgICAgICAgY29uc3QgeyBtZXRhLCBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICByZXR1cm4gKHRoaXMub3B0cy5kZWZhdWx0TWV0YSA9IHR5cGVvZiBtZXRhID09IFwib2JqZWN0XCIgPyBtZXRhW3NjaGVtYUlkXSB8fCBtZXRhIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgdmFsaWRhdGUoc2NoZW1hS2V5UmVmLCAvLyBrZXksIHJlZiBvciBzY2hlbWEgb2JqZWN0XG4gICAgZGF0YSAvLyB0byBiZSB2YWxpZGF0ZWRcbiAgICApIHtcbiAgICAgICAgbGV0IHY7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hS2V5UmVmID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLmdldFNjaGVtYShzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgaWYgKCF2KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gc2NoZW1hIHdpdGgga2V5IG9yIHJlZiBcIiR7c2NoZW1hS2V5UmVmfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2ID0gdGhpcy5jb21waWxlKHNjaGVtYUtleVJlZik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWQgPSB2KGRhdGEpO1xuICAgICAgICBpZiAoIShcIiRhc3luY1wiIGluIHYpKVxuICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSB2LmVycm9ycztcbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cbiAgICBjb21waWxlKHNjaGVtYSwgX21ldGEpIHtcbiAgICAgICAgY29uc3Qgc2NoID0gdGhpcy5fYWRkU2NoZW1hKHNjaGVtYSwgX21ldGEpO1xuICAgICAgICByZXR1cm4gKHNjaC52YWxpZGF0ZSB8fCB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaCkpO1xuICAgIH1cbiAgICBjb21waWxlQXN5bmMoc2NoZW1hLCBtZXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRzLmxvYWRTY2hlbWEgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zLmxvYWRTY2hlbWEgc2hvdWxkIGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBsb2FkU2NoZW1hIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIHJldHVybiBydW5Db21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2hlbWEsIG1ldGEpO1xuICAgICAgICBhc3luYyBmdW5jdGlvbiBydW5Db21waWxlQXN5bmMoX3NjaGVtYSwgX21ldGEpIHtcbiAgICAgICAgICAgIGF3YWl0IGxvYWRNZXRhU2NoZW1hLmNhbGwodGhpcywgX3NjaGVtYS4kc2NoZW1hKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaCA9IHRoaXMuX2FkZFNjaGVtYShfc2NoZW1hLCBfbWV0YSk7XG4gICAgICAgICAgICByZXR1cm4gc2NoLnZhbGlkYXRlIHx8IF9jb21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRNZXRhU2NoZW1hKCRyZWYpIHtcbiAgICAgICAgICAgIGlmICgkcmVmICYmICF0aGlzLmdldFNjaGVtYSgkcmVmKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJ1bkNvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHsgJHJlZiB9LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBfY29tcGlsZUFzeW5jKHNjaCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcGlsZVNjaGVtYUVudihzY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgcmVmX2Vycm9yXzEuZGVmYXVsdCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgY2hlY2tMb2FkZWQuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBsb2FkTWlzc2luZ1NjaGVtYS5jYWxsKHRoaXMsIGUubWlzc2luZ1NjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTG9hZGVkKHsgbWlzc2luZ1NjaGVtYTogcmVmLCBtaXNzaW5nUmVmIH0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlZnNbcmVmXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW55U2NoZW1hICR7cmVmfSBpcyBsb2FkZWQgYnV0ICR7bWlzc2luZ1JlZn0gY2Fubm90IGJlIHJlc29sdmVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gbG9hZE1pc3NpbmdTY2hlbWEocmVmKSB7XG4gICAgICAgICAgICBjb25zdCBfc2NoZW1hID0gYXdhaXQgX2xvYWRTY2hlbWEuY2FsbCh0aGlzLCByZWYpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlZnNbcmVmXSlcbiAgICAgICAgICAgICAgICBhd2FpdCBsb2FkTWV0YVNjaGVtYS5jYWxsKHRoaXMsIF9zY2hlbWEuJHNjaGVtYSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVmc1tyZWZdKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hKF9zY2hlbWEsIHJlZiwgbWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gX2xvYWRTY2hlbWEocmVmKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gdGhpcy5fbG9hZGluZ1tyZWZdO1xuICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCAodGhpcy5fbG9hZGluZ1tyZWZdID0gbG9hZFNjaGVtYShyZWYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9sb2FkaW5nW3JlZl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQWRkcyBzY2hlbWEgdG8gdGhlIGluc3RhbmNlXG4gICAgYWRkU2NoZW1hKHNjaGVtYSwgLy8gSWYgYXJyYXkgaXMgcGFzc2VkLCBga2V5YCB3aWxsIGJlIGlnbm9yZWRcbiAgICBrZXksIC8vIE9wdGlvbmFsIHNjaGVtYSBrZXkuIENhbiBiZSBwYXNzZWQgdG8gYHZhbGlkYXRlYCBtZXRob2QgaW5zdGVhZCBvZiBzY2hlbWEgb2JqZWN0IG9yIGlkL3JlZi4gT25lIHNjaGVtYSBwZXIgaW5zdGFuY2UgY2FuIGhhdmUgZW1wdHkgYGlkYCBhbmQgYGtleWAuXG4gICAgX21ldGEsIC8vIHRydWUgaWYgc2NoZW1hIGlzIGEgbWV0YS1zY2hlbWEuIFVzZWQgaW50ZXJuYWxseSwgYWRkTWV0YVNjaGVtYSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgIF92YWxpZGF0ZVNjaGVtYSA9IHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSAvLyBmYWxzZSB0byBza2lwIHNjaGVtYSB2YWxpZGF0aW9uLiBVc2VkIGludGVybmFsbHksIG9wdGlvbiB2YWxpZGF0ZVNjaGVtYSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNjaCBvZiBzY2hlbWEpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWEoc2NoLCB1bmRlZmluZWQsIF9tZXRhLCBfdmFsaWRhdGVTY2hlbWEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICAgICAgaWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGlkICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNjaGVtYSAke3NjaGVtYUlkfSBtdXN0IGJlIHN0cmluZ2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGtleSA9IHJlc29sdmVfMS5ub3JtYWxpemVJZChrZXkgfHwgaWQpO1xuICAgICAgICB0aGlzLl9jaGVja1VuaXF1ZShrZXkpO1xuICAgICAgICB0aGlzLnNjaGVtYXNba2V5XSA9IHRoaXMuX2FkZFNjaGVtYShzY2hlbWEsIF9tZXRhLCBrZXksIF92YWxpZGF0ZVNjaGVtYSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBBZGQgc2NoZW1hIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIG90aGVyIHNjaGVtYXNcbiAgICAvLyBvcHRpb25zIGluIE1FVEFfSUdOT1JFX09QVElPTlMgYXJlIGFsd2F5IHNldCB0byBmYWxzZVxuICAgIGFkZE1ldGFTY2hlbWEoc2NoZW1hLCBrZXksIC8vIHNjaGVtYSBrZXlcbiAgICBfdmFsaWRhdGVTY2hlbWEgPSB0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEgLy8gZmFsc2UgdG8gc2tpcCBzY2hlbWEgdmFsaWRhdGlvbiwgY2FuIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdmFsaWRhdGVTY2hlbWEgb3B0aW9uIGZvciBtZXRhLXNjaGVtYVxuICAgICkge1xuICAgICAgICB0aGlzLmFkZFNjaGVtYShzY2hlbWEsIGtleSwgdHJ1ZSwgX3ZhbGlkYXRlU2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vICBWYWxpZGF0ZSBzY2hlbWEgYWdhaW5zdCBpdHMgbWV0YS1zY2hlbWFcbiAgICB2YWxpZGF0ZVNjaGVtYShzY2hlbWEsIHRocm93T3JMb2dFcnJvcikge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgJHNjaGVtYTtcbiAgICAgICAgJHNjaGVtYSA9IHNjaGVtYS4kc2NoZW1hO1xuICAgICAgICBpZiAoJHNjaGVtYSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiAkc2NoZW1hICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIiRzY2hlbWEgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICAkc2NoZW1hID0gJHNjaGVtYSB8fCB0aGlzLm9wdHMuZGVmYXVsdE1ldGEgfHwgdGhpcy5kZWZhdWx0TWV0YSgpO1xuICAgICAgICBpZiAoISRzY2hlbWEpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJtZXRhLXNjaGVtYSBub3QgYXZhaWxhYmxlXCIpO1xuICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWQgPSB0aGlzLnZhbGlkYXRlKCRzY2hlbWEsIHNjaGVtYSk7XG4gICAgICAgIGlmICghdmFsaWQgJiYgdGhyb3dPckxvZ0Vycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gXCJzY2hlbWEgaXMgaW52YWxpZDogXCIgKyB0aGlzLmVycm9yc1RleHQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEgPT09IFwibG9nXCIpXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9XG4gICAgLy8gR2V0IGNvbXBpbGVkIHNjaGVtYSBieSBga2V5YCBvciBgcmVmYC5cbiAgICAvLyAoYGtleWAgdGhhdCB3YXMgcGFzc2VkIHRvIGBhZGRTY2hlbWFgIG9yIGZ1bGwgc2NoZW1hIHJlZmVyZW5jZSAtIGBzY2hlbWEuJGlkYCBvciByZXNvbHZlZCBpZClcbiAgICBnZXRTY2hlbWEoa2V5UmVmKSB7XG4gICAgICAgIGxldCBzY2g7XG4gICAgICAgIHdoaWxlICh0eXBlb2YgKHNjaCA9IGdldFNjaEVudi5jYWxsKHRoaXMsIGtleVJlZikpID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBrZXlSZWYgPSBzY2g7XG4gICAgICAgIGlmIChzY2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IG5ldyBjb21waWxlXzEuU2NoZW1hRW52KHsgc2NoZW1hOiB7fSwgc2NoZW1hSWQgfSk7XG4gICAgICAgICAgICBzY2ggPSBjb21waWxlXzEucmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsIGtleVJlZik7XG4gICAgICAgICAgICBpZiAoIXNjaClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnJlZnNba2V5UmVmXSA9IHNjaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHNjaC52YWxpZGF0ZSB8fCB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaCkpO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgY2FjaGVkIHNjaGVtYShzKS5cbiAgICAvLyBJZiBubyBwYXJhbWV0ZXIgaXMgcGFzc2VkIGFsbCBzY2hlbWFzIGJ1dCBtZXRhLXNjaGVtYXMgYXJlIHJlbW92ZWQuXG4gICAgLy8gSWYgUmVnRXhwIGlzIHBhc3NlZCBhbGwgc2NoZW1hcyB3aXRoIGtleS9pZCBtYXRjaGluZyBwYXR0ZXJuIGJ1dCBtZXRhLXNjaGVtYXMgYXJlIHJlbW92ZWQuXG4gICAgLy8gRXZlbiBpZiBzY2hlbWEgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBzY2hlbWFzIGl0IHN0aWxsIGNhbiBiZSByZW1vdmVkIGFzIG90aGVyIHNjaGVtYXMgaGF2ZSBsb2NhbCByZWZlcmVuY2VzLlxuICAgIHJlbW92ZVNjaGVtYShzY2hlbWFLZXlSZWYpIHtcbiAgICAgICAgaWYgKHNjaGVtYUtleVJlZiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnNjaGVtYXMsIHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMucmVmcywgc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHNjaGVtYUtleVJlZikge1xuICAgICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5zY2hlbWFzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMucmVmcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaCA9IGdldFNjaEVudi5jYWxsKHRoaXMsIHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2ggPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuZGVsZXRlKHNjaC5zY2hlbWEpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNjaGVtYXNbc2NoZW1hS2V5UmVmXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5yZWZzW3NjaGVtYUtleVJlZl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZUtleSA9IHNjaGVtYUtleVJlZjtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5kZWxldGUoY2FjaGVLZXkpO1xuICAgICAgICAgICAgICAgIGxldCBpZCA9IHNjaGVtYUtleVJlZlt0aGlzLm9wdHMuc2NoZW1hSWRdO1xuICAgICAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgICAgICBpZCA9IHJlc29sdmVfMS5ub3JtYWxpemVJZChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNjaGVtYXNbaWRdO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5yZWZzW2lkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdi5yZW1vdmVTY2hlbWE6IGludmFsaWQgcGFyYW1ldGVyXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFkZCBcInZvY2FidWxhcnlcIiAtIGEgY29sbGVjdGlvbiBvZiBrZXl3b3Jkc1xuICAgIGFkZFZvY2FidWxhcnkoZGVmaW5pdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBkZWYgb2YgZGVmaW5pdGlvbnMpXG4gICAgICAgICAgICB0aGlzLmFkZEtleXdvcmQoZGVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkZEtleXdvcmQoa3dkT3JEZWYsIGRlZiAvLyBkZXByZWNhdGVkXG4gICAgKSB7XG4gICAgICAgIGxldCBrZXl3b3JkO1xuICAgICAgICBpZiAodHlwZW9mIGt3ZE9yRGVmID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGtleXdvcmQgPSBrd2RPckRlZjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwidGhlc2UgcGFyYW1ldGVycyBhcmUgZGVwcmVjYXRlZCwgc2VlIGRvY3MgZm9yIGFkZEtleXdvcmRcIik7XG4gICAgICAgICAgICAgICAgZGVmLmtleXdvcmQgPSBrZXl3b3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBrd2RPckRlZiA9PSBcIm9iamVjdFwiICYmIGRlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWYgPSBrd2RPckRlZjtcbiAgICAgICAgICAgIGtleXdvcmQgPSBkZWYua2V5d29yZDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGtleXdvcmQpICYmICFrZXl3b3JkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZEtleXdvcmRzOiBrZXl3b3JkIG11c3QgYmUgc3RyaW5nIG9yIG5vbi1lbXB0eSBhcnJheVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYWRkS2V5d29yZHMgcGFyYW1ldGVyc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja0tleXdvcmQuY2FsbCh0aGlzLCBrZXl3b3JkLCBkZWYpO1xuICAgICAgICBpZiAoIWRlZikge1xuICAgICAgICAgICAgdXRpbF8xLmVhY2hJdGVtKGtleXdvcmQsIChrd2QpID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrd2QpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGtleXdvcmRNZXRhc2NoZW1hLmNhbGwodGhpcywgZGVmKTtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIC4uLmRlZixcbiAgICAgICAgICAgIHR5cGU6IGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKGRlZi50eXBlKSxcbiAgICAgICAgICAgIHNjaGVtYVR5cGU6IGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKGRlZi5zY2hlbWFUeXBlKSxcbiAgICAgICAgfTtcbiAgICAgICAgdXRpbF8xLmVhY2hJdGVtKGtleXdvcmQsIGRlZmluaXRpb24udHlwZS5sZW5ndGggPT09IDBcbiAgICAgICAgICAgID8gKGspID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrLCBkZWZpbml0aW9uKVxuICAgICAgICAgICAgOiAoaykgPT4gZGVmaW5pdGlvbi50eXBlLmZvckVhY2goKHQpID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrLCBkZWZpbml0aW9uLCB0KSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0S2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSB0aGlzLlJVTEVTLmFsbFtrZXl3b3JkXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBydWxlID09IFwib2JqZWN0XCIgPyBydWxlLmRlZmluaXRpb24gOiAhIXJ1bGU7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBrZXl3b3JkXG4gICAgcmVtb3ZlS2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIC8vIFRPRE8gcmV0dXJuIHR5cGUgc2hvdWxkIGJlIEFqdlxuICAgICAgICBjb25zdCB7IFJVTEVTIH0gPSB0aGlzO1xuICAgICAgICBkZWxldGUgUlVMRVMua2V5d29yZHNba2V5d29yZF07XG4gICAgICAgIGRlbGV0ZSBSVUxFUy5hbGxba2V5d29yZF07XG4gICAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgUlVMRVMucnVsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBncm91cC5ydWxlcy5maW5kSW5kZXgoKHJ1bGUpID0+IHJ1bGUua2V5d29yZCA9PT0ga2V5d29yZCk7XG4gICAgICAgICAgICBpZiAoaSA+PSAwKVxuICAgICAgICAgICAgICAgIGdyb3VwLnJ1bGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gQWRkIGZvcm1hdFxuICAgIGFkZEZvcm1hdChuYW1lLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGZvcm1hdCA9IG5ldyBSZWdFeHAoZm9ybWF0KTtcbiAgICAgICAgdGhpcy5mb3JtYXRzW25hbWVdID0gZm9ybWF0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZXJyb3JzVGV4dChlcnJvcnMgPSB0aGlzLmVycm9ycywgLy8gb3B0aW9uYWwgYXJyYXkgb2YgdmFsaWRhdGlvbiBlcnJvcnNcbiAgICB7IHNlcGFyYXRvciA9IFwiLCBcIiwgZGF0YVZhciA9IFwiZGF0YVwiIH0gPSB7fSAvLyBvcHRpb25hbCBvcHRpb25zIHdpdGggcHJvcGVydGllcyBgc2VwYXJhdG9yYCBhbmQgYGRhdGFWYXJgXG4gICAgKSB7XG4gICAgICAgIGlmICghZXJyb3JzIHx8IGVycm9ycy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gXCJObyBlcnJvcnNcIjtcbiAgICAgICAgcmV0dXJuIGVycm9yc1xuICAgICAgICAgICAgLm1hcCgoZSkgPT4gYCR7ZGF0YVZhcn0ke2UuaW5zdGFuY2VQYXRofSAke2UubWVzc2FnZX1gKVxuICAgICAgICAgICAgLnJlZHVjZSgodGV4dCwgbXNnKSA9PiB0ZXh0ICsgc2VwYXJhdG9yICsgbXNnKTtcbiAgICB9XG4gICAgJGRhdGFNZXRhU2NoZW1hKG1ldGFTY2hlbWEsIGtleXdvcmRzSnNvblBvaW50ZXJzKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVzID0gdGhpcy5SVUxFUy5hbGw7XG4gICAgICAgIG1ldGFTY2hlbWEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1ldGFTY2hlbWEpKTtcbiAgICAgICAgZm9yIChjb25zdCBqc29uUG9pbnRlciBvZiBrZXl3b3Jkc0pzb25Qb2ludGVycykge1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBqc29uUG9pbnRlci5zcGxpdChcIi9cIikuc2xpY2UoMSk7IC8vIGZpcnN0IHNlZ21lbnQgaXMgYW4gZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICBsZXQga2V5d29yZHMgPSBtZXRhU2NoZW1hO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzZWcgb2Ygc2VnbWVudHMpXG4gICAgICAgICAgICAgICAga2V5d29yZHMgPSBrZXl3b3Jkc1tzZWddO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcnVsZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBydWxlID0gcnVsZXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJ1bGUgIT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgeyAkZGF0YSB9ID0gcnVsZS5kZWZpbml0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IGtleXdvcmRzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKCRkYXRhICYmIHNjaGVtYSlcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZHNba2V5XSA9IHNjaGVtYU9yRGF0YShzY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRhU2NoZW1hO1xuICAgIH1cbiAgICBfcmVtb3ZlQWxsU2NoZW1hcyhzY2hlbWFzLCByZWdleCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleVJlZiBpbiBzY2hlbWFzKSB7XG4gICAgICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFzW2tleVJlZl07XG4gICAgICAgICAgICBpZiAoIXJlZ2V4IHx8IHJlZ2V4LnRlc3Qoa2V5UmVmKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYXNba2V5UmVmXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoICYmICFzY2gubWV0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5kZWxldGUoc2NoLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFzW2tleVJlZl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9hZGRTY2hlbWEoc2NoZW1hLCBtZXRhLCBiYXNlSWQsIHZhbGlkYXRlU2NoZW1hID0gdGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hLCBhZGRTY2hlbWEgPSB0aGlzLm9wdHMuYWRkVXNlZFNjaGVtYSkge1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5qdGQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2NoZW1hIG11c3QgYmUgb2JqZWN0XCIpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNjaGVtYSAhPSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgbXVzdCBiZSBvYmplY3Qgb3IgYm9vbGVhblwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2NoID0gdGhpcy5fY2FjaGUuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGlmIChzY2ggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBzY2g7XG4gICAgICAgIGNvbnN0IGxvY2FsUmVmcyA9IHJlc29sdmVfMS5nZXRTY2hlbWFSZWZzLmNhbGwodGhpcywgc2NoZW1hKTtcbiAgICAgICAgYmFzZUlkID0gcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKGlkIHx8IGJhc2VJZCk7XG4gICAgICAgIHNjaCA9IG5ldyBjb21waWxlXzEuU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgbWV0YSwgYmFzZUlkLCBsb2NhbFJlZnMgfSk7XG4gICAgICAgIHRoaXMuX2NhY2hlLnNldChzY2guc2NoZW1hLCBzY2gpO1xuICAgICAgICBpZiAoYWRkU2NoZW1hICYmICFiYXNlSWQuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gYXRtIGl0IGlzIGFsbG93ZWQgdG8gb3ZlcndyaXRlIHNjaGVtYXMgd2l0aG91dCBpZCAoaW5zdGVhZCBvZiBub3QgYWRkaW5nIHRoZW0pXG4gICAgICAgICAgICBpZiAoYmFzZUlkKVxuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrVW5pcXVlKGJhc2VJZCk7XG4gICAgICAgICAgICB0aGlzLnJlZnNbYmFzZUlkXSA9IHNjaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsaWRhdGVTY2hlbWEpXG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlU2NoZW1hKHNjaGVtYSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBzY2g7XG4gICAgfVxuICAgIF9jaGVja1VuaXF1ZShpZCkge1xuICAgICAgICBpZiAodGhpcy5zY2hlbWFzW2lkXSB8fCB0aGlzLnJlZnNbaWRdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNjaGVtYSB3aXRoIGtleSBvciBpZCBcIiR7aWR9XCIgYWxyZWFkeSBleGlzdHNgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY29tcGlsZVNjaGVtYUVudihzY2gpIHtcbiAgICAgICAgaWYgKHNjaC5tZXRhKVxuICAgICAgICAgICAgdGhpcy5fY29tcGlsZU1ldGFTY2hlbWEoc2NoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29tcGlsZV8xLmNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFzY2gudmFsaWRhdGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgIHJldHVybiBzY2gudmFsaWRhdGU7XG4gICAgfVxuICAgIF9jb21waWxlTWV0YVNjaGVtYShzY2gpIHtcbiAgICAgICAgY29uc3QgY3VycmVudE9wdHMgPSB0aGlzLm9wdHM7XG4gICAgICAgIHRoaXMub3B0cyA9IHRoaXMuX21ldGFPcHRzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29tcGlsZV8xLmNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5vcHRzID0gY3VycmVudE9wdHM7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBBanY7XG5BanYuVmFsaWRhdGlvbkVycm9yID0gdmFsaWRhdGlvbl9lcnJvcl8xLmRlZmF1bHQ7XG5BanYuTWlzc2luZ1JlZkVycm9yID0gcmVmX2Vycm9yXzEuZGVmYXVsdDtcbmZ1bmN0aW9uIGNoZWNrT3B0aW9ucyhjaGVja09wdHMsIG9wdGlvbnMsIG1zZywgbG9nID0gXCJlcnJvclwiKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY2hlY2tPcHRzKSB7XG4gICAgICAgIGNvbnN0IG9wdCA9IGtleTtcbiAgICAgICAgaWYgKG9wdCBpbiBvcHRpb25zKVxuICAgICAgICAgICAgdGhpcy5sb2dnZXJbbG9nXShgJHttc2d9OiBvcHRpb24gJHtrZXl9LiAke2NoZWNrT3B0c1tvcHRdfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNjaEVudihrZXlSZWYpIHtcbiAgICBrZXlSZWYgPSByZXNvbHZlXzEubm9ybWFsaXplSWQoa2V5UmVmKTsgLy8gVE9ETyB0ZXN0cyBmYWlsIHdpdGhvdXQgdGhpcyBsaW5lXG4gICAgcmV0dXJuIHRoaXMuc2NoZW1hc1trZXlSZWZdIHx8IHRoaXMucmVmc1trZXlSZWZdO1xufVxuZnVuY3Rpb24gYWRkSW5pdGlhbFNjaGVtYXMoKSB7XG4gICAgY29uc3Qgb3B0c1NjaGVtYXMgPSB0aGlzLm9wdHMuc2NoZW1hcztcbiAgICBpZiAoIW9wdHNTY2hlbWFzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0c1NjaGVtYXMpKVxuICAgICAgICB0aGlzLmFkZFNjaGVtYShvcHRzU2NoZW1hcyk7XG4gICAgZWxzZVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRzU2NoZW1hcylcbiAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hKG9wdHNTY2hlbWFzW2tleV0sIGtleSk7XG59XG5mdW5jdGlvbiBhZGRJbml0aWFsRm9ybWF0cygpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5vcHRzLmZvcm1hdHMpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gdGhpcy5vcHRzLmZvcm1hdHNbbmFtZV07XG4gICAgICAgIGlmIChmb3JtYXQpXG4gICAgICAgICAgICB0aGlzLmFkZEZvcm1hdChuYW1lLCBmb3JtYXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZEluaXRpYWxLZXl3b3JkcyhkZWZzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmcykpIHtcbiAgICAgICAgdGhpcy5hZGRWb2NhYnVsYXJ5KGRlZnMpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyLndhcm4oXCJrZXl3b3JkcyBvcHRpb24gYXMgbWFwIGlzIGRlcHJlY2F0ZWQsIHBhc3MgYXJyYXlcIik7XG4gICAgZm9yIChjb25zdCBrZXl3b3JkIGluIGRlZnMpIHtcbiAgICAgICAgY29uc3QgZGVmID0gZGVmc1trZXl3b3JkXTtcbiAgICAgICAgaWYgKCFkZWYua2V5d29yZClcbiAgICAgICAgICAgIGRlZi5rZXl3b3JkID0ga2V5d29yZDtcbiAgICAgICAgdGhpcy5hZGRLZXl3b3JkKGRlZik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0TWV0YVNjaGVtYU9wdGlvbnMoKSB7XG4gICAgY29uc3QgbWV0YU9wdHMgPSB7IC4uLnRoaXMub3B0cyB9O1xuICAgIGZvciAoY29uc3Qgb3B0IG9mIE1FVEFfSUdOT1JFX09QVElPTlMpXG4gICAgICAgIGRlbGV0ZSBtZXRhT3B0c1tvcHRdO1xuICAgIHJldHVybiBtZXRhT3B0cztcbn1cbmNvbnN0IG5vTG9ncyA9IHsgbG9nKCkgeyB9LCB3YXJuKCkgeyB9LCBlcnJvcigpIHsgfSB9O1xuZnVuY3Rpb24gZ2V0TG9nZ2VyKGxvZ2dlcikge1xuICAgIGlmIChsb2dnZXIgPT09IGZhbHNlKVxuICAgICAgICByZXR1cm4gbm9Mb2dzO1xuICAgIGlmIChsb2dnZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIGNvbnNvbGU7XG4gICAgaWYgKGxvZ2dlci5sb2cgJiYgbG9nZ2VyLndhcm4gJiYgbG9nZ2VyLmVycm9yKVxuICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgIHRocm93IG5ldyBFcnJvcihcImxvZ2dlciBtdXN0IGltcGxlbWVudCBsb2csIHdhcm4gYW5kIGVycm9yIG1ldGhvZHNcIik7XG59XG5jb25zdCBLRVlXT1JEX05BTUUgPSAvXlthLXpfJF1bYS16MC05XyQ6LV0qJC9pO1xuZnVuY3Rpb24gY2hlY2tLZXl3b3JkKGtleXdvcmQsIGRlZikge1xuICAgIGNvbnN0IHsgUlVMRVMgfSA9IHRoaXM7XG4gICAgdXRpbF8xLmVhY2hJdGVtKGtleXdvcmQsIChrd2QpID0+IHtcbiAgICAgICAgaWYgKFJVTEVTLmtleXdvcmRzW2t3ZF0pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleXdvcmQgJHtrd2R9IGlzIGFscmVhZHkgZGVmaW5lZGApO1xuICAgICAgICBpZiAoIUtFWVdPUkRfTkFNRS50ZXN0KGt3ZCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleXdvcmQgJHtrd2R9IGhhcyBpbnZhbGlkIG5hbWVgKTtcbiAgICB9KTtcbiAgICBpZiAoIWRlZilcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChkZWYuJGRhdGEgJiYgIShcImNvZGVcIiBpbiBkZWYgfHwgXCJ2YWxpZGF0ZVwiIGluIGRlZikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCckZGF0YSBrZXl3b3JkIG11c3QgaGF2ZSBcImNvZGVcIiBvciBcInZhbGlkYXRlXCIgZnVuY3Rpb24nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRSdWxlKGtleXdvcmQsIGRlZmluaXRpb24sIGRhdGFUeXBlKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHBvc3QgPSBkZWZpbml0aW9uID09PSBudWxsIHx8IGRlZmluaXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlZmluaXRpb24ucG9zdDtcbiAgICBpZiAoZGF0YVR5cGUgJiYgcG9zdClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXl3b3JkIHdpdGggXCJwb3N0XCIgZmxhZyBjYW5ub3QgaGF2ZSBcInR5cGVcIicpO1xuICAgIGNvbnN0IHsgUlVMRVMgfSA9IHRoaXM7XG4gICAgbGV0IHJ1bGVHcm91cCA9IHBvc3QgPyBSVUxFUy5wb3N0IDogUlVMRVMucnVsZXMuZmluZCgoeyB0eXBlOiB0IH0pID0+IHQgPT09IGRhdGFUeXBlKTtcbiAgICBpZiAoIXJ1bGVHcm91cCkge1xuICAgICAgICBydWxlR3JvdXAgPSB7IHR5cGU6IGRhdGFUeXBlLCBydWxlczogW10gfTtcbiAgICAgICAgUlVMRVMucnVsZXMucHVzaChydWxlR3JvdXApO1xuICAgIH1cbiAgICBSVUxFUy5rZXl3b3Jkc1trZXl3b3JkXSA9IHRydWU7XG4gICAgaWYgKCFkZWZpbml0aW9uKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgcnVsZSA9IHtcbiAgICAgICAga2V5d29yZCxcbiAgICAgICAgZGVmaW5pdGlvbjoge1xuICAgICAgICAgICAgLi4uZGVmaW5pdGlvbixcbiAgICAgICAgICAgIHR5cGU6IGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKGRlZmluaXRpb24udHlwZSksXG4gICAgICAgICAgICBzY2hlbWFUeXBlOiBkYXRhVHlwZV8xLmdldEpTT05UeXBlcyhkZWZpbml0aW9uLnNjaGVtYVR5cGUpLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgaWYgKGRlZmluaXRpb24uYmVmb3JlKVxuICAgICAgICBhZGRCZWZvcmVSdWxlLmNhbGwodGhpcywgcnVsZUdyb3VwLCBydWxlLCBkZWZpbml0aW9uLmJlZm9yZSk7XG4gICAgZWxzZVxuICAgICAgICBydWxlR3JvdXAucnVsZXMucHVzaChydWxlKTtcbiAgICBSVUxFUy5hbGxba2V5d29yZF0gPSBydWxlO1xuICAgIChfYSA9IGRlZmluaXRpb24uaW1wbGVtZW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGt3ZCkgPT4gdGhpcy5hZGRLZXl3b3JkKGt3ZCkpO1xufVxuZnVuY3Rpb24gYWRkQmVmb3JlUnVsZShydWxlR3JvdXAsIHJ1bGUsIGJlZm9yZSkge1xuICAgIGNvbnN0IGkgPSBydWxlR3JvdXAucnVsZXMuZmluZEluZGV4KChfcnVsZSkgPT4gX3J1bGUua2V5d29yZCA9PT0gYmVmb3JlKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgIHJ1bGVHcm91cC5ydWxlcy5zcGxpY2UoaSwgMCwgcnVsZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBydWxlR3JvdXAucnVsZXMucHVzaChydWxlKTtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgcnVsZSAke2JlZm9yZX0gaXMgbm90IGRlZmluZWRgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBrZXl3b3JkTWV0YXNjaGVtYShkZWYpIHtcbiAgICBsZXQgeyBtZXRhU2NoZW1hIH0gPSBkZWY7XG4gICAgaWYgKG1ldGFTY2hlbWEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChkZWYuJGRhdGEgJiYgdGhpcy5vcHRzLiRkYXRhKVxuICAgICAgICBtZXRhU2NoZW1hID0gc2NoZW1hT3JEYXRhKG1ldGFTY2hlbWEpO1xuICAgIGRlZi52YWxpZGF0ZVNjaGVtYSA9IHRoaXMuY29tcGlsZShtZXRhU2NoZW1hLCB0cnVlKTtcbn1cbmNvbnN0ICRkYXRhUmVmID0ge1xuICAgICRyZWY6IFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Fqdi12YWxpZGF0b3IvYWp2L21hc3Rlci9saWIvcmVmcy9kYXRhLmpzb24jXCIsXG59O1xuZnVuY3Rpb24gc2NoZW1hT3JEYXRhKHNjaGVtYSkge1xuICAgIHJldHVybiB7IGFueU9mOiBbc2NoZW1hLCAkZGF0YVJlZl0gfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpZFwiLFxuICAgIGNvZGUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTk9UIFNVUFBPUlRFRDoga2V5d29yZCBcImlkXCIsIHVzZSBcIiRpZFwiIGZvciBzY2hlbWEgSUQnKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYWxsUmVmID0gZXhwb3J0cy5nZXRWYWxpZGF0ZSA9IHZvaWQgMDtcbmNvbnN0IHJlZl9lcnJvcl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvcmVmX2Vycm9yXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL25hbWVzXCIpO1xuY29uc3QgY29tcGlsZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiJHJlZlwiLFxuICAgIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYTogJHJlZiwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBiYXNlSWQsIHNjaGVtYUVudjogZW52LCB2YWxpZGF0ZU5hbWUsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgICAgICBjb25zdCB7IHJvb3QgfSA9IGVudjtcbiAgICAgICAgaWYgKCgkcmVmID09PSBcIiNcIiB8fCAkcmVmID09PSBcIiMvXCIpICYmIGJhc2VJZCA9PT0gcm9vdC5iYXNlSWQpXG4gICAgICAgICAgICByZXR1cm4gY2FsbFJvb3RSZWYoKTtcbiAgICAgICAgY29uc3Qgc2NoT3JFbnYgPSBjb21waWxlXzEucmVzb2x2ZVJlZi5jYWxsKHNlbGYsIHJvb3QsIGJhc2VJZCwgJHJlZik7XG4gICAgICAgIGlmIChzY2hPckVudiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IHJlZl9lcnJvcl8xLmRlZmF1bHQoYmFzZUlkLCAkcmVmKTtcbiAgICAgICAgaWYgKHNjaE9yRW52IGluc3RhbmNlb2YgY29tcGlsZV8xLlNjaGVtYUVudilcbiAgICAgICAgICAgIHJldHVybiBjYWxsVmFsaWRhdGUoc2NoT3JFbnYpO1xuICAgICAgICByZXR1cm4gaW5saW5lUmVmU2NoZW1hKHNjaE9yRW52KTtcbiAgICAgICAgZnVuY3Rpb24gY2FsbFJvb3RSZWYoKSB7XG4gICAgICAgICAgICBpZiAoZW52ID09PSByb290KVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsUmVmKGN4dCwgdmFsaWRhdGVOYW1lLCBlbnYsIGVudi4kYXN5bmMpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdE5hbWUgPSBnZW4uc2NvcGVWYWx1ZShcInJvb3RcIiwgeyByZWY6IHJvb3QgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbFJlZihjeHQsIGNvZGVnZW5fMS5fIGAke3Jvb3ROYW1lfS52YWxpZGF0ZWAsIHJvb3QsIHJvb3QuJGFzeW5jKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYWxsVmFsaWRhdGUoc2NoKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gZ2V0VmFsaWRhdGUoY3h0LCBzY2gpO1xuICAgICAgICAgICAgY2FsbFJlZihjeHQsIHYsIHNjaCwgc2NoLiRhc3luYyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW5saW5lUmVmU2NoZW1hKHNjaCkge1xuICAgICAgICAgICAgY29uc3Qgc2NoTmFtZSA9IGdlbi5zY29wZVZhbHVlKFwic2NoZW1hXCIsIG9wdHMuY29kZS5zb3VyY2UgPT09IHRydWUgPyB7IHJlZjogc2NoLCBjb2RlOiBjb2RlZ2VuXzEuc3RyaW5naWZ5KHNjaCkgfSA6IHsgcmVmOiBzY2ggfSk7XG4gICAgICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHNjaCxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZXM6IFtdLFxuICAgICAgICAgICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5uaWwsXG4gICAgICAgICAgICAgICAgdG9wU2NoZW1hUmVmOiBzY2hOYW1lLFxuICAgICAgICAgICAgICAgIGVyclNjaGVtYVBhdGg6ICRyZWYsXG4gICAgICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0KTtcbiAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmZ1bmN0aW9uIGdldFZhbGlkYXRlKGN4dCwgc2NoKSB7XG4gICAgY29uc3QgeyBnZW4gfSA9IGN4dDtcbiAgICByZXR1cm4gc2NoLnZhbGlkYXRlXG4gICAgICAgID8gZ2VuLnNjb3BlVmFsdWUoXCJ2YWxpZGF0ZVwiLCB7IHJlZjogc2NoLnZhbGlkYXRlIH0pXG4gICAgICAgIDogY29kZWdlbl8xLl8gYCR7Z2VuLnNjb3BlVmFsdWUoXCJ3cmFwcGVyXCIsIHsgcmVmOiBzY2ggfSl9LnZhbGlkYXRlYDtcbn1cbmV4cG9ydHMuZ2V0VmFsaWRhdGUgPSBnZXRWYWxpZGF0ZTtcbmZ1bmN0aW9uIGNhbGxSZWYoY3h0LCB2LCBzY2gsICRhc3luYykge1xuICAgIGNvbnN0IHsgZ2VuLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHsgYWxsRXJyb3JzLCBzY2hlbWFFbnY6IGVudiwgb3B0cyB9ID0gaXQ7XG4gICAgY29uc3QgcGFzc0N4dCA9IG9wdHMucGFzc0NvbnRleHQgPyBuYW1lc18xLmRlZmF1bHQudGhpcyA6IGNvZGVnZW5fMS5uaWw7XG4gICAgaWYgKCRhc3luYylcbiAgICAgICAgY2FsbEFzeW5jUmVmKCk7XG4gICAgZWxzZVxuICAgICAgICBjYWxsU3luY1JlZigpO1xuICAgIGZ1bmN0aW9uIGNhbGxBc3luY1JlZigpIHtcbiAgICAgICAgaWYgKCFlbnYuJGFzeW5jKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMgc2NoZW1hIHJlZmVyZW5jZWQgYnkgc3luYyBzY2hlbWFcIik7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgICAgICBnZW4udHJ5KCgpID0+IHtcbiAgICAgICAgICAgIGdlbi5jb2RlKGNvZGVnZW5fMS5fIGBhd2FpdCAke2NvZGVfMS5jYWxsVmFsaWRhdGVDb2RlKGN4dCwgdiwgcGFzc0N4dCl9YCk7XG4gICAgICAgICAgICBhZGRFdmFsdWF0ZWRGcm9tKHYpOyAvLyBUT0RPIHdpbGwgbm90IHdvcmsgd2l0aCBhc3luYywgaXQgaGFzIHRvIGJlIHJldHVybmVkIHdpdGggdGhlIHJlc3VsdFxuICAgICAgICAgICAgaWYgKCFhbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgIH0sIChlKSA9PiB7XG4gICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCEoJHtlfSBpbnN0YW5jZW9mICR7aXQuVmFsaWRhdGlvbkVycm9yfSlgLCAoKSA9PiBnZW4udGhyb3coZSkpO1xuICAgICAgICAgICAgYWRkRXJyb3JzRnJvbShlKTtcbiAgICAgICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbGxTeW5jUmVmKCkge1xuICAgICAgICBjeHQucmVzdWx0KGNvZGVfMS5jYWxsVmFsaWRhdGVDb2RlKGN4dCwgdiwgcGFzc0N4dCksICgpID0+IGFkZEV2YWx1YXRlZEZyb20odiksICgpID0+IGFkZEVycm9yc0Zyb20odikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRFcnJvcnNGcm9tKHNvdXJjZSkge1xuICAgICAgICBjb25zdCBlcnJzID0gY29kZWdlbl8xLl8gYCR7c291cmNlfS5lcnJvcnNgO1xuICAgICAgICBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30gPT09IG51bGwgPyAke2VycnN9IDogJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30uY29uY2F0KCR7ZXJyc30pYCk7IC8vIFRPRE8gdGFnZ2VkXG4gICAgICAgIGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LmVycm9ycywgY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9Lmxlbmd0aGApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRFdmFsdWF0ZWRGcm9tKHNvdXJjZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghaXQub3B0cy51bmV2YWx1YXRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgc2NoRXZhbHVhdGVkID0gKF9hID0gc2NoID09PSBudWxsIHx8IHNjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoLnZhbGlkYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXZhbHVhdGVkO1xuICAgICAgICAvLyBUT0RPIHJlZmFjdG9yXG4gICAgICAgIGlmIChpdC5wcm9wcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHNjaEV2YWx1YXRlZCAmJiAhc2NoRXZhbHVhdGVkLmR5bmFtaWNQcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChzY2hFdmFsdWF0ZWQucHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpdC5wcm9wcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5wcm9wcyhnZW4sIHNjaEV2YWx1YXRlZC5wcm9wcywgaXQucHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzID0gZ2VuLnZhcihcInByb3BzXCIsIGNvZGVnZW5fMS5fIGAke3NvdXJjZX0uZXZhbHVhdGVkLnByb3BzYCk7XG4gICAgICAgICAgICAgICAgaXQucHJvcHMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCBwcm9wcywgaXQucHJvcHMsIGNvZGVnZW5fMS5OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQuaXRlbXMgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChzY2hFdmFsdWF0ZWQgJiYgIXNjaEV2YWx1YXRlZC5keW5hbWljSXRlbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NoRXZhbHVhdGVkLml0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXQuaXRlbXMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBzY2hFdmFsdWF0ZWQuaXRlbXMsIGl0Lml0ZW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtcyA9IGdlbi52YXIoXCJpdGVtc1wiLCBjb2RlZ2VuXzEuXyBgJHtzb3VyY2V9LmV2YWx1YXRlZC5pdGVtc2ApO1xuICAgICAgICAgICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgaXRlbXMsIGl0Lml0ZW1zLCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmNhbGxSZWYgPSBjYWxsUmVmO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgaWRfMSA9IHJlcXVpcmUoXCIuL2lkXCIpO1xuY29uc3QgcmVmXzEgPSByZXF1aXJlKFwiLi9yZWZcIik7XG5jb25zdCBjb3JlID0gW1xuICAgIFwiJHNjaGVtYVwiLFxuICAgIFwiJGlkXCIsXG4gICAgXCIkZGVmc1wiLFxuICAgIFwiJHZvY2FidWxhcnlcIixcbiAgICB7IGtleXdvcmQ6IFwiJGNvbW1lbnRcIiB9LFxuICAgIFwiZGVmaW5pdGlvbnNcIixcbiAgICBpZF8xLmRlZmF1bHQsXG4gICAgcmVmXzEuZGVmYXVsdCxcbl07XG5leHBvcnRzLmRlZmF1bHQgPSBjb3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3Qgb3BzID0gY29kZWdlbl8xLm9wZXJhdG9ycztcbmNvbnN0IEtXRHMgPSB7XG4gICAgbWF4aW11bTogeyBva1N0cjogXCI8PVwiLCBvazogb3BzLkxURSwgZmFpbDogb3BzLkdUIH0sXG4gICAgbWluaW11bTogeyBva1N0cjogXCI+PVwiLCBvazogb3BzLkdURSwgZmFpbDogb3BzLkxUIH0sXG4gICAgZXhjbHVzaXZlTWF4aW11bTogeyBva1N0cjogXCI8XCIsIG9rOiBvcHMuTFQsIGZhaWw6IG9wcy5HVEUgfSxcbiAgICBleGNsdXNpdmVNaW5pbXVtOiB7IG9rU3RyOiBcIj5cIiwgb2s6IG9wcy5HVCwgZmFpbDogb3BzLkxURSB9LFxufTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLnN0ciBgbXVzdCBiZSAke0tXRHNba2V5d29yZF0ub2tTdHJ9ICR7c2NoZW1hQ29kZX1gLFxuICAgIHBhcmFtczogKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuXyBge2NvbXBhcmlzb246ICR7S1dEc1trZXl3b3JkXS5va1N0cn0sIGxpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IE9iamVjdC5rZXlzKEtXRHMpLFxuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGtleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGUgfSA9IGN4dDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YShjb2RlZ2VuXzEuXyBgJHtkYXRhfSAke0tXRHNba2V5d29yZF0uZmFpbH0gJHtzY2hlbWFDb2RlfSB8fCBpc05hTigke2RhdGF9KWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXROdW1iZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBtdXN0IGJlIG11bHRpcGxlIG9mICR7c2NoZW1hQ29kZX1gLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuXyBge211bHRpcGxlT2Y6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICAvLyBjb25zdCBiZHQgPSBiYWQkRGF0YVR5cGUoc2NoZW1hQ29kZSwgPHN0cmluZz5kZWYuc2NoZW1hVHlwZSwgJGRhdGEpXG4gICAgICAgIGNvbnN0IHByZWMgPSBpdC5vcHRzLm11bHRpcGxlT2ZQcmVjaXNpb247XG4gICAgICAgIGNvbnN0IHJlcyA9IGdlbi5sZXQoXCJyZXNcIik7XG4gICAgICAgIGNvbnN0IGludmFsaWQgPSBwcmVjXG4gICAgICAgICAgICA/IGNvZGVnZW5fMS5fIGBNYXRoLmFicyhNYXRoLnJvdW5kKCR7cmVzfSkgLSAke3Jlc30pID4gMWUtJHtwcmVjfWBcbiAgICAgICAgICAgIDogY29kZWdlbl8xLl8gYCR7cmVzfSAhPT0gcGFyc2VJbnQoJHtyZXN9KWA7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoY29kZWdlbl8xLl8gYCgke3NjaGVtYUNvZGV9ID09PSAwIHx8ICgke3Jlc30gPSAke2RhdGF9LyR7c2NoZW1hQ29kZX0sICR7aW52YWxpZH0pKWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVsdGlwbGVPZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYmVzdGllanMvcHVueWNvZGUuanMgLSBwdW55Y29kZS51Y3MyLmRlY29kZVxuZnVuY3Rpb24gdWNzMmxlbmd0aChzdHIpIHtcbiAgICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGxldCB2YWx1ZTtcbiAgICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgICAgIGxlbmd0aCsrO1xuICAgICAgICB2YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KHBvcysrKTtcbiAgICAgICAgaWYgKHZhbHVlID49IDB4ZDgwMCAmJiB2YWx1ZSA8PSAweGRiZmYgJiYgcG9zIDwgbGVuKSB7XG4gICAgICAgICAgICAvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHZhbHVlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgICAgIGlmICgodmFsdWUgJiAweGZjMDApID09PSAweGRjMDApXG4gICAgICAgICAgICAgICAgcG9zKys7IC8vIGxvdyBzdXJyb2dhdGVcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gdWNzMmxlbmd0aDtcbnVjczJsZW5ndGguY29kZSA9ICdyZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS91Y3MybGVuZ3RoXCIpLmRlZmF1bHQnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dWNzMmxlbmd0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgdWNzMmxlbmd0aF8xID0gcmVxdWlyZShcIi4uLy4uL3J1bnRpbWUvdWNzMmxlbmd0aFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2UoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pIHtcbiAgICAgICAgY29uc3QgY29tcCA9IGtleXdvcmQgPT09IFwibWF4TGVuZ3RoXCIgPyBcIm1vcmVcIiA6IFwiZmV3ZXJcIjtcbiAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5zdHIgYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gY2hhcmFjdGVyc2A7XG4gICAgfSxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLl8gYHtsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBbXCJtYXhMZW5ndGhcIiwgXCJtaW5MZW5ndGhcIl0sXG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3Qgb3AgPSBrZXl3b3JkID09PSBcIm1heExlbmd0aFwiID8gY29kZWdlbl8xLm9wZXJhdG9ycy5HVCA6IGNvZGVnZW5fMS5vcGVyYXRvcnMuTFQ7XG4gICAgICAgIGNvbnN0IGxlbiA9IGl0Lm9wdHMudW5pY29kZSA9PT0gZmFsc2UgPyBjb2RlZ2VuXzEuXyBgJHtkYXRhfS5sZW5ndGhgIDogY29kZWdlbl8xLl8gYCR7dXRpbF8xLnVzZUZ1bmMoY3h0LmdlbiwgdWNzMmxlbmd0aF8xLmRlZmF1bHQpfSgke2RhdGF9KWA7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoY29kZWdlbl8xLl8gYCR7bGVufSAke29wfSAke3NjaGVtYUNvZGV9YCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW1pdExlbmd0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLnN0ciBgbXVzdCBtYXRjaCBwYXR0ZXJuIFwiJHtzY2hlbWFDb2RlfVwiYCxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLl8gYHtwYXR0ZXJuOiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicGF0dGVyblwiLFxuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGRhdGEsICRkYXRhLCBzY2hlbWEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIC8vIFRPRE8gcmVnZXhwIHNob3VsZCBiZSB3cmFwcGVkIGluIHRyeS9jYXRjaHNcbiAgICAgICAgY29uc3QgdSA9IGl0Lm9wdHMudW5pY29kZVJlZ0V4cCA/IFwidVwiIDogXCJcIjtcbiAgICAgICAgY29uc3QgcmVnRXhwID0gJGRhdGEgPyBjb2RlZ2VuXzEuXyBgKG5ldyBSZWdFeHAoJHtzY2hlbWFDb2RlfSwgJHt1fSkpYCA6IGNvZGVfMS51c2VQYXR0ZXJuKGN4dCwgc2NoZW1hKTtcbiAgICAgICAgY3h0LmZhaWwkZGF0YShjb2RlZ2VuXzEuXyBgISR7cmVnRXhwfS50ZXN0KCR7ZGF0YX0pYCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXR0ZXJuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2UoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pIHtcbiAgICAgICAgY29uc3QgY29tcCA9IGtleXdvcmQgPT09IFwibWF4UHJvcGVydGllc1wiID8gXCJtb3JlXCIgOiBcImZld2VyXCI7XG4gICAgICAgIHJldHVybiBjb2RlZ2VuXzEuc3RyIGBtdXN0IE5PVCBoYXZlICR7Y29tcH0gdGhhbiAke3NjaGVtYUNvZGV9IGl0ZW1zYDtcbiAgICB9LFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuXyBge2xpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFtcIm1heFByb3BlcnRpZXNcIiwgXCJtaW5Qcm9wZXJ0aWVzXCJdLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGtleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGUgfSA9IGN4dDtcbiAgICAgICAgY29uc3Qgb3AgPSBrZXl3b3JkID09PSBcIm1heFByb3BlcnRpZXNcIiA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuR1QgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLkxUO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKGNvZGVnZW5fMS5fIGBPYmplY3Qua2V5cygke2RhdGF9KS5sZW5ndGggJHtvcH0gJHtzY2hlbWFDb2RlfWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXRQcm9wZXJ0aWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBtaXNzaW5nUHJvcGVydHkgfSB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBtdXN0IGhhdmUgcmVxdWlyZWQgcHJvcGVydHkgJyR7bWlzc2luZ1Byb3BlcnR5fSdgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eSB9IH0pID0+IGNvZGVnZW5fMS5fIGB7bWlzc2luZ1Byb3BlcnR5OiAke21pc3NpbmdQcm9wZXJ0eX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJyZXF1aXJlZFwiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHNjaGVtYUNvZGUsIGRhdGEsICRkYXRhLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMgfSA9IGl0O1xuICAgICAgICBpZiAoISRkYXRhICYmIHNjaGVtYS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHVzZUxvb3AgPSBzY2hlbWEubGVuZ3RoID49IG9wdHMubG9vcFJlcXVpcmVkO1xuICAgICAgICBpZiAoaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgYWxsRXJyb3JzTW9kZSgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBleGl0T25FcnJvck1vZGUoKTtcbiAgICAgICAgaWYgKG9wdHMuc3RyaWN0UmVxdWlyZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gY3h0LnBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgY29uc3QgeyBkZWZpbmVkUHJvcGVydGllcyB9ID0gY3h0Lml0O1xuICAgICAgICAgICAgZm9yIChjb25zdCByZXF1aXJlZEtleSBvZiBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHByb3BzID09PSBudWxsIHx8IHByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wc1tyZXF1aXJlZEtleV0pID09PSB1bmRlZmluZWQgJiYgIWRlZmluZWRQcm9wZXJ0aWVzLmhhcyhyZXF1aXJlZEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hUGF0aCA9IGl0LnNjaGVtYUVudi5iYXNlSWQgKyBpdC5lcnJTY2hlbWFQYXRoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBgcmVxdWlyZWQgcHJvcGVydHkgXCIke3JlcXVpcmVkS2V5fVwiIGlzIG5vdCBkZWZpbmVkIGF0IFwiJHtzY2hlbWFQYXRofVwiIChzdHJpY3RSZXF1aXJlZClgO1xuICAgICAgICAgICAgICAgICAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCBtc2csIGl0Lm9wdHMuc3RyaWN0UmVxdWlyZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhbGxFcnJvcnNNb2RlKCkge1xuICAgICAgICAgICAgaWYgKHVzZUxvb3AgfHwgJGRhdGEpIHtcbiAgICAgICAgICAgICAgICBjeHQuYmxvY2skZGF0YShjb2RlZ2VuXzEubmlsLCBsb29wQWxsUmVxdWlyZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlXzEuY2hlY2tSZXBvcnRNaXNzaW5nUHJvcChjeHQsIHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBleGl0T25FcnJvck1vZGUoKSB7XG4gICAgICAgICAgICBjb25zdCBtaXNzaW5nID0gZ2VuLmxldChcIm1pc3NpbmdcIik7XG4gICAgICAgICAgICBpZiAodXNlTG9vcCB8fCAkZGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCAoKSA9PiBsb29wVW50aWxNaXNzaW5nKG1pc3NpbmcsIHZhbGlkKSk7XG4gICAgICAgICAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlXzEuY2hlY2tNaXNzaW5nUHJvcChjeHQsIHNjaGVtYSwgbWlzc2luZykpO1xuICAgICAgICAgICAgICAgIGNvZGVfMS5yZXBvcnRNaXNzaW5nUHJvcChjeHQsIG1pc3NpbmcpO1xuICAgICAgICAgICAgICAgIGdlbi5lbHNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG9vcEFsbFJlcXVpcmVkKCkge1xuICAgICAgICAgICAgZ2VuLmZvck9mKFwicHJvcFwiLCBzY2hlbWFDb2RlLCAocHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBtaXNzaW5nUHJvcGVydHk6IHByb3AgfSk7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVfMS5ub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgb3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4gY3h0LmVycm9yKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG9vcFVudGlsTWlzc2luZyhtaXNzaW5nLCB2YWxpZCkge1xuICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IG1pc3NpbmdQcm9wZXJ0eTogbWlzc2luZyB9KTtcbiAgICAgICAgICAgIGdlbi5mb3JPZihtaXNzaW5nLCBzY2hlbWFDb2RlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgY29kZV8xLnByb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgbWlzc2luZywgb3B0cy5vd25Qcm9wZXJ0aWVzKSk7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5ub3QodmFsaWQpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGN4dC5lcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uYnJlYWsoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGNvZGVnZW5fMS5uaWwpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1aXJlZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSB7XG4gICAgICAgIGNvbnN0IGNvbXAgPSBrZXl3b3JkID09PSBcIm1heEl0ZW1zXCIgPyBcIm1vcmVcIiA6IFwiZmV3ZXJcIjtcbiAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5zdHIgYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gaXRlbXNgO1xuICAgIH0sXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+IGNvZGVnZW5fMS5fIGB7bGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogW1wibWF4SXRlbXNcIiwgXCJtaW5JdGVtc1wiXSxcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGtleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGUgfSA9IGN4dDtcbiAgICAgICAgY29uc3Qgb3AgPSBrZXl3b3JkID09PSBcIm1heEl0ZW1zXCIgPyBjb2RlZ2VuXzEub3BlcmF0b3JzLkdUIDogY29kZWdlbl8xLm9wZXJhdG9ycy5MVDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YShjb2RlZ2VuXzEuXyBgJHtkYXRhfS5sZW5ndGggJHtvcH0gJHtzY2hlbWFDb2RlfWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXRJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hanYtdmFsaWRhdG9yL2Fqdi9pc3N1ZXMvODg5XG5jb25zdCBlcXVhbCA9IHJlcXVpcmUoXCJmYXN0LWRlZXAtZXF1YWxcIik7XG5lcXVhbC5jb2RlID0gJ3JlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL2VxdWFsXCIpLmRlZmF1bHQnO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXF1YWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcXVhbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGRhdGFUeXBlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZS9kYXRhVHlwZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXF1YWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL2VxdWFsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IGksIGogfSB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBtdXN0IE5PVCBoYXZlIGR1cGxpY2F0ZSBpdGVtcyAoaXRlbXMgIyMgJHtqfSBhbmQgJHtpfSBhcmUgaWRlbnRpY2FsKWAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgaSwgaiB9IH0pID0+IGNvZGVnZW5fMS5fIGB7aTogJHtpfSwgajogJHtqfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYm9vbGVhblwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmICghJGRhdGEgJiYgIXNjaGVtYSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIik7XG4gICAgICAgIGNvbnN0IGl0ZW1UeXBlcyA9IHBhcmVudFNjaGVtYS5pdGVtcyA/IGRhdGFUeXBlXzEuZ2V0U2NoZW1hVHlwZXMocGFyZW50U2NoZW1hLml0ZW1zKSA6IFtdO1xuICAgICAgICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgdmFsaWRhdGVVbmlxdWVJdGVtcywgY29kZWdlbl8xLl8gYCR7c2NoZW1hQ29kZX0gPT09IGZhbHNlYCk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlVW5pcXVlSXRlbXMoKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gZ2VuLmxldChcImlcIiwgY29kZWdlbl8xLl8gYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgICAgICAgICBjb25zdCBqID0gZ2VuLmxldChcImpcIik7XG4gICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgaSwgaiB9KTtcbiAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2l9ID4gMWAsICgpID0+IChjYW5PcHRpbWl6ZSgpID8gbG9vcE4gOiBsb29wTjIpKGksIGopKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYW5PcHRpbWl6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtVHlwZXMubGVuZ3RoID4gMCAmJiAhaXRlbVR5cGVzLnNvbWUoKHQpID0+IHQgPT09IFwib2JqZWN0XCIgfHwgdCA9PT0gXCJhcnJheVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb29wTihpLCBqKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gZ2VuLm5hbWUoXCJpdGVtXCIpO1xuICAgICAgICAgICAgY29uc3Qgd3JvbmdUeXBlID0gZGF0YVR5cGVfMS5jaGVja0RhdGFUeXBlcyhpdGVtVHlwZXMsIGl0ZW0sIGl0Lm9wdHMuc3RyaWN0TnVtYmVycywgZGF0YVR5cGVfMS5EYXRhVHlwZS5Xcm9uZyk7XG4gICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gZ2VuLmNvbnN0KFwiaW5kaWNlc1wiLCBjb2RlZ2VuXzEuXyBge31gKTtcbiAgICAgICAgICAgIGdlbi5mb3IoY29kZWdlbl8xLl8gYDske2l9LS07YCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGdlbi5sZXQoaXRlbSwgY29kZWdlbl8xLl8gYCR7ZGF0YX1bJHtpfV1gKTtcbiAgICAgICAgICAgICAgICBnZW4uaWYod3JvbmdUeXBlLCBjb2RlZ2VuXzEuXyBgY29udGludWVgKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbVR5cGVzLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgdHlwZW9mICR7aXRlbX0gPT0gXCJzdHJpbmdcImAsIGNvZGVnZW5fMS5fIGAke2l0ZW19ICs9IFwiX1wiYCk7XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5pZihjb2RlZ2VuXzEuXyBgdHlwZW9mICR7aW5kaWNlc31bJHtpdGVtfV0gPT0gXCJudW1iZXJcImAsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihqLCBjb2RlZ2VuXzEuXyBgJHtpbmRpY2VzfVske2l0ZW19XWApO1xuICAgICAgICAgICAgICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmJyZWFrKCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNvZGUoY29kZWdlbl8xLl8gYCR7aW5kaWNlc31bJHtpdGVtfV0gPSAke2l9YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb29wTjIoaSwgaikge1xuICAgICAgICAgICAgY29uc3QgZXFsID0gdXRpbF8xLnVzZUZ1bmMoZ2VuLCBlcXVhbF8xLmRlZmF1bHQpO1xuICAgICAgICAgICAgY29uc3Qgb3V0ZXIgPSBnZW4ubmFtZShcIm91dGVyXCIpO1xuICAgICAgICAgICAgZ2VuLmxhYmVsKG91dGVyKS5mb3IoY29kZWdlbl8xLl8gYDske2l9LS07YCwgKCkgPT4gZ2VuLmZvcihjb2RlZ2VuXzEuXyBgJHtqfSA9ICR7aX07ICR7an0tLTtgLCAoKSA9PiBnZW4uaWYoY29kZWdlbl8xLl8gYCR7ZXFsfSgke2RhdGF9WyR7aX1dLCAke2RhdGF9WyR7an1dKWAsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuYnJlYWsob3V0ZXIpO1xuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5pcXVlSXRlbXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVxdWFsXzEgPSByZXF1aXJlKFwiLi4vLi4vcnVudGltZS9lcXVhbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwibXVzdCBiZSBlcXVhbCB0byBjb25zdGFudFwiLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuXyBge2FsbG93ZWRWYWx1ZTogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImNvbnN0XCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWFDb2RlLCBzY2hlbWEgfSA9IGN4dDtcbiAgICAgICAgaWYgKCRkYXRhIHx8IChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgY3h0LmZhaWwkZGF0YShjb2RlZ2VuXzEuXyBgISR7dXRpbF8xLnVzZUZ1bmMoZ2VuLCBlcXVhbF8xLmRlZmF1bHQpfSgke2RhdGF9LCAke3NjaGVtYUNvZGV9KWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3h0LmZhaWwoY29kZWdlbl8xLl8gYCR7c2NoZW1hfSAhPT0gJHtkYXRhfWApO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXF1YWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL2VxdWFsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IGJlIGVxdWFsIHRvIG9uZSBvZiB0aGUgYWxsb3dlZCB2YWx1ZXNcIixcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLl8gYHthbGxvd2VkVmFsdWVzOiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZW51bVwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKCEkZGF0YSAmJiBzY2hlbWEubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW51bSBtdXN0IGhhdmUgbm9uLWVtcHR5IGFycmF5XCIpO1xuICAgICAgICBjb25zdCB1c2VMb29wID0gc2NoZW1hLmxlbmd0aCA+PSBpdC5vcHRzLmxvb3BFbnVtO1xuICAgICAgICBjb25zdCBlcWwgPSB1dGlsXzEudXNlRnVuYyhnZW4sIGVxdWFsXzEuZGVmYXVsdCk7XG4gICAgICAgIGxldCB2YWxpZDtcbiAgICAgICAgaWYgKHVzZUxvb3AgfHwgJGRhdGEpIHtcbiAgICAgICAgICAgIHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgICAgICAgICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsIGxvb3BFbnVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICAgICAgY29uc3QgdlNjaGVtYSA9IGdlbi5jb25zdChcInZTY2hlbWFcIiwgc2NoZW1hQ29kZSk7XG4gICAgICAgICAgICB2YWxpZCA9IGNvZGVnZW5fMS5vciguLi5zY2hlbWEubWFwKChfeCwgaSkgPT4gZXF1YWxDb2RlKHZTY2hlbWEsIGkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3h0LnBhc3ModmFsaWQpO1xuICAgICAgICBmdW5jdGlvbiBsb29wRW51bSgpIHtcbiAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKTtcbiAgICAgICAgICAgIGdlbi5mb3JPZihcInZcIiwgc2NoZW1hQ29kZSwgKHYpID0+IGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtlcWx9KCR7ZGF0YX0sICR7dn0pYCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkuYnJlYWsoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVxdWFsQ29kZSh2U2NoZW1hLCBpKSB7XG4gICAgICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFbaV07XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHNjaCA9PT0gXCJvYmplY3RcIiAmJiBzY2ggIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGNvZGVnZW5fMS5fIGAke2VxbH0oJHtkYXRhfSwgJHt2U2NoZW1hfVske2l9XSlgXG4gICAgICAgICAgICAgICAgOiBjb2RlZ2VuXzEuXyBgJHtkYXRhfSA9PT0gJHtzY2h9YDtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW51bS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGxpbWl0TnVtYmVyXzEgPSByZXF1aXJlKFwiLi9saW1pdE51bWJlclwiKTtcbmNvbnN0IG11bHRpcGxlT2ZfMSA9IHJlcXVpcmUoXCIuL211bHRpcGxlT2ZcIik7XG5jb25zdCBsaW1pdExlbmd0aF8xID0gcmVxdWlyZShcIi4vbGltaXRMZW5ndGhcIik7XG5jb25zdCBwYXR0ZXJuXzEgPSByZXF1aXJlKFwiLi9wYXR0ZXJuXCIpO1xuY29uc3QgbGltaXRQcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9saW1pdFByb3BlcnRpZXNcIik7XG5jb25zdCByZXF1aXJlZF8xID0gcmVxdWlyZShcIi4vcmVxdWlyZWRcIik7XG5jb25zdCBsaW1pdEl0ZW1zXzEgPSByZXF1aXJlKFwiLi9saW1pdEl0ZW1zXCIpO1xuY29uc3QgdW5pcXVlSXRlbXNfMSA9IHJlcXVpcmUoXCIuL3VuaXF1ZUl0ZW1zXCIpO1xuY29uc3QgY29uc3RfMSA9IHJlcXVpcmUoXCIuL2NvbnN0XCIpO1xuY29uc3QgZW51bV8xID0gcmVxdWlyZShcIi4vZW51bVwiKTtcbmNvbnN0IHZhbGlkYXRpb24gPSBbXG4gICAgLy8gbnVtYmVyXG4gICAgbGltaXROdW1iZXJfMS5kZWZhdWx0LFxuICAgIG11bHRpcGxlT2ZfMS5kZWZhdWx0LFxuICAgIC8vIHN0cmluZ1xuICAgIGxpbWl0TGVuZ3RoXzEuZGVmYXVsdCxcbiAgICBwYXR0ZXJuXzEuZGVmYXVsdCxcbiAgICAvLyBvYmplY3RcbiAgICBsaW1pdFByb3BlcnRpZXNfMS5kZWZhdWx0LFxuICAgIHJlcXVpcmVkXzEuZGVmYXVsdCxcbiAgICAvLyBhcnJheVxuICAgIGxpbWl0SXRlbXNfMS5kZWZhdWx0LFxuICAgIHVuaXF1ZUl0ZW1zXzEuZGVmYXVsdCxcbiAgICAvLyBhbnlcbiAgICB7IGtleXdvcmQ6IFwidHlwZVwiLCBzY2hlbWFUeXBlOiBbXCJzdHJpbmdcIiwgXCJhcnJheVwiXSB9LFxuICAgIHsga2V5d29yZDogXCJudWxsYWJsZVwiLCBzY2hlbWFUeXBlOiBcImJvb2xlYW5cIiB9LFxuICAgIGNvbnN0XzEuZGVmYXVsdCxcbiAgICBlbnVtXzEuZGVmYXVsdCxcbl07XG5leHBvcnRzLmRlZmF1bHQgPSB2YWxpZGF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gY29kZWdlbl8xLnN0ciBgbXVzdCBOT1QgaGF2ZSBtb3JlIHRoYW4gJHtsZW59IGl0ZW1zYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBsZW4gfSB9KSA9PiBjb2RlZ2VuXzEuXyBge2xpbWl0OiAke2xlbn19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJhZGRpdGlvbmFsSXRlbXNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogW1wiYm9vbGVhblwiLCBcIm9iamVjdFwiXSxcbiAgICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBpdGVtcyB9ID0gcGFyZW50U2NoZW1hO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCAnXCJhZGRpdGlvbmFsSXRlbXNcIiBpcyBpZ25vcmVkIHdoZW4gXCJpdGVtc1wiIGlzIG5vdCBhbiBhcnJheSBvZiBzY2hlbWFzJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMoY3h0LCBpdGVtcyk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyhjeHQsIGl0ZW1zKSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICBpdC5pdGVtcyA9IHRydWU7XG4gICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsIGNvZGVnZW5fMS5fIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBsZW46IGl0ZW1zLmxlbmd0aCB9KTtcbiAgICAgICAgY3h0LnBhc3MoY29kZWdlbl8xLl8gYCR7bGVufSA8PSAke2l0ZW1zLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmICF1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4udmFyKFwidmFsaWRcIiwgY29kZWdlbl8xLl8gYCR7bGVufSA8PSAke2l0ZW1zLmxlbmd0aH1gKTsgLy8gVE9ETyB2YXJcbiAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5ub3QodmFsaWQpLCAoKSA9PiB2YWxpZGF0ZUl0ZW1zKHZhbGlkKSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXModmFsaWQpIHtcbiAgICAgICAgZ2VuLmZvclJhbmdlKFwiaVwiLCBpdGVtcy5sZW5ndGgsIGxlbiwgKGkpID0+IHtcbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoeyBrZXl3b3JkLCBkYXRhUHJvcDogaSwgZGF0YVByb3BUeXBlOiB1dGlsXzEuVHlwZS5OdW0gfSwgdmFsaWQpO1xuICAgICAgICAgICAgaWYgKCFpdC5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5ub3QodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMgPSB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcztcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZGl0aW9uYWxJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVUdXBsZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJhcnJheVwiLCBcImJvb2xlYW5cIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVUdXBsZShjeHQsIFwiYWRkaXRpb25hbEl0ZW1zXCIsIHNjaGVtYSk7XG4gICAgICAgIGl0Lml0ZW1zID0gdHJ1ZTtcbiAgICAgICAgaWYgKHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY3h0Lm9rKGNvZGVfMS52YWxpZGF0ZUFycmF5KGN4dCkpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gdmFsaWRhdGVUdXBsZShjeHQsIGV4dHJhSXRlbXMsIHNjaEFyciA9IGN4dC5zY2hlbWEpIHtcbiAgICBjb25zdCB7IGdlbiwgcGFyZW50U2NoZW1hLCBkYXRhLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgIGNoZWNrU3RyaWN0VHVwbGUocGFyZW50U2NoZW1hKTtcbiAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBzY2hBcnIubGVuZ3RoICYmIGl0Lml0ZW1zICE9PSB0cnVlKSB7XG4gICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgc2NoQXJyLmxlbmd0aCwgaXQuaXRlbXMpO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsIGNvZGVnZW5fMS5fIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgIHNjaEFyci5mb3JFYWNoKChzY2gsIGkpID0+IHtcbiAgICAgICAgaWYgKHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2xlbn0gPiAke2l9YCwgKCkgPT4gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgICAgc2NoZW1hUHJvcDogaSxcbiAgICAgICAgICAgIGRhdGFQcm9wOiBpLFxuICAgICAgICB9LCB2YWxpZCkpO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGNoZWNrU3RyaWN0VHVwbGUoc2NoKSB7XG4gICAgICAgIGNvbnN0IHsgb3B0cywgZXJyU2NoZW1hUGF0aCB9ID0gaXQ7XG4gICAgICAgIGNvbnN0IGwgPSBzY2hBcnIubGVuZ3RoO1xuICAgICAgICBjb25zdCBmdWxsVHVwbGUgPSBsID09PSBzY2gubWluSXRlbXMgJiYgKGwgPT09IHNjaC5tYXhJdGVtcyB8fCBzY2hbZXh0cmFJdGVtc10gPT09IGZhbHNlKTtcbiAgICAgICAgaWYgKG9wdHMuc3RyaWN0VHVwbGVzICYmICFmdWxsVHVwbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBcIiR7a2V5d29yZH1cIiBpcyAke2x9LXR1cGxlLCBidXQgbWluSXRlbXMgb3IgbWF4SXRlbXMvJHtleHRyYUl0ZW1zfSBhcmUgbm90IHNwZWNpZmllZCBvciBkaWZmZXJlbnQgYXQgcGF0aCBcIiR7ZXJyU2NoZW1hUGF0aH1cImA7XG4gICAgICAgICAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCBtc2csIG9wdHMuc3RyaWN0VHVwbGVzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVUdXBsZSA9IHZhbGlkYXRlVHVwbGU7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGl0ZW1zXzEgPSByZXF1aXJlKFwiLi9pdGVtc1wiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInByZWZpeEl0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcImFycmF5XCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGNvZGU6IChjeHQpID0+IGl0ZW1zXzEudmFsaWRhdGVUdXBsZShjeHQsIFwiaXRlbXNcIiksXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJlZml4SXRlbXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgYWRkaXRpb25hbEl0ZW1zXzEgPSByZXF1aXJlKFwiLi9hZGRpdGlvbmFsSXRlbXNcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gY29kZWdlbl8xLnN0ciBgbXVzdCBOT1QgaGF2ZSBtb3JlIHRoYW4gJHtsZW59IGl0ZW1zYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBsZW4gfSB9KSA9PiBjb2RlZ2VuXzEuXyBge2xpbWl0OiAke2xlbn19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4SXRlbXMgfSA9IHBhcmVudFNjaGVtYTtcbiAgICAgICAgaXQuaXRlbXMgPSB0cnVlO1xuICAgICAgICBpZiAodXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAocHJlZml4SXRlbXMpXG4gICAgICAgICAgICBhZGRpdGlvbmFsSXRlbXNfMS52YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyhjeHQsIHByZWZpeEl0ZW1zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY3h0Lm9rKGNvZGVfMS52YWxpZGF0ZUFycmF5KGN4dCkpO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXRlbXMyMDIwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbWluLCBtYXggfSB9KSA9PiBtYXggPT09IHVuZGVmaW5lZFxuICAgICAgICA/IGNvZGVnZW5fMS5zdHIgYG11c3QgY29udGFpbiBhdCBsZWFzdCAke21pbn0gdmFsaWQgaXRlbShzKWBcbiAgICAgICAgOiBjb2RlZ2VuXzEuc3RyIGBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgJHttaW59IGFuZCBubyBtb3JlIHRoYW4gJHttYXh9IHZhbGlkIGl0ZW0ocylgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IG1pbiwgbWF4IH0gfSkgPT4gbWF4ID09PSB1bmRlZmluZWQgPyBjb2RlZ2VuXzEuXyBge21pbkNvbnRhaW5zOiAke21pbn19YCA6IGNvZGVnZW5fMS5fIGB7bWluQ29udGFpbnM6ICR7bWlufSwgbWF4Q29udGFpbnM6ICR7bWF4fX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImNvbnRhaW5zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgICAgICBsZXQgbWluO1xuICAgICAgICBsZXQgbWF4O1xuICAgICAgICBjb25zdCB7IG1pbkNvbnRhaW5zLCBtYXhDb250YWlucyB9ID0gcGFyZW50U2NoZW1hO1xuICAgICAgICBpZiAoaXQub3B0cy5uZXh0KSB7XG4gICAgICAgICAgICBtaW4gPSBtaW5Db250YWlucyA9PT0gdW5kZWZpbmVkID8gMSA6IG1pbkNvbnRhaW5zO1xuICAgICAgICAgICAgbWF4ID0gbWF4Q29udGFpbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtaW4gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCBjb2RlZ2VuXzEuXyBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7IG1pbiwgbWF4IH0pO1xuICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQgJiYgbWluID09PSAwKSB7XG4gICAgICAgICAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCBgXCJtaW5Db250YWluc1wiID09IDAgd2l0aG91dCBcIm1heENvbnRhaW5zXCI6IFwiY29udGFpbnNcIiBrZXl3b3JkIGlnbm9yZWRgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQgJiYgbWluID4gbWF4KSB7XG4gICAgICAgICAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCBgXCJtaW5Db250YWluc1wiID4gXCJtYXhDb250YWluc1wiIGlzIGFsd2F5cyBpbnZhbGlkYCk7XG4gICAgICAgICAgICBjeHQuZmFpbCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGxldCBjb25kID0gY29kZWdlbl8xLl8gYCR7bGVufSA+PSAke21pbn1gO1xuICAgICAgICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbmQgPSBjb2RlZ2VuXzEuXyBgJHtjb25kfSAmJiAke2xlbn0gPD0gJHttYXh9YDtcbiAgICAgICAgICAgIGN4dC5wYXNzKGNvbmQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGl0Lml0ZW1zID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQgJiYgbWluID09PSAxKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUl0ZW1zKHZhbGlkLCAoKSA9PiBnZW4uaWYodmFsaWQsICgpID0+IGdlbi5icmVhaygpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZW4ubGV0KHZhbGlkLCBmYWxzZSk7XG4gICAgICAgICAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSBnZW4ubGV0KFwiY291bnRcIiwgMCk7XG4gICAgICAgICAgICB2YWxpZGF0ZUl0ZW1zKHNjaFZhbGlkLCAoKSA9PiBnZW4uaWYoc2NoVmFsaWQsICgpID0+IGNoZWNrTGltaXRzKGNvdW50KSkpO1xuICAgICAgICB9XG4gICAgICAgIGN4dC5yZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyhfdmFsaWQsIGJsb2NrKSB7XG4gICAgICAgICAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIDAsIGxlbiwgKGkpID0+IHtcbiAgICAgICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZDogXCJjb250YWluc1wiLFxuICAgICAgICAgICAgICAgICAgICBkYXRhUHJvcDogaSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVByb3BUeXBlOiB1dGlsXzEuVHlwZS5OdW0sXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSwgX3ZhbGlkKTtcbiAgICAgICAgICAgICAgICBibG9jaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tMaW1pdHMoY291bnQpIHtcbiAgICAgICAgICAgIGdlbi5jb2RlKGNvZGVnZW5fMS5fIGAke2NvdW50fSsrYCk7XG4gICAgICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7Y291bnR9ID49ICR7bWlufWAsICgpID0+IGdlbi5hc3NpZ24odmFsaWQsIHRydWUpLmJyZWFrKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2NvdW50fSA+ICR7bWF4fWAsICgpID0+IGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhaygpKTtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSAxKVxuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtjb3VudH0gPj0gJHttaW59YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250YWlucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVTY2hlbWFEZXBzID0gZXhwb3J0cy52YWxpZGF0ZVByb3BlcnR5RGVwcyA9IGV4cG9ydHMuZXJyb3IgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuZXhwb3J0cy5lcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgcHJvcGVydHksIGRlcHNDb3VudCwgZGVwcyB9IH0pID0+IHtcbiAgICAgICAgY29uc3QgcHJvcGVydHlfaWVzID0gZGVwc0NvdW50ID09PSAxID8gXCJwcm9wZXJ0eVwiIDogXCJwcm9wZXJ0aWVzXCI7XG4gICAgICAgIHJldHVybiBjb2RlZ2VuXzEuc3RyIGBtdXN0IGhhdmUgJHtwcm9wZXJ0eV9pZXN9ICR7ZGVwc30gd2hlbiBwcm9wZXJ0eSAke3Byb3BlcnR5fSBpcyBwcmVzZW50YDtcbiAgICB9LFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IHByb3BlcnR5LCBkZXBzQ291bnQsIGRlcHMsIG1pc3NpbmdQcm9wZXJ0eSB9IH0pID0+IGNvZGVnZW5fMS5fIGB7cHJvcGVydHk6ICR7cHJvcGVydHl9LFxuICAgIG1pc3NpbmdQcm9wZXJ0eTogJHttaXNzaW5nUHJvcGVydHl9LFxuICAgIGRlcHNDb3VudDogJHtkZXBzQ291bnR9LFxuICAgIGRlcHM6ICR7ZGVwc319YCwgLy8gVE9ETyBjaGFuZ2UgdG8gcmVmZXJlbmNlXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZGVwZW5kZW5jaWVzXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICAgIGVycm9yOiBleHBvcnRzLmVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IFtwcm9wRGVwcywgc2NoRGVwc10gPSBzcGxpdERlcGVuZGVuY2llcyhjeHQpO1xuICAgICAgICB2YWxpZGF0ZVByb3BlcnR5RGVwcyhjeHQsIHByb3BEZXBzKTtcbiAgICAgICAgdmFsaWRhdGVTY2hlbWFEZXBzKGN4dCwgc2NoRGVwcyk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBzcGxpdERlcGVuZGVuY2llcyh7IHNjaGVtYSB9KSB7XG4gICAgY29uc3QgcHJvcGVydHlEZXBzID0ge307XG4gICAgY29uc3Qgc2NoZW1hRGVwcyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBpZiAoa2V5ID09PSBcIl9fcHJvdG9fX1wiKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGRlcHMgPSBBcnJheS5pc0FycmF5KHNjaGVtYVtrZXldKSA/IHByb3BlcnR5RGVwcyA6IHNjaGVtYURlcHM7XG4gICAgICAgIGRlcHNba2V5XSA9IHNjaGVtYVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gW3Byb3BlcnR5RGVwcywgc2NoZW1hRGVwc107XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5RGVwcyhjeHQsIHByb3BlcnR5RGVwcyA9IGN4dC5zY2hlbWEpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICBpZiAoT2JqZWN0LmtleXMocHJvcGVydHlEZXBzKS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBtaXNzaW5nID0gZ2VuLmxldChcIm1pc3NpbmdcIik7XG4gICAgZm9yIChjb25zdCBwcm9wIGluIHByb3BlcnR5RGVwcykge1xuICAgICAgICBjb25zdCBkZXBzID0gcHJvcGVydHlEZXBzW3Byb3BdO1xuICAgICAgICBpZiAoZGVwcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgaGFzUHJvcGVydHkgPSBjb2RlXzEucHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpO1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHtcbiAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgZGVwc0NvdW50OiBkZXBzLmxlbmd0aCxcbiAgICAgICAgICAgIGRlcHM6IGRlcHMuam9pbihcIiwgXCIpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgICAgICAgICAgZ2VuLmlmKGhhc1Byb3BlcnR5LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkZXBQcm9wIG9mIGRlcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZV8xLmNoZWNrUmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBkZXBQcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtoYXNQcm9wZXJ0eX0gJiYgKCR7Y29kZV8xLmNoZWNrTWlzc2luZ1Byb3AoY3h0LCBkZXBzLCBtaXNzaW5nKX0pYCk7XG4gICAgICAgICAgICBjb2RlXzEucmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBtaXNzaW5nKTtcbiAgICAgICAgICAgIGdlbi5lbHNlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlUHJvcGVydHlEZXBzID0gdmFsaWRhdGVQcm9wZXJ0eURlcHM7XG5mdW5jdGlvbiB2YWxpZGF0ZVNjaGVtYURlcHMoY3h0LCBzY2hlbWFEZXBzID0gY3h0LnNjaGVtYSkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gc2NoZW1hRGVwcykge1xuICAgICAgICBpZiAodXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWFEZXBzW3Byb3BdKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBnZW4uaWYoY29kZV8xLnByb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQsIHNjaGVtYVByb3A6IHByb3AgfSwgdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoQ3h0LCB2YWxpZCk7XG4gICAgICAgIH0sICgpID0+IGdlbi52YXIodmFsaWQsIHRydWUpIC8vIFRPRE8gdmFyXG4gICAgICAgICk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVNjaGVtYURlcHMgPSB2YWxpZGF0ZVNjaGVtYURlcHM7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXBlbmRlbmNpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwicHJvcGVydHkgbmFtZSBtdXN0IGJlIHZhbGlkXCIsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXMgfSkgPT4gY29kZWdlbl8xLl8gYHtwcm9wZXJ0eU5hbWU6ICR7cGFyYW1zLnByb3BlcnR5TmFtZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJwcm9wZXJ0eU5hbWVzXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmICh1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgZ2VuLmZvckluKFwia2V5XCIsIGRhdGEsIChrZXkpID0+IHtcbiAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBwcm9wZXJ0eU5hbWU6IGtleSB9KTtcbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwicHJvcGVydHlOYW1lc1wiLFxuICAgICAgICAgICAgICAgIGRhdGE6IGtleSxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZXM6IFtcInN0cmluZ1wiXSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWU6IGtleSxcbiAgICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5ub3QodmFsaWQpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LmVycm9yKHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICBnZW4uYnJlYWsoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BlcnR5TmFtZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvbmFtZXNcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IE5PVCBoYXZlIGFkZGl0aW9uYWwgcHJvcGVydGllc1wiLFxuICAgIHBhcmFtczogKHsgcGFyYW1zIH0pID0+IGNvZGVnZW5fMS5fIGB7YWRkaXRpb25hbFByb3BlcnR5OiAke3BhcmFtcy5hZGRpdGlvbmFsUHJvcGVydHl9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIixcbiAgICB0eXBlOiBbXCJvYmplY3RcIl0sXG4gICAgc2NoZW1hVHlwZTogW1wiYm9vbGVhblwiLCBcIm9iamVjdFwiXSxcbiAgICBhbGxvd1VuZGVmaW5lZDogdHJ1ZSxcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGVycnNDb3VudCwgaXQgfSA9IGN4dDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghZXJyc0NvdW50KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICBjb25zdCB7IGFsbEVycm9ycywgb3B0cyB9ID0gaXQ7XG4gICAgICAgIGl0LnByb3BzID0gdHJ1ZTtcbiAgICAgICAgaWYgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCAhPT0gXCJhbGxcIiAmJiB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHByb3BzID0gY29kZV8xLmFsbFNjaGVtYVByb3BlcnRpZXMocGFyZW50U2NoZW1hLnByb3BlcnRpZXMpO1xuICAgICAgICBjb25zdCBwYXRQcm9wcyA9IGNvZGVfMS5hbGxTY2hlbWFQcm9wZXJ0aWVzKHBhcmVudFNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcyk7XG4gICAgICAgIGNoZWNrQWRkaXRpb25hbFByb3BlcnRpZXMoKTtcbiAgICAgICAgY3h0Lm9rKGNvZGVnZW5fMS5fIGAke2VycnNDb3VudH0gPT09ICR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc31gKTtcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tBZGRpdGlvbmFsUHJvcGVydGllcygpIHtcbiAgICAgICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wcy5sZW5ndGggJiYgIXBhdFByb3BzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnR5Q29kZShrZXkpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKGlzQWRkaXRpb25hbChrZXkpLCAoKSA9PiBhZGRpdGlvbmFsUHJvcGVydHlDb2RlKGtleSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNBZGRpdGlvbmFsKGtleSkge1xuICAgICAgICAgICAgbGV0IGRlZmluZWRQcm9wO1xuICAgICAgICAgICAgaWYgKHByb3BzLmxlbmd0aCA+IDgpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIG1heWJlIGFuIG9wdGlvbiBpbnN0ZWFkIG9mIGhhcmQtY29kZWQgOD9cbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wc1NjaGVtYSA9IHV0aWxfMS5zY2hlbWFSZWZPclZhbChpdCwgcGFyZW50U2NoZW1hLnByb3BlcnRpZXMsIFwicHJvcGVydGllc1wiKTtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9IGNvZGVfMS5pc093blByb3BlcnR5KGdlbiwgcHJvcHNTY2hlbWEsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9IGNvZGVnZW5fMS5vciguLi5wcm9wcy5tYXAoKHApID0+IGNvZGVnZW5fMS5fIGAke2tleX0gPT09ICR7cH1gKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9IGNvZGVnZW5fMS5uaWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0UHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lZFByb3AgPSBjb2RlZ2VuXzEub3IoZGVmaW5lZFByb3AsIC4uLnBhdFByb3BzLm1hcCgocCkgPT4gY29kZWdlbl8xLl8gYCR7Y29kZV8xLnVzZVBhdHRlcm4oY3h0LCBwKX0udGVzdCgke2tleX0pYCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5ub3QoZGVmaW5lZFByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlbGV0ZUFkZGl0aW9uYWwoa2V5KSB7XG4gICAgICAgICAgICBnZW4uY29kZShjb2RlZ2VuXzEuXyBgZGVsZXRlICR7ZGF0YX1bJHtrZXl9XWApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFkZGl0aW9uYWxQcm9wZXJ0eUNvZGUoa2V5KSB7XG4gICAgICAgICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImFsbFwiIHx8IChvcHRzLnJlbW92ZUFkZGl0aW9uYWwgJiYgc2NoZW1hID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGVBZGRpdGlvbmFsKGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgYWRkaXRpb25hbFByb3BlcnR5OiBrZXkgfSk7XG4gICAgICAgICAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFhbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5icmVhaygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgIXV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImZhaWxpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBhcHBseUFkZGl0aW9uYWxTY2hlbWEoa2V5LCB2YWxpZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLm5vdCh2YWxpZCksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4dC5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlQWRkaXRpb25hbChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5QWRkaXRpb25hbFNjaGVtYShrZXksIHZhbGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLm5vdCh2YWxpZCksICgpID0+IGdlbi5icmVhaygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXBwbHlBZGRpdGlvbmFsU2NoZW1hKGtleSwgdmFsaWQsIGVycm9ycykge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NoZW1hID0ge1xuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICBkYXRhUHJvcDoga2V5LFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuU3RyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChlcnJvcnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzdWJzY2hlbWEsIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoc3Vic2NoZW1hLCB2YWxpZCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZGl0aW9uYWxQcm9wZXJ0aWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgYWRkaXRpb25hbFByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL2FkZGl0aW9uYWxQcm9wZXJ0aWVzXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicHJvcGVydGllc1wiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmIChpdC5vcHRzLnJlbW92ZUFkZGl0aW9uYWwgPT09IFwiYWxsXCIgJiYgcGFyZW50U2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEuZGVmYXVsdC5jb2RlKG5ldyB2YWxpZGF0ZV8xLktleXdvcmRDeHQoaXQsIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEuZGVmYXVsdCwgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsUHJvcHMgPSBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcyhzY2hlbWEpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgYWxsUHJvcHMpIHtcbiAgICAgICAgICAgIGl0LmRlZmluZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBhbGxQcm9wcy5sZW5ndGggJiYgaXQucHJvcHMgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgdXRpbF8xLnRvSGFzaChhbGxQcm9wcyksIGl0LnByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gYWxsUHJvcHMuZmlsdGVyKChwKSA9PiAhdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWFbcF0pKTtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAoaGFzRGVmYXVsdChwcm9wKSkge1xuICAgICAgICAgICAgICAgIGFwcGx5UHJvcGVydHlTY2hlbWEocHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoY29kZV8xLnByb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSk7XG4gICAgICAgICAgICAgICAgYXBwbHlQcm9wZXJ0eVNjaGVtYShwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0LmFsbEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmVsc2UoKS52YXIodmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGdlbi5lbmRJZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3h0Lml0LmRlZmluZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFzRGVmYXVsdChwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gaXQub3B0cy51c2VEZWZhdWx0cyAmJiAhaXQuY29tcG9zaXRlUnVsZSAmJiBzY2hlbWFbcHJvcF0uZGVmYXVsdCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5UHJvcGVydHlTY2hlbWEocHJvcCkge1xuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJwcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgc2NoZW1hUHJvcDogcHJvcCxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcDogcHJvcCxcbiAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCB1dGlsXzIgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMgfSA9IGl0O1xuICAgICAgICBjb25zdCBwYXR0ZXJucyA9IGNvZGVfMS5hbGxTY2hlbWFQcm9wZXJ0aWVzKHNjaGVtYSk7XG4gICAgICAgIGNvbnN0IGFsd2F5c1ZhbGlkUGF0dGVybnMgPSBwYXR0ZXJucy5maWx0ZXIoKHApID0+IHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hW3BdKSk7XG4gICAgICAgIGlmIChwYXR0ZXJucy5sZW5ndGggPT09IDAgfHxcbiAgICAgICAgICAgIChhbHdheXNWYWxpZFBhdHRlcm5zLmxlbmd0aCA9PT0gcGF0dGVybnMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgKCFpdC5vcHRzLnVuZXZhbHVhdGVkIHx8IGl0LnByb3BzID09PSB0cnVlKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGVja1Byb3BlcnRpZXMgPSBvcHRzLnN0cmljdFNjaGVtYSAmJiAhb3B0cy5hbGxvd01hdGNoaW5nUHJvcGVydGllcyAmJiBwYXJlbnRTY2hlbWEucHJvcGVydGllcztcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBpZiAoaXQucHJvcHMgIT09IHRydWUgJiYgIShpdC5wcm9wcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKSkge1xuICAgICAgICAgICAgaXQucHJvcHMgPSB1dGlsXzIuZXZhbHVhdGVkUHJvcHNUb05hbWUoZ2VuLCBpdC5wcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gaXQ7XG4gICAgICAgIHZhbGlkYXRlUGF0dGVyblByb3BlcnRpZXMoKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVQYXR0ZXJuUHJvcGVydGllcygpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGF0IG9mIHBhdHRlcm5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrUHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tNYXRjaGluZ1Byb3BlcnRpZXMocGF0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLnZhcih2YWxpZCwgdHJ1ZSk7IC8vIFRPRE8gdmFyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uaWYodmFsaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGVja01hdGNoaW5nUHJvcGVydGllcyhwYXQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBjaGVja1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3IFJlZ0V4cChwYXQpLnRlc3QocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZShpdCwgYHByb3BlcnR5ICR7cHJvcH0gbWF0Y2hlcyBwYXR0ZXJuICR7cGF0fSAodXNlIGFsbG93TWF0Y2hpbmdQcm9wZXJ0aWVzKWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMocGF0KSB7XG4gICAgICAgICAgICBnZW4uZm9ySW4oXCJrZXlcIiwgZGF0YSwgKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtjb2RlXzEudXNlUGF0dGVybihjeHQsIHBhdCl9LnRlc3QoJHtrZXl9KWAsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWx3YXlzVmFsaWQgPSBhbHdheXNWYWxpZFBhdHRlcm5zLmluY2x1ZGVzKHBhdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWx3YXlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFQcm9wOiBwYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByb3A6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IHV0aWxfMi5UeXBlLlN0cixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBwcm9wcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHtwcm9wc31bJHtrZXl9XWAsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFhbHdheXNWYWxpZCAmJiAhaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW4gc2hvcnQtY2lyY3VpdCBpZiBgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzYCBpcyBub3Qgc3VwcG9ydGVkIChvcHRzLm5leHQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3IgaWYgYWxsIHByb3BlcnRpZXMgd2VyZSBldmFsdWF0ZWQgKHByb3BzID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5ub3QodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXR0ZXJuUHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJub3RcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmICh1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGN4dC5mYWlsKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgIGtleXdvcmQ6IFwibm90XCIsXG4gICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgIGFsbEVycm9yczogZmFsc2UsXG4gICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgY3h0LmZhaWxSZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IoKSk7XG4gICAgfSxcbiAgICBlcnJvcjogeyBtZXNzYWdlOiBcIm11c3QgTk9UIGJlIHZhbGlkXCIgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImFueU9mXCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGNvZGU6IGNvZGVfMS52YWxpZGF0ZVVuaW9uLFxuICAgIGVycm9yOiB7IG1lc3NhZ2U6IFwibXVzdCBtYXRjaCBhIHNjaGVtYSBpbiBhbnlPZlwiIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW55T2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwibXVzdCBtYXRjaCBleGFjdGx5IG9uZSBzY2hlbWEgaW4gb25lT2ZcIixcbiAgICBwYXJhbXM6ICh7IHBhcmFtcyB9KSA9PiBjb2RlZ2VuXzEuXyBge3Bhc3NpbmdTY2hlbWFzOiAke3BhcmFtcy5wYXNzaW5nfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIm9uZU9mXCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICBpZiAoaXQub3B0cy5kaXNjcmltaW5hdG9yICYmIHBhcmVudFNjaGVtYS5kaXNjcmltaW5hdG9yKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBzY2hBcnIgPSBzY2hlbWE7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIGZhbHNlKTtcbiAgICAgICAgY29uc3QgcGFzc2luZyA9IGdlbi5sZXQoXCJwYXNzaW5nXCIsIG51bGwpO1xuICAgICAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHsgcGFzc2luZyB9KTtcbiAgICAgICAgLy8gVE9ETyBwb3NzaWJseSBmYWlsIHN0cmFpZ2h0IGF3YXkgKHdpdGggd2FybmluZyBvciBleGNlcHRpb24pIGlmIHRoZXJlIGFyZSB0d28gZW1wdHkgYWx3YXlzIHZhbGlkIHNjaGVtYXNcbiAgICAgICAgZ2VuLmJsb2NrKHZhbGlkYXRlT25lT2YpO1xuICAgICAgICBjeHQucmVzdWx0KHZhbGlkLCAoKSA9PiBjeHQucmVzZXQoKSwgKCkgPT4gY3h0LmVycm9yKHRydWUpKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVPbmVPZigpIHtcbiAgICAgICAgICAgIHNjaEFyci5mb3JFYWNoKChzY2gsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgc2NoQ3h0O1xuICAgICAgICAgICAgICAgIGlmICh1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLnZhcihzY2hWYWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwib25lT2ZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYVByb3A6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9LCBzY2hWYWxpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC5pZihjb2RlZ2VuXzEuXyBgJHtzY2hWYWxpZH0gJiYgJHt2YWxpZH1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFzc2lnbih2YWxpZCwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXNzaWduKHBhc3NpbmcsIGNvZGVnZW5fMS5fIGBbJHtwYXNzaW5nfSwgJHtpfV1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmVsc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2VuLmlmKHNjaFZhbGlkLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHBhc3NpbmcsIGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoQ3h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCwgY29kZWdlbl8xLk5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uZU9mLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImFsbE9mXCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBzY2hlbWEuZm9yRWFjaCgoc2NoLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAodXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2gpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoeyBrZXl3b3JkOiBcImFsbE9mXCIsIHNjaGVtYVByb3A6IGkgfSwgdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQpO1xuICAgICAgICB9KTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFsbE9mLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXMgfSkgPT4gY29kZWdlbl8xLnN0ciBgbXVzdCBtYXRjaCBcIiR7cGFyYW1zLmlmQ2xhdXNlfVwiIHNjaGVtYWAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXMgfSkgPT4gY29kZWdlbl8xLl8gYHtmYWlsaW5nS2V5d29yZDogJHtwYXJhbXMuaWZDbGF1c2V9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiaWZcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmIChwYXJlbnRTY2hlbWEudGhlbiA9PT0gdW5kZWZpbmVkICYmIHBhcmVudFNjaGVtYS5lbHNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHV0aWxfMS5jaGVja1N0cmljdE1vZGUoaXQsICdcImlmXCIgd2l0aG91dCBcInRoZW5cIiBhbmQgXCJlbHNlXCIgaXMgaWdub3JlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc1RoZW4gPSBoYXNTY2hlbWEoaXQsIFwidGhlblwiKTtcbiAgICAgICAgY29uc3QgaGFzRWxzZSA9IGhhc1NjaGVtYShpdCwgXCJlbHNlXCIpO1xuICAgICAgICBpZiAoIWhhc1RoZW4gJiYgIWhhc0Vsc2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpO1xuICAgICAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgICAgICB2YWxpZGF0ZUlmKCk7XG4gICAgICAgIGN4dC5yZXNldCgpO1xuICAgICAgICBpZiAoaGFzVGhlbiAmJiBoYXNFbHNlKSB7XG4gICAgICAgICAgICBjb25zdCBpZkNsYXVzZSA9IGdlbi5sZXQoXCJpZkNsYXVzZVwiKTtcbiAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBpZkNsYXVzZSB9KTtcbiAgICAgICAgICAgIGdlbi5pZihzY2hWYWxpZCwgdmFsaWRhdGVDbGF1c2UoXCJ0aGVuXCIsIGlmQ2xhdXNlKSwgdmFsaWRhdGVDbGF1c2UoXCJlbHNlXCIsIGlmQ2xhdXNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzVGhlbikge1xuICAgICAgICAgICAgZ2VuLmlmKHNjaFZhbGlkLCB2YWxpZGF0ZUNsYXVzZShcInRoZW5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5ub3Qoc2NoVmFsaWQpLCB2YWxpZGF0ZUNsYXVzZShcImVsc2VcIikpO1xuICAgICAgICB9XG4gICAgICAgIGN4dC5wYXNzKHZhbGlkLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUlmKCkge1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJpZlwiLFxuICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhbGxFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgfSwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVDbGF1c2Uoa2V5d29yZCwgaWZDbGF1c2UpIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQgfSwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHNjaFZhbGlkKTtcbiAgICAgICAgICAgICAgICBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHZhbGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoaWZDbGF1c2UpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oaWZDbGF1c2UsIGNvZGVnZW5fMS5fIGAke2tleXdvcmR9YCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgaWZDbGF1c2U6IGtleXdvcmQgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcbn07XG5mdW5jdGlvbiBoYXNTY2hlbWEoaXQsIGtleXdvcmQpIHtcbiAgICBjb25zdCBzY2hlbWEgPSBpdC5zY2hlbWFba2V5d29yZF07XG4gICAgcmV0dXJuIHNjaGVtYSAhPT0gdW5kZWZpbmVkICYmICF1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogW1widGhlblwiLCBcImVsc2VcIl0sXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICBjb2RlKHsga2V5d29yZCwgcGFyZW50U2NoZW1hLCBpdCB9KSB7XG4gICAgICAgIGlmIChwYXJlbnRTY2hlbWEuaWYgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHV0aWxfMS5jaGVja1N0cmljdE1vZGUoaXQsIGBcIiR7a2V5d29yZH1cIiB3aXRob3V0IFwiaWZcIiBpcyBpZ25vcmVkYCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aGVuRWxzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGFkZGl0aW9uYWxJdGVtc18xID0gcmVxdWlyZShcIi4vYWRkaXRpb25hbEl0ZW1zXCIpO1xuY29uc3QgcHJlZml4SXRlbXNfMSA9IHJlcXVpcmUoXCIuL3ByZWZpeEl0ZW1zXCIpO1xuY29uc3QgaXRlbXNfMSA9IHJlcXVpcmUoXCIuL2l0ZW1zXCIpO1xuY29uc3QgaXRlbXMyMDIwXzEgPSByZXF1aXJlKFwiLi9pdGVtczIwMjBcIik7XG5jb25zdCBjb250YWluc18xID0gcmVxdWlyZShcIi4vY29udGFpbnNcIik7XG5jb25zdCBkZXBlbmRlbmNpZXNfMSA9IHJlcXVpcmUoXCIuL2RlcGVuZGVuY2llc1wiKTtcbmNvbnN0IHByb3BlcnR5TmFtZXNfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnR5TmFtZXNcIik7XG5jb25zdCBhZGRpdGlvbmFsUHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vYWRkaXRpb25hbFByb3BlcnRpZXNcIik7XG5jb25zdCBwcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9wcm9wZXJ0aWVzXCIpO1xuY29uc3QgcGF0dGVyblByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL3BhdHRlcm5Qcm9wZXJ0aWVzXCIpO1xuY29uc3Qgbm90XzEgPSByZXF1aXJlKFwiLi9ub3RcIik7XG5jb25zdCBhbnlPZl8xID0gcmVxdWlyZShcIi4vYW55T2ZcIik7XG5jb25zdCBvbmVPZl8xID0gcmVxdWlyZShcIi4vb25lT2ZcIik7XG5jb25zdCBhbGxPZl8xID0gcmVxdWlyZShcIi4vYWxsT2ZcIik7XG5jb25zdCBpZl8xID0gcmVxdWlyZShcIi4vaWZcIik7XG5jb25zdCB0aGVuRWxzZV8xID0gcmVxdWlyZShcIi4vdGhlbkVsc2VcIik7XG5mdW5jdGlvbiBnZXRBcHBsaWNhdG9yKGRyYWZ0MjAyMCA9IGZhbHNlKSB7XG4gICAgY29uc3QgYXBwbGljYXRvciA9IFtcbiAgICAgICAgLy8gYW55XG4gICAgICAgIG5vdF8xLmRlZmF1bHQsXG4gICAgICAgIGFueU9mXzEuZGVmYXVsdCxcbiAgICAgICAgb25lT2ZfMS5kZWZhdWx0LFxuICAgICAgICBhbGxPZl8xLmRlZmF1bHQsXG4gICAgICAgIGlmXzEuZGVmYXVsdCxcbiAgICAgICAgdGhlbkVsc2VfMS5kZWZhdWx0LFxuICAgICAgICAvLyBvYmplY3RcbiAgICAgICAgcHJvcGVydHlOYW1lc18xLmRlZmF1bHQsXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICAgICAgZGVwZW5kZW5jaWVzXzEuZGVmYXVsdCxcbiAgICAgICAgcHJvcGVydGllc18xLmRlZmF1bHQsXG4gICAgICAgIHBhdHRlcm5Qcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICBdO1xuICAgIC8vIGFycmF5XG4gICAgaWYgKGRyYWZ0MjAyMClcbiAgICAgICAgYXBwbGljYXRvci5wdXNoKHByZWZpeEl0ZW1zXzEuZGVmYXVsdCwgaXRlbXMyMDIwXzEuZGVmYXVsdCk7XG4gICAgZWxzZVxuICAgICAgICBhcHBsaWNhdG9yLnB1c2goYWRkaXRpb25hbEl0ZW1zXzEuZGVmYXVsdCwgaXRlbXNfMS5kZWZhdWx0KTtcbiAgICBhcHBsaWNhdG9yLnB1c2goY29udGFpbnNfMS5kZWZhdWx0KTtcbiAgICByZXR1cm4gYXBwbGljYXRvcjtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGdldEFwcGxpY2F0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBzY2hlbWFDb2RlIH0pID0+IGNvZGVnZW5fMS5zdHIgYG11c3QgbWF0Y2ggZm9ybWF0IFwiJHtzY2hlbWFDb2RlfVwiYCxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLl8gYHtmb3JtYXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJmb3JtYXRcIixcbiAgICB0eXBlOiBbXCJudW1iZXJcIiwgXCJzdHJpbmdcIl0sXG4gICAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCwgcnVsZVR5cGUpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgb3B0cywgZXJyU2NoZW1hUGF0aCwgc2NoZW1hRW52LCBzZWxmIH0gPSBpdDtcbiAgICAgICAgaWYgKCFvcHRzLnZhbGlkYXRlRm9ybWF0cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCRkYXRhKVxuICAgICAgICAgICAgdmFsaWRhdGUkRGF0YUZvcm1hdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2YWxpZGF0ZUZvcm1hdCgpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZSREYXRhRm9ybWF0KCkge1xuICAgICAgICAgICAgY29uc3QgZm10cyA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7XG4gICAgICAgICAgICAgICAgcmVmOiBzZWxmLmZvcm1hdHMsXG4gICAgICAgICAgICAgICAgY29kZTogb3B0cy5jb2RlLmZvcm1hdHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGZEZWYgPSBnZW4uY29uc3QoXCJmRGVmXCIsIGNvZGVnZW5fMS5fIGAke2ZtdHN9WyR7c2NoZW1hQ29kZX1dYCk7XG4gICAgICAgICAgICBjb25zdCBmVHlwZSA9IGdlbi5sZXQoXCJmVHlwZVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IGdlbi5sZXQoXCJmb3JtYXRcIik7XG4gICAgICAgICAgICAvLyBUT0RPIHNpbXBsaWZ5XG4gICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYHR5cGVvZiAke2ZEZWZ9ID09IFwib2JqZWN0XCIgJiYgISgke2ZEZWZ9IGluc3RhbmNlb2YgUmVnRXhwKWAsICgpID0+IGdlbi5hc3NpZ24oZlR5cGUsIGNvZGVnZW5fMS5fIGAke2ZEZWZ9LnR5cGUgfHwgXCJzdHJpbmdcImApLmFzc2lnbihmb3JtYXQsIGNvZGVnZW5fMS5fIGAke2ZEZWZ9LnZhbGlkYXRlYCksICgpID0+IGdlbi5hc3NpZ24oZlR5cGUsIGNvZGVnZW5fMS5fIGBcInN0cmluZ1wiYCkuYXNzaWduKGZvcm1hdCwgZkRlZikpO1xuICAgICAgICAgICAgY3h0LmZhaWwkZGF0YShjb2RlZ2VuXzEub3IodW5rbm93bkZtdCgpLCBpbnZhbGlkRm10KCkpKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHVua25vd25GbXQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMuc3RyaWN0U2NoZW1hID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5uaWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5fIGAke3NjaGVtYUNvZGV9ICYmICEke2Zvcm1hdH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gaW52YWxpZEZtdCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsRm9ybWF0ID0gc2NoZW1hRW52LiRhc3luY1xuICAgICAgICAgICAgICAgICAgICA/IGNvZGVnZW5fMS5fIGAoJHtmRGVmfS5hc3luYyA/IGF3YWl0ICR7Zm9ybWF0fSgke2RhdGF9KSA6ICR7Zm9ybWF0fSgke2RhdGF9KSlgXG4gICAgICAgICAgICAgICAgICAgIDogY29kZWdlbl8xLl8gYCR7Zm9ybWF0fSgke2RhdGF9KWA7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWREYXRhID0gY29kZWdlbl8xLl8gYCh0eXBlb2YgJHtmb3JtYXR9ID09IFwiZnVuY3Rpb25cIiA/ICR7Y2FsbEZvcm1hdH0gOiAke2Zvcm1hdH0udGVzdCgke2RhdGF9KSlgO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgJHtmb3JtYXR9ICYmICR7Zm9ybWF0fSAhPT0gdHJ1ZSAmJiAke2ZUeXBlfSA9PT0gJHtydWxlVHlwZX0gJiYgISR7dmFsaWREYXRhfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoKSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXREZWYgPSBzZWxmLmZvcm1hdHNbc2NoZW1hXTtcbiAgICAgICAgICAgIGlmICghZm9ybWF0RGVmKSB7XG4gICAgICAgICAgICAgICAgdW5rbm93bkZvcm1hdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXREZWYgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgW2ZtdFR5cGUsIGZvcm1hdCwgZm10UmVmXSA9IGdldEZvcm1hdChmb3JtYXREZWYpO1xuICAgICAgICAgICAgaWYgKGZtdFR5cGUgPT09IHJ1bGVUeXBlKVxuICAgICAgICAgICAgICAgIGN4dC5wYXNzKHZhbGlkQ29uZGl0aW9uKCkpO1xuICAgICAgICAgICAgZnVuY3Rpb24gdW5rbm93bkZvcm1hdCgpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5zdHJpY3RTY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubG9nZ2VyLndhcm4odW5rbm93bk1zZygpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodW5rbm93bk1zZygpKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1bmtub3duTXNnKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYHVua25vd24gZm9ybWF0IFwiJHtzY2hlbWF9XCIgaWdub3JlZCBpbiBzY2hlbWEgYXQgcGF0aCBcIiR7ZXJyU2NoZW1hUGF0aH1cImA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Rm9ybWF0KGZtdERlZikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBmbXREZWYgaW5zdGFuY2VvZiBSZWdFeHBcbiAgICAgICAgICAgICAgICAgICAgPyBjb2RlZ2VuXzEucmVnZXhwQ29kZShmbXREZWYpXG4gICAgICAgICAgICAgICAgICAgIDogb3B0cy5jb2RlLmZvcm1hdHNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29kZWdlbl8xLl8gYCR7b3B0cy5jb2RlLmZvcm1hdHN9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkoc2NoZW1hKX1gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBjb25zdCBmbXQgPSBnZW4uc2NvcGVWYWx1ZShcImZvcm1hdHNcIiwgeyBrZXk6IHNjaGVtYSwgcmVmOiBmbXREZWYsIGNvZGUgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbXREZWYgPT0gXCJvYmplY3RcIiAmJiAhKGZtdERlZiBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtmbXREZWYudHlwZSB8fCBcInN0cmluZ1wiLCBmbXREZWYudmFsaWRhdGUsIGNvZGVnZW5fMS5fIGAke2ZtdH0udmFsaWRhdGVgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcInN0cmluZ1wiLCBmbXREZWYsIGZtdF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiB2YWxpZENvbmRpdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdERlZiA9PSBcIm9iamVjdFwiICYmICEoZm9ybWF0RGVmIGluc3RhbmNlb2YgUmVnRXhwKSAmJiBmb3JtYXREZWYuYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzY2hlbWFFbnYuJGFzeW5jKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMgZm9ybWF0IGluIHN5bmMgc2NoZW1hXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLl8gYGF3YWl0ICR7Zm10UmVmfSgke2RhdGF9KWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZm9ybWF0ID09IFwiZnVuY3Rpb25cIiA/IGNvZGVnZW5fMS5fIGAke2ZtdFJlZn0oJHtkYXRhfSlgIDogY29kZWdlbl8xLl8gYCR7Zm10UmVmfS50ZXN0KCR7ZGF0YX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZm9ybWF0XzEgPSByZXF1aXJlKFwiLi9mb3JtYXRcIik7XG5jb25zdCBmb3JtYXQgPSBbZm9ybWF0XzEuZGVmYXVsdF07XG5leHBvcnRzLmRlZmF1bHQgPSBmb3JtYXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29udGVudFZvY2FidWxhcnkgPSBleHBvcnRzLm1ldGFkYXRhVm9jYWJ1bGFyeSA9IHZvaWQgMDtcbmV4cG9ydHMubWV0YWRhdGFWb2NhYnVsYXJ5ID0gW1xuICAgIFwidGl0bGVcIixcbiAgICBcImRlc2NyaXB0aW9uXCIsXG4gICAgXCJkZWZhdWx0XCIsXG4gICAgXCJkZXByZWNhdGVkXCIsXG4gICAgXCJyZWFkT25seVwiLFxuICAgIFwid3JpdGVPbmx5XCIsXG4gICAgXCJleGFtcGxlc1wiLFxuXTtcbmV4cG9ydHMuY29udGVudFZvY2FidWxhcnkgPSBbXG4gICAgXCJjb250ZW50TWVkaWFUeXBlXCIsXG4gICAgXCJjb250ZW50RW5jb2RpbmdcIixcbiAgICBcImNvbnRlbnRTY2hlbWFcIixcbl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRhZGF0YS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5jb25zdCB2YWxpZGF0aW9uXzEgPSByZXF1aXJlKFwiLi92YWxpZGF0aW9uXCIpO1xuY29uc3QgYXBwbGljYXRvcl8xID0gcmVxdWlyZShcIi4vYXBwbGljYXRvclwiKTtcbmNvbnN0IGZvcm1hdF8xID0gcmVxdWlyZShcIi4vZm9ybWF0XCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgZHJhZnQ3Vm9jYWJ1bGFyaWVzID0gW1xuICAgIGNvcmVfMS5kZWZhdWx0LFxuICAgIHZhbGlkYXRpb25fMS5kZWZhdWx0LFxuICAgIGFwcGxpY2F0b3JfMS5kZWZhdWx0KCksXG4gICAgZm9ybWF0XzEuZGVmYXVsdCxcbiAgICBtZXRhZGF0YV8xLm1ldGFkYXRhVm9jYWJ1bGFyeSxcbiAgICBtZXRhZGF0YV8xLmNvbnRlbnRWb2NhYnVsYXJ5LFxuXTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRyYWZ0N1ZvY2FidWxhcmllcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyYWZ0Ny5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGlzY3JFcnJvciA9IHZvaWQgMDtcbnZhciBEaXNjckVycm9yO1xuKGZ1bmN0aW9uIChEaXNjckVycm9yKSB7XG4gICAgRGlzY3JFcnJvcltcIlRhZ1wiXSA9IFwidGFnXCI7XG4gICAgRGlzY3JFcnJvcltcIk1hcHBpbmdcIl0gPSBcIm1hcHBpbmdcIjtcbn0pKERpc2NyRXJyb3IgPSBleHBvcnRzLkRpc2NyRXJyb3IgfHwgKGV4cG9ydHMuRGlzY3JFcnJvciA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uL2Rpc2NyaW1pbmF0b3IvdHlwZXNcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgZGlzY3JFcnJvciwgdGFnTmFtZSB9IH0pID0+IGRpc2NyRXJyb3IgPT09IHR5cGVzXzEuRGlzY3JFcnJvci5UYWdcbiAgICAgICAgPyBgdGFnIFwiJHt0YWdOYW1lfVwiIG11c3QgYmUgc3RyaW5nYFxuICAgICAgICA6IGB2YWx1ZSBvZiB0YWcgXCIke3RhZ05hbWV9XCIgbXVzdCBiZSBpbiBvbmVPZmAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgZGlzY3JFcnJvciwgdGFnLCB0YWdOYW1lIH0gfSkgPT4gY29kZWdlbl8xLl8gYHtlcnJvcjogJHtkaXNjckVycm9yfSwgdGFnOiAke3RhZ05hbWV9LCB0YWdWYWx1ZTogJHt0YWd9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZGlzY3JpbWluYXRvclwiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgb25lT2YgfSA9IHBhcmVudFNjaGVtYTtcbiAgICAgICAgaWYgKCFpdC5vcHRzLmRpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRpc2NyaW1pbmF0b3I6IHJlcXVpcmVzIGRpc2NyaW1pbmF0b3Igb3B0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSBzY2hlbWEucHJvcGVydHlOYW1lO1xuICAgICAgICBpZiAodHlwZW9mIHRhZ05hbWUgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRpc2NyaW1pbmF0b3I6IHJlcXVpcmVzIHByb3BlcnR5TmFtZVwiKTtcbiAgICAgICAgaWYgKHNjaGVtYS5tYXBwaW5nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogbWFwcGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICBpZiAoIW9uZU9mKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgb25lT2Yga2V5d29yZFwiKTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgZmFsc2UpO1xuICAgICAgICBjb25zdCB0YWcgPSBnZW4uY29uc3QoXCJ0YWdcIiwgY29kZWdlbl8xLl8gYCR7ZGF0YX0ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eSh0YWdOYW1lKX1gKTtcbiAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGB0eXBlb2YgJHt0YWd9ID09IFwic3RyaW5nXCJgLCAoKSA9PiB2YWxpZGF0ZU1hcHBpbmcoKSwgKCkgPT4gY3h0LmVycm9yKGZhbHNlLCB7IGRpc2NyRXJyb3I6IHR5cGVzXzEuRGlzY3JFcnJvci5UYWcsIHRhZywgdGFnTmFtZSB9KSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlTWFwcGluZygpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcHBpbmcgPSBnZXRNYXBwaW5nKCk7XG4gICAgICAgICAgICBnZW4uaWYoZmFsc2UpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0YWdWYWx1ZSBpbiBtYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgZ2VuLmVsc2VJZihjb2RlZ2VuXzEuXyBgJHt0YWd9ID09PSAke3RhZ1ZhbHVlfWApO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGFwcGx5VGFnU2NoZW1hKG1hcHBpbmdbdGFnVmFsdWVdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZW4uZWxzZSgpO1xuICAgICAgICAgICAgY3h0LmVycm9yKGZhbHNlLCB7IGRpc2NyRXJyb3I6IHR5cGVzXzEuRGlzY3JFcnJvci5NYXBwaW5nLCB0YWcsIHRhZ05hbWUgfSk7XG4gICAgICAgICAgICBnZW4uZW5kSWYoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcHBseVRhZ1NjaGVtYShzY2hlbWFQcm9wKSB7XG4gICAgICAgICAgICBjb25zdCBfdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQ6IFwib25lT2ZcIiwgc2NoZW1hUHJvcCB9LCBfdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCwgY29kZWdlbl8xLk5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIF92YWxpZDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRNYXBwaW5nKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3Qgb25lT2ZNYXBwaW5nID0ge307XG4gICAgICAgICAgICBjb25zdCB0b3BSZXF1aXJlZCA9IGhhc1JlcXVpcmVkKHBhcmVudFNjaGVtYSk7XG4gICAgICAgICAgICBsZXQgdGFnUmVxdWlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvbmVPZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaCA9IG9uZU9mW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BTY2ggPSAoX2EgPSBzY2gucHJvcGVydGllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3RhZ05hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcFNjaCAhPSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogb25lT2Ygc2NoZW1hcyBtdXN0IGhhdmUgXCJwcm9wZXJ0aWVzLyR7dGFnTmFtZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YWdSZXF1aXJlZCA9IHRhZ1JlcXVpcmVkICYmICh0b3BSZXF1aXJlZCB8fCBoYXNSZXF1aXJlZChzY2gpKTtcbiAgICAgICAgICAgICAgICBhZGRNYXBwaW5ncyhwcm9wU2NoLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGFnUmVxdWlyZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBcIiR7dGFnTmFtZX1cIiBtdXN0IGJlIHJlcXVpcmVkYCk7XG4gICAgICAgICAgICByZXR1cm4gb25lT2ZNYXBwaW5nO1xuICAgICAgICAgICAgZnVuY3Rpb24gaGFzUmVxdWlyZWQoeyByZXF1aXJlZCB9KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocmVxdWlyZWQpICYmIHJlcXVpcmVkLmluY2x1ZGVzKHRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkTWFwcGluZ3Moc2NoLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaC5jb25zdCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRNYXBwaW5nKHNjaC5jb25zdCwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaC5lbnVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdGFnVmFsdWUgb2Ygc2NoLmVudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1hcHBpbmcodGFnVmFsdWUsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IFwicHJvcGVydGllcy8ke3RhZ05hbWV9XCIgbXVzdCBoYXZlIFwiY29uc3RcIiBvciBcImVudW1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmcodGFnVmFsdWUsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhZ1ZhbHVlICE9IFwic3RyaW5nXCIgfHwgdGFnVmFsdWUgaW4gb25lT2ZNYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogXCIke3RhZ05hbWV9XCIgdmFsdWVzIG11c3QgYmUgdW5pcXVlIHN0cmluZ3NgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25lT2ZNYXBwaW5nW3RhZ1ZhbHVlXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db2RlR2VuID0gZXhwb3J0cy5OYW1lID0gZXhwb3J0cy5uaWwgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyID0gZXhwb3J0cy5fID0gZXhwb3J0cy5LZXl3b3JkQ3h0ID0gdm9pZCAwO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbmNvbnN0IGRyYWZ0N18xID0gcmVxdWlyZShcIi4vdm9jYWJ1bGFyaWVzL2RyYWZ0N1wiKTtcbmNvbnN0IGRpc2NyaW1pbmF0b3JfMSA9IHJlcXVpcmUoXCIuL3ZvY2FidWxhcmllcy9kaXNjcmltaW5hdG9yXCIpO1xuY29uc3QgZHJhZnQ3TWV0YVNjaGVtYSA9IHJlcXVpcmUoXCIuL3JlZnMvanNvbi1zY2hlbWEtZHJhZnQtMDcuanNvblwiKTtcbmNvbnN0IE1FVEFfU1VQUE9SVF9EQVRBID0gW1wiL3Byb3BlcnRpZXNcIl07XG5jb25zdCBNRVRBX1NDSEVNQV9JRCA9IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWFcIjtcbmNsYXNzIEFqdiBleHRlbmRzIGNvcmVfMS5kZWZhdWx0IHtcbiAgICBfYWRkVm9jYWJ1bGFyaWVzKCkge1xuICAgICAgICBzdXBlci5fYWRkVm9jYWJ1bGFyaWVzKCk7XG4gICAgICAgIGRyYWZ0N18xLmRlZmF1bHQuZm9yRWFjaCgodikgPT4gdGhpcy5hZGRWb2NhYnVsYXJ5KHYpKTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5kaXNjcmltaW5hdG9yKVxuICAgICAgICAgICAgdGhpcy5hZGRLZXl3b3JkKGRpc2NyaW1pbmF0b3JfMS5kZWZhdWx0KTtcbiAgICB9XG4gICAgX2FkZERlZmF1bHRNZXRhU2NoZW1hKCkge1xuICAgICAgICBzdXBlci5fYWRkRGVmYXVsdE1ldGFTY2hlbWEoKTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdHMubWV0YSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbWV0YVNjaGVtYSA9IHRoaXMub3B0cy4kZGF0YVxuICAgICAgICAgICAgPyB0aGlzLiRkYXRhTWV0YVNjaGVtYShkcmFmdDdNZXRhU2NoZW1hLCBNRVRBX1NVUFBPUlRfREFUQSlcbiAgICAgICAgICAgIDogZHJhZnQ3TWV0YVNjaGVtYTtcbiAgICAgICAgdGhpcy5hZGRNZXRhU2NoZW1hKG1ldGFTY2hlbWEsIE1FVEFfU0NIRU1BX0lELCBmYWxzZSk7XG4gICAgICAgIHRoaXMucmVmc1tcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvc2NoZW1hXCJdID0gTUVUQV9TQ0hFTUFfSUQ7XG4gICAgfVxuICAgIGRlZmF1bHRNZXRhKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMub3B0cy5kZWZhdWx0TWV0YSA9XG4gICAgICAgICAgICBzdXBlci5kZWZhdWx0TWV0YSgpIHx8ICh0aGlzLmdldFNjaGVtYShNRVRBX1NDSEVNQV9JRCkgPyBNRVRBX1NDSEVNQV9JRCA6IHVuZGVmaW5lZCkpO1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEFqdjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEFqdjtcbnZhciB2YWxpZGF0ZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS92YWxpZGF0ZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIktleXdvcmRDeHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRlXzEuS2V5d29yZEN4dDsgfSB9KTtcbnZhciBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL2NvZGVnZW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuXzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0clwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cmluZ2lmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5pbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLm5pbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5OYW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29kZUdlblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLkNvZGVHZW47IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hanYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZvcm1hdE5hbWVzID0gZXhwb3J0cy5mYXN0Rm9ybWF0cyA9IGV4cG9ydHMuZnVsbEZvcm1hdHMgPSB2b2lkIDA7XG5mdW5jdGlvbiBmbXREZWYodmFsaWRhdGUsIGNvbXBhcmUpIHtcbiAgICByZXR1cm4geyB2YWxpZGF0ZSwgY29tcGFyZSB9O1xufVxuZXhwb3J0cy5mdWxsRm9ybWF0cyA9IHtcbiAgICAvLyBkYXRlOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgZGF0ZTogZm10RGVmKGRhdGUsIGNvbXBhcmVEYXRlKSxcbiAgICAvLyBkYXRlLXRpbWU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICB0aW1lOiBmbXREZWYodGltZSwgY29tcGFyZVRpbWUpLFxuICAgIFwiZGF0ZS10aW1lXCI6IGZtdERlZihkYXRlX3RpbWUsIGNvbXBhcmVEYXRlVGltZSksXG4gICAgLy8gZHVyYXRpb246IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I2FwcGVuZGl4LUFcbiAgICBkdXJhdGlvbjogL15QKD8hJCkoKFxcZCtZKT8oXFxkK00pPyhcXGQrRCk/KFQoPz1cXGQpKFxcZCtIKT8oXFxkK00pPyhcXGQrUyk/KT98KFxcZCtXKT8pJC8sXG4gICAgdXJpLFxuICAgIFwidXJpLXJlZmVyZW5jZVwiOiAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KT8oPzpcXC8/XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol18JVswLTlhLWZdezJ9KSpAKT8oPzpcXFsoPzooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7Nn18OjooPzpbMC05YS1mXXsxLDR9Oil7NX18KD86WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7NH18KD86KD86WzAtOWEtZl17MSw0fTopezAsMX1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXszfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwyfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezJ9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDN9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9OnwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw0fVswLTlhLWZdezEsNH0pPzo6KSg/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykpfCg/Oig/OlswLTlhLWZdezEsNH06KXswLDV9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDZ9WzAtOWEtZl17MSw0fSk/OjopfFtWdl1bMC05YS1mXStcXC5bYS16MC05XFwtLl9+ISQmJygpKissOz06XSspXFxdfCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KXwoPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PV18JVswLTlhLWZdezJ9KSopKD86OlxcZCopPyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSp8XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT98KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT8oPzpcXD8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8oPzojKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/JC9pLFxuICAgIC8vIHVyaS10ZW1wbGF0ZTogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY1NzBcbiAgICBcInVyaS10ZW1wbGF0ZVwiOiAvXig/Oig/OlteXFx4MDAtXFx4MjBcIic8PiVcXFxcXmB7fH1dfCVbMC05YS1mXXsyfSl8XFx7WysjLi87PyY9LCFAfF0/KD86W2EtejAtOV9dfCVbMC05YS1mXXsyfSkrKD86OlsxLTldWzAtOV17MCwzfXxcXCopPyg/OiwoPzpbYS16MC05X118JVswLTlhLWZdezJ9KSsoPzo6WzEtOV1bMC05XXswLDN9fFxcKik/KSpcXH0pKiQvaSxcbiAgICAvLyBGb3IgdGhlIHNvdXJjZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZHBlcmluaS83MjkyOTRcbiAgICAvLyBGb3IgdGVzdCBjYXNlczogaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL2RlbW8vdXJsLXJlZ2V4XG4gICAgdXJsOiAvXig/Omh0dHBzP3xmdHApOlxcL1xcLyg/OlxcUysoPzo6XFxTKik/QCk/KD86KD8hKD86MTB8MTI3KSg/OlxcLlxcZHsxLDN9KXszfSkoPyEoPzoxNjlcXC4yNTR8MTkyXFwuMTY4KSg/OlxcLlxcZHsxLDN9KXsyfSkoPyExNzJcXC4oPzoxWzYtOV18MlxcZHwzWzAtMV0pKD86XFwuXFxkezEsM30pezJ9KSg/OlsxLTldXFxkP3wxXFxkXFxkfDJbMDFdXFxkfDIyWzAtM10pKD86XFwuKD86MT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkpezJ9KD86XFwuKD86WzEtOV1cXGQ/fDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNF0pKXwoPzooPzpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rLSkqW2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKykoPzpcXC4oPzpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rLSkqW2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKykqKD86XFwuKD86W2EtelxcdXswMGExfS1cXHV7ZmZmZn1dezIsfSkpKSg/OjpcXGR7Miw1fSk/KD86XFwvW15cXHNdKik/JC9pdSxcbiAgICBlbWFpbDogL15bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqQCg/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT8kL2ksXG4gICAgaG9zdG5hbWU6IC9eKD89LnsxLDI1M31cXC4/JClbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8oPzpcXC5bYS16MC05XSg/OlstMC05YS16XXswLDYxfVswLTlhLXpdKT8pKlxcLj8kL2ksXG4gICAgLy8gb3B0aW1pemVkIGh0dHBzOi8vd3d3LnNhZmFyaWJvb2tzb25saW5lLmNvbS9saWJyYXJ5L3ZpZXcvcmVndWxhci1leHByZXNzaW9ucy1jb29rYm9vay85NzgwNTk2ODAyODM3L2NoMDdzMTYuaHRtbFxuICAgIGlwdjQ6IC9eKD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pJC8sXG4gICAgaXB2NjogL14oKChbMC05YS1mXXsxLDR9Oil7N30oWzAtOWEtZl17MSw0fXw6KSl8KChbMC05YS1mXXsxLDR9Oil7Nn0oOlswLTlhLWZdezEsNH18KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlhLWZdezEsNH06KXs1fSgoKDpbMC05YS1mXXsxLDR9KXsxLDJ9KXw6KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlhLWZdezEsNH06KXs0fSgoKDpbMC05YS1mXXsxLDR9KXsxLDN9KXwoKDpbMC05YS1mXXsxLDR9KT86KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7M30oKCg6WzAtOWEtZl17MSw0fSl7MSw0fSl8KCg6WzAtOWEtZl17MSw0fSl7MCwyfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXsyfSgoKDpbMC05YS1mXXsxLDR9KXsxLDV9KXwoKDpbMC05YS1mXXsxLDR9KXswLDN9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezF9KCgoOlswLTlhLWZdezEsNH0pezEsNn0pfCgoOlswLTlhLWZdezEsNH0pezAsNH06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KDooKCg6WzAtOWEtZl17MSw0fSl7MSw3fSl8KCg6WzAtOWEtZl17MSw0fSl7MCw1fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKSkkL2ksXG4gICAgcmVnZXgsXG4gICAgLy8gdXVpZDogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDEyMlxuICAgIHV1aWQ6IC9eKD86dXJuOnV1aWQ6KT9bMC05YS1mXXs4fS0oPzpbMC05YS1mXXs0fS0pezN9WzAtOWEtZl17MTJ9JC9pLFxuICAgIC8vIEpTT04tcG9pbnRlcjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5MDFcbiAgICAvLyB1cmkgZnJhZ21lbnQ6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I2FwcGVuZGl4LUFcbiAgICBcImpzb24tcG9pbnRlclwiOiAvXig/OlxcLyg/Oltefi9dfH4wfH4xKSopKiQvLFxuICAgIFwianNvbi1wb2ludGVyLXVyaS1mcmFnbWVudFwiOiAvXiMoPzpcXC8oPzpbYS16MC05X1xcLS4hJCYnKCkqKyw7Oj1AXXwlWzAtOWEtZl17Mn18fjB8fjEpKikqJC9pLFxuICAgIC8vIHJlbGF0aXZlIEpTT04tcG9pbnRlcjogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtbHVmZi1yZWxhdGl2ZS1qc29uLXBvaW50ZXItMDBcbiAgICBcInJlbGF0aXZlLWpzb24tcG9pbnRlclwiOiAvXig/OjB8WzEtOV1bMC05XSopKD86I3woPzpcXC8oPzpbXn4vXXx+MHx+MSkqKSopJC8sXG4gICAgLy8gdGhlIGZvbGxvd2luZyBmb3JtYXRzIGFyZSB1c2VkIGJ5IHRoZSBvcGVuYXBpIHNwZWNpZmljYXRpb246IGh0dHBzOi8vc3BlYy5vcGVuYXBpcy5vcmcvb2FzL3YzLjAuMCNkYXRhLXR5cGVzXG4gICAgLy8gYnl0ZTogaHR0cHM6Ly9naXRodWIuY29tL21pZ3VlbG1vdGEvaXMtYmFzZTY0XG4gICAgYnl0ZSxcbiAgICAvLyBzaWduZWQgMzIgYml0IGludGVnZXJcbiAgICBpbnQzMjogeyB0eXBlOiBcIm51bWJlclwiLCB2YWxpZGF0ZTogdmFsaWRhdGVJbnQzMiB9LFxuICAgIC8vIHNpZ25lZCA2NCBiaXQgaW50ZWdlclxuICAgIGludDY0OiB7IHR5cGU6IFwibnVtYmVyXCIsIHZhbGlkYXRlOiB2YWxpZGF0ZUludDY0IH0sXG4gICAgLy8gQy10eXBlIGZsb2F0XG4gICAgZmxvYXQ6IHsgdHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlTnVtYmVyIH0sXG4gICAgLy8gQy10eXBlIGRvdWJsZVxuICAgIGRvdWJsZTogeyB0eXBlOiBcIm51bWJlclwiLCB2YWxpZGF0ZTogdmFsaWRhdGVOdW1iZXIgfSxcbiAgICAvLyBoaW50IHRvIHRoZSBVSSB0byBoaWRlIGlucHV0IHN0cmluZ3NcbiAgICBwYXNzd29yZDogdHJ1ZSxcbiAgICAvLyB1bmNoZWNrZWQgc3RyaW5nIHBheWxvYWRcbiAgICBiaW5hcnk6IHRydWUsXG59O1xuZXhwb3J0cy5mYXN0Rm9ybWF0cyA9IHtcbiAgICAuLi5leHBvcnRzLmZ1bGxGb3JtYXRzLFxuICAgIGRhdGU6IGZtdERlZigvXlxcZFxcZFxcZFxcZC1bMC0xXVxcZC1bMC0zXVxcZCQvLCBjb21wYXJlRGF0ZSksXG4gICAgdGltZTogZm10RGVmKC9eKD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPyk/JC9pLCBjb21wYXJlVGltZSksXG4gICAgXCJkYXRlLXRpbWVcIjogZm10RGVmKC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkW3RcXHNdKD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPykkL2ksIGNvbXBhcmVEYXRlVGltZSksXG4gICAgLy8gdXJpOiBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL2lzLW15LWpzb24tdmFsaWQvYmxvYi9tYXN0ZXIvZm9ybWF0cy5qc1xuICAgIHVyaTogL14oPzpbYS16XVthLXowLTkrXFwtLl0qOikoPzpcXC8/XFwvKT9bXlxcc10qJC9pLFxuICAgIFwidXJpLXJlZmVyZW5jZVwiOiAvXig/Oig/OlthLXpdW2EtejAtOStcXC0uXSo6KT9cXC8/XFwvKT8oPzpbXlxcXFxcXHMjXVteXFxzI10qKT8oPzojW15cXFxcXFxzXSopPyQvaSxcbiAgICAvLyBlbWFpbCAoc291cmNlcyBmcm9tIGpzZW4gdmFsaWRhdG9yKTpcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwMTMyMy91c2luZy1hLXJlZ3VsYXItZXhwcmVzc2lvbi10by12YWxpZGF0ZS1hbi1lbWFpbC1hZGRyZXNzI2Fuc3dlci04ODI5MzYzXG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCN2YWxpZC1lLW1haWwtYWRkcmVzcyAoc2VhcmNoIGZvciAnd2lsZnVsIHZpb2xhdGlvbicpXG4gICAgZW1haWw6IC9eW2EtejAtOS4hIyQlJicqKy89P15fYHt8fX4tXStAW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KD86XFwuW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KSokL2ksXG59O1xuZXhwb3J0cy5mb3JtYXROYW1lcyA9IE9iamVjdC5rZXlzKGV4cG9ydHMuZnVsbEZvcm1hdHMpO1xuZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjYXBwZW5kaXgtQ1xuICAgIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbn1cbmNvbnN0IERBVEUgPSAvXihcXGRcXGRcXGRcXGQpLShcXGRcXGQpLShcXGRcXGQpJC87XG5jb25zdCBEQVlTID0gWzAsIDMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xuZnVuY3Rpb24gZGF0ZShzdHIpIHtcbiAgICAvLyBmdWxsLWRhdGUgZnJvbSBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgY29uc3QgbWF0Y2hlcyA9IERBVEUuZXhlYyhzdHIpO1xuICAgIGlmICghbWF0Y2hlcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHllYXIgPSArbWF0Y2hlc1sxXTtcbiAgICBjb25zdCBtb250aCA9ICttYXRjaGVzWzJdO1xuICAgIGNvbnN0IGRheSA9ICttYXRjaGVzWzNdO1xuICAgIHJldHVybiAobW9udGggPj0gMSAmJlxuICAgICAgICBtb250aCA8PSAxMiAmJlxuICAgICAgICBkYXkgPj0gMSAmJlxuICAgICAgICBkYXkgPD0gKG1vbnRoID09PSAyICYmIGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IERBWVNbbW9udGhdKSk7XG59XG5mdW5jdGlvbiBjb21wYXJlRGF0ZShkMSwgZDIpIHtcbiAgICBpZiAoIShkMSAmJiBkMikpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKGQxID4gZDIpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmIChkMSA8IGQyKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgcmV0dXJuIDA7XG59XG5jb25zdCBUSU1FID0gL14oXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKShcXC5cXGQrKT8oenxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPyk/JC9pO1xuZnVuY3Rpb24gdGltZShzdHIsIHdpdGhUaW1lWm9uZSkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBUSU1FLmV4ZWMoc3RyKTtcbiAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBob3VyID0gK21hdGNoZXNbMV07XG4gICAgY29uc3QgbWludXRlID0gK21hdGNoZXNbMl07XG4gICAgY29uc3Qgc2Vjb25kID0gK21hdGNoZXNbM107XG4gICAgY29uc3QgdGltZVpvbmUgPSBtYXRjaGVzWzVdO1xuICAgIHJldHVybiAoKChob3VyIDw9IDIzICYmIG1pbnV0ZSA8PSA1OSAmJiBzZWNvbmQgPD0gNTkpIHx8XG4gICAgICAgIChob3VyID09PSAyMyAmJiBtaW51dGUgPT09IDU5ICYmIHNlY29uZCA9PT0gNjApKSAmJlxuICAgICAgICAoIXdpdGhUaW1lWm9uZSB8fCB0aW1lWm9uZSAhPT0gXCJcIikpO1xufVxuZnVuY3Rpb24gY29tcGFyZVRpbWUodDEsIHQyKSB7XG4gICAgaWYgKCEodDEgJiYgdDIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGExID0gVElNRS5leGVjKHQxKTtcbiAgICBjb25zdCBhMiA9IFRJTUUuZXhlYyh0Mik7XG4gICAgaWYgKCEoYTEgJiYgYTIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHQxID0gYTFbMV0gKyBhMVsyXSArIGExWzNdICsgKGExWzRdIHx8IFwiXCIpO1xuICAgIHQyID0gYTJbMV0gKyBhMlsyXSArIGEyWzNdICsgKGEyWzRdIHx8IFwiXCIpO1xuICAgIGlmICh0MSA+IHQyKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAodDEgPCB0MilcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xufVxuY29uc3QgREFURV9USU1FX1NFUEFSQVRPUiA9IC90fFxccy9pO1xuZnVuY3Rpb24gZGF0ZV90aW1lKHN0cikge1xuICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICBjb25zdCBkYXRlVGltZSA9IHN0ci5zcGxpdChEQVRFX1RJTUVfU0VQQVJBVE9SKTtcbiAgICByZXR1cm4gZGF0ZVRpbWUubGVuZ3RoID09PSAyICYmIGRhdGUoZGF0ZVRpbWVbMF0pICYmIHRpbWUoZGF0ZVRpbWVbMV0sIHRydWUpO1xufVxuZnVuY3Rpb24gY29tcGFyZURhdGVUaW1lKGR0MSwgZHQyKSB7XG4gICAgaWYgKCEoZHQxICYmIGR0MikpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgW2QxLCB0MV0gPSBkdDEuc3BsaXQoREFURV9USU1FX1NFUEFSQVRPUik7XG4gICAgY29uc3QgW2QyLCB0Ml0gPSBkdDIuc3BsaXQoREFURV9USU1FX1NFUEFSQVRPUik7XG4gICAgY29uc3QgcmVzID0gY29tcGFyZURhdGUoZDEsIGQyKTtcbiAgICBpZiAocmVzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlcyB8fCBjb21wYXJlVGltZSh0MSwgdDIpO1xufVxuY29uc3QgTk9UX1VSSV9GUkFHTUVOVCA9IC9cXC98Oi87XG5jb25zdCBVUkkgPSAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KSg/OlxcLz9cXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06XXwlWzAtOWEtZl17Mn0pKkApPyg/OlxcWyg/Oig/Oig/Oig/OlswLTlhLWZdezEsNH06KXs2fXw6Oig/OlswLTlhLWZdezEsNH06KXs1fXwoPzpbMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXs0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwxfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezN9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDJ9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7Mn18KD86KD86WzAtOWEtZl17MSw0fTopezAsM31bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH06fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDR9WzAtOWEtZl17MSw0fSk/OjopKD86WzAtOWEtZl17MSw0fTpbMC05YS1mXXsxLDR9fCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSl8KD86KD86WzAtOWEtZl17MSw0fTopezAsNX1bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH18KD86KD86WzAtOWEtZl17MSw0fTopezAsNn1bMC05YS1mXXsxLDR9KT86Oil8W1Z2XVswLTlhLWZdK1xcLlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdKylcXF18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pfCg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PV18JVswLTlhLWZdezJ9KSopKD86OlxcZCopPyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqfFxcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT98KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopKD86XFw/KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyg/OiMoPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/JC9pO1xuZnVuY3Rpb24gdXJpKHN0cikge1xuICAgIC8vIGh0dHA6Ly9qbXJ3YXJlLmNvbS9hcnRpY2xlcy8yMDA5L3VyaV9yZWdleHAvVVJJX3JlZ2V4Lmh0bWwgKyBvcHRpb25hbCBwcm90b2NvbCArIHJlcXVpcmVkIFwiLlwiXG4gICAgcmV0dXJuIE5PVF9VUklfRlJBR01FTlQudGVzdChzdHIpICYmIFVSSS50ZXN0KHN0cik7XG59XG5jb25zdCBCWVRFID0gL14oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezJ9PT18W0EtWmEtejAtOSsvXXszfT0pPyQvZ207XG5mdW5jdGlvbiBieXRlKHN0cikge1xuICAgIEJZVEUubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gQllURS50ZXN0KHN0cik7XG59XG5jb25zdCBNSU5fSU5UMzIgPSAtKDIgKiogMzEpO1xuY29uc3QgTUFYX0lOVDMyID0gMiAqKiAzMSAtIDE7XG5mdW5jdGlvbiB2YWxpZGF0ZUludDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIodmFsdWUpICYmIHZhbHVlIDw9IE1BWF9JTlQzMiAmJiB2YWx1ZSA+PSBNSU5fSU5UMzI7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUludDY0KHZhbHVlKSB7XG4gICAgLy8gSlNPTiBhbmQgamF2YXNjcmlwdCBtYXggSW50IGlzIDIqKjUzLCBzbyBhbnkgaW50IHRoYXQgcGFzc2VzIGlzSW50ZWdlciBpcyB2YWxpZCBmb3IgSW50NjRcbiAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlcigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IFpfQU5DSE9SID0gL1teXFxcXF1cXFxcWi87XG5mdW5jdGlvbiByZWdleChzdHIpIHtcbiAgICBpZiAoWl9BTkNIT1IudGVzdChzdHIpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IFJlZ0V4cChzdHIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZvcm1hdExpbWl0RGVmaW5pdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGFqdl8xID0gcmVxdWlyZShcImFqdlwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCJhanYvZGlzdC9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBvcHMgPSBjb2RlZ2VuXzEub3BlcmF0b3JzO1xuY29uc3QgS1dEcyA9IHtcbiAgICBmb3JtYXRNYXhpbXVtOiB7IG9rU3RyOiBcIjw9XCIsIG9rOiBvcHMuTFRFLCBmYWlsOiBvcHMuR1QgfSxcbiAgICBmb3JtYXRNaW5pbXVtOiB7IG9rU3RyOiBcIj49XCIsIG9rOiBvcHMuR1RFLCBmYWlsOiBvcHMuTFQgfSxcbiAgICBmb3JtYXRFeGNsdXNpdmVNYXhpbXVtOiB7IG9rU3RyOiBcIjxcIiwgb2s6IG9wcy5MVCwgZmFpbDogb3BzLkdURSB9LFxuICAgIGZvcm1hdEV4Y2x1c2l2ZU1pbmltdW06IHsgb2tTdHI6IFwiPlwiLCBvazogb3BzLkdULCBmYWlsOiBvcHMuTFRFIH0sXG59O1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBzaG91bGQgYmUgJHtLV0RzW2tleXdvcmRdLm9rU3RyfSAke3NjaGVtYUNvZGV9YCxcbiAgICBwYXJhbXM6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLl8gYHtjb21wYXJpc29uOiAke0tXRHNba2V5d29yZF0ub2tTdHJ9LCBsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmV4cG9ydHMuZm9ybWF0TGltaXREZWZpbml0aW9uID0ge1xuICAgIGtleXdvcmQ6IE9iamVjdC5rZXlzKEtXRHMpLFxuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgc2NoZW1hQ29kZSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICAgICAgaWYgKCFvcHRzLnZhbGlkYXRlRm9ybWF0cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZkN4dCA9IG5ldyBhanZfMS5LZXl3b3JkQ3h0KGl0LCBzZWxmLlJVTEVTLmFsbC5mb3JtYXQuZGVmaW5pdGlvbiwgXCJmb3JtYXRcIik7XG4gICAgICAgIGlmIChmQ3h0LiRkYXRhKVxuICAgICAgICAgICAgdmFsaWRhdGUkRGF0YUZvcm1hdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2YWxpZGF0ZUZvcm1hdCgpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZSREYXRhRm9ybWF0KCkge1xuICAgICAgICAgICAgY29uc3QgZm10cyA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7XG4gICAgICAgICAgICAgICAgcmVmOiBzZWxmLmZvcm1hdHMsXG4gICAgICAgICAgICAgICAgY29kZTogb3B0cy5jb2RlLmZvcm1hdHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGZtdCA9IGdlbi5jb25zdChcImZtdFwiLCBjb2RlZ2VuXzEuXyBgJHtmbXRzfVske2ZDeHQuc2NoZW1hQ29kZX1dYCk7XG4gICAgICAgICAgICBjeHQuZmFpbCRkYXRhKGNvZGVnZW5fMS5vcihjb2RlZ2VuXzEuXyBgdHlwZW9mICR7Zm10fSAhPSBcIm9iamVjdFwiYCwgY29kZWdlbl8xLl8gYCR7Zm10fSBpbnN0YW5jZW9mIFJlZ0V4cGAsIGNvZGVnZW5fMS5fIGB0eXBlb2YgJHtmbXR9LmNvbXBhcmUgIT0gXCJmdW5jdGlvblwiYCwgY29tcGFyZUNvZGUoZm10KSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KCkge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gZkN4dC5zY2hlbWE7XG4gICAgICAgICAgICBjb25zdCBmbXREZWYgPSBzZWxmLmZvcm1hdHNbZm9ybWF0XTtcbiAgICAgICAgICAgIGlmICghZm10RGVmIHx8IGZtdERlZiA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZtdERlZiAhPSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICAgICAgZm10RGVmIGluc3RhbmNlb2YgUmVnRXhwIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIGZtdERlZi5jb21wYXJlICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke2tleXdvcmR9XCI6IGZvcm1hdCBcIiR7Zm9ybWF0fVwiIGRvZXMgbm90IGRlZmluZSBcImNvbXBhcmVcIiBmdW5jdGlvbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZm10ID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAgICAgICAgICBrZXk6IGZvcm1hdCxcbiAgICAgICAgICAgICAgICByZWY6IGZtdERlZixcbiAgICAgICAgICAgICAgICBjb2RlOiBvcHRzLmNvZGUuZm9ybWF0cyA/IGNvZGVnZW5fMS5fIGAke29wdHMuY29kZS5mb3JtYXRzfSR7Y29kZWdlbl8xLmdldFByb3BlcnR5KGZvcm1hdCl9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3h0LmZhaWwkZGF0YShjb21wYXJlQ29kZShmbXQpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb21wYXJlQ29kZShmbXQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgJHtmbXR9LmNvbXBhcmUoJHtkYXRhfSwgJHtzY2hlbWFDb2RlfSkgJHtLV0RzW2tleXdvcmRdLmZhaWx9IDBgO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFtcImZvcm1hdFwiXSxcbn07XG5jb25zdCBmb3JtYXRMaW1pdFBsdWdpbiA9IChhanYpID0+IHtcbiAgICBhanYuYWRkS2V5d29yZChleHBvcnRzLmZvcm1hdExpbWl0RGVmaW5pdGlvbik7XG4gICAgcmV0dXJuIGFqdjtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBmb3JtYXRMaW1pdFBsdWdpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZm9ybWF0c18xID0gcmVxdWlyZShcIi4vZm9ybWF0c1wiKTtcbmNvbnN0IGxpbWl0XzEgPSByZXF1aXJlKFwiLi9saW1pdFwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCJhanYvZGlzdC9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBmdWxsTmFtZSA9IG5ldyBjb2RlZ2VuXzEuTmFtZShcImZ1bGxGb3JtYXRzXCIpO1xuY29uc3QgZmFzdE5hbWUgPSBuZXcgY29kZWdlbl8xLk5hbWUoXCJmYXN0Rm9ybWF0c1wiKTtcbmNvbnN0IGZvcm1hdHNQbHVnaW4gPSAoYWp2LCBvcHRzID0geyBrZXl3b3JkczogdHJ1ZSB9KSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0cykpIHtcbiAgICAgICAgYWRkRm9ybWF0cyhhanYsIG9wdHMsIGZvcm1hdHNfMS5mdWxsRm9ybWF0cywgZnVsbE5hbWUpO1xuICAgICAgICByZXR1cm4gYWp2O1xuICAgIH1cbiAgICBjb25zdCBbZm9ybWF0cywgZXhwb3J0TmFtZV0gPSBvcHRzLm1vZGUgPT09IFwiZmFzdFwiID8gW2Zvcm1hdHNfMS5mYXN0Rm9ybWF0cywgZmFzdE5hbWVdIDogW2Zvcm1hdHNfMS5mdWxsRm9ybWF0cywgZnVsbE5hbWVdO1xuICAgIGNvbnN0IGxpc3QgPSBvcHRzLmZvcm1hdHMgfHwgZm9ybWF0c18xLmZvcm1hdE5hbWVzO1xuICAgIGFkZEZvcm1hdHMoYWp2LCBsaXN0LCBmb3JtYXRzLCBleHBvcnROYW1lKTtcbiAgICBpZiAob3B0cy5rZXl3b3JkcylcbiAgICAgICAgbGltaXRfMS5kZWZhdWx0KGFqdik7XG4gICAgcmV0dXJuIGFqdjtcbn07XG5mb3JtYXRzUGx1Z2luLmdldCA9IChuYW1lLCBtb2RlID0gXCJmdWxsXCIpID0+IHtcbiAgICBjb25zdCBmb3JtYXRzID0gbW9kZSA9PT0gXCJmYXN0XCIgPyBmb3JtYXRzXzEuZmFzdEZvcm1hdHMgOiBmb3JtYXRzXzEuZnVsbEZvcm1hdHM7XG4gICAgY29uc3QgZiA9IGZvcm1hdHNbbmFtZV07XG4gICAgaWYgKCFmKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZm9ybWF0IFwiJHtuYW1lfVwiYCk7XG4gICAgcmV0dXJuIGY7XG59O1xuZnVuY3Rpb24gYWRkRm9ybWF0cyhhanYsIGxpc3QsIGZzLCBleHBvcnROYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBfYjtcbiAgICAoX2EgPSAoX2IgPSBhanYub3B0cy5jb2RlKS5mb3JtYXRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2IuZm9ybWF0cyA9IGNvZGVnZW5fMS5fIGByZXF1aXJlKFwiYWp2LWZvcm1hdHMvZGlzdC9mb3JtYXRzXCIpLiR7ZXhwb3J0TmFtZX1gKTtcbiAgICBmb3IgKGNvbnN0IGYgb2YgbGlzdClcbiAgICAgICAgYWp2LmFkZEZvcm1hdChmLCBmc1tmXSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmb3JtYXRzUGx1Z2luO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZm9ybWF0c1BsdWdpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY29weVByb3BlcnR5ID0gKHRvLCBmcm9tLCBwcm9wZXJ0eSwgaWdub3JlTm9uQ29uZmlndXJhYmxlKSA9PiB7XG5cdC8vIGBGdW5jdGlvbiNsZW5ndGhgIHNob3VsZCByZWZsZWN0IHRoZSBwYXJhbWV0ZXJzIG9mIGB0b2Agbm90IGBmcm9tYCBzaW5jZSB3ZSBrZWVwIGl0cyBib2R5LlxuXHQvLyBgRnVuY3Rpb24jcHJvdG90eXBlYCBpcyBub24td3JpdGFibGUgYW5kIG5vbi1jb25maWd1cmFibGUgc28gY2FuIG5ldmVyIGJlIG1vZGlmaWVkLlxuXHRpZiAocHJvcGVydHkgPT09ICdsZW5ndGgnIHx8IHByb3BlcnR5ID09PSAncHJvdG90eXBlJykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIGBGdW5jdGlvbiNhcmd1bWVudHNgIGFuZCBgRnVuY3Rpb24jY2FsbGVyYCBzaG91bGQgbm90IGJlIGNvcGllZC4gVGhleSB3ZXJlIHJlcG9ydGVkIHRvIGJlIHByZXNlbnQgaW4gYFJlZmxlY3Qub3duS2V5c2AgZm9yIHNvbWUgZGV2aWNlcyBpbiBSZWFjdCBOYXRpdmUgKCM0MSksIHNvIHdlIGV4cGxpY2l0bHkgaWdub3JlIHRoZW0gaGVyZS5cblx0aWYgKHByb3BlcnR5ID09PSAnYXJndW1lbnRzJyB8fCBwcm9wZXJ0eSA9PT0gJ2NhbGxlcicpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCB0b0Rlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvLCBwcm9wZXJ0eSk7XG5cdGNvbnN0IGZyb21EZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihmcm9tLCBwcm9wZXJ0eSk7XG5cblx0aWYgKCFjYW5Db3B5UHJvcGVydHkodG9EZXNjcmlwdG9yLCBmcm9tRGVzY3JpcHRvcikgJiYgaWdub3JlTm9uQ29uZmlndXJhYmxlKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCBwcm9wZXJ0eSwgZnJvbURlc2NyaXB0b3IpO1xufTtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpYCB0aHJvd3MgaWYgdGhlIHByb3BlcnR5IGV4aXN0cywgaXMgbm90IGNvbmZpZ3VyYWJsZSBhbmQgZWl0aGVyOlxuLy8gIC0gb25lIGl0cyBkZXNjcmlwdG9ycyBpcyBjaGFuZ2VkXG4vLyAgLSBpdCBpcyBub24td3JpdGFibGUgYW5kIGl0cyB2YWx1ZSBpcyBjaGFuZ2VkXG5jb25zdCBjYW5Db3B5UHJvcGVydHkgPSBmdW5jdGlvbiAodG9EZXNjcmlwdG9yLCBmcm9tRGVzY3JpcHRvcikge1xuXHRyZXR1cm4gdG9EZXNjcmlwdG9yID09PSB1bmRlZmluZWQgfHwgdG9EZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSB8fCAoXG5cdFx0dG9EZXNjcmlwdG9yLndyaXRhYmxlID09PSBmcm9tRGVzY3JpcHRvci53cml0YWJsZSAmJlxuXHRcdHRvRGVzY3JpcHRvci5lbnVtZXJhYmxlID09PSBmcm9tRGVzY3JpcHRvci5lbnVtZXJhYmxlICYmXG5cdFx0dG9EZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9PT0gZnJvbURlc2NyaXB0b3IuY29uZmlndXJhYmxlICYmXG5cdFx0KHRvRGVzY3JpcHRvci53cml0YWJsZSB8fCB0b0Rlc2NyaXB0b3IudmFsdWUgPT09IGZyb21EZXNjcmlwdG9yLnZhbHVlKVxuXHQpO1xufTtcblxuY29uc3QgY2hhbmdlUHJvdG90eXBlID0gKHRvLCBmcm9tKSA9PiB7XG5cdGNvbnN0IGZyb21Qcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnJvbSk7XG5cdGlmIChmcm9tUHJvdG90eXBlID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodG8pKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0T2JqZWN0LnNldFByb3RvdHlwZU9mKHRvLCBmcm9tUHJvdG90eXBlKTtcbn07XG5cbmNvbnN0IHdyYXBwZWRUb1N0cmluZyA9ICh3aXRoTmFtZSwgZnJvbUJvZHkpID0+IGAvKiBXcmFwcGVkICR7d2l0aE5hbWV9Ki9cXG4ke2Zyb21Cb2R5fWA7XG5cbmNvbnN0IHRvU3RyaW5nRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRnVuY3Rpb24ucHJvdG90eXBlLCAndG9TdHJpbmcnKTtcbmNvbnN0IHRvU3RyaW5nTmFtZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLCAnbmFtZScpO1xuXG4vLyBXZSBjYWxsIGBmcm9tLnRvU3RyaW5nKClgIGVhcmx5IChub3QgbGF6aWx5KSB0byBlbnN1cmUgYGZyb21gIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cbi8vIFdlIHVzZSBgYmluZCgpYCBpbnN0ZWFkIG9mIGEgY2xvc3VyZSBmb3IgdGhlIHNhbWUgcmVhc29uLlxuLy8gQ2FsbGluZyBgZnJvbS50b1N0cmluZygpYCBlYXJseSBhbHNvIGFsbG93cyBjYWNoaW5nIGl0IGluIGNhc2UgYHRvLnRvU3RyaW5nKClgIGlzIGNhbGxlZCBzZXZlcmFsIHRpbWVzLlxuY29uc3QgY2hhbmdlVG9TdHJpbmcgPSAodG8sIGZyb20sIG5hbWUpID0+IHtcblx0Y29uc3Qgd2l0aE5hbWUgPSBuYW1lID09PSAnJyA/ICcnIDogYHdpdGggJHtuYW1lLnRyaW0oKX0oKSBgO1xuXHRjb25zdCBuZXdUb1N0cmluZyA9IHdyYXBwZWRUb1N0cmluZy5iaW5kKG51bGwsIHdpdGhOYW1lLCBmcm9tLnRvU3RyaW5nKCkpO1xuXHQvLyBFbnN1cmUgYHRvLnRvU3RyaW5nLnRvU3RyaW5nYCBpcyBub24tZW51bWVyYWJsZSBhbmQgaGFzIHRoZSBzYW1lIGBzYW1lYFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3VG9TdHJpbmcsICduYW1lJywgdG9TdHJpbmdOYW1lKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCAndG9TdHJpbmcnLCB7Li4udG9TdHJpbmdEZXNjcmlwdG9yLCB2YWx1ZTogbmV3VG9TdHJpbmd9KTtcbn07XG5cbmNvbnN0IG1pbWljRm4gPSAodG8sIGZyb20sIHtpZ25vcmVOb25Db25maWd1cmFibGUgPSBmYWxzZX0gPSB7fSkgPT4ge1xuXHRjb25zdCB7bmFtZX0gPSB0bztcblxuXHRmb3IgKGNvbnN0IHByb3BlcnR5IG9mIFJlZmxlY3Qub3duS2V5cyhmcm9tKSkge1xuXHRcdGNvcHlQcm9wZXJ0eSh0bywgZnJvbSwgcHJvcGVydHksIGlnbm9yZU5vbkNvbmZpZ3VyYWJsZSk7XG5cdH1cblxuXHRjaGFuZ2VQcm90b3R5cGUodG8sIGZyb20pO1xuXHRjaGFuZ2VUb1N0cmluZyh0bywgZnJvbSwgbmFtZSk7XG5cblx0cmV0dXJuIHRvO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtaW1pY0ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgbWltaWNGbiA9IHJlcXVpcmUoJ21pbWljLWZuJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGlucHV0RnVuY3Rpb24sIG9wdGlvbnMgPSB7fSkgPT4ge1xuXHRpZiAodHlwZW9mIGlucHV0RnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiwgZ290IFxcYCR7dHlwZW9mIGlucHV0RnVuY3Rpb259XFxgYCk7XG5cdH1cblxuXHRjb25zdCB7XG5cdFx0d2FpdCA9IDAsXG5cdFx0YmVmb3JlID0gZmFsc2UsXG5cdFx0YWZ0ZXIgPSB0cnVlXG5cdH0gPSBvcHRpb25zO1xuXG5cdGlmICghYmVmb3JlICYmICFhZnRlcikge1xuXHRcdHRocm93IG5ldyBFcnJvcignQm90aCBgYmVmb3JlYCBhbmQgYGFmdGVyYCBhcmUgZmFsc2UsIGZ1bmN0aW9uIHdvdWxkblxcJ3QgYmUgY2FsbGVkLicpO1xuXHR9XG5cblx0bGV0IHRpbWVvdXQ7XG5cdGxldCByZXN1bHQ7XG5cblx0Y29uc3QgZGVib3VuY2VkRnVuY3Rpb24gPSBmdW5jdGlvbiAoLi4uYXJndW1lbnRzXykge1xuXHRcdGNvbnN0IGNvbnRleHQgPSB0aGlzO1xuXG5cdFx0Y29uc3QgbGF0ZXIgPSAoKSA9PiB7XG5cdFx0XHR0aW1lb3V0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoYWZ0ZXIpIHtcblx0XHRcdFx0cmVzdWx0ID0gaW5wdXRGdW5jdGlvbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHNfKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Y29uc3Qgc2hvdWxkQ2FsbE5vdyA9IGJlZm9yZSAmJiAhdGltZW91dDtcblx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0dGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuXG5cdFx0aWYgKHNob3VsZENhbGxOb3cpIHtcblx0XHRcdHJlc3VsdCA9IGlucHV0RnVuY3Rpb24uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzXyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRtaW1pY0ZuKGRlYm91bmNlZEZ1bmN0aW9uLCBpbnB1dEZ1bmN0aW9uKTtcblxuXHRkZWJvdW5jZWRGdW5jdGlvbi5jYW5jZWwgPSAoKSA9PiB7XG5cdFx0aWYgKHRpbWVvdXQpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHRcdHRpbWVvdXQgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBkZWJvdW5jZWRGdW5jdGlvbjtcbn07XG4iLCIvLyBOb3RlOiB0aGlzIGlzIHRoZSBzZW12ZXIub3JnIHZlcnNpb24gb2YgdGhlIHNwZWMgdGhhdCBpdCBpbXBsZW1lbnRzXG4vLyBOb3QgbmVjZXNzYXJpbHkgdGhlIHBhY2thZ2UgdmVyc2lvbiBvZiB0aGlzIGNvZGUuXG5jb25zdCBTRU1WRVJfU1BFQ19WRVJTSU9OID0gJzIuMC4wJ1xuXG5jb25zdCBNQVhfTEVOR1RIID0gMjU2XG5jb25zdCBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHxcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gOTAwNzE5OTI1NDc0MDk5MVxuXG4vLyBNYXggc2FmZSBzZWdtZW50IGxlbmd0aCBmb3IgY29lcmNpb24uXG5jb25zdCBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIID0gMTZcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFNFTVZFUl9TUEVDX1ZFUlNJT04sXG4gIE1BWF9MRU5HVEgsXG4gIE1BWF9TQUZFX0lOVEVHRVIsXG4gIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEhcbn1cbiIsImNvbnN0IGRlYnVnID0gKFxuICB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiZcbiAgcHJvY2Vzcy5lbnYgJiZcbiAgcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyAmJlxuICAvXFxic2VtdmVyXFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKVxuKSA/ICguLi5hcmdzKSA9PiBjb25zb2xlLmVycm9yKCdTRU1WRVInLCAuLi5hcmdzKVxuICA6ICgpID0+IHt9XG5cbm1vZHVsZS5leHBvcnRzID0gZGVidWdcbiIsImNvbnN0IHsgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuL2RlYnVnJylcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9XG5cbi8vIFRoZSBhY3R1YWwgcmVnZXhwcyBnbyBvbiBleHBvcnRzLnJlXG5jb25zdCByZSA9IGV4cG9ydHMucmUgPSBbXVxuY29uc3Qgc3JjID0gZXhwb3J0cy5zcmMgPSBbXVxuY29uc3QgdCA9IGV4cG9ydHMudCA9IHt9XG5sZXQgUiA9IDBcblxuY29uc3QgY3JlYXRlVG9rZW4gPSAobmFtZSwgdmFsdWUsIGlzR2xvYmFsKSA9PiB7XG4gIGNvbnN0IGluZGV4ID0gUisrXG4gIGRlYnVnKGluZGV4LCB2YWx1ZSlcbiAgdFtuYW1lXSA9IGluZGV4XG4gIHNyY1tpbmRleF0gPSB2YWx1ZVxuICByZVtpbmRleF0gPSBuZXcgUmVnRXhwKHZhbHVlLCBpc0dsb2JhbCA/ICdnJyA6IHVuZGVmaW5lZClcbn1cblxuLy8gVGhlIGZvbGxvd2luZyBSZWd1bGFyIEV4cHJlc3Npb25zIGNhbiBiZSB1c2VkIGZvciB0b2tlbml6aW5nLFxuLy8gdmFsaWRhdGluZywgYW5kIHBhcnNpbmcgU2VtVmVyIHZlcnNpb24gc3RyaW5ncy5cblxuLy8gIyMgTnVtZXJpYyBJZGVudGlmaWVyXG4vLyBBIHNpbmdsZSBgMGAsIG9yIGEgbm9uLXplcm8gZGlnaXQgZm9sbG93ZWQgYnkgemVybyBvciBtb3JlIGRpZ2l0cy5cblxuY3JlYXRlVG9rZW4oJ05VTUVSSUNJREVOVElGSUVSJywgJzB8WzEtOV1cXFxcZConKVxuY3JlYXRlVG9rZW4oJ05VTUVSSUNJREVOVElGSUVSTE9PU0UnLCAnWzAtOV0rJylcblxuLy8gIyMgTm9uLW51bWVyaWMgSWRlbnRpZmllclxuLy8gWmVybyBvciBtb3JlIGRpZ2l0cywgZm9sbG93ZWQgYnkgYSBsZXR0ZXIgb3IgaHlwaGVuLCBhbmQgdGhlbiB6ZXJvIG9yXG4vLyBtb3JlIGxldHRlcnMsIGRpZ2l0cywgb3IgaHlwaGVucy5cblxuY3JlYXRlVG9rZW4oJ05PTk5VTUVSSUNJREVOVElGSUVSJywgJ1xcXFxkKlthLXpBLVotXVthLXpBLVowLTktXSonKVxuXG4vLyAjIyBNYWluIFZlcnNpb25cbi8vIFRocmVlIGRvdC1zZXBhcmF0ZWQgbnVtZXJpYyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ01BSU5WRVJTSU9OJywgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KWApXG5cbmNyZWF0ZVRva2VuKCdNQUlOVkVSU0lPTkxPT1NFJywgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlgKVxuXG4vLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uIElkZW50aWZpZXJcbi8vIEEgbnVtZXJpYyBpZGVudGlmaWVyLCBvciBhIG5vbi1udW1lcmljIGlkZW50aWZpZXIuXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFSURFTlRJRklFUicsIGAoPzoke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXVxufXwke3NyY1t0Lk5PTk5VTUVSSUNJREVOVElGSUVSXX0pYClcblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0VJREVOVElGSUVSTE9PU0UnLCBgKD86JHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXVxufXwke3NyY1t0Lk5PTk5VTUVSSUNJREVOVElGSUVSXX0pYClcblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvblxuLy8gSHlwaGVuLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBkb3Qtc2VwYXJhdGVkIHByZS1yZWxlYXNlIHZlcnNpb25cbi8vIGlkZW50aWZpZXJzLlxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRScsIGAoPzotKCR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJdXG59KD86XFxcXC4ke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSXX0pKikpYClcblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0VMT09TRScsIGAoPzotPygke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdXG59KD86XFxcXC4ke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdfSkqKSlgKVxuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YSBJZGVudGlmaWVyXG4vLyBBbnkgY29tYmluYXRpb24gb2YgZGlnaXRzLCBsZXR0ZXJzLCBvciBoeXBoZW5zLlxuXG5jcmVhdGVUb2tlbignQlVJTERJREVOVElGSUVSJywgJ1swLTlBLVphLXotXSsnKVxuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YVxuLy8gUGx1cyBzaWduLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBwZXJpb2Qtc2VwYXJhdGVkIGJ1aWxkIG1ldGFkYXRhXG4vLyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ0JVSUxEJywgYCg/OlxcXFwrKCR7c3JjW3QuQlVJTERJREVOVElGSUVSXVxufSg/OlxcXFwuJHtzcmNbdC5CVUlMRElERU5USUZJRVJdfSkqKSlgKVxuXG4vLyAjIyBGdWxsIFZlcnNpb24gU3RyaW5nXG4vLyBBIG1haW4gdmVyc2lvbiwgZm9sbG93ZWQgb3B0aW9uYWxseSBieSBhIHByZS1yZWxlYXNlIHZlcnNpb24gYW5kXG4vLyBidWlsZCBtZXRhZGF0YS5cblxuLy8gTm90ZSB0aGF0IHRoZSBvbmx5IG1ham9yLCBtaW5vciwgcGF0Y2gsIGFuZCBwcmUtcmVsZWFzZSBzZWN0aW9ucyBvZlxuLy8gdGhlIHZlcnNpb24gc3RyaW5nIGFyZSBjYXB0dXJpbmcgZ3JvdXBzLiAgVGhlIGJ1aWxkIG1ldGFkYXRhIGlzIG5vdCBhXG4vLyBjYXB0dXJpbmcgZ3JvdXAsIGJlY2F1c2UgaXQgc2hvdWxkIG5vdCBldmVyIGJlIHVzZWQgaW4gdmVyc2lvblxuLy8gY29tcGFyaXNvbi5cblxuY3JlYXRlVG9rZW4oJ0ZVTExQTEFJTicsIGB2PyR7c3JjW3QuTUFJTlZFUlNJT05dXG59JHtzcmNbdC5QUkVSRUxFQVNFXX0/JHtcbiAgc3JjW3QuQlVJTERdfT9gKVxuXG5jcmVhdGVUb2tlbignRlVMTCcsIGBeJHtzcmNbdC5GVUxMUExBSU5dfSRgKVxuXG4vLyBsaWtlIGZ1bGwsIGJ1dCBhbGxvd3MgdjEuMi4zIGFuZCA9MS4yLjMsIHdoaWNoIHBlb3BsZSBkbyBzb21ldGltZXMuXG4vLyBhbHNvLCAxLjAuMGFscGhhMSAocHJlcmVsZWFzZSB3aXRob3V0IHRoZSBoeXBoZW4pIHdoaWNoIGlzIHByZXR0eVxuLy8gY29tbW9uIGluIHRoZSBucG0gcmVnaXN0cnkuXG5jcmVhdGVUb2tlbignTE9PU0VQTEFJTicsIGBbdj1cXFxcc10qJHtzcmNbdC5NQUlOVkVSU0lPTkxPT1NFXVxufSR7c3JjW3QuUFJFUkVMRUFTRUxPT1NFXX0/JHtcbiAgc3JjW3QuQlVJTERdfT9gKVxuXG5jcmVhdGVUb2tlbignTE9PU0UnLCBgXiR7c3JjW3QuTE9PU0VQTEFJTl19JGApXG5cbmNyZWF0ZVRva2VuKCdHVExUJywgJygoPzo8fD4pPz0/KScpXG5cbi8vIFNvbWV0aGluZyBsaWtlIFwiMi4qXCIgb3IgXCIxLjIueFwiLlxuLy8gTm90ZSB0aGF0IFwieC54XCIgaXMgYSB2YWxpZCB4UmFuZ2UgaWRlbnRpZmVyLCBtZWFuaW5nIFwiYW55IHZlcnNpb25cIlxuLy8gT25seSB0aGUgZmlyc3QgaXRlbSBpcyBzdHJpY3RseSByZXF1aXJlZC5cbmNyZWF0ZVRva2VuKCdYUkFOR0VJREVOVElGSUVSTE9PU0UnLCBgJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX18eHxYfFxcXFwqYClcbmNyZWF0ZVRva2VuKCdYUkFOR0VJREVOVElGSUVSJywgYCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfXx4fFh8XFxcXCpgKVxuXG5jcmVhdGVUb2tlbignWFJBTkdFUExBSU4nLCBgW3Y9XFxcXHNdKigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJdfSlgICtcbiAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGAoPzoke3NyY1t0LlBSRVJFTEVBU0VdfSk/JHtcbiAgICAgICAgICAgICAgICAgICAgIHNyY1t0LkJVSUxEXX0/YCArXG4gICAgICAgICAgICAgICAgICAgYCk/KT9gKVxuXG5jcmVhdGVUb2tlbignWFJBTkdFUExBSU5MT09TRScsIGBbdj1cXFxcc10qKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCg/OiR7c3JjW3QuUFJFUkVMRUFTRUxPT1NFXX0pPyR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1t0LkJVSUxEXX0/YCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKT8pP2ApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqJHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignWFJBTkdFTE9PU0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqJHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQ29lcmNpb24uXG4vLyBFeHRyYWN0IGFueXRoaW5nIHRoYXQgY291bGQgY29uY2VpdmFibHkgYmUgYSBwYXJ0IG9mIGEgdmFsaWQgc2VtdmVyXG5jcmVhdGVUb2tlbignQ09FUkNFJywgYCR7JyhefFteXFxcXGRdKScgK1xuICAgICAgICAgICAgICAnKFxcXFxkezEsJ30ke01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEh9fSlgICtcbiAgICAgICAgICAgICAgYCg/OlxcXFwuKFxcXFxkezEsJHtNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIfX0pKT9gICtcbiAgICAgICAgICAgICAgYCg/OlxcXFwuKFxcXFxkezEsJHtNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIfX0pKT9gICtcbiAgICAgICAgICAgICAgYCg/OiR8W15cXFxcZF0pYClcbmNyZWF0ZVRva2VuKCdDT0VSQ0VSVEwnLCBzcmNbdC5DT0VSQ0VdLCB0cnVlKVxuXG4vLyBUaWxkZSByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwicmVhc29uYWJseSBhdCBvciBncmVhdGVyIHRoYW5cIlxuY3JlYXRlVG9rZW4oJ0xPTkVUSUxERScsICcoPzp+Pj8pJylcblxuY3JlYXRlVG9rZW4oJ1RJTERFVFJJTScsIGAoXFxcXHMqKSR7c3JjW3QuTE9ORVRJTERFXX1cXFxccytgLCB0cnVlKVxuZXhwb3J0cy50aWxkZVRyaW1SZXBsYWNlID0gJyQxfidcblxuY3JlYXRlVG9rZW4oJ1RJTERFJywgYF4ke3NyY1t0LkxPTkVUSUxERV19JHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignVElMREVMT09TRScsIGBeJHtzcmNbdC5MT05FVElMREVdfSR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19JGApXG5cbi8vIENhcmV0IHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJhdCBsZWFzdCBhbmQgYmFja3dhcmRzIGNvbXBhdGlibGUgd2l0aFwiXG5jcmVhdGVUb2tlbignTE9ORUNBUkVUJywgJyg/OlxcXFxeKScpXG5cbmNyZWF0ZVRva2VuKCdDQVJFVFRSSU0nLCBgKFxcXFxzKikke3NyY1t0LkxPTkVDQVJFVF19XFxcXHMrYCwgdHJ1ZSlcbmV4cG9ydHMuY2FyZXRUcmltUmVwbGFjZSA9ICckMV4nXG5cbmNyZWF0ZVRva2VuKCdDQVJFVCcsIGBeJHtzcmNbdC5MT05FQ0FSRVRdfSR7c3JjW3QuWFJBTkdFUExBSU5dfSRgKVxuY3JlYXRlVG9rZW4oJ0NBUkVUTE9PU0UnLCBgXiR7c3JjW3QuTE9ORUNBUkVUXX0ke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKVxuXG4vLyBBIHNpbXBsZSBndC9sdC9lcSB0aGluZywgb3IganVzdCBcIlwiIHRvIGluZGljYXRlIFwiYW55IHZlcnNpb25cIlxuY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1JMT09TRScsIGBeJHtzcmNbdC5HVExUXX1cXFxccyooJHtzcmNbdC5MT09TRVBMQUlOXX0pJHxeJGApXG5jcmVhdGVUb2tlbignQ09NUEFSQVRPUicsIGBeJHtzcmNbdC5HVExUXX1cXFxccyooJHtzcmNbdC5GVUxMUExBSU5dfSkkfF4kYClcblxuLy8gQW4gZXhwcmVzc2lvbiB0byBzdHJpcCBhbnkgd2hpdGVzcGFjZSBiZXR3ZWVuIHRoZSBndGx0IGFuZCB0aGUgdGhpbmdcbi8vIGl0IG1vZGlmaWVzLCBzbyB0aGF0IGA+IDEuMi4zYCA9PT4gYD4xLjIuM2BcbmNyZWF0ZVRva2VuKCdDT01QQVJBVE9SVFJJTScsIGAoXFxcXHMqKSR7c3JjW3QuR1RMVF1cbn1cXFxccyooJHtzcmNbdC5MT09TRVBMQUlOXX18JHtzcmNbdC5YUkFOR0VQTEFJTl19KWAsIHRydWUpXG5leHBvcnRzLmNvbXBhcmF0b3JUcmltUmVwbGFjZSA9ICckMSQyJDMnXG5cbi8vIFNvbWV0aGluZyBsaWtlIGAxLjIuMyAtIDEuMi40YFxuLy8gTm90ZSB0aGF0IHRoZXNlIGFsbCB1c2UgdGhlIGxvb3NlIGZvcm0sIGJlY2F1c2UgdGhleSdsbCBiZVxuLy8gY2hlY2tlZCBhZ2FpbnN0IGVpdGhlciB0aGUgc3RyaWN0IG9yIGxvb3NlIGNvbXBhcmF0b3IgZm9ybVxuLy8gbGF0ZXIuXG5jcmVhdGVUb2tlbignSFlQSEVOUkFOR0UnLCBgXlxcXFxzKigke3NyY1t0LlhSQU5HRVBMQUlOXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYFxcXFxzKy1cXFxccytgICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuWFJBTkdFUExBSU5dfSlgICtcbiAgICAgICAgICAgICAgICAgICBgXFxcXHMqJGApXG5cbmNyZWF0ZVRva2VuKCdIWVBIRU5SQU5HRUxPT1NFJywgYF5cXFxccyooJHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgXFxcXHMrLVxcXFxzK2AgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCgke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcXFxccyokYClcblxuLy8gU3RhciByYW5nZXMgYmFzaWNhbGx5IGp1c3QgYWxsb3cgYW55dGhpbmcgYXQgYWxsLlxuY3JlYXRlVG9rZW4oJ1NUQVInLCAnKDx8Pik/PT9cXFxccypcXFxcKicpXG4vLyA+PTAuMC4wIGlzIGxpa2UgYSBzdGFyXG5jcmVhdGVUb2tlbignR1RFMCcsICdeXFxcXHMqPj1cXFxccyowXFwuMFxcLjBcXFxccyokJylcbmNyZWF0ZVRva2VuKCdHVEUwUFJFJywgJ15cXFxccyo+PVxcXFxzKjBcXC4wXFwuMC0wXFxcXHMqJCcpXG4iLCIvLyBwYXJzZSBvdXQganVzdCB0aGUgb3B0aW9ucyB3ZSBjYXJlIGFib3V0IHNvIHdlIGFsd2F5cyBnZXQgYSBjb25zaXN0ZW50XG4vLyBvYmogd2l0aCBrZXlzIGluIGEgY29uc2lzdGVudCBvcmRlci5cbmNvbnN0IG9wdHMgPSBbJ2luY2x1ZGVQcmVyZWxlYXNlJywgJ2xvb3NlJywgJ3J0bCddXG5jb25zdCBwYXJzZU9wdGlvbnMgPSBvcHRpb25zID0+XG4gICFvcHRpb25zID8ge31cbiAgOiB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgPyB7IGxvb3NlOiB0cnVlIH1cbiAgOiBvcHRzLmZpbHRlcihrID0+IG9wdGlvbnNba10pLnJlZHVjZSgob3B0aW9ucywgaykgPT4ge1xuICAgIG9wdGlvbnNba10gPSB0cnVlXG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfSwge30pXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlT3B0aW9uc1xuIiwiY29uc3QgbnVtZXJpYyA9IC9eWzAtOV0rJC9cbmNvbnN0IGNvbXBhcmVJZGVudGlmaWVycyA9IChhLCBiKSA9PiB7XG4gIGNvbnN0IGFudW0gPSBudW1lcmljLnRlc3QoYSlcbiAgY29uc3QgYm51bSA9IG51bWVyaWMudGVzdChiKVxuXG4gIGlmIChhbnVtICYmIGJudW0pIHtcbiAgICBhID0gK2FcbiAgICBiID0gK2JcbiAgfVxuXG4gIHJldHVybiBhID09PSBiID8gMFxuICAgIDogKGFudW0gJiYgIWJudW0pID8gLTFcbiAgICA6IChibnVtICYmICFhbnVtKSA/IDFcbiAgICA6IGEgPCBiID8gLTFcbiAgICA6IDFcbn1cblxuY29uc3QgcmNvbXBhcmVJZGVudGlmaWVycyA9IChhLCBiKSA9PiBjb21wYXJlSWRlbnRpZmllcnMoYiwgYSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXBhcmVJZGVudGlmaWVycyxcbiAgcmNvbXBhcmVJZGVudGlmaWVyc1xufVxuIiwiY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCB7IE1BWF9MRU5HVEgsIE1BWF9TQUZFX0lOVEVHRVIgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NvbnN0YW50cycpXG5jb25zdCB7IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgeyBjb21wYXJlSWRlbnRpZmllcnMgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lkZW50aWZpZXJzJylcbmNsYXNzIFNlbVZlciB7XG4gIGNvbnN0cnVjdG9yICh2ZXJzaW9uLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICAgIGlmICh2ZXJzaW9uLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UgJiZcbiAgICAgICAgICB2ZXJzaW9uLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgICAgcmV0dXJuIHZlcnNpb25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnZlcnNpb25cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBWZXJzaW9uOiAke3ZlcnNpb259YClcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBgdmVyc2lvbiBpcyBsb25nZXIgdGhhbiAke01BWF9MRU5HVEh9IGNoYXJhY3RlcnNgXG4gICAgICApXG4gICAgfVxuXG4gICAgZGVidWcoJ1NlbVZlcicsIHZlcnNpb24sIG9wdGlvbnMpXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgICAvLyB0aGlzIGlzbid0IGFjdHVhbGx5IHJlbGV2YW50IGZvciB2ZXJzaW9ucywgYnV0IGtlZXAgaXQgc28gdGhhdCB3ZVxuICAgIC8vIGRvbid0IHJ1biBpbnRvIHRyb3VibGUgcGFzc2luZyB0aGlzLm9wdGlvbnMgYXJvdW5kLlxuICAgIHRoaXMuaW5jbHVkZVByZXJlbGVhc2UgPSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcblxuICAgIGNvbnN0IG0gPSB2ZXJzaW9uLnRyaW0oKS5tYXRjaChvcHRpb25zLmxvb3NlID8gcmVbdC5MT09TRV0gOiByZVt0LkZVTExdKVxuXG4gICAgaWYgKCFtKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFZlcnNpb246ICR7dmVyc2lvbn1gKVxuICAgIH1cblxuICAgIHRoaXMucmF3ID0gdmVyc2lvblxuXG4gICAgLy8gdGhlc2UgYXJlIGFjdHVhbGx5IG51bWJlcnNcbiAgICB0aGlzLm1ham9yID0gK21bMV1cbiAgICB0aGlzLm1pbm9yID0gK21bMl1cbiAgICB0aGlzLnBhdGNoID0gK21bM11cblxuICAgIGlmICh0aGlzLm1ham9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1ham9yIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWpvciB2ZXJzaW9uJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5taW5vciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5taW5vciA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWlub3IgdmVyc2lvbicpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGF0Y2ggPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMucGF0Y2ggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHBhdGNoIHZlcnNpb24nKVxuICAgIH1cblxuICAgIC8vIG51bWJlcmlmeSBhbnkgcHJlcmVsZWFzZSBudW1lcmljIGlkc1xuICAgIGlmICghbVs0XSkge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gbVs0XS5zcGxpdCgnLicpLm1hcCgoaWQpID0+IHtcbiAgICAgICAgaWYgKC9eWzAtOV0rJC8udGVzdChpZCkpIHtcbiAgICAgICAgICBjb25zdCBudW0gPSAraWRcbiAgICAgICAgICBpZiAobnVtID49IDAgJiYgbnVtIDwgTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgcmV0dXJuIG51bVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5idWlsZCA9IG1bNV0gPyBtWzVdLnNwbGl0KCcuJykgOiBbXVxuICAgIHRoaXMuZm9ybWF0KClcbiAgfVxuXG4gIGZvcm1hdCAoKSB7XG4gICAgdGhpcy52ZXJzaW9uID0gYCR7dGhpcy5tYWpvcn0uJHt0aGlzLm1pbm9yfS4ke3RoaXMucGF0Y2h9YFxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICB0aGlzLnZlcnNpb24gKz0gYC0ke3RoaXMucHJlcmVsZWFzZS5qb2luKCcuJyl9YFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy52ZXJzaW9uXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVyc2lvblxuICB9XG5cbiAgY29tcGFyZSAob3RoZXIpIHtcbiAgICBkZWJ1ZygnU2VtVmVyLmNvbXBhcmUnLCB0aGlzLnZlcnNpb24sIHRoaXMub3B0aW9ucywgb3RoZXIpXG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBpZiAodHlwZW9mIG90aGVyID09PSAnc3RyaW5nJyAmJiBvdGhlciA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICBpZiAob3RoZXIudmVyc2lvbiA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbXBhcmVNYWluKG90aGVyKSB8fCB0aGlzLmNvbXBhcmVQcmUob3RoZXIpXG4gIH1cblxuICBjb21wYXJlTWFpbiAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5tYWpvciwgb3RoZXIubWFqb3IpIHx8XG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5taW5vciwgb3RoZXIubWlub3IpIHx8XG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5wYXRjaCwgb3RoZXIucGF0Y2gpXG4gICAgKVxuICB9XG5cbiAgY29tcGFyZVByZSAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIC8vIE5PVCBoYXZpbmcgYSBwcmVyZWxlYXNlIGlzID4gaGF2aW5nIG9uZVxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfSBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiBvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICBsZXQgaSA9IDBcbiAgICBkbyB7XG4gICAgICBjb25zdCBhID0gdGhpcy5wcmVyZWxlYXNlW2ldXG4gICAgICBjb25zdCBiID0gb3RoZXIucHJlcmVsZWFzZVtpXVxuICAgICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgY29tcGFyZUJ1aWxkIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgbGV0IGkgPSAwXG4gICAgZG8ge1xuICAgICAgY29uc3QgYSA9IHRoaXMuYnVpbGRbaV1cbiAgICAgIGNvbnN0IGIgPSBvdGhlci5idWlsZFtpXVxuICAgICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgLy8gcHJlbWlub3Igd2lsbCBidW1wIHRoZSB2ZXJzaW9uIHVwIHRvIHRoZSBuZXh0IG1pbm9yIHJlbGVhc2UsIGFuZCBpbW1lZGlhdGVseVxuICAvLyBkb3duIHRvIHByZS1yZWxlYXNlLiBwcmVtYWpvciBhbmQgcHJlcGF0Y2ggd29yayB0aGUgc2FtZSB3YXkuXG4gIGluYyAocmVsZWFzZSwgaWRlbnRpZmllcikge1xuICAgIHN3aXRjaCAocmVsZWFzZSkge1xuICAgICAgY2FzZSAncHJlbWFqb3InOlxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLm1pbm9yID0gMFxuICAgICAgICB0aGlzLm1ham9yKytcbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwcmVtaW5vcic6XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMubWlub3IrK1xuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3ByZXBhdGNoJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhbHJlYWR5IGEgcHJlcmVsZWFzZSwgaXQgd2lsbCBidW1wIHRvIHRoZSBuZXh0IHZlcnNpb25cbiAgICAgICAgLy8gZHJvcCBhbnkgcHJlcmVsZWFzZXMgdGhhdCBtaWdodCBhbHJlYWR5IGV4aXN0LCBzaW5jZSB0aGV5IGFyZSBub3RcbiAgICAgICAgLy8gcmVsZXZhbnQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcilcbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpXG4gICAgICAgIGJyZWFrXG4gICAgICAvLyBJZiB0aGUgaW5wdXQgaXMgYSBub24tcHJlcmVsZWFzZSB2ZXJzaW9uLCB0aGlzIGFjdHMgdGhlIHNhbWUgYXNcbiAgICAgIC8vIHByZXBhdGNoLlxuICAgICAgY2FzZSAncHJlcmVsZWFzZSc6XG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcilcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnbWFqb3InOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1ham9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWFqb3IgdmVyc2lvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtYWpvci5cbiAgICAgICAgLy8gMS4wLjAtNSBidW1wcyB0byAxLjAuMFxuICAgICAgICAvLyAxLjEuMCBidW1wcyB0byAyLjAuMFxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5taW5vciAhPT0gMCB8fFxuICAgICAgICAgIHRoaXMucGF0Y2ggIT09IDAgfHxcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMubWFqb3IrK1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWlub3IgPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdtaW5vcic6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmUtbWlub3IgdmVyc2lvbiwgYnVtcCB1cCB0byB0aGUgc2FtZSBtaW5vciB2ZXJzaW9uLlxuICAgICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1pbm9yLlxuICAgICAgICAvLyAxLjIuMC01IGJ1bXBzIHRvIDEuMi4wXG4gICAgICAgIC8vIDEuMi4xIGJ1bXBzIHRvIDEuMy4wXG4gICAgICAgIGlmICh0aGlzLnBhdGNoICE9PSAwIHx8IHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLm1pbm9yKytcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncGF0Y2gnOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIG5vdCBhIHByZS1yZWxlYXNlIHZlcnNpb24sIGl0IHdpbGwgaW5jcmVtZW50IHRoZSBwYXRjaC5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSBwcmUtcmVsZWFzZSBpdCB3aWxsIGJ1bXAgdXAgdG8gdGhlIHNhbWUgcGF0Y2ggdmVyc2lvbi5cbiAgICAgICAgLy8gMS4yLjAtNSBwYXRjaGVzIHRvIDEuMi4wXG4gICAgICAgIC8vIDEuMi4wIHBhdGNoZXMgdG8gMS4yLjFcbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnBhdGNoKytcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgICAgICBicmVha1xuICAgICAgLy8gVGhpcyBwcm9iYWJseSBzaG91bGRuJ3QgYmUgdXNlZCBwdWJsaWNseS5cbiAgICAgIC8vIDEuMC4wICdwcmUnIHdvdWxkIGJlY29tZSAxLjAuMC0wIHdoaWNoIGlzIHRoZSB3cm9uZyBkaXJlY3Rpb24uXG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFswXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBpID0gdGhpcy5wcmVyZWxlYXNlLmxlbmd0aFxuICAgICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByZXJlbGVhc2VbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZVtpXSsrXG4gICAgICAgICAgICAgIGkgPSAtMlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGRpZG4ndCBpbmNyZW1lbnQgYW55dGhpbmdcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZS5wdXNoKDApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpZGVudGlmaWVyKSB7XG4gICAgICAgICAgLy8gMS4yLjAtYmV0YS4xIGJ1bXBzIHRvIDEuMi4wLWJldGEuMixcbiAgICAgICAgICAvLyAxLjIuMC1iZXRhLmZvb2JseiBvciAxLjIuMC1iZXRhIGJ1bXBzIHRvIDEuMi4wLWJldGEuMFxuICAgICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2VbMF0gPT09IGlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGlmIChpc05hTih0aGlzLnByZXJlbGVhc2VbMV0pKSB7XG4gICAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCAwXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgMF1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGluY3JlbWVudCBhcmd1bWVudDogJHtyZWxlYXNlfWApXG4gICAgfVxuICAgIHRoaXMuZm9ybWF0KClcbiAgICB0aGlzLnJhdyA9IHRoaXMudmVyc2lvblxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZW1WZXJcbiIsImNvbnN0IHtNQVhfTEVOR1RIfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NvbnN0YW50cycpXG5jb25zdCB7IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgcGFyc2UgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICByZXR1cm4gdmVyc2lvblxuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5MT09TRV0gOiByZVt0LkZVTExdXG4gIGlmICghci50ZXN0KHZlcnNpb24pKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VcbiIsImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCB2YWxpZCA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHYgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKVxuICByZXR1cm4gdiA/IHYudmVyc2lvbiA6IG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRcbiIsImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCBjbGVhbiA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHMgPSBwYXJzZSh2ZXJzaW9uLnRyaW0oKS5yZXBsYWNlKC9eWz12XSsvLCAnJyksIG9wdGlvbnMpXG4gIHJldHVybiBzID8gcy52ZXJzaW9uIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBjbGVhblxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuXG5jb25zdCBpbmMgPSAodmVyc2lvbiwgcmVsZWFzZSwgb3B0aW9ucywgaWRlbnRpZmllcikgPT4ge1xuICBpZiAodHlwZW9mIChvcHRpb25zKSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZGVudGlmaWVyID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWRcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucykuaW5jKHJlbGVhc2UsIGlkZW50aWZpZXIpLnZlcnNpb25cbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluY1xuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgY29tcGFyZSA9IChhLCBiLCBsb29zZSkgPT5cbiAgbmV3IFNlbVZlcihhLCBsb29zZSkuY29tcGFyZShuZXcgU2VtVmVyKGIsIGxvb3NlKSlcblxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGVxID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA9PT0gMFxubW9kdWxlLmV4cG9ydHMgPSBlcVxuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IGVxID0gcmVxdWlyZSgnLi9lcScpXG5cbmNvbnN0IGRpZmYgPSAodmVyc2lvbjEsIHZlcnNpb24yKSA9PiB7XG4gIGlmIChlcSh2ZXJzaW9uMSwgdmVyc2lvbjIpKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB2MSA9IHBhcnNlKHZlcnNpb24xKVxuICAgIGNvbnN0IHYyID0gcGFyc2UodmVyc2lvbjIpXG4gICAgY29uc3QgaGFzUHJlID0gdjEucHJlcmVsZWFzZS5sZW5ndGggfHwgdjIucHJlcmVsZWFzZS5sZW5ndGhcbiAgICBjb25zdCBwcmVmaXggPSBoYXNQcmUgPyAncHJlJyA6ICcnXG4gICAgY29uc3QgZGVmYXVsdFJlc3VsdCA9IGhhc1ByZSA/ICdwcmVyZWxlYXNlJyA6ICcnXG4gICAgZm9yIChjb25zdCBrZXkgaW4gdjEpIHtcbiAgICAgIGlmIChrZXkgPT09ICdtYWpvcicgfHwga2V5ID09PSAnbWlub3InIHx8IGtleSA9PT0gJ3BhdGNoJykge1xuICAgICAgICBpZiAodjFba2V5XSAhPT0gdjJba2V5XSkge1xuICAgICAgICAgIHJldHVybiBwcmVmaXggKyBrZXlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFJlc3VsdCAvLyBtYXkgYmUgdW5kZWZpbmVkXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gZGlmZlxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgbWFqb3IgPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1ham9yXG5tb2R1bGUuZXhwb3J0cyA9IG1ham9yXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBtaW5vciA9IChhLCBsb29zZSkgPT4gbmV3IFNlbVZlcihhLCBsb29zZSkubWlub3Jcbm1vZHVsZS5leHBvcnRzID0gbWlub3JcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IHBhdGNoID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5wYXRjaFxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaFxuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHByZXJlbGVhc2UgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBwYXJzZWQgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKVxuICByZXR1cm4gKHBhcnNlZCAmJiBwYXJzZWQucHJlcmVsZWFzZS5sZW5ndGgpID8gcGFyc2VkLnByZXJlbGVhc2UgOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IHByZXJlbGVhc2VcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgcmNvbXBhcmUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYiwgYSwgbG9vc2UpXG5tb2R1bGUuZXhwb3J0cyA9IHJjb21wYXJlXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGNvbXBhcmVMb29zZSA9IChhLCBiKSA9PiBjb21wYXJlKGEsIGIsIHRydWUpXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVMb29zZVxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgY29tcGFyZUJ1aWxkID0gKGEsIGIsIGxvb3NlKSA9PiB7XG4gIGNvbnN0IHZlcnNpb25BID0gbmV3IFNlbVZlcihhLCBsb29zZSlcbiAgY29uc3QgdmVyc2lvbkIgPSBuZXcgU2VtVmVyKGIsIGxvb3NlKVxuICByZXR1cm4gdmVyc2lvbkEuY29tcGFyZSh2ZXJzaW9uQikgfHwgdmVyc2lvbkEuY29tcGFyZUJ1aWxkKHZlcnNpb25CKVxufVxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlQnVpbGRcbiIsImNvbnN0IGNvbXBhcmVCdWlsZCA9IHJlcXVpcmUoJy4vY29tcGFyZS1idWlsZCcpXG5jb25zdCBzb3J0ID0gKGxpc3QsIGxvb3NlKSA9PiBsaXN0LnNvcnQoKGEsIGIpID0+IGNvbXBhcmVCdWlsZChhLCBiLCBsb29zZSkpXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnRcbiIsImNvbnN0IGNvbXBhcmVCdWlsZCA9IHJlcXVpcmUoJy4vY29tcGFyZS1idWlsZCcpXG5jb25zdCByc29ydCA9IChsaXN0LCBsb29zZSkgPT4gbGlzdC5zb3J0KChhLCBiKSA9PiBjb21wYXJlQnVpbGQoYiwgYSwgbG9vc2UpKVxubW9kdWxlLmV4cG9ydHMgPSByc29ydFxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBndCA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPiAwXG5tb2R1bGUuZXhwb3J0cyA9IGd0XG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGx0ID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8IDBcbm1vZHVsZS5leHBvcnRzID0gbHRcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbmVxID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSAhPT0gMFxubW9kdWxlLmV4cG9ydHMgPSBuZXFcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZ3RlID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGd0ZVxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBsdGUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpIDw9IDBcbm1vZHVsZS5leHBvcnRzID0gbHRlXG4iLCJjb25zdCBlcSA9IHJlcXVpcmUoJy4vZXEnKVxuY29uc3QgbmVxID0gcmVxdWlyZSgnLi9uZXEnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuL2d0JylcbmNvbnN0IGd0ZSA9IHJlcXVpcmUoJy4vZ3RlJylcbmNvbnN0IGx0ID0gcmVxdWlyZSgnLi9sdCcpXG5jb25zdCBsdGUgPSByZXF1aXJlKCcuL2x0ZScpXG5cbmNvbnN0IGNtcCA9IChhLCBvcCwgYiwgbG9vc2UpID0+IHtcbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgJz09PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKVxuICAgICAgICBhID0gYS52ZXJzaW9uXG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdvYmplY3QnKVxuICAgICAgICBiID0gYi52ZXJzaW9uXG4gICAgICByZXR1cm4gYSA9PT0gYlxuXG4gICAgY2FzZSAnIT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpXG4gICAgICAgIGEgPSBhLnZlcnNpb25cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpXG4gICAgICAgIGIgPSBiLnZlcnNpb25cbiAgICAgIHJldHVybiBhICE9PSBiXG5cbiAgICBjYXNlICcnOlxuICAgIGNhc2UgJz0nOlxuICAgIGNhc2UgJz09JzpcbiAgICAgIHJldHVybiBlcShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJyE9JzpcbiAgICAgIHJldHVybiBuZXEoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc+JzpcbiAgICAgIHJldHVybiBndChhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJz49JzpcbiAgICAgIHJldHVybiBndGUoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc8JzpcbiAgICAgIHJldHVybiBsdChhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJzw9JzpcbiAgICAgIHJldHVybiBsdGUoYSwgYiwgbG9vc2UpXG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBvcGVyYXRvcjogJHtvcH1gKVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGNtcFxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHtyZSwgdH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IGNvZXJjZSA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgcmV0dXJuIHZlcnNpb25cbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ251bWJlcicpIHtcbiAgICB2ZXJzaW9uID0gU3RyaW5nKHZlcnNpb24pXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgbGV0IG1hdGNoID0gbnVsbFxuICBpZiAoIW9wdGlvbnMucnRsKSB7XG4gICAgbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKHJlW3QuQ09FUkNFXSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5kIHRoZSByaWdodC1tb3N0IGNvZXJjaWJsZSBzdHJpbmcgdGhhdCBkb2VzIG5vdCBzaGFyZVxuICAgIC8vIGEgdGVybWludXMgd2l0aCBhIG1vcmUgbGVmdC13YXJkIGNvZXJjaWJsZSBzdHJpbmcuXG4gICAgLy8gRWcsICcxLjIuMy40JyB3YW50cyB0byBjb2VyY2UgJzIuMy40Jywgbm90ICczLjQnIG9yICc0J1xuICAgIC8vXG4gICAgLy8gV2FsayB0aHJvdWdoIHRoZSBzdHJpbmcgY2hlY2tpbmcgd2l0aCBhIC9nIHJlZ2V4cFxuICAgIC8vIE1hbnVhbGx5IHNldCB0aGUgaW5kZXggc28gYXMgdG8gcGljayB1cCBvdmVybGFwcGluZyBtYXRjaGVzLlxuICAgIC8vIFN0b3Agd2hlbiB3ZSBnZXQgYSBtYXRjaCB0aGF0IGVuZHMgYXQgdGhlIHN0cmluZyBlbmQsIHNpbmNlIG5vXG4gICAgLy8gY29lcmNpYmxlIHN0cmluZyBjYW4gYmUgbW9yZSByaWdodC13YXJkIHdpdGhvdXQgdGhlIHNhbWUgdGVybWludXMuXG4gICAgbGV0IG5leHRcbiAgICB3aGlsZSAoKG5leHQgPSByZVt0LkNPRVJDRVJUTF0uZXhlYyh2ZXJzaW9uKSkgJiZcbiAgICAgICAgKCFtYXRjaCB8fCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCAhPT0gdmVyc2lvbi5sZW5ndGgpXG4gICAgKSB7XG4gICAgICBpZiAoIW1hdGNoIHx8XG4gICAgICAgICAgICBuZXh0LmluZGV4ICsgbmV4dFswXS5sZW5ndGggIT09IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSB7XG4gICAgICAgIG1hdGNoID0gbmV4dFxuICAgICAgfVxuICAgICAgcmVbdC5DT0VSQ0VSVExdLmxhc3RJbmRleCA9IG5leHQuaW5kZXggKyBuZXh0WzFdLmxlbmd0aCArIG5leHRbMl0ubGVuZ3RoXG4gICAgfVxuICAgIC8vIGxlYXZlIGl0IGluIGEgY2xlYW4gc3RhdGVcbiAgICByZVt0LkNPRVJDRVJUTF0ubGFzdEluZGV4ID0gLTFcbiAgfVxuXG4gIGlmIChtYXRjaCA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbFxuXG4gIHJldHVybiBwYXJzZShgJHttYXRjaFsyXX0uJHttYXRjaFszXSB8fCAnMCd9LiR7bWF0Y2hbNF0gfHwgJzAnfWAsIG9wdGlvbnMpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGNvZXJjZVxuIiwiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChZYWxsaXN0KSB7XG4gIFlhbGxpc3QucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiogKCkge1xuICAgIGZvciAobGV0IHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyOyB3YWxrZXIgPSB3YWxrZXIubmV4dCkge1xuICAgICAgeWllbGQgd2Fsa2VyLnZhbHVlXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcbm1vZHVsZS5leHBvcnRzID0gWWFsbGlzdFxuXG5ZYWxsaXN0Lk5vZGUgPSBOb2RlXG5ZYWxsaXN0LmNyZWF0ZSA9IFlhbGxpc3RcblxuZnVuY3Rpb24gWWFsbGlzdCAobGlzdCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIFlhbGxpc3QpKSB7XG4gICAgc2VsZiA9IG5ldyBZYWxsaXN0KClcbiAgfVxuXG4gIHNlbGYudGFpbCA9IG51bGxcbiAgc2VsZi5oZWFkID0gbnVsbFxuICBzZWxmLmxlbmd0aCA9IDBcblxuICBpZiAobGlzdCAmJiB0eXBlb2YgbGlzdC5mb3JFYWNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBzZWxmLnB1c2goaXRlbSlcbiAgICB9KVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBzZWxmLnB1c2goYXJndW1lbnRzW2ldKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJlbW92ZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZS5saXN0ICE9PSB0aGlzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmluZyBub2RlIHdoaWNoIGRvZXMgbm90IGJlbG9uZyB0byB0aGlzIGxpc3QnKVxuICB9XG5cbiAgdmFyIG5leHQgPSBub2RlLm5leHRcbiAgdmFyIHByZXYgPSBub2RlLnByZXZcblxuICBpZiAobmV4dCkge1xuICAgIG5leHQucHJldiA9IHByZXZcbiAgfVxuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5uZXh0ID0gbmV4dFxuICB9XG5cbiAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5leHRcbiAgfVxuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsID0gcHJldlxuICB9XG5cbiAgbm9kZS5saXN0Lmxlbmd0aC0tXG4gIG5vZGUubmV4dCA9IG51bGxcbiAgbm9kZS5wcmV2ID0gbnVsbFxuICBub2RlLmxpc3QgPSBudWxsXG5cbiAgcmV0dXJuIG5leHRcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAobm9kZS5saXN0KSB7XG4gICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSlcbiAgfVxuXG4gIHZhciBoZWFkID0gdGhpcy5oZWFkXG4gIG5vZGUubGlzdCA9IHRoaXNcbiAgbm9kZS5uZXh0ID0gaGVhZFxuICBpZiAoaGVhZCkge1xuICAgIGhlYWQucHJldiA9IG5vZGVcbiAgfVxuXG4gIHRoaXMuaGVhZCA9IG5vZGVcbiAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwgPSBub2RlXG4gIH1cbiAgdGhpcy5sZW5ndGgrK1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wdXNoTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChub2RlLmxpc3QpIHtcbiAgICBub2RlLmxpc3QucmVtb3ZlTm9kZShub2RlKVxuICB9XG5cbiAgdmFyIHRhaWwgPSB0aGlzLnRhaWxcbiAgbm9kZS5saXN0ID0gdGhpc1xuICBub2RlLnByZXYgPSB0YWlsXG4gIGlmICh0YWlsKSB7XG4gICAgdGFpbC5uZXh0ID0gbm9kZVxuICB9XG5cbiAgdGhpcy50YWlsID0gbm9kZVxuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5vZGVcbiAgfVxuICB0aGlzLmxlbmd0aCsrXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHB1c2godGhpcywgYXJndW1lbnRzW2ldKVxuICB9XG4gIHJldHVybiB0aGlzLmxlbmd0aFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB1bnNoaWZ0KHRoaXMsIGFyZ3VtZW50c1tpXSlcbiAgfVxuICByZXR1cm4gdGhpcy5sZW5ndGhcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMudGFpbCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHZhciByZXMgPSB0aGlzLnRhaWwudmFsdWVcbiAgdGhpcy50YWlsID0gdGhpcy50YWlsLnByZXZcbiAgaWYgKHRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbC5uZXh0ID0gbnVsbFxuICB9IGVsc2Uge1xuICAgIHRoaXMuaGVhZCA9IG51bGxcbiAgfVxuICB0aGlzLmxlbmd0aC0tXG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgdmFyIHJlcyA9IHRoaXMuaGVhZC52YWx1ZVxuICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dFxuICBpZiAodGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkLnByZXYgPSBudWxsXG4gIH0gZWxzZSB7XG4gICAgdGhpcy50YWlsID0gbnVsbFxuICB9XG4gIHRoaXMubGVuZ3RoLS1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy5oZWFkLCBpID0gMDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMudGFpbCwgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdhbGtlci52YWx1ZVxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLmdldFJldmVyc2UgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdhbGtlci52YWx1ZVxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIHZhciByZXMgPSBuZXcgWWFsbGlzdCgpXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgIHJlcy5wdXNoKGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgdGhpcykpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLm1hcFJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QoKVxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoZm4sIGluaXRpYWwpIHtcbiAgdmFyIGFjY1xuICB2YXIgd2Fsa2VyID0gdGhpcy5oZWFkXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIGFjYyA9IGluaXRpYWxcbiAgfSBlbHNlIGlmICh0aGlzLmhlYWQpIHtcbiAgICB3YWxrZXIgPSB0aGlzLmhlYWQubmV4dFxuICAgIGFjYyA9IHRoaXMuaGVhZC52YWx1ZVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBsaXN0IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhY2MgPSBmbihhY2MsIHdhbGtlci52YWx1ZSwgaSlcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG5cbiAgcmV0dXJuIGFjY1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2VSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsKSB7XG4gIHZhciBhY2NcbiAgdmFyIHdhbGtlciA9IHRoaXMudGFpbFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsXG4gIH0gZWxzZSBpZiAodGhpcy50YWlsKSB7XG4gICAgd2Fsa2VyID0gdGhpcy50YWlsLnByZXZcbiAgICBhY2MgPSB0aGlzLnRhaWwudmFsdWVcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBhY2MgPSBmbihhY2MsIHdhbGtlci52YWx1ZSwgaSlcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG5cbiAgcmV0dXJuIGFjY1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGFycltpXSA9IHdhbGtlci52YWx1ZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgcmV0dXJuIGFyclxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5UmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhcnJbaV0gPSB3YWxrZXIudmFsdWVcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIHJldHVybiBhcnJcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aFxuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICBmcm9tID0gZnJvbSB8fCAwXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKVxuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXRcbiAgfVxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tID0gMFxuICB9XG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgZnJvbTsgaSsrKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICBmb3IgKDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCB0bzsgaSsrLCB3YWxrZXIgPSB3YWxrZXIubmV4dCkge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNsaWNlUmV2ZXJzZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICB0byA9IHRvIHx8IHRoaXMubGVuZ3RoXG4gIGlmICh0byA8IDApIHtcbiAgICB0byArPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZyb20gPSBmcm9tIHx8IDBcbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSArPSB0aGlzLmxlbmd0aFxuICB9XG4gIHZhciByZXQgPSBuZXcgWWFsbGlzdCgpXG4gIGlmICh0byA8IGZyb20gfHwgdG8gPCAwKSB7XG4gICAgcmV0dXJuIHJldFxuICB9XG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gPSAwXG4gIH1cbiAgaWYgKHRvID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0byA9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbCAmJiBpID4gdG87IGktLSkge1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgZm9yICg7IHdhbGtlciAhPT0gbnVsbCAmJiBpID4gZnJvbTsgaS0tLCB3YWxrZXIgPSB3YWxrZXIucHJldikge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNwbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZGVsZXRlQ291bnQsIC4uLm5vZGVzKSB7XG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aCAtIDFcbiAgfVxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aCArIHN0YXJ0O1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBzdGFydDsgaSsrKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuXG4gIHZhciByZXQgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgd2Fsa2VyICYmIGkgPCBkZWxldGVDb3VudDsgaSsrKSB7XG4gICAgcmV0LnB1c2god2Fsa2VyLnZhbHVlKVxuICAgIHdhbGtlciA9IHRoaXMucmVtb3ZlTm9kZSh3YWxrZXIpXG4gIH1cbiAgaWYgKHdhbGtlciA9PT0gbnVsbCkge1xuICAgIHdhbGtlciA9IHRoaXMudGFpbFxuICB9XG5cbiAgaWYgKHdhbGtlciAhPT0gdGhpcy5oZWFkICYmIHdhbGtlciAhPT0gdGhpcy50YWlsKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB3YWxrZXIgPSBpbnNlcnQodGhpcywgd2Fsa2VyLCBub2Rlc1tpXSlcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCA9IHRoaXMuaGVhZFxuICB2YXIgdGFpbCA9IHRoaXMudGFpbFxuICBmb3IgKHZhciB3YWxrZXIgPSBoZWFkOyB3YWxrZXIgIT09IG51bGw7IHdhbGtlciA9IHdhbGtlci5wcmV2KSB7XG4gICAgdmFyIHAgPSB3YWxrZXIucHJldlxuICAgIHdhbGtlci5wcmV2ID0gd2Fsa2VyLm5leHRcbiAgICB3YWxrZXIubmV4dCA9IHBcbiAgfVxuICB0aGlzLmhlYWQgPSB0YWlsXG4gIHRoaXMudGFpbCA9IGhlYWRcbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gaW5zZXJ0IChzZWxmLCBub2RlLCB2YWx1ZSkge1xuICB2YXIgaW5zZXJ0ZWQgPSBub2RlID09PSBzZWxmLmhlYWQgP1xuICAgIG5ldyBOb2RlKHZhbHVlLCBudWxsLCBub2RlLCBzZWxmKSA6XG4gICAgbmV3IE5vZGUodmFsdWUsIG5vZGUsIG5vZGUubmV4dCwgc2VsZilcblxuICBpZiAoaW5zZXJ0ZWQubmV4dCA9PT0gbnVsbCkge1xuICAgIHNlbGYudGFpbCA9IGluc2VydGVkXG4gIH1cbiAgaWYgKGluc2VydGVkLnByZXYgPT09IG51bGwpIHtcbiAgICBzZWxmLmhlYWQgPSBpbnNlcnRlZFxuICB9XG5cbiAgc2VsZi5sZW5ndGgrK1xuXG4gIHJldHVybiBpbnNlcnRlZFxufVxuXG5mdW5jdGlvbiBwdXNoIChzZWxmLCBpdGVtKSB7XG4gIHNlbGYudGFpbCA9IG5ldyBOb2RlKGl0ZW0sIHNlbGYudGFpbCwgbnVsbCwgc2VsZilcbiAgaWYgKCFzZWxmLmhlYWQpIHtcbiAgICBzZWxmLmhlYWQgPSBzZWxmLnRhaWxcbiAgfVxuICBzZWxmLmxlbmd0aCsrXG59XG5cbmZ1bmN0aW9uIHVuc2hpZnQgKHNlbGYsIGl0ZW0pIHtcbiAgc2VsZi5oZWFkID0gbmV3IE5vZGUoaXRlbSwgbnVsbCwgc2VsZi5oZWFkLCBzZWxmKVxuICBpZiAoIXNlbGYudGFpbCkge1xuICAgIHNlbGYudGFpbCA9IHNlbGYuaGVhZFxuICB9XG4gIHNlbGYubGVuZ3RoKytcbn1cblxuZnVuY3Rpb24gTm9kZSAodmFsdWUsIHByZXYsIG5leHQsIGxpc3QpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5vZGUpKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHZhbHVlLCBwcmV2LCBuZXh0LCBsaXN0KVxuICB9XG5cbiAgdGhpcy5saXN0ID0gbGlzdFxuICB0aGlzLnZhbHVlID0gdmFsdWVcblxuICBpZiAocHJldikge1xuICAgIHByZXYubmV4dCA9IHRoaXNcbiAgICB0aGlzLnByZXYgPSBwcmV2XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wcmV2ID0gbnVsbFxuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0LnByZXYgPSB0aGlzXG4gICAgdGhpcy5uZXh0ID0gbmV4dFxuICB9IGVsc2Uge1xuICAgIHRoaXMubmV4dCA9IG51bGxcbiAgfVxufVxuXG50cnkge1xuICAvLyBhZGQgaWYgc3VwcG9ydCBmb3IgU3ltYm9sLml0ZXJhdG9yIGlzIHByZXNlbnRcbiAgcmVxdWlyZSgnLi9pdGVyYXRvci5qcycpKFlhbGxpc3QpXG59IGNhdGNoIChlcikge31cbiIsIid1c2Ugc3RyaWN0J1xuXG4vLyBBIGxpbmtlZCBsaXN0IHRvIGtlZXAgdHJhY2sgb2YgcmVjZW50bHktdXNlZC1uZXNzXG5jb25zdCBZYWxsaXN0ID0gcmVxdWlyZSgneWFsbGlzdCcpXG5cbmNvbnN0IE1BWCA9IFN5bWJvbCgnbWF4JylcbmNvbnN0IExFTkdUSCA9IFN5bWJvbCgnbGVuZ3RoJylcbmNvbnN0IExFTkdUSF9DQUxDVUxBVE9SID0gU3ltYm9sKCdsZW5ndGhDYWxjdWxhdG9yJylcbmNvbnN0IEFMTE9XX1NUQUxFID0gU3ltYm9sKCdhbGxvd1N0YWxlJylcbmNvbnN0IE1BWF9BR0UgPSBTeW1ib2woJ21heEFnZScpXG5jb25zdCBESVNQT1NFID0gU3ltYm9sKCdkaXNwb3NlJylcbmNvbnN0IE5PX0RJU1BPU0VfT05fU0VUID0gU3ltYm9sKCdub0Rpc3Bvc2VPblNldCcpXG5jb25zdCBMUlVfTElTVCA9IFN5bWJvbCgnbHJ1TGlzdCcpXG5jb25zdCBDQUNIRSA9IFN5bWJvbCgnY2FjaGUnKVxuY29uc3QgVVBEQVRFX0FHRV9PTl9HRVQgPSBTeW1ib2woJ3VwZGF0ZUFnZU9uR2V0JylcblxuY29uc3QgbmFpdmVMZW5ndGggPSAoKSA9PiAxXG5cbi8vIGxydUxpc3QgaXMgYSB5YWxsaXN0IHdoZXJlIHRoZSBoZWFkIGlzIHRoZSB5b3VuZ2VzdFxuLy8gaXRlbSwgYW5kIHRoZSB0YWlsIGlzIHRoZSBvbGRlc3QuICB0aGUgbGlzdCBjb250YWlucyB0aGUgSGl0XG4vLyBvYmplY3RzIGFzIHRoZSBlbnRyaWVzLlxuLy8gRWFjaCBIaXQgb2JqZWN0IGhhcyBhIHJlZmVyZW5jZSB0byBpdHMgWWFsbGlzdC5Ob2RlLiAgVGhpc1xuLy8gbmV2ZXIgY2hhbmdlcy5cbi8vXG4vLyBjYWNoZSBpcyBhIE1hcCAob3IgUHNldWRvTWFwKSB0aGF0IG1hdGNoZXMgdGhlIGtleXMgdG9cbi8vIHRoZSBZYWxsaXN0Lk5vZGUgb2JqZWN0LlxuY2xhc3MgTFJVQ2FjaGUge1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpXG4gICAgICBvcHRpb25zID0geyBtYXg6IG9wdGlvbnMgfVxuXG4gICAgaWYgKCFvcHRpb25zKVxuICAgICAgb3B0aW9ucyA9IHt9XG5cbiAgICBpZiAob3B0aW9ucy5tYXggJiYgKHR5cGVvZiBvcHRpb25zLm1heCAhPT0gJ251bWJlcicgfHwgb3B0aW9ucy5tYXggPCAwKSlcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpXG4gICAgLy8gS2luZCBvZiB3ZWlyZCB0byBoYXZlIGEgZGVmYXVsdCBtYXggb2YgSW5maW5pdHksIGJ1dCBvaCB3ZWxsLlxuICAgIGNvbnN0IG1heCA9IHRoaXNbTUFYXSA9IG9wdGlvbnMubWF4IHx8IEluZmluaXR5XG5cbiAgICBjb25zdCBsYyA9IG9wdGlvbnMubGVuZ3RoIHx8IG5haXZlTGVuZ3RoXG4gICAgdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gPSAodHlwZW9mIGxjICE9PSAnZnVuY3Rpb24nKSA/IG5haXZlTGVuZ3RoIDogbGNcbiAgICB0aGlzW0FMTE9XX1NUQUxFXSA9IG9wdGlvbnMuc3RhbGUgfHwgZmFsc2VcbiAgICBpZiAob3B0aW9ucy5tYXhBZ2UgJiYgdHlwZW9mIG9wdGlvbnMubWF4QWdlICE9PSAnbnVtYmVyJylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heEFnZSBtdXN0IGJlIGEgbnVtYmVyJylcbiAgICB0aGlzW01BWF9BR0VdID0gb3B0aW9ucy5tYXhBZ2UgfHwgMFxuICAgIHRoaXNbRElTUE9TRV0gPSBvcHRpb25zLmRpc3Bvc2VcbiAgICB0aGlzW05PX0RJU1BPU0VfT05fU0VUXSA9IG9wdGlvbnMubm9EaXNwb3NlT25TZXQgfHwgZmFsc2VcbiAgICB0aGlzW1VQREFURV9BR0VfT05fR0VUXSA9IG9wdGlvbnMudXBkYXRlQWdlT25HZXQgfHwgZmFsc2VcbiAgICB0aGlzLnJlc2V0KClcbiAgfVxuXG4gIC8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbWF4IGNoYW5nZXMuXG4gIHNldCBtYXggKG1MKSB7XG4gICAgaWYgKHR5cGVvZiBtTCAhPT0gJ251bWJlcicgfHwgbUwgPCAwKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJylcblxuICAgIHRoaXNbTUFYXSA9IG1MIHx8IEluZmluaXR5XG4gICAgdHJpbSh0aGlzKVxuICB9XG4gIGdldCBtYXggKCkge1xuICAgIHJldHVybiB0aGlzW01BWF1cbiAgfVxuXG4gIHNldCBhbGxvd1N0YWxlIChhbGxvd1N0YWxlKSB7XG4gICAgdGhpc1tBTExPV19TVEFMRV0gPSAhIWFsbG93U3RhbGVcbiAgfVxuICBnZXQgYWxsb3dTdGFsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXNbQUxMT1dfU1RBTEVdXG4gIH1cblxuICBzZXQgbWF4QWdlIChtQSkge1xuICAgIGlmICh0eXBlb2YgbUEgIT09ICdudW1iZXInKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4QWdlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJylcblxuICAgIHRoaXNbTUFYX0FHRV0gPSBtQVxuICAgIHRyaW0odGhpcylcbiAgfVxuICBnZXQgbWF4QWdlICgpIHtcbiAgICByZXR1cm4gdGhpc1tNQVhfQUdFXVxuICB9XG5cbiAgLy8gcmVzaXplIHRoZSBjYWNoZSB3aGVuIHRoZSBsZW5ndGhDYWxjdWxhdG9yIGNoYW5nZXMuXG4gIHNldCBsZW5ndGhDYWxjdWxhdG9yIChsQykge1xuICAgIGlmICh0eXBlb2YgbEMgIT09ICdmdW5jdGlvbicpXG4gICAgICBsQyA9IG5haXZlTGVuZ3RoXG5cbiAgICBpZiAobEMgIT09IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKSB7XG4gICAgICB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSA9IGxDXG4gICAgICB0aGlzW0xFTkdUSF0gPSAwXG4gICAgICB0aGlzW0xSVV9MSVNUXS5mb3JFYWNoKGhpdCA9PiB7XG4gICAgICAgIGhpdC5sZW5ndGggPSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXShoaXQudmFsdWUsIGhpdC5rZXkpXG4gICAgICAgIHRoaXNbTEVOR1RIXSArPSBoaXQubGVuZ3RoXG4gICAgICB9KVxuICAgIH1cbiAgICB0cmltKHRoaXMpXG4gIH1cbiAgZ2V0IGxlbmd0aENhbGN1bGF0b3IgKCkgeyByZXR1cm4gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gfVxuXG4gIGdldCBsZW5ndGggKCkgeyByZXR1cm4gdGhpc1tMRU5HVEhdIH1cbiAgZ2V0IGl0ZW1Db3VudCAoKSB7IHJldHVybiB0aGlzW0xSVV9MSVNUXS5sZW5ndGggfVxuXG4gIHJmb3JFYWNoIChmbiwgdGhpc3ApIHtcbiAgICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgICBmb3IgKGxldCB3YWxrZXIgPSB0aGlzW0xSVV9MSVNUXS50YWlsOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICBjb25zdCBwcmV2ID0gd2Fsa2VyLnByZXZcbiAgICAgIGZvckVhY2hTdGVwKHRoaXMsIGZuLCB3YWxrZXIsIHRoaXNwKVxuICAgICAgd2Fsa2VyID0gcHJldlxuICAgIH1cbiAgfVxuXG4gIGZvckVhY2ggKGZuLCB0aGlzcCkge1xuICAgIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICAgIGZvciAobGV0IHdhbGtlciA9IHRoaXNbTFJVX0xJU1RdLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICAgIGNvbnN0IG5leHQgPSB3YWxrZXIubmV4dFxuICAgICAgZm9yRWFjaFN0ZXAodGhpcywgZm4sIHdhbGtlciwgdGhpc3ApXG4gICAgICB3YWxrZXIgPSBuZXh0XG4gICAgfVxuICB9XG5cbiAga2V5cyAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLnRvQXJyYXkoKS5tYXAoayA9PiBrLmtleSlcbiAgfVxuXG4gIHZhbHVlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLnRvQXJyYXkoKS5tYXAoayA9PiBrLnZhbHVlKVxuICB9XG5cbiAgcmVzZXQgKCkge1xuICAgIGlmICh0aGlzW0RJU1BPU0VdICYmXG4gICAgICAgIHRoaXNbTFJVX0xJU1RdICYmXG4gICAgICAgIHRoaXNbTFJVX0xJU1RdLmxlbmd0aCkge1xuICAgICAgdGhpc1tMUlVfTElTVF0uZm9yRWFjaChoaXQgPT4gdGhpc1tESVNQT1NFXShoaXQua2V5LCBoaXQudmFsdWUpKVxuICAgIH1cblxuICAgIHRoaXNbQ0FDSEVdID0gbmV3IE1hcCgpIC8vIGhhc2ggb2YgaXRlbXMgYnkga2V5XG4gICAgdGhpc1tMUlVfTElTVF0gPSBuZXcgWWFsbGlzdCgpIC8vIGxpc3Qgb2YgaXRlbXMgaW4gb3JkZXIgb2YgdXNlIHJlY2VuY3lcbiAgICB0aGlzW0xFTkdUSF0gPSAwIC8vIGxlbmd0aCBvZiBpdGVtcyBpbiB0aGUgbGlzdFxuICB9XG5cbiAgZHVtcCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLm1hcChoaXQgPT5cbiAgICAgIGlzU3RhbGUodGhpcywgaGl0KSA/IGZhbHNlIDoge1xuICAgICAgICBrOiBoaXQua2V5LFxuICAgICAgICB2OiBoaXQudmFsdWUsXG4gICAgICAgIGU6IGhpdC5ub3cgKyAoaGl0Lm1heEFnZSB8fCAwKVxuICAgICAgfSkudG9BcnJheSgpLmZpbHRlcihoID0+IGgpXG4gIH1cblxuICBkdW1wTHJ1ICgpIHtcbiAgICByZXR1cm4gdGhpc1tMUlVfTElTVF1cbiAgfVxuXG4gIHNldCAoa2V5LCB2YWx1ZSwgbWF4QWdlKSB7XG4gICAgbWF4QWdlID0gbWF4QWdlIHx8IHRoaXNbTUFYX0FHRV1cblxuICAgIGlmIChtYXhBZ2UgJiYgdHlwZW9mIG1heEFnZSAhPT0gJ251bWJlcicpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhBZ2UgbXVzdCBiZSBhIG51bWJlcicpXG5cbiAgICBjb25zdCBub3cgPSBtYXhBZ2UgPyBEYXRlLm5vdygpIDogMFxuICAgIGNvbnN0IGxlbiA9IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKHZhbHVlLCBrZXkpXG5cbiAgICBpZiAodGhpc1tDQUNIRV0uaGFzKGtleSkpIHtcbiAgICAgIGlmIChsZW4gPiB0aGlzW01BWF0pIHtcbiAgICAgICAgZGVsKHRoaXMsIHRoaXNbQ0FDSEVdLmdldChrZXkpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9kZSA9IHRoaXNbQ0FDSEVdLmdldChrZXkpXG4gICAgICBjb25zdCBpdGVtID0gbm9kZS52YWx1ZVxuXG4gICAgICAvLyBkaXNwb3NlIG9mIHRoZSBvbGQgb25lIGJlZm9yZSBvdmVyd3JpdGluZ1xuICAgICAgLy8gc3BsaXQgb3V0IGludG8gMiBpZnMgZm9yIGJldHRlciBjb3ZlcmFnZSB0cmFja2luZ1xuICAgICAgaWYgKHRoaXNbRElTUE9TRV0pIHtcbiAgICAgICAgaWYgKCF0aGlzW05PX0RJU1BPU0VfT05fU0VUXSlcbiAgICAgICAgICB0aGlzW0RJU1BPU0VdKGtleSwgaXRlbS52YWx1ZSlcbiAgICAgIH1cblxuICAgICAgaXRlbS5ub3cgPSBub3dcbiAgICAgIGl0ZW0ubWF4QWdlID0gbWF4QWdlXG4gICAgICBpdGVtLnZhbHVlID0gdmFsdWVcbiAgICAgIHRoaXNbTEVOR1RIXSArPSBsZW4gLSBpdGVtLmxlbmd0aFxuICAgICAgaXRlbS5sZW5ndGggPSBsZW5cbiAgICAgIHRoaXMuZ2V0KGtleSlcbiAgICAgIHRyaW0odGhpcylcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgY29uc3QgaGl0ID0gbmV3IEVudHJ5KGtleSwgdmFsdWUsIGxlbiwgbm93LCBtYXhBZ2UpXG5cbiAgICAvLyBvdmVyc2l6ZWQgb2JqZWN0cyBmYWxsIG91dCBvZiBjYWNoZSBhdXRvbWF0aWNhbGx5LlxuICAgIGlmIChoaXQubGVuZ3RoID4gdGhpc1tNQVhdKSB7XG4gICAgICBpZiAodGhpc1tESVNQT1NFXSlcbiAgICAgICAgdGhpc1tESVNQT1NFXShrZXksIHZhbHVlKVxuXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB0aGlzW0xFTkdUSF0gKz0gaGl0Lmxlbmd0aFxuICAgIHRoaXNbTFJVX0xJU1RdLnVuc2hpZnQoaGl0KVxuICAgIHRoaXNbQ0FDSEVdLnNldChrZXksIHRoaXNbTFJVX0xJU1RdLmhlYWQpXG4gICAgdHJpbSh0aGlzKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBoYXMgKGtleSkge1xuICAgIGlmICghdGhpc1tDQUNIRV0uaGFzKGtleSkpIHJldHVybiBmYWxzZVxuICAgIGNvbnN0IGhpdCA9IHRoaXNbQ0FDSEVdLmdldChrZXkpLnZhbHVlXG4gICAgcmV0dXJuICFpc1N0YWxlKHRoaXMsIGhpdClcbiAgfVxuXG4gIGdldCAoa2V5KSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBrZXksIHRydWUpXG4gIH1cblxuICBwZWVrIChrZXkpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgZmFsc2UpXG4gIH1cblxuICBwb3AgKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzW0xSVV9MSVNUXS50YWlsXG4gICAgaWYgKCFub2RlKVxuICAgICAgcmV0dXJuIG51bGxcblxuICAgIGRlbCh0aGlzLCBub2RlKVxuICAgIHJldHVybiBub2RlLnZhbHVlXG4gIH1cblxuICBkZWwgKGtleSkge1xuICAgIGRlbCh0aGlzLCB0aGlzW0NBQ0hFXS5nZXQoa2V5KSlcbiAgfVxuXG4gIGxvYWQgKGFycikge1xuICAgIC8vIHJlc2V0IHRoZSBjYWNoZVxuICAgIHRoaXMucmVzZXQoKVxuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuICAgIC8vIEEgcHJldmlvdXMgc2VyaWFsaXplZCBjYWNoZSBoYXMgdGhlIG1vc3QgcmVjZW50IGl0ZW1zIGZpcnN0XG4gICAgZm9yIChsZXQgbCA9IGFyci5sZW5ndGggLSAxOyBsID49IDA7IGwtLSkge1xuICAgICAgY29uc3QgaGl0ID0gYXJyW2xdXG4gICAgICBjb25zdCBleHBpcmVzQXQgPSBoaXQuZSB8fCAwXG4gICAgICBpZiAoZXhwaXJlc0F0ID09PSAwKVxuICAgICAgICAvLyB0aGUgaXRlbSB3YXMgY3JlYXRlZCB3aXRob3V0IGV4cGlyYXRpb24gaW4gYSBub24gYWdlZCBjYWNoZVxuICAgICAgICB0aGlzLnNldChoaXQuaywgaGl0LnYpXG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF4QWdlID0gZXhwaXJlc0F0IC0gbm93XG4gICAgICAgIC8vIGRvbnQgYWRkIGFscmVhZHkgZXhwaXJlZCBpdGVtc1xuICAgICAgICBpZiAobWF4QWdlID4gMCkge1xuICAgICAgICAgIHRoaXMuc2V0KGhpdC5rLCBoaXQudiwgbWF4QWdlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJ1bmUgKCkge1xuICAgIHRoaXNbQ0FDSEVdLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IGdldCh0aGlzLCBrZXksIGZhbHNlKSlcbiAgfVxufVxuXG5jb25zdCBnZXQgPSAoc2VsZiwga2V5LCBkb1VzZSkgPT4ge1xuICBjb25zdCBub2RlID0gc2VsZltDQUNIRV0uZ2V0KGtleSlcbiAgaWYgKG5vZGUpIHtcbiAgICBjb25zdCBoaXQgPSBub2RlLnZhbHVlXG4gICAgaWYgKGlzU3RhbGUoc2VsZiwgaGl0KSkge1xuICAgICAgZGVsKHNlbGYsIG5vZGUpXG4gICAgICBpZiAoIXNlbGZbQUxMT1dfU1RBTEVdKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkb1VzZSkge1xuICAgICAgICBpZiAoc2VsZltVUERBVEVfQUdFX09OX0dFVF0pXG4gICAgICAgICAgbm9kZS52YWx1ZS5ub3cgPSBEYXRlLm5vdygpXG4gICAgICAgIHNlbGZbTFJVX0xJU1RdLnVuc2hpZnROb2RlKG5vZGUpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoaXQudmFsdWVcbiAgfVxufVxuXG5jb25zdCBpc1N0YWxlID0gKHNlbGYsIGhpdCkgPT4ge1xuICBpZiAoIWhpdCB8fCAoIWhpdC5tYXhBZ2UgJiYgIXNlbGZbTUFYX0FHRV0pKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gaGl0Lm5vd1xuICByZXR1cm4gaGl0Lm1heEFnZSA/IGRpZmYgPiBoaXQubWF4QWdlXG4gICAgOiBzZWxmW01BWF9BR0VdICYmIChkaWZmID4gc2VsZltNQVhfQUdFXSlcbn1cblxuY29uc3QgdHJpbSA9IHNlbGYgPT4ge1xuICBpZiAoc2VsZltMRU5HVEhdID4gc2VsZltNQVhdKSB7XG4gICAgZm9yIChsZXQgd2Fsa2VyID0gc2VsZltMUlVfTElTVF0udGFpbDtcbiAgICAgIHNlbGZbTEVOR1RIXSA+IHNlbGZbTUFYXSAmJiB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICAvLyBXZSBrbm93IHRoYXQgd2UncmUgYWJvdXQgdG8gZGVsZXRlIHRoaXMgb25lLCBhbmQgYWxzb1xuICAgICAgLy8gd2hhdCB0aGUgbmV4dCBsZWFzdCByZWNlbnRseSB1c2VkIGtleSB3aWxsIGJlLCBzbyBqdXN0XG4gICAgICAvLyBnbyBhaGVhZCBhbmQgc2V0IGl0IG5vdy5cbiAgICAgIGNvbnN0IHByZXYgPSB3YWxrZXIucHJldlxuICAgICAgZGVsKHNlbGYsIHdhbGtlcilcbiAgICAgIHdhbGtlciA9IHByZXZcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgZGVsID0gKHNlbGYsIG5vZGUpID0+IHtcbiAgaWYgKG5vZGUpIHtcbiAgICBjb25zdCBoaXQgPSBub2RlLnZhbHVlXG4gICAgaWYgKHNlbGZbRElTUE9TRV0pXG4gICAgICBzZWxmW0RJU1BPU0VdKGhpdC5rZXksIGhpdC52YWx1ZSlcblxuICAgIHNlbGZbTEVOR1RIXSAtPSBoaXQubGVuZ3RoXG4gICAgc2VsZltDQUNIRV0uZGVsZXRlKGhpdC5rZXkpXG4gICAgc2VsZltMUlVfTElTVF0ucmVtb3ZlTm9kZShub2RlKVxuICB9XG59XG5cbmNsYXNzIEVudHJ5IHtcbiAgY29uc3RydWN0b3IgKGtleSwgdmFsdWUsIGxlbmd0aCwgbm93LCBtYXhBZ2UpIHtcbiAgICB0aGlzLmtleSA9IGtleVxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoXG4gICAgdGhpcy5ub3cgPSBub3dcbiAgICB0aGlzLm1heEFnZSA9IG1heEFnZSB8fCAwXG4gIH1cbn1cblxuY29uc3QgZm9yRWFjaFN0ZXAgPSAoc2VsZiwgZm4sIG5vZGUsIHRoaXNwKSA9PiB7XG4gIGxldCBoaXQgPSBub2RlLnZhbHVlXG4gIGlmIChpc1N0YWxlKHNlbGYsIGhpdCkpIHtcbiAgICBkZWwoc2VsZiwgbm9kZSlcbiAgICBpZiAoIXNlbGZbQUxMT1dfU1RBTEVdKVxuICAgICAgaGl0ID0gdW5kZWZpbmVkXG4gIH1cbiAgaWYgKGhpdClcbiAgICBmbi5jYWxsKHRoaXNwLCBoaXQudmFsdWUsIGhpdC5rZXksIHNlbGYpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTFJVQ2FjaGVcbiIsIi8vIGhvaXN0ZWQgY2xhc3MgZm9yIGN5Y2xpYyBkZXBlbmRlbmN5XG5jbGFzcyBSYW5nZSB7XG4gIGNvbnN0cnVjdG9yIChyYW5nZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucylcblxuICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHJhbmdlLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UgJiZcbiAgICAgICAgcmFuZ2UuaW5jbHVkZVByZXJlbGVhc2UgPT09ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiByYW5nZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS5yYXcsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJhbmdlIGluc3RhbmNlb2YgQ29tcGFyYXRvcikge1xuICAgICAgLy8ganVzdCBwdXQgaXQgaW4gdGhlIHNldCBhbmQgcmV0dXJuXG4gICAgICB0aGlzLnJhdyA9IHJhbmdlLnZhbHVlXG4gICAgICB0aGlzLnNldCA9IFtbcmFuZ2VdXVxuICAgICAgdGhpcy5mb3JtYXQoKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICAgIHRoaXMuaW5jbHVkZVByZXJlbGVhc2UgPSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcblxuICAgIC8vIEZpcnN0LCBzcGxpdCBiYXNlZCBvbiBib29sZWFuIG9yIHx8XG4gICAgdGhpcy5yYXcgPSByYW5nZVxuICAgIHRoaXMuc2V0ID0gcmFuZ2VcbiAgICAgIC5zcGxpdCgvXFxzKlxcfFxcfFxccyovKVxuICAgICAgLy8gbWFwIHRoZSByYW5nZSB0byBhIDJkIGFycmF5IG9mIGNvbXBhcmF0b3JzXG4gICAgICAubWFwKHJhbmdlID0+IHRoaXMucGFyc2VSYW5nZShyYW5nZS50cmltKCkpKVxuICAgICAgLy8gdGhyb3cgb3V0IGFueSBjb21wYXJhdG9yIGxpc3RzIHRoYXQgYXJlIGVtcHR5XG4gICAgICAvLyB0aGlzIGdlbmVyYWxseSBtZWFucyB0aGF0IGl0IHdhcyBub3QgYSB2YWxpZCByYW5nZSwgd2hpY2ggaXMgYWxsb3dlZFxuICAgICAgLy8gaW4gbG9vc2UgbW9kZSwgYnV0IHdpbGwgc3RpbGwgdGhyb3cgaWYgdGhlIFdIT0xFIHJhbmdlIGlzIGludmFsaWQuXG4gICAgICAuZmlsdGVyKGMgPT4gYy5sZW5ndGgpXG5cbiAgICBpZiAoIXRoaXMuc2V0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBTZW1WZXIgUmFuZ2U6ICR7cmFuZ2V9YClcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGFueSB0aGF0IGFyZSBub3QgdGhlIG51bGwgc2V0LCB0aHJvdyBvdXQgbnVsbCBzZXRzLlxuICAgIGlmICh0aGlzLnNldC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBrZWVwIHRoZSBmaXJzdCBvbmUsIGluIGNhc2UgdGhleSdyZSBhbGwgbnVsbCBzZXRzXG4gICAgICBjb25zdCBmaXJzdCA9IHRoaXMuc2V0WzBdXG4gICAgICB0aGlzLnNldCA9IHRoaXMuc2V0LmZpbHRlcihjID0+ICFpc051bGxTZXQoY1swXSkpXG4gICAgICBpZiAodGhpcy5zZXQubGVuZ3RoID09PSAwKVxuICAgICAgICB0aGlzLnNldCA9IFtmaXJzdF1cbiAgICAgIGVsc2UgaWYgKHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhbnkgdGhhdCBhcmUgKiwgdGhlbiB0aGUgcmFuZ2UgaXMganVzdCAqXG4gICAgICAgIGZvciAoY29uc3QgYyBvZiB0aGlzLnNldCkge1xuICAgICAgICAgIGlmIChjLmxlbmd0aCA9PT0gMSAmJiBpc0FueShjWzBdKSkge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSBbY11cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5mb3JtYXQoKVxuICB9XG5cbiAgZm9ybWF0ICgpIHtcbiAgICB0aGlzLnJhbmdlID0gdGhpcy5zZXRcbiAgICAgIC5tYXAoKGNvbXBzKSA9PiB7XG4gICAgICAgIHJldHVybiBjb21wcy5qb2luKCcgJykudHJpbSgpXG4gICAgICB9KVxuICAgICAgLmpvaW4oJ3x8JylcbiAgICAgIC50cmltKClcbiAgICByZXR1cm4gdGhpcy5yYW5nZVxuICB9XG5cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLnJhbmdlXG4gIH1cblxuICBwYXJzZVJhbmdlIChyYW5nZSkge1xuICAgIHJhbmdlID0gcmFuZ2UudHJpbSgpXG5cbiAgICAvLyBtZW1vaXplIHJhbmdlIHBhcnNpbmcgZm9yIHBlcmZvcm1hbmNlLlxuICAgIC8vIHRoaXMgaXMgYSB2ZXJ5IGhvdCBwYXRoLCBhbmQgZnVsbHkgZGV0ZXJtaW5pc3RpYy5cbiAgICBjb25zdCBtZW1vT3B0cyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucykuam9pbignLCcpXG4gICAgY29uc3QgbWVtb0tleSA9IGBwYXJzZVJhbmdlOiR7bWVtb09wdHN9OiR7cmFuZ2V9YFxuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChtZW1vS2V5KVxuICAgIGlmIChjYWNoZWQpXG4gICAgICByZXR1cm4gY2FjaGVkXG5cbiAgICBjb25zdCBsb29zZSA9IHRoaXMub3B0aW9ucy5sb29zZVxuICAgIC8vIGAxLjIuMyAtIDEuMi40YCA9PiBgPj0xLjIuMyA8PTEuMi40YFxuICAgIGNvbnN0IGhyID0gbG9vc2UgPyByZVt0LkhZUEhFTlJBTkdFTE9PU0VdIDogcmVbdC5IWVBIRU5SQU5HRV1cbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UoaHIsIGh5cGhlblJlcGxhY2UodGhpcy5vcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSlcbiAgICBkZWJ1ZygnaHlwaGVuIHJlcGxhY2UnLCByYW5nZSlcbiAgICAvLyBgPiAxLjIuMyA8IDEuMi41YCA9PiBgPjEuMi4zIDwxLjIuNWBcbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5DT01QQVJBVE9SVFJJTV0sIGNvbXBhcmF0b3JUcmltUmVwbGFjZSlcbiAgICBkZWJ1ZygnY29tcGFyYXRvciB0cmltJywgcmFuZ2UsIHJlW3QuQ09NUEFSQVRPUlRSSU1dKVxuXG4gICAgLy8gYH4gMS4yLjNgID0+IGB+MS4yLjNgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuVElMREVUUklNXSwgdGlsZGVUcmltUmVwbGFjZSlcblxuICAgIC8vIGBeIDEuMi4zYCA9PiBgXjEuMi4zYFxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LkNBUkVUVFJJTV0sIGNhcmV0VHJpbVJlcGxhY2UpXG5cbiAgICAvLyBub3JtYWxpemUgc3BhY2VzXG4gICAgcmFuZ2UgPSByYW5nZS5zcGxpdCgvXFxzKy8pLmpvaW4oJyAnKVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIHJhbmdlIGlzIGNvbXBsZXRlbHkgdHJpbW1lZCBhbmRcbiAgICAvLyByZWFkeSB0byBiZSBzcGxpdCBpbnRvIGNvbXBhcmF0b3JzLlxuXG4gICAgY29uc3QgY29tcFJlID0gbG9vc2UgPyByZVt0LkNPTVBBUkFUT1JMT09TRV0gOiByZVt0LkNPTVBBUkFUT1JdXG4gICAgY29uc3QgcmFuZ2VMaXN0ID0gcmFuZ2VcbiAgICAgIC5zcGxpdCgnICcpXG4gICAgICAubWFwKGNvbXAgPT4gcGFyc2VDb21wYXJhdG9yKGNvbXAsIHRoaXMub3B0aW9ucykpXG4gICAgICAuam9pbignICcpXG4gICAgICAuc3BsaXQoL1xccysvKVxuICAgICAgLy8gPj0wLjAuMCBpcyBlcXVpdmFsZW50IHRvICpcbiAgICAgIC5tYXAoY29tcCA9PiByZXBsYWNlR1RFMChjb21wLCB0aGlzLm9wdGlvbnMpKVxuICAgICAgLy8gaW4gbG9vc2UgbW9kZSwgdGhyb3cgb3V0IGFueSB0aGF0IGFyZSBub3QgdmFsaWQgY29tcGFyYXRvcnNcbiAgICAgIC5maWx0ZXIodGhpcy5vcHRpb25zLmxvb3NlID8gY29tcCA9PiAhIWNvbXAubWF0Y2goY29tcFJlKSA6ICgpID0+IHRydWUpXG4gICAgICAubWFwKGNvbXAgPT4gbmV3IENvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKSlcblxuICAgIC8vIGlmIGFueSBjb21wYXJhdG9ycyBhcmUgdGhlIG51bGwgc2V0LCB0aGVuIHJlcGxhY2Ugd2l0aCBKVVNUIG51bGwgc2V0XG4gICAgLy8gaWYgbW9yZSB0aGFuIG9uZSBjb21wYXJhdG9yLCByZW1vdmUgYW55ICogY29tcGFyYXRvcnNcbiAgICAvLyBhbHNvLCBkb24ndCBpbmNsdWRlIHRoZSBzYW1lIGNvbXBhcmF0b3IgbW9yZSB0aGFuIG9uY2VcbiAgICBjb25zdCBsID0gcmFuZ2VMaXN0Lmxlbmd0aFxuICAgIGNvbnN0IHJhbmdlTWFwID0gbmV3IE1hcCgpXG4gICAgZm9yIChjb25zdCBjb21wIG9mIHJhbmdlTGlzdCkge1xuICAgICAgaWYgKGlzTnVsbFNldChjb21wKSlcbiAgICAgICAgcmV0dXJuIFtjb21wXVxuICAgICAgcmFuZ2VNYXAuc2V0KGNvbXAudmFsdWUsIGNvbXApXG4gICAgfVxuICAgIGlmIChyYW5nZU1hcC5zaXplID4gMSAmJiByYW5nZU1hcC5oYXMoJycpKVxuICAgICAgcmFuZ2VNYXAuZGVsZXRlKCcnKVxuXG4gICAgY29uc3QgcmVzdWx0ID0gWy4uLnJhbmdlTWFwLnZhbHVlcygpXVxuICAgIGNhY2hlLnNldChtZW1vS2V5LCByZXN1bHQpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgaW50ZXJzZWN0cyAocmFuZ2UsIG9wdGlvbnMpIHtcbiAgICBpZiAoIShyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBSYW5nZSBpcyByZXF1aXJlZCcpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2V0LnNvbWUoKHRoaXNDb21wYXJhdG9ycykgPT4ge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgaXNTYXRpc2ZpYWJsZSh0aGlzQ29tcGFyYXRvcnMsIG9wdGlvbnMpICYmXG4gICAgICAgIHJhbmdlLnNldC5zb21lKChyYW5nZUNvbXBhcmF0b3JzKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlzU2F0aXNmaWFibGUocmFuZ2VDb21wYXJhdG9ycywgb3B0aW9ucykgJiZcbiAgICAgICAgICAgIHRoaXNDb21wYXJhdG9ycy5ldmVyeSgodGhpc0NvbXBhcmF0b3IpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlQ29tcGFyYXRvcnMuZXZlcnkoKHJhbmdlQ29tcGFyYXRvcikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzQ29tcGFyYXRvci5pbnRlcnNlY3RzKHJhbmdlQ29tcGFyYXRvciwgb3B0aW9ucylcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH0pXG4gIH1cblxuICAvLyBpZiBBTlkgb2YgdGhlIHNldHMgbWF0Y2ggQUxMIG9mIGl0cyBjb21wYXJhdG9ycywgdGhlbiBwYXNzXG4gIHRlc3QgKHZlcnNpb24pIHtcbiAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMub3B0aW9ucylcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0ZXN0U2V0KHRoaXMuc2V0W2ldLCB2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IFJhbmdlXG5cbmNvbnN0IExSVSA9IHJlcXVpcmUoJ2xydS1jYWNoZScpXG5jb25zdCBjYWNoZSA9IG5ldyBMUlUoeyBtYXg6IDEwMDAgfSlcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCBDb21wYXJhdG9yID0gcmVxdWlyZSgnLi9jb21wYXJhdG9yJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvZGVidWcnKVxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi9zZW12ZXInKVxuY29uc3Qge1xuICByZSxcbiAgdCxcbiAgY29tcGFyYXRvclRyaW1SZXBsYWNlLFxuICB0aWxkZVRyaW1SZXBsYWNlLFxuICBjYXJldFRyaW1SZXBsYWNlXG59ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuXG5jb25zdCBpc051bGxTZXQgPSBjID0+IGMudmFsdWUgPT09ICc8MC4wLjAtMCdcbmNvbnN0IGlzQW55ID0gYyA9PiBjLnZhbHVlID09PSAnJ1xuXG4vLyB0YWtlIGEgc2V0IG9mIGNvbXBhcmF0b3JzIGFuZCBkZXRlcm1pbmUgd2hldGhlciB0aGVyZVxuLy8gZXhpc3RzIGEgdmVyc2lvbiB3aGljaCBjYW4gc2F0aXNmeSBpdFxuY29uc3QgaXNTYXRpc2ZpYWJsZSA9IChjb21wYXJhdG9ycywgb3B0aW9ucykgPT4ge1xuICBsZXQgcmVzdWx0ID0gdHJ1ZVxuICBjb25zdCByZW1haW5pbmdDb21wYXJhdG9ycyA9IGNvbXBhcmF0b3JzLnNsaWNlKClcbiAgbGV0IHRlc3RDb21wYXJhdG9yID0gcmVtYWluaW5nQ29tcGFyYXRvcnMucG9wKClcblxuICB3aGlsZSAocmVzdWx0ICYmIHJlbWFpbmluZ0NvbXBhcmF0b3JzLmxlbmd0aCkge1xuICAgIHJlc3VsdCA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLmV2ZXJ5KChvdGhlckNvbXBhcmF0b3IpID0+IHtcbiAgICAgIHJldHVybiB0ZXN0Q29tcGFyYXRvci5pbnRlcnNlY3RzKG90aGVyQ29tcGFyYXRvciwgb3B0aW9ucylcbiAgICB9KVxuXG4gICAgdGVzdENvbXBhcmF0b3IgPSByZW1haW5pbmdDb21wYXJhdG9ycy5wb3AoKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vLyBjb21wcmlzZWQgb2YgeHJhbmdlcywgdGlsZGVzLCBzdGFycywgYW5kIGd0bHQncyBhdCB0aGlzIHBvaW50LlxuLy8gYWxyZWFkeSByZXBsYWNlZCB0aGUgaHlwaGVuIHJhbmdlc1xuLy8gdHVybiBpbnRvIGEgc2V0IG9mIEpVU1QgY29tcGFyYXRvcnMuXG5jb25zdCBwYXJzZUNvbXBhcmF0b3IgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygnY29tcCcsIGNvbXAsIG9wdGlvbnMpXG4gIGNvbXAgPSByZXBsYWNlQ2FyZXRzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCdjYXJldCcsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlVGlsZGVzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCd0aWxkZXMnLCBjb21wKVxuICBjb21wID0gcmVwbGFjZVhSYW5nZXMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3hyYW5nZScsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlU3RhcnMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3N0YXJzJywgY29tcClcbiAgcmV0dXJuIGNvbXBcbn1cblxuY29uc3QgaXNYID0gaWQgPT4gIWlkIHx8IGlkLnRvTG93ZXJDYXNlKCkgPT09ICd4JyB8fCBpZCA9PT0gJyonXG5cbi8vIH4sIH4+IC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gfjIsIH4yLngsIH4yLngueCwgfj4yLCB+PjIueCB+PjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMC0wXG4vLyB+Mi4wLCB+Mi4wLngsIH4+Mi4wLCB+PjIuMC54IC0tPiA+PTIuMC4wIDwyLjEuMC0wXG4vLyB+MS4yLCB+MS4yLngsIH4+MS4yLCB+PjEuMi54IC0tPiA+PTEuMi4wIDwxLjMuMC0wXG4vLyB+MS4yLjMsIH4+MS4yLjMgLS0+ID49MS4yLjMgPDEuMy4wLTBcbi8vIH4xLjIuMCwgfj4xLjIuMCAtLT4gPj0xLjIuMCA8MS4zLjAtMFxuY29uc3QgcmVwbGFjZVRpbGRlcyA9IChjb21wLCBvcHRpb25zKSA9PlxuICBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcCgoY29tcCkgPT4ge1xuICAgIHJldHVybiByZXBsYWNlVGlsZGUoY29tcCwgb3B0aW9ucylcbiAgfSkuam9pbignICcpXG5cbmNvbnN0IHJlcGxhY2VUaWxkZSA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5USUxERUxPT1NFXSA6IHJlW3QuVElMREVdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKF8sIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ3RpbGRlJywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgbGV0IHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAgPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKGlzWChwKSkge1xuICAgICAgLy8gfjEuMiA9PSA+PTEuMi4wIDwxLjMuMC0wXG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uMCA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlVGlsZGUgcHInLCBwcilcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gfjEuMi4zID09ID49MS4yLjMgPDEuMy4wLTBcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9XG5cbiAgICBkZWJ1ZygndGlsZGUgcmV0dXJuJywgcmV0KVxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuLy8gXiAtLT4gKiAoYW55LCBraW5kYSBzaWxseSlcbi8vIF4yLCBeMi54LCBeMi54LnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIF4yLjAsIF4yLjAueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuLy8gXjEuMiwgXjEuMi54IC0tPiA+PTEuMi4wIDwyLjAuMC0wXG4vLyBeMS4yLjMgLS0+ID49MS4yLjMgPDIuMC4wLTBcbi8vIF4xLjIuMCAtLT4gPj0xLjIuMCA8Mi4wLjAtMFxuY29uc3QgcmVwbGFjZUNhcmV0cyA9IChjb21wLCBvcHRpb25zKSA9PlxuICBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcCgoY29tcCkgPT4ge1xuICAgIHJldHVybiByZXBsYWNlQ2FyZXQoY29tcCwgb3B0aW9ucylcbiAgfSkuam9pbignICcpXG5cbmNvbnN0IHJlcGxhY2VDYXJldCA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdjYXJldCcsIGNvbXAsIG9wdGlvbnMpXG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5DQVJFVExPT1NFXSA6IHJlW3QuQ0FSRVRdXG4gIGNvbnN0IHogPSBvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gJy0wJyA6ICcnXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKF8sIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ2NhcmV0JywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgbGV0IHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAke3p9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgfSBlbHNlIGlmIChpc1gocCkpIHtcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3p9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7en0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZUNhcmV0IHByJywgcHIpXG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICAgICAgfSA8JHtNfS4ke219LiR7K3AgKyAxfS0wYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Zygnbm8gcHInKVxuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICAgIH0ke3p9IDwke019LiR7bX0uJHsrcCArIDF9LTBgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICAgIH0ke3p9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgICAgfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH1cblxuICAgIGRlYnVnKCdjYXJldCByZXR1cm4nLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG5jb25zdCByZXBsYWNlWFJhbmdlcyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlWFJhbmdlcycsIGNvbXAsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wLnNwbGl0KC9cXHMrLykubWFwKChjb21wKSA9PiB7XG4gICAgcmV0dXJuIHJlcGxhY2VYUmFuZ2UoY29tcCwgb3B0aW9ucylcbiAgfSkuam9pbignICcpXG59XG5cbmNvbnN0IHJlcGxhY2VYUmFuZ2UgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBjb21wID0gY29tcC50cmltKClcbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LlhSQU5HRUxPT1NFXSA6IHJlW3QuWFJBTkdFXVxuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIChyZXQsIGd0bHQsIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ3hSYW5nZScsIGNvbXAsIHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpXG4gICAgY29uc3QgeE0gPSBpc1goTSlcbiAgICBjb25zdCB4bSA9IHhNIHx8IGlzWChtKVxuICAgIGNvbnN0IHhwID0geG0gfHwgaXNYKHApXG4gICAgY29uc3QgYW55WCA9IHhwXG5cbiAgICBpZiAoZ3RsdCA9PT0gJz0nICYmIGFueVgpIHtcbiAgICAgIGd0bHQgPSAnJ1xuICAgIH1cblxuICAgIC8vIGlmIHdlJ3JlIGluY2x1ZGluZyBwcmVyZWxlYXNlcyBpbiB0aGUgbWF0Y2gsIHRoZW4gd2UgbmVlZFxuICAgIC8vIHRvIGZpeCB0aGlzIHRvIC0wLCB0aGUgbG93ZXN0IHBvc3NpYmxlIHByZXJlbGVhc2UgdmFsdWVcbiAgICBwciA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyAnLTAnIDogJydcblxuICAgIGlmICh4TSkge1xuICAgICAgaWYgKGd0bHQgPT09ICc+JyB8fCBndGx0ID09PSAnPCcpIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBhbGxvd2VkXG4gICAgICAgIHJldCA9ICc8MC4wLjAtMCdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgaXMgZm9yYmlkZGVuXG4gICAgICAgIHJldCA9ICcqJ1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ3RsdCAmJiBhbnlYKSB7XG4gICAgICAvLyB3ZSBrbm93IHBhdGNoIGlzIGFuIHgsIGJlY2F1c2Ugd2UgaGF2ZSBhbnkgeCBhdCBhbGwuXG4gICAgICAvLyByZXBsYWNlIFggd2l0aCAwXG4gICAgICBpZiAoeG0pIHtcbiAgICAgICAgbSA9IDBcbiAgICAgIH1cbiAgICAgIHAgPSAwXG5cbiAgICAgIGlmIChndGx0ID09PSAnPicpIHtcbiAgICAgICAgLy8gPjEgPT4gPj0yLjAuMFxuICAgICAgICAvLyA+MS4yID0+ID49MS4zLjBcbiAgICAgICAgZ3RsdCA9ICc+PSdcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMVxuICAgICAgICAgIG0gPSAwXG4gICAgICAgICAgcCA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtID0gK20gKyAxXG4gICAgICAgICAgcCA9IDBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChndGx0ID09PSAnPD0nKSB7XG4gICAgICAgIC8vIDw9MC43LnggaXMgYWN0dWFsbHkgPDAuOC4wLCBzaW5jZSBhbnkgMC43Lnggc2hvdWxkXG4gICAgICAgIC8vIHBhc3MuICBTaW1pbGFybHksIDw9Ny54IGlzIGFjdHVhbGx5IDw4LjAuMCwgZXRjLlxuICAgICAgICBndGx0ID0gJzwnXG4gICAgICAgIGlmICh4bSkge1xuICAgICAgICAgIE0gPSArTSArIDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtID0gK20gKyAxXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGd0bHQgPT09ICc8JylcbiAgICAgICAgcHIgPSAnLTAnXG5cbiAgICAgIHJldCA9IGAke2d0bHQgKyBNfS4ke219LiR7cH0ke3ByfWBcbiAgICB9IGVsc2UgaWYgKHhtKSB7XG4gICAgICByZXQgPSBgPj0ke019LjAuMCR7cHJ9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgfSBlbHNlIGlmICh4cCkge1xuICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3ByXG4gICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgfVxuXG4gICAgZGVidWcoJ3hSYW5nZSByZXR1cm4nLCByZXQpXG5cbiAgICByZXR1cm4gcmV0XG4gIH0pXG59XG5cbi8vIEJlY2F1c2UgKiBpcyBBTkQtZWQgd2l0aCBldmVyeXRoaW5nIGVsc2UgaW4gdGhlIGNvbXBhcmF0b3IsXG4vLyBhbmQgJycgbWVhbnMgXCJhbnkgdmVyc2lvblwiLCBqdXN0IHJlbW92ZSB0aGUgKnMgZW50aXJlbHkuXG5jb25zdCByZXBsYWNlU3RhcnMgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygncmVwbGFjZVN0YXJzJywgY29tcCwgb3B0aW9ucylcbiAgLy8gTG9vc2VuZXNzIGlzIGlnbm9yZWQgaGVyZS4gIHN0YXIgaXMgYWx3YXlzIGFzIGxvb3NlIGFzIGl0IGdldHMhXG4gIHJldHVybiBjb21wLnRyaW0oKS5yZXBsYWNlKHJlW3QuU1RBUl0sICcnKVxufVxuXG5jb25zdCByZXBsYWNlR1RFMCA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlR1RFMCcsIGNvbXAsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wLnRyaW0oKVxuICAgIC5yZXBsYWNlKHJlW29wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyB0LkdURTBQUkUgOiB0LkdURTBdLCAnJylcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBwYXNzZWQgdG8gc3RyaW5nLnJlcGxhY2UocmVbdC5IWVBIRU5SQU5HRV0pXG4vLyBNLCBtLCBwYXRjaCwgcHJlcmVsZWFzZSwgYnVpbGRcbi8vIDEuMiAtIDMuNC41ID0+ID49MS4yLjAgPD0zLjQuNVxuLy8gMS4yLjMgLSAzLjQgPT4gPj0xLjIuMCA8My41LjAtMCBBbnkgMy40Lnggd2lsbCBkb1xuLy8gMS4yIC0gMy40ID0+ID49MS4yLjAgPDMuNS4wLTBcbmNvbnN0IGh5cGhlblJlcGxhY2UgPSBpbmNQciA9PiAoJDAsXG4gIGZyb20sIGZNLCBmbSwgZnAsIGZwciwgZmIsXG4gIHRvLCB0TSwgdG0sIHRwLCB0cHIsIHRiKSA9PiB7XG4gIGlmIChpc1goZk0pKSB7XG4gICAgZnJvbSA9ICcnXG4gIH0gZWxzZSBpZiAoaXNYKGZtKSkge1xuICAgIGZyb20gPSBgPj0ke2ZNfS4wLjAke2luY1ByID8gJy0wJyA6ICcnfWBcbiAgfSBlbHNlIGlmIChpc1goZnApKSB7XG4gICAgZnJvbSA9IGA+PSR7Zk19LiR7Zm19LjAke2luY1ByID8gJy0wJyA6ICcnfWBcbiAgfSBlbHNlIGlmIChmcHIpIHtcbiAgICBmcm9tID0gYD49JHtmcm9tfWBcbiAgfSBlbHNlIHtcbiAgICBmcm9tID0gYD49JHtmcm9tfSR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9XG5cbiAgaWYgKGlzWCh0TSkpIHtcbiAgICB0byA9ICcnXG4gIH0gZWxzZSBpZiAoaXNYKHRtKSkge1xuICAgIHRvID0gYDwkeyt0TSArIDF9LjAuMC0wYFxuICB9IGVsc2UgaWYgKGlzWCh0cCkpIHtcbiAgICB0byA9IGA8JHt0TX0uJHsrdG0gKyAxfS4wLTBgXG4gIH0gZWxzZSBpZiAodHByKSB7XG4gICAgdG8gPSBgPD0ke3RNfS4ke3RtfS4ke3RwfS0ke3Rwcn1gXG4gIH0gZWxzZSBpZiAoaW5jUHIpIHtcbiAgICB0byA9IGA8JHt0TX0uJHt0bX0uJHsrdHAgKyAxfS0wYFxuICB9IGVsc2Uge1xuICAgIHRvID0gYDw9JHt0b31gXG4gIH1cblxuICByZXR1cm4gKGAke2Zyb219ICR7dG99YCkudHJpbSgpXG59XG5cbmNvbnN0IHRlc3RTZXQgPSAoc2V0LCB2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFzZXRbaV0udGVzdCh2ZXJzaW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgaWYgKHZlcnNpb24ucHJlcmVsZWFzZS5sZW5ndGggJiYgIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAvLyBGaW5kIHRoZSBzZXQgb2YgdmVyc2lvbnMgdGhhdCBhcmUgYWxsb3dlZCB0byBoYXZlIHByZXJlbGVhc2VzXG4gICAgLy8gRm9yIGV4YW1wbGUsIF4xLjIuMy1wci4xIGRlc3VnYXJzIHRvID49MS4yLjMtcHIuMSA8Mi4wLjBcbiAgICAvLyBUaGF0IHNob3VsZCBhbGxvdyBgMS4yLjMtcHIuMmAgdG8gcGFzcy5cbiAgICAvLyBIb3dldmVyLCBgMS4yLjQtYWxwaGEubm90cmVhZHlgIHNob3VsZCBOT1QgYmUgYWxsb3dlZCxcbiAgICAvLyBldmVuIHRob3VnaCBpdCdzIHdpdGhpbiB0aGUgcmFuZ2Ugc2V0IGJ5IHRoZSBjb21wYXJhdG9ycy5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgZGVidWcoc2V0W2ldLnNlbXZlcilcbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyID09PSBDb21wYXJhdG9yLkFOWSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAoc2V0W2ldLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IHNldFtpXS5zZW12ZXJcbiAgICAgICAgaWYgKGFsbG93ZWQubWFqb3IgPT09IHZlcnNpb24ubWFqb3IgJiZcbiAgICAgICAgICAgIGFsbG93ZWQubWlub3IgPT09IHZlcnNpb24ubWlub3IgJiZcbiAgICAgICAgICAgIGFsbG93ZWQucGF0Y2ggPT09IHZlcnNpb24ucGF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmVyc2lvbiBoYXMgYSAtcHJlLCBidXQgaXQncyBub3Qgb25lIG9mIHRoZSBvbmVzIHdlIGxpa2UuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwiY29uc3QgQU5ZID0gU3ltYm9sKCdTZW1WZXIgQU5ZJylcbi8vIGhvaXN0ZWQgY2xhc3MgZm9yIGN5Y2xpYyBkZXBlbmRlbmN5XG5jbGFzcyBDb21wYXJhdG9yIHtcbiAgc3RhdGljIGdldCBBTlkgKCkge1xuICAgIHJldHVybiBBTllcbiAgfVxuICBjb25zdHJ1Y3RvciAoY29tcCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucylcblxuICAgIGlmIChjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikge1xuICAgICAgaWYgKGNvbXAubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSkge1xuICAgICAgICByZXR1cm4gY29tcFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcCA9IGNvbXAudmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWJ1ZygnY29tcGFyYXRvcicsIGNvbXAsIG9wdGlvbnMpXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgICB0aGlzLnBhcnNlKGNvbXApXG5cbiAgICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgdGhpcy52YWx1ZSA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm9wZXJhdG9yICsgdGhpcy5zZW12ZXIudmVyc2lvblxuICAgIH1cblxuICAgIGRlYnVnKCdjb21wJywgdGhpcylcbiAgfVxuXG4gIHBhcnNlIChjb21wKSB7XG4gICAgY29uc3QgciA9IHRoaXMub3B0aW9ucy5sb29zZSA/IHJlW3QuQ09NUEFSQVRPUkxPT1NFXSA6IHJlW3QuQ09NUEFSQVRPUl1cbiAgICBjb25zdCBtID0gY29tcC5tYXRjaChyKVxuXG4gICAgaWYgKCFtKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGNvbXBhcmF0b3I6ICR7Y29tcH1gKVxuICAgIH1cblxuICAgIHRoaXMub3BlcmF0b3IgPSBtWzFdICE9PSB1bmRlZmluZWQgPyBtWzFdIDogJydcbiAgICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJz0nKSB7XG4gICAgICB0aGlzLm9wZXJhdG9yID0gJydcbiAgICB9XG5cbiAgICAvLyBpZiBpdCBsaXRlcmFsbHkgaXMganVzdCAnPicgb3IgJycgdGhlbiBhbGxvdyBhbnl0aGluZy5cbiAgICBpZiAoIW1bMl0pIHtcbiAgICAgIHRoaXMuc2VtdmVyID0gQU5ZXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VtdmVyID0gbmV3IFNlbVZlcihtWzJdLCB0aGlzLm9wdGlvbnMubG9vc2UpXG4gICAgfVxuICB9XG5cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlXG4gIH1cblxuICB0ZXN0ICh2ZXJzaW9uKSB7XG4gICAgZGVidWcoJ0NvbXBhcmF0b3IudGVzdCcsIHZlcnNpb24sIHRoaXMub3B0aW9ucy5sb29zZSlcblxuICAgIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZIHx8IHZlcnNpb24gPT09IEFOWSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY21wKHZlcnNpb24sIHRoaXMub3BlcmF0b3IsIHRoaXMuc2VtdmVyLCB0aGlzLm9wdGlvbnMpXG4gIH1cblxuICBpbnRlcnNlY3RzIChjb21wLCBvcHRpb25zKSB7XG4gICAgaWYgKCEoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIENvbXBhcmF0b3IgaXMgcmVxdWlyZWQnKVxuICAgIH1cblxuICAgIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIGxvb3NlOiAhIW9wdGlvbnMsXG4gICAgICAgIGluY2x1ZGVQcmVyZWxlYXNlOiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSAnJykge1xuICAgICAgaWYgKHRoaXMudmFsdWUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKGNvbXAudmFsdWUsIG9wdGlvbnMpLnRlc3QodGhpcy52YWx1ZSlcbiAgICB9IGVsc2UgaWYgKGNvbXAub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgICBpZiAoY29tcC52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmFuZ2UodGhpcy52YWx1ZSwgb3B0aW9ucykudGVzdChjb21wLnNlbXZlcilcbiAgICB9XG5cbiAgICBjb25zdCBzYW1lRGlyZWN0aW9uSW5jcmVhc2luZyA9XG4gICAgICAodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPicpICYmXG4gICAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPicpXG4gICAgY29uc3Qgc2FtZURpcmVjdGlvbkRlY3JlYXNpbmcgPVxuICAgICAgKHRoaXMub3BlcmF0b3IgPT09ICc8PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJzwnKSAmJlxuICAgICAgKGNvbXAub3BlcmF0b3IgPT09ICc8PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzwnKVxuICAgIGNvbnN0IHNhbWVTZW1WZXIgPSB0aGlzLnNlbXZlci52ZXJzaW9uID09PSBjb21wLnNlbXZlci52ZXJzaW9uXG4gICAgY29uc3QgZGlmZmVyZW50RGlyZWN0aW9uc0luY2x1c2l2ZSA9XG4gICAgICAodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPD0nKSAmJlxuICAgICAgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzw9JylcbiAgICBjb25zdCBvcHBvc2l0ZURpcmVjdGlvbnNMZXNzVGhhbiA9XG4gICAgICBjbXAodGhpcy5zZW12ZXIsICc8JywgY29tcC5zZW12ZXIsIG9wdGlvbnMpICYmXG4gICAgICAodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPicpICYmXG4gICAgICAgIChjb21wLm9wZXJhdG9yID09PSAnPD0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8JylcbiAgICBjb25zdCBvcHBvc2l0ZURpcmVjdGlvbnNHcmVhdGVyVGhhbiA9XG4gICAgICBjbXAodGhpcy5zZW12ZXIsICc+JywgY29tcC5zZW12ZXIsIG9wdGlvbnMpICYmXG4gICAgICAodGhpcy5vcGVyYXRvciA9PT0gJzw9JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPCcpICYmXG4gICAgICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc+JylcblxuICAgIHJldHVybiAoXG4gICAgICBzYW1lRGlyZWN0aW9uSW5jcmVhc2luZyB8fFxuICAgICAgc2FtZURpcmVjdGlvbkRlY3JlYXNpbmcgfHxcbiAgICAgIChzYW1lU2VtVmVyICYmIGRpZmZlcmVudERpcmVjdGlvbnNJbmNsdXNpdmUpIHx8XG4gICAgICBvcHBvc2l0ZURpcmVjdGlvbnNMZXNzVGhhbiB8fFxuICAgICAgb3Bwb3NpdGVEaXJlY3Rpb25zR3JlYXRlclRoYW5cbiAgICApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wYXJhdG9yXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3Qge3JlLCB0fSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcbmNvbnN0IGNtcCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9jbXAnKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4vcmFuZ2UnKVxuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHNhdGlzZmllcyA9ICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICB0cnkge1xuICAgIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiByYW5nZS50ZXN0KHZlcnNpb24pXG59XG5tb2R1bGUuZXhwb3J0cyA9IHNhdGlzZmllc1xuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcblxuLy8gTW9zdGx5IGp1c3QgZm9yIHRlc3RpbmcgYW5kIGxlZ2FjeSBBUEkgcmVhc29uc1xuY29uc3QgdG9Db21wYXJhdG9ycyA9IChyYW5nZSwgb3B0aW9ucykgPT5cbiAgbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKS5zZXRcbiAgICAubWFwKGNvbXAgPT4gY29tcC5tYXAoYyA9PiBjLnZhbHVlKS5qb2luKCcgJykudHJpbSgpLnNwbGl0KCcgJykpXG5cbm1vZHVsZS5leHBvcnRzID0gdG9Db21wYXJhdG9yc1xuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcblxuY29uc3QgbWF4U2F0aXNmeWluZyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgbGV0IG1heCA9IG51bGxcbiAgbGV0IG1heFNWID0gbnVsbFxuICBsZXQgcmFuZ2VPYmogPSBudWxsXG4gIHRyeSB7XG4gICAgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHtcbiAgICAgIC8vIHNhdGlzZmllcyh2LCByYW5nZSwgb3B0aW9ucylcbiAgICAgIGlmICghbWF4IHx8IG1heFNWLmNvbXBhcmUodikgPT09IC0xKSB7XG4gICAgICAgIC8vIGNvbXBhcmUobWF4LCB2LCB0cnVlKVxuICAgICAgICBtYXggPSB2XG4gICAgICAgIG1heFNWID0gbmV3IFNlbVZlcihtYXgsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWF4XG59XG5tb2R1bGUuZXhwb3J0cyA9IG1heFNhdGlzZnlpbmdcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBtaW5TYXRpc2Z5aW5nID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBsZXQgbWluID0gbnVsbFxuICBsZXQgbWluU1YgPSBudWxsXG4gIGxldCByYW5nZU9iaiA9IG51bGxcbiAgdHJ5IHtcbiAgICByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZlcnNpb25zLmZvckVhY2goKHYpID0+IHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkge1xuICAgICAgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtaW4gfHwgbWluU1YuY29tcGFyZSh2KSA9PT0gMSkge1xuICAgICAgICAvLyBjb21wYXJlKG1pbiwgdiwgdHJ1ZSlcbiAgICAgICAgbWluID0gdlxuICAgICAgICBtaW5TViA9IG5ldyBTZW1WZXIobWluLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG1pblxufVxubW9kdWxlLmV4cG9ydHMgPSBtaW5TYXRpc2Z5aW5nXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3QnKVxuXG5jb25zdCBtaW5WZXJzaW9uID0gKHJhbmdlLCBsb29zZSkgPT4ge1xuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpXG5cbiAgbGV0IG1pbnZlciA9IG5ldyBTZW1WZXIoJzAuMC4wJylcbiAgaWYgKHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXJcbiAgfVxuXG4gIG1pbnZlciA9IG5ldyBTZW1WZXIoJzAuMC4wLTAnKVxuICBpZiAocmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgbWludmVyID0gbnVsbFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldXG5cbiAgICBsZXQgc2V0TWluID0gbnVsbFxuICAgIGNvbXBhcmF0b3JzLmZvckVhY2goKGNvbXBhcmF0b3IpID0+IHtcbiAgICAgIC8vIENsb25lIHRvIGF2b2lkIG1hbmlwdWxhdGluZyB0aGUgY29tcGFyYXRvcidzIHNlbXZlciBvYmplY3QuXG4gICAgICBjb25zdCBjb21wdmVyID0gbmV3IFNlbVZlcihjb21wYXJhdG9yLnNlbXZlci52ZXJzaW9uKVxuICAgICAgc3dpdGNoIChjb21wYXJhdG9yLm9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgIGlmIChjb21wdmVyLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb21wdmVyLnBhdGNoKytcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcHZlci5wcmVyZWxlYXNlLnB1c2goMClcbiAgICAgICAgICB9XG4gICAgICAgICAgY29tcHZlci5yYXcgPSBjb21wdmVyLmZvcm1hdCgpXG4gICAgICAgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgIGlmICghc2V0TWluIHx8IGd0KGNvbXB2ZXIsIHNldE1pbikpIHtcbiAgICAgICAgICAgIHNldE1pbiA9IGNvbXB2ZXJcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAvKiBJZ25vcmUgbWF4aW11bSB2ZXJzaW9ucyAqL1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG9wZXJhdGlvbjogJHtjb21wYXJhdG9yLm9wZXJhdG9yfWApXG4gICAgICB9XG4gICAgfSlcbiAgICBpZiAoc2V0TWluICYmICghbWludmVyIHx8IGd0KG1pbnZlciwgc2V0TWluKSkpXG4gICAgICBtaW52ZXIgPSBzZXRNaW5cbiAgfVxuXG4gIGlmIChtaW52ZXIgJiYgcmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gbWluVmVyc2lvblxuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHZhbGlkUmFuZ2UgPSAocmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBSZXR1cm4gJyonIGluc3RlYWQgb2YgJycgc28gdGhhdCB0cnV0aGluZXNzIHdvcmtzLlxuICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiBpdCdzIGludmFsaWQgYW55d2F5XG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucykucmFuZ2UgfHwgJyonXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZFJhbmdlXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBDb21wYXJhdG9yID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9jb21wYXJhdG9yJylcbmNvbnN0IHtBTll9ID0gQ29tcGFyYXRvclxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3QnKVxuY29uc3QgbHQgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvbHQnKVxuY29uc3QgbHRlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2x0ZScpXG5jb25zdCBndGUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3RlJylcblxuY29uc3Qgb3V0c2lkZSA9ICh2ZXJzaW9uLCByYW5nZSwgaGlsbywgb3B0aW9ucykgPT4ge1xuICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKVxuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcblxuICBsZXQgZ3RmbiwgbHRlZm4sIGx0Zm4sIGNvbXAsIGVjb21wXG4gIHN3aXRjaCAoaGlsbykge1xuICAgIGNhc2UgJz4nOlxuICAgICAgZ3RmbiA9IGd0XG4gICAgICBsdGVmbiA9IGx0ZVxuICAgICAgbHRmbiA9IGx0XG4gICAgICBjb21wID0gJz4nXG4gICAgICBlY29tcCA9ICc+PSdcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnPCc6XG4gICAgICBndGZuID0gbHRcbiAgICAgIGx0ZWZuID0gZ3RlXG4gICAgICBsdGZuID0gZ3RcbiAgICAgIGNvbXAgPSAnPCdcbiAgICAgIGVjb21wID0gJzw9J1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBwcm92aWRlIGEgaGlsbyB2YWwgb2YgXCI8XCIgb3IgXCI+XCInKVxuICB9XG5cbiAgLy8gSWYgaXQgc2F0aXNmaWVzIHRoZSByYW5nZSBpdCBpcyBub3Qgb3V0c2lkZVxuICBpZiAoc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gRnJvbSBub3cgb24sIHZhcmlhYmxlIHRlcm1zIGFyZSBhcyBpZiB3ZSdyZSBpbiBcImd0clwiIG1vZGUuXG4gIC8vIGJ1dCBub3RlIHRoYXQgZXZlcnl0aGluZyBpcyBmbGlwcGVkIGZvciB0aGUgXCJsdHJcIiBmdW5jdGlvbi5cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldXG5cbiAgICBsZXQgaGlnaCA9IG51bGxcbiAgICBsZXQgbG93ID0gbnVsbFxuXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaCgoY29tcGFyYXRvcikgPT4ge1xuICAgICAgaWYgKGNvbXBhcmF0b3Iuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IG5ldyBDb21wYXJhdG9yKCc+PTAuMC4wJylcbiAgICAgIH1cbiAgICAgIGhpZ2ggPSBoaWdoIHx8IGNvbXBhcmF0b3JcbiAgICAgIGxvdyA9IGxvdyB8fCBjb21wYXJhdG9yXG4gICAgICBpZiAoZ3Rmbihjb21wYXJhdG9yLnNlbXZlciwgaGlnaC5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGhpZ2ggPSBjb21wYXJhdG9yXG4gICAgICB9IGVsc2UgaWYgKGx0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGxvdy5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGxvdyA9IGNvbXBhcmF0b3JcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gSWYgdGhlIGVkZ2UgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhIG9wZXJhdG9yIHRoZW4gb3VyIHZlcnNpb25cbiAgICAvLyBpc24ndCBvdXRzaWRlIGl0XG4gICAgaWYgKGhpZ2gub3BlcmF0b3IgPT09IGNvbXAgfHwgaGlnaC5vcGVyYXRvciA9PT0gZWNvbXApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBsb3dlc3QgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhbiBvcGVyYXRvciBhbmQgb3VyIHZlcnNpb25cbiAgICAvLyBpcyBsZXNzIHRoYW4gaXQgdGhlbiBpdCBpc24ndCBoaWdoZXIgdGhhbiB0aGUgcmFuZ2VcbiAgICBpZiAoKCFsb3cub3BlcmF0b3IgfHwgbG93Lm9wZXJhdG9yID09PSBjb21wKSAmJlxuICAgICAgICBsdGVmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIGlmIChsb3cub3BlcmF0b3IgPT09IGVjb21wICYmIGx0Zm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG91dHNpZGVcbiIsIi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGdyZWF0ZXIgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZS5cbmNvbnN0IG91dHNpZGUgPSByZXF1aXJlKCcuL291dHNpZGUnKVxuY29uc3QgZ3RyID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPicsIG9wdGlvbnMpXG5tb2R1bGUuZXhwb3J0cyA9IGd0clxuIiwiY29uc3Qgb3V0c2lkZSA9IHJlcXVpcmUoJy4vb3V0c2lkZScpXG4vLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBsZXNzIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2VcbmNvbnN0IGx0ciA9ICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykgPT4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJzwnLCBvcHRpb25zKVxubW9kdWxlLmV4cG9ydHMgPSBsdHJcbiIsImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBpbnRlcnNlY3RzID0gKHIxLCByMiwgb3B0aW9ucykgPT4ge1xuICByMSA9IG5ldyBSYW5nZShyMSwgb3B0aW9ucylcbiAgcjIgPSBuZXcgUmFuZ2UocjIsIG9wdGlvbnMpXG4gIHJldHVybiByMS5pbnRlcnNlY3RzKHIyKVxufVxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcnNlY3RzXG4iLCIvLyBnaXZlbiBhIHNldCBvZiB2ZXJzaW9ucyBhbmQgYSByYW5nZSwgY3JlYXRlIGEgXCJzaW1wbGlmaWVkXCIgcmFuZ2Vcbi8vIHRoYXQgaW5jbHVkZXMgdGhlIHNhbWUgdmVyc2lvbnMgdGhhdCB0aGUgb3JpZ2luYWwgcmFuZ2UgZG9lc1xuLy8gSWYgdGhlIG9yaWdpbmFsIHJhbmdlIGlzIHNob3J0ZXIgdGhhbiB0aGUgc2ltcGxpZmllZCBvbmUsIHJldHVybiB0aGF0LlxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcy5qcycpXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NvbXBhcmUuanMnKVxubW9kdWxlLmV4cG9ydHMgPSAodmVyc2lvbnMsIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHNldCA9IFtdXG4gIGxldCBtaW4gPSBudWxsXG4gIGxldCBwcmV2ID0gbnVsbFxuICBjb25zdCB2ID0gdmVyc2lvbnMuc29ydCgoYSwgYikgPT4gY29tcGFyZShhLCBiLCBvcHRpb25zKSlcbiAgZm9yIChjb25zdCB2ZXJzaW9uIG9mIHYpIHtcbiAgICBjb25zdCBpbmNsdWRlZCA9IHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucylcbiAgICBpZiAoaW5jbHVkZWQpIHtcbiAgICAgIHByZXYgPSB2ZXJzaW9uXG4gICAgICBpZiAoIW1pbilcbiAgICAgICAgbWluID0gdmVyc2lvblxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJldikge1xuICAgICAgICBzZXQucHVzaChbbWluLCBwcmV2XSlcbiAgICAgIH1cbiAgICAgIHByZXYgPSBudWxsXG4gICAgICBtaW4gPSBudWxsXG4gICAgfVxuICB9XG4gIGlmIChtaW4pXG4gICAgc2V0LnB1c2goW21pbiwgbnVsbF0pXG5cbiAgY29uc3QgcmFuZ2VzID0gW11cbiAgZm9yIChjb25zdCBbbWluLCBtYXhdIG9mIHNldCkge1xuICAgIGlmIChtaW4gPT09IG1heClcbiAgICAgIHJhbmdlcy5wdXNoKG1pbilcbiAgICBlbHNlIGlmICghbWF4ICYmIG1pbiA9PT0gdlswXSlcbiAgICAgIHJhbmdlcy5wdXNoKCcqJylcbiAgICBlbHNlIGlmICghbWF4KVxuICAgICAgcmFuZ2VzLnB1c2goYD49JHttaW59YClcbiAgICBlbHNlIGlmIChtaW4gPT09IHZbMF0pXG4gICAgICByYW5nZXMucHVzaChgPD0ke21heH1gKVxuICAgIGVsc2VcbiAgICAgIHJhbmdlcy5wdXNoKGAke21pbn0gLSAke21heH1gKVxuICB9XG4gIGNvbnN0IHNpbXBsaWZpZWQgPSByYW5nZXMuam9pbignIHx8ICcpXG4gIGNvbnN0IG9yaWdpbmFsID0gdHlwZW9mIHJhbmdlLnJhdyA9PT0gJ3N0cmluZycgPyByYW5nZS5yYXcgOiBTdHJpbmcocmFuZ2UpXG4gIHJldHVybiBzaW1wbGlmaWVkLmxlbmd0aCA8IG9yaWdpbmFsLmxlbmd0aCA/IHNpbXBsaWZpZWQgOiByYW5nZVxufVxuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlLmpzJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuLi9jbGFzc2VzL2NvbXBhcmF0b3IuanMnKVxuY29uc3QgeyBBTlkgfSA9IENvbXBhcmF0b3JcbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMuanMnKVxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9jb21wYXJlLmpzJylcblxuLy8gQ29tcGxleCByYW5nZSBgcjEgfHwgcjIgfHwgLi4uYCBpcyBhIHN1YnNldCBvZiBgUjEgfHwgUjIgfHwgLi4uYCBpZmY6XG4vLyAtIEV2ZXJ5IHNpbXBsZSByYW5nZSBgcjEsIHIyLCAuLi5gIGlzIGEgbnVsbCBzZXQsIE9SXG4vLyAtIEV2ZXJ5IHNpbXBsZSByYW5nZSBgcjEsIHIyLCAuLi5gIHdoaWNoIGlzIG5vdCBhIG51bGwgc2V0IGlzIGEgc3Vic2V0IG9mXG4vLyAgIHNvbWUgYFIxLCBSMiwgLi4uYFxuLy9cbi8vIFNpbXBsZSByYW5nZSBgYzEgYzIgLi4uYCBpcyBhIHN1YnNldCBvZiBzaW1wbGUgcmFuZ2UgYEMxIEMyIC4uLmAgaWZmOlxuLy8gLSBJZiBjIGlzIG9ubHkgdGhlIEFOWSBjb21wYXJhdG9yXG4vLyAgIC0gSWYgQyBpcyBvbmx5IHRoZSBBTlkgY29tcGFyYXRvciwgcmV0dXJuIHRydWVcbi8vICAgLSBFbHNlIGlmIGluIHByZXJlbGVhc2UgbW9kZSwgcmV0dXJuIGZhbHNlXG4vLyAgIC0gZWxzZSByZXBsYWNlIGMgd2l0aCBgWz49MC4wLjBdYFxuLy8gLSBJZiBDIGlzIG9ubHkgdGhlIEFOWSBjb21wYXJhdG9yXG4vLyAgIC0gaWYgaW4gcHJlcmVsZWFzZSBtb2RlLCByZXR1cm4gdHJ1ZVxuLy8gICAtIGVsc2UgcmVwbGFjZSBDIHdpdGggYFs+PTAuMC4wXWBcbi8vIC0gTGV0IEVRIGJlIHRoZSBzZXQgb2YgPSBjb21wYXJhdG9ycyBpbiBjXG4vLyAtIElmIEVRIGlzIG1vcmUgdGhhbiBvbmUsIHJldHVybiB0cnVlIChudWxsIHNldClcbi8vIC0gTGV0IEdUIGJlIHRoZSBoaWdoZXN0ID4gb3IgPj0gY29tcGFyYXRvciBpbiBjXG4vLyAtIExldCBMVCBiZSB0aGUgbG93ZXN0IDwgb3IgPD0gY29tcGFyYXRvciBpbiBjXG4vLyAtIElmIEdUIGFuZCBMVCwgYW5kIEdULnNlbXZlciA+IExULnNlbXZlciwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gLSBJZiBhbnkgQyBpcyBhID0gcmFuZ2UsIGFuZCBHVCBvciBMVCBhcmUgc2V0LCByZXR1cm4gZmFsc2Vcbi8vIC0gSWYgRVFcbi8vICAgLSBJZiBHVCwgYW5kIEVRIGRvZXMgbm90IHNhdGlzZnkgR1QsIHJldHVybiB0cnVlIChudWxsIHNldClcbi8vICAgLSBJZiBMVCwgYW5kIEVRIGRvZXMgbm90IHNhdGlzZnkgTFQsIHJldHVybiB0cnVlIChudWxsIHNldClcbi8vICAgLSBJZiBFUSBzYXRpc2ZpZXMgZXZlcnkgQywgcmV0dXJuIHRydWVcbi8vICAgLSBFbHNlIHJldHVybiBmYWxzZVxuLy8gLSBJZiBHVFxuLy8gICAtIElmIEdULnNlbXZlciBpcyBsb3dlciB0aGFuIGFueSA+IG9yID49IGNvbXAgaW4gQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgR1QgaXMgPj0sIGFuZCBHVC5zZW12ZXIgZG9lcyBub3Qgc2F0aXNmeSBldmVyeSBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVC5zZW12ZXIgaGFzIGEgcHJlcmVsZWFzZSwgYW5kIG5vdCBpbiBwcmVyZWxlYXNlIG1vZGVcbi8vICAgICAtIElmIG5vIEMgaGFzIGEgcHJlcmVsZWFzZSBhbmQgdGhlIEdULnNlbXZlciB0dXBsZSwgcmV0dXJuIGZhbHNlXG4vLyAtIElmIExUXG4vLyAgIC0gSWYgTFQuc2VtdmVyIGlzIGdyZWF0ZXIgdGhhbiBhbnkgPCBvciA8PSBjb21wIGluIEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIExUIGlzIDw9LCBhbmQgTFQuc2VtdmVyIGRvZXMgbm90IHNhdGlzZnkgZXZlcnkgQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgR1Quc2VtdmVyIGhhcyBhIHByZXJlbGVhc2UsIGFuZCBub3QgaW4gcHJlcmVsZWFzZSBtb2RlXG4vLyAgICAgLSBJZiBubyBDIGhhcyBhIHByZXJlbGVhc2UgYW5kIHRoZSBMVC5zZW12ZXIgdHVwbGUsIHJldHVybiBmYWxzZVxuLy8gLSBFbHNlIHJldHVybiB0cnVlXG5cbmNvbnN0IHN1YnNldCA9IChzdWIsIGRvbSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGlmIChzdWIgPT09IGRvbSlcbiAgICByZXR1cm4gdHJ1ZVxuXG4gIHN1YiA9IG5ldyBSYW5nZShzdWIsIG9wdGlvbnMpXG4gIGRvbSA9IG5ldyBSYW5nZShkb20sIG9wdGlvbnMpXG4gIGxldCBzYXdOb25OdWxsID0gZmFsc2VcblxuICBPVVRFUjogZm9yIChjb25zdCBzaW1wbGVTdWIgb2Ygc3ViLnNldCkge1xuICAgIGZvciAoY29uc3Qgc2ltcGxlRG9tIG9mIGRvbS5zZXQpIHtcbiAgICAgIGNvbnN0IGlzU3ViID0gc2ltcGxlU3Vic2V0KHNpbXBsZVN1Yiwgc2ltcGxlRG9tLCBvcHRpb25zKVxuICAgICAgc2F3Tm9uTnVsbCA9IHNhd05vbk51bGwgfHwgaXNTdWIgIT09IG51bGxcbiAgICAgIGlmIChpc1N1YilcbiAgICAgICAgY29udGludWUgT1VURVJcbiAgICB9XG4gICAgLy8gdGhlIG51bGwgc2V0IGlzIGEgc3Vic2V0IG9mIGV2ZXJ5dGhpbmcsIGJ1dCBudWxsIHNpbXBsZSByYW5nZXMgaW5cbiAgICAvLyBhIGNvbXBsZXggcmFuZ2Ugc2hvdWxkIGJlIGlnbm9yZWQuICBzbyBpZiB3ZSBzYXcgYSBub24tbnVsbCByYW5nZSxcbiAgICAvLyB0aGVuIHdlIGtub3cgdGhpcyBpc24ndCBhIHN1YnNldCwgYnV0IGlmIEVWRVJZIHNpbXBsZSByYW5nZSB3YXMgbnVsbCxcbiAgICAvLyB0aGVuIGl0IGlzIGEgc3Vic2V0LlxuICAgIGlmIChzYXdOb25OdWxsKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuY29uc3Qgc2ltcGxlU3Vic2V0ID0gKHN1YiwgZG9tLCBvcHRpb25zKSA9PiB7XG4gIGlmIChzdWIgPT09IGRvbSlcbiAgICByZXR1cm4gdHJ1ZVxuXG4gIGlmIChzdWIubGVuZ3RoID09PSAxICYmIHN1YlswXS5zZW12ZXIgPT09IEFOWSkge1xuICAgIGlmIChkb20ubGVuZ3RoID09PSAxICYmIGRvbVswXS5zZW12ZXIgPT09IEFOWSlcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZWxzZSBpZiAob3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSlcbiAgICAgIHN1YiA9IFsgbmV3IENvbXBhcmF0b3IoJz49MC4wLjAtMCcpIF1cbiAgICBlbHNlXG4gICAgICBzdWIgPSBbIG5ldyBDb21wYXJhdG9yKCc+PTAuMC4wJykgXVxuICB9XG5cbiAgaWYgKGRvbS5sZW5ndGggPT09IDEgJiYgZG9tWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgaWYgKG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGVsc2VcbiAgICAgIGRvbSA9IFsgbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKSBdXG4gIH1cblxuICBjb25zdCBlcVNldCA9IG5ldyBTZXQoKVxuICBsZXQgZ3QsIGx0XG4gIGZvciAoY29uc3QgYyBvZiBzdWIpIHtcbiAgICBpZiAoYy5vcGVyYXRvciA9PT0gJz4nIHx8IGMub3BlcmF0b3IgPT09ICc+PScpXG4gICAgICBndCA9IGhpZ2hlckdUKGd0LCBjLCBvcHRpb25zKVxuICAgIGVsc2UgaWYgKGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nKVxuICAgICAgbHQgPSBsb3dlckxUKGx0LCBjLCBvcHRpb25zKVxuICAgIGVsc2VcbiAgICAgIGVxU2V0LmFkZChjLnNlbXZlcilcbiAgfVxuXG4gIGlmIChlcVNldC5zaXplID4gMSlcbiAgICByZXR1cm4gbnVsbFxuXG4gIGxldCBndGx0Q29tcFxuICBpZiAoZ3QgJiYgbHQpIHtcbiAgICBndGx0Q29tcCA9IGNvbXBhcmUoZ3Quc2VtdmVyLCBsdC5zZW12ZXIsIG9wdGlvbnMpXG4gICAgaWYgKGd0bHRDb21wID4gMClcbiAgICAgIHJldHVybiBudWxsXG4gICAgZWxzZSBpZiAoZ3RsdENvbXAgPT09IDAgJiYgKGd0Lm9wZXJhdG9yICE9PSAnPj0nIHx8IGx0Lm9wZXJhdG9yICE9PSAnPD0nKSlcbiAgICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyB3aWxsIGl0ZXJhdGUgb25lIG9yIHplcm8gdGltZXNcbiAgZm9yIChjb25zdCBlcSBvZiBlcVNldCkge1xuICAgIGlmIChndCAmJiAhc2F0aXNmaWVzKGVxLCBTdHJpbmcoZ3QpLCBvcHRpb25zKSlcbiAgICAgIHJldHVybiBudWxsXG5cbiAgICBpZiAobHQgJiYgIXNhdGlzZmllcyhlcSwgU3RyaW5nKGx0KSwgb3B0aW9ucykpXG4gICAgICByZXR1cm4gbnVsbFxuXG4gICAgZm9yIChjb25zdCBjIG9mIGRvbSkge1xuICAgICAgaWYgKCFzYXRpc2ZpZXMoZXEsIFN0cmluZyhjKSwgb3B0aW9ucykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBsZXQgaGlnaGVyLCBsb3dlclxuICBsZXQgaGFzRG9tTFQsIGhhc0RvbUdUXG4gIC8vIGlmIHRoZSBzdWJzZXQgaGFzIGEgcHJlcmVsZWFzZSwgd2UgbmVlZCBhIGNvbXBhcmF0b3IgaW4gdGhlIHN1cGVyc2V0XG4gIC8vIHdpdGggdGhlIHNhbWUgdHVwbGUgYW5kIGEgcHJlcmVsZWFzZSwgb3IgaXQncyBub3QgYSBzdWJzZXRcbiAgbGV0IG5lZWREb21MVFByZSA9IGx0ICYmXG4gICAgIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiZcbiAgICBsdC5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggPyBsdC5zZW12ZXIgOiBmYWxzZVxuICBsZXQgbmVlZERvbUdUUHJlID0gZ3QgJiZcbiAgICAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJlxuICAgIGd0LnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA/IGd0LnNlbXZlciA6IGZhbHNlXG4gIC8vIGV4Y2VwdGlvbjogPDEuMi4zLTAgaXMgdGhlIHNhbWUgYXMgPDEuMi4zXG4gIGlmIChuZWVkRG9tTFRQcmUgJiYgbmVlZERvbUxUUHJlLnByZXJlbGVhc2UubGVuZ3RoID09PSAxICYmXG4gICAgICBsdC5vcGVyYXRvciA9PT0gJzwnICYmIG5lZWREb21MVFByZS5wcmVyZWxlYXNlWzBdID09PSAwKSB7XG4gICAgbmVlZERvbUxUUHJlID0gZmFsc2VcbiAgfVxuXG4gIGZvciAoY29uc3QgYyBvZiBkb20pIHtcbiAgICBoYXNEb21HVCA9IGhhc0RvbUdUIHx8IGMub3BlcmF0b3IgPT09ICc+JyB8fCBjLm9wZXJhdG9yID09PSAnPj0nXG4gICAgaGFzRG9tTFQgPSBoYXNEb21MVCB8fCBjLm9wZXJhdG9yID09PSAnPCcgfHwgYy5vcGVyYXRvciA9PT0gJzw9J1xuICAgIGlmIChndCkge1xuICAgICAgaWYgKG5lZWREb21HVFByZSkge1xuICAgICAgICBpZiAoYy5zZW12ZXIucHJlcmVsZWFzZSAmJiBjLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCAmJlxuICAgICAgICAgICAgYy5zZW12ZXIubWFqb3IgPT09IG5lZWREb21HVFByZS5tYWpvciAmJlxuICAgICAgICAgICAgYy5zZW12ZXIubWlub3IgPT09IG5lZWREb21HVFByZS5taW5vciAmJlxuICAgICAgICAgICAgYy5zZW12ZXIucGF0Y2ggPT09IG5lZWREb21HVFByZS5wYXRjaCkge1xuICAgICAgICAgIG5lZWREb21HVFByZSA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjLm9wZXJhdG9yID09PSAnPicgfHwgYy5vcGVyYXRvciA9PT0gJz49Jykge1xuICAgICAgICBoaWdoZXIgPSBoaWdoZXJHVChndCwgYywgb3B0aW9ucylcbiAgICAgICAgaWYgKGhpZ2hlciA9PT0gYyAmJiBoaWdoZXIgIT09IGd0KVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfSBlbHNlIGlmIChndC5vcGVyYXRvciA9PT0gJz49JyAmJiAhc2F0aXNmaWVzKGd0LnNlbXZlciwgU3RyaW5nKGMpLCBvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChsdCkge1xuICAgICAgaWYgKG5lZWREb21MVFByZSkge1xuICAgICAgICBpZiAoYy5zZW12ZXIucHJlcmVsZWFzZSAmJiBjLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCAmJlxuICAgICAgICAgICAgYy5zZW12ZXIubWFqb3IgPT09IG5lZWREb21MVFByZS5tYWpvciAmJlxuICAgICAgICAgICAgYy5zZW12ZXIubWlub3IgPT09IG5lZWREb21MVFByZS5taW5vciAmJlxuICAgICAgICAgICAgYy5zZW12ZXIucGF0Y2ggPT09IG5lZWREb21MVFByZS5wYXRjaCkge1xuICAgICAgICAgIG5lZWREb21MVFByZSA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjLm9wZXJhdG9yID09PSAnPCcgfHwgYy5vcGVyYXRvciA9PT0gJzw9Jykge1xuICAgICAgICBsb3dlciA9IGxvd2VyTFQobHQsIGMsIG9wdGlvbnMpXG4gICAgICAgIGlmIChsb3dlciA9PT0gYyAmJiBsb3dlciAhPT0gbHQpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9IGVsc2UgaWYgKGx0Lm9wZXJhdG9yID09PSAnPD0nICYmICFzYXRpc2ZpZXMobHQuc2VtdmVyLCBTdHJpbmcoYyksIG9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKCFjLm9wZXJhdG9yICYmIChsdCB8fCBndCkgJiYgZ3RsdENvbXAgIT09IDApXG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIGlmIHRoZXJlIHdhcyBhIDwgb3IgPiwgYW5kIG5vdGhpbmcgaW4gdGhlIGRvbSwgdGhlbiBtdXN0IGJlIGZhbHNlXG4gIC8vIFVOTEVTUyBpdCB3YXMgbGltaXRlZCBieSBhbm90aGVyIHJhbmdlIGluIHRoZSBvdGhlciBkaXJlY3Rpb24uXG4gIC8vIEVnLCA+MS4wLjAgPDEuMC4xIGlzIHN0aWxsIGEgc3Vic2V0IG9mIDwyLjAuMFxuICBpZiAoZ3QgJiYgaGFzRG9tTFQgJiYgIWx0ICYmIGd0bHRDb21wICE9PSAwKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIGlmIChsdCAmJiBoYXNEb21HVCAmJiAhZ3QgJiYgZ3RsdENvbXAgIT09IDApXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgLy8gd2UgbmVlZGVkIGEgcHJlcmVsZWFzZSByYW5nZSBpbiBhIHNwZWNpZmljIHR1cGxlLCBidXQgZGlkbid0IGdldCBvbmVcbiAgLy8gdGhlbiB0aGlzIGlzbid0IGEgc3Vic2V0LiAgZWcgPj0xLjIuMy1wcmUgaXMgbm90IGEgc3Vic2V0IG9mID49MS4wLjAsXG4gIC8vIGJlY2F1c2UgaXQgaW5jbHVkZXMgcHJlcmVsZWFzZXMgaW4gdGhlIDEuMi4zIHR1cGxlXG4gIGlmIChuZWVkRG9tR1RQcmUgfHwgbmVlZERvbUxUUHJlKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8vID49MS4yLjMgaXMgbG93ZXIgdGhhbiA+MS4yLjNcbmNvbnN0IGhpZ2hlckdUID0gKGEsIGIsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFhKVxuICAgIHJldHVybiBiXG4gIGNvbnN0IGNvbXAgPSBjb21wYXJlKGEuc2VtdmVyLCBiLnNlbXZlciwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAgPiAwID8gYVxuICAgIDogY29tcCA8IDAgPyBiXG4gICAgOiBiLm9wZXJhdG9yID09PSAnPicgJiYgYS5vcGVyYXRvciA9PT0gJz49JyA/IGJcbiAgICA6IGFcbn1cblxuLy8gPD0xLjIuMyBpcyBoaWdoZXIgdGhhbiA8MS4yLjNcbmNvbnN0IGxvd2VyTFQgPSAoYSwgYiwgb3B0aW9ucykgPT4ge1xuICBpZiAoIWEpXG4gICAgcmV0dXJuIGJcbiAgY29uc3QgY29tcCA9IGNvbXBhcmUoYS5zZW12ZXIsIGIuc2VtdmVyLCBvcHRpb25zKVxuICByZXR1cm4gY29tcCA8IDAgPyBhXG4gICAgOiBjb21wID4gMCA/IGJcbiAgICA6IGIub3BlcmF0b3IgPT09ICc8JyAmJiBhLm9wZXJhdG9yID09PSAnPD0nID8gYlxuICAgIDogYVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN1YnNldFxuIiwiLy8ganVzdCBwcmUtbG9hZCBhbGwgdGhlIHN0dWZmIHRoYXQgaW5kZXguanMgbGF6aWx5IGV4cG9ydHNcbmNvbnN0IGludGVybmFsUmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3JlJylcbm1vZHVsZS5leHBvcnRzID0ge1xuICByZTogaW50ZXJuYWxSZS5yZSxcbiAgc3JjOiBpbnRlcm5hbFJlLnNyYyxcbiAgdG9rZW5zOiBpbnRlcm5hbFJlLnQsXG4gIFNFTVZFUl9TUEVDX1ZFUlNJT046IHJlcXVpcmUoJy4vaW50ZXJuYWwvY29uc3RhbnRzJykuU0VNVkVSX1NQRUNfVkVSU0lPTixcbiAgU2VtVmVyOiByZXF1aXJlKCcuL2NsYXNzZXMvc2VtdmVyJyksXG4gIGNvbXBhcmVJZGVudGlmaWVyczogcmVxdWlyZSgnLi9pbnRlcm5hbC9pZGVudGlmaWVycycpLmNvbXBhcmVJZGVudGlmaWVycyxcbiAgcmNvbXBhcmVJZGVudGlmaWVyczogcmVxdWlyZSgnLi9pbnRlcm5hbC9pZGVudGlmaWVycycpLnJjb21wYXJlSWRlbnRpZmllcnMsXG4gIHBhcnNlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wYXJzZScpLFxuICB2YWxpZDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvdmFsaWQnKSxcbiAgY2xlYW46IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NsZWFuJyksXG4gIGluYzogcmVxdWlyZSgnLi9mdW5jdGlvbnMvaW5jJyksXG4gIGRpZmY6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2RpZmYnKSxcbiAgbWFqb3I6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL21ham9yJyksXG4gIG1pbm9yOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9taW5vcicpLFxuICBwYXRjaDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvcGF0Y2gnKSxcbiAgcHJlcmVsZWFzZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvcHJlcmVsZWFzZScpLFxuICBjb21wYXJlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb21wYXJlJyksXG4gIHJjb21wYXJlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9yY29tcGFyZScpLFxuICBjb21wYXJlTG9vc2U6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvbXBhcmUtbG9vc2UnKSxcbiAgY29tcGFyZUJ1aWxkOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb21wYXJlLWJ1aWxkJyksXG4gIHNvcnQ6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3NvcnQnKSxcbiAgcnNvcnQ6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3Jzb3J0JyksXG4gIGd0OiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9ndCcpLFxuICBsdDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvbHQnKSxcbiAgZXE6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2VxJyksXG4gIG5lcTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvbmVxJyksXG4gIGd0ZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvZ3RlJyksXG4gIGx0ZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvbHRlJyksXG4gIGNtcDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvY21wJyksXG4gIGNvZXJjZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29lcmNlJyksXG4gIENvbXBhcmF0b3I6IHJlcXVpcmUoJy4vY2xhc3Nlcy9jb21wYXJhdG9yJyksXG4gIFJhbmdlOiByZXF1aXJlKCcuL2NsYXNzZXMvcmFuZ2UnKSxcbiAgc2F0aXNmaWVzOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9zYXRpc2ZpZXMnKSxcbiAgdG9Db21wYXJhdG9yczogcmVxdWlyZSgnLi9yYW5nZXMvdG8tY29tcGFyYXRvcnMnKSxcbiAgbWF4U2F0aXNmeWluZzogcmVxdWlyZSgnLi9yYW5nZXMvbWF4LXNhdGlzZnlpbmcnKSxcbiAgbWluU2F0aXNmeWluZzogcmVxdWlyZSgnLi9yYW5nZXMvbWluLXNhdGlzZnlpbmcnKSxcbiAgbWluVmVyc2lvbjogcmVxdWlyZSgnLi9yYW5nZXMvbWluLXZlcnNpb24nKSxcbiAgdmFsaWRSYW5nZTogcmVxdWlyZSgnLi9yYW5nZXMvdmFsaWQnKSxcbiAgb3V0c2lkZTogcmVxdWlyZSgnLi9yYW5nZXMvb3V0c2lkZScpLFxuICBndHI6IHJlcXVpcmUoJy4vcmFuZ2VzL2d0cicpLFxuICBsdHI6IHJlcXVpcmUoJy4vcmFuZ2VzL2x0cicpLFxuICBpbnRlcnNlY3RzOiByZXF1aXJlKCcuL3Jhbmdlcy9pbnRlcnNlY3RzJyksXG4gIHNpbXBsaWZ5UmFuZ2U6IHJlcXVpcmUoJy4vcmFuZ2VzL3NpbXBsaWZ5JyksXG4gIHN1YnNldDogcmVxdWlyZSgnLi9yYW5nZXMvc3Vic2V0JyksXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IG1pbWljRm4gPSAodG8sIGZyb20pID0+IHtcblx0Zm9yIChjb25zdCBwcm9wIG9mIFJlZmxlY3Qub3duS2V5cyhmcm9tKSkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0bywgcHJvcCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihmcm9tLCBwcm9wKSk7XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1pbWljRm47XG4vLyBUT0RPOiBSZW1vdmUgdGhpcyBmb3IgdGhlIG5leHQgbWFqb3IgcmVsZWFzZVxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1pbWljRm47XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBtaW1pY0ZuID0gcmVxdWlyZSgnbWltaWMtZm4nKTtcblxuY29uc3QgY2FsbGVkRnVuY3Rpb25zID0gbmV3IFdlYWtNYXAoKTtcblxuY29uc3Qgb25ldGltZSA9IChmdW5jdGlvbl8sIG9wdGlvbnMgPSB7fSkgPT4ge1xuXHRpZiAodHlwZW9mIGZ1bmN0aW9uXyAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgZnVuY3Rpb24nKTtcblx0fVxuXG5cdGxldCByZXR1cm5WYWx1ZTtcblx0bGV0IGNhbGxDb3VudCA9IDA7XG5cdGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uXy5kaXNwbGF5TmFtZSB8fCBmdW5jdGlvbl8ubmFtZSB8fCAnPGFub255bW91cz4nO1xuXG5cdGNvbnN0IG9uZXRpbWUgPSBmdW5jdGlvbiAoLi4uYXJndW1lbnRzXykge1xuXHRcdGNhbGxlZEZ1bmN0aW9ucy5zZXQob25ldGltZSwgKytjYWxsQ291bnQpO1xuXG5cdFx0aWYgKGNhbGxDb3VudCA9PT0gMSkge1xuXHRcdFx0cmV0dXJuVmFsdWUgPSBmdW5jdGlvbl8uYXBwbHkodGhpcywgYXJndW1lbnRzXyk7XG5cdFx0XHRmdW5jdGlvbl8gPSBudWxsO1xuXHRcdH0gZWxzZSBpZiAob3B0aW9ucy50aHJvdyA9PT0gdHJ1ZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBGdW5jdGlvbiBcXGAke2Z1bmN0aW9uTmFtZX1cXGAgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2VgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0dXJuVmFsdWU7XG5cdH07XG5cblx0bWltaWNGbihvbmV0aW1lLCBmdW5jdGlvbl8pO1xuXHRjYWxsZWRGdW5jdGlvbnMuc2V0KG9uZXRpbWUsIGNhbGxDb3VudCk7XG5cblx0cmV0dXJuIG9uZXRpbWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9uZXRpbWU7XG4vLyBUT0RPOiBSZW1vdmUgdGhpcyBmb3IgdGhlIG5leHQgbWFqb3IgcmVsZWFzZVxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG9uZXRpbWU7XG5cbm1vZHVsZS5leHBvcnRzLmNhbGxDb3VudCA9IGZ1bmN0aW9uXyA9PiB7XG5cdGlmICghY2FsbGVkRnVuY3Rpb25zLmhhcyhmdW5jdGlvbl8pKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBUaGUgZ2l2ZW4gZnVuY3Rpb24gXFxgJHtmdW5jdGlvbl8ubmFtZX1cXGAgaXMgbm90IHdyYXBwZWQgYnkgdGhlIFxcYG9uZXRpbWVcXGAgcGFja2FnZWApO1xuXHR9XG5cblx0cmV0dXJuIGNhbGxlZEZ1bmN0aW9ucy5nZXQoZnVuY3Rpb25fKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfYSwgX2I7XG52YXIgX0NvbmZfdmFsaWRhdG9yLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBfQ29uZl9vcHRpb25zLCBfQ29uZl9kZWZhdWx0VmFsdWVzO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcInV0aWxcIik7XG5jb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgZG90UHJvcCA9IHJlcXVpcmUoXCJkb3QtcHJvcFwiKTtcbmNvbnN0IHBrZ1VwID0gcmVxdWlyZShcInBrZy11cFwiKTtcbmNvbnN0IGVudlBhdGhzID0gcmVxdWlyZShcImVudi1wYXRoc1wiKTtcbmNvbnN0IGF0b21pY2FsbHkgPSByZXF1aXJlKFwiYXRvbWljYWxseVwiKTtcbmNvbnN0IGFqdl8xID0gcmVxdWlyZShcImFqdlwiKTtcbmNvbnN0IGFqdl9mb3JtYXRzXzEgPSByZXF1aXJlKFwiYWp2LWZvcm1hdHNcIik7XG5jb25zdCBkZWJvdW5jZUZuID0gcmVxdWlyZShcImRlYm91bmNlLWZuXCIpO1xuY29uc3Qgc2VtdmVyID0gcmVxdWlyZShcInNlbXZlclwiKTtcbmNvbnN0IG9uZXRpbWUgPSByZXF1aXJlKFwib25ldGltZVwiKTtcbmNvbnN0IGVuY3J5cHRpb25BbGdvcml0aG0gPSAnYWVzLTI1Ni1jYmMnO1xuY29uc3QgY3JlYXRlUGxhaW5PYmplY3QgPSAoKSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG59O1xuY29uc3QgaXNFeGlzdCA9IChkYXRhKSA9PiB7XG4gICAgcmV0dXJuIGRhdGEgIT09IHVuZGVmaW5lZCAmJiBkYXRhICE9PSBudWxsO1xufTtcbmxldCBwYXJlbnREaXIgPSAnJztcbnRyeSB7XG4gICAgLy8gUHJldmVudCBjYWNoaW5nIG9mIHRoaXMgbW9kdWxlIHNvIG1vZHVsZS5wYXJlbnQgaXMgYWx3YXlzIGFjY3VyYXRlLlxuICAgIC8vIE5vdGU6IFRoaXMgdHJpY2sgd29uJ3Qgd29yayB3aXRoIEVTTSBvciBpbnNpZGUgYSB3ZWJ3b3JrZXJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWR5bmFtaWMtZGVsZXRlXG4gICAgZGVsZXRlIHJlcXVpcmUuY2FjaGVbX19maWxlbmFtZV07XG4gICAgcGFyZW50RGlyID0gcGF0aC5kaXJuYW1lKChfYiA9IChfYSA9IG1vZHVsZS5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWxlbmFtZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJy4nKTtcbn1cbmNhdGNoIChfYykgeyB9XG5jb25zdCBjaGVja1ZhbHVlVHlwZSA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgY29uc3Qgbm9uSnNvblR5cGVzID0gbmV3IFNldChbXG4gICAgICAgICd1bmRlZmluZWQnLFxuICAgICAgICAnc3ltYm9sJyxcbiAgICAgICAgJ2Z1bmN0aW9uJ1xuICAgIF0pO1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgaWYgKG5vbkpzb25UeXBlcy5oYXModHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgU2V0dGluZyBhIHZhbHVlIG9mIHR5cGUgXFxgJHt0eXBlfVxcYCBmb3Iga2V5IFxcYCR7a2V5fVxcYCBpcyBub3QgYWxsb3dlZCBhcyBpdCdzIG5vdCBzdXBwb3J0ZWQgYnkgSlNPTmApO1xuICAgIH1cbn07XG5jb25zdCBJTlRFUk5BTF9LRVkgPSAnX19pbnRlcm5hbF9fJztcbmNvbnN0IE1JR1JBVElPTl9LRVkgPSBgJHtJTlRFUk5BTF9LRVl9Lm1pZ3JhdGlvbnMudmVyc2lvbmA7XG5jbGFzcyBDb25mIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJ0aWFsT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgX0NvbmZfdmFsaWRhdG9yLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQ29uZl9lbmNyeXB0aW9uS2V5LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQ29uZl9vcHRpb25zLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQ29uZl9kZWZhdWx0VmFsdWVzLnNldCh0aGlzLCB7fSk7XG4gICAgICAgIHRoaXMuX2Rlc2VyaWFsaXplID0gdmFsdWUgPT4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX3NlcmlhbGl6ZSA9IHZhbHVlID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlLCB1bmRlZmluZWQsICdcXHQnKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNvbmZpZ05hbWU6ICdjb25maWcnLFxuICAgICAgICAgICAgZmlsZUV4dGVuc2lvbjogJ2pzb24nLFxuICAgICAgICAgICAgcHJvamVjdFN1ZmZpeDogJ25vZGVqcycsXG4gICAgICAgICAgICBjbGVhckludmFsaWRDb25maWc6IGZhbHNlLFxuICAgICAgICAgICAgYWNjZXNzUHJvcGVydGllc0J5RG90Tm90YXRpb246IHRydWUsXG4gICAgICAgICAgICAuLi5wYXJ0aWFsT3B0aW9uc1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBnZXRQYWNrYWdlRGF0YSA9IG9uZXRpbWUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFja2FnZVBhdGggPSBwa2dVcC5zeW5jKHsgY3dkOiBwYXJlbnREaXIgfSk7XG4gICAgICAgICAgICAvLyBDYW4ndCB1c2UgYHJlcXVpcmVgIGJlY2F1c2Ugb2YgV2VicGFjayBiZWluZyBhbm5veWluZzpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL3dlYnBhY2svaXNzdWVzLzE5NlxuICAgICAgICAgICAgY29uc3QgcGFja2FnZURhdGEgPSBwYWNrYWdlUGF0aCAmJiBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhwYWNrYWdlUGF0aCwgJ3V0ZjgnKSk7XG4gICAgICAgICAgICByZXR1cm4gcGFja2FnZURhdGEgIT09IG51bGwgJiYgcGFja2FnZURhdGEgIT09IHZvaWQgMCA/IHBhY2thZ2VEYXRhIDoge307XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIW9wdGlvbnMuY3dkKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMucHJvamVjdE5hbWUpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnByb2plY3ROYW1lID0gZ2V0UGFja2FnZURhdGEoKS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnByb2plY3ROYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0IG5hbWUgY291bGQgbm90IGJlIGluZmVycmVkLiBQbGVhc2Ugc3BlY2lmeSB0aGUgYHByb2plY3ROYW1lYCBvcHRpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zLmN3ZCA9IGVudlBhdGhzKG9wdGlvbnMucHJvamVjdE5hbWUsIHsgc3VmZml4OiBvcHRpb25zLnByb2plY3RTdWZmaXggfSkuY29uZmlnO1xuICAgICAgICB9XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NvbmZfb3B0aW9ucywgb3B0aW9ucywgXCJmXCIpO1xuICAgICAgICBpZiAob3B0aW9ucy5zY2hlbWEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zY2hlbWEgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGBzY2hlbWFgIG9wdGlvbiBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFqdiA9IG5ldyBhanZfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgICAgICBhbGxFcnJvcnM6IHRydWUsXG4gICAgICAgICAgICAgICAgdXNlRGVmYXVsdHM6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWp2X2Zvcm1hdHNfMS5kZWZhdWx0KGFqdik7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogb3B0aW9ucy5zY2hlbWFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Db25mX3ZhbGlkYXRvciwgYWp2LmNvbXBpbGUoc2NoZW1hKSwgXCJmXCIpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0aW9ucy5zY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZGVmYXVsdFZhbHVlcywgXCJmXCIpW2tleV0gPSB2YWx1ZS5kZWZhdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ29uZl9kZWZhdWx0VmFsdWVzLCB7XG4gICAgICAgICAgICAgICAgLi4uX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9kZWZhdWx0VmFsdWVzLCBcImZcIiksXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5kZWZhdWx0c1xuICAgICAgICAgICAgfSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnNlcmlhbGl6ZSkge1xuICAgICAgICAgICAgdGhpcy5fc2VyaWFsaXplID0gb3B0aW9ucy5zZXJpYWxpemU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZGVzZXJpYWxpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rlc2VyaWFsaXplID0gb3B0aW9ucy5kZXNlcmlhbGl6ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyBldmVudHNfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBvcHRpb25zLmVuY3J5cHRpb25LZXksIFwiZlwiKTtcbiAgICAgICAgY29uc3QgZmlsZUV4dGVuc2lvbiA9IG9wdGlvbnMuZmlsZUV4dGVuc2lvbiA/IGAuJHtvcHRpb25zLmZpbGVFeHRlbnNpb259YCA6ICcnO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoLnJlc29sdmUob3B0aW9ucy5jd2QsIGAkeyhfYSA9IG9wdGlvbnMuY29uZmlnTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ2NvbmZpZyd9JHtmaWxlRXh0ZW5zaW9ufWApO1xuICAgICAgICBjb25zdCBmaWxlU3RvcmUgPSB0aGlzLnN0b3JlO1xuICAgICAgICBjb25zdCBzdG9yZSA9IE9iamVjdC5hc3NpZ24oY3JlYXRlUGxhaW5PYmplY3QoKSwgb3B0aW9ucy5kZWZhdWx0cywgZmlsZVN0b3JlKTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGUoc3RvcmUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChmaWxlU3RvcmUsIHN0b3JlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2IpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy53YXRjaCkge1xuICAgICAgICAgICAgdGhpcy5fd2F0Y2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5taWdyYXRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMucHJvamVjdFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnByb2plY3RWZXJzaW9uID0gZ2V0UGFja2FnZURhdGEoKS52ZXJzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnByb2plY3RWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0IHZlcnNpb24gY291bGQgbm90IGJlIGluZmVycmVkLiBQbGVhc2Ugc3BlY2lmeSB0aGUgYHByb2plY3RWZXJzaW9uYCBvcHRpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9taWdyYXRlKG9wdGlvbnMubWlncmF0aW9ucywgb3B0aW9ucy5wcm9qZWN0VmVyc2lvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0KGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX29wdGlvbnMsIFwiZlwiKS5hY2Nlc3NQcm9wZXJ0aWVzQnlEb3ROb3RhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldChrZXksIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdG9yZSB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGtleSBpbiBzdG9yZSA/IHN0b3JlW2tleV0gOiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyAmJiB0eXBlb2Yga2V5ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxga2V5XFxgIHRvIGJlIG9mIHR5cGUgXFxgc3RyaW5nXFxgIG9yIFxcYG9iamVjdFxcYCwgZ290ICR7dHlwZW9mIGtleX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ29iamVjdCcgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVXNlIGBkZWxldGUoKWAgdG8gY2xlYXIgdmFsdWVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NvbnRhaW5zUmVzZXJ2ZWRLZXkoa2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGxlYXNlIGRvbid0IHVzZSB0aGUgJHtJTlRFUk5BTF9LRVl9IGtleSwgYXMgaXQncyB1c2VkIHRvIG1hbmFnZSB0aGlzIG1vZHVsZSBpbnRlcm5hbCBvcGVyYXRpb25zLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3RvcmUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHNldCA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjaGVja1ZhbHVlVHlwZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX29wdGlvbnMsIFwiZlwiKS5hY2Nlc3NQcm9wZXJ0aWVzQnlEb3ROb3RhdGlvbikge1xuICAgICAgICAgICAgICAgIGRvdFByb3Auc2V0KHN0b3JlLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0b3JlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBvYmplY3QgPSBrZXk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgaWYgYW4gaXRlbSBleGlzdHMuXG5cbiAgICBAcGFyYW0ga2V5IC0gVGhlIGtleSBvZiB0aGUgaXRlbSB0byBjaGVjay5cbiAgICAqL1xuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfb3B0aW9ucywgXCJmXCIpLmFjY2Vzc1Byb3BlcnRpZXNCeURvdE5vdGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZG90UHJvcC5oYXModGhpcy5zdG9yZSwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5IGluIHRoaXMuc3RvcmU7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlc2V0IGl0ZW1zIHRvIHRoZWlyIGRlZmF1bHQgdmFsdWVzLCBhcyBkZWZpbmVkIGJ5IHRoZSBgZGVmYXVsdHNgIG9yIGBzY2hlbWFgIG9wdGlvbi5cblxuICAgIEBzZWUgYGNsZWFyKClgIHRvIHJlc2V0IGFsbCBpdGVtcy5cblxuICAgIEBwYXJhbSBrZXlzIC0gVGhlIGtleXMgb2YgdGhlIGl0ZW1zIHRvIHJlc2V0LlxuICAgICovXG4gICAgcmVzZXQoLi4ua2V5cykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgICAgICBpZiAoaXNFeGlzdChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX2RlZmF1bHRWYWx1ZXMsIFwiZlwiKVtrZXldKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9kZWZhdWx0VmFsdWVzLCBcImZcIilba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgRGVsZXRlIGFuIGl0ZW0uXG5cbiAgICBAcGFyYW0ga2V5IC0gVGhlIGtleSBvZiB0aGUgaXRlbSB0byBkZWxldGUuXG4gICAgKi9cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGNvbnN0IHsgc3RvcmUgfSA9IHRoaXM7XG4gICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX29wdGlvbnMsIFwiZlwiKS5hY2Nlc3NQcm9wZXJ0aWVzQnlEb3ROb3RhdGlvbikge1xuICAgICAgICAgICAgZG90UHJvcC5kZWxldGUoc3RvcmUsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWR5bmFtaWMtZGVsZXRlXG4gICAgICAgICAgICBkZWxldGUgc3RvcmVba2V5XTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgfVxuICAgIC8qKlxuICAgIERlbGV0ZSBhbGwgaXRlbXMuXG5cbiAgICBUaGlzIHJlc2V0cyBrbm93biBpdGVtcyB0byB0aGVpciBkZWZhdWx0IHZhbHVlcywgaWYgZGVmaW5lZCBieSB0aGUgYGRlZmF1bHRzYCBvciBgc2NoZW1hYCBvcHRpb24uXG4gICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5zdG9yZSA9IGNyZWF0ZVBsYWluT2JqZWN0KCk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZGVmYXVsdFZhbHVlcywgXCJmXCIpKSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldChrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFdhdGNoZXMgdGhlIGdpdmVuIGBrZXlgLCBjYWxsaW5nIGBjYWxsYmFja2Agb24gYW55IGNoYW5nZXMuXG5cbiAgICBAcGFyYW0ga2V5IC0gVGhlIGtleSB3byB3YXRjaC5cbiAgICBAcGFyYW0gY2FsbGJhY2sgLSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIG9uIGFueSBjaGFuZ2VzLiBXaGVuIGEgYGtleWAgaXMgZmlyc3Qgc2V0IGBvbGRWYWx1ZWAgd2lsbCBiZSBgdW5kZWZpbmVkYCwgYW5kIHdoZW4gYSBrZXkgaXMgZGVsZXRlZCBgbmV3VmFsdWVgIHdpbGwgYmUgYHVuZGVmaW5lZGAuXG4gICAgQHJldHVybnMgQSBmdW5jdGlvbiwgdGhhdCB3aGVuIGNhbGxlZCwgd2lsbCB1bnN1YnNjcmliZS5cbiAgICAqL1xuICAgIG9uRGlkQ2hhbmdlKGtleSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBrZXlcXGAgdG8gYmUgb2YgdHlwZSBcXGBzdHJpbmdcXGAsIGdvdCAke3R5cGVvZiBrZXl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgY2FsbGJhY2tcXGAgdG8gYmUgb2YgdHlwZSBcXGBmdW5jdGlvblxcYCwgZ290ICR7dHlwZW9mIGNhbGxiYWNrfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVDaGFuZ2UoKCkgPT4gdGhpcy5nZXQoa2V5KSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICBXYXRjaGVzIHRoZSB3aG9sZSBjb25maWcgb2JqZWN0LCBjYWxsaW5nIGBjYWxsYmFja2Agb24gYW55IGNoYW5nZXMuXG5cbiAgICBAcGFyYW0gY2FsbGJhY2sgLSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIG9uIGFueSBjaGFuZ2VzLiBXaGVuIGEgYGtleWAgaXMgZmlyc3Qgc2V0IGBvbGRWYWx1ZWAgd2lsbCBiZSBgdW5kZWZpbmVkYCwgYW5kIHdoZW4gYSBrZXkgaXMgZGVsZXRlZCBgbmV3VmFsdWVgIHdpbGwgYmUgYHVuZGVmaW5lZGAuXG4gICAgQHJldHVybnMgQSBmdW5jdGlvbiwgdGhhdCB3aGVuIGNhbGxlZCwgd2lsbCB1bnN1YnNjcmliZS5cbiAgICAqL1xuICAgIG9uRGlkQW55Q2hhbmdlKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFxcYGNhbGxiYWNrXFxgIHRvIGJlIG9mIHR5cGUgXFxgZnVuY3Rpb25cXGAsIGdvdCAke3R5cGVvZiBjYWxsYmFja31gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlQ2hhbmdlKCgpID0+IHRoaXMuc3RvcmUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnN0b3JlKS5sZW5ndGg7XG4gICAgfVxuICAgIGdldCBzdG9yZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBmcy5yZWFkRmlsZVN5bmModGhpcy5wYXRoLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX2VuY3J5cHRpb25LZXksIFwiZlwiKSA/IG51bGwgOiAndXRmOCcpO1xuICAgICAgICAgICAgY29uc3QgZGF0YVN0cmluZyA9IHRoaXMuX2VuY3J5cHREYXRhKGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgZGVzZXJpYWxpemVkRGF0YSA9IHRoaXMuX2Rlc2VyaWFsaXplKGRhdGFTdHJpbmcpO1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGUoZGVzZXJpYWxpemVkRGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihjcmVhdGVQbGFpbk9iamVjdCgpLCBkZXNlcmlhbGl6ZWREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vuc3VyZURpcmVjdG9yeSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVQbGFpbk9iamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfb3B0aW9ucywgXCJmXCIpLmNsZWFySW52YWxpZENvbmZpZyAmJiBlcnJvci5uYW1lID09PSAnU3ludGF4RXJyb3InKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVBsYWluT2JqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQgc3RvcmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlRGlyZWN0b3J5KCk7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlKHZhbHVlKTtcbiAgICAgICAgdGhpcy5fd3JpdGUodmFsdWUpO1xuICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KCdjaGFuZ2UnKTtcbiAgICB9XG4gICAgKlsoX0NvbmZfdmFsaWRhdG9yID0gbmV3IFdlYWtNYXAoKSwgX0NvbmZfZW5jcnlwdGlvbktleSA9IG5ldyBXZWFrTWFwKCksIF9Db25mX29wdGlvbnMgPSBuZXcgV2Vha01hcCgpLCBfQ29uZl9kZWZhdWx0VmFsdWVzID0gbmV3IFdlYWtNYXAoKSwgU3ltYm9sLml0ZXJhdG9yKV0oKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuc3RvcmUpKSB7XG4gICAgICAgICAgICB5aWVsZCBba2V5LCB2YWx1ZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2VuY3J5cHREYXRhKGRhdGEpIHtcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX2VuY3J5cHRpb25LZXksIFwiZlwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYW4gaW5pdGlhbGl6YXRpb24gdmVjdG9yIGhhcyBiZWVuIHVzZWQgdG8gZW5jcnlwdCB0aGUgZGF0YVxuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZW5jcnlwdGlvbktleSwgXCJmXCIpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuc2xpY2UoMTYsIDE3KS50b1N0cmluZygpID09PSAnOicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluaXRpYWxpemF0aW9uVmVjdG9yID0gZGF0YS5zbGljZSgwLCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXNzd29yZCA9IGNyeXB0by5wYmtkZjJTeW5jKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZW5jcnlwdGlvbktleSwgXCJmXCIpLCBpbml0aWFsaXphdGlvblZlY3Rvci50b1N0cmluZygpLCAxMDAwMCwgMzIsICdzaGE1MTInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoZW5jcnlwdGlvbkFsZ29yaXRobSwgcGFzc3dvcmQsIGluaXRpYWxpemF0aW9uVmVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBCdWZmZXIuY29uY2F0KFtkZWNpcGhlci51cGRhdGUoQnVmZmVyLmZyb20oZGF0YS5zbGljZSgxNykpKSwgZGVjaXBoZXIuZmluYWwoKV0pLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcihlbmNyeXB0aW9uQWxnb3JpdGhtLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX2VuY3J5cHRpb25LZXksIFwiZlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gQnVmZmVyLmNvbmNhdChbZGVjaXBoZXIudXBkYXRlKEJ1ZmZlci5mcm9tKGRhdGEpKSwgZGVjaXBoZXIuZmluYWwoKV0pLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2IpIHsgfVxuICAgICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cbiAgICBfaGFuZGxlQ2hhbmdlKGdldHRlciwgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IGN1cnJlbnRWYWx1ZSA9IGdldHRlcigpO1xuICAgICAgICBjb25zdCBvbkNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBnZXR0ZXIoKTtcbiAgICAgICAgICAgIGlmICh1dGlsXzEuaXNEZWVwU3RyaWN0RXF1YWwobmV3VmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBuZXdWYWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmV2ZW50cy5vbignY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgICAgICByZXR1cm4gKCkgPT4gdGhpcy5ldmVudHMucmVtb3ZlTGlzdGVuZXIoJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICB9XG4gICAgX3ZhbGlkYXRlKGRhdGEpIHtcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX3ZhbGlkYXRvciwgXCJmXCIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWQgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX3ZhbGlkYXRvciwgXCJmXCIpLmNhbGwodGhpcywgZGF0YSk7XG4gICAgICAgIGlmICh2YWxpZCB8fCAhX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl92YWxpZGF0b3IsIFwiZlwiKS5lcnJvcnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvcnMgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX3ZhbGlkYXRvciwgXCJmXCIpLmVycm9yc1xuICAgICAgICAgICAgLm1hcCgoeyBpbnN0YW5jZVBhdGgsIG1lc3NhZ2UgPSAnJyB9KSA9PiBgXFxgJHtpbnN0YW5jZVBhdGguc2xpY2UoMSl9XFxgICR7bWVzc2FnZX1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25maWcgc2NoZW1hIHZpb2xhdGlvbjogJyArIGVycm9ycy5qb2luKCc7ICcpKTtcbiAgICB9XG4gICAgX2Vuc3VyZURpcmVjdG9yeSgpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSBkaXJlY3RvcnkgZXhpc3RzIGFzIGl0IGNvdWxkIGhhdmUgYmVlbiBkZWxldGVkIGluIHRoZSBtZWFudGltZS5cbiAgICAgICAgZnMubWtkaXJTeW5jKHBhdGguZGlybmFtZSh0aGlzLnBhdGgpLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgX3dyaXRlKHZhbHVlKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fc2VyaWFsaXplKHZhbHVlKTtcbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZW5jcnlwdGlvbktleSwgXCJmXCIpKSB7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsaXphdGlvblZlY3RvciA9IGNyeXB0by5yYW5kb21CeXRlcygxNik7XG4gICAgICAgICAgICBjb25zdCBwYXNzd29yZCA9IGNyeXB0by5wYmtkZjJTeW5jKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZW5jcnlwdGlvbktleSwgXCJmXCIpLCBpbml0aWFsaXphdGlvblZlY3Rvci50b1N0cmluZygpLCAxMDAwMCwgMzIsICdzaGE1MTInKTtcbiAgICAgICAgICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihlbmNyeXB0aW9uQWxnb3JpdGhtLCBwYXNzd29yZCwgaW5pdGlhbGl6YXRpb25WZWN0b3IpO1xuICAgICAgICAgICAgZGF0YSA9IEJ1ZmZlci5jb25jYXQoW2luaXRpYWxpemF0aW9uVmVjdG9yLCBCdWZmZXIuZnJvbSgnOicpLCBjaXBoZXIudXBkYXRlKEJ1ZmZlci5mcm9tKGRhdGEpKSwgY2lwaGVyLmZpbmFsKCldKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZW1wb3Jhcnkgd29ya2Fyb3VuZCBmb3IgQ29uZiBiZWluZyBwYWNrYWdlZCBpbiBhIFVidW50dSBTbmFwIGFwcC5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvY29uZi9wdWxsLzgyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5TTkFQKSB7XG4gICAgICAgICAgICBmcy53cml0ZUZpbGVTeW5jKHRoaXMucGF0aCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF0b21pY2FsbHkud3JpdGVGaWxlU3luYyh0aGlzLnBhdGgsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gRml4IGZvciBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2VsZWN0cm9uLXN0b3JlL2lzc3Vlcy8xMDZcbiAgICAgICAgICAgICAgICAvLyBTb21ldGltZXMgb24gV2luZG93cywgd2Ugd2lsbCBnZXQgYW4gRVhERVYgZXJyb3Igd2hlbiBhdG9taWMgd3JpdGluZ1xuICAgICAgICAgICAgICAgIC8vIChldmVuIHRob3VnaCB0byB0aGUgc2FtZSBkaXJlY3RvcnkpLCBzbyB3ZSBmYWxsIGJhY2sgdG8gbm9uIGF0b21pYyB3cml0ZVxuICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSAnRVhERVYnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmModGhpcy5wYXRoLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfd2F0Y2goKSB7XG4gICAgICAgIHRoaXMuX2Vuc3VyZURpcmVjdG9yeSgpO1xuICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmModGhpcy5wYXRoKSkge1xuICAgICAgICAgICAgdGhpcy5fd3JpdGUoY3JlYXRlUGxhaW5PYmplY3QoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICAgICAgICAgIGZzLndhdGNoKHRoaXMucGF0aCwgeyBwZXJzaXN0ZW50OiBmYWxzZSB9LCBkZWJvdW5jZUZuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBPbiBMaW51eCBhbmQgV2luZG93cywgd3JpdGluZyB0byB0aGUgY29uZmlnIGZpbGUgZW1pdHMgYSBgcmVuYW1lYCBldmVudCwgc28gd2Ugc2tpcCBjaGVja2luZyB0aGUgZXZlbnQgdHlwZS5cbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KCdjaGFuZ2UnKTtcbiAgICAgICAgICAgIH0sIHsgd2FpdDogMTAwIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZzLndhdGNoRmlsZSh0aGlzLnBhdGgsIHsgcGVyc2lzdGVudDogZmFsc2UgfSwgZGVib3VuY2VGbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZW1pdCgnY2hhbmdlJyk7XG4gICAgICAgICAgICB9LCB7IHdhaXQ6IDUwMDAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9taWdyYXRlKG1pZ3JhdGlvbnMsIHZlcnNpb25Ub01pZ3JhdGUpIHtcbiAgICAgICAgbGV0IHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uID0gdGhpcy5fZ2V0KE1JR1JBVElPTl9LRVksICcwLjAuMCcpO1xuICAgICAgICBjb25zdCBuZXdlclZlcnNpb25zID0gT2JqZWN0LmtleXMobWlncmF0aW9ucylcbiAgICAgICAgICAgIC5maWx0ZXIoY2FuZGlkYXRlVmVyc2lvbiA9PiB0aGlzLl9zaG91bGRQZXJmb3JtTWlncmF0aW9uKGNhbmRpZGF0ZVZlcnNpb24sIHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uLCB2ZXJzaW9uVG9NaWdyYXRlKSk7XG4gICAgICAgIGxldCBzdG9yZUJhY2t1cCA9IHsgLi4udGhpcy5zdG9yZSB9O1xuICAgICAgICBmb3IgKGNvbnN0IHZlcnNpb24gb2YgbmV3ZXJWZXJzaW9ucykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtaWdyYXRpb24gPSBtaWdyYXRpb25zW3ZlcnNpb25dO1xuICAgICAgICAgICAgICAgIG1pZ3JhdGlvbih0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXQoTUlHUkFUSU9OX0tFWSwgdmVyc2lvbik7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNNaWdyYXRlZFZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICAgICAgICAgIHN0b3JlQmFja3VwID0geyAuLi50aGlzLnN0b3JlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmVCYWNrdXA7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgdGhlIG1pZ3JhdGlvbiEgQ2hhbmdlcyBhcHBsaWVkIHRvIHRoZSBzdG9yZSB1bnRpbCB0aGlzIGZhaWxlZCBtaWdyYXRpb24gd2lsbCBiZSByZXN0b3JlZC4gJHtlcnJvcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faXNWZXJzaW9uSW5SYW5nZUZvcm1hdChwcmV2aW91c01pZ3JhdGVkVmVyc2lvbikgfHwgIXNlbXZlci5lcShwcmV2aW91c01pZ3JhdGVkVmVyc2lvbiwgdmVyc2lvblRvTWlncmF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldChNSUdSQVRJT05fS0VZLCB2ZXJzaW9uVG9NaWdyYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY29udGFpbnNSZXNlcnZlZEtleShrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzS2V5ID0gT2JqZWN0LmtleXMoa2V5KVswXTtcbiAgICAgICAgICAgIGlmIChmaXJzS2V5ID09PSBJTlRFUk5BTF9LRVkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9vcHRpb25zLCBcImZcIikuYWNjZXNzUHJvcGVydGllc0J5RG90Tm90YXRpb24pIHtcbiAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChgJHtJTlRFUk5BTF9LRVl9LmApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfaXNWZXJzaW9uSW5SYW5nZUZvcm1hdCh2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBzZW12ZXIuY2xlYW4odmVyc2lvbikgPT09IG51bGw7XG4gICAgfVxuICAgIF9zaG91bGRQZXJmb3JtTWlncmF0aW9uKGNhbmRpZGF0ZVZlcnNpb24sIHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uLCB2ZXJzaW9uVG9NaWdyYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1ZlcnNpb25JblJhbmdlRm9ybWF0KGNhbmRpZGF0ZVZlcnNpb24pKSB7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNNaWdyYXRlZFZlcnNpb24gIT09ICcwLjAuMCcgJiYgc2VtdmVyLnNhdGlzZmllcyhwcmV2aW91c01pZ3JhdGVkVmVyc2lvbiwgY2FuZGlkYXRlVmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VtdmVyLnNhdGlzZmllcyh2ZXJzaW9uVG9NaWdyYXRlLCBjYW5kaWRhdGVWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VtdmVyLmx0ZShjYW5kaWRhdGVWZXJzaW9uLCBwcmV2aW91c01pZ3JhdGVkVmVyc2lvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VtdmVyLmd0KGNhbmRpZGF0ZVZlcnNpb24sIHZlcnNpb25Ub01pZ3JhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9nZXQoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRvdFByb3AuZ2V0KHRoaXMuc3RvcmUsIGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgICB9XG4gICAgX3NldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHsgc3RvcmUgfSA9IHRoaXM7XG4gICAgICAgIGRvdFByb3Auc2V0KHN0b3JlLCBrZXksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IENvbmY7XG4vLyBGb3IgQ29tbW9uSlMgZGVmYXVsdCBleHBvcnQgc3VwcG9ydFxubW9kdWxlLmV4cG9ydHMgPSBDb25mO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IENvbmY7XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3Qge2FwcCwgaXBjTWFpbiwgaXBjUmVuZGVyZXIsIHNoZWxsfSA9IHJlcXVpcmUoJ2VsZWN0cm9uJyk7XG5jb25zdCBDb25mID0gcmVxdWlyZSgnY29uZicpO1xuXG5sZXQgaXNJbml0aWFsaXplZCA9IGZhbHNlO1xuXG4vLyBTZXQgdXAgdGhlIGBpcGNNYWluYCBoYW5kbGVyIGZvciBjb21tdW5pY2F0aW9uIGJldHdlZW4gcmVuZGVyZXIgYW5kIG1haW4gcHJvY2Vzcy5cbmNvbnN0IGluaXREYXRhTGlzdGVuZXIgPSAoKSA9PiB7XG5cdGlmICghaXBjTWFpbiB8fCAhYXBwKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdFbGVjdHJvbiBTdG9yZTogWW91IG5lZWQgdG8gY2FsbCBgLmluaXRSZW5kZXJlcigpYCBmcm9tIHRoZSBtYWluIHByb2Nlc3MuJyk7XG5cdH1cblxuXHRjb25zdCBhcHBEYXRhID0ge1xuXHRcdGRlZmF1bHRDd2Q6IGFwcC5nZXRQYXRoKCd1c2VyRGF0YScpLFxuXHRcdGFwcFZlcnNpb246IGFwcC5nZXRWZXJzaW9uKClcblx0fTtcblxuXHRpZiAoaXNJbml0aWFsaXplZCkge1xuXHRcdHJldHVybiBhcHBEYXRhO1xuXHR9XG5cblx0aXBjTWFpbi5vbignZWxlY3Ryb24tc3RvcmUtZ2V0LWRhdGEnLCBldmVudCA9PiB7XG5cdFx0ZXZlbnQucmV0dXJuVmFsdWUgPSBhcHBEYXRhO1xuXHR9KTtcblxuXHRpc0luaXRpYWxpemVkID0gdHJ1ZTtcblxuXHRyZXR1cm4gYXBwRGF0YTtcbn07XG5cbmNsYXNzIEVsZWN0cm9uU3RvcmUgZXh0ZW5kcyBDb25mIHtcblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdGxldCBkZWZhdWx0Q3dkO1xuXHRcdGxldCBhcHBWZXJzaW9uO1xuXG5cdFx0Ly8gSWYgd2UgYXJlIGluIHRoZSByZW5kZXJlciBwcm9jZXNzLCB3ZSBjb21tdW5pY2F0ZSB3aXRoIHRoZSBtYWluIHByb2Nlc3Ncblx0XHQvLyB0byBnZXQgdGhlIHJlcXVpcmVkIGRhdGEgZm9yIHRoZSBtb2R1bGUgb3RoZXJ3aXNlLCB3ZSBwdWxsIGZyb20gdGhlIG1haW4gcHJvY2Vzcy5cblx0XHRpZiAoaXBjUmVuZGVyZXIpIHtcblx0XHRcdGNvbnN0IGFwcERhdGEgPSBpcGNSZW5kZXJlci5zZW5kU3luYygnZWxlY3Ryb24tc3RvcmUtZ2V0LWRhdGEnKTtcblxuXHRcdFx0aWYgKCFhcHBEYXRhKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignRWxlY3Ryb24gU3RvcmU6IFlvdSBuZWVkIHRvIGNhbGwgYC5pbml0UmVuZGVyZXIoKWAgZnJvbSB0aGUgbWFpbiBwcm9jZXNzLicpO1xuXHRcdFx0fVxuXG5cdFx0XHQoe2RlZmF1bHRDd2QsIGFwcFZlcnNpb259ID0gYXBwRGF0YSk7XG5cdFx0fSBlbHNlIGlmIChpcGNNYWluICYmIGFwcCkge1xuXHRcdFx0KHtkZWZhdWx0Q3dkLCBhcHBWZXJzaW9ufSA9IGluaXREYXRhTGlzdGVuZXIoKSk7XG5cdFx0fVxuXG5cdFx0b3B0aW9ucyA9IHtcblx0XHRcdG5hbWU6ICdjb25maWcnLFxuXHRcdFx0Li4ub3B0aW9uc1xuXHRcdH07XG5cblx0XHRpZiAoIW9wdGlvbnMucHJvamVjdFZlcnNpb24pIHtcblx0XHRcdG9wdGlvbnMucHJvamVjdFZlcnNpb24gPSBhcHBWZXJzaW9uO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmN3ZCkge1xuXHRcdFx0b3B0aW9ucy5jd2QgPSBwYXRoLmlzQWJzb2x1dGUob3B0aW9ucy5jd2QpID8gb3B0aW9ucy5jd2QgOiBwYXRoLmpvaW4oZGVmYXVsdEN3ZCwgb3B0aW9ucy5jd2QpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvcHRpb25zLmN3ZCA9IGRlZmF1bHRDd2Q7XG5cdFx0fVxuXG5cdFx0b3B0aW9ucy5jb25maWdOYW1lID0gb3B0aW9ucy5uYW1lO1xuXHRcdGRlbGV0ZSBvcHRpb25zLm5hbWU7XG5cblx0XHRzdXBlcihvcHRpb25zKTtcblx0fVxuXG5cdHN0YXRpYyBpbml0UmVuZGVyZXIoKSB7XG5cdFx0aW5pdERhdGFMaXN0ZW5lcigpO1xuXHR9XG5cblx0b3BlbkluRWRpdG9yKCkge1xuXHRcdHNoZWxsLm9wZW5QYXRoKHRoaXMucGF0aCk7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFbGVjdHJvblN0b3JlO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tbWl4ZWQtc3BhY2VzLWFuZC10YWJzICovXG5pbXBvcnQgU3RvcmUgZnJvbSAnZWxlY3Ryb24tc3RvcmUnO1xuXG5jb25zdCBzY2hlbWEgPSB7XG5cdG5vdGVzOiB7XG5cdFx0dHlwZTogJ29iamVjdCcsXG4gICAgcGF0dGVyblByb3BlcnRpZXM6IHtcbiAgICAgICdbQS1aYS16MC05Xy1dJzoge1xuICAgICAgXHR0eXBlOiAnb2JqZWN0JyxcbiAgICAgIFx0cHJvcGVydGllczoge1xuICAgICAgXHRcdGlkOiB7IHR5cGU6ICdzdHJpbmcnLCBkZWZhdWx0OiAnJyB9LFxuICAgICAgXHRcdHRpdGxlOiB7IHR5cGU6ICdzdHJpbmcnLCBkZWZhdWx0OiAnJyB9LFxuICAgICAgXHRcdGNvbnRlbnQ6IHsgdHlwZTogJ29iamVjdCcsIGRlZmF1bHQ6IHsgdHlwZTogJ2RvYycsIGNvbnRlbnQ6IFtdIH0gfSxcbiAgICAgIFx0XHRsYWJlbHM6IHsgdHlwZTogJ2FycmF5JywgZGVmYXVsdDogW10gfSxcbiAgICAgIFx0XHRjcmVhdGVkQXQ6IHsgdHlwZTogJ251bWJlcicsIGRlZmF1bHQ6IERhdGUubm93KCkgfSxcbiAgICAgIFx0XHR1cGRhdGVkQXQ6IHsgdHlwZTogJ251bWJlcicsIGRlZmF1bHQ6IERhdGUubm93KCkgfSxcbiAgICAgIFx0XHRpc0Jvb2ttYXJrZWQ6IHsgdHlwZTogJ2Jvb2xlYW4nLCBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgXHRcdGlzQXJjaGl2ZWQ6IHsgdHlwZTogJ2Jvb2xlYW4nLCBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICAgIGxhc3RDdXJzb3JQb3NpdGlvbjogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogMCB9LFxuICAgICAgXHR9LFxuICAgICAgfSxcbiAgICB9LFxuXHR9LFxuICBsYWJlbHM6IHtcbiAgICB0eXBlOiAnYXJyYXknLFxuICB9LFxufTtcblxuY29uc3Qgc3RvcmUgPSBuZXcgU3RvcmUoe1xuXHRzY2hlbWEsXG4gIGVuY3J5cHRpb25LZXk6IGltcG9ydC5tZXRhLmVudi5WSVRFX0VOQ1JZUFRfS0VZLFxufSk7XG5cbi8vIHN0b3JlLm9uRGlkQ2hhbmdlKCdub3RlcycsICh2YWx1ZSkgPT4ge1xuLy8gICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4vLyB9KTtcblxuZXhwb3J0IGRlZmF1bHQgc3RvcmU7XG4iLCJpbXBvcnQgU3RvcmUgZnJvbSAnZWxlY3Ryb24tc3RvcmUnO1xuaW1wb3J0IHsgYXBwIH0gZnJvbSAnZWxlY3Ryb24nO1xuXG5jb25zdCBzY2hlbWEgPSB7XG5cdGRhdGFEaXI6IHtcblx0XHR0eXBlOiAnc3RyaW5nJyxcblx0XHRkZWZhdWx0OiBhcHAuZ2V0UGF0aCgndXNlckRhdGEnKSxcblx0fSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBTdG9yZSh7IG5hbWU6ICdzZXR0aW5ncycsIHNjaGVtYSwgZW5jcnlwdGlvbktleTogcHJvY2Vzcy5lbnYuVklURV9FTkNSWVBUX0tFWSB9KTtcbiIsImltcG9ydCBkYXRhIGZyb20gJy4vbW9kdWxlcy9kYXRhLnN0b3JlJztcbmltcG9ydCBzZXR0aW5ncyBmcm9tICcuL21vZHVsZXMvc2V0dGluZ3Muc3RvcmUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cdGRhdGEsXG5cdHNldHRpbmdzLFxufTtcbiIsImltcG9ydCB7IGFwcCwgQnJvd3NlcldpbmRvdywgZGlhbG9nLCBwcm90b2NvbCwgbmF0aXZlVGhlbWUsIHNoZWxsIH0gZnJvbSAnZWxlY3Ryb24nO1xuaW1wb3J0IHsgaXBjTWFpbiB9IGZyb20gJ2VsZWN0cm9uLWJldHRlci1pcGMnO1xuaW1wb3J0IHsgam9pbiwgbm9ybWFsaXplIH0gZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBVUkwgfSBmcm9tICd1cmwnO1xuaW1wb3J0IHsgcmVtb3ZlLCByZWFkSnNvbiwgZW5zdXJlRGlyLCBjb3B5LCBvdXRwdXRKc29uLCBwYXRoRXhpc3RzU3luYyB9IGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCBzdG9yZSBmcm9tICcuL3N0b3JlJztcblxuY29uc3QgaXNTaW5nbGVJbnN0YW5jZSA9IGFwcC5yZXF1ZXN0U2luZ2xlSW5zdGFuY2VMb2NrKCk7XG5cbmlmICghaXNTaW5nbGVJbnN0YW5jZSkge1xuICBhcHAucXVpdCgpO1xuICBwcm9jZXNzLmV4aXQoMCk7XG59XG5cbmFwcC5kaXNhYmxlSGFyZHdhcmVBY2NlbGVyYXRpb24oKTtcblxuLyoqXG4gKiBXb3JrYXJvdW5kIGZvciBUeXBlU2NyaXB0IGJ1Z1xuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzQxNDY4I2lzc3VlY29tbWVudC03Mjc1NDM0MDBcbiAqL1xuY29uc3QgZW52ID0gaW1wb3J0Lm1ldGEuZW52O1xuXG4vLyBJbnN0YWxsIFwiVnVlLmpzIGRldnRvb2xzXCJcbmlmIChlbnYuTU9ERSA9PT0gJ2RldmVsb3BtZW50Jykge1xuICBhcHAud2hlblJlYWR5KClcbiAgICAudGhlbigoKSA9PiBpbXBvcnQoJ2VsZWN0cm9uLWRldnRvb2xzLWluc3RhbGxlcicpKVxuICAgIC50aGVuKCh7ZGVmYXVsdDogaW5zdGFsbEV4dGVuc2lvbiwgVlVFSlMzX0RFVlRPT0xTfSkgPT4gaW5zdGFsbEV4dGVuc2lvbihWVUVKUzNfREVWVE9PTFMsIHtcbiAgICAgIGxvYWRFeHRlbnNpb25PcHRpb25zOiB7XG4gICAgICAgIGFsbG93RmlsZUFjY2VzczogdHJ1ZSxcbiAgICAgIH0sXG4gICAgfSkpXG4gICAgLmNhdGNoKGUgPT4gY29uc29sZS5lcnJvcignRmFpbGVkIGluc3RhbGwgZXh0ZW5zaW9uOicsIGUpKTtcbn1cblxubGV0IG1haW5XaW5kb3cgPSBudWxsO1xuXG5jb25zdCBjcmVhdGVXaW5kb3cgPSBhc3luYyAoKSA9PiB7XG4gIG1haW5XaW5kb3cgPSBuZXcgQnJvd3NlcldpbmRvdyh7XG4gICAgc2hvdzogZmFsc2UsXG4gICAgd2lkdGg6IDk1MCxcbiAgICBoZWlnaHQ6IDYwMCxcbiAgICB3ZWJQcmVmZXJlbmNlczoge1xuICAgICAgcHJlbG9hZDogam9pbihfX2Rpcm5hbWUsICcuLi8uLi9wcmVsb2FkL2Rpc3QvaW5kZXguY2pzJyksXG4gICAgICBjb250ZXh0SXNvbGF0aW9uOiBlbnYuTU9ERSAhPT0gJ3Rlc3QnLFxuICAgICAgZW5hYmxlUmVtb3RlTW9kdWxlOiBlbnYuTU9ERSA9PT0gJ3Rlc3QnLFxuICAgIH0sXG4gIH0pO1xuXG4gIG1haW5XaW5kb3cuc2V0TWVudUJhclZpc2liaWxpdHkoZmFsc2UpO1xuXG4gIG1haW5XaW5kb3cub24oJ3JlYWR5LXRvLXNob3cnLCAoKSA9PiB7XG4gICAgbWFpbldpbmRvdz8uc2hvdygpO1xuXG4gICAgaWYgKGVudi5NT0RFID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBtYWluV2luZG93Py53ZWJDb250ZW50cy5vcGVuRGV2VG9vbHMoKTtcbiAgICB9XG4gIH0pO1xuXG4gIG1haW5XaW5kb3c/LndlYkNvbnRlbnRzLm9uKCduZXctd2luZG93JywgZnVuY3Rpb24oZXZlbnQsIHVybCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJ25vdGU6Ly8nKSkgcmV0dXJuO1xuXG4gICAgc2hlbGwub3BlbkV4dGVybmFsKHVybCk7XG4gIH0pO1xuXG4gIGNvbnN0IHBhZ2VVcmwgPSBlbnYuTU9ERSA9PT0gJ2RldmVsb3BtZW50J1xuICAgID8gZW52LlZJVEVfREVWX1NFUlZFUl9VUkxcbiAgICA6IG5ldyBVUkwoJy4uL3JlbmRlcmVyL2Rpc3QvaW5kZXguaHRtbCcsICdmaWxlOi8vJyArIF9fZGlybmFtZSkudG9TdHJpbmcoKTtcblxuICBhd2FpdCBtYWluV2luZG93LmxvYWRVUkwocGFnZVVybCk7XG59O1xuXG5hcHAub24oJ3NlY29uZC1pbnN0YW5jZScsICgpID0+IHtcbiAgaWYgKG1haW5XaW5kb3cpIHtcbiAgICBpZiAobWFpbldpbmRvdy5pc01pbmltaXplZCgpKSBtYWluV2luZG93LnJlc3RvcmUoKTtcbiAgICBtYWluV2luZG93LmZvY3VzKCk7XG4gIH1cbn0pO1xuXG5hcHAub24oJ3dpbmRvdy1hbGwtY2xvc2VkJywgKCkgPT4ge1xuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSAhPT0gJ2RhcndpbicpIHtcbiAgICBhcHAucXVpdCgpO1xuICB9XG59KTtcblxuYXBwLndoZW5SZWFkeSgpXG4gIC50aGVuKGFzeW5jICgpID0+IHtcbiAgICBwcm90b2NvbC5yZWdpc3RlckZpbGVQcm90b2NvbCgnYXNzZXRzJywgKHJlcXVlc3QsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBjb25zdCB1cmwgPSByZXF1ZXN0LnVybC5zdWJzdHIoOSk7XG5cbiAgICAgIGNvbnN0IGRpciA9IHN0b3JlLnNldHRpbmdzLmdldCgnZGF0YURpcicpO1xuICAgICAgY29uc3QgaW1nUGF0aCA9IGAke2Rpcn0vbm90ZXMtYXNzZXRzLyR7dXJsfWA7XG5cbiAgICAgIGNhbGxiYWNrKHsgcGF0aDogbm9ybWFsaXplKGltZ1BhdGgpIH0pO1xuICAgIH0pO1xuXG4gICAgYXdhaXQgZW5zdXJlRGlyKGpvaW4oYXBwLmdldFBhdGgoJ3VzZXJEYXRhJyksICdub3Rlcy1hc3NldHMnKSk7XG4gICAgYXdhaXQgY3JlYXRlV2luZG93KCk7XG4gIH0pXG4gIC5jYXRjaCgoZSkgPT4gY29uc29sZS5lcnJvcignRmFpbGVkIGNyZWF0ZSB3aW5kb3c6JywgZSkpO1xuXG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdhcHA6aW5mbycsICgpID0+ICh7XG4gIG5hbWU6IGFwcC5nZXROYW1lKCksXG4gIHZlcnNpb246IGFwcC5nZXRWZXJzaW9uKCksXG59KSk7XG5cbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2RpYWxvZzpvcGVuJywgKHByb3BzKSA9PiBkaWFsb2cuc2hvd09wZW5EaWFsb2cocHJvcHMpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2RpYWxvZzptZXNzYWdlJywgKHByb3BzKSA9PiBkaWFsb2cuc2hvd01lc3NhZ2VCb3gocHJvcHMpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2RpYWxvZzpzYXZlJywgKHByb3BzKSA9PiBkaWFsb2cuc2hvd1NhdmVEaWFsb2cocHJvcHMpKTtcblxuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignZnM6Y29weScsICh7IHBhdGgsIGRlc3QgfSkgPT4gY29weShwYXRoLCBkZXN0KSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdmczpvdXRwdXQtanNvbicsICh7IHBhdGgsIGRhdGEgfSkgPT4gb3V0cHV0SnNvbihwYXRoLCBkYXRhKSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdmczpyZWFkLWpzb24nLCAocGF0aCkgPT4gcmVhZEpzb24ocGF0aCkpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignZnM6ZW5zdXJlRGlyJywgKHBhdGgpID0+IGVuc3VyZURpcihwYXRoKSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdmczpwYXRoRXhpc3RzJywgKHBhdGgpID0+IHBhdGhFeGlzdHNTeW5jKHBhdGgpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2ZzOnJlbW92ZScsIChwYXRoKSA9PiByZW1vdmUocGF0aCkpO1xuXG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdoZWxwZXI6cmVsYXVuY2gnLCAob3B0aW9ucyA9IHt9KSA9PiB7XG4gIGFwcC5yZWxhdW5jaCh7IGFyZ3M6IHByb2Nlc3MuYXJndi5zbGljZSgxKS5jb25jYXQoWyctLXJlbGF1bmNoJ10pLCAuLi5vcHRpb25zIH0pO1xuICBhcHAuZXhpdCgwKTtcbn0pO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignaGVscGVyOmdldC1wYXRoJywgKG5hbWUpID0+IGFwcC5nZXRQYXRoKG5hbWUpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2hlbHBlcjppcy1kYXJrLXRoZW1lJywgKCkgPT4gbmF0aXZlVGhlbWUuc2hvdWxkVXNlRGFya0NvbG9ycyk7XG5cbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ3N0b3JhZ2U6c3RvcmUnLCAobmFtZSkgPT4gc3RvcmVbbmFtZV0/LnN0b3JlKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ3N0b3JhZ2U6cmVwbGFjZScsICh7IG5hbWUsIGRhdGEgfSkgPT4gKHN0b3JlW25hbWVdLnN0b3JlID0gZGF0YSkpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignc3RvcmFnZTpnZXQnLCAoeyBuYW1lLCBrZXksIGRlZiB9KSA9PiBzdG9yZVtuYW1lXT8uZ2V0KGtleSwgZGVmKSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdzdG9yYWdlOnNldCcsICh7IG5hbWUsIGtleSwgdmFsdWUgfSkgPT4gc3RvcmVbbmFtZV0/LnNldChrZXksIHZhbHVlKSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdzdG9yYWdlOmRlbGV0ZScsICh7IG5hbWUsIGtleSB9KSA9PiBzdG9yZVtuYW1lXT8uZGVsZXRlKGtleSkpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignc3RvcmFnZTpoYXMnLCAoeyBuYW1lLCBrZXkgfSkgPT4gc3RvcmVbbmFtZV0/LmhhcyhrZXkpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ3N0b3JhZ2U6Y2xlYXInLCAobmFtZSkgPT4gc3RvcmVbbmFtZV0/LmNsZWFyKCkpO1xuIl0sIm5hbWVzIjpbInNlcmlhbGl6ZUVycm9yIiwiZGVzZXJpYWxpemVFcnJvciIsImVsZWN0cm9uIiwicmVxdWlyZSQkMCIsInJlcXVpcmUkJDEiLCJ1dGlsIiwicmVxdWlyZSQkMiIsImlwY1JlbmRlcmVyIiwiaXBjIiwiaXBjTWFpbiIsImNvbnN0YW50cyIsInBvbHlmaWxscyIsInBhdGNoIiwibGVnYWN5IiwiY2xvbmUiLCJmcyIsInJlcXVpcmUkJDMiLCJyZXF1aXJlJCQ0IiwiZGVidWciLCJnbG9iYWwiLCJyZXF1aXJlJCQ1IiwicGF0aCIsInUiLCJta2RpcnMiLCJ1dGltZXNNaWxsaXMiLCJ1dGltZXNNaWxsaXNTeW5jIiwiZ2V0U3RhdHMiLCJhcmVJZGVudGljYWwiLCJzdGF0IiwibWtkaXJzU3luYyIsIm9uRGlyIiwib25GaWxlIiwib25MaW5rIiwiY29weUZpbGUiLCJtYXlDb3B5RmlsZSIsInNldERlc3RNb2RlIiwiZmlsZUlzTm90V3JpdGFibGUiLCJtYWtlRmlsZVdyaXRhYmxlIiwic2V0RGVzdFRpbWVzdGFtcHMiLCJta0RpckFuZENvcHkiLCJjb3B5RGlyIiwiY29weURpckl0ZW0iLCJzdGFydENvcHkiLCJjb3B5TGluayIsImNvcHlTeW5jIiwicGF0aEV4aXN0cyIsImNvcHkiLCJkZWZhdWx0cyIsInJpbXJhZiIsInJlbW92ZSIsInJlbW92ZVN5bmMiLCJta2RpciIsImZpbGUiLCJsaW5rIiwic3ltbGlua1BhdGhzIiwic3ltbGlua1BhdGhzU3luYyIsInN5bWxpbmtUeXBlIiwic3ltbGlua1R5cGVTeW5jIiwicmVxdWlyZSQkNiIsInJlcXVpcmUkJDciLCJzeW1saW5rIiwic3RyaW5naWZ5Iiwic3RyaXBCb20iLCJyZWFkRmlsZSIsIndyaXRlRmlsZSIsImpzb25maWxlIiwicmVhZEZpbGVTeW5jIiwid3JpdGVGaWxlU3luYyIsImpzb25GaWxlIiwib3V0cHV0RmlsZSIsIm91dHB1dEZpbGVTeW5jIiwiaXNQYXJlbnRSb290IiwiZG9SZW5hbWUiLCJyZW5hbWUiLCJtb3ZlQWNyb3NzRGV2aWNlIiwibW92ZVN5bmMiLCJtb3ZlIiwicmVxdWlyZSQkOCIsInJlcXVpcmUkJDkiLCJyZXF1aXJlJCQxMCIsInJlcXVpcmUkJDExIiwiaXNPYmoiLCJwYXRoRXhpc3RzTW9kdWxlIiwicFRyeSIsInBUcnlNb2R1bGUiLCJwTGltaXQiLCJwTGltaXRNb2R1bGUiLCJwTG9jYXRlIiwibG9jYXRlUGF0aE1vZHVsZSIsImZpbmRVcE1vZHVsZSIsInBrZ1VwTW9kdWxlIiwiZW52IiwiZW52UGF0aHNNb2R1bGUiLCJjb25zdHNfMSIsImZzXzEiLCJ1dGlsXzEiLCJkaXN0IiwibmFtZXNfMSIsImNvZGVnZW5fMSIsImVycm9yc18xIiwiY29kZV8xIiwidHJhdmVyc2UiLCJqc29uU2NoZW1hVHJhdmVyc2VNb2R1bGUiLCJ0aGlzIiwicmVzb2x2ZSIsImVxdWFsIiwiVVJJIiwiZGF0YVR5cGVfMSIsInJlc29sdmVfMSIsInZhbGlkYXRlXzEiLCJkZWYiLCJjb3JlXzEiLCJlcnJvciIsInVjczJsZW5ndGhfMSIsImVxdWFsXzEiLCJ2YWxpZGF0aW9uXzEiLCJpdGVtc18xIiwiYWRkaXRpb25hbEl0ZW1zXzEiLCJwcm9wZXJ0aWVzIiwiYWRkaXRpb25hbFByb3BlcnRpZXNfMSIsInJlcXVpcmUkJDEyIiwicmVxdWlyZSQkMTMiLCJyZXF1aXJlJCQxNCIsInJlcXVpcmUkJDE1IiwiZm9ybWF0IiwiZm9ybWF0XzIiLCJmb3JtYXRfMSIsIm1pbWljRm4iLCJNQVhfTEVOR1RIIiwiTUFYX1NBRkVfSU5URUdFUiIsInBhcnNlT3B0aW9ucyIsImNvbXBhcmVJZGVudGlmaWVycyIsInJlIiwidCIsIlNlbVZlciIsInNlbXZlciIsInBhcnNlIiwidmFsaWQiLCJjb21wYXJlIiwiZXEiLCJjb21wYXJlQnVpbGQiLCJndCIsImx0IiwibmVxIiwiZ3RlIiwibHRlIiwiY21wIiwiWWFsbGlzdCIsIlJhbmdlIiwiQ29tcGFyYXRvciIsIkFOWSIsInNhdGlzZmllcyIsIm91dHNpZGUiLCJyZXF1aXJlJCQxNiIsInJlcXVpcmUkJDE3IiwicmVxdWlyZSQkMTgiLCJyZXF1aXJlJCQxOSIsInJlcXVpcmUkJDIwIiwicmVxdWlyZSQkMjEiLCJyZXF1aXJlJCQyMiIsInJlcXVpcmUkJDIzIiwicmVxdWlyZSQkMjQiLCJyZXF1aXJlJCQyNSIsInJlcXVpcmUkJDI2IiwicmVxdWlyZSQkMjciLCJyZXF1aXJlJCQyOCIsInJlcXVpcmUkJDI5IiwicmVxdWlyZSQkMzAiLCJyZXF1aXJlJCQzMSIsInJlcXVpcmUkJDMyIiwicmVxdWlyZSQkMzMiLCJyZXF1aXJlJCQzNCIsInJlcXVpcmUkJDM1IiwicmVxdWlyZSQkMzYiLCJyZXF1aXJlJCQzNyIsInJlcXVpcmUkJDM4IiwicmVxdWlyZSQkMzkiLCJyZXF1aXJlJCQ0MCIsIm1pbWljRm5Nb2R1bGUiLCJvbmV0aW1lTW9kdWxlIiwiZG90UHJvcCIsInBrZ1VwIiwiZGVib3VuY2VGbiIsInNjaGVtYSIsInN0b3JlIiwiU3RvcmUiLCJhcHAiLCJkYXRhIiwiQnJvd3NlcldpbmRvdyIsImpvaW4iLCJzaGVsbCIsInByb3RvY29sIiwibm9ybWFsaXplIiwiZW5zdXJlRGlyIiwiZGlhbG9nIiwib3V0cHV0SnNvbiIsInJlYWRKc29uIiwicGF0aEV4aXN0c1N5bmMiLCJuYXRpdmVUaGVtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSx1QkFBdUIsTUFBTTtBQUFBLEVBQzVCLFlBQVksU0FBUztBQUNwQixVQUFNLFNBQVMscUJBQXFCO0FBQ3BDLFdBQU8sZUFBZSxNQUFNLFFBQVE7QUFBQSxNQUNuQyxPQUFPO0FBQUEsTUFDUCxjQUFjO0FBQUEsTUFDZCxVQUFVO0FBQUE7QUFHWCxRQUFJLE1BQU0sbUJBQW1CO0FBQzVCLFlBQU0sa0JBQWtCLE1BQU07QUFBQTtBQUFBO0FBQUEsU0FJekIscUJBQXFCLFNBQVM7QUFDcEMsUUFBSTtBQUNILGFBQU8sS0FBSyxVQUFVO0FBQUEsWUFDckI7QUFDRCxhQUFPLE9BQU87QUFBQTtBQUFBO0FBQUE7QUFLakIsTUFBTSxtQkFBbUI7QUFBQSxFQUN4QixFQUFDLFVBQVUsUUFBUSxZQUFZO0FBQUEsRUFDL0IsRUFBQyxVQUFVLFdBQVcsWUFBWTtBQUFBLEVBQ2xDLEVBQUMsVUFBVSxTQUFTLFlBQVk7QUFBQSxFQUNoQyxFQUFDLFVBQVUsUUFBUSxZQUFZO0FBQUE7QUFHaEMsTUFBTSxXQUFXLE9BQU87QUFFeEIsTUFBTSxTQUFTLFVBQVE7QUFDdEIsT0FBSyxZQUFZO0FBQ2pCLFFBQU0sUUFBTyxLQUFLO0FBQ2xCLFNBQU8sS0FBSztBQUNaLFNBQU87QUFBQTtBQUdSLE1BQU0sa0JBQWtCLENBQUM7QUFBQSxFQUN4QjtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsTUFDSztBQUNMLFFBQU0sS0FB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
