"use strict";
const require$$0 = require("electron");
const require$$1 = require("path");
require("url");
const require$$0$3 = require("fs");
const require$$0$1 = require("constants");
const require$$0$2 = require("stream");
const require$$4 = require("util");
const require$$5 = require("assert");
const require$$3$1 = require("crypto");
const require$$5$1 = require("events");
const require$$1$1 = require("os");
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var serializeError_1;
var hasRequiredSerializeError;
function requireSerializeError() {
  if (hasRequiredSerializeError)
    return serializeError_1;
  hasRequiredSerializeError = 1;
  class NonError extends Error {
    constructor(message) {
      super(NonError._prepareSuperMessage(message));
      Object.defineProperty(this, "name", {
        value: "NonError",
        configurable: true,
        writable: true
      });
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, NonError);
      }
    }
    static _prepareSuperMessage(message) {
      try {
        return JSON.stringify(message);
      } catch {
        return String(message);
      }
    }
  }
  const commonProperties = [
    { property: "name", enumerable: false },
    { property: "message", enumerable: false },
    { property: "stack", enumerable: false },
    { property: "code", enumerable: true }
  ];
  const isCalled = Symbol(".toJSON called");
  const toJSON = (from) => {
    from[isCalled] = true;
    const json2 = from.toJSON();
    delete from[isCalled];
    return json2;
  };
  const destroyCircular = ({
    from,
    seen,
    to_,
    forceEnumerable,
    maxDepth,
    depth
  }) => {
    const to = to_ || (Array.isArray(from) ? [] : {});
    seen.push(from);
    if (depth >= maxDepth) {
      return to;
    }
    if (typeof from.toJSON === "function" && from[isCalled] !== true) {
      return toJSON(from);
    }
    for (const [key, value] of Object.entries(from)) {
      if (typeof Buffer === "function" && Buffer.isBuffer(value)) {
        to[key] = "[object Buffer]";
        continue;
      }
      if (typeof value === "function") {
        continue;
      }
      if (!value || typeof value !== "object") {
        to[key] = value;
        continue;
      }
      if (!seen.includes(from[key])) {
        depth++;
        to[key] = destroyCircular({
          from: from[key],
          seen: seen.slice(),
          forceEnumerable,
          maxDepth,
          depth
        });
        continue;
      }
      to[key] = "[Circular]";
    }
    for (const { property, enumerable } of commonProperties) {
      if (typeof from[property] === "string") {
        Object.defineProperty(to, property, {
          value: from[property],
          enumerable: forceEnumerable ? true : enumerable,
          configurable: true,
          writable: true
        });
      }
    }
    return to;
  };
  const serializeError = (value, options = {}) => {
    const { maxDepth = Number.POSITIVE_INFINITY } = options;
    if (typeof value === "object" && value !== null) {
      return destroyCircular({
        from: value,
        seen: [],
        forceEnumerable: true,
        maxDepth,
        depth: 0
      });
    }
    if (typeof value === "function") {
      return `[Function: ${value.name || "anonymous"}]`;
    }
    return value;
  };
  const deserializeError = (value, options = {}) => {
    const { maxDepth = Number.POSITIVE_INFINITY } = options;
    if (value instanceof Error) {
      return value;
    }
    if (typeof value === "object" && value !== null && !Array.isArray(value)) {
      const newError = new Error();
      destroyCircular({
        from: value,
        seen: [],
        to_: newError,
        maxDepth,
        depth: 0
      });
      return newError;
    }
    return new NonError(value);
  };
  serializeError_1 = {
    serializeError,
    deserializeError
  };
  return serializeError_1;
}
var util$2 = {};
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil)
    return util$2;
  hasRequiredUtil = 1;
  const getUniqueId = () => `${Date.now()}-${Math.random()}`;
  const getSendChannel = (channel) => `%better-ipc-send-channel-${channel}`;
  const getRendererSendChannel = (channel) => `%better-ipc-send-channel-${channel}`;
  util$2.currentWindowChannel = "%better-ipc-current-window";
  util$2.getSendChannel = getSendChannel;
  util$2.getRendererSendChannel = getRendererSendChannel;
  util$2.getResponseChannels = (channel) => {
    const id2 = getUniqueId();
    return {
      sendChannel: getSendChannel(channel),
      dataChannel: `%better-ipc-response-data-channel-${channel}-${id2}`,
      errorChannel: `%better-ipc-response-error-channel-${channel}-${id2}`
    };
  };
  util$2.getRendererResponseChannels = (channel) => {
    const id2 = getUniqueId();
    return {
      sendChannel: getRendererSendChannel(channel),
      dataChannel: `%better-ipc-response-data-channel-${channel}-${id2}`,
      errorChannel: `%better-ipc-response-error-channel-${channel}-${id2}`
    };
  };
  return util$2;
}
var main;
var hasRequiredMain;
function requireMain() {
  if (hasRequiredMain)
    return main;
  hasRequiredMain = 1;
  const electron = require$$0;
  const { serializeError, deserializeError } = requireSerializeError();
  const util2 = requireUtil();
  const { ipcMain: ipcMain2, BrowserWindow } = electron;
  const ipc = Object.create(ipcMain2 || {});
  ipc.callRenderer = (browserWindow, channel, data) => new Promise((resolve2, reject) => {
    if (!browserWindow) {
      throw new Error("Browser window required");
    }
    const { sendChannel, dataChannel, errorChannel } = util2.getRendererResponseChannels(channel);
    const cleanup = () => {
      ipcMain2.off(dataChannel, onData);
      ipcMain2.off(errorChannel, onError);
    };
    const onData = (event, result) => {
      const window2 = BrowserWindow.fromWebContents(event.sender);
      if (window2.id === browserWindow.id) {
        cleanup();
        resolve2(result);
      }
    };
    const onError = (event, error2) => {
      const window2 = BrowserWindow.fromWebContents(event.sender);
      if (window2.id === browserWindow.id) {
        cleanup();
        reject(deserializeError(error2));
      }
    };
    ipcMain2.on(dataChannel, onData);
    ipcMain2.on(errorChannel, onError);
    const completeData = {
      dataChannel,
      errorChannel,
      userData: data
    };
    if (browserWindow.webContents) {
      browserWindow.webContents.send(sendChannel, completeData);
    }
  });
  ipc.callFocusedRenderer = async (...args) => {
    const focusedWindow = BrowserWindow.getFocusedWindow();
    if (!focusedWindow) {
      throw new Error("No browser window in focus");
    }
    return ipc.callRenderer(focusedWindow, ...args);
  };
  ipc.answerRenderer = (browserWindowOrChannel, channelOrCallback, callbackOrNothing) => {
    let window2;
    let channel;
    let callback;
    if (callbackOrNothing === void 0) {
      channel = browserWindowOrChannel;
      callback = channelOrCallback;
    } else {
      window2 = browserWindowOrChannel;
      channel = channelOrCallback;
      callback = callbackOrNothing;
      if (!window2) {
        throw new Error("Browser window required");
      }
    }
    const sendChannel = util2.getSendChannel(channel);
    const listener = async (event, data) => {
      const browserWindow = BrowserWindow.fromWebContents(event.sender);
      if (window2 && window2.id !== browserWindow.id) {
        return;
      }
      const send = (channel2, data2) => {
        if (!(browserWindow && browserWindow.isDestroyed())) {
          event.sender.send(channel2, data2);
        }
      };
      const { dataChannel, errorChannel, userData } = data;
      try {
        send(dataChannel, await callback(userData, browserWindow));
      } catch (error2) {
        send(errorChannel, serializeError(error2));
      }
    };
    ipcMain2.on(sendChannel, listener);
    return () => {
      ipcMain2.off(sendChannel, listener);
    };
  };
  ipc.sendToRenderers = (channel, data) => {
    for (const browserWindow of BrowserWindow.getAllWindows()) {
      if (browserWindow.webContents) {
        browserWindow.webContents.send(channel, data);
      }
    }
  };
  main = ipc;
  return main;
}
var renderer;
var hasRequiredRenderer;
function requireRenderer() {
  if (hasRequiredRenderer)
    return renderer;
  hasRequiredRenderer = 1;
  const electron = require$$0;
  const { serializeError, deserializeError } = requireSerializeError();
  const util2 = requireUtil();
  const { ipcRenderer: ipcRenderer2 } = electron;
  const ipc = Object.create(ipcRenderer2 || {});
  ipc.callMain = (channel, data) => new Promise((resolve2, reject) => {
    const { sendChannel, dataChannel, errorChannel } = util2.getResponseChannels(channel);
    const cleanup = () => {
      ipcRenderer2.off(dataChannel, onData);
      ipcRenderer2.off(errorChannel, onError);
    };
    const onData = (_event, result) => {
      cleanup();
      resolve2(result);
    };
    const onError = (_event, error2) => {
      cleanup();
      reject(deserializeError(error2));
    };
    ipcRenderer2.once(dataChannel, onData);
    ipcRenderer2.once(errorChannel, onError);
    const completeData = {
      dataChannel,
      errorChannel,
      userData: data
    };
    ipcRenderer2.send(sendChannel, completeData);
  });
  ipc.answerMain = (channel, callback) => {
    const sendChannel = util2.getRendererSendChannel(channel);
    const listener = async (_event, data) => {
      const { dataChannel, errorChannel, userData } = data;
      try {
        ipcRenderer2.send(dataChannel, await callback(userData));
      } catch (error2) {
        ipcRenderer2.send(errorChannel, serializeError(error2));
      }
    };
    ipcRenderer2.on(sendChannel, listener);
    return () => {
      ipcRenderer2.off(sendChannel, listener);
    };
  };
  renderer = ipc;
  return renderer;
}
var ipcMain$1;
if (process.type === "renderer") {
  requireRenderer();
} else {
  ipcMain$1 = requireMain();
}
var fs$k = {};
var universalify$1 = {};
universalify$1.fromCallback = function(fn) {
  return Object.defineProperty(function(...args) {
    if (typeof args[args.length - 1] === "function")
      fn.apply(this, args);
    else {
      return new Promise((resolve2, reject) => {
        fn.call(
          this,
          ...args,
          (err, res) => err != null ? reject(err) : resolve2(res)
        );
      });
    }
  }, "name", { value: fn.name });
};
universalify$1.fromPromise = function(fn) {
  return Object.defineProperty(function(...args) {
    const cb = args[args.length - 1];
    if (typeof cb !== "function")
      return fn.apply(this, args);
    else
      fn.apply(this, args.slice(0, -1)).then((r) => cb(null, r), cb);
  }, "name", { value: fn.name });
};
var constants$1 = require$$0$1;
var origCwd = process.cwd;
var cwd = null;
var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process);
  return cwd;
};
try {
  process.cwd();
} catch (er) {
}
if (typeof process.chdir === "function") {
  var chdir = process.chdir;
  process.chdir = function(d) {
    cwd = null;
    chdir.call(process, d);
  };
  if (Object.setPrototypeOf)
    Object.setPrototypeOf(process.chdir, chdir);
}
var polyfills$1 = patch$2;
function patch$2(fs2) {
  if (constants$1.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs2);
  }
  if (!fs2.lutimes) {
    patchLutimes(fs2);
  }
  fs2.chown = chownFix(fs2.chown);
  fs2.fchown = chownFix(fs2.fchown);
  fs2.lchown = chownFix(fs2.lchown);
  fs2.chmod = chmodFix(fs2.chmod);
  fs2.fchmod = chmodFix(fs2.fchmod);
  fs2.lchmod = chmodFix(fs2.lchmod);
  fs2.chownSync = chownFixSync(fs2.chownSync);
  fs2.fchownSync = chownFixSync(fs2.fchownSync);
  fs2.lchownSync = chownFixSync(fs2.lchownSync);
  fs2.chmodSync = chmodFixSync(fs2.chmodSync);
  fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
  fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
  fs2.stat = statFix(fs2.stat);
  fs2.fstat = statFix(fs2.fstat);
  fs2.lstat = statFix(fs2.lstat);
  fs2.statSync = statFixSync(fs2.statSync);
  fs2.fstatSync = statFixSync(fs2.fstatSync);
  fs2.lstatSync = statFixSync(fs2.lstatSync);
  if (!fs2.lchmod) {
    fs2.lchmod = function(path2, mode, cb) {
      if (cb)
        process.nextTick(cb);
    };
    fs2.lchmodSync = function() {
    };
  }
  if (!fs2.lchown) {
    fs2.lchown = function(path2, uid, gid, cb) {
      if (cb)
        process.nextTick(cb);
    };
    fs2.lchownSync = function() {
    };
  }
  if (platform === "win32") {
    fs2.rename = /* @__PURE__ */ function(fs$rename) {
      return function(from, to, cb) {
        var start = Date.now();
        var backoff = 0;
        fs$rename(from, to, function CB(er) {
          if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
            setTimeout(function() {
              fs2.stat(to, function(stater, st) {
                if (stater && stater.code === "ENOENT")
                  fs$rename(from, to, CB);
                else
                  cb(er);
              });
            }, backoff);
            if (backoff < 100)
              backoff += 10;
            return;
          }
          if (cb)
            cb(er);
        });
      };
    }(fs2.rename);
  }
  fs2.read = function(fs$read) {
    function read(fd, buffer, offset, length, position, callback_) {
      var callback;
      if (callback_ && typeof callback_ === "function") {
        var eagCounter = 0;
        callback = function(er, _, __) {
          if (er && er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
          }
          callback_.apply(this, arguments);
        };
      }
      return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
    }
    if (Object.setPrototypeOf)
      Object.setPrototypeOf(read, fs$read);
    return read;
  }(fs2.read);
  fs2.readSync = /* @__PURE__ */ function(fs$readSync) {
    return function(fd, buffer, offset, length, position) {
      var eagCounter = 0;
      while (true) {
        try {
          return fs$readSync.call(fs2, fd, buffer, offset, length, position);
        } catch (er) {
          if (er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            continue;
          }
          throw er;
        }
      }
    };
  }(fs2.readSync);
  function patchLchmod(fs3) {
    fs3.lchmod = function(path2, mode, callback) {
      fs3.open(
        path2,
        constants$1.O_WRONLY | constants$1.O_SYMLINK,
        mode,
        function(err, fd) {
          if (err) {
            if (callback)
              callback(err);
            return;
          }
          fs3.fchmod(fd, mode, function(err2) {
            fs3.close(fd, function(err22) {
              if (callback)
                callback(err2 || err22);
            });
          });
        }
      );
    };
    fs3.lchmodSync = function(path2, mode) {
      var fd = fs3.openSync(path2, constants$1.O_WRONLY | constants$1.O_SYMLINK, mode);
      var threw = true;
      var ret;
      try {
        ret = fs3.fchmodSync(fd, mode);
        threw = false;
      } finally {
        if (threw) {
          try {
            fs3.closeSync(fd);
          } catch (er) {
          }
        } else {
          fs3.closeSync(fd);
        }
      }
      return ret;
    };
  }
  function patchLutimes(fs3) {
    if (constants$1.hasOwnProperty("O_SYMLINK")) {
      fs3.lutimes = function(path2, at, mt, cb) {
        fs3.open(path2, constants$1.O_SYMLINK, function(er, fd) {
          if (er) {
            if (cb)
              cb(er);
            return;
          }
          fs3.futimes(fd, at, mt, function(er2) {
            fs3.close(fd, function(er22) {
              if (cb)
                cb(er2 || er22);
            });
          });
        });
      };
      fs3.lutimesSync = function(path2, at, mt) {
        var fd = fs3.openSync(path2, constants$1.O_SYMLINK);
        var ret;
        var threw = true;
        try {
          ret = fs3.futimesSync(fd, at, mt);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs3.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs3.closeSync(fd);
          }
        }
        return ret;
      };
    } else {
      fs3.lutimes = function(_a, _b, _c, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs3.lutimesSync = function() {
      };
    }
  }
  function chmodFix(orig) {
    if (!orig)
      return orig;
    return function(target, mode, cb) {
      return orig.call(fs2, target, mode, function(er) {
        if (chownErOk(er))
          er = null;
        if (cb)
          cb.apply(this, arguments);
      });
    };
  }
  function chmodFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, mode) {
      try {
        return orig.call(fs2, target, mode);
      } catch (er) {
        if (!chownErOk(er))
          throw er;
      }
    };
  }
  function chownFix(orig) {
    if (!orig)
      return orig;
    return function(target, uid, gid, cb) {
      return orig.call(fs2, target, uid, gid, function(er) {
        if (chownErOk(er))
          er = null;
        if (cb)
          cb.apply(this, arguments);
      });
    };
  }
  function chownFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, uid, gid) {
      try {
        return orig.call(fs2, target, uid, gid);
      } catch (er) {
        if (!chownErOk(er))
          throw er;
      }
    };
  }
  function statFix(orig) {
    if (!orig)
      return orig;
    return function(target, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      function callback(er, stats) {
        if (stats) {
          if (stats.uid < 0)
            stats.uid += 4294967296;
          if (stats.gid < 0)
            stats.gid += 4294967296;
        }
        if (cb)
          cb.apply(this, arguments);
      }
      return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
    };
  }
  function statFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, options) {
      var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
      if (stats.uid < 0)
        stats.uid += 4294967296;
      if (stats.gid < 0)
        stats.gid += 4294967296;
      return stats;
    };
  }
  function chownErOk(er) {
    if (!er)
      return true;
    if (er.code === "ENOSYS")
      return true;
    var nonroot = !process.getuid || process.getuid() !== 0;
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true;
    }
    return false;
  }
}
var Stream = require$$0$2.Stream;
var legacyStreams = legacy$1;
function legacy$1(fs2) {
  return {
    ReadStream,
    WriteStream
  };
  function ReadStream(path2, options) {
    if (!(this instanceof ReadStream))
      return new ReadStream(path2, options);
    Stream.call(this);
    var self2 = this;
    this.path = path2;
    this.fd = null;
    this.readable = true;
    this.paused = false;
    this.flags = "r";
    this.mode = 438;
    this.bufferSize = 64 * 1024;
    options = options || {};
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }
    if (this.encoding)
      this.setEncoding(this.encoding);
    if (this.start !== void 0) {
      if ("number" !== typeof this.start) {
        throw TypeError("start must be a Number");
      }
      if (this.end === void 0) {
        this.end = Infinity;
      } else if ("number" !== typeof this.end) {
        throw TypeError("end must be a Number");
      }
      if (this.start > this.end) {
        throw new Error("start must be <= end");
      }
      this.pos = this.start;
    }
    if (this.fd !== null) {
      process.nextTick(function() {
        self2._read();
      });
      return;
    }
    fs2.open(this.path, this.flags, this.mode, function(err, fd) {
      if (err) {
        self2.emit("error", err);
        self2.readable = false;
        return;
      }
      self2.fd = fd;
      self2.emit("open", fd);
      self2._read();
    });
  }
  function WriteStream(path2, options) {
    if (!(this instanceof WriteStream))
      return new WriteStream(path2, options);
    Stream.call(this);
    this.path = path2;
    this.fd = null;
    this.writable = true;
    this.flags = "w";
    this.encoding = "binary";
    this.mode = 438;
    this.bytesWritten = 0;
    options = options || {};
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }
    if (this.start !== void 0) {
      if ("number" !== typeof this.start) {
        throw TypeError("start must be a Number");
      }
      if (this.start < 0) {
        throw new Error("start must be >= zero");
      }
      this.pos = this.start;
    }
    this.busy = false;
    this._queue = [];
    if (this.fd === null) {
      this._open = fs2.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
      this.flush();
    }
  }
}
var clone_1 = clone$1;
var getPrototypeOf = Object.getPrototypeOf || function(obj) {
  return obj.__proto__;
};
function clone$1(obj) {
  if (obj === null || typeof obj !== "object")
    return obj;
  if (obj instanceof Object)
    var copy2 = { __proto__: getPrototypeOf(obj) };
  else
    var copy2 = /* @__PURE__ */ Object.create(null);
  Object.getOwnPropertyNames(obj).forEach(function(key) {
    Object.defineProperty(copy2, key, Object.getOwnPropertyDescriptor(obj, key));
  });
  return copy2;
}
var fs$j = require$$0$3;
var polyfills = polyfills$1;
var legacy = legacyStreams;
var clone = clone_1;
var util$1 = require$$4;
var gracefulQueue;
var previousSymbol;
if (typeof Symbol === "function" && typeof Symbol.for === "function") {
  gracefulQueue = Symbol.for("graceful-fs.queue");
  previousSymbol = Symbol.for("graceful-fs.previous");
} else {
  gracefulQueue = "___graceful-fs.queue";
  previousSymbol = "___graceful-fs.previous";
}
function noop() {
}
function publishQueue(context, queue) {
  Object.defineProperty(context, gracefulQueue, {
    get: function() {
      return queue;
    }
  });
}
var debug$2 = noop;
if (util$1.debuglog)
  debug$2 = util$1.debuglog("gfs4");
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
  debug$2 = function() {
    var m = util$1.format.apply(util$1, arguments);
    m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
    console.error(m);
  };
if (!fs$j[gracefulQueue]) {
  var queue = commonjsGlobal[gracefulQueue] || [];
  publishQueue(fs$j, queue);
  fs$j.close = function(fs$close) {
    function close(fd, cb) {
      return fs$close.call(fs$j, fd, function(err) {
        if (!err) {
          resetQueue();
        }
        if (typeof cb === "function")
          cb.apply(this, arguments);
      });
    }
    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    });
    return close;
  }(fs$j.close);
  fs$j.closeSync = function(fs$closeSync) {
    function closeSync(fd) {
      fs$closeSync.apply(fs$j, arguments);
      resetQueue();
    }
    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    });
    return closeSync;
  }(fs$j.closeSync);
  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
    process.on("exit", function() {
      debug$2(fs$j[gracefulQueue]);
      require$$5.equal(fs$j[gracefulQueue].length, 0);
    });
  }
}
if (!commonjsGlobal[gracefulQueue]) {
  publishQueue(commonjsGlobal, fs$j[gracefulQueue]);
}
var gracefulFs = patch$1(clone(fs$j));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs$j.__patched) {
  gracefulFs = patch$1(fs$j);
  fs$j.__patched = true;
}
function patch$1(fs2) {
  polyfills(fs2);
  fs2.gracefulify = patch$1;
  fs2.createReadStream = createReadStream;
  fs2.createWriteStream = createWriteStream;
  var fs$readFile = fs2.readFile;
  fs2.readFile = readFile2;
  function readFile2(path2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$readFile(path2, options, cb);
    function go$readFile(path3, options2, cb2, startTime) {
      return fs$readFile(path3, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$readFile, [path3, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$writeFile = fs2.writeFile;
  fs2.writeFile = writeFile2;
  function writeFile2(path2, data, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$writeFile(path2, data, options, cb);
    function go$writeFile(path3, data2, options2, cb2, startTime) {
      return fs$writeFile(path3, data2, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$writeFile, [path3, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$appendFile = fs2.appendFile;
  if (fs$appendFile)
    fs2.appendFile = appendFile;
  function appendFile(path2, data, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$appendFile(path2, data, options, cb);
    function go$appendFile(path3, data2, options2, cb2, startTime) {
      return fs$appendFile(path3, data2, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$appendFile, [path3, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$copyFile = fs2.copyFile;
  if (fs$copyFile)
    fs2.copyFile = copyFile2;
  function copyFile2(src, dest, flags, cb) {
    if (typeof flags === "function") {
      cb = flags;
      flags = 0;
    }
    return go$copyFile(src, dest, flags, cb);
    function go$copyFile(src2, dest2, flags2, cb2, startTime) {
      return fs$copyFile(src2, dest2, flags2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$readdir = fs2.readdir;
  fs2.readdir = readdir;
  function readdir(path2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$readdir(path2, options, cb);
    function go$readdir(path3, options2, cb2, startTime) {
      return fs$readdir(path3, options2, function(err, files) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$readdir, [path3, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (files && files.sort)
            files.sort();
          if (typeof cb2 === "function")
            cb2.call(this, err, files);
        }
      });
    }
  }
  if (process.version.substr(0, 4) === "v0.8") {
    var legStreams = legacy(fs2);
    ReadStream = legStreams.ReadStream;
    WriteStream = legStreams.WriteStream;
  }
  var fs$ReadStream = fs2.ReadStream;
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype);
    ReadStream.prototype.open = ReadStream$open;
  }
  var fs$WriteStream = fs2.WriteStream;
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype);
    WriteStream.prototype.open = WriteStream$open;
  }
  Object.defineProperty(fs2, "ReadStream", {
    get: function() {
      return ReadStream;
    },
    set: function(val) {
      ReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(fs2, "WriteStream", {
    get: function() {
      return WriteStream;
    },
    set: function(val) {
      WriteStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileReadStream = ReadStream;
  Object.defineProperty(fs2, "FileReadStream", {
    get: function() {
      return FileReadStream;
    },
    set: function(val) {
      FileReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileWriteStream = WriteStream;
  Object.defineProperty(fs2, "FileWriteStream", {
    get: function() {
      return FileWriteStream;
    },
    set: function(val) {
      FileWriteStream = val;
    },
    enumerable: true,
    configurable: true
  });
  function ReadStream(path2, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this;
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
  }
  function ReadStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function(err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy();
        that.emit("error", err);
      } else {
        that.fd = fd;
        that.emit("open", fd);
        that.read();
      }
    });
  }
  function WriteStream(path2, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this;
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
  }
  function WriteStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function(err, fd) {
      if (err) {
        that.destroy();
        that.emit("error", err);
      } else {
        that.fd = fd;
        that.emit("open", fd);
      }
    });
  }
  function createReadStream(path2, options) {
    return new fs2.ReadStream(path2, options);
  }
  function createWriteStream(path2, options) {
    return new fs2.WriteStream(path2, options);
  }
  var fs$open = fs2.open;
  fs2.open = open;
  function open(path2, flags, mode, cb) {
    if (typeof mode === "function")
      cb = mode, mode = null;
    return go$open(path2, flags, mode, cb);
    function go$open(path3, flags2, mode2, cb2, startTime) {
      return fs$open(path3, flags2, mode2, function(err, fd) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$open, [path3, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  return fs2;
}
function enqueue(elem) {
  debug$2("ENQUEUE", elem[0].name, elem[1]);
  fs$j[gracefulQueue].push(elem);
  retry();
}
var retryTimer;
function resetQueue() {
  var now = Date.now();
  for (var i = 0; i < fs$j[gracefulQueue].length; ++i) {
    if (fs$j[gracefulQueue][i].length > 2) {
      fs$j[gracefulQueue][i][3] = now;
      fs$j[gracefulQueue][i][4] = now;
    }
  }
  retry();
}
function retry() {
  clearTimeout(retryTimer);
  retryTimer = void 0;
  if (fs$j[gracefulQueue].length === 0)
    return;
  var elem = fs$j[gracefulQueue].shift();
  var fn = elem[0];
  var args = elem[1];
  var err = elem[2];
  var startTime = elem[3];
  var lastTime = elem[4];
  if (startTime === void 0) {
    debug$2("RETRY", fn.name, args);
    fn.apply(null, args);
  } else if (Date.now() - startTime >= 6e4) {
    debug$2("TIMEOUT", fn.name, args);
    var cb = args.pop();
    if (typeof cb === "function")
      cb.call(null, err);
  } else {
    var sinceAttempt = Date.now() - lastTime;
    var sinceStart = Math.max(lastTime - startTime, 1);
    var desiredDelay = Math.min(sinceStart * 1.2, 100);
    if (sinceAttempt >= desiredDelay) {
      debug$2("RETRY", fn.name, args);
      fn.apply(null, args.concat([startTime]));
    } else {
      fs$j[gracefulQueue].push(elem);
    }
  }
  if (retryTimer === void 0) {
    retryTimer = setTimeout(retry, 0);
  }
}
(function(exports2) {
  const u2 = universalify$1.fromCallback;
  const fs2 = gracefulFs;
  const api = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((key) => {
    return typeof fs2[key] === "function";
  });
  Object.assign(exports2, fs2);
  api.forEach((method) => {
    exports2[method] = u2(fs2[method]);
  });
  exports2.exists = function(filename, callback) {
    if (typeof callback === "function") {
      return fs2.exists(filename, callback);
    }
    return new Promise((resolve2) => {
      return fs2.exists(filename, resolve2);
    });
  };
  exports2.read = function(fd, buffer, offset, length, position, callback) {
    if (typeof callback === "function") {
      return fs2.read(fd, buffer, offset, length, position, callback);
    }
    return new Promise((resolve2, reject) => {
      fs2.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
        if (err)
          return reject(err);
        resolve2({ bytesRead, buffer: buffer2 });
      });
    });
  };
  exports2.write = function(fd, buffer, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs2.write(fd, buffer, ...args);
    }
    return new Promise((resolve2, reject) => {
      fs2.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
        if (err)
          return reject(err);
        resolve2({ bytesWritten, buffer: buffer2 });
      });
    });
  };
  exports2.readv = function(fd, buffers, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs2.readv(fd, buffers, ...args);
    }
    return new Promise((resolve2, reject) => {
      fs2.readv(fd, buffers, ...args, (err, bytesRead, buffers2) => {
        if (err)
          return reject(err);
        resolve2({ bytesRead, buffers: buffers2 });
      });
    });
  };
  exports2.writev = function(fd, buffers, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs2.writev(fd, buffers, ...args);
    }
    return new Promise((resolve2, reject) => {
      fs2.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
        if (err)
          return reject(err);
        resolve2({ bytesWritten, buffers: buffers2 });
      });
    });
  };
  if (typeof fs2.realpath.native === "function") {
    exports2.realpath.native = u2(fs2.realpath.native);
  } else {
    process.emitWarning(
      "fs.realpath.native is not a function. Is fs being monkey-patched?",
      "Warning",
      "fs-extra-WARN0003"
    );
  }
})(fs$k);
var makeDir$1 = {};
var utils$1 = {};
const path$h = require$$1;
utils$1.checkPath = function checkPath(pth) {
  if (process.platform === "win32") {
    const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path$h.parse(pth).root, ""));
    if (pathHasInvalidWinCharacters) {
      const error2 = new Error(`Path contains invalid characters: ${pth}`);
      error2.code = "EINVAL";
      throw error2;
    }
  }
};
const fs$i = fs$k;
const { checkPath: checkPath2 } = utils$1;
const getMode = (options) => {
  const defaults2 = { mode: 511 };
  if (typeof options === "number")
    return options;
  return { ...defaults2, ...options }.mode;
};
makeDir$1.makeDir = async (dir, options) => {
  checkPath2(dir);
  return fs$i.mkdir(dir, {
    mode: getMode(options),
    recursive: true
  });
};
makeDir$1.makeDirSync = (dir, options) => {
  checkPath2(dir);
  return fs$i.mkdirSync(dir, {
    mode: getMode(options),
    recursive: true
  });
};
const u$e = universalify$1.fromPromise;
const { makeDir: _makeDir, makeDirSync } = makeDir$1;
const makeDir = u$e(_makeDir);
var mkdirs$2 = {
  mkdirs: makeDir,
  mkdirsSync: makeDirSync,
  // alias
  mkdirp: makeDir,
  mkdirpSync: makeDirSync,
  ensureDir: makeDir,
  ensureDirSync: makeDirSync
};
const u$d = universalify$1.fromPromise;
const fs$h = fs$k;
function pathExists$8(path2) {
  return fs$h.access(path2).then(() => true).catch(() => false);
}
var pathExists_1 = {
  pathExists: u$d(pathExists$8),
  pathExistsSync: fs$h.existsSync
};
const fs$g = fs$k;
const u$c = universalify$1.fromPromise;
async function utimesMillis$1(path2, atime, mtime) {
  const fd = await fs$g.open(path2, "r+");
  let closeErr = null;
  try {
    await fs$g.futimes(fd, atime, mtime);
  } finally {
    try {
      await fs$g.close(fd);
    } catch (e) {
      closeErr = e;
    }
  }
  if (closeErr) {
    throw closeErr;
  }
}
function utimesMillisSync$1(path2, atime, mtime) {
  const fd = fs$g.openSync(path2, "r+");
  fs$g.futimesSync(fd, atime, mtime);
  return fs$g.closeSync(fd);
}
var utimes = {
  utimesMillis: u$c(utimesMillis$1),
  utimesMillisSync: utimesMillisSync$1
};
const fs$f = fs$k;
const path$g = require$$1;
const u$b = universalify$1.fromPromise;
function getStats$1(src, dest, opts2) {
  const statFunc = opts2.dereference ? (file2) => fs$f.stat(file2, { bigint: true }) : (file2) => fs$f.lstat(file2, { bigint: true });
  return Promise.all([
    statFunc(src),
    statFunc(dest).catch((err) => {
      if (err.code === "ENOENT")
        return null;
      throw err;
    })
  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
}
function getStatsSync(src, dest, opts2) {
  let destStat;
  const statFunc = opts2.dereference ? (file2) => fs$f.statSync(file2, { bigint: true }) : (file2) => fs$f.lstatSync(file2, { bigint: true });
  const srcStat = statFunc(src);
  try {
    destStat = statFunc(dest);
  } catch (err) {
    if (err.code === "ENOENT")
      return { srcStat, destStat: null };
    throw err;
  }
  return { srcStat, destStat };
}
async function checkPaths(src, dest, funcName, opts2) {
  const { srcStat, destStat } = await getStats$1(src, dest, opts2);
  if (destStat) {
    if (areIdentical$2(srcStat, destStat)) {
      const srcBaseName = path$g.basename(src);
      const destBaseName = path$g.basename(dest);
      if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
        return { srcStat, destStat, isChangingCase: true };
      }
      throw new Error("Source and destination must not be the same.");
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
    }
  }
  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new Error(errMsg(src, dest, funcName));
  }
  return { srcStat, destStat };
}
function checkPathsSync(src, dest, funcName, opts2) {
  const { srcStat, destStat } = getStatsSync(src, dest, opts2);
  if (destStat) {
    if (areIdentical$2(srcStat, destStat)) {
      const srcBaseName = path$g.basename(src);
      const destBaseName = path$g.basename(dest);
      if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
        return { srcStat, destStat, isChangingCase: true };
      }
      throw new Error("Source and destination must not be the same.");
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
    }
  }
  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new Error(errMsg(src, dest, funcName));
  }
  return { srcStat, destStat };
}
async function checkParentPaths(src, srcStat, dest, funcName) {
  const srcParent = path$g.resolve(path$g.dirname(src));
  const destParent = path$g.resolve(path$g.dirname(dest));
  if (destParent === srcParent || destParent === path$g.parse(destParent).root)
    return;
  let destStat;
  try {
    destStat = await fs$f.stat(destParent, { bigint: true });
  } catch (err) {
    if (err.code === "ENOENT")
      return;
    throw err;
  }
  if (areIdentical$2(srcStat, destStat)) {
    throw new Error(errMsg(src, dest, funcName));
  }
  return checkParentPaths(src, srcStat, destParent, funcName);
}
function checkParentPathsSync(src, srcStat, dest, funcName) {
  const srcParent = path$g.resolve(path$g.dirname(src));
  const destParent = path$g.resolve(path$g.dirname(dest));
  if (destParent === srcParent || destParent === path$g.parse(destParent).root)
    return;
  let destStat;
  try {
    destStat = fs$f.statSync(destParent, { bigint: true });
  } catch (err) {
    if (err.code === "ENOENT")
      return;
    throw err;
  }
  if (areIdentical$2(srcStat, destStat)) {
    throw new Error(errMsg(src, dest, funcName));
  }
  return checkParentPathsSync(src, srcStat, destParent, funcName);
}
function areIdentical$2(srcStat, destStat) {
  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
}
function isSrcSubdir(src, dest) {
  const srcArr = path$g.resolve(src).split(path$g.sep).filter((i) => i);
  const destArr = path$g.resolve(dest).split(path$g.sep).filter((i) => i);
  return srcArr.every((cur, i) => destArr[i] === cur);
}
function errMsg(src, dest, funcName) {
  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
}
var stat$4 = {
  // checkPaths
  checkPaths: u$b(checkPaths),
  checkPathsSync,
  // checkParent
  checkParentPaths: u$b(checkParentPaths),
  checkParentPathsSync,
  // Misc
  isSrcSubdir,
  areIdentical: areIdentical$2
};
const fs$e = fs$k;
const path$f = require$$1;
const { mkdirs: mkdirs$1 } = mkdirs$2;
const { pathExists: pathExists$7 } = pathExists_1;
const { utimesMillis } = utimes;
const stat$3 = stat$4;
async function copy$2(src, dest, opts2 = {}) {
  if (typeof opts2 === "function") {
    opts2 = { filter: opts2 };
  }
  opts2.clobber = "clobber" in opts2 ? !!opts2.clobber : true;
  opts2.overwrite = "overwrite" in opts2 ? !!opts2.overwrite : opts2.clobber;
  if (opts2.preserveTimestamps && process.arch === "ia32") {
    process.emitWarning(
      "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
      "Warning",
      "fs-extra-WARN0001"
    );
  }
  const { srcStat, destStat } = await stat$3.checkPaths(src, dest, "copy", opts2);
  await stat$3.checkParentPaths(src, srcStat, dest, "copy");
  const include = await runFilter(src, dest, opts2);
  if (!include)
    return;
  const destParent = path$f.dirname(dest);
  const dirExists = await pathExists$7(destParent);
  if (!dirExists) {
    await mkdirs$1(destParent);
  }
  await getStatsAndPerformCopy(destStat, src, dest, opts2);
}
async function runFilter(src, dest, opts2) {
  if (!opts2.filter)
    return true;
  return opts2.filter(src, dest);
}
async function getStatsAndPerformCopy(destStat, src, dest, opts2) {
  const statFn = opts2.dereference ? fs$e.stat : fs$e.lstat;
  const srcStat = await statFn(src);
  if (srcStat.isDirectory())
    return onDir$1(srcStat, destStat, src, dest, opts2);
  if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
    return onFile$1(srcStat, destStat, src, dest, opts2);
  if (srcStat.isSymbolicLink())
    return onLink$1(destStat, src, dest, opts2);
  if (srcStat.isSocket())
    throw new Error(`Cannot copy a socket file: ${src}`);
  if (srcStat.isFIFO())
    throw new Error(`Cannot copy a FIFO pipe: ${src}`);
  throw new Error(`Unknown file: ${src}`);
}
async function onFile$1(srcStat, destStat, src, dest, opts2) {
  if (!destStat)
    return copyFile$1(srcStat, src, dest, opts2);
  if (opts2.overwrite) {
    await fs$e.unlink(dest);
    return copyFile$1(srcStat, src, dest, opts2);
  }
  if (opts2.errorOnExist) {
    throw new Error(`'${dest}' already exists`);
  }
}
async function copyFile$1(srcStat, src, dest, opts2) {
  await fs$e.copyFile(src, dest);
  if (opts2.preserveTimestamps) {
    if (fileIsNotWritable$1(srcStat.mode)) {
      await makeFileWritable$1(dest, srcStat.mode);
    }
    const updatedSrcStat = await fs$e.stat(src);
    await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
  }
  return fs$e.chmod(dest, srcStat.mode);
}
function fileIsNotWritable$1(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable$1(dest, srcMode) {
  return fs$e.chmod(dest, srcMode | 128);
}
async function onDir$1(srcStat, destStat, src, dest, opts2) {
  if (!destStat) {
    await fs$e.mkdir(dest);
  }
  const items2 = await fs$e.readdir(src);
  await Promise.all(items2.map(async (item) => {
    const srcItem = path$f.join(src, item);
    const destItem = path$f.join(dest, item);
    const include = await runFilter(srcItem, destItem, opts2);
    if (!include)
      return;
    const { destStat: destStat2 } = await stat$3.checkPaths(srcItem, destItem, "copy", opts2);
    return getStatsAndPerformCopy(destStat2, srcItem, destItem, opts2);
  }));
  if (!destStat) {
    await fs$e.chmod(dest, srcStat.mode);
  }
}
async function onLink$1(destStat, src, dest, opts2) {
  let resolvedSrc = await fs$e.readlink(src);
  if (opts2.dereference) {
    resolvedSrc = path$f.resolve(process.cwd(), resolvedSrc);
  }
  if (!destStat) {
    return fs$e.symlink(resolvedSrc, dest);
  }
  let resolvedDest = null;
  try {
    resolvedDest = await fs$e.readlink(dest);
  } catch (e) {
    if (e.code === "EINVAL" || e.code === "UNKNOWN")
      return fs$e.symlink(resolvedSrc, dest);
    throw e;
  }
  if (opts2.dereference) {
    resolvedDest = path$f.resolve(process.cwd(), resolvedDest);
  }
  if (stat$3.isSrcSubdir(resolvedSrc, resolvedDest)) {
    throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
  }
  if (stat$3.isSrcSubdir(resolvedDest, resolvedSrc)) {
    throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
  }
  await fs$e.unlink(dest);
  return fs$e.symlink(resolvedSrc, dest);
}
var copy_1 = copy$2;
const fs$d = gracefulFs;
const path$e = require$$1;
const mkdirsSync$1 = mkdirs$2.mkdirsSync;
const utimesMillisSync = utimes.utimesMillisSync;
const stat$2 = stat$4;
function copySync$1(src, dest, opts2) {
  if (typeof opts2 === "function") {
    opts2 = { filter: opts2 };
  }
  opts2 = opts2 || {};
  opts2.clobber = "clobber" in opts2 ? !!opts2.clobber : true;
  opts2.overwrite = "overwrite" in opts2 ? !!opts2.overwrite : opts2.clobber;
  if (opts2.preserveTimestamps && process.arch === "ia32") {
    process.emitWarning(
      "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
      "Warning",
      "fs-extra-WARN0002"
    );
  }
  const { srcStat, destStat } = stat$2.checkPathsSync(src, dest, "copy", opts2);
  stat$2.checkParentPathsSync(src, srcStat, dest, "copy");
  if (opts2.filter && !opts2.filter(src, dest))
    return;
  const destParent = path$e.dirname(dest);
  if (!fs$d.existsSync(destParent))
    mkdirsSync$1(destParent);
  return getStats(destStat, src, dest, opts2);
}
function getStats(destStat, src, dest, opts2) {
  const statSync = opts2.dereference ? fs$d.statSync : fs$d.lstatSync;
  const srcStat = statSync(src);
  if (srcStat.isDirectory())
    return onDir(srcStat, destStat, src, dest, opts2);
  else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
    return onFile(srcStat, destStat, src, dest, opts2);
  else if (srcStat.isSymbolicLink())
    return onLink(destStat, src, dest, opts2);
  else if (srcStat.isSocket())
    throw new Error(`Cannot copy a socket file: ${src}`);
  else if (srcStat.isFIFO())
    throw new Error(`Cannot copy a FIFO pipe: ${src}`);
  throw new Error(`Unknown file: ${src}`);
}
function onFile(srcStat, destStat, src, dest, opts2) {
  if (!destStat)
    return copyFile(srcStat, src, dest, opts2);
  return mayCopyFile(srcStat, src, dest, opts2);
}
function mayCopyFile(srcStat, src, dest, opts2) {
  if (opts2.overwrite) {
    fs$d.unlinkSync(dest);
    return copyFile(srcStat, src, dest, opts2);
  } else if (opts2.errorOnExist) {
    throw new Error(`'${dest}' already exists`);
  }
}
function copyFile(srcStat, src, dest, opts2) {
  fs$d.copyFileSync(src, dest);
  if (opts2.preserveTimestamps)
    handleTimestamps(srcStat.mode, src, dest);
  return setDestMode(dest, srcStat.mode);
}
function handleTimestamps(srcMode, src, dest) {
  if (fileIsNotWritable(srcMode))
    makeFileWritable(dest, srcMode);
  return setDestTimestamps(src, dest);
}
function fileIsNotWritable(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable(dest, srcMode) {
  return setDestMode(dest, srcMode | 128);
}
function setDestMode(dest, srcMode) {
  return fs$d.chmodSync(dest, srcMode);
}
function setDestTimestamps(src, dest) {
  const updatedSrcStat = fs$d.statSync(src);
  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
}
function onDir(srcStat, destStat, src, dest, opts2) {
  if (!destStat)
    return mkDirAndCopy(srcStat.mode, src, dest, opts2);
  return copyDir(src, dest, opts2);
}
function mkDirAndCopy(srcMode, src, dest, opts2) {
  fs$d.mkdirSync(dest);
  copyDir(src, dest, opts2);
  return setDestMode(dest, srcMode);
}
function copyDir(src, dest, opts2) {
  fs$d.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts2));
}
function copyDirItem(item, src, dest, opts2) {
  const srcItem = path$e.join(src, item);
  const destItem = path$e.join(dest, item);
  if (opts2.filter && !opts2.filter(srcItem, destItem))
    return;
  const { destStat } = stat$2.checkPathsSync(srcItem, destItem, "copy", opts2);
  return getStats(destStat, srcItem, destItem, opts2);
}
function onLink(destStat, src, dest, opts2) {
  let resolvedSrc = fs$d.readlinkSync(src);
  if (opts2.dereference) {
    resolvedSrc = path$e.resolve(process.cwd(), resolvedSrc);
  }
  if (!destStat) {
    return fs$d.symlinkSync(resolvedSrc, dest);
  } else {
    let resolvedDest;
    try {
      resolvedDest = fs$d.readlinkSync(dest);
    } catch (err) {
      if (err.code === "EINVAL" || err.code === "UNKNOWN")
        return fs$d.symlinkSync(resolvedSrc, dest);
      throw err;
    }
    if (opts2.dereference) {
      resolvedDest = path$e.resolve(process.cwd(), resolvedDest);
    }
    if (stat$2.isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
    }
    if (stat$2.isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
    }
    return copyLink(resolvedSrc, dest);
  }
}
function copyLink(resolvedSrc, dest) {
  fs$d.unlinkSync(dest);
  return fs$d.symlinkSync(resolvedSrc, dest);
}
var copySync_1 = copySync$1;
const u$a = universalify$1.fromPromise;
var copy$1 = {
  copy: u$a(copy_1),
  copySync: copySync_1
};
const fs$c = gracefulFs;
const u$9 = universalify$1.fromCallback;
function remove$2(path2, callback) {
  fs$c.rm(path2, { recursive: true, force: true }, callback);
}
function removeSync$1(path2) {
  fs$c.rmSync(path2, { recursive: true, force: true });
}
var remove_1 = {
  remove: u$9(remove$2),
  removeSync: removeSync$1
};
const u$8 = universalify$1.fromPromise;
const fs$b = fs$k;
const path$d = require$$1;
const mkdir$3 = mkdirs$2;
const remove$1 = remove_1;
const emptyDir = u$8(async function emptyDir2(dir) {
  let items2;
  try {
    items2 = await fs$b.readdir(dir);
  } catch {
    return mkdir$3.mkdirs(dir);
  }
  return Promise.all(items2.map((item) => remove$1.remove(path$d.join(dir, item))));
});
function emptyDirSync(dir) {
  let items2;
  try {
    items2 = fs$b.readdirSync(dir);
  } catch {
    return mkdir$3.mkdirsSync(dir);
  }
  items2.forEach((item) => {
    item = path$d.join(dir, item);
    remove$1.removeSync(item);
  });
}
var empty = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
};
const u$7 = universalify$1.fromPromise;
const path$c = require$$1;
const fs$a = fs$k;
const mkdir$2 = mkdirs$2;
async function createFile$1(file2) {
  let stats;
  try {
    stats = await fs$a.stat(file2);
  } catch {
  }
  if (stats && stats.isFile())
    return;
  const dir = path$c.dirname(file2);
  let dirStats = null;
  try {
    dirStats = await fs$a.stat(dir);
  } catch (err) {
    if (err.code === "ENOENT") {
      await mkdir$2.mkdirs(dir);
      await fs$a.writeFile(file2, "");
      return;
    } else {
      throw err;
    }
  }
  if (dirStats.isDirectory()) {
    await fs$a.writeFile(file2, "");
  } else {
    await fs$a.readdir(dir);
  }
}
function createFileSync$1(file2) {
  let stats;
  try {
    stats = fs$a.statSync(file2);
  } catch {
  }
  if (stats && stats.isFile())
    return;
  const dir = path$c.dirname(file2);
  try {
    if (!fs$a.statSync(dir).isDirectory()) {
      fs$a.readdirSync(dir);
    }
  } catch (err) {
    if (err && err.code === "ENOENT")
      mkdir$2.mkdirsSync(dir);
    else
      throw err;
  }
  fs$a.writeFileSync(file2, "");
}
var file = {
  createFile: u$7(createFile$1),
  createFileSync: createFileSync$1
};
const u$6 = universalify$1.fromPromise;
const path$b = require$$1;
const fs$9 = fs$k;
const mkdir$1 = mkdirs$2;
const { pathExists: pathExists$6 } = pathExists_1;
const { areIdentical: areIdentical$1 } = stat$4;
async function createLink$1(srcpath, dstpath) {
  let dstStat;
  try {
    dstStat = await fs$9.lstat(dstpath);
  } catch {
  }
  let srcStat;
  try {
    srcStat = await fs$9.lstat(srcpath);
  } catch (err) {
    err.message = err.message.replace("lstat", "ensureLink");
    throw err;
  }
  if (dstStat && areIdentical$1(srcStat, dstStat))
    return;
  const dir = path$b.dirname(dstpath);
  const dirExists = await pathExists$6(dir);
  if (!dirExists) {
    await mkdir$1.mkdirs(dir);
  }
  await fs$9.link(srcpath, dstpath);
}
function createLinkSync$1(srcpath, dstpath) {
  let dstStat;
  try {
    dstStat = fs$9.lstatSync(dstpath);
  } catch {
  }
  try {
    const srcStat = fs$9.lstatSync(srcpath);
    if (dstStat && areIdentical$1(srcStat, dstStat))
      return;
  } catch (err) {
    err.message = err.message.replace("lstat", "ensureLink");
    throw err;
  }
  const dir = path$b.dirname(dstpath);
  const dirExists = fs$9.existsSync(dir);
  if (dirExists)
    return fs$9.linkSync(srcpath, dstpath);
  mkdir$1.mkdirsSync(dir);
  return fs$9.linkSync(srcpath, dstpath);
}
var link = {
  createLink: u$6(createLink$1),
  createLinkSync: createLinkSync$1
};
const path$a = require$$1;
const fs$8 = fs$k;
const { pathExists: pathExists$5 } = pathExists_1;
const u$5 = universalify$1.fromPromise;
async function symlinkPaths$1(srcpath, dstpath) {
  if (path$a.isAbsolute(srcpath)) {
    try {
      await fs$8.lstat(srcpath);
    } catch (err) {
      err.message = err.message.replace("lstat", "ensureSymlink");
      throw err;
    }
    return {
      toCwd: srcpath,
      toDst: srcpath
    };
  }
  const dstdir = path$a.dirname(dstpath);
  const relativeToDst = path$a.join(dstdir, srcpath);
  const exists = await pathExists$5(relativeToDst);
  if (exists) {
    return {
      toCwd: relativeToDst,
      toDst: srcpath
    };
  }
  try {
    await fs$8.lstat(srcpath);
  } catch (err) {
    err.message = err.message.replace("lstat", "ensureSymlink");
    throw err;
  }
  return {
    toCwd: srcpath,
    toDst: path$a.relative(dstdir, srcpath)
  };
}
function symlinkPathsSync$1(srcpath, dstpath) {
  if (path$a.isAbsolute(srcpath)) {
    const exists2 = fs$8.existsSync(srcpath);
    if (!exists2)
      throw new Error("absolute srcpath does not exist");
    return {
      toCwd: srcpath,
      toDst: srcpath
    };
  }
  const dstdir = path$a.dirname(dstpath);
  const relativeToDst = path$a.join(dstdir, srcpath);
  const exists = fs$8.existsSync(relativeToDst);
  if (exists) {
    return {
      toCwd: relativeToDst,
      toDst: srcpath
    };
  }
  const srcExists = fs$8.existsSync(srcpath);
  if (!srcExists)
    throw new Error("relative srcpath does not exist");
  return {
    toCwd: srcpath,
    toDst: path$a.relative(dstdir, srcpath)
  };
}
var symlinkPaths_1 = {
  symlinkPaths: u$5(symlinkPaths$1),
  symlinkPathsSync: symlinkPathsSync$1
};
const fs$7 = fs$k;
const u$4 = universalify$1.fromPromise;
async function symlinkType$1(srcpath, type2) {
  if (type2)
    return type2;
  let stats;
  try {
    stats = await fs$7.lstat(srcpath);
  } catch {
    return "file";
  }
  return stats && stats.isDirectory() ? "dir" : "file";
}
function symlinkTypeSync$1(srcpath, type2) {
  if (type2)
    return type2;
  let stats;
  try {
    stats = fs$7.lstatSync(srcpath);
  } catch {
    return "file";
  }
  return stats && stats.isDirectory() ? "dir" : "file";
}
var symlinkType_1 = {
  symlinkType: u$4(symlinkType$1),
  symlinkTypeSync: symlinkTypeSync$1
};
const u$3 = universalify$1.fromPromise;
const path$9 = require$$1;
const fs$6 = fs$k;
const { mkdirs, mkdirsSync } = mkdirs$2;
const { symlinkPaths, symlinkPathsSync } = symlinkPaths_1;
const { symlinkType, symlinkTypeSync } = symlinkType_1;
const { pathExists: pathExists$4 } = pathExists_1;
const { areIdentical } = stat$4;
async function createSymlink$1(srcpath, dstpath, type2) {
  let stats;
  try {
    stats = await fs$6.lstat(dstpath);
  } catch {
  }
  if (stats && stats.isSymbolicLink()) {
    const [srcStat, dstStat] = await Promise.all([
      fs$6.stat(srcpath),
      fs$6.stat(dstpath)
    ]);
    if (areIdentical(srcStat, dstStat))
      return;
  }
  const relative = await symlinkPaths(srcpath, dstpath);
  srcpath = relative.toDst;
  const toType = await symlinkType(relative.toCwd, type2);
  const dir = path$9.dirname(dstpath);
  if (!await pathExists$4(dir)) {
    await mkdirs(dir);
  }
  return fs$6.symlink(srcpath, dstpath, toType);
}
function createSymlinkSync$1(srcpath, dstpath, type2) {
  let stats;
  try {
    stats = fs$6.lstatSync(dstpath);
  } catch {
  }
  if (stats && stats.isSymbolicLink()) {
    const srcStat = fs$6.statSync(srcpath);
    const dstStat = fs$6.statSync(dstpath);
    if (areIdentical(srcStat, dstStat))
      return;
  }
  const relative = symlinkPathsSync(srcpath, dstpath);
  srcpath = relative.toDst;
  type2 = symlinkTypeSync(relative.toCwd, type2);
  const dir = path$9.dirname(dstpath);
  const exists = fs$6.existsSync(dir);
  if (exists)
    return fs$6.symlinkSync(srcpath, dstpath, type2);
  mkdirsSync(dir);
  return fs$6.symlinkSync(srcpath, dstpath, type2);
}
var symlink = {
  createSymlink: u$3(createSymlink$1),
  createSymlinkSync: createSymlinkSync$1
};
const { createFile, createFileSync } = file;
const { createLink, createLinkSync } = link;
const { createSymlink, createSymlinkSync } = symlink;
var ensure = {
  // file
  createFile,
  createFileSync,
  ensureFile: createFile,
  ensureFileSync: createFileSync,
  // link
  createLink,
  createLinkSync,
  ensureLink: createLink,
  ensureLinkSync: createLinkSync,
  // symlink
  createSymlink,
  createSymlinkSync,
  ensureSymlink: createSymlink,
  ensureSymlinkSync: createSymlinkSync
};
function stringify$3(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
  const EOF = finalEOL ? EOL : "";
  const str = JSON.stringify(obj, replacer, spaces);
  return str.replace(/\n/g, EOL) + EOF;
}
function stripBom$1(content) {
  if (Buffer.isBuffer(content))
    content = content.toString("utf8");
  return content.replace(/^\uFEFF/, "");
}
var utils = { stringify: stringify$3, stripBom: stripBom$1 };
let _fs;
try {
  _fs = gracefulFs;
} catch (_) {
  _fs = require$$0$3;
}
const universalify = universalify$1;
const { stringify: stringify$2, stripBom } = utils;
async function _readFile(file2, options = {}) {
  if (typeof options === "string") {
    options = { encoding: options };
  }
  const fs2 = options.fs || _fs;
  const shouldThrow = "throws" in options ? options.throws : true;
  let data = await universalify.fromCallback(fs2.readFile)(file2, options);
  data = stripBom(data);
  let obj;
  try {
    obj = JSON.parse(data, options ? options.reviver : null);
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file2}: ${err.message}`;
      throw err;
    } else {
      return null;
    }
  }
  return obj;
}
const readFile$1 = universalify.fromPromise(_readFile);
function readFileSync$1(file2, options = {}) {
  if (typeof options === "string") {
    options = { encoding: options };
  }
  const fs2 = options.fs || _fs;
  const shouldThrow = "throws" in options ? options.throws : true;
  try {
    let content = fs2.readFileSync(file2, options);
    content = stripBom(content);
    return JSON.parse(content, options.reviver);
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file2}: ${err.message}`;
      throw err;
    } else {
      return null;
    }
  }
}
async function _writeFile(file2, obj, options = {}) {
  const fs2 = options.fs || _fs;
  const str = stringify$2(obj, options);
  await universalify.fromCallback(fs2.writeFile)(file2, str, options);
}
const writeFile$1 = universalify.fromPromise(_writeFile);
function writeFileSync$1(file2, obj, options = {}) {
  const fs2 = options.fs || _fs;
  const str = stringify$2(obj, options);
  return fs2.writeFileSync(file2, str, options);
}
const jsonfile$1 = {
  readFile: readFile$1,
  readFileSync: readFileSync$1,
  writeFile: writeFile$1,
  writeFileSync: writeFileSync$1
};
var jsonfile_1 = jsonfile$1;
const jsonFile$1 = jsonfile_1;
var jsonfile = {
  // jsonfile exports
  readJson: jsonFile$1.readFile,
  readJsonSync: jsonFile$1.readFileSync,
  writeJson: jsonFile$1.writeFile,
  writeJsonSync: jsonFile$1.writeFileSync
};
const u$2 = universalify$1.fromPromise;
const fs$5 = fs$k;
const path$8 = require$$1;
const mkdir = mkdirs$2;
const pathExists$3 = pathExists_1.pathExists;
async function outputFile$1(file2, data, encoding = "utf-8") {
  const dir = path$8.dirname(file2);
  if (!await pathExists$3(dir)) {
    await mkdir.mkdirs(dir);
  }
  return fs$5.writeFile(file2, data, encoding);
}
function outputFileSync$1(file2, ...args) {
  const dir = path$8.dirname(file2);
  if (!fs$5.existsSync(dir)) {
    mkdir.mkdirsSync(dir);
  }
  fs$5.writeFileSync(file2, ...args);
}
var outputFile_1 = {
  outputFile: u$2(outputFile$1),
  outputFileSync: outputFileSync$1
};
const { stringify: stringify$1 } = utils;
const { outputFile } = outputFile_1;
async function outputJson(file2, data, options = {}) {
  const str = stringify$1(data, options);
  await outputFile(file2, str, options);
}
var outputJson_1 = outputJson;
const { stringify } = utils;
const { outputFileSync } = outputFile_1;
function outputJsonSync(file2, data, options) {
  const str = stringify(data, options);
  outputFileSync(file2, str, options);
}
var outputJsonSync_1 = outputJsonSync;
const u$1 = universalify$1.fromPromise;
const jsonFile = jsonfile;
jsonFile.outputJson = u$1(outputJson_1);
jsonFile.outputJsonSync = outputJsonSync_1;
jsonFile.outputJSON = jsonFile.outputJson;
jsonFile.outputJSONSync = jsonFile.outputJsonSync;
jsonFile.writeJSON = jsonFile.writeJson;
jsonFile.writeJSONSync = jsonFile.writeJsonSync;
jsonFile.readJSON = jsonFile.readJson;
jsonFile.readJSONSync = jsonFile.readJsonSync;
var json = jsonFile;
const fs$4 = fs$k;
const path$7 = require$$1;
const { copy } = copy$1;
const { remove } = remove_1;
const { mkdirp } = mkdirs$2;
const { pathExists: pathExists$2 } = pathExists_1;
const stat$1 = stat$4;
async function move$1(src, dest, opts2 = {}) {
  const overwrite = opts2.overwrite || opts2.clobber || false;
  const { srcStat, isChangingCase = false } = await stat$1.checkPaths(src, dest, "move", opts2);
  await stat$1.checkParentPaths(src, srcStat, dest, "move");
  const destParent = path$7.dirname(dest);
  const parsedParentPath = path$7.parse(destParent);
  if (parsedParentPath.root !== destParent) {
    await mkdirp(destParent);
  }
  return doRename$1(src, dest, overwrite, isChangingCase);
}
async function doRename$1(src, dest, overwrite, isChangingCase) {
  if (!isChangingCase) {
    if (overwrite) {
      await remove(dest);
    } else if (await pathExists$2(dest)) {
      throw new Error("dest already exists.");
    }
  }
  try {
    await fs$4.rename(src, dest);
  } catch (err) {
    if (err.code !== "EXDEV") {
      throw err;
    }
    await moveAcrossDevice$1(src, dest, overwrite);
  }
}
async function moveAcrossDevice$1(src, dest, overwrite) {
  const opts2 = {
    overwrite,
    errorOnExist: true,
    preserveTimestamps: true
  };
  await copy(src, dest, opts2);
  return remove(src);
}
var move_1 = move$1;
const fs$3 = gracefulFs;
const path$6 = require$$1;
const copySync = copy$1.copySync;
const removeSync = remove_1.removeSync;
const mkdirpSync = mkdirs$2.mkdirpSync;
const stat = stat$4;
function moveSync(src, dest, opts2) {
  opts2 = opts2 || {};
  const overwrite = opts2.overwrite || opts2.clobber || false;
  const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, "move", opts2);
  stat.checkParentPathsSync(src, srcStat, dest, "move");
  if (!isParentRoot(dest))
    mkdirpSync(path$6.dirname(dest));
  return doRename(src, dest, overwrite, isChangingCase);
}
function isParentRoot(dest) {
  const parent = path$6.dirname(dest);
  const parsedPath = path$6.parse(parent);
  return parsedPath.root === parent;
}
function doRename(src, dest, overwrite, isChangingCase) {
  if (isChangingCase)
    return rename(src, dest, overwrite);
  if (overwrite) {
    removeSync(dest);
    return rename(src, dest, overwrite);
  }
  if (fs$3.existsSync(dest))
    throw new Error("dest already exists.");
  return rename(src, dest, overwrite);
}
function rename(src, dest, overwrite) {
  try {
    fs$3.renameSync(src, dest);
  } catch (err) {
    if (err.code !== "EXDEV")
      throw err;
    return moveAcrossDevice(src, dest, overwrite);
  }
}
function moveAcrossDevice(src, dest, overwrite) {
  const opts2 = {
    overwrite,
    errorOnExist: true,
    preserveTimestamps: true
  };
  copySync(src, dest, opts2);
  return removeSync(src);
}
var moveSync_1 = moveSync;
const u = universalify$1.fromPromise;
var move = {
  move: u(move_1),
  moveSync: moveSync_1
};
var lib = {
  // Export promiseified graceful-fs:
  ...fs$k,
  // Export extra methods:
  ...copy$1,
  ...empty,
  ...ensure,
  ...json,
  ...mkdirs$2,
  ...move,
  ...outputFile_1,
  ...pathExists_1,
  ...remove_1
};
var source = { exports: {} };
var isObj$1 = (value) => {
  const type2 = typeof value;
  return value !== null && (type2 === "object" || type2 === "function");
};
const isObj = isObj$1;
const disallowedKeys = /* @__PURE__ */ new Set([
  "__proto__",
  "prototype",
  "constructor"
]);
const isValidPath = (pathSegments) => !pathSegments.some((segment) => disallowedKeys.has(segment));
function getPathSegments(path2) {
  const pathArray = path2.split(".");
  const parts = [];
  for (let i = 0; i < pathArray.length; i++) {
    let p = pathArray[i];
    while (p[p.length - 1] === "\\" && pathArray[i + 1] !== void 0) {
      p = p.slice(0, -1) + ".";
      p += pathArray[++i];
    }
    parts.push(p);
  }
  if (!isValidPath(parts)) {
    return [];
  }
  return parts;
}
var dotProp = {
  get(object, path2, value) {
    if (!isObj(object) || typeof path2 !== "string") {
      return value === void 0 ? object : value;
    }
    const pathArray = getPathSegments(path2);
    if (pathArray.length === 0) {
      return;
    }
    for (let i = 0; i < pathArray.length; i++) {
      object = object[pathArray[i]];
      if (object === void 0 || object === null) {
        if (i !== pathArray.length - 1) {
          return value;
        }
        break;
      }
    }
    return object === void 0 ? value : object;
  },
  set(object, path2, value) {
    if (!isObj(object) || typeof path2 !== "string") {
      return object;
    }
    const root = object;
    const pathArray = getPathSegments(path2);
    for (let i = 0; i < pathArray.length; i++) {
      const p = pathArray[i];
      if (!isObj(object[p])) {
        object[p] = {};
      }
      if (i === pathArray.length - 1) {
        object[p] = value;
      }
      object = object[p];
    }
    return root;
  },
  delete(object, path2) {
    if (!isObj(object) || typeof path2 !== "string") {
      return false;
    }
    const pathArray = getPathSegments(path2);
    for (let i = 0; i < pathArray.length; i++) {
      const p = pathArray[i];
      if (i === pathArray.length - 1) {
        delete object[p];
        return true;
      }
      object = object[p];
      if (!isObj(object)) {
        return false;
      }
    }
  },
  has(object, path2) {
    if (!isObj(object) || typeof path2 !== "string") {
      return false;
    }
    const pathArray = getPathSegments(path2);
    if (pathArray.length === 0) {
      return false;
    }
    for (let i = 0; i < pathArray.length; i++) {
      if (isObj(object)) {
        if (!(pathArray[i] in object)) {
          return false;
        }
        object = object[pathArray[i]];
      } else {
        return false;
      }
    }
    return true;
  }
};
var pkgUp = { exports: {} };
var findUp$1 = { exports: {} };
var locatePath$1 = { exports: {} };
var pathExists$1 = { exports: {} };
const fs$2 = require$$0$3;
pathExists$1.exports = (fp) => new Promise((resolve2) => {
  fs$2.access(fp, (err) => {
    resolve2(!err);
  });
});
pathExists$1.exports.sync = (fp) => {
  try {
    fs$2.accessSync(fp);
    return true;
  } catch (err) {
    return false;
  }
};
var pathExistsExports = pathExists$1.exports;
var pLimit$2 = { exports: {} };
var pTry$2 = { exports: {} };
const pTry$1 = (fn, ...arguments_) => new Promise((resolve2) => {
  resolve2(fn(...arguments_));
});
pTry$2.exports = pTry$1;
pTry$2.exports.default = pTry$1;
var pTryExports = pTry$2.exports;
const pTry = pTryExports;
const pLimit$1 = (concurrency) => {
  if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
    return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
  }
  const queue = [];
  let activeCount = 0;
  const next = () => {
    activeCount--;
    if (queue.length > 0) {
      queue.shift()();
    }
  };
  const run = (fn, resolve2, ...args) => {
    activeCount++;
    const result = pTry(fn, ...args);
    resolve2(result);
    result.then(next, next);
  };
  const enqueue2 = (fn, resolve2, ...args) => {
    if (activeCount < concurrency) {
      run(fn, resolve2, ...args);
    } else {
      queue.push(run.bind(null, fn, resolve2, ...args));
    }
  };
  const generator = (fn, ...args) => new Promise((resolve2) => enqueue2(fn, resolve2, ...args));
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue.length
    },
    clearQueue: {
      value: () => {
        queue.length = 0;
      }
    }
  });
  return generator;
};
pLimit$2.exports = pLimit$1;
pLimit$2.exports.default = pLimit$1;
var pLimitExports = pLimit$2.exports;
const pLimit = pLimitExports;
class EndError extends Error {
  constructor(value) {
    super();
    this.value = value;
  }
}
const testElement = (el, tester) => Promise.resolve(el).then(tester);
const finder = (el) => Promise.all(el).then((val) => val[1] === true && Promise.reject(new EndError(val[0])));
var pLocate$1 = (iterable, tester, opts2) => {
  opts2 = Object.assign({
    concurrency: Infinity,
    preserveOrder: true
  }, opts2);
  const limit2 = pLimit(opts2.concurrency);
  const items2 = [...iterable].map((el) => [el, limit2(testElement, el, tester)]);
  const checkLimit = pLimit(opts2.preserveOrder ? 1 : Infinity);
  return Promise.all(items2.map((el) => checkLimit(finder, el))).then(() => {
  }).catch((err) => err instanceof EndError ? err.value : Promise.reject(err));
};
const path$5 = require$$1;
const pathExists = pathExistsExports;
const pLocate = pLocate$1;
locatePath$1.exports = (iterable, options) => {
  options = Object.assign({
    cwd: process.cwd()
  }, options);
  return pLocate(iterable, (el) => pathExists(path$5.resolve(options.cwd, el)), options);
};
locatePath$1.exports.sync = (iterable, options) => {
  options = Object.assign({
    cwd: process.cwd()
  }, options);
  for (const el of iterable) {
    if (pathExists.sync(path$5.resolve(options.cwd, el))) {
      return el;
    }
  }
};
var locatePathExports = locatePath$1.exports;
const path$4 = require$$1;
const locatePath = locatePathExports;
findUp$1.exports = (filename, opts2 = {}) => {
  const startDir = path$4.resolve(opts2.cwd || "");
  const { root } = path$4.parse(startDir);
  const filenames = [].concat(filename);
  return new Promise((resolve2) => {
    (function find(dir) {
      locatePath(filenames, { cwd: dir }).then((file2) => {
        if (file2) {
          resolve2(path$4.join(dir, file2));
        } else if (dir === root) {
          resolve2(null);
        } else {
          find(path$4.dirname(dir));
        }
      });
    })(startDir);
  });
};
findUp$1.exports.sync = (filename, opts2 = {}) => {
  let dir = path$4.resolve(opts2.cwd || "");
  const { root } = path$4.parse(dir);
  const filenames = [].concat(filename);
  while (true) {
    const file2 = locatePath.sync(filenames, { cwd: dir });
    if (file2) {
      return path$4.join(dir, file2);
    }
    if (dir === root) {
      return null;
    }
    dir = path$4.dirname(dir);
  }
};
var findUpExports = findUp$1.exports;
const findUp = findUpExports;
pkgUp.exports = async ({ cwd: cwd2 } = {}) => findUp("package.json", { cwd: cwd2 });
pkgUp.exports.sync = ({ cwd: cwd2 } = {}) => findUp.sync("package.json", { cwd: cwd2 });
var pkgUpExports = pkgUp.exports;
var envPaths$1 = { exports: {} };
const path$3 = require$$1;
const os = require$$1$1;
const homedir = os.homedir();
const tmpdir = os.tmpdir();
const { env: env$1 } = process;
const macos = (name) => {
  const library = path$3.join(homedir, "Library");
  return {
    data: path$3.join(library, "Application Support", name),
    config: path$3.join(library, "Preferences", name),
    cache: path$3.join(library, "Caches", name),
    log: path$3.join(library, "Logs", name),
    temp: path$3.join(tmpdir, name)
  };
};
const windows = (name) => {
  const appData = env$1.APPDATA || path$3.join(homedir, "AppData", "Roaming");
  const localAppData = env$1.LOCALAPPDATA || path$3.join(homedir, "AppData", "Local");
  return {
    // Data/config/cache/log are invented by me as Windows isn't opinionated about this
    data: path$3.join(localAppData, name, "Data"),
    config: path$3.join(appData, name, "Config"),
    cache: path$3.join(localAppData, name, "Cache"),
    log: path$3.join(localAppData, name, "Log"),
    temp: path$3.join(tmpdir, name)
  };
};
const linux = (name) => {
  const username = path$3.basename(homedir);
  return {
    data: path$3.join(env$1.XDG_DATA_HOME || path$3.join(homedir, ".local", "share"), name),
    config: path$3.join(env$1.XDG_CONFIG_HOME || path$3.join(homedir, ".config"), name),
    cache: path$3.join(env$1.XDG_CACHE_HOME || path$3.join(homedir, ".cache"), name),
    // https://wiki.debian.org/XDGBaseDirectorySpecification#state
    log: path$3.join(env$1.XDG_STATE_HOME || path$3.join(homedir, ".local", "state"), name),
    temp: path$3.join(tmpdir, username, name)
  };
};
const envPaths = (name, options) => {
  if (typeof name !== "string") {
    throw new TypeError(`Expected string, got ${typeof name}`);
  }
  options = Object.assign({ suffix: "nodejs" }, options);
  if (options.suffix) {
    name += `-${options.suffix}`;
  }
  if (process.platform === "darwin") {
    return macos(name);
  }
  if (process.platform === "win32") {
    return windows(name);
  }
  return linux(name);
};
envPaths$1.exports = envPaths;
envPaths$1.exports.default = envPaths;
var envPathsExports = envPaths$1.exports;
var dist$1 = {};
var consts = {};
Object.defineProperty(consts, "__esModule", { value: true });
consts.NOOP = consts.LIMIT_FILES_DESCRIPTORS = consts.LIMIT_BASENAME_LENGTH = consts.IS_USER_ROOT = consts.IS_POSIX = consts.DEFAULT_TIMEOUT_SYNC = consts.DEFAULT_TIMEOUT_ASYNC = consts.DEFAULT_WRITE_OPTIONS = consts.DEFAULT_READ_OPTIONS = consts.DEFAULT_FOLDER_MODE = consts.DEFAULT_FILE_MODE = consts.DEFAULT_ENCODING = void 0;
const DEFAULT_ENCODING = "utf8";
consts.DEFAULT_ENCODING = DEFAULT_ENCODING;
const DEFAULT_FILE_MODE = 438;
consts.DEFAULT_FILE_MODE = DEFAULT_FILE_MODE;
const DEFAULT_FOLDER_MODE = 511;
consts.DEFAULT_FOLDER_MODE = DEFAULT_FOLDER_MODE;
const DEFAULT_READ_OPTIONS = {};
consts.DEFAULT_READ_OPTIONS = DEFAULT_READ_OPTIONS;
const DEFAULT_WRITE_OPTIONS = {};
consts.DEFAULT_WRITE_OPTIONS = DEFAULT_WRITE_OPTIONS;
const DEFAULT_TIMEOUT_ASYNC = 5e3;
consts.DEFAULT_TIMEOUT_ASYNC = DEFAULT_TIMEOUT_ASYNC;
const DEFAULT_TIMEOUT_SYNC = 100;
consts.DEFAULT_TIMEOUT_SYNC = DEFAULT_TIMEOUT_SYNC;
const IS_POSIX = !!process.getuid;
consts.IS_POSIX = IS_POSIX;
const IS_USER_ROOT = process.getuid ? !process.getuid() : false;
consts.IS_USER_ROOT = IS_USER_ROOT;
const LIMIT_BASENAME_LENGTH = 128;
consts.LIMIT_BASENAME_LENGTH = LIMIT_BASENAME_LENGTH;
const LIMIT_FILES_DESCRIPTORS = 1e4;
consts.LIMIT_FILES_DESCRIPTORS = LIMIT_FILES_DESCRIPTORS;
const NOOP = () => {
};
consts.NOOP = NOOP;
var fs$1 = {};
var attemptify = {};
Object.defineProperty(attemptify, "__esModule", { value: true });
attemptify.attemptifySync = attemptify.attemptifyAsync = void 0;
const consts_1$4 = consts;
const attemptifyAsync = (fn, onError = consts_1$4.NOOP) => {
  return function() {
    return fn.apply(void 0, arguments).catch(onError);
  };
};
attemptify.attemptifyAsync = attemptifyAsync;
const attemptifySync = (fn, onError = consts_1$4.NOOP) => {
  return function() {
    try {
      return fn.apply(void 0, arguments);
    } catch (error2) {
      return onError(error2);
    }
  };
};
attemptify.attemptifySync = attemptifySync;
var fs_handlers = {};
Object.defineProperty(fs_handlers, "__esModule", { value: true });
const consts_1$3 = consts;
const Handlers = {
  isChangeErrorOk: (error2) => {
    const { code: code2 } = error2;
    if (code2 === "ENOSYS")
      return true;
    if (!consts_1$3.IS_USER_ROOT && (code2 === "EINVAL" || code2 === "EPERM"))
      return true;
    return false;
  },
  isRetriableError: (error2) => {
    const { code: code2 } = error2;
    if (code2 === "EMFILE" || code2 === "ENFILE" || code2 === "EAGAIN" || code2 === "EBUSY" || code2 === "EACCESS" || code2 === "EACCS" || code2 === "EPERM")
      return true;
    return false;
  },
  onChangeError: (error2) => {
    if (Handlers.isChangeErrorOk(error2))
      return;
    throw error2;
  }
};
fs_handlers.default = Handlers;
var retryify = {};
var retryify_queue = {};
Object.defineProperty(retryify_queue, "__esModule", { value: true });
const consts_1$2 = consts;
const RetryfyQueue = {
  interval: 25,
  intervalId: void 0,
  limit: consts_1$2.LIMIT_FILES_DESCRIPTORS,
  queueActive: /* @__PURE__ */ new Set(),
  queueWaiting: /* @__PURE__ */ new Set(),
  init: () => {
    if (RetryfyQueue.intervalId)
      return;
    RetryfyQueue.intervalId = setInterval(RetryfyQueue.tick, RetryfyQueue.interval);
  },
  reset: () => {
    if (!RetryfyQueue.intervalId)
      return;
    clearInterval(RetryfyQueue.intervalId);
    delete RetryfyQueue.intervalId;
  },
  add: (fn) => {
    RetryfyQueue.queueWaiting.add(fn);
    if (RetryfyQueue.queueActive.size < RetryfyQueue.limit / 2) {
      RetryfyQueue.tick();
    } else {
      RetryfyQueue.init();
    }
  },
  remove: (fn) => {
    RetryfyQueue.queueWaiting.delete(fn);
    RetryfyQueue.queueActive.delete(fn);
  },
  schedule: () => {
    return new Promise((resolve2) => {
      const cleanup = () => RetryfyQueue.remove(resolver);
      const resolver = () => resolve2(cleanup);
      RetryfyQueue.add(resolver);
    });
  },
  tick: () => {
    if (RetryfyQueue.queueActive.size >= RetryfyQueue.limit)
      return;
    if (!RetryfyQueue.queueWaiting.size)
      return RetryfyQueue.reset();
    for (const fn of RetryfyQueue.queueWaiting) {
      if (RetryfyQueue.queueActive.size >= RetryfyQueue.limit)
        break;
      RetryfyQueue.queueWaiting.delete(fn);
      RetryfyQueue.queueActive.add(fn);
      fn();
    }
  }
};
retryify_queue.default = RetryfyQueue;
Object.defineProperty(retryify, "__esModule", { value: true });
retryify.retryifySync = retryify.retryifyAsync = void 0;
const retryify_queue_1 = retryify_queue;
const retryifyAsync = (fn, isRetriableError) => {
  return function(timestamp) {
    return function attempt() {
      return retryify_queue_1.default.schedule().then((cleanup) => {
        return fn.apply(void 0, arguments).then((result) => {
          cleanup();
          return result;
        }, (error2) => {
          cleanup();
          if (Date.now() >= timestamp)
            throw error2;
          if (isRetriableError(error2)) {
            const delay = Math.round(100 + 400 * Math.random()), delayPromise = new Promise((resolve2) => setTimeout(resolve2, delay));
            return delayPromise.then(() => attempt.apply(void 0, arguments));
          }
          throw error2;
        });
      });
    };
  };
};
retryify.retryifyAsync = retryifyAsync;
const retryifySync = (fn, isRetriableError) => {
  return function(timestamp) {
    return function attempt() {
      try {
        return fn.apply(void 0, arguments);
      } catch (error2) {
        if (Date.now() > timestamp)
          throw error2;
        if (isRetriableError(error2))
          return attempt.apply(void 0, arguments);
        throw error2;
      }
    };
  };
};
retryify.retryifySync = retryifySync;
Object.defineProperty(fs$1, "__esModule", { value: true });
const fs = require$$0$3;
const util_1$p = require$$4;
const attemptify_1 = attemptify;
const fs_handlers_1 = fs_handlers;
const retryify_1 = retryify;
const FS = {
  chmodAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.chmod), fs_handlers_1.default.onChangeError),
  chownAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.chown), fs_handlers_1.default.onChangeError),
  closeAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.close)),
  fsyncAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.fsync)),
  mkdirAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.mkdir)),
  realpathAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.realpath)),
  statAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.stat)),
  unlinkAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.unlink)),
  closeRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.close), fs_handlers_1.default.isRetriableError),
  fsyncRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.fsync), fs_handlers_1.default.isRetriableError),
  openRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.open), fs_handlers_1.default.isRetriableError),
  readFileRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.readFile), fs_handlers_1.default.isRetriableError),
  renameRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.rename), fs_handlers_1.default.isRetriableError),
  statRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.stat), fs_handlers_1.default.isRetriableError),
  writeRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.write), fs_handlers_1.default.isRetriableError),
  chmodSyncAttempt: attemptify_1.attemptifySync(fs.chmodSync, fs_handlers_1.default.onChangeError),
  chownSyncAttempt: attemptify_1.attemptifySync(fs.chownSync, fs_handlers_1.default.onChangeError),
  closeSyncAttempt: attemptify_1.attemptifySync(fs.closeSync),
  mkdirSyncAttempt: attemptify_1.attemptifySync(fs.mkdirSync),
  realpathSyncAttempt: attemptify_1.attemptifySync(fs.realpathSync),
  statSyncAttempt: attemptify_1.attemptifySync(fs.statSync),
  unlinkSyncAttempt: attemptify_1.attemptifySync(fs.unlinkSync),
  closeSyncRetry: retryify_1.retryifySync(fs.closeSync, fs_handlers_1.default.isRetriableError),
  fsyncSyncRetry: retryify_1.retryifySync(fs.fsyncSync, fs_handlers_1.default.isRetriableError),
  openSyncRetry: retryify_1.retryifySync(fs.openSync, fs_handlers_1.default.isRetriableError),
  readFileSyncRetry: retryify_1.retryifySync(fs.readFileSync, fs_handlers_1.default.isRetriableError),
  renameSyncRetry: retryify_1.retryifySync(fs.renameSync, fs_handlers_1.default.isRetriableError),
  statSyncRetry: retryify_1.retryifySync(fs.statSync, fs_handlers_1.default.isRetriableError),
  writeSyncRetry: retryify_1.retryifySync(fs.writeSync, fs_handlers_1.default.isRetriableError)
};
fs$1.default = FS;
var lang = {};
Object.defineProperty(lang, "__esModule", { value: true });
const Lang = {
  isFunction: (x) => {
    return typeof x === "function";
  },
  isString: (x) => {
    return typeof x === "string";
  },
  isUndefined: (x) => {
    return typeof x === "undefined";
  }
};
lang.default = Lang;
var scheduler = {};
Object.defineProperty(scheduler, "__esModule", { value: true });
const Queues = {};
const Scheduler = {
  next: (id2) => {
    const queue = Queues[id2];
    if (!queue)
      return;
    queue.shift();
    const job = queue[0];
    if (job) {
      job(() => Scheduler.next(id2));
    } else {
      delete Queues[id2];
    }
  },
  schedule: (id2) => {
    return new Promise((resolve2) => {
      let queue = Queues[id2];
      if (!queue)
        queue = Queues[id2] = [];
      queue.push(resolve2);
      if (queue.length > 1)
        return;
      resolve2(() => Scheduler.next(id2));
    });
  }
};
scheduler.default = Scheduler;
var temp = {};
Object.defineProperty(temp, "__esModule", { value: true });
const path$2 = require$$1;
const consts_1$1 = consts;
const fs_1$1 = fs$1;
const Temp = {
  store: {},
  create: (filePath) => {
    const randomness = `000000${Math.floor(Math.random() * 16777215).toString(16)}`.slice(-6), timestamp = Date.now().toString().slice(-10), prefix = "tmp-", suffix = `.${prefix}${timestamp}${randomness}`, tempPath = `${filePath}${suffix}`;
    return tempPath;
  },
  get: (filePath, creator, purge = true) => {
    const tempPath = Temp.truncate(creator(filePath));
    if (tempPath in Temp.store)
      return Temp.get(filePath, creator, purge);
    Temp.store[tempPath] = purge;
    const disposer = () => delete Temp.store[tempPath];
    return [tempPath, disposer];
  },
  purge: (filePath) => {
    if (!Temp.store[filePath])
      return;
    delete Temp.store[filePath];
    fs_1$1.default.unlinkAttempt(filePath);
  },
  purgeSync: (filePath) => {
    if (!Temp.store[filePath])
      return;
    delete Temp.store[filePath];
    fs_1$1.default.unlinkSyncAttempt(filePath);
  },
  purgeSyncAll: () => {
    for (const filePath in Temp.store) {
      Temp.purgeSync(filePath);
    }
  },
  truncate: (filePath) => {
    const basename = path$2.basename(filePath);
    if (basename.length <= consts_1$1.LIMIT_BASENAME_LENGTH)
      return filePath;
    const truncable = /^(\.?)(.*?)((?:\.[^.]+)?(?:\.tmp-\d{10}[a-f0-9]{6})?)$/.exec(basename);
    if (!truncable)
      return filePath;
    const truncationLength = basename.length - consts_1$1.LIMIT_BASENAME_LENGTH;
    return `${filePath.slice(0, -basename.length)}${truncable[1]}${truncable[2].slice(0, -truncationLength)}${truncable[3]}`;
  }
};
process.on("exit", Temp.purgeSyncAll);
temp.default = Temp;
Object.defineProperty(dist$1, "__esModule", { value: true });
dist$1.writeFileSync = dist$1.writeFile = dist$1.readFileSync = dist$1.readFile = void 0;
const path$1 = require$$1;
const consts_1 = consts;
const fs_1 = fs$1;
const lang_1 = lang;
const scheduler_1 = scheduler;
const temp_1 = temp;
function readFile(filePath, options = consts_1.DEFAULT_READ_OPTIONS) {
  var _a;
  if (lang_1.default.isString(options))
    return readFile(filePath, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_ASYNC);
  return fs_1.default.readFileRetry(timeout)(filePath, options);
}
dist$1.readFile = readFile;
function readFileSync(filePath, options = consts_1.DEFAULT_READ_OPTIONS) {
  var _a;
  if (lang_1.default.isString(options))
    return readFileSync(filePath, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_SYNC);
  return fs_1.default.readFileSyncRetry(timeout)(filePath, options);
}
dist$1.readFileSync = readFileSync;
const writeFile = (filePath, data, options, callback) => {
  if (lang_1.default.isFunction(options))
    return writeFile(filePath, data, consts_1.DEFAULT_WRITE_OPTIONS, options);
  const promise = writeFileAsync(filePath, data, options);
  if (callback)
    promise.then(callback, callback);
  return promise;
};
dist$1.writeFile = writeFile;
const writeFileAsync = async (filePath, data, options = consts_1.DEFAULT_WRITE_OPTIONS) => {
  var _a;
  if (lang_1.default.isString(options))
    return writeFileAsync(filePath, data, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_ASYNC);
  let schedulerCustomDisposer = null, schedulerDisposer = null, tempDisposer = null, tempPath = null, fd = null;
  try {
    if (options.schedule)
      schedulerCustomDisposer = await options.schedule(filePath);
    schedulerDisposer = await scheduler_1.default.schedule(filePath);
    filePath = await fs_1.default.realpathAttempt(filePath) || filePath;
    [tempPath, tempDisposer] = temp_1.default.get(filePath, options.tmpCreate || temp_1.default.create, !(options.tmpPurge === false));
    const useStatChown = consts_1.IS_POSIX && lang_1.default.isUndefined(options.chown), useStatMode = lang_1.default.isUndefined(options.mode);
    if (useStatChown || useStatMode) {
      const stat2 = await fs_1.default.statAttempt(filePath);
      if (stat2) {
        options = { ...options };
        if (useStatChown)
          options.chown = { uid: stat2.uid, gid: stat2.gid };
        if (useStatMode)
          options.mode = stat2.mode;
      }
    }
    const parentPath = path$1.dirname(filePath);
    await fs_1.default.mkdirAttempt(parentPath, {
      mode: consts_1.DEFAULT_FOLDER_MODE,
      recursive: true
    });
    fd = await fs_1.default.openRetry(timeout)(tempPath, "w", options.mode || consts_1.DEFAULT_FILE_MODE);
    if (options.tmpCreated)
      options.tmpCreated(tempPath);
    if (lang_1.default.isString(data)) {
      await fs_1.default.writeRetry(timeout)(fd, data, 0, options.encoding || consts_1.DEFAULT_ENCODING);
    } else if (!lang_1.default.isUndefined(data)) {
      await fs_1.default.writeRetry(timeout)(fd, data, 0, data.length, 0);
    }
    if (options.fsync !== false) {
      if (options.fsyncWait !== false) {
        await fs_1.default.fsyncRetry(timeout)(fd);
      } else {
        fs_1.default.fsyncAttempt(fd);
      }
    }
    await fs_1.default.closeRetry(timeout)(fd);
    fd = null;
    if (options.chown)
      await fs_1.default.chownAttempt(tempPath, options.chown.uid, options.chown.gid);
    if (options.mode)
      await fs_1.default.chmodAttempt(tempPath, options.mode);
    try {
      await fs_1.default.renameRetry(timeout)(tempPath, filePath);
    } catch (error2) {
      if (error2.code !== "ENAMETOOLONG")
        throw error2;
      await fs_1.default.renameRetry(timeout)(tempPath, temp_1.default.truncate(filePath));
    }
    tempDisposer();
    tempPath = null;
  } finally {
    if (fd)
      await fs_1.default.closeAttempt(fd);
    if (tempPath)
      temp_1.default.purge(tempPath);
    if (schedulerCustomDisposer)
      schedulerCustomDisposer();
    if (schedulerDisposer)
      schedulerDisposer();
  }
};
const writeFileSync = (filePath, data, options = consts_1.DEFAULT_WRITE_OPTIONS) => {
  var _a;
  if (lang_1.default.isString(options))
    return writeFileSync(filePath, data, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_SYNC);
  let tempDisposer = null, tempPath = null, fd = null;
  try {
    filePath = fs_1.default.realpathSyncAttempt(filePath) || filePath;
    [tempPath, tempDisposer] = temp_1.default.get(filePath, options.tmpCreate || temp_1.default.create, !(options.tmpPurge === false));
    const useStatChown = consts_1.IS_POSIX && lang_1.default.isUndefined(options.chown), useStatMode = lang_1.default.isUndefined(options.mode);
    if (useStatChown || useStatMode) {
      const stat2 = fs_1.default.statSyncAttempt(filePath);
      if (stat2) {
        options = { ...options };
        if (useStatChown)
          options.chown = { uid: stat2.uid, gid: stat2.gid };
        if (useStatMode)
          options.mode = stat2.mode;
      }
    }
    const parentPath = path$1.dirname(filePath);
    fs_1.default.mkdirSyncAttempt(parentPath, {
      mode: consts_1.DEFAULT_FOLDER_MODE,
      recursive: true
    });
    fd = fs_1.default.openSyncRetry(timeout)(tempPath, "w", options.mode || consts_1.DEFAULT_FILE_MODE);
    if (options.tmpCreated)
      options.tmpCreated(tempPath);
    if (lang_1.default.isString(data)) {
      fs_1.default.writeSyncRetry(timeout)(fd, data, 0, options.encoding || consts_1.DEFAULT_ENCODING);
    } else if (!lang_1.default.isUndefined(data)) {
      fs_1.default.writeSyncRetry(timeout)(fd, data, 0, data.length, 0);
    }
    if (options.fsync !== false) {
      if (options.fsyncWait !== false) {
        fs_1.default.fsyncSyncRetry(timeout)(fd);
      } else {
        fs_1.default.fsyncAttempt(fd);
      }
    }
    fs_1.default.closeSyncRetry(timeout)(fd);
    fd = null;
    if (options.chown)
      fs_1.default.chownSyncAttempt(tempPath, options.chown.uid, options.chown.gid);
    if (options.mode)
      fs_1.default.chmodSyncAttempt(tempPath, options.mode);
    try {
      fs_1.default.renameSyncRetry(timeout)(tempPath, filePath);
    } catch (error2) {
      if (error2.code !== "ENAMETOOLONG")
        throw error2;
      fs_1.default.renameSyncRetry(timeout)(tempPath, temp_1.default.truncate(filePath));
    }
    tempDisposer();
    tempPath = null;
  } finally {
    if (fd)
      fs_1.default.closeSyncAttempt(fd);
    if (tempPath)
      temp_1.default.purge(tempPath);
  }
};
dist$1.writeFileSync = writeFileSync;
var ajv = { exports: {} };
var core$2 = {};
var validate = {};
var boolSchema = {};
var errors = {};
var codegen = {};
var code$1 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.regexpCode = exports2.getProperty = exports2.safeStringify = exports2.stringify = exports2.strConcat = exports2.addCodeArg = exports2.str = exports2._ = exports2.nil = exports2._Code = exports2.Name = exports2.IDENTIFIER = exports2._CodeOrName = void 0;
  class _CodeOrName {
  }
  exports2._CodeOrName = _CodeOrName;
  exports2.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class Name extends _CodeOrName {
    constructor(s) {
      super();
      if (!exports2.IDENTIFIER.test(s))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = s;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  exports2.Name = Name;
  class _Code extends _CodeOrName {
    constructor(code2) {
      super();
      this._items = typeof code2 === "string" ? [code2] : code2;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return false;
      const item = this._items[0];
      return item === "" || item === '""';
    }
    get str() {
      var _a;
      return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
    }
    get names() {
      var _a;
      return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names2, c) => {
        if (c instanceof Name)
          names2[c.str] = (names2[c.str] || 0) + 1;
        return names2;
      }, {});
    }
  }
  exports2._Code = _Code;
  exports2.nil = new _Code("");
  function _(strs, ...args) {
    const code2 = [strs[0]];
    let i = 0;
    while (i < args.length) {
      addCodeArg(code2, args[i]);
      code2.push(strs[++i]);
    }
    return new _Code(code2);
  }
  exports2._ = _;
  const plus = new _Code("+");
  function str(strs, ...args) {
    const expr = [safeStringify(strs[0])];
    let i = 0;
    while (i < args.length) {
      expr.push(plus);
      addCodeArg(expr, args[i]);
      expr.push(plus, safeStringify(strs[++i]));
    }
    optimize(expr);
    return new _Code(expr);
  }
  exports2.str = str;
  function addCodeArg(code2, arg) {
    if (arg instanceof _Code)
      code2.push(...arg._items);
    else if (arg instanceof Name)
      code2.push(arg);
    else
      code2.push(interpolate(arg));
  }
  exports2.addCodeArg = addCodeArg;
  function optimize(expr) {
    let i = 1;
    while (i < expr.length - 1) {
      if (expr[i] === plus) {
        const res = mergeExprItems(expr[i - 1], expr[i + 1]);
        if (res !== void 0) {
          expr.splice(i - 1, 3, res);
          continue;
        }
        expr[i++] = "+";
      }
      i++;
    }
  }
  function mergeExprItems(a, b) {
    if (b === '""')
      return a;
    if (a === '""')
      return b;
    if (typeof a == "string") {
      if (b instanceof Name || a[a.length - 1] !== '"')
        return;
      if (typeof b != "string")
        return `${a.slice(0, -1)}${b}"`;
      if (b[0] === '"')
        return a.slice(0, -1) + b.slice(1);
      return;
    }
    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
      return `"${a}${b.slice(1)}`;
    return;
  }
  function strConcat(c1, c2) {
    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
  }
  exports2.strConcat = strConcat;
  function interpolate(x) {
    return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
  }
  function stringify2(x) {
    return new _Code(safeStringify(x));
  }
  exports2.stringify = stringify2;
  function safeStringify(x) {
    return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  exports2.safeStringify = safeStringify;
  function getProperty(key) {
    return typeof key == "string" && exports2.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
  }
  exports2.getProperty = getProperty;
  function regexpCode(rx) {
    return new _Code(rx.toString());
  }
  exports2.regexpCode = regexpCode;
})(code$1);
var scope = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ValueScope = exports2.ValueScopeName = exports2.Scope = exports2.varKinds = exports2.UsedValueState = void 0;
  const code_12 = code$1;
  class ValueError extends Error {
    constructor(name) {
      super(`CodeGen: "code" for ${name} not defined`);
      this.value = name.value;
    }
  }
  var UsedValueState;
  (function(UsedValueState2) {
    UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
    UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
  })(UsedValueState = exports2.UsedValueState || (exports2.UsedValueState = {}));
  exports2.varKinds = {
    const: new code_12.Name("const"),
    let: new code_12.Name("let"),
    var: new code_12.Name("var")
  };
  class Scope {
    constructor({ prefixes, parent } = {}) {
      this._names = {};
      this._prefixes = prefixes;
      this._parent = parent;
    }
    toName(nameOrPrefix) {
      return nameOrPrefix instanceof code_12.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix) {
      return new code_12.Name(this._newName(prefix));
    }
    _newName(prefix) {
      const ng = this._names[prefix] || this._nameGroup(prefix);
      return `${prefix}${ng.index++}`;
    }
    _nameGroup(prefix) {
      var _a, _b;
      if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
        throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
      }
      return this._names[prefix] = { prefix, index: 0 };
    }
  }
  exports2.Scope = Scope;
  class ValueScopeName extends code_12.Name {
    constructor(prefix, nameStr) {
      super(nameStr);
      this.prefix = prefix;
    }
    setValue(value, { property, itemIndex }) {
      this.value = value;
      this.scopePath = code_12._`.${new code_12.Name(property)}[${itemIndex}]`;
    }
  }
  exports2.ValueScopeName = ValueScopeName;
  const line = code_12._`\n`;
  class ValueScope extends Scope {
    constructor(opts2) {
      super(opts2);
      this._values = {};
      this._scope = opts2.scope;
      this.opts = { ...opts2, _n: opts2.lines ? line : code_12.nil };
    }
    get() {
      return this._scope;
    }
    name(prefix) {
      return new ValueScopeName(prefix, this._newName(prefix));
    }
    value(nameOrPrefix, value) {
      var _a;
      if (value.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const name = this.toName(nameOrPrefix);
      const { prefix } = name;
      const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
      let vs = this._values[prefix];
      if (vs) {
        const _name = vs.get(valueKey);
        if (_name)
          return _name;
      } else {
        vs = this._values[prefix] = /* @__PURE__ */ new Map();
      }
      vs.set(valueKey, name);
      const s = this._scope[prefix] || (this._scope[prefix] = []);
      const itemIndex = s.length;
      s[itemIndex] = value.ref;
      name.setValue(value, { property: prefix, itemIndex });
      return name;
    }
    getValue(prefix, keyOrRef) {
      const vs = this._values[prefix];
      if (!vs)
        return;
      return vs.get(keyOrRef);
    }
    scopeRefs(scopeName, values = this._values) {
      return this._reduceValues(values, (name) => {
        if (name.scopePath === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return code_12._`${scopeName}${name.scopePath}`;
      });
    }
    scopeCode(values = this._values, usedValues, getCode) {
      return this._reduceValues(values, (name) => {
        if (name.value === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return name.value.code;
      }, usedValues, getCode);
    }
    _reduceValues(values, valueCode, usedValues = {}, getCode) {
      let code2 = code_12.nil;
      for (const prefix in values) {
        const vs = values[prefix];
        if (!vs)
          continue;
        const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
        vs.forEach((name) => {
          if (nameSet.has(name))
            return;
          nameSet.set(name, UsedValueState.Started);
          let c = valueCode(name);
          if (c) {
            const def2 = this.opts.es5 ? exports2.varKinds.var : exports2.varKinds.const;
            code2 = code_12._`${code2}${def2} ${name} = ${c};${this.opts._n}`;
          } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
            code2 = code_12._`${code2}${c}${this.opts._n}`;
          } else {
            throw new ValueError(name);
          }
          nameSet.set(name, UsedValueState.Completed);
        });
      }
      return code2;
    }
  }
  exports2.ValueScope = ValueScope;
})(scope);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.or = exports2.and = exports2.not = exports2.CodeGen = exports2.operators = exports2.varKinds = exports2.ValueScopeName = exports2.ValueScope = exports2.Scope = exports2.Name = exports2.regexpCode = exports2.stringify = exports2.getProperty = exports2.nil = exports2.strConcat = exports2.str = exports2._ = void 0;
  const code_12 = code$1;
  const scope_1 = scope;
  var code_2 = code$1;
  Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
    return code_2._;
  } });
  Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
    return code_2.str;
  } });
  Object.defineProperty(exports2, "strConcat", { enumerable: true, get: function() {
    return code_2.strConcat;
  } });
  Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
    return code_2.nil;
  } });
  Object.defineProperty(exports2, "getProperty", { enumerable: true, get: function() {
    return code_2.getProperty;
  } });
  Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
    return code_2.stringify;
  } });
  Object.defineProperty(exports2, "regexpCode", { enumerable: true, get: function() {
    return code_2.regexpCode;
  } });
  Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
    return code_2.Name;
  } });
  var scope_2 = scope;
  Object.defineProperty(exports2, "Scope", { enumerable: true, get: function() {
    return scope_2.Scope;
  } });
  Object.defineProperty(exports2, "ValueScope", { enumerable: true, get: function() {
    return scope_2.ValueScope;
  } });
  Object.defineProperty(exports2, "ValueScopeName", { enumerable: true, get: function() {
    return scope_2.ValueScopeName;
  } });
  Object.defineProperty(exports2, "varKinds", { enumerable: true, get: function() {
    return scope_2.varKinds;
  } });
  exports2.operators = {
    GT: new code_12._Code(">"),
    GTE: new code_12._Code(">="),
    LT: new code_12._Code("<"),
    LTE: new code_12._Code("<="),
    EQ: new code_12._Code("==="),
    NEQ: new code_12._Code("!=="),
    NOT: new code_12._Code("!"),
    OR: new code_12._Code("||"),
    AND: new code_12._Code("&&"),
    ADD: new code_12._Code("+")
  };
  class Node2 {
    optimizeNodes() {
      return this;
    }
    optimizeNames(_names, _constants) {
      return this;
    }
  }
  class Def extends Node2 {
    constructor(varKind, name, rhs) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.rhs = rhs;
    }
    render({ es5, _n }) {
      const varKind = es5 ? scope_1.varKinds.var : this.varKind;
      const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${varKind} ${this.name}${rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (!names2[this.name.str])
        return;
      if (this.rhs)
        this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      return this.rhs instanceof code_12._CodeOrName ? this.rhs.names : {};
    }
  }
  class Assign extends Node2 {
    constructor(lhs, rhs, sideEffects) {
      super();
      this.lhs = lhs;
      this.rhs = rhs;
      this.sideEffects = sideEffects;
    }
    render({ _n }) {
      return `${this.lhs} = ${this.rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (this.lhs instanceof code_12.Name && !names2[this.lhs.str] && !this.sideEffects)
        return;
      this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      const names2 = this.lhs instanceof code_12.Name ? {} : { ...this.lhs.names };
      return addExprNames(names2, this.rhs);
    }
  }
  class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
      super(lhs, rhs, sideEffects);
      this.op = op;
    }
    render({ _n }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
    }
  }
  class Label extends Node2 {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      return `${this.label}:` + _n;
    }
  }
  class Break extends Node2 {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      const label = this.label ? ` ${this.label}` : "";
      return `break${label};` + _n;
    }
  }
  class Throw extends Node2 {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render({ _n }) {
      return `throw ${this.error};` + _n;
    }
    get names() {
      return this.error.names;
    }
  }
  class AnyCode extends Node2 {
    constructor(code2) {
      super();
      this.code = code2;
    }
    render({ _n }) {
      return `${this.code};` + _n;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      this.code = optimizeExpr(this.code, names2, constants2);
      return this;
    }
    get names() {
      return this.code instanceof code_12._CodeOrName ? this.code.names : {};
    }
  }
  class ParentNode extends Node2 {
    constructor(nodes = []) {
      super();
      this.nodes = nodes;
    }
    render(opts2) {
      return this.nodes.reduce((code2, n) => code2 + n.render(opts2), "");
    }
    optimizeNodes() {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i].optimizeNodes();
        if (Array.isArray(n))
          nodes.splice(i, 1, ...n);
        else if (n)
          nodes[i] = n;
        else
          nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i];
        if (n.optimizeNames(names2, constants2))
          continue;
        subtractNames(names2, n.names);
        nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((names2, n) => addNames(names2, n.names), {});
    }
  }
  class BlockNode extends ParentNode {
    render(opts2) {
      return "{" + opts2._n + super.render(opts2) + "}" + opts2._n;
    }
  }
  class Root extends ParentNode {
  }
  class Else extends BlockNode {
  }
  Else.kind = "else";
  class If extends BlockNode {
    constructor(condition, nodes) {
      super(nodes);
      this.condition = condition;
    }
    render(opts2) {
      let code2 = `if(${this.condition})` + super.render(opts2);
      if (this.else)
        code2 += "else " + this.else.render(opts2);
      return code2;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const cond = this.condition;
      if (cond === true)
        return this.nodes;
      let e = this.else;
      if (e) {
        const ns = e.optimizeNodes();
        e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
      }
      if (e) {
        if (cond === false)
          return e instanceof If ? e : e.nodes;
        if (this.nodes.length)
          return this;
        return new If(not2(cond), e instanceof If ? [e] : e.nodes);
      }
      if (cond === false || !this.nodes.length)
        return void 0;
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a;
      this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants2);
      if (!(super.optimizeNames(names2, constants2) || this.else))
        return;
      this.condition = optimizeExpr(this.condition, names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      addExprNames(names2, this.condition);
      if (this.else)
        addNames(names2, this.else.names);
      return names2;
    }
  }
  If.kind = "if";
  class For extends BlockNode {
  }
  For.kind = "for";
  class ForLoop extends For {
    constructor(iteration) {
      super();
      this.iteration = iteration;
    }
    render(opts2) {
      return `for(${this.iteration})` + super.render(opts2);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iteration = optimizeExpr(this.iteration, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iteration.names);
    }
  }
  class ForRange extends For {
    constructor(varKind, name, from, to) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.from = from;
      this.to = to;
    }
    render(opts2) {
      const varKind = opts2.es5 ? scope_1.varKinds.var : this.varKind;
      const { name, from, to } = this;
      return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts2);
    }
    get names() {
      const names2 = addExprNames(super.names, this.from);
      return addExprNames(names2, this.to);
    }
  }
  class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
      super();
      this.loop = loop;
      this.varKind = varKind;
      this.name = name;
      this.iterable = iterable;
    }
    render(opts2) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts2);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iterable = optimizeExpr(this.iterable, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iterable.names);
    }
  }
  class Func extends BlockNode {
    constructor(name, args, async) {
      super();
      this.name = name;
      this.args = args;
      this.async = async;
    }
    render(opts2) {
      const _async = this.async ? "async " : "";
      return `${_async}function ${this.name}(${this.args})` + super.render(opts2);
    }
  }
  Func.kind = "func";
  class Return extends ParentNode {
    render(opts2) {
      return "return " + super.render(opts2);
    }
  }
  Return.kind = "return";
  class Try extends BlockNode {
    render(opts2) {
      let code2 = "try" + super.render(opts2);
      if (this.catch)
        code2 += this.catch.render(opts2);
      if (this.finally)
        code2 += this.finally.render(opts2);
      return code2;
    }
    optimizeNodes() {
      var _a, _b;
      super.optimizeNodes();
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a, _b;
      super.optimizeNames(names2, constants2);
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants2);
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      if (this.catch)
        addNames(names2, this.catch.names);
      if (this.finally)
        addNames(names2, this.finally.names);
      return names2;
    }
  }
  class Catch extends BlockNode {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render(opts2) {
      return `catch(${this.error})` + super.render(opts2);
    }
  }
  Catch.kind = "catch";
  class Finally extends BlockNode {
    render(opts2) {
      return "finally" + super.render(opts2);
    }
  }
  Finally.kind = "finally";
  class CodeGen {
    constructor(extScope, opts2 = {}) {
      this._values = {};
      this._blockStarts = [];
      this._constants = {};
      this.opts = { ...opts2, _n: opts2.lines ? "\n" : "" };
      this._extScope = extScope;
      this._scope = new scope_1.Scope({ parent: extScope });
      this._nodes = [new Root()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(prefix) {
      return this._scope.name(prefix);
    }
    // reserves unique name in the external scope
    scopeName(prefix) {
      return this._extScope.name(prefix);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(prefixOrName, value) {
      const name = this._extScope.value(prefixOrName, value);
      const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
      vs.add(name);
      return name;
    }
    getScopeValue(prefix, keyOrRef) {
      return this._extScope.getValue(prefix, keyOrRef);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(scopeName) {
      return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant) {
      const name = this._scope.toName(nameOrPrefix);
      if (rhs !== void 0 && constant)
        this._constants[name.str] = rhs;
      this._leafNode(new Def(varKind, name, rhs));
      return name;
    }
    // `const` declaration (`var` in es5 mode)
    const(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    // `var` declaration with optional assignment
    var(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    // assignment code
    assign(lhs, rhs, sideEffects) {
      return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    // `+=` code
    add(lhs, rhs) {
      return this._leafNode(new AssignOp(lhs, exports2.operators.ADD, rhs));
    }
    // appends passed SafeExpr to code or executes Block
    code(c) {
      if (typeof c == "function")
        c();
      else if (c !== code_12.nil)
        this._leafNode(new AnyCode(c));
      return this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...keyValues) {
      const code2 = ["{"];
      for (const [key, value] of keyValues) {
        if (code2.length > 1)
          code2.push(",");
        code2.push(key);
        if (key !== value || this.opts.es5) {
          code2.push(":");
          code_12.addCodeArg(code2, value);
        }
      }
      code2.push("}");
      return new code_12._Code(code2);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(condition, thenBody, elseBody) {
      this._blockNode(new If(condition));
      if (thenBody && elseBody) {
        this.code(thenBody).else().code(elseBody).endIf();
      } else if (thenBody) {
        this.code(thenBody).endIf();
      } else if (elseBody) {
        throw new Error('CodeGen: "else" body without "then" body');
      }
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(condition) {
      return this._elseNode(new If(condition));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new Else());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(If, Else);
    }
    _for(node, forBody) {
      this._blockNode(node);
      if (forBody)
        this.code(forBody).endFor();
      return this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(iteration, forBody) {
      return this._for(new ForLoop(iteration), forBody);
    }
    // `for` statement for a range of values
    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
      const name = this._scope.toName(nameOrPrefix);
      if (this.opts.es5) {
        const arr = iterable instanceof code_12.Name ? iterable : this.var("_arr", iterable);
        return this.forRange("_i", 0, code_12._`${arr}.length`, (i) => {
          this.var(name, code_12._`${arr}[${i}]`);
          forBody(name);
        });
      }
      return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
      if (this.opts.ownProperties) {
        return this.forOf(nameOrPrefix, code_12._`Object.keys(${obj})`, forBody);
      }
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(For);
    }
    // `label` statement
    label(label) {
      return this._leafNode(new Label(label));
    }
    // `break` statement
    break(label) {
      return this._leafNode(new Break(label));
    }
    // `return` statement
    return(value) {
      const node = new Return();
      this._blockNode(node);
      this.code(value);
      if (node.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(Return);
    }
    // `try` statement
    try(tryBody, catchCode, finallyCode) {
      if (!catchCode && !finallyCode)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const node = new Try();
      this._blockNode(node);
      this.code(tryBody);
      if (catchCode) {
        const error2 = this.name("e");
        this._currNode = node.catch = new Catch(error2);
        catchCode(error2);
      }
      if (finallyCode) {
        this._currNode = node.finally = new Finally();
        this.code(finallyCode);
      }
      return this._endBlockNode(Catch, Finally);
    }
    // `throw` statement
    throw(error2) {
      return this._leafNode(new Throw(error2));
    }
    // start self-balancing block
    block(body, nodeCount) {
      this._blockStarts.push(this._nodes.length);
      if (body)
        this.code(body).endBlock(nodeCount);
      return this;
    }
    // end the current self-balancing block
    endBlock(nodeCount) {
      const len = this._blockStarts.pop();
      if (len === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const toClose = this._nodes.length - len;
      if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
        throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
      }
      this._nodes.length = len;
      return this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(name, args = code_12.nil, async, funcBody) {
      this._blockNode(new Func(name, args, async));
      if (funcBody)
        this.code(funcBody).endFunc();
      return this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(Func);
    }
    optimize(n = 1) {
      while (n-- > 0) {
        this._root.optimizeNodes();
        this._root.optimizeNames(this._root.names, this._constants);
      }
    }
    _leafNode(node) {
      this._currNode.nodes.push(node);
      return this;
    }
    _blockNode(node) {
      this._currNode.nodes.push(node);
      this._nodes.push(node);
    }
    _endBlockNode(N1, N2) {
      const n = this._currNode;
      if (n instanceof N1 || N2 && n instanceof N2) {
        this._nodes.pop();
        return this;
      }
      throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
    }
    _elseNode(node) {
      const n = this._currNode;
      if (!(n instanceof If)) {
        throw new Error('CodeGen: "else" without "if"');
      }
      this._currNode = n.else = node;
      return this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const ns = this._nodes;
      return ns[ns.length - 1];
    }
    set _currNode(node) {
      const ns = this._nodes;
      ns[ns.length - 1] = node;
    }
  }
  exports2.CodeGen = CodeGen;
  function addNames(names2, from) {
    for (const n in from)
      names2[n] = (names2[n] || 0) + (from[n] || 0);
    return names2;
  }
  function addExprNames(names2, from) {
    return from instanceof code_12._CodeOrName ? addNames(names2, from.names) : names2;
  }
  function optimizeExpr(expr, names2, constants2) {
    if (expr instanceof code_12.Name)
      return replaceName(expr);
    if (!canOptimize(expr))
      return expr;
    return new code_12._Code(expr._items.reduce((items2, c) => {
      if (c instanceof code_12.Name)
        c = replaceName(c);
      if (c instanceof code_12._Code)
        items2.push(...c._items);
      else
        items2.push(c);
      return items2;
    }, []));
    function replaceName(n) {
      const c = constants2[n.str];
      if (c === void 0 || names2[n.str] !== 1)
        return n;
      delete names2[n.str];
      return c;
    }
    function canOptimize(e) {
      return e instanceof code_12._Code && e._items.some((c) => c instanceof code_12.Name && names2[c.str] === 1 && constants2[c.str] !== void 0);
    }
  }
  function subtractNames(names2, from) {
    for (const n in from)
      names2[n] = (names2[n] || 0) - (from[n] || 0);
  }
  function not2(x) {
    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : code_12._`!${par(x)}`;
  }
  exports2.not = not2;
  const andCode = mappend(exports2.operators.AND);
  function and(...args) {
    return args.reduce(andCode);
  }
  exports2.and = and;
  const orCode = mappend(exports2.operators.OR);
  function or(...args) {
    return args.reduce(orCode);
  }
  exports2.or = or;
  function mappend(op) {
    return (x, y) => x === code_12.nil ? y : y === code_12.nil ? x : code_12._`${par(x)} ${op} ${par(y)}`;
  }
  function par(x) {
    return x instanceof code_12.Name ? x : code_12._`(${x})`;
  }
})(codegen);
var util = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.checkStrictMode = exports2.getErrorPath = exports2.Type = exports2.useFunc = exports2.setEvaluated = exports2.evaluatedPropsToName = exports2.mergeEvaluated = exports2.eachItem = exports2.unescapeJsonPointer = exports2.escapeJsonPointer = exports2.escapeFragment = exports2.unescapeFragment = exports2.schemaRefOrVal = exports2.schemaHasRulesButRef = exports2.schemaHasRules = exports2.checkUnknownRules = exports2.alwaysValidSchema = exports2.toHash = void 0;
  const codegen_12 = codegen;
  const code_12 = code$1;
  function toHash(arr) {
    const hash = {};
    for (const item of arr)
      hash[item] = true;
    return hash;
  }
  exports2.toHash = toHash;
  function alwaysValidSchema(it, schema2) {
    if (typeof schema2 == "boolean")
      return schema2;
    if (Object.keys(schema2).length === 0)
      return true;
    checkUnknownRules(it, schema2);
    return !schemaHasRules(schema2, it.self.RULES.all);
  }
  exports2.alwaysValidSchema = alwaysValidSchema;
  function checkUnknownRules(it, schema2 = it.schema) {
    const { opts: opts2, self: self2 } = it;
    if (!opts2.strictSchema)
      return;
    if (typeof schema2 === "boolean")
      return;
    const rules2 = self2.RULES.keywords;
    for (const key in schema2) {
      if (!rules2[key])
        checkStrictMode(it, `unknown keyword: "${key}"`);
    }
  }
  exports2.checkUnknownRules = checkUnknownRules;
  function schemaHasRules(schema2, rules2) {
    if (typeof schema2 == "boolean")
      return !schema2;
    for (const key in schema2)
      if (rules2[key])
        return true;
    return false;
  }
  exports2.schemaHasRules = schemaHasRules;
  function schemaHasRulesButRef(schema2, RULES) {
    if (typeof schema2 == "boolean")
      return !schema2;
    for (const key in schema2)
      if (key !== "$ref" && RULES.all[key])
        return true;
    return false;
  }
  exports2.schemaHasRulesButRef = schemaHasRulesButRef;
  function schemaRefOrVal({ topSchemaRef, schemaPath }, schema2, keyword2, $data) {
    if (!$data) {
      if (typeof schema2 == "number" || typeof schema2 == "boolean")
        return schema2;
      if (typeof schema2 == "string")
        return codegen_12._`${schema2}`;
    }
    return codegen_12._`${topSchemaRef}${schemaPath}${codegen_12.getProperty(keyword2)}`;
  }
  exports2.schemaRefOrVal = schemaRefOrVal;
  function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
  }
  exports2.unescapeFragment = unescapeFragment;
  function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
  }
  exports2.escapeFragment = escapeFragment;
  function escapeJsonPointer(str) {
    if (typeof str == "number")
      return `${str}`;
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  exports2.escapeJsonPointer = escapeJsonPointer;
  function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  exports2.unescapeJsonPointer = unescapeJsonPointer;
  function eachItem(xs, f) {
    if (Array.isArray(xs)) {
      for (const x of xs)
        f(x);
    } else {
      f(xs);
    }
  }
  exports2.eachItem = eachItem;
  function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
    return (gen, from, to, toName) => {
      const res = to === void 0 ? from : to instanceof codegen_12.Name ? (from instanceof codegen_12.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_12.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
      return toName === codegen_12.Name && !(res instanceof codegen_12.Name) ? resultToName(gen, res) : res;
    };
  }
  exports2.mergeEvaluated = {
    props: makeMergeEvaluated({
      mergeNames: (gen, from, to) => gen.if(codegen_12._`${to} !== true && ${from} !== undefined`, () => {
        gen.if(codegen_12._`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, codegen_12._`${to} || {}`).code(codegen_12._`Object.assign(${to}, ${from})`));
      }),
      mergeToName: (gen, from, to) => gen.if(codegen_12._`${to} !== true`, () => {
        if (from === true) {
          gen.assign(to, true);
        } else {
          gen.assign(to, codegen_12._`${to} || {}`);
          setEvaluated(gen, to, from);
        }
      }),
      mergeValues: (from, to) => from === true ? true : { ...from, ...to },
      resultToName: evaluatedPropsToName
    }),
    items: makeMergeEvaluated({
      mergeNames: (gen, from, to) => gen.if(codegen_12._`${to} !== true && ${from} !== undefined`, () => gen.assign(to, codegen_12._`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
      mergeToName: (gen, from, to) => gen.if(codegen_12._`${to} !== true`, () => gen.assign(to, from === true ? true : codegen_12._`${to} > ${from} ? ${to} : ${from}`)),
      mergeValues: (from, to) => from === true ? true : Math.max(from, to),
      resultToName: (gen, items2) => gen.var("items", items2)
    })
  };
  function evaluatedPropsToName(gen, ps) {
    if (ps === true)
      return gen.var("props", true);
    const props = gen.var("props", codegen_12._`{}`);
    if (ps !== void 0)
      setEvaluated(gen, props, ps);
    return props;
  }
  exports2.evaluatedPropsToName = evaluatedPropsToName;
  function setEvaluated(gen, props, ps) {
    Object.keys(ps).forEach((p) => gen.assign(codegen_12._`${props}${codegen_12.getProperty(p)}`, true));
  }
  exports2.setEvaluated = setEvaluated;
  const snippets = {};
  function useFunc(gen, f) {
    return gen.scopeValue("func", {
      ref: f,
      code: snippets[f.code] || (snippets[f.code] = new code_12._Code(f.code))
    });
  }
  exports2.useFunc = useFunc;
  var Type;
  (function(Type2) {
    Type2[Type2["Num"] = 0] = "Num";
    Type2[Type2["Str"] = 1] = "Str";
  })(Type = exports2.Type || (exports2.Type = {}));
  function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
    if (dataProp instanceof codegen_12.Name) {
      const isNumber = dataPropType === Type.Num;
      return jsPropertySyntax ? isNumber ? codegen_12._`"[" + ${dataProp} + "]"` : codegen_12._`"['" + ${dataProp} + "']"` : isNumber ? codegen_12._`"/" + ${dataProp}` : codegen_12._`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return jsPropertySyntax ? codegen_12.getProperty(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
  }
  exports2.getErrorPath = getErrorPath;
  function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
    if (!mode)
      return;
    msg = `strict mode: ${msg}`;
    if (mode === true)
      throw new Error(msg);
    it.self.logger.warn(msg);
  }
  exports2.checkStrictMode = checkStrictMode;
})(util);
var names$1 = {};
Object.defineProperty(names$1, "__esModule", { value: true });
const codegen_1$t = codegen;
const names = {
  // validation function arguments
  data: new codegen_1$t.Name("data"),
  // args passed from referencing schema
  valCxt: new codegen_1$t.Name("valCxt"),
  instancePath: new codegen_1$t.Name("instancePath"),
  parentData: new codegen_1$t.Name("parentData"),
  parentDataProperty: new codegen_1$t.Name("parentDataProperty"),
  rootData: new codegen_1$t.Name("rootData"),
  dynamicAnchors: new codegen_1$t.Name("dynamicAnchors"),
  // function scoped variables
  vErrors: new codegen_1$t.Name("vErrors"),
  errors: new codegen_1$t.Name("errors"),
  this: new codegen_1$t.Name("this"),
  // "globals"
  self: new codegen_1$t.Name("self"),
  scope: new codegen_1$t.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new codegen_1$t.Name("json"),
  jsonPos: new codegen_1$t.Name("jsonPos"),
  jsonLen: new codegen_1$t.Name("jsonLen"),
  jsonPart: new codegen_1$t.Name("jsonPart")
};
names$1.default = names;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.extendErrors = exports2.resetErrorsCount = exports2.reportExtraError = exports2.reportError = exports2.keyword$DataError = exports2.keywordError = void 0;
  const codegen_12 = codegen;
  const util_12 = util;
  const names_12 = names$1;
  exports2.keywordError = {
    message: ({ keyword: keyword2 }) => codegen_12.str`must pass "${keyword2}" keyword validation`
  };
  exports2.keyword$DataError = {
    message: ({ keyword: keyword2, schemaType }) => schemaType ? codegen_12.str`"${keyword2}" keyword must be ${schemaType} ($data)` : codegen_12.str`"${keyword2}" keyword is invalid ($data)`
  };
  function reportError(cxt, error2 = exports2.keywordError, errorPaths, overrideAllErrors) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
      addError(gen, errObj);
    } else {
      returnErrors(it, codegen_12._`[${errObj}]`);
    }
  }
  exports2.reportError = reportError;
  function reportExtraError(cxt, error2 = exports2.keywordError, errorPaths) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
      returnErrors(it, names_12.default.vErrors);
    }
  }
  exports2.reportExtraError = reportExtraError;
  function resetErrorsCount(gen, errsCount) {
    gen.assign(names_12.default.errors, errsCount);
    gen.if(codegen_12._`${names_12.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign(codegen_12._`${names_12.default.vErrors}.length`, errsCount), () => gen.assign(names_12.default.vErrors, null)));
  }
  exports2.resetErrorsCount = resetErrorsCount;
  function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it }) {
    if (errsCount === void 0)
      throw new Error("ajv implementation error");
    const err = gen.name("err");
    gen.forRange("i", errsCount, names_12.default.errors, (i) => {
      gen.const(err, codegen_12._`${names_12.default.vErrors}[${i}]`);
      gen.if(codegen_12._`${err}.instancePath === undefined`, () => gen.assign(codegen_12._`${err}.instancePath`, codegen_12.strConcat(names_12.default.instancePath, it.errorPath)));
      gen.assign(codegen_12._`${err}.schemaPath`, codegen_12.str`${it.errSchemaPath}/${keyword2}`);
      if (it.opts.verbose) {
        gen.assign(codegen_12._`${err}.schema`, schemaValue);
        gen.assign(codegen_12._`${err}.data`, data);
      }
    });
  }
  exports2.extendErrors = extendErrors;
  function addError(gen, errObj) {
    const err = gen.const("err", errObj);
    gen.if(codegen_12._`${names_12.default.vErrors} === null`, () => gen.assign(names_12.default.vErrors, codegen_12._`[${err}]`), codegen_12._`${names_12.default.vErrors}.push(${err})`);
    gen.code(codegen_12._`${names_12.default.errors}++`);
  }
  function returnErrors(it, errs) {
    const { gen, validateName, schemaEnv } = it;
    if (schemaEnv.$async) {
      gen.throw(codegen_12._`new ${it.ValidationError}(${errs})`);
    } else {
      gen.assign(codegen_12._`${validateName}.errors`, errs);
      gen.return(false);
    }
  }
  const E = {
    keyword: new codegen_12.Name("keyword"),
    schemaPath: new codegen_12.Name("schemaPath"),
    params: new codegen_12.Name("params"),
    propertyName: new codegen_12.Name("propertyName"),
    message: new codegen_12.Name("message"),
    schema: new codegen_12.Name("schema"),
    parentSchema: new codegen_12.Name("parentSchema")
  };
  function errorObjectCode(cxt, error2, errorPaths) {
    const { createErrors } = cxt.it;
    if (createErrors === false)
      return codegen_12._`{}`;
    return errorObject(cxt, error2, errorPaths);
  }
  function errorObject(cxt, error2, errorPaths = {}) {
    const { gen, it } = cxt;
    const keyValues = [
      errorInstancePath(it, errorPaths),
      errorSchemaPath(cxt, errorPaths)
    ];
    extraErrorProps(cxt, error2, keyValues);
    return gen.object(...keyValues);
  }
  function errorInstancePath({ errorPath }, { instancePath }) {
    const instPath = instancePath ? codegen_12.str`${errorPath}${util_12.getErrorPath(instancePath, util_12.Type.Str)}` : errorPath;
    return [names_12.default.instancePath, codegen_12.strConcat(names_12.default.instancePath, instPath)];
  }
  function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
    let schPath = parentSchema ? errSchemaPath : codegen_12.str`${errSchemaPath}/${keyword2}`;
    if (schemaPath) {
      schPath = codegen_12.str`${schPath}${util_12.getErrorPath(schemaPath, util_12.Type.Str)}`;
    }
    return [E.schemaPath, schPath];
  }
  function extraErrorProps(cxt, { params, message }, keyValues) {
    const { keyword: keyword2, data, schemaValue, it } = cxt;
    const { opts: opts2, propertyName, topSchemaRef, schemaPath } = it;
    keyValues.push([E.keyword, keyword2], [E.params, typeof params == "function" ? params(cxt) : params || codegen_12._`{}`]);
    if (opts2.messages) {
      keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts2.verbose) {
      keyValues.push([E.schema, schemaValue], [E.parentSchema, codegen_12._`${topSchemaRef}${schemaPath}`], [names_12.default.data, data]);
    }
    if (propertyName)
      keyValues.push([E.propertyName, propertyName]);
  }
})(errors);
Object.defineProperty(boolSchema, "__esModule", { value: true });
boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
const errors_1$2 = errors;
const codegen_1$s = codegen;
const names_1$6 = names$1;
const boolError = {
  message: "boolean schema is false"
};
function topBoolOrEmptySchema(it) {
  const { gen, schema: schema2, validateName } = it;
  if (schema2 === false) {
    falseSchemaError(it, false);
  } else if (typeof schema2 == "object" && schema2.$async === true) {
    gen.return(names_1$6.default.data);
  } else {
    gen.assign(codegen_1$s._`${validateName}.errors`, null);
    gen.return(true);
  }
}
boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
function boolOrEmptySchema(it, valid2) {
  const { gen, schema: schema2 } = it;
  if (schema2 === false) {
    gen.var(valid2, false);
    falseSchemaError(it);
  } else {
    gen.var(valid2, true);
  }
}
boolSchema.boolOrEmptySchema = boolOrEmptySchema;
function falseSchemaError(it, overrideAllErrors) {
  const { gen, data } = it;
  const cxt = {
    gen,
    keyword: "false schema",
    data,
    schema: false,
    schemaCode: false,
    schemaValue: false,
    params: {},
    it
  };
  errors_1$2.reportError(cxt, boolError, void 0, overrideAllErrors);
}
var dataType = {};
var rules = {};
Object.defineProperty(rules, "__esModule", { value: true });
rules.getRules = rules.isJSONType = void 0;
const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
const jsonTypes = new Set(_jsonTypes);
function isJSONType(x) {
  return typeof x == "string" && jsonTypes.has(x);
}
rules.isJSONType = isJSONType;
function getRules() {
  const groups = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...groups, integer: true, boolean: true, null: true },
    rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
rules.getRules = getRules;
var applicability = {};
Object.defineProperty(applicability, "__esModule", { value: true });
applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
function schemaHasRulesForType({ schema: schema2, self: self2 }, type2) {
  const group = self2.RULES.types[type2];
  return group && group !== true && shouldUseGroup(schema2, group);
}
applicability.schemaHasRulesForType = schemaHasRulesForType;
function shouldUseGroup(schema2, group) {
  return group.rules.some((rule) => shouldUseRule(schema2, rule));
}
applicability.shouldUseGroup = shouldUseGroup;
function shouldUseRule(schema2, rule) {
  var _a;
  return schema2[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema2[kwd] !== void 0));
}
applicability.shouldUseRule = shouldUseRule;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.reportTypeError = exports2.checkDataTypes = exports2.checkDataType = exports2.coerceAndCheckDataType = exports2.getJSONTypes = exports2.getSchemaTypes = exports2.DataType = void 0;
  const rules_1 = rules;
  const applicability_12 = applicability;
  const errors_12 = errors;
  const codegen_12 = codegen;
  const util_12 = util;
  var DataType;
  (function(DataType2) {
    DataType2[DataType2["Correct"] = 0] = "Correct";
    DataType2[DataType2["Wrong"] = 1] = "Wrong";
  })(DataType = exports2.DataType || (exports2.DataType = {}));
  function getSchemaTypes(schema2) {
    const types2 = getJSONTypes(schema2.type);
    const hasNull = types2.includes("null");
    if (hasNull) {
      if (schema2.nullable === false)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!types2.length && schema2.nullable !== void 0) {
        throw new Error('"nullable" cannot be used without "type"');
      }
      if (schema2.nullable === true)
        types2.push("null");
    }
    return types2;
  }
  exports2.getSchemaTypes = getSchemaTypes;
  function getJSONTypes(ts) {
    const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
    if (types2.every(rules_1.isJSONType))
      return types2;
    throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
  }
  exports2.getJSONTypes = getJSONTypes;
  function coerceAndCheckDataType(it, types2) {
    const { gen, data, opts: opts2 } = it;
    const coerceTo = coerceToTypes(types2, opts2.coerceTypes);
    const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && applicability_12.schemaHasRulesForType(it, types2[0]));
    if (checkTypes) {
      const wrongType = checkDataTypes(types2, data, opts2.strictNumbers, DataType.Wrong);
      gen.if(wrongType, () => {
        if (coerceTo.length)
          coerceData(it, types2, coerceTo);
        else
          reportTypeError(it);
      });
    }
    return checkTypes;
  }
  exports2.coerceAndCheckDataType = coerceAndCheckDataType;
  const COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function coerceToTypes(types2, coerceTypes) {
    return coerceTypes ? types2.filter((t2) => COERCIBLE.has(t2) || coerceTypes === "array" && t2 === "array") : [];
  }
  function coerceData(it, types2, coerceTo) {
    const { gen, data, opts: opts2 } = it;
    const dataType2 = gen.let("dataType", codegen_12._`typeof ${data}`);
    const coerced = gen.let("coerced", codegen_12._`undefined`);
    if (opts2.coerceTypes === "array") {
      gen.if(codegen_12._`${dataType2} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, codegen_12._`${data}[0]`).assign(dataType2, codegen_12._`typeof ${data}`).if(checkDataTypes(types2, data, opts2.strictNumbers), () => gen.assign(coerced, data)));
    }
    gen.if(codegen_12._`${coerced} !== undefined`);
    for (const t2 of coerceTo) {
      if (COERCIBLE.has(t2) || t2 === "array" && opts2.coerceTypes === "array") {
        coerceSpecificType(t2);
      }
    }
    gen.else();
    reportTypeError(it);
    gen.endIf();
    gen.if(codegen_12._`${coerced} !== undefined`, () => {
      gen.assign(data, coerced);
      assignParentData(it, coerced);
    });
    function coerceSpecificType(t2) {
      switch (t2) {
        case "string":
          gen.elseIf(codegen_12._`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, codegen_12._`"" + ${data}`).elseIf(codegen_12._`${data} === null`).assign(coerced, codegen_12._`""`);
          return;
        case "number":
          gen.elseIf(codegen_12._`${dataType2} == "boolean" || ${data} === null
              || (${dataType2} == "string" && ${data} && ${data} == +${data})`).assign(coerced, codegen_12._`+${data}`);
          return;
        case "integer":
          gen.elseIf(codegen_12._`${dataType2} === "boolean" || ${data} === null
              || (${dataType2} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, codegen_12._`+${data}`);
          return;
        case "boolean":
          gen.elseIf(codegen_12._`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf(codegen_12._`${data} === "true" || ${data} === 1`).assign(coerced, true);
          return;
        case "null":
          gen.elseIf(codegen_12._`${data} === "" || ${data} === 0 || ${data} === false`);
          gen.assign(coerced, null);
          return;
        case "array":
          gen.elseIf(codegen_12._`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data} === null`).assign(coerced, codegen_12._`[${data}]`);
      }
    }
  }
  function assignParentData({ gen, parentData, parentDataProperty }, expr) {
    gen.if(codegen_12._`${parentData} !== undefined`, () => gen.assign(codegen_12._`${parentData}[${parentDataProperty}]`, expr));
  }
  function checkDataType(dataType2, data, strictNums, correct = DataType.Correct) {
    const EQ = correct === DataType.Correct ? codegen_12.operators.EQ : codegen_12.operators.NEQ;
    let cond;
    switch (dataType2) {
      case "null":
        return codegen_12._`${data} ${EQ} null`;
      case "array":
        cond = codegen_12._`Array.isArray(${data})`;
        break;
      case "object":
        cond = codegen_12._`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
        break;
      case "integer":
        cond = numCond(codegen_12._`!(${data} % 1) && !isNaN(${data})`);
        break;
      case "number":
        cond = numCond();
        break;
      default:
        return codegen_12._`typeof ${data} ${EQ} ${dataType2}`;
    }
    return correct === DataType.Correct ? cond : codegen_12.not(cond);
    function numCond(_cond = codegen_12.nil) {
      return codegen_12.and(codegen_12._`typeof ${data} == "number"`, _cond, strictNums ? codegen_12._`isFinite(${data})` : codegen_12.nil);
    }
  }
  exports2.checkDataType = checkDataType;
  function checkDataTypes(dataTypes, data, strictNums, correct) {
    if (dataTypes.length === 1) {
      return checkDataType(dataTypes[0], data, strictNums, correct);
    }
    let cond;
    const types2 = util_12.toHash(dataTypes);
    if (types2.array && types2.object) {
      const notObj = codegen_12._`typeof ${data} != "object"`;
      cond = types2.null ? notObj : codegen_12._`!${data} || ${notObj}`;
      delete types2.null;
      delete types2.array;
      delete types2.object;
    } else {
      cond = codegen_12.nil;
    }
    if (types2.number)
      delete types2.integer;
    for (const t2 in types2)
      cond = codegen_12.and(cond, checkDataType(t2, data, strictNums, correct));
    return cond;
  }
  exports2.checkDataTypes = checkDataTypes;
  const typeError = {
    message: ({ schema: schema2 }) => `must be ${schema2}`,
    params: ({ schema: schema2, schemaValue }) => typeof schema2 == "string" ? codegen_12._`{type: ${schema2}}` : codegen_12._`{type: ${schemaValue}}`
  };
  function reportTypeError(it) {
    const cxt = getTypeErrorContext(it);
    errors_12.reportError(cxt, typeError);
  }
  exports2.reportTypeError = reportTypeError;
  function getTypeErrorContext(it) {
    const { gen, data, schema: schema2 } = it;
    const schemaCode = util_12.schemaRefOrVal(it, schema2, "type");
    return {
      gen,
      keyword: "type",
      data,
      schema: schema2.type,
      schemaCode,
      schemaValue: schemaCode,
      parentSchema: schema2,
      params: {},
      it
    };
  }
})(dataType);
var defaults = {};
Object.defineProperty(defaults, "__esModule", { value: true });
defaults.assignDefaults = void 0;
const codegen_1$r = codegen;
const util_1$o = util;
function assignDefaults(it, ty) {
  const { properties: properties2, items: items2 } = it.schema;
  if (ty === "object" && properties2) {
    for (const key in properties2) {
      assignDefault(it, key, properties2[key].default);
    }
  } else if (ty === "array" && Array.isArray(items2)) {
    items2.forEach((sch, i) => assignDefault(it, i, sch.default));
  }
}
defaults.assignDefaults = assignDefaults;
function assignDefault(it, prop, defaultValue) {
  const { gen, compositeRule, data, opts: opts2 } = it;
  if (defaultValue === void 0)
    return;
  const childData = codegen_1$r._`${data}${codegen_1$r.getProperty(prop)}`;
  if (compositeRule) {
    util_1$o.checkStrictMode(it, `default is ignored for: ${childData}`);
    return;
  }
  let condition = codegen_1$r._`${childData} === undefined`;
  if (opts2.useDefaults === "empty") {
    condition = codegen_1$r._`${condition} || ${childData} === null || ${childData} === ""`;
  }
  gen.if(condition, codegen_1$r._`${childData} = ${codegen_1$r.stringify(defaultValue)}`);
}
var keyword = {};
var code = {};
Object.defineProperty(code, "__esModule", { value: true });
code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
const codegen_1$q = codegen;
const util_1$n = util;
const names_1$5 = names$1;
function checkReportMissingProp(cxt, prop) {
  const { gen, data, it } = cxt;
  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
    cxt.setParams({ missingProperty: codegen_1$q._`${prop}` }, true);
    cxt.error();
  });
}
code.checkReportMissingProp = checkReportMissingProp;
function checkMissingProp({ gen, data, it: { opts: opts2 } }, properties2, missing) {
  return codegen_1$q.or(...properties2.map((prop) => codegen_1$q.and(noPropertyInData(gen, data, prop, opts2.ownProperties), codegen_1$q._`${missing} = ${prop}`)));
}
code.checkMissingProp = checkMissingProp;
function reportMissingProp(cxt, missing) {
  cxt.setParams({ missingProperty: missing }, true);
  cxt.error();
}
code.reportMissingProp = reportMissingProp;
function hasPropFunc(gen) {
  return gen.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: codegen_1$q._`Object.prototype.hasOwnProperty`
  });
}
code.hasPropFunc = hasPropFunc;
function isOwnProperty(gen, data, property) {
  return codegen_1$q._`${hasPropFunc(gen)}.call(${data}, ${property})`;
}
code.isOwnProperty = isOwnProperty;
function propertyInData(gen, data, property, ownProperties) {
  const cond = codegen_1$q._`${data}${codegen_1$q.getProperty(property)} !== undefined`;
  return ownProperties ? codegen_1$q._`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
}
code.propertyInData = propertyInData;
function noPropertyInData(gen, data, property, ownProperties) {
  const cond = codegen_1$q._`${data}${codegen_1$q.getProperty(property)} === undefined`;
  return ownProperties ? codegen_1$q.or(cond, codegen_1$q.not(isOwnProperty(gen, data, property))) : cond;
}
code.noPropertyInData = noPropertyInData;
function allSchemaProperties(schemaMap) {
  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
}
code.allSchemaProperties = allSchemaProperties;
function schemaProperties(it, schemaMap) {
  return allSchemaProperties(schemaMap).filter((p) => !util_1$n.alwaysValidSchema(it, schemaMap[p]));
}
code.schemaProperties = schemaProperties;
function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
  const dataAndSchema = passSchema ? codegen_1$q._`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
  const valCxt = [
    [names_1$5.default.instancePath, codegen_1$q.strConcat(names_1$5.default.instancePath, errorPath)],
    [names_1$5.default.parentData, it.parentData],
    [names_1$5.default.parentDataProperty, it.parentDataProperty],
    [names_1$5.default.rootData, names_1$5.default.rootData]
  ];
  if (it.opts.dynamicRef)
    valCxt.push([names_1$5.default.dynamicAnchors, names_1$5.default.dynamicAnchors]);
  const args = codegen_1$q._`${dataAndSchema}, ${gen.object(...valCxt)}`;
  return context !== codegen_1$q.nil ? codegen_1$q._`${func}.call(${context}, ${args})` : codegen_1$q._`${func}(${args})`;
}
code.callValidateCode = callValidateCode;
function usePattern({ gen, it: { opts: opts2 } }, pattern2) {
  const u2 = opts2.unicodeRegExp ? "u" : "";
  return gen.scopeValue("pattern", {
    key: pattern2,
    ref: new RegExp(pattern2, u2),
    code: codegen_1$q._`new RegExp(${pattern2}, ${u2})`
  });
}
code.usePattern = usePattern;
function validateArray(cxt) {
  const { gen, data, keyword: keyword2, it } = cxt;
  const valid2 = gen.name("valid");
  if (it.allErrors) {
    const validArr = gen.let("valid", true);
    validateItems(() => gen.assign(validArr, false));
    return validArr;
  }
  gen.var(valid2, true);
  validateItems(() => gen.break());
  return valid2;
  function validateItems(notValid) {
    const len = gen.const("len", codegen_1$q._`${data}.length`);
    gen.forRange("i", 0, len, (i) => {
      cxt.subschema({
        keyword: keyword2,
        dataProp: i,
        dataPropType: util_1$n.Type.Num
      }, valid2);
      gen.if(codegen_1$q.not(valid2), notValid);
    });
  }
}
code.validateArray = validateArray;
function validateUnion(cxt) {
  const { gen, schema: schema2, keyword: keyword2, it } = cxt;
  if (!Array.isArray(schema2))
    throw new Error("ajv implementation error");
  const alwaysValid = schema2.some((sch) => util_1$n.alwaysValidSchema(it, sch));
  if (alwaysValid && !it.opts.unevaluated)
    return;
  const valid2 = gen.let("valid", false);
  const schValid = gen.name("_valid");
  gen.block(() => schema2.forEach((_sch, i) => {
    const schCxt = cxt.subschema({
      keyword: keyword2,
      schemaProp: i,
      compositeRule: true
    }, schValid);
    gen.assign(valid2, codegen_1$q._`${valid2} || ${schValid}`);
    const merged = cxt.mergeValidEvaluated(schCxt, schValid);
    if (!merged)
      gen.if(codegen_1$q.not(valid2));
  }));
  cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
}
code.validateUnion = validateUnion;
Object.defineProperty(keyword, "__esModule", { value: true });
keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
const codegen_1$p = codegen;
const names_1$4 = names$1;
const code_1$9 = code;
const errors_1$1 = errors;
function macroKeywordCode(cxt, def2) {
  const { gen, keyword: keyword2, schema: schema2, parentSchema, it } = cxt;
  const macroSchema = def2.macro.call(it.self, schema2, parentSchema, it);
  const schemaRef = useKeyword(gen, keyword2, macroSchema);
  if (it.opts.validateSchema !== false)
    it.self.validateSchema(macroSchema, true);
  const valid2 = gen.name("valid");
  cxt.subschema({
    schema: macroSchema,
    schemaPath: codegen_1$p.nil,
    errSchemaPath: `${it.errSchemaPath}/${keyword2}`,
    topSchemaRef: schemaRef,
    compositeRule: true
  }, valid2);
  cxt.pass(valid2, () => cxt.error(true));
}
keyword.macroKeywordCode = macroKeywordCode;
function funcKeywordCode(cxt, def2) {
  var _a;
  const { gen, keyword: keyword2, schema: schema2, parentSchema, $data, it } = cxt;
  checkAsyncKeyword(it, def2);
  const validate2 = !$data && def2.compile ? def2.compile.call(it.self, schema2, parentSchema, it) : def2.validate;
  const validateRef = useKeyword(gen, keyword2, validate2);
  const valid2 = gen.let("valid");
  cxt.block$data(valid2, validateKeyword);
  cxt.ok((_a = def2.valid) !== null && _a !== void 0 ? _a : valid2);
  function validateKeyword() {
    if (def2.errors === false) {
      assignValid();
      if (def2.modifying)
        modifyData(cxt);
      reportErrs(() => cxt.error());
    } else {
      const ruleErrs = def2.async ? validateAsync() : validateSync();
      if (def2.modifying)
        modifyData(cxt);
      reportErrs(() => addErrs(cxt, ruleErrs));
    }
  }
  function validateAsync() {
    const ruleErrs = gen.let("ruleErrs", null);
    gen.try(() => assignValid(codegen_1$p._`await `), (e) => gen.assign(valid2, false).if(codegen_1$p._`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, codegen_1$p._`${e}.errors`), () => gen.throw(e)));
    return ruleErrs;
  }
  function validateSync() {
    const validateErrs = codegen_1$p._`${validateRef}.errors`;
    gen.assign(validateErrs, null);
    assignValid(codegen_1$p.nil);
    return validateErrs;
  }
  function assignValid(_await = def2.async ? codegen_1$p._`await ` : codegen_1$p.nil) {
    const passCxt = it.opts.passContext ? names_1$4.default.this : names_1$4.default.self;
    const passSchema = !("compile" in def2 && !$data || def2.schema === false);
    gen.assign(valid2, codegen_1$p._`${_await}${code_1$9.callValidateCode(cxt, validateRef, passCxt, passSchema)}`, def2.modifying);
  }
  function reportErrs(errors2) {
    var _a2;
    gen.if(codegen_1$p.not((_a2 = def2.valid) !== null && _a2 !== void 0 ? _a2 : valid2), errors2);
  }
}
keyword.funcKeywordCode = funcKeywordCode;
function modifyData(cxt) {
  const { gen, data, it } = cxt;
  gen.if(it.parentData, () => gen.assign(data, codegen_1$p._`${it.parentData}[${it.parentDataProperty}]`));
}
function addErrs(cxt, errs) {
  const { gen } = cxt;
  gen.if(codegen_1$p._`Array.isArray(${errs})`, () => {
    gen.assign(names_1$4.default.vErrors, codegen_1$p._`${names_1$4.default.vErrors} === null ? ${errs} : ${names_1$4.default.vErrors}.concat(${errs})`).assign(names_1$4.default.errors, codegen_1$p._`${names_1$4.default.vErrors}.length`);
    errors_1$1.extendErrors(cxt);
  }, () => cxt.error());
}
function checkAsyncKeyword({ schemaEnv }, def2) {
  if (def2.async && !schemaEnv.$async)
    throw new Error("async keyword in sync schema");
}
function useKeyword(gen, keyword2, result) {
  if (result === void 0)
    throw new Error(`keyword "${keyword2}" failed to compile`);
  return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: codegen_1$p.stringify(result) });
}
function validSchemaType(schema2, schemaType, allowUndefined = false) {
  return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema2) : st === "object" ? schema2 && typeof schema2 == "object" && !Array.isArray(schema2) : typeof schema2 == st || allowUndefined && typeof schema2 == "undefined");
}
keyword.validSchemaType = validSchemaType;
function validateKeywordUsage({ schema: schema2, opts: opts2, self: self2, errSchemaPath }, def2, keyword2) {
  if (Array.isArray(def2.keyword) ? !def2.keyword.includes(keyword2) : def2.keyword !== keyword2) {
    throw new Error("ajv implementation error");
  }
  const deps = def2.dependencies;
  if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema2, kwd))) {
    throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
  }
  if (def2.validateSchema) {
    const valid2 = def2.validateSchema(schema2[keyword2]);
    if (!valid2) {
      const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def2.validateSchema.errors);
      if (opts2.validateSchema === "log")
        self2.logger.error(msg);
      else
        throw new Error(msg);
    }
  }
}
keyword.validateKeywordUsage = validateKeywordUsage;
var subschema = {};
Object.defineProperty(subschema, "__esModule", { value: true });
subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
const codegen_1$o = codegen;
const util_1$m = util;
function getSubschema(it, { keyword: keyword2, schemaProp, schema: schema2, schemaPath, errSchemaPath, topSchemaRef }) {
  if (keyword2 !== void 0 && schema2 !== void 0) {
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  }
  if (keyword2 !== void 0) {
    const sch = it.schema[keyword2];
    return schemaProp === void 0 ? {
      schema: sch,
      schemaPath: codegen_1$o._`${it.schemaPath}${codegen_1$o.getProperty(keyword2)}`,
      errSchemaPath: `${it.errSchemaPath}/${keyword2}`
    } : {
      schema: sch[schemaProp],
      schemaPath: codegen_1$o._`${it.schemaPath}${codegen_1$o.getProperty(keyword2)}${codegen_1$o.getProperty(schemaProp)}`,
      errSchemaPath: `${it.errSchemaPath}/${keyword2}/${util_1$m.escapeFragment(schemaProp)}`
    };
  }
  if (schema2 !== void 0) {
    if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    }
    return {
      schema: schema2,
      schemaPath,
      topSchemaRef,
      errSchemaPath
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
subschema.getSubschema = getSubschema;
function extendSubschemaData(subschema2, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
  if (data !== void 0 && dataProp !== void 0) {
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  }
  const { gen } = it;
  if (dataProp !== void 0) {
    const { errorPath, dataPathArr, opts: opts2 } = it;
    const nextData = gen.let("data", codegen_1$o._`${it.data}${codegen_1$o.getProperty(dataProp)}`, true);
    dataContextProps(nextData);
    subschema2.errorPath = codegen_1$o.str`${errorPath}${util_1$m.getErrorPath(dataProp, dpType, opts2.jsPropertySyntax)}`;
    subschema2.parentDataProperty = codegen_1$o._`${dataProp}`;
    subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
  }
  if (data !== void 0) {
    const nextData = data instanceof codegen_1$o.Name ? data : gen.let("data", data, true);
    dataContextProps(nextData);
    if (propertyName !== void 0)
      subschema2.propertyName = propertyName;
  }
  if (dataTypes)
    subschema2.dataTypes = dataTypes;
  function dataContextProps(_nextData) {
    subschema2.data = _nextData;
    subschema2.dataLevel = it.dataLevel + 1;
    subschema2.dataTypes = [];
    it.definedProperties = /* @__PURE__ */ new Set();
    subschema2.parentData = it.data;
    subschema2.dataNames = [...it.dataNames, _nextData];
  }
}
subschema.extendSubschemaData = extendSubschemaData;
function extendSubschemaMode(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
  if (compositeRule !== void 0)
    subschema2.compositeRule = compositeRule;
  if (createErrors !== void 0)
    subschema2.createErrors = createErrors;
  if (allErrors !== void 0)
    subschema2.allErrors = allErrors;
  subschema2.jtdDiscriminator = jtdDiscriminator;
  subschema2.jtdMetadata = jtdMetadata;
}
subschema.extendSubschemaMode = extendSubschemaMode;
var resolve$1 = {};
var fastDeepEqual = function equal(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    if (a.constructor !== b.constructor)
      return false;
    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!equal(a[i], b[i]))
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
        return false;
    for (i = length; i-- !== 0; ) {
      var key = keys[i];
      if (!equal(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
};
var jsonSchemaTraverse = { exports: {} };
var traverse$1 = jsonSchemaTraverse.exports = function(schema2, opts2, cb) {
  if (typeof opts2 == "function") {
    cb = opts2;
    opts2 = {};
  }
  cb = opts2.cb || cb;
  var pre = typeof cb == "function" ? cb : cb.pre || function() {
  };
  var post = cb.post || function() {
  };
  _traverse(opts2, pre, post, schema2, "", schema2);
};
traverse$1.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true,
  if: true,
  then: true,
  else: true
};
traverse$1.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};
traverse$1.propsKeywords = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};
traverse$1.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};
function _traverse(opts2, pre, post, schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema2 && typeof schema2 == "object" && !Array.isArray(schema2)) {
    pre(schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema2) {
      var sch = schema2[key];
      if (Array.isArray(sch)) {
        if (key in traverse$1.arrayKeywords) {
          for (var i = 0; i < sch.length; i++)
            _traverse(opts2, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema2, i);
        }
      } else if (key in traverse$1.propsKeywords) {
        if (sch && typeof sch == "object") {
          for (var prop in sch)
            _traverse(opts2, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema2, prop);
        }
      } else if (key in traverse$1.keywords || opts2.allKeys && !(key in traverse$1.skipKeywords)) {
        _traverse(opts2, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema2);
      }
    }
    post(schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}
function escapeJsonPtr(str) {
  return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
var jsonSchemaTraverseExports = jsonSchemaTraverse.exports;
var uri_all = { exports: {} };
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function(module2, exports2) {
  (function(global2, factory) {
    factory(exports2);
  })(commonjsGlobal, function(exports3) {
    function merge() {
      for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
        sets[_key] = arguments[_key];
      }
      if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
          sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join("");
      } else {
        return sets[0];
      }
    }
    function subexp(str) {
      return "(?:" + str + ")";
    }
    function typeOf(o) {
      return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
    }
    function toUpperCase(str) {
      return str.toUpperCase();
    }
    function toArray(obj) {
      return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
    }
    function assign(target, source2) {
      var obj = target;
      if (source2) {
        for (var key in source2) {
          obj[key] = source2[key];
        }
      }
      return obj;
    }
    function buildExps(isIRI) {
      var ALPHA$$ = "[A-Za-z]", DIGIT$$ = "[0-9]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$);
      subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*");
      subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*");
      var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+");
      subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+");
      subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*");
      var PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]"));
      subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+");
      subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*");
      return {
        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
        //RFC 6874, with relaxed parsing rules
      };
    }
    var URI_PROTOCOL = buildExps(false);
    var IRI_PROTOCOL = buildExps(true);
    var slicedToArray = /* @__PURE__ */ function() {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"])
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    var toConsumableArray = function(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
          arr2[i] = arr[i];
        return arr2;
      } else {
        return Array.from(arr);
      }
    };
    var maxInt = 2147483647;
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter = "-";
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7E]/;
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    var errors2 = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    function error$12(type2) {
      throw new RangeError(errors2[type2]);
    }
    function map(array, fn) {
      var result = [];
      var length = array.length;
      while (length--) {
        result[length] = fn(array[length]);
      }
      return result;
    }
    function mapDomain(string, fn) {
      var parts = string.split("@");
      var result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string = parts[1];
      }
      string = string.replace(regexSeparators, ".");
      var labels = string.split(".");
      var encoded = map(labels, fn).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      var output = [];
      var counter = 0;
      var length = string.length;
      while (counter < length) {
        var value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          var extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    var ucs2encode = function ucs2encode2(array) {
      return String.fromCodePoint.apply(String, toConsumableArray(array));
    };
    var basicToDigit = function basicToDigit2(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    };
    var digitToBasic = function digitToBasic2(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    var adapt = function adapt2(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (
        ;
        /* no initialization */
        delta > baseMinusTMin * tMax >> 1;
        k += base
      ) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var decode = function decode2(input) {
      var output = [];
      var inputLength = input.length;
      var i = 0;
      var n = initialN;
      var bias = initialBias;
      var basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (var j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error$12("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        var oldi = i;
        for (
          var w = 1, k = base;
          ;
          /* no condition */
          k += base
        ) {
          if (index >= inputLength) {
            error$12("invalid-input");
          }
          var digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base || digit > floor((maxInt - i) / w)) {
            error$12("overflow");
          }
          i += digit * w;
          var t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t2) {
            break;
          }
          var baseMinusT = base - t2;
          if (w > floor(maxInt / baseMinusT)) {
            error$12("overflow");
          }
          w *= baseMinusT;
        }
        var out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error$12("overflow");
        }
        n += floor(i / out);
        i %= out;
        output.splice(i++, 0, n);
      }
      return String.fromCodePoint.apply(String, output);
    };
    var encode = function encode2(input) {
      var output = [];
      input = ucs2decode(input);
      var inputLength = input.length;
      var n = initialN;
      var delta = 0;
      var bias = initialBias;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _currentValue2 = _step.value;
          if (_currentValue2 < 128) {
            output.push(stringFromCharCode(_currentValue2));
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      var basicLength = output.length;
      var handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        var m = maxInt;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = void 0;
        try {
          for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var currentValue = _step2.value;
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
        var handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error$12("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = void 0;
        try {
          for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _currentValue = _step3.value;
            if (_currentValue < n && ++delta > maxInt) {
              error$12("overflow");
            }
            if (_currentValue == n) {
              var q = delta;
              for (
                var k = base;
                ;
                /* no condition */
                k += base
              ) {
                var t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t2) {
                  break;
                }
                var qMinusT = q - t2;
                var baseMinusT = base - t2;
                output.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    };
    var toUnicode = function toUnicode2(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    var toASCII = function toASCII2(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    var punycode = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      "version": "2.1.0",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode,
      "encode": encode,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    var SCHEMES = {};
    function pctEncChar(chr) {
      var c = chr.charCodeAt(0);
      var e = void 0;
      if (c < 16)
        e = "%0" + c.toString(16).toUpperCase();
      else if (c < 128)
        e = "%" + c.toString(16).toUpperCase();
      else if (c < 2048)
        e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      else
        e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      return e;
    }
    function pctDecChars(str) {
      var newStr = "";
      var i = 0;
      var il = str.length;
      while (i < il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
          newStr += String.fromCharCode(c);
          i += 3;
        } else if (c >= 194 && c < 224) {
          if (il - i >= 6) {
            var c2 = parseInt(str.substr(i + 4, 2), 16);
            newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
          } else {
            newStr += str.substr(i, 6);
          }
          i += 6;
        } else if (c >= 224) {
          if (il - i >= 9) {
            var _c = parseInt(str.substr(i + 4, 2), 16);
            var c3 = parseInt(str.substr(i + 7, 2), 16);
            newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
          } else {
            newStr += str.substr(i, 9);
          }
          i += 9;
        } else {
          newStr += str.substr(i, 3);
          i += 3;
        }
      }
      return newStr;
    }
    function _normalizeComponentEncoding(components, protocol) {
      function decodeUnreserved2(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
      }
      if (components.scheme)
        components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
      if (components.userinfo !== void 0)
        components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.host !== void 0)
        components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.path !== void 0)
        components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.query !== void 0)
        components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.fragment !== void 0)
        components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      return components;
    }
    function _stripLeadingZeros(str) {
      return str.replace(/^0*(.*)/, "$1") || "0";
    }
    function _normalizeIPv4(host, protocol) {
      var matches = host.match(protocol.IPV4ADDRESS) || [];
      var _matches = slicedToArray(matches, 2), address = _matches[1];
      if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
      } else {
        return host;
      }
    }
    function _normalizeIPv6(host, protocol) {
      var matches = host.match(protocol.IPV6ADDRESS) || [];
      var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
      if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
          fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
        }
        if (isLastFieldIPv4Address) {
          fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function(acc, field, index) {
          if (!field || field === "0") {
            var lastLongest = acc[acc.length - 1];
            if (lastLongest && lastLongest.index + lastLongest.length === index) {
              lastLongest.length++;
            } else {
              acc.push({ index, length: 1 });
            }
          }
          return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function(a, b) {
          return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
          var newFirst = fields.slice(0, longestZeroFields.index);
          var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
          newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
          newHost = fields.join(":");
        }
        if (zone) {
          newHost += "%" + zone;
        }
        return newHost;
      } else {
        return host;
      }
    }
    var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
    var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
    function parse2(uriString) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var components = {};
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      if (options.reference === "suffix")
        uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
      var matches = uriString.match(URI_PARSE);
      if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
          components.scheme = matches[1];
          components.userinfo = matches[3];
          components.host = matches[4];
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = matches[7];
          components.fragment = matches[8];
          if (isNaN(components.port)) {
            components.port = matches[5];
          }
        } else {
          components.scheme = matches[1] || void 0;
          components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
          components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
          components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
          if (isNaN(components.port)) {
            components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
          }
        }
        if (components.host) {
          components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
          components.reference = "same-document";
        } else if (components.scheme === void 0) {
          components.reference = "relative";
        } else if (components.fragment === void 0) {
          components.reference = "absolute";
        } else {
          components.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
          components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
            try {
              components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
            }
          }
          _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
          _normalizeComponentEncoding(components, protocol);
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(components, options);
        }
      } else {
        components.error = components.error || "URI can not be parsed.";
      }
      return components;
    }
    function _recomposeAuthority(components, options) {
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
          return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    var RDS1 = /^\.\.?\//;
    var RDS2 = /^\/\.(\/|$)/;
    var RDS3 = /^\/\.\.(\/|$)/;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
    function removeDotSegments(input) {
      var output = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          var im = input.match(RDS5);
          if (im) {
            var s = im[0];
            input = input.slice(s.length);
            output.push(s);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output.join("");
    }
    function serialize(components) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize)
        schemeHandler.serialize(components, options);
      if (components.host) {
        if (protocol.IPV6ADDRESS.test(components.host))
          ;
        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
          try {
            components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
          } catch (e) {
            components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
          }
        }
      }
      _normalizeComponentEncoding(components, protocol);
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
      }
      var authority = _recomposeAuthority(components, options);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        var s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0) {
          s = s.replace(/^\/\//, "/%2F");
        }
        uriTokens.push(s);
      }
      if (components.query !== void 0) {
        uriTokens.push("?");
        uriTokens.push(components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
      }
      return uriTokens.join("");
    }
    function resolveComponents(base2, relative) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var skipNormalization = arguments[3];
      var target = {};
      if (!skipNormalization) {
        base2 = parse2(serialize(base2, options), options);
        relative = parse2(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base2.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base2.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                target.path = "/" + relative.path;
              } else if (!base2.path) {
                target.path = relative.path;
              } else {
                target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base2.userinfo;
          target.host = base2.host;
          target.port = base2.port;
        }
        target.scheme = base2.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function resolve2(baseURI, relativeURI, options) {
      var schemelessOptions = assign({ scheme: "null" }, options);
      return serialize(resolveComponents(parse2(baseURI, schemelessOptions), parse2(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
    }
    function normalize(uri, options) {
      if (typeof uri === "string") {
        uri = serialize(parse2(uri, options), options);
      } else if (typeOf(uri) === "object") {
        uri = parse2(serialize(uri, options), options);
      }
      return uri;
    }
    function equal3(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = serialize(parse2(uriA, options), options);
      } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
      }
      if (typeof uriB === "string") {
        uriB = serialize(parse2(uriB, options), options);
      } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
      }
      return uriA === uriB;
    }
    function escapeComponent(str, options) {
      return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
    }
    function unescapeComponent(str, options) {
      return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
    }
    var handler = {
      scheme: "http",
      domainHost: true,
      parse: function parse3(components, options) {
        if (!components.host) {
          components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
      },
      serialize: function serialize2(components, options) {
        var secure = String(components.scheme).toLowerCase() === "https";
        if (components.port === (secure ? 443 : 80) || components.port === "") {
          components.port = void 0;
        }
        if (!components.path) {
          components.path = "/";
        }
        return components;
      }
    };
    var handler$1 = {
      scheme: "https",
      domainHost: handler.domainHost,
      parse: handler.parse,
      serialize: handler.serialize
    };
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    var handler$2 = {
      scheme: "ws",
      domainHost: true,
      parse: function parse3(components, options) {
        var wsComponents = components;
        wsComponents.secure = isSecure(wsComponents);
        wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
        wsComponents.path = void 0;
        wsComponents.query = void 0;
        return wsComponents;
      },
      serialize: function serialize2(wsComponents, options) {
        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
          wsComponents.port = void 0;
        }
        if (typeof wsComponents.secure === "boolean") {
          wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
          wsComponents.secure = void 0;
        }
        if (wsComponents.resourceName) {
          var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path2 = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
          wsComponents.path = path2 && path2 !== "/" ? path2 : void 0;
          wsComponents.query = query;
          wsComponents.resourceName = void 0;
        }
        wsComponents.fragment = void 0;
        return wsComponents;
      }
    };
    var handler$3 = {
      scheme: "wss",
      domainHost: handler$2.domainHost,
      parse: handler$2.parse,
      serialize: handler$2.serialize
    };
    var O = {};
    var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]";
    var HEXDIG$$ = "[0-9A-Fa-f]";
    var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
    var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
    var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
    var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
    var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
    var UNRESERVED = new RegExp(UNRESERVED$$, "g");
    var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
    var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
    var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
    var NOT_HFVALUE = NOT_HFNAME;
    function decodeUnreserved(str) {
      var decStr = pctDecChars(str);
      return !decStr.match(UNRESERVED) ? str : decStr;
    }
    var handler$4 = {
      scheme: "mailto",
      parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = void 0;
        if (mailtoComponents.query) {
          var unknownHeaders = false;
          var headers = {};
          var hfields = mailtoComponents.query.split("&");
          for (var x = 0, xl = hfields.length; x < xl; ++x) {
            var hfield = hfields[x].split("=");
            switch (hfield[0]) {
              case "to":
                var toAddrs = hfield[1].split(",");
                for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                  to.push(toAddrs[_x]);
                }
                break;
              case "subject":
                mailtoComponents.subject = unescapeComponent(hfield[1], options);
                break;
              case "body":
                mailtoComponents.body = unescapeComponent(hfield[1], options);
                break;
              default:
                unknownHeaders = true;
                headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                break;
            }
          }
          if (unknownHeaders)
            mailtoComponents.headers = headers;
        }
        mailtoComponents.query = void 0;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
          var addr = to[_x2].split("@");
          addr[0] = unescapeComponent(addr[0]);
          if (!options.unicodeSupport) {
            try {
              addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
            } catch (e) {
              mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
            }
          } else {
            addr[1] = unescapeComponent(addr[1], options).toLowerCase();
          }
          to[_x2] = addr.join("@");
        }
        return mailtoComponents;
      },
      serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray(mailtoComponents.to);
        if (to) {
          for (var x = 0, xl = to.length; x < xl; ++x) {
            var toAddr = String(to[x]);
            var atIdx = toAddr.lastIndexOf("@");
            var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
            var domain = toAddr.slice(atIdx + 1);
            try {
              domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
            } catch (e) {
              components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
            to[x] = localPart + "@" + domain;
          }
          components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject)
          headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body)
          headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
          if (headers[name] !== O[name]) {
            fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
          }
        }
        if (fields.length) {
          components.query = fields.join("&");
        }
        return components;
      }
    };
    var URN_PARSE = /^([^\:]+)\:(.*)/;
    var handler$5 = {
      scheme: "urn",
      parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = matches[1].toLowerCase();
          var nss = matches[2];
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          urnComponents.nid = nid;
          urnComponents.nss = nss;
          urnComponents.path = void 0;
          if (schemeHandler) {
            urnComponents = schemeHandler.parse(urnComponents, options);
          }
        } else {
          urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
      },
      serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
          urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
      }
    };
    var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
    var handler$6 = {
      scheme: "urn:uuid",
      parse: function parse3(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = void 0;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
          uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
      },
      serialize: function serialize2(uuidComponents, options) {
        var urnComponents = uuidComponents;
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
      }
    };
    SCHEMES[handler.scheme] = handler;
    SCHEMES[handler$1.scheme] = handler$1;
    SCHEMES[handler$2.scheme] = handler$2;
    SCHEMES[handler$3.scheme] = handler$3;
    SCHEMES[handler$4.scheme] = handler$4;
    SCHEMES[handler$5.scheme] = handler$5;
    SCHEMES[handler$6.scheme] = handler$6;
    exports3.SCHEMES = SCHEMES;
    exports3.pctEncChar = pctEncChar;
    exports3.pctDecChars = pctDecChars;
    exports3.parse = parse2;
    exports3.removeDotSegments = removeDotSegments;
    exports3.serialize = serialize;
    exports3.resolveComponents = resolveComponents;
    exports3.resolve = resolve2;
    exports3.normalize = normalize;
    exports3.equal = equal3;
    exports3.escapeComponent = escapeComponent;
    exports3.unescapeComponent = unescapeComponent;
    Object.defineProperty(exports3, "__esModule", { value: true });
  });
})(uri_all, uri_all.exports);
var uri_allExports = uri_all.exports;
Object.defineProperty(resolve$1, "__esModule", { value: true });
resolve$1.getSchemaRefs = resolve$1.resolveUrl = resolve$1.normalizeId = resolve$1._getFullPath = resolve$1.getFullPath = resolve$1.inlineRef = void 0;
const util_1$l = util;
const equal$2 = fastDeepEqual;
const traverse = jsonSchemaTraverseExports;
const URI$1 = uri_allExports;
const SIMPLE_INLINED = /* @__PURE__ */ new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function inlineRef(schema2, limit2 = true) {
  if (typeof schema2 == "boolean")
    return true;
  if (limit2 === true)
    return !hasRef(schema2);
  if (!limit2)
    return false;
  return countKeys(schema2) <= limit2;
}
resolve$1.inlineRef = inlineRef;
const REF_KEYWORDS = /* @__PURE__ */ new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function hasRef(schema2) {
  for (const key in schema2) {
    if (REF_KEYWORDS.has(key))
      return true;
    const sch = schema2[key];
    if (Array.isArray(sch) && sch.some(hasRef))
      return true;
    if (typeof sch == "object" && hasRef(sch))
      return true;
  }
  return false;
}
function countKeys(schema2) {
  let count = 0;
  for (const key in schema2) {
    if (key === "$ref")
      return Infinity;
    count++;
    if (SIMPLE_INLINED.has(key))
      continue;
    if (typeof schema2[key] == "object") {
      util_1$l.eachItem(schema2[key], (sch) => count += countKeys(sch));
    }
    if (count === Infinity)
      return Infinity;
  }
  return count;
}
function getFullPath(id2 = "", normalize) {
  if (normalize !== false)
    id2 = normalizeId(id2);
  const p = URI$1.parse(id2);
  return _getFullPath(p);
}
resolve$1.getFullPath = getFullPath;
function _getFullPath(p) {
  return URI$1.serialize(p).split("#")[0] + "#";
}
resolve$1._getFullPath = _getFullPath;
const TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id2) {
  return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
}
resolve$1.normalizeId = normalizeId;
function resolveUrl(baseId, id2) {
  id2 = normalizeId(id2);
  return URI$1.resolve(baseId, id2);
}
resolve$1.resolveUrl = resolveUrl;
const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
function getSchemaRefs(schema2) {
  if (typeof schema2 == "boolean")
    return {};
  const { schemaId } = this.opts;
  const schId = normalizeId(schema2[schemaId]);
  const baseIds = { "": schId };
  const pathPrefix = getFullPath(schId, false);
  const localRefs = {};
  const schemaRefs = /* @__PURE__ */ new Set();
  traverse(schema2, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
    if (parentJsonPtr === void 0)
      return;
    const fullPath = pathPrefix + jsonPtr;
    let baseId = baseIds[parentJsonPtr];
    if (typeof sch[schemaId] == "string")
      baseId = addRef.call(this, sch[schemaId]);
    addAnchor.call(this, sch.$anchor);
    addAnchor.call(this, sch.$dynamicAnchor);
    baseIds[jsonPtr] = baseId;
    function addRef(ref2) {
      ref2 = normalizeId(baseId ? URI$1.resolve(baseId, ref2) : ref2);
      if (schemaRefs.has(ref2))
        throw ambiguos(ref2);
      schemaRefs.add(ref2);
      let schOrRef = this.refs[ref2];
      if (typeof schOrRef == "string")
        schOrRef = this.refs[schOrRef];
      if (typeof schOrRef == "object") {
        checkAmbiguosRef(sch, schOrRef.schema, ref2);
      } else if (ref2 !== normalizeId(fullPath)) {
        if (ref2[0] === "#") {
          checkAmbiguosRef(sch, localRefs[ref2], ref2);
          localRefs[ref2] = sch;
        } else {
          this.refs[ref2] = fullPath;
        }
      }
      return ref2;
    }
    function addAnchor(anchor) {
      if (typeof anchor == "string") {
        if (!ANCHOR.test(anchor))
          throw new Error(`invalid anchor "${anchor}"`);
        addRef.call(this, `#${anchor}`);
      }
    }
  });
  return localRefs;
  function checkAmbiguosRef(sch1, sch2, ref2) {
    if (sch2 !== void 0 && !equal$2(sch1, sch2))
      throw ambiguos(ref2);
  }
  function ambiguos(ref2) {
    return new Error(`reference "${ref2}" resolves to more than one schema`);
  }
}
resolve$1.getSchemaRefs = getSchemaRefs;
Object.defineProperty(validate, "__esModule", { value: true });
validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
const boolSchema_1 = boolSchema;
const dataType_1$1 = dataType;
const applicability_1 = applicability;
const dataType_2 = dataType;
const defaults_1 = defaults;
const keyword_1 = keyword;
const subschema_1 = subschema;
const codegen_1$n = codegen;
const names_1$3 = names$1;
const resolve_1$2 = resolve$1;
const util_1$k = util;
const errors_1 = errors;
function validateFunctionCode(it) {
  if (isSchemaObj(it)) {
    checkKeywords(it);
    if (schemaCxtHasRules(it)) {
      topSchemaObjCode(it);
      return;
    }
  }
  validateFunction(it, () => boolSchema_1.topBoolOrEmptySchema(it));
}
validate.validateFunctionCode = validateFunctionCode;
function validateFunction({ gen, validateName, schema: schema2, schemaEnv, opts: opts2 }, body) {
  if (opts2.code.es5) {
    gen.func(validateName, codegen_1$n._`${names_1$3.default.data}, ${names_1$3.default.valCxt}`, schemaEnv.$async, () => {
      gen.code(codegen_1$n._`"use strict"; ${funcSourceUrl(schema2, opts2)}`);
      destructureValCxtES5(gen, opts2);
      gen.code(body);
    });
  } else {
    gen.func(validateName, codegen_1$n._`${names_1$3.default.data}, ${destructureValCxt(opts2)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema2, opts2)).code(body));
  }
}
function destructureValCxt(opts2) {
  return codegen_1$n._`{${names_1$3.default.instancePath}="", ${names_1$3.default.parentData}, ${names_1$3.default.parentDataProperty}, ${names_1$3.default.rootData}=${names_1$3.default.data}${opts2.dynamicRef ? codegen_1$n._`, ${names_1$3.default.dynamicAnchors}={}` : codegen_1$n.nil}}={}`;
}
function destructureValCxtES5(gen, opts2) {
  gen.if(names_1$3.default.valCxt, () => {
    gen.var(names_1$3.default.instancePath, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.instancePath}`);
    gen.var(names_1$3.default.parentData, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.parentData}`);
    gen.var(names_1$3.default.parentDataProperty, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.parentDataProperty}`);
    gen.var(names_1$3.default.rootData, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.rootData}`);
    if (opts2.dynamicRef)
      gen.var(names_1$3.default.dynamicAnchors, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.dynamicAnchors}`);
  }, () => {
    gen.var(names_1$3.default.instancePath, codegen_1$n._`""`);
    gen.var(names_1$3.default.parentData, codegen_1$n._`undefined`);
    gen.var(names_1$3.default.parentDataProperty, codegen_1$n._`undefined`);
    gen.var(names_1$3.default.rootData, names_1$3.default.data);
    if (opts2.dynamicRef)
      gen.var(names_1$3.default.dynamicAnchors, codegen_1$n._`{}`);
  });
}
function topSchemaObjCode(it) {
  const { schema: schema2, opts: opts2, gen } = it;
  validateFunction(it, () => {
    if (opts2.$comment && schema2.$comment)
      commentKeyword(it);
    checkNoDefault(it);
    gen.let(names_1$3.default.vErrors, null);
    gen.let(names_1$3.default.errors, 0);
    if (opts2.unevaluated)
      resetEvaluated(it);
    typeAndKeywords(it);
    returnResults(it);
  });
  return;
}
function resetEvaluated(it) {
  const { gen, validateName } = it;
  it.evaluated = gen.const("evaluated", codegen_1$n._`${validateName}.evaluated`);
  gen.if(codegen_1$n._`${it.evaluated}.dynamicProps`, () => gen.assign(codegen_1$n._`${it.evaluated}.props`, codegen_1$n._`undefined`));
  gen.if(codegen_1$n._`${it.evaluated}.dynamicItems`, () => gen.assign(codegen_1$n._`${it.evaluated}.items`, codegen_1$n._`undefined`));
}
function funcSourceUrl(schema2, opts2) {
  const schId = typeof schema2 == "object" && schema2[opts2.schemaId];
  return schId && (opts2.code.source || opts2.code.process) ? codegen_1$n._`/*# sourceURL=${schId} */` : codegen_1$n.nil;
}
function subschemaCode(it, valid2) {
  if (isSchemaObj(it)) {
    checkKeywords(it);
    if (schemaCxtHasRules(it)) {
      subSchemaObjCode(it, valid2);
      return;
    }
  }
  boolSchema_1.boolOrEmptySchema(it, valid2);
}
function schemaCxtHasRules({ schema: schema2, self: self2 }) {
  if (typeof schema2 == "boolean")
    return !schema2;
  for (const key in schema2)
    if (self2.RULES.all[key])
      return true;
  return false;
}
function isSchemaObj(it) {
  return typeof it.schema != "boolean";
}
function subSchemaObjCode(it, valid2) {
  const { schema: schema2, gen, opts: opts2 } = it;
  if (opts2.$comment && schema2.$comment)
    commentKeyword(it);
  updateContext(it);
  checkAsyncSchema(it);
  const errsCount = gen.const("_errs", names_1$3.default.errors);
  typeAndKeywords(it, errsCount);
  gen.var(valid2, codegen_1$n._`${errsCount} === ${names_1$3.default.errors}`);
}
function checkKeywords(it) {
  util_1$k.checkUnknownRules(it);
  checkRefsAndKeywords(it);
}
function typeAndKeywords(it, errsCount) {
  if (it.opts.jtd)
    return schemaKeywords(it, [], false, errsCount);
  const types2 = dataType_1$1.getSchemaTypes(it.schema);
  const checkedTypes = dataType_1$1.coerceAndCheckDataType(it, types2);
  schemaKeywords(it, types2, !checkedTypes, errsCount);
}
function checkRefsAndKeywords(it) {
  const { schema: schema2, errSchemaPath, opts: opts2, self: self2 } = it;
  if (schema2.$ref && opts2.ignoreKeywordsWithRef && util_1$k.schemaHasRulesButRef(schema2, self2.RULES)) {
    self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
  }
}
function checkNoDefault(it) {
  const { schema: schema2, opts: opts2 } = it;
  if (schema2.default !== void 0 && opts2.useDefaults && opts2.strictSchema) {
    util_1$k.checkStrictMode(it, "default is ignored in the schema root");
  }
}
function updateContext(it) {
  const schId = it.schema[it.opts.schemaId];
  if (schId)
    it.baseId = resolve_1$2.resolveUrl(it.baseId, schId);
}
function checkAsyncSchema(it) {
  if (it.schema.$async && !it.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function commentKeyword({ gen, schemaEnv, schema: schema2, errSchemaPath, opts: opts2 }) {
  const msg = schema2.$comment;
  if (opts2.$comment === true) {
    gen.code(codegen_1$n._`${names_1$3.default.self}.logger.log(${msg})`);
  } else if (typeof opts2.$comment == "function") {
    const schemaPath = codegen_1$n.str`${errSchemaPath}/$comment`;
    const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
    gen.code(codegen_1$n._`${names_1$3.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
  }
}
function returnResults(it) {
  const { gen, schemaEnv, validateName, ValidationError: ValidationError2, opts: opts2 } = it;
  if (schemaEnv.$async) {
    gen.if(codegen_1$n._`${names_1$3.default.errors} === 0`, () => gen.return(names_1$3.default.data), () => gen.throw(codegen_1$n._`new ${ValidationError2}(${names_1$3.default.vErrors})`));
  } else {
    gen.assign(codegen_1$n._`${validateName}.errors`, names_1$3.default.vErrors);
    if (opts2.unevaluated)
      assignEvaluated(it);
    gen.return(codegen_1$n._`${names_1$3.default.errors} === 0`);
  }
}
function assignEvaluated({ gen, evaluated, props, items: items2 }) {
  if (props instanceof codegen_1$n.Name)
    gen.assign(codegen_1$n._`${evaluated}.props`, props);
  if (items2 instanceof codegen_1$n.Name)
    gen.assign(codegen_1$n._`${evaluated}.items`, items2);
}
function schemaKeywords(it, types2, typeErrors, errsCount) {
  const { gen, schema: schema2, data, allErrors, opts: opts2, self: self2 } = it;
  const { RULES } = self2;
  if (schema2.$ref && (opts2.ignoreKeywordsWithRef || !util_1$k.schemaHasRulesButRef(schema2, RULES))) {
    gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
    return;
  }
  if (!opts2.jtd)
    checkStrictTypes(it, types2);
  gen.block(() => {
    for (const group of RULES.rules)
      groupKeywords(group);
    groupKeywords(RULES.post);
  });
  function groupKeywords(group) {
    if (!applicability_1.shouldUseGroup(schema2, group))
      return;
    if (group.type) {
      gen.if(dataType_2.checkDataType(group.type, data, opts2.strictNumbers));
      iterateKeywords(it, group);
      if (types2.length === 1 && types2[0] === group.type && typeErrors) {
        gen.else();
        dataType_2.reportTypeError(it);
      }
      gen.endIf();
    } else {
      iterateKeywords(it, group);
    }
    if (!allErrors)
      gen.if(codegen_1$n._`${names_1$3.default.errors} === ${errsCount || 0}`);
  }
}
function iterateKeywords(it, group) {
  const { gen, schema: schema2, opts: { useDefaults } } = it;
  if (useDefaults)
    defaults_1.assignDefaults(it, group.type);
  gen.block(() => {
    for (const rule of group.rules) {
      if (applicability_1.shouldUseRule(schema2, rule)) {
        keywordCode(it, rule.keyword, rule.definition, group.type);
      }
    }
  });
}
function checkStrictTypes(it, types2) {
  if (it.schemaEnv.meta || !it.opts.strictTypes)
    return;
  checkContextTypes(it, types2);
  if (!it.opts.allowUnionTypes)
    checkMultipleTypes(it, types2);
  checkKeywordTypes(it, it.dataTypes);
}
function checkContextTypes(it, types2) {
  if (!types2.length)
    return;
  if (!it.dataTypes.length) {
    it.dataTypes = types2;
    return;
  }
  types2.forEach((t2) => {
    if (!includesType(it.dataTypes, t2)) {
      strictTypesError(it, `type "${t2}" not allowed by context "${it.dataTypes.join(",")}"`);
    }
  });
  it.dataTypes = it.dataTypes.filter((t2) => includesType(types2, t2));
}
function checkMultipleTypes(it, ts) {
  if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
    strictTypesError(it, "use allowUnionTypes to allow union type keyword");
  }
}
function checkKeywordTypes(it, ts) {
  const rules2 = it.self.RULES.all;
  for (const keyword2 in rules2) {
    const rule = rules2[keyword2];
    if (typeof rule == "object" && applicability_1.shouldUseRule(it.schema, rule)) {
      const { type: type2 } = rule.definition;
      if (type2.length && !type2.some((t2) => hasApplicableType(ts, t2))) {
        strictTypesError(it, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
      }
    }
  }
}
function hasApplicableType(schTs, kwdT) {
  return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
}
function includesType(ts, t2) {
  return ts.includes(t2) || t2 === "integer" && ts.includes("number");
}
function strictTypesError(it, msg) {
  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
  msg += ` at "${schemaPath}" (strictTypes)`;
  util_1$k.checkStrictMode(it, msg, it.opts.strictTypes);
}
class KeywordCxt {
  constructor(it, def2, keyword2) {
    keyword_1.validateKeywordUsage(it, def2, keyword2);
    this.gen = it.gen;
    this.allErrors = it.allErrors;
    this.keyword = keyword2;
    this.data = it.data;
    this.schema = it.schema[keyword2];
    this.$data = def2.$data && it.opts.$data && this.schema && this.schema.$data;
    this.schemaValue = util_1$k.schemaRefOrVal(it, this.schema, keyword2, this.$data);
    this.schemaType = def2.schemaType;
    this.parentSchema = it.schema;
    this.params = {};
    this.it = it;
    this.def = def2;
    if (this.$data) {
      this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
    } else {
      this.schemaCode = this.schemaValue;
      if (!keyword_1.validSchemaType(this.schema, def2.schemaType, def2.allowUndefined)) {
        throw new Error(`${keyword2} value must be ${JSON.stringify(def2.schemaType)}`);
      }
    }
    if ("code" in def2 ? def2.trackErrors : def2.errors !== false) {
      this.errsCount = it.gen.const("_errs", names_1$3.default.errors);
    }
  }
  result(condition, successAction, failAction) {
    this.failResult(codegen_1$n.not(condition), successAction, failAction);
  }
  failResult(condition, successAction, failAction) {
    this.gen.if(condition);
    if (failAction)
      failAction();
    else
      this.error();
    if (successAction) {
      this.gen.else();
      successAction();
      if (this.allErrors)
        this.gen.endIf();
    } else {
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
  }
  pass(condition, failAction) {
    this.failResult(codegen_1$n.not(condition), void 0, failAction);
  }
  fail(condition) {
    if (condition === void 0) {
      this.error();
      if (!this.allErrors)
        this.gen.if(false);
      return;
    }
    this.gen.if(condition);
    this.error();
    if (this.allErrors)
      this.gen.endIf();
    else
      this.gen.else();
  }
  fail$data(condition) {
    if (!this.$data)
      return this.fail(condition);
    const { schemaCode } = this;
    this.fail(codegen_1$n._`${schemaCode} !== undefined && (${codegen_1$n.or(this.invalid$data(), condition)})`);
  }
  error(append, errorParams, errorPaths) {
    if (errorParams) {
      this.setParams(errorParams);
      this._error(append, errorPaths);
      this.setParams({});
      return;
    }
    this._error(append, errorPaths);
  }
  _error(append, errorPaths) {
    (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
  }
  $dataError() {
    errors_1.reportError(this, this.def.$dataError || errors_1.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    errors_1.resetErrorsCount(this.gen, this.errsCount);
  }
  ok(cond) {
    if (!this.allErrors)
      this.gen.if(cond);
  }
  setParams(obj, assign) {
    if (assign)
      Object.assign(this.params, obj);
    else
      this.params = obj;
  }
  block$data(valid2, codeBlock, $dataValid = codegen_1$n.nil) {
    this.gen.block(() => {
      this.check$data(valid2, $dataValid);
      codeBlock();
    });
  }
  check$data(valid2 = codegen_1$n.nil, $dataValid = codegen_1$n.nil) {
    if (!this.$data)
      return;
    const { gen, schemaCode, schemaType, def: def2 } = this;
    gen.if(codegen_1$n.or(codegen_1$n._`${schemaCode} === undefined`, $dataValid));
    if (valid2 !== codegen_1$n.nil)
      gen.assign(valid2, true);
    if (schemaType.length || def2.validateSchema) {
      gen.elseIf(this.invalid$data());
      this.$dataError();
      if (valid2 !== codegen_1$n.nil)
        gen.assign(valid2, false);
    }
    gen.else();
  }
  invalid$data() {
    const { gen, schemaCode, schemaType, def: def2, it } = this;
    return codegen_1$n.or(wrong$DataType(), invalid$DataSchema());
    function wrong$DataType() {
      if (schemaType.length) {
        if (!(schemaCode instanceof codegen_1$n.Name))
          throw new Error("ajv implementation error");
        const st = Array.isArray(schemaType) ? schemaType : [schemaType];
        return codegen_1$n._`${dataType_2.checkDataTypes(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
      }
      return codegen_1$n.nil;
    }
    function invalid$DataSchema() {
      if (def2.validateSchema) {
        const validateSchemaRef = gen.scopeValue("validate$data", { ref: def2.validateSchema });
        return codegen_1$n._`!${validateSchemaRef}(${schemaCode})`;
      }
      return codegen_1$n.nil;
    }
  }
  subschema(appl, valid2) {
    const subschema2 = subschema_1.getSubschema(this.it, appl);
    subschema_1.extendSubschemaData(subschema2, this.it, appl);
    subschema_1.extendSubschemaMode(subschema2, appl);
    const nextContext = { ...this.it, ...subschema2, items: void 0, props: void 0 };
    subschemaCode(nextContext, valid2);
    return nextContext;
  }
  mergeEvaluated(schemaCxt, toName) {
    const { it, gen } = this;
    if (!it.opts.unevaluated)
      return;
    if (it.props !== true && schemaCxt.props !== void 0) {
      it.props = util_1$k.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
    }
    if (it.items !== true && schemaCxt.items !== void 0) {
      it.items = util_1$k.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
    }
  }
  mergeValidEvaluated(schemaCxt, valid2) {
    const { it, gen } = this;
    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
      gen.if(valid2, () => this.mergeEvaluated(schemaCxt, codegen_1$n.Name));
      return true;
    }
  }
}
validate.KeywordCxt = KeywordCxt;
function keywordCode(it, keyword2, def2, ruleType) {
  const cxt = new KeywordCxt(it, def2, keyword2);
  if ("code" in def2) {
    def2.code(cxt, ruleType);
  } else if (cxt.$data && def2.validate) {
    keyword_1.funcKeywordCode(cxt, def2);
  } else if ("macro" in def2) {
    keyword_1.macroKeywordCode(cxt, def2);
  } else if (def2.compile || def2.validate) {
    keyword_1.funcKeywordCode(cxt, def2);
  }
}
const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, { dataLevel, dataNames, dataPathArr }) {
  let jsonPointer;
  let data;
  if ($data === "")
    return names_1$3.default.rootData;
  if ($data[0] === "/") {
    if (!JSON_POINTER.test($data))
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    jsonPointer = $data;
    data = names_1$3.default.rootData;
  } else {
    const matches = RELATIVE_JSON_POINTER.exec($data);
    if (!matches)
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    const up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer === "#") {
      if (up >= dataLevel)
        throw new Error(errorMsg("property/index", up));
      return dataPathArr[dataLevel - up];
    }
    if (up > dataLevel)
      throw new Error(errorMsg("data", up));
    data = dataNames[dataLevel - up];
    if (!jsonPointer)
      return data;
  }
  let expr = data;
  const segments = jsonPointer.split("/");
  for (const segment of segments) {
    if (segment) {
      data = codegen_1$n._`${data}${codegen_1$n.getProperty(util_1$k.unescapeJsonPointer(segment))}`;
      expr = codegen_1$n._`${expr} && ${data}`;
    }
  }
  return expr;
  function errorMsg(pointerType, up) {
    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
  }
}
validate.getData = getData;
var validation_error = {};
Object.defineProperty(validation_error, "__esModule", { value: true });
class ValidationError extends Error {
  constructor(errors2) {
    super("validation failed");
    this.errors = errors2;
    this.ajv = this.validation = true;
  }
}
validation_error.default = ValidationError;
var ref_error = {};
Object.defineProperty(ref_error, "__esModule", { value: true });
const resolve_1$1 = resolve$1;
class MissingRefError extends Error {
  constructor(baseId, ref2, msg) {
    super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
    this.missingRef = resolve_1$1.resolveUrl(baseId, ref2);
    this.missingSchema = resolve_1$1.normalizeId(resolve_1$1.getFullPath(this.missingRef));
  }
}
ref_error.default = MissingRefError;
var compile = {};
Object.defineProperty(compile, "__esModule", { value: true });
compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
const codegen_1$m = codegen;
const validation_error_1 = validation_error;
const names_1$2 = names$1;
const resolve_1 = resolve$1;
const util_1$j = util;
const validate_1$1 = validate;
const URI = uri_allExports;
class SchemaEnv {
  constructor(env2) {
    var _a;
    this.refs = {};
    this.dynamicAnchors = {};
    let schema2;
    if (typeof env2.schema == "object")
      schema2 = env2.schema;
    this.schema = env2.schema;
    this.schemaId = env2.schemaId;
    this.root = env2.root || this;
    this.baseId = (_a = env2.baseId) !== null && _a !== void 0 ? _a : resolve_1.normalizeId(schema2 === null || schema2 === void 0 ? void 0 : schema2[env2.schemaId || "$id"]);
    this.schemaPath = env2.schemaPath;
    this.localRefs = env2.localRefs;
    this.meta = env2.meta;
    this.$async = schema2 === null || schema2 === void 0 ? void 0 : schema2.$async;
    this.refs = {};
  }
}
compile.SchemaEnv = SchemaEnv;
function compileSchema(sch) {
  const _sch = getCompilingSchema.call(this, sch);
  if (_sch)
    return _sch;
  const rootId = resolve_1.getFullPath(sch.root.baseId);
  const { es5, lines } = this.opts.code;
  const { ownProperties } = this.opts;
  const gen = new codegen_1$m.CodeGen(this.scope, { es5, lines, ownProperties });
  let _ValidationError;
  if (sch.$async) {
    _ValidationError = gen.scopeValue("Error", {
      ref: validation_error_1.default,
      code: codegen_1$m._`require("ajv/dist/runtime/validation_error").default`
    });
  }
  const validateName = gen.scopeName("validate");
  sch.validateName = validateName;
  const schemaCxt = {
    gen,
    allErrors: this.opts.allErrors,
    data: names_1$2.default.data,
    parentData: names_1$2.default.parentData,
    parentDataProperty: names_1$2.default.parentDataProperty,
    dataNames: [names_1$2.default.data],
    dataPathArr: [codegen_1$m.nil],
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
    topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: codegen_1$m.stringify(sch.schema) } : { ref: sch.schema }),
    validateName,
    ValidationError: _ValidationError,
    schema: sch.schema,
    schemaEnv: sch,
    rootId,
    baseId: sch.baseId || rootId,
    schemaPath: codegen_1$m.nil,
    errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: codegen_1$m._`""`,
    opts: this.opts,
    self: this
  };
  let sourceCode;
  try {
    this._compilations.add(sch);
    validate_1$1.validateFunctionCode(schemaCxt);
    gen.optimize(this.opts.code.optimize);
    const validateCode = gen.toString();
    sourceCode = `${gen.scopeRefs(names_1$2.default.scope)}return ${validateCode}`;
    if (this.opts.code.process)
      sourceCode = this.opts.code.process(sourceCode, sch);
    const makeValidate = new Function(`${names_1$2.default.self}`, `${names_1$2.default.scope}`, sourceCode);
    const validate2 = makeValidate(this, this.scope.get());
    this.scope.value(validateName, { ref: validate2 });
    validate2.errors = null;
    validate2.schema = sch.schema;
    validate2.schemaEnv = sch;
    if (sch.$async)
      validate2.$async = true;
    if (this.opts.code.source === true) {
      validate2.source = { validateName, validateCode, scopeValues: gen._values };
    }
    if (this.opts.unevaluated) {
      const { props, items: items2 } = schemaCxt;
      validate2.evaluated = {
        props: props instanceof codegen_1$m.Name ? void 0 : props,
        items: items2 instanceof codegen_1$m.Name ? void 0 : items2,
        dynamicProps: props instanceof codegen_1$m.Name,
        dynamicItems: items2 instanceof codegen_1$m.Name
      };
      if (validate2.source)
        validate2.source.evaluated = codegen_1$m.stringify(validate2.evaluated);
    }
    sch.validate = validate2;
    return sch;
  } catch (e) {
    delete sch.validate;
    delete sch.validateName;
    if (sourceCode)
      this.logger.error("Error compiling schema, function code:", sourceCode);
    throw e;
  } finally {
    this._compilations.delete(sch);
  }
}
compile.compileSchema = compileSchema;
function resolveRef(root, baseId, ref2) {
  var _a;
  ref2 = resolve_1.resolveUrl(baseId, ref2);
  const schOrFunc = root.refs[ref2];
  if (schOrFunc)
    return schOrFunc;
  let _sch = resolve.call(this, root, ref2);
  if (_sch === void 0) {
    const schema2 = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref2];
    const { schemaId } = this.opts;
    if (schema2)
      _sch = new SchemaEnv({ schema: schema2, schemaId, root, baseId });
  }
  if (_sch === void 0)
    return;
  return root.refs[ref2] = inlineOrCompile.call(this, _sch);
}
compile.resolveRef = resolveRef;
function inlineOrCompile(sch) {
  if (resolve_1.inlineRef(sch.schema, this.opts.inlineRefs))
    return sch.schema;
  return sch.validate ? sch : compileSchema.call(this, sch);
}
function getCompilingSchema(schEnv) {
  for (const sch of this._compilations) {
    if (sameSchemaEnv(sch, schEnv))
      return sch;
  }
}
compile.getCompilingSchema = getCompilingSchema;
function sameSchemaEnv(s1, s2) {
  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
}
function resolve(root, ref2) {
  let sch;
  while (typeof (sch = this.refs[ref2]) == "string")
    ref2 = sch;
  return sch || this.schemas[ref2] || resolveSchema.call(this, root, ref2);
}
function resolveSchema(root, ref2) {
  const p = URI.parse(ref2);
  const refPath = resolve_1._getFullPath(p);
  let baseId = resolve_1.getFullPath(root.baseId);
  if (Object.keys(root.schema).length > 0 && refPath === baseId) {
    return getJsonPointer.call(this, p, root);
  }
  const id2 = resolve_1.normalizeId(refPath);
  const schOrRef = this.refs[id2] || this.schemas[id2];
  if (typeof schOrRef == "string") {
    const sch = resolveSchema.call(this, root, schOrRef);
    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
      return;
    return getJsonPointer.call(this, p, sch);
  }
  if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
    return;
  if (!schOrRef.validate)
    compileSchema.call(this, schOrRef);
  if (id2 === resolve_1.normalizeId(ref2)) {
    const { schema: schema2 } = schOrRef;
    const { schemaId } = this.opts;
    const schId = schema2[schemaId];
    if (schId)
      baseId = resolve_1.resolveUrl(baseId, schId);
    return new SchemaEnv({ schema: schema2, schemaId, root, baseId });
  }
  return getJsonPointer.call(this, p, schOrRef);
}
compile.resolveSchema = resolveSchema;
const PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function getJsonPointer(parsedRef, { baseId, schema: schema2, root }) {
  var _a;
  if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
    return;
  for (const part of parsedRef.fragment.slice(1).split("/")) {
    if (typeof schema2 == "boolean")
      return;
    schema2 = schema2[util_1$j.unescapeFragment(part)];
    if (schema2 === void 0)
      return;
    const schId = typeof schema2 == "object" && schema2[this.opts.schemaId];
    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
      baseId = resolve_1.resolveUrl(baseId, schId);
    }
  }
  let env2;
  if (typeof schema2 != "boolean" && schema2.$ref && !util_1$j.schemaHasRulesButRef(schema2, this.RULES)) {
    const $ref = resolve_1.resolveUrl(baseId, schema2.$ref);
    env2 = resolveSchema.call(this, root, $ref);
  }
  const { schemaId } = this.opts;
  env2 = env2 || new SchemaEnv({ schema: schema2, schemaId, root, baseId });
  if (env2.schema !== env2.root.schema)
    return env2;
  return void 0;
}
const $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
const type$1 = "object";
const required$1 = [
  "$data"
];
const properties$2 = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
};
const additionalProperties$1 = false;
const require$$9 = {
  $id: $id$1,
  description,
  type: type$1,
  required: required$1,
  properties: properties$2,
  additionalProperties: additionalProperties$1
};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
  var validate_12 = validate;
  Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  const validation_error_12 = validation_error;
  const ref_error_12 = ref_error;
  const rules_1 = rules;
  const compile_12 = compile;
  const codegen_2 = codegen;
  const resolve_12 = resolve$1;
  const dataType_12 = dataType;
  const util_12 = util;
  const $dataRefSchema = require$$9;
  const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
  const EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]);
  const removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  };
  const deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  };
  const MAX_EXPRESSION = 200;
  function requiredOptions(o) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
    const s = o.strict;
    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
    const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
    return {
      strictSchema: (_c = (_b = o.strictSchema) !== null && _b !== void 0 ? _b : s) !== null && _c !== void 0 ? _c : true,
      strictNumbers: (_e = (_d = o.strictNumbers) !== null && _d !== void 0 ? _d : s) !== null && _e !== void 0 ? _e : true,
      strictTypes: (_g = (_f = o.strictTypes) !== null && _f !== void 0 ? _f : s) !== null && _g !== void 0 ? _g : "log",
      strictTuples: (_j = (_h = o.strictTuples) !== null && _h !== void 0 ? _h : s) !== null && _j !== void 0 ? _j : "log",
      strictRequired: (_l = (_k = o.strictRequired) !== null && _k !== void 0 ? _k : s) !== null && _l !== void 0 ? _l : false,
      code: o.code ? { ...o.code, optimize } : { optimize },
      loopRequired: (_m = o.loopRequired) !== null && _m !== void 0 ? _m : MAX_EXPRESSION,
      loopEnum: (_o = o.loopEnum) !== null && _o !== void 0 ? _o : MAX_EXPRESSION,
      meta: (_p = o.meta) !== null && _p !== void 0 ? _p : true,
      messages: (_q = o.messages) !== null && _q !== void 0 ? _q : true,
      inlineRefs: (_r = o.inlineRefs) !== null && _r !== void 0 ? _r : true,
      schemaId: (_s = o.schemaId) !== null && _s !== void 0 ? _s : "$id",
      addUsedSchema: (_t = o.addUsedSchema) !== null && _t !== void 0 ? _t : true,
      validateSchema: (_u = o.validateSchema) !== null && _u !== void 0 ? _u : true,
      validateFormats: (_v = o.validateFormats) !== null && _v !== void 0 ? _v : true,
      unicodeRegExp: (_w = o.unicodeRegExp) !== null && _w !== void 0 ? _w : true,
      int32range: (_x = o.int32range) !== null && _x !== void 0 ? _x : true
    };
  }
  class Ajv {
    constructor(opts2 = {}) {
      this.schemas = {};
      this.refs = {};
      this.formats = {};
      this._compilations = /* @__PURE__ */ new Set();
      this._loading = {};
      this._cache = /* @__PURE__ */ new Map();
      opts2 = this.opts = { ...opts2, ...requiredOptions(opts2) };
      const { es5, lines } = this.opts.code;
      this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
      this.logger = getLogger(opts2.logger);
      const formatOpt = opts2.validateFormats;
      opts2.validateFormats = false;
      this.RULES = rules_1.getRules();
      checkOptions.call(this, removedOptions, opts2, "NOT SUPPORTED");
      checkOptions.call(this, deprecatedOptions, opts2, "DEPRECATED", "warn");
      this._metaOpts = getMetaSchemaOptions.call(this);
      if (opts2.formats)
        addInitialFormats.call(this);
      this._addVocabularies();
      this._addDefaultMetaSchema();
      if (opts2.keywords)
        addInitialKeywords.call(this, opts2.keywords);
      if (typeof opts2.meta == "object")
        this.addMetaSchema(opts2.meta);
      addInitialSchemas.call(this);
      opts2.validateFormats = formatOpt;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data, meta, schemaId } = this.opts;
      let _dataRefSchema = $dataRefSchema;
      if (schemaId === "id") {
        _dataRefSchema = { ...$dataRefSchema };
        _dataRefSchema.id = _dataRefSchema.$id;
        delete _dataRefSchema.$id;
      }
      if (meta && $data)
        this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
      const { meta, schemaId } = this.opts;
      return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
    }
    validate(schemaKeyRef, data) {
      let v;
      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v)
          throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
      } else {
        v = this.compile(schemaKeyRef);
      }
      const valid2 = v(data);
      if (!("$async" in v))
        this.errors = v.errors;
      return valid2;
    }
    compile(schema2, _meta) {
      const sch = this._addSchema(schema2, _meta);
      return sch.validate || this._compileSchemaEnv(sch);
    }
    compileAsync(schema2, meta) {
      if (typeof this.opts.loadSchema != "function") {
        throw new Error("options.loadSchema should be a function");
      }
      const { loadSchema } = this.opts;
      return runCompileAsync.call(this, schema2, meta);
      async function runCompileAsync(_schema, _meta) {
        await loadMetaSchema.call(this, _schema.$schema);
        const sch = this._addSchema(_schema, _meta);
        return sch.validate || _compileAsync.call(this, sch);
      }
      async function loadMetaSchema($ref) {
        if ($ref && !this.getSchema($ref)) {
          await runCompileAsync.call(this, { $ref }, true);
        }
      }
      async function _compileAsync(sch) {
        try {
          return this._compileSchemaEnv(sch);
        } catch (e) {
          if (!(e instanceof ref_error_12.default))
            throw e;
          checkLoaded.call(this, e);
          await loadMissingSchema.call(this, e.missingSchema);
          return _compileAsync.call(this, sch);
        }
      }
      function checkLoaded({ missingSchema: ref2, missingRef }) {
        if (this.refs[ref2]) {
          throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
        }
      }
      async function loadMissingSchema(ref2) {
        const _schema = await _loadSchema.call(this, ref2);
        if (!this.refs[ref2])
          await loadMetaSchema.call(this, _schema.$schema);
        if (!this.refs[ref2])
          this.addSchema(_schema, ref2, meta);
      }
      async function _loadSchema(ref2) {
        const p = this._loading[ref2];
        if (p)
          return p;
        try {
          return await (this._loading[ref2] = loadSchema(ref2));
        } finally {
          delete this._loading[ref2];
        }
      }
    }
    // Adds schema to the instance
    addSchema(schema2, key, _meta, _validateSchema = this.opts.validateSchema) {
      if (Array.isArray(schema2)) {
        for (const sch of schema2)
          this.addSchema(sch, void 0, _meta, _validateSchema);
        return this;
      }
      let id2;
      if (typeof schema2 === "object") {
        const { schemaId } = this.opts;
        id2 = schema2[schemaId];
        if (id2 !== void 0 && typeof id2 != "string") {
          throw new Error(`schema ${schemaId} must be string`);
        }
      }
      key = resolve_12.normalizeId(key || id2);
      this._checkUnique(key);
      this.schemas[key] = this._addSchema(schema2, _meta, key, _validateSchema, true);
      return this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(schema2, key, _validateSchema = this.opts.validateSchema) {
      this.addSchema(schema2, key, true, _validateSchema);
      return this;
    }
    //  Validate schema against its meta-schema
    validateSchema(schema2, throwOrLogError) {
      if (typeof schema2 == "boolean")
        return true;
      let $schema2;
      $schema2 = schema2.$schema;
      if ($schema2 !== void 0 && typeof $schema2 != "string") {
        throw new Error("$schema must be a string");
      }
      $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
      if (!$schema2) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      const valid2 = this.validate($schema2, schema2);
      if (!valid2 && throwOrLogError) {
        const message = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid2;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(keyRef) {
      let sch;
      while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
        keyRef = sch;
      if (sch === void 0) {
        const { schemaId } = this.opts;
        const root = new compile_12.SchemaEnv({ schema: {}, schemaId });
        sch = compile_12.resolveSchema.call(this, root, keyRef);
        if (!sch)
          return;
        this.refs[keyRef] = sch;
      }
      return sch.validate || this._compileSchemaEnv(sch);
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        this._removeAllSchemas(this.schemas, schemaKeyRef);
        this._removeAllSchemas(this.refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          this._removeAllSchemas(this.schemas);
          this._removeAllSchemas(this.refs);
          this._cache.clear();
          return this;
        case "string": {
          const sch = getSchEnv.call(this, schemaKeyRef);
          if (typeof sch == "object")
            this._cache.delete(sch.schema);
          delete this.schemas[schemaKeyRef];
          delete this.refs[schemaKeyRef];
          return this;
        }
        case "object": {
          const cacheKey = schemaKeyRef;
          this._cache.delete(cacheKey);
          let id2 = schemaKeyRef[this.opts.schemaId];
          if (id2) {
            id2 = resolve_12.normalizeId(id2);
            delete this.schemas[id2];
            delete this.refs[id2];
          }
          return this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(definitions2) {
      for (const def2 of definitions2)
        this.addKeyword(def2);
      return this;
    }
    addKeyword(kwdOrDef, def2) {
      let keyword2;
      if (typeof kwdOrDef == "string") {
        keyword2 = kwdOrDef;
        if (typeof def2 == "object") {
          this.logger.warn("these parameters are deprecated, see docs for addKeyword");
          def2.keyword = keyword2;
        }
      } else if (typeof kwdOrDef == "object" && def2 === void 0) {
        def2 = kwdOrDef;
        keyword2 = def2.keyword;
        if (Array.isArray(keyword2) && !keyword2.length) {
          throw new Error("addKeywords: keyword must be string or non-empty array");
        }
      } else {
        throw new Error("invalid addKeywords parameters");
      }
      checkKeyword.call(this, keyword2, def2);
      if (!def2) {
        util_12.eachItem(keyword2, (kwd) => addRule.call(this, kwd));
        return this;
      }
      keywordMetaschema.call(this, def2);
      const definition = {
        ...def2,
        type: dataType_12.getJSONTypes(def2.type),
        schemaType: dataType_12.getJSONTypes(def2.schemaType)
      };
      util_12.eachItem(keyword2, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t2) => addRule.call(this, k, definition, t2)));
      return this;
    }
    getKeyword(keyword2) {
      const rule = this.RULES.all[keyword2];
      return typeof rule == "object" ? rule.definition : !!rule;
    }
    // Remove keyword
    removeKeyword(keyword2) {
      const { RULES } = this;
      delete RULES.keywords[keyword2];
      delete RULES.all[keyword2];
      for (const group of RULES.rules) {
        const i = group.rules.findIndex((rule) => rule.keyword === keyword2);
        if (i >= 0)
          group.rules.splice(i, 1);
      }
      return this;
    }
    // Add format
    addFormat(name, format2) {
      if (typeof format2 == "string")
        format2 = new RegExp(format2);
      this.formats[name] = format2;
      return this;
    }
    errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
      if (!errors2 || errors2.length === 0)
        return "No errors";
      return errors2.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
      const rules2 = this.RULES.all;
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      for (const jsonPointer of keywordsJsonPointers) {
        const segments = jsonPointer.split("/").slice(1);
        let keywords = metaSchema;
        for (const seg of segments)
          keywords = keywords[seg];
        for (const key in rules2) {
          const rule = rules2[key];
          if (typeof rule != "object")
            continue;
          const { $data } = rule.definition;
          const schema2 = keywords[key];
          if ($data && schema2)
            keywords[key] = schemaOrData(schema2);
        }
      }
      return metaSchema;
    }
    _removeAllSchemas(schemas, regex) {
      for (const keyRef in schemas) {
        const sch = schemas[keyRef];
        if (!regex || regex.test(keyRef)) {
          if (typeof sch == "string") {
            delete schemas[keyRef];
          } else if (sch && !sch.meta) {
            this._cache.delete(sch.schema);
            delete schemas[keyRef];
          }
        }
      }
    }
    _addSchema(schema2, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
      let id2;
      const { schemaId } = this.opts;
      if (typeof schema2 == "object") {
        id2 = schema2[schemaId];
      } else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        else if (typeof schema2 != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let sch = this._cache.get(schema2);
      if (sch !== void 0)
        return sch;
      const localRefs = resolve_12.getSchemaRefs.call(this, schema2);
      baseId = resolve_12.normalizeId(id2 || baseId);
      sch = new compile_12.SchemaEnv({ schema: schema2, schemaId, meta, baseId, localRefs });
      this._cache.set(sch.schema, sch);
      if (addSchema && !baseId.startsWith("#")) {
        if (baseId)
          this._checkUnique(baseId);
        this.refs[baseId] = sch;
      }
      if (validateSchema)
        this.validateSchema(schema2, true);
      return sch;
    }
    _checkUnique(id2) {
      if (this.schemas[id2] || this.refs[id2]) {
        throw new Error(`schema with key or id "${id2}" already exists`);
      }
    }
    _compileSchemaEnv(sch) {
      if (sch.meta)
        this._compileMetaSchema(sch);
      else
        compile_12.compileSchema.call(this, sch);
      if (!sch.validate)
        throw new Error("ajv implementation error");
      return sch.validate;
    }
    _compileMetaSchema(sch) {
      const currentOpts = this.opts;
      this.opts = this._metaOpts;
      try {
        compile_12.compileSchema.call(this, sch);
      } finally {
        this.opts = currentOpts;
      }
    }
  }
  exports2.default = Ajv;
  Ajv.ValidationError = validation_error_12.default;
  Ajv.MissingRefError = ref_error_12.default;
  function checkOptions(checkOpts, options, msg, log = "error") {
    for (const key in checkOpts) {
      const opt = key;
      if (opt in options)
        this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
    }
  }
  function getSchEnv(keyRef) {
    keyRef = resolve_12.normalizeId(keyRef);
    return this.schemas[keyRef] || this.refs[keyRef];
  }
  function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
      return;
    if (Array.isArray(optsSchemas))
      this.addSchema(optsSchemas);
    else
      for (const key in optsSchemas)
        this.addSchema(optsSchemas[key], key);
  }
  function addInitialFormats() {
    for (const name in this.opts.formats) {
      const format2 = this.opts.formats[name];
      if (format2)
        this.addFormat(name, format2);
    }
  }
  function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
      this.addVocabulary(defs);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword2 in defs) {
      const def2 = defs[keyword2];
      if (!def2.keyword)
        def2.keyword = keyword2;
      this.addKeyword(def2);
    }
  }
  function getMetaSchemaOptions() {
    const metaOpts = { ...this.opts };
    for (const opt of META_IGNORE_OPTIONS)
      delete metaOpts[opt];
    return metaOpts;
  }
  const noLogs = { log() {
  }, warn() {
  }, error() {
  } };
  function getLogger(logger) {
    if (logger === false)
      return noLogs;
    if (logger === void 0)
      return console;
    if (logger.log && logger.warn && logger.error)
      return logger;
    throw new Error("logger must implement log, warn and error methods");
  }
  const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
  function checkKeyword(keyword2, def2) {
    const { RULES } = this;
    util_12.eachItem(keyword2, (kwd) => {
      if (RULES.keywords[kwd])
        throw new Error(`Keyword ${kwd} is already defined`);
      if (!KEYWORD_NAME.test(kwd))
        throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def2)
      return;
    if (def2.$data && !("code" in def2 || "validate" in def2)) {
      throw new Error('$data keyword must have "code" or "validate" function');
    }
  }
  function addRule(keyword2, definition, dataType2) {
    var _a;
    const post = definition === null || definition === void 0 ? void 0 : definition.post;
    if (dataType2 && post)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t2 }) => t2 === dataType2);
    if (!ruleGroup) {
      ruleGroup = { type: dataType2, rules: [] };
      RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword2] = true;
    if (!definition)
      return;
    const rule = {
      keyword: keyword2,
      definition: {
        ...definition,
        type: dataType_12.getJSONTypes(definition.type),
        schemaType: dataType_12.getJSONTypes(definition.schemaType)
      }
    };
    if (definition.before)
      addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
      ruleGroup.rules.push(rule);
    RULES.all[keyword2] = rule;
    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
  }
  function addBeforeRule(ruleGroup, rule, before) {
    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i >= 0) {
      ruleGroup.rules.splice(i, 0, rule);
    } else {
      ruleGroup.rules.push(rule);
      this.logger.warn(`rule ${before} is not defined`);
    }
  }
  function keywordMetaschema(def2) {
    let { metaSchema } = def2;
    if (metaSchema === void 0)
      return;
    if (def2.$data && this.opts.$data)
      metaSchema = schemaOrData(metaSchema);
    def2.validateSchema = this.compile(metaSchema, true);
  }
  const $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function schemaOrData(schema2) {
    return { anyOf: [schema2, $dataRef] };
  }
})(core$2);
var draft7 = {};
var core$1 = {};
var id = {};
Object.defineProperty(id, "__esModule", { value: true });
const def$s = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
id.default = def$s;
var ref = {};
Object.defineProperty(ref, "__esModule", { value: true });
ref.callRef = ref.getValidate = void 0;
const ref_error_1 = ref_error;
const code_1$8 = code;
const codegen_1$l = codegen;
const names_1$1 = names$1;
const compile_1 = compile;
const util_1$i = util;
const def$r = {
  keyword: "$ref",
  schemaType: "string",
  code(cxt) {
    const { gen, schema: $ref, it } = cxt;
    const { baseId, schemaEnv: env2, validateName, opts: opts2, self: self2 } = it;
    const { root } = env2;
    if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
      return callRootRef();
    const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
    if (schOrEnv === void 0)
      throw new ref_error_1.default(baseId, $ref);
    if (schOrEnv instanceof compile_1.SchemaEnv)
      return callValidate(schOrEnv);
    return inlineRefSchema(schOrEnv);
    function callRootRef() {
      if (env2 === root)
        return callRef(cxt, validateName, env2, env2.$async);
      const rootName = gen.scopeValue("root", { ref: root });
      return callRef(cxt, codegen_1$l._`${rootName}.validate`, root, root.$async);
    }
    function callValidate(sch) {
      const v = getValidate(cxt, sch);
      callRef(cxt, v, sch, sch.$async);
    }
    function inlineRefSchema(sch) {
      const schName = gen.scopeValue("schema", opts2.code.source === true ? { ref: sch, code: codegen_1$l.stringify(sch) } : { ref: sch });
      const valid2 = gen.name("valid");
      const schCxt = cxt.subschema({
        schema: sch,
        dataTypes: [],
        schemaPath: codegen_1$l.nil,
        topSchemaRef: schName,
        errSchemaPath: $ref
      }, valid2);
      cxt.mergeEvaluated(schCxt);
      cxt.ok(valid2);
    }
  }
};
function getValidate(cxt, sch) {
  const { gen } = cxt;
  return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : codegen_1$l._`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
}
ref.getValidate = getValidate;
function callRef(cxt, v, sch, $async) {
  const { gen, it } = cxt;
  const { allErrors, schemaEnv: env2, opts: opts2 } = it;
  const passCxt = opts2.passContext ? names_1$1.default.this : codegen_1$l.nil;
  if ($async)
    callAsyncRef();
  else
    callSyncRef();
  function callAsyncRef() {
    if (!env2.$async)
      throw new Error("async schema referenced by sync schema");
    const valid2 = gen.let("valid");
    gen.try(() => {
      gen.code(codegen_1$l._`await ${code_1$8.callValidateCode(cxt, v, passCxt)}`);
      addEvaluatedFrom(v);
      if (!allErrors)
        gen.assign(valid2, true);
    }, (e) => {
      gen.if(codegen_1$l._`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
      addErrorsFrom(e);
      if (!allErrors)
        gen.assign(valid2, false);
    });
    cxt.ok(valid2);
  }
  function callSyncRef() {
    cxt.result(code_1$8.callValidateCode(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
  }
  function addErrorsFrom(source2) {
    const errs = codegen_1$l._`${source2}.errors`;
    gen.assign(names_1$1.default.vErrors, codegen_1$l._`${names_1$1.default.vErrors} === null ? ${errs} : ${names_1$1.default.vErrors}.concat(${errs})`);
    gen.assign(names_1$1.default.errors, codegen_1$l._`${names_1$1.default.vErrors}.length`);
  }
  function addEvaluatedFrom(source2) {
    var _a;
    if (!it.opts.unevaluated)
      return;
    const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
    if (it.props !== true) {
      if (schEvaluated && !schEvaluated.dynamicProps) {
        if (schEvaluated.props !== void 0) {
          it.props = util_1$i.mergeEvaluated.props(gen, schEvaluated.props, it.props);
        }
      } else {
        const props = gen.var("props", codegen_1$l._`${source2}.evaluated.props`);
        it.props = util_1$i.mergeEvaluated.props(gen, props, it.props, codegen_1$l.Name);
      }
    }
    if (it.items !== true) {
      if (schEvaluated && !schEvaluated.dynamicItems) {
        if (schEvaluated.items !== void 0) {
          it.items = util_1$i.mergeEvaluated.items(gen, schEvaluated.items, it.items);
        }
      } else {
        const items2 = gen.var("items", codegen_1$l._`${source2}.evaluated.items`);
        it.items = util_1$i.mergeEvaluated.items(gen, items2, it.items, codegen_1$l.Name);
      }
    }
  }
}
ref.callRef = callRef;
ref.default = def$r;
Object.defineProperty(core$1, "__esModule", { value: true });
const id_1 = id;
const ref_1 = ref;
const core = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  id_1.default,
  ref_1.default
];
core$1.default = core;
var validation$1 = {};
var limitNumber = {};
Object.defineProperty(limitNumber, "__esModule", { value: true });
const codegen_1$k = codegen;
const ops = codegen_1$k.operators;
const KWDs = {
  maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
  minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
  exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
  exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
};
const error$i = {
  message: ({ keyword: keyword2, schemaCode }) => codegen_1$k.str`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
  params: ({ keyword: keyword2, schemaCode }) => codegen_1$k._`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
};
const def$q = {
  keyword: Object.keys(KWDs),
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$i,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    cxt.fail$data(codegen_1$k._`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
  }
};
limitNumber.default = def$q;
var multipleOf = {};
Object.defineProperty(multipleOf, "__esModule", { value: true });
const codegen_1$j = codegen;
const error$h = {
  message: ({ schemaCode }) => codegen_1$j.str`must be multiple of ${schemaCode}`,
  params: ({ schemaCode }) => codegen_1$j._`{multipleOf: ${schemaCode}}`
};
const def$p = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$h,
  code(cxt) {
    const { gen, data, schemaCode, it } = cxt;
    const prec = it.opts.multipleOfPrecision;
    const res = gen.let("res");
    const invalid = prec ? codegen_1$j._`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : codegen_1$j._`${res} !== parseInt(${res})`;
    cxt.fail$data(codegen_1$j._`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
  }
};
multipleOf.default = def$p;
var limitLength = {};
var ucs2length$1 = {};
Object.defineProperty(ucs2length$1, "__esModule", { value: true });
function ucs2length(str) {
  const len = str.length;
  let length = 0;
  let pos = 0;
  let value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 55296 && value <= 56319 && pos < len) {
      value = str.charCodeAt(pos);
      if ((value & 64512) === 56320)
        pos++;
    }
  }
  return length;
}
ucs2length$1.default = ucs2length;
ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(limitLength, "__esModule", { value: true });
const codegen_1$i = codegen;
const util_1$h = util;
const ucs2length_1 = ucs2length$1;
const error$g = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxLength" ? "more" : "fewer";
    return codegen_1$i.str`must NOT have ${comp} than ${schemaCode} characters`;
  },
  params: ({ schemaCode }) => codegen_1$i._`{limit: ${schemaCode}}`
};
const def$o = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: true,
  error: error$g,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode, it } = cxt;
    const op = keyword2 === "maxLength" ? codegen_1$i.operators.GT : codegen_1$i.operators.LT;
    const len = it.opts.unicode === false ? codegen_1$i._`${data}.length` : codegen_1$i._`${util_1$h.useFunc(cxt.gen, ucs2length_1.default)}(${data})`;
    cxt.fail$data(codegen_1$i._`${len} ${op} ${schemaCode}`);
  }
};
limitLength.default = def$o;
var pattern = {};
Object.defineProperty(pattern, "__esModule", { value: true });
const code_1$7 = code;
const codegen_1$h = codegen;
const error$f = {
  message: ({ schemaCode }) => codegen_1$h.str`must match pattern "${schemaCode}"`,
  params: ({ schemaCode }) => codegen_1$h._`{pattern: ${schemaCode}}`
};
const def$n = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: true,
  error: error$f,
  code(cxt) {
    const { data, $data, schema: schema2, schemaCode, it } = cxt;
    const u2 = it.opts.unicodeRegExp ? "u" : "";
    const regExp = $data ? codegen_1$h._`(new RegExp(${schemaCode}, ${u2}))` : code_1$7.usePattern(cxt, schema2);
    cxt.fail$data(codegen_1$h._`!${regExp}.test(${data})`);
  }
};
pattern.default = def$n;
var limitProperties = {};
Object.defineProperty(limitProperties, "__esModule", { value: true });
const codegen_1$g = codegen;
const error$e = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxProperties" ? "more" : "fewer";
    return codegen_1$g.str`must NOT have ${comp} than ${schemaCode} items`;
  },
  params: ({ schemaCode }) => codegen_1$g._`{limit: ${schemaCode}}`
};
const def$m = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: true,
  error: error$e,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxProperties" ? codegen_1$g.operators.GT : codegen_1$g.operators.LT;
    cxt.fail$data(codegen_1$g._`Object.keys(${data}).length ${op} ${schemaCode}`);
  }
};
limitProperties.default = def$m;
var required = {};
Object.defineProperty(required, "__esModule", { value: true });
const code_1$6 = code;
const codegen_1$f = codegen;
const util_1$g = util;
const error$d = {
  message: ({ params: { missingProperty } }) => codegen_1$f.str`must have required property '${missingProperty}'`,
  params: ({ params: { missingProperty } }) => codegen_1$f._`{missingProperty: ${missingProperty}}`
};
const def$l = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: true,
  error: error$d,
  code(cxt) {
    const { gen, schema: schema2, schemaCode, data, $data, it } = cxt;
    const { opts: opts2 } = it;
    if (!$data && schema2.length === 0)
      return;
    const useLoop = schema2.length >= opts2.loopRequired;
    if (it.allErrors)
      allErrorsMode();
    else
      exitOnErrorMode();
    if (opts2.strictRequired) {
      const props = cxt.parentSchema.properties;
      const { definedProperties } = cxt.it;
      for (const requiredKey of schema2) {
        if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
          const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
          util_1$g.checkStrictMode(it, msg, it.opts.strictRequired);
        }
      }
    }
    function allErrorsMode() {
      if (useLoop || $data) {
        cxt.block$data(codegen_1$f.nil, loopAllRequired);
      } else {
        for (const prop of schema2) {
          code_1$6.checkReportMissingProp(cxt, prop);
        }
      }
    }
    function exitOnErrorMode() {
      const missing = gen.let("missing");
      if (useLoop || $data) {
        const valid2 = gen.let("valid", true);
        cxt.block$data(valid2, () => loopUntilMissing(missing, valid2));
        cxt.ok(valid2);
      } else {
        gen.if(code_1$6.checkMissingProp(cxt, schema2, missing));
        code_1$6.reportMissingProp(cxt, missing);
        gen.else();
      }
    }
    function loopAllRequired() {
      gen.forOf("prop", schemaCode, (prop) => {
        cxt.setParams({ missingProperty: prop });
        gen.if(code_1$6.noPropertyInData(gen, data, prop, opts2.ownProperties), () => cxt.error());
      });
    }
    function loopUntilMissing(missing, valid2) {
      cxt.setParams({ missingProperty: missing });
      gen.forOf(missing, schemaCode, () => {
        gen.assign(valid2, code_1$6.propertyInData(gen, data, missing, opts2.ownProperties));
        gen.if(codegen_1$f.not(valid2), () => {
          cxt.error();
          gen.break();
        });
      }, codegen_1$f.nil);
    }
  }
};
required.default = def$l;
var limitItems = {};
Object.defineProperty(limitItems, "__esModule", { value: true });
const codegen_1$e = codegen;
const error$c = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxItems" ? "more" : "fewer";
    return codegen_1$e.str`must NOT have ${comp} than ${schemaCode} items`;
  },
  params: ({ schemaCode }) => codegen_1$e._`{limit: ${schemaCode}}`
};
const def$k = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: true,
  error: error$c,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxItems" ? codegen_1$e.operators.GT : codegen_1$e.operators.LT;
    cxt.fail$data(codegen_1$e._`${data}.length ${op} ${schemaCode}`);
  }
};
limitItems.default = def$k;
var uniqueItems = {};
var equal$1 = {};
Object.defineProperty(equal$1, "__esModule", { value: true });
const equal2 = fastDeepEqual;
equal2.code = 'require("ajv/dist/runtime/equal").default';
equal$1.default = equal2;
Object.defineProperty(uniqueItems, "__esModule", { value: true });
const dataType_1 = dataType;
const codegen_1$d = codegen;
const util_1$f = util;
const equal_1$2 = equal$1;
const error$b = {
  message: ({ params: { i, j } }) => codegen_1$d.str`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
  params: ({ params: { i, j } }) => codegen_1$d._`{i: ${i}, j: ${j}}`
};
const def$j = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: true,
  error: error$b,
  code(cxt) {
    const { gen, data, $data, schema: schema2, parentSchema, schemaCode, it } = cxt;
    if (!$data && !schema2)
      return;
    const valid2 = gen.let("valid");
    const itemTypes = parentSchema.items ? dataType_1.getSchemaTypes(parentSchema.items) : [];
    cxt.block$data(valid2, validateUniqueItems, codegen_1$d._`${schemaCode} === false`);
    cxt.ok(valid2);
    function validateUniqueItems() {
      const i = gen.let("i", codegen_1$d._`${data}.length`);
      const j = gen.let("j");
      cxt.setParams({ i, j });
      gen.assign(valid2, true);
      gen.if(codegen_1$d._`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
    }
    function canOptimize() {
      return itemTypes.length > 0 && !itemTypes.some((t2) => t2 === "object" || t2 === "array");
    }
    function loopN(i, j) {
      const item = gen.name("item");
      const wrongType = dataType_1.checkDataTypes(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
      const indices = gen.const("indices", codegen_1$d._`{}`);
      gen.for(codegen_1$d._`;${i}--;`, () => {
        gen.let(item, codegen_1$d._`${data}[${i}]`);
        gen.if(wrongType, codegen_1$d._`continue`);
        if (itemTypes.length > 1)
          gen.if(codegen_1$d._`typeof ${item} == "string"`, codegen_1$d._`${item} += "_"`);
        gen.if(codegen_1$d._`typeof ${indices}[${item}] == "number"`, () => {
          gen.assign(j, codegen_1$d._`${indices}[${item}]`);
          cxt.error();
          gen.assign(valid2, false).break();
        }).code(codegen_1$d._`${indices}[${item}] = ${i}`);
      });
    }
    function loopN2(i, j) {
      const eql = util_1$f.useFunc(gen, equal_1$2.default);
      const outer = gen.name("outer");
      gen.label(outer).for(codegen_1$d._`;${i}--;`, () => gen.for(codegen_1$d._`${j} = ${i}; ${j}--;`, () => gen.if(codegen_1$d._`${eql}(${data}[${i}], ${data}[${j}])`, () => {
        cxt.error();
        gen.assign(valid2, false).break(outer);
      })));
    }
  }
};
uniqueItems.default = def$j;
var _const = {};
Object.defineProperty(_const, "__esModule", { value: true });
const codegen_1$c = codegen;
const util_1$e = util;
const equal_1$1 = equal$1;
const error$a = {
  message: "must be equal to constant",
  params: ({ schemaCode }) => codegen_1$c._`{allowedValue: ${schemaCode}}`
};
const def$i = {
  keyword: "const",
  $data: true,
  error: error$a,
  code(cxt) {
    const { gen, data, $data, schemaCode, schema: schema2 } = cxt;
    if ($data || schema2 && typeof schema2 == "object") {
      cxt.fail$data(codegen_1$c._`!${util_1$e.useFunc(gen, equal_1$1.default)}(${data}, ${schemaCode})`);
    } else {
      cxt.fail(codegen_1$c._`${schema2} !== ${data}`);
    }
  }
};
_const.default = def$i;
var _enum = {};
Object.defineProperty(_enum, "__esModule", { value: true });
const codegen_1$b = codegen;
const util_1$d = util;
const equal_1 = equal$1;
const error$9 = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode }) => codegen_1$b._`{allowedValues: ${schemaCode}}`
};
const def$h = {
  keyword: "enum",
  schemaType: "array",
  $data: true,
  error: error$9,
  code(cxt) {
    const { gen, data, $data, schema: schema2, schemaCode, it } = cxt;
    if (!$data && schema2.length === 0)
      throw new Error("enum must have non-empty array");
    const useLoop = schema2.length >= it.opts.loopEnum;
    const eql = util_1$d.useFunc(gen, equal_1.default);
    let valid2;
    if (useLoop || $data) {
      valid2 = gen.let("valid");
      cxt.block$data(valid2, loopEnum);
    } else {
      if (!Array.isArray(schema2))
        throw new Error("ajv implementation error");
      const vSchema = gen.const("vSchema", schemaCode);
      valid2 = codegen_1$b.or(...schema2.map((_x, i) => equalCode(vSchema, i)));
    }
    cxt.pass(valid2);
    function loopEnum() {
      gen.assign(valid2, false);
      gen.forOf("v", schemaCode, (v) => gen.if(codegen_1$b._`${eql}(${data}, ${v})`, () => gen.assign(valid2, true).break()));
    }
    function equalCode(vSchema, i) {
      const sch = schema2[i];
      return typeof sch === "object" && sch !== null ? codegen_1$b._`${eql}(${data}, ${vSchema}[${i}])` : codegen_1$b._`${data} === ${sch}`;
    }
  }
};
_enum.default = def$h;
Object.defineProperty(validation$1, "__esModule", { value: true });
const limitNumber_1 = limitNumber;
const multipleOf_1 = multipleOf;
const limitLength_1 = limitLength;
const pattern_1 = pattern;
const limitProperties_1 = limitProperties;
const required_1 = required;
const limitItems_1 = limitItems;
const uniqueItems_1 = uniqueItems;
const const_1 = _const;
const enum_1 = _enum;
const validation = [
  // number
  limitNumber_1.default,
  multipleOf_1.default,
  // string
  limitLength_1.default,
  pattern_1.default,
  // object
  limitProperties_1.default,
  required_1.default,
  // array
  limitItems_1.default,
  uniqueItems_1.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  const_1.default,
  enum_1.default
];
validation$1.default = validation;
var applicator = {};
var additionalItems = {};
Object.defineProperty(additionalItems, "__esModule", { value: true });
additionalItems.validateAdditionalItems = void 0;
const codegen_1$a = codegen;
const util_1$c = util;
const error$8 = {
  message: ({ params: { len } }) => codegen_1$a.str`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => codegen_1$a._`{limit: ${len}}`
};
const def$g = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: error$8,
  code(cxt) {
    const { parentSchema, it } = cxt;
    const { items: items2 } = parentSchema;
    if (!Array.isArray(items2)) {
      util_1$c.checkStrictMode(it, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    validateAdditionalItems(cxt, items2);
  }
};
function validateAdditionalItems(cxt, items2) {
  const { gen, schema: schema2, data, keyword: keyword2, it } = cxt;
  it.items = true;
  const len = gen.const("len", codegen_1$a._`${data}.length`);
  if (schema2 === false) {
    cxt.setParams({ len: items2.length });
    cxt.pass(codegen_1$a._`${len} <= ${items2.length}`);
  } else if (typeof schema2 == "object" && !util_1$c.alwaysValidSchema(it, schema2)) {
    const valid2 = gen.var("valid", codegen_1$a._`${len} <= ${items2.length}`);
    gen.if(codegen_1$a.not(valid2), () => validateItems(valid2));
    cxt.ok(valid2);
  }
  function validateItems(valid2) {
    gen.forRange("i", items2.length, len, (i) => {
      cxt.subschema({ keyword: keyword2, dataProp: i, dataPropType: util_1$c.Type.Num }, valid2);
      if (!it.allErrors)
        gen.if(codegen_1$a.not(valid2), () => gen.break());
    });
  }
}
additionalItems.validateAdditionalItems = validateAdditionalItems;
additionalItems.default = def$g;
var prefixItems = {};
var items = {};
Object.defineProperty(items, "__esModule", { value: true });
items.validateTuple = void 0;
const codegen_1$9 = codegen;
const util_1$b = util;
const code_1$5 = code;
const def$f = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(cxt) {
    const { schema: schema2, it } = cxt;
    if (Array.isArray(schema2))
      return validateTuple(cxt, "additionalItems", schema2);
    it.items = true;
    if (util_1$b.alwaysValidSchema(it, schema2))
      return;
    cxt.ok(code_1$5.validateArray(cxt));
  }
};
function validateTuple(cxt, extraItems, schArr = cxt.schema) {
  const { gen, parentSchema, data, keyword: keyword2, it } = cxt;
  checkStrictTuple(parentSchema);
  if (it.opts.unevaluated && schArr.length && it.items !== true) {
    it.items = util_1$b.mergeEvaluated.items(gen, schArr.length, it.items);
  }
  const valid2 = gen.name("valid");
  const len = gen.const("len", codegen_1$9._`${data}.length`);
  schArr.forEach((sch, i) => {
    if (util_1$b.alwaysValidSchema(it, sch))
      return;
    gen.if(codegen_1$9._`${len} > ${i}`, () => cxt.subschema({
      keyword: keyword2,
      schemaProp: i,
      dataProp: i
    }, valid2));
    cxt.ok(valid2);
  });
  function checkStrictTuple(sch) {
    const { opts: opts2, errSchemaPath } = it;
    const l = schArr.length;
    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
    if (opts2.strictTuples && !fullTuple) {
      const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
      util_1$b.checkStrictMode(it, msg, opts2.strictTuples);
    }
  }
}
items.validateTuple = validateTuple;
items.default = def$f;
Object.defineProperty(prefixItems, "__esModule", { value: true });
const items_1$1 = items;
const def$e = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (cxt) => items_1$1.validateTuple(cxt, "items")
};
prefixItems.default = def$e;
var items2020 = {};
Object.defineProperty(items2020, "__esModule", { value: true });
const codegen_1$8 = codegen;
const util_1$a = util;
const code_1$4 = code;
const additionalItems_1$1 = additionalItems;
const error$7 = {
  message: ({ params: { len } }) => codegen_1$8.str`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => codegen_1$8._`{limit: ${len}}`
};
const def$d = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: error$7,
  code(cxt) {
    const { schema: schema2, parentSchema, it } = cxt;
    const { prefixItems: prefixItems2 } = parentSchema;
    it.items = true;
    if (util_1$a.alwaysValidSchema(it, schema2))
      return;
    if (prefixItems2)
      additionalItems_1$1.validateAdditionalItems(cxt, prefixItems2);
    else
      cxt.ok(code_1$4.validateArray(cxt));
  }
};
items2020.default = def$d;
var contains = {};
Object.defineProperty(contains, "__esModule", { value: true });
const codegen_1$7 = codegen;
const util_1$9 = util;
const error$6 = {
  message: ({ params: { min, max } }) => max === void 0 ? codegen_1$7.str`must contain at least ${min} valid item(s)` : codegen_1$7.str`must contain at least ${min} and no more than ${max} valid item(s)`,
  params: ({ params: { min, max } }) => max === void 0 ? codegen_1$7._`{minContains: ${min}}` : codegen_1$7._`{minContains: ${min}, maxContains: ${max}}`
};
const def$c = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: true,
  error: error$6,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, it } = cxt;
    let min;
    let max;
    const { minContains, maxContains } = parentSchema;
    if (it.opts.next) {
      min = minContains === void 0 ? 1 : minContains;
      max = maxContains;
    } else {
      min = 1;
    }
    const len = gen.const("len", codegen_1$7._`${data}.length`);
    cxt.setParams({ min, max });
    if (max === void 0 && min === 0) {
      util_1$9.checkStrictMode(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
      return;
    }
    if (max !== void 0 && min > max) {
      util_1$9.checkStrictMode(it, `"minContains" > "maxContains" is always invalid`);
      cxt.fail();
      return;
    }
    if (util_1$9.alwaysValidSchema(it, schema2)) {
      let cond = codegen_1$7._`${len} >= ${min}`;
      if (max !== void 0)
        cond = codegen_1$7._`${cond} && ${len} <= ${max}`;
      cxt.pass(cond);
      return;
    }
    it.items = true;
    const valid2 = gen.name("valid");
    if (max === void 0 && min === 1) {
      validateItems(valid2, () => gen.if(valid2, () => gen.break()));
    } else {
      gen.let(valid2, false);
      const schValid = gen.name("_valid");
      const count = gen.let("count", 0);
      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
    }
    cxt.result(valid2, () => cxt.reset());
    function validateItems(_valid, block) {
      gen.forRange("i", 0, len, (i) => {
        cxt.subschema({
          keyword: "contains",
          dataProp: i,
          dataPropType: util_1$9.Type.Num,
          compositeRule: true
        }, _valid);
        block();
      });
    }
    function checkLimits(count) {
      gen.code(codegen_1$7._`${count}++`);
      if (max === void 0) {
        gen.if(codegen_1$7._`${count} >= ${min}`, () => gen.assign(valid2, true).break());
      } else {
        gen.if(codegen_1$7._`${count} > ${max}`, () => gen.assign(valid2, false).break());
        if (min === 1)
          gen.assign(valid2, true);
        else
          gen.if(codegen_1$7._`${count} >= ${min}`, () => gen.assign(valid2, true));
      }
    }
  }
};
contains.default = def$c;
var dependencies = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.validateSchemaDeps = exports2.validatePropertyDeps = exports2.error = void 0;
  const codegen_12 = codegen;
  const util_12 = util;
  const code_12 = code;
  exports2.error = {
    message: ({ params: { property, depsCount, deps } }) => {
      const property_ies = depsCount === 1 ? "property" : "properties";
      return codegen_12.str`must have ${property_ies} ${deps} when property ${property} is present`;
    },
    params: ({ params: { property, depsCount, deps, missingProperty } }) => codegen_12._`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
    // TODO change to reference
  };
  const def2 = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports2.error,
    code(cxt) {
      const [propDeps, schDeps] = splitDependencies(cxt);
      validatePropertyDeps(cxt, propDeps);
      validateSchemaDeps(cxt, schDeps);
    }
  };
  function splitDependencies({ schema: schema2 }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key in schema2) {
      if (key === "__proto__")
        continue;
      const deps = Array.isArray(schema2[key]) ? propertyDeps : schemaDeps;
      deps[key] = schema2[key];
    }
    return [propertyDeps, schemaDeps];
  }
  function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
    const { gen, data, it } = cxt;
    if (Object.keys(propertyDeps).length === 0)
      return;
    const missing = gen.let("missing");
    for (const prop in propertyDeps) {
      const deps = propertyDeps[prop];
      if (deps.length === 0)
        continue;
      const hasProperty = code_12.propertyInData(gen, data, prop, it.opts.ownProperties);
      cxt.setParams({
        property: prop,
        depsCount: deps.length,
        deps: deps.join(", ")
      });
      if (it.allErrors) {
        gen.if(hasProperty, () => {
          for (const depProp of deps) {
            code_12.checkReportMissingProp(cxt, depProp);
          }
        });
      } else {
        gen.if(codegen_12._`${hasProperty} && (${code_12.checkMissingProp(cxt, deps, missing)})`);
        code_12.reportMissingProp(cxt, missing);
        gen.else();
      }
    }
  }
  exports2.validatePropertyDeps = validatePropertyDeps;
  function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
    const { gen, data, keyword: keyword2, it } = cxt;
    const valid2 = gen.name("valid");
    for (const prop in schemaDeps) {
      if (util_12.alwaysValidSchema(it, schemaDeps[prop]))
        continue;
      gen.if(
        code_12.propertyInData(gen, data, prop, it.opts.ownProperties),
        () => {
          const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid2);
          cxt.mergeValidEvaluated(schCxt, valid2);
        },
        () => gen.var(valid2, true)
        // TODO var
      );
      cxt.ok(valid2);
    }
  }
  exports2.validateSchemaDeps = validateSchemaDeps;
  exports2.default = def2;
})(dependencies);
var propertyNames = {};
Object.defineProperty(propertyNames, "__esModule", { value: true });
const codegen_1$6 = codegen;
const util_1$8 = util;
const error$5 = {
  message: "property name must be valid",
  params: ({ params }) => codegen_1$6._`{propertyName: ${params.propertyName}}`
};
const def$b = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: error$5,
  code(cxt) {
    const { gen, schema: schema2, data, it } = cxt;
    if (util_1$8.alwaysValidSchema(it, schema2))
      return;
    const valid2 = gen.name("valid");
    gen.forIn("key", data, (key) => {
      cxt.setParams({ propertyName: key });
      cxt.subschema({
        keyword: "propertyNames",
        data: key,
        dataTypes: ["string"],
        propertyName: key,
        compositeRule: true
      }, valid2);
      gen.if(codegen_1$6.not(valid2), () => {
        cxt.error(true);
        if (!it.allErrors)
          gen.break();
      });
    });
    cxt.ok(valid2);
  }
};
propertyNames.default = def$b;
var additionalProperties = {};
Object.defineProperty(additionalProperties, "__esModule", { value: true });
const code_1$3 = code;
const codegen_1$5 = codegen;
const names_1 = names$1;
const util_1$7 = util;
const error$4 = {
  message: "must NOT have additional properties",
  params: ({ params }) => codegen_1$5._`{additionalProperty: ${params.additionalProperty}}`
};
const def$a = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: true,
  trackErrors: true,
  error: error$4,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, errsCount, it } = cxt;
    if (!errsCount)
      throw new Error("ajv implementation error");
    const { allErrors, opts: opts2 } = it;
    it.props = true;
    if (opts2.removeAdditional !== "all" && util_1$7.alwaysValidSchema(it, schema2))
      return;
    const props = code_1$3.allSchemaProperties(parentSchema.properties);
    const patProps = code_1$3.allSchemaProperties(parentSchema.patternProperties);
    checkAdditionalProperties();
    cxt.ok(codegen_1$5._`${errsCount} === ${names_1.default.errors}`);
    function checkAdditionalProperties() {
      gen.forIn("key", data, (key) => {
        if (!props.length && !patProps.length)
          additionalPropertyCode(key);
        else
          gen.if(isAdditional(key), () => additionalPropertyCode(key));
      });
    }
    function isAdditional(key) {
      let definedProp;
      if (props.length > 8) {
        const propsSchema = util_1$7.schemaRefOrVal(it, parentSchema.properties, "properties");
        definedProp = code_1$3.isOwnProperty(gen, propsSchema, key);
      } else if (props.length) {
        definedProp = codegen_1$5.or(...props.map((p) => codegen_1$5._`${key} === ${p}`));
      } else {
        definedProp = codegen_1$5.nil;
      }
      if (patProps.length) {
        definedProp = codegen_1$5.or(definedProp, ...patProps.map((p) => codegen_1$5._`${code_1$3.usePattern(cxt, p)}.test(${key})`));
      }
      return codegen_1$5.not(definedProp);
    }
    function deleteAdditional(key) {
      gen.code(codegen_1$5._`delete ${data}[${key}]`);
    }
    function additionalPropertyCode(key) {
      if (opts2.removeAdditional === "all" || opts2.removeAdditional && schema2 === false) {
        deleteAdditional(key);
        return;
      }
      if (schema2 === false) {
        cxt.setParams({ additionalProperty: key });
        cxt.error();
        if (!allErrors)
          gen.break();
        return;
      }
      if (typeof schema2 == "object" && !util_1$7.alwaysValidSchema(it, schema2)) {
        const valid2 = gen.name("valid");
        if (opts2.removeAdditional === "failing") {
          applyAdditionalSchema(key, valid2, false);
          gen.if(codegen_1$5.not(valid2), () => {
            cxt.reset();
            deleteAdditional(key);
          });
        } else {
          applyAdditionalSchema(key, valid2);
          if (!allErrors)
            gen.if(codegen_1$5.not(valid2), () => gen.break());
        }
      }
    }
    function applyAdditionalSchema(key, valid2, errors2) {
      const subschema2 = {
        keyword: "additionalProperties",
        dataProp: key,
        dataPropType: util_1$7.Type.Str
      };
      if (errors2 === false) {
        Object.assign(subschema2, {
          compositeRule: true,
          createErrors: false,
          allErrors: false
        });
      }
      cxt.subschema(subschema2, valid2);
    }
  }
};
additionalProperties.default = def$a;
var properties$1 = {};
Object.defineProperty(properties$1, "__esModule", { value: true });
const validate_1 = validate;
const code_1$2 = code;
const util_1$6 = util;
const additionalProperties_1$1 = additionalProperties;
const def$9 = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, it } = cxt;
    if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
      additionalProperties_1$1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1$1.default, "additionalProperties"));
    }
    const allProps = code_1$2.allSchemaProperties(schema2);
    for (const prop of allProps) {
      it.definedProperties.add(prop);
    }
    if (it.opts.unevaluated && allProps.length && it.props !== true) {
      it.props = util_1$6.mergeEvaluated.props(gen, util_1$6.toHash(allProps), it.props);
    }
    const properties2 = allProps.filter((p) => !util_1$6.alwaysValidSchema(it, schema2[p]));
    if (properties2.length === 0)
      return;
    const valid2 = gen.name("valid");
    for (const prop of properties2) {
      if (hasDefault(prop)) {
        applyPropertySchema(prop);
      } else {
        gen.if(code_1$2.propertyInData(gen, data, prop, it.opts.ownProperties));
        applyPropertySchema(prop);
        if (!it.allErrors)
          gen.else().var(valid2, true);
        gen.endIf();
      }
      cxt.it.definedProperties.add(prop);
      cxt.ok(valid2);
    }
    function hasDefault(prop) {
      return it.opts.useDefaults && !it.compositeRule && schema2[prop].default !== void 0;
    }
    function applyPropertySchema(prop) {
      cxt.subschema({
        keyword: "properties",
        schemaProp: prop,
        dataProp: prop
      }, valid2);
    }
  }
};
properties$1.default = def$9;
var patternProperties = {};
Object.defineProperty(patternProperties, "__esModule", { value: true });
const code_1$1 = code;
const codegen_1$4 = codegen;
const util_1$5 = util;
const util_2 = util;
const def$8 = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema: schema2, data, parentSchema, it } = cxt;
    const { opts: opts2 } = it;
    const patterns = code_1$1.allSchemaProperties(schema2);
    const alwaysValidPatterns = patterns.filter((p) => util_1$5.alwaysValidSchema(it, schema2[p]));
    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
      return;
    }
    const checkProperties = opts2.strictSchema && !opts2.allowMatchingProperties && parentSchema.properties;
    const valid2 = gen.name("valid");
    if (it.props !== true && !(it.props instanceof codegen_1$4.Name)) {
      it.props = util_2.evaluatedPropsToName(gen, it.props);
    }
    const { props } = it;
    validatePatternProperties();
    function validatePatternProperties() {
      for (const pat of patterns) {
        if (checkProperties)
          checkMatchingProperties(pat);
        if (it.allErrors) {
          validateProperties(pat);
        } else {
          gen.var(valid2, true);
          validateProperties(pat);
          gen.if(valid2);
        }
      }
    }
    function checkMatchingProperties(pat) {
      for (const prop in checkProperties) {
        if (new RegExp(pat).test(prop)) {
          util_1$5.checkStrictMode(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
        }
      }
    }
    function validateProperties(pat) {
      gen.forIn("key", data, (key) => {
        gen.if(codegen_1$4._`${code_1$1.usePattern(cxt, pat)}.test(${key})`, () => {
          const alwaysValid = alwaysValidPatterns.includes(pat);
          if (!alwaysValid) {
            cxt.subschema({
              keyword: "patternProperties",
              schemaProp: pat,
              dataProp: key,
              dataPropType: util_2.Type.Str
            }, valid2);
          }
          if (it.opts.unevaluated && props !== true) {
            gen.assign(codegen_1$4._`${props}[${key}]`, true);
          } else if (!alwaysValid && !it.allErrors) {
            gen.if(codegen_1$4.not(valid2), () => gen.break());
          }
        });
      });
    }
  }
};
patternProperties.default = def$8;
var not = {};
Object.defineProperty(not, "__esModule", { value: true });
const util_1$4 = util;
const def$7 = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  code(cxt) {
    const { gen, schema: schema2, it } = cxt;
    if (util_1$4.alwaysValidSchema(it, schema2)) {
      cxt.fail();
      return;
    }
    const valid2 = gen.name("valid");
    cxt.subschema({
      keyword: "not",
      compositeRule: true,
      createErrors: false,
      allErrors: false
    }, valid2);
    cxt.failResult(valid2, () => cxt.reset(), () => cxt.error());
  },
  error: { message: "must NOT be valid" }
};
not.default = def$7;
var anyOf = {};
Object.defineProperty(anyOf, "__esModule", { value: true });
const code_1 = code;
const def$6 = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: true,
  code: code_1.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
anyOf.default = def$6;
var oneOf = {};
Object.defineProperty(oneOf, "__esModule", { value: true });
const codegen_1$3 = codegen;
const util_1$3 = util;
const error$3 = {
  message: "must match exactly one schema in oneOf",
  params: ({ params }) => codegen_1$3._`{passingSchemas: ${params.passing}}`
};
const def$5 = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: true,
  error: error$3,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, it } = cxt;
    if (!Array.isArray(schema2))
      throw new Error("ajv implementation error");
    if (it.opts.discriminator && parentSchema.discriminator)
      return;
    const schArr = schema2;
    const valid2 = gen.let("valid", false);
    const passing = gen.let("passing", null);
    const schValid = gen.name("_valid");
    cxt.setParams({ passing });
    gen.block(validateOneOf);
    cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
    function validateOneOf() {
      schArr.forEach((sch, i) => {
        let schCxt;
        if (util_1$3.alwaysValidSchema(it, sch)) {
          gen.var(schValid, true);
        } else {
          schCxt = cxt.subschema({
            keyword: "oneOf",
            schemaProp: i,
            compositeRule: true
          }, schValid);
        }
        if (i > 0) {
          gen.if(codegen_1$3._`${schValid} && ${valid2}`).assign(valid2, false).assign(passing, codegen_1$3._`[${passing}, ${i}]`).else();
        }
        gen.if(schValid, () => {
          gen.assign(valid2, true);
          gen.assign(passing, i);
          if (schCxt)
            cxt.mergeEvaluated(schCxt, codegen_1$3.Name);
        });
      });
    }
  }
};
oneOf.default = def$5;
var allOf = {};
Object.defineProperty(allOf, "__esModule", { value: true });
const util_1$2 = util;
const def$4 = {
  keyword: "allOf",
  schemaType: "array",
  code(cxt) {
    const { gen, schema: schema2, it } = cxt;
    if (!Array.isArray(schema2))
      throw new Error("ajv implementation error");
    const valid2 = gen.name("valid");
    schema2.forEach((sch, i) => {
      if (util_1$2.alwaysValidSchema(it, sch))
        return;
      const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid2);
      cxt.ok(valid2);
      cxt.mergeEvaluated(schCxt);
    });
  }
};
allOf.default = def$4;
var _if = {};
Object.defineProperty(_if, "__esModule", { value: true });
const codegen_1$2 = codegen;
const util_1$1 = util;
const error$2 = {
  message: ({ params }) => codegen_1$2.str`must match "${params.ifClause}" schema`,
  params: ({ params }) => codegen_1$2._`{failingKeyword: ${params.ifClause}}`
};
const def$3 = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  error: error$2,
  code(cxt) {
    const { gen, parentSchema, it } = cxt;
    if (parentSchema.then === void 0 && parentSchema.else === void 0) {
      util_1$1.checkStrictMode(it, '"if" without "then" and "else" is ignored');
    }
    const hasThen = hasSchema(it, "then");
    const hasElse = hasSchema(it, "else");
    if (!hasThen && !hasElse)
      return;
    const valid2 = gen.let("valid", true);
    const schValid = gen.name("_valid");
    validateIf();
    cxt.reset();
    if (hasThen && hasElse) {
      const ifClause = gen.let("ifClause");
      cxt.setParams({ ifClause });
      gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
    } else if (hasThen) {
      gen.if(schValid, validateClause("then"));
    } else {
      gen.if(codegen_1$2.not(schValid), validateClause("else"));
    }
    cxt.pass(valid2, () => cxt.error(true));
    function validateIf() {
      const schCxt = cxt.subschema({
        keyword: "if",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, schValid);
      cxt.mergeEvaluated(schCxt);
    }
    function validateClause(keyword2, ifClause) {
      return () => {
        const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
        gen.assign(valid2, schValid);
        cxt.mergeValidEvaluated(schCxt, valid2);
        if (ifClause)
          gen.assign(ifClause, codegen_1$2._`${keyword2}`);
        else
          cxt.setParams({ ifClause: keyword2 });
      };
    }
  }
};
function hasSchema(it, keyword2) {
  const schema2 = it.schema[keyword2];
  return schema2 !== void 0 && !util_1$1.alwaysValidSchema(it, schema2);
}
_if.default = def$3;
var thenElse = {};
Object.defineProperty(thenElse, "__esModule", { value: true });
const util_1 = util;
const def$2 = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: keyword2, parentSchema, it }) {
    if (parentSchema.if === void 0)
      util_1.checkStrictMode(it, `"${keyword2}" without "if" is ignored`);
  }
};
thenElse.default = def$2;
Object.defineProperty(applicator, "__esModule", { value: true });
const additionalItems_1 = additionalItems;
const prefixItems_1 = prefixItems;
const items_1 = items;
const items2020_1 = items2020;
const contains_1 = contains;
const dependencies_1 = dependencies;
const propertyNames_1 = propertyNames;
const additionalProperties_1 = additionalProperties;
const properties_1 = properties$1;
const patternProperties_1 = patternProperties;
const not_1 = not;
const anyOf_1 = anyOf;
const oneOf_1 = oneOf;
const allOf_1 = allOf;
const if_1 = _if;
const thenElse_1 = thenElse;
function getApplicator(draft2020 = false) {
  const applicator2 = [
    // any
    not_1.default,
    anyOf_1.default,
    oneOf_1.default,
    allOf_1.default,
    if_1.default,
    thenElse_1.default,
    // object
    propertyNames_1.default,
    additionalProperties_1.default,
    dependencies_1.default,
    properties_1.default,
    patternProperties_1.default
  ];
  if (draft2020)
    applicator2.push(prefixItems_1.default, items2020_1.default);
  else
    applicator2.push(additionalItems_1.default, items_1.default);
  applicator2.push(contains_1.default);
  return applicator2;
}
applicator.default = getApplicator;
var format$2 = {};
var format$1 = {};
Object.defineProperty(format$1, "__esModule", { value: true });
const codegen_1$1 = codegen;
const error$1 = {
  message: ({ schemaCode }) => codegen_1$1.str`must match format "${schemaCode}"`,
  params: ({ schemaCode }) => codegen_1$1._`{format: ${schemaCode}}`
};
const def$1 = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: true,
  error: error$1,
  code(cxt, ruleType) {
    const { gen, data, $data, schema: schema2, schemaCode, it } = cxt;
    const { opts: opts2, errSchemaPath, schemaEnv, self: self2 } = it;
    if (!opts2.validateFormats)
      return;
    if ($data)
      validate$DataFormat();
    else
      validateFormat();
    function validate$DataFormat() {
      const fmts = gen.scopeValue("formats", {
        ref: self2.formats,
        code: opts2.code.formats
      });
      const fDef = gen.const("fDef", codegen_1$1._`${fmts}[${schemaCode}]`);
      const fType = gen.let("fType");
      const format2 = gen.let("format");
      gen.if(codegen_1$1._`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, codegen_1$1._`${fDef}.type || "string"`).assign(format2, codegen_1$1._`${fDef}.validate`), () => gen.assign(fType, codegen_1$1._`"string"`).assign(format2, fDef));
      cxt.fail$data(codegen_1$1.or(unknownFmt(), invalidFmt()));
      function unknownFmt() {
        if (opts2.strictSchema === false)
          return codegen_1$1.nil;
        return codegen_1$1._`${schemaCode} && !${format2}`;
      }
      function invalidFmt() {
        const callFormat = schemaEnv.$async ? codegen_1$1._`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : codegen_1$1._`${format2}(${data})`;
        const validData = codegen_1$1._`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
        return codegen_1$1._`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
      }
    }
    function validateFormat() {
      const formatDef = self2.formats[schema2];
      if (!formatDef) {
        unknownFormat();
        return;
      }
      if (formatDef === true)
        return;
      const [fmtType, format2, fmtRef] = getFormat(formatDef);
      if (fmtType === ruleType)
        cxt.pass(validCondition());
      function unknownFormat() {
        if (opts2.strictSchema === false) {
          self2.logger.warn(unknownMsg());
          return;
        }
        throw new Error(unknownMsg());
        function unknownMsg() {
          return `unknown format "${schema2}" ignored in schema at path "${errSchemaPath}"`;
        }
      }
      function getFormat(fmtDef) {
        const code2 = fmtDef instanceof RegExp ? codegen_1$1.regexpCode(fmtDef) : opts2.code.formats ? codegen_1$1._`${opts2.code.formats}${codegen_1$1.getProperty(schema2)}` : void 0;
        const fmt = gen.scopeValue("formats", { key: schema2, ref: fmtDef, code: code2 });
        if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
          return [fmtDef.type || "string", fmtDef.validate, codegen_1$1._`${fmt}.validate`];
        }
        return ["string", fmtDef, fmt];
      }
      function validCondition() {
        if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
          if (!schemaEnv.$async)
            throw new Error("async format in sync schema");
          return codegen_1$1._`await ${fmtRef}(${data})`;
        }
        return typeof format2 == "function" ? codegen_1$1._`${fmtRef}(${data})` : codegen_1$1._`${fmtRef}.test(${data})`;
      }
    }
  }
};
format$1.default = def$1;
Object.defineProperty(format$2, "__esModule", { value: true });
const format_1$1 = format$1;
const format = [format_1$1.default];
format$2.default = format;
var metadata = {};
Object.defineProperty(metadata, "__esModule", { value: true });
metadata.contentVocabulary = metadata.metadataVocabulary = void 0;
metadata.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
metadata.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(draft7, "__esModule", { value: true });
const core_1 = core$1;
const validation_1 = validation$1;
const applicator_1 = applicator;
const format_1 = format$2;
const metadata_1 = metadata;
const draft7Vocabularies = [
  core_1.default,
  validation_1.default,
  applicator_1.default(),
  format_1.default,
  metadata_1.metadataVocabulary,
  metadata_1.contentVocabulary
];
draft7.default = draft7Vocabularies;
var discriminator = {};
var types = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.DiscrError = void 0;
  (function(DiscrError) {
    DiscrError["Tag"] = "tag";
    DiscrError["Mapping"] = "mapping";
  })(exports2.DiscrError || (exports2.DiscrError = {}));
})(types);
Object.defineProperty(discriminator, "__esModule", { value: true });
const codegen_1 = codegen;
const types_1 = types;
const error = {
  message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
  params: ({ params: { discrError, tag, tagName } }) => codegen_1._`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
};
const def = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error,
  code(cxt) {
    const { gen, data, schema: schema2, parentSchema, it } = cxt;
    const { oneOf: oneOf2 } = parentSchema;
    if (!it.opts.discriminator) {
      throw new Error("discriminator: requires discriminator option");
    }
    const tagName = schema2.propertyName;
    if (typeof tagName != "string")
      throw new Error("discriminator: requires propertyName");
    if (schema2.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!oneOf2)
      throw new Error("discriminator: requires oneOf keyword");
    const valid2 = gen.let("valid", false);
    const tag = gen.const("tag", codegen_1._`${data}${codegen_1.getProperty(tagName)}`);
    gen.if(codegen_1._`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
    cxt.ok(valid2);
    function validateMapping() {
      const mapping = getMapping();
      gen.if(false);
      for (const tagValue in mapping) {
        gen.elseIf(codegen_1._`${tag} === ${tagValue}`);
        gen.assign(valid2, applyTagSchema(mapping[tagValue]));
      }
      gen.else();
      cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
      gen.endIf();
    }
    function applyTagSchema(schemaProp) {
      const _valid = gen.name("valid");
      const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
      cxt.mergeEvaluated(schCxt, codegen_1.Name);
      return _valid;
    }
    function getMapping() {
      var _a;
      const oneOfMapping = {};
      const topRequired = hasRequired(parentSchema);
      let tagRequired = true;
      for (let i = 0; i < oneOf2.length; i++) {
        const sch = oneOf2[i];
        const propSch = (_a = sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
        if (typeof propSch != "object") {
          throw new Error(`discriminator: oneOf schemas must have "properties/${tagName}"`);
        }
        tagRequired = tagRequired && (topRequired || hasRequired(sch));
        addMappings(propSch, i);
      }
      if (!tagRequired)
        throw new Error(`discriminator: "${tagName}" must be required`);
      return oneOfMapping;
      function hasRequired({ required: required2 }) {
        return Array.isArray(required2) && required2.includes(tagName);
      }
      function addMappings(sch, i) {
        if (sch.const) {
          addMapping(sch.const, i);
        } else if (sch.enum) {
          for (const tagValue of sch.enum) {
            addMapping(tagValue, i);
          }
        } else {
          throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
        }
      }
      function addMapping(tagValue, i) {
        if (typeof tagValue != "string" || tagValue in oneOfMapping) {
          throw new Error(`discriminator: "${tagName}" values must be unique strings`);
        }
        oneOfMapping[tagValue] = i;
      }
    }
  }
};
discriminator.default = def;
const $schema = "http://json-schema.org/draft-07/schema#";
const $id = "http://json-schema.org/draft-07/schema#";
const title = "Core schema meta-schema";
const definitions = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        "default": 0
      }
    ]
  },
  simpleTypes: {
    "enum": [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: true,
    "default": []
  }
};
const type = [
  "object",
  "boolean"
];
const properties = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  "default": true,
  readOnly: {
    type: "boolean",
    "default": false
  },
  examples: {
    type: "array",
    items: true
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    "default": true
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    "default": false
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    "default": {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  "const": true,
  "enum": {
    type: "array",
    items: true,
    minItems: 1,
    uniqueItems: true
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: true
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  "if": {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  "else": {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
};
const require$$3 = {
  $schema,
  $id,
  title,
  definitions,
  type,
  properties,
  "default": true
};
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
  const core_12 = core$2;
  const draft7_1 = draft7;
  const discriminator_1 = discriminator;
  const draft7MetaSchema = require$$3;
  const META_SUPPORT_DATA = ["/properties"];
  const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
  class Ajv extends core_12.default {
    _addVocabularies() {
      super._addVocabularies();
      draft7_1.default.forEach((v) => this.addVocabulary(v));
      if (this.opts.discriminator)
        this.addKeyword(discriminator_1.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      if (!this.opts.meta)
        return;
      const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
      this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
      this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
    }
  }
  module2.exports = exports2 = Ajv;
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.default = Ajv;
  var validate_12 = validate;
  Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
})(ajv, ajv.exports);
var ajvExports = ajv.exports;
var dist = { exports: {} };
var formats = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.formatNames = exports2.fastFormats = exports2.fullFormats = void 0;
  function fmtDef(validate2, compare2) {
    return { validate: validate2, compare: compare2 };
  }
  exports2.fullFormats = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: fmtDef(date, compareDate),
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: fmtDef(time, compareTime),
    "date-time": fmtDef(date_time, compareDateTime),
    // duration: https://tools.ietf.org/html/rfc3339#appendix-A
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    // uri-template: https://tools.ietf.org/html/rfc6570
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    // For the source: https://gist.github.com/dperini/729294
    // For test cases: https://mathiasbynens.be/demo/url-regex
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex,
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
    // byte: https://github.com/miguelmota/is-base64
    byte,
    // signed 32 bit integer
    int32: { type: "number", validate: validateInt32 },
    // signed 64 bit integer
    int64: { type: "number", validate: validateInt64 },
    // C-type float
    float: { type: "number", validate: validateNumber },
    // C-type double
    double: { type: "number", validate: validateNumber },
    // hint to the UI to hide input strings
    password: true,
    // unchecked string payload
    binary: true
  };
  exports2.fastFormats = {
    ...exports2.fullFormats,
    date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
    time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
    "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
  };
  exports2.formatNames = Object.keys(exports2.fullFormats);
  function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function date(str) {
    const matches = DATE.exec(str);
    if (!matches)
      return false;
    const year = +matches[1];
    const month = +matches[2];
    const day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
  }
  function compareDate(d1, d2) {
    if (!(d1 && d2))
      return void 0;
    if (d1 > d2)
      return 1;
    if (d1 < d2)
      return -1;
    return 0;
  }
  const TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
  function time(str, withTimeZone) {
    const matches = TIME.exec(str);
    if (!matches)
      return false;
    const hour = +matches[1];
    const minute = +matches[2];
    const second = +matches[3];
    const timeZone = matches[5];
    return (hour <= 23 && minute <= 59 && second <= 59 || hour === 23 && minute === 59 && second === 60) && (!withTimeZone || timeZone !== "");
  }
  function compareTime(t1, t2) {
    if (!(t1 && t2))
      return void 0;
    const a1 = TIME.exec(t1);
    const a2 = TIME.exec(t2);
    if (!(a1 && a2))
      return void 0;
    t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
    t2 = a2[1] + a2[2] + a2[3] + (a2[4] || "");
    if (t1 > t2)
      return 1;
    if (t1 < t2)
      return -1;
    return 0;
  }
  const DATE_TIME_SEPARATOR = /t|\s/i;
  function date_time(str) {
    const dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true);
  }
  function compareDateTime(dt1, dt2) {
    if (!(dt1 && dt2))
      return void 0;
    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
    const res = compareDate(d1, d2);
    if (res === void 0)
      return void 0;
    return res || compareTime(t1, t2);
  }
  const NOT_URI_FRAGMENT = /\/|:/;
  const URI2 = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function uri(str) {
    return NOT_URI_FRAGMENT.test(str) && URI2.test(str);
  }
  const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function byte(str) {
    BYTE.lastIndex = 0;
    return BYTE.test(str);
  }
  const MIN_INT32 = -(2 ** 31);
  const MAX_INT32 = 2 ** 31 - 1;
  function validateInt32(value) {
    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
  }
  function validateInt64(value) {
    return Number.isInteger(value);
  }
  function validateNumber() {
    return true;
  }
  const Z_ANCHOR = /[^\\]\\Z/;
  function regex(str) {
    if (Z_ANCHOR.test(str))
      return false;
    try {
      new RegExp(str);
      return true;
    } catch (e) {
      return false;
    }
  }
})(formats);
var limit = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.formatLimitDefinition = void 0;
  const ajv_1 = ajvExports;
  const codegen_12 = codegen;
  const ops2 = codegen_12.operators;
  const KWDs2 = {
    formatMaximum: { okStr: "<=", ok: ops2.LTE, fail: ops2.GT },
    formatMinimum: { okStr: ">=", ok: ops2.GTE, fail: ops2.LT },
    formatExclusiveMaximum: { okStr: "<", ok: ops2.LT, fail: ops2.GTE },
    formatExclusiveMinimum: { okStr: ">", ok: ops2.GT, fail: ops2.LTE }
  };
  const error2 = {
    message: ({ keyword: keyword2, schemaCode }) => codegen_12.str`should be ${KWDs2[keyword2].okStr} ${schemaCode}`,
    params: ({ keyword: keyword2, schemaCode }) => codegen_12._`{comparison: ${KWDs2[keyword2].okStr}, limit: ${schemaCode}}`
  };
  exports2.formatLimitDefinition = {
    keyword: Object.keys(KWDs2),
    type: "string",
    schemaType: "string",
    $data: true,
    error: error2,
    code(cxt) {
      const { gen, data, schemaCode, keyword: keyword2, it } = cxt;
      const { opts: opts2, self: self2 } = it;
      if (!opts2.validateFormats)
        return;
      const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
      if (fCxt.$data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen.scopeValue("formats", {
          ref: self2.formats,
          code: opts2.code.formats
        });
        const fmt = gen.const("fmt", codegen_12._`${fmts}[${fCxt.schemaCode}]`);
        cxt.fail$data(codegen_12.or(codegen_12._`typeof ${fmt} != "object"`, codegen_12._`${fmt} instanceof RegExp`, codegen_12._`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
      }
      function validateFormat() {
        const format2 = fCxt.schema;
        const fmtDef = self2.formats[format2];
        if (!fmtDef || fmtDef === true)
          return;
        if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
          throw new Error(`"${keyword2}": format "${format2}" does not define "compare" function`);
        }
        const fmt = gen.scopeValue("formats", {
          key: format2,
          ref: fmtDef,
          code: opts2.code.formats ? codegen_12._`${opts2.code.formats}${codegen_12.getProperty(format2)}` : void 0
        });
        cxt.fail$data(compareCode(fmt));
      }
      function compareCode(fmt) {
        return codegen_12._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs2[keyword2].fail} 0`;
      }
    },
    dependencies: ["format"]
  };
  const formatLimitPlugin = (ajv2) => {
    ajv2.addKeyword(exports2.formatLimitDefinition);
    return ajv2;
  };
  exports2.default = formatLimitPlugin;
})(limit);
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  const formats_1 = formats;
  const limit_1 = limit;
  const codegen_12 = codegen;
  const fullName = new codegen_12.Name("fullFormats");
  const fastName = new codegen_12.Name("fastFormats");
  const formatsPlugin = (ajv2, opts2 = { keywords: true }) => {
    if (Array.isArray(opts2)) {
      addFormats(ajv2, opts2, formats_1.fullFormats, fullName);
      return ajv2;
    }
    const [formats2, exportName] = opts2.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
    const list = opts2.formats || formats_1.formatNames;
    addFormats(ajv2, list, formats2, exportName);
    if (opts2.keywords)
      limit_1.default(ajv2);
    return ajv2;
  };
  formatsPlugin.get = (name, mode = "full") => {
    const formats2 = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
    const f = formats2[name];
    if (!f)
      throw new Error(`Unknown format "${name}"`);
    return f;
  };
  function addFormats(ajv2, list, fs2, exportName) {
    var _a;
    var _b;
    (_a = (_b = ajv2.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = codegen_12._`require("ajv-formats/dist/formats").${exportName}`;
    for (const f of list)
      ajv2.addFormat(f, fs2[f]);
  }
  module2.exports = exports2 = formatsPlugin;
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.default = formatsPlugin;
})(dist, dist.exports);
var distExports = dist.exports;
const copyProperty = (to, from, property, ignoreNonConfigurable) => {
  if (property === "length" || property === "prototype") {
    return;
  }
  if (property === "arguments" || property === "caller") {
    return;
  }
  const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
  const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
    return;
  }
  Object.defineProperty(to, property, fromDescriptor);
};
const canCopyProperty = function(toDescriptor, fromDescriptor) {
  return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
};
const changePrototype = (to, from) => {
  const fromPrototype = Object.getPrototypeOf(from);
  if (fromPrototype === Object.getPrototypeOf(to)) {
    return;
  }
  Object.setPrototypeOf(to, fromPrototype);
};
const wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
const toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
const toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
const changeToString = (to, from, name) => {
  const withName = name === "" ? "" : `with ${name.trim()}() `;
  const newToString = wrappedToString.bind(null, withName, from.toString());
  Object.defineProperty(newToString, "name", toStringName);
  Object.defineProperty(to, "toString", { ...toStringDescriptor, value: newToString });
};
const mimicFn$4 = (to, from, { ignoreNonConfigurable = false } = {}) => {
  const { name } = to;
  for (const property of Reflect.ownKeys(from)) {
    copyProperty(to, from, property, ignoreNonConfigurable);
  }
  changePrototype(to, from);
  changeToString(to, from, name);
  return to;
};
var mimicFn_1 = mimicFn$4;
const mimicFn$3 = mimicFn_1;
var debounceFn = (inputFunction, options = {}) => {
  if (typeof inputFunction !== "function") {
    throw new TypeError(`Expected the first argument to be a function, got \`${typeof inputFunction}\``);
  }
  const {
    wait = 0,
    before = false,
    after = true
  } = options;
  if (!before && !after) {
    throw new Error("Both `before` and `after` are false, function wouldn't be called.");
  }
  let timeout;
  let result;
  const debouncedFunction = function(...arguments_) {
    const context = this;
    const later = () => {
      timeout = void 0;
      if (after) {
        result = inputFunction.apply(context, arguments_);
      }
    };
    const shouldCallNow = before && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (shouldCallNow) {
      result = inputFunction.apply(context, arguments_);
    }
    return result;
  };
  mimicFn$3(debouncedFunction, inputFunction);
  debouncedFunction.cancel = () => {
    if (timeout) {
      clearTimeout(timeout);
      timeout = void 0;
    }
  };
  return debouncedFunction;
};
var re$3 = { exports: {} };
const SEMVER_SPEC_VERSION = "2.0.0";
const MAX_LENGTH$2 = 256;
const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991;
const MAX_SAFE_COMPONENT_LENGTH = 16;
var constants = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH: MAX_LENGTH$2,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  MAX_SAFE_COMPONENT_LENGTH
};
const debug$1 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
};
var debug_1 = debug$1;
(function(module2, exports2) {
  const { MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2 } = constants;
  const debug2 = debug_1;
  exports2 = module2.exports = {};
  const re2 = exports2.re = [];
  const src = exports2.src = [];
  const t2 = exports2.t = {};
  let R = 0;
  const createToken = (name, value, isGlobal) => {
    const index = R++;
    debug2(index, value);
    t2[name] = index;
    src[index] = value;
    re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
  createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
  createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NUMERICIDENTIFIER]}|${src[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NUMERICIDENTIFIERLOOSE]}|${src[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
  createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`);
  createToken("FULL", `^${src[t2.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`);
  createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:$|[^\\d])`);
  createToken("COERCERTL", src[t2.COERCE], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true);
  exports2.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true);
  exports2.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true);
  exports2.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
})(re$3, re$3.exports);
var reExports = re$3.exports;
const opts = ["includePrerelease", "loose", "rtl"];
const parseOptions$2 = (options) => !options ? {} : typeof options !== "object" ? { loose: true } : opts.filter((k) => options[k]).reduce((options2, k) => {
  options2[k] = true;
  return options2;
}, {});
var parseOptions_1 = parseOptions$2;
const numeric = /^[0-9]+$/;
const compareIdentifiers$1 = (a, b) => {
  const anum = numeric.test(a);
  const bnum = numeric.test(b);
  if (anum && bnum) {
    a = +a;
    b = +b;
  }
  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);
var identifiers = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
const debug = debug_1;
const { MAX_LENGTH: MAX_LENGTH$1, MAX_SAFE_INTEGER } = constants;
const { re: re$2, t: t$2 } = reExports;
const parseOptions$1 = parseOptions_1;
const { compareIdentifiers } = identifiers;
let SemVer$c = class SemVer {
  constructor(version, options) {
    options = parseOptions$1(options);
    if (version instanceof SemVer) {
      if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError(`Invalid Version: ${version}`);
    }
    if (version.length > MAX_LENGTH$1) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH$1} characters`
      );
    }
    debug("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    const m = version.trim().match(options.loose ? re$2[t$2.LOOSE] : re$2[t$2.FULL]);
    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`);
    }
    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map((id2) => {
        if (/^[0-9]+$/.test(id2)) {
          const num = +id2;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id2;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join(".")}`;
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  }
  comparePre(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    let i = 0;
    do {
      const a = this.prerelease[i];
      const b = other.prerelease[i];
      debug("prerelease compare", i, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    let i = 0;
    do {
      const a = this.build[i];
      const b = other.build[i];
      debug("prerelease compare", i, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          let i = this.prerelease.length;
          while (--i >= 0) {
            if (typeof this.prerelease[i] === "number") {
              this.prerelease[i]++;
              i = -2;
            }
          }
          if (i === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error(`invalid increment argument: ${release}`);
    }
    this.format();
    this.raw = this.version;
    return this;
  }
};
var semver$1 = SemVer$c;
const { MAX_LENGTH } = constants;
const { re: re$1, t: t$1 } = reExports;
const SemVer$b = semver$1;
const parseOptions = parseOptions_1;
const parse$5 = (version, options) => {
  options = parseOptions(options);
  if (version instanceof SemVer$b) {
    return version;
  }
  if (typeof version !== "string") {
    return null;
  }
  if (version.length > MAX_LENGTH) {
    return null;
  }
  const r = options.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL];
  if (!r.test(version)) {
    return null;
  }
  try {
    return new SemVer$b(version, options);
  } catch (er) {
    return null;
  }
};
var parse_1 = parse$5;
const parse$4 = parse_1;
const valid$1 = (version, options) => {
  const v = parse$4(version, options);
  return v ? v.version : null;
};
var valid_1 = valid$1;
const parse$3 = parse_1;
const clean = (version, options) => {
  const s = parse$3(version.trim().replace(/^[=v]+/, ""), options);
  return s ? s.version : null;
};
var clean_1 = clean;
const SemVer$a = semver$1;
const inc = (version, release, options, identifier) => {
  if (typeof options === "string") {
    identifier = options;
    options = void 0;
  }
  try {
    return new SemVer$a(version, options).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
};
var inc_1 = inc;
const SemVer$9 = semver$1;
const compare$a = (a, b, loose) => new SemVer$9(a, loose).compare(new SemVer$9(b, loose));
var compare_1 = compare$a;
const compare$9 = compare_1;
const eq$2 = (a, b, loose) => compare$9(a, b, loose) === 0;
var eq_1 = eq$2;
const parse$2 = parse_1;
const eq$1 = eq_1;
const diff = (version1, version2) => {
  if (eq$1(version1, version2)) {
    return null;
  } else {
    const v1 = parse$2(version1);
    const v2 = parse$2(version2);
    const hasPre = v1.prerelease.length || v2.prerelease.length;
    const prefix = hasPre ? "pre" : "";
    const defaultResult = hasPre ? "prerelease" : "";
    for (const key in v1) {
      if (key === "major" || key === "minor" || key === "patch") {
        if (v1[key] !== v2[key]) {
          return prefix + key;
        }
      }
    }
    return defaultResult;
  }
};
var diff_1 = diff;
const SemVer$8 = semver$1;
const major = (a, loose) => new SemVer$8(a, loose).major;
var major_1 = major;
const SemVer$7 = semver$1;
const minor = (a, loose) => new SemVer$7(a, loose).minor;
var minor_1 = minor;
const SemVer$6 = semver$1;
const patch = (a, loose) => new SemVer$6(a, loose).patch;
var patch_1 = patch;
const parse$1 = parse_1;
const prerelease = (version, options) => {
  const parsed = parse$1(version, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
var prerelease_1 = prerelease;
const compare$8 = compare_1;
const rcompare = (a, b, loose) => compare$8(b, a, loose);
var rcompare_1 = rcompare;
const compare$7 = compare_1;
const compareLoose = (a, b) => compare$7(a, b, true);
var compareLoose_1 = compareLoose;
const SemVer$5 = semver$1;
const compareBuild$2 = (a, b, loose) => {
  const versionA = new SemVer$5(a, loose);
  const versionB = new SemVer$5(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
var compareBuild_1 = compareBuild$2;
const compareBuild$1 = compareBuild_1;
const sort = (list, loose) => list.sort((a, b) => compareBuild$1(a, b, loose));
var sort_1 = sort;
const compareBuild = compareBuild_1;
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
var rsort_1 = rsort;
const compare$6 = compare_1;
const gt$3 = (a, b, loose) => compare$6(a, b, loose) > 0;
var gt_1 = gt$3;
const compare$5 = compare_1;
const lt$2 = (a, b, loose) => compare$5(a, b, loose) < 0;
var lt_1 = lt$2;
const compare$4 = compare_1;
const neq$1 = (a, b, loose) => compare$4(a, b, loose) !== 0;
var neq_1 = neq$1;
const compare$3 = compare_1;
const gte$2 = (a, b, loose) => compare$3(a, b, loose) >= 0;
var gte_1 = gte$2;
const compare$2 = compare_1;
const lte$2 = (a, b, loose) => compare$2(a, b, loose) <= 0;
var lte_1 = lte$2;
const eq = eq_1;
const neq = neq_1;
const gt$2 = gt_1;
const gte$1 = gte_1;
const lt$1 = lt_1;
const lte$1 = lte_1;
const cmp = (a, op, b, loose) => {
  switch (op) {
    case "===":
      if (typeof a === "object")
        a = a.version;
      if (typeof b === "object")
        b = b.version;
      return a === b;
    case "!==":
      if (typeof a === "object")
        a = a.version;
      if (typeof b === "object")
        b = b.version;
      return a !== b;
    case "":
    case "=":
    case "==":
      return eq(a, b, loose);
    case "!=":
      return neq(a, b, loose);
    case ">":
      return gt$2(a, b, loose);
    case ">=":
      return gte$1(a, b, loose);
    case "<":
      return lt$1(a, b, loose);
    case "<=":
      return lte$1(a, b, loose);
    default:
      throw new TypeError(`Invalid operator: ${op}`);
  }
};
var cmp_1 = cmp;
const SemVer$4 = semver$1;
const parse = parse_1;
const { re, t } = reExports;
const coerce = (version, options) => {
  if (version instanceof SemVer$4) {
    return version;
  }
  if (typeof version === "number") {
    version = String(version);
  }
  if (typeof version !== "string") {
    return null;
  }
  options = options || {};
  let match = null;
  if (!options.rtl) {
    match = version.match(re[t.COERCE]);
  } else {
    let next;
    while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
    }
    re[t.COERCERTL].lastIndex = -1;
  }
  if (match === null)
    return null;
  return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
};
var coerce_1 = coerce;
var iterator;
var hasRequiredIterator;
function requireIterator() {
  if (hasRequiredIterator)
    return iterator;
  hasRequiredIterator = 1;
  iterator = function(Yallist2) {
    Yallist2.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head; walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
  return iterator;
}
var yallist = Yallist$1;
Yallist$1.Node = Node;
Yallist$1.create = Yallist$1;
function Yallist$1(list) {
  var self2 = this;
  if (!(self2 instanceof Yallist$1)) {
    self2 = new Yallist$1();
  }
  self2.tail = null;
  self2.head = null;
  self2.length = 0;
  if (list && typeof list.forEach === "function") {
    list.forEach(function(item) {
      self2.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self2.push(arguments[i]);
    }
  }
  return self2;
}
Yallist$1.prototype.removeNode = function(node) {
  if (node.list !== this) {
    throw new Error("removing node which does not belong to this list");
  }
  var next = node.next;
  var prev = node.prev;
  if (next) {
    next.prev = prev;
  }
  if (prev) {
    prev.next = next;
  }
  if (node === this.head) {
    this.head = next;
  }
  if (node === this.tail) {
    this.tail = prev;
  }
  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;
  return next;
};
Yallist$1.prototype.unshiftNode = function(node) {
  if (node === this.head) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var head = this.head;
  node.list = this;
  node.next = head;
  if (head) {
    head.prev = node;
  }
  this.head = node;
  if (!this.tail) {
    this.tail = node;
  }
  this.length++;
};
Yallist$1.prototype.pushNode = function(node) {
  if (node === this.tail) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var tail = this.tail;
  node.list = this;
  node.prev = tail;
  if (tail) {
    tail.next = node;
  }
  this.tail = node;
  if (!this.head) {
    this.head = node;
  }
  this.length++;
};
Yallist$1.prototype.push = function() {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i]);
  }
  return this.length;
};
Yallist$1.prototype.unshift = function() {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i]);
  }
  return this.length;
};
Yallist$1.prototype.pop = function() {
  if (!this.tail) {
    return void 0;
  }
  var res = this.tail.value;
  this.tail = this.tail.prev;
  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.shift = function() {
  if (!this.head) {
    return void 0;
  }
  var res = this.head.value;
  this.head = this.head.next;
  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.forEach = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.next;
  }
};
Yallist$1.prototype.forEachReverse = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.prev;
  }
};
Yallist$1.prototype.get = function(n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    walker = walker.next;
  }
  if (i === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.getReverse = function(n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    walker = walker.prev;
  }
  if (i === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.map = function(fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.head; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }
  return res;
};
Yallist$1.prototype.mapReverse = function(fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.tail; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }
  return res;
};
Yallist$1.prototype.reduce = function(fn, initial) {
  var acc;
  var walker = this.head;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i);
    walker = walker.next;
  }
  return acc;
};
Yallist$1.prototype.reduceReverse = function(fn, initial) {
  var acc;
  var walker = this.tail;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i);
    walker = walker.prev;
  }
  return acc;
};
Yallist$1.prototype.toArray = function() {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.next;
  }
  return arr;
};
Yallist$1.prototype.toArrayReverse = function() {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.prev;
  }
  return arr;
};
Yallist$1.prototype.slice = function(from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next;
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.sliceReverse = function(from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev;
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.splice = function(start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1;
  }
  if (start < 0) {
    start = this.length + start;
  }
  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next;
  }
  var ret = [];
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }
  if (walker === null) {
    walker = this.tail;
  }
  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }
  for (var i = 0; i < nodes.length; i++) {
    walker = insert(this, walker, nodes[i]);
  }
  return ret;
};
Yallist$1.prototype.reverse = function() {
  var head = this.head;
  var tail = this.tail;
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }
  this.head = tail;
  this.tail = head;
  return this;
};
function insert(self2, node, value) {
  var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
  if (inserted.next === null) {
    self2.tail = inserted;
  }
  if (inserted.prev === null) {
    self2.head = inserted;
  }
  self2.length++;
  return inserted;
}
function push(self2, item) {
  self2.tail = new Node(item, self2.tail, null, self2);
  if (!self2.head) {
    self2.head = self2.tail;
  }
  self2.length++;
}
function unshift(self2, item) {
  self2.head = new Node(item, null, self2.head, self2);
  if (!self2.tail) {
    self2.tail = self2.head;
  }
  self2.length++;
}
function Node(value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list);
  }
  this.list = list;
  this.value = value;
  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }
  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}
try {
  requireIterator()(Yallist$1);
} catch (er) {
}
const Yallist = yallist;
const MAX = Symbol("max");
const LENGTH = Symbol("length");
const LENGTH_CALCULATOR = Symbol("lengthCalculator");
const ALLOW_STALE = Symbol("allowStale");
const MAX_AGE = Symbol("maxAge");
const DISPOSE = Symbol("dispose");
const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
const LRU_LIST = Symbol("lruList");
const CACHE = Symbol("cache");
const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
const naiveLength = () => 1;
class LRUCache {
  constructor(options) {
    if (typeof options === "number")
      options = { max: options };
    if (!options)
      options = {};
    if (options.max && (typeof options.max !== "number" || options.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[MAX] = options.max || Infinity;
    const lc = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  }
  // resize the cache when the max changes.
  set max(mL) {
    if (typeof mL !== "number" || mL < 0)
      throw new TypeError("max must be a non-negative number");
    this[MAX] = mL || Infinity;
    trim(this);
  }
  get max() {
    return this[MAX];
  }
  set allowStale(allowStale) {
    this[ALLOW_STALE] = !!allowStale;
  }
  get allowStale() {
    return this[ALLOW_STALE];
  }
  set maxAge(mA) {
    if (typeof mA !== "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[MAX_AGE] = mA;
    trim(this);
  }
  get maxAge() {
    return this[MAX_AGE];
  }
  // resize the cache when the lengthCalculator changes.
  set lengthCalculator(lC) {
    if (typeof lC !== "function")
      lC = naiveLength;
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC;
      this[LENGTH] = 0;
      this[LRU_LIST].forEach((hit) => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
        this[LENGTH] += hit.length;
      });
    }
    trim(this);
  }
  get lengthCalculator() {
    return this[LENGTH_CALCULATOR];
  }
  get length() {
    return this[LENGTH];
  }
  get itemCount() {
    return this[LRU_LIST].length;
  }
  rforEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].tail; walker !== null; ) {
      const prev = walker.prev;
      forEachStep(this, fn, walker, thisp);
      walker = prev;
    }
  }
  forEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].head; walker !== null; ) {
      const next = walker.next;
      forEachStep(this, fn, walker, thisp);
      walker = next;
    }
  }
  keys() {
    return this[LRU_LIST].toArray().map((k) => k.key);
  }
  values() {
    return this[LRU_LIST].toArray().map((k) => k.value);
  }
  reset() {
    if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
      this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
    }
    this[CACHE] = /* @__PURE__ */ new Map();
    this[LRU_LIST] = new Yallist();
    this[LENGTH] = 0;
  }
  dump() {
    return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
      k: hit.key,
      v: hit.value,
      e: hit.now + (hit.maxAge || 0)
    }).toArray().filter((h) => h);
  }
  dumpLru() {
    return this[LRU_LIST];
  }
  set(key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE];
    if (maxAge && typeof maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    const now = maxAge ? Date.now() : 0;
    const len = this[LENGTH_CALCULATOR](value, key);
    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key));
        return false;
      }
      const node = this[CACHE].get(key);
      const item = node.value;
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value);
      }
      item.now = now;
      item.maxAge = maxAge;
      item.value = value;
      this[LENGTH] += len - item.length;
      item.length = len;
      this.get(key);
      trim(this);
      return true;
    }
    const hit = new Entry(key, value, len, now, maxAge);
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value);
      return false;
    }
    this[LENGTH] += hit.length;
    this[LRU_LIST].unshift(hit);
    this[CACHE].set(key, this[LRU_LIST].head);
    trim(this);
    return true;
  }
  has(key) {
    if (!this[CACHE].has(key))
      return false;
    const hit = this[CACHE].get(key).value;
    return !isStale(this, hit);
  }
  get(key) {
    return get(this, key, true);
  }
  peek(key) {
    return get(this, key, false);
  }
  pop() {
    const node = this[LRU_LIST].tail;
    if (!node)
      return null;
    del(this, node);
    return node.value;
  }
  del(key) {
    del(this, this[CACHE].get(key));
  }
  load(arr) {
    this.reset();
    const now = Date.now();
    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l];
      const expiresAt = hit.e || 0;
      if (expiresAt === 0)
        this.set(hit.k, hit.v);
      else {
        const maxAge = expiresAt - now;
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge);
        }
      }
    }
  }
  prune() {
    this[CACHE].forEach((value, key) => get(this, key, false));
  }
}
const get = (self2, key, doUse) => {
  const node = self2[CACHE].get(key);
  if (node) {
    const hit = node.value;
    if (isStale(self2, hit)) {
      del(self2, node);
      if (!self2[ALLOW_STALE])
        return void 0;
    } else {
      if (doUse) {
        if (self2[UPDATE_AGE_ON_GET])
          node.value.now = Date.now();
        self2[LRU_LIST].unshiftNode(node);
      }
    }
    return hit.value;
  }
};
const isStale = (self2, hit) => {
  if (!hit || !hit.maxAge && !self2[MAX_AGE])
    return false;
  const diff2 = Date.now() - hit.now;
  return hit.maxAge ? diff2 > hit.maxAge : self2[MAX_AGE] && diff2 > self2[MAX_AGE];
};
const trim = (self2) => {
  if (self2[LENGTH] > self2[MAX]) {
    for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
      const prev = walker.prev;
      del(self2, walker);
      walker = prev;
    }
  }
};
const del = (self2, node) => {
  if (node) {
    const hit = node.value;
    if (self2[DISPOSE])
      self2[DISPOSE](hit.key, hit.value);
    self2[LENGTH] -= hit.length;
    self2[CACHE].delete(hit.key);
    self2[LRU_LIST].removeNode(node);
  }
};
class Entry {
  constructor(key, value, length, now, maxAge) {
    this.key = key;
    this.value = value;
    this.length = length;
    this.now = now;
    this.maxAge = maxAge || 0;
  }
}
const forEachStep = (self2, fn, node, thisp) => {
  let hit = node.value;
  if (isStale(self2, hit)) {
    del(self2, node);
    if (!self2[ALLOW_STALE])
      hit = void 0;
  }
  if (hit)
    fn.call(thisp, hit.value, hit.key, self2);
};
var lruCache = LRUCache;
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange)
    return range;
  hasRequiredRange = 1;
  class Range2 {
    constructor(range2, options) {
      options = parseOptions2(options);
      if (range2 instanceof Range2) {
        if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
          return range2;
        } else {
          return new Range2(range2.raw, options);
        }
      }
      if (range2 instanceof Comparator2) {
        this.raw = range2.value;
        this.set = [[range2]];
        this.format();
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range2;
      this.set = range2.split(/\s*\|\|\s*/).map((range3) => this.parseRange(range3.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${range2}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0)
          this.set = [first];
        else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.format();
    }
    format() {
      this.range = this.set.map((comps) => {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range2) {
      range2 = range2.trim();
      const memoOpts = Object.keys(this.options).join(",");
      const memoKey = `parseRange:${memoOpts}:${range2}`;
      const cached = cache.get(memoKey);
      if (cached)
        return cached;
      const loose = this.options.loose;
      const hr = loose ? re2[t2.HYPHENRANGELOOSE] : re2[t2.HYPHENRANGE];
      range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug2("hyphen replace", range2);
      range2 = range2.replace(re2[t2.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range2, re2[t2.COMPARATORTRIM]);
      range2 = range2.replace(re2[t2.TILDETRIM], tildeTrimReplace);
      range2 = range2.replace(re2[t2.CARETTRIM], caretTrimReplace);
      range2 = range2.split(/\s+/).join(" ");
      const compRe = loose ? re2[t2.COMPARATORLOOSE] : re2[t2.COMPARATOR];
      const rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator2(comp, this.options));
      rangeList.length;
      const rangeMap = /* @__PURE__ */ new Map();
      for (const comp of rangeList) {
        if (isNullSet(comp))
          return [comp];
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has(""))
        rangeMap.delete("");
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range2, options) {
      if (!(range2 instanceof Range2)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer3(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range = Range2;
  const LRU = lruCache;
  const cache = new LRU({ max: 1e3 });
  const parseOptions2 = parseOptions_1;
  const Comparator2 = requireComparator();
  const debug2 = debug_1;
  const SemVer3 = semver$1;
  const {
    re: re2,
    t: t2,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = reExports;
  const isNullSet = (c) => c.value === "<0.0.0-0";
  const isAny = (c) => c.value === "";
  const isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  const parseComparator = (comp, options) => {
    debug2("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug2("caret", comp);
    comp = replaceTildes(comp, options);
    debug2("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug2("xrange", comp);
    comp = replaceStars(comp, options);
    debug2("stars", comp);
    return comp;
  };
  const isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
  const replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
    return replaceTilde(comp2, options);
  }).join(" ");
  const replaceTilde = (comp, options) => {
    const r = options.loose ? re2[t2.TILDELOOSE] : re2[t2.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug2("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug2("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug2("tilde return", ret);
      return ret;
    });
  };
  const replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
    return replaceCaret(comp2, options);
  }).join(" ");
  const replaceCaret = (comp, options) => {
    debug2("caret", comp, options);
    const r = options.loose ? re2[t2.CARETLOOSE] : re2[t2.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug2("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug2("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug2("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug2("caret return", ret);
      return ret;
    });
  };
  const replaceXRanges = (comp, options) => {
    debug2("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((comp2) => {
      return replaceXRange(comp2, options);
    }).join(" ");
  };
  const replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re2[t2.XRANGELOOSE] : re2[t2.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug2("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<")
          pr = "-0";
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug2("xRange return", ret);
      return ret;
    });
  };
  const replaceStars = (comp, options) => {
    debug2("replaceStars", comp, options);
    return comp.trim().replace(re2[t2.STAR], "");
  };
  const replaceGTE0 = (comp, options) => {
    debug2("replaceGTE0", comp, options);
    return comp.trim().replace(re2[options.includePrerelease ? t2.GTE0PRE : t2.GTE0], "");
  };
  const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  const testSet = (set, version, options) => {
    for (let i = 0; i < set.length; i++) {
      if (!set[i].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (let i = 0; i < set.length; i++) {
        debug2(set[i].semver);
        if (set[i].semver === Comparator2.ANY) {
          continue;
        }
        if (set[i].semver.prerelease.length > 0) {
          const allowed = set[i].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range;
}
var comparator;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator)
    return comparator;
  hasRequiredComparator = 1;
  const ANY2 = Symbol("SemVer ANY");
  class Comparator2 {
    static get ANY() {
      return ANY2;
    }
    constructor(comp, options) {
      options = parseOptions2(options);
      if (comp instanceof Comparator2) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      debug2("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY2) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re2[t2.COMPARATORLOOSE] : re2[t2.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY2;
      } else {
        this.semver = new SemVer3(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version) {
      debug2("Comparator.test", version, this.options.loose);
      if (this.semver === ANY2 || version === ANY2) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer3(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp2(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator2)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range2(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range2(this.value, options).test(comp.semver);
      }
      const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      const sameSemVer = this.semver.version === comp.semver.version;
      const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      const oppositeDirectionsLessThan = cmp2(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
      const oppositeDirectionsGreaterThan = cmp2(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    }
  }
  comparator = Comparator2;
  const parseOptions2 = parseOptions_1;
  const { re: re2, t: t2 } = reExports;
  const cmp2 = cmp_1;
  const debug2 = debug_1;
  const SemVer3 = semver$1;
  const Range2 = requireRange();
  return comparator;
}
const Range$8 = requireRange();
const satisfies$3 = (version, range2, options) => {
  try {
    range2 = new Range$8(range2, options);
  } catch (er) {
    return false;
  }
  return range2.test(version);
};
var satisfies_1 = satisfies$3;
const Range$7 = requireRange();
const toComparators = (range2, options) => new Range$7(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
var toComparators_1 = toComparators;
const SemVer$3 = semver$1;
const Range$6 = requireRange();
const maxSatisfying = (versions, range2, options) => {
  let max = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$6(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!max || maxSV.compare(v) === -1) {
        max = v;
        maxSV = new SemVer$3(max, options);
      }
    }
  });
  return max;
};
var maxSatisfying_1 = maxSatisfying;
const SemVer$2 = semver$1;
const Range$5 = requireRange();
const minSatisfying = (versions, range2, options) => {
  let min = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$5(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!min || minSV.compare(v) === 1) {
        min = v;
        minSV = new SemVer$2(min, options);
      }
    }
  });
  return min;
};
var minSatisfying_1 = minSatisfying;
const SemVer$1 = semver$1;
const Range$4 = requireRange();
const gt$1 = gt_1;
const minVersion = (range2, loose) => {
  range2 = new Range$4(range2, loose);
  let minver = new SemVer$1("0.0.0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = new SemVer$1("0.0.0-0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = null;
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let setMin = null;
    comparators.forEach((comparator2) => {
      const compver = new SemVer$1(comparator2.semver.version);
      switch (comparator2.operator) {
        case ">":
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
        case "":
        case ">=":
          if (!setMin || gt$1(compver, setMin)) {
            setMin = compver;
          }
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${comparator2.operator}`);
      }
    });
    if (setMin && (!minver || gt$1(minver, setMin)))
      minver = setMin;
  }
  if (minver && range2.test(minver)) {
    return minver;
  }
  return null;
};
var minVersion_1 = minVersion;
const Range$3 = requireRange();
const validRange = (range2, options) => {
  try {
    return new Range$3(range2, options).range || "*";
  } catch (er) {
    return null;
  }
};
var valid = validRange;
const SemVer2 = semver$1;
const Comparator$1 = requireComparator();
const { ANY: ANY$1 } = Comparator$1;
const Range$2 = requireRange();
const satisfies$2 = satisfies_1;
const gt = gt_1;
const lt = lt_1;
const lte = lte_1;
const gte = gte_1;
const outside$2 = (version, range2, hilo, options) => {
  version = new SemVer2(version, options);
  range2 = new Range$2(range2, options);
  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case ">":
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = ">";
      ecomp = ">=";
      break;
    case "<":
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = "<";
      ecomp = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (satisfies$2(version, range2, options)) {
    return false;
  }
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let high = null;
    let low = null;
    comparators.forEach((comparator2) => {
      if (comparator2.semver === ANY$1) {
        comparator2 = new Comparator$1(">=0.0.0");
      }
      high = high || comparator2;
      low = low || comparator2;
      if (gtfn(comparator2.semver, high.semver, options)) {
        high = comparator2;
      } else if (ltfn(comparator2.semver, low.semver, options)) {
        low = comparator2;
      }
    });
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }
    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }
  return true;
};
var outside_1 = outside$2;
const outside$1 = outside_1;
const gtr = (version, range2, options) => outside$1(version, range2, ">", options);
var gtr_1 = gtr;
const outside = outside_1;
const ltr = (version, range2, options) => outside(version, range2, "<", options);
var ltr_1 = ltr;
const Range$1 = requireRange();
const intersects = (r1, r2, options) => {
  r1 = new Range$1(r1, options);
  r2 = new Range$1(r2, options);
  return r1.intersects(r2);
};
var intersects_1 = intersects;
const satisfies$1 = satisfies_1;
const compare$1 = compare_1;
var simplify = (versions, range2, options) => {
  const set = [];
  let min = null;
  let prev = null;
  const v = versions.sort((a, b) => compare$1(a, b, options));
  for (const version of v) {
    const included = satisfies$1(version, range2, options);
    if (included) {
      prev = version;
      if (!min)
        min = version;
    } else {
      if (prev) {
        set.push([min, prev]);
      }
      prev = null;
      min = null;
    }
  }
  if (min)
    set.push([min, null]);
  const ranges = [];
  for (const [min2, max] of set) {
    if (min2 === max)
      ranges.push(min2);
    else if (!max && min2 === v[0])
      ranges.push("*");
    else if (!max)
      ranges.push(`>=${min2}`);
    else if (min2 === v[0])
      ranges.push(`<=${max}`);
    else
      ranges.push(`${min2} - ${max}`);
  }
  const simplified = ranges.join(" || ");
  const original = typeof range2.raw === "string" ? range2.raw : String(range2);
  return simplified.length < original.length ? simplified : range2;
};
const Range = requireRange();
const Comparator = requireComparator();
const { ANY } = Comparator;
const satisfies = satisfies_1;
const compare = compare_1;
const subset = (sub, dom, options = {}) => {
  if (sub === dom)
    return true;
  sub = new Range(sub, options);
  dom = new Range(dom, options);
  let sawNonNull = false;
  OUTER:
    for (const simpleSub of sub.set) {
      for (const simpleDom of dom.set) {
        const isSub = simpleSubset(simpleSub, simpleDom, options);
        sawNonNull = sawNonNull || isSub !== null;
        if (isSub)
          continue OUTER;
      }
      if (sawNonNull)
        return false;
    }
  return true;
};
const simpleSubset = (sub, dom, options) => {
  if (sub === dom)
    return true;
  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY)
      return true;
    else if (options.includePrerelease)
      sub = [new Comparator(">=0.0.0-0")];
    else
      sub = [new Comparator(">=0.0.0")];
  }
  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease)
      return true;
    else
      dom = [new Comparator(">=0.0.0")];
  }
  const eqSet = /* @__PURE__ */ new Set();
  let gt2, lt2;
  for (const c of sub) {
    if (c.operator === ">" || c.operator === ">=")
      gt2 = higherGT(gt2, c, options);
    else if (c.operator === "<" || c.operator === "<=")
      lt2 = lowerLT(lt2, c, options);
    else
      eqSet.add(c.semver);
  }
  if (eqSet.size > 1)
    return null;
  let gtltComp;
  if (gt2 && lt2) {
    gtltComp = compare(gt2.semver, lt2.semver, options);
    if (gtltComp > 0)
      return null;
    else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<="))
      return null;
  }
  for (const eq2 of eqSet) {
    if (gt2 && !satisfies(eq2, String(gt2), options))
      return null;
    if (lt2 && !satisfies(eq2, String(lt2), options))
      return null;
    for (const c of dom) {
      if (!satisfies(eq2, String(c), options))
        return false;
    }
    return true;
  }
  let higher, lower;
  let hasDomLT, hasDomGT;
  let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
  let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }
  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
    hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
    if (gt2) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false;
        }
      }
      if (c.operator === ">" || c.operator === ">=") {
        higher = higherGT(gt2, c, options);
        if (higher === c && higher !== gt2)
          return false;
      } else if (gt2.operator === ">=" && !satisfies(gt2.semver, String(c), options))
        return false;
    }
    if (lt2) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false;
        }
      }
      if (c.operator === "<" || c.operator === "<=") {
        lower = lowerLT(lt2, c, options);
        if (lower === c && lower !== lt2)
          return false;
      } else if (lt2.operator === "<=" && !satisfies(lt2.semver, String(c), options))
        return false;
    }
    if (!c.operator && (lt2 || gt2) && gtltComp !== 0)
      return false;
  }
  if (gt2 && hasDomLT && !lt2 && gtltComp !== 0)
    return false;
  if (lt2 && hasDomGT && !gt2 && gtltComp !== 0)
    return false;
  if (needDomGTPre || needDomLTPre)
    return false;
  return true;
};
const higherGT = (a, b, options) => {
  if (!a)
    return b;
  const comp = compare(a.semver, b.semver, options);
  return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
};
const lowerLT = (a, b, options) => {
  if (!a)
    return b;
  const comp = compare(a.semver, b.semver, options);
  return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
};
var subset_1 = subset;
const internalRe = reExports;
var semver = {
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  SemVer: semver$1,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers,
  parse: parse_1,
  valid: valid_1,
  clean: clean_1,
  inc: inc_1,
  diff: diff_1,
  major: major_1,
  minor: minor_1,
  patch: patch_1,
  prerelease: prerelease_1,
  compare: compare_1,
  rcompare: rcompare_1,
  compareLoose: compareLoose_1,
  compareBuild: compareBuild_1,
  sort: sort_1,
  rsort: rsort_1,
  gt: gt_1,
  lt: lt_1,
  eq: eq_1,
  neq: neq_1,
  gte: gte_1,
  lte: lte_1,
  cmp: cmp_1,
  coerce: coerce_1,
  Comparator: requireComparator(),
  Range: requireRange(),
  satisfies: satisfies_1,
  toComparators: toComparators_1,
  maxSatisfying: maxSatisfying_1,
  minSatisfying: minSatisfying_1,
  minVersion: minVersion_1,
  validRange: valid,
  outside: outside_1,
  gtr: gtr_1,
  ltr: ltr_1,
  intersects: intersects_1,
  simplifyRange: simplify,
  subset: subset_1
};
var onetime$1 = { exports: {} };
var mimicFn$2 = { exports: {} };
const mimicFn$1 = (to, from) => {
  for (const prop of Reflect.ownKeys(from)) {
    Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
  }
  return to;
};
mimicFn$2.exports = mimicFn$1;
mimicFn$2.exports.default = mimicFn$1;
var mimicFnExports = mimicFn$2.exports;
const mimicFn = mimicFnExports;
const calledFunctions = /* @__PURE__ */ new WeakMap();
const onetime = (function_, options = {}) => {
  if (typeof function_ !== "function") {
    throw new TypeError("Expected a function");
  }
  let returnValue;
  let callCount = 0;
  const functionName = function_.displayName || function_.name || "<anonymous>";
  const onetime2 = function(...arguments_) {
    calledFunctions.set(onetime2, ++callCount);
    if (callCount === 1) {
      returnValue = function_.apply(this, arguments_);
      function_ = null;
    } else if (options.throw === true) {
      throw new Error(`Function \`${functionName}\` can only be called once`);
    }
    return returnValue;
  };
  mimicFn(onetime2, function_);
  calledFunctions.set(onetime2, callCount);
  return onetime2;
};
onetime$1.exports = onetime;
onetime$1.exports.default = onetime;
onetime$1.exports.callCount = (function_) => {
  if (!calledFunctions.has(function_)) {
    throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
  }
  return calledFunctions.get(function_);
};
var onetimeExports = onetime$1.exports;
(function(module2, exports2) {
  var __classPrivateFieldSet = commonjsGlobal && commonjsGlobal.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = commonjsGlobal && commonjsGlobal.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _a, _b;
  var _Conf_validator, _Conf_encryptionKey, _Conf_options, _Conf_defaultValues;
  Object.defineProperty(exports2, "__esModule", { value: true });
  const util_12 = require$$4;
  const fs2 = require$$0$3;
  const path2 = require$$1;
  const crypto = require$$3$1;
  const assert = require$$5;
  const events_1 = require$$5$1;
  const dotProp$1 = dotProp;
  const pkgUp2 = pkgUpExports;
  const envPaths2 = envPathsExports;
  const atomically = dist$1;
  const ajv_1 = ajvExports;
  const ajv_formats_1 = distExports;
  const debounceFn$1 = debounceFn;
  const semver$12 = semver;
  const onetime2 = onetimeExports;
  const encryptionAlgorithm = "aes-256-cbc";
  const createPlainObject = () => {
    return /* @__PURE__ */ Object.create(null);
  };
  const isExist = (data) => {
    return data !== void 0 && data !== null;
  };
  let parentDir = "";
  try {
    delete require.cache[__filename];
    parentDir = path2.dirname((_b = (_a = module2.parent) === null || _a === void 0 ? void 0 : _a.filename) !== null && _b !== void 0 ? _b : ".");
  } catch (_c) {
  }
  const checkValueType = (key, value) => {
    const nonJsonTypes = /* @__PURE__ */ new Set([
      "undefined",
      "symbol",
      "function"
    ]);
    const type2 = typeof value;
    if (nonJsonTypes.has(type2)) {
      throw new TypeError(`Setting a value of type \`${type2}\` for key \`${key}\` is not allowed as it's not supported by JSON`);
    }
  };
  const INTERNAL_KEY = "__internal__";
  const MIGRATION_KEY = `${INTERNAL_KEY}.migrations.version`;
  class Conf2 {
    constructor(partialOptions = {}) {
      var _a2;
      _Conf_validator.set(this, void 0);
      _Conf_encryptionKey.set(this, void 0);
      _Conf_options.set(this, void 0);
      _Conf_defaultValues.set(this, {});
      this._deserialize = (value) => JSON.parse(value);
      this._serialize = (value) => JSON.stringify(value, void 0, "	");
      const options = {
        configName: "config",
        fileExtension: "json",
        projectSuffix: "nodejs",
        clearInvalidConfig: false,
        accessPropertiesByDotNotation: true,
        ...partialOptions
      };
      const getPackageData = onetime2(() => {
        const packagePath = pkgUp2.sync({ cwd: parentDir });
        const packageData = packagePath && JSON.parse(fs2.readFileSync(packagePath, "utf8"));
        return packageData !== null && packageData !== void 0 ? packageData : {};
      });
      if (!options.cwd) {
        if (!options.projectName) {
          options.projectName = getPackageData().name;
        }
        if (!options.projectName) {
          throw new Error("Project name could not be inferred. Please specify the `projectName` option.");
        }
        options.cwd = envPaths2(options.projectName, { suffix: options.projectSuffix }).config;
      }
      __classPrivateFieldSet(this, _Conf_options, options, "f");
      if (options.schema) {
        if (typeof options.schema !== "object") {
          throw new TypeError("The `schema` option must be an object.");
        }
        const ajv2 = new ajv_1.default({
          allErrors: true,
          useDefaults: true
        });
        ajv_formats_1.default(ajv2);
        const schema2 = {
          type: "object",
          properties: options.schema
        };
        __classPrivateFieldSet(this, _Conf_validator, ajv2.compile(schema2), "f");
        for (const [key, value] of Object.entries(options.schema)) {
          if (value === null || value === void 0 ? void 0 : value.default) {
            __classPrivateFieldGet(this, _Conf_defaultValues, "f")[key] = value.default;
          }
        }
      }
      if (options.defaults) {
        __classPrivateFieldSet(this, _Conf_defaultValues, {
          ...__classPrivateFieldGet(this, _Conf_defaultValues, "f"),
          ...options.defaults
        }, "f");
      }
      if (options.serialize) {
        this._serialize = options.serialize;
      }
      if (options.deserialize) {
        this._deserialize = options.deserialize;
      }
      this.events = new events_1.EventEmitter();
      __classPrivateFieldSet(this, _Conf_encryptionKey, options.encryptionKey, "f");
      const fileExtension = options.fileExtension ? `.${options.fileExtension}` : "";
      this.path = path2.resolve(options.cwd, `${(_a2 = options.configName) !== null && _a2 !== void 0 ? _a2 : "config"}${fileExtension}`);
      const fileStore = this.store;
      const store2 = Object.assign(createPlainObject(), options.defaults, fileStore);
      this._validate(store2);
      try {
        assert.deepEqual(fileStore, store2);
      } catch (_b2) {
        this.store = store2;
      }
      if (options.watch) {
        this._watch();
      }
      if (options.migrations) {
        if (!options.projectVersion) {
          options.projectVersion = getPackageData().version;
        }
        if (!options.projectVersion) {
          throw new Error("Project version could not be inferred. Please specify the `projectVersion` option.");
        }
        this._migrate(options.migrations, options.projectVersion);
      }
    }
    get(key, defaultValue) {
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        return this._get(key, defaultValue);
      }
      const { store: store2 } = this;
      return key in store2 ? store2[key] : defaultValue;
    }
    set(key, value) {
      if (typeof key !== "string" && typeof key !== "object") {
        throw new TypeError(`Expected \`key\` to be of type \`string\` or \`object\`, got ${typeof key}`);
      }
      if (typeof key !== "object" && value === void 0) {
        throw new TypeError("Use `delete()` to clear values");
      }
      if (this._containsReservedKey(key)) {
        throw new TypeError(`Please don't use the ${INTERNAL_KEY} key, as it's used to manage this module internal operations.`);
      }
      const { store: store2 } = this;
      const set = (key2, value2) => {
        checkValueType(key2, value2);
        if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
          dotProp$1.set(store2, key2, value2);
        } else {
          store2[key2] = value2;
        }
      };
      if (typeof key === "object") {
        const object = key;
        for (const [key2, value2] of Object.entries(object)) {
          set(key2, value2);
        }
      } else {
        set(key, value);
      }
      this.store = store2;
    }
    /**
    	    Check if an item exists.
    
    	    @param key - The key of the item to check.
    	    */
    has(key) {
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        return dotProp$1.has(this.store, key);
      }
      return key in this.store;
    }
    /**
    	    Reset items to their default values, as defined by the `defaults` or `schema` option.
    
    	    @see `clear()` to reset all items.
    
    	    @param keys - The keys of the items to reset.
    	    */
    reset(...keys) {
      for (const key of keys) {
        if (isExist(__classPrivateFieldGet(this, _Conf_defaultValues, "f")[key])) {
          this.set(key, __classPrivateFieldGet(this, _Conf_defaultValues, "f")[key]);
        }
      }
    }
    /**
    	    Delete an item.
    
    	    @param key - The key of the item to delete.
    	    */
    delete(key) {
      const { store: store2 } = this;
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        dotProp$1.delete(store2, key);
      } else {
        delete store2[key];
      }
      this.store = store2;
    }
    /**
    	    Delete all items.
    
    	    This resets known items to their default values, if defined by the `defaults` or `schema` option.
    	    */
    clear() {
      this.store = createPlainObject();
      for (const key of Object.keys(__classPrivateFieldGet(this, _Conf_defaultValues, "f"))) {
        this.reset(key);
      }
    }
    /**
    	    Watches the given `key`, calling `callback` on any changes.
    
    	    @param key - The key wo watch.
    	    @param callback - A callback function that is called on any changes. When a `key` is first set `oldValue` will be `undefined`, and when a key is deleted `newValue` will be `undefined`.
    	    @returns A function, that when called, will unsubscribe.
    	    */
    onDidChange(key, callback) {
      if (typeof key !== "string") {
        throw new TypeError(`Expected \`key\` to be of type \`string\`, got ${typeof key}`);
      }
      if (typeof callback !== "function") {
        throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof callback}`);
      }
      return this._handleChange(() => this.get(key), callback);
    }
    /**
    	    Watches the whole config object, calling `callback` on any changes.
    
    	    @param callback - A callback function that is called on any changes. When a `key` is first set `oldValue` will be `undefined`, and when a key is deleted `newValue` will be `undefined`.
    	    @returns A function, that when called, will unsubscribe.
    	    */
    onDidAnyChange(callback) {
      if (typeof callback !== "function") {
        throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof callback}`);
      }
      return this._handleChange(() => this.store, callback);
    }
    get size() {
      return Object.keys(this.store).length;
    }
    get store() {
      try {
        const data = fs2.readFileSync(this.path, __classPrivateFieldGet(this, _Conf_encryptionKey, "f") ? null : "utf8");
        const dataString = this._encryptData(data);
        const deserializedData = this._deserialize(dataString);
        this._validate(deserializedData);
        return Object.assign(createPlainObject(), deserializedData);
      } catch (error2) {
        if (error2.code === "ENOENT") {
          this._ensureDirectory();
          return createPlainObject();
        }
        if (__classPrivateFieldGet(this, _Conf_options, "f").clearInvalidConfig && error2.name === "SyntaxError") {
          return createPlainObject();
        }
        throw error2;
      }
    }
    set store(value) {
      this._ensureDirectory();
      this._validate(value);
      this._write(value);
      this.events.emit("change");
    }
    *[(_Conf_validator = /* @__PURE__ */ new WeakMap(), _Conf_encryptionKey = /* @__PURE__ */ new WeakMap(), _Conf_options = /* @__PURE__ */ new WeakMap(), _Conf_defaultValues = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
      for (const [key, value] of Object.entries(this.store)) {
        yield [key, value];
      }
    }
    _encryptData(data) {
      if (!__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
        return data.toString();
      }
      try {
        if (__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
          try {
            if (data.slice(16, 17).toString() === ":") {
              const initializationVector = data.slice(0, 16);
              const password = crypto.pbkdf2Sync(__classPrivateFieldGet(this, _Conf_encryptionKey, "f"), initializationVector.toString(), 1e4, 32, "sha512");
              const decipher = crypto.createDecipheriv(encryptionAlgorithm, password, initializationVector);
              data = Buffer.concat([decipher.update(Buffer.from(data.slice(17))), decipher.final()]).toString("utf8");
            } else {
              const decipher = crypto.createDecipher(encryptionAlgorithm, __classPrivateFieldGet(this, _Conf_encryptionKey, "f"));
              data = Buffer.concat([decipher.update(Buffer.from(data)), decipher.final()]).toString("utf8");
            }
          } catch (_a2) {
          }
        }
      } catch (_b2) {
      }
      return data.toString();
    }
    _handleChange(getter, callback) {
      let currentValue = getter();
      const onChange = () => {
        const oldValue = currentValue;
        const newValue = getter();
        if (util_12.isDeepStrictEqual(newValue, oldValue)) {
          return;
        }
        currentValue = newValue;
        callback.call(this, newValue, oldValue);
      };
      this.events.on("change", onChange);
      return () => this.events.removeListener("change", onChange);
    }
    _validate(data) {
      if (!__classPrivateFieldGet(this, _Conf_validator, "f")) {
        return;
      }
      const valid2 = __classPrivateFieldGet(this, _Conf_validator, "f").call(this, data);
      if (valid2 || !__classPrivateFieldGet(this, _Conf_validator, "f").errors) {
        return;
      }
      const errors2 = __classPrivateFieldGet(this, _Conf_validator, "f").errors.map(({ instancePath, message = "" }) => `\`${instancePath.slice(1)}\` ${message}`);
      throw new Error("Config schema violation: " + errors2.join("; "));
    }
    _ensureDirectory() {
      fs2.mkdirSync(path2.dirname(this.path), { recursive: true });
    }
    _write(value) {
      let data = this._serialize(value);
      if (__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
        const initializationVector = crypto.randomBytes(16);
        const password = crypto.pbkdf2Sync(__classPrivateFieldGet(this, _Conf_encryptionKey, "f"), initializationVector.toString(), 1e4, 32, "sha512");
        const cipher = crypto.createCipheriv(encryptionAlgorithm, password, initializationVector);
        data = Buffer.concat([initializationVector, Buffer.from(":"), cipher.update(Buffer.from(data)), cipher.final()]);
      }
      if (process.env.SNAP) {
        fs2.writeFileSync(this.path, data);
      } else {
        try {
          atomically.writeFileSync(this.path, data);
        } catch (error2) {
          if (error2.code === "EXDEV") {
            fs2.writeFileSync(this.path, data);
            return;
          }
          throw error2;
        }
      }
    }
    _watch() {
      this._ensureDirectory();
      if (!fs2.existsSync(this.path)) {
        this._write(createPlainObject());
      }
      if (process.platform === "win32") {
        fs2.watch(this.path, { persistent: false }, debounceFn$1(() => {
          this.events.emit("change");
        }, { wait: 100 }));
      } else {
        fs2.watchFile(this.path, { persistent: false }, debounceFn$1(() => {
          this.events.emit("change");
        }, { wait: 5e3 }));
      }
    }
    _migrate(migrations, versionToMigrate) {
      let previousMigratedVersion = this._get(MIGRATION_KEY, "0.0.0");
      const newerVersions = Object.keys(migrations).filter((candidateVersion) => this._shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate));
      let storeBackup = { ...this.store };
      for (const version of newerVersions) {
        try {
          const migration = migrations[version];
          migration(this);
          this._set(MIGRATION_KEY, version);
          previousMigratedVersion = version;
          storeBackup = { ...this.store };
        } catch (error2) {
          this.store = storeBackup;
          throw new Error(`Something went wrong during the migration! Changes applied to the store until this failed migration will be restored. ${error2}`);
        }
      }
      if (this._isVersionInRangeFormat(previousMigratedVersion) || !semver$12.eq(previousMigratedVersion, versionToMigrate)) {
        this._set(MIGRATION_KEY, versionToMigrate);
      }
    }
    _containsReservedKey(key) {
      if (typeof key === "object") {
        const firsKey = Object.keys(key)[0];
        if (firsKey === INTERNAL_KEY) {
          return true;
        }
      }
      if (typeof key !== "string") {
        return false;
      }
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        if (key.startsWith(`${INTERNAL_KEY}.`)) {
          return true;
        }
        return false;
      }
      return false;
    }
    _isVersionInRangeFormat(version) {
      return semver$12.clean(version) === null;
    }
    _shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate) {
      if (this._isVersionInRangeFormat(candidateVersion)) {
        if (previousMigratedVersion !== "0.0.0" && semver$12.satisfies(previousMigratedVersion, candidateVersion)) {
          return false;
        }
        return semver$12.satisfies(versionToMigrate, candidateVersion);
      }
      if (semver$12.lte(candidateVersion, previousMigratedVersion)) {
        return false;
      }
      if (semver$12.gt(candidateVersion, versionToMigrate)) {
        return false;
      }
      return true;
    }
    _get(key, defaultValue) {
      return dotProp$1.get(this.store, key, defaultValue);
    }
    _set(key, value) {
      const { store: store2 } = this;
      dotProp$1.set(store2, key, value);
      this.store = store2;
    }
  }
  exports2.default = Conf2;
  module2.exports = Conf2;
  module2.exports.default = Conf2;
})(source, source.exports);
var sourceExports = source.exports;
const path = require$$1;
const { app, ipcMain, ipcRenderer, shell } = require$$0;
const Conf = sourceExports;
let isInitialized = false;
const initDataListener = () => {
  if (!ipcMain || !app) {
    throw new Error("Electron Store: You need to call `.initRenderer()` from the main process.");
  }
  const appData = {
    defaultCwd: app.getPath("userData"),
    appVersion: app.getVersion()
  };
  if (isInitialized) {
    return appData;
  }
  ipcMain.on("electron-store-get-data", (event) => {
    event.returnValue = appData;
  });
  isInitialized = true;
  return appData;
};
class ElectronStore extends Conf {
  constructor(options) {
    let defaultCwd;
    let appVersion;
    if (ipcRenderer) {
      const appData = ipcRenderer.sendSync("electron-store-get-data");
      if (!appData) {
        throw new Error("Electron Store: You need to call `.initRenderer()` from the main process.");
      }
      ({ defaultCwd, appVersion } = appData);
    } else if (ipcMain && app) {
      ({ defaultCwd, appVersion } = initDataListener());
    }
    options = {
      name: "config",
      ...options
    };
    if (!options.projectVersion) {
      options.projectVersion = appVersion;
    }
    if (options.cwd) {
      options.cwd = path.isAbsolute(options.cwd) ? options.cwd : path.join(defaultCwd, options.cwd);
    } else {
      options.cwd = defaultCwd;
    }
    options.configName = options.name;
    delete options.name;
    super(options);
  }
  static initRenderer() {
    initDataListener();
  }
  openInEditor() {
    shell.openPath(this.path);
  }
}
var electronStore = ElectronStore;
const Store = /* @__PURE__ */ getDefaultExportFromCjs(electronStore);
var define_import_meta_env_default$1 = { VITE_DEV_SERVER_URL: "http://localhost:5173/", BASE_URL: "/", MODE: "development", DEV: true, PROD: false, SSR: false };
const schema$1 = {
  notes: {
    type: "object",
    patternProperties: {
      "[A-Za-z0-9_-]": {
        type: "object",
        properties: {
          id: { type: "string", default: "" },
          title: { type: "string", default: "" },
          content: { type: "object", default: { type: "doc", content: [] } },
          labels: { type: "array", default: [] },
          createdAt: { type: "number", default: Date.now() },
          updatedAt: { type: "number", default: Date.now() },
          isBookmarked: { type: "boolean", default: false },
          isArchived: { type: "boolean", default: false },
          lastCursorPosition: { type: "number", default: 0 }
        }
      }
    }
  },
  labels: {
    type: "array"
  }
};
const store$1 = new Store({
  schema: schema$1,
  encryptionKey: define_import_meta_env_default$1.VITE_ENCRYPT_KEY
});
const schema = {
  dataDir: {
    type: "string",
    default: require$$0.app.getPath("userData")
  }
};
const settings = new Store({ name: "settings", schema, encryptionKey: process.env.VITE_ENCRYPT_KEY });
const store = {
  data: store$1,
  settings
};
var define_import_meta_env_default = { VITE_DEV_SERVER_URL: "http://localhost:5173/", BASE_URL: "/", MODE: "development", DEV: true, PROD: false, SSR: false };
const isSingleInstance = require$$0.app.requestSingleInstanceLock();
if (!isSingleInstance) {
  require$$0.app.quit();
  process.exit(0);
}
require$$0.app.disableHardwareAcceleration();
const env = define_import_meta_env_default;
let mainWindow = null;
const createWindow = async () => {
  mainWindow = new require$$0.BrowserWindow({
    show: false,
    width: 950,
    height: 600,
    webPreferences: {
      preload: require$$1.join(__dirname, "../../preload/dist/index.cjs"),
      contextIsolation: env.MODE !== "test",
      enableRemoteModule: env.MODE === "test",
      nodeIntegration: true
    }
  });
  mainWindow.setMenuBarVisibility(false);
  mainWindow.on("ready-to-show", () => {
    mainWindow == null ? void 0 : mainWindow.show();
    {
      mainWindow == null ? void 0 : mainWindow.webContents.openDevTools();
    }
  });
  mainWindow == null ? void 0 : mainWindow.webContents.setWindowOpenHandler(function(details) {
    const url = details.url;
    if (url.startsWith("note://"))
      return;
    require$$0.shell.openExternal(url);
    return {
      action: "deny"
    };
  });
  const pageUrl = env.VITE_DEV_SERVER_URL;
  await mainWindow.loadURL(pageUrl);
};
require$$0.app.on("NSApplicationDelegate.applicationSupportsSecureRestorableState", () => {
  return true;
});
require$$0.app.on("second-instance", () => {
  if (mainWindow) {
    if (mainWindow.isMinimized())
      mainWindow.restore();
    mainWindow.focus();
  }
});
require$$0.app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    require$$0.app.quit();
  }
});
require$$0.app.whenReady().then(async () => {
  require$$0.protocol.registerFileProtocol("assets", (request, callback) => {
    const url = request.url.substr(9);
    const dir = store.settings.get("dataDir");
    const imgPath = `${dir}/notes-assets/${url}`;
    callback({ path: require$$1.normalize(imgPath) });
  });
  await lib.ensureDir(require$$1.join(require$$0.app.getPath("userData"), "notes-assets"));
  await createWindow();
}).catch((e) => console.error("Failed create window:", e));
ipcMain$1.answerRenderer("app:info", () => ({
  name: require$$0.app.getName(),
  version: require$$0.app.getVersion()
}));
ipcMain$1.answerRenderer("app:spellcheck", (isEnabled) => {
  mainWindow.webContents.session.setSpellCheckerEnabled(isEnabled);
});
ipcMain$1.answerRenderer("app:set-zoom", (newZoomLevel) => {
  mainWindow.webContents.zoomFactor = newZoomLevel;
});
ipcMain$1.answerRenderer("dialog:open", (props) => require$$0.dialog.showOpenDialog(props));
ipcMain$1.answerRenderer("dialog:message", (props) => require$$0.dialog.showMessageBox(props));
ipcMain$1.answerRenderer("dialog:save", (props) => require$$0.dialog.showSaveDialog(props));
ipcMain$1.answerRenderer("fs:copy", ({ path: path2, dest }) => lib.copy(path2, dest));
ipcMain$1.answerRenderer("fs:output-json", ({ path: path2, data }) => lib.outputJson(path2, data));
ipcMain$1.answerRenderer("fs:read-json", (path2) => lib.readJson(path2));
ipcMain$1.answerRenderer("fs:ensureDir", (path2) => lib.ensureDir(path2));
ipcMain$1.answerRenderer("fs:pathExists", (path2) => lib.pathExistsSync(path2));
ipcMain$1.answerRenderer("fs:remove", (path2) => lib.remove(path2));
ipcMain$1.answerRenderer("helper:relaunch", (options = {}) => {
  require$$0.app.relaunch({ args: process.argv.slice(1).concat(["--relaunch"]), ...options });
  require$$0.app.exit(0);
});
ipcMain$1.answerRenderer("helper:get-path", (name) => require$$0.app.getPath(name));
ipcMain$1.answerRenderer("helper:is-dark-theme", () => require$$0.nativeTheme.shouldUseDarkColors);
ipcMain$1.answerRenderer("storage:store", (name) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.store;
});
ipcMain$1.answerRenderer("storage:replace", ({ name, data }) => store[name].store = data);
ipcMain$1.answerRenderer("storage:get", ({ name, key, def: def2 }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.get(key, def2);
});
ipcMain$1.answerRenderer("storage:set", ({ name, key, value }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.set(key, value);
});
ipcMain$1.answerRenderer("storage:delete", ({ name, key }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.delete(key);
});
ipcMain$1.answerRenderer("storage:has", ({ name, key }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.has(key);
});
ipcMain$1.answerRenderer("storage:clear", (name) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.clear();
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguY2pzIiwic291cmNlcyI6WyIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tYmV0dGVyLWlwYy9ub2RlX21vZHVsZXMvc2VyaWFsaXplLWVycm9yL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWJldHRlci1pcGMvc291cmNlL3V0aWwuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tYmV0dGVyLWlwYy9zb3VyY2UvbWFpbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1iZXR0ZXItaXBjL3NvdXJjZS9yZW5kZXJlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1iZXR0ZXItaXBjL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3VuaXZlcnNhbGlmeS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9wb2x5ZmlsbHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvbGVnYWN5LXN0cmVhbXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvY2xvbmUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvZ3JhY2VmdWwtZnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2ZzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9ta2RpcnMvdXRpbHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21rZGlycy9tYWtlLWRpci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvbWtkaXJzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9wYXRoLWV4aXN0cy9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvdXRpbC91dGltZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3V0aWwvc3RhdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvY29weS9jb3B5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5L2NvcHktc3luYy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvY29weS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvcmVtb3ZlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbXB0eS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL2ZpbGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9saW5rLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvc3ltbGluay1wYXRocy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL3N5bWxpbmstdHlwZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL3N5bWxpbmsuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qc29uZmlsZS91dGlscy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qc29uZmlsZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvanNvbi9qc29uZmlsZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvb3V0cHV0LWZpbGUvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2pzb24vb3V0cHV0LWpzb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2pzb24vb3V0cHV0LWpzb24tc3luYy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvanNvbi9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvbW92ZS9tb3ZlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9tb3ZlL21vdmUtc3luYy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvbW92ZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvaXMtb2JqL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RvdC1wcm9wL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3BhdGgtZXhpc3RzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3AtdHJ5L2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3AtbGltaXQvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcC1sb2NhdGUvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9jYXRlLXBhdGgvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZmluZC11cC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wa2ctdXAvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZW52LXBhdGhzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC9jb25zdHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL2F0dGVtcHRpZnkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL2ZzX2hhbmRsZXJzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC91dGlscy9yZXRyeWlmeV9xdWV1ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hdG9taWNhbGx5L2Rpc3QvdXRpbHMvcmV0cnlpZnkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL2ZzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC91dGlscy9sYW5nLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC91dGlscy9zY2hlZHVsZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL3RlbXAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvY29kZWdlbi9jb2RlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvY29kZWdlbi9zY29wZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2NvZGVnZW4vaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS91dGlsLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvbmFtZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9lcnJvcnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9ib29sU2NoZW1hLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvcnVsZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9hcHBsaWNhYmlsaXR5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9kZWZhdWx0cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvY29kZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2tleXdvcmQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9zdWJzY2hlbWEuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZmFzdC1kZWVwLWVxdWFsL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLXRyYXZlcnNlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3VyaS1qcy9kaXN0L2VzNS91cmkuYWxsLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvcmVzb2x2ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3JlZl9lcnJvci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvcmUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvcmUvaWQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvcmUvcmVmLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9jb3JlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0TnVtYmVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL211bHRpcGxlT2YuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS91Y3MybGVuZ3RoLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0TGVuZ3RoLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL3BhdHRlcm4uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbGltaXRQcm9wZXJ0aWVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL3JlcXVpcmVkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0SXRlbXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS9lcXVhbC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi91bmlxdWVJdGVtcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9jb25zdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9lbnVtLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FkZGl0aW9uYWxJdGVtcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pdGVtcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wcmVmaXhJdGVtcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pdGVtczIwMjAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvY29udGFpbnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvZGVwZW5kZW5jaWVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3Byb3BlcnR5TmFtZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWRkaXRpb25hbFByb3BlcnRpZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJvcGVydGllcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wYXR0ZXJuUHJvcGVydGllcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9ub3QuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYW55T2YuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3Ivb25lT2YuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWxsT2YuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaWYuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvdGhlbkVsc2UuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Zvcm1hdC9mb3JtYXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Zvcm1hdC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvbWV0YWRhdGEuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2RyYWZ0Ny5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvci90eXBlcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvci9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9hanYuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvZGlzdC9mb3JtYXRzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi1mb3JtYXRzL2Rpc3QvbGltaXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvZGlzdC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZWJvdW5jZS1mbi9ub2RlX21vZHVsZXMvbWltaWMtZm4vaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGVib3VuY2UtZm4vaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2NvbnN0YW50cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvZGVidWcuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL3JlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9wYXJzZS1vcHRpb25zLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9pZGVudGlmaWVycy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9zZW12ZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wYXJzZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3ZhbGlkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY2xlYW4uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9pbmMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZXEuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9kaWZmLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbWFqb3IuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9taW5vci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3BhdGNoLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcHJlcmVsZWFzZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3Jjb21wYXJlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS1sb29zZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUtYnVpbGQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zb3J0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcnNvcnQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9ndC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbmVxLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZ3RlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbHRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY21wLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29lcmNlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3lhbGxpc3QvaXRlcmF0b3IuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMveWFsbGlzdC95YWxsaXN0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9yYW5nZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9jb21wYXJhdG9yLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvdG8tY29tcGFyYXRvcnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9tYXgtc2F0aXNmeWluZy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21pbi1zYXRpc2Z5aW5nLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWluLXZlcnNpb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy92YWxpZC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL291dHNpZGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9ndHIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9sdHIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9pbnRlcnNlY3RzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvc2ltcGxpZnkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zdWJzZXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21pbWljLWZuL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29uZXRpbWUvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9kaXN0L3NvdXJjZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1zdG9yZS9pbmRleC5qcyIsIi4uL3NyYy9zdG9yZS9tb2R1bGVzL2RhdGEuc3RvcmUuanMiLCIuLi9zcmMvc3RvcmUvbW9kdWxlcy9zZXR0aW5ncy5zdG9yZS5qcyIsIi4uL3NyYy9zdG9yZS9pbmRleC5qcyIsIi4uL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNsYXNzIE5vbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG5cdFx0c3VwZXIoTm9uRXJyb3IuX3ByZXBhcmVTdXBlck1lc3NhZ2UobWVzc2FnZSkpO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmFtZScsIHtcblx0XHRcdHZhbHVlOiAnTm9uRXJyb3InLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0d3JpdGFibGU6IHRydWVcblx0XHR9KTtcblxuXHRcdGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuXHRcdFx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgTm9uRXJyb3IpO1xuXHRcdH1cblx0fVxuXG5cdHN0YXRpYyBfcHJlcGFyZVN1cGVyTWVzc2FnZShtZXNzYWdlKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShtZXNzYWdlKTtcblx0XHR9IGNhdGNoIHtcblx0XHRcdHJldHVybiBTdHJpbmcobWVzc2FnZSk7XG5cdFx0fVxuXHR9XG59XG5cbmNvbnN0IGNvbW1vblByb3BlcnRpZXMgPSBbXG5cdHtwcm9wZXJ0eTogJ25hbWUnLCBlbnVtZXJhYmxlOiBmYWxzZX0sXG5cdHtwcm9wZXJ0eTogJ21lc3NhZ2UnLCBlbnVtZXJhYmxlOiBmYWxzZX0sXG5cdHtwcm9wZXJ0eTogJ3N0YWNrJywgZW51bWVyYWJsZTogZmFsc2V9LFxuXHR7cHJvcGVydHk6ICdjb2RlJywgZW51bWVyYWJsZTogdHJ1ZX1cbl07XG5cbmNvbnN0IGlzQ2FsbGVkID0gU3ltYm9sKCcudG9KU09OIGNhbGxlZCcpO1xuXG5jb25zdCB0b0pTT04gPSBmcm9tID0+IHtcblx0ZnJvbVtpc0NhbGxlZF0gPSB0cnVlO1xuXHRjb25zdCBqc29uID0gZnJvbS50b0pTT04oKTtcblx0ZGVsZXRlIGZyb21baXNDYWxsZWRdO1xuXHRyZXR1cm4ganNvbjtcbn07XG5cbmNvbnN0IGRlc3Ryb3lDaXJjdWxhciA9ICh7XG5cdGZyb20sXG5cdHNlZW4sXG5cdHRvXyxcblx0Zm9yY2VFbnVtZXJhYmxlLFxuXHRtYXhEZXB0aCxcblx0ZGVwdGhcbn0pID0+IHtcblx0Y29uc3QgdG8gPSB0b18gfHwgKEFycmF5LmlzQXJyYXkoZnJvbSkgPyBbXSA6IHt9KTtcblxuXHRzZWVuLnB1c2goZnJvbSk7XG5cblx0aWYgKGRlcHRoID49IG1heERlcHRoKSB7XG5cdFx0cmV0dXJuIHRvO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBmcm9tLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJyAmJiBmcm9tW2lzQ2FsbGVkXSAhPT0gdHJ1ZSkge1xuXHRcdHJldHVybiB0b0pTT04oZnJvbSk7XG5cdH1cblxuXHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmcm9tKSkge1xuXHRcdGlmICh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcblx0XHRcdHRvW2tleV0gPSAnW29iamVjdCBCdWZmZXJdJztcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0dG9ba2V5XSA9IHZhbHVlO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0aWYgKCFzZWVuLmluY2x1ZGVzKGZyb21ba2V5XSkpIHtcblx0XHRcdGRlcHRoKys7XG5cblx0XHRcdHRvW2tleV0gPSBkZXN0cm95Q2lyY3VsYXIoe1xuXHRcdFx0XHRmcm9tOiBmcm9tW2tleV0sXG5cdFx0XHRcdHNlZW46IHNlZW4uc2xpY2UoKSxcblx0XHRcdFx0Zm9yY2VFbnVtZXJhYmxlLFxuXHRcdFx0XHRtYXhEZXB0aCxcblx0XHRcdFx0ZGVwdGhcblx0XHRcdH0pO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0dG9ba2V5XSA9ICdbQ2lyY3VsYXJdJztcblx0fVxuXG5cdGZvciAoY29uc3Qge3Byb3BlcnR5LCBlbnVtZXJhYmxlfSBvZiBjb21tb25Qcm9wZXJ0aWVzKSB7XG5cdFx0aWYgKHR5cGVvZiBmcm9tW3Byb3BlcnR5XSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0bywgcHJvcGVydHksIHtcblx0XHRcdFx0dmFsdWU6IGZyb21bcHJvcGVydHldLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiBmb3JjZUVudW1lcmFibGUgPyB0cnVlIDogZW51bWVyYWJsZSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuY29uc3Qgc2VyaWFsaXplRXJyb3IgPSAodmFsdWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuXHRjb25zdCB7bWF4RGVwdGggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFl9ID0gb3B0aW9ucztcblxuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuXHRcdHJldHVybiBkZXN0cm95Q2lyY3VsYXIoe1xuXHRcdFx0ZnJvbTogdmFsdWUsXG5cdFx0XHRzZWVuOiBbXSxcblx0XHRcdGZvcmNlRW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdG1heERlcHRoLFxuXHRcdFx0ZGVwdGg6IDBcblx0XHR9KTtcblx0fVxuXG5cdC8vIFBlb3BsZSBzb21ldGltZXMgdGhyb3cgdGhpbmdzIGJlc2lkZXMgRXJyb3Igb2JqZWN0c+KAplxuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Ly8gYEpTT04uc3RyaW5naWZ5KClgIGRpc2NhcmRzIGZ1bmN0aW9ucy4gV2UgZG8gdG9vLCB1bmxlc3MgYSBmdW5jdGlvbiBpcyB0aHJvd24gZGlyZWN0bHkuXG5cdFx0cmV0dXJuIGBbRnVuY3Rpb246ICR7KHZhbHVlLm5hbWUgfHwgJ2Fub255bW91cycpfV1gO1xuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufTtcblxuY29uc3QgZGVzZXJpYWxpemVFcnJvciA9ICh2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG5cdGNvbnN0IHttYXhEZXB0aCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWX0gPSBvcHRpb25zO1xuXG5cdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0Y29uc3QgbmV3RXJyb3IgPSBuZXcgRXJyb3IoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSB1bmljb3JuL2Vycm9yLW1lc3NhZ2Vcblx0XHRkZXN0cm95Q2lyY3VsYXIoe1xuXHRcdFx0ZnJvbTogdmFsdWUsXG5cdFx0XHRzZWVuOiBbXSxcblx0XHRcdHRvXzogbmV3RXJyb3IsXG5cdFx0XHRtYXhEZXB0aCxcblx0XHRcdGRlcHRoOiAwXG5cdFx0fSk7XG5cdFx0cmV0dXJuIG5ld0Vycm9yO1xuXHR9XG5cblx0cmV0dXJuIG5ldyBOb25FcnJvcih2YWx1ZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0c2VyaWFsaXplRXJyb3IsXG5cdGRlc2VyaWFsaXplRXJyb3Jcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGdldFVuaXF1ZUlkID0gKCkgPT4gYCR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpfWA7XG5cbmNvbnN0IGdldFNlbmRDaGFubmVsID0gY2hhbm5lbCA9PiBgJWJldHRlci1pcGMtc2VuZC1jaGFubmVsLSR7Y2hhbm5lbH1gO1xuY29uc3QgZ2V0UmVuZGVyZXJTZW5kQ2hhbm5lbCA9IGNoYW5uZWwgPT4gYCViZXR0ZXItaXBjLXNlbmQtY2hhbm5lbC0ke2NoYW5uZWx9YDtcblxubW9kdWxlLmV4cG9ydHMuY3VycmVudFdpbmRvd0NoYW5uZWwgPSAnJWJldHRlci1pcGMtY3VycmVudC13aW5kb3cnO1xuXG5tb2R1bGUuZXhwb3J0cy5nZXRTZW5kQ2hhbm5lbCA9IGdldFNlbmRDaGFubmVsO1xubW9kdWxlLmV4cG9ydHMuZ2V0UmVuZGVyZXJTZW5kQ2hhbm5lbCA9IGdldFJlbmRlcmVyU2VuZENoYW5uZWw7XG5cbm1vZHVsZS5leHBvcnRzLmdldFJlc3BvbnNlQ2hhbm5lbHMgPSBjaGFubmVsID0+IHtcblx0Y29uc3QgaWQgPSBnZXRVbmlxdWVJZCgpO1xuXHRyZXR1cm4ge1xuXHRcdHNlbmRDaGFubmVsOiBnZXRTZW5kQ2hhbm5lbChjaGFubmVsKSxcblx0XHRkYXRhQ2hhbm5lbDogYCViZXR0ZXItaXBjLXJlc3BvbnNlLWRhdGEtY2hhbm5lbC0ke2NoYW5uZWx9LSR7aWR9YCxcblx0XHRlcnJvckNoYW5uZWw6IGAlYmV0dGVyLWlwYy1yZXNwb25zZS1lcnJvci1jaGFubmVsLSR7Y2hhbm5lbH0tJHtpZH1gXG5cdH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5nZXRSZW5kZXJlclJlc3BvbnNlQ2hhbm5lbHMgPSBjaGFubmVsID0+IHtcblx0Y29uc3QgaWQgPSBnZXRVbmlxdWVJZCgpO1xuXHRyZXR1cm4ge1xuXHRcdHNlbmRDaGFubmVsOiBnZXRSZW5kZXJlclNlbmRDaGFubmVsKGNoYW5uZWwpLFxuXHRcdGRhdGFDaGFubmVsOiBgJWJldHRlci1pcGMtcmVzcG9uc2UtZGF0YS1jaGFubmVsLSR7Y2hhbm5lbH0tJHtpZH1gLFxuXHRcdGVycm9yQ2hhbm5lbDogYCViZXR0ZXItaXBjLXJlc3BvbnNlLWVycm9yLWNoYW5uZWwtJHtjaGFubmVsfS0ke2lkfWBcblx0fTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBlbGVjdHJvbiA9IHJlcXVpcmUoJ2VsZWN0cm9uJyk7XG5jb25zdCB7c2VyaWFsaXplRXJyb3IsIGRlc2VyaWFsaXplRXJyb3J9ID0gcmVxdWlyZSgnc2VyaWFsaXplLWVycm9yJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsLmpzJyk7XG5cbmNvbnN0IHtpcGNNYWluLCBCcm93c2VyV2luZG93fSA9IGVsZWN0cm9uO1xuY29uc3QgaXBjID0gT2JqZWN0LmNyZWF0ZShpcGNNYWluIHx8IHt9KTtcblxuaXBjLmNhbGxSZW5kZXJlciA9IChicm93c2VyV2luZG93LCBjaGFubmVsLCBkYXRhKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdGlmICghYnJvd3NlcldpbmRvdykge1xuXHRcdHRocm93IG5ldyBFcnJvcignQnJvd3NlciB3aW5kb3cgcmVxdWlyZWQnKTtcblx0fVxuXG5cdGNvbnN0IHtzZW5kQ2hhbm5lbCwgZGF0YUNoYW5uZWwsIGVycm9yQ2hhbm5lbH0gPSB1dGlsLmdldFJlbmRlcmVyUmVzcG9uc2VDaGFubmVscyhjaGFubmVsKTtcblxuXHRjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuXHRcdGlwY01haW4ub2ZmKGRhdGFDaGFubmVsLCBvbkRhdGEpO1xuXHRcdGlwY01haW4ub2ZmKGVycm9yQ2hhbm5lbCwgb25FcnJvcik7XG5cdH07XG5cblx0Y29uc3Qgb25EYXRhID0gKGV2ZW50LCByZXN1bHQpID0+IHtcblx0XHRjb25zdCB3aW5kb3cgPSBCcm93c2VyV2luZG93LmZyb21XZWJDb250ZW50cyhldmVudC5zZW5kZXIpO1xuXHRcdGlmICh3aW5kb3cuaWQgPT09IGJyb3dzZXJXaW5kb3cuaWQpIHtcblx0XHRcdGNsZWFudXAoKTtcblx0XHRcdHJlc29sdmUocmVzdWx0KTtcblx0XHR9XG5cdH07XG5cblx0Y29uc3Qgb25FcnJvciA9IChldmVudCwgZXJyb3IpID0+IHtcblx0XHRjb25zdCB3aW5kb3cgPSBCcm93c2VyV2luZG93LmZyb21XZWJDb250ZW50cyhldmVudC5zZW5kZXIpO1xuXHRcdGlmICh3aW5kb3cuaWQgPT09IGJyb3dzZXJXaW5kb3cuaWQpIHtcblx0XHRcdGNsZWFudXAoKTtcblx0XHRcdHJlamVjdChkZXNlcmlhbGl6ZUVycm9yKGVycm9yKSk7XG5cdFx0fVxuXHR9O1xuXG5cdGlwY01haW4ub24oZGF0YUNoYW5uZWwsIG9uRGF0YSk7XG5cdGlwY01haW4ub24oZXJyb3JDaGFubmVsLCBvbkVycm9yKTtcblxuXHRjb25zdCBjb21wbGV0ZURhdGEgPSB7XG5cdFx0ZGF0YUNoYW5uZWwsXG5cdFx0ZXJyb3JDaGFubmVsLFxuXHRcdHVzZXJEYXRhOiBkYXRhXG5cdH07XG5cblx0aWYgKGJyb3dzZXJXaW5kb3cud2ViQ29udGVudHMpIHtcblx0XHRicm93c2VyV2luZG93LndlYkNvbnRlbnRzLnNlbmQoc2VuZENoYW5uZWwsIGNvbXBsZXRlRGF0YSk7XG5cdH1cbn0pO1xuXG5pcGMuY2FsbEZvY3VzZWRSZW5kZXJlciA9IGFzeW5jICguLi5hcmdzKSA9PiB7XG5cdGNvbnN0IGZvY3VzZWRXaW5kb3cgPSBCcm93c2VyV2luZG93LmdldEZvY3VzZWRXaW5kb3coKTtcblx0aWYgKCFmb2N1c2VkV2luZG93KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdObyBicm93c2VyIHdpbmRvdyBpbiBmb2N1cycpO1xuXHR9XG5cblx0cmV0dXJuIGlwYy5jYWxsUmVuZGVyZXIoZm9jdXNlZFdpbmRvdywgLi4uYXJncyk7XG59O1xuXG5pcGMuYW5zd2VyUmVuZGVyZXIgPSAoYnJvd3NlcldpbmRvd09yQ2hhbm5lbCwgY2hhbm5lbE9yQ2FsbGJhY2ssIGNhbGxiYWNrT3JOb3RoaW5nKSA9PiB7XG5cdGxldCB3aW5kb3c7XG5cdGxldCBjaGFubmVsO1xuXHRsZXQgY2FsbGJhY2s7XG5cblx0aWYgKGNhbGxiYWNrT3JOb3RoaW5nID09PSB1bmRlZmluZWQpIHtcblx0XHRjaGFubmVsID0gYnJvd3NlcldpbmRvd09yQ2hhbm5lbDtcblx0XHRjYWxsYmFjayA9IGNoYW5uZWxPckNhbGxiYWNrO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdyA9IGJyb3dzZXJXaW5kb3dPckNoYW5uZWw7XG5cdFx0Y2hhbm5lbCA9IGNoYW5uZWxPckNhbGxiYWNrO1xuXHRcdGNhbGxiYWNrID0gY2FsbGJhY2tPck5vdGhpbmc7XG5cblx0XHRpZiAoIXdpbmRvdykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdCcm93c2VyIHdpbmRvdyByZXF1aXJlZCcpO1xuXHRcdH1cblx0fVxuXG5cdGNvbnN0IHNlbmRDaGFubmVsID0gdXRpbC5nZXRTZW5kQ2hhbm5lbChjaGFubmVsKTtcblxuXHRjb25zdCBsaXN0ZW5lciA9IGFzeW5jIChldmVudCwgZGF0YSkgPT4ge1xuXHRcdGNvbnN0IGJyb3dzZXJXaW5kb3cgPSBCcm93c2VyV2luZG93LmZyb21XZWJDb250ZW50cyhldmVudC5zZW5kZXIpO1xuXG5cdFx0aWYgKHdpbmRvdyAmJiB3aW5kb3cuaWQgIT09IGJyb3dzZXJXaW5kb3cuaWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBzZW5kID0gKGNoYW5uZWwsIGRhdGEpID0+IHtcblx0XHRcdGlmICghKGJyb3dzZXJXaW5kb3cgJiYgYnJvd3NlcldpbmRvdy5pc0Rlc3Ryb3llZCgpKSkge1xuXHRcdFx0XHRldmVudC5zZW5kZXIuc2VuZChjaGFubmVsLCBkYXRhKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Y29uc3Qge2RhdGFDaGFubmVsLCBlcnJvckNoYW5uZWwsIHVzZXJEYXRhfSA9IGRhdGE7XG5cblx0XHR0cnkge1xuXHRcdFx0c2VuZChkYXRhQ2hhbm5lbCwgYXdhaXQgY2FsbGJhY2sodXNlckRhdGEsIGJyb3dzZXJXaW5kb3cpKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0c2VuZChlcnJvckNoYW5uZWwsIHNlcmlhbGl6ZUVycm9yKGVycm9yKSk7XG5cdFx0fVxuXHR9O1xuXG5cdGlwY01haW4ub24oc2VuZENoYW5uZWwsIGxpc3RlbmVyKTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlwY01haW4ub2ZmKHNlbmRDaGFubmVsLCBsaXN0ZW5lcik7XG5cdH07XG59O1xuXG5pcGMuc2VuZFRvUmVuZGVyZXJzID0gKGNoYW5uZWwsIGRhdGEpID0+IHtcblx0Zm9yIChjb25zdCBicm93c2VyV2luZG93IG9mIEJyb3dzZXJXaW5kb3cuZ2V0QWxsV2luZG93cygpKSB7XG5cdFx0aWYgKGJyb3dzZXJXaW5kb3cud2ViQ29udGVudHMpIHtcblx0XHRcdGJyb3dzZXJXaW5kb3cud2ViQ29udGVudHMuc2VuZChjaGFubmVsLCBkYXRhKTtcblx0XHR9XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXBjO1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgZWxlY3Ryb24gPSByZXF1aXJlKCdlbGVjdHJvbicpO1xuY29uc3Qge3NlcmlhbGl6ZUVycm9yLCBkZXNlcmlhbGl6ZUVycm9yfSA9IHJlcXVpcmUoJ3NlcmlhbGl6ZS1lcnJvcicpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbC5qcycpO1xuXG5jb25zdCB7aXBjUmVuZGVyZXJ9ID0gZWxlY3Ryb247XG5jb25zdCBpcGMgPSBPYmplY3QuY3JlYXRlKGlwY1JlbmRlcmVyIHx8IHt9KTtcblxuaXBjLmNhbGxNYWluID0gKGNoYW5uZWwsIGRhdGEpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0Y29uc3Qge3NlbmRDaGFubmVsLCBkYXRhQ2hhbm5lbCwgZXJyb3JDaGFubmVsfSA9IHV0aWwuZ2V0UmVzcG9uc2VDaGFubmVscyhjaGFubmVsKTtcblxuXHRjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuXHRcdGlwY1JlbmRlcmVyLm9mZihkYXRhQ2hhbm5lbCwgb25EYXRhKTtcblx0XHRpcGNSZW5kZXJlci5vZmYoZXJyb3JDaGFubmVsLCBvbkVycm9yKTtcblx0fTtcblxuXHRjb25zdCBvbkRhdGEgPSAoX2V2ZW50LCByZXN1bHQpID0+IHtcblx0XHRjbGVhbnVwKCk7XG5cdFx0cmVzb2x2ZShyZXN1bHQpO1xuXHR9O1xuXG5cdGNvbnN0IG9uRXJyb3IgPSAoX2V2ZW50LCBlcnJvcikgPT4ge1xuXHRcdGNsZWFudXAoKTtcblx0XHRyZWplY3QoZGVzZXJpYWxpemVFcnJvcihlcnJvcikpO1xuXHR9O1xuXG5cdGlwY1JlbmRlcmVyLm9uY2UoZGF0YUNoYW5uZWwsIG9uRGF0YSk7XG5cdGlwY1JlbmRlcmVyLm9uY2UoZXJyb3JDaGFubmVsLCBvbkVycm9yKTtcblxuXHRjb25zdCBjb21wbGV0ZURhdGEgPSB7XG5cdFx0ZGF0YUNoYW5uZWwsXG5cdFx0ZXJyb3JDaGFubmVsLFxuXHRcdHVzZXJEYXRhOiBkYXRhXG5cdH07XG5cblx0aXBjUmVuZGVyZXIuc2VuZChzZW5kQ2hhbm5lbCwgY29tcGxldGVEYXRhKTtcbn0pO1xuXG5pcGMuYW5zd2VyTWFpbiA9IChjaGFubmVsLCBjYWxsYmFjaykgPT4ge1xuXHRjb25zdCBzZW5kQ2hhbm5lbCA9IHV0aWwuZ2V0UmVuZGVyZXJTZW5kQ2hhbm5lbChjaGFubmVsKTtcblxuXHRjb25zdCBsaXN0ZW5lciA9IGFzeW5jIChfZXZlbnQsIGRhdGEpID0+IHtcblx0XHRjb25zdCB7ZGF0YUNoYW5uZWwsIGVycm9yQ2hhbm5lbCwgdXNlckRhdGF9ID0gZGF0YTtcblxuXHRcdHRyeSB7XG5cdFx0XHRpcGNSZW5kZXJlci5zZW5kKGRhdGFDaGFubmVsLCBhd2FpdCBjYWxsYmFjayh1c2VyRGF0YSkpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpcGNSZW5kZXJlci5zZW5kKGVycm9yQ2hhbm5lbCwgc2VyaWFsaXplRXJyb3IoZXJyb3IpKTtcblx0XHR9XG5cdH07XG5cblx0aXBjUmVuZGVyZXIub24oc2VuZENoYW5uZWwsIGxpc3RlbmVyKTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlwY1JlbmRlcmVyLm9mZihzZW5kQ2hhbm5lbCwgbGlzdGVuZXIpO1xuXHR9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpcGM7XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcblx0bW9kdWxlLmV4cG9ydHMuaXBjUmVuZGVyZXIgPSByZXF1aXJlKCcuL3NvdXJjZS9yZW5kZXJlci5qcycpO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMuaXBjTWFpbiA9IHJlcXVpcmUoJy4vc291cmNlL21haW4uanMnKTtcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmZyb21DYWxsYmFjayA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIGZuLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBmbi5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICAoZXJyLCByZXMpID0+IChlcnIgIT0gbnVsbCkgPyByZWplY3QoZXJyKSA6IHJlc29sdmUocmVzKVxuICAgICAgICApXG4gICAgICB9KVxuICAgIH1cbiAgfSwgJ25hbWUnLCB7IHZhbHVlOiBmbi5uYW1lIH0pXG59XG5cbmV4cG9ydHMuZnJvbVByb21pc2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIGNvbnN0IGNiID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdXG4gICAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgZWxzZSBmbi5hcHBseSh0aGlzLCBhcmdzLnNsaWNlKDAsIC0xKSkudGhlbihyID0+IGNiKG51bGwsIHIpLCBjYilcbiAgfSwgJ25hbWUnLCB7IHZhbHVlOiBmbi5uYW1lIH0pXG59XG4iLCJ2YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnY29uc3RhbnRzJylcblxudmFyIG9yaWdDd2QgPSBwcm9jZXNzLmN3ZFxudmFyIGN3ZCA9IG51bGxcblxudmFyIHBsYXRmb3JtID0gcHJvY2Vzcy5lbnYuR1JBQ0VGVUxfRlNfUExBVEZPUk0gfHwgcHJvY2Vzcy5wbGF0Zm9ybVxuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIWN3ZClcbiAgICBjd2QgPSBvcmlnQ3dkLmNhbGwocHJvY2VzcylcbiAgcmV0dXJuIGN3ZFxufVxudHJ5IHtcbiAgcHJvY2Vzcy5jd2QoKVxufSBjYXRjaCAoZXIpIHt9XG5cbi8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHVudGlsIG5vZGUuanMgMTIgaXMgcmVxdWlyZWRcbmlmICh0eXBlb2YgcHJvY2Vzcy5jaGRpciA9PT0gJ2Z1bmN0aW9uJykge1xuICB2YXIgY2hkaXIgPSBwcm9jZXNzLmNoZGlyXG4gIHByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZCkge1xuICAgIGN3ZCA9IG51bGxcbiAgICBjaGRpci5jYWxsKHByb2Nlc3MsIGQpXG4gIH1cbiAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb2Nlc3MuY2hkaXIsIGNoZGlyKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoXG5cbmZ1bmN0aW9uIHBhdGNoIChmcykge1xuICAvLyAocmUtKWltcGxlbWVudCBzb21lIHRoaW5ncyB0aGF0IGFyZSBrbm93biBidXN0ZWQgb3IgbWlzc2luZy5cblxuICAvLyBsY2htb2QsIGJyb2tlbiBwcmlvciB0byAwLjYuMlxuICAvLyBiYWNrLXBvcnQgdGhlIGZpeCBoZXJlLlxuICBpZiAoY29uc3RhbnRzLmhhc093blByb3BlcnR5KCdPX1NZTUxJTksnKSAmJlxuICAgICAgcHJvY2Vzcy52ZXJzaW9uLm1hdGNoKC9edjBcXC42XFwuWzAtMl18XnYwXFwuNVxcLi8pKSB7XG4gICAgcGF0Y2hMY2htb2QoZnMpXG4gIH1cblxuICAvLyBsdXRpbWVzIGltcGxlbWVudGF0aW9uLCBvciBuby1vcFxuICBpZiAoIWZzLmx1dGltZXMpIHtcbiAgICBwYXRjaEx1dGltZXMoZnMpXG4gIH1cblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL25vZGUtZ3JhY2VmdWwtZnMvaXNzdWVzLzRcbiAgLy8gQ2hvd24gc2hvdWxkIG5vdCBmYWlsIG9uIGVpbnZhbCBvciBlcGVybSBpZiBub24tcm9vdC5cbiAgLy8gSXQgc2hvdWxkIG5vdCBmYWlsIG9uIGVub3N5cyBldmVyLCBhcyB0aGlzIGp1c3QgaW5kaWNhdGVzXG4gIC8vIHRoYXQgYSBmcyBkb2Vzbid0IHN1cHBvcnQgdGhlIGludGVuZGVkIG9wZXJhdGlvbi5cblxuICBmcy5jaG93biA9IGNob3duRml4KGZzLmNob3duKVxuICBmcy5mY2hvd24gPSBjaG93bkZpeChmcy5mY2hvd24pXG4gIGZzLmxjaG93biA9IGNob3duRml4KGZzLmxjaG93bilcblxuICBmcy5jaG1vZCA9IGNobW9kRml4KGZzLmNobW9kKVxuICBmcy5mY2htb2QgPSBjaG1vZEZpeChmcy5mY2htb2QpXG4gIGZzLmxjaG1vZCA9IGNobW9kRml4KGZzLmxjaG1vZClcblxuICBmcy5jaG93blN5bmMgPSBjaG93bkZpeFN5bmMoZnMuY2hvd25TeW5jKVxuICBmcy5mY2hvd25TeW5jID0gY2hvd25GaXhTeW5jKGZzLmZjaG93blN5bmMpXG4gIGZzLmxjaG93blN5bmMgPSBjaG93bkZpeFN5bmMoZnMubGNob3duU3luYylcblxuICBmcy5jaG1vZFN5bmMgPSBjaG1vZEZpeFN5bmMoZnMuY2htb2RTeW5jKVxuICBmcy5mY2htb2RTeW5jID0gY2htb2RGaXhTeW5jKGZzLmZjaG1vZFN5bmMpXG4gIGZzLmxjaG1vZFN5bmMgPSBjaG1vZEZpeFN5bmMoZnMubGNobW9kU3luYylcblxuICBmcy5zdGF0ID0gc3RhdEZpeChmcy5zdGF0KVxuICBmcy5mc3RhdCA9IHN0YXRGaXgoZnMuZnN0YXQpXG4gIGZzLmxzdGF0ID0gc3RhdEZpeChmcy5sc3RhdClcblxuICBmcy5zdGF0U3luYyA9IHN0YXRGaXhTeW5jKGZzLnN0YXRTeW5jKVxuICBmcy5mc3RhdFN5bmMgPSBzdGF0Rml4U3luYyhmcy5mc3RhdFN5bmMpXG4gIGZzLmxzdGF0U3luYyA9IHN0YXRGaXhTeW5jKGZzLmxzdGF0U3luYylcblxuICAvLyBpZiBsY2htb2QvbGNob3duIGRvIG5vdCBleGlzdCwgdGhlbiBtYWtlIHRoZW0gbm8tb3BzXG4gIGlmICghZnMubGNobW9kKSB7XG4gICAgZnMubGNobW9kID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUsIGNiKSB7XG4gICAgICBpZiAoY2IpIHByb2Nlc3MubmV4dFRpY2soY2IpXG4gICAgfVxuICAgIGZzLmxjaG1vZFN5bmMgPSBmdW5jdGlvbiAoKSB7fVxuICB9XG4gIGlmICghZnMubGNob3duKSB7XG4gICAgZnMubGNob3duID0gZnVuY3Rpb24gKHBhdGgsIHVpZCwgZ2lkLCBjYikge1xuICAgICAgaWYgKGNiKSBwcm9jZXNzLm5leHRUaWNrKGNiKVxuICAgIH1cbiAgICBmcy5sY2hvd25TeW5jID0gZnVuY3Rpb24gKCkge31cbiAgfVxuXG4gIC8vIG9uIFdpbmRvd3MsIEEvViBzb2Z0d2FyZSBjYW4gbG9jayB0aGUgZGlyZWN0b3J5LCBjYXVzaW5nIHRoaXNcbiAgLy8gdG8gZmFpbCB3aXRoIGFuIEVBQ0NFUyBvciBFUEVSTSBpZiB0aGUgZGlyZWN0b3J5IGNvbnRhaW5zIG5ld2x5XG4gIC8vIGNyZWF0ZWQgZmlsZXMuICBUcnkgYWdhaW4gb24gZmFpbHVyZSwgZm9yIHVwIHRvIDYwIHNlY29uZHMuXG5cbiAgLy8gU2V0IHRoZSB0aW1lb3V0IHRoaXMgbG9uZyBiZWNhdXNlIHNvbWUgV2luZG93cyBBbnRpLVZpcnVzLCBzdWNoIGFzIFBhcml0eVxuICAvLyBiaXQ5LCBtYXkgbG9jayBmaWxlcyBmb3IgdXAgdG8gYSBtaW51dGUsIGNhdXNpbmcgbnBtIHBhY2thZ2UgaW5zdGFsbFxuICAvLyBmYWlsdXJlcy4gQWxzbywgdGFrZSBjYXJlIHRvIHlpZWxkIHRoZSBzY2hlZHVsZXIuIFdpbmRvd3Mgc2NoZWR1bGluZyBnaXZlc1xuICAvLyBDUFUgdG8gYSBidXN5IGxvb3BpbmcgcHJvY2Vzcywgd2hpY2ggY2FuIGNhdXNlIHRoZSBwcm9ncmFtIGNhdXNpbmcgdGhlIGxvY2tcbiAgLy8gY29udGVudGlvbiB0byBiZSBzdGFydmVkIG9mIENQVSBieSBub2RlLCBzbyB0aGUgY29udGVudGlvbiBkb2Vzbid0IHJlc29sdmUuXG4gIGlmIChwbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgZnMucmVuYW1lID0gKGZ1bmN0aW9uIChmcyRyZW5hbWUpIHsgcmV0dXJuIGZ1bmN0aW9uIChmcm9tLCB0bywgY2IpIHtcbiAgICAgIHZhciBzdGFydCA9IERhdGUubm93KClcbiAgICAgIHZhciBiYWNrb2ZmID0gMDtcbiAgICAgIGZzJHJlbmFtZShmcm9tLCB0bywgZnVuY3Rpb24gQ0IgKGVyKSB7XG4gICAgICAgIGlmIChlclxuICAgICAgICAgICAgJiYgKGVyLmNvZGUgPT09IFwiRUFDQ0VTXCIgfHwgZXIuY29kZSA9PT0gXCJFUEVSTVwiKVxuICAgICAgICAgICAgJiYgRGF0ZS5ub3coKSAtIHN0YXJ0IDwgNjAwMDApIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZnMuc3RhdCh0bywgZnVuY3Rpb24gKHN0YXRlciwgc3QpIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlciAmJiBzdGF0ZXIuY29kZSA9PT0gXCJFTk9FTlRcIilcbiAgICAgICAgICAgICAgICBmcyRyZW5hbWUoZnJvbSwgdG8sIENCKTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNiKGVyKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LCBiYWNrb2ZmKVxuICAgICAgICAgIGlmIChiYWNrb2ZmIDwgMTAwKVxuICAgICAgICAgICAgYmFja29mZiArPSAxMDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNiKSBjYihlcilcbiAgICAgIH0pXG4gICAgfX0pKGZzLnJlbmFtZSlcbiAgfVxuXG4gIC8vIGlmIHJlYWQoKSByZXR1cm5zIEVBR0FJTiwgdGhlbiBqdXN0IHRyeSBpdCBhZ2Fpbi5cbiAgZnMucmVhZCA9IChmdW5jdGlvbiAoZnMkcmVhZCkge1xuICAgIGZ1bmN0aW9uIHJlYWQgKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2tfKSB7XG4gICAgICB2YXIgY2FsbGJhY2tcbiAgICAgIGlmIChjYWxsYmFja18gJiYgdHlwZW9mIGNhbGxiYWNrXyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgZWFnQ291bnRlciA9IDBcbiAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoZXIsIF8sIF9fKSB7XG4gICAgICAgICAgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFQUdBSU4nICYmIGVhZ0NvdW50ZXIgPCAxMCkge1xuICAgICAgICAgICAgZWFnQ291bnRlciArK1xuICAgICAgICAgICAgcmV0dXJuIGZzJHJlYWQuY2FsbChmcywgZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaylcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2tfLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZzJHJlYWQuY2FsbChmcywgZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaylcbiAgICB9XG5cbiAgICAvLyBUaGlzIGVuc3VyZXMgYHV0aWwucHJvbWlzaWZ5YCB3b3JrcyBhcyBpdCBkb2VzIGZvciBuYXRpdmUgYGZzLnJlYWRgLlxuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIE9iamVjdC5zZXRQcm90b3R5cGVPZihyZWFkLCBmcyRyZWFkKVxuICAgIHJldHVybiByZWFkXG4gIH0pKGZzLnJlYWQpXG5cbiAgZnMucmVhZFN5bmMgPSAoZnVuY3Rpb24gKGZzJHJlYWRTeW5jKSB7IHJldHVybiBmdW5jdGlvbiAoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XG4gICAgdmFyIGVhZ0NvdW50ZXIgPSAwXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmcyRyZWFkU3luYy5jYWxsKGZzLCBmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBpZiAoZXIuY29kZSA9PT0gJ0VBR0FJTicgJiYgZWFnQ291bnRlciA8IDEwKSB7XG4gICAgICAgICAgZWFnQ291bnRlciArK1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJcbiAgICAgIH1cbiAgICB9XG4gIH19KShmcy5yZWFkU3luYylcblxuICBmdW5jdGlvbiBwYXRjaExjaG1vZCAoZnMpIHtcbiAgICBmcy5sY2htb2QgPSBmdW5jdGlvbiAocGF0aCwgbW9kZSwgY2FsbGJhY2spIHtcbiAgICAgIGZzLm9wZW4oIHBhdGhcbiAgICAgICAgICAgICAsIGNvbnN0YW50cy5PX1dST05MWSB8IGNvbnN0YW50cy5PX1NZTUxJTktcbiAgICAgICAgICAgICAsIG1vZGVcbiAgICAgICAgICAgICAsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVycilcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICAvLyBwcmVmZXIgdG8gcmV0dXJuIHRoZSBjaG1vZCBlcnJvciwgaWYgb25lIG9jY3VycyxcbiAgICAgICAgLy8gYnV0IHN0aWxsIHRyeSB0byBjbG9zZSwgYW5kIHJlcG9ydCBjbG9zaW5nIGVycm9ycyBpZiB0aGV5IG9jY3VyLlxuICAgICAgICBmcy5mY2htb2QoZmQsIG1vZGUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBmcy5jbG9zZShmZCwgZnVuY3Rpb24oZXJyMikge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIgfHwgZXJyMilcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmcy5sY2htb2RTeW5jID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUpIHtcbiAgICAgIHZhciBmZCA9IGZzLm9wZW5TeW5jKHBhdGgsIGNvbnN0YW50cy5PX1dST05MWSB8IGNvbnN0YW50cy5PX1NZTUxJTkssIG1vZGUpXG5cbiAgICAgIC8vIHByZWZlciB0byByZXR1cm4gdGhlIGNobW9kIGVycm9yLCBpZiBvbmUgb2NjdXJzLFxuICAgICAgLy8gYnV0IHN0aWxsIHRyeSB0byBjbG9zZSwgYW5kIHJlcG9ydCBjbG9zaW5nIGVycm9ycyBpZiB0aGV5IG9jY3VyLlxuICAgICAgdmFyIHRocmV3ID0gdHJ1ZVxuICAgICAgdmFyIHJldFxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0ID0gZnMuZmNobW9kU3luYyhmZCwgbW9kZSlcbiAgICAgICAgdGhyZXcgPSBmYWxzZVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRocmV3KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgICB9IGNhdGNoIChlcikge31cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXRcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaEx1dGltZXMgKGZzKSB7XG4gICAgaWYgKGNvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eShcIk9fU1lNTElOS1wiKSkge1xuICAgICAgZnMubHV0aW1lcyA9IGZ1bmN0aW9uIChwYXRoLCBhdCwgbXQsIGNiKSB7XG4gICAgICAgIGZzLm9wZW4ocGF0aCwgY29uc3RhbnRzLk9fU1lNTElOSywgZnVuY3Rpb24gKGVyLCBmZCkge1xuICAgICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgaWYgKGNiKSBjYihlcilcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBmcy5mdXRpbWVzKGZkLCBhdCwgbXQsIGZ1bmN0aW9uIChlcikge1xuICAgICAgICAgICAgZnMuY2xvc2UoZmQsIGZ1bmN0aW9uIChlcjIpIHtcbiAgICAgICAgICAgICAgaWYgKGNiKSBjYihlciB8fCBlcjIpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGZzLmx1dGltZXNTeW5jID0gZnVuY3Rpb24gKHBhdGgsIGF0LCBtdCkge1xuICAgICAgICB2YXIgZmQgPSBmcy5vcGVuU3luYyhwYXRoLCBjb25zdGFudHMuT19TWU1MSU5LKVxuICAgICAgICB2YXIgcmV0XG4gICAgICAgIHZhciB0aHJldyA9IHRydWVcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXQgPSBmcy5mdXRpbWVzU3luYyhmZCwgYXQsIG10KVxuICAgICAgICAgIHRocmV3ID0gZmFsc2VcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAodGhyZXcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVyKSB7fVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXRcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBmcy5sdXRpbWVzID0gZnVuY3Rpb24gKF9hLCBfYiwgX2MsIGNiKSB7IGlmIChjYikgcHJvY2Vzcy5uZXh0VGljayhjYikgfVxuICAgICAgZnMubHV0aW1lc1N5bmMgPSBmdW5jdGlvbiAoKSB7fVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNobW9kRml4IChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBtb2RlLCBjYikge1xuICAgICAgcmV0dXJuIG9yaWcuY2FsbChmcywgdGFyZ2V0LCBtb2RlLCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgICAgaWYgKGNob3duRXJPayhlcikpIGVyID0gbnVsbFxuICAgICAgICBpZiAoY2IpIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2htb2RGaXhTeW5jIChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBtb2RlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIG1vZGUpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBpZiAoIWNob3duRXJPayhlcikpIHRocm93IGVyXG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICBmdW5jdGlvbiBjaG93bkZpeCAob3JpZykge1xuICAgIGlmICghb3JpZykgcmV0dXJuIG9yaWdcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgdWlkLCBnaWQsIGNiKSB7XG4gICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIHVpZCwgZ2lkLCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgICAgaWYgKGNob3duRXJPayhlcikpIGVyID0gbnVsbFxuICAgICAgICBpZiAoY2IpIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hvd25GaXhTeW5jIChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCB1aWQsIGdpZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG9yaWcuY2FsbChmcywgdGFyZ2V0LCB1aWQsIGdpZClcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGlmICghY2hvd25Fck9rKGVyKSkgdGhyb3cgZXJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdGF0Rml4IChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIC8vIE9sZGVyIHZlcnNpb25zIG9mIE5vZGUgZXJyb25lb3VzbHkgcmV0dXJuZWQgc2lnbmVkIGludGVnZXJzIGZvclxuICAgIC8vIHVpZCArIGdpZC5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucywgY2IpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYiA9IG9wdGlvbnNcbiAgICAgICAgb3B0aW9ucyA9IG51bGxcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrIChlciwgc3RhdHMpIHtcbiAgICAgICAgaWYgKHN0YXRzKSB7XG4gICAgICAgICAgaWYgKHN0YXRzLnVpZCA8IDApIHN0YXRzLnVpZCArPSAweDEwMDAwMDAwMFxuICAgICAgICAgIGlmIChzdGF0cy5naWQgPCAwKSBzdGF0cy5naWQgKz0gMHgxMDAwMDAwMDBcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2IpIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zID8gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgICAgICA6IG9yaWcuY2FsbChmcywgdGFyZ2V0LCBjYWxsYmFjaylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdGF0Rml4U3luYyAob3JpZykge1xuICAgIGlmICghb3JpZykgcmV0dXJuIG9yaWdcbiAgICAvLyBPbGRlciB2ZXJzaW9ucyBvZiBOb2RlIGVycm9uZW91c2x5IHJldHVybmVkIHNpZ25lZCBpbnRlZ2VycyBmb3JcbiAgICAvLyB1aWQgKyBnaWQuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzdGF0cyA9IG9wdGlvbnMgPyBvcmlnLmNhbGwoZnMsIHRhcmdldCwgb3B0aW9ucylcbiAgICAgICAgOiBvcmlnLmNhbGwoZnMsIHRhcmdldClcbiAgICAgIGlmIChzdGF0cy51aWQgPCAwKSBzdGF0cy51aWQgKz0gMHgxMDAwMDAwMDBcbiAgICAgIGlmIChzdGF0cy5naWQgPCAwKSBzdGF0cy5naWQgKz0gMHgxMDAwMDAwMDBcbiAgICAgIHJldHVybiBzdGF0cztcbiAgICB9XG4gIH1cblxuICAvLyBFTk9TWVMgbWVhbnMgdGhhdCB0aGUgZnMgZG9lc24ndCBzdXBwb3J0IHRoZSBvcC4gSnVzdCBpZ25vcmVcbiAgLy8gdGhhdCwgYmVjYXVzZSBpdCBkb2Vzbid0IG1hdHRlci5cbiAgLy9cbiAgLy8gaWYgdGhlcmUncyBubyBnZXR1aWQsIG9yIGlmIGdldHVpZCgpIGlzIHNvbWV0aGluZyBvdGhlclxuICAvLyB0aGFuIDAsIGFuZCB0aGUgZXJyb3IgaXMgRUlOVkFMIG9yIEVQRVJNLCB0aGVuIGp1c3QgaWdub3JlXG4gIC8vIGl0LlxuICAvL1xuICAvLyBUaGlzIHNwZWNpZmljIGNhc2UgaXMgYSBzaWxlbnQgZmFpbHVyZSBpbiBjcCwgaW5zdGFsbCwgdGFyLFxuICAvLyBhbmQgbW9zdCBvdGhlciB1bml4IHRvb2xzIHRoYXQgbWFuYWdlIHBlcm1pc3Npb25zLlxuICAvL1xuICAvLyBXaGVuIHJ1bm5pbmcgYXMgcm9vdCwgb3IgaWYgb3RoZXIgdHlwZXMgb2YgZXJyb3JzIGFyZVxuICAvLyBlbmNvdW50ZXJlZCwgdGhlbiBpdCdzIHN0cmljdC5cbiAgZnVuY3Rpb24gY2hvd25Fck9rIChlcikge1xuICAgIGlmICghZXIpXG4gICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgaWYgKGVyLmNvZGUgPT09IFwiRU5PU1lTXCIpXG4gICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgdmFyIG5vbnJvb3QgPSAhcHJvY2Vzcy5nZXR1aWQgfHwgcHJvY2Vzcy5nZXR1aWQoKSAhPT0gMFxuICAgIGlmIChub25yb290KSB7XG4gICAgICBpZiAoZXIuY29kZSA9PT0gXCJFSU5WQUxcIiB8fCBlci5jb2RlID09PSBcIkVQRVJNXCIpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbiIsInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW1cblxubW9kdWxlLmV4cG9ydHMgPSBsZWdhY3lcblxuZnVuY3Rpb24gbGVnYWN5IChmcykge1xuICByZXR1cm4ge1xuICAgIFJlYWRTdHJlYW06IFJlYWRTdHJlYW0sXG4gICAgV3JpdGVTdHJlYW06IFdyaXRlU3RyZWFtXG4gIH1cblxuICBmdW5jdGlvbiBSZWFkU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRTdHJlYW0pKSByZXR1cm4gbmV3IFJlYWRTdHJlYW0ocGF0aCwgb3B0aW9ucyk7XG5cbiAgICBTdHJlYW0uY2FsbCh0aGlzKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5mZCA9IG51bGw7XG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuZmxhZ3MgPSAncic7XG4gICAgdGhpcy5tb2RlID0gNDM4OyAvKj0wNjY2Ki9cbiAgICB0aGlzLmJ1ZmZlclNpemUgPSA2NCAqIDEwMjQ7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIE1peGluIG9wdGlvbnMgaW50byB0aGlzXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVuY29kaW5nKSB0aGlzLnNldEVuY29kaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgaWYgKHRoaXMuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdGhpcy5zdGFydCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ3N0YXJ0IG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZW5kID0gSW5maW5pdHk7XG4gICAgICB9IGVsc2UgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdGhpcy5lbmQpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdlbmQgbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdGFydCA+IHRoaXMuZW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQgbXVzdCBiZSA8PSBlbmQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZkICE9PSBudWxsKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLl9yZWFkKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmcy5vcGVuKHRoaXMucGF0aCwgdGhpcy5mbGFncywgdGhpcy5tb2RlLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgc2VsZi5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNlbGYuZmQgPSBmZDtcbiAgICAgIHNlbGYuZW1pdCgnb3BlbicsIGZkKTtcbiAgICAgIHNlbGYuX3JlYWQoKTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gV3JpdGVTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGVTdHJlYW0pKSByZXR1cm4gbmV3IFdyaXRlU3RyZWFtKHBhdGgsIG9wdGlvbnMpO1xuXG4gICAgU3RyZWFtLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuZmQgPSBudWxsO1xuICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gICAgdGhpcy5mbGFncyA9ICd3JztcbiAgICB0aGlzLmVuY29kaW5nID0gJ2JpbmFyeSc7XG4gICAgdGhpcy5tb2RlID0gNDM4OyAvKj0wNjY2Ki9cbiAgICB0aGlzLmJ5dGVzV3JpdHRlbiA9IDA7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIE1peGluIG9wdGlvbnMgaW50byB0aGlzXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIHRoaXMuc3RhcnQpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdzdGFydCBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGFydCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydCBtdXN0IGJlID49IHplcm8nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0O1xuICAgIH1cblxuICAgIHRoaXMuYnVzeSA9IGZhbHNlO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG5cbiAgICBpZiAodGhpcy5mZCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fb3BlbiA9IGZzLm9wZW47XG4gICAgICB0aGlzLl9xdWV1ZS5wdXNoKFt0aGlzLl9vcGVuLCB0aGlzLnBhdGgsIHRoaXMuZmxhZ3MsIHRoaXMubW9kZSwgdW5kZWZpbmVkXSk7XG4gICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVxuXG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqLl9fcHJvdG9fX1xufVxuXG5mdW5jdGlvbiBjbG9uZSAob2JqKSB7XG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpXG4gICAgcmV0dXJuIG9ialxuXG4gIGlmIChvYmogaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgdmFyIGNvcHkgPSB7IF9fcHJvdG9fXzogZ2V0UHJvdG90eXBlT2Yob2JqKSB9XG4gIGVsc2VcbiAgICB2YXIgY29weSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb3B5LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpKVxuICB9KVxuXG4gIHJldHVybiBjb3B5XG59XG4iLCJ2YXIgZnMgPSByZXF1aXJlKCdmcycpXG52YXIgcG9seWZpbGxzID0gcmVxdWlyZSgnLi9wb2x5ZmlsbHMuanMnKVxudmFyIGxlZ2FjeSA9IHJlcXVpcmUoJy4vbGVnYWN5LXN0cmVhbXMuanMnKVxudmFyIGNsb25lID0gcmVxdWlyZSgnLi9jbG9uZS5qcycpXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gbm9kZSAwLnggcG9seWZpbGwgKi9cbnZhciBncmFjZWZ1bFF1ZXVlXG52YXIgcHJldmlvdXNTeW1ib2xcblxuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgLSBub2RlIDAueCBwb2x5ZmlsbCAqL1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5mb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgZ3JhY2VmdWxRdWV1ZSA9IFN5bWJvbC5mb3IoJ2dyYWNlZnVsLWZzLnF1ZXVlJylcbiAgLy8gVGhpcyBpcyB1c2VkIGluIHRlc3RpbmcgYnkgZnV0dXJlIHZlcnNpb25zXG4gIHByZXZpb3VzU3ltYm9sID0gU3ltYm9sLmZvcignZ3JhY2VmdWwtZnMucHJldmlvdXMnKVxufSBlbHNlIHtcbiAgZ3JhY2VmdWxRdWV1ZSA9ICdfX19ncmFjZWZ1bC1mcy5xdWV1ZSdcbiAgcHJldmlvdXNTeW1ib2wgPSAnX19fZ3JhY2VmdWwtZnMucHJldmlvdXMnXG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuZnVuY3Rpb24gcHVibGlzaFF1ZXVlKGNvbnRleHQsIHF1ZXVlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb250ZXh0LCBncmFjZWZ1bFF1ZXVlLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBxdWV1ZVxuICAgIH1cbiAgfSlcbn1cblxudmFyIGRlYnVnID0gbm9vcFxuaWYgKHV0aWwuZGVidWdsb2cpXG4gIGRlYnVnID0gdXRpbC5kZWJ1Z2xvZygnZ2ZzNCcpXG5lbHNlIGlmICgvXFxiZ2ZzNFxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJykpXG4gIGRlYnVnID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG0gPSB1dGlsLmZvcm1hdC5hcHBseSh1dGlsLCBhcmd1bWVudHMpXG4gICAgbSA9ICdHRlM0OiAnICsgbS5zcGxpdCgvXFxuLykuam9pbignXFxuR0ZTNDogJylcbiAgICBjb25zb2xlLmVycm9yKG0pXG4gIH1cblxuLy8gT25jZSB0aW1lIGluaXRpYWxpemF0aW9uXG5pZiAoIWZzW2dyYWNlZnVsUXVldWVdKSB7XG4gIC8vIFRoaXMgcXVldWUgY2FuIGJlIHNoYXJlZCBieSBtdWx0aXBsZSBsb2FkZWQgaW5zdGFuY2VzXG4gIHZhciBxdWV1ZSA9IGdsb2JhbFtncmFjZWZ1bFF1ZXVlXSB8fCBbXVxuICBwdWJsaXNoUXVldWUoZnMsIHF1ZXVlKVxuXG4gIC8vIFBhdGNoIGZzLmNsb3NlL2Nsb3NlU3luYyB0byBzaGFyZWQgcXVldWUgdmVyc2lvbiwgYmVjYXVzZSB3ZSBuZWVkXG4gIC8vIHRvIHJldHJ5KCkgd2hlbmV2ZXIgYSBjbG9zZSBoYXBwZW5zICphbnl3aGVyZSogaW4gdGhlIHByb2dyYW0uXG4gIC8vIFRoaXMgaXMgZXNzZW50aWFsIHdoZW4gbXVsdGlwbGUgZ3JhY2VmdWwtZnMgaW5zdGFuY2VzIGFyZVxuICAvLyBpbiBwbGF5IGF0IHRoZSBzYW1lIHRpbWUuXG4gIGZzLmNsb3NlID0gKGZ1bmN0aW9uIChmcyRjbG9zZSkge1xuICAgIGZ1bmN0aW9uIGNsb3NlIChmZCwgY2IpIHtcbiAgICAgIHJldHVybiBmcyRjbG9zZS5jYWxsKGZzLCBmZCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIHVzZXMgdGhlIGdyYWNlZnVsLWZzIHNoYXJlZCBxdWV1ZVxuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIHJlc2V0UXVldWUoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9KVxuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbG9zZSwgcHJldmlvdXNTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmcyRjbG9zZVxuICAgIH0pXG4gICAgcmV0dXJuIGNsb3NlXG4gIH0pKGZzLmNsb3NlKVxuXG4gIGZzLmNsb3NlU3luYyA9IChmdW5jdGlvbiAoZnMkY2xvc2VTeW5jKSB7XG4gICAgZnVuY3Rpb24gY2xvc2VTeW5jIChmZCkge1xuICAgICAgLy8gVGhpcyBmdW5jdGlvbiB1c2VzIHRoZSBncmFjZWZ1bC1mcyBzaGFyZWQgcXVldWVcbiAgICAgIGZzJGNsb3NlU3luYy5hcHBseShmcywgYXJndW1lbnRzKVxuICAgICAgcmVzZXRRdWV1ZSgpXG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb3NlU3luYywgcHJldmlvdXNTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmcyRjbG9zZVN5bmNcbiAgICB9KVxuICAgIHJldHVybiBjbG9zZVN5bmNcbiAgfSkoZnMuY2xvc2VTeW5jKVxuXG4gIGlmICgvXFxiZ2ZzNFxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJykpIHtcbiAgICBwcm9jZXNzLm9uKCdleGl0JywgZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zyhmc1tncmFjZWZ1bFF1ZXVlXSlcbiAgICAgIHJlcXVpcmUoJ2Fzc2VydCcpLmVxdWFsKGZzW2dyYWNlZnVsUXVldWVdLmxlbmd0aCwgMClcbiAgICB9KVxuICB9XG59XG5cbmlmICghZ2xvYmFsW2dyYWNlZnVsUXVldWVdKSB7XG4gIHB1Ymxpc2hRdWV1ZShnbG9iYWwsIGZzW2dyYWNlZnVsUXVldWVdKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaChjbG9uZShmcykpXG5pZiAocHJvY2Vzcy5lbnYuVEVTVF9HUkFDRUZVTF9GU19HTE9CQUxfUEFUQ0ggJiYgIWZzLl9fcGF0Y2hlZCkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcGF0Y2goZnMpXG4gICAgZnMuX19wYXRjaGVkID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcGF0Y2ggKGZzKSB7XG4gIC8vIEV2ZXJ5dGhpbmcgdGhhdCByZWZlcmVuY2VzIHRoZSBvcGVuKCkgZnVuY3Rpb24gbmVlZHMgdG8gYmUgaW4gaGVyZVxuICBwb2x5ZmlsbHMoZnMpXG4gIGZzLmdyYWNlZnVsaWZ5ID0gcGF0Y2hcblxuICBmcy5jcmVhdGVSZWFkU3RyZWFtID0gY3JlYXRlUmVhZFN0cmVhbVxuICBmcy5jcmVhdGVXcml0ZVN0cmVhbSA9IGNyZWF0ZVdyaXRlU3RyZWFtXG4gIHZhciBmcyRyZWFkRmlsZSA9IGZzLnJlYWRGaWxlXG4gIGZzLnJlYWRGaWxlID0gcmVhZEZpbGVcbiAgZnVuY3Rpb24gcmVhZEZpbGUgKHBhdGgsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBvcHRpb25zLCBvcHRpb25zID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJHJlYWRGaWxlKHBhdGgsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kcmVhZEZpbGUgKHBhdGgsIG9wdGlvbnMsIGNiLCBzdGFydFRpbWUpIHtcbiAgICAgIHJldHVybiBmcyRyZWFkRmlsZShwYXRoLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJHJlYWRGaWxlLCBbcGF0aCwgb3B0aW9ucywgY2JdLCBlcnIsIHN0YXJ0VGltZSB8fCBEYXRlLm5vdygpLCBEYXRlLm5vdygpXSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICB2YXIgZnMkd3JpdGVGaWxlID0gZnMud3JpdGVGaWxlXG4gIGZzLndyaXRlRmlsZSA9IHdyaXRlRmlsZVxuICBmdW5jdGlvbiB3cml0ZUZpbGUgKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBvcHRpb25zLCBvcHRpb25zID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJHdyaXRlRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBjYilcblxuICAgIGZ1bmN0aW9uIGdvJHdyaXRlRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IsIHN0YXJ0VGltZSkge1xuICAgICAgcmV0dXJuIGZzJHdyaXRlRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJHdyaXRlRmlsZSwgW3BhdGgsIGRhdGEsIG9wdGlvbnMsIGNiXSwgZXJyLCBzdGFydFRpbWUgfHwgRGF0ZS5ub3coKSwgRGF0ZS5ub3coKV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgdmFyIGZzJGFwcGVuZEZpbGUgPSBmcy5hcHBlbmRGaWxlXG4gIGlmIChmcyRhcHBlbmRGaWxlKVxuICAgIGZzLmFwcGVuZEZpbGUgPSBhcHBlbmRGaWxlXG4gIGZ1bmN0aW9uIGFwcGVuZEZpbGUgKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBvcHRpb25zLCBvcHRpb25zID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJGFwcGVuZEZpbGUocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpXG5cbiAgICBmdW5jdGlvbiBnbyRhcHBlbmRGaWxlIChwYXRoLCBkYXRhLCBvcHRpb25zLCBjYiwgc3RhcnRUaW1lKSB7XG4gICAgICByZXR1cm4gZnMkYXBwZW5kRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJGFwcGVuZEZpbGUsIFtwYXRoLCBkYXRhLCBvcHRpb25zLCBjYl0sIGVyciwgc3RhcnRUaW1lIHx8IERhdGUubm93KCksIERhdGUubm93KCldKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyRjb3B5RmlsZSA9IGZzLmNvcHlGaWxlXG4gIGlmIChmcyRjb3B5RmlsZSlcbiAgICBmcy5jb3B5RmlsZSA9IGNvcHlGaWxlXG4gIGZ1bmN0aW9uIGNvcHlGaWxlIChzcmMsIGRlc3QsIGZsYWdzLCBjYikge1xuICAgIGlmICh0eXBlb2YgZmxhZ3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gZmxhZ3NcbiAgICAgIGZsYWdzID0gMFxuICAgIH1cbiAgICByZXR1cm4gZ28kY29weUZpbGUoc3JjLCBkZXN0LCBmbGFncywgY2IpXG5cbiAgICBmdW5jdGlvbiBnbyRjb3B5RmlsZSAoc3JjLCBkZXN0LCBmbGFncywgY2IsIHN0YXJ0VGltZSkge1xuICAgICAgcmV0dXJuIGZzJGNvcHlGaWxlKHNyYywgZGVzdCwgZmxhZ3MsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kY29weUZpbGUsIFtzcmMsIGRlc3QsIGZsYWdzLCBjYl0sIGVyciwgc3RhcnRUaW1lIHx8IERhdGUubm93KCksIERhdGUubm93KCldKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyRyZWFkZGlyID0gZnMucmVhZGRpclxuICBmcy5yZWFkZGlyID0gcmVhZGRpclxuICBmdW5jdGlvbiByZWFkZGlyIChwYXRoLCBvcHRpb25zLCBjYikge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gb3B0aW9ucywgb3B0aW9ucyA9IG51bGxcblxuICAgIHJldHVybiBnbyRyZWFkZGlyKHBhdGgsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kcmVhZGRpciAocGF0aCwgb3B0aW9ucywgY2IsIHN0YXJ0VGltZSkge1xuICAgICAgcmV0dXJuIGZzJHJlYWRkaXIocGF0aCwgb3B0aW9ucywgZnVuY3Rpb24gKGVyciwgZmlsZXMpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kcmVhZGRpciwgW3BhdGgsIG9wdGlvbnMsIGNiXSwgZXJyLCBzdGFydFRpbWUgfHwgRGF0ZS5ub3coKSwgRGF0ZS5ub3coKV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChmaWxlcyAmJiBmaWxlcy5zb3J0KVxuICAgICAgICAgICAgZmlsZXMuc29ydCgpXG5cbiAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IuY2FsbCh0aGlzLCBlcnIsIGZpbGVzKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLnZlcnNpb24uc3Vic3RyKDAsIDQpID09PSAndjAuOCcpIHtcbiAgICB2YXIgbGVnU3RyZWFtcyA9IGxlZ2FjeShmcylcbiAgICBSZWFkU3RyZWFtID0gbGVnU3RyZWFtcy5SZWFkU3RyZWFtXG4gICAgV3JpdGVTdHJlYW0gPSBsZWdTdHJlYW1zLldyaXRlU3RyZWFtXG4gIH1cblxuICB2YXIgZnMkUmVhZFN0cmVhbSA9IGZzLlJlYWRTdHJlYW1cbiAgaWYgKGZzJFJlYWRTdHJlYW0pIHtcbiAgICBSZWFkU3RyZWFtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZnMkUmVhZFN0cmVhbS5wcm90b3R5cGUpXG4gICAgUmVhZFN0cmVhbS5wcm90b3R5cGUub3BlbiA9IFJlYWRTdHJlYW0kb3BlblxuICB9XG5cbiAgdmFyIGZzJFdyaXRlU3RyZWFtID0gZnMuV3JpdGVTdHJlYW1cbiAgaWYgKGZzJFdyaXRlU3RyZWFtKSB7XG4gICAgV3JpdGVTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShmcyRXcml0ZVN0cmVhbS5wcm90b3R5cGUpXG4gICAgV3JpdGVTdHJlYW0ucHJvdG90eXBlLm9wZW4gPSBXcml0ZVN0cmVhbSRvcGVuXG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnMsICdSZWFkU3RyZWFtJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFJlYWRTdHJlYW1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgUmVhZFN0cmVhbSA9IHZhbFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZzLCAnV3JpdGVTdHJlYW0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gV3JpdGVTdHJlYW1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgV3JpdGVTdHJlYW0gPSB2YWxcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG5cbiAgLy8gbGVnYWN5IG5hbWVzXG4gIHZhciBGaWxlUmVhZFN0cmVhbSA9IFJlYWRTdHJlYW1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZzLCAnRmlsZVJlYWRTdHJlYW0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gRmlsZVJlYWRTdHJlYW1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgRmlsZVJlYWRTdHJlYW0gPSB2YWxcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG4gIHZhciBGaWxlV3JpdGVTdHJlYW0gPSBXcml0ZVN0cmVhbVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnMsICdGaWxlV3JpdGVTdHJlYW0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gRmlsZVdyaXRlU3RyZWFtXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIEZpbGVXcml0ZVN0cmVhbSA9IHZhbFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcblxuICBmdW5jdGlvbiBSZWFkU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBSZWFkU3RyZWFtKVxuICAgICAgcmV0dXJuIGZzJFJlYWRTdHJlYW0uYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdGhpc1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBSZWFkU3RyZWFtLmFwcGx5KE9iamVjdC5jcmVhdGUoUmVhZFN0cmVhbS5wcm90b3R5cGUpLCBhcmd1bWVudHMpXG4gIH1cblxuICBmdW5jdGlvbiBSZWFkU3RyZWFtJG9wZW4gKCkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIG9wZW4odGhhdC5wYXRoLCB0aGF0LmZsYWdzLCB0aGF0Lm1vZGUsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmICh0aGF0LmF1dG9DbG9zZSlcbiAgICAgICAgICB0aGF0LmRlc3Ryb3koKVxuXG4gICAgICAgIHRoYXQuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGF0LmZkID0gZmRcbiAgICAgICAgdGhhdC5lbWl0KCdvcGVuJywgZmQpXG4gICAgICAgIHRoYXQucmVhZCgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIFdyaXRlU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBXcml0ZVN0cmVhbSlcbiAgICAgIHJldHVybiBmcyRXcml0ZVN0cmVhbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0aGlzXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIFdyaXRlU3RyZWFtLmFwcGx5KE9iamVjdC5jcmVhdGUoV3JpdGVTdHJlYW0ucHJvdG90eXBlKSwgYXJndW1lbnRzKVxuICB9XG5cbiAgZnVuY3Rpb24gV3JpdGVTdHJlYW0kb3BlbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgb3Blbih0aGF0LnBhdGgsIHRoYXQuZmxhZ3MsIHRoYXQubW9kZSwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhhdC5kZXN0cm95KClcbiAgICAgICAgdGhhdC5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoYXQuZmQgPSBmZFxuICAgICAgICB0aGF0LmVtaXQoJ29wZW4nLCBmZClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUmVhZFN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgZnMuUmVhZFN0cmVhbShwYXRoLCBvcHRpb25zKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlV3JpdGVTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IGZzLldyaXRlU3RyZWFtKHBhdGgsIG9wdGlvbnMpXG4gIH1cblxuICB2YXIgZnMkb3BlbiA9IGZzLm9wZW5cbiAgZnMub3BlbiA9IG9wZW5cbiAgZnVuY3Rpb24gb3BlbiAocGF0aCwgZmxhZ3MsIG1vZGUsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBtb2RlID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBtb2RlLCBtb2RlID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJG9wZW4ocGF0aCwgZmxhZ3MsIG1vZGUsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kb3BlbiAocGF0aCwgZmxhZ3MsIG1vZGUsIGNiLCBzdGFydFRpbWUpIHtcbiAgICAgIHJldHVybiBmcyRvcGVuKHBhdGgsIGZsYWdzLCBtb2RlLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgICBpZiAoZXJyICYmIChlcnIuY29kZSA9PT0gJ0VNRklMRScgfHwgZXJyLmNvZGUgPT09ICdFTkZJTEUnKSlcbiAgICAgICAgICBlbnF1ZXVlKFtnbyRvcGVuLCBbcGF0aCwgZmxhZ3MsIG1vZGUsIGNiXSwgZXJyLCBzdGFydFRpbWUgfHwgRGF0ZS5ub3coKSwgRGF0ZS5ub3coKV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZzXG59XG5cbmZ1bmN0aW9uIGVucXVldWUgKGVsZW0pIHtcbiAgZGVidWcoJ0VOUVVFVUUnLCBlbGVtWzBdLm5hbWUsIGVsZW1bMV0pXG4gIGZzW2dyYWNlZnVsUXVldWVdLnB1c2goZWxlbSlcbiAgcmV0cnkoKVxufVxuXG4vLyBrZWVwIHRyYWNrIG9mIHRoZSB0aW1lb3V0IGJldHdlZW4gcmV0cnkoKSBjYWxsc1xudmFyIHJldHJ5VGltZXJcblxuLy8gcmVzZXQgdGhlIHN0YXJ0VGltZSBhbmQgbGFzdFRpbWUgdG8gbm93XG4vLyB0aGlzIHJlc2V0cyB0aGUgc3RhcnQgb2YgdGhlIDYwIHNlY29uZCBvdmVyYWxsIHRpbWVvdXQgYXMgd2VsbCBhcyB0aGVcbi8vIGRlbGF5IGJldHdlZW4gYXR0ZW1wdHMgc28gdGhhdCB3ZSdsbCByZXRyeSB0aGVzZSBqb2JzIHNvb25lclxuZnVuY3Rpb24gcmVzZXRRdWV1ZSAoKSB7XG4gIHZhciBub3cgPSBEYXRlLm5vdygpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnNbZ3JhY2VmdWxRdWV1ZV0ubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBlbnRyaWVzIHRoYXQgYXJlIG9ubHkgYSBsZW5ndGggb2YgMiBhcmUgZnJvbSBhbiBvbGRlciB2ZXJzaW9uLCBkb24ndFxuICAgIC8vIGJvdGhlciBtb2RpZnlpbmcgdGhvc2Ugc2luY2UgdGhleSdsbCBiZSByZXRyaWVkIGFueXdheS5cbiAgICBpZiAoZnNbZ3JhY2VmdWxRdWV1ZV1baV0ubGVuZ3RoID4gMikge1xuICAgICAgZnNbZ3JhY2VmdWxRdWV1ZV1baV1bM10gPSBub3cgLy8gc3RhcnRUaW1lXG4gICAgICBmc1tncmFjZWZ1bFF1ZXVlXVtpXVs0XSA9IG5vdyAvLyBsYXN0VGltZVxuICAgIH1cbiAgfVxuICAvLyBjYWxsIHJldHJ5IHRvIG1ha2Ugc3VyZSB3ZSdyZSBhY3RpdmVseSBwcm9jZXNzaW5nIHRoZSBxdWV1ZVxuICByZXRyeSgpXG59XG5cbmZ1bmN0aW9uIHJldHJ5ICgpIHtcbiAgLy8gY2xlYXIgdGhlIHRpbWVyIGFuZCByZW1vdmUgaXQgdG8gaGVscCBwcmV2ZW50IHVuaW50ZW5kZWQgY29uY3VycmVuY3lcbiAgY2xlYXJUaW1lb3V0KHJldHJ5VGltZXIpXG4gIHJldHJ5VGltZXIgPSB1bmRlZmluZWRcblxuICBpZiAoZnNbZ3JhY2VmdWxRdWV1ZV0ubGVuZ3RoID09PSAwKVxuICAgIHJldHVyblxuXG4gIHZhciBlbGVtID0gZnNbZ3JhY2VmdWxRdWV1ZV0uc2hpZnQoKVxuICB2YXIgZm4gPSBlbGVtWzBdXG4gIHZhciBhcmdzID0gZWxlbVsxXVxuICAvLyB0aGVzZSBpdGVtcyBtYXkgYmUgdW5zZXQgaWYgdGhleSB3ZXJlIGFkZGVkIGJ5IGFuIG9sZGVyIGdyYWNlZnVsLWZzXG4gIHZhciBlcnIgPSBlbGVtWzJdXG4gIHZhciBzdGFydFRpbWUgPSBlbGVtWzNdXG4gIHZhciBsYXN0VGltZSA9IGVsZW1bNF1cblxuICAvLyBpZiB3ZSBkb24ndCBoYXZlIGEgc3RhcnRUaW1lIHdlIGhhdmUgbm8gd2F5IG9mIGtub3dpbmcgaWYgd2UndmUgd2FpdGVkXG4gIC8vIGxvbmcgZW5vdWdoLCBzbyBnbyBhaGVhZCBhbmQgcmV0cnkgdGhpcyBpdGVtIG5vd1xuICBpZiAoc3RhcnRUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICBkZWJ1ZygnUkVUUlknLCBmbi5uYW1lLCBhcmdzKVxuICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpXG4gIH0gZWxzZSBpZiAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA+PSA2MDAwMCkge1xuICAgIC8vIGl0J3MgYmVlbiBtb3JlIHRoYW4gNjAgc2Vjb25kcyB0b3RhbCwgYmFpbCBub3dcbiAgICBkZWJ1ZygnVElNRU9VVCcsIGZuLm5hbWUsIGFyZ3MpXG4gICAgdmFyIGNiID0gYXJncy5wb3AoKVxuICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYi5jYWxsKG51bGwsIGVycilcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgYW1vdW50IG9mIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBhdHRlbXB0IGFuZCByaWdodCBub3dcbiAgICB2YXIgc2luY2VBdHRlbXB0ID0gRGF0ZS5ub3coKSAtIGxhc3RUaW1lXG4gICAgLy8gdGhlIGFtb3VudCBvZiB0aW1lIGJldHdlZW4gd2hlbiB3ZSBmaXJzdCB0cmllZCwgYW5kIHdoZW4gd2UgbGFzdCB0cmllZFxuICAgIC8vIHJvdW5kZWQgdXAgdG8gYXQgbGVhc3QgMVxuICAgIHZhciBzaW5jZVN0YXJ0ID0gTWF0aC5tYXgobGFzdFRpbWUgLSBzdGFydFRpbWUsIDEpXG4gICAgLy8gYmFja29mZi4gd2FpdCBsb25nZXIgdGhhbiB0aGUgdG90YWwgdGltZSB3ZSd2ZSBiZWVuIHJldHJ5aW5nLCBidXQgb25seVxuICAgIC8vIHVwIHRvIGEgbWF4aW11bSBvZiAxMDBtc1xuICAgIHZhciBkZXNpcmVkRGVsYXkgPSBNYXRoLm1pbihzaW5jZVN0YXJ0ICogMS4yLCAxMDApXG4gICAgLy8gaXQncyBiZWVuIGxvbmcgZW5vdWdoIHNpbmNlIHRoZSBsYXN0IHJldHJ5LCBkbyBpdCBhZ2FpblxuICAgIGlmIChzaW5jZUF0dGVtcHQgPj0gZGVzaXJlZERlbGF5KSB7XG4gICAgICBkZWJ1ZygnUkVUUlknLCBmbi5uYW1lLCBhcmdzKVxuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoW3N0YXJ0VGltZV0pKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiB3ZSBjYW4ndCBkbyB0aGlzIGpvYiB5ZXQsIHB1c2ggaXQgdG8gdGhlIGVuZCBvZiB0aGUgcXVldWVcbiAgICAgIC8vIGFuZCBsZXQgdGhlIG5leHQgaXRlcmF0aW9uIGNoZWNrIGFnYWluXG4gICAgICBmc1tncmFjZWZ1bFF1ZXVlXS5wdXNoKGVsZW0pXG4gICAgfVxuICB9XG5cbiAgLy8gc2NoZWR1bGUgb3VyIG5leHQgcnVuIGlmIG9uZSBpc24ndCBhbHJlYWR5IHNjaGVkdWxlZFxuICBpZiAocmV0cnlUaW1lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0cnlUaW1lciA9IHNldFRpbWVvdXQocmV0cnksIDApXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuLy8gVGhpcyBpcyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL25vcm1hbGl6ZS9telxuLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTYgSm9uYXRoYW4gT25nIG1lQGpvbmdsZWJlcnJ5LmNvbSBhbmQgQ29udHJpYnV0b3JzXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcblxuY29uc3QgYXBpID0gW1xuICAnYWNjZXNzJyxcbiAgJ2FwcGVuZEZpbGUnLFxuICAnY2htb2QnLFxuICAnY2hvd24nLFxuICAnY2xvc2UnLFxuICAnY29weUZpbGUnLFxuICAnZmNobW9kJyxcbiAgJ2ZjaG93bicsXG4gICdmZGF0YXN5bmMnLFxuICAnZnN0YXQnLFxuICAnZnN5bmMnLFxuICAnZnRydW5jYXRlJyxcbiAgJ2Z1dGltZXMnLFxuICAnbGNobW9kJyxcbiAgJ2xjaG93bicsXG4gICdsaW5rJyxcbiAgJ2xzdGF0JyxcbiAgJ21rZGlyJyxcbiAgJ21rZHRlbXAnLFxuICAnb3BlbicsXG4gICdvcGVuZGlyJyxcbiAgJ3JlYWRkaXInLFxuICAncmVhZEZpbGUnLFxuICAncmVhZGxpbmsnLFxuICAncmVhbHBhdGgnLFxuICAncmVuYW1lJyxcbiAgJ3JtJyxcbiAgJ3JtZGlyJyxcbiAgJ3N0YXQnLFxuICAnc3ltbGluaycsXG4gICd0cnVuY2F0ZScsXG4gICd1bmxpbmsnLFxuICAndXRpbWVzJyxcbiAgJ3dyaXRlRmlsZSdcbl0uZmlsdGVyKGtleSA9PiB7XG4gIC8vIFNvbWUgY29tbWFuZHMgYXJlIG5vdCBhdmFpbGFibGUgb24gc29tZSBzeXN0ZW1zLiBFeDpcbiAgLy8gZnMuY3Agd2FzIGFkZGVkIGluIE5vZGUuanMgdjE2LjcuMFxuICAvLyBmcy5sY2hvd24gaXMgbm90IGF2YWlsYWJsZSBvbiBhdCBsZWFzdCBzb21lIExpbnV4XG4gIHJldHVybiB0eXBlb2YgZnNba2V5XSA9PT0gJ2Z1bmN0aW9uJ1xufSlcblxuLy8gRXhwb3J0IGNsb25lZCBmczpcbk9iamVjdC5hc3NpZ24oZXhwb3J0cywgZnMpXG5cbi8vIFVuaXZlcnNhbGlmeSBhc3luYyBtZXRob2RzOlxuYXBpLmZvckVhY2gobWV0aG9kID0+IHtcbiAgZXhwb3J0c1ttZXRob2RdID0gdShmc1ttZXRob2RdKVxufSlcblxuLy8gV2UgZGlmZmVyIGZyb20gbXovZnMgaW4gdGhhdCB3ZSBzdGlsbCBzaGlwIHRoZSBvbGQsIGJyb2tlbiwgZnMuZXhpc3RzKClcbi8vIHNpbmNlIHdlIGFyZSBhIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIHRoZSBuYXRpdmUgbW9kdWxlXG5leHBvcnRzLmV4aXN0cyA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmcy5leGlzdHMoZmlsZW5hbWUsIGNhbGxiYWNrKVxuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICByZXR1cm4gZnMuZXhpc3RzKGZpbGVuYW1lLCByZXNvbHZlKVxuICB9KVxufVxuXG4vLyBmcy5yZWFkKCksIGZzLndyaXRlKCksIGZzLnJlYWR2KCksICYgZnMud3JpdGV2KCkgbmVlZCBzcGVjaWFsIHRyZWF0bWVudCBkdWUgdG8gbXVsdGlwbGUgY2FsbGJhY2sgYXJnc1xuXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZzLnJlYWQoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaylcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZzLnJlYWQoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCAoZXJyLCBieXRlc1JlYWQsIGJ1ZmZlcikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICByZXNvbHZlKHsgYnl0ZXNSZWFkLCBidWZmZXIgfSlcbiAgICB9KVxuICB9KVxufVxuXG4vLyBGdW5jdGlvbiBzaWduYXR1cmUgY2FuIGJlXG4vLyBmcy53cml0ZShmZCwgYnVmZmVyWywgb2Zmc2V0WywgbGVuZ3RoWywgcG9zaXRpb25dXV0sIGNhbGxiYWNrKVxuLy8gT1Jcbi8vIGZzLndyaXRlKGZkLCBzdHJpbmdbLCBwb3NpdGlvblssIGVuY29kaW5nXV0sIGNhbGxiYWNrKVxuLy8gV2UgbmVlZCB0byBoYW5kbGUgYm90aCBjYXNlcywgc28gd2UgdXNlIC4uLmFyZ3NcbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoZmQsIGJ1ZmZlciwgLi4uYXJncykge1xuICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmcy53cml0ZShmZCwgYnVmZmVyLCAuLi5hcmdzKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmcy53cml0ZShmZCwgYnVmZmVyLCAuLi5hcmdzLCAoZXJyLCBieXRlc1dyaXR0ZW4sIGJ1ZmZlcikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICByZXNvbHZlKHsgYnl0ZXNXcml0dGVuLCBidWZmZXIgfSlcbiAgICB9KVxuICB9KVxufVxuXG4vLyBGdW5jdGlvbiBzaWduYXR1cmUgaXNcbi8vIHMucmVhZHYoZmQsIGJ1ZmZlcnNbLCBwb3NpdGlvbl0sIGNhbGxiYWNrKVxuLy8gV2UgbmVlZCB0byBoYW5kbGUgdGhlIG9wdGlvbmFsIGFyZywgc28gd2UgdXNlIC4uLmFyZ3NcbmV4cG9ydHMucmVhZHYgPSBmdW5jdGlvbiAoZmQsIGJ1ZmZlcnMsIC4uLmFyZ3MpIHtcbiAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnMucmVhZHYoZmQsIGJ1ZmZlcnMsIC4uLmFyZ3MpXG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZzLnJlYWR2KGZkLCBidWZmZXJzLCAuLi5hcmdzLCAoZXJyLCBieXRlc1JlYWQsIGJ1ZmZlcnMpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgcmVzb2x2ZSh7IGJ5dGVzUmVhZCwgYnVmZmVycyB9KVxuICAgIH0pXG4gIH0pXG59XG5cbi8vIEZ1bmN0aW9uIHNpZ25hdHVyZSBpc1xuLy8gcy53cml0ZXYoZmQsIGJ1ZmZlcnNbLCBwb3NpdGlvbl0sIGNhbGxiYWNrKVxuLy8gV2UgbmVlZCB0byBoYW5kbGUgdGhlIG9wdGlvbmFsIGFyZywgc28gd2UgdXNlIC4uLmFyZ3NcbmV4cG9ydHMud3JpdGV2ID0gZnVuY3Rpb24gKGZkLCBidWZmZXJzLCAuLi5hcmdzKSB7XG4gIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZzLndyaXRldihmZCwgYnVmZmVycywgLi4uYXJncylcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnMud3JpdGV2KGZkLCBidWZmZXJzLCAuLi5hcmdzLCAoZXJyLCBieXRlc1dyaXR0ZW4sIGJ1ZmZlcnMpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgcmVzb2x2ZSh7IGJ5dGVzV3JpdHRlbiwgYnVmZmVycyB9KVxuICAgIH0pXG4gIH0pXG59XG5cbi8vIGZzLnJlYWxwYXRoLm5hdGl2ZSBzb21ldGltZXMgbm90IGF2YWlsYWJsZSBpZiBmcyBpcyBtb25rZXktcGF0Y2hlZFxuaWYgKHR5cGVvZiBmcy5yZWFscGF0aC5uYXRpdmUgPT09ICdmdW5jdGlvbicpIHtcbiAgZXhwb3J0cy5yZWFscGF0aC5uYXRpdmUgPSB1KGZzLnJlYWxwYXRoLm5hdGl2ZSlcbn0gZWxzZSB7XG4gIHByb2Nlc3MuZW1pdFdhcm5pbmcoXG4gICAgJ2ZzLnJlYWxwYXRoLm5hdGl2ZSBpcyBub3QgYSBmdW5jdGlvbi4gSXMgZnMgYmVpbmcgbW9ua2V5LXBhdGNoZWQ/JyxcbiAgICAnV2FybmluZycsICdmcy1leHRyYS1XQVJOMDAwMydcbiAgKVxufVxuIiwiLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvbWFrZS1kaXJcbi8vIENvcHlyaWdodCAoYykgU2luZHJlIFNvcmh1cyA8c2luZHJlc29yaHVzQGdtYWlsLmNvbT4gKHNpbmRyZXNvcmh1cy5jb20pXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbid1c2Ugc3RyaWN0J1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzg5ODdcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9saWJ1di9saWJ1di9wdWxsLzEwODhcbm1vZHVsZS5leHBvcnRzLmNoZWNrUGF0aCA9IGZ1bmN0aW9uIGNoZWNrUGF0aCAocHRoKSB7XG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgY29uc3QgcGF0aEhhc0ludmFsaWRXaW5DaGFyYWN0ZXJzID0gL1s8PjpcInw/Kl0vLnRlc3QocHRoLnJlcGxhY2UocGF0aC5wYXJzZShwdGgpLnJvb3QsICcnKSlcblxuICAgIGlmIChwYXRoSGFzSW52YWxpZFdpbkNoYXJhY3RlcnMpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBQYXRoIGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVyczogJHtwdGh9YClcbiAgICAgIGVycm9yLmNvZGUgPSAnRUlOVkFMJ1xuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5jb25zdCB7IGNoZWNrUGF0aCB9ID0gcmVxdWlyZSgnLi91dGlscycpXG5cbmNvbnN0IGdldE1vZGUgPSBvcHRpb25zID0+IHtcbiAgY29uc3QgZGVmYXVsdHMgPSB7IG1vZGU6IDBvNzc3IH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykgcmV0dXJuIG9wdGlvbnNcbiAgcmV0dXJuICh7IC4uLmRlZmF1bHRzLCAuLi5vcHRpb25zIH0pLm1vZGVcbn1cblxubW9kdWxlLmV4cG9ydHMubWFrZURpciA9IGFzeW5jIChkaXIsIG9wdGlvbnMpID0+IHtcbiAgY2hlY2tQYXRoKGRpcilcblxuICByZXR1cm4gZnMubWtkaXIoZGlyLCB7XG4gICAgbW9kZTogZ2V0TW9kZShvcHRpb25zKSxcbiAgICByZWN1cnNpdmU6IHRydWVcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMubWFrZURpclN5bmMgPSAoZGlyLCBvcHRpb25zKSA9PiB7XG4gIGNoZWNrUGF0aChkaXIpXG5cbiAgcmV0dXJuIGZzLm1rZGlyU3luYyhkaXIsIHtcbiAgICBtb2RlOiBnZXRNb2RlKG9wdGlvbnMpLFxuICAgIHJlY3Vyc2l2ZTogdHJ1ZVxuICB9KVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2VcbmNvbnN0IHsgbWFrZURpcjogX21ha2VEaXIsIG1ha2VEaXJTeW5jIH0gPSByZXF1aXJlKCcuL21ha2UtZGlyJylcbmNvbnN0IG1ha2VEaXIgPSB1KF9tYWtlRGlyKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWtkaXJzOiBtYWtlRGlyLFxuICBta2RpcnNTeW5jOiBtYWtlRGlyU3luYyxcbiAgLy8gYWxpYXNcbiAgbWtkaXJwOiBtYWtlRGlyLFxuICBta2RpcnBTeW5jOiBtYWtlRGlyU3luYyxcbiAgZW5zdXJlRGlyOiBtYWtlRGlyLFxuICBlbnN1cmVEaXJTeW5jOiBtYWtlRGlyU3luY1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2VcbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vZnMnKVxuXG5mdW5jdGlvbiBwYXRoRXhpc3RzIChwYXRoKSB7XG4gIHJldHVybiBmcy5hY2Nlc3MocGF0aCkudGhlbigoKSA9PiB0cnVlKS5jYXRjaCgoKSA9PiBmYWxzZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhdGhFeGlzdHM6IHUocGF0aEV4aXN0cyksXG4gIHBhdGhFeGlzdHNTeW5jOiBmcy5leGlzdHNTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2VcblxuYXN5bmMgZnVuY3Rpb24gdXRpbWVzTWlsbGlzIChwYXRoLCBhdGltZSwgbXRpbWUpIHtcbiAgLy8gaWYgKCFIQVNfTUlMTElTX1JFUykgcmV0dXJuIGZzLnV0aW1lcyhwYXRoLCBhdGltZSwgbXRpbWUsIGNhbGxiYWNrKVxuICBjb25zdCBmZCA9IGF3YWl0IGZzLm9wZW4ocGF0aCwgJ3IrJylcblxuICBsZXQgY2xvc2VFcnIgPSBudWxsXG5cbiAgdHJ5IHtcbiAgICBhd2FpdCBmcy5mdXRpbWVzKGZkLCBhdGltZSwgbXRpbWUpXG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGZzLmNsb3NlKGZkKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNsb3NlRXJyID0gZVxuICAgIH1cbiAgfVxuXG4gIGlmIChjbG9zZUVycikge1xuICAgIHRocm93IGNsb3NlRXJyXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRpbWVzTWlsbGlzU3luYyAocGF0aCwgYXRpbWUsIG10aW1lKSB7XG4gIGNvbnN0IGZkID0gZnMub3BlblN5bmMocGF0aCwgJ3IrJylcbiAgZnMuZnV0aW1lc1N5bmMoZmQsIGF0aW1lLCBtdGltZSlcbiAgcmV0dXJuIGZzLmNsb3NlU3luYyhmZClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHV0aW1lc01pbGxpczogdSh1dGltZXNNaWxsaXMpLFxuICB1dGltZXNNaWxsaXNTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2VcblxuZnVuY3Rpb24gZ2V0U3RhdHMgKHNyYywgZGVzdCwgb3B0cykge1xuICBjb25zdCBzdGF0RnVuYyA9IG9wdHMuZGVyZWZlcmVuY2VcbiAgICA/IChmaWxlKSA9PiBmcy5zdGF0KGZpbGUsIHsgYmlnaW50OiB0cnVlIH0pXG4gICAgOiAoZmlsZSkgPT4gZnMubHN0YXQoZmlsZSwgeyBiaWdpbnQ6IHRydWUgfSlcbiAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICBzdGF0RnVuYyhzcmMpLFxuICAgIHN0YXRGdW5jKGRlc3QpLmNhdGNoKGVyciA9PiB7XG4gICAgICBpZiAoZXJyLmNvZGUgPT09ICdFTk9FTlQnKSByZXR1cm4gbnVsbFxuICAgICAgdGhyb3cgZXJyXG4gICAgfSlcbiAgXSkudGhlbigoW3NyY1N0YXQsIGRlc3RTdGF0XSkgPT4gKHsgc3JjU3RhdCwgZGVzdFN0YXQgfSkpXG59XG5cbmZ1bmN0aW9uIGdldFN0YXRzU3luYyAoc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGxldCBkZXN0U3RhdFxuICBjb25zdCBzdGF0RnVuYyA9IG9wdHMuZGVyZWZlcmVuY2VcbiAgICA/IChmaWxlKSA9PiBmcy5zdGF0U3luYyhmaWxlLCB7IGJpZ2ludDogdHJ1ZSB9KVxuICAgIDogKGZpbGUpID0+IGZzLmxzdGF0U3luYyhmaWxlLCB7IGJpZ2ludDogdHJ1ZSB9KVxuICBjb25zdCBzcmNTdGF0ID0gc3RhdEZ1bmMoc3JjKVxuICB0cnkge1xuICAgIGRlc3RTdGF0ID0gc3RhdEZ1bmMoZGVzdClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykgcmV0dXJuIHsgc3JjU3RhdCwgZGVzdFN0YXQ6IG51bGwgfVxuICAgIHRocm93IGVyclxuICB9XG4gIHJldHVybiB7IHNyY1N0YXQsIGRlc3RTdGF0IH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gY2hlY2tQYXRocyAoc3JjLCBkZXN0LCBmdW5jTmFtZSwgb3B0cykge1xuICBjb25zdCB7IHNyY1N0YXQsIGRlc3RTdGF0IH0gPSBhd2FpdCBnZXRTdGF0cyhzcmMsIGRlc3QsIG9wdHMpXG4gIGlmIChkZXN0U3RhdCkge1xuICAgIGlmIChhcmVJZGVudGljYWwoc3JjU3RhdCwgZGVzdFN0YXQpKSB7XG4gICAgICBjb25zdCBzcmNCYXNlTmFtZSA9IHBhdGguYmFzZW5hbWUoc3JjKVxuICAgICAgY29uc3QgZGVzdEJhc2VOYW1lID0gcGF0aC5iYXNlbmFtZShkZXN0KVxuICAgICAgaWYgKGZ1bmNOYW1lID09PSAnbW92ZScgJiZcbiAgICAgICAgc3JjQmFzZU5hbWUgIT09IGRlc3RCYXNlTmFtZSAmJlxuICAgICAgICBzcmNCYXNlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBkZXN0QmFzZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICByZXR1cm4geyBzcmNTdGF0LCBkZXN0U3RhdCwgaXNDaGFuZ2luZ0Nhc2U6IHRydWUgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTb3VyY2UgYW5kIGRlc3RpbmF0aW9uIG11c3Qgbm90IGJlIHRoZSBzYW1lLicpXG4gICAgfVxuICAgIGlmIChzcmNTdGF0LmlzRGlyZWN0b3J5KCkgJiYgIWRlc3RTdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IG92ZXJ3cml0ZSBub24tZGlyZWN0b3J5ICcke2Rlc3R9JyB3aXRoIGRpcmVjdG9yeSAnJHtzcmN9Jy5gKVxuICAgIH1cbiAgICBpZiAoIXNyY1N0YXQuaXNEaXJlY3RvcnkoKSAmJiBkZXN0U3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBvdmVyd3JpdGUgZGlyZWN0b3J5ICcke2Rlc3R9JyB3aXRoIG5vbi1kaXJlY3RvcnkgJyR7c3JjfScuYClcbiAgICB9XG4gIH1cblxuICBpZiAoc3JjU3RhdC5pc0RpcmVjdG9yeSgpICYmIGlzU3JjU3ViZGlyKHNyYywgZGVzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKHNyYywgZGVzdCwgZnVuY05hbWUpKVxuICB9XG5cbiAgcmV0dXJuIHsgc3JjU3RhdCwgZGVzdFN0YXQgfVxufVxuXG5mdW5jdGlvbiBjaGVja1BhdGhzU3luYyAoc3JjLCBkZXN0LCBmdW5jTmFtZSwgb3B0cykge1xuICBjb25zdCB7IHNyY1N0YXQsIGRlc3RTdGF0IH0gPSBnZXRTdGF0c1N5bmMoc3JjLCBkZXN0LCBvcHRzKVxuXG4gIGlmIChkZXN0U3RhdCkge1xuICAgIGlmIChhcmVJZGVudGljYWwoc3JjU3RhdCwgZGVzdFN0YXQpKSB7XG4gICAgICBjb25zdCBzcmNCYXNlTmFtZSA9IHBhdGguYmFzZW5hbWUoc3JjKVxuICAgICAgY29uc3QgZGVzdEJhc2VOYW1lID0gcGF0aC5iYXNlbmFtZShkZXN0KVxuICAgICAgaWYgKGZ1bmNOYW1lID09PSAnbW92ZScgJiZcbiAgICAgICAgc3JjQmFzZU5hbWUgIT09IGRlc3RCYXNlTmFtZSAmJlxuICAgICAgICBzcmNCYXNlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBkZXN0QmFzZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICByZXR1cm4geyBzcmNTdGF0LCBkZXN0U3RhdCwgaXNDaGFuZ2luZ0Nhc2U6IHRydWUgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTb3VyY2UgYW5kIGRlc3RpbmF0aW9uIG11c3Qgbm90IGJlIHRoZSBzYW1lLicpXG4gICAgfVxuICAgIGlmIChzcmNTdGF0LmlzRGlyZWN0b3J5KCkgJiYgIWRlc3RTdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IG92ZXJ3cml0ZSBub24tZGlyZWN0b3J5ICcke2Rlc3R9JyB3aXRoIGRpcmVjdG9yeSAnJHtzcmN9Jy5gKVxuICAgIH1cbiAgICBpZiAoIXNyY1N0YXQuaXNEaXJlY3RvcnkoKSAmJiBkZXN0U3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBvdmVyd3JpdGUgZGlyZWN0b3J5ICcke2Rlc3R9JyB3aXRoIG5vbi1kaXJlY3RvcnkgJyR7c3JjfScuYClcbiAgICB9XG4gIH1cblxuICBpZiAoc3JjU3RhdC5pc0RpcmVjdG9yeSgpICYmIGlzU3JjU3ViZGlyKHNyYywgZGVzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKHNyYywgZGVzdCwgZnVuY05hbWUpKVxuICB9XG4gIHJldHVybiB7IHNyY1N0YXQsIGRlc3RTdGF0IH1cbn1cblxuLy8gcmVjdXJzaXZlbHkgY2hlY2sgaWYgZGVzdCBwYXJlbnQgaXMgYSBzdWJkaXJlY3Rvcnkgb2Ygc3JjLlxuLy8gSXQgd29ya3MgZm9yIGFsbCBmaWxlIHR5cGVzIGluY2x1ZGluZyBzeW1saW5rcyBzaW5jZSBpdFxuLy8gY2hlY2tzIHRoZSBzcmMgYW5kIGRlc3QgaW5vZGVzLiBJdCBzdGFydHMgZnJvbSB0aGUgZGVlcGVzdFxuLy8gcGFyZW50IGFuZCBzdG9wcyBvbmNlIGl0IHJlYWNoZXMgdGhlIHNyYyBwYXJlbnQgb3IgdGhlIHJvb3QgcGF0aC5cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrUGFyZW50UGF0aHMgKHNyYywgc3JjU3RhdCwgZGVzdCwgZnVuY05hbWUpIHtcbiAgY29uc3Qgc3JjUGFyZW50ID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShzcmMpKVxuICBjb25zdCBkZXN0UGFyZW50ID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShkZXN0KSlcbiAgaWYgKGRlc3RQYXJlbnQgPT09IHNyY1BhcmVudCB8fCBkZXN0UGFyZW50ID09PSBwYXRoLnBhcnNlKGRlc3RQYXJlbnQpLnJvb3QpIHJldHVyblxuXG4gIGxldCBkZXN0U3RhdFxuICB0cnkge1xuICAgIGRlc3RTdGF0ID0gYXdhaXQgZnMuc3RhdChkZXN0UGFyZW50LCB7IGJpZ2ludDogdHJ1ZSB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgPT09ICdFTk9FTlQnKSByZXR1cm5cbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIGlmIChhcmVJZGVudGljYWwoc3JjU3RhdCwgZGVzdFN0YXQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyhzcmMsIGRlc3QsIGZ1bmNOYW1lKSlcbiAgfVxuXG4gIHJldHVybiBjaGVja1BhcmVudFBhdGhzKHNyYywgc3JjU3RhdCwgZGVzdFBhcmVudCwgZnVuY05hbWUpXG59XG5cbmZ1bmN0aW9uIGNoZWNrUGFyZW50UGF0aHNTeW5jIChzcmMsIHNyY1N0YXQsIGRlc3QsIGZ1bmNOYW1lKSB7XG4gIGNvbnN0IHNyY1BhcmVudCA9IHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUoc3JjKSlcbiAgY29uc3QgZGVzdFBhcmVudCA9IHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUoZGVzdCkpXG4gIGlmIChkZXN0UGFyZW50ID09PSBzcmNQYXJlbnQgfHwgZGVzdFBhcmVudCA9PT0gcGF0aC5wYXJzZShkZXN0UGFyZW50KS5yb290KSByZXR1cm5cbiAgbGV0IGRlc3RTdGF0XG4gIHRyeSB7XG4gICAgZGVzdFN0YXQgPSBmcy5zdGF0U3luYyhkZXN0UGFyZW50LCB7IGJpZ2ludDogdHJ1ZSB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgPT09ICdFTk9FTlQnKSByZXR1cm5cbiAgICB0aHJvdyBlcnJcbiAgfVxuICBpZiAoYXJlSWRlbnRpY2FsKHNyY1N0YXQsIGRlc3RTdGF0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2coc3JjLCBkZXN0LCBmdW5jTmFtZSkpXG4gIH1cbiAgcmV0dXJuIGNoZWNrUGFyZW50UGF0aHNTeW5jKHNyYywgc3JjU3RhdCwgZGVzdFBhcmVudCwgZnVuY05hbWUpXG59XG5cbmZ1bmN0aW9uIGFyZUlkZW50aWNhbCAoc3JjU3RhdCwgZGVzdFN0YXQpIHtcbiAgcmV0dXJuIGRlc3RTdGF0LmlubyAmJiBkZXN0U3RhdC5kZXYgJiYgZGVzdFN0YXQuaW5vID09PSBzcmNTdGF0LmlubyAmJiBkZXN0U3RhdC5kZXYgPT09IHNyY1N0YXQuZGV2XG59XG5cbi8vIHJldHVybiB0cnVlIGlmIGRlc3QgaXMgYSBzdWJkaXIgb2Ygc3JjLCBvdGhlcndpc2UgZmFsc2UuXG4vLyBJdCBvbmx5IGNoZWNrcyB0aGUgcGF0aCBzdHJpbmdzLlxuZnVuY3Rpb24gaXNTcmNTdWJkaXIgKHNyYywgZGVzdCkge1xuICBjb25zdCBzcmNBcnIgPSBwYXRoLnJlc29sdmUoc3JjKS5zcGxpdChwYXRoLnNlcCkuZmlsdGVyKGkgPT4gaSlcbiAgY29uc3QgZGVzdEFyciA9IHBhdGgucmVzb2x2ZShkZXN0KS5zcGxpdChwYXRoLnNlcCkuZmlsdGVyKGkgPT4gaSlcbiAgcmV0dXJuIHNyY0Fyci5ldmVyeSgoY3VyLCBpKSA9PiBkZXN0QXJyW2ldID09PSBjdXIpXG59XG5cbmZ1bmN0aW9uIGVyck1zZyAoc3JjLCBkZXN0LCBmdW5jTmFtZSkge1xuICByZXR1cm4gYENhbm5vdCAke2Z1bmNOYW1lfSAnJHtzcmN9JyB0byBhIHN1YmRpcmVjdG9yeSBvZiBpdHNlbGYsICcke2Rlc3R9Jy5gXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBjaGVja1BhdGhzXG4gIGNoZWNrUGF0aHM6IHUoY2hlY2tQYXRocyksXG4gIGNoZWNrUGF0aHNTeW5jLFxuICAvLyBjaGVja1BhcmVudFxuICBjaGVja1BhcmVudFBhdGhzOiB1KGNoZWNrUGFyZW50UGF0aHMpLFxuICBjaGVja1BhcmVudFBhdGhzU3luYyxcbiAgLy8gTWlzY1xuICBpc1NyY1N1YmRpcixcbiAgYXJlSWRlbnRpY2FsXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCB7IG1rZGlycyB9ID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHsgcGF0aEV4aXN0cyB9ID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKVxuY29uc3QgeyB1dGltZXNNaWxsaXMgfSA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbWVzJylcbmNvbnN0IHN0YXQgPSByZXF1aXJlKCcuLi91dGlsL3N0YXQnKVxuXG5hc3luYyBmdW5jdGlvbiBjb3B5IChzcmMsIGRlc3QsIG9wdHMgPSB7fSkge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRzID0geyBmaWx0ZXI6IG9wdHMgfVxuICB9XG5cbiAgb3B0cy5jbG9iYmVyID0gJ2Nsb2JiZXInIGluIG9wdHMgPyAhIW9wdHMuY2xvYmJlciA6IHRydWUgLy8gZGVmYXVsdCB0byB0cnVlIGZvciBub3dcbiAgb3B0cy5vdmVyd3JpdGUgPSAnb3ZlcndyaXRlJyBpbiBvcHRzID8gISFvcHRzLm92ZXJ3cml0ZSA6IG9wdHMuY2xvYmJlciAvLyBvdmVyd3JpdGUgZmFsbHMgYmFjayB0byBjbG9iYmVyXG5cbiAgLy8gV2FybiBhYm91dCB1c2luZyBwcmVzZXJ2ZVRpbWVzdGFtcHMgb24gMzItYml0IG5vZGVcbiAgaWYgKG9wdHMucHJlc2VydmVUaW1lc3RhbXBzICYmIHByb2Nlc3MuYXJjaCA9PT0gJ2lhMzInKSB7XG4gICAgcHJvY2Vzcy5lbWl0V2FybmluZyhcbiAgICAgICdVc2luZyB0aGUgcHJlc2VydmVUaW1lc3RhbXBzIG9wdGlvbiBpbiAzMi1iaXQgbm9kZSBpcyBub3QgcmVjb21tZW5kZWQ7XFxuXFxuJyArXG4gICAgICAnXFx0c2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcHJpY2hhcmRzb24vbm9kZS1mcy1leHRyYS9pc3N1ZXMvMjY5JyxcbiAgICAgICdXYXJuaW5nJywgJ2ZzLWV4dHJhLVdBUk4wMDAxJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHsgc3JjU3RhdCwgZGVzdFN0YXQgfSA9IGF3YWl0IHN0YXQuY2hlY2tQYXRocyhzcmMsIGRlc3QsICdjb3B5Jywgb3B0cylcblxuICBhd2FpdCBzdGF0LmNoZWNrUGFyZW50UGF0aHMoc3JjLCBzcmNTdGF0LCBkZXN0LCAnY29weScpXG5cbiAgY29uc3QgaW5jbHVkZSA9IGF3YWl0IHJ1bkZpbHRlcihzcmMsIGRlc3QsIG9wdHMpXG5cbiAgaWYgKCFpbmNsdWRlKSByZXR1cm5cblxuICAvLyBjaGVjayBpZiB0aGUgcGFyZW50IG9mIGRlc3QgZXhpc3RzLCBhbmQgY3JlYXRlIGl0IGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgY29uc3QgZGVzdFBhcmVudCA9IHBhdGguZGlybmFtZShkZXN0KVxuICBjb25zdCBkaXJFeGlzdHMgPSBhd2FpdCBwYXRoRXhpc3RzKGRlc3RQYXJlbnQpXG4gIGlmICghZGlyRXhpc3RzKSB7XG4gICAgYXdhaXQgbWtkaXJzKGRlc3RQYXJlbnQpXG4gIH1cblxuICBhd2FpdCBnZXRTdGF0c0FuZFBlcmZvcm1Db3B5KGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJ1bkZpbHRlciAoc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmICghb3B0cy5maWx0ZXIpIHJldHVybiB0cnVlXG4gIHJldHVybiBvcHRzLmZpbHRlcihzcmMsIGRlc3QpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFN0YXRzQW5kUGVyZm9ybUNvcHkgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgY29uc3Qgc3RhdEZuID0gb3B0cy5kZXJlZmVyZW5jZSA/IGZzLnN0YXQgOiBmcy5sc3RhdFxuICBjb25zdCBzcmNTdGF0ID0gYXdhaXQgc3RhdEZuKHNyYylcblxuICBpZiAoc3JjU3RhdC5pc0RpcmVjdG9yeSgpKSByZXR1cm4gb25EaXIoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcblxuICBpZiAoXG4gICAgc3JjU3RhdC5pc0ZpbGUoKSB8fFxuICAgIHNyY1N0YXQuaXNDaGFyYWN0ZXJEZXZpY2UoKSB8fFxuICAgIHNyY1N0YXQuaXNCbG9ja0RldmljZSgpXG4gICkgcmV0dXJuIG9uRmlsZShzcmNTdGF0LCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxuXG4gIGlmIChzcmNTdGF0LmlzU3ltYm9saWNMaW5rKCkpIHJldHVybiBvbkxpbmsoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcbiAgaWYgKHNyY1N0YXQuaXNTb2NrZXQoKSkgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29weSBhIHNvY2tldCBmaWxlOiAke3NyY31gKVxuICBpZiAoc3JjU3RhdC5pc0ZJRk8oKSkgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29weSBhIEZJRk8gcGlwZTogJHtzcmN9YClcbiAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGZpbGU6ICR7c3JjfWApXG59XG5cbmFzeW5jIGZ1bmN0aW9uIG9uRmlsZSAoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBpZiAoIWRlc3RTdGF0KSByZXR1cm4gY29weUZpbGUoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxuXG4gIGlmIChvcHRzLm92ZXJ3cml0ZSkge1xuICAgIGF3YWl0IGZzLnVubGluayhkZXN0KVxuICAgIHJldHVybiBjb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIH1cbiAgaWYgKG9wdHMuZXJyb3JPbkV4aXN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAnJHtkZXN0fScgYWxyZWFkeSBleGlzdHNgKVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvcHlGaWxlIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgYXdhaXQgZnMuY29weUZpbGUoc3JjLCBkZXN0KVxuICBpZiAob3B0cy5wcmVzZXJ2ZVRpbWVzdGFtcHMpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGZpbGUgaXMgd3JpdGFibGUgYmVmb3JlIHNldHRpbmcgdGhlIHRpbWVzdGFtcFxuICAgIC8vIG90aGVyd2lzZSBvcGVuIGZhaWxzIHdpdGggRVBFUk0gd2hlbiBpbnZva2VkIHdpdGggJ3IrJ1xuICAgIC8vICh0aHJvdWdoIHV0aW1lcyBjYWxsKVxuICAgIGlmIChmaWxlSXNOb3RXcml0YWJsZShzcmNTdGF0Lm1vZGUpKSB7XG4gICAgICBhd2FpdCBtYWtlRmlsZVdyaXRhYmxlKGRlc3QsIHNyY1N0YXQubW9kZSlcbiAgICB9XG5cbiAgICAvLyBTZXQgdGltZXN0YW1wcyBhbmQgbW9kZSBjb3JyZXNwb25kaW5nbHlcblxuICAgIC8vIE5vdGUgdGhhdCBUaGUgaW5pdGlhbCBzcmNTdGF0LmF0aW1lIGNhbm5vdCBiZSB0cnVzdGVkXG4gICAgLy8gYmVjYXVzZSBpdCBpcyBtb2RpZmllZCBieSB0aGUgcmVhZCgyKSBzeXN0ZW0gY2FsbFxuICAgIC8vIChTZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sI2ZzX3N0YXRfdGltZV92YWx1ZXMpXG4gICAgY29uc3QgdXBkYXRlZFNyY1N0YXQgPSBhd2FpdCBmcy5zdGF0KHNyYylcbiAgICBhd2FpdCB1dGltZXNNaWxsaXMoZGVzdCwgdXBkYXRlZFNyY1N0YXQuYXRpbWUsIHVwZGF0ZWRTcmNTdGF0Lm10aW1lKVxuICB9XG5cbiAgcmV0dXJuIGZzLmNobW9kKGRlc3QsIHNyY1N0YXQubW9kZSlcbn1cblxuZnVuY3Rpb24gZmlsZUlzTm90V3JpdGFibGUgKHNyY01vZGUpIHtcbiAgcmV0dXJuIChzcmNNb2RlICYgMG8yMDApID09PSAwXG59XG5cbmZ1bmN0aW9uIG1ha2VGaWxlV3JpdGFibGUgKGRlc3QsIHNyY01vZGUpIHtcbiAgcmV0dXJuIGZzLmNobW9kKGRlc3QsIHNyY01vZGUgfCAwbzIwMClcbn1cblxuYXN5bmMgZnVuY3Rpb24gb25EaXIgKHNyY1N0YXQsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgLy8gdGhlIGRlc3QgZGlyZWN0b3J5IG1pZ2h0IG5vdCBleGlzdCwgY3JlYXRlIGl0XG4gIGlmICghZGVzdFN0YXQpIHtcbiAgICBhd2FpdCBmcy5ta2RpcihkZXN0KVxuICB9XG5cbiAgY29uc3QgaXRlbXMgPSBhd2FpdCBmcy5yZWFkZGlyKHNyYylcblxuICAvLyBsb29wIHRocm91Z2ggdGhlIGZpbGVzIGluIHRoZSBjdXJyZW50IGRpcmVjdG9yeSB0byBjb3B5IGV2ZXJ5dGhpbmdcbiAgYXdhaXQgUHJvbWlzZS5hbGwoaXRlbXMubWFwKGFzeW5jIGl0ZW0gPT4ge1xuICAgIGNvbnN0IHNyY0l0ZW0gPSBwYXRoLmpvaW4oc3JjLCBpdGVtKVxuICAgIGNvbnN0IGRlc3RJdGVtID0gcGF0aC5qb2luKGRlc3QsIGl0ZW0pXG5cbiAgICAvLyBza2lwIHRoZSBpdGVtIGlmIGl0IGlzIG1hdGNoZXMgYnkgdGhlIGZpbHRlciBmdW5jdGlvblxuICAgIGNvbnN0IGluY2x1ZGUgPSBhd2FpdCBydW5GaWx0ZXIoc3JjSXRlbSwgZGVzdEl0ZW0sIG9wdHMpXG4gICAgaWYgKCFpbmNsdWRlKSByZXR1cm5cblxuICAgIGNvbnN0IHsgZGVzdFN0YXQgfSA9IGF3YWl0IHN0YXQuY2hlY2tQYXRocyhzcmNJdGVtLCBkZXN0SXRlbSwgJ2NvcHknLCBvcHRzKVxuXG4gICAgLy8gSWYgdGhlIGl0ZW0gaXMgYSBjb3B5YWJsZSBmaWxlLCBgZ2V0U3RhdHNBbmRQZXJmb3JtQ29weWAgd2lsbCBjb3B5IGl0XG4gICAgLy8gSWYgdGhlIGl0ZW0gaXMgYSBkaXJlY3RvcnksIGBnZXRTdGF0c0FuZFBlcmZvcm1Db3B5YCB3aWxsIGNhbGwgYG9uRGlyYCByZWN1cnNpdmVseVxuICAgIHJldHVybiBnZXRTdGF0c0FuZFBlcmZvcm1Db3B5KGRlc3RTdGF0LCBzcmNJdGVtLCBkZXN0SXRlbSwgb3B0cylcbiAgfSkpXG5cbiAgaWYgKCFkZXN0U3RhdCkge1xuICAgIGF3YWl0IGZzLmNobW9kKGRlc3QsIHNyY1N0YXQubW9kZSlcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBvbkxpbmsgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgbGV0IHJlc29sdmVkU3JjID0gYXdhaXQgZnMucmVhZGxpbmsoc3JjKVxuICBpZiAob3B0cy5kZXJlZmVyZW5jZSkge1xuICAgIHJlc29sdmVkU3JjID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIHJlc29sdmVkU3JjKVxuICB9XG4gIGlmICghZGVzdFN0YXQpIHtcbiAgICByZXR1cm4gZnMuc3ltbGluayhyZXNvbHZlZFNyYywgZGVzdClcbiAgfVxuXG4gIGxldCByZXNvbHZlZERlc3QgPSBudWxsXG4gIHRyeSB7XG4gICAgcmVzb2x2ZWREZXN0ID0gYXdhaXQgZnMucmVhZGxpbmsoZGVzdClcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGRlc3QgZXhpc3RzIGFuZCBpcyBhIHJlZ3VsYXIgZmlsZSBvciBkaXJlY3RvcnksXG4gICAgLy8gV2luZG93cyBtYXkgdGhyb3cgVU5LTk9XTiBlcnJvci4gSWYgZGVzdCBhbHJlYWR5IGV4aXN0cyxcbiAgICAvLyBmcyB0aHJvd3MgZXJyb3IgYW55d2F5LCBzbyBubyBuZWVkIHRvIGd1YXJkIGFnYWluc3QgaXQgaGVyZS5cbiAgICBpZiAoZS5jb2RlID09PSAnRUlOVkFMJyB8fCBlLmNvZGUgPT09ICdVTktOT1dOJykgcmV0dXJuIGZzLnN5bWxpbmsocmVzb2x2ZWRTcmMsIGRlc3QpXG4gICAgdGhyb3cgZVxuICB9XG4gIGlmIChvcHRzLmRlcmVmZXJlbmNlKSB7XG4gICAgcmVzb2x2ZWREZXN0ID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIHJlc29sdmVkRGVzdClcbiAgfVxuICBpZiAoc3RhdC5pc1NyY1N1YmRpcihyZXNvbHZlZFNyYywgcmVzb2x2ZWREZXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvcHkgJyR7cmVzb2x2ZWRTcmN9JyB0byBhIHN1YmRpcmVjdG9yeSBvZiBpdHNlbGYsICcke3Jlc29sdmVkRGVzdH0nLmApXG4gIH1cblxuICAvLyBkbyBub3QgY29weSBpZiBzcmMgaXMgYSBzdWJkaXIgb2YgZGVzdCBzaW5jZSB1bmxpbmtpbmdcbiAgLy8gZGVzdCBpbiB0aGlzIGNhc2Ugd291bGQgcmVzdWx0IGluIHJlbW92aW5nIHNyYyBjb250ZW50c1xuICAvLyBhbmQgdGhlcmVmb3JlIGEgYnJva2VuIHN5bWxpbmsgd291bGQgYmUgY3JlYXRlZC5cbiAgaWYgKHN0YXQuaXNTcmNTdWJkaXIocmVzb2x2ZWREZXN0LCByZXNvbHZlZFNyYykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBvdmVyd3JpdGUgJyR7cmVzb2x2ZWREZXN0fScgd2l0aCAnJHtyZXNvbHZlZFNyY30nLmApXG4gIH1cblxuICAvLyBjb3B5IHRoZSBsaW5rXG4gIGF3YWl0IGZzLnVubGluayhkZXN0KVxuICByZXR1cm4gZnMuc3ltbGluayhyZXNvbHZlZFNyYywgZGVzdClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBta2RpcnNTeW5jID0gcmVxdWlyZSgnLi4vbWtkaXJzJykubWtkaXJzU3luY1xuY29uc3QgdXRpbWVzTWlsbGlzU3luYyA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbWVzJykudXRpbWVzTWlsbGlzU3luY1xuY29uc3Qgc3RhdCA9IHJlcXVpcmUoJy4uL3V0aWwvc3RhdCcpXG5cbmZ1bmN0aW9uIGNvcHlTeW5jIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0cyA9IHsgZmlsdGVyOiBvcHRzIH1cbiAgfVxuXG4gIG9wdHMgPSBvcHRzIHx8IHt9XG4gIG9wdHMuY2xvYmJlciA9ICdjbG9iYmVyJyBpbiBvcHRzID8gISFvcHRzLmNsb2JiZXIgOiB0cnVlIC8vIGRlZmF1bHQgdG8gdHJ1ZSBmb3Igbm93XG4gIG9wdHMub3ZlcndyaXRlID0gJ292ZXJ3cml0ZScgaW4gb3B0cyA/ICEhb3B0cy5vdmVyd3JpdGUgOiBvcHRzLmNsb2JiZXIgLy8gb3ZlcndyaXRlIGZhbGxzIGJhY2sgdG8gY2xvYmJlclxuXG4gIC8vIFdhcm4gYWJvdXQgdXNpbmcgcHJlc2VydmVUaW1lc3RhbXBzIG9uIDMyLWJpdCBub2RlXG4gIGlmIChvcHRzLnByZXNlcnZlVGltZXN0YW1wcyAmJiBwcm9jZXNzLmFyY2ggPT09ICdpYTMyJykge1xuICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoXG4gICAgICAnVXNpbmcgdGhlIHByZXNlcnZlVGltZXN0YW1wcyBvcHRpb24gaW4gMzItYml0IG5vZGUgaXMgbm90IHJlY29tbWVuZGVkO1xcblxcbicgK1xuICAgICAgJ1xcdHNlZSBodHRwczovL2dpdGh1Yi5jb20vanByaWNoYXJkc29uL25vZGUtZnMtZXh0cmEvaXNzdWVzLzI2OScsXG4gICAgICAnV2FybmluZycsICdmcy1leHRyYS1XQVJOMDAwMidcbiAgICApXG4gIH1cblxuICBjb25zdCB7IHNyY1N0YXQsIGRlc3RTdGF0IH0gPSBzdGF0LmNoZWNrUGF0aHNTeW5jKHNyYywgZGVzdCwgJ2NvcHknLCBvcHRzKVxuICBzdGF0LmNoZWNrUGFyZW50UGF0aHNTeW5jKHNyYywgc3JjU3RhdCwgZGVzdCwgJ2NvcHknKVxuICBpZiAob3B0cy5maWx0ZXIgJiYgIW9wdHMuZmlsdGVyKHNyYywgZGVzdCkpIHJldHVyblxuICBjb25zdCBkZXN0UGFyZW50ID0gcGF0aC5kaXJuYW1lKGRlc3QpXG4gIGlmICghZnMuZXhpc3RzU3luYyhkZXN0UGFyZW50KSkgbWtkaXJzU3luYyhkZXN0UGFyZW50KVxuICByZXR1cm4gZ2V0U3RhdHMoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdHMgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgY29uc3Qgc3RhdFN5bmMgPSBvcHRzLmRlcmVmZXJlbmNlID8gZnMuc3RhdFN5bmMgOiBmcy5sc3RhdFN5bmNcbiAgY29uc3Qgc3JjU3RhdCA9IHN0YXRTeW5jKHNyYylcblxuICBpZiAoc3JjU3RhdC5pc0RpcmVjdG9yeSgpKSByZXR1cm4gb25EaXIoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcbiAgZWxzZSBpZiAoc3JjU3RhdC5pc0ZpbGUoKSB8fFxuICAgICAgICAgICBzcmNTdGF0LmlzQ2hhcmFjdGVyRGV2aWNlKCkgfHxcbiAgICAgICAgICAgc3JjU3RhdC5pc0Jsb2NrRGV2aWNlKCkpIHJldHVybiBvbkZpbGUoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcbiAgZWxzZSBpZiAoc3JjU3RhdC5pc1N5bWJvbGljTGluaygpKSByZXR1cm4gb25MaW5rKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIGVsc2UgaWYgKHNyY1N0YXQuaXNTb2NrZXQoKSkgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29weSBhIHNvY2tldCBmaWxlOiAke3NyY31gKVxuICBlbHNlIGlmIChzcmNTdGF0LmlzRklGTygpKSB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb3B5IGEgRklGTyBwaXBlOiAke3NyY31gKVxuICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZmlsZTogJHtzcmN9YClcbn1cblxuZnVuY3Rpb24gb25GaWxlIChzcmNTdGF0LCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmICghZGVzdFN0YXQpIHJldHVybiBjb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIHJldHVybiBtYXlDb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG59XG5cbmZ1bmN0aW9uIG1heUNvcHlGaWxlIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgaWYgKG9wdHMub3ZlcndyaXRlKSB7XG4gICAgZnMudW5saW5rU3luYyhkZXN0KVxuICAgIHJldHVybiBjb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIH0gZWxzZSBpZiAob3B0cy5lcnJvck9uRXhpc3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCcke2Rlc3R9JyBhbHJlYWR5IGV4aXN0c2ApXG4gIH1cbn1cblxuZnVuY3Rpb24gY29weUZpbGUgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBmcy5jb3B5RmlsZVN5bmMoc3JjLCBkZXN0KVxuICBpZiAob3B0cy5wcmVzZXJ2ZVRpbWVzdGFtcHMpIGhhbmRsZVRpbWVzdGFtcHMoc3JjU3RhdC5tb2RlLCBzcmMsIGRlc3QpXG4gIHJldHVybiBzZXREZXN0TW9kZShkZXN0LCBzcmNTdGF0Lm1vZGUpXG59XG5cbmZ1bmN0aW9uIGhhbmRsZVRpbWVzdGFtcHMgKHNyY01vZGUsIHNyYywgZGVzdCkge1xuICAvLyBNYWtlIHN1cmUgdGhlIGZpbGUgaXMgd3JpdGFibGUgYmVmb3JlIHNldHRpbmcgdGhlIHRpbWVzdGFtcFxuICAvLyBvdGhlcndpc2Ugb3BlbiBmYWlscyB3aXRoIEVQRVJNIHdoZW4gaW52b2tlZCB3aXRoICdyKydcbiAgLy8gKHRocm91Z2ggdXRpbWVzIGNhbGwpXG4gIGlmIChmaWxlSXNOb3RXcml0YWJsZShzcmNNb2RlKSkgbWFrZUZpbGVXcml0YWJsZShkZXN0LCBzcmNNb2RlKVxuICByZXR1cm4gc2V0RGVzdFRpbWVzdGFtcHMoc3JjLCBkZXN0KVxufVxuXG5mdW5jdGlvbiBmaWxlSXNOb3RXcml0YWJsZSAoc3JjTW9kZSkge1xuICByZXR1cm4gKHNyY01vZGUgJiAwbzIwMCkgPT09IDBcbn1cblxuZnVuY3Rpb24gbWFrZUZpbGVXcml0YWJsZSAoZGVzdCwgc3JjTW9kZSkge1xuICByZXR1cm4gc2V0RGVzdE1vZGUoZGVzdCwgc3JjTW9kZSB8IDBvMjAwKVxufVxuXG5mdW5jdGlvbiBzZXREZXN0TW9kZSAoZGVzdCwgc3JjTW9kZSkge1xuICByZXR1cm4gZnMuY2htb2RTeW5jKGRlc3QsIHNyY01vZGUpXG59XG5cbmZ1bmN0aW9uIHNldERlc3RUaW1lc3RhbXBzIChzcmMsIGRlc3QpIHtcbiAgLy8gVGhlIGluaXRpYWwgc3JjU3RhdC5hdGltZSBjYW5ub3QgYmUgdHJ1c3RlZFxuICAvLyBiZWNhdXNlIGl0IGlzIG1vZGlmaWVkIGJ5IHRoZSByZWFkKDIpIHN5c3RlbSBjYWxsXG4gIC8vIChTZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sI2ZzX3N0YXRfdGltZV92YWx1ZXMpXG4gIGNvbnN0IHVwZGF0ZWRTcmNTdGF0ID0gZnMuc3RhdFN5bmMoc3JjKVxuICByZXR1cm4gdXRpbWVzTWlsbGlzU3luYyhkZXN0LCB1cGRhdGVkU3JjU3RhdC5hdGltZSwgdXBkYXRlZFNyY1N0YXQubXRpbWUpXG59XG5cbmZ1bmN0aW9uIG9uRGlyIChzcmNTdGF0LCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmICghZGVzdFN0YXQpIHJldHVybiBta0RpckFuZENvcHkoc3JjU3RhdC5tb2RlLCBzcmMsIGRlc3QsIG9wdHMpXG4gIHJldHVybiBjb3B5RGlyKHNyYywgZGVzdCwgb3B0cylcbn1cblxuZnVuY3Rpb24gbWtEaXJBbmRDb3B5IChzcmNNb2RlLCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgZnMubWtkaXJTeW5jKGRlc3QpXG4gIGNvcHlEaXIoc3JjLCBkZXN0LCBvcHRzKVxuICByZXR1cm4gc2V0RGVzdE1vZGUoZGVzdCwgc3JjTW9kZSlcbn1cblxuZnVuY3Rpb24gY29weURpciAoc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGZzLnJlYWRkaXJTeW5jKHNyYykuZm9yRWFjaChpdGVtID0+IGNvcHlEaXJJdGVtKGl0ZW0sIHNyYywgZGVzdCwgb3B0cykpXG59XG5cbmZ1bmN0aW9uIGNvcHlEaXJJdGVtIChpdGVtLCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgY29uc3Qgc3JjSXRlbSA9IHBhdGguam9pbihzcmMsIGl0ZW0pXG4gIGNvbnN0IGRlc3RJdGVtID0gcGF0aC5qb2luKGRlc3QsIGl0ZW0pXG4gIGlmIChvcHRzLmZpbHRlciAmJiAhb3B0cy5maWx0ZXIoc3JjSXRlbSwgZGVzdEl0ZW0pKSByZXR1cm5cbiAgY29uc3QgeyBkZXN0U3RhdCB9ID0gc3RhdC5jaGVja1BhdGhzU3luYyhzcmNJdGVtLCBkZXN0SXRlbSwgJ2NvcHknLCBvcHRzKVxuICByZXR1cm4gZ2V0U3RhdHMoZGVzdFN0YXQsIHNyY0l0ZW0sIGRlc3RJdGVtLCBvcHRzKVxufVxuXG5mdW5jdGlvbiBvbkxpbmsgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgbGV0IHJlc29sdmVkU3JjID0gZnMucmVhZGxpbmtTeW5jKHNyYylcbiAgaWYgKG9wdHMuZGVyZWZlcmVuY2UpIHtcbiAgICByZXNvbHZlZFNyYyA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCByZXNvbHZlZFNyYylcbiAgfVxuXG4gIGlmICghZGVzdFN0YXQpIHtcbiAgICByZXR1cm4gZnMuc3ltbGlua1N5bmMocmVzb2x2ZWRTcmMsIGRlc3QpXG4gIH0gZWxzZSB7XG4gICAgbGV0IHJlc29sdmVkRGVzdFxuICAgIHRyeSB7XG4gICAgICByZXNvbHZlZERlc3QgPSBmcy5yZWFkbGlua1N5bmMoZGVzdClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIGRlc3QgZXhpc3RzIGFuZCBpcyBhIHJlZ3VsYXIgZmlsZSBvciBkaXJlY3RvcnksXG4gICAgICAvLyBXaW5kb3dzIG1heSB0aHJvdyBVTktOT1dOIGVycm9yLiBJZiBkZXN0IGFscmVhZHkgZXhpc3RzLFxuICAgICAgLy8gZnMgdGhyb3dzIGVycm9yIGFueXdheSwgc28gbm8gbmVlZCB0byBndWFyZCBhZ2FpbnN0IGl0IGhlcmUuXG4gICAgICBpZiAoZXJyLmNvZGUgPT09ICdFSU5WQUwnIHx8IGVyci5jb2RlID09PSAnVU5LTk9XTicpIHJldHVybiBmcy5zeW1saW5rU3luYyhyZXNvbHZlZFNyYywgZGVzdClcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgICBpZiAob3B0cy5kZXJlZmVyZW5jZSkge1xuICAgICAgcmVzb2x2ZWREZXN0ID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIHJlc29sdmVkRGVzdClcbiAgICB9XG4gICAgaWYgKHN0YXQuaXNTcmNTdWJkaXIocmVzb2x2ZWRTcmMsIHJlc29sdmVkRGVzdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvcHkgJyR7cmVzb2x2ZWRTcmN9JyB0byBhIHN1YmRpcmVjdG9yeSBvZiBpdHNlbGYsICcke3Jlc29sdmVkRGVzdH0nLmApXG4gICAgfVxuXG4gICAgLy8gcHJldmVudCBjb3B5IGlmIHNyYyBpcyBhIHN1YmRpciBvZiBkZXN0IHNpbmNlIHVubGlua2luZ1xuICAgIC8vIGRlc3QgaW4gdGhpcyBjYXNlIHdvdWxkIHJlc3VsdCBpbiByZW1vdmluZyBzcmMgY29udGVudHNcbiAgICAvLyBhbmQgdGhlcmVmb3JlIGEgYnJva2VuIHN5bWxpbmsgd291bGQgYmUgY3JlYXRlZC5cbiAgICBpZiAoc3RhdC5pc1NyY1N1YmRpcihyZXNvbHZlZERlc3QsIHJlc29sdmVkU3JjKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgb3ZlcndyaXRlICcke3Jlc29sdmVkRGVzdH0nIHdpdGggJyR7cmVzb2x2ZWRTcmN9Jy5gKVxuICAgIH1cbiAgICByZXR1cm4gY29weUxpbmsocmVzb2x2ZWRTcmMsIGRlc3QpXG4gIH1cbn1cblxuZnVuY3Rpb24gY29weUxpbmsgKHJlc29sdmVkU3JjLCBkZXN0KSB7XG4gIGZzLnVubGlua1N5bmMoZGVzdClcbiAgcmV0dXJuIGZzLnN5bWxpbmtTeW5jKHJlc29sdmVkU3JjLCBkZXN0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW5jXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21Qcm9taXNlXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29weTogdShyZXF1aXJlKCcuL2NvcHknKSksXG4gIGNvcHlTeW5jOiByZXF1aXJlKCcuL2NvcHktc3luYycpXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5cbmZ1bmN0aW9uIHJlbW92ZSAocGF0aCwgY2FsbGJhY2spIHtcbiAgZnMucm0ocGF0aCwgeyByZWN1cnNpdmU6IHRydWUsIGZvcmNlOiB0cnVlIH0sIGNhbGxiYWNrKVxufVxuXG5mdW5jdGlvbiByZW1vdmVTeW5jIChwYXRoKSB7XG4gIGZzLnJtU3luYyhwYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlbW92ZTogdShyZW1vdmUpLFxuICByZW1vdmVTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21Qcm9taXNlXG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL2ZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHJlbW92ZSA9IHJlcXVpcmUoJy4uL3JlbW92ZScpXG5cbmNvbnN0IGVtcHR5RGlyID0gdShhc3luYyBmdW5jdGlvbiBlbXB0eURpciAoZGlyKSB7XG4gIGxldCBpdGVtc1xuICB0cnkge1xuICAgIGl0ZW1zID0gYXdhaXQgZnMucmVhZGRpcihkaXIpXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBta2Rpci5ta2RpcnMoZGlyKVxuICB9XG5cbiAgcmV0dXJuIFByb21pc2UuYWxsKGl0ZW1zLm1hcChpdGVtID0+IHJlbW92ZS5yZW1vdmUocGF0aC5qb2luKGRpciwgaXRlbSkpKSlcbn0pXG5cbmZ1bmN0aW9uIGVtcHR5RGlyU3luYyAoZGlyKSB7XG4gIGxldCBpdGVtc1xuICB0cnkge1xuICAgIGl0ZW1zID0gZnMucmVhZGRpclN5bmMoZGlyKVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbWtkaXIubWtkaXJzU3luYyhkaXIpXG4gIH1cblxuICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgIGl0ZW0gPSBwYXRoLmpvaW4oZGlyLCBpdGVtKVxuICAgIHJlbW92ZS5yZW1vdmVTeW5jKGl0ZW0pXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlbXB0eURpclN5bmMsXG4gIGVtcHR5ZGlyU3luYzogZW1wdHlEaXJTeW5jLFxuICBlbXB0eURpcixcbiAgZW1wdHlkaXI6IGVtcHR5RGlyXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21Qcm9taXNlXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL2ZzJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlRmlsZSAoZmlsZSkge1xuICBsZXQgc3RhdHNcbiAgdHJ5IHtcbiAgICBzdGF0cyA9IGF3YWl0IGZzLnN0YXQoZmlsZSlcbiAgfSBjYXRjaCB7IH1cbiAgaWYgKHN0YXRzICYmIHN0YXRzLmlzRmlsZSgpKSByZXR1cm5cblxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZmlsZSlcblxuICBsZXQgZGlyU3RhdHMgPSBudWxsXG4gIHRyeSB7XG4gICAgZGlyU3RhdHMgPSBhd2FpdCBmcy5zdGF0KGRpcilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gaWYgdGhlIGRpcmVjdG9yeSBkb2Vzbid0IGV4aXN0LCBtYWtlIGl0XG4gICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgYXdhaXQgbWtkaXIubWtkaXJzKGRpcilcbiAgICAgIGF3YWl0IGZzLndyaXRlRmlsZShmaWxlLCAnJylcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyU3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShmaWxlLCAnJylcbiAgfSBlbHNlIHtcbiAgICAvLyBwYXJlbnQgaXMgbm90IGEgZGlyZWN0b3J5XG4gICAgLy8gVGhpcyBpcyBqdXN0IHRvIGNhdXNlIGFuIGludGVybmFsIEVOT1RESVIgZXJyb3IgdG8gYmUgdGhyb3duXG4gICAgYXdhaXQgZnMucmVhZGRpcihkaXIpXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRmlsZVN5bmMgKGZpbGUpIHtcbiAgbGV0IHN0YXRzXG4gIHRyeSB7XG4gICAgc3RhdHMgPSBmcy5zdGF0U3luYyhmaWxlKVxuICB9IGNhdGNoIHsgfVxuICBpZiAoc3RhdHMgJiYgc3RhdHMuaXNGaWxlKCkpIHJldHVyblxuXG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShmaWxlKVxuICB0cnkge1xuICAgIGlmICghZnMuc3RhdFN5bmMoZGlyKS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAvLyBwYXJlbnQgaXMgbm90IGEgZGlyZWN0b3J5XG4gICAgICAvLyBUaGlzIGlzIGp1c3QgdG8gY2F1c2UgYW4gaW50ZXJuYWwgRU5PVERJUiBlcnJvciB0byBiZSB0aHJvd25cbiAgICAgIGZzLnJlYWRkaXJTeW5jKGRpcilcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIElmIHRoZSBzdGF0IGNhbGwgYWJvdmUgZmFpbGVkIGJlY2F1c2UgdGhlIGRpcmVjdG9yeSBkb2Vzbid0IGV4aXN0LCBjcmVhdGUgaXRcbiAgICBpZiAoZXJyICYmIGVyci5jb2RlID09PSAnRU5PRU5UJykgbWtkaXIubWtkaXJzU3luYyhkaXIpXG4gICAgZWxzZSB0aHJvdyBlcnJcbiAgfVxuXG4gIGZzLndyaXRlRmlsZVN5bmMoZmlsZSwgJycpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVGaWxlOiB1KGNyZWF0ZUZpbGUpLFxuICBjcmVhdGVGaWxlU3luY1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tUHJvbWlzZVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5jb25zdCBta2RpciA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5jb25zdCB7IHBhdGhFeGlzdHMgfSA9IHJlcXVpcmUoJy4uL3BhdGgtZXhpc3RzJylcbmNvbnN0IHsgYXJlSWRlbnRpY2FsIH0gPSByZXF1aXJlKCcuLi91dGlsL3N0YXQnKVxuXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVMaW5rIChzcmNwYXRoLCBkc3RwYXRoKSB7XG4gIGxldCBkc3RTdGF0XG4gIHRyeSB7XG4gICAgZHN0U3RhdCA9IGF3YWl0IGZzLmxzdGF0KGRzdHBhdGgpXG4gIH0gY2F0Y2gge1xuICAgIC8vIGlnbm9yZSBlcnJvclxuICB9XG5cbiAgbGV0IHNyY1N0YXRcbiAgdHJ5IHtcbiAgICBzcmNTdGF0ID0gYXdhaXQgZnMubHN0YXQoc3JjcGF0aClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLm1lc3NhZ2UgPSBlcnIubWVzc2FnZS5yZXBsYWNlKCdsc3RhdCcsICdlbnN1cmVMaW5rJylcbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIGlmIChkc3RTdGF0ICYmIGFyZUlkZW50aWNhbChzcmNTdGF0LCBkc3RTdGF0KSkgcmV0dXJuXG5cbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGRzdHBhdGgpXG5cbiAgY29uc3QgZGlyRXhpc3RzID0gYXdhaXQgcGF0aEV4aXN0cyhkaXIpXG5cbiAgaWYgKCFkaXJFeGlzdHMpIHtcbiAgICBhd2FpdCBta2Rpci5ta2RpcnMoZGlyKVxuICB9XG5cbiAgYXdhaXQgZnMubGluayhzcmNwYXRoLCBkc3RwYXRoKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rU3luYyAoc3JjcGF0aCwgZHN0cGF0aCkge1xuICBsZXQgZHN0U3RhdFxuICB0cnkge1xuICAgIGRzdFN0YXQgPSBmcy5sc3RhdFN5bmMoZHN0cGF0aClcbiAgfSBjYXRjaCB7fVxuXG4gIHRyeSB7XG4gICAgY29uc3Qgc3JjU3RhdCA9IGZzLmxzdGF0U3luYyhzcmNwYXRoKVxuICAgIGlmIChkc3RTdGF0ICYmIGFyZUlkZW50aWNhbChzcmNTdGF0LCBkc3RTdGF0KSkgcmV0dXJuXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5tZXNzYWdlID0gZXJyLm1lc3NhZ2UucmVwbGFjZSgnbHN0YXQnLCAnZW5zdXJlTGluaycpXG4gICAgdGhyb3cgZXJyXG4gIH1cblxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgY29uc3QgZGlyRXhpc3RzID0gZnMuZXhpc3RzU3luYyhkaXIpXG4gIGlmIChkaXJFeGlzdHMpIHJldHVybiBmcy5saW5rU3luYyhzcmNwYXRoLCBkc3RwYXRoKVxuICBta2Rpci5ta2RpcnNTeW5jKGRpcilcblxuICByZXR1cm4gZnMubGlua1N5bmMoc3JjcGF0aCwgZHN0cGF0aClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZUxpbms6IHUoY3JlYXRlTGluayksXG4gIGNyZWF0ZUxpbmtTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5jb25zdCB7IHBhdGhFeGlzdHMgfSA9IHJlcXVpcmUoJy4uL3BhdGgtZXhpc3RzJylcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21Qcm9taXNlXG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCByZXR1cm5zIHR3byB0eXBlcyBvZiBwYXRocywgb25lIHJlbGF0aXZlIHRvIHN5bWxpbmssIGFuZCBvbmVcbiAqIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LiBDaGVja3MgaWYgcGF0aCBpcyBhYnNvbHV0ZSBvclxuICogcmVsYXRpdmUuIElmIHRoZSBwYXRoIGlzIHJlbGF0aXZlLCB0aGlzIGZ1bmN0aW9uIGNoZWNrcyBpZiB0aGUgcGF0aCBpc1xuICogcmVsYXRpdmUgdG8gc3ltbGluayBvciByZWxhdGl2ZSB0byBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LiBUaGlzIGlzIGFuXG4gKiBpbml0aWF0aXZlIHRvIGZpbmQgYSBzbWFydGVyIGBzcmNwYXRoYCB0byBzdXBwbHkgd2hlbiBidWlsZGluZyBzeW1saW5rcy5cbiAqIFRoaXMgYWxsb3dzIHlvdSB0byBkZXRlcm1pbmUgd2hpY2ggcGF0aCB0byB1c2Ugb3V0IG9mIG9uZSBvZiB0aHJlZSBwb3NzaWJsZVxuICogdHlwZXMgb2Ygc291cmNlIHBhdGhzLiBUaGUgZmlyc3QgaXMgYW4gYWJzb2x1dGUgcGF0aC4gVGhpcyBpcyBkZXRlY3RlZCBieVxuICogYHBhdGguaXNBYnNvbHV0ZSgpYC4gV2hlbiBhbiBhYnNvbHV0ZSBwYXRoIGlzIHByb3ZpZGVkLCBpdCBpcyBjaGVja2VkIHRvXG4gKiBzZWUgaWYgaXQgZXhpc3RzLiBJZiBpdCBkb2VzIGl0J3MgdXNlZCwgaWYgbm90IGFuIGVycm9yIGlzIHJldHVybmVkXG4gKiAoY2FsbGJhY2spLyB0aHJvd24gKHN5bmMpLiBUaGUgb3RoZXIgdHdvIG9wdGlvbnMgZm9yIGBzcmNwYXRoYCBhcmUgYVxuICogcmVsYXRpdmUgdXJsLiBCeSBkZWZhdWx0IE5vZGUncyBgZnMuc3ltbGlua2Agd29ya3MgYnkgY3JlYXRpbmcgYSBzeW1saW5rXG4gKiB1c2luZyBgZHN0cGF0aGAgYW5kIGV4cGVjdHMgdGhlIGBzcmNwYXRoYCB0byBiZSByZWxhdGl2ZSB0byB0aGUgbmV3bHlcbiAqIGNyZWF0ZWQgc3ltbGluay4gSWYgeW91IHByb3ZpZGUgYSBgc3JjcGF0aGAgdGhhdCBkb2VzIG5vdCBleGlzdCBvbiB0aGUgZmlsZVxuICogc3lzdGVtIGl0IHJlc3VsdHMgaW4gYSBicm9rZW4gc3ltbGluay4gVG8gbWluaW1pemUgdGhpcywgdGhlIGZ1bmN0aW9uXG4gKiBjaGVja3MgdG8gc2VlIGlmIHRoZSAncmVsYXRpdmUgdG8gc3ltbGluaycgc291cmNlIGZpbGUgZXhpc3RzLCBhbmQgaWYgaXRcbiAqIGRvZXMgaXQgd2lsbCB1c2UgaXQuIElmIGl0IGRvZXMgbm90LCBpdCBjaGVja3MgaWYgdGhlcmUncyBhIGZpbGUgdGhhdFxuICogZXhpc3RzIHRoYXQgaXMgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnksIGlmIGRvZXMgaXRzIHVzZWQuXG4gKiBUaGlzIHByZXNlcnZlcyB0aGUgZXhwZWN0YXRpb25zIG9mIHRoZSBvcmlnaW5hbCBmcy5zeW1saW5rIHNwZWMgYW5kIGFkZHNcbiAqIHRoZSBhYmlsaXR5IHRvIHBhc3MgaW4gYHJlbGF0aXZlIHRvIGN1cnJlbnQgd29ya2luZyBkaXJlY290cnlgIHBhdGhzLlxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIHN5bWxpbmtQYXRocyAoc3JjcGF0aCwgZHN0cGF0aCkge1xuICBpZiAocGF0aC5pc0Fic29sdXRlKHNyY3BhdGgpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGZzLmxzdGF0KHNyY3BhdGgpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBlcnIubWVzc2FnZSA9IGVyci5tZXNzYWdlLnJlcGxhY2UoJ2xzdGF0JywgJ2Vuc3VyZVN5bWxpbmsnKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvQ3dkOiBzcmNwYXRoLFxuICAgICAgdG9Ec3Q6IHNyY3BhdGhcbiAgICB9XG4gIH1cblxuICBjb25zdCBkc3RkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgY29uc3QgcmVsYXRpdmVUb0RzdCA9IHBhdGguam9pbihkc3RkaXIsIHNyY3BhdGgpXG5cbiAgY29uc3QgZXhpc3RzID0gYXdhaXQgcGF0aEV4aXN0cyhyZWxhdGl2ZVRvRHN0KVxuICBpZiAoZXhpc3RzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvQ3dkOiByZWxhdGl2ZVRvRHN0LFxuICAgICAgdG9Ec3Q6IHNyY3BhdGhcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIGF3YWl0IGZzLmxzdGF0KHNyY3BhdGgpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5tZXNzYWdlID0gZXJyLm1lc3NhZ2UucmVwbGFjZSgnbHN0YXQnLCAnZW5zdXJlU3ltbGluaycpXG4gICAgdGhyb3cgZXJyXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvQ3dkOiBzcmNwYXRoLFxuICAgIHRvRHN0OiBwYXRoLnJlbGF0aXZlKGRzdGRpciwgc3JjcGF0aClcbiAgfVxufVxuXG5mdW5jdGlvbiBzeW1saW5rUGF0aHNTeW5jIChzcmNwYXRoLCBkc3RwYXRoKSB7XG4gIGlmIChwYXRoLmlzQWJzb2x1dGUoc3JjcGF0aCkpIHtcbiAgICBjb25zdCBleGlzdHMgPSBmcy5leGlzdHNTeW5jKHNyY3BhdGgpXG4gICAgaWYgKCFleGlzdHMpIHRocm93IG5ldyBFcnJvcignYWJzb2x1dGUgc3JjcGF0aCBkb2VzIG5vdCBleGlzdCcpXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvQ3dkOiBzcmNwYXRoLFxuICAgICAgdG9Ec3Q6IHNyY3BhdGhcbiAgICB9XG4gIH1cblxuICBjb25zdCBkc3RkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgY29uc3QgcmVsYXRpdmVUb0RzdCA9IHBhdGguam9pbihkc3RkaXIsIHNyY3BhdGgpXG4gIGNvbnN0IGV4aXN0cyA9IGZzLmV4aXN0c1N5bmMocmVsYXRpdmVUb0RzdClcbiAgaWYgKGV4aXN0cykge1xuICAgIHJldHVybiB7XG4gICAgICB0b0N3ZDogcmVsYXRpdmVUb0RzdCxcbiAgICAgIHRvRHN0OiBzcmNwYXRoXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3JjRXhpc3RzID0gZnMuZXhpc3RzU3luYyhzcmNwYXRoKVxuICBpZiAoIXNyY0V4aXN0cykgdGhyb3cgbmV3IEVycm9yKCdyZWxhdGl2ZSBzcmNwYXRoIGRvZXMgbm90IGV4aXN0JylcbiAgcmV0dXJuIHtcbiAgICB0b0N3ZDogc3JjcGF0aCxcbiAgICB0b0RzdDogcGF0aC5yZWxhdGl2ZShkc3RkaXIsIHNyY3BhdGgpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN5bWxpbmtQYXRoczogdShzeW1saW5rUGF0aHMpLFxuICBzeW1saW5rUGF0aHNTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2VcblxuYXN5bmMgZnVuY3Rpb24gc3ltbGlua1R5cGUgKHNyY3BhdGgsIHR5cGUpIHtcbiAgaWYgKHR5cGUpIHJldHVybiB0eXBlXG5cbiAgbGV0IHN0YXRzXG4gIHRyeSB7XG4gICAgc3RhdHMgPSBhd2FpdCBmcy5sc3RhdChzcmNwYXRoKVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gJ2ZpbGUnXG4gIH1cblxuICByZXR1cm4gKHN0YXRzICYmIHN0YXRzLmlzRGlyZWN0b3J5KCkpID8gJ2RpcicgOiAnZmlsZSdcbn1cblxuZnVuY3Rpb24gc3ltbGlua1R5cGVTeW5jIChzcmNwYXRoLCB0eXBlKSB7XG4gIGlmICh0eXBlKSByZXR1cm4gdHlwZVxuXG4gIGxldCBzdGF0c1xuICB0cnkge1xuICAgIHN0YXRzID0gZnMubHN0YXRTeW5jKHNyY3BhdGgpXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAnZmlsZSdcbiAgfVxuICByZXR1cm4gKHN0YXRzICYmIHN0YXRzLmlzRGlyZWN0b3J5KCkpID8gJ2RpcicgOiAnZmlsZSdcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN5bWxpbmtUeXBlOiB1KHN5bWxpbmtUeXBlKSxcbiAgc3ltbGlua1R5cGVTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21Qcm9taXNlXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL2ZzJylcblxuY29uc3QgeyBta2RpcnMsIG1rZGlyc1N5bmMgfSA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5cbmNvbnN0IHsgc3ltbGlua1BhdGhzLCBzeW1saW5rUGF0aHNTeW5jIH0gPSByZXF1aXJlKCcuL3N5bWxpbmstcGF0aHMnKVxuY29uc3QgeyBzeW1saW5rVHlwZSwgc3ltbGlua1R5cGVTeW5jIH0gPSByZXF1aXJlKCcuL3N5bWxpbmstdHlwZScpXG5cbmNvbnN0IHsgcGF0aEV4aXN0cyB9ID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKVxuXG5jb25zdCB7IGFyZUlkZW50aWNhbCB9ID0gcmVxdWlyZSgnLi4vdXRpbC9zdGF0JylcblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlU3ltbGluayAoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSkge1xuICBsZXQgc3RhdHNcbiAgdHJ5IHtcbiAgICBzdGF0cyA9IGF3YWl0IGZzLmxzdGF0KGRzdHBhdGgpXG4gIH0gY2F0Y2ggeyB9XG5cbiAgaWYgKHN0YXRzICYmIHN0YXRzLmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICBjb25zdCBbc3JjU3RhdCwgZHN0U3RhdF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICBmcy5zdGF0KHNyY3BhdGgpLFxuICAgICAgZnMuc3RhdChkc3RwYXRoKVxuICAgIF0pXG5cbiAgICBpZiAoYXJlSWRlbnRpY2FsKHNyY1N0YXQsIGRzdFN0YXQpKSByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHJlbGF0aXZlID0gYXdhaXQgc3ltbGlua1BhdGhzKHNyY3BhdGgsIGRzdHBhdGgpXG4gIHNyY3BhdGggPSByZWxhdGl2ZS50b0RzdFxuICBjb25zdCB0b1R5cGUgPSBhd2FpdCBzeW1saW5rVHlwZShyZWxhdGl2ZS50b0N3ZCwgdHlwZSlcbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGRzdHBhdGgpXG5cbiAgaWYgKCEoYXdhaXQgcGF0aEV4aXN0cyhkaXIpKSkge1xuICAgIGF3YWl0IG1rZGlycyhkaXIpXG4gIH1cblxuICByZXR1cm4gZnMuc3ltbGluayhzcmNwYXRoLCBkc3RwYXRoLCB0b1R5cGUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN5bWxpbmtTeW5jIChzcmNwYXRoLCBkc3RwYXRoLCB0eXBlKSB7XG4gIGxldCBzdGF0c1xuICB0cnkge1xuICAgIHN0YXRzID0gZnMubHN0YXRTeW5jKGRzdHBhdGgpXG4gIH0gY2F0Y2ggeyB9XG4gIGlmIChzdGF0cyAmJiBzdGF0cy5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgY29uc3Qgc3JjU3RhdCA9IGZzLnN0YXRTeW5jKHNyY3BhdGgpXG4gICAgY29uc3QgZHN0U3RhdCA9IGZzLnN0YXRTeW5jKGRzdHBhdGgpXG4gICAgaWYgKGFyZUlkZW50aWNhbChzcmNTdGF0LCBkc3RTdGF0KSkgcmV0dXJuXG4gIH1cblxuICBjb25zdCByZWxhdGl2ZSA9IHN5bWxpbmtQYXRoc1N5bmMoc3JjcGF0aCwgZHN0cGF0aClcbiAgc3JjcGF0aCA9IHJlbGF0aXZlLnRvRHN0XG4gIHR5cGUgPSBzeW1saW5rVHlwZVN5bmMocmVsYXRpdmUudG9Dd2QsIHR5cGUpXG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShkc3RwYXRoKVxuICBjb25zdCBleGlzdHMgPSBmcy5leGlzdHNTeW5jKGRpcilcbiAgaWYgKGV4aXN0cykgcmV0dXJuIGZzLnN5bWxpbmtTeW5jKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUpXG4gIG1rZGlyc1N5bmMoZGlyKVxuICByZXR1cm4gZnMuc3ltbGlua1N5bmMoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZVN5bWxpbms6IHUoY3JlYXRlU3ltbGluayksXG4gIGNyZWF0ZVN5bWxpbmtTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBjcmVhdGVGaWxlLCBjcmVhdGVGaWxlU3luYyB9ID0gcmVxdWlyZSgnLi9maWxlJylcbmNvbnN0IHsgY3JlYXRlTGluaywgY3JlYXRlTGlua1N5bmMgfSA9IHJlcXVpcmUoJy4vbGluaycpXG5jb25zdCB7IGNyZWF0ZVN5bWxpbmssIGNyZWF0ZVN5bWxpbmtTeW5jIH0gPSByZXF1aXJlKCcuL3N5bWxpbmsnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gZmlsZVxuICBjcmVhdGVGaWxlLFxuICBjcmVhdGVGaWxlU3luYyxcbiAgZW5zdXJlRmlsZTogY3JlYXRlRmlsZSxcbiAgZW5zdXJlRmlsZVN5bmM6IGNyZWF0ZUZpbGVTeW5jLFxuICAvLyBsaW5rXG4gIGNyZWF0ZUxpbmssXG4gIGNyZWF0ZUxpbmtTeW5jLFxuICBlbnN1cmVMaW5rOiBjcmVhdGVMaW5rLFxuICBlbnN1cmVMaW5rU3luYzogY3JlYXRlTGlua1N5bmMsXG4gIC8vIHN5bWxpbmtcbiAgY3JlYXRlU3ltbGluayxcbiAgY3JlYXRlU3ltbGlua1N5bmMsXG4gIGVuc3VyZVN5bWxpbms6IGNyZWF0ZVN5bWxpbmssXG4gIGVuc3VyZVN5bWxpbmtTeW5jOiBjcmVhdGVTeW1saW5rU3luY1xufVxuIiwiZnVuY3Rpb24gc3RyaW5naWZ5IChvYmosIHsgRU9MID0gJ1xcbicsIGZpbmFsRU9MID0gdHJ1ZSwgcmVwbGFjZXIgPSBudWxsLCBzcGFjZXMgfSA9IHt9KSB7XG4gIGNvbnN0IEVPRiA9IGZpbmFsRU9MID8gRU9MIDogJydcbiAgY29uc3Qgc3RyID0gSlNPTi5zdHJpbmdpZnkob2JqLCByZXBsYWNlciwgc3BhY2VzKVxuXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxuL2csIEVPTCkgKyBFT0Zcbn1cblxuZnVuY3Rpb24gc3RyaXBCb20gKGNvbnRlbnQpIHtcbiAgLy8gd2UgZG8gdGhpcyBiZWNhdXNlIEpTT04ucGFyc2Ugd291bGQgY29udmVydCBpdCB0byBhIHV0Zjggc3RyaW5nIGlmIGVuY29kaW5nIHdhc24ndCBzcGVjaWZpZWRcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjb250ZW50KSkgY29udGVudCA9IGNvbnRlbnQudG9TdHJpbmcoJ3V0ZjgnKVxuICByZXR1cm4gY29udGVudC5yZXBsYWNlKC9eXFx1RkVGRi8sICcnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgc3RyaW5naWZ5LCBzdHJpcEJvbSB9XG4iLCJsZXQgX2ZzXG50cnkge1xuICBfZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG59IGNhdGNoIChfKSB7XG4gIF9mcyA9IHJlcXVpcmUoJ2ZzJylcbn1cbmNvbnN0IHVuaXZlcnNhbGlmeSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpXG5jb25zdCB7IHN0cmluZ2lmeSwgc3RyaXBCb20gfSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuXG5hc3luYyBmdW5jdGlvbiBfcmVhZEZpbGUgKGZpbGUsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHsgZW5jb2Rpbmc6IG9wdGlvbnMgfVxuICB9XG5cbiAgY29uc3QgZnMgPSBvcHRpb25zLmZzIHx8IF9mc1xuXG4gIGNvbnN0IHNob3VsZFRocm93ID0gJ3Rocm93cycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudGhyb3dzIDogdHJ1ZVxuXG4gIGxldCBkYXRhID0gYXdhaXQgdW5pdmVyc2FsaWZ5LmZyb21DYWxsYmFjayhmcy5yZWFkRmlsZSkoZmlsZSwgb3B0aW9ucylcblxuICBkYXRhID0gc3RyaXBCb20oZGF0YSlcblxuICBsZXQgb2JqXG4gIHRyeSB7XG4gICAgb2JqID0gSlNPTi5wYXJzZShkYXRhLCBvcHRpb25zID8gb3B0aW9ucy5yZXZpdmVyIDogbnVsbClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHNob3VsZFRocm93KSB7XG4gICAgICBlcnIubWVzc2FnZSA9IGAke2ZpbGV9OiAke2Vyci5tZXNzYWdlfWBcbiAgICAgIHRocm93IGVyclxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmpcbn1cblxuY29uc3QgcmVhZEZpbGUgPSB1bml2ZXJzYWxpZnkuZnJvbVByb21pc2UoX3JlYWRGaWxlKVxuXG5mdW5jdGlvbiByZWFkRmlsZVN5bmMgKGZpbGUsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHsgZW5jb2Rpbmc6IG9wdGlvbnMgfVxuICB9XG5cbiAgY29uc3QgZnMgPSBvcHRpb25zLmZzIHx8IF9mc1xuXG4gIGNvbnN0IHNob3VsZFRocm93ID0gJ3Rocm93cycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudGhyb3dzIDogdHJ1ZVxuXG4gIHRyeSB7XG4gICAgbGV0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZSwgb3B0aW9ucylcbiAgICBjb250ZW50ID0gc3RyaXBCb20oY29udGVudClcbiAgICByZXR1cm4gSlNPTi5wYXJzZShjb250ZW50LCBvcHRpb25zLnJldml2ZXIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgZXJyLm1lc3NhZ2UgPSBgJHtmaWxlfTogJHtlcnIubWVzc2FnZX1gXG4gICAgICB0aHJvdyBlcnJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gX3dyaXRlRmlsZSAoZmlsZSwgb2JqLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgZnMgPSBvcHRpb25zLmZzIHx8IF9mc1xuXG4gIGNvbnN0IHN0ciA9IHN0cmluZ2lmeShvYmosIG9wdGlvbnMpXG5cbiAgYXdhaXQgdW5pdmVyc2FsaWZ5LmZyb21DYWxsYmFjayhmcy53cml0ZUZpbGUpKGZpbGUsIHN0ciwgb3B0aW9ucylcbn1cblxuY29uc3Qgd3JpdGVGaWxlID0gdW5pdmVyc2FsaWZ5LmZyb21Qcm9taXNlKF93cml0ZUZpbGUpXG5cbmZ1bmN0aW9uIHdyaXRlRmlsZVN5bmMgKGZpbGUsIG9iaiwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGZzID0gb3B0aW9ucy5mcyB8fCBfZnNcblxuICBjb25zdCBzdHIgPSBzdHJpbmdpZnkob2JqLCBvcHRpb25zKVxuICAvLyBub3Qgc3VyZSBpZiBmcy53cml0ZUZpbGVTeW5jIHJldHVybnMgYW55dGhpbmcsIGJ1dCBqdXN0IGluIGNhc2VcbiAgcmV0dXJuIGZzLndyaXRlRmlsZVN5bmMoZmlsZSwgc3RyLCBvcHRpb25zKVxufVxuXG5jb25zdCBqc29uZmlsZSA9IHtcbiAgcmVhZEZpbGUsXG4gIHJlYWRGaWxlU3luYyxcbiAgd3JpdGVGaWxlLFxuICB3cml0ZUZpbGVTeW5jXG59XG5cbm1vZHVsZS5leHBvcnRzID0ganNvbmZpbGVcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBqc29uRmlsZSA9IHJlcXVpcmUoJ2pzb25maWxlJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGpzb25maWxlIGV4cG9ydHNcbiAgcmVhZEpzb246IGpzb25GaWxlLnJlYWRGaWxlLFxuICByZWFkSnNvblN5bmM6IGpzb25GaWxlLnJlYWRGaWxlU3luYyxcbiAgd3JpdGVKc29uOiBqc29uRmlsZS53cml0ZUZpbGUsXG4gIHdyaXRlSnNvblN5bmM6IGpzb25GaWxlLndyaXRlRmlsZVN5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2VcbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgbWtkaXIgPSByZXF1aXJlKCcuLi9ta2RpcnMnKVxuY29uc3QgcGF0aEV4aXN0cyA9IHJlcXVpcmUoJy4uL3BhdGgtZXhpc3RzJykucGF0aEV4aXN0c1xuXG5hc3luYyBmdW5jdGlvbiBvdXRwdXRGaWxlIChmaWxlLCBkYXRhLCBlbmNvZGluZyA9ICd1dGYtOCcpIHtcbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGUpXG5cbiAgaWYgKCEoYXdhaXQgcGF0aEV4aXN0cyhkaXIpKSkge1xuICAgIGF3YWl0IG1rZGlyLm1rZGlycyhkaXIpXG4gIH1cblxuICByZXR1cm4gZnMud3JpdGVGaWxlKGZpbGUsIGRhdGEsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBvdXRwdXRGaWxlU3luYyAoZmlsZSwgLi4uYXJncykge1xuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZmlsZSlcbiAgaWYgKCFmcy5leGlzdHNTeW5jKGRpcikpIHtcbiAgICBta2Rpci5ta2RpcnNTeW5jKGRpcilcbiAgfVxuXG4gIGZzLndyaXRlRmlsZVN5bmMoZmlsZSwgLi4uYXJncylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG91dHB1dEZpbGU6IHUob3V0cHV0RmlsZSksXG4gIG91dHB1dEZpbGVTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBzdHJpbmdpZnkgfSA9IHJlcXVpcmUoJ2pzb25maWxlL3V0aWxzJylcbmNvbnN0IHsgb3V0cHV0RmlsZSB9ID0gcmVxdWlyZSgnLi4vb3V0cHV0LWZpbGUnKVxuXG5hc3luYyBmdW5jdGlvbiBvdXRwdXRKc29uIChmaWxlLCBkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qgc3RyID0gc3RyaW5naWZ5KGRhdGEsIG9wdGlvbnMpXG5cbiAgYXdhaXQgb3V0cHV0RmlsZShmaWxlLCBzdHIsIG9wdGlvbnMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3V0cHV0SnNvblxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgc3RyaW5naWZ5IH0gPSByZXF1aXJlKCdqc29uZmlsZS91dGlscycpXG5jb25zdCB7IG91dHB1dEZpbGVTeW5jIH0gPSByZXF1aXJlKCcuLi9vdXRwdXQtZmlsZScpXG5cbmZ1bmN0aW9uIG91dHB1dEpzb25TeW5jIChmaWxlLCBkYXRhLCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0ciA9IHN0cmluZ2lmeShkYXRhLCBvcHRpb25zKVxuXG4gIG91dHB1dEZpbGVTeW5jKGZpbGUsIHN0ciwgb3B0aW9ucylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdXRwdXRKc29uU3luY1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tUHJvbWlzZVxuY29uc3QganNvbkZpbGUgPSByZXF1aXJlKCcuL2pzb25maWxlJylcblxuanNvbkZpbGUub3V0cHV0SnNvbiA9IHUocmVxdWlyZSgnLi9vdXRwdXQtanNvbicpKVxuanNvbkZpbGUub3V0cHV0SnNvblN5bmMgPSByZXF1aXJlKCcuL291dHB1dC1qc29uLXN5bmMnKVxuLy8gYWxpYXNlc1xuanNvbkZpbGUub3V0cHV0SlNPTiA9IGpzb25GaWxlLm91dHB1dEpzb25cbmpzb25GaWxlLm91dHB1dEpTT05TeW5jID0ganNvbkZpbGUub3V0cHV0SnNvblN5bmNcbmpzb25GaWxlLndyaXRlSlNPTiA9IGpzb25GaWxlLndyaXRlSnNvblxuanNvbkZpbGUud3JpdGVKU09OU3luYyA9IGpzb25GaWxlLndyaXRlSnNvblN5bmNcbmpzb25GaWxlLnJlYWRKU09OID0ganNvbkZpbGUucmVhZEpzb25cbmpzb25GaWxlLnJlYWRKU09OU3luYyA9IGpzb25GaWxlLnJlYWRKc29uU3luY1xuXG5tb2R1bGUuZXhwb3J0cyA9IGpzb25GaWxlXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCB7IGNvcHkgfSA9IHJlcXVpcmUoJy4uL2NvcHknKVxuY29uc3QgeyByZW1vdmUgfSA9IHJlcXVpcmUoJy4uL3JlbW92ZScpXG5jb25zdCB7IG1rZGlycCB9ID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHsgcGF0aEV4aXN0cyB9ID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKVxuY29uc3Qgc3RhdCA9IHJlcXVpcmUoJy4uL3V0aWwvc3RhdCcpXG5cbmFzeW5jIGZ1bmN0aW9uIG1vdmUgKHNyYywgZGVzdCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IG92ZXJ3cml0ZSA9IG9wdHMub3ZlcndyaXRlIHx8IG9wdHMuY2xvYmJlciB8fCBmYWxzZVxuXG4gIGNvbnN0IHsgc3JjU3RhdCwgaXNDaGFuZ2luZ0Nhc2UgPSBmYWxzZSB9ID0gYXdhaXQgc3RhdC5jaGVja1BhdGhzKHNyYywgZGVzdCwgJ21vdmUnLCBvcHRzKVxuXG4gIGF3YWl0IHN0YXQuY2hlY2tQYXJlbnRQYXRocyhzcmMsIHNyY1N0YXQsIGRlc3QsICdtb3ZlJylcblxuICAvLyBJZiB0aGUgcGFyZW50IG9mIGRlc3QgaXMgbm90IHJvb3QsIG1ha2Ugc3VyZSBpdCBleGlzdHMgYmVmb3JlIHByb2NlZWRpbmdcbiAgY29uc3QgZGVzdFBhcmVudCA9IHBhdGguZGlybmFtZShkZXN0KVxuICBjb25zdCBwYXJzZWRQYXJlbnRQYXRoID0gcGF0aC5wYXJzZShkZXN0UGFyZW50KVxuICBpZiAocGFyc2VkUGFyZW50UGF0aC5yb290ICE9PSBkZXN0UGFyZW50KSB7XG4gICAgYXdhaXQgbWtkaXJwKGRlc3RQYXJlbnQpXG4gIH1cblxuICByZXR1cm4gZG9SZW5hbWUoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGlzQ2hhbmdpbmdDYXNlKVxufVxuXG5hc3luYyBmdW5jdGlvbiBkb1JlbmFtZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGlzQ2hhbmdpbmdDYXNlKSB7XG4gIGlmICghaXNDaGFuZ2luZ0Nhc2UpIHtcbiAgICBpZiAob3ZlcndyaXRlKSB7XG4gICAgICBhd2FpdCByZW1vdmUoZGVzdClcbiAgICB9IGVsc2UgaWYgKGF3YWl0IHBhdGhFeGlzdHMoZGVzdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZGVzdCBhbHJlYWR5IGV4aXN0cy4nKVxuICAgIH1cbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVHJ5IHcvIHJlbmFtZSBmaXJzdCwgYW5kIHRyeSBjb3B5ICsgcmVtb3ZlIGlmIEVYREVWXG4gICAgYXdhaXQgZnMucmVuYW1lKHNyYywgZGVzdClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlICE9PSAnRVhERVYnKSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gICAgYXdhaXQgbW92ZUFjcm9zc0RldmljZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSlcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBtb3ZlQWNyb3NzRGV2aWNlIChzcmMsIGRlc3QsIG92ZXJ3cml0ZSkge1xuICBjb25zdCBvcHRzID0ge1xuICAgIG92ZXJ3cml0ZSxcbiAgICBlcnJvck9uRXhpc3Q6IHRydWUsXG4gICAgcHJlc2VydmVUaW1lc3RhbXBzOiB0cnVlXG4gIH1cblxuICBhd2FpdCBjb3B5KHNyYywgZGVzdCwgb3B0cylcbiAgcmV0dXJuIHJlbW92ZShzcmMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbW92ZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgY29weVN5bmMgPSByZXF1aXJlKCcuLi9jb3B5JykuY29weVN5bmNcbmNvbnN0IHJlbW92ZVN5bmMgPSByZXF1aXJlKCcuLi9yZW1vdmUnKS5yZW1vdmVTeW5jXG5jb25zdCBta2RpcnBTeW5jID0gcmVxdWlyZSgnLi4vbWtkaXJzJykubWtkaXJwU3luY1xuY29uc3Qgc3RhdCA9IHJlcXVpcmUoJy4uL3V0aWwvc3RhdCcpXG5cbmZ1bmN0aW9uIG1vdmVTeW5jIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge31cbiAgY29uc3Qgb3ZlcndyaXRlID0gb3B0cy5vdmVyd3JpdGUgfHwgb3B0cy5jbG9iYmVyIHx8IGZhbHNlXG5cbiAgY29uc3QgeyBzcmNTdGF0LCBpc0NoYW5naW5nQ2FzZSA9IGZhbHNlIH0gPSBzdGF0LmNoZWNrUGF0aHNTeW5jKHNyYywgZGVzdCwgJ21vdmUnLCBvcHRzKVxuICBzdGF0LmNoZWNrUGFyZW50UGF0aHNTeW5jKHNyYywgc3JjU3RhdCwgZGVzdCwgJ21vdmUnKVxuICBpZiAoIWlzUGFyZW50Um9vdChkZXN0KSkgbWtkaXJwU3luYyhwYXRoLmRpcm5hbWUoZGVzdCkpXG4gIHJldHVybiBkb1JlbmFtZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgaXNDaGFuZ2luZ0Nhc2UpXG59XG5cbmZ1bmN0aW9uIGlzUGFyZW50Um9vdCAoZGVzdCkge1xuICBjb25zdCBwYXJlbnQgPSBwYXRoLmRpcm5hbWUoZGVzdClcbiAgY29uc3QgcGFyc2VkUGF0aCA9IHBhdGgucGFyc2UocGFyZW50KVxuICByZXR1cm4gcGFyc2VkUGF0aC5yb290ID09PSBwYXJlbnRcbn1cblxuZnVuY3Rpb24gZG9SZW5hbWUgKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBpc0NoYW5naW5nQ2FzZSkge1xuICBpZiAoaXNDaGFuZ2luZ0Nhc2UpIHJldHVybiByZW5hbWUoc3JjLCBkZXN0LCBvdmVyd3JpdGUpXG4gIGlmIChvdmVyd3JpdGUpIHtcbiAgICByZW1vdmVTeW5jKGRlc3QpXG4gICAgcmV0dXJuIHJlbmFtZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSlcbiAgfVxuICBpZiAoZnMuZXhpc3RzU3luYyhkZXN0KSkgdGhyb3cgbmV3IEVycm9yKCdkZXN0IGFscmVhZHkgZXhpc3RzLicpXG4gIHJldHVybiByZW5hbWUoc3JjLCBkZXN0LCBvdmVyd3JpdGUpXG59XG5cbmZ1bmN0aW9uIHJlbmFtZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUpIHtcbiAgdHJ5IHtcbiAgICBmcy5yZW5hbWVTeW5jKHNyYywgZGVzdClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlICE9PSAnRVhERVYnKSB0aHJvdyBlcnJcbiAgICByZXR1cm4gbW92ZUFjcm9zc0RldmljZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBtb3ZlQWNyb3NzRGV2aWNlIChzcmMsIGRlc3QsIG92ZXJ3cml0ZSkge1xuICBjb25zdCBvcHRzID0ge1xuICAgIG92ZXJ3cml0ZSxcbiAgICBlcnJvck9uRXhpc3Q6IHRydWUsXG4gICAgcHJlc2VydmVUaW1lc3RhbXBzOiB0cnVlXG4gIH1cbiAgY29weVN5bmMoc3JjLCBkZXN0LCBvcHRzKVxuICByZXR1cm4gcmVtb3ZlU3luYyhzcmMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbW92ZVN5bmNcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2Vcbm1vZHVsZS5leHBvcnRzID0ge1xuICBtb3ZlOiB1KHJlcXVpcmUoJy4vbW92ZScpKSxcbiAgbW92ZVN5bmM6IHJlcXVpcmUoJy4vbW92ZS1zeW5jJylcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gRXhwb3J0IHByb21pc2VpZmllZCBncmFjZWZ1bC1mczpcbiAgLi4ucmVxdWlyZSgnLi9mcycpLFxuICAvLyBFeHBvcnQgZXh0cmEgbWV0aG9kczpcbiAgLi4ucmVxdWlyZSgnLi9jb3B5JyksXG4gIC4uLnJlcXVpcmUoJy4vZW1wdHknKSxcbiAgLi4ucmVxdWlyZSgnLi9lbnN1cmUnKSxcbiAgLi4ucmVxdWlyZSgnLi9qc29uJyksXG4gIC4uLnJlcXVpcmUoJy4vbWtkaXJzJyksXG4gIC4uLnJlcXVpcmUoJy4vbW92ZScpLFxuICAuLi5yZXF1aXJlKCcuL291dHB1dC1maWxlJyksXG4gIC4uLnJlcXVpcmUoJy4vcGF0aC1leGlzdHMnKSxcbiAgLi4ucmVxdWlyZSgnLi9yZW1vdmUnKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbHVlID0+IHtcblx0Y29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblx0cmV0dXJuIHZhbHVlICE9PSBudWxsICYmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBpc09iaiA9IHJlcXVpcmUoJ2lzLW9iaicpO1xuXG5jb25zdCBkaXNhbGxvd2VkS2V5cyA9IG5ldyBTZXQoW1xuXHQnX19wcm90b19fJyxcblx0J3Byb3RvdHlwZScsXG5cdCdjb25zdHJ1Y3Rvcidcbl0pO1xuXG5jb25zdCBpc1ZhbGlkUGF0aCA9IHBhdGhTZWdtZW50cyA9PiAhcGF0aFNlZ21lbnRzLnNvbWUoc2VnbWVudCA9PiBkaXNhbGxvd2VkS2V5cy5oYXMoc2VnbWVudCkpO1xuXG5mdW5jdGlvbiBnZXRQYXRoU2VnbWVudHMocGF0aCkge1xuXHRjb25zdCBwYXRoQXJyYXkgPSBwYXRoLnNwbGl0KCcuJyk7XG5cdGNvbnN0IHBhcnRzID0gW107XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoQXJyYXkubGVuZ3RoOyBpKyspIHtcblx0XHRsZXQgcCA9IHBhdGhBcnJheVtpXTtcblxuXHRcdHdoaWxlIChwW3AubGVuZ3RoIC0gMV0gPT09ICdcXFxcJyAmJiBwYXRoQXJyYXlbaSArIDFdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHAgPSBwLnNsaWNlKDAsIC0xKSArICcuJztcblx0XHRcdHAgKz0gcGF0aEFycmF5WysraV07XG5cdFx0fVxuXG5cdFx0cGFydHMucHVzaChwKTtcblx0fVxuXG5cdGlmICghaXNWYWxpZFBhdGgocGFydHMpKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cblx0cmV0dXJuIHBhcnRzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Z2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcblx0XHRpZiAoIWlzT2JqKG9iamVjdCkgfHwgdHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IG9iamVjdCA6IHZhbHVlO1xuXHRcdH1cblxuXHRcdGNvbnN0IHBhdGhBcnJheSA9IGdldFBhdGhTZWdtZW50cyhwYXRoKTtcblx0XHRpZiAocGF0aEFycmF5Lmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aEFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRvYmplY3QgPSBvYmplY3RbcGF0aEFycmF5W2ldXTtcblxuXHRcdFx0aWYgKG9iamVjdCA9PT0gdW5kZWZpbmVkIHx8IG9iamVjdCA9PT0gbnVsbCkge1xuXHRcdFx0XHQvLyBgb2JqZWN0YCBpcyBlaXRoZXIgYHVuZGVmaW5lZGAgb3IgYG51bGxgIHNvIHdlIHdhbnQgdG8gc3RvcCB0aGUgbG9vcCwgYW5kXG5cdFx0XHRcdC8vIGlmIHRoaXMgaXMgbm90IHRoZSBsYXN0IGJpdCBvZiB0aGUgcGF0aCwgYW5kXG5cdFx0XHRcdC8vIGlmIGl0IGRpZCd0IHJldHVybiBgdW5kZWZpbmVkYFxuXHRcdFx0XHQvLyBpdCB3b3VsZCByZXR1cm4gYG51bGxgIGlmIGBvYmplY3RgIGlzIGBudWxsYFxuXHRcdFx0XHQvLyBidXQgd2Ugd2FudCBgZ2V0KHtmb286IG51bGx9LCAnZm9vLmJhcicpYCB0byBlcXVhbCBgdW5kZWZpbmVkYCwgb3IgdGhlIHN1cHBsaWVkIHZhbHVlLCBub3QgYG51bGxgXG5cdFx0XHRcdGlmIChpICE9PSBwYXRoQXJyYXkubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmplY3QgPT09IHVuZGVmaW5lZCA/IHZhbHVlIDogb2JqZWN0O1xuXHR9LFxuXG5cdHNldChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG5cdFx0aWYgKCFpc09iaihvYmplY3QpIHx8IHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIG9iamVjdDtcblx0XHR9XG5cblx0XHRjb25zdCByb290ID0gb2JqZWN0O1xuXHRcdGNvbnN0IHBhdGhBcnJheSA9IGdldFBhdGhTZWdtZW50cyhwYXRoKTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aEFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBwID0gcGF0aEFycmF5W2ldO1xuXG5cdFx0XHRpZiAoIWlzT2JqKG9iamVjdFtwXSkpIHtcblx0XHRcdFx0b2JqZWN0W3BdID0ge307XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpID09PSBwYXRoQXJyYXkubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRvYmplY3RbcF0gPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0b2JqZWN0ID0gb2JqZWN0W3BdO1xuXHRcdH1cblxuXHRcdHJldHVybiByb290O1xuXHR9LFxuXG5cdGRlbGV0ZShvYmplY3QsIHBhdGgpIHtcblx0XHRpZiAoIWlzT2JqKG9iamVjdCkgfHwgdHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Y29uc3QgcGF0aEFycmF5ID0gZ2V0UGF0aFNlZ21lbnRzKHBhdGgpO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoQXJyYXkubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IHAgPSBwYXRoQXJyYXlbaV07XG5cblx0XHRcdGlmIChpID09PSBwYXRoQXJyYXkubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRkZWxldGUgb2JqZWN0W3BdO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0b2JqZWN0ID0gb2JqZWN0W3BdO1xuXG5cdFx0XHRpZiAoIWlzT2JqKG9iamVjdCkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRoYXMob2JqZWN0LCBwYXRoKSB7XG5cdFx0aWYgKCFpc09iaihvYmplY3QpIHx8IHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGNvbnN0IHBhdGhBcnJheSA9IGdldFBhdGhTZWdtZW50cyhwYXRoKTtcblx0XHRpZiAocGF0aEFycmF5Lmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL25vLWZvci1sb29wXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoQXJyYXkubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChpc09iaihvYmplY3QpKSB7XG5cdFx0XHRcdGlmICghKHBhdGhBcnJheVtpXSBpbiBvYmplY3QpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0b2JqZWN0ID0gb2JqZWN0W3BhdGhBcnJheVtpXV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnAgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG5cdGZzLmFjY2VzcyhmcCwgZXJyID0+IHtcblx0XHRyZXNvbHZlKCFlcnIpO1xuXHR9KTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cy5zeW5jID0gZnAgPT4ge1xuXHR0cnkge1xuXHRcdGZzLmFjY2Vzc1N5bmMoZnApO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHBUcnkgPSAoZm4sIC4uLmFyZ3VtZW50c18pID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuXHRyZXNvbHZlKGZuKC4uLmFyZ3VtZW50c18pKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBUcnk7XG4vLyBUT0RPOiByZW1vdmUgdGhpcyBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gcFRyeTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHBUcnkgPSByZXF1aXJlKCdwLXRyeScpO1xuXG5jb25zdCBwTGltaXQgPSBjb25jdXJyZW5jeSA9PiB7XG5cdGlmICghKChOdW1iZXIuaXNJbnRlZ2VyKGNvbmN1cnJlbmN5KSB8fCBjb25jdXJyZW5jeSA9PT0gSW5maW5pdHkpICYmIGNvbmN1cnJlbmN5ID4gMCkpIHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYGNvbmN1cnJlbmN5YCB0byBiZSBhIG51bWJlciBmcm9tIDEgYW5kIHVwJykpO1xuXHR9XG5cblx0Y29uc3QgcXVldWUgPSBbXTtcblx0bGV0IGFjdGl2ZUNvdW50ID0gMDtcblxuXHRjb25zdCBuZXh0ID0gKCkgPT4ge1xuXHRcdGFjdGl2ZUNvdW50LS07XG5cblx0XHRpZiAocXVldWUubGVuZ3RoID4gMCkge1xuXHRcdFx0cXVldWUuc2hpZnQoKSgpO1xuXHRcdH1cblx0fTtcblxuXHRjb25zdCBydW4gPSAoZm4sIHJlc29sdmUsIC4uLmFyZ3MpID0+IHtcblx0XHRhY3RpdmVDb3VudCsrO1xuXG5cdFx0Y29uc3QgcmVzdWx0ID0gcFRyeShmbiwgLi4uYXJncyk7XG5cblx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cblx0XHRyZXN1bHQudGhlbihuZXh0LCBuZXh0KTtcblx0fTtcblxuXHRjb25zdCBlbnF1ZXVlID0gKGZuLCByZXNvbHZlLCAuLi5hcmdzKSA9PiB7XG5cdFx0aWYgKGFjdGl2ZUNvdW50IDwgY29uY3VycmVuY3kpIHtcblx0XHRcdHJ1bihmbiwgcmVzb2x2ZSwgLi4uYXJncyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHF1ZXVlLnB1c2gocnVuLmJpbmQobnVsbCwgZm4sIHJlc29sdmUsIC4uLmFyZ3MpKTtcblx0XHR9XG5cdH07XG5cblx0Y29uc3QgZ2VuZXJhdG9yID0gKGZuLCAuLi5hcmdzKSA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IGVucXVldWUoZm4sIHJlc29sdmUsIC4uLmFyZ3MpKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZ2VuZXJhdG9yLCB7XG5cdFx0YWN0aXZlQ291bnQ6IHtcblx0XHRcdGdldDogKCkgPT4gYWN0aXZlQ291bnRcblx0XHR9LFxuXHRcdHBlbmRpbmdDb3VudDoge1xuXHRcdFx0Z2V0OiAoKSA9PiBxdWV1ZS5sZW5ndGhcblx0XHR9LFxuXHRcdGNsZWFyUXVldWU6IHtcblx0XHRcdHZhbHVlOiAoKSA9PiB7XG5cdFx0XHRcdHF1ZXVlLmxlbmd0aCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gZ2VuZXJhdG9yO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBwTGltaXQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gcExpbWl0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcExpbWl0ID0gcmVxdWlyZSgncC1saW1pdCcpO1xuXG5jbGFzcyBFbmRFcnJvciBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IodmFsdWUpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0fVxufVxuXG4vLyBUaGUgaW5wdXQgY2FuIGFsc28gYmUgYSBwcm9taXNlLCBzbyB3ZSBgUHJvbWlzZS5yZXNvbHZlKClgIGl0XG5jb25zdCB0ZXN0RWxlbWVudCA9IChlbCwgdGVzdGVyKSA9PiBQcm9taXNlLnJlc29sdmUoZWwpLnRoZW4odGVzdGVyKTtcblxuLy8gVGhlIGlucHV0IGNhbiBhbHNvIGJlIGEgcHJvbWlzZSwgc28gd2UgYFByb21pc2UuYWxsKClgIHRoZW0gYm90aFxuY29uc3QgZmluZGVyID0gZWwgPT4gUHJvbWlzZS5hbGwoZWwpLnRoZW4odmFsID0+IHZhbFsxXSA9PT0gdHJ1ZSAmJiBQcm9taXNlLnJlamVjdChuZXcgRW5kRXJyb3IodmFsWzBdKSkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChpdGVyYWJsZSwgdGVzdGVyLCBvcHRzKSA9PiB7XG5cdG9wdHMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRjb25jdXJyZW5jeTogSW5maW5pdHksXG5cdFx0cHJlc2VydmVPcmRlcjogdHJ1ZVxuXHR9LCBvcHRzKTtcblxuXHRjb25zdCBsaW1pdCA9IHBMaW1pdChvcHRzLmNvbmN1cnJlbmN5KTtcblxuXHQvLyBTdGFydCBhbGwgdGhlIHByb21pc2VzIGNvbmN1cnJlbnRseSB3aXRoIG9wdGlvbmFsIGxpbWl0XG5cdGNvbnN0IGl0ZW1zID0gWy4uLml0ZXJhYmxlXS5tYXAoZWwgPT4gW2VsLCBsaW1pdCh0ZXN0RWxlbWVudCwgZWwsIHRlc3RlcildKTtcblxuXHQvLyBDaGVjayB0aGUgcHJvbWlzZXMgZWl0aGVyIHNlcmlhbGx5IG9yIGNvbmN1cnJlbnRseVxuXHRjb25zdCBjaGVja0xpbWl0ID0gcExpbWl0KG9wdHMucHJlc2VydmVPcmRlciA/IDEgOiBJbmZpbml0eSk7XG5cblx0cmV0dXJuIFByb21pc2UuYWxsKGl0ZW1zLm1hcChlbCA9PiBjaGVja0xpbWl0KGZpbmRlciwgZWwpKSlcblx0XHQudGhlbigoKSA9PiB7fSlcblx0XHQuY2F0Y2goZXJyID0+IGVyciBpbnN0YW5jZW9mIEVuZEVycm9yID8gZXJyLnZhbHVlIDogUHJvbWlzZS5yZWplY3QoZXJyKSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCdwYXRoLWV4aXN0cycpO1xuY29uc3QgcExvY2F0ZSA9IHJlcXVpcmUoJ3AtbG9jYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGl0ZXJhYmxlLCBvcHRpb25zKSA9PiB7XG5cdG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRjd2Q6IHByb2Nlc3MuY3dkKClcblx0fSwgb3B0aW9ucyk7XG5cblx0cmV0dXJuIHBMb2NhdGUoaXRlcmFibGUsIGVsID0+IHBhdGhFeGlzdHMocGF0aC5yZXNvbHZlKG9wdGlvbnMuY3dkLCBlbCkpLCBvcHRpb25zKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnN5bmMgPSAoaXRlcmFibGUsIG9wdGlvbnMpID0+IHtcblx0b3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdGN3ZDogcHJvY2Vzcy5jd2QoKVxuXHR9LCBvcHRpb25zKTtcblxuXHRmb3IgKGNvbnN0IGVsIG9mIGl0ZXJhYmxlKSB7XG5cdFx0aWYgKHBhdGhFeGlzdHMuc3luYyhwYXRoLnJlc29sdmUob3B0aW9ucy5jd2QsIGVsKSkpIHtcblx0XHRcdHJldHVybiBlbDtcblx0XHR9XG5cdH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgbG9jYXRlUGF0aCA9IHJlcXVpcmUoJ2xvY2F0ZS1wYXRoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZpbGVuYW1lLCBvcHRzID0ge30pID0+IHtcblx0Y29uc3Qgc3RhcnREaXIgPSBwYXRoLnJlc29sdmUob3B0cy5jd2QgfHwgJycpO1xuXHRjb25zdCB7cm9vdH0gPSBwYXRoLnBhcnNlKHN0YXJ0RGlyKTtcblxuXHRjb25zdCBmaWxlbmFtZXMgPSBbXS5jb25jYXQoZmlsZW5hbWUpO1xuXG5cdHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcblx0XHQoZnVuY3Rpb24gZmluZChkaXIpIHtcblx0XHRcdGxvY2F0ZVBhdGgoZmlsZW5hbWVzLCB7Y3dkOiBkaXJ9KS50aGVuKGZpbGUgPT4ge1xuXHRcdFx0XHRpZiAoZmlsZSkge1xuXHRcdFx0XHRcdHJlc29sdmUocGF0aC5qb2luKGRpciwgZmlsZSkpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGRpciA9PT0gcm9vdCkge1xuXHRcdFx0XHRcdHJlc29sdmUobnVsbCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZmluZChwYXRoLmRpcm5hbWUoZGlyKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pKHN0YXJ0RGlyKTtcblx0fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5zeW5jID0gKGZpbGVuYW1lLCBvcHRzID0ge30pID0+IHtcblx0bGV0IGRpciA9IHBhdGgucmVzb2x2ZShvcHRzLmN3ZCB8fCAnJyk7XG5cdGNvbnN0IHtyb290fSA9IHBhdGgucGFyc2UoZGlyKTtcblxuXHRjb25zdCBmaWxlbmFtZXMgPSBbXS5jb25jYXQoZmlsZW5hbWUpO1xuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cblx0d2hpbGUgKHRydWUpIHtcblx0XHRjb25zdCBmaWxlID0gbG9jYXRlUGF0aC5zeW5jKGZpbGVuYW1lcywge2N3ZDogZGlyfSk7XG5cblx0XHRpZiAoZmlsZSkge1xuXHRcdFx0cmV0dXJuIHBhdGguam9pbihkaXIsIGZpbGUpO1xuXHRcdH1cblxuXHRcdGlmIChkaXIgPT09IHJvb3QpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGRpciA9IHBhdGguZGlybmFtZShkaXIpO1xuXHR9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgZmluZFVwID0gcmVxdWlyZSgnZmluZC11cCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzeW5jICh7Y3dkfSA9IHt9KSA9PiBmaW5kVXAoJ3BhY2thZ2UuanNvbicsIHtjd2R9KTtcbm1vZHVsZS5leHBvcnRzLnN5bmMgPSAoe2N3ZH0gPSB7fSkgPT4gZmluZFVwLnN5bmMoJ3BhY2thZ2UuanNvbicsIHtjd2R9KTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5cbmNvbnN0IGhvbWVkaXIgPSBvcy5ob21lZGlyKCk7XG5jb25zdCB0bXBkaXIgPSBvcy50bXBkaXIoKTtcbmNvbnN0IHtlbnZ9ID0gcHJvY2VzcztcblxuY29uc3QgbWFjb3MgPSBuYW1lID0+IHtcblx0Y29uc3QgbGlicmFyeSA9IHBhdGguam9pbihob21lZGlyLCAnTGlicmFyeScpO1xuXG5cdHJldHVybiB7XG5cdFx0ZGF0YTogcGF0aC5qb2luKGxpYnJhcnksICdBcHBsaWNhdGlvbiBTdXBwb3J0JywgbmFtZSksXG5cdFx0Y29uZmlnOiBwYXRoLmpvaW4obGlicmFyeSwgJ1ByZWZlcmVuY2VzJywgbmFtZSksXG5cdFx0Y2FjaGU6IHBhdGguam9pbihsaWJyYXJ5LCAnQ2FjaGVzJywgbmFtZSksXG5cdFx0bG9nOiBwYXRoLmpvaW4obGlicmFyeSwgJ0xvZ3MnLCBuYW1lKSxcblx0XHR0ZW1wOiBwYXRoLmpvaW4odG1wZGlyLCBuYW1lKVxuXHR9O1xufTtcblxuY29uc3Qgd2luZG93cyA9IG5hbWUgPT4ge1xuXHRjb25zdCBhcHBEYXRhID0gZW52LkFQUERBVEEgfHwgcGF0aC5qb2luKGhvbWVkaXIsICdBcHBEYXRhJywgJ1JvYW1pbmcnKTtcblx0Y29uc3QgbG9jYWxBcHBEYXRhID0gZW52LkxPQ0FMQVBQREFUQSB8fCBwYXRoLmpvaW4oaG9tZWRpciwgJ0FwcERhdGEnLCAnTG9jYWwnKTtcblxuXHRyZXR1cm4ge1xuXHRcdC8vIERhdGEvY29uZmlnL2NhY2hlL2xvZyBhcmUgaW52ZW50ZWQgYnkgbWUgYXMgV2luZG93cyBpc24ndCBvcGluaW9uYXRlZCBhYm91dCB0aGlzXG5cdFx0ZGF0YTogcGF0aC5qb2luKGxvY2FsQXBwRGF0YSwgbmFtZSwgJ0RhdGEnKSxcblx0XHRjb25maWc6IHBhdGguam9pbihhcHBEYXRhLCBuYW1lLCAnQ29uZmlnJyksXG5cdFx0Y2FjaGU6IHBhdGguam9pbihsb2NhbEFwcERhdGEsIG5hbWUsICdDYWNoZScpLFxuXHRcdGxvZzogcGF0aC5qb2luKGxvY2FsQXBwRGF0YSwgbmFtZSwgJ0xvZycpLFxuXHRcdHRlbXA6IHBhdGguam9pbih0bXBkaXIsIG5hbWUpXG5cdH07XG59O1xuXG4vLyBodHRwczovL3NwZWNpZmljYXRpb25zLmZyZWVkZXNrdG9wLm9yZy9iYXNlZGlyLXNwZWMvYmFzZWRpci1zcGVjLWxhdGVzdC5odG1sXG5jb25zdCBsaW51eCA9IG5hbWUgPT4ge1xuXHRjb25zdCB1c2VybmFtZSA9IHBhdGguYmFzZW5hbWUoaG9tZWRpcik7XG5cblx0cmV0dXJuIHtcblx0XHRkYXRhOiBwYXRoLmpvaW4oZW52LlhER19EQVRBX0hPTUUgfHwgcGF0aC5qb2luKGhvbWVkaXIsICcubG9jYWwnLCAnc2hhcmUnKSwgbmFtZSksXG5cdFx0Y29uZmlnOiBwYXRoLmpvaW4oZW52LlhER19DT05GSUdfSE9NRSB8fCBwYXRoLmpvaW4oaG9tZWRpciwgJy5jb25maWcnKSwgbmFtZSksXG5cdFx0Y2FjaGU6IHBhdGguam9pbihlbnYuWERHX0NBQ0hFX0hPTUUgfHwgcGF0aC5qb2luKGhvbWVkaXIsICcuY2FjaGUnKSwgbmFtZSksXG5cdFx0Ly8gaHR0cHM6Ly93aWtpLmRlYmlhbi5vcmcvWERHQmFzZURpcmVjdG9yeVNwZWNpZmljYXRpb24jc3RhdGVcblx0XHRsb2c6IHBhdGguam9pbihlbnYuWERHX1NUQVRFX0hPTUUgfHwgcGF0aC5qb2luKGhvbWVkaXIsICcubG9jYWwnLCAnc3RhdGUnKSwgbmFtZSksXG5cdFx0dGVtcDogcGF0aC5qb2luKHRtcGRpciwgdXNlcm5hbWUsIG5hbWUpXG5cdH07XG59O1xuXG5jb25zdCBlbnZQYXRocyA9IChuYW1lLCBvcHRpb25zKSA9PiB7XG5cdGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBuYW1lfWApO1xuXHR9XG5cblx0b3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe3N1ZmZpeDogJ25vZGVqcyd9LCBvcHRpb25zKTtcblxuXHRpZiAob3B0aW9ucy5zdWZmaXgpIHtcblx0XHQvLyBBZGQgc3VmZml4IHRvIHByZXZlbnQgcG9zc2libGUgY29uZmxpY3Qgd2l0aCBuYXRpdmUgYXBwc1xuXHRcdG5hbWUgKz0gYC0ke29wdGlvbnMuc3VmZml4fWA7XG5cdH1cblxuXHRpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicpIHtcblx0XHRyZXR1cm4gbWFjb3MobmFtZSk7XG5cdH1cblxuXHRpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuXHRcdHJldHVybiB3aW5kb3dzKG5hbWUpO1xuXHR9XG5cblx0cmV0dXJuIGxpbnV4KG5hbWUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbnZQYXRocztcbi8vIFRPRE86IFJlbW92ZSB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZW52UGF0aHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIENPTlNUUyAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OT09QID0gZXhwb3J0cy5MSU1JVF9GSUxFU19ERVNDUklQVE9SUyA9IGV4cG9ydHMuTElNSVRfQkFTRU5BTUVfTEVOR1RIID0gZXhwb3J0cy5JU19VU0VSX1JPT1QgPSBleHBvcnRzLklTX1BPU0lYID0gZXhwb3J0cy5ERUZBVUxUX1RJTUVPVVRfU1lOQyA9IGV4cG9ydHMuREVGQVVMVF9USU1FT1VUX0FTWU5DID0gZXhwb3J0cy5ERUZBVUxUX1dSSVRFX09QVElPTlMgPSBleHBvcnRzLkRFRkFVTFRfUkVBRF9PUFRJT05TID0gZXhwb3J0cy5ERUZBVUxUX0ZPTERFUl9NT0RFID0gZXhwb3J0cy5ERUZBVUxUX0ZJTEVfTU9ERSA9IGV4cG9ydHMuREVGQVVMVF9FTkNPRElORyA9IHZvaWQgMDtcbmNvbnN0IERFRkFVTFRfRU5DT0RJTkcgPSAndXRmOCc7XG5leHBvcnRzLkRFRkFVTFRfRU5DT0RJTkcgPSBERUZBVUxUX0VOQ09ESU5HO1xuY29uc3QgREVGQVVMVF9GSUxFX01PREUgPSAwbzY2NjtcbmV4cG9ydHMuREVGQVVMVF9GSUxFX01PREUgPSBERUZBVUxUX0ZJTEVfTU9ERTtcbmNvbnN0IERFRkFVTFRfRk9MREVSX01PREUgPSAwbzc3NztcbmV4cG9ydHMuREVGQVVMVF9GT0xERVJfTU9ERSA9IERFRkFVTFRfRk9MREVSX01PREU7XG5jb25zdCBERUZBVUxUX1JFQURfT1BUSU9OUyA9IHt9O1xuZXhwb3J0cy5ERUZBVUxUX1JFQURfT1BUSU9OUyA9IERFRkFVTFRfUkVBRF9PUFRJT05TO1xuY29uc3QgREVGQVVMVF9XUklURV9PUFRJT05TID0ge307XG5leHBvcnRzLkRFRkFVTFRfV1JJVEVfT1BUSU9OUyA9IERFRkFVTFRfV1JJVEVfT1BUSU9OUztcbmNvbnN0IERFRkFVTFRfVElNRU9VVF9BU1lOQyA9IDUwMDA7XG5leHBvcnRzLkRFRkFVTFRfVElNRU9VVF9BU1lOQyA9IERFRkFVTFRfVElNRU9VVF9BU1lOQztcbmNvbnN0IERFRkFVTFRfVElNRU9VVF9TWU5DID0gMTAwO1xuZXhwb3J0cy5ERUZBVUxUX1RJTUVPVVRfU1lOQyA9IERFRkFVTFRfVElNRU9VVF9TWU5DO1xuY29uc3QgSVNfUE9TSVggPSAhIXByb2Nlc3MuZ2V0dWlkO1xuZXhwb3J0cy5JU19QT1NJWCA9IElTX1BPU0lYO1xuY29uc3QgSVNfVVNFUl9ST09UID0gcHJvY2Vzcy5nZXR1aWQgPyAhcHJvY2Vzcy5nZXR1aWQoKSA6IGZhbHNlO1xuZXhwb3J0cy5JU19VU0VSX1JPT1QgPSBJU19VU0VSX1JPT1Q7XG5jb25zdCBMSU1JVF9CQVNFTkFNRV9MRU5HVEggPSAxMjg7IC8vVE9ETzogZmV0Y2ggdGhlIHJlYWwgbGltaXQgZnJvbSB0aGUgZmlsZXN5c3RlbSAvL1RPRE86IGZldGNoIHRoZSB3aG9sZS1wYXRoIGxlbmd0aCBsaW1pdCB0b29cbmV4cG9ydHMuTElNSVRfQkFTRU5BTUVfTEVOR1RIID0gTElNSVRfQkFTRU5BTUVfTEVOR1RIO1xuY29uc3QgTElNSVRfRklMRVNfREVTQ1JJUFRPUlMgPSAxMDAwMDsgLy9UT0RPOiBmZXRjaCB0aGUgcmVhbCBsaW1pdCBmcm9tIHRoZSBmaWxlc3lzdGVtXG5leHBvcnRzLkxJTUlUX0ZJTEVTX0RFU0NSSVBUT1JTID0gTElNSVRfRklMRVNfREVTQ1JJUFRPUlM7XG5jb25zdCBOT09QID0gKCkgPT4geyB9O1xuZXhwb3J0cy5OT09QID0gTk9PUDtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogSU1QT1JUICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmF0dGVtcHRpZnlTeW5jID0gZXhwb3J0cy5hdHRlbXB0aWZ5QXN5bmMgPSB2b2lkIDA7XG5jb25zdCBjb25zdHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdHNcIik7XG4vKiBBVFRFTVBUSUZZICovXG4vL1RPRE86IE1heWJlIHB1Ymxpc2ggdGhpcyBhcyBhIHN0YW5kYWxvbmUgcGFja2FnZVxuLy9GSVhNRTogVGhlIHR5cGUgY2FzdGluZ3MgaGVyZSBhcmVuJ3QgZXhhY3RseSBjb3JyZWN0XG5jb25zdCBhdHRlbXB0aWZ5QXN5bmMgPSAoZm4sIG9uRXJyb3IgPSBjb25zdHNfMS5OT09QKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKS5jYXRjaChvbkVycm9yKTtcbiAgICB9O1xufTtcbmV4cG9ydHMuYXR0ZW1wdGlmeUFzeW5jID0gYXR0ZW1wdGlmeUFzeW5jO1xuY29uc3QgYXR0ZW1wdGlmeVN5bmMgPSAoZm4sIG9uRXJyb3IgPSBjb25zdHNfMS5OT09QKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gb25FcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmV4cG9ydHMuYXR0ZW1wdGlmeVN5bmMgPSBhdHRlbXB0aWZ5U3luYztcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogSU1QT1JUICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb25zdHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdHNcIik7XG4vKiBGUyBIQU5ETEVSUyAqL1xuY29uc3QgSGFuZGxlcnMgPSB7XG4gICAgaXNDaGFuZ2VFcnJvck9rOiAoZXJyb3IpID0+IHtcbiAgICAgICAgY29uc3QgeyBjb2RlIH0gPSBlcnJvcjtcbiAgICAgICAgaWYgKGNvZGUgPT09ICdFTk9TWVMnKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICghY29uc3RzXzEuSVNfVVNFUl9ST09UICYmIChjb2RlID09PSAnRUlOVkFMJyB8fCBjb2RlID09PSAnRVBFUk0nKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBpc1JldHJpYWJsZUVycm9yOiAoZXJyb3IpID0+IHtcbiAgICAgICAgY29uc3QgeyBjb2RlIH0gPSBlcnJvcjtcbiAgICAgICAgaWYgKGNvZGUgPT09ICdFTUZJTEUnIHx8IGNvZGUgPT09ICdFTkZJTEUnIHx8IGNvZGUgPT09ICdFQUdBSU4nIHx8IGNvZGUgPT09ICdFQlVTWScgfHwgY29kZSA9PT0gJ0VBQ0NFU1MnIHx8IGNvZGUgPT09ICdFQUNDUycgfHwgY29kZSA9PT0gJ0VQRVJNJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBvbkNoYW5nZUVycm9yOiAoZXJyb3IpID0+IHtcbiAgICAgICAgaWYgKEhhbmRsZXJzLmlzQ2hhbmdlRXJyb3JPayhlcnJvcikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn07XG4vKiBFWFBPUlQgKi9cbmV4cG9ydHMuZGVmYXVsdCA9IEhhbmRsZXJzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBJTVBPUlQgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbnN0c18xID0gcmVxdWlyZShcIi4uL2NvbnN0c1wiKTtcbi8qIFJFVFJZSUZZIFFVRVVFICovXG5jb25zdCBSZXRyeWZ5UXVldWUgPSB7XG4gICAgaW50ZXJ2YWw6IDI1LFxuICAgIGludGVydmFsSWQ6IHVuZGVmaW5lZCxcbiAgICBsaW1pdDogY29uc3RzXzEuTElNSVRfRklMRVNfREVTQ1JJUFRPUlMsXG4gICAgcXVldWVBY3RpdmU6IG5ldyBTZXQoKSxcbiAgICBxdWV1ZVdhaXRpbmc6IG5ldyBTZXQoKSxcbiAgICBpbml0OiAoKSA9PiB7XG4gICAgICAgIGlmIChSZXRyeWZ5UXVldWUuaW50ZXJ2YWxJZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgUmV0cnlmeVF1ZXVlLmludGVydmFsSWQgPSBzZXRJbnRlcnZhbChSZXRyeWZ5UXVldWUudGljaywgUmV0cnlmeVF1ZXVlLmludGVydmFsKTtcbiAgICB9LFxuICAgIHJlc2V0OiAoKSA9PiB7XG4gICAgICAgIGlmICghUmV0cnlmeVF1ZXVlLmludGVydmFsSWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoUmV0cnlmeVF1ZXVlLmludGVydmFsSWQpO1xuICAgICAgICBkZWxldGUgUmV0cnlmeVF1ZXVlLmludGVydmFsSWQ7XG4gICAgfSxcbiAgICBhZGQ6IChmbikgPT4ge1xuICAgICAgICBSZXRyeWZ5UXVldWUucXVldWVXYWl0aW5nLmFkZChmbik7XG4gICAgICAgIGlmIChSZXRyeWZ5UXVldWUucXVldWVBY3RpdmUuc2l6ZSA8IChSZXRyeWZ5UXVldWUubGltaXQgLyAyKSkgeyAvLyBBY3RpdmUgcXVldWUgbm90IHVuZGVyIHByZWFzc3VyZSwgZXhlY3V0aW5nIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBSZXRyeWZ5UXVldWUudGljaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgUmV0cnlmeVF1ZXVlLmluaXQoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlOiAoZm4pID0+IHtcbiAgICAgICAgUmV0cnlmeVF1ZXVlLnF1ZXVlV2FpdGluZy5kZWxldGUoZm4pO1xuICAgICAgICBSZXRyeWZ5UXVldWUucXVldWVBY3RpdmUuZGVsZXRlKGZuKTtcbiAgICB9LFxuICAgIHNjaGVkdWxlOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiBSZXRyeWZ5UXVldWUucmVtb3ZlKHJlc29sdmVyKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gKCkgPT4gcmVzb2x2ZShjbGVhbnVwKTtcbiAgICAgICAgICAgIFJldHJ5ZnlRdWV1ZS5hZGQocmVzb2x2ZXIpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIHRpY2s6ICgpID0+IHtcbiAgICAgICAgaWYgKFJldHJ5ZnlRdWV1ZS5xdWV1ZUFjdGl2ZS5zaXplID49IFJldHJ5ZnlRdWV1ZS5saW1pdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFSZXRyeWZ5UXVldWUucXVldWVXYWl0aW5nLnNpemUpXG4gICAgICAgICAgICByZXR1cm4gUmV0cnlmeVF1ZXVlLnJlc2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgZm4gb2YgUmV0cnlmeVF1ZXVlLnF1ZXVlV2FpdGluZykge1xuICAgICAgICAgICAgaWYgKFJldHJ5ZnlRdWV1ZS5xdWV1ZUFjdGl2ZS5zaXplID49IFJldHJ5ZnlRdWV1ZS5saW1pdClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIFJldHJ5ZnlRdWV1ZS5xdWV1ZVdhaXRpbmcuZGVsZXRlKGZuKTtcbiAgICAgICAgICAgIFJldHJ5ZnlRdWV1ZS5xdWV1ZUFjdGl2ZS5hZGQoZm4pO1xuICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKiBFWFBPUlQgKi9cbmV4cG9ydHMuZGVmYXVsdCA9IFJldHJ5ZnlRdWV1ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogSU1QT1JUICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJldHJ5aWZ5U3luYyA9IGV4cG9ydHMucmV0cnlpZnlBc3luYyA9IHZvaWQgMDtcbmNvbnN0IHJldHJ5aWZ5X3F1ZXVlXzEgPSByZXF1aXJlKFwiLi9yZXRyeWlmeV9xdWV1ZVwiKTtcbi8qIFJFVFJZSUZZICovXG5jb25zdCByZXRyeWlmeUFzeW5jID0gKGZuLCBpc1JldHJpYWJsZUVycm9yKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0aW1lc3RhbXApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGF0dGVtcHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0cnlpZnlfcXVldWVfMS5kZWZhdWx0LnNjaGVkdWxlKCkudGhlbihjbGVhbnVwID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0sIGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSA+PSB0aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmV0cmlhYmxlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWxheSA9IE1hdGgucm91bmQoMTAwICsgKDQwMCAqIE1hdGgucmFuZG9tKCkpKSwgZGVsYXlQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsYXlQcm9taXNlLnRoZW4oKCkgPT4gYXR0ZW1wdC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfTtcbn07XG5leHBvcnRzLnJldHJ5aWZ5QXN5bmMgPSByZXRyeWlmeUFzeW5jO1xuY29uc3QgcmV0cnlpZnlTeW5jID0gKGZuLCBpc1JldHJpYWJsZUVycm9yKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0aW1lc3RhbXApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGF0dGVtcHQoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSA+IHRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmV0cmlhYmxlRXJyb3IoZXJyb3IpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0ZW1wdC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbn07XG5leHBvcnRzLnJldHJ5aWZ5U3luYyA9IHJldHJ5aWZ5U3luYztcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogSU1QT1JUICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY29uc3QgYXR0ZW1wdGlmeV8xID0gcmVxdWlyZShcIi4vYXR0ZW1wdGlmeVwiKTtcbmNvbnN0IGZzX2hhbmRsZXJzXzEgPSByZXF1aXJlKFwiLi9mc19oYW5kbGVyc1wiKTtcbmNvbnN0IHJldHJ5aWZ5XzEgPSByZXF1aXJlKFwiLi9yZXRyeWlmeVwiKTtcbi8qIEZTICovXG5jb25zdCBGUyA9IHtcbiAgICBjaG1vZEF0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5jaG1vZCksIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5vbkNoYW5nZUVycm9yKSxcbiAgICBjaG93bkF0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5jaG93biksIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5vbkNoYW5nZUVycm9yKSxcbiAgICBjbG9zZUF0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5jbG9zZSkpLFxuICAgIGZzeW5jQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLmZzeW5jKSksXG4gICAgbWtkaXJBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMubWtkaXIpKSxcbiAgICByZWFscGF0aEF0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5yZWFscGF0aCkpLFxuICAgIHN0YXRBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMuc3RhdCkpLFxuICAgIHVubGlua0F0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy51bmxpbmspKSxcbiAgICBjbG9zZVJldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5jbG9zZSksIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICBmc3luY1JldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5mc3luYyksIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICBvcGVuUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLm9wZW4pLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgcmVhZEZpbGVSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMucmVhZEZpbGUpLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgcmVuYW1lUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLnJlbmFtZSksIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICBzdGF0UmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLnN0YXQpLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgd3JpdGVSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMud3JpdGUpLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgY2htb2RTeW5jQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlTeW5jKGZzLmNobW9kU3luYywgZnNfaGFuZGxlcnNfMS5kZWZhdWx0Lm9uQ2hhbmdlRXJyb3IpLFxuICAgIGNob3duU3luY0F0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5U3luYyhmcy5jaG93blN5bmMsIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5vbkNoYW5nZUVycm9yKSxcbiAgICBjbG9zZVN5bmNBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeVN5bmMoZnMuY2xvc2VTeW5jKSxcbiAgICBta2RpclN5bmNBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeVN5bmMoZnMubWtkaXJTeW5jKSxcbiAgICByZWFscGF0aFN5bmNBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeVN5bmMoZnMucmVhbHBhdGhTeW5jKSxcbiAgICBzdGF0U3luY0F0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5U3luYyhmcy5zdGF0U3luYyksXG4gICAgdW5saW5rU3luY0F0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5U3luYyhmcy51bmxpbmtTeW5jKSxcbiAgICBjbG9zZVN5bmNSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeVN5bmMoZnMuY2xvc2VTeW5jLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgZnN5bmNTeW5jUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlTeW5jKGZzLmZzeW5jU3luYywgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIG9wZW5TeW5jUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlTeW5jKGZzLm9wZW5TeW5jLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgcmVhZEZpbGVTeW5jUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlTeW5jKGZzLnJlYWRGaWxlU3luYywgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIHJlbmFtZVN5bmNSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeVN5bmMoZnMucmVuYW1lU3luYywgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIHN0YXRTeW5jUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlTeW5jKGZzLnN0YXRTeW5jLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgd3JpdGVTeW5jUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlTeW5jKGZzLndyaXRlU3luYywgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpXG59O1xuLyogRVhQT1JUICovXG5leHBvcnRzLmRlZmF1bHQgPSBGUztcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogTEFORyAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTGFuZyA9IHtcbiAgICBpc0Z1bmN0aW9uOiAoeCkgPT4ge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG4gICAgfSxcbiAgICBpc1N0cmluZzogKHgpID0+IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnc3RyaW5nJztcbiAgICB9LFxuICAgIGlzVW5kZWZpbmVkOiAoeCkgPT4ge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09ICd1bmRlZmluZWQnO1xuICAgIH1cbn07XG4vKiBFWFBPUlQgKi9cbmV4cG9ydHMuZGVmYXVsdCA9IExhbmc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIElNUE9SVCAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyogVkFSSUFCTEVTICovXG5jb25zdCBRdWV1ZXMgPSB7fTtcbi8qIFNDSEVEVUxFUiAqL1xuLy9UT0RPOiBNYXliZSBwdWJsaXNoIHRoaXMgYXMgYSBzdGFuZGFsb25lIHBhY2thZ2VcbmNvbnN0IFNjaGVkdWxlciA9IHtcbiAgICBuZXh0OiAoaWQpID0+IHtcbiAgICAgICAgY29uc3QgcXVldWUgPSBRdWV1ZXNbaWRdO1xuICAgICAgICBpZiAoIXF1ZXVlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICBjb25zdCBqb2IgPSBxdWV1ZVswXTtcbiAgICAgICAgaWYgKGpvYikge1xuICAgICAgICAgICAgam9iKCgpID0+IFNjaGVkdWxlci5uZXh0KGlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgUXVldWVzW2lkXTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2NoZWR1bGU6IChpZCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBsZXQgcXVldWUgPSBRdWV1ZXNbaWRdO1xuICAgICAgICAgICAgaWYgKCFxdWV1ZSlcbiAgICAgICAgICAgICAgICBxdWV1ZSA9IFF1ZXVlc1tpZF0gPSBbXTtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2gocmVzb2x2ZSk7XG4gICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICByZXNvbHZlKCgpID0+IFNjaGVkdWxlci5uZXh0KGlkKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4vKiBFWFBPUlQgKi9cbmV4cG9ydHMuZGVmYXVsdCA9IFNjaGVkdWxlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogSU1QT1JUICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBjb25zdHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdHNcIik7XG5jb25zdCBmc18xID0gcmVxdWlyZShcIi4vZnNcIik7XG4vKiBURU1QICovXG4vL1RPRE86IE1heWJlIHB1Ymxpc2ggdGhpcyBhcyBhIHN0YW5kYWxvbmUgcGFja2FnZVxuY29uc3QgVGVtcCA9IHtcbiAgICBzdG9yZToge30sXG4gICAgY3JlYXRlOiAoZmlsZVBhdGgpID0+IHtcbiAgICAgICAgY29uc3QgcmFuZG9tbmVzcyA9IGAwMDAwMDAke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDE2Nzc3MjE1KS50b1N0cmluZygxNil9YC5zbGljZSgtNiksIC8vIDYgcmFuZG9tLWVub3VnaCBoZXggY2hhcmFjdGVyc1xuICAgICAgICB0aW1lc3RhbXAgPSBEYXRlLm5vdygpLnRvU3RyaW5nKCkuc2xpY2UoLTEwKSwgLy8gMTAgcHJlY2lzZSB0aW1lc3RhbXAgZGlnaXRzXG4gICAgICAgIHByZWZpeCA9ICd0bXAtJywgc3VmZml4ID0gYC4ke3ByZWZpeH0ke3RpbWVzdGFtcH0ke3JhbmRvbW5lc3N9YCwgdGVtcFBhdGggPSBgJHtmaWxlUGF0aH0ke3N1ZmZpeH1gO1xuICAgICAgICByZXR1cm4gdGVtcFBhdGg7XG4gICAgfSxcbiAgICBnZXQ6IChmaWxlUGF0aCwgY3JlYXRvciwgcHVyZ2UgPSB0cnVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRlbXBQYXRoID0gVGVtcC50cnVuY2F0ZShjcmVhdG9yKGZpbGVQYXRoKSk7XG4gICAgICAgIGlmICh0ZW1wUGF0aCBpbiBUZW1wLnN0b3JlKVxuICAgICAgICAgICAgcmV0dXJuIFRlbXAuZ2V0KGZpbGVQYXRoLCBjcmVhdG9yLCBwdXJnZSk7IC8vIENvbGxpc2lvbiBmb3VuZCwgdHJ5IGFnYWluXG4gICAgICAgIFRlbXAuc3RvcmVbdGVtcFBhdGhdID0gcHVyZ2U7XG4gICAgICAgIGNvbnN0IGRpc3Bvc2VyID0gKCkgPT4gZGVsZXRlIFRlbXAuc3RvcmVbdGVtcFBhdGhdO1xuICAgICAgICByZXR1cm4gW3RlbXBQYXRoLCBkaXNwb3Nlcl07XG4gICAgfSxcbiAgICBwdXJnZTogKGZpbGVQYXRoKSA9PiB7XG4gICAgICAgIGlmICghVGVtcC5zdG9yZVtmaWxlUGF0aF0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRlbGV0ZSBUZW1wLnN0b3JlW2ZpbGVQYXRoXTtcbiAgICAgICAgZnNfMS5kZWZhdWx0LnVubGlua0F0dGVtcHQoZmlsZVBhdGgpO1xuICAgIH0sXG4gICAgcHVyZ2VTeW5jOiAoZmlsZVBhdGgpID0+IHtcbiAgICAgICAgaWYgKCFUZW1wLnN0b3JlW2ZpbGVQYXRoXSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZGVsZXRlIFRlbXAuc3RvcmVbZmlsZVBhdGhdO1xuICAgICAgICBmc18xLmRlZmF1bHQudW5saW5rU3luY0F0dGVtcHQoZmlsZVBhdGgpO1xuICAgIH0sXG4gICAgcHVyZ2VTeW5jQWxsOiAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZmlsZVBhdGggaW4gVGVtcC5zdG9yZSkge1xuICAgICAgICAgICAgVGVtcC5wdXJnZVN5bmMoZmlsZVBhdGgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB0cnVuY2F0ZTogKGZpbGVQYXRoKSA9PiB7XG4gICAgICAgIGNvbnN0IGJhc2VuYW1lID0gcGF0aC5iYXNlbmFtZShmaWxlUGF0aCk7XG4gICAgICAgIGlmIChiYXNlbmFtZS5sZW5ndGggPD0gY29uc3RzXzEuTElNSVRfQkFTRU5BTUVfTEVOR1RIKVxuICAgICAgICAgICAgcmV0dXJuIGZpbGVQYXRoOyAvL0ZJWE1FOiBSb3VnaCBhbmQgcXVpY2sgYXR0ZW1wdCBhdCBkZXRlY3Rpbmcgb2sgbGVuZ3Roc1xuICAgICAgICBjb25zdCB0cnVuY2FibGUgPSAvXihcXC4/KSguKj8pKCg/OlxcLlteLl0rKT8oPzpcXC50bXAtXFxkezEwfVthLWYwLTldezZ9KT8pJC8uZXhlYyhiYXNlbmFtZSk7XG4gICAgICAgIGlmICghdHJ1bmNhYmxlKVxuICAgICAgICAgICAgcmV0dXJuIGZpbGVQYXRoOyAvL0ZJWE1FOiBObyB0cnVuY2FibGUgcGFydCBkZXRlY3RlZCwgY2FuJ3QgcmVhbGx5IGRvIG11Y2ggd2l0aG91dCBhbHNvIGNoYW5naW5nIHRoZSBwYXJlbnQgcGF0aCwgd2hpY2ggaXMgdW5zYWZlLCBob3BpbmcgZm9yIHRoZSBiZXN0IGhlcmVcbiAgICAgICAgY29uc3QgdHJ1bmNhdGlvbkxlbmd0aCA9IGJhc2VuYW1lLmxlbmd0aCAtIGNvbnN0c18xLkxJTUlUX0JBU0VOQU1FX0xFTkdUSDtcbiAgICAgICAgcmV0dXJuIGAke2ZpbGVQYXRoLnNsaWNlKDAsIC1iYXNlbmFtZS5sZW5ndGgpfSR7dHJ1bmNhYmxlWzFdfSR7dHJ1bmNhYmxlWzJdLnNsaWNlKDAsIC10cnVuY2F0aW9uTGVuZ3RoKX0ke3RydW5jYWJsZVszXX1gOyAvL0ZJWE1FOiBUaGUgdHJ1bmNhYmxlIHBhcnQgbWlnaHQgYmUgc2hvcnRlciB0aGFuIG5lZWRlZCBoZXJlXG4gICAgfVxufTtcbi8qIElOSVQgKi9cbnByb2Nlc3Mub24oJ2V4aXQnLCBUZW1wLnB1cmdlU3luY0FsbCk7IC8vIEVuc3VyaW5nIHB1cmdlYWJsZSB0ZW1wIGZpbGVzIGFyZSBwdXJnZWQgb24gZXhpdFxuLyogRVhQT1JUICovXG5leHBvcnRzLmRlZmF1bHQgPSBUZW1wO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBJTVBPUlQgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMud3JpdGVGaWxlU3luYyA9IGV4cG9ydHMud3JpdGVGaWxlID0gZXhwb3J0cy5yZWFkRmlsZVN5bmMgPSBleHBvcnRzLnJlYWRGaWxlID0gdm9pZCAwO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgY29uc3RzXzEgPSByZXF1aXJlKFwiLi9jb25zdHNcIik7XG5jb25zdCBmc18xID0gcmVxdWlyZShcIi4vdXRpbHMvZnNcIik7XG5jb25zdCBsYW5nXzEgPSByZXF1aXJlKFwiLi91dGlscy9sYW5nXCIpO1xuY29uc3Qgc2NoZWR1bGVyXzEgPSByZXF1aXJlKFwiLi91dGlscy9zY2hlZHVsZXJcIik7XG5jb25zdCB0ZW1wXzEgPSByZXF1aXJlKFwiLi91dGlscy90ZW1wXCIpO1xuZnVuY3Rpb24gcmVhZEZpbGUoZmlsZVBhdGgsIG9wdGlvbnMgPSBjb25zdHNfMS5ERUZBVUxUX1JFQURfT1BUSU9OUykge1xuICAgIHZhciBfYTtcbiAgICBpZiAobGFuZ18xLmRlZmF1bHQuaXNTdHJpbmcob3B0aW9ucykpXG4gICAgICAgIHJldHVybiByZWFkRmlsZShmaWxlUGF0aCwgeyBlbmNvZGluZzogb3B0aW9ucyB9KTtcbiAgICBjb25zdCB0aW1lb3V0ID0gRGF0ZS5ub3coKSArICgoX2EgPSBvcHRpb25zLnRpbWVvdXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbnN0c18xLkRFRkFVTFRfVElNRU9VVF9BU1lOQyk7XG4gICAgcmV0dXJuIGZzXzEuZGVmYXVsdC5yZWFkRmlsZVJldHJ5KHRpbWVvdXQpKGZpbGVQYXRoLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMucmVhZEZpbGUgPSByZWFkRmlsZTtcbjtcbmZ1bmN0aW9uIHJlYWRGaWxlU3luYyhmaWxlUGF0aCwgb3B0aW9ucyA9IGNvbnN0c18xLkRFRkFVTFRfUkVBRF9PUFRJT05TKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChsYW5nXzEuZGVmYXVsdC5pc1N0cmluZyhvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIHJlYWRGaWxlU3luYyhmaWxlUGF0aCwgeyBlbmNvZGluZzogb3B0aW9ucyB9KTtcbiAgICBjb25zdCB0aW1lb3V0ID0gRGF0ZS5ub3coKSArICgoX2EgPSBvcHRpb25zLnRpbWVvdXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbnN0c18xLkRFRkFVTFRfVElNRU9VVF9TWU5DKTtcbiAgICByZXR1cm4gZnNfMS5kZWZhdWx0LnJlYWRGaWxlU3luY1JldHJ5KHRpbWVvdXQpKGZpbGVQYXRoLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMucmVhZEZpbGVTeW5jID0gcmVhZEZpbGVTeW5jO1xuO1xuY29uc3Qgd3JpdGVGaWxlID0gKGZpbGVQYXRoLCBkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICAgIGlmIChsYW5nXzEuZGVmYXVsdC5pc0Z1bmN0aW9uKG9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gd3JpdGVGaWxlKGZpbGVQYXRoLCBkYXRhLCBjb25zdHNfMS5ERUZBVUxUX1dSSVRFX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHByb21pc2UgPSB3cml0ZUZpbGVBc3luYyhmaWxlUGF0aCwgZGF0YSwgb3B0aW9ucyk7XG4gICAgaWYgKGNhbGxiYWNrKVxuICAgICAgICBwcm9taXNlLnRoZW4oY2FsbGJhY2ssIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn07XG5leHBvcnRzLndyaXRlRmlsZSA9IHdyaXRlRmlsZTtcbmNvbnN0IHdyaXRlRmlsZUFzeW5jID0gYXN5bmMgKGZpbGVQYXRoLCBkYXRhLCBvcHRpb25zID0gY29uc3RzXzEuREVGQVVMVF9XUklURV9PUFRJT05TKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChsYW5nXzEuZGVmYXVsdC5pc1N0cmluZyhvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIHdyaXRlRmlsZUFzeW5jKGZpbGVQYXRoLCBkYXRhLCB7IGVuY29kaW5nOiBvcHRpb25zIH0pO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBEYXRlLm5vdygpICsgKChfYSA9IG9wdGlvbnMudGltZW91dCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29uc3RzXzEuREVGQVVMVF9USU1FT1VUX0FTWU5DKTtcbiAgICBsZXQgc2NoZWR1bGVyQ3VzdG9tRGlzcG9zZXIgPSBudWxsLCBzY2hlZHVsZXJEaXNwb3NlciA9IG51bGwsIHRlbXBEaXNwb3NlciA9IG51bGwsIHRlbXBQYXRoID0gbnVsbCwgZmQgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChvcHRpb25zLnNjaGVkdWxlKVxuICAgICAgICAgICAgc2NoZWR1bGVyQ3VzdG9tRGlzcG9zZXIgPSBhd2FpdCBvcHRpb25zLnNjaGVkdWxlKGZpbGVQYXRoKTtcbiAgICAgICAgc2NoZWR1bGVyRGlzcG9zZXIgPSBhd2FpdCBzY2hlZHVsZXJfMS5kZWZhdWx0LnNjaGVkdWxlKGZpbGVQYXRoKTtcbiAgICAgICAgZmlsZVBhdGggPSBhd2FpdCBmc18xLmRlZmF1bHQucmVhbHBhdGhBdHRlbXB0KGZpbGVQYXRoKSB8fCBmaWxlUGF0aDtcbiAgICAgICAgW3RlbXBQYXRoLCB0ZW1wRGlzcG9zZXJdID0gdGVtcF8xLmRlZmF1bHQuZ2V0KGZpbGVQYXRoLCBvcHRpb25zLnRtcENyZWF0ZSB8fCB0ZW1wXzEuZGVmYXVsdC5jcmVhdGUsICEob3B0aW9ucy50bXBQdXJnZSA9PT0gZmFsc2UpKTtcbiAgICAgICAgY29uc3QgdXNlU3RhdENob3duID0gY29uc3RzXzEuSVNfUE9TSVggJiYgbGFuZ18xLmRlZmF1bHQuaXNVbmRlZmluZWQob3B0aW9ucy5jaG93biksIHVzZVN0YXRNb2RlID0gbGFuZ18xLmRlZmF1bHQuaXNVbmRlZmluZWQob3B0aW9ucy5tb2RlKTtcbiAgICAgICAgaWYgKHVzZVN0YXRDaG93biB8fCB1c2VTdGF0TW9kZSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdCA9IGF3YWl0IGZzXzEuZGVmYXVsdC5zdGF0QXR0ZW1wdChmaWxlUGF0aCk7XG4gICAgICAgICAgICBpZiAoc3RhdCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgICAgICBpZiAodXNlU3RhdENob3duKVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNob3duID0geyB1aWQ6IHN0YXQudWlkLCBnaWQ6IHN0YXQuZ2lkIH07XG4gICAgICAgICAgICAgICAgaWYgKHVzZVN0YXRNb2RlKVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm1vZGUgPSBzdGF0Lm1vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IHBhdGguZGlybmFtZShmaWxlUGF0aCk7XG4gICAgICAgIGF3YWl0IGZzXzEuZGVmYXVsdC5ta2RpckF0dGVtcHQocGFyZW50UGF0aCwge1xuICAgICAgICAgICAgbW9kZTogY29uc3RzXzEuREVGQVVMVF9GT0xERVJfTU9ERSxcbiAgICAgICAgICAgIHJlY3Vyc2l2ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgZmQgPSBhd2FpdCBmc18xLmRlZmF1bHQub3BlblJldHJ5KHRpbWVvdXQpKHRlbXBQYXRoLCAndycsIG9wdGlvbnMubW9kZSB8fCBjb25zdHNfMS5ERUZBVUxUX0ZJTEVfTU9ERSk7XG4gICAgICAgIGlmIChvcHRpb25zLnRtcENyZWF0ZWQpXG4gICAgICAgICAgICBvcHRpb25zLnRtcENyZWF0ZWQodGVtcFBhdGgpO1xuICAgICAgICBpZiAobGFuZ18xLmRlZmF1bHQuaXNTdHJpbmcoZGF0YSkpIHtcbiAgICAgICAgICAgIGF3YWl0IGZzXzEuZGVmYXVsdC53cml0ZVJldHJ5KHRpbWVvdXQpKGZkLCBkYXRhLCAwLCBvcHRpb25zLmVuY29kaW5nIHx8IGNvbnN0c18xLkRFRkFVTFRfRU5DT0RJTkcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFsYW5nXzEuZGVmYXVsdC5pc1VuZGVmaW5lZChkYXRhKSkge1xuICAgICAgICAgICAgYXdhaXQgZnNfMS5kZWZhdWx0LndyaXRlUmV0cnkodGltZW91dCkoZmQsIGRhdGEsIDAsIGRhdGEubGVuZ3RoLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5mc3luYyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZzeW5jV2FpdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBmc18xLmRlZmF1bHQuZnN5bmNSZXRyeSh0aW1lb3V0KShmZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmc18xLmRlZmF1bHQuZnN5bmNBdHRlbXB0KGZkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBmc18xLmRlZmF1bHQuY2xvc2VSZXRyeSh0aW1lb3V0KShmZCk7XG4gICAgICAgIGZkID0gbnVsbDtcbiAgICAgICAgaWYgKG9wdGlvbnMuY2hvd24pXG4gICAgICAgICAgICBhd2FpdCBmc18xLmRlZmF1bHQuY2hvd25BdHRlbXB0KHRlbXBQYXRoLCBvcHRpb25zLmNob3duLnVpZCwgb3B0aW9ucy5jaG93bi5naWQpO1xuICAgICAgICBpZiAob3B0aW9ucy5tb2RlKVxuICAgICAgICAgICAgYXdhaXQgZnNfMS5kZWZhdWx0LmNobW9kQXR0ZW1wdCh0ZW1wUGF0aCwgb3B0aW9ucy5tb2RlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGZzXzEuZGVmYXVsdC5yZW5hbWVSZXRyeSh0aW1lb3V0KSh0ZW1wUGF0aCwgZmlsZVBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgIT09ICdFTkFNRVRPT0xPTkcnKVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgYXdhaXQgZnNfMS5kZWZhdWx0LnJlbmFtZVJldHJ5KHRpbWVvdXQpKHRlbXBQYXRoLCB0ZW1wXzEuZGVmYXVsdC50cnVuY2F0ZShmaWxlUGF0aCkpO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBEaXNwb3NlcigpO1xuICAgICAgICB0ZW1wUGF0aCA9IG51bGw7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBpZiAoZmQpXG4gICAgICAgICAgICBhd2FpdCBmc18xLmRlZmF1bHQuY2xvc2VBdHRlbXB0KGZkKTtcbiAgICAgICAgaWYgKHRlbXBQYXRoKVxuICAgICAgICAgICAgdGVtcF8xLmRlZmF1bHQucHVyZ2UodGVtcFBhdGgpO1xuICAgICAgICBpZiAoc2NoZWR1bGVyQ3VzdG9tRGlzcG9zZXIpXG4gICAgICAgICAgICBzY2hlZHVsZXJDdXN0b21EaXNwb3NlcigpO1xuICAgICAgICBpZiAoc2NoZWR1bGVyRGlzcG9zZXIpXG4gICAgICAgICAgICBzY2hlZHVsZXJEaXNwb3NlcigpO1xuICAgIH1cbn07XG5jb25zdCB3cml0ZUZpbGVTeW5jID0gKGZpbGVQYXRoLCBkYXRhLCBvcHRpb25zID0gY29uc3RzXzEuREVGQVVMVF9XUklURV9PUFRJT05TKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChsYW5nXzEuZGVmYXVsdC5pc1N0cmluZyhvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIHdyaXRlRmlsZVN5bmMoZmlsZVBhdGgsIGRhdGEsIHsgZW5jb2Rpbmc6IG9wdGlvbnMgfSk7XG4gICAgY29uc3QgdGltZW91dCA9IERhdGUubm93KCkgKyAoKF9hID0gb3B0aW9ucy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb25zdHNfMS5ERUZBVUxUX1RJTUVPVVRfU1lOQyk7XG4gICAgbGV0IHRlbXBEaXNwb3NlciA9IG51bGwsIHRlbXBQYXRoID0gbnVsbCwgZmQgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICAgIGZpbGVQYXRoID0gZnNfMS5kZWZhdWx0LnJlYWxwYXRoU3luY0F0dGVtcHQoZmlsZVBhdGgpIHx8IGZpbGVQYXRoO1xuICAgICAgICBbdGVtcFBhdGgsIHRlbXBEaXNwb3Nlcl0gPSB0ZW1wXzEuZGVmYXVsdC5nZXQoZmlsZVBhdGgsIG9wdGlvbnMudG1wQ3JlYXRlIHx8IHRlbXBfMS5kZWZhdWx0LmNyZWF0ZSwgIShvcHRpb25zLnRtcFB1cmdlID09PSBmYWxzZSkpO1xuICAgICAgICBjb25zdCB1c2VTdGF0Q2hvd24gPSBjb25zdHNfMS5JU19QT1NJWCAmJiBsYW5nXzEuZGVmYXVsdC5pc1VuZGVmaW5lZChvcHRpb25zLmNob3duKSwgdXNlU3RhdE1vZGUgPSBsYW5nXzEuZGVmYXVsdC5pc1VuZGVmaW5lZChvcHRpb25zLm1vZGUpO1xuICAgICAgICBpZiAodXNlU3RhdENob3duIHx8IHVzZVN0YXRNb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ID0gZnNfMS5kZWZhdWx0LnN0YXRTeW5jQXR0ZW1wdChmaWxlUGF0aCk7XG4gICAgICAgICAgICBpZiAoc3RhdCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgICAgICBpZiAodXNlU3RhdENob3duKVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNob3duID0geyB1aWQ6IHN0YXQudWlkLCBnaWQ6IHN0YXQuZ2lkIH07XG4gICAgICAgICAgICAgICAgaWYgKHVzZVN0YXRNb2RlKVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm1vZGUgPSBzdGF0Lm1vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IHBhdGguZGlybmFtZShmaWxlUGF0aCk7XG4gICAgICAgIGZzXzEuZGVmYXVsdC5ta2RpclN5bmNBdHRlbXB0KHBhcmVudFBhdGgsIHtcbiAgICAgICAgICAgIG1vZGU6IGNvbnN0c18xLkRFRkFVTFRfRk9MREVSX01PREUsXG4gICAgICAgICAgICByZWN1cnNpdmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGZkID0gZnNfMS5kZWZhdWx0Lm9wZW5TeW5jUmV0cnkodGltZW91dCkodGVtcFBhdGgsICd3Jywgb3B0aW9ucy5tb2RlIHx8IGNvbnN0c18xLkRFRkFVTFRfRklMRV9NT0RFKTtcbiAgICAgICAgaWYgKG9wdGlvbnMudG1wQ3JlYXRlZClcbiAgICAgICAgICAgIG9wdGlvbnMudG1wQ3JlYXRlZCh0ZW1wUGF0aCk7XG4gICAgICAgIGlmIChsYW5nXzEuZGVmYXVsdC5pc1N0cmluZyhkYXRhKSkge1xuICAgICAgICAgICAgZnNfMS5kZWZhdWx0LndyaXRlU3luY1JldHJ5KHRpbWVvdXQpKGZkLCBkYXRhLCAwLCBvcHRpb25zLmVuY29kaW5nIHx8IGNvbnN0c18xLkRFRkFVTFRfRU5DT0RJTkcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFsYW5nXzEuZGVmYXVsdC5pc1VuZGVmaW5lZChkYXRhKSkge1xuICAgICAgICAgICAgZnNfMS5kZWZhdWx0LndyaXRlU3luY1JldHJ5KHRpbWVvdXQpKGZkLCBkYXRhLCAwLCBkYXRhLmxlbmd0aCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZnN5bmMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5mc3luY1dhaXQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZnNfMS5kZWZhdWx0LmZzeW5jU3luY1JldHJ5KHRpbWVvdXQpKGZkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZzXzEuZGVmYXVsdC5mc3luY0F0dGVtcHQoZmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZzXzEuZGVmYXVsdC5jbG9zZVN5bmNSZXRyeSh0aW1lb3V0KShmZCk7XG4gICAgICAgIGZkID0gbnVsbDtcbiAgICAgICAgaWYgKG9wdGlvbnMuY2hvd24pXG4gICAgICAgICAgICBmc18xLmRlZmF1bHQuY2hvd25TeW5jQXR0ZW1wdCh0ZW1wUGF0aCwgb3B0aW9ucy5jaG93bi51aWQsIG9wdGlvbnMuY2hvd24uZ2lkKTtcbiAgICAgICAgaWYgKG9wdGlvbnMubW9kZSlcbiAgICAgICAgICAgIGZzXzEuZGVmYXVsdC5jaG1vZFN5bmNBdHRlbXB0KHRlbXBQYXRoLCBvcHRpb25zLm1vZGUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZnNfMS5kZWZhdWx0LnJlbmFtZVN5bmNSZXRyeSh0aW1lb3V0KSh0ZW1wUGF0aCwgZmlsZVBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgIT09ICdFTkFNRVRPT0xPTkcnKVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgZnNfMS5kZWZhdWx0LnJlbmFtZVN5bmNSZXRyeSh0aW1lb3V0KSh0ZW1wUGF0aCwgdGVtcF8xLmRlZmF1bHQudHJ1bmNhdGUoZmlsZVBhdGgpKTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wRGlzcG9zZXIoKTtcbiAgICAgICAgdGVtcFBhdGggPSBudWxsO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGZkKVxuICAgICAgICAgICAgZnNfMS5kZWZhdWx0LmNsb3NlU3luY0F0dGVtcHQoZmQpO1xuICAgICAgICBpZiAodGVtcFBhdGgpXG4gICAgICAgICAgICB0ZW1wXzEuZGVmYXVsdC5wdXJnZSh0ZW1wUGF0aCk7XG4gICAgfVxufTtcbmV4cG9ydHMud3JpdGVGaWxlU3luYyA9IHdyaXRlRmlsZVN5bmM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVnZXhwQ29kZSA9IGV4cG9ydHMuZ2V0UHJvcGVydHkgPSBleHBvcnRzLnNhZmVTdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyQ29uY2F0ID0gZXhwb3J0cy5hZGRDb2RlQXJnID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLl8gPSBleHBvcnRzLm5pbCA9IGV4cG9ydHMuX0NvZGUgPSBleHBvcnRzLk5hbWUgPSBleHBvcnRzLklERU5USUZJRVIgPSBleHBvcnRzLl9Db2RlT3JOYW1lID0gdm9pZCAwO1xuY2xhc3MgX0NvZGVPck5hbWUge1xufVxuZXhwb3J0cy5fQ29kZU9yTmFtZSA9IF9Db2RlT3JOYW1lO1xuZXhwb3J0cy5JREVOVElGSUVSID0gL15bYS16JF9dW2EteiRfMC05XSokL2k7XG5jbGFzcyBOYW1lIGV4dGVuZHMgX0NvZGVPck5hbWUge1xuICAgIGNvbnN0cnVjdG9yKHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKCFleHBvcnRzLklERU5USUZJRVIudGVzdChzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvZGVHZW46IG5hbWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcIik7XG4gICAgICAgIHRoaXMuc3RyID0gcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cjtcbiAgICB9XG4gICAgZW1wdHlTdHIoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4geyBbdGhpcy5zdHJdOiAxIH07XG4gICAgfVxufVxuZXhwb3J0cy5OYW1lID0gTmFtZTtcbmNsYXNzIF9Db2RlIGV4dGVuZHMgX0NvZGVPck5hbWUge1xuICAgIGNvbnN0cnVjdG9yKGNvZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5faXRlbXMgPSB0eXBlb2YgY29kZSA9PT0gXCJzdHJpbmdcIiA/IFtjb2RlXSA6IGNvZGU7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHI7XG4gICAgfVxuICAgIGVtcHR5U3RyKCkge1xuICAgICAgICBpZiAodGhpcy5faXRlbXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW1zWzBdO1xuICAgICAgICByZXR1cm4gaXRlbSA9PT0gXCJcIiB8fCBpdGVtID09PSAnXCJcIic7XG4gICAgfVxuICAgIGdldCBzdHIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLl9zdHIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICh0aGlzLl9zdHIgPSB0aGlzLl9pdGVtcy5yZWR1Y2UoKHMsIGMpID0+IGAke3N9JHtjfWAsIFwiXCIpKSk7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuX25hbWVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAodGhpcy5fbmFtZXMgPSB0aGlzLl9pdGVtcy5yZWR1Y2UoKG5hbWVzLCBjKSA9PiB7XG4gICAgICAgICAgICBpZiAoYyBpbnN0YW5jZW9mIE5hbWUpXG4gICAgICAgICAgICAgICAgbmFtZXNbYy5zdHJdID0gKG5hbWVzW2Muc3RyXSB8fCAwKSArIDE7XG4gICAgICAgICAgICByZXR1cm4gbmFtZXM7XG4gICAgICAgIH0sIHt9KSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuX0NvZGUgPSBfQ29kZTtcbmV4cG9ydHMubmlsID0gbmV3IF9Db2RlKFwiXCIpO1xuZnVuY3Rpb24gXyhzdHJzLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgY29kZSA9IFtzdHJzWzBdXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgICBhZGRDb2RlQXJnKGNvZGUsIGFyZ3NbaV0pO1xuICAgICAgICBjb2RlLnB1c2goc3Ryc1srK2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfQ29kZShjb2RlKTtcbn1cbmV4cG9ydHMuXyA9IF87XG5jb25zdCBwbHVzID0gbmV3IF9Db2RlKFwiK1wiKTtcbmZ1bmN0aW9uIHN0cihzdHJzLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgZXhwciA9IFtzYWZlU3RyaW5naWZ5KHN0cnNbMF0pXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgICBleHByLnB1c2gocGx1cyk7XG4gICAgICAgIGFkZENvZGVBcmcoZXhwciwgYXJnc1tpXSk7XG4gICAgICAgIGV4cHIucHVzaChwbHVzLCBzYWZlU3RyaW5naWZ5KHN0cnNbKytpXSkpO1xuICAgIH1cbiAgICBvcHRpbWl6ZShleHByKTtcbiAgICByZXR1cm4gbmV3IF9Db2RlKGV4cHIpO1xufVxuZXhwb3J0cy5zdHIgPSBzdHI7XG5mdW5jdGlvbiBhZGRDb2RlQXJnKGNvZGUsIGFyZykge1xuICAgIGlmIChhcmcgaW5zdGFuY2VvZiBfQ29kZSlcbiAgICAgICAgY29kZS5wdXNoKC4uLmFyZy5faXRlbXMpO1xuICAgIGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIE5hbWUpXG4gICAgICAgIGNvZGUucHVzaChhcmcpO1xuICAgIGVsc2VcbiAgICAgICAgY29kZS5wdXNoKGludGVycG9sYXRlKGFyZykpO1xufVxuZXhwb3J0cy5hZGRDb2RlQXJnID0gYWRkQ29kZUFyZztcbmZ1bmN0aW9uIG9wdGltaXplKGV4cHIpIHtcbiAgICBsZXQgaSA9IDE7XG4gICAgd2hpbGUgKGkgPCBleHByLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgaWYgKGV4cHJbaV0gPT09IHBsdXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG1lcmdlRXhwckl0ZW1zKGV4cHJbaSAtIDFdLCBleHByW2kgKyAxXSk7XG4gICAgICAgICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBleHByLnNwbGljZShpIC0gMSwgMywgcmVzKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cHJbaSsrXSA9IFwiK1wiO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG59XG5mdW5jdGlvbiBtZXJnZUV4cHJJdGVtcyhhLCBiKSB7XG4gICAgaWYgKGIgPT09ICdcIlwiJylcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgaWYgKGEgPT09ICdcIlwiJylcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBOYW1lIHx8IGFbYS5sZW5ndGggLSAxXSAhPT0gJ1wiJylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByZXR1cm4gYCR7YS5zbGljZSgwLCAtMSl9JHtifVwiYDtcbiAgICAgICAgaWYgKGJbMF0gPT09ICdcIicpXG4gICAgICAgICAgICByZXR1cm4gYS5zbGljZSgwLCAtMSkgKyBiLnNsaWNlKDEpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYiA9PSBcInN0cmluZ1wiICYmIGJbMF0gPT09ICdcIicgJiYgIShhIGluc3RhbmNlb2YgTmFtZSkpXG4gICAgICAgIHJldHVybiBgXCIke2F9JHtiLnNsaWNlKDEpfWA7XG4gICAgcmV0dXJuO1xufVxuZnVuY3Rpb24gc3RyQ29uY2F0KGMxLCBjMikge1xuICAgIHJldHVybiBjMi5lbXB0eVN0cigpID8gYzEgOiBjMS5lbXB0eVN0cigpID8gYzIgOiBzdHIgYCR7YzF9JHtjMn1gO1xufVxuZXhwb3J0cy5zdHJDb25jYXQgPSBzdHJDb25jYXQ7XG4vLyBUT0RPIGRvIG5vdCBhbGxvdyBhcnJheXMgaGVyZVxuZnVuY3Rpb24gaW50ZXJwb2xhdGUoeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PSBcIm51bWJlclwiIHx8IHR5cGVvZiB4ID09IFwiYm9vbGVhblwiIHx8IHggPT09IG51bGxcbiAgICAgICAgPyB4XG4gICAgICAgIDogc2FmZVN0cmluZ2lmeShBcnJheS5pc0FycmF5KHgpID8geC5qb2luKFwiLFwiKSA6IHgpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KHgpIHtcbiAgICByZXR1cm4gbmV3IF9Db2RlKHNhZmVTdHJpbmdpZnkoeCkpO1xufVxuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5mdW5jdGlvbiBzYWZlU3RyaW5naWZ5KHgpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeClcbiAgICAgICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgXCJcXFxcdTIwMjhcIilcbiAgICAgICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgXCJcXFxcdTIwMjlcIik7XG59XG5leHBvcnRzLnNhZmVTdHJpbmdpZnkgPSBzYWZlU3RyaW5naWZ5O1xuZnVuY3Rpb24gZ2V0UHJvcGVydHkoa2V5KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiAmJiBleHBvcnRzLklERU5USUZJRVIudGVzdChrZXkpID8gbmV3IF9Db2RlKGAuJHtrZXl9YCkgOiBfIGBbJHtrZXl9XWA7XG59XG5leHBvcnRzLmdldFByb3BlcnR5ID0gZ2V0UHJvcGVydHk7XG5mdW5jdGlvbiByZWdleHBDb2RlKHJ4KSB7XG4gICAgcmV0dXJuIG5ldyBfQ29kZShyeC50b1N0cmluZygpKTtcbn1cbmV4cG9ydHMucmVnZXhwQ29kZSA9IHJlZ2V4cENvZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WYWx1ZVNjb3BlID0gZXhwb3J0cy5WYWx1ZVNjb3BlTmFtZSA9IGV4cG9ydHMuU2NvcGUgPSBleHBvcnRzLnZhcktpbmRzID0gZXhwb3J0cy5Vc2VkVmFsdWVTdGF0ZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuL2NvZGVcIik7XG5jbGFzcyBWYWx1ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgc3VwZXIoYENvZGVHZW46IFwiY29kZVwiIGZvciAke25hbWV9IG5vdCBkZWZpbmVkYCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBuYW1lLnZhbHVlO1xuICAgIH1cbn1cbnZhciBVc2VkVmFsdWVTdGF0ZTtcbihmdW5jdGlvbiAoVXNlZFZhbHVlU3RhdGUpIHtcbiAgICBVc2VkVmFsdWVTdGF0ZVtVc2VkVmFsdWVTdGF0ZVtcIlN0YXJ0ZWRcIl0gPSAwXSA9IFwiU3RhcnRlZFwiO1xuICAgIFVzZWRWYWx1ZVN0YXRlW1VzZWRWYWx1ZVN0YXRlW1wiQ29tcGxldGVkXCJdID0gMV0gPSBcIkNvbXBsZXRlZFwiO1xufSkoVXNlZFZhbHVlU3RhdGUgPSBleHBvcnRzLlVzZWRWYWx1ZVN0YXRlIHx8IChleHBvcnRzLlVzZWRWYWx1ZVN0YXRlID0ge30pKTtcbmV4cG9ydHMudmFyS2luZHMgPSB7XG4gICAgY29uc3Q6IG5ldyBjb2RlXzEuTmFtZShcImNvbnN0XCIpLFxuICAgIGxldDogbmV3IGNvZGVfMS5OYW1lKFwibGV0XCIpLFxuICAgIHZhcjogbmV3IGNvZGVfMS5OYW1lKFwidmFyXCIpLFxufTtcbmNsYXNzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHByZWZpeGVzLCBwYXJlbnQgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMuX25hbWVzID0ge307XG4gICAgICAgIHRoaXMuX3ByZWZpeGVzID0gcHJlZml4ZXM7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgdG9OYW1lKG5hbWVPclByZWZpeCkge1xuICAgICAgICByZXR1cm4gbmFtZU9yUHJlZml4IGluc3RhbmNlb2YgY29kZV8xLk5hbWUgPyBuYW1lT3JQcmVmaXggOiB0aGlzLm5hbWUobmFtZU9yUHJlZml4KTtcbiAgICB9XG4gICAgbmFtZShwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjb2RlXzEuTmFtZSh0aGlzLl9uZXdOYW1lKHByZWZpeCkpO1xuICAgIH1cbiAgICBfbmV3TmFtZShwcmVmaXgpIHtcbiAgICAgICAgY29uc3QgbmcgPSB0aGlzLl9uYW1lc1twcmVmaXhdIHx8IHRoaXMuX25hbWVHcm91cChwcmVmaXgpO1xuICAgICAgICByZXR1cm4gYCR7cHJlZml4fSR7bmcuaW5kZXgrK31gO1xuICAgIH1cbiAgICBfbmFtZUdyb3VwKHByZWZpeCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoKChfYiA9IChfYSA9IHRoaXMuX3BhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9wcmVmaXhlcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhhcyhwcmVmaXgpKSB8fCAodGhpcy5fcHJlZml4ZXMgJiYgIXRoaXMuX3ByZWZpeGVzLmhhcyhwcmVmaXgpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBwcmVmaXggXCIke3ByZWZpeH1cIiBpcyBub3QgYWxsb3dlZCBpbiB0aGlzIHNjb3BlYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLl9uYW1lc1twcmVmaXhdID0geyBwcmVmaXgsIGluZGV4OiAwIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuU2NvcGUgPSBTY29wZTtcbmNsYXNzIFZhbHVlU2NvcGVOYW1lIGV4dGVuZHMgY29kZV8xLk5hbWUge1xuICAgIGNvbnN0cnVjdG9yKHByZWZpeCwgbmFtZVN0cikge1xuICAgICAgICBzdXBlcihuYW1lU3RyKTtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgfVxuICAgIHNldFZhbHVlKHZhbHVlLCB7IHByb3BlcnR5LCBpdGVtSW5kZXggfSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc2NvcGVQYXRoID0gY29kZV8xLl8gYC4ke25ldyBjb2RlXzEuTmFtZShwcm9wZXJ0eSl9WyR7aXRlbUluZGV4fV1gO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFsdWVTY29wZU5hbWUgPSBWYWx1ZVNjb3BlTmFtZTtcbmNvbnN0IGxpbmUgPSBjb2RlXzEuXyBgXFxuYDtcbmNsYXNzIFZhbHVlU2NvcGUgZXh0ZW5kcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0ge307XG4gICAgICAgIHRoaXMuX3Njb3BlID0gb3B0cy5zY29wZTtcbiAgICAgICAgdGhpcy5vcHRzID0geyAuLi5vcHRzLCBfbjogb3B0cy5saW5lcyA/IGxpbmUgOiBjb2RlXzEubmlsIH07XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njb3BlO1xuICAgIH1cbiAgICBuYW1lKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlU2NvcGVOYW1lKHByZWZpeCwgdGhpcy5fbmV3TmFtZShwcmVmaXgpKTtcbiAgICB9XG4gICAgdmFsdWUobmFtZU9yUHJlZml4LCB2YWx1ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh2YWx1ZS5yZWYgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvZGVHZW46IHJlZiBtdXN0IGJlIHBhc3NlZCBpbiB2YWx1ZVwiKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4IH0gPSBuYW1lO1xuICAgICAgICBjb25zdCB2YWx1ZUtleSA9IChfYSA9IHZhbHVlLmtleSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFsdWUucmVmO1xuICAgICAgICBsZXQgdnMgPSB0aGlzLl92YWx1ZXNbcHJlZml4XTtcbiAgICAgICAgaWYgKHZzKSB7XG4gICAgICAgICAgICBjb25zdCBfbmFtZSA9IHZzLmdldCh2YWx1ZUtleSk7XG4gICAgICAgICAgICBpZiAoX25hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdnMgPSB0aGlzLl92YWx1ZXNbcHJlZml4XSA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICB2cy5zZXQodmFsdWVLZXksIG5hbWUpO1xuICAgICAgICBjb25zdCBzID0gdGhpcy5fc2NvcGVbcHJlZml4XSB8fCAodGhpcy5fc2NvcGVbcHJlZml4XSA9IFtdKTtcbiAgICAgICAgY29uc3QgaXRlbUluZGV4ID0gcy5sZW5ndGg7XG4gICAgICAgIHNbaXRlbUluZGV4XSA9IHZhbHVlLnJlZjtcbiAgICAgICAgbmFtZS5zZXRWYWx1ZSh2YWx1ZSwgeyBwcm9wZXJ0eTogcHJlZml4LCBpdGVtSW5kZXggfSk7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICBnZXRWYWx1ZShwcmVmaXgsIGtleU9yUmVmKSB7XG4gICAgICAgIGNvbnN0IHZzID0gdGhpcy5fdmFsdWVzW3ByZWZpeF07XG4gICAgICAgIGlmICghdnMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiB2cy5nZXQoa2V5T3JSZWYpO1xuICAgIH1cbiAgICBzY29wZVJlZnMoc2NvcGVOYW1lLCB2YWx1ZXMgPSB0aGlzLl92YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZHVjZVZhbHVlcyh2YWx1ZXMsIChuYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAobmFtZS5zY29wZVBhdGggPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IG5hbWUgXCIke25hbWV9XCIgaGFzIG5vIHZhbHVlYCk7XG4gICAgICAgICAgICByZXR1cm4gY29kZV8xLl8gYCR7c2NvcGVOYW1lfSR7bmFtZS5zY29wZVBhdGh9YDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNjb3BlQ29kZSh2YWx1ZXMgPSB0aGlzLl92YWx1ZXMsIHVzZWRWYWx1ZXMsIGdldENvZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZHVjZVZhbHVlcyh2YWx1ZXMsIChuYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAobmFtZS52YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogbmFtZSBcIiR7bmFtZX1cIiBoYXMgbm8gdmFsdWVgKTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lLnZhbHVlLmNvZGU7XG4gICAgICAgIH0sIHVzZWRWYWx1ZXMsIGdldENvZGUpO1xuICAgIH1cbiAgICBfcmVkdWNlVmFsdWVzKHZhbHVlcywgdmFsdWVDb2RlLCB1c2VkVmFsdWVzID0ge30sIGdldENvZGUpIHtcbiAgICAgICAgbGV0IGNvZGUgPSBjb2RlXzEubmlsO1xuICAgICAgICBmb3IgKGNvbnN0IHByZWZpeCBpbiB2YWx1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZzID0gdmFsdWVzW3ByZWZpeF07XG4gICAgICAgICAgICBpZiAoIXZzKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgbmFtZVNldCA9ICh1c2VkVmFsdWVzW3ByZWZpeF0gPSB1c2VkVmFsdWVzW3ByZWZpeF0gfHwgbmV3IE1hcCgpKTtcbiAgICAgICAgICAgIHZzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZVNldC5oYXMobmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBuYW1lU2V0LnNldChuYW1lLCBVc2VkVmFsdWVTdGF0ZS5TdGFydGVkKTtcbiAgICAgICAgICAgICAgICBsZXQgYyA9IHZhbHVlQ29kZShuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWYgPSB0aGlzLm9wdHMuZXM1ID8gZXhwb3J0cy52YXJLaW5kcy52YXIgOiBleHBvcnRzLnZhcktpbmRzLmNvbnN0O1xuICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29kZV8xLl8gYCR7Y29kZX0ke2RlZn0gJHtuYW1lfSA9ICR7Y307JHt0aGlzLm9wdHMuX259YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKGMgPSBnZXRDb2RlID09PSBudWxsIHx8IGdldENvZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdldENvZGUobmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlXzEuXyBgJHtjb2RlfSR7Y30ke3RoaXMub3B0cy5fbn1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5hbWVTZXQuc2V0KG5hbWUsIFVzZWRWYWx1ZVN0YXRlLkNvbXBsZXRlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG59XG5leHBvcnRzLlZhbHVlU2NvcGUgPSBWYWx1ZVNjb3BlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NvcGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm9yID0gZXhwb3J0cy5hbmQgPSBleHBvcnRzLm5vdCA9IGV4cG9ydHMuQ29kZUdlbiA9IGV4cG9ydHMub3BlcmF0b3JzID0gZXhwb3J0cy52YXJLaW5kcyA9IGV4cG9ydHMuVmFsdWVTY29wZU5hbWUgPSBleHBvcnRzLlZhbHVlU2NvcGUgPSBleHBvcnRzLlNjb3BlID0gZXhwb3J0cy5OYW1lID0gZXhwb3J0cy5yZWdleHBDb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLmdldFByb3BlcnR5ID0gZXhwb3J0cy5uaWwgPSBleHBvcnRzLnN0ckNvbmNhdCA9IGV4cG9ydHMuc3RyID0gZXhwb3J0cy5fID0gdm9pZCAwO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4vY29kZVwiKTtcbmNvbnN0IHNjb3BlXzEgPSByZXF1aXJlKFwiLi9zY29wZVwiKTtcbnZhciBjb2RlXzIgPSByZXF1aXJlKFwiLi9jb2RlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLl87IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5zdHI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJDb25jYXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5zdHJDb25jYXQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuaWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5uaWw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRQcm9wZXJ0eVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLmdldFByb3BlcnR5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5naWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuc3RyaW5naWZ5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVnZXhwQ29kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLnJlZ2V4cENvZGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOYW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuTmFtZTsgfSB9KTtcbnZhciBzY29wZV8yID0gcmVxdWlyZShcIi4vc2NvcGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTY29wZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NvcGVfMi5TY29wZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZhbHVlU2NvcGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjb3BlXzIuVmFsdWVTY29wZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZhbHVlU2NvcGVOYW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY29wZV8yLlZhbHVlU2NvcGVOYW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmFyS2luZHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjb3BlXzIudmFyS2luZHM7IH0gfSk7XG5leHBvcnRzLm9wZXJhdG9ycyA9IHtcbiAgICBHVDogbmV3IGNvZGVfMS5fQ29kZShcIj5cIiksXG4gICAgR1RFOiBuZXcgY29kZV8xLl9Db2RlKFwiPj1cIiksXG4gICAgTFQ6IG5ldyBjb2RlXzEuX0NvZGUoXCI8XCIpLFxuICAgIExURTogbmV3IGNvZGVfMS5fQ29kZShcIjw9XCIpLFxuICAgIEVROiBuZXcgY29kZV8xLl9Db2RlKFwiPT09XCIpLFxuICAgIE5FUTogbmV3IGNvZGVfMS5fQ29kZShcIiE9PVwiKSxcbiAgICBOT1Q6IG5ldyBjb2RlXzEuX0NvZGUoXCIhXCIpLFxuICAgIE9SOiBuZXcgY29kZV8xLl9Db2RlKFwifHxcIiksXG4gICAgQU5EOiBuZXcgY29kZV8xLl9Db2RlKFwiJiZcIiksXG4gICAgQUREOiBuZXcgY29kZV8xLl9Db2RlKFwiK1wiKSxcbn07XG5jbGFzcyBOb2RlIHtcbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhfbmFtZXMsIF9jb25zdGFudHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuY2xhc3MgRGVmIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IodmFyS2luZCwgbmFtZSwgcmhzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudmFyS2luZCA9IHZhcktpbmQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucmhzID0gcmhzO1xuICAgIH1cbiAgICByZW5kZXIoeyBlczUsIF9uIH0pIHtcbiAgICAgICAgY29uc3QgdmFyS2luZCA9IGVzNSA/IHNjb3BlXzEudmFyS2luZHMudmFyIDogdGhpcy52YXJLaW5kO1xuICAgICAgICBjb25zdCByaHMgPSB0aGlzLnJocyA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IGAgPSAke3RoaXMucmhzfWA7XG4gICAgICAgIHJldHVybiBgJHt2YXJLaW5kfSAke3RoaXMubmFtZX0ke3Joc307YCArIF9uO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgaWYgKCFuYW1lc1t0aGlzLm5hbWUuc3RyXSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMucmhzKVxuICAgICAgICAgICAgdGhpcy5yaHMgPSBvcHRpbWl6ZUV4cHIodGhpcy5yaHMsIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yaHMgaW5zdGFuY2VvZiBjb2RlXzEuX0NvZGVPck5hbWUgPyB0aGlzLnJocy5uYW1lcyA6IHt9O1xuICAgIH1cbn1cbmNsYXNzIEFzc2lnbiBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGxocywgcmhzLCBzaWRlRWZmZWN0cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxocyA9IGxocztcbiAgICAgICAgdGhpcy5yaHMgPSByaHM7XG4gICAgICAgIHRoaXMuc2lkZUVmZmVjdHMgPSBzaWRlRWZmZWN0cztcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5saHN9ID0gJHt0aGlzLnJoc307YCArIF9uO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgaWYgKHRoaXMubGhzIGluc3RhbmNlb2YgY29kZV8xLk5hbWUgJiYgIW5hbWVzW3RoaXMubGhzLnN0cl0gJiYgIXRoaXMuc2lkZUVmZmVjdHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucmhzID0gb3B0aW1pemVFeHByKHRoaXMucmhzLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSB0aGlzLmxocyBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lID8ge30gOiB7IC4uLnRoaXMubGhzLm5hbWVzIH07XG4gICAgICAgIHJldHVybiBhZGRFeHByTmFtZXMobmFtZXMsIHRoaXMucmhzKTtcbiAgICB9XG59XG5jbGFzcyBBc3NpZ25PcCBleHRlbmRzIEFzc2lnbiB7XG4gICAgY29uc3RydWN0b3IobGhzLCBvcCwgcmhzLCBzaWRlRWZmZWN0cykge1xuICAgICAgICBzdXBlcihsaHMsIHJocywgc2lkZUVmZmVjdHMpO1xuICAgICAgICB0aGlzLm9wID0gb3A7XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubGhzfSAke3RoaXMub3B9PSAke3RoaXMucmhzfTtgICsgX247XG4gICAgfVxufVxuY2xhc3MgTGFiZWwgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihsYWJlbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIHRoaXMubmFtZXMgPSB7fTtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5sYWJlbH06YCArIF9uO1xuICAgIH1cbn1cbmNsYXNzIEJyZWFrIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IobGFiZWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgICB0aGlzLm5hbWVzID0ge307XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLmxhYmVsID8gYCAke3RoaXMubGFiZWx9YCA6IFwiXCI7XG4gICAgICAgIHJldHVybiBgYnJlYWske2xhYmVsfTtgICsgX247XG4gICAgfVxufVxuY2xhc3MgVGhyb3cgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGB0aHJvdyAke3RoaXMuZXJyb3J9O2AgKyBfbjtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvci5uYW1lcztcbiAgICB9XG59XG5jbGFzcyBBbnlDb2RlIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29kZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvZGV9O2AgKyBfbjtcbiAgICB9XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29kZX1gID8gdGhpcyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIHRoaXMuY29kZSA9IG9wdGltaXplRXhwcih0aGlzLmNvZGUsIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2RlIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlT3JOYW1lID8gdGhpcy5jb2RlLm5hbWVzIDoge307XG4gICAgfVxufVxuY2xhc3MgUGFyZW50Tm9kZSBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKG5vZGVzID0gW10pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5yZWR1Y2UoKGNvZGUsIG4pID0+IGNvZGUgKyBuLnJlbmRlcihvcHRzKSwgXCJcIik7XG4gICAgfVxuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIGNvbnN0IHsgbm9kZXMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gbm9kZXNbaV0ub3B0aW1pemVOb2RlcygpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobikpXG4gICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEsIC4uLm4pO1xuICAgICAgICAgICAgZWxzZSBpZiAobilcbiAgICAgICAgICAgICAgICBub2Rlc1tpXSA9IG47XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2Rlcy5sZW5ndGggPiAwID8gdGhpcyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGNvbnN0IHsgbm9kZXMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAvLyBpdGVyYXRpbmcgYmFja3dhcmRzIGltcHJvdmVzIDEtcGFzcyBvcHRpbWl6YXRpb25cbiAgICAgICAgICAgIGNvbnN0IG4gPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChuLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBzdWJ0cmFjdE5hbWVzKG5hbWVzLCBuLm5hbWVzKTtcbiAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXMubGVuZ3RoID4gMCA/IHRoaXMgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXMucmVkdWNlKChuYW1lcywgbikgPT4gYWRkTmFtZXMobmFtZXMsIG4ubmFtZXMpLCB7fSk7XG4gICAgfVxufVxuY2xhc3MgQmxvY2tOb2RlIGV4dGVuZHMgUGFyZW50Tm9kZSB7XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIFwie1wiICsgb3B0cy5fbiArIHN1cGVyLnJlbmRlcihvcHRzKSArIFwifVwiICsgb3B0cy5fbjtcbiAgICB9XG59XG5jbGFzcyBSb290IGV4dGVuZHMgUGFyZW50Tm9kZSB7XG59XG5jbGFzcyBFbHNlIGV4dGVuZHMgQmxvY2tOb2RlIHtcbn1cbkVsc2Uua2luZCA9IFwiZWxzZVwiO1xuY2xhc3MgSWYgZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbmRpdGlvbiwgbm9kZXMpIHtcbiAgICAgICAgc3VwZXIobm9kZXMpO1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgbGV0IGNvZGUgPSBgaWYoJHt0aGlzLmNvbmRpdGlvbn0pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICAgICAgaWYgKHRoaXMuZWxzZSlcbiAgICAgICAgICAgIGNvZGUgKz0gXCJlbHNlIFwiICsgdGhpcy5lbHNlLnJlbmRlcihvcHRzKTtcbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIHN1cGVyLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgY29uc3QgY29uZCA9IHRoaXMuY29uZGl0aW9uO1xuICAgICAgICBpZiAoY29uZCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVzOyAvLyBlbHNlIGlzIGlnbm9yZWQgaGVyZVxuICAgICAgICBsZXQgZSA9IHRoaXMuZWxzZTtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5zID0gZS5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgICAgICBlID0gdGhpcy5lbHNlID0gQXJyYXkuaXNBcnJheShucykgPyBuZXcgRWxzZShucykgOiBucztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgaWYgKGNvbmQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgSWYgPyBlIDogZS5ub2RlcztcbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBuZXcgSWYobm90KGNvbmQpLCBlIGluc3RhbmNlb2YgSWYgPyBbZV0gOiBlLm5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZCA9PT0gZmFsc2UgfHwgIXRoaXMubm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZWxzZSA9IChfYSA9IHRoaXMuZWxzZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIGlmICghKHN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykgfHwgdGhpcy5lbHNlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBvcHRpbWl6ZUV4cHIodGhpcy5jb25kaXRpb24sIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IHN1cGVyLm5hbWVzO1xuICAgICAgICBhZGRFeHByTmFtZXMobmFtZXMsIHRoaXMuY29uZGl0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMuZWxzZSlcbiAgICAgICAgICAgIGFkZE5hbWVzKG5hbWVzLCB0aGlzLmVsc2UubmFtZXMpO1xuICAgICAgICByZXR1cm4gbmFtZXM7XG4gICAgfVxufVxuSWYua2luZCA9IFwiaWZcIjtcbmNsYXNzIEZvciBleHRlbmRzIEJsb2NrTm9kZSB7XG59XG5Gb3Iua2luZCA9IFwiZm9yXCI7XG5jbGFzcyBGb3JMb29wIGV4dGVuZHMgRm9yIHtcbiAgICBjb25zdHJ1Y3RvcihpdGVyYXRpb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pdGVyYXRpb24gPSBpdGVyYXRpb247XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBgZm9yKCR7dGhpcy5pdGVyYXRpb259KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBpZiAoIXN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuaXRlcmF0aW9uID0gb3B0aW1pemVFeHByKHRoaXMuaXRlcmF0aW9uLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIGFkZE5hbWVzKHN1cGVyLm5hbWVzLCB0aGlzLml0ZXJhdGlvbi5uYW1lcyk7XG4gICAgfVxufVxuY2xhc3MgRm9yUmFuZ2UgZXh0ZW5kcyBGb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhcktpbmQsIG5hbWUsIGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudmFyS2luZCA9IHZhcktpbmQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgY29uc3QgdmFyS2luZCA9IG9wdHMuZXM1ID8gc2NvcGVfMS52YXJLaW5kcy52YXIgOiB0aGlzLnZhcktpbmQ7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgZnJvbSwgdG8gfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBgZm9yKCR7dmFyS2luZH0gJHtuYW1lfT0ke2Zyb219OyAke25hbWV9PCR7dG99OyAke25hbWV9KyspYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IGFkZEV4cHJOYW1lcyhzdXBlci5uYW1lcywgdGhpcy5mcm9tKTtcbiAgICAgICAgcmV0dXJuIGFkZEV4cHJOYW1lcyhuYW1lcywgdGhpcy50byk7XG4gICAgfVxufVxuY2xhc3MgRm9ySXRlciBleHRlbmRzIEZvciB7XG4gICAgY29uc3RydWN0b3IobG9vcCwgdmFyS2luZCwgbmFtZSwgaXRlcmFibGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sb29wID0gbG9vcDtcbiAgICAgICAgdGhpcy52YXJLaW5kID0gdmFyS2luZDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5pdGVyYWJsZSA9IGl0ZXJhYmxlO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gYGZvcigke3RoaXMudmFyS2luZH0gJHt0aGlzLm5hbWV9ICR7dGhpcy5sb29wfSAke3RoaXMuaXRlcmFibGV9KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBpZiAoIXN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuaXRlcmFibGUgPSBvcHRpbWl6ZUV4cHIodGhpcy5pdGVyYWJsZSwgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiBhZGROYW1lcyhzdXBlci5uYW1lcywgdGhpcy5pdGVyYWJsZS5uYW1lcyk7XG4gICAgfVxufVxuY2xhc3MgRnVuYyBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgYXJncywgYXN5bmMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgdGhpcy5hc3luYyA9IGFzeW5jO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICBjb25zdCBfYXN5bmMgPSB0aGlzLmFzeW5jID8gXCJhc3luYyBcIiA6IFwiXCI7XG4gICAgICAgIHJldHVybiBgJHtfYXN5bmN9ZnVuY3Rpb24gJHt0aGlzLm5hbWV9KCR7dGhpcy5hcmdzfSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbn1cbkZ1bmMua2luZCA9IFwiZnVuY1wiO1xuY2xhc3MgUmV0dXJuIGV4dGVuZHMgUGFyZW50Tm9kZSB7XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIFwicmV0dXJuIFwiICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbn1cblJldHVybi5raW5kID0gXCJyZXR1cm5cIjtcbmNsYXNzIFRyeSBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgbGV0IGNvZGUgPSBcInRyeVwiICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgICAgICBpZiAodGhpcy5jYXRjaClcbiAgICAgICAgICAgIGNvZGUgKz0gdGhpcy5jYXRjaC5yZW5kZXIob3B0cyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmFsbHkpXG4gICAgICAgICAgICBjb2RlICs9IHRoaXMuZmluYWxseS5yZW5kZXIob3B0cyk7XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBzdXBlci5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgIChfYSA9IHRoaXMuY2F0Y2gpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgIChfYiA9IHRoaXMuZmluYWxseSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICAoX2EgPSB0aGlzLmNhdGNoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgKF9iID0gdGhpcy5maW5hbGx5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBzdXBlci5uYW1lcztcbiAgICAgICAgaWYgKHRoaXMuY2F0Y2gpXG4gICAgICAgICAgICBhZGROYW1lcyhuYW1lcywgdGhpcy5jYXRjaC5uYW1lcyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmFsbHkpXG4gICAgICAgICAgICBhZGROYW1lcyhuYW1lcywgdGhpcy5maW5hbGx5Lm5hbWVzKTtcbiAgICAgICAgcmV0dXJuIG5hbWVzO1xuICAgIH1cbn1cbmNsYXNzIENhdGNoIGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBgY2F0Y2goJHt0aGlzLmVycm9yfSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbn1cbkNhdGNoLmtpbmQgPSBcImNhdGNoXCI7XG5jbGFzcyBGaW5hbGx5IGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gXCJmaW5hbGx5XCIgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxufVxuRmluYWxseS5raW5kID0gXCJmaW5hbGx5XCI7XG5jbGFzcyBDb2RlR2VuIHtcbiAgICBjb25zdHJ1Y3RvcihleHRTY29wZSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IHt9O1xuICAgICAgICB0aGlzLl9ibG9ja1N0YXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLl9jb25zdGFudHMgPSB7fTtcbiAgICAgICAgdGhpcy5vcHRzID0geyAuLi5vcHRzLCBfbjogb3B0cy5saW5lcyA/IFwiXFxuXCIgOiBcIlwiIH07XG4gICAgICAgIHRoaXMuX2V4dFNjb3BlID0gZXh0U2NvcGU7XG4gICAgICAgIHRoaXMuX3Njb3BlID0gbmV3IHNjb3BlXzEuU2NvcGUoeyBwYXJlbnQ6IGV4dFNjb3BlIH0pO1xuICAgICAgICB0aGlzLl9ub2RlcyA9IFtuZXcgUm9vdCgpXTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290LnJlbmRlcih0aGlzLm9wdHMpO1xuICAgIH1cbiAgICAvLyByZXR1cm5zIHVuaXF1ZSBuYW1lIGluIHRoZSBpbnRlcm5hbCBzY29wZVxuICAgIG5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY29wZS5uYW1lKHByZWZpeCk7XG4gICAgfVxuICAgIC8vIHJlc2VydmVzIHVuaXF1ZSBuYW1lIGluIHRoZSBleHRlcm5hbCBzY29wZVxuICAgIHNjb3BlTmFtZShwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLm5hbWUocHJlZml4KTtcbiAgICB9XG4gICAgLy8gcmVzZXJ2ZXMgdW5pcXVlIG5hbWUgaW4gdGhlIGV4dGVybmFsIHNjb3BlIGFuZCBhc3NpZ25zIHZhbHVlIHRvIGl0XG4gICAgc2NvcGVWYWx1ZShwcmVmaXhPck5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9leHRTY29wZS52YWx1ZShwcmVmaXhPck5hbWUsIHZhbHVlKTtcbiAgICAgICAgY29uc3QgdnMgPSB0aGlzLl92YWx1ZXNbbmFtZS5wcmVmaXhdIHx8ICh0aGlzLl92YWx1ZXNbbmFtZS5wcmVmaXhdID0gbmV3IFNldCgpKTtcbiAgICAgICAgdnMuYWRkKG5hbWUpO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgZ2V0U2NvcGVWYWx1ZShwcmVmaXgsIGtleU9yUmVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5nZXRWYWx1ZShwcmVmaXgsIGtleU9yUmVmKTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIGNvZGUgdGhhdCBhc3NpZ25zIHZhbHVlcyBpbiB0aGUgZXh0ZXJuYWwgc2NvcGUgdG8gdGhlIG5hbWVzIHRoYXQgYXJlIHVzZWQgaW50ZXJuYWxseVxuICAgIC8vIChzYW1lIG5hbWVzIHRoYXQgd2VyZSByZXR1cm5lZCBieSBnZW4uc2NvcGVOYW1lIG9yIGdlbi5zY29wZVZhbHVlKVxuICAgIHNjb3BlUmVmcyhzY29wZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLnNjb3BlUmVmcyhzY29wZU5hbWUsIHRoaXMuX3ZhbHVlcyk7XG4gICAgfVxuICAgIHNjb3BlQ29kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLnNjb3BlQ29kZSh0aGlzLl92YWx1ZXMpO1xuICAgIH1cbiAgICBfZGVmKHZhcktpbmQsIG5hbWVPclByZWZpeCwgcmhzLCBjb25zdGFudCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIGlmIChyaHMgIT09IHVuZGVmaW5lZCAmJiBjb25zdGFudClcbiAgICAgICAgICAgIHRoaXMuX2NvbnN0YW50c1tuYW1lLnN0cl0gPSByaHM7XG4gICAgICAgIHRoaXMuX2xlYWZOb2RlKG5ldyBEZWYodmFyS2luZCwgbmFtZSwgcmhzKSk7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICAvLyBgY29uc3RgIGRlY2xhcmF0aW9uIChgdmFyYCBpbiBlczUgbW9kZSlcbiAgICBjb25zdChuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYoc2NvcGVfMS52YXJLaW5kcy5jb25zdCwgbmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCk7XG4gICAgfVxuICAgIC8vIGBsZXRgIGRlY2xhcmF0aW9uIHdpdGggb3B0aW9uYWwgYXNzaWdubWVudCAoYHZhcmAgaW4gZXM1IG1vZGUpXG4gICAgbGV0KG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZihzY29wZV8xLnZhcktpbmRzLmxldCwgbmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCk7XG4gICAgfVxuICAgIC8vIGB2YXJgIGRlY2xhcmF0aW9uIHdpdGggb3B0aW9uYWwgYXNzaWdubWVudFxuICAgIHZhcihuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYoc2NvcGVfMS52YXJLaW5kcy52YXIsIG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpO1xuICAgIH1cbiAgICAvLyBhc3NpZ25tZW50IGNvZGVcbiAgICBhc3NpZ24obGhzLCByaHMsIHNpZGVFZmZlY3RzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgQXNzaWduKGxocywgcmhzLCBzaWRlRWZmZWN0cykpO1xuICAgIH1cbiAgICAvLyBgKz1gIGNvZGVcbiAgICBhZGQobGhzLCByaHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBBc3NpZ25PcChsaHMsIGV4cG9ydHMub3BlcmF0b3JzLkFERCwgcmhzKSk7XG4gICAgfVxuICAgIC8vIGFwcGVuZHMgcGFzc2VkIFNhZmVFeHByIHRvIGNvZGUgb3IgZXhlY3V0ZXMgQmxvY2tcbiAgICBjb2RlKGMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIGMoKTtcbiAgICAgICAgZWxzZSBpZiAoYyAhPT0gY29kZV8xLm5pbClcbiAgICAgICAgICAgIHRoaXMuX2xlYWZOb2RlKG5ldyBBbnlDb2RlKGMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIHJldHVybnMgY29kZSBmb3Igb2JqZWN0IGxpdGVyYWwgZm9yIHRoZSBwYXNzZWQgYXJndW1lbnQgbGlzdCBvZiBrZXktdmFsdWUgcGFpcnNcbiAgICBvYmplY3QoLi4ua2V5VmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBbXCJ7XCJdO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBrZXlWYWx1ZXMpIHtcbiAgICAgICAgICAgIGlmIChjb2RlLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgY29kZS5wdXNoKFwiLFwiKTtcbiAgICAgICAgICAgIGNvZGUucHVzaChrZXkpO1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gdmFsdWUgfHwgdGhpcy5vcHRzLmVzNSkge1xuICAgICAgICAgICAgICAgIGNvZGUucHVzaChcIjpcIik7XG4gICAgICAgICAgICAgICAgY29kZV8xLmFkZENvZGVBcmcoY29kZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvZGUucHVzaChcIn1cIik7XG4gICAgICAgIHJldHVybiBuZXcgY29kZV8xLl9Db2RlKGNvZGUpO1xuICAgIH1cbiAgICAvLyBgaWZgIGNsYXVzZSAob3Igc3RhdGVtZW50IGlmIGB0aGVuQm9keWAgYW5kLCBvcHRpb25hbGx5LCBgZWxzZUJvZHlgIGFyZSBwYXNzZWQpXG4gICAgaWYoY29uZGl0aW9uLCB0aGVuQm9keSwgZWxzZUJvZHkpIHtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5ldyBJZihjb25kaXRpb24pKTtcbiAgICAgICAgaWYgKHRoZW5Cb2R5ICYmIGVsc2VCb2R5KSB7XG4gICAgICAgICAgICB0aGlzLmNvZGUodGhlbkJvZHkpLmVsc2UoKS5jb2RlKGVsc2VCb2R5KS5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoZW5Cb2R5KSB7XG4gICAgICAgICAgICB0aGlzLmNvZGUodGhlbkJvZHkpLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxzZUJvZHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJlbHNlXCIgYm9keSB3aXRob3V0IFwidGhlblwiIGJvZHknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gYGVsc2UgaWZgIGNsYXVzZSAtIGludmFsaWQgd2l0aG91dCBgaWZgIG9yIGFmdGVyIGBlbHNlYCBjbGF1c2VzXG4gICAgZWxzZUlmKGNvbmRpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxzZU5vZGUobmV3IElmKGNvbmRpdGlvbikpO1xuICAgIH1cbiAgICAvLyBgZWxzZWAgY2xhdXNlIC0gb25seSB2YWxpZCBhZnRlciBgaWZgIG9yIGBlbHNlIGlmYCBjbGF1c2VzXG4gICAgZWxzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vsc2VOb2RlKG5ldyBFbHNlKCkpO1xuICAgIH1cbiAgICAvLyBlbmQgYGlmYCBzdGF0ZW1lbnQgKG5lZWRlZCBpZiBnZW4uaWYgd2FzIHVzZWQgb25seSB3aXRoIGNvbmRpdGlvbilcbiAgICBlbmRJZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShJZiwgRWxzZSk7XG4gICAgfVxuICAgIF9mb3Iobm9kZSwgZm9yQm9keSkge1xuICAgICAgICB0aGlzLl9ibG9ja05vZGUobm9kZSk7XG4gICAgICAgIGlmIChmb3JCb2R5KVxuICAgICAgICAgICAgdGhpcy5jb2RlKGZvckJvZHkpLmVuZEZvcigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gYSBnZW5lcmljIGBmb3JgIGNsYXVzZSAob3Igc3RhdGVtZW50IGlmIGBmb3JCb2R5YCBpcyBwYXNzZWQpXG4gICAgZm9yKGl0ZXJhdGlvbiwgZm9yQm9keSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JMb29wKGl0ZXJhdGlvbiksIGZvckJvZHkpO1xuICAgIH1cbiAgICAvLyBgZm9yYCBzdGF0ZW1lbnQgZm9yIGEgcmFuZ2Ugb2YgdmFsdWVzXG4gICAgZm9yUmFuZ2UobmFtZU9yUHJlZml4LCBmcm9tLCB0bywgZm9yQm9keSwgdmFyS2luZCA9IHRoaXMub3B0cy5lczUgPyBzY29wZV8xLnZhcktpbmRzLnZhciA6IHNjb3BlXzEudmFyS2luZHMubGV0KSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9yUmFuZ2UodmFyS2luZCwgbmFtZSwgZnJvbSwgdG8pLCAoKSA9PiBmb3JCb2R5KG5hbWUpKTtcbiAgICB9XG4gICAgLy8gYGZvci1vZmAgc3RhdGVtZW50IChpbiBlczUgbW9kZSByZXBsYWNlIHdpdGggYSBub3JtYWwgZm9yIGxvb3ApXG4gICAgZm9yT2YobmFtZU9yUHJlZml4LCBpdGVyYWJsZSwgZm9yQm9keSwgdmFyS2luZCA9IHNjb3BlXzEudmFyS2luZHMuY29uc3QpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX3Njb3BlLnRvTmFtZShuYW1lT3JQcmVmaXgpO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmVzNSkge1xuICAgICAgICAgICAgY29uc3QgYXJyID0gaXRlcmFibGUgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSA/IGl0ZXJhYmxlIDogdGhpcy52YXIoXCJfYXJyXCIsIGl0ZXJhYmxlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvclJhbmdlKFwiX2lcIiwgMCwgY29kZV8xLl8gYCR7YXJyfS5sZW5ndGhgLCAoaSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudmFyKG5hbWUsIGNvZGVfMS5fIGAke2Fycn1bJHtpfV1gKTtcbiAgICAgICAgICAgICAgICBmb3JCb2R5KG5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9ySXRlcihcIm9mXCIsIHZhcktpbmQsIG5hbWUsIGl0ZXJhYmxlKSwgKCkgPT4gZm9yQm9keShuYW1lKSk7XG4gICAgfVxuICAgIC8vIGBmb3ItaW5gIHN0YXRlbWVudC5cbiAgICAvLyBXaXRoIG9wdGlvbiBgb3duUHJvcGVydGllc2AgcmVwbGFjZWQgd2l0aCBhIGBmb3Itb2ZgIGxvb3AgZm9yIG9iamVjdCBrZXlzXG4gICAgZm9ySW4obmFtZU9yUHJlZml4LCBvYmosIGZvckJvZHksIHZhcktpbmQgPSB0aGlzLm9wdHMuZXM1ID8gc2NvcGVfMS52YXJLaW5kcy52YXIgOiBzY29wZV8xLnZhcktpbmRzLmNvbnN0KSB7XG4gICAgICAgIGlmICh0aGlzLm9wdHMub3duUHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9yT2YobmFtZU9yUHJlZml4LCBjb2RlXzEuXyBgT2JqZWN0LmtleXMoJHtvYmp9KWAsIGZvckJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9ySXRlcihcImluXCIsIHZhcktpbmQsIG5hbWUsIG9iaiksICgpID0+IGZvckJvZHkobmFtZSkpO1xuICAgIH1cbiAgICAvLyBlbmQgYGZvcmAgbG9vcFxuICAgIGVuZEZvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShGb3IpO1xuICAgIH1cbiAgICAvLyBgbGFiZWxgIHN0YXRlbWVudFxuICAgIGxhYmVsKGxhYmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgTGFiZWwobGFiZWwpKTtcbiAgICB9XG4gICAgLy8gYGJyZWFrYCBzdGF0ZW1lbnRcbiAgICBicmVhayhsYWJlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IEJyZWFrKGxhYmVsKSk7XG4gICAgfVxuICAgIC8vIGByZXR1cm5gIHN0YXRlbWVudFxuICAgIHJldHVybih2YWx1ZSkge1xuICAgICAgICBjb25zdCBub2RlID0gbmV3IFJldHVybigpO1xuICAgICAgICB0aGlzLl9ibG9ja05vZGUobm9kZSk7XG4gICAgICAgIHRoaXMuY29kZSh2YWx1ZSk7XG4gICAgICAgIGlmIChub2RlLm5vZGVzLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJyZXR1cm5cIiBzaG91bGQgaGF2ZSBvbmUgbm9kZScpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKFJldHVybik7XG4gICAgfVxuICAgIC8vIGB0cnlgIHN0YXRlbWVudFxuICAgIHRyeSh0cnlCb2R5LCBjYXRjaENvZGUsIGZpbmFsbHlDb2RlKSB7XG4gICAgICAgIGlmICghY2F0Y2hDb2RlICYmICFmaW5hbGx5Q29kZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJ0cnlcIiB3aXRob3V0IFwiY2F0Y2hcIiBhbmQgXCJmaW5hbGx5XCInKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBUcnkoKTtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5vZGUpO1xuICAgICAgICB0aGlzLmNvZGUodHJ5Qm9keSk7XG4gICAgICAgIGlmIChjYXRjaENvZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5uYW1lKFwiZVwiKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJOb2RlID0gbm9kZS5jYXRjaCA9IG5ldyBDYXRjaChlcnJvcik7XG4gICAgICAgICAgICBjYXRjaENvZGUoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaW5hbGx5Q29kZSkge1xuICAgICAgICAgICAgdGhpcy5fY3Vyck5vZGUgPSBub2RlLmZpbmFsbHkgPSBuZXcgRmluYWxseSgpO1xuICAgICAgICAgICAgdGhpcy5jb2RlKGZpbmFsbHlDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKENhdGNoLCBGaW5hbGx5KTtcbiAgICB9XG4gICAgLy8gYHRocm93YCBzdGF0ZW1lbnRcbiAgICB0aHJvdyhlcnJvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IFRocm93KGVycm9yKSk7XG4gICAgfVxuICAgIC8vIHN0YXJ0IHNlbGYtYmFsYW5jaW5nIGJsb2NrXG4gICAgYmxvY2soYm9keSwgbm9kZUNvdW50KSB7XG4gICAgICAgIHRoaXMuX2Jsb2NrU3RhcnRzLnB1c2godGhpcy5fbm9kZXMubGVuZ3RoKTtcbiAgICAgICAgaWYgKGJvZHkpXG4gICAgICAgICAgICB0aGlzLmNvZGUoYm9keSkuZW5kQmxvY2sobm9kZUNvdW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGVuZCB0aGUgY3VycmVudCBzZWxmLWJhbGFuY2luZyBibG9ja1xuICAgIGVuZEJsb2NrKG5vZGVDb3VudCkge1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLl9ibG9ja1N0YXJ0cy5wb3AoKTtcbiAgICAgICAgaWYgKGxlbiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogbm90IGluIHNlbGYtYmFsYW5jaW5nIGJsb2NrXCIpO1xuICAgICAgICBjb25zdCB0b0Nsb3NlID0gdGhpcy5fbm9kZXMubGVuZ3RoIC0gbGVuO1xuICAgICAgICBpZiAodG9DbG9zZSA8IDAgfHwgKG5vZGVDb3VudCAhPT0gdW5kZWZpbmVkICYmIHRvQ2xvc2UgIT09IG5vZGVDb3VudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogd3JvbmcgbnVtYmVyIG9mIG5vZGVzOiAke3RvQ2xvc2V9IHZzICR7bm9kZUNvdW50fSBleHBlY3RlZGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25vZGVzLmxlbmd0aCA9IGxlbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGBmdW5jdGlvbmAgaGVhZGluZyAob3IgZGVmaW5pdGlvbiBpZiBmdW5jQm9keSBpcyBwYXNzZWQpXG4gICAgZnVuYyhuYW1lLCBhcmdzID0gY29kZV8xLm5pbCwgYXN5bmMsIGZ1bmNCb2R5KSB7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShuZXcgRnVuYyhuYW1lLCBhcmdzLCBhc3luYykpO1xuICAgICAgICBpZiAoZnVuY0JvZHkpXG4gICAgICAgICAgICB0aGlzLmNvZGUoZnVuY0JvZHkpLmVuZEZ1bmMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGVuZCBmdW5jdGlvbiBkZWZpbml0aW9uXG4gICAgZW5kRnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShGdW5jKTtcbiAgICB9XG4gICAgb3B0aW1pemUobiA9IDEpIHtcbiAgICAgICAgd2hpbGUgKG4tLSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3Qub3B0aW1pemVOb2RlcygpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdC5vcHRpbWl6ZU5hbWVzKHRoaXMuX3Jvb3QubmFtZXMsIHRoaXMuX2NvbnN0YW50cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2xlYWZOb2RlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5fY3Vyck5vZGUubm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIF9ibG9ja05vZGUobm9kZSkge1xuICAgICAgICB0aGlzLl9jdXJyTm9kZS5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB0aGlzLl9ub2Rlcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgICBfZW5kQmxvY2tOb2RlKE4xLCBOMikge1xuICAgICAgICBjb25zdCBuID0gdGhpcy5fY3Vyck5vZGU7XG4gICAgICAgIGlmIChuIGluc3RhbmNlb2YgTjEgfHwgKE4yICYmIG4gaW5zdGFuY2VvZiBOMikpIHtcbiAgICAgICAgICAgIHRoaXMuX25vZGVzLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBub3QgaW4gYmxvY2sgXCIke04yID8gYCR7TjEua2luZH0vJHtOMi5raW5kfWAgOiBOMS5raW5kfVwiYCk7XG4gICAgfVxuICAgIF9lbHNlTm9kZShub2RlKSB7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLl9jdXJyTm9kZTtcbiAgICAgICAgaWYgKCEobiBpbnN0YW5jZW9mIElmKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlR2VuOiBcImVsc2VcIiB3aXRob3V0IFwiaWZcIicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnJOb2RlID0gbi5lbHNlID0gbm9kZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBfcm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vZGVzWzBdO1xuICAgIH1cbiAgICBnZXQgX2N1cnJOb2RlKCkge1xuICAgICAgICBjb25zdCBucyA9IHRoaXMuX25vZGVzO1xuICAgICAgICByZXR1cm4gbnNbbnMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHNldCBfY3Vyck5vZGUobm9kZSkge1xuICAgICAgICBjb25zdCBucyA9IHRoaXMuX25vZGVzO1xuICAgICAgICBuc1tucy5sZW5ndGggLSAxXSA9IG5vZGU7XG4gICAgfVxufVxuZXhwb3J0cy5Db2RlR2VuID0gQ29kZUdlbjtcbmZ1bmN0aW9uIGFkZE5hbWVzKG5hbWVzLCBmcm9tKSB7XG4gICAgZm9yIChjb25zdCBuIGluIGZyb20pXG4gICAgICAgIG5hbWVzW25dID0gKG5hbWVzW25dIHx8IDApICsgKGZyb21bbl0gfHwgMCk7XG4gICAgcmV0dXJuIG5hbWVzO1xufVxuZnVuY3Rpb24gYWRkRXhwck5hbWVzKG5hbWVzLCBmcm9tKSB7XG4gICAgcmV0dXJuIGZyb20gaW5zdGFuY2VvZiBjb2RlXzEuX0NvZGVPck5hbWUgPyBhZGROYW1lcyhuYW1lcywgZnJvbS5uYW1lcykgOiBuYW1lcztcbn1cbmZ1bmN0aW9uIG9wdGltaXplRXhwcihleHByLCBuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSlcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VOYW1lKGV4cHIpO1xuICAgIGlmICghY2FuT3B0aW1pemUoZXhwcikpXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIHJldHVybiBuZXcgY29kZV8xLl9Db2RlKGV4cHIuX2l0ZW1zLnJlZHVjZSgoaXRlbXMsIGMpID0+IHtcbiAgICAgICAgaWYgKGMgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSlcbiAgICAgICAgICAgIGMgPSByZXBsYWNlTmFtZShjKTtcbiAgICAgICAgaWYgKGMgaW5zdGFuY2VvZiBjb2RlXzEuX0NvZGUpXG4gICAgICAgICAgICBpdGVtcy5wdXNoKC4uLmMuX2l0ZW1zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgaXRlbXMucHVzaChjKTtcbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0sIFtdKSk7XG4gICAgZnVuY3Rpb24gcmVwbGFjZU5hbWUobikge1xuICAgICAgICBjb25zdCBjID0gY29uc3RhbnRzW24uc3RyXTtcbiAgICAgICAgaWYgKGMgPT09IHVuZGVmaW5lZCB8fCBuYW1lc1tuLnN0cl0gIT09IDEpXG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgZGVsZXRlIG5hbWVzW24uc3RyXTtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbk9wdGltaXplKGUpIHtcbiAgICAgICAgcmV0dXJuIChlIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlICYmXG4gICAgICAgICAgICBlLl9pdGVtcy5zb21lKChjKSA9PiBjIGluc3RhbmNlb2YgY29kZV8xLk5hbWUgJiYgbmFtZXNbYy5zdHJdID09PSAxICYmIGNvbnN0YW50c1tjLnN0cl0gIT09IHVuZGVmaW5lZCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN1YnRyYWN0TmFtZXMobmFtZXMsIGZyb20pIHtcbiAgICBmb3IgKGNvbnN0IG4gaW4gZnJvbSlcbiAgICAgICAgbmFtZXNbbl0gPSAobmFtZXNbbl0gfHwgMCkgLSAoZnJvbVtuXSB8fCAwKTtcbn1cbmZ1bmN0aW9uIG5vdCh4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09IFwiYm9vbGVhblwiIHx8IHR5cGVvZiB4ID09IFwibnVtYmVyXCIgfHwgeCA9PT0gbnVsbCA/ICF4IDogY29kZV8xLl8gYCEke3Bhcih4KX1gO1xufVxuZXhwb3J0cy5ub3QgPSBub3Q7XG5jb25zdCBhbmRDb2RlID0gbWFwcGVuZChleHBvcnRzLm9wZXJhdG9ycy5BTkQpO1xuLy8gYm9vbGVhbiBBTkQgKCYmKSBleHByZXNzaW9uIHdpdGggdGhlIHBhc3NlZCBhcmd1bWVudHNcbmZ1bmN0aW9uIGFuZCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGFyZ3MucmVkdWNlKGFuZENvZGUpO1xufVxuZXhwb3J0cy5hbmQgPSBhbmQ7XG5jb25zdCBvckNvZGUgPSBtYXBwZW5kKGV4cG9ydHMub3BlcmF0b3JzLk9SKTtcbi8vIGJvb2xlYW4gT1IgKHx8KSBleHByZXNzaW9uIHdpdGggdGhlIHBhc3NlZCBhcmd1bWVudHNcbmZ1bmN0aW9uIG9yKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gYXJncy5yZWR1Y2Uob3JDb2RlKTtcbn1cbmV4cG9ydHMub3IgPSBvcjtcbmZ1bmN0aW9uIG1hcHBlbmQob3ApIHtcbiAgICByZXR1cm4gKHgsIHkpID0+ICh4ID09PSBjb2RlXzEubmlsID8geSA6IHkgPT09IGNvZGVfMS5uaWwgPyB4IDogY29kZV8xLl8gYCR7cGFyKHgpfSAke29wfSAke3Bhcih5KX1gKTtcbn1cbmZ1bmN0aW9uIHBhcih4KSB7XG4gICAgcmV0dXJuIHggaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSA/IHggOiBjb2RlXzEuXyBgKCR7eH0pYDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jaGVja1N0cmljdE1vZGUgPSBleHBvcnRzLmdldEVycm9yUGF0aCA9IGV4cG9ydHMuVHlwZSA9IGV4cG9ydHMudXNlRnVuYyA9IGV4cG9ydHMuc2V0RXZhbHVhdGVkID0gZXhwb3J0cy5ldmFsdWF0ZWRQcm9wc1RvTmFtZSA9IGV4cG9ydHMubWVyZ2VFdmFsdWF0ZWQgPSBleHBvcnRzLmVhY2hJdGVtID0gZXhwb3J0cy51bmVzY2FwZUpzb25Qb2ludGVyID0gZXhwb3J0cy5lc2NhcGVKc29uUG9pbnRlciA9IGV4cG9ydHMuZXNjYXBlRnJhZ21lbnQgPSBleHBvcnRzLnVuZXNjYXBlRnJhZ21lbnQgPSBleHBvcnRzLnNjaGVtYVJlZk9yVmFsID0gZXhwb3J0cy5zY2hlbWFIYXNSdWxlc0J1dFJlZiA9IGV4cG9ydHMuc2NoZW1hSGFzUnVsZXMgPSBleHBvcnRzLmNoZWNrVW5rbm93blJ1bGVzID0gZXhwb3J0cy5hbHdheXNWYWxpZFNjaGVtYSA9IGV4cG9ydHMudG9IYXNoID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4vY29kZWdlblwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW4vY29kZVwiKTtcbi8vIFRPRE8gcmVmYWN0b3IgdG8gdXNlIFNldFxuZnVuY3Rpb24gdG9IYXNoKGFycikge1xuICAgIGNvbnN0IGhhc2ggPSB7fTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKVxuICAgICAgICBoYXNoW2l0ZW1dID0gdHJ1ZTtcbiAgICByZXR1cm4gaGFzaDtcbn1cbmV4cG9ydHMudG9IYXNoID0gdG9IYXNoO1xuZnVuY3Rpb24gYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIGlmIChPYmplY3Qua2V5cyhzY2hlbWEpLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2hlY2tVbmtub3duUnVsZXMoaXQsIHNjaGVtYSk7XG4gICAgcmV0dXJuICFzY2hlbWFIYXNSdWxlcyhzY2hlbWEsIGl0LnNlbGYuUlVMRVMuYWxsKTtcbn1cbmV4cG9ydHMuYWx3YXlzVmFsaWRTY2hlbWEgPSBhbHdheXNWYWxpZFNjaGVtYTtcbmZ1bmN0aW9uIGNoZWNrVW5rbm93blJ1bGVzKGl0LCBzY2hlbWEgPSBpdC5zY2hlbWEpIHtcbiAgICBjb25zdCB7IG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgIGlmICghb3B0cy5zdHJpY3RTY2hlbWEpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBydWxlcyA9IHNlbGYuUlVMRVMua2V5d29yZHM7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGlmICghcnVsZXNba2V5XSlcbiAgICAgICAgICAgIGNoZWNrU3RyaWN0TW9kZShpdCwgYHVua25vd24ga2V5d29yZDogXCIke2tleX1cImApO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tVbmtub3duUnVsZXMgPSBjaGVja1Vua25vd25SdWxlcztcbmZ1bmN0aW9uIHNjaGVtYUhhc1J1bGVzKHNjaGVtYSwgcnVsZXMpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuICFzY2hlbWE7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKVxuICAgICAgICBpZiAocnVsZXNba2V5XSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuc2NoZW1hSGFzUnVsZXMgPSBzY2hlbWFIYXNSdWxlcztcbmZ1bmN0aW9uIHNjaGVtYUhhc1J1bGVzQnV0UmVmKHNjaGVtYSwgUlVMRVMpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuICFzY2hlbWE7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKVxuICAgICAgICBpZiAoa2V5ICE9PSBcIiRyZWZcIiAmJiBSVUxFUy5hbGxba2V5XSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuc2NoZW1hSGFzUnVsZXNCdXRSZWYgPSBzY2hlbWFIYXNSdWxlc0J1dFJlZjtcbmZ1bmN0aW9uIHNjaGVtYVJlZk9yVmFsKHsgdG9wU2NoZW1hUmVmLCBzY2hlbWFQYXRoIH0sIHNjaGVtYSwga2V5d29yZCwgJGRhdGEpIHtcbiAgICBpZiAoISRkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLl8gYCR7c2NoZW1hfWA7XG4gICAgfVxuICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgJHt0b3BTY2hlbWFSZWZ9JHtzY2hlbWFQYXRofSR7Y29kZWdlbl8xLmdldFByb3BlcnR5KGtleXdvcmQpfWA7XG59XG5leHBvcnRzLnNjaGVtYVJlZk9yVmFsID0gc2NoZW1hUmVmT3JWYWw7XG5mdW5jdGlvbiB1bmVzY2FwZUZyYWdtZW50KHN0cikge1xuICAgIHJldHVybiB1bmVzY2FwZUpzb25Qb2ludGVyKGRlY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbn1cbmV4cG9ydHMudW5lc2NhcGVGcmFnbWVudCA9IHVuZXNjYXBlRnJhZ21lbnQ7XG5mdW5jdGlvbiBlc2NhcGVGcmFnbWVudChzdHIpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGVzY2FwZUpzb25Qb2ludGVyKHN0cikpO1xufVxuZXhwb3J0cy5lc2NhcGVGcmFnbWVudCA9IGVzY2FwZUZyYWdtZW50O1xuZnVuY3Rpb24gZXNjYXBlSnNvblBvaW50ZXIoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgPT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIGAke3N0cn1gO1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcLy9nLCBcIn4xXCIpO1xufVxuZXhwb3J0cy5lc2NhcGVKc29uUG9pbnRlciA9IGVzY2FwZUpzb25Qb2ludGVyO1xuZnVuY3Rpb24gdW5lc2NhcGVKc29uUG9pbnRlcihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL34xL2csIFwiL1wiKS5yZXBsYWNlKC9+MC9nLCBcIn5cIik7XG59XG5leHBvcnRzLnVuZXNjYXBlSnNvblBvaW50ZXIgPSB1bmVzY2FwZUpzb25Qb2ludGVyO1xuZnVuY3Rpb24gZWFjaEl0ZW0oeHMsIGYpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh4cykpIHtcbiAgICAgICAgZm9yIChjb25zdCB4IG9mIHhzKVxuICAgICAgICAgICAgZih4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGYoeHMpO1xuICAgIH1cbn1cbmV4cG9ydHMuZWFjaEl0ZW0gPSBlYWNoSXRlbTtcbmZ1bmN0aW9uIG1ha2VNZXJnZUV2YWx1YXRlZCh7IG1lcmdlTmFtZXMsIG1lcmdlVG9OYW1lLCBtZXJnZVZhbHVlcywgcmVzdWx0VG9OYW1lLCB9KSB7XG4gICAgcmV0dXJuIChnZW4sIGZyb20sIHRvLCB0b05hbWUpID0+IHtcbiAgICAgICAgY29uc3QgcmVzID0gdG8gPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBmcm9tXG4gICAgICAgICAgICA6IHRvIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWVcbiAgICAgICAgICAgICAgICA/IChmcm9tIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUgPyBtZXJnZU5hbWVzKGdlbiwgZnJvbSwgdG8pIDogbWVyZ2VUb05hbWUoZ2VuLCBmcm9tLCB0byksIHRvKVxuICAgICAgICAgICAgICAgIDogZnJvbSBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lXG4gICAgICAgICAgICAgICAgICAgID8gKG1lcmdlVG9OYW1lKGdlbiwgdG8sIGZyb20pLCBmcm9tKVxuICAgICAgICAgICAgICAgICAgICA6IG1lcmdlVmFsdWVzKGZyb20sIHRvKTtcbiAgICAgICAgcmV0dXJuIHRvTmFtZSA9PT0gY29kZWdlbl8xLk5hbWUgJiYgIShyZXMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSkgPyByZXN1bHRUb05hbWUoZ2VuLCByZXMpIDogcmVzO1xuICAgIH07XG59XG5leHBvcnRzLm1lcmdlRXZhbHVhdGVkID0ge1xuICAgIHByb3BzOiBtYWtlTWVyZ2VFdmFsdWF0ZWQoe1xuICAgICAgICBtZXJnZU5hbWVzOiAoZ2VuLCBmcm9tLCB0bykgPT4gZ2VuLmlmKGNvZGVnZW5fMS5fIGAke3RvfSAhPT0gdHJ1ZSAmJiAke2Zyb219ICE9PSB1bmRlZmluZWRgLCAoKSA9PiB7XG4gICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7ZnJvbX0gPT09IHRydWVgLCAoKSA9PiBnZW4uYXNzaWduKHRvLCB0cnVlKSwgKCkgPT4gZ2VuLmFzc2lnbih0bywgY29kZWdlbl8xLl8gYCR7dG99IHx8IHt9YCkuY29kZShjb2RlZ2VuXzEuXyBgT2JqZWN0LmFzc2lnbigke3RvfSwgJHtmcm9tfSlgKSk7XG4gICAgICAgIH0pLFxuICAgICAgICBtZXJnZVRvTmFtZTogKGdlbiwgZnJvbSwgdG8pID0+IGdlbi5pZihjb2RlZ2VuXzEuXyBgJHt0b30gIT09IHRydWVgLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZnJvbSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odG8sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih0bywgY29kZWdlbl8xLl8gYCR7dG99IHx8IHt9YCk7XG4gICAgICAgICAgICAgICAgc2V0RXZhbHVhdGVkKGdlbiwgdG8sIGZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgbWVyZ2VWYWx1ZXM6IChmcm9tLCB0bykgPT4gKGZyb20gPT09IHRydWUgPyB0cnVlIDogeyAuLi5mcm9tLCAuLi50byB9KSxcbiAgICAgICAgcmVzdWx0VG9OYW1lOiBldmFsdWF0ZWRQcm9wc1RvTmFtZSxcbiAgICB9KSxcbiAgICBpdGVtczogbWFrZU1lcmdlRXZhbHVhdGVkKHtcbiAgICAgICAgbWVyZ2VOYW1lczogKGdlbiwgZnJvbSwgdG8pID0+IGdlbi5pZihjb2RlZ2VuXzEuXyBgJHt0b30gIT09IHRydWUgJiYgJHtmcm9tfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4gZ2VuLmFzc2lnbih0bywgY29kZWdlbl8xLl8gYCR7ZnJvbX0gPT09IHRydWUgPyB0cnVlIDogJHt0b30gPiAke2Zyb219ID8gJHt0b30gOiAke2Zyb219YCkpLFxuICAgICAgICBtZXJnZVRvTmFtZTogKGdlbiwgZnJvbSwgdG8pID0+IGdlbi5pZihjb2RlZ2VuXzEuXyBgJHt0b30gIT09IHRydWVgLCAoKSA9PiBnZW4uYXNzaWduKHRvLCBmcm9tID09PSB0cnVlID8gdHJ1ZSA6IGNvZGVnZW5fMS5fIGAke3RvfSA+ICR7ZnJvbX0gPyAke3RvfSA6ICR7ZnJvbX1gKSksXG4gICAgICAgIG1lcmdlVmFsdWVzOiAoZnJvbSwgdG8pID0+IChmcm9tID09PSB0cnVlID8gdHJ1ZSA6IE1hdGgubWF4KGZyb20sIHRvKSksXG4gICAgICAgIHJlc3VsdFRvTmFtZTogKGdlbiwgaXRlbXMpID0+IGdlbi52YXIoXCJpdGVtc1wiLCBpdGVtcyksXG4gICAgfSksXG59O1xuZnVuY3Rpb24gZXZhbHVhdGVkUHJvcHNUb05hbWUoZ2VuLCBwcykge1xuICAgIGlmIChwcyA9PT0gdHJ1ZSlcbiAgICAgICAgcmV0dXJuIGdlbi52YXIoXCJwcm9wc1wiLCB0cnVlKTtcbiAgICBjb25zdCBwcm9wcyA9IGdlbi52YXIoXCJwcm9wc1wiLCBjb2RlZ2VuXzEuXyBge31gKTtcbiAgICBpZiAocHMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgc2V0RXZhbHVhdGVkKGdlbiwgcHJvcHMsIHBzKTtcbiAgICByZXR1cm4gcHJvcHM7XG59XG5leHBvcnRzLmV2YWx1YXRlZFByb3BzVG9OYW1lID0gZXZhbHVhdGVkUHJvcHNUb05hbWU7XG5mdW5jdGlvbiBzZXRFdmFsdWF0ZWQoZ2VuLCBwcm9wcywgcHMpIHtcbiAgICBPYmplY3Qua2V5cyhwcykuZm9yRWFjaCgocCkgPT4gZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHtwcm9wc30ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eShwKX1gLCB0cnVlKSk7XG59XG5leHBvcnRzLnNldEV2YWx1YXRlZCA9IHNldEV2YWx1YXRlZDtcbmNvbnN0IHNuaXBwZXRzID0ge307XG5mdW5jdGlvbiB1c2VGdW5jKGdlbiwgZikge1xuICAgIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcImZ1bmNcIiwge1xuICAgICAgICByZWY6IGYsXG4gICAgICAgIGNvZGU6IHNuaXBwZXRzW2YuY29kZV0gfHwgKHNuaXBwZXRzW2YuY29kZV0gPSBuZXcgY29kZV8xLl9Db2RlKGYuY29kZSkpLFxuICAgIH0pO1xufVxuZXhwb3J0cy51c2VGdW5jID0gdXNlRnVuYztcbnZhciBUeXBlO1xuKGZ1bmN0aW9uIChUeXBlKSB7XG4gICAgVHlwZVtUeXBlW1wiTnVtXCJdID0gMF0gPSBcIk51bVwiO1xuICAgIFR5cGVbVHlwZVtcIlN0clwiXSA9IDFdID0gXCJTdHJcIjtcbn0pKFR5cGUgPSBleHBvcnRzLlR5cGUgfHwgKGV4cG9ydHMuVHlwZSA9IHt9KSk7XG5mdW5jdGlvbiBnZXRFcnJvclBhdGgoZGF0YVByb3AsIGRhdGFQcm9wVHlwZSwganNQcm9wZXJ0eVN5bnRheCkge1xuICAgIC8vIGxldCBwYXRoXG4gICAgaWYgKGRhdGFQcm9wIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpIHtcbiAgICAgICAgY29uc3QgaXNOdW1iZXIgPSBkYXRhUHJvcFR5cGUgPT09IFR5cGUuTnVtO1xuICAgICAgICByZXR1cm4ganNQcm9wZXJ0eVN5bnRheFxuICAgICAgICAgICAgPyBpc051bWJlclxuICAgICAgICAgICAgICAgID8gY29kZWdlbl8xLl8gYFwiW1wiICsgJHtkYXRhUHJvcH0gKyBcIl1cImBcbiAgICAgICAgICAgICAgICA6IGNvZGVnZW5fMS5fIGBcIlsnXCIgKyAke2RhdGFQcm9wfSArIFwiJ11cImBcbiAgICAgICAgICAgIDogaXNOdW1iZXJcbiAgICAgICAgICAgICAgICA/IGNvZGVnZW5fMS5fIGBcIi9cIiArICR7ZGF0YVByb3B9YFxuICAgICAgICAgICAgICAgIDogY29kZWdlbl8xLl8gYFwiL1wiICsgJHtkYXRhUHJvcH0ucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcXFwvL2csIFwifjFcIilgOyAvLyBUT0RPIG1heWJlIHVzZSBnbG9iYWwgZXNjYXBlUG9pbnRlclxuICAgIH1cbiAgICByZXR1cm4ganNQcm9wZXJ0eVN5bnRheCA/IGNvZGVnZW5fMS5nZXRQcm9wZXJ0eShkYXRhUHJvcCkudG9TdHJpbmcoKSA6IFwiL1wiICsgZXNjYXBlSnNvblBvaW50ZXIoZGF0YVByb3ApO1xufVxuZXhwb3J0cy5nZXRFcnJvclBhdGggPSBnZXRFcnJvclBhdGg7XG5mdW5jdGlvbiBjaGVja1N0cmljdE1vZGUoaXQsIG1zZywgbW9kZSA9IGl0Lm9wdHMuc3RyaWN0U2NoZW1hKSB7XG4gICAgaWYgKCFtb2RlKVxuICAgICAgICByZXR1cm47XG4gICAgbXNnID0gYHN0cmljdCBtb2RlOiAke21zZ31gO1xuICAgIGlmIChtb2RlID09PSB0cnVlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICBpdC5zZWxmLmxvZ2dlci53YXJuKG1zZyk7XG59XG5leHBvcnRzLmNoZWNrU3RyaWN0TW9kZSA9IGNoZWNrU3RyaWN0TW9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXMgPSB7XG4gICAgLy8gdmFsaWRhdGlvbiBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICBkYXRhOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJkYXRhXCIpLFxuICAgIC8vIGFyZ3MgcGFzc2VkIGZyb20gcmVmZXJlbmNpbmcgc2NoZW1hXG4gICAgdmFsQ3h0OiBuZXcgY29kZWdlbl8xLk5hbWUoXCJ2YWxDeHRcIiksXG4gICAgaW5zdGFuY2VQYXRoOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJpbnN0YW5jZVBhdGhcIiksXG4gICAgcGFyZW50RGF0YTogbmV3IGNvZGVnZW5fMS5OYW1lKFwicGFyZW50RGF0YVwiKSxcbiAgICBwYXJlbnREYXRhUHJvcGVydHk6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmVudERhdGFQcm9wZXJ0eVwiKSxcbiAgICByb290RGF0YTogbmV3IGNvZGVnZW5fMS5OYW1lKFwicm9vdERhdGFcIiksXG4gICAgZHluYW1pY0FuY2hvcnM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImR5bmFtaWNBbmNob3JzXCIpLFxuICAgIC8vIGZ1bmN0aW9uIHNjb3BlZCB2YXJpYWJsZXNcbiAgICB2RXJyb3JzOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJ2RXJyb3JzXCIpLFxuICAgIGVycm9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwiZXJyb3JzXCIpLFxuICAgIHRoaXM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInRoaXNcIiksXG4gICAgLy8gXCJnbG9iYWxzXCJcbiAgICBzZWxmOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJzZWxmXCIpLFxuICAgIHNjb3BlOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJzY29wZVwiKSxcbiAgICAvLyBKVEQgc2VyaWFsaXplL3BhcnNlIG5hbWUgZm9yIEpTT04gc3RyaW5nIGFuZCBwb3NpdGlvblxuICAgIGpzb246IG5ldyBjb2RlZ2VuXzEuTmFtZShcImpzb25cIiksXG4gICAganNvblBvczogbmV3IGNvZGVnZW5fMS5OYW1lKFwianNvblBvc1wiKSxcbiAgICBqc29uTGVuOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJqc29uTGVuXCIpLFxuICAgIGpzb25QYXJ0OiBuZXcgY29kZWdlbl8xLk5hbWUoXCJqc29uUGFydFwiKSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBuYW1lcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hbWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHRlbmRFcnJvcnMgPSBleHBvcnRzLnJlc2V0RXJyb3JzQ291bnQgPSBleHBvcnRzLnJlcG9ydEV4dHJhRXJyb3IgPSBleHBvcnRzLnJlcG9ydEVycm9yID0gZXhwb3J0cy5rZXl3b3JkJERhdGFFcnJvciA9IGV4cG9ydHMua2V5d29yZEVycm9yID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4vY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4vbmFtZXNcIik7XG5leHBvcnRzLmtleXdvcmRFcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBrZXl3b3JkIH0pID0+IGNvZGVnZW5fMS5zdHIgYG11c3QgcGFzcyBcIiR7a2V5d29yZH1cIiBrZXl3b3JkIHZhbGlkYXRpb25gLFxufTtcbmV4cG9ydHMua2V5d29yZCREYXRhRXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsga2V5d29yZCwgc2NoZW1hVHlwZSB9KSA9PiBzY2hlbWFUeXBlXG4gICAgICAgID8gY29kZWdlbl8xLnN0ciBgXCIke2tleXdvcmR9XCIga2V5d29yZCBtdXN0IGJlICR7c2NoZW1hVHlwZX0gKCRkYXRhKWBcbiAgICAgICAgOiBjb2RlZ2VuXzEuc3RyIGBcIiR7a2V5d29yZH1cIiBrZXl3b3JkIGlzIGludmFsaWQgKCRkYXRhKWAsXG59O1xuZnVuY3Rpb24gcmVwb3J0RXJyb3IoY3h0LCBlcnJvciA9IGV4cG9ydHMua2V5d29yZEVycm9yLCBlcnJvclBhdGhzLCBvdmVycmlkZUFsbEVycm9ycykge1xuICAgIGNvbnN0IHsgaXQgfSA9IGN4dDtcbiAgICBjb25zdCB7IGdlbiwgY29tcG9zaXRlUnVsZSwgYWxsRXJyb3JzIH0gPSBpdDtcbiAgICBjb25zdCBlcnJPYmogPSBlcnJvck9iamVjdENvZGUoY3h0LCBlcnJvciwgZXJyb3JQYXRocyk7XG4gICAgaWYgKG92ZXJyaWRlQWxsRXJyb3JzICE9PSBudWxsICYmIG92ZXJyaWRlQWxsRXJyb3JzICE9PSB2b2lkIDAgPyBvdmVycmlkZUFsbEVycm9ycyA6IChjb21wb3NpdGVSdWxlIHx8IGFsbEVycm9ycykpIHtcbiAgICAgICAgYWRkRXJyb3IoZ2VuLCBlcnJPYmopO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuRXJyb3JzKGl0LCBjb2RlZ2VuXzEuXyBgWyR7ZXJyT2JqfV1gKTtcbiAgICB9XG59XG5leHBvcnRzLnJlcG9ydEVycm9yID0gcmVwb3J0RXJyb3I7XG5mdW5jdGlvbiByZXBvcnRFeHRyYUVycm9yKGN4dCwgZXJyb3IgPSBleHBvcnRzLmtleXdvcmRFcnJvciwgZXJyb3JQYXRocykge1xuICAgIGNvbnN0IHsgaXQgfSA9IGN4dDtcbiAgICBjb25zdCB7IGdlbiwgY29tcG9zaXRlUnVsZSwgYWxsRXJyb3JzIH0gPSBpdDtcbiAgICBjb25zdCBlcnJPYmogPSBlcnJvck9iamVjdENvZGUoY3h0LCBlcnJvciwgZXJyb3JQYXRocyk7XG4gICAgYWRkRXJyb3IoZ2VuLCBlcnJPYmopO1xuICAgIGlmICghKGNvbXBvc2l0ZVJ1bGUgfHwgYWxsRXJyb3JzKSkge1xuICAgICAgICByZXR1cm5FcnJvcnMoaXQsIG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzKTtcbiAgICB9XG59XG5leHBvcnRzLnJlcG9ydEV4dHJhRXJyb3IgPSByZXBvcnRFeHRyYUVycm9yO1xuZnVuY3Rpb24gcmVzZXRFcnJvcnNDb3VudChnZW4sIGVycnNDb3VudCkge1xuICAgIGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LmVycm9ycywgZXJyc0NvdW50KTtcbiAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9ICE9PSBudWxsYCwgKCkgPT4gZ2VuLmlmKGVycnNDb3VudCwgKCkgPT4gZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30ubGVuZ3RoYCwgZXJyc0NvdW50KSwgKCkgPT4gZ2VuLmFzc2lnbihuYW1lc18xLmRlZmF1bHQudkVycm9ycywgbnVsbCkpKTtcbn1cbmV4cG9ydHMucmVzZXRFcnJvcnNDb3VudCA9IHJlc2V0RXJyb3JzQ291bnQ7XG5mdW5jdGlvbiBleHRlbmRFcnJvcnMoeyBnZW4sIGtleXdvcmQsIHNjaGVtYVZhbHVlLCBkYXRhLCBlcnJzQ291bnQsIGl0LCB9KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGVycnNDb3VudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgY29uc3QgZXJyID0gZ2VuLm5hbWUoXCJlcnJcIik7XG4gICAgZ2VuLmZvclJhbmdlKFwiaVwiLCBlcnJzQ291bnQsIG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsIChpKSA9PiB7XG4gICAgICAgIGdlbi5jb25zdChlcnIsIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfVske2l9XWApO1xuICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7ZXJyfS5pbnN0YW5jZVBhdGggPT09IHVuZGVmaW5lZGAsICgpID0+IGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7ZXJyfS5pbnN0YW5jZVBhdGhgLCBjb2RlZ2VuXzEuc3RyQ29uY2F0KG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsIGl0LmVycm9yUGF0aCkpKTtcbiAgICAgICAgZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHtlcnJ9LnNjaGVtYVBhdGhgLCBjb2RlZ2VuXzEuc3RyIGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gKTtcbiAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHtlcnJ9LnNjaGVtYWAsIHNjaGVtYVZhbHVlKTtcbiAgICAgICAgICAgIGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7ZXJyfS5kYXRhYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuZXh0ZW5kRXJyb3JzID0gZXh0ZW5kRXJyb3JzO1xuZnVuY3Rpb24gYWRkRXJyb3IoZ2VuLCBlcnJPYmopIHtcbiAgICBjb25zdCBlcnIgPSBnZW4uY29uc3QoXCJlcnJcIiwgZXJyT2JqKTtcbiAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9ID09PSBudWxsYCwgKCkgPT4gZ2VuLmFzc2lnbihuYW1lc18xLmRlZmF1bHQudkVycm9ycywgY29kZWdlbl8xLl8gYFske2Vycn1dYCksIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5wdXNoKCR7ZXJyfSlgKTtcbiAgICBnZW4uY29kZShjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfSsrYCk7XG59XG5mdW5jdGlvbiByZXR1cm5FcnJvcnMoaXQsIGVycnMpIHtcbiAgICBjb25zdCB7IGdlbiwgdmFsaWRhdGVOYW1lLCBzY2hlbWFFbnYgfSA9IGl0O1xuICAgIGlmIChzY2hlbWFFbnYuJGFzeW5jKSB7XG4gICAgICAgIGdlbi50aHJvdyhjb2RlZ2VuXzEuXyBgbmV3ICR7aXQuVmFsaWRhdGlvbkVycm9yfSgke2VycnN9KWApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIGVycnMpO1xuICAgICAgICBnZW4ucmV0dXJuKGZhbHNlKTtcbiAgICB9XG59XG5jb25zdCBFID0ge1xuICAgIGtleXdvcmQ6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImtleXdvcmRcIiksXG4gICAgc2NoZW1hUGF0aDogbmV3IGNvZGVnZW5fMS5OYW1lKFwic2NoZW1hUGF0aFwiKSxcbiAgICBwYXJhbXM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmFtc1wiKSxcbiAgICBwcm9wZXJ0eU5hbWU6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInByb3BlcnR5TmFtZVwiKSxcbiAgICBtZXNzYWdlOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJtZXNzYWdlXCIpLFxuICAgIHNjaGVtYTogbmV3IGNvZGVnZW5fMS5OYW1lKFwic2NoZW1hXCIpLFxuICAgIHBhcmVudFNjaGVtYTogbmV3IGNvZGVnZW5fMS5OYW1lKFwicGFyZW50U2NoZW1hXCIpLFxufTtcbmZ1bmN0aW9uIGVycm9yT2JqZWN0Q29kZShjeHQsIGVycm9yLCBlcnJvclBhdGhzKSB7XG4gICAgY29uc3QgeyBjcmVhdGVFcnJvcnMgfSA9IGN4dC5pdDtcbiAgICBpZiAoY3JlYXRlRXJyb3JzID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5fIGB7fWA7XG4gICAgcmV0dXJuIGVycm9yT2JqZWN0KGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpO1xufVxuZnVuY3Rpb24gZXJyb3JPYmplY3QoY3h0LCBlcnJvciwgZXJyb3JQYXRocyA9IHt9KSB7XG4gICAgY29uc3QgeyBnZW4sIGl0IH0gPSBjeHQ7XG4gICAgY29uc3Qga2V5VmFsdWVzID0gW1xuICAgICAgICBlcnJvckluc3RhbmNlUGF0aChpdCwgZXJyb3JQYXRocyksXG4gICAgICAgIGVycm9yU2NoZW1hUGF0aChjeHQsIGVycm9yUGF0aHMpLFxuICAgIF07XG4gICAgZXh0cmFFcnJvclByb3BzKGN4dCwgZXJyb3IsIGtleVZhbHVlcyk7XG4gICAgcmV0dXJuIGdlbi5vYmplY3QoLi4ua2V5VmFsdWVzKTtcbn1cbmZ1bmN0aW9uIGVycm9ySW5zdGFuY2VQYXRoKHsgZXJyb3JQYXRoIH0sIHsgaW5zdGFuY2VQYXRoIH0pIHtcbiAgICBjb25zdCBpbnN0UGF0aCA9IGluc3RhbmNlUGF0aFxuICAgICAgICA/IGNvZGVnZW5fMS5zdHIgYCR7ZXJyb3JQYXRofSR7dXRpbF8xLmdldEVycm9yUGF0aChpbnN0YW5jZVBhdGgsIHV0aWxfMS5UeXBlLlN0cil9YFxuICAgICAgICA6IGVycm9yUGF0aDtcbiAgICByZXR1cm4gW25hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsIGNvZGVnZW5fMS5zdHJDb25jYXQobmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgaW5zdFBhdGgpXTtcbn1cbmZ1bmN0aW9uIGVycm9yU2NoZW1hUGF0aCh7IGtleXdvcmQsIGl0OiB7IGVyclNjaGVtYVBhdGggfSB9LCB7IHNjaGVtYVBhdGgsIHBhcmVudFNjaGVtYSB9KSB7XG4gICAgbGV0IHNjaFBhdGggPSBwYXJlbnRTY2hlbWEgPyBlcnJTY2hlbWFQYXRoIDogY29kZWdlbl8xLnN0ciBgJHtlcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9YDtcbiAgICBpZiAoc2NoZW1hUGF0aCkge1xuICAgICAgICBzY2hQYXRoID0gY29kZWdlbl8xLnN0ciBgJHtzY2hQYXRofSR7dXRpbF8xLmdldEVycm9yUGF0aChzY2hlbWFQYXRoLCB1dGlsXzEuVHlwZS5TdHIpfWA7XG4gICAgfVxuICAgIHJldHVybiBbRS5zY2hlbWFQYXRoLCBzY2hQYXRoXTtcbn1cbmZ1bmN0aW9uIGV4dHJhRXJyb3JQcm9wcyhjeHQsIHsgcGFyYW1zLCBtZXNzYWdlIH0sIGtleVZhbHVlcykge1xuICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hVmFsdWUsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgeyBvcHRzLCBwcm9wZXJ0eU5hbWUsIHRvcFNjaGVtYVJlZiwgc2NoZW1hUGF0aCB9ID0gaXQ7XG4gICAga2V5VmFsdWVzLnB1c2goW0Uua2V5d29yZCwga2V5d29yZF0sIFtFLnBhcmFtcywgdHlwZW9mIHBhcmFtcyA9PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMoY3h0KSA6IHBhcmFtcyB8fCBjb2RlZ2VuXzEuXyBge31gXSk7XG4gICAgaWYgKG9wdHMubWVzc2FnZXMpIHtcbiAgICAgICAga2V5VmFsdWVzLnB1c2goW0UubWVzc2FnZSwgdHlwZW9mIG1lc3NhZ2UgPT0gXCJmdW5jdGlvblwiID8gbWVzc2FnZShjeHQpIDogbWVzc2FnZV0pO1xuICAgIH1cbiAgICBpZiAob3B0cy52ZXJib3NlKSB7XG4gICAgICAgIGtleVZhbHVlcy5wdXNoKFtFLnNjaGVtYSwgc2NoZW1hVmFsdWVdLCBbRS5wYXJlbnRTY2hlbWEsIGNvZGVnZW5fMS5fIGAke3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9YF0sIFtuYW1lc18xLmRlZmF1bHQuZGF0YSwgZGF0YV0pO1xuICAgIH1cbiAgICBpZiAocHJvcGVydHlOYW1lKVxuICAgICAgICBrZXlWYWx1ZXMucHVzaChbRS5wcm9wZXJ0eU5hbWUsIHByb3BlcnR5TmFtZV0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ib29sT3JFbXB0eVNjaGVtYSA9IGV4cG9ydHMudG9wQm9vbE9yRW1wdHlTY2hlbWEgPSB2b2lkIDA7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vbmFtZXNcIik7XG5jb25zdCBib29sRXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJib29sZWFuIHNjaGVtYSBpcyBmYWxzZVwiLFxufTtcbmZ1bmN0aW9uIHRvcEJvb2xPckVtcHR5U2NoZW1hKGl0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgdmFsaWRhdGVOYW1lIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICBmYWxzZVNjaGVtYUVycm9yKGl0LCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBzY2hlbWEuJGFzeW5jID09PSB0cnVlKSB7XG4gICAgICAgIGdlbi5yZXR1cm4obmFtZXNfMS5kZWZhdWx0LmRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIG51bGwpO1xuICAgICAgICBnZW4ucmV0dXJuKHRydWUpO1xuICAgIH1cbn1cbmV4cG9ydHMudG9wQm9vbE9yRW1wdHlTY2hlbWEgPSB0b3BCb29sT3JFbXB0eVNjaGVtYTtcbmZ1bmN0aW9uIGJvb2xPckVtcHR5U2NoZW1hKGl0LCB2YWxpZCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEgfSA9IGl0O1xuICAgIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgIGdlbi52YXIodmFsaWQsIGZhbHNlKTsgLy8gVE9ETyB2YXJcbiAgICAgICAgZmFsc2VTY2hlbWFFcnJvcihpdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW4udmFyKHZhbGlkLCB0cnVlKTsgLy8gVE9ETyB2YXJcbiAgICB9XG59XG5leHBvcnRzLmJvb2xPckVtcHR5U2NoZW1hID0gYm9vbE9yRW1wdHlTY2hlbWE7XG5mdW5jdGlvbiBmYWxzZVNjaGVtYUVycm9yKGl0LCBvdmVycmlkZUFsbEVycm9ycykge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhIH0gPSBpdDtcbiAgICAvLyBUT0RPIG1heWJlIHNvbWUgb3RoZXIgaW50ZXJmYWNlIHNob3VsZCBiZSB1c2VkIGZvciBub24ta2V5d29yZCB2YWxpZGF0aW9uIGVycm9ycy4uLlxuICAgIGNvbnN0IGN4dCA9IHtcbiAgICAgICAgZ2VuLFxuICAgICAgICBrZXl3b3JkOiBcImZhbHNlIHNjaGVtYVwiLFxuICAgICAgICBkYXRhLFxuICAgICAgICBzY2hlbWE6IGZhbHNlLFxuICAgICAgICBzY2hlbWFDb2RlOiBmYWxzZSxcbiAgICAgICAgc2NoZW1hVmFsdWU6IGZhbHNlLFxuICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICBpdCxcbiAgICB9O1xuICAgIGVycm9yc18xLnJlcG9ydEVycm9yKGN4dCwgYm9vbEVycm9yLCB1bmRlZmluZWQsIG92ZXJyaWRlQWxsRXJyb3JzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvb2xTY2hlbWEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFJ1bGVzID0gZXhwb3J0cy5pc0pTT05UeXBlID0gdm9pZCAwO1xuY29uc3QgX2pzb25UeXBlcyA9IFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImludGVnZXJcIiwgXCJib29sZWFuXCIsIFwibnVsbFwiLCBcIm9iamVjdFwiLCBcImFycmF5XCJdO1xuY29uc3QganNvblR5cGVzID0gbmV3IFNldChfanNvblR5cGVzKTtcbmZ1bmN0aW9uIGlzSlNPTlR5cGUoeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PSBcInN0cmluZ1wiICYmIGpzb25UeXBlcy5oYXMoeCk7XG59XG5leHBvcnRzLmlzSlNPTlR5cGUgPSBpc0pTT05UeXBlO1xuZnVuY3Rpb24gZ2V0UnVsZXMoKSB7XG4gICAgY29uc3QgZ3JvdXBzID0ge1xuICAgICAgICBudW1iZXI6IHsgdHlwZTogXCJudW1iZXJcIiwgcnVsZXM6IFtdIH0sXG4gICAgICAgIHN0cmluZzogeyB0eXBlOiBcInN0cmluZ1wiLCBydWxlczogW10gfSxcbiAgICAgICAgYXJyYXk6IHsgdHlwZTogXCJhcnJheVwiLCBydWxlczogW10gfSxcbiAgICAgICAgb2JqZWN0OiB7IHR5cGU6IFwib2JqZWN0XCIsIHJ1bGVzOiBbXSB9LFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZXM6IHsgLi4uZ3JvdXBzLCBpbnRlZ2VyOiB0cnVlLCBib29sZWFuOiB0cnVlLCBudWxsOiB0cnVlIH0sXG4gICAgICAgIHJ1bGVzOiBbeyBydWxlczogW10gfSwgZ3JvdXBzLm51bWJlciwgZ3JvdXBzLnN0cmluZywgZ3JvdXBzLmFycmF5LCBncm91cHMub2JqZWN0XSxcbiAgICAgICAgcG9zdDogeyBydWxlczogW10gfSxcbiAgICAgICAgYWxsOiB7fSxcbiAgICAgICAga2V5d29yZHM6IHt9LFxuICAgIH07XG59XG5leHBvcnRzLmdldFJ1bGVzID0gZ2V0UnVsZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ydWxlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hvdWxkVXNlUnVsZSA9IGV4cG9ydHMuc2hvdWxkVXNlR3JvdXAgPSBleHBvcnRzLnNjaGVtYUhhc1J1bGVzRm9yVHlwZSA9IHZvaWQgMDtcbmZ1bmN0aW9uIHNjaGVtYUhhc1J1bGVzRm9yVHlwZSh7IHNjaGVtYSwgc2VsZiB9LCB0eXBlKSB7XG4gICAgY29uc3QgZ3JvdXAgPSBzZWxmLlJVTEVTLnR5cGVzW3R5cGVdO1xuICAgIHJldHVybiBncm91cCAmJiBncm91cCAhPT0gdHJ1ZSAmJiBzaG91bGRVc2VHcm91cChzY2hlbWEsIGdyb3VwKTtcbn1cbmV4cG9ydHMuc2NoZW1hSGFzUnVsZXNGb3JUeXBlID0gc2NoZW1hSGFzUnVsZXNGb3JUeXBlO1xuZnVuY3Rpb24gc2hvdWxkVXNlR3JvdXAoc2NoZW1hLCBncm91cCkge1xuICAgIHJldHVybiBncm91cC5ydWxlcy5zb21lKChydWxlKSA9PiBzaG91bGRVc2VSdWxlKHNjaGVtYSwgcnVsZSkpO1xufVxuZXhwb3J0cy5zaG91bGRVc2VHcm91cCA9IHNob3VsZFVzZUdyb3VwO1xuZnVuY3Rpb24gc2hvdWxkVXNlUnVsZShzY2hlbWEsIHJ1bGUpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChzY2hlbWFbcnVsZS5rZXl3b3JkXSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICgoX2EgPSBydWxlLmRlZmluaXRpb24uaW1wbGVtZW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvbWUoKGt3ZCkgPT4gc2NoZW1hW2t3ZF0gIT09IHVuZGVmaW5lZCkpKTtcbn1cbmV4cG9ydHMuc2hvdWxkVXNlUnVsZSA9IHNob3VsZFVzZVJ1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHBsaWNhYmlsaXR5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXBvcnRUeXBlRXJyb3IgPSBleHBvcnRzLmNoZWNrRGF0YVR5cGVzID0gZXhwb3J0cy5jaGVja0RhdGFUeXBlID0gZXhwb3J0cy5jb2VyY2VBbmRDaGVja0RhdGFUeXBlID0gZXhwb3J0cy5nZXRKU09OVHlwZXMgPSBleHBvcnRzLmdldFNjaGVtYVR5cGVzID0gZXhwb3J0cy5EYXRhVHlwZSA9IHZvaWQgMDtcbmNvbnN0IHJ1bGVzXzEgPSByZXF1aXJlKFwiLi4vcnVsZXNcIik7XG5jb25zdCBhcHBsaWNhYmlsaXR5XzEgPSByZXF1aXJlKFwiLi9hcHBsaWNhYmlsaXR5XCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBEYXRhVHlwZTtcbihmdW5jdGlvbiAoRGF0YVR5cGUpIHtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIkNvcnJlY3RcIl0gPSAwXSA9IFwiQ29ycmVjdFwiO1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wiV3JvbmdcIl0gPSAxXSA9IFwiV3JvbmdcIjtcbn0pKERhdGFUeXBlID0gZXhwb3J0cy5EYXRhVHlwZSB8fCAoZXhwb3J0cy5EYXRhVHlwZSA9IHt9KSk7XG5mdW5jdGlvbiBnZXRTY2hlbWFUeXBlcyhzY2hlbWEpIHtcbiAgICBjb25zdCB0eXBlcyA9IGdldEpTT05UeXBlcyhzY2hlbWEudHlwZSk7XG4gICAgY29uc3QgaGFzTnVsbCA9IHR5cGVzLmluY2x1ZGVzKFwibnVsbFwiKTtcbiAgICBpZiAoaGFzTnVsbCkge1xuICAgICAgICBpZiAoc2NoZW1hLm51bGxhYmxlID09PSBmYWxzZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInR5cGU6IG51bGwgY29udHJhZGljdHMgbnVsbGFibGU6IGZhbHNlXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCF0eXBlcy5sZW5ndGggJiYgc2NoZW1hLm51bGxhYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJudWxsYWJsZVwiIGNhbm5vdCBiZSB1c2VkIHdpdGhvdXQgXCJ0eXBlXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLm51bGxhYmxlID09PSB0cnVlKVxuICAgICAgICAgICAgdHlwZXMucHVzaChcIm51bGxcIik7XG4gICAgfVxuICAgIHJldHVybiB0eXBlcztcbn1cbmV4cG9ydHMuZ2V0U2NoZW1hVHlwZXMgPSBnZXRTY2hlbWFUeXBlcztcbmZ1bmN0aW9uIGdldEpTT05UeXBlcyh0cykge1xuICAgIGNvbnN0IHR5cGVzID0gQXJyYXkuaXNBcnJheSh0cykgPyB0cyA6IHRzID8gW3RzXSA6IFtdO1xuICAgIGlmICh0eXBlcy5ldmVyeShydWxlc18xLmlzSlNPTlR5cGUpKVxuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZSBtdXN0IGJlIEpTT05UeXBlIG9yIEpTT05UeXBlW106IFwiICsgdHlwZXMuam9pbihcIixcIikpO1xufVxuZXhwb3J0cy5nZXRKU09OVHlwZXMgPSBnZXRKU09OVHlwZXM7XG5mdW5jdGlvbiBjb2VyY2VBbmRDaGVja0RhdGFUeXBlKGl0LCB0eXBlcykge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBvcHRzIH0gPSBpdDtcbiAgICBjb25zdCBjb2VyY2VUbyA9IGNvZXJjZVRvVHlwZXModHlwZXMsIG9wdHMuY29lcmNlVHlwZXMpO1xuICAgIGNvbnN0IGNoZWNrVHlwZXMgPSB0eXBlcy5sZW5ndGggPiAwICYmXG4gICAgICAgICEoY29lcmNlVG8ubGVuZ3RoID09PSAwICYmIHR5cGVzLmxlbmd0aCA9PT0gMSAmJiBhcHBsaWNhYmlsaXR5XzEuc2NoZW1hSGFzUnVsZXNGb3JUeXBlKGl0LCB0eXBlc1swXSkpO1xuICAgIGlmIChjaGVja1R5cGVzKSB7XG4gICAgICAgIGNvbnN0IHdyb25nVHlwZSA9IGNoZWNrRGF0YVR5cGVzKHR5cGVzLCBkYXRhLCBvcHRzLnN0cmljdE51bWJlcnMsIERhdGFUeXBlLldyb25nKTtcbiAgICAgICAgZ2VuLmlmKHdyb25nVHlwZSwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvZXJjZVRvLmxlbmd0aClcbiAgICAgICAgICAgICAgICBjb2VyY2VEYXRhKGl0LCB0eXBlcywgY29lcmNlVG8pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlcG9ydFR5cGVFcnJvcihpdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hlY2tUeXBlcztcbn1cbmV4cG9ydHMuY29lcmNlQW5kQ2hlY2tEYXRhVHlwZSA9IGNvZXJjZUFuZENoZWNrRGF0YVR5cGU7XG5jb25zdCBDT0VSQ0lCTEUgPSBuZXcgU2V0KFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImludGVnZXJcIiwgXCJib29sZWFuXCIsIFwibnVsbFwiXSk7XG5mdW5jdGlvbiBjb2VyY2VUb1R5cGVzKHR5cGVzLCBjb2VyY2VUeXBlcykge1xuICAgIHJldHVybiBjb2VyY2VUeXBlc1xuICAgICAgICA/IHR5cGVzLmZpbHRlcigodCkgPT4gQ09FUkNJQkxFLmhhcyh0KSB8fCAoY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIiAmJiB0ID09PSBcImFycmF5XCIpKVxuICAgICAgICA6IFtdO1xufVxuZnVuY3Rpb24gY29lcmNlRGF0YShpdCwgdHlwZXMsIGNvZXJjZVRvKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIG9wdHMgfSA9IGl0O1xuICAgIGNvbnN0IGRhdGFUeXBlID0gZ2VuLmxldChcImRhdGFUeXBlXCIsIGNvZGVnZW5fMS5fIGB0eXBlb2YgJHtkYXRhfWApO1xuICAgIGNvbnN0IGNvZXJjZWQgPSBnZW4ubGV0KFwiY29lcmNlZFwiLCBjb2RlZ2VuXzEuXyBgdW5kZWZpbmVkYCk7XG4gICAgaWYgKG9wdHMuY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIikge1xuICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7ZGF0YVR5cGV9ID09ICdvYmplY3QnICYmIEFycmF5LmlzQXJyYXkoJHtkYXRhfSkgJiYgJHtkYXRhfS5sZW5ndGggPT0gMWAsICgpID0+IGdlblxuICAgICAgICAgICAgLmFzc2lnbihkYXRhLCBjb2RlZ2VuXzEuXyBgJHtkYXRhfVswXWApXG4gICAgICAgICAgICAuYXNzaWduKGRhdGFUeXBlLCBjb2RlZ2VuXzEuXyBgdHlwZW9mICR7ZGF0YX1gKVxuICAgICAgICAgICAgLmlmKGNoZWNrRGF0YVR5cGVzKHR5cGVzLCBkYXRhLCBvcHRzLnN0cmljdE51bWJlcnMpLCAoKSA9PiBnZW4uYXNzaWduKGNvZXJjZWQsIGRhdGEpKSk7XG4gICAgfVxuICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtjb2VyY2VkfSAhPT0gdW5kZWZpbmVkYCk7XG4gICAgZm9yIChjb25zdCB0IG9mIGNvZXJjZVRvKSB7XG4gICAgICAgIGlmIChDT0VSQ0lCTEUuaGFzKHQpIHx8ICh0ID09PSBcImFycmF5XCIgJiYgb3B0cy5jb2VyY2VUeXBlcyA9PT0gXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgY29lcmNlU3BlY2lmaWNUeXBlKHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdlbi5lbHNlKCk7XG4gICAgcmVwb3J0VHlwZUVycm9yKGl0KTtcbiAgICBnZW4uZW5kSWYoKTtcbiAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7Y29lcmNlZH0gIT09IHVuZGVmaW5lZGAsICgpID0+IHtcbiAgICAgICAgZ2VuLmFzc2lnbihkYXRhLCBjb2VyY2VkKTtcbiAgICAgICAgYXNzaWduUGFyZW50RGF0YShpdCwgY29lcmNlZCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gY29lcmNlU3BlY2lmaWNUeXBlKHQpIHtcbiAgICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoY29kZWdlbl8xLl8gYCR7ZGF0YVR5cGV9ID09IFwibnVtYmVyXCIgfHwgJHtkYXRhVHlwZX0gPT0gXCJib29sZWFuXCJgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIGNvZGVnZW5fMS5fIGBcIlwiICsgJHtkYXRhfWApXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoY29kZWdlbl8xLl8gYCR7ZGF0YX0gPT09IG51bGxgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIGNvZGVnZW5fMS5fIGBcIlwiYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKGNvZGVnZW5fMS5fIGAke2RhdGFUeXBlfSA9PSBcImJvb2xlYW5cIiB8fCAke2RhdGF9ID09PSBudWxsXG4gICAgICAgICAgICAgIHx8ICgke2RhdGFUeXBlfSA9PSBcInN0cmluZ1wiICYmICR7ZGF0YX0gJiYgJHtkYXRhfSA9PSArJHtkYXRhfSlgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIGNvZGVnZW5fMS5fIGArJHtkYXRhfWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJpbnRlZ2VyXCI6XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoY29kZWdlbl8xLl8gYCR7ZGF0YVR5cGV9ID09PSBcImJvb2xlYW5cIiB8fCAke2RhdGF9ID09PSBudWxsXG4gICAgICAgICAgICAgIHx8ICgke2RhdGFUeXBlfSA9PT0gXCJzdHJpbmdcIiAmJiAke2RhdGF9ICYmICR7ZGF0YX0gPT0gKyR7ZGF0YX0gJiYgISgke2RhdGF9ICUgMSkpYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBjb2RlZ2VuXzEuXyBgKyR7ZGF0YX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKGNvZGVnZW5fMS5fIGAke2RhdGF9ID09PSBcImZhbHNlXCIgfHwgJHtkYXRhfSA9PT0gMCB8fCAke2RhdGF9ID09PSBudWxsYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZihjb2RlZ2VuXzEuXyBgJHtkYXRhfSA9PT0gXCJ0cnVlXCIgfHwgJHtkYXRhfSA9PT0gMWApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcIm51bGxcIjpcbiAgICAgICAgICAgICAgICBnZW4uZWxzZUlmKGNvZGVnZW5fMS5fIGAke2RhdGF9ID09PSBcIlwiIHx8ICR7ZGF0YX0gPT09IDAgfHwgJHtkYXRhfSA9PT0gZmFsc2VgKTtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKGNvZXJjZWQsIG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKGNvZGVnZW5fMS5fIGAke2RhdGFUeXBlfSA9PT0gXCJzdHJpbmdcIiB8fCAke2RhdGFUeXBlfSA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgICB8fCAke2RhdGFUeXBlfSA9PT0gXCJib29sZWFuXCIgfHwgJHtkYXRhfSA9PT0gbnVsbGApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgY29kZWdlbl8xLl8gYFske2RhdGF9XWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzaWduUGFyZW50RGF0YSh7IGdlbiwgcGFyZW50RGF0YSwgcGFyZW50RGF0YVByb3BlcnR5IH0sIGV4cHIpIHtcbiAgICAvLyBUT0RPIHVzZSBnZW4ucHJvcGVydHlcbiAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7cGFyZW50RGF0YX0gIT09IHVuZGVmaW5lZGAsICgpID0+IGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7cGFyZW50RGF0YX1bJHtwYXJlbnREYXRhUHJvcGVydHl9XWAsIGV4cHIpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrRGF0YVR5cGUoZGF0YVR5cGUsIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QgPSBEYXRhVHlwZS5Db3JyZWN0KSB7XG4gICAgY29uc3QgRVEgPSBjb3JyZWN0ID09PSBEYXRhVHlwZS5Db3JyZWN0ID8gY29kZWdlbl8xLm9wZXJhdG9ycy5FUSA6IGNvZGVnZW5fMS5vcGVyYXRvcnMuTkVRO1xuICAgIGxldCBjb25kO1xuICAgIHN3aXRjaCAoZGF0YVR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm51bGxcIjpcbiAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgJHtkYXRhfSAke0VRfSBudWxsYDtcbiAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICBjb25kID0gY29kZWdlbl8xLl8gYEFycmF5LmlzQXJyYXkoJHtkYXRhfSlgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIGNvbmQgPSBjb2RlZ2VuXzEuXyBgJHtkYXRhfSAmJiB0eXBlb2YgJHtkYXRhfSA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KCR7ZGF0YX0pYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW50ZWdlclwiOlxuICAgICAgICAgICAgY29uZCA9IG51bUNvbmQoY29kZWdlbl8xLl8gYCEoJHtkYXRhfSAlIDEpICYmICFpc05hTigke2RhdGF9KWApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGNvbmQgPSBudW1Db25kKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgdHlwZW9mICR7ZGF0YX0gJHtFUX0gJHtkYXRhVHlwZX1gO1xuICAgIH1cbiAgICByZXR1cm4gY29ycmVjdCA9PT0gRGF0YVR5cGUuQ29ycmVjdCA/IGNvbmQgOiBjb2RlZ2VuXzEubm90KGNvbmQpO1xuICAgIGZ1bmN0aW9uIG51bUNvbmQoX2NvbmQgPSBjb2RlZ2VuXzEubmlsKSB7XG4gICAgICAgIHJldHVybiBjb2RlZ2VuXzEuYW5kKGNvZGVnZW5fMS5fIGB0eXBlb2YgJHtkYXRhfSA9PSBcIm51bWJlclwiYCwgX2NvbmQsIHN0cmljdE51bXMgPyBjb2RlZ2VuXzEuXyBgaXNGaW5pdGUoJHtkYXRhfSlgIDogY29kZWdlbl8xLm5pbCk7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja0RhdGFUeXBlID0gY2hlY2tEYXRhVHlwZTtcbmZ1bmN0aW9uIGNoZWNrRGF0YVR5cGVzKGRhdGFUeXBlcywgZGF0YSwgc3RyaWN0TnVtcywgY29ycmVjdCkge1xuICAgIGlmIChkYXRhVHlwZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBjaGVja0RhdGFUeXBlKGRhdGFUeXBlc1swXSwgZGF0YSwgc3RyaWN0TnVtcywgY29ycmVjdCk7XG4gICAgfVxuICAgIGxldCBjb25kO1xuICAgIGNvbnN0IHR5cGVzID0gdXRpbF8xLnRvSGFzaChkYXRhVHlwZXMpO1xuICAgIGlmICh0eXBlcy5hcnJheSAmJiB0eXBlcy5vYmplY3QpIHtcbiAgICAgICAgY29uc3Qgbm90T2JqID0gY29kZWdlbl8xLl8gYHR5cGVvZiAke2RhdGF9ICE9IFwib2JqZWN0XCJgO1xuICAgICAgICBjb25kID0gdHlwZXMubnVsbCA/IG5vdE9iaiA6IGNvZGVnZW5fMS5fIGAhJHtkYXRhfSB8fCAke25vdE9ian1gO1xuICAgICAgICBkZWxldGUgdHlwZXMubnVsbDtcbiAgICAgICAgZGVsZXRlIHR5cGVzLmFycmF5O1xuICAgICAgICBkZWxldGUgdHlwZXMub2JqZWN0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uZCA9IGNvZGVnZW5fMS5uaWw7XG4gICAgfVxuICAgIGlmICh0eXBlcy5udW1iZXIpXG4gICAgICAgIGRlbGV0ZSB0eXBlcy5pbnRlZ2VyO1xuICAgIGZvciAoY29uc3QgdCBpbiB0eXBlcylcbiAgICAgICAgY29uZCA9IGNvZGVnZW5fMS5hbmQoY29uZCwgY2hlY2tEYXRhVHlwZSh0LCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0KSk7XG4gICAgcmV0dXJuIGNvbmQ7XG59XG5leHBvcnRzLmNoZWNrRGF0YVR5cGVzID0gY2hlY2tEYXRhVHlwZXM7XG5jb25zdCB0eXBlRXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgc2NoZW1hIH0pID0+IGBtdXN0IGJlICR7c2NoZW1hfWAsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWEsIHNjaGVtYVZhbHVlIH0pID0+IHR5cGVvZiBzY2hlbWEgPT0gXCJzdHJpbmdcIiA/IGNvZGVnZW5fMS5fIGB7dHlwZTogJHtzY2hlbWF9fWAgOiBjb2RlZ2VuXzEuXyBge3R5cGU6ICR7c2NoZW1hVmFsdWV9fWAsXG59O1xuZnVuY3Rpb24gcmVwb3J0VHlwZUVycm9yKGl0KSB7XG4gICAgY29uc3QgY3h0ID0gZ2V0VHlwZUVycm9yQ29udGV4dChpdCk7XG4gICAgZXJyb3JzXzEucmVwb3J0RXJyb3IoY3h0LCB0eXBlRXJyb3IpO1xufVxuZXhwb3J0cy5yZXBvcnRUeXBlRXJyb3IgPSByZXBvcnRUeXBlRXJyb3I7XG5mdW5jdGlvbiBnZXRUeXBlRXJyb3JDb250ZXh0KGl0KSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIHNjaGVtYSB9ID0gaXQ7XG4gICAgY29uc3Qgc2NoZW1hQ29kZSA9IHV0aWxfMS5zY2hlbWFSZWZPclZhbChpdCwgc2NoZW1hLCBcInR5cGVcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2VuLFxuICAgICAgICBrZXl3b3JkOiBcInR5cGVcIixcbiAgICAgICAgZGF0YSxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWEudHlwZSxcbiAgICAgICAgc2NoZW1hQ29kZSxcbiAgICAgICAgc2NoZW1hVmFsdWU6IHNjaGVtYUNvZGUsXG4gICAgICAgIHBhcmVudFNjaGVtYTogc2NoZW1hLFxuICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICBpdCxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YVR5cGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzc2lnbkRlZmF1bHRzID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmZ1bmN0aW9uIGFzc2lnbkRlZmF1bHRzKGl0LCB0eSkge1xuICAgIGNvbnN0IHsgcHJvcGVydGllcywgaXRlbXMgfSA9IGl0LnNjaGVtYTtcbiAgICBpZiAodHkgPT09IFwib2JqZWN0XCIgJiYgcHJvcGVydGllcykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBhc3NpZ25EZWZhdWx0KGl0LCBrZXksIHByb3BlcnRpZXNba2V5XS5kZWZhdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eSA9PT0gXCJhcnJheVwiICYmIEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgIGl0ZW1zLmZvckVhY2goKHNjaCwgaSkgPT4gYXNzaWduRGVmYXVsdChpdCwgaSwgc2NoLmRlZmF1bHQpKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2lnbkRlZmF1bHRzID0gYXNzaWduRGVmYXVsdHM7XG5mdW5jdGlvbiBhc3NpZ25EZWZhdWx0KGl0LCBwcm9wLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBjb25zdCB7IGdlbiwgY29tcG9zaXRlUnVsZSwgZGF0YSwgb3B0cyB9ID0gaXQ7XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgY2hpbGREYXRhID0gY29kZWdlbl8xLl8gYCR7ZGF0YX0ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eShwcm9wKX1gO1xuICAgIGlmIChjb21wb3NpdGVSdWxlKSB7XG4gICAgICAgIHV0aWxfMS5jaGVja1N0cmljdE1vZGUoaXQsIGBkZWZhdWx0IGlzIGlnbm9yZWQgZm9yOiAke2NoaWxkRGF0YX1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY29uZGl0aW9uID0gY29kZWdlbl8xLl8gYCR7Y2hpbGREYXRhfSA9PT0gdW5kZWZpbmVkYDtcbiAgICBpZiAob3B0cy51c2VEZWZhdWx0cyA9PT0gXCJlbXB0eVwiKSB7XG4gICAgICAgIGNvbmRpdGlvbiA9IGNvZGVnZW5fMS5fIGAke2NvbmRpdGlvbn0gfHwgJHtjaGlsZERhdGF9ID09PSBudWxsIHx8ICR7Y2hpbGREYXRhfSA9PT0gXCJcImA7XG4gICAgfVxuICAgIC8vIGAke2NoaWxkRGF0YX0gPT09IHVuZGVmaW5lZGAgK1xuICAgIC8vIChvcHRzLnVzZURlZmF1bHRzID09PSBcImVtcHR5XCIgPyBgIHx8ICR7Y2hpbGREYXRhfSA9PT0gbnVsbCB8fCAke2NoaWxkRGF0YX0gPT09IFwiXCJgIDogXCJcIilcbiAgICBnZW4uaWYoY29uZGl0aW9uLCBjb2RlZ2VuXzEuXyBgJHtjaGlsZERhdGF9ID0gJHtjb2RlZ2VuXzEuc3RyaW5naWZ5KGRlZmF1bHRWYWx1ZSl9YCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVVbmlvbiA9IGV4cG9ydHMudmFsaWRhdGVBcnJheSA9IGV4cG9ydHMudXNlUGF0dGVybiA9IGV4cG9ydHMuY2FsbFZhbGlkYXRlQ29kZSA9IGV4cG9ydHMuc2NoZW1hUHJvcGVydGllcyA9IGV4cG9ydHMuYWxsU2NoZW1hUHJvcGVydGllcyA9IGV4cG9ydHMubm9Qcm9wZXJ0eUluRGF0YSA9IGV4cG9ydHMucHJvcGVydHlJbkRhdGEgPSBleHBvcnRzLmlzT3duUHJvcGVydHkgPSBleHBvcnRzLmhhc1Byb3BGdW5jID0gZXhwb3J0cy5yZXBvcnRNaXNzaW5nUHJvcCA9IGV4cG9ydHMuY2hlY2tNaXNzaW5nUHJvcCA9IGV4cG9ydHMuY2hlY2tSZXBvcnRNaXNzaW5nUHJvcCA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21waWxlL25hbWVzXCIpO1xuZnVuY3Rpb24gY2hlY2tSZXBvcnRNaXNzaW5nUHJvcChjeHQsIHByb3ApIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICBnZW4uaWYobm9Qcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3AsIGl0Lm9wdHMub3duUHJvcGVydGllcyksICgpID0+IHtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7IG1pc3NpbmdQcm9wZXJ0eTogY29kZWdlbl8xLl8gYCR7cHJvcH1gIH0sIHRydWUpO1xuICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY2hlY2tSZXBvcnRNaXNzaW5nUHJvcCA9IGNoZWNrUmVwb3J0TWlzc2luZ1Byb3A7XG5mdW5jdGlvbiBjaGVja01pc3NpbmdQcm9wKHsgZ2VuLCBkYXRhLCBpdDogeyBvcHRzIH0gfSwgcHJvcGVydGllcywgbWlzc2luZykge1xuICAgIHJldHVybiBjb2RlZ2VuXzEub3IoLi4ucHJvcGVydGllcy5tYXAoKHByb3ApID0+IGNvZGVnZW5fMS5hbmQobm9Qcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3AsIG9wdHMub3duUHJvcGVydGllcyksIGNvZGVnZW5fMS5fIGAke21pc3Npbmd9ID0gJHtwcm9wfWApKSk7XG59XG5leHBvcnRzLmNoZWNrTWlzc2luZ1Byb3AgPSBjaGVja01pc3NpbmdQcm9wO1xuZnVuY3Rpb24gcmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBtaXNzaW5nKSB7XG4gICAgY3h0LnNldFBhcmFtcyh7IG1pc3NpbmdQcm9wZXJ0eTogbWlzc2luZyB9LCB0cnVlKTtcbiAgICBjeHQuZXJyb3IoKTtcbn1cbmV4cG9ydHMucmVwb3J0TWlzc2luZ1Byb3AgPSByZXBvcnRNaXNzaW5nUHJvcDtcbmZ1bmN0aW9uIGhhc1Byb3BGdW5jKGdlbikge1xuICAgIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcImZ1bmNcIiwge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICAgIHJlZjogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICAgY29kZTogY29kZWdlbl8xLl8gYE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlgLFxuICAgIH0pO1xufVxuZXhwb3J0cy5oYXNQcm9wRnVuYyA9IGhhc1Byb3BGdW5jO1xuZnVuY3Rpb24gaXNPd25Qcm9wZXJ0eShnZW4sIGRhdGEsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIGNvZGVnZW5fMS5fIGAke2hhc1Byb3BGdW5jKGdlbil9LmNhbGwoJHtkYXRhfSwgJHtwcm9wZXJ0eX0pYDtcbn1cbmV4cG9ydHMuaXNPd25Qcm9wZXJ0eSA9IGlzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBwcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3BlcnR5LCBvd25Qcm9wZXJ0aWVzKSB7XG4gICAgY29uc3QgY29uZCA9IGNvZGVnZW5fMS5fIGAke2RhdGF9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkocHJvcGVydHkpfSAhPT0gdW5kZWZpbmVkYDtcbiAgICByZXR1cm4gb3duUHJvcGVydGllcyA/IGNvZGVnZW5fMS5fIGAke2NvbmR9ICYmICR7aXNPd25Qcm9wZXJ0eShnZW4sIGRhdGEsIHByb3BlcnR5KX1gIDogY29uZDtcbn1cbmV4cG9ydHMucHJvcGVydHlJbkRhdGEgPSBwcm9wZXJ0eUluRGF0YTtcbmZ1bmN0aW9uIG5vUHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wZXJ0eSwgb3duUHJvcGVydGllcykge1xuICAgIGNvbnN0IGNvbmQgPSBjb2RlZ2VuXzEuXyBgJHtkYXRhfSR7Y29kZWdlbl8xLmdldFByb3BlcnR5KHByb3BlcnR5KX0gPT09IHVuZGVmaW5lZGA7XG4gICAgcmV0dXJuIG93blByb3BlcnRpZXMgPyBjb2RlZ2VuXzEub3IoY29uZCwgY29kZWdlbl8xLm5vdChpc093blByb3BlcnR5KGdlbiwgZGF0YSwgcHJvcGVydHkpKSkgOiBjb25kO1xufVxuZXhwb3J0cy5ub1Byb3BlcnR5SW5EYXRhID0gbm9Qcm9wZXJ0eUluRGF0YTtcbmZ1bmN0aW9uIGFsbFNjaGVtYVByb3BlcnRpZXMoc2NoZW1hTWFwKSB7XG4gICAgcmV0dXJuIHNjaGVtYU1hcCA/IE9iamVjdC5rZXlzKHNjaGVtYU1hcCkuZmlsdGVyKChwKSA9PiBwICE9PSBcIl9fcHJvdG9fX1wiKSA6IFtdO1xufVxuZXhwb3J0cy5hbGxTY2hlbWFQcm9wZXJ0aWVzID0gYWxsU2NoZW1hUHJvcGVydGllcztcbmZ1bmN0aW9uIHNjaGVtYVByb3BlcnRpZXMoaXQsIHNjaGVtYU1hcCkge1xuICAgIHJldHVybiBhbGxTY2hlbWFQcm9wZXJ0aWVzKHNjaGVtYU1hcCkuZmlsdGVyKChwKSA9PiAhdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWFNYXBbcF0pKTtcbn1cbmV4cG9ydHMuc2NoZW1hUHJvcGVydGllcyA9IHNjaGVtYVByb3BlcnRpZXM7XG5mdW5jdGlvbiBjYWxsVmFsaWRhdGVDb2RlKHsgc2NoZW1hQ29kZSwgZGF0YSwgaXQ6IHsgZ2VuLCB0b3BTY2hlbWFSZWYsIHNjaGVtYVBhdGgsIGVycm9yUGF0aCB9LCBpdCB9LCBmdW5jLCBjb250ZXh0LCBwYXNzU2NoZW1hKSB7XG4gICAgY29uc3QgZGF0YUFuZFNjaGVtYSA9IHBhc3NTY2hlbWEgPyBjb2RlZ2VuXzEuXyBgJHtzY2hlbWFDb2RlfSwgJHtkYXRhfSwgJHt0b3BTY2hlbWFSZWZ9JHtzY2hlbWFQYXRofWAgOiBkYXRhO1xuICAgIGNvbnN0IHZhbEN4dCA9IFtcbiAgICAgICAgW25hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsIGNvZGVnZW5fMS5zdHJDb25jYXQobmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgZXJyb3JQYXRoKV0sXG4gICAgICAgIFtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YSwgaXQucGFyZW50RGF0YV0sXG4gICAgICAgIFtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5LCBpdC5wYXJlbnREYXRhUHJvcGVydHldLFxuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhLCBuYW1lc18xLmRlZmF1bHQucm9vdERhdGFdLFxuICAgIF07XG4gICAgaWYgKGl0Lm9wdHMuZHluYW1pY1JlZilcbiAgICAgICAgdmFsQ3h0LnB1c2goW25hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9ycywgbmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzXSk7XG4gICAgY29uc3QgYXJncyA9IGNvZGVnZW5fMS5fIGAke2RhdGFBbmRTY2hlbWF9LCAke2dlbi5vYmplY3QoLi4udmFsQ3h0KX1gO1xuICAgIHJldHVybiBjb250ZXh0ICE9PSBjb2RlZ2VuXzEubmlsID8gY29kZWdlbl8xLl8gYCR7ZnVuY30uY2FsbCgke2NvbnRleHR9LCAke2FyZ3N9KWAgOiBjb2RlZ2VuXzEuXyBgJHtmdW5jfSgke2FyZ3N9KWA7XG59XG5leHBvcnRzLmNhbGxWYWxpZGF0ZUNvZGUgPSBjYWxsVmFsaWRhdGVDb2RlO1xuZnVuY3Rpb24gdXNlUGF0dGVybih7IGdlbiwgaXQ6IHsgb3B0cyB9IH0sIHBhdHRlcm4pIHtcbiAgICBjb25zdCB1ID0gb3B0cy51bmljb2RlUmVnRXhwID8gXCJ1XCIgOiBcIlwiO1xuICAgIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcInBhdHRlcm5cIiwge1xuICAgICAgICBrZXk6IHBhdHRlcm4sXG4gICAgICAgIHJlZjogbmV3IFJlZ0V4cChwYXR0ZXJuLCB1KSxcbiAgICAgICAgY29kZTogY29kZWdlbl8xLl8gYG5ldyBSZWdFeHAoJHtwYXR0ZXJufSwgJHt1fSlgLFxuICAgIH0pO1xufVxuZXhwb3J0cy51c2VQYXR0ZXJuID0gdXNlUGF0dGVybjtcbmZ1bmN0aW9uIHZhbGlkYXRlQXJyYXkoY3h0KSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGlmIChpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRBcnIgPSBnZW4ubGV0KFwidmFsaWRcIiwgdHJ1ZSk7XG4gICAgICAgIHZhbGlkYXRlSXRlbXMoKCkgPT4gZ2VuLmFzc2lnbih2YWxpZEFyciwgZmFsc2UpKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkQXJyO1xuICAgIH1cbiAgICBnZW4udmFyKHZhbGlkLCB0cnVlKTtcbiAgICB2YWxpZGF0ZUl0ZW1zKCgpID0+IGdlbi5icmVhaygpKTtcbiAgICByZXR1cm4gdmFsaWQ7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyhub3RWYWxpZCkge1xuICAgICAgICBjb25zdCBsZW4gPSBnZW4uY29uc3QoXCJsZW5cIiwgY29kZWdlbl8xLl8gYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgICAgIGdlbi5mb3JSYW5nZShcImlcIiwgMCwgbGVuLCAoaSkgPT4ge1xuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcDogaSxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IHV0aWxfMS5UeXBlLk51bSxcbiAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEubm90KHZhbGlkKSwgbm90VmFsaWQpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlQXJyYXkgPSB2YWxpZGF0ZUFycmF5O1xuZnVuY3Rpb24gdmFsaWRhdGVVbmlvbihjeHQpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgY29uc3QgYWx3YXlzVmFsaWQgPSBzY2hlbWEuc29tZSgoc2NoKSA9PiB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaCkpO1xuICAgIGlmIChhbHdheXNWYWxpZCAmJiAhaXQub3B0cy51bmV2YWx1YXRlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIGZhbHNlKTtcbiAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgIGdlbi5ibG9jaygoKSA9PiBzY2hlbWEuZm9yRWFjaCgoX3NjaCwgaSkgPT4ge1xuICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgfSwgc2NoVmFsaWQpO1xuICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBjb2RlZ2VuXzEuXyBgJHt2YWxpZH0gfHwgJHtzY2hWYWxpZH1gKTtcbiAgICAgICAgY29uc3QgbWVyZ2VkID0gY3h0Lm1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoQ3h0LCBzY2hWYWxpZCk7XG4gICAgICAgIC8vIGNhbiBzaG9ydC1jaXJjdWl0IGlmIGB1bmV2YWx1YXRlZFByb3BlcnRpZXMvSXRlbXNgIG5vdCBzdXBwb3J0ZWQgKG9wdHMudW5ldmFsdWF0ZWQgIT09IHRydWUpXG4gICAgICAgIC8vIG9yIGlmIGFsbCBwcm9wZXJ0aWVzIGFuZCBpdGVtcyB3ZXJlIGV2YWx1YXRlZCAoaXQucHJvcHMgPT09IHRydWUgJiYgaXQuaXRlbXMgPT09IHRydWUpXG4gICAgICAgIGlmICghbWVyZ2VkKVxuICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5ub3QodmFsaWQpKTtcbiAgICB9KSk7XG4gICAgY3h0LnJlc3VsdCh2YWxpZCwgKCkgPT4gY3h0LnJlc2V0KCksICgpID0+IGN4dC5lcnJvcih0cnVlKSk7XG59XG5leHBvcnRzLnZhbGlkYXRlVW5pb24gPSB2YWxpZGF0ZVVuaW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVLZXl3b3JkVXNhZ2UgPSBleHBvcnRzLnZhbGlkU2NoZW1hVHlwZSA9IGV4cG9ydHMuZnVuY0tleXdvcmRDb2RlID0gZXhwb3J0cy5tYWNyb0tleXdvcmRDb2RlID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uL25hbWVzXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uLy4uL3ZvY2FidWxhcmllcy9jb2RlXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuZnVuY3Rpb24gbWFjcm9LZXl3b3JkQ29kZShjeHQsIGRlZikge1xuICAgIGNvbnN0IHsgZ2VuLCBrZXl3b3JkLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCBtYWNyb1NjaGVtYSA9IGRlZi5tYWNyby5jYWxsKGl0LnNlbGYsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCk7XG4gICAgY29uc3Qgc2NoZW1hUmVmID0gdXNlS2V5d29yZChnZW4sIGtleXdvcmQsIG1hY3JvU2NoZW1hKTtcbiAgICBpZiAoaXQub3B0cy52YWxpZGF0ZVNjaGVtYSAhPT0gZmFsc2UpXG4gICAgICAgIGl0LnNlbGYudmFsaWRhdGVTY2hlbWEobWFjcm9TY2hlbWEsIHRydWUpO1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgc2NoZW1hOiBtYWNyb1NjaGVtYSxcbiAgICAgICAgc2NoZW1hUGF0aDogY29kZWdlbl8xLm5pbCxcbiAgICAgICAgZXJyU2NoZW1hUGF0aDogYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWAsXG4gICAgICAgIHRvcFNjaGVtYVJlZjogc2NoZW1hUmVmLFxuICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgIH0sIHZhbGlkKTtcbiAgICBjeHQucGFzcyh2YWxpZCwgKCkgPT4gY3h0LmVycm9yKHRydWUpKTtcbn1cbmV4cG9ydHMubWFjcm9LZXl3b3JkQ29kZSA9IG1hY3JvS2V5d29yZENvZGU7XG5mdW5jdGlvbiBmdW5jS2V5d29yZENvZGUoY3h0LCBkZWYpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBnZW4sIGtleXdvcmQsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCAkZGF0YSwgaXQgfSA9IGN4dDtcbiAgICBjaGVja0FzeW5jS2V5d29yZChpdCwgZGVmKTtcbiAgICBjb25zdCB2YWxpZGF0ZSA9ICEkZGF0YSAmJiBkZWYuY29tcGlsZSA/IGRlZi5jb21waWxlLmNhbGwoaXQuc2VsZiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0KSA6IGRlZi52YWxpZGF0ZTtcbiAgICBjb25zdCB2YWxpZGF0ZVJlZiA9IHVzZUtleXdvcmQoZ2VuLCBrZXl3b3JkLCB2YWxpZGF0ZSk7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIik7XG4gICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsIHZhbGlkYXRlS2V5d29yZCk7XG4gICAgY3h0Lm9rKChfYSA9IGRlZi52YWxpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFsaWQpO1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlS2V5d29yZCgpIHtcbiAgICAgICAgaWYgKGRlZi5lcnJvcnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBhc3NpZ25WYWxpZCgpO1xuICAgICAgICAgICAgaWYgKGRlZi5tb2RpZnlpbmcpXG4gICAgICAgICAgICAgICAgbW9kaWZ5RGF0YShjeHQpO1xuICAgICAgICAgICAgcmVwb3J0RXJycygoKSA9PiBjeHQuZXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBydWxlRXJycyA9IGRlZi5hc3luYyA/IHZhbGlkYXRlQXN5bmMoKSA6IHZhbGlkYXRlU3luYygpO1xuICAgICAgICAgICAgaWYgKGRlZi5tb2RpZnlpbmcpXG4gICAgICAgICAgICAgICAgbW9kaWZ5RGF0YShjeHQpO1xuICAgICAgICAgICAgcmVwb3J0RXJycygoKSA9PiBhZGRFcnJzKGN4dCwgcnVsZUVycnMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUFzeW5jKCkge1xuICAgICAgICBjb25zdCBydWxlRXJycyA9IGdlbi5sZXQoXCJydWxlRXJyc1wiLCBudWxsKTtcbiAgICAgICAgZ2VuLnRyeSgoKSA9PiBhc3NpZ25WYWxpZChjb2RlZ2VuXzEuXyBgYXdhaXQgYCksIChlKSA9PiBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuaWYoY29kZWdlbl8xLl8gYCR7ZX0gaW5zdGFuY2VvZiAke2l0LlZhbGlkYXRpb25FcnJvcn1gLCAoKSA9PiBnZW4uYXNzaWduKHJ1bGVFcnJzLCBjb2RlZ2VuXzEuXyBgJHtlfS5lcnJvcnNgKSwgKCkgPT4gZ2VuLnRocm93KGUpKSk7XG4gICAgICAgIHJldHVybiBydWxlRXJycztcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVTeW5jKCkge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZUVycnMgPSBjb2RlZ2VuXzEuXyBgJHt2YWxpZGF0ZVJlZn0uZXJyb3JzYDtcbiAgICAgICAgZ2VuLmFzc2lnbih2YWxpZGF0ZUVycnMsIG51bGwpO1xuICAgICAgICBhc3NpZ25WYWxpZChjb2RlZ2VuXzEubmlsKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlRXJycztcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzaWduVmFsaWQoX2F3YWl0ID0gZGVmLmFzeW5jID8gY29kZWdlbl8xLl8gYGF3YWl0IGAgOiBjb2RlZ2VuXzEubmlsKSB7XG4gICAgICAgIGNvbnN0IHBhc3NDeHQgPSBpdC5vcHRzLnBhc3NDb250ZXh0ID8gbmFtZXNfMS5kZWZhdWx0LnRoaXMgOiBuYW1lc18xLmRlZmF1bHQuc2VsZjtcbiAgICAgICAgY29uc3QgcGFzc1NjaGVtYSA9ICEoKFwiY29tcGlsZVwiIGluIGRlZiAmJiAhJGRhdGEpIHx8IGRlZi5zY2hlbWEgPT09IGZhbHNlKTtcbiAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgY29kZWdlbl8xLl8gYCR7X2F3YWl0fSR7Y29kZV8xLmNhbGxWYWxpZGF0ZUNvZGUoY3h0LCB2YWxpZGF0ZVJlZiwgcGFzc0N4dCwgcGFzc1NjaGVtYSl9YCwgZGVmLm1vZGlmeWluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcG9ydEVycnMoZXJyb3JzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5ub3QoKF9hID0gZGVmLnZhbGlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2YWxpZCksIGVycm9ycyk7XG4gICAgfVxufVxuZXhwb3J0cy5mdW5jS2V5d29yZENvZGUgPSBmdW5jS2V5d29yZENvZGU7XG5mdW5jdGlvbiBtb2RpZnlEYXRhKGN4dCkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgIGdlbi5pZihpdC5wYXJlbnREYXRhLCAoKSA9PiBnZW4uYXNzaWduKGRhdGEsIGNvZGVnZW5fMS5fIGAke2l0LnBhcmVudERhdGF9WyR7aXQucGFyZW50RGF0YVByb3BlcnR5fV1gKSk7XG59XG5mdW5jdGlvbiBhZGRFcnJzKGN4dCwgZXJycykge1xuICAgIGNvbnN0IHsgZ2VuIH0gPSBjeHQ7XG4gICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGBBcnJheS5pc0FycmF5KCR7ZXJyc30pYCwgKCkgPT4ge1xuICAgICAgICBnZW5cbiAgICAgICAgICAgIC5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfSA9PT0gbnVsbCA/ICR7ZXJyc30gOiAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5jb25jYXQoJHtlcnJzfSlgKVxuICAgICAgICAgICAgLmFzc2lnbihuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30ubGVuZ3RoYCk7XG4gICAgICAgIGVycm9yc18xLmV4dGVuZEVycm9ycyhjeHQpO1xuICAgIH0sICgpID0+IGN4dC5lcnJvcigpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrQXN5bmNLZXl3b3JkKHsgc2NoZW1hRW52IH0sIGRlZikge1xuICAgIGlmIChkZWYuYXN5bmMgJiYgIXNjaGVtYUVudi4kYXN5bmMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIGtleXdvcmQgaW4gc3luYyBzY2hlbWFcIik7XG59XG5mdW5jdGlvbiB1c2VLZXl3b3JkKGdlbiwga2V5d29yZCwgcmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGtleXdvcmQgXCIke2tleXdvcmR9XCIgZmFpbGVkIHRvIGNvbXBpbGVgKTtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJrZXl3b3JkXCIsIHR5cGVvZiByZXN1bHQgPT0gXCJmdW5jdGlvblwiID8geyByZWY6IHJlc3VsdCB9IDogeyByZWY6IHJlc3VsdCwgY29kZTogY29kZWdlbl8xLnN0cmluZ2lmeShyZXN1bHQpIH0pO1xufVxuZnVuY3Rpb24gdmFsaWRTY2hlbWFUeXBlKHNjaGVtYSwgc2NoZW1hVHlwZSwgYWxsb3dVbmRlZmluZWQgPSBmYWxzZSkge1xuICAgIC8vIFRPRE8gYWRkIHRlc3RzXG4gICAgcmV0dXJuICghc2NoZW1hVHlwZS5sZW5ndGggfHxcbiAgICAgICAgc2NoZW1hVHlwZS5zb21lKChzdCkgPT4gc3QgPT09IFwiYXJyYXlcIlxuICAgICAgICAgICAgPyBBcnJheS5pc0FycmF5KHNjaGVtYSlcbiAgICAgICAgICAgIDogc3QgPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgICAgICA/IHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoc2NoZW1hKVxuICAgICAgICAgICAgICAgIDogdHlwZW9mIHNjaGVtYSA9PSBzdCB8fCAoYWxsb3dVbmRlZmluZWQgJiYgdHlwZW9mIHNjaGVtYSA9PSBcInVuZGVmaW5lZFwiKSkpO1xufVxuZXhwb3J0cy52YWxpZFNjaGVtYVR5cGUgPSB2YWxpZFNjaGVtYVR5cGU7XG5mdW5jdGlvbiB2YWxpZGF0ZUtleXdvcmRVc2FnZSh7IHNjaGVtYSwgb3B0cywgc2VsZiwgZXJyU2NoZW1hUGF0aCB9LCBkZWYsIGtleXdvcmQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZWYua2V5d29yZCkgPyAhZGVmLmtleXdvcmQuaW5jbHVkZXMoa2V5d29yZCkgOiBkZWYua2V5d29yZCAhPT0ga2V5d29yZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgfVxuICAgIGNvbnN0IGRlcHMgPSBkZWYuZGVwZW5kZW5jaWVzO1xuICAgIGlmIChkZXBzID09PSBudWxsIHx8IGRlcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlcHMuc29tZSgoa3dkKSA9PiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNjaGVtYSwga3dkKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXJlbnQgc2NoZW1hIG11c3QgaGF2ZSBkZXBlbmRlbmNpZXMgb2YgJHtrZXl3b3JkfTogJHtkZXBzLmpvaW4oXCIsXCIpfWApO1xuICAgIH1cbiAgICBpZiAoZGVmLnZhbGlkYXRlU2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZGVmLnZhbGlkYXRlU2NoZW1hKHNjaGVtYVtrZXl3b3JkXSk7XG4gICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBrZXl3b3JkIFwiJHtrZXl3b3JkfVwiIHZhbHVlIGlzIGludmFsaWQgYXQgcGF0aCBcIiR7ZXJyU2NoZW1hUGF0aH1cIjogYCArXG4gICAgICAgICAgICAgICAgc2VsZi5lcnJvcnNUZXh0KGRlZi52YWxpZGF0ZVNjaGVtYS5lcnJvcnMpO1xuICAgICAgICAgICAgaWYgKG9wdHMudmFsaWRhdGVTY2hlbWEgPT09IFwibG9nXCIpXG4gICAgICAgICAgICAgICAgc2VsZi5sb2dnZXIuZXJyb3IobXNnKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVLZXl3b3JkVXNhZ2UgPSB2YWxpZGF0ZUtleXdvcmRVc2FnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleXdvcmQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4dGVuZFN1YnNjaGVtYU1vZGUgPSBleHBvcnRzLmV4dGVuZFN1YnNjaGVtYURhdGEgPSBleHBvcnRzLmdldFN1YnNjaGVtYSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5mdW5jdGlvbiBnZXRTdWJzY2hlbWEoaXQsIHsga2V5d29yZCwgc2NoZW1hUHJvcCwgc2NoZW1hLCBzY2hlbWFQYXRoLCBlcnJTY2hlbWFQYXRoLCB0b3BTY2hlbWFSZWYgfSkge1xuICAgIGlmIChrZXl3b3JkICE9PSB1bmRlZmluZWQgJiYgc2NoZW1hICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdib3RoIFwia2V5d29yZFwiIGFuZCBcInNjaGVtYVwiIHBhc3NlZCwgb25seSBvbmUgYWxsb3dlZCcpO1xuICAgIH1cbiAgICBpZiAoa2V5d29yZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHNjaCA9IGl0LnNjaGVtYVtrZXl3b3JkXTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYVByb3AgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBzY2gsXG4gICAgICAgICAgICAgICAgc2NoZW1hUGF0aDogY29kZWdlbl8xLl8gYCR7aXQuc2NoZW1hUGF0aH0ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eShrZXl3b3JkKX1gLFxuICAgICAgICAgICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBzY2hbc2NoZW1hUHJvcF0sXG4gICAgICAgICAgICAgICAgc2NoZW1hUGF0aDogY29kZWdlbl8xLl8gYCR7aXQuc2NoZW1hUGF0aH0ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eShrZXl3b3JkKX0ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eShzY2hlbWFQcm9wKX1gLFxuICAgICAgICAgICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH0vJHt1dGlsXzEuZXNjYXBlRnJhZ21lbnQoc2NoZW1hUHJvcCl9YCxcbiAgICAgICAgICAgIH07XG4gICAgfVxuICAgIGlmIChzY2hlbWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoc2NoZW1hUGF0aCA9PT0gdW5kZWZpbmVkIHx8IGVyclNjaGVtYVBhdGggPT09IHVuZGVmaW5lZCB8fCB0b3BTY2hlbWFSZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInNjaGVtYVBhdGhcIiwgXCJlcnJTY2hlbWFQYXRoXCIgYW5kIFwidG9wU2NoZW1hUmVmXCIgYXJlIHJlcXVpcmVkIHdpdGggXCJzY2hlbWFcIicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICBzY2hlbWFQYXRoLFxuICAgICAgICAgICAgdG9wU2NoZW1hUmVmLFxuICAgICAgICAgICAgZXJyU2NoZW1hUGF0aCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdlaXRoZXIgXCJrZXl3b3JkXCIgb3IgXCJzY2hlbWFcIiBtdXN0IGJlIHBhc3NlZCcpO1xufVxuZXhwb3J0cy5nZXRTdWJzY2hlbWEgPSBnZXRTdWJzY2hlbWE7XG5mdW5jdGlvbiBleHRlbmRTdWJzY2hlbWFEYXRhKHN1YnNjaGVtYSwgaXQsIHsgZGF0YVByb3AsIGRhdGFQcm9wVHlwZTogZHBUeXBlLCBkYXRhLCBkYXRhVHlwZXMsIHByb3BlcnR5TmFtZSB9KSB7XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCAmJiBkYXRhUHJvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYm90aCBcImRhdGFcIiBhbmQgXCJkYXRhUHJvcFwiIHBhc3NlZCwgb25seSBvbmUgYWxsb3dlZCcpO1xuICAgIH1cbiAgICBjb25zdCB7IGdlbiB9ID0gaXQ7XG4gICAgaWYgKGRhdGFQcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgeyBlcnJvclBhdGgsIGRhdGFQYXRoQXJyLCBvcHRzIH0gPSBpdDtcbiAgICAgICAgY29uc3QgbmV4dERhdGEgPSBnZW4ubGV0KFwiZGF0YVwiLCBjb2RlZ2VuXzEuXyBgJHtpdC5kYXRhfSR7Y29kZWdlbl8xLmdldFByb3BlcnR5KGRhdGFQcm9wKX1gLCB0cnVlKTtcbiAgICAgICAgZGF0YUNvbnRleHRQcm9wcyhuZXh0RGF0YSk7XG4gICAgICAgIHN1YnNjaGVtYS5lcnJvclBhdGggPSBjb2RlZ2VuXzEuc3RyIGAke2Vycm9yUGF0aH0ke3V0aWxfMS5nZXRFcnJvclBhdGgoZGF0YVByb3AsIGRwVHlwZSwgb3B0cy5qc1Byb3BlcnR5U3ludGF4KX1gO1xuICAgICAgICBzdWJzY2hlbWEucGFyZW50RGF0YVByb3BlcnR5ID0gY29kZWdlbl8xLl8gYCR7ZGF0YVByb3B9YDtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFQYXRoQXJyID0gWy4uLmRhdGFQYXRoQXJyLCBzdWJzY2hlbWEucGFyZW50RGF0YVByb3BlcnR5XTtcbiAgICB9XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBuZXh0RGF0YSA9IGRhdGEgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSA/IGRhdGEgOiBnZW4ubGV0KFwiZGF0YVwiLCBkYXRhLCB0cnVlKTsgLy8gcmVwbGFjZWFibGUgaWYgdXNlZCBvbmNlP1xuICAgICAgICBkYXRhQ29udGV4dFByb3BzKG5leHREYXRhKTtcbiAgICAgICAgaWYgKHByb3BlcnR5TmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgc3Vic2NoZW1hLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcbiAgICAgICAgLy8gVE9ETyBzb21ldGhpbmcgaXMgcG9zc2libHkgd3JvbmcgaGVyZSB3aXRoIG5vdCBjaGFuZ2luZyBwYXJlbnREYXRhUHJvcGVydHkgYW5kIG5vdCBhcHBlbmRpbmcgZGF0YVBhdGhBcnJcbiAgICB9XG4gICAgaWYgKGRhdGFUeXBlcylcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFUeXBlcyA9IGRhdGFUeXBlcztcbiAgICBmdW5jdGlvbiBkYXRhQ29udGV4dFByb3BzKF9uZXh0RGF0YSkge1xuICAgICAgICBzdWJzY2hlbWEuZGF0YSA9IF9uZXh0RGF0YTtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFMZXZlbCA9IGl0LmRhdGFMZXZlbCArIDE7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhVHlwZXMgPSBbXTtcbiAgICAgICAgaXQuZGVmaW5lZFByb3BlcnRpZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHN1YnNjaGVtYS5wYXJlbnREYXRhID0gaXQuZGF0YTtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFOYW1lcyA9IFsuLi5pdC5kYXRhTmFtZXMsIF9uZXh0RGF0YV07XG4gICAgfVxufVxuZXhwb3J0cy5leHRlbmRTdWJzY2hlbWFEYXRhID0gZXh0ZW5kU3Vic2NoZW1hRGF0YTtcbmZ1bmN0aW9uIGV4dGVuZFN1YnNjaGVtYU1vZGUoc3Vic2NoZW1hLCB7IGp0ZERpc2NyaW1pbmF0b3IsIGp0ZE1ldGFkYXRhLCBjb21wb3NpdGVSdWxlLCBjcmVhdGVFcnJvcnMsIGFsbEVycm9ycyB9KSB7XG4gICAgaWYgKGNvbXBvc2l0ZVJ1bGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgc3Vic2NoZW1hLmNvbXBvc2l0ZVJ1bGUgPSBjb21wb3NpdGVSdWxlO1xuICAgIGlmIChjcmVhdGVFcnJvcnMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgc3Vic2NoZW1hLmNyZWF0ZUVycm9ycyA9IGNyZWF0ZUVycm9ycztcbiAgICBpZiAoYWxsRXJyb3JzICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHN1YnNjaGVtYS5hbGxFcnJvcnMgPSBhbGxFcnJvcnM7XG4gICAgc3Vic2NoZW1hLmp0ZERpc2NyaW1pbmF0b3IgPSBqdGREaXNjcmltaW5hdG9yOyAvLyBub3QgaW5oZXJpdGVkXG4gICAgc3Vic2NoZW1hLmp0ZE1ldGFkYXRhID0ganRkTWV0YWRhdGE7IC8vIG5vdCBpbmhlcml0ZWRcbn1cbmV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hTW9kZSA9IGV4dGVuZFN1YnNjaGVtYU1vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY2hlbWEuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBkbyBub3QgZWRpdCAuanMgZmlsZXMgZGlyZWN0bHkgLSBlZGl0IHNyYy9pbmRleC5qc3RcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0Jykge1xuICAgIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgbGVuZ3RoLCBpLCBrZXlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG5cblxuICAgIGlmIChhLmNvbnN0cnVjdG9yID09PSBSZWdFeHApIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcbiAgICBpZiAoYS52YWx1ZU9mICE9PSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YpIHJldHVybiBhLnZhbHVlT2YoKSA9PT0gYi52YWx1ZU9mKCk7XG4gICAgaWYgKGEudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoIWVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gdHJ1ZSBpZiBib3RoIE5hTiwgZmFsc2Ugb3RoZXJ3aXNlXG4gIHJldHVybiBhIT09YSAmJiBiIT09Yjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0cmF2ZXJzZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNjaGVtYSwgb3B0cywgY2IpIHtcbiAgLy8gTGVnYWN5IHN1cHBvcnQgZm9yIHYwLjMuMSBhbmQgZWFybGllci5cbiAgaWYgKHR5cGVvZiBvcHRzID09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgY2IgPSBvcHRzLmNiIHx8IGNiO1xuICB2YXIgcHJlID0gKHR5cGVvZiBjYiA9PSAnZnVuY3Rpb24nKSA/IGNiIDogY2IucHJlIHx8IGZ1bmN0aW9uKCkge307XG4gIHZhciBwb3N0ID0gY2IucG9zdCB8fCBmdW5jdGlvbigpIHt9O1xuXG4gIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaGVtYSwgJycsIHNjaGVtYSk7XG59O1xuXG5cbnRyYXZlcnNlLmtleXdvcmRzID0ge1xuICBhZGRpdGlvbmFsSXRlbXM6IHRydWUsXG4gIGl0ZW1zOiB0cnVlLFxuICBjb250YWluczogdHJ1ZSxcbiAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHRydWUsXG4gIHByb3BlcnR5TmFtZXM6IHRydWUsXG4gIG5vdDogdHJ1ZSxcbiAgaWY6IHRydWUsXG4gIHRoZW46IHRydWUsXG4gIGVsc2U6IHRydWVcbn07XG5cbnRyYXZlcnNlLmFycmF5S2V5d29yZHMgPSB7XG4gIGl0ZW1zOiB0cnVlLFxuICBhbGxPZjogdHJ1ZSxcbiAgYW55T2Y6IHRydWUsXG4gIG9uZU9mOiB0cnVlXG59O1xuXG50cmF2ZXJzZS5wcm9wc0tleXdvcmRzID0ge1xuICAkZGVmczogdHJ1ZSxcbiAgZGVmaW5pdGlvbnM6IHRydWUsXG4gIHByb3BlcnRpZXM6IHRydWUsXG4gIHBhdHRlcm5Qcm9wZXJ0aWVzOiB0cnVlLFxuICBkZXBlbmRlbmNpZXM6IHRydWVcbn07XG5cbnRyYXZlcnNlLnNraXBLZXl3b3JkcyA9IHtcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgZW51bTogdHJ1ZSxcbiAgY29uc3Q6IHRydWUsXG4gIHJlcXVpcmVkOiB0cnVlLFxuICBtYXhpbXVtOiB0cnVlLFxuICBtaW5pbXVtOiB0cnVlLFxuICBleGNsdXNpdmVNYXhpbXVtOiB0cnVlLFxuICBleGNsdXNpdmVNaW5pbXVtOiB0cnVlLFxuICBtdWx0aXBsZU9mOiB0cnVlLFxuICBtYXhMZW5ndGg6IHRydWUsXG4gIG1pbkxlbmd0aDogdHJ1ZSxcbiAgcGF0dGVybjogdHJ1ZSxcbiAgZm9ybWF0OiB0cnVlLFxuICBtYXhJdGVtczogdHJ1ZSxcbiAgbWluSXRlbXM6IHRydWUsXG4gIHVuaXF1ZUl0ZW1zOiB0cnVlLFxuICBtYXhQcm9wZXJ0aWVzOiB0cnVlLFxuICBtaW5Qcm9wZXJ0aWVzOiB0cnVlXG59O1xuXG5cbmZ1bmN0aW9uIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCkge1xuICBpZiAoc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgIHByZShzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpO1xuICAgIGZvciAodmFyIGtleSBpbiBzY2hlbWEpIHtcbiAgICAgIHZhciBzY2ggPSBzY2hlbWFba2V5XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaCkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0cmF2ZXJzZS5hcnJheUtleXdvcmRzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNjaC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaFtpXSwganNvblB0ciArICcvJyArIGtleSArICcvJyArIGksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hLCBpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gdHJhdmVyc2UucHJvcHNLZXl3b3Jkcykge1xuICAgICAgICBpZiAoc2NoICYmIHR5cGVvZiBzY2ggPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNjaClcbiAgICAgICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaFtwcm9wXSwganNvblB0ciArICcvJyArIGtleSArICcvJyArIGVzY2FwZUpzb25QdHIocHJvcCksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hLCBwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gdHJhdmVyc2Uua2V5d29yZHMgfHwgKG9wdHMuYWxsS2V5cyAmJiAhKGtleSBpbiB0cmF2ZXJzZS5za2lwS2V5d29yZHMpKSkge1xuICAgICAgICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2gsIGpzb25QdHIgKyAnLycgKyBrZXksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9zdChzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZXNjYXBlSnNvblB0cihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKTtcbn1cbiIsIi8qKiBAbGljZW5zZSBVUkkuanMgdjQuNC4xIChjKSAyMDExIEdhcnkgQ291cnQuIExpY2Vuc2U6IGh0dHA6Ly9naXRodWIuY29tL2dhcnljb3VydC91cmktanMgKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5VUkkgPSBnbG9iYWwuVVJJIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBtZXJnZSgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc2V0cyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBzZXRzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGlmIChzZXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc2V0c1swXSA9IHNldHNbMF0uc2xpY2UoMCwgLTEpO1xuICAgICAgICB2YXIgeGwgPSBzZXRzLmxlbmd0aCAtIDE7XG4gICAgICAgIGZvciAodmFyIHggPSAxOyB4IDwgeGw7ICsreCkge1xuICAgICAgICAgICAgc2V0c1t4XSA9IHNldHNbeF0uc2xpY2UoMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHNldHNbeGxdID0gc2V0c1t4bF0uc2xpY2UoMSk7XG4gICAgICAgIHJldHVybiBzZXRzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZXRzWzBdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN1YmV4cChzdHIpIHtcbiAgICByZXR1cm4gXCIoPzpcIiArIHN0ciArIFwiKVwiO1xufVxuZnVuY3Rpb24gdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gbyA9PT0gdW5kZWZpbmVkID8gXCJ1bmRlZmluZWRcIiA6IG8gPT09IG51bGwgPyBcIm51bGxcIiA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zcGxpdChcIiBcIikucG9wKCkuc3BsaXQoXCJdXCIpLnNoaWZ0KCkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHRvVXBwZXJDYXNlKHN0cikge1xuICAgIHJldHVybiBzdHIudG9VcHBlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gdW5kZWZpbmVkICYmIG9iaiAhPT0gbnVsbCA/IG9iaiBpbnN0YW5jZW9mIEFycmF5ID8gb2JqIDogdHlwZW9mIG9iai5sZW5ndGggIT09IFwibnVtYmVyXCIgfHwgb2JqLnNwbGl0IHx8IG9iai5zZXRJbnRlcnZhbCB8fCBvYmouY2FsbCA/IFtvYmpdIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqKSA6IFtdO1xufVxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7XG4gICAgdmFyIG9iaiA9IHRhcmdldDtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gYnVpbGRFeHBzKGlzSVJJKSB7XG4gICAgdmFyIEFMUEhBJCQgPSBcIltBLVphLXpdXCIsXG4gICAgICAgIENSJCA9IFwiW1xcXFx4MERdXCIsXG4gICAgICAgIERJR0lUJCQgPSBcIlswLTldXCIsXG4gICAgICAgIERRVU9URSQkID0gXCJbXFxcXHgyMl1cIixcbiAgICAgICAgSEVYRElHJCQgPSBtZXJnZShESUdJVCQkLCBcIltBLUZhLWZdXCIpLFxuICAgICAgICAvL2Nhc2UtaW5zZW5zaXRpdmVcbiAgICBMRiQkID0gXCJbXFxcXHgwQV1cIixcbiAgICAgICAgU1AkJCA9IFwiW1xcXFx4MjBdXCIsXG4gICAgICAgIFBDVF9FTkNPREVEJCA9IHN1YmV4cChzdWJleHAoXCIlW0VGZWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVbODlBLUZhLWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpKSxcbiAgICAgICAgLy9leHBhbmRlZFxuICAgIEdFTl9ERUxJTVMkJCA9IFwiW1xcXFw6XFxcXC9cXFxcP1xcXFwjXFxcXFtcXFxcXVxcXFxAXVwiLFxuICAgICAgICBTVUJfREVMSU1TJCQgPSBcIltcXFxcIVxcXFwkXFxcXCZcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcO1xcXFw9XVwiLFxuICAgICAgICBSRVNFUlZFRCQkID0gbWVyZ2UoR0VOX0RFTElNUyQkLCBTVUJfREVMSU1TJCQpLFxuICAgICAgICBVQ1NDSEFSJCQgPSBpc0lSSSA/IFwiW1xcXFx4QTAtXFxcXHUyMDBEXFxcXHUyMDEwLVxcXFx1MjAyOVxcXFx1MjAyRi1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl1cIiA6IFwiW11cIixcbiAgICAgICAgLy9zdWJzZXQsIGV4Y2x1ZGVzIGJpZGkgY29udHJvbCBjaGFyYWN0ZXJzXG4gICAgSVBSSVZBVEUkJCA9IGlzSVJJID8gXCJbXFxcXHVFMDAwLVxcXFx1RjhGRl1cIiA6IFwiW11cIixcbiAgICAgICAgLy9zdWJzZXRcbiAgICBVTlJFU0VSVkVEJCQgPSBtZXJnZShBTFBIQSQkLCBESUdJVCQkLCBcIltcXFxcLVxcXFwuXFxcXF9cXFxcfl1cIiwgVUNTQ0hBUiQkKSxcbiAgICAgICAgU0NIRU1FJCA9IHN1YmV4cChBTFBIQSQkICsgbWVyZ2UoQUxQSEEkJCwgRElHSVQkJCwgXCJbXFxcXCtcXFxcLVxcXFwuXVwiKSArIFwiKlwiKSxcbiAgICAgICAgVVNFUklORk8kID0gc3ViZXhwKHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOl1cIikpICsgXCIqXCIpLFxuICAgICAgICBERUNfT0NURVQkID0gc3ViZXhwKHN1YmV4cChcIjI1WzAtNV1cIikgKyBcInxcIiArIHN1YmV4cChcIjJbMC00XVwiICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIjFcIiArIERJR0lUJCQgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiWzEtOV1cIiArIERJR0lUJCQpICsgXCJ8XCIgKyBESUdJVCQkKSxcbiAgICAgICAgREVDX09DVEVUX1JFTEFYRUQkID0gc3ViZXhwKHN1YmV4cChcIjI1WzAtNV1cIikgKyBcInxcIiArIHN1YmV4cChcIjJbMC00XVwiICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIjFcIiArIERJR0lUJCQgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiMD9bMS05XVwiICsgRElHSVQkJCkgKyBcInwwPzA/XCIgKyBESUdJVCQkKSxcbiAgICAgICAgLy9yZWxheGVkIHBhcnNpbmcgcnVsZXNcbiAgICBJUFY0QUREUkVTUyQgPSBzdWJleHAoREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkKSxcbiAgICAgICAgSDE2JCA9IHN1YmV4cChIRVhESUckJCArIFwiezEsNH1cIiksXG4gICAgICAgIExTMzIkID0gc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiICsgSDE2JCkgKyBcInxcIiArIElQVjRBRERSRVNTJCksXG4gICAgICAgIElQVjZBRERSRVNTMSQgPSBzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7Nn1cIiArIExTMzIkKSxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICA2KCBoMTYgXCI6XCIgKSBsczMyXG4gICAgSVBWNkFERFJFU1MyJCA9IHN1YmV4cChcIlxcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezV9XCIgKyBMUzMyJCksXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgIFwiOjpcIiA1KCBoMTYgXCI6XCIgKSBsczMyXG4gICAgSVBWNkFERFJFU1MzJCA9IHN1YmV4cChzdWJleHAoSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcIns0fVwiICsgTFMzMiQpLFxuICAgICAgICAvL1sgICAgICAgICAgICAgICBoMTYgXSBcIjo6XCIgNCggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTNCQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsMX1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7M31cIiArIExTMzIkKSxcbiAgICAgICAgLy9bICoxKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgMyggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTNSQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsMn1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7Mn1cIiArIExTMzIkKSxcbiAgICAgICAgLy9bICoyKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgMiggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTNiQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsM31cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgSDE2JCArIFwiXFxcXDpcIiArIExTMzIkKSxcbiAgICAgICAgLy9bICozKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgaDE2IFwiOlwiICAgbHMzMlxuICAgIElQVjZBRERSRVNTNyQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsNH1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgTFMzMiQpLFxuICAgICAgICAvL1sgKjQoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICAgICAgICAgICAgbHMzMlxuICAgIElQVjZBRERSRVNTOCQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsNX1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgSDE2JCksXG4gICAgICAgIC8vWyAqNSggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgICAgICAgICAgICBoMTZcbiAgICBJUFY2QUREUkVTUzkkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDZ9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiksXG4gICAgICAgIC8vWyAqNiggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiXG4gICAgSVBWNkFERFJFU1MkID0gc3ViZXhwKFtJUFY2QUREUkVTUzEkLCBJUFY2QUREUkVTUzIkLCBJUFY2QUREUkVTUzMkLCBJUFY2QUREUkVTUzQkLCBJUFY2QUREUkVTUzUkLCBJUFY2QUREUkVTUzYkLCBJUFY2QUREUkVTUzckLCBJUFY2QUREUkVTUzgkLCBJUFY2QUREUkVTUzkkXS5qb2luKFwifFwiKSksXG4gICAgICAgIFpPTkVJRCQgPSBzdWJleHAoc3ViZXhwKFVOUkVTRVJWRUQkJCArIFwifFwiICsgUENUX0VOQ09ERUQkKSArIFwiK1wiKSxcbiAgICAgICAgLy9SRkMgNjg3NFxuICAgIElQVjZBRERSWiQgPSBzdWJleHAoSVBWNkFERFJFU1MkICsgXCJcXFxcJTI1XCIgKyBaT05FSUQkKSxcbiAgICAgICAgLy9SRkMgNjg3NFxuICAgIElQVjZBRERSWl9SRUxBWEVEJCA9IHN1YmV4cChJUFY2QUREUkVTUyQgKyBzdWJleHAoXCJcXFxcJTI1fFxcXFwlKD8hXCIgKyBIRVhESUckJCArIFwiezJ9KVwiKSArIFpPTkVJRCQpLFxuICAgICAgICAvL1JGQyA2ODc0LCB3aXRoIHJlbGF4ZWQgcGFyc2luZyBydWxlc1xuICAgIElQVkZVVFVSRSQgPSBzdWJleHAoXCJbdlZdXCIgKyBIRVhESUckJCArIFwiK1xcXFwuXCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpdXCIpICsgXCIrXCIpLFxuICAgICAgICBJUF9MSVRFUkFMJCA9IHN1YmV4cChcIlxcXFxbXCIgKyBzdWJleHAoSVBWNkFERFJaX1JFTEFYRUQkICsgXCJ8XCIgKyBJUFY2QUREUkVTUyQgKyBcInxcIiArIElQVkZVVFVSRSQpICsgXCJcXFxcXVwiKSxcbiAgICAgICAgLy9SRkMgNjg3NFxuICAgIFJFR19OQU1FJCA9IHN1YmV4cChzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCkpICsgXCIqXCIpLFxuICAgICAgICBIT1NUJCA9IHN1YmV4cChJUF9MSVRFUkFMJCArIFwifFwiICsgSVBWNEFERFJFU1MkICsgXCIoPyFcIiArIFJFR19OQU1FJCArIFwiKVwiICsgXCJ8XCIgKyBSRUdfTkFNRSQpLFxuICAgICAgICBQT1JUJCA9IHN1YmV4cChESUdJVCQkICsgXCIqXCIpLFxuICAgICAgICBBVVRIT1JJVFkkID0gc3ViZXhwKHN1YmV4cChVU0VSSU5GTyQgKyBcIkBcIikgKyBcIj9cIiArIEhPU1QkICsgc3ViZXhwKFwiXFxcXDpcIiArIFBPUlQkKSArIFwiP1wiKSxcbiAgICAgICAgUENIQVIkID0gc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBdXCIpKSxcbiAgICAgICAgU0VHTUVOVCQgPSBzdWJleHAoUENIQVIkICsgXCIqXCIpLFxuICAgICAgICBTRUdNRU5UX05aJCA9IHN1YmV4cChQQ0hBUiQgKyBcIitcIiksXG4gICAgICAgIFNFR01FTlRfTlpfTkMkID0gc3ViZXhwKHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcQF1cIikpICsgXCIrXCIpLFxuICAgICAgICBQQVRIX0FCRU1QVFkkID0gc3ViZXhwKHN1YmV4cChcIlxcXFwvXCIgKyBTRUdNRU5UJCkgKyBcIipcIiksXG4gICAgICAgIFBBVEhfQUJTT0xVVEUkID0gc3ViZXhwKFwiXFxcXC9cIiArIHN1YmV4cChTRUdNRU5UX05aJCArIFBBVEhfQUJFTVBUWSQpICsgXCI/XCIpLFxuICAgICAgICAvL3NpbXBsaWZpZWRcbiAgICBQQVRIX05PU0NIRU1FJCA9IHN1YmV4cChTRUdNRU5UX05aX05DJCArIFBBVEhfQUJFTVBUWSQpLFxuICAgICAgICAvL3NpbXBsaWZpZWRcbiAgICBQQVRIX1JPT1RMRVNTJCA9IHN1YmV4cChTRUdNRU5UX05aJCArIFBBVEhfQUJFTVBUWSQpLFxuICAgICAgICAvL3NpbXBsaWZpZWRcbiAgICBQQVRIX0VNUFRZJCA9IFwiKD8hXCIgKyBQQ0hBUiQgKyBcIilcIixcbiAgICAgICAgUEFUSCQgPSBzdWJleHAoUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfTk9TQ0hFTUUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuICAgICAgICBRVUVSWSQgPSBzdWJleHAoc3ViZXhwKFBDSEFSJCArIFwifFwiICsgbWVyZ2UoXCJbXFxcXC9cXFxcP11cIiwgSVBSSVZBVEUkJCkpICsgXCIqXCIpLFxuICAgICAgICBGUkFHTUVOVCQgPSBzdWJleHAoc3ViZXhwKFBDSEFSJCArIFwifFtcXFxcL1xcXFw/XVwiKSArIFwiKlwiKSxcbiAgICAgICAgSElFUl9QQVJUJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvXCIgKyBBVVRIT1JJVFkkICsgUEFUSF9BQkVNUFRZJCkgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuICAgICAgICBVUkkkID0gc3ViZXhwKFNDSEVNRSQgKyBcIlxcXFw6XCIgKyBISUVSX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjXCIgKyBGUkFHTUVOVCQpICsgXCI/XCIpLFxuICAgICAgICBSRUxBVElWRV9QQVJUJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvXCIgKyBBVVRIT1JJVFkkICsgUEFUSF9BQkVNUFRZJCkgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuICAgICAgICBSRUxBVElWRSQgPSBzdWJleHAoUkVMQVRJVkVfUEFSVCQgKyBzdWJleHAoXCJcXFxcP1wiICsgUVVFUlkkKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCNcIiArIEZSQUdNRU5UJCkgKyBcIj9cIiksXG4gICAgICAgIFVSSV9SRUZFUkVOQ0UkID0gc3ViZXhwKFVSSSQgKyBcInxcIiArIFJFTEFUSVZFJCksXG4gICAgICAgIEFCU09MVVRFX1VSSSQgPSBzdWJleHAoU0NIRU1FJCArIFwiXFxcXDpcIiArIEhJRVJfUEFSVCQgKyBzdWJleHAoXCJcXFxcP1wiICsgUVVFUlkkKSArIFwiP1wiKSxcbiAgICAgICAgR0VORVJJQ19SRUYkID0gXCJeKFwiICsgU0NIRU1FJCArIFwiKVxcXFw6XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjKFwiICsgRlJBR01FTlQkICsgXCIpXCIpICsgXCI/JFwiLFxuICAgICAgICBSRUxBVElWRV9SRUYkID0gXCJeKCl7MH1cIiArIHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvKFwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/KVwiKSArIFwiPyhcIiArIFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9FTVBUWSQgKyBcIilcIikgKyBzdWJleHAoXCJcXFxcPyhcIiArIFFVRVJZJCArIFwiKVwiKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCMoXCIgKyBGUkFHTUVOVCQgKyBcIilcIikgKyBcIj8kXCIsXG4gICAgICAgIEFCU09MVVRFX1JFRiQgPSBcIl4oXCIgKyBTQ0hFTUUkICsgXCIpXFxcXDpcIiArIHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvKFwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/KVwiKSArIFwiPyhcIiArIFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQgKyBcIilcIikgKyBzdWJleHAoXCJcXFxcPyhcIiArIFFVRVJZJCArIFwiKVwiKSArIFwiPyRcIixcbiAgICAgICAgU0FNRURPQ19SRUYkID0gXCJeXCIgKyBzdWJleHAoXCJcXFxcIyhcIiArIEZSQUdNRU5UJCArIFwiKVwiKSArIFwiPyRcIixcbiAgICAgICAgQVVUSE9SSVRZX1JFRiQgPSBcIl5cIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPyRcIjtcbiAgICByZXR1cm4ge1xuICAgICAgICBOT1RfU0NIRU1FOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIEFMUEhBJCQsIERJR0lUJCQsIFwiW1xcXFwrXFxcXC1cXFxcLl1cIiksIFwiZ1wiKSxcbiAgICAgICAgTk9UX1VTRVJJTkZPOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFw6XVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX0hPU1Q6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXFtcXFxcXVxcXFw6XVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX1BBVEg6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXC9cXFxcOlxcXFxAXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX1BBVEhfTk9TQ0hFTUU6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXC9cXFxcQF1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9RVUVSWTogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOlxcXFxAXFxcXC9cXFxcP11cIiwgSVBSSVZBVEUkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX0ZSQUdNRU5UOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJV1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBcXFxcL1xcXFw/XVwiKSwgXCJnXCIpLFxuICAgICAgICBFU0NBUEU6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIFVOUkVTRVJWRUQ6IG5ldyBSZWdFeHAoVU5SRVNFUlZFRCQkLCBcImdcIiksXG4gICAgICAgIE9USEVSX0NIQVJTOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJV1cIiwgVU5SRVNFUlZFRCQkLCBSRVNFUlZFRCQkKSwgXCJnXCIpLFxuICAgICAgICBQQ1RfRU5DT0RFRDogbmV3IFJlZ0V4cChQQ1RfRU5DT0RFRCQsIFwiZ1wiKSxcbiAgICAgICAgSVBWNEFERFJFU1M6IG5ldyBSZWdFeHAoXCJeKFwiICsgSVBWNEFERFJFU1MkICsgXCIpJFwiKSxcbiAgICAgICAgSVBWNkFERFJFU1M6IG5ldyBSZWdFeHAoXCJeXFxcXFs/KFwiICsgSVBWNkFERFJFU1MkICsgXCIpXCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXCUyNXxcXFxcJSg/IVwiICsgSEVYRElHJCQgKyBcInsyfSlcIikgKyBcIihcIiArIFpPTkVJRCQgKyBcIilcIikgKyBcIj9cXFxcXT8kXCIpIC8vUkZDIDY4NzQsIHdpdGggcmVsYXhlZCBwYXJzaW5nIHJ1bGVzXG4gICAgfTtcbn1cbnZhciBVUklfUFJPVE9DT0wgPSBidWlsZEV4cHMoZmFsc2UpO1xuXG52YXIgSVJJX1BST1RPQ09MID0gYnVpbGRFeHBzKHRydWUpO1xuXG52YXIgc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHtcbiAgICAgIHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICAgIH1cbiAgfTtcbn0oKTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIHRvQ29uc3VtYWJsZUFycmF5ID0gZnVuY3Rpb24gKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgIHJldHVybiBhcnIyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGFycik7XG4gIH1cbn07XG5cbi8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblxudmFyIG1heEludCA9IDIxNDc0ODM2NDc7IC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuLyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xudmFyIGJhc2UgPSAzNjtcbnZhciB0TWluID0gMTtcbnZhciB0TWF4ID0gMjY7XG52YXIgc2tldyA9IDM4O1xudmFyIGRhbXAgPSA3MDA7XG52YXIgaW5pdGlhbEJpYXMgPSA3MjtcbnZhciBpbml0aWFsTiA9IDEyODsgLy8gMHg4MFxudmFyIGRlbGltaXRlciA9ICctJzsgLy8gJ1xceDJEJ1xuXG4vKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xudmFyIHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vO1xudmFyIHJlZ2V4Tm9uQVNDSUkgPSAvW15cXDAtXFx4N0VdLzsgLy8gbm9uLUFTQ0lJIGNoYXJzXG52YXIgcmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZzsgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG4vKiogRXJyb3IgbWVzc2FnZXMgKi9cbnZhciBlcnJvcnMgPSB7XG5cdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG59O1xuXG4vKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG52YXIgYmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZXJyb3IkMSh0eXBlKSB7XG5cdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG59XG5cbi8qKlxuICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuICogaXRlbS5cbiAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHR2YXIgcmVzdWx0ID0gW107XG5cdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcbiAqIGFkZHJlc3Nlcy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG4gKiBjaGFyYWN0ZXIuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuICogZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHR2YXIgcmVzdWx0ID0gJyc7XG5cdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdH1cblx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcbiAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuICogbWF0Y2hpbmcgVVRGLTE2LlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG4gKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBkZWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG4gKi9cbmZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdHZhciBvdXRwdXQgPSBbXTtcblx0dmFyIGNvdW50ZXIgPSAwO1xuXHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHR2YXIgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdC8vIEl0J3MgYSBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXIuXG5cdFx0XHR2YXIgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7XG5cdFx0XHRcdC8vIExvdyBzdXJyb2dhdGUuXG5cdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJdCdzIGFuIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZVxuXHRcdFx0XHQvLyBuZXh0IGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpci5cblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG4gKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBlbmNvZGVcbiAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG4gKi9cbnZhciB1Y3MyZW5jb2RlID0gZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQuYXBwbHkoU3RyaW5nLCB0b0NvbnN1bWFibGVBcnJheShhcnJheSkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG4gKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cbiAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcbiAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuICovXG52YXIgYmFzaWNUb0RpZ2l0ID0gZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRpZiAoY29kZVBvaW50IC0gMHgzMCA8IDB4MEEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHgxNjtcblx0fVxuXHRpZiAoY29kZVBvaW50IC0gMHg0MSA8IDB4MUEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHg0MTtcblx0fVxuXHRpZiAoY29kZVBvaW50IC0gMHg2MSA8IDB4MUEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHg2MTtcblx0fVxuXHRyZXR1cm4gYmFzZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG4gKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG4gKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cbiAqL1xudmFyIGRpZ2l0VG9CYXNpYyA9IGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcbn07XG5cbi8qKlxuICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgYWRhcHQgPSBmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0dmFyIGsgPSAwO1xuXHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdGZvciAoOyAvKiBubyBpbml0aWFsaXphdGlvbiAqL2RlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHR9XG5cdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuICogc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICovXG52YXIgZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdC8vIERvbid0IHVzZSBVQ1MtMi5cblx0dmFyIG91dHB1dCA9IFtdO1xuXHR2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cdHZhciBpID0gMDtcblx0dmFyIG4gPSBpbml0aWFsTjtcblx0dmFyIGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0dmFyIGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdGJhc2ljID0gMDtcblx0fVxuXG5cdGZvciAodmFyIGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdGVycm9yJDEoJ25vdC1iYXNpYycpO1xuXHRcdH1cblx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0fVxuXG5cdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRmb3IgKHZhciBpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7KSAvKiBubyBmaW5hbCBleHByZXNzaW9uICove1xuXG5cdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHR2YXIgb2xkaSA9IGk7XG5cdFx0Zm9yICh2YXIgdyA9IDEsIGsgPSBiYXNlOzsgLyogbm8gY29uZGl0aW9uICovayArPSBiYXNlKSB7XG5cblx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRlcnJvciQxKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRlcnJvciQxKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdHZhciB0ID0gayA8PSBiaWFzID8gdE1pbiA6IGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXM7XG5cblx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdGVycm9yJDEoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblx0XHR9XG5cblx0XHR2YXIgb3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHR9XG5cblx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdGkgJT0gb3V0O1xuXG5cdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dC5cblx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cdH1cblxuXHRyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQuYXBwbHkoU3RyaW5nLCBvdXRwdXQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICovXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdHZhciBvdXRwdXQgPSBbXTtcblxuXHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBhbiBhcnJheSBvZiBVbmljb2RlIGNvZGUgcG9pbnRzLlxuXHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdC8vIENhY2hlIHRoZSBsZW5ndGguXG5cdHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZS5cblx0dmFyIG4gPSBpbml0aWFsTjtcblx0dmFyIGRlbHRhID0gMDtcblx0dmFyIGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzLlxuXHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG5cdHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuXHR2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cblx0dHJ5IHtcblx0XHRmb3IgKHZhciBfaXRlcmF0b3IgPSBpbnB1dFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcblx0XHRcdHZhciBfY3VycmVudFZhbHVlMiA9IF9zdGVwLnZhbHVlO1xuXG5cdFx0XHRpZiAoX2N1cnJlbnRWYWx1ZTIgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShfY3VycmVudFZhbHVlMikpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0X2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuXHRcdF9pdGVyYXRvckVycm9yID0gZXJyO1xuXHR9IGZpbmFsbHkge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuXHRcdFx0XHRfaXRlcmF0b3IucmV0dXJuKCk7XG5cdFx0XHR9XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuXHRcdFx0XHR0aHJvdyBfaXRlcmF0b3JFcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2YXIgYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXHR2YXIgaGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aDtcblxuXHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIHdpdGggYSBkZWxpbWl0ZXIgdW5sZXNzIGl0J3MgZW1wdHkuXG5cdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdH1cblxuXHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHR2YXIgbSA9IG1heEludDtcblx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuXHRcdHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcblx0XHR2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGZvciAodmFyIF9pdGVyYXRvcjIgPSBpbnB1dFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuXHRcdFx0XHR2YXIgY3VycmVudFZhbHVlID0gX3N0ZXAyLnZhbHVlO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvdy5cblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG5cdFx0XHRfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcblx0XHRcdFx0XHRfaXRlcmF0b3IyLnJldHVybigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG5cdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHR9XG5cblx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdG4gPSBtO1xuXG5cdFx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTtcblx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IzID0gZmFsc2U7XG5cdFx0dmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuXHRcdHRyeSB7XG5cdFx0XHRmb3IgKHZhciBfaXRlcmF0b3IzID0gaW5wdXRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHtcblx0XHRcdFx0dmFyIF9jdXJyZW50VmFsdWUgPSBfc3RlcDMudmFsdWU7XG5cblx0XHRcdFx0aWYgKF9jdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvciQxKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChfY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cblx0XHRcdFx0XHR2YXIgcSA9IGRlbHRhO1xuXHRcdFx0XHRcdGZvciAodmFyIGsgPSBiYXNlOzsgLyogbm8gY29uZGl0aW9uICovayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR2YXIgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiBrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFyIHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdHZhciBiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpKTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7XG5cdFx0XHRfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4pIHtcblx0XHRcdFx0XHRfaXRlcmF0b3IzLnJldHVybigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG5cdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3IzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0KytkZWx0YTtcblx0XHQrK247XG5cdH1cblx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG4gKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuICogY29udmVydCB0byBVbmljb2RlLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG4gKiBzdHJpbmcuXG4gKi9cbnZhciB0b1VuaWNvZGUgPSBmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24gKHN0cmluZykge1xuXHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKSA/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSkgOiBzdHJpbmc7XG5cdH0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cbiAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG4gKiBBU0NJSS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcbiAqIFVuaWNvZGUgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuICogZW1haWwgYWRkcmVzcy5cbiAqL1xudmFyIHRvQVNDSUkgPSBmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uIChzdHJpbmcpIHtcblx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZykgPyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKSA6IHN0cmluZztcblx0fSk7XG59O1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xudmFyIHB1bnljb2RlID0ge1xuXHQvKipcbiAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG4gICogQG1lbWJlck9mIHB1bnljb2RlXG4gICogQHR5cGUgU3RyaW5nXG4gICovXG5cdCd2ZXJzaW9uJzogJzIuMS4wJyxcblx0LyoqXG4gICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcbiAgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuICAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuICAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICAqIEB0eXBlIE9iamVjdFxuICAqL1xuXHQndWNzMic6IHtcblx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHR9LFxuXHQnZGVjb2RlJzogZGVjb2RlLFxuXHQnZW5jb2RlJzogZW5jb2RlLFxuXHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcbn07XG5cbi8qKlxuICogVVJJLmpzXG4gKlxuICogQGZpbGVvdmVydmlldyBBbiBSRkMgMzk4NiBjb21wbGlhbnQsIHNjaGVtZSBleHRlbmRhYmxlIFVSSSBwYXJzaW5nL3ZhbGlkYXRpbmcvcmVzb2x2aW5nIGxpYnJhcnkgZm9yIEphdmFTY3JpcHQuXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86Z2FyeS5jb3VydEBnbWFpbC5jb21cIj5HYXJ5IENvdXJ0PC9hPlxuICogQHNlZSBodHRwOi8vZ2l0aHViLmNvbS9nYXJ5Y291cnQvdXJpLWpzXG4gKi9cbi8qKlxuICogQ29weXJpZ2h0IDIwMTEgR2FyeSBDb3VydC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmVcbiAqIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mXG4gKiAgICAgICBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3RcbiAqICAgICAgIG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gKiAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBHQVJZIENPVVJUIGBgQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRFxuICogV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEdBUlkgQ09VUlQgT1JcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SXG4gKiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG4gKiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUZcbiAqIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICpcbiAqIFRoZSB2aWV3cyBhbmQgY29uY2x1c2lvbnMgY29udGFpbmVkIGluIHRoZSBzb2Z0d2FyZSBhbmQgZG9jdW1lbnRhdGlvbiBhcmUgdGhvc2Ugb2YgdGhlXG4gKiBhdXRob3JzIGFuZCBzaG91bGQgbm90IGJlIGludGVycHJldGVkIGFzIHJlcHJlc2VudGluZyBvZmZpY2lhbCBwb2xpY2llcywgZWl0aGVyIGV4cHJlc3NlZFxuICogb3IgaW1wbGllZCwgb2YgR2FyeSBDb3VydC5cbiAqL1xudmFyIFNDSEVNRVMgPSB7fTtcbmZ1bmN0aW9uIHBjdEVuY0NoYXIoY2hyKSB7XG4gICAgdmFyIGMgPSBjaHIuY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgZSA9IHZvaWQgMDtcbiAgICBpZiAoYyA8IDE2KSBlID0gXCIlMFwiICsgYy50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtlbHNlIGlmIChjIDwgMTI4KSBlID0gXCIlXCIgKyBjLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO2Vsc2UgaWYgKGMgPCAyMDQ4KSBlID0gXCIlXCIgKyAoYyA+PiA2IHwgMTkyKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArIFwiJVwiICsgKGMgJiA2MyB8IDEyOCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7ZWxzZSBlID0gXCIlXCIgKyAoYyA+PiAxMiB8IDIyNCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBcIiVcIiArIChjID4+IDYgJiA2MyB8IDEyOCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBcIiVcIiArIChjICYgNjMgfCAxMjgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBlO1xufVxuZnVuY3Rpb24gcGN0RGVjQ2hhcnMoc3RyKSB7XG4gICAgdmFyIG5ld1N0ciA9IFwiXCI7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBpbCA9IHN0ci5sZW5ndGg7XG4gICAgd2hpbGUgKGkgPCBpbCkge1xuICAgICAgICB2YXIgYyA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDEsIDIpLCAxNik7XG4gICAgICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICAgICAgICBuZXdTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgfSBlbHNlIGlmIChjID49IDE5NCAmJiBjIDwgMjI0KSB7XG4gICAgICAgICAgICBpZiAoaWwgLSBpID49IDYpIHtcbiAgICAgICAgICAgICAgICB2YXIgYzIgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyA0LCAyKSwgMTYpO1xuICAgICAgICAgICAgICAgIG5ld1N0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMzEpIDw8IDYgfCBjMiAmIDYzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U3RyICs9IHN0ci5zdWJzdHIoaSwgNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpICs9IDY7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA+PSAyMjQpIHtcbiAgICAgICAgICAgIGlmIChpbCAtIGkgPj0gOSkge1xuICAgICAgICAgICAgICAgIHZhciBfYyA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDQsIDIpLCAxNik7XG4gICAgICAgICAgICAgICAgdmFyIGMzID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgNywgMiksIDE2KTtcbiAgICAgICAgICAgICAgICBuZXdTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDE1KSA8PCAxMiB8IChfYyAmIDYzKSA8PCA2IHwgYzMgJiA2Myk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSArPSA5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3U3RyICs9IHN0ci5zdWJzdHIoaSwgMyk7XG4gICAgICAgICAgICBpICs9IDM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld1N0cjtcbn1cbmZ1bmN0aW9uIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBwcm90b2NvbCkge1xuICAgIGZ1bmN0aW9uIGRlY29kZVVucmVzZXJ2ZWQoc3RyKSB7XG4gICAgICAgIHZhciBkZWNTdHIgPSBwY3REZWNDaGFycyhzdHIpO1xuICAgICAgICByZXR1cm4gIWRlY1N0ci5tYXRjaChwcm90b2NvbC5VTlJFU0VSVkVEKSA/IHN0ciA6IGRlY1N0cjtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMuc2NoZW1lKSBjb21wb25lbnRzLnNjaGVtZSA9IFN0cmluZyhjb21wb25lbnRzLnNjaGVtZSkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKHByb3RvY29sLk5PVF9TQ0hFTUUsIFwiXCIpO1xuICAgIGlmIChjb21wb25lbnRzLnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMudXNlcmluZm8gPSBTdHJpbmcoY29tcG9uZW50cy51c2VyaW5mbykucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShwcm90b2NvbC5OT1RfVVNFUklORk8sIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICBpZiAoY29tcG9uZW50cy5ob3N0ICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMuaG9zdCA9IFN0cmluZyhjb21wb25lbnRzLmhvc3QpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShwcm90b2NvbC5OT1RfSE9TVCwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgIGlmIChjb21wb25lbnRzLnBhdGggIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5wYXRoID0gU3RyaW5nKGNvbXBvbmVudHMucGF0aCkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShjb21wb25lbnRzLnNjaGVtZSA/IHByb3RvY29sLk5PVF9QQVRIIDogcHJvdG9jb2wuTk9UX1BBVEhfTk9TQ0hFTUUsIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICBpZiAoY29tcG9uZW50cy5xdWVyeSAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLnF1ZXJ5ID0gU3RyaW5nKGNvbXBvbmVudHMucXVlcnkpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UocHJvdG9jb2wuTk9UX1FVRVJZLCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG4gICAgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5mcmFnbWVudCA9IFN0cmluZyhjb21wb25lbnRzLmZyYWdtZW50KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKHByb3RvY29sLk5PVF9GUkFHTUVOVCwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgIHJldHVybiBjb21wb25lbnRzO1xufVxuXG5mdW5jdGlvbiBfc3RyaXBMZWFkaW5nWmVyb3Moc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eMCooLiopLywgXCIkMVwiKSB8fCBcIjBcIjtcbn1cbmZ1bmN0aW9uIF9ub3JtYWxpemVJUHY0KGhvc3QsIHByb3RvY29sKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBob3N0Lm1hdGNoKHByb3RvY29sLklQVjRBRERSRVNTKSB8fCBbXTtcblxuICAgIHZhciBfbWF0Y2hlcyA9IHNsaWNlZFRvQXJyYXkobWF0Y2hlcywgMiksXG4gICAgICAgIGFkZHJlc3MgPSBfbWF0Y2hlc1sxXTtcblxuICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBhZGRyZXNzLnNwbGl0KFwiLlwiKS5tYXAoX3N0cmlwTGVhZGluZ1plcm9zKS5qb2luKFwiLlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaG9zdDtcbiAgICB9XG59XG5mdW5jdGlvbiBfbm9ybWFsaXplSVB2Nihob3N0LCBwcm90b2NvbCkge1xuICAgIHZhciBtYXRjaGVzID0gaG9zdC5tYXRjaChwcm90b2NvbC5JUFY2QUREUkVTUykgfHwgW107XG5cbiAgICB2YXIgX21hdGNoZXMyID0gc2xpY2VkVG9BcnJheShtYXRjaGVzLCAzKSxcbiAgICAgICAgYWRkcmVzcyA9IF9tYXRjaGVzMlsxXSxcbiAgICAgICAgem9uZSA9IF9tYXRjaGVzMlsyXTtcblxuICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgIHZhciBfYWRkcmVzcyR0b0xvd2VyQ2FzZSQgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkuc3BsaXQoJzo6JykucmV2ZXJzZSgpLFxuICAgICAgICAgICAgX2FkZHJlc3MkdG9Mb3dlckNhc2UkMiA9IHNsaWNlZFRvQXJyYXkoX2FkZHJlc3MkdG9Mb3dlckNhc2UkLCAyKSxcbiAgICAgICAgICAgIGxhc3QgPSBfYWRkcmVzcyR0b0xvd2VyQ2FzZSQyWzBdLFxuICAgICAgICAgICAgZmlyc3QgPSBfYWRkcmVzcyR0b0xvd2VyQ2FzZSQyWzFdO1xuXG4gICAgICAgIHZhciBmaXJzdEZpZWxkcyA9IGZpcnN0ID8gZmlyc3Quc3BsaXQoXCI6XCIpLm1hcChfc3RyaXBMZWFkaW5nWmVyb3MpIDogW107XG4gICAgICAgIHZhciBsYXN0RmllbGRzID0gbGFzdC5zcGxpdChcIjpcIikubWFwKF9zdHJpcExlYWRpbmdaZXJvcyk7XG4gICAgICAgIHZhciBpc0xhc3RGaWVsZElQdjRBZGRyZXNzID0gcHJvdG9jb2wuSVBWNEFERFJFU1MudGVzdChsYXN0RmllbGRzW2xhc3RGaWVsZHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICB2YXIgZmllbGRDb3VudCA9IGlzTGFzdEZpZWxkSVB2NEFkZHJlc3MgPyA3IDogODtcbiAgICAgICAgdmFyIGxhc3RGaWVsZHNTdGFydCA9IGxhc3RGaWVsZHMubGVuZ3RoIC0gZmllbGRDb3VudDtcbiAgICAgICAgdmFyIGZpZWxkcyA9IEFycmF5KGZpZWxkQ291bnQpO1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGZpZWxkQ291bnQ7ICsreCkge1xuICAgICAgICAgICAgZmllbGRzW3hdID0gZmlyc3RGaWVsZHNbeF0gfHwgbGFzdEZpZWxkc1tsYXN0RmllbGRzU3RhcnQgKyB4XSB8fCAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMYXN0RmllbGRJUHY0QWRkcmVzcykge1xuICAgICAgICAgICAgZmllbGRzW2ZpZWxkQ291bnQgLSAxXSA9IF9ub3JtYWxpemVJUHY0KGZpZWxkc1tmaWVsZENvdW50IC0gMV0sIHByb3RvY29sKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWxsWmVyb0ZpZWxkcyA9IGZpZWxkcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZmllbGQsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWZpZWxkIHx8IGZpZWxkID09PSBcIjBcIikge1xuICAgICAgICAgICAgICAgIHZhciBsYXN0TG9uZ2VzdCA9IGFjY1thY2MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RMb25nZXN0ICYmIGxhc3RMb25nZXN0LmluZGV4ICsgbGFzdExvbmdlc3QubGVuZ3RoID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0TG9uZ2VzdC5sZW5ndGgrKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhY2MucHVzaCh7IGluZGV4OiBpbmRleCwgbGVuZ3RoOiAxIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgdmFyIGxvbmdlc3RaZXJvRmllbGRzID0gYWxsWmVyb0ZpZWxkcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfSlbMF07XG4gICAgICAgIHZhciBuZXdIb3N0ID0gdm9pZCAwO1xuICAgICAgICBpZiAobG9uZ2VzdFplcm9GaWVsZHMgJiYgbG9uZ2VzdFplcm9GaWVsZHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIG5ld0ZpcnN0ID0gZmllbGRzLnNsaWNlKDAsIGxvbmdlc3RaZXJvRmllbGRzLmluZGV4KTtcbiAgICAgICAgICAgIHZhciBuZXdMYXN0ID0gZmllbGRzLnNsaWNlKGxvbmdlc3RaZXJvRmllbGRzLmluZGV4ICsgbG9uZ2VzdFplcm9GaWVsZHMubGVuZ3RoKTtcbiAgICAgICAgICAgIG5ld0hvc3QgPSBuZXdGaXJzdC5qb2luKFwiOlwiKSArIFwiOjpcIiArIG5ld0xhc3Quam9pbihcIjpcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdIb3N0ID0gZmllbGRzLmpvaW4oXCI6XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh6b25lKSB7XG4gICAgICAgICAgICBuZXdIb3N0ICs9IFwiJVwiICsgem9uZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3SG9zdDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaG9zdDtcbiAgICB9XG59XG52YXIgVVJJX1BBUlNFID0gL14oPzooW146XFwvPyNdKyk6KT8oPzpcXC9cXC8oKD86KFteXFwvPyNAXSopQCk/KFxcW1teXFwvPyNcXF1dK1xcXXxbXlxcLz8jOl0qKSg/OlxcOihcXGQqKSk/KSk/KFtePyNdKikoPzpcXD8oW14jXSopKT8oPzojKCg/Oi58XFxufFxccikqKSk/L2k7XG52YXIgTk9fTUFUQ0hfSVNfVU5ERUZJTkVEID0gXCJcIi5tYXRjaCgvKCl7MH0vKVsxXSA9PT0gdW5kZWZpbmVkO1xuZnVuY3Rpb24gcGFyc2UodXJpU3RyaW5nKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgdmFyIGNvbXBvbmVudHMgPSB7fTtcbiAgICB2YXIgcHJvdG9jb2wgPSBvcHRpb25zLmlyaSAhPT0gZmFsc2UgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0w7XG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlID09PSBcInN1ZmZpeFwiKSB1cmlTdHJpbmcgPSAob3B0aW9ucy5zY2hlbWUgPyBvcHRpb25zLnNjaGVtZSArIFwiOlwiIDogXCJcIikgKyBcIi8vXCIgKyB1cmlTdHJpbmc7XG4gICAgdmFyIG1hdGNoZXMgPSB1cmlTdHJpbmcubWF0Y2goVVJJX1BBUlNFKTtcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICBpZiAoTk9fTUFUQ0hfSVNfVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAvL3N0b3JlIGVhY2ggY29tcG9uZW50XG4gICAgICAgICAgICBjb21wb25lbnRzLnNjaGVtZSA9IG1hdGNoZXNbMV07XG4gICAgICAgICAgICBjb21wb25lbnRzLnVzZXJpbmZvID0gbWF0Y2hlc1szXTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9IG1hdGNoZXNbNF07XG4gICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSBtYXRjaGVzWzZdIHx8IFwiXCI7XG4gICAgICAgICAgICBjb21wb25lbnRzLnF1ZXJ5ID0gbWF0Y2hlc1s3XTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZnJhZ21lbnQgPSBtYXRjaGVzWzhdO1xuICAgICAgICAgICAgLy9maXggcG9ydCBudW1iZXJcbiAgICAgICAgICAgIGlmIChpc05hTihjb21wb25lbnRzLnBvcnQpKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gbWF0Y2hlc1s1XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vSUUgRklYIGZvciBpbXByb3BlciBSZWdFeHAgbWF0Y2hpbmdcbiAgICAgICAgICAgIC8vc3RvcmUgZWFjaCBjb21wb25lbnRcbiAgICAgICAgICAgIGNvbXBvbmVudHMuc2NoZW1lID0gbWF0Y2hlc1sxXSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLnVzZXJpbmZvID0gdXJpU3RyaW5nLmluZGV4T2YoXCJAXCIpICE9PSAtMSA/IG1hdGNoZXNbM10gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLmhvc3QgPSB1cmlTdHJpbmcuaW5kZXhPZihcIi8vXCIpICE9PSAtMSA/IG1hdGNoZXNbNF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSBtYXRjaGVzWzZdIHx8IFwiXCI7XG4gICAgICAgICAgICBjb21wb25lbnRzLnF1ZXJ5ID0gdXJpU3RyaW5nLmluZGV4T2YoXCI/XCIpICE9PSAtMSA/IG1hdGNoZXNbN10gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLmZyYWdtZW50ID0gdXJpU3RyaW5nLmluZGV4T2YoXCIjXCIpICE9PSAtMSA/IG1hdGNoZXNbOF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvL2ZpeCBwb3J0IG51bWJlclxuICAgICAgICAgICAgaWYgKGlzTmFOKGNvbXBvbmVudHMucG9ydCkpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSB1cmlTdHJpbmcubWF0Y2goL1xcL1xcLyg/Oi58XFxuKSpcXDooPzpcXC98XFw/fFxcI3wkKS8pID8gbWF0Y2hlc1s0XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcG9uZW50cy5ob3N0KSB7XG4gICAgICAgICAgICAvL25vcm1hbGl6ZSBJUCBob3N0c1xuICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gX25vcm1hbGl6ZUlQdjYoX25vcm1hbGl6ZUlQdjQoY29tcG9uZW50cy5ob3N0LCBwcm90b2NvbCksIHByb3RvY29sKTtcbiAgICAgICAgfVxuICAgICAgICAvL2RldGVybWluZSByZWZlcmVuY2UgdHlwZVxuICAgICAgICBpZiAoY29tcG9uZW50cy5zY2hlbWUgPT09IHVuZGVmaW5lZCAmJiBjb21wb25lbnRzLnVzZXJpbmZvID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy5ob3N0ID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy5wb3J0ID09PSB1bmRlZmluZWQgJiYgIWNvbXBvbmVudHMucGF0aCAmJiBjb21wb25lbnRzLnF1ZXJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJzYW1lLWRvY3VtZW50XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG9uZW50cy5zY2hlbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5yZWZlcmVuY2UgPSBcInJlbGF0aXZlXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG9uZW50cy5mcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJ1cmlcIjtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciByZWZlcmVuY2UgZXJyb3JzXG4gICAgICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gXCJzdWZmaXhcIiAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gY29tcG9uZW50cy5yZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiVVJJIGlzIG5vdCBhIFwiICsgb3B0aW9ucy5yZWZlcmVuY2UgKyBcIiByZWZlcmVuY2UuXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy9maW5kIHNjaGVtZSBoYW5kbGVyXG4gICAgICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1sob3B0aW9ucy5zY2hlbWUgfHwgY29tcG9uZW50cy5zY2hlbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIC8vY2hlY2sgaWYgc2NoZW1lIGNhbid0IGhhbmRsZSBJUklzXG4gICAgICAgIGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIudW5pY29kZVN1cHBvcnQpKSB7XG4gICAgICAgICAgICAvL2lmIGhvc3QgY29tcG9uZW50IGlzIGEgZG9tYWluIG5hbWVcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRzLmhvc3QgJiYgKG9wdGlvbnMuZG9tYWluSG9zdCB8fCBzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuZG9tYWluSG9zdCkpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgVW5pY29kZSBJRE4gLT4gQVNDSUkgSUROXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gcHVueWNvZGUudG9BU0NJSShjb21wb25lbnRzLmhvc3QucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgcGN0RGVjQ2hhcnMpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gQVNDSUkgdmlhIHB1bnljb2RlOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9jb252ZXJ0IElSSSAtPiBVUklcbiAgICAgICAgICAgIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBVUklfUFJPVE9DT0wpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9ub3JtYWxpemUgZW5jb2RpbmdzXG4gICAgICAgICAgICBfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgcHJvdG9jb2wpO1xuICAgICAgICB9XG4gICAgICAgIC8vcGVyZm9ybSBzY2hlbWUgc3BlY2lmaWMgcGFyc2luZ1xuICAgICAgICBpZiAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLnBhcnNlKSB7XG4gICAgICAgICAgICBzY2hlbWVIYW5kbGVyLnBhcnNlKGNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUkkgY2FuIG5vdCBiZSBwYXJzZWQuXCI7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnRzO1xufVxuXG5mdW5jdGlvbiBfcmVjb21wb3NlQXV0aG9yaXR5KGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgcHJvdG9jb2wgPSBvcHRpb25zLmlyaSAhPT0gZmFsc2UgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0w7XG4gICAgdmFyIHVyaVRva2VucyA9IFtdO1xuICAgIGlmIChjb21wb25lbnRzLnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy51c2VyaW5mbyk7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiQFwiKTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vbm9ybWFsaXplIElQIGhvc3RzLCBhZGQgYnJhY2tldHMgYW5kIGVzY2FwZSB6b25lIHNlcGFyYXRvciBmb3IgSVB2NlxuICAgICAgICB1cmlUb2tlbnMucHVzaChfbm9ybWFsaXplSVB2Nihfbm9ybWFsaXplSVB2NChTdHJpbmcoY29tcG9uZW50cy5ob3N0KSwgcHJvdG9jb2wpLCBwcm90b2NvbCkucmVwbGFjZShwcm90b2NvbC5JUFY2QUREUkVTUywgZnVuY3Rpb24gKF8sICQxLCAkMikge1xuICAgICAgICAgICAgcmV0dXJuIFwiW1wiICsgJDEgKyAoJDIgPyBcIiUyNVwiICsgJDIgOiBcIlwiKSArIFwiXVwiO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29tcG9uZW50cy5wb3J0ID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBjb21wb25lbnRzLnBvcnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goXCI6XCIpO1xuICAgICAgICB1cmlUb2tlbnMucHVzaChTdHJpbmcoY29tcG9uZW50cy5wb3J0KSk7XG4gICAgfVxuICAgIHJldHVybiB1cmlUb2tlbnMubGVuZ3RoID8gdXJpVG9rZW5zLmpvaW4oXCJcIikgOiB1bmRlZmluZWQ7XG59XG5cbnZhciBSRFMxID0gL15cXC5cXC4/XFwvLztcbnZhciBSRFMyID0gL15cXC9cXC4oXFwvfCQpLztcbnZhciBSRFMzID0gL15cXC9cXC5cXC4oXFwvfCQpLztcbnZhciBSRFM1ID0gL15cXC8/KD86LnxcXG4pKj8oPz1cXC98JCkvO1xuZnVuY3Rpb24gcmVtb3ZlRG90U2VnbWVudHMoaW5wdXQpIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgd2hpbGUgKGlucHV0Lmxlbmd0aCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goUkRTMSkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMxLCBcIlwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5tYXRjaChSRFMyKSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzIsIFwiL1wiKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5tYXRjaChSRFMzKSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzMsIFwiL1wiKTtcbiAgICAgICAgICAgIG91dHB1dC5wb3AoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gXCIuXCIgfHwgaW5wdXQgPT09IFwiLi5cIikge1xuICAgICAgICAgICAgaW5wdXQgPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGltID0gaW5wdXQubWF0Y2goUkRTNSk7XG4gICAgICAgICAgICBpZiAoaW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IGltWzBdO1xuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2Uocy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGRvdCBzZWdtZW50IGNvbmRpdGlvblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oXCJcIik7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShjb21wb25lbnRzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgdmFyIHByb3RvY29sID0gb3B0aW9ucy5pcmkgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0w7XG4gICAgdmFyIHVyaVRva2VucyA9IFtdO1xuICAgIC8vZmluZCBzY2hlbWUgaGFuZGxlclxuICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1sob3B0aW9ucy5zY2hlbWUgfHwgY29tcG9uZW50cy5zY2hlbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKV07XG4gICAgLy9wZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBzZXJpYWxpemF0aW9uXG4gICAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUpIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKGNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgIGlmIChjb21wb25lbnRzLmhvc3QpIHtcbiAgICAgICAgLy9pZiBob3N0IGNvbXBvbmVudCBpcyBhbiBJUHY2IGFkZHJlc3NcbiAgICAgICAgaWYgKHByb3RvY29sLklQVjZBRERSRVNTLnRlc3QoY29tcG9uZW50cy5ob3N0KSkge31cbiAgICAgICAgLy9UT0RPOiBub3JtYWxpemUgSVB2NiBhZGRyZXNzIGFzIHBlciBSRkMgNTk1MlxuXG4gICAgICAgIC8vaWYgaG9zdCBjb21wb25lbnQgaXMgYSBkb21haW4gbmFtZVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmRvbWFpbkhvc3QgfHwgc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLmRvbWFpbkhvc3QpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgSUROIHZpYSBwdW55Y29kZVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9ICFvcHRpb25zLmlyaSA/IHB1bnljb2RlLnRvQVNDSUkoY29tcG9uZW50cy5ob3N0LnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHBjdERlY0NoYXJzKS50b0xvd2VyQ2FzZSgpKSA6IHB1bnljb2RlLnRvVW5pY29kZShjb21wb25lbnRzLmhvc3QpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gXCIgKyAoIW9wdGlvbnMuaXJpID8gXCJBU0NJSVwiIDogXCJVbmljb2RlXCIpICsgXCIgdmlhIHB1bnljb2RlOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIH1cbiAgICAvL25vcm1hbGl6ZSBlbmNvZGluZ1xuICAgIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBwcm90b2NvbCk7XG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiICYmIGNvbXBvbmVudHMuc2NoZW1lKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMuc2NoZW1lKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goXCI6XCIpO1xuICAgIH1cbiAgICB2YXIgYXV0aG9yaXR5ID0gX3JlY29tcG9zZUF1dGhvcml0eShjb21wb25lbnRzLCBvcHRpb25zKTtcbiAgICBpZiAoYXV0aG9yaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiKSB7XG4gICAgICAgICAgICB1cmlUb2tlbnMucHVzaChcIi8vXCIpO1xuICAgICAgICB9XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGF1dGhvcml0eSk7XG4gICAgICAgIGlmIChjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5wYXRoLmNoYXJBdCgwKSAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgIHVyaVRva2Vucy5wdXNoKFwiL1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tcG9uZW50cy5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHMgPSBjb21wb25lbnRzLnBhdGg7XG4gICAgICAgIGlmICghb3B0aW9ucy5hYnNvbHV0ZVBhdGggJiYgKCFzY2hlbWVIYW5kbGVyIHx8ICFzY2hlbWVIYW5kbGVyLmFic29sdXRlUGF0aCkpIHtcbiAgICAgICAgICAgIHMgPSByZW1vdmVEb3RTZWdtZW50cyhzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXV0aG9yaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoL15cXC9cXC8vLCBcIi8lMkZcIik7IC8vZG9uJ3QgYWxsb3cgdGhlIHBhdGggdG8gc3RhcnQgd2l0aCBcIi8vXCJcbiAgICAgICAgfVxuICAgICAgICB1cmlUb2tlbnMucHVzaChzKTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cmlUb2tlbnMucHVzaChcIj9cIik7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMucXVlcnkpO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50cy5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiI1wiKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5mcmFnbWVudCk7XG4gICAgfVxuICAgIHJldHVybiB1cmlUb2tlbnMuam9pbihcIlwiKTsgLy9tZXJnZSB0b2tlbnMgaW50byBhIHN0cmluZ1xufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50cyhiYXNlLCByZWxhdGl2ZSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgc2tpcE5vcm1hbGl6YXRpb24gPSBhcmd1bWVudHNbM107XG5cbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgaWYgKCFza2lwTm9ybWFsaXphdGlvbikge1xuICAgICAgICBiYXNlID0gcGFyc2Uoc2VyaWFsaXplKGJhc2UsIG9wdGlvbnMpLCBvcHRpb25zKTsgLy9ub3JtYWxpemUgYmFzZSBjb21wb25lbnRzXG4gICAgICAgIHJlbGF0aXZlID0gcGFyc2Uoc2VyaWFsaXplKHJlbGF0aXZlLCBvcHRpb25zKSwgb3B0aW9ucyk7IC8vbm9ybWFsaXplIHJlbGF0aXZlIGNvbXBvbmVudHNcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKCFvcHRpb25zLnRvbGVyYW50ICYmIHJlbGF0aXZlLnNjaGVtZSkge1xuICAgICAgICB0YXJnZXQuc2NoZW1lID0gcmVsYXRpdmUuc2NoZW1lO1xuICAgICAgICAvL3RhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgICAgIHRhcmdldC51c2VyaW5mbyA9IHJlbGF0aXZlLnVzZXJpbmZvO1xuICAgICAgICB0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoIHx8IFwiXCIpO1xuICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVsYXRpdmUudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvL3RhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgICAgICAgICB0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mbztcbiAgICAgICAgICAgIHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCBcIlwiKTtcbiAgICAgICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGg7XG4gICAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gYmFzZS5xdWVyeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5wYXRoLmNoYXJBdCgwKSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGJhc2UudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCBiYXNlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCBiYXNlLnBvcnQgIT09IHVuZGVmaW5lZCkgJiYgIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBcIi9cIiArIHJlbGF0aXZlLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZWxhdGl2ZS5wYXRoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGguc2xpY2UoMCwgYmFzZS5wYXRoLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpICsgcmVsYXRpdmUucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHRhcmdldC5wYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3RhcmdldC5hdXRob3JpdHkgPSBiYXNlLmF1dGhvcml0eTtcbiAgICAgICAgICAgIHRhcmdldC51c2VyaW5mbyA9IGJhc2UudXNlcmluZm87XG4gICAgICAgICAgICB0YXJnZXQuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgIHRhcmdldC5wb3J0ID0gYmFzZS5wb3J0O1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5zY2hlbWUgPSBiYXNlLnNjaGVtZTtcbiAgICB9XG4gICAgdGFyZ2V0LmZyYWdtZW50ID0gcmVsYXRpdmUuZnJhZ21lbnQ7XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShiYXNlVVJJLCByZWxhdGl2ZVVSSSwgb3B0aW9ucykge1xuICAgIHZhciBzY2hlbWVsZXNzT3B0aW9ucyA9IGFzc2lnbih7IHNjaGVtZTogJ251bGwnIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBzZXJpYWxpemUocmVzb2x2ZUNvbXBvbmVudHMocGFyc2UoYmFzZVVSSSwgc2NoZW1lbGVzc09wdGlvbnMpLCBwYXJzZShyZWxhdGl2ZVVSSSwgc2NoZW1lbGVzc09wdGlvbnMpLCBzY2hlbWVsZXNzT3B0aW9ucywgdHJ1ZSksIHNjaGVtZWxlc3NPcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplKHVyaSwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdXJpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHVyaSA9IHNlcmlhbGl6ZShwYXJzZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVPZih1cmkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHVyaSA9IHBhcnNlKHNlcmlhbGl6ZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHVyaTtcbn1cblxuZnVuY3Rpb24gZXF1YWwodXJpQSwgdXJpQiwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdXJpQSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB1cmlBID0gc2VyaWFsaXplKHBhcnNlKHVyaUEsIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVPZih1cmlBKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB1cmlBID0gc2VyaWFsaXplKHVyaUEsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHVyaUIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdXJpQiA9IHNlcmlhbGl6ZShwYXJzZSh1cmlCLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0eXBlT2YodXJpQikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdXJpQiA9IHNlcmlhbGl6ZSh1cmlCLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHVyaUEgPT09IHVyaUI7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUNvbXBvbmVudChzdHIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gc3RyICYmIHN0ci50b1N0cmluZygpLnJlcGxhY2UoIW9wdGlvbnMgfHwgIW9wdGlvbnMuaXJpID8gVVJJX1BST1RPQ09MLkVTQ0FQRSA6IElSSV9QUk9UT0NPTC5FU0NBUEUsIHBjdEVuY0NoYXIpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZUNvbXBvbmVudChzdHIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gc3RyICYmIHN0ci50b1N0cmluZygpLnJlcGxhY2UoIW9wdGlvbnMgfHwgIW9wdGlvbnMuaXJpID8gVVJJX1BST1RPQ09MLlBDVF9FTkNPREVEIDogSVJJX1BST1RPQ09MLlBDVF9FTkNPREVELCBwY3REZWNDaGFycyk7XG59XG5cbnZhciBoYW5kbGVyID0ge1xuICAgIHNjaGVtZTogXCJodHRwXCIsXG4gICAgZG9tYWluSG9zdDogdHJ1ZSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICAvL3JlcG9ydCBtaXNzaW5nIGhvc3RcbiAgICAgICAgaWYgKCFjb21wb25lbnRzLmhvc3QpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSFRUUCBVUklzIG11c3QgaGF2ZSBhIGhvc3QuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBzZWN1cmUgPSBTdHJpbmcoY29tcG9uZW50cy5zY2hlbWUpLnRvTG93ZXJDYXNlKCkgPT09IFwiaHR0cHNcIjtcbiAgICAgICAgLy9ub3JtYWxpemUgdGhlIGRlZmF1bHQgcG9ydFxuICAgICAgICBpZiAoY29tcG9uZW50cy5wb3J0ID09PSAoc2VjdXJlID8gNDQzIDogODApIHx8IGNvbXBvbmVudHMucG9ydCA9PT0gXCJcIikge1xuICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vbm9ybWFsaXplIHRoZSBlbXB0eSBwYXRoXG4gICAgICAgIGlmICghY29tcG9uZW50cy5wYXRoKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSBcIi9cIjtcbiAgICAgICAgfVxuICAgICAgICAvL05PVEU6IFdlIGRvIG5vdCBwYXJzZSBxdWVyeSBzdHJpbmdzIGZvciBIVFRQIFVSSXNcbiAgICAgICAgLy9hcyBXV1cgRm9ybSBVcmwgRW5jb2RlZCBxdWVyeSBzdHJpbmdzIGFyZSBwYXJ0IG9mIHRoZSBIVE1MNCsgc3BlYyxcbiAgICAgICAgLy9hbmQgbm90IHRoZSBIVFRQIHNwZWMuXG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbn07XG5cbnZhciBoYW5kbGVyJDEgPSB7XG4gICAgc2NoZW1lOiBcImh0dHBzXCIsXG4gICAgZG9tYWluSG9zdDogaGFuZGxlci5kb21haW5Ib3N0LFxuICAgIHBhcnNlOiBoYW5kbGVyLnBhcnNlLFxuICAgIHNlcmlhbGl6ZTogaGFuZGxlci5zZXJpYWxpemVcbn07XG5cbmZ1bmN0aW9uIGlzU2VjdXJlKHdzQ29tcG9uZW50cykge1xuICAgIHJldHVybiB0eXBlb2Ygd3NDb21wb25lbnRzLnNlY3VyZSA9PT0gJ2Jvb2xlYW4nID8gd3NDb21wb25lbnRzLnNlY3VyZSA6IFN0cmluZyh3c0NvbXBvbmVudHMuc2NoZW1lKS50b0xvd2VyQ2FzZSgpID09PSBcIndzc1wiO1xufVxuLy9SRkMgNjQ1NVxudmFyIGhhbmRsZXIkMiA9IHtcbiAgICBzY2hlbWU6IFwid3NcIixcbiAgICBkb21haW5Ib3N0OiB0cnVlLFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB3c0NvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgICAgICAvL2luZGljYXRlIGlmIHRoZSBzZWN1cmUgZmxhZyBpcyBzZXRcbiAgICAgICAgd3NDb21wb25lbnRzLnNlY3VyZSA9IGlzU2VjdXJlKHdzQ29tcG9uZW50cyk7XG4gICAgICAgIC8vY29uc3RydWN0IHJlc291Y2UgbmFtZVxuICAgICAgICB3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lID0gKHdzQ29tcG9uZW50cy5wYXRoIHx8ICcvJykgKyAod3NDb21wb25lbnRzLnF1ZXJ5ID8gJz8nICsgd3NDb21wb25lbnRzLnF1ZXJ5IDogJycpO1xuICAgICAgICB3c0NvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgd3NDb21wb25lbnRzLnF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gd3NDb21wb25lbnRzO1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUod3NDb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIC8vbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcbiAgICAgICAgaWYgKHdzQ29tcG9uZW50cy5wb3J0ID09PSAoaXNTZWN1cmUod3NDb21wb25lbnRzKSA/IDQ0MyA6IDgwKSB8fCB3c0NvbXBvbmVudHMucG9ydCA9PT0gXCJcIikge1xuICAgICAgICAgICAgd3NDb21wb25lbnRzLnBvcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9lbnN1cmUgc2NoZW1lIG1hdGNoZXMgc2VjdXJlIGZsYWdcbiAgICAgICAgaWYgKHR5cGVvZiB3c0NvbXBvbmVudHMuc2VjdXJlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5zY2hlbWUgPSB3c0NvbXBvbmVudHMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuICAgICAgICAgICAgd3NDb21wb25lbnRzLnNlY3VyZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvL3JlY29uc3RydWN0IHBhdGggZnJvbSByZXNvdXJjZSBuYW1lXG4gICAgICAgIGlmICh3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lKSB7XG4gICAgICAgICAgICB2YXIgX3dzQ29tcG9uZW50cyRyZXNvdXJjID0gd3NDb21wb25lbnRzLnJlc291cmNlTmFtZS5zcGxpdCgnPycpLFxuICAgICAgICAgICAgICAgIF93c0NvbXBvbmVudHMkcmVzb3VyYzIgPSBzbGljZWRUb0FycmF5KF93c0NvbXBvbmVudHMkcmVzb3VyYywgMiksXG4gICAgICAgICAgICAgICAgcGF0aCA9IF93c0NvbXBvbmVudHMkcmVzb3VyYzJbMF0sXG4gICAgICAgICAgICAgICAgcXVlcnkgPSBfd3NDb21wb25lbnRzJHJlc291cmMyWzFdO1xuXG4gICAgICAgICAgICB3c0NvbXBvbmVudHMucGF0aCA9IHBhdGggJiYgcGF0aCAhPT0gJy8nID8gcGF0aCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgd3NDb21wb25lbnRzLnJlc291cmNlTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvL2ZvcmJpZCBmcmFnbWVudCBjb21wb25lbnRcbiAgICAgICAgd3NDb21wb25lbnRzLmZyYWdtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gd3NDb21wb25lbnRzO1xuICAgIH1cbn07XG5cbnZhciBoYW5kbGVyJDMgPSB7XG4gICAgc2NoZW1lOiBcIndzc1wiLFxuICAgIGRvbWFpbkhvc3Q6IGhhbmRsZXIkMi5kb21haW5Ib3N0LFxuICAgIHBhcnNlOiBoYW5kbGVyJDIucGFyc2UsXG4gICAgc2VyaWFsaXplOiBoYW5kbGVyJDIuc2VyaWFsaXplXG59O1xuXG52YXIgTyA9IHt9O1xudmFyIGlzSVJJID0gdHJ1ZTtcbi8vUkZDIDM5ODZcbnZhciBVTlJFU0VSVkVEJCQgPSBcIltBLVphLXowLTlcXFxcLVxcXFwuXFxcXF9cXFxcflwiICsgKGlzSVJJID8gXCJcXFxceEEwLVxcXFx1MjAwRFxcXFx1MjAxMC1cXFxcdTIwMjlcXFxcdTIwMkYtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZcIiA6IFwiXCIpICsgXCJdXCI7XG52YXIgSEVYRElHJCQgPSBcIlswLTlBLUZhLWZdXCI7IC8vY2FzZS1pbnNlbnNpdGl2ZVxudmFyIFBDVF9FTkNPREVEJCA9IHN1YmV4cChzdWJleHAoXCIlW0VGZWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVbODlBLUZhLWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpKTsgLy9leHBhbmRlZFxuLy9SRkMgNTMyMiwgZXhjZXB0IHRoZXNlIHN5bWJvbHMgYXMgcGVyIFJGQyA2MDY4OiBAIDogLyA/ICMgWyBdICYgOyA9XG4vL2NvbnN0IEFURVhUJCQgPSBcIltBLVphLXowLTlcXFxcIVxcXFwjXFxcXCRcXFxcJVxcXFwmXFxcXCdcXFxcKlxcXFwrXFxcXC1cXFxcL1xcXFw9XFxcXD9cXFxcXlxcXFxfXFxcXGBcXFxce1xcXFx8XFxcXH1cXFxcfl1cIjtcbi8vY29uc3QgV1NQJCQgPSBcIltcXFxceDIwXFxcXHgwOV1cIjtcbi8vY29uc3QgT0JTX1FURVhUJCQgPSBcIltcXFxceDAxLVxcXFx4MDhcXFxceDBCXFxcXHgwQ1xcXFx4MEUtXFxcXHgxRlxcXFx4N0ZdXCI7ICAvLyglZDEtOCAvICVkMTEtMTIgLyAlZDE0LTMxIC8gJWQxMjcpXG4vL2NvbnN0IFFURVhUJCQgPSBtZXJnZShcIltcXFxceDIxXFxcXHgyMy1cXFxceDVCXFxcXHg1RC1cXFxceDdFXVwiLCBPQlNfUVRFWFQkJCk7ICAvLyVkMzMgLyAlZDM1LTkxIC8gJWQ5My0xMjYgLyBvYnMtcXRleHRcbi8vY29uc3QgVkNIQVIkJCA9IFwiW1xcXFx4MjEtXFxcXHg3RV1cIjtcbi8vY29uc3QgV1NQJCQgPSBcIltcXFxceDIwXFxcXHgwOV1cIjtcbi8vY29uc3QgT0JTX1FQJCA9IHN1YmV4cChcIlxcXFxcXFxcXCIgKyBtZXJnZShcIltcXFxceDAwXFxcXHgwRFxcXFx4MEFdXCIsIE9CU19RVEVYVCQkKSk7ICAvLyVkMCAvIENSIC8gTEYgLyBvYnMtcXRleHRcbi8vY29uc3QgRldTJCA9IHN1YmV4cChzdWJleHAoV1NQJCQgKyBcIipcIiArIFwiXFxcXHgwRFxcXFx4MEFcIikgKyBcIj9cIiArIFdTUCQkICsgXCIrXCIpO1xuLy9jb25zdCBRVU9URURfUEFJUiQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXFxcXFxcIiArIHN1YmV4cChWQ0hBUiQkICsgXCJ8XCIgKyBXU1AkJCkpICsgXCJ8XCIgKyBPQlNfUVAkKTtcbi8vY29uc3QgUVVPVEVEX1NUUklORyQgPSBzdWJleHAoJ1xcXFxcIicgKyBzdWJleHAoRldTJCArIFwiP1wiICsgUUNPTlRFTlQkKSArIFwiKlwiICsgRldTJCArIFwiP1wiICsgJ1xcXFxcIicpO1xudmFyIEFURVhUJCQgPSBcIltBLVphLXowLTlcXFxcIVxcXFwkXFxcXCVcXFxcJ1xcXFwqXFxcXCtcXFxcLVxcXFxeXFxcXF9cXFxcYFxcXFx7XFxcXHxcXFxcfVxcXFx+XVwiO1xudmFyIFFURVhUJCQgPSBcIltcXFxcIVxcXFwkXFxcXCVcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcLVxcXFwuMC05XFxcXDxcXFxcPkEtWlxcXFx4NUUtXFxcXHg3RV1cIjtcbnZhciBWQ0hBUiQkID0gbWVyZ2UoUVRFWFQkJCwgXCJbXFxcXFxcXCJcXFxcXFxcXF1cIik7XG52YXIgU09NRV9ERUxJTVMkJCA9IFwiW1xcXFwhXFxcXCRcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcO1xcXFw6XFxcXEBdXCI7XG52YXIgVU5SRVNFUlZFRCA9IG5ldyBSZWdFeHAoVU5SRVNFUlZFRCQkLCBcImdcIik7XG52YXIgUENUX0VOQ09ERUQgPSBuZXcgUmVnRXhwKFBDVF9FTkNPREVEJCwgXCJnXCIpO1xudmFyIE5PVF9MT0NBTF9QQVJUID0gbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBBVEVYVCQkLCBcIltcXFxcLl1cIiwgJ1tcXFxcXCJdJywgVkNIQVIkJCksIFwiZ1wiKTtcbnZhciBOT1RfSEZOQU1FID0gbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBVTlJFU0VSVkVEJCQsIFNPTUVfREVMSU1TJCQpLCBcImdcIik7XG52YXIgTk9UX0hGVkFMVUUgPSBOT1RfSEZOQU1FO1xuZnVuY3Rpb24gZGVjb2RlVW5yZXNlcnZlZChzdHIpIHtcbiAgICB2YXIgZGVjU3RyID0gcGN0RGVjQ2hhcnMoc3RyKTtcbiAgICByZXR1cm4gIWRlY1N0ci5tYXRjaChVTlJFU0VSVkVEKSA/IHN0ciA6IGRlY1N0cjtcbn1cbnZhciBoYW5kbGVyJDQgPSB7XG4gICAgc2NoZW1lOiBcIm1haWx0b1wiLFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSQkMShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBtYWlsdG9Db21wb25lbnRzID0gY29tcG9uZW50cztcbiAgICAgICAgdmFyIHRvID0gbWFpbHRvQ29tcG9uZW50cy50byA9IG1haWx0b0NvbXBvbmVudHMucGF0aCA/IG1haWx0b0NvbXBvbmVudHMucGF0aC5zcGxpdChcIixcIikgOiBbXTtcbiAgICAgICAgbWFpbHRvQ29tcG9uZW50cy5wYXRoID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFpbHRvQ29tcG9uZW50cy5xdWVyeSkge1xuICAgICAgICAgICAgdmFyIHVua25vd25IZWFkZXJzID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgdmFyIGhmaWVsZHMgPSBtYWlsdG9Db21wb25lbnRzLnF1ZXJ5LnNwbGl0KFwiJlwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwLCB4bCA9IGhmaWVsZHMubGVuZ3RoOyB4IDwgeGw7ICsreCkge1xuICAgICAgICAgICAgICAgIHZhciBoZmllbGQgPSBoZmllbGRzW3hdLnNwbGl0KFwiPVwiKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGhmaWVsZFswXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG9cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b0FkZHJzID0gaGZpZWxkWzFdLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF94ID0gMCwgX3hsID0gdG9BZGRycy5sZW5ndGg7IF94IDwgX3hsOyArK194KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8ucHVzaCh0b0FkZHJzW194XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1YmplY3RcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haWx0b0NvbXBvbmVudHMuc3ViamVjdCA9IHVuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFsxXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haWx0b0NvbXBvbmVudHMuYm9keSA9IHVuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFsxXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVua25vd25IZWFkZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzBdLCBvcHRpb25zKV0gPSB1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVua25vd25IZWFkZXJzKSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIG1haWx0b0NvbXBvbmVudHMucXVlcnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAodmFyIF94MiA9IDAsIF94bDIgPSB0by5sZW5ndGg7IF94MiA8IF94bDI7ICsrX3gyKSB7XG4gICAgICAgICAgICB2YXIgYWRkciA9IHRvW194Ml0uc3BsaXQoXCJAXCIpO1xuICAgICAgICAgICAgYWRkclswXSA9IHVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMF0pO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnVuaWNvZGVTdXBwb3J0KSB7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IFVuaWNvZGUgSUROIC0+IEFTQ0lJIElETlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJbMV0gPSBwdW55Y29kZS50b0FTQ0lJKHVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMV0sIG9wdGlvbnMpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbHRvQ29tcG9uZW50cy5lcnJvciA9IG1haWx0b0NvbXBvbmVudHMuZXJyb3IgfHwgXCJFbWFpbCBhZGRyZXNzJ3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gQVNDSUkgdmlhIHB1bnljb2RlOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRyWzFdID0gdW5lc2NhcGVDb21wb25lbnQoYWRkclsxXSwgb3B0aW9ucykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvW194Ml0gPSBhZGRyLmpvaW4oXCJAXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWlsdG9Db21wb25lbnRzO1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUkJDEobWFpbHRvQ29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgY29tcG9uZW50cyA9IG1haWx0b0NvbXBvbmVudHM7XG4gICAgICAgIHZhciB0byA9IHRvQXJyYXkobWFpbHRvQ29tcG9uZW50cy50byk7XG4gICAgICAgIGlmICh0bykge1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDAsIHhsID0gdG8ubGVuZ3RoOyB4IDwgeGw7ICsreCkge1xuICAgICAgICAgICAgICAgIHZhciB0b0FkZHIgPSBTdHJpbmcodG9beF0pO1xuICAgICAgICAgICAgICAgIHZhciBhdElkeCA9IHRvQWRkci5sYXN0SW5kZXhPZihcIkBcIik7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsUGFydCA9IHRvQWRkci5zbGljZSgwLCBhdElkeCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpLnJlcGxhY2UoTk9UX0xPQ0FMX1BBUlQsIHBjdEVuY0NoYXIpO1xuICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSB0b0FkZHIuc2xpY2UoYXRJZHggKyAxKTtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgSUROIHZpYSBwdW55Y29kZVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbiA9ICFvcHRpb25zLmlyaSA/IHB1bnljb2RlLnRvQVNDSUkodW5lc2NhcGVDb21wb25lbnQoZG9tYWluLCBvcHRpb25zKS50b0xvd2VyQ2FzZSgpKSA6IHB1bnljb2RlLnRvVW5pY29kZShkb21haW4pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJFbWFpbCBhZGRyZXNzJ3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gXCIgKyAoIW9wdGlvbnMuaXJpID8gXCJBU0NJSVwiIDogXCJVbmljb2RlXCIpICsgXCIgdmlhIHB1bnljb2RlOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvW3hdID0gbG9jYWxQYXJ0ICsgXCJAXCIgKyBkb21haW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSB0by5qb2luKFwiLFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVhZGVycyA9IG1haWx0b0NvbXBvbmVudHMuaGVhZGVycyA9IG1haWx0b0NvbXBvbmVudHMuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgaWYgKG1haWx0b0NvbXBvbmVudHMuc3ViamVjdCkgaGVhZGVyc1tcInN1YmplY3RcIl0gPSBtYWlsdG9Db21wb25lbnRzLnN1YmplY3Q7XG4gICAgICAgIGlmIChtYWlsdG9Db21wb25lbnRzLmJvZHkpIGhlYWRlcnNbXCJib2R5XCJdID0gbWFpbHRvQ29tcG9uZW50cy5ib2R5O1xuICAgICAgICB2YXIgZmllbGRzID0gW107XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gaGVhZGVycykge1xuICAgICAgICAgICAgaWYgKGhlYWRlcnNbbmFtZV0gIT09IE9bbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChuYW1lLnJlcGxhY2UoUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKS5yZXBsYWNlKE5PVF9IRk5BTUUsIHBjdEVuY0NoYXIpICsgXCI9XCIgKyBoZWFkZXJzW25hbWVdLnJlcGxhY2UoUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKS5yZXBsYWNlKE5PVF9IRlZBTFVFLCBwY3RFbmNDaGFyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucXVlcnkgPSBmaWVsZHMuam9pbihcIiZcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgfVxufTtcblxudmFyIFVSTl9QQVJTRSA9IC9eKFteXFw6XSspXFw6KC4qKS87XG4vL1JGQyAyMTQxXG52YXIgaGFuZGxlciQ1ID0ge1xuICAgIHNjaGVtZTogXCJ1cm5cIixcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UkJDEoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IGNvbXBvbmVudHMucGF0aCAmJiBjb21wb25lbnRzLnBhdGgubWF0Y2goVVJOX1BBUlNFKTtcbiAgICAgICAgdmFyIHVybkNvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgdmFyIHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudHMuc2NoZW1lIHx8IFwidXJuXCI7XG4gICAgICAgICAgICB2YXIgbmlkID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIG5zcyA9IG1hdGNoZXNbMl07XG4gICAgICAgICAgICB2YXIgdXJuU2NoZW1lID0gc2NoZW1lICsgXCI6XCIgKyAob3B0aW9ucy5uaWQgfHwgbmlkKTtcbiAgICAgICAgICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1t1cm5TY2hlbWVdO1xuICAgICAgICAgICAgdXJuQ29tcG9uZW50cy5uaWQgPSBuaWQ7XG4gICAgICAgICAgICB1cm5Db21wb25lbnRzLm5zcyA9IG5zcztcbiAgICAgICAgICAgIHVybkNvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChzY2hlbWVIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdXJuQ29tcG9uZW50cyA9IHNjaGVtZUhhbmRsZXIucGFyc2UodXJuQ29tcG9uZW50cywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cm5Db21wb25lbnRzLmVycm9yID0gdXJuQ29tcG9uZW50cy5lcnJvciB8fCBcIlVSTiBjYW4gbm90IGJlIHBhcnNlZC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJuQ29tcG9uZW50cztcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplJCQxKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudHMuc2NoZW1lIHx8IFwidXJuXCI7XG4gICAgICAgIHZhciBuaWQgPSB1cm5Db21wb25lbnRzLm5pZDtcbiAgICAgICAgdmFyIHVyblNjaGVtZSA9IHNjaGVtZSArIFwiOlwiICsgKG9wdGlvbnMubmlkIHx8IG5pZCk7XG4gICAgICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1t1cm5TY2hlbWVdO1xuICAgICAgICBpZiAoc2NoZW1lSGFuZGxlcikge1xuICAgICAgICAgICAgdXJuQ29tcG9uZW50cyA9IHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cmlDb21wb25lbnRzID0gdXJuQ29tcG9uZW50cztcbiAgICAgICAgdmFyIG5zcyA9IHVybkNvbXBvbmVudHMubnNzO1xuICAgICAgICB1cmlDb21wb25lbnRzLnBhdGggPSAobmlkIHx8IG9wdGlvbnMubmlkKSArIFwiOlwiICsgbnNzO1xuICAgICAgICByZXR1cm4gdXJpQ29tcG9uZW50cztcbiAgICB9XG59O1xuXG52YXIgVVVJRCA9IC9eWzAtOUEtRmEtZl17OH0oPzpcXC1bMC05QS1GYS1mXXs0fSl7M31cXC1bMC05QS1GYS1mXXsxMn0kLztcbi8vUkZDIDQxMjJcbnZhciBoYW5kbGVyJDYgPSB7XG4gICAgc2NoZW1lOiBcInVybjp1dWlkXCIsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHV1aWRDb21wb25lbnRzID0gdXJuQ29tcG9uZW50cztcbiAgICAgICAgdXVpZENvbXBvbmVudHMudXVpZCA9IHV1aWRDb21wb25lbnRzLm5zcztcbiAgICAgICAgdXVpZENvbXBvbmVudHMubnNzID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgKCF1dWlkQ29tcG9uZW50cy51dWlkIHx8ICF1dWlkQ29tcG9uZW50cy51dWlkLm1hdGNoKFVVSUQpKSkge1xuICAgICAgICAgICAgdXVpZENvbXBvbmVudHMuZXJyb3IgPSB1dWlkQ29tcG9uZW50cy5lcnJvciB8fCBcIlVVSUQgaXMgbm90IHZhbGlkLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dWlkQ29tcG9uZW50cztcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplKHV1aWRDb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB1cm5Db21wb25lbnRzID0gdXVpZENvbXBvbmVudHM7XG4gICAgICAgIC8vbm9ybWFsaXplIFVVSURcbiAgICAgICAgdXJuQ29tcG9uZW50cy5uc3MgPSAodXVpZENvbXBvbmVudHMudXVpZCB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gdXJuQ29tcG9uZW50cztcbiAgICB9XG59O1xuXG5TQ0hFTUVTW2hhbmRsZXIuc2NoZW1lXSA9IGhhbmRsZXI7XG5TQ0hFTUVTW2hhbmRsZXIkMS5zY2hlbWVdID0gaGFuZGxlciQxO1xuU0NIRU1FU1toYW5kbGVyJDIuc2NoZW1lXSA9IGhhbmRsZXIkMjtcblNDSEVNRVNbaGFuZGxlciQzLnNjaGVtZV0gPSBoYW5kbGVyJDM7XG5TQ0hFTUVTW2hhbmRsZXIkNC5zY2hlbWVdID0gaGFuZGxlciQ0O1xuU0NIRU1FU1toYW5kbGVyJDUuc2NoZW1lXSA9IGhhbmRsZXIkNTtcblNDSEVNRVNbaGFuZGxlciQ2LnNjaGVtZV0gPSBoYW5kbGVyJDY7XG5cbmV4cG9ydHMuU0NIRU1FUyA9IFNDSEVNRVM7XG5leHBvcnRzLnBjdEVuY0NoYXIgPSBwY3RFbmNDaGFyO1xuZXhwb3J0cy5wY3REZWNDaGFycyA9IHBjdERlY0NoYXJzO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5yZW1vdmVEb3RTZWdtZW50cyA9IHJlbW92ZURvdFNlZ21lbnRzO1xuZXhwb3J0cy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG5leHBvcnRzLnJlc29sdmVDb21wb25lbnRzID0gcmVzb2x2ZUNvbXBvbmVudHM7XG5leHBvcnRzLnJlc29sdmUgPSByZXNvbHZlO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5leHBvcnRzLmVxdWFsID0gZXF1YWw7XG5leHBvcnRzLmVzY2FwZUNvbXBvbmVudCA9IGVzY2FwZUNvbXBvbmVudDtcbmV4cG9ydHMudW5lc2NhcGVDb21wb25lbnQgPSB1bmVzY2FwZUNvbXBvbmVudDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVyaS5hbGwuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0U2NoZW1hUmVmcyA9IGV4cG9ydHMucmVzb2x2ZVVybCA9IGV4cG9ydHMubm9ybWFsaXplSWQgPSBleHBvcnRzLl9nZXRGdWxsUGF0aCA9IGV4cG9ydHMuZ2V0RnVsbFBhdGggPSBleHBvcnRzLmlubGluZVJlZiA9IHZvaWQgMDtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCBlcXVhbCA9IHJlcXVpcmUoXCJmYXN0LWRlZXAtZXF1YWxcIik7XG5jb25zdCB0cmF2ZXJzZSA9IHJlcXVpcmUoXCJqc29uLXNjaGVtYS10cmF2ZXJzZVwiKTtcbmNvbnN0IFVSSSA9IHJlcXVpcmUoXCJ1cmktanNcIik7XG4vLyBUT0RPIHJlZmFjdG9yIHRvIHVzZSBrZXl3b3JkIGRlZmluaXRpb25zXG5jb25zdCBTSU1QTEVfSU5MSU5FRCA9IG5ldyBTZXQoW1xuICAgIFwidHlwZVwiLFxuICAgIFwiZm9ybWF0XCIsXG4gICAgXCJwYXR0ZXJuXCIsXG4gICAgXCJtYXhMZW5ndGhcIixcbiAgICBcIm1pbkxlbmd0aFwiLFxuICAgIFwibWF4UHJvcGVydGllc1wiLFxuICAgIFwibWluUHJvcGVydGllc1wiLFxuICAgIFwibWF4SXRlbXNcIixcbiAgICBcIm1pbkl0ZW1zXCIsXG4gICAgXCJtYXhpbXVtXCIsXG4gICAgXCJtaW5pbXVtXCIsXG4gICAgXCJ1bmlxdWVJdGVtc1wiLFxuICAgIFwibXVsdGlwbGVPZlwiLFxuICAgIFwicmVxdWlyZWRcIixcbiAgICBcImVudW1cIixcbiAgICBcImNvbnN0XCIsXG5dKTtcbmZ1bmN0aW9uIGlubGluZVJlZihzY2hlbWEsIGxpbWl0ID0gdHJ1ZSkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAobGltaXQgPT09IHRydWUpXG4gICAgICAgIHJldHVybiAhaGFzUmVmKHNjaGVtYSk7XG4gICAgaWYgKCFsaW1pdClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBjb3VudEtleXMoc2NoZW1hKSA8PSBsaW1pdDtcbn1cbmV4cG9ydHMuaW5saW5lUmVmID0gaW5saW5lUmVmO1xuY29uc3QgUkVGX0tFWVdPUkRTID0gbmV3IFNldChbXG4gICAgXCIkcmVmXCIsXG4gICAgXCIkcmVjdXJzaXZlUmVmXCIsXG4gICAgXCIkcmVjdXJzaXZlQW5jaG9yXCIsXG4gICAgXCIkZHluYW1pY1JlZlwiLFxuICAgIFwiJGR5bmFtaWNBbmNob3JcIixcbl0pO1xuZnVuY3Rpb24gaGFzUmVmKHNjaGVtYSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBpZiAoUkVGX0tFWVdPUkRTLmhhcyhrZXkpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnN0IHNjaCA9IHNjaGVtYVtrZXldO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2gpICYmIHNjaC5zb21lKGhhc1JlZikpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2ggPT0gXCJvYmplY3RcIiAmJiBoYXNSZWYoc2NoKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjb3VudEtleXMoc2NoZW1hKSB7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCIkcmVmXCIpXG4gICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICAgIGlmIChTSU1QTEVfSU5MSU5FRC5oYXMoa2V5KSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYVtrZXldID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHV0aWxfMS5lYWNoSXRlbShzY2hlbWFba2V5XSwgKHNjaCkgPT4gKGNvdW50ICs9IGNvdW50S2V5cyhzY2gpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50ID09PSBJbmZpbml0eSlcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xufVxuZnVuY3Rpb24gZ2V0RnVsbFBhdGgoaWQgPSBcIlwiLCBub3JtYWxpemUpIHtcbiAgICBpZiAobm9ybWFsaXplICE9PSBmYWxzZSlcbiAgICAgICAgaWQgPSBub3JtYWxpemVJZChpZCk7XG4gICAgY29uc3QgcCA9IFVSSS5wYXJzZShpZCk7XG4gICAgcmV0dXJuIF9nZXRGdWxsUGF0aChwKTtcbn1cbmV4cG9ydHMuZ2V0RnVsbFBhdGggPSBnZXRGdWxsUGF0aDtcbmZ1bmN0aW9uIF9nZXRGdWxsUGF0aChwKSB7XG4gICAgcmV0dXJuIFVSSS5zZXJpYWxpemUocCkuc3BsaXQoXCIjXCIpWzBdICsgXCIjXCI7XG59XG5leHBvcnRzLl9nZXRGdWxsUGF0aCA9IF9nZXRGdWxsUGF0aDtcbmNvbnN0IFRSQUlMSU5HX1NMQVNIX0hBU0ggPSAvI1xcLz8kLztcbmZ1bmN0aW9uIG5vcm1hbGl6ZUlkKGlkKSB7XG4gICAgcmV0dXJuIGlkID8gaWQucmVwbGFjZShUUkFJTElOR19TTEFTSF9IQVNILCBcIlwiKSA6IFwiXCI7XG59XG5leHBvcnRzLm5vcm1hbGl6ZUlkID0gbm9ybWFsaXplSWQ7XG5mdW5jdGlvbiByZXNvbHZlVXJsKGJhc2VJZCwgaWQpIHtcbiAgICBpZCA9IG5vcm1hbGl6ZUlkKGlkKTtcbiAgICByZXR1cm4gVVJJLnJlc29sdmUoYmFzZUlkLCBpZCk7XG59XG5leHBvcnRzLnJlc29sdmVVcmwgPSByZXNvbHZlVXJsO1xuY29uc3QgQU5DSE9SID0gL15bYS16X11bLWEtejAtOS5fXSokL2k7XG5mdW5jdGlvbiBnZXRTY2hlbWFSZWZzKHNjaGVtYSkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4ge307XG4gICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgIGNvbnN0IHNjaElkID0gbm9ybWFsaXplSWQoc2NoZW1hW3NjaGVtYUlkXSk7XG4gICAgY29uc3QgYmFzZUlkcyA9IHsgXCJcIjogc2NoSWQgfTtcbiAgICBjb25zdCBwYXRoUHJlZml4ID0gZ2V0RnVsbFBhdGgoc2NoSWQsIGZhbHNlKTtcbiAgICBjb25zdCBsb2NhbFJlZnMgPSB7fTtcbiAgICBjb25zdCBzY2hlbWFSZWZzID0gbmV3IFNldCgpO1xuICAgIHRyYXZlcnNlKHNjaGVtYSwgeyBhbGxLZXlzOiB0cnVlIH0sIChzY2gsIGpzb25QdHIsIF8sIHBhcmVudEpzb25QdHIpID0+IHtcbiAgICAgICAgaWYgKHBhcmVudEpzb25QdHIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoUHJlZml4ICsganNvblB0cjtcbiAgICAgICAgbGV0IGJhc2VJZCA9IGJhc2VJZHNbcGFyZW50SnNvblB0cl07XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoW3NjaGVtYUlkXSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgYmFzZUlkID0gYWRkUmVmLmNhbGwodGhpcywgc2NoW3NjaGVtYUlkXSk7XG4gICAgICAgIGFkZEFuY2hvci5jYWxsKHRoaXMsIHNjaC4kYW5jaG9yKTtcbiAgICAgICAgYWRkQW5jaG9yLmNhbGwodGhpcywgc2NoLiRkeW5hbWljQW5jaG9yKTtcbiAgICAgICAgYmFzZUlkc1tqc29uUHRyXSA9IGJhc2VJZDtcbiAgICAgICAgZnVuY3Rpb24gYWRkUmVmKHJlZikge1xuICAgICAgICAgICAgcmVmID0gbm9ybWFsaXplSWQoYmFzZUlkID8gVVJJLnJlc29sdmUoYmFzZUlkLCByZWYpIDogcmVmKTtcbiAgICAgICAgICAgIGlmIChzY2hlbWFSZWZzLmhhcyhyZWYpKVxuICAgICAgICAgICAgICAgIHRocm93IGFtYmlndW9zKHJlZik7XG4gICAgICAgICAgICBzY2hlbWFSZWZzLmFkZChyZWYpO1xuICAgICAgICAgICAgbGV0IHNjaE9yUmVmID0gdGhpcy5yZWZzW3JlZl07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaE9yUmVmID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgc2NoT3JSZWYgPSB0aGlzLnJlZnNbc2NoT3JSZWZdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hPclJlZiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tBbWJpZ3Vvc1JlZihzY2gsIHNjaE9yUmVmLnNjaGVtYSwgcmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlZiAhPT0gbm9ybWFsaXplSWQoZnVsbFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZlswXSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tBbWJpZ3Vvc1JlZihzY2gsIGxvY2FsUmVmc1tyZWZdLCByZWYpO1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFJlZnNbcmVmXSA9IHNjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmc1tyZWZdID0gZnVsbFBhdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlZjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRBbmNob3IoYW5jaG9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFuY2hvciA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBTkNIT1IudGVzdChhbmNob3IpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgYW5jaG9yIFwiJHthbmNob3J9XCJgKTtcbiAgICAgICAgICAgICAgICBhZGRSZWYuY2FsbCh0aGlzLCBgIyR7YW5jaG9yfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGxvY2FsUmVmcztcbiAgICBmdW5jdGlvbiBjaGVja0FtYmlndW9zUmVmKHNjaDEsIHNjaDIsIHJlZikge1xuICAgICAgICBpZiAoc2NoMiAhPT0gdW5kZWZpbmVkICYmICFlcXVhbChzY2gxLCBzY2gyKSlcbiAgICAgICAgICAgIHRocm93IGFtYmlndW9zKHJlZik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFtYmlndW9zKHJlZikge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKGByZWZlcmVuY2UgXCIke3JlZn1cIiByZXNvbHZlcyB0byBtb3JlIHRoYW4gb25lIHNjaGVtYWApO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0U2NoZW1hUmVmcyA9IGdldFNjaGVtYVJlZnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXREYXRhID0gZXhwb3J0cy5LZXl3b3JkQ3h0ID0gZXhwb3J0cy52YWxpZGF0ZUZ1bmN0aW9uQ29kZSA9IHZvaWQgMDtcbmNvbnN0IGJvb2xTY2hlbWFfMSA9IHJlcXVpcmUoXCIuL2Jvb2xTY2hlbWFcIik7XG5jb25zdCBkYXRhVHlwZV8xID0gcmVxdWlyZShcIi4vZGF0YVR5cGVcIik7XG5jb25zdCBhcHBsaWNhYmlsaXR5XzEgPSByZXF1aXJlKFwiLi9hcHBsaWNhYmlsaXR5XCIpO1xuY29uc3QgZGF0YVR5cGVfMiA9IHJlcXVpcmUoXCIuL2RhdGFUeXBlXCIpO1xuY29uc3QgZGVmYXVsdHNfMSA9IHJlcXVpcmUoXCIuL2RlZmF1bHRzXCIpO1xuY29uc3Qga2V5d29yZF8xID0gcmVxdWlyZShcIi4va2V5d29yZFwiKTtcbmNvbnN0IHN1YnNjaGVtYV8xID0gcmVxdWlyZShcIi4vc3Vic2NoZW1hXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uL25hbWVzXCIpO1xuY29uc3QgcmVzb2x2ZV8xID0gcmVxdWlyZShcIi4uL3Jlc29sdmVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbi8vIHNjaGVtYSBjb21waWxhdGlvbiAtIGdlbmVyYXRlcyB2YWxpZGF0aW9uIGZ1bmN0aW9uLCBzdWJzY2hlbWFDb2RlIChiZWxvdykgaXMgdXNlZCBmb3Igc3Vic2NoZW1hc1xuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvZGUoaXQpIHtcbiAgICBpZiAoaXNTY2hlbWFPYmooaXQpKSB7XG4gICAgICAgIGNoZWNrS2V5d29yZHMoaXQpO1xuICAgICAgICBpZiAoc2NoZW1hQ3h0SGFzUnVsZXMoaXQpKSB7XG4gICAgICAgICAgICB0b3BTY2hlbWFPYmpDb2RlKGl0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YWxpZGF0ZUZ1bmN0aW9uKGl0LCAoKSA9PiBib29sU2NoZW1hXzEudG9wQm9vbE9yRW1wdHlTY2hlbWEoaXQpKTtcbn1cbmV4cG9ydHMudmFsaWRhdGVGdW5jdGlvbkNvZGUgPSB2YWxpZGF0ZUZ1bmN0aW9uQ29kZTtcbmZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb24oeyBnZW4sIHZhbGlkYXRlTmFtZSwgc2NoZW1hLCBzY2hlbWFFbnYsIG9wdHMgfSwgYm9keSkge1xuICAgIGlmIChvcHRzLmNvZGUuZXM1KSB7XG4gICAgICAgIGdlbi5mdW5jKHZhbGlkYXRlTmFtZSwgY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LmRhdGF9LCAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9YCwgc2NoZW1hRW52LiRhc3luYywgKCkgPT4ge1xuICAgICAgICAgICAgZ2VuLmNvZGUoY29kZWdlbl8xLl8gYFwidXNlIHN0cmljdFwiOyAke2Z1bmNTb3VyY2VVcmwoc2NoZW1hLCBvcHRzKX1gKTtcbiAgICAgICAgICAgIGRlc3RydWN0dXJlVmFsQ3h0RVM1KGdlbiwgb3B0cyk7XG4gICAgICAgICAgICBnZW4uY29kZShib2R5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW4uZnVuYyh2YWxpZGF0ZU5hbWUsIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC5kYXRhfSwgJHtkZXN0cnVjdHVyZVZhbEN4dChvcHRzKX1gLCBzY2hlbWFFbnYuJGFzeW5jLCAoKSA9PiBnZW4uY29kZShmdW5jU291cmNlVXJsKHNjaGVtYSwgb3B0cykpLmNvZGUoYm9keSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlc3RydWN0dXJlVmFsQ3h0KG9wdHMpIHtcbiAgICByZXR1cm4gY29kZWdlbl8xLl8gYHske25hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGh9PVwiXCIsICR7bmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGF9LCAke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHl9LCAke25hbWVzXzEuZGVmYXVsdC5yb290RGF0YX09JHtuYW1lc18xLmRlZmF1bHQuZGF0YX0ke29wdHMuZHluYW1pY1JlZiA/IGNvZGVnZW5fMS5fIGAsICR7bmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzfT17fWAgOiBjb2RlZ2VuXzEubmlsfX09e31gO1xufVxuZnVuY3Rpb24gZGVzdHJ1Y3R1cmVWYWxDeHRFUzUoZ2VuLCBvcHRzKSB7XG4gICAgZ2VuLmlmKG5hbWVzXzEuZGVmYXVsdC52YWxDeHQsICgpID0+IHtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fS4ke25hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGh9YCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGEsIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGF9YCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSwgY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5fWApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5yb290RGF0YSwgY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQucm9vdERhdGF9YCk7XG4gICAgICAgIGlmIChvcHRzLmR5bmFtaWNSZWYpXG4gICAgICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9ycywgY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnN9YCk7XG4gICAgfSwgKCkgPT4ge1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsIGNvZGVnZW5fMS5fIGBcIlwiYCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGEsIGNvZGVnZW5fMS5fIGB1bmRlZmluZWRgKTtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5LCBjb2RlZ2VuXzEuXyBgdW5kZWZpbmVkYCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhLCBuYW1lc18xLmRlZmF1bHQuZGF0YSk7XG4gICAgICAgIGlmIChvcHRzLmR5bmFtaWNSZWYpXG4gICAgICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9ycywgY29kZWdlbl8xLl8gYHt9YCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB0b3BTY2hlbWFPYmpDb2RlKGl0KSB7XG4gICAgY29uc3QgeyBzY2hlbWEsIG9wdHMsIGdlbiB9ID0gaXQ7XG4gICAgdmFsaWRhdGVGdW5jdGlvbihpdCwgKCkgPT4ge1xuICAgICAgICBpZiAob3B0cy4kY29tbWVudCAmJiBzY2hlbWEuJGNvbW1lbnQpXG4gICAgICAgICAgICBjb21tZW50S2V5d29yZChpdCk7XG4gICAgICAgIGNoZWNrTm9EZWZhdWx0KGl0KTtcbiAgICAgICAgZ2VuLmxldChuYW1lc18xLmRlZmF1bHQudkVycm9ycywgbnVsbCk7XG4gICAgICAgIGdlbi5sZXQobmFtZXNfMS5kZWZhdWx0LmVycm9ycywgMCk7XG4gICAgICAgIGlmIChvcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICAgICAgcmVzZXRFdmFsdWF0ZWQoaXQpO1xuICAgICAgICB0eXBlQW5kS2V5d29yZHMoaXQpO1xuICAgICAgICByZXR1cm5SZXN1bHRzKGl0KTtcbiAgICB9KTtcbiAgICByZXR1cm47XG59XG5mdW5jdGlvbiByZXNldEV2YWx1YXRlZChpdCkge1xuICAgIC8vIFRPRE8gbWF5YmUgc29tZSBob29rIHRvIGV4ZWN1dGUgaXQgaW4gdGhlIGVuZCB0byBjaGVjayB3aGV0aGVyIHByb3BzL2l0ZW1zIGFyZSBOYW1lLCBhcyBpbiBhc3NpZ25FdmFsdWF0ZWRcbiAgICBjb25zdCB7IGdlbiwgdmFsaWRhdGVOYW1lIH0gPSBpdDtcbiAgICBpdC5ldmFsdWF0ZWQgPSBnZW4uY29uc3QoXCJldmFsdWF0ZWRcIiwgY29kZWdlbl8xLl8gYCR7dmFsaWRhdGVOYW1lfS5ldmFsdWF0ZWRgKTtcbiAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7aXQuZXZhbHVhdGVkfS5keW5hbWljUHJvcHNgLCAoKSA9PiBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke2l0LmV2YWx1YXRlZH0ucHJvcHNgLCBjb2RlZ2VuXzEuXyBgdW5kZWZpbmVkYCkpO1xuICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtpdC5ldmFsdWF0ZWR9LmR5bmFtaWNJdGVtc2AsICgpID0+IGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7aXQuZXZhbHVhdGVkfS5pdGVtc2AsIGNvZGVnZW5fMS5fIGB1bmRlZmluZWRgKSk7XG59XG5mdW5jdGlvbiBmdW5jU291cmNlVXJsKHNjaGVtYSwgb3B0cykge1xuICAgIGNvbnN0IHNjaElkID0gdHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmIHNjaGVtYVtvcHRzLnNjaGVtYUlkXTtcbiAgICByZXR1cm4gc2NoSWQgJiYgKG9wdHMuY29kZS5zb3VyY2UgfHwgb3B0cy5jb2RlLnByb2Nlc3MpID8gY29kZWdlbl8xLl8gYC8qIyBzb3VyY2VVUkw9JHtzY2hJZH0gKi9gIDogY29kZWdlbl8xLm5pbDtcbn1cbi8vIHNjaGVtYSBjb21waWxhdGlvbiAtIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCByZWN1cnNpdmVseSB0byBnZW5lcmF0ZSBjb2RlIGZvciBzdWItc2NoZW1hc1xuZnVuY3Rpb24gc3Vic2NoZW1hQ29kZShpdCwgdmFsaWQpIHtcbiAgICBpZiAoaXNTY2hlbWFPYmooaXQpKSB7XG4gICAgICAgIGNoZWNrS2V5d29yZHMoaXQpO1xuICAgICAgICBpZiAoc2NoZW1hQ3h0SGFzUnVsZXMoaXQpKSB7XG4gICAgICAgICAgICBzdWJTY2hlbWFPYmpDb2RlKGl0LCB2YWxpZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgYm9vbFNjaGVtYV8xLmJvb2xPckVtcHR5U2NoZW1hKGl0LCB2YWxpZCk7XG59XG5mdW5jdGlvbiBzY2hlbWFDeHRIYXNSdWxlcyh7IHNjaGVtYSwgc2VsZiB9KSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiAhc2NoZW1hO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSlcbiAgICAgICAgaWYgKHNlbGYuUlVMRVMuYWxsW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1NjaGVtYU9iaihpdCkge1xuICAgIHJldHVybiB0eXBlb2YgaXQuc2NoZW1hICE9IFwiYm9vbGVhblwiO1xufVxuZnVuY3Rpb24gc3ViU2NoZW1hT2JqQ29kZShpdCwgdmFsaWQpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgZ2VuLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAob3B0cy4kY29tbWVudCAmJiBzY2hlbWEuJGNvbW1lbnQpXG4gICAgICAgIGNvbW1lbnRLZXl3b3JkKGl0KTtcbiAgICB1cGRhdGVDb250ZXh0KGl0KTtcbiAgICBjaGVja0FzeW5jU2NoZW1hKGl0KTtcbiAgICBjb25zdCBlcnJzQ291bnQgPSBnZW4uY29uc3QoXCJfZXJyc1wiLCBuYW1lc18xLmRlZmF1bHQuZXJyb3JzKTtcbiAgICB0eXBlQW5kS2V5d29yZHMoaXQsIGVycnNDb3VudCk7XG4gICAgLy8gVE9ETyB2YXJcbiAgICBnZW4udmFyKHZhbGlkLCBjb2RlZ2VuXzEuXyBgJHtlcnJzQ291bnR9ID09PSAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9YCk7XG59XG5mdW5jdGlvbiBjaGVja0tleXdvcmRzKGl0KSB7XG4gICAgdXRpbF8xLmNoZWNrVW5rbm93blJ1bGVzKGl0KTtcbiAgICBjaGVja1JlZnNBbmRLZXl3b3JkcyhpdCk7XG59XG5mdW5jdGlvbiB0eXBlQW5kS2V5d29yZHMoaXQsIGVycnNDb3VudCkge1xuICAgIGlmIChpdC5vcHRzLmp0ZClcbiAgICAgICAgcmV0dXJuIHNjaGVtYUtleXdvcmRzKGl0LCBbXSwgZmFsc2UsIGVycnNDb3VudCk7XG4gICAgY29uc3QgdHlwZXMgPSBkYXRhVHlwZV8xLmdldFNjaGVtYVR5cGVzKGl0LnNjaGVtYSk7XG4gICAgY29uc3QgY2hlY2tlZFR5cGVzID0gZGF0YVR5cGVfMS5jb2VyY2VBbmRDaGVja0RhdGFUeXBlKGl0LCB0eXBlcyk7XG4gICAgc2NoZW1hS2V5d29yZHMoaXQsIHR5cGVzLCAhY2hlY2tlZFR5cGVzLCBlcnJzQ291bnQpO1xufVxuZnVuY3Rpb24gY2hlY2tSZWZzQW5kS2V5d29yZHMoaXQpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgZXJyU2NoZW1hUGF0aCwgb3B0cywgc2VsZiB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYS4kcmVmICYmIG9wdHMuaWdub3JlS2V5d29yZHNXaXRoUmVmICYmIHV0aWxfMS5zY2hlbWFIYXNSdWxlc0J1dFJlZihzY2hlbWEsIHNlbGYuUlVMRVMpKSB7XG4gICAgICAgIHNlbGYubG9nZ2VyLndhcm4oYCRyZWY6IGtleXdvcmRzIGlnbm9yZWQgaW4gc2NoZW1hIGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCJgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja05vRGVmYXVsdChpdCkge1xuICAgIGNvbnN0IHsgc2NoZW1hLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hLmRlZmF1bHQgIT09IHVuZGVmaW5lZCAmJiBvcHRzLnVzZURlZmF1bHRzICYmIG9wdHMuc3RyaWN0U2NoZW1hKSB7XG4gICAgICAgIHV0aWxfMS5jaGVja1N0cmljdE1vZGUoaXQsIFwiZGVmYXVsdCBpcyBpZ25vcmVkIGluIHRoZSBzY2hlbWEgcm9vdFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0KGl0KSB7XG4gICAgY29uc3Qgc2NoSWQgPSBpdC5zY2hlbWFbaXQub3B0cy5zY2hlbWFJZF07XG4gICAgaWYgKHNjaElkKVxuICAgICAgICBpdC5iYXNlSWQgPSByZXNvbHZlXzEucmVzb2x2ZVVybChpdC5iYXNlSWQsIHNjaElkKTtcbn1cbmZ1bmN0aW9uIGNoZWNrQXN5bmNTY2hlbWEoaXQpIHtcbiAgICBpZiAoaXQuc2NoZW1hLiRhc3luYyAmJiAhaXQuc2NoZW1hRW52LiRhc3luYylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMgc2NoZW1hIGluIHN5bmMgc2NoZW1hXCIpO1xufVxuZnVuY3Rpb24gY29tbWVudEtleXdvcmQoeyBnZW4sIHNjaGVtYUVudiwgc2NoZW1hLCBlcnJTY2hlbWFQYXRoLCBvcHRzIH0pIHtcbiAgICBjb25zdCBtc2cgPSBzY2hlbWEuJGNvbW1lbnQ7XG4gICAgaWYgKG9wdHMuJGNvbW1lbnQgPT09IHRydWUpIHtcbiAgICAgICAgZ2VuLmNvZGUoY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnNlbGZ9LmxvZ2dlci5sb2coJHttc2d9KWApO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb3B0cy4kY29tbWVudCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hUGF0aCA9IGNvZGVnZW5fMS5zdHIgYCR7ZXJyU2NoZW1hUGF0aH0vJGNvbW1lbnRgO1xuICAgICAgICBjb25zdCByb290TmFtZSA9IGdlbi5zY29wZVZhbHVlKFwicm9vdFwiLCB7IHJlZjogc2NoZW1hRW52LnJvb3QgfSk7XG4gICAgICAgIGdlbi5jb2RlKGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC5zZWxmfS5vcHRzLiRjb21tZW50KCR7bXNnfSwgJHtzY2hlbWFQYXRofSwgJHtyb290TmFtZX0uc2NoZW1hKWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJldHVyblJlc3VsdHMoaXQpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hRW52LCB2YWxpZGF0ZU5hbWUsIFZhbGlkYXRpb25FcnJvciwgb3B0cyB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYUVudi4kYXN5bmMpIHtcbiAgICAgICAgLy8gVE9ETyBhc3NpZ24gdW5ldmFsdWF0ZWRcbiAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9ID09PSAwYCwgKCkgPT4gZ2VuLnJldHVybihuYW1lc18xLmRlZmF1bHQuZGF0YSksICgpID0+IGdlbi50aHJvdyhjb2RlZ2VuXzEuXyBgbmV3ICR7VmFsaWRhdGlvbkVycm9yfSgke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfSlgKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke3ZhbGlkYXRlTmFtZX0uZXJyb3JzYCwgbmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMpO1xuICAgICAgICBpZiAob3B0cy51bmV2YWx1YXRlZClcbiAgICAgICAgICAgIGFzc2lnbkV2YWx1YXRlZChpdCk7XG4gICAgICAgIGdlbi5yZXR1cm4oY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc30gPT09IDBgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NpZ25FdmFsdWF0ZWQoeyBnZW4sIGV2YWx1YXRlZCwgcHJvcHMsIGl0ZW1zIH0pIHtcbiAgICBpZiAocHJvcHMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSlcbiAgICAgICAgZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHtldmFsdWF0ZWR9LnByb3BzYCwgcHJvcHMpO1xuICAgIGlmIChpdGVtcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKVxuICAgICAgICBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke2V2YWx1YXRlZH0uaXRlbXNgLCBpdGVtcyk7XG59XG5mdW5jdGlvbiBzY2hlbWFLZXl3b3JkcyhpdCwgdHlwZXMsIHR5cGVFcnJvcnMsIGVycnNDb3VudCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGRhdGEsIGFsbEVycm9ycywgb3B0cywgc2VsZiB9ID0gaXQ7XG4gICAgY29uc3QgeyBSVUxFUyB9ID0gc2VsZjtcbiAgICBpZiAoc2NoZW1hLiRyZWYgJiYgKG9wdHMuaWdub3JlS2V5d29yZHNXaXRoUmVmIHx8ICF1dGlsXzEuc2NoZW1hSGFzUnVsZXNCdXRSZWYoc2NoZW1hLCBSVUxFUykpKSB7XG4gICAgICAgIGdlbi5ibG9jaygoKSA9PiBrZXl3b3JkQ29kZShpdCwgXCIkcmVmXCIsIFJVTEVTLmFsbC4kcmVmLmRlZmluaXRpb24pKTsgLy8gVE9ETyB0eXBlY2FzdFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghb3B0cy5qdGQpXG4gICAgICAgIGNoZWNrU3RyaWN0VHlwZXMoaXQsIHR5cGVzKTtcbiAgICBnZW4uYmxvY2soKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIFJVTEVTLnJ1bGVzKVxuICAgICAgICAgICAgZ3JvdXBLZXl3b3Jkcyhncm91cCk7XG4gICAgICAgIGdyb3VwS2V5d29yZHMoUlVMRVMucG9zdCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gZ3JvdXBLZXl3b3Jkcyhncm91cCkge1xuICAgICAgICBpZiAoIWFwcGxpY2FiaWxpdHlfMS5zaG91bGRVc2VHcm91cChzY2hlbWEsIGdyb3VwKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGdyb3VwLnR5cGUpIHtcbiAgICAgICAgICAgIGdlbi5pZihkYXRhVHlwZV8yLmNoZWNrRGF0YVR5cGUoZ3JvdXAudHlwZSwgZGF0YSwgb3B0cy5zdHJpY3ROdW1iZXJzKSk7XG4gICAgICAgICAgICBpdGVyYXRlS2V5d29yZHMoaXQsIGdyb3VwKTtcbiAgICAgICAgICAgIGlmICh0eXBlcy5sZW5ndGggPT09IDEgJiYgdHlwZXNbMF0gPT09IGdyb3VwLnR5cGUgJiYgdHlwZUVycm9ycykge1xuICAgICAgICAgICAgICAgIGdlbi5lbHNlKCk7XG4gICAgICAgICAgICAgICAgZGF0YVR5cGVfMi5yZXBvcnRUeXBlRXJyb3IoaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVyYXRlS2V5d29yZHMoaXQsIGdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIG1ha2UgaXQgXCJva1wiIGNhbGw/XG4gICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9ID09PSAke2VycnNDb3VudCB8fCAwfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGl0ZXJhdGVLZXl3b3JkcyhpdCwgZ3JvdXApIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBvcHRzOiB7IHVzZURlZmF1bHRzIH0sIH0gPSBpdDtcbiAgICBpZiAodXNlRGVmYXVsdHMpXG4gICAgICAgIGRlZmF1bHRzXzEuYXNzaWduRGVmYXVsdHMoaXQsIGdyb3VwLnR5cGUpO1xuICAgIGdlbi5ibG9jaygoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgcnVsZSBvZiBncm91cC5ydWxlcykge1xuICAgICAgICAgICAgaWYgKGFwcGxpY2FiaWxpdHlfMS5zaG91bGRVc2VSdWxlKHNjaGVtYSwgcnVsZSkpIHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkQ29kZShpdCwgcnVsZS5rZXl3b3JkLCBydWxlLmRlZmluaXRpb24sIGdyb3VwLnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjaGVja1N0cmljdFR5cGVzKGl0LCB0eXBlcykge1xuICAgIGlmIChpdC5zY2hlbWFFbnYubWV0YSB8fCAhaXQub3B0cy5zdHJpY3RUeXBlcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGNoZWNrQ29udGV4dFR5cGVzKGl0LCB0eXBlcyk7XG4gICAgaWYgKCFpdC5vcHRzLmFsbG93VW5pb25UeXBlcylcbiAgICAgICAgY2hlY2tNdWx0aXBsZVR5cGVzKGl0LCB0eXBlcyk7XG4gICAgY2hlY2tLZXl3b3JkVHlwZXMoaXQsIGl0LmRhdGFUeXBlcyk7XG59XG5mdW5jdGlvbiBjaGVja0NvbnRleHRUeXBlcyhpdCwgdHlwZXMpIHtcbiAgICBpZiAoIXR5cGVzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghaXQuZGF0YVR5cGVzLmxlbmd0aCkge1xuICAgICAgICBpdC5kYXRhVHlwZXMgPSB0eXBlcztcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0eXBlcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgIGlmICghaW5jbHVkZXNUeXBlKGl0LmRhdGFUeXBlcywgdCkpIHtcbiAgICAgICAgICAgIHN0cmljdFR5cGVzRXJyb3IoaXQsIGB0eXBlIFwiJHt0fVwiIG5vdCBhbGxvd2VkIGJ5IGNvbnRleHQgXCIke2l0LmRhdGFUeXBlcy5qb2luKFwiLFwiKX1cImApO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaXQuZGF0YVR5cGVzID0gaXQuZGF0YVR5cGVzLmZpbHRlcigodCkgPT4gaW5jbHVkZXNUeXBlKHR5cGVzLCB0KSk7XG59XG5mdW5jdGlvbiBjaGVja011bHRpcGxlVHlwZXMoaXQsIHRzKSB7XG4gICAgaWYgKHRzLmxlbmd0aCA+IDEgJiYgISh0cy5sZW5ndGggPT09IDIgJiYgdHMuaW5jbHVkZXMoXCJudWxsXCIpKSkge1xuICAgICAgICBzdHJpY3RUeXBlc0Vycm9yKGl0LCBcInVzZSBhbGxvd1VuaW9uVHlwZXMgdG8gYWxsb3cgdW5pb24gdHlwZSBrZXl3b3JkXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrS2V5d29yZFR5cGVzKGl0LCB0cykge1xuICAgIGNvbnN0IHJ1bGVzID0gaXQuc2VsZi5SVUxFUy5hbGw7XG4gICAgZm9yIChjb25zdCBrZXl3b3JkIGluIHJ1bGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSBydWxlc1trZXl3b3JkXTtcbiAgICAgICAgaWYgKHR5cGVvZiBydWxlID09IFwib2JqZWN0XCIgJiYgYXBwbGljYWJpbGl0eV8xLnNob3VsZFVzZVJ1bGUoaXQuc2NoZW1hLCBydWxlKSkge1xuICAgICAgICAgICAgY29uc3QgeyB0eXBlIH0gPSBydWxlLmRlZmluaXRpb247XG4gICAgICAgICAgICBpZiAodHlwZS5sZW5ndGggJiYgIXR5cGUuc29tZSgodCkgPT4gaGFzQXBwbGljYWJsZVR5cGUodHMsIHQpKSkge1xuICAgICAgICAgICAgICAgIHN0cmljdFR5cGVzRXJyb3IoaXQsIGBtaXNzaW5nIHR5cGUgXCIke3R5cGUuam9pbihcIixcIil9XCIgZm9yIGtleXdvcmQgXCIke2tleXdvcmR9XCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGhhc0FwcGxpY2FibGVUeXBlKHNjaFRzLCBrd2RUKSB7XG4gICAgcmV0dXJuIHNjaFRzLmluY2x1ZGVzKGt3ZFQpIHx8IChrd2RUID09PSBcIm51bWJlclwiICYmIHNjaFRzLmluY2x1ZGVzKFwiaW50ZWdlclwiKSk7XG59XG5mdW5jdGlvbiBpbmNsdWRlc1R5cGUodHMsIHQpIHtcbiAgICByZXR1cm4gdHMuaW5jbHVkZXModCkgfHwgKHQgPT09IFwiaW50ZWdlclwiICYmIHRzLmluY2x1ZGVzKFwibnVtYmVyXCIpKTtcbn1cbmZ1bmN0aW9uIHN0cmljdFR5cGVzRXJyb3IoaXQsIG1zZykge1xuICAgIGNvbnN0IHNjaGVtYVBhdGggPSBpdC5zY2hlbWFFbnYuYmFzZUlkICsgaXQuZXJyU2NoZW1hUGF0aDtcbiAgICBtc2cgKz0gYCBhdCBcIiR7c2NoZW1hUGF0aH1cIiAoc3RyaWN0VHlwZXMpYDtcbiAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCBtc2csIGl0Lm9wdHMuc3RyaWN0VHlwZXMpO1xufVxuY2xhc3MgS2V5d29yZEN4dCB7XG4gICAgY29uc3RydWN0b3IoaXQsIGRlZiwga2V5d29yZCkge1xuICAgICAgICBrZXl3b3JkXzEudmFsaWRhdGVLZXl3b3JkVXNhZ2UoaXQsIGRlZiwga2V5d29yZCk7XG4gICAgICAgIHRoaXMuZ2VuID0gaXQuZ2VuO1xuICAgICAgICB0aGlzLmFsbEVycm9ycyA9IGl0LmFsbEVycm9ycztcbiAgICAgICAgdGhpcy5rZXl3b3JkID0ga2V5d29yZDtcbiAgICAgICAgdGhpcy5kYXRhID0gaXQuZGF0YTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBpdC5zY2hlbWFba2V5d29yZF07XG4gICAgICAgIHRoaXMuJGRhdGEgPSBkZWYuJGRhdGEgJiYgaXQub3B0cy4kZGF0YSAmJiB0aGlzLnNjaGVtYSAmJiB0aGlzLnNjaGVtYS4kZGF0YTtcbiAgICAgICAgdGhpcy5zY2hlbWFWYWx1ZSA9IHV0aWxfMS5zY2hlbWFSZWZPclZhbChpdCwgdGhpcy5zY2hlbWEsIGtleXdvcmQsIHRoaXMuJGRhdGEpO1xuICAgICAgICB0aGlzLnNjaGVtYVR5cGUgPSBkZWYuc2NoZW1hVHlwZTtcbiAgICAgICAgdGhpcy5wYXJlbnRTY2hlbWEgPSBpdC5zY2hlbWE7XG4gICAgICAgIHRoaXMucGFyYW1zID0ge307XG4gICAgICAgIHRoaXMuaXQgPSBpdDtcbiAgICAgICAgdGhpcy5kZWYgPSBkZWY7XG4gICAgICAgIGlmICh0aGlzLiRkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVtYUNvZGUgPSBpdC5nZW4uY29uc3QoXCJ2U2NoZW1hXCIsIGdldERhdGEodGhpcy4kZGF0YSwgaXQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hQ29kZSA9IHRoaXMuc2NoZW1hVmFsdWU7XG4gICAgICAgICAgICBpZiAoIWtleXdvcmRfMS52YWxpZFNjaGVtYVR5cGUodGhpcy5zY2hlbWEsIGRlZi5zY2hlbWFUeXBlLCBkZWYuYWxsb3dVbmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2tleXdvcmR9IHZhbHVlIG11c3QgYmUgJHtKU09OLnN0cmluZ2lmeShkZWYuc2NoZW1hVHlwZSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiY29kZVwiIGluIGRlZiA/IGRlZi50cmFja0Vycm9ycyA6IGRlZi5lcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLmVycnNDb3VudCA9IGl0Lmdlbi5jb25zdChcIl9lcnJzXCIsIG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VsdChjb25kaXRpb24sIHN1Y2Nlc3NBY3Rpb24sIGZhaWxBY3Rpb24pIHtcbiAgICAgICAgdGhpcy5mYWlsUmVzdWx0KGNvZGVnZW5fMS5ub3QoY29uZGl0aW9uKSwgc3VjY2Vzc0FjdGlvbiwgZmFpbEFjdGlvbik7XG4gICAgfVxuICAgIGZhaWxSZXN1bHQoY29uZGl0aW9uLCBzdWNjZXNzQWN0aW9uLCBmYWlsQWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZ2VuLmlmKGNvbmRpdGlvbik7XG4gICAgICAgIGlmIChmYWlsQWN0aW9uKVxuICAgICAgICAgICAgZmFpbEFjdGlvbigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmVycm9yKCk7XG4gICAgICAgIGlmIChzdWNjZXNzQWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmdlbi5lbHNlKCk7XG4gICAgICAgICAgICBzdWNjZXNzQWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5nZW4uZW5kSWYoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbEVycm9ycylcbiAgICAgICAgICAgICAgICB0aGlzLmdlbi5lbmRJZigpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuLmVsc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXNzKGNvbmRpdGlvbiwgZmFpbEFjdGlvbikge1xuICAgICAgICB0aGlzLmZhaWxSZXN1bHQoY29kZWdlbl8xLm5vdChjb25kaXRpb24pLCB1bmRlZmluZWQsIGZhaWxBY3Rpb24pO1xuICAgIH1cbiAgICBmYWlsKGNvbmRpdGlvbikge1xuICAgICAgICBpZiAoY29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5nZW4uaWYoZmFsc2UpOyAvLyB0aGlzIGJyYW5jaCB3aWxsIGJlIHJlbW92ZWQgYnkgZ2VuLm9wdGltaXplXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZW4uaWYoY29uZGl0aW9uKTtcbiAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgICBpZiAodGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICB0aGlzLmdlbi5lbmRJZigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmdlbi5lbHNlKCk7XG4gICAgfVxuICAgIGZhaWwkZGF0YShjb25kaXRpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLiRkYXRhKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbChjb25kaXRpb24pO1xuICAgICAgICBjb25zdCB7IHNjaGVtYUNvZGUgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZmFpbChjb2RlZ2VuXzEuXyBgJHtzY2hlbWFDb2RlfSAhPT0gdW5kZWZpbmVkICYmICgke2NvZGVnZW5fMS5vcih0aGlzLmludmFsaWQkZGF0YSgpLCBjb25kaXRpb24pfSlgKTtcbiAgICB9XG4gICAgZXJyb3IoYXBwZW5kLCBlcnJvclBhcmFtcywgZXJyb3JQYXRocykge1xuICAgICAgICBpZiAoZXJyb3JQYXJhbXMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UGFyYW1zKGVycm9yUGFyYW1zKTtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKGFwcGVuZCwgZXJyb3JQYXRocyk7XG4gICAgICAgICAgICB0aGlzLnNldFBhcmFtcyh7fSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZXJyb3IoYXBwZW5kLCBlcnJvclBhdGhzKTtcbiAgICB9XG4gICAgX2Vycm9yKGFwcGVuZCwgZXJyb3JQYXRocykge1xuICAgICAgICA7XG4gICAgICAgIChhcHBlbmQgPyBlcnJvcnNfMS5yZXBvcnRFeHRyYUVycm9yIDogZXJyb3JzXzEucmVwb3J0RXJyb3IpKHRoaXMsIHRoaXMuZGVmLmVycm9yLCBlcnJvclBhdGhzKTtcbiAgICB9XG4gICAgJGRhdGFFcnJvcigpIHtcbiAgICAgICAgZXJyb3JzXzEucmVwb3J0RXJyb3IodGhpcywgdGhpcy5kZWYuJGRhdGFFcnJvciB8fCBlcnJvcnNfMS5rZXl3b3JkJERhdGFFcnJvcik7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5lcnJzQ291bnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWRkIFwidHJhY2tFcnJvcnNcIiB0byBrZXl3b3JkIGRlZmluaXRpb24nKTtcbiAgICAgICAgZXJyb3JzXzEucmVzZXRFcnJvcnNDb3VudCh0aGlzLmdlbiwgdGhpcy5lcnJzQ291bnQpO1xuICAgIH1cbiAgICBvayhjb25kKSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICB0aGlzLmdlbi5pZihjb25kKTtcbiAgICB9XG4gICAgc2V0UGFyYW1zKG9iaiwgYXNzaWduKSB7XG4gICAgICAgIGlmIChhc3NpZ24pXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMucGFyYW1zLCBvYmopO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnBhcmFtcyA9IG9iajtcbiAgICB9XG4gICAgYmxvY2skZGF0YSh2YWxpZCwgY29kZUJsb2NrLCAkZGF0YVZhbGlkID0gY29kZWdlbl8xLm5pbCkge1xuICAgICAgICB0aGlzLmdlbi5ibG9jaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrJGRhdGEodmFsaWQsICRkYXRhVmFsaWQpO1xuICAgICAgICAgICAgY29kZUJsb2NrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjaGVjayRkYXRhKHZhbGlkID0gY29kZWdlbl8xLm5pbCwgJGRhdGFWYWxpZCA9IGNvZGVnZW5fMS5uaWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRkYXRhKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hQ29kZSwgc2NoZW1hVHlwZSwgZGVmIH0gPSB0aGlzO1xuICAgICAgICBnZW4uaWYoY29kZWdlbl8xLm9yKGNvZGVnZW5fMS5fIGAke3NjaGVtYUNvZGV9ID09PSB1bmRlZmluZWRgLCAkZGF0YVZhbGlkKSk7XG4gICAgICAgIGlmICh2YWxpZCAhPT0gY29kZWdlbl8xLm5pbClcbiAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICBpZiAoc2NoZW1hVHlwZS5sZW5ndGggfHwgZGVmLnZhbGlkYXRlU2NoZW1hKSB7XG4gICAgICAgICAgICBnZW4uZWxzZUlmKHRoaXMuaW52YWxpZCRkYXRhKCkpO1xuICAgICAgICAgICAgdGhpcy4kZGF0YUVycm9yKCk7XG4gICAgICAgICAgICBpZiAodmFsaWQgIT09IGNvZGVnZW5fMS5uaWwpXG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGdlbi5lbHNlKCk7XG4gICAgfVxuICAgIGludmFsaWQkZGF0YSgpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYUNvZGUsIHNjaGVtYVR5cGUsIGRlZiwgaXQgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBjb2RlZ2VuXzEub3Iod3JvbmckRGF0YVR5cGUoKSwgaW52YWxpZCREYXRhU2NoZW1hKCkpO1xuICAgICAgICBmdW5jdGlvbiB3cm9uZyREYXRhVHlwZSgpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWFUeXBlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICghKHNjaGVtYUNvZGUgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdCA9IEFycmF5LmlzQXJyYXkoc2NoZW1hVHlwZSkgPyBzY2hlbWFUeXBlIDogW3NjaGVtYVR5cGVdO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgJHtkYXRhVHlwZV8yLmNoZWNrRGF0YVR5cGVzKHN0LCBzY2hlbWFDb2RlLCBpdC5vcHRzLnN0cmljdE51bWJlcnMsIGRhdGFUeXBlXzIuRGF0YVR5cGUuV3JvbmcpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLm5pbDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbnZhbGlkJERhdGFTY2hlbWEoKSB7XG4gICAgICAgICAgICBpZiAoZGVmLnZhbGlkYXRlU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVTY2hlbWFSZWYgPSBnZW4uc2NvcGVWYWx1ZShcInZhbGlkYXRlJGRhdGFcIiwgeyByZWY6IGRlZi52YWxpZGF0ZVNjaGVtYSB9KTsgLy8gVE9ETyB2YWx1ZS5jb2RlIGZvciBzdGFuZGFsb25lXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5fIGAhJHt2YWxpZGF0ZVNjaGVtYVJlZn0oJHtzY2hlbWFDb2RlfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5uaWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Vic2NoZW1hKGFwcGwsIHZhbGlkKSB7XG4gICAgICAgIGNvbnN0IHN1YnNjaGVtYSA9IHN1YnNjaGVtYV8xLmdldFN1YnNjaGVtYSh0aGlzLml0LCBhcHBsKTtcbiAgICAgICAgc3Vic2NoZW1hXzEuZXh0ZW5kU3Vic2NoZW1hRGF0YShzdWJzY2hlbWEsIHRoaXMuaXQsIGFwcGwpO1xuICAgICAgICBzdWJzY2hlbWFfMS5leHRlbmRTdWJzY2hlbWFNb2RlKHN1YnNjaGVtYSwgYXBwbCk7XG4gICAgICAgIGNvbnN0IG5leHRDb250ZXh0ID0geyAuLi50aGlzLml0LCAuLi5zdWJzY2hlbWEsIGl0ZW1zOiB1bmRlZmluZWQsIHByb3BzOiB1bmRlZmluZWQgfTtcbiAgICAgICAgc3Vic2NoZW1hQ29kZShuZXh0Q29udGV4dCwgdmFsaWQpO1xuICAgICAgICByZXR1cm4gbmV4dENvbnRleHQ7XG4gICAgfVxuICAgIG1lcmdlRXZhbHVhdGVkKHNjaGVtYUN4dCwgdG9OYW1lKSB7XG4gICAgICAgIGNvbnN0IHsgaXQsIGdlbiB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFpdC5vcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoaXQucHJvcHMgIT09IHRydWUgJiYgc2NoZW1hQ3h0LnByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgc2NoZW1hQ3h0LnByb3BzLCBpdC5wcm9wcywgdG9OYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQuaXRlbXMgIT09IHRydWUgJiYgc2NoZW1hQ3h0Lml0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgc2NoZW1hQ3h0Lml0ZW1zLCBpdC5pdGVtcywgdG9OYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtZXJnZVZhbGlkRXZhbHVhdGVkKHNjaGVtYUN4dCwgdmFsaWQpIHtcbiAgICAgICAgY29uc3QgeyBpdCwgZ2VuIH0gPSB0aGlzO1xuICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiAoaXQucHJvcHMgIT09IHRydWUgfHwgaXQuaXRlbXMgIT09IHRydWUpKSB7XG4gICAgICAgICAgICBnZW4uaWYodmFsaWQsICgpID0+IHRoaXMubWVyZ2VFdmFsdWF0ZWQoc2NoZW1hQ3h0LCBjb2RlZ2VuXzEuTmFtZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLktleXdvcmRDeHQgPSBLZXl3b3JkQ3h0O1xuZnVuY3Rpb24ga2V5d29yZENvZGUoaXQsIGtleXdvcmQsIGRlZiwgcnVsZVR5cGUpIHtcbiAgICBjb25zdCBjeHQgPSBuZXcgS2V5d29yZEN4dChpdCwgZGVmLCBrZXl3b3JkKTtcbiAgICBpZiAoXCJjb2RlXCIgaW4gZGVmKSB7XG4gICAgICAgIGRlZi5jb2RlKGN4dCwgcnVsZVR5cGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjeHQuJGRhdGEgJiYgZGVmLnZhbGlkYXRlKSB7XG4gICAgICAgIGtleXdvcmRfMS5mdW5jS2V5d29yZENvZGUoY3h0LCBkZWYpO1xuICAgIH1cbiAgICBlbHNlIGlmIChcIm1hY3JvXCIgaW4gZGVmKSB7XG4gICAgICAgIGtleXdvcmRfMS5tYWNyb0tleXdvcmRDb2RlKGN4dCwgZGVmKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVmLmNvbXBpbGUgfHwgZGVmLnZhbGlkYXRlKSB7XG4gICAgICAgIGtleXdvcmRfMS5mdW5jS2V5d29yZENvZGUoY3h0LCBkZWYpO1xuICAgIH1cbn1cbmNvbnN0IEpTT05fUE9JTlRFUiA9IC9eXFwvKD86W15+XXx+MHx+MSkqJC87XG5jb25zdCBSRUxBVElWRV9KU09OX1BPSU5URVIgPSAvXihbMC05XSspKCN8XFwvKD86W15+XXx+MHx+MSkqKT8kLztcbmZ1bmN0aW9uIGdldERhdGEoJGRhdGEsIHsgZGF0YUxldmVsLCBkYXRhTmFtZXMsIGRhdGFQYXRoQXJyIH0pIHtcbiAgICBsZXQganNvblBvaW50ZXI7XG4gICAgbGV0IGRhdGE7XG4gICAgaWYgKCRkYXRhID09PSBcIlwiKVxuICAgICAgICByZXR1cm4gbmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhO1xuICAgIGlmICgkZGF0YVswXSA9PT0gXCIvXCIpIHtcbiAgICAgICAgaWYgKCFKU09OX1BPSU5URVIudGVzdCgkZGF0YSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSlNPTi1wb2ludGVyOiAkeyRkYXRhfWApO1xuICAgICAgICBqc29uUG9pbnRlciA9ICRkYXRhO1xuICAgICAgICBkYXRhID0gbmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IFJFTEFUSVZFX0pTT05fUE9JTlRFUi5leGVjKCRkYXRhKTtcbiAgICAgICAgaWYgKCFtYXRjaGVzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEpTT04tcG9pbnRlcjogJHskZGF0YX1gKTtcbiAgICAgICAgY29uc3QgdXAgPSArbWF0Y2hlc1sxXTtcbiAgICAgICAganNvblBvaW50ZXIgPSBtYXRjaGVzWzJdO1xuICAgICAgICBpZiAoanNvblBvaW50ZXIgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICBpZiAodXAgPj0gZGF0YUxldmVsKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyhcInByb3BlcnR5L2luZGV4XCIsIHVwKSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVBhdGhBcnJbZGF0YUxldmVsIC0gdXBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cCA+IGRhdGFMZXZlbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyhcImRhdGFcIiwgdXApKTtcbiAgICAgICAgZGF0YSA9IGRhdGFOYW1lc1tkYXRhTGV2ZWwgLSB1cF07XG4gICAgICAgIGlmICghanNvblBvaW50ZXIpXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgbGV0IGV4cHIgPSBkYXRhO1xuICAgIGNvbnN0IHNlZ21lbnRzID0ganNvblBvaW50ZXIuc3BsaXQoXCIvXCIpO1xuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICAgICAgZGF0YSA9IGNvZGVnZW5fMS5fIGAke2RhdGF9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkodXRpbF8xLnVuZXNjYXBlSnNvblBvaW50ZXIoc2VnbWVudCkpfWA7XG4gICAgICAgICAgICBleHByID0gY29kZWdlbl8xLl8gYCR7ZXhwcn0gJiYgJHtkYXRhfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4cHI7XG4gICAgZnVuY3Rpb24gZXJyb3JNc2cocG9pbnRlclR5cGUsIHVwKSB7XG4gICAgICAgIHJldHVybiBgQ2Fubm90IGFjY2VzcyAke3BvaW50ZXJUeXBlfSAke3VwfSBsZXZlbHMgdXAsIGN1cnJlbnQgbGV2ZWwgaXMgJHtkYXRhTGV2ZWx9YDtcbiAgICB9XG59XG5leHBvcnRzLmdldERhdGEgPSBnZXREYXRhO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZXJyb3JzKSB7XG4gICAgICAgIHN1cGVyKFwidmFsaWRhdGlvbiBmYWlsZWRcIik7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aGlzLmFqdiA9IHRoaXMudmFsaWRhdGlvbiA9IHRydWU7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gVmFsaWRhdGlvbkVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdGlvbl9lcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJlc29sdmVfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVcIik7XG5jbGFzcyBNaXNzaW5nUmVmRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoYmFzZUlkLCByZWYsIG1zZykge1xuICAgICAgICBzdXBlcihtc2cgfHwgYGNhbid0IHJlc29sdmUgcmVmZXJlbmNlICR7cmVmfSBmcm9tIGlkICR7YmFzZUlkfWApO1xuICAgICAgICB0aGlzLm1pc3NpbmdSZWYgPSByZXNvbHZlXzEucmVzb2x2ZVVybChiYXNlSWQsIHJlZik7XG4gICAgICAgIHRoaXMubWlzc2luZ1NjaGVtYSA9IHJlc29sdmVfMS5ub3JtYWxpemVJZChyZXNvbHZlXzEuZ2V0RnVsbFBhdGgodGhpcy5taXNzaW5nUmVmKSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gTWlzc2luZ1JlZkVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmX2Vycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXNvbHZlU2NoZW1hID0gZXhwb3J0cy5nZXRDb21waWxpbmdTY2hlbWEgPSBleHBvcnRzLnJlc29sdmVSZWYgPSBleHBvcnRzLmNvbXBpbGVTY2hlbWEgPSBleHBvcnRzLlNjaGVtYUVudiA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW5cIik7XG5jb25zdCB2YWxpZGF0aW9uX2Vycm9yXzEgPSByZXF1aXJlKFwiLi4vcnVudGltZS92YWxpZGF0aW9uX2Vycm9yXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuL25hbWVzXCIpO1xuY29uc3QgcmVzb2x2ZV8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCB2YWxpZGF0ZV8xID0gcmVxdWlyZShcIi4vdmFsaWRhdGVcIik7XG5jb25zdCBVUkkgPSByZXF1aXJlKFwidXJpLWpzXCIpO1xuY2xhc3MgU2NoZW1hRW52IHtcbiAgICBjb25zdHJ1Y3RvcihlbnYpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnJlZnMgPSB7fTtcbiAgICAgICAgdGhpcy5keW5hbWljQW5jaG9ycyA9IHt9O1xuICAgICAgICBsZXQgc2NoZW1hO1xuICAgICAgICBpZiAodHlwZW9mIGVudi5zY2hlbWEgPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHNjaGVtYSA9IGVudi5zY2hlbWE7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gZW52LnNjaGVtYTtcbiAgICAgICAgdGhpcy5zY2hlbWFJZCA9IGVudi5zY2hlbWFJZDtcbiAgICAgICAgdGhpcy5yb290ID0gZW52LnJvb3QgfHwgdGhpcztcbiAgICAgICAgdGhpcy5iYXNlSWQgPSAoX2EgPSBlbnYuYmFzZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiByZXNvbHZlXzEubm9ybWFsaXplSWQoc2NoZW1hID09PSBudWxsIHx8IHNjaGVtYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoZW1hW2Vudi5zY2hlbWFJZCB8fCBcIiRpZFwiXSk7XG4gICAgICAgIHRoaXMuc2NoZW1hUGF0aCA9IGVudi5zY2hlbWFQYXRoO1xuICAgICAgICB0aGlzLmxvY2FsUmVmcyA9IGVudi5sb2NhbFJlZnM7XG4gICAgICAgIHRoaXMubWV0YSA9IGVudi5tZXRhO1xuICAgICAgICB0aGlzLiRhc3luYyA9IHNjaGVtYSA9PT0gbnVsbCB8fCBzY2hlbWEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaGVtYS4kYXN5bmM7XG4gICAgICAgIHRoaXMucmVmcyA9IHt9O1xuICAgIH1cbn1cbmV4cG9ydHMuU2NoZW1hRW52ID0gU2NoZW1hRW52O1xuLy8gbGV0IGNvZGVTaXplID0gMFxuLy8gbGV0IG5vZGVDb3VudCA9IDBcbi8vIENvbXBpbGVzIHNjaGVtYSBpbiBTY2hlbWFFbnZcbmZ1bmN0aW9uIGNvbXBpbGVTY2hlbWEoc2NoKSB7XG4gICAgLy8gVE9ETyByZWZhY3RvciAtIHJlbW92ZSBjb21waWxhdGlvbnNcbiAgICBjb25zdCBfc2NoID0gZ2V0Q29tcGlsaW5nU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbiAgICBpZiAoX3NjaClcbiAgICAgICAgcmV0dXJuIF9zY2g7XG4gICAgY29uc3Qgcm9vdElkID0gcmVzb2x2ZV8xLmdldEZ1bGxQYXRoKHNjaC5yb290LmJhc2VJZCk7IC8vIFRPRE8gaWYgZ2V0RnVsbFBhdGggcmVtb3ZlZCAxIHRlc3RzIGZhaWxzXG4gICAgY29uc3QgeyBlczUsIGxpbmVzIH0gPSB0aGlzLm9wdHMuY29kZTtcbiAgICBjb25zdCB7IG93blByb3BlcnRpZXMgfSA9IHRoaXMub3B0cztcbiAgICBjb25zdCBnZW4gPSBuZXcgY29kZWdlbl8xLkNvZGVHZW4odGhpcy5zY29wZSwgeyBlczUsIGxpbmVzLCBvd25Qcm9wZXJ0aWVzIH0pO1xuICAgIGxldCBfVmFsaWRhdGlvbkVycm9yO1xuICAgIGlmIChzY2guJGFzeW5jKSB7XG4gICAgICAgIF9WYWxpZGF0aW9uRXJyb3IgPSBnZW4uc2NvcGVWYWx1ZShcIkVycm9yXCIsIHtcbiAgICAgICAgICAgIHJlZjogdmFsaWRhdGlvbl9lcnJvcl8xLmRlZmF1bHQsXG4gICAgICAgICAgICBjb2RlOiBjb2RlZ2VuXzEuXyBgcmVxdWlyZShcImFqdi9kaXN0L3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiKS5kZWZhdWx0YCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkYXRlTmFtZSA9IGdlbi5zY29wZU5hbWUoXCJ2YWxpZGF0ZVwiKTtcbiAgICBzY2gudmFsaWRhdGVOYW1lID0gdmFsaWRhdGVOYW1lO1xuICAgIGNvbnN0IHNjaGVtYUN4dCA9IHtcbiAgICAgICAgZ2VuLFxuICAgICAgICBhbGxFcnJvcnM6IHRoaXMub3B0cy5hbGxFcnJvcnMsXG4gICAgICAgIGRhdGE6IG5hbWVzXzEuZGVmYXVsdC5kYXRhLFxuICAgICAgICBwYXJlbnREYXRhOiBuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YSxcbiAgICAgICAgcGFyZW50RGF0YVByb3BlcnR5OiBuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5LFxuICAgICAgICBkYXRhTmFtZXM6IFtuYW1lc18xLmRlZmF1bHQuZGF0YV0sXG4gICAgICAgIGRhdGFQYXRoQXJyOiBbY29kZWdlbl8xLm5pbF0sXG4gICAgICAgIGRhdGFMZXZlbDogMCxcbiAgICAgICAgZGF0YVR5cGVzOiBbXSxcbiAgICAgICAgZGVmaW5lZFByb3BlcnRpZXM6IG5ldyBTZXQoKSxcbiAgICAgICAgdG9wU2NoZW1hUmVmOiBnZW4uc2NvcGVWYWx1ZShcInNjaGVtYVwiLCB0aGlzLm9wdHMuY29kZS5zb3VyY2UgPT09IHRydWVcbiAgICAgICAgICAgID8geyByZWY6IHNjaC5zY2hlbWEsIGNvZGU6IGNvZGVnZW5fMS5zdHJpbmdpZnkoc2NoLnNjaGVtYSkgfVxuICAgICAgICAgICAgOiB7IHJlZjogc2NoLnNjaGVtYSB9KSxcbiAgICAgICAgdmFsaWRhdGVOYW1lLFxuICAgICAgICBWYWxpZGF0aW9uRXJyb3I6IF9WYWxpZGF0aW9uRXJyb3IsXG4gICAgICAgIHNjaGVtYTogc2NoLnNjaGVtYSxcbiAgICAgICAgc2NoZW1hRW52OiBzY2gsXG4gICAgICAgIHJvb3RJZCxcbiAgICAgICAgYmFzZUlkOiBzY2guYmFzZUlkIHx8IHJvb3RJZCxcbiAgICAgICAgc2NoZW1hUGF0aDogY29kZWdlbl8xLm5pbCxcbiAgICAgICAgZXJyU2NoZW1hUGF0aDogc2NoLnNjaGVtYVBhdGggfHwgKHRoaXMub3B0cy5qdGQgPyBcIlwiIDogXCIjXCIpLFxuICAgICAgICBlcnJvclBhdGg6IGNvZGVnZW5fMS5fIGBcIlwiYCxcbiAgICAgICAgb3B0czogdGhpcy5vcHRzLFxuICAgICAgICBzZWxmOiB0aGlzLFxuICAgIH07XG4gICAgbGV0IHNvdXJjZUNvZGU7XG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fY29tcGlsYXRpb25zLmFkZChzY2gpO1xuICAgICAgICB2YWxpZGF0ZV8xLnZhbGlkYXRlRnVuY3Rpb25Db2RlKHNjaGVtYUN4dCk7XG4gICAgICAgIGdlbi5vcHRpbWl6ZSh0aGlzLm9wdHMuY29kZS5vcHRpbWl6ZSk7XG4gICAgICAgIC8vIGdlbi5vcHRpbWl6ZSgxKVxuICAgICAgICBjb25zdCB2YWxpZGF0ZUNvZGUgPSBnZW4udG9TdHJpbmcoKTtcbiAgICAgICAgc291cmNlQ29kZSA9IGAke2dlbi5zY29wZVJlZnMobmFtZXNfMS5kZWZhdWx0LnNjb3BlKX1yZXR1cm4gJHt2YWxpZGF0ZUNvZGV9YDtcbiAgICAgICAgLy8gY29uc29sZS5sb2coKGNvZGVTaXplICs9IHNvdXJjZUNvZGUubGVuZ3RoKSwgKG5vZGVDb3VudCArPSBnZW4ubm9kZUNvdW50KSlcbiAgICAgICAgaWYgKHRoaXMub3B0cy5jb2RlLnByb2Nlc3MpXG4gICAgICAgICAgICBzb3VyY2VDb2RlID0gdGhpcy5vcHRzLmNvZGUucHJvY2Vzcyhzb3VyY2VDb2RlLCBzY2gpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlxcblxcblxcbiAqKiogXFxuXCIsIHNvdXJjZUNvZGUpXG4gICAgICAgIGNvbnN0IG1ha2VWYWxpZGF0ZSA9IG5ldyBGdW5jdGlvbihgJHtuYW1lc18xLmRlZmF1bHQuc2VsZn1gLCBgJHtuYW1lc18xLmRlZmF1bHQuc2NvcGV9YCwgc291cmNlQ29kZSk7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlID0gbWFrZVZhbGlkYXRlKHRoaXMsIHRoaXMuc2NvcGUuZ2V0KCkpO1xuICAgICAgICB0aGlzLnNjb3BlLnZhbHVlKHZhbGlkYXRlTmFtZSwgeyByZWY6IHZhbGlkYXRlIH0pO1xuICAgICAgICB2YWxpZGF0ZS5lcnJvcnMgPSBudWxsO1xuICAgICAgICB2YWxpZGF0ZS5zY2hlbWEgPSBzY2guc2NoZW1hO1xuICAgICAgICB2YWxpZGF0ZS5zY2hlbWFFbnYgPSBzY2g7XG4gICAgICAgIGlmIChzY2guJGFzeW5jKVxuICAgICAgICAgICAgdmFsaWRhdGUuJGFzeW5jID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5jb2RlLnNvdXJjZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFsaWRhdGUuc291cmNlID0geyB2YWxpZGF0ZU5hbWUsIHZhbGlkYXRlQ29kZSwgc2NvcGVWYWx1ZXM6IGdlbi5fdmFsdWVzIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0cy51bmV2YWx1YXRlZCkge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wcywgaXRlbXMgfSA9IHNjaGVtYUN4dDtcbiAgICAgICAgICAgIHZhbGlkYXRlLmV2YWx1YXRlZCA9IHtcbiAgICAgICAgICAgICAgICBwcm9wczogcHJvcHMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSA/IHVuZGVmaW5lZCA6IHByb3BzLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBpdGVtcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lID8gdW5kZWZpbmVkIDogaXRlbXMsXG4gICAgICAgICAgICAgICAgZHluYW1pY1Byb3BzOiBwcm9wcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lLFxuICAgICAgICAgICAgICAgIGR5bmFtaWNJdGVtczogaXRlbXMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodmFsaWRhdGUuc291cmNlKVxuICAgICAgICAgICAgICAgIHZhbGlkYXRlLnNvdXJjZS5ldmFsdWF0ZWQgPSBjb2RlZ2VuXzEuc3RyaW5naWZ5KHZhbGlkYXRlLmV2YWx1YXRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgc2NoLnZhbGlkYXRlID0gdmFsaWRhdGU7XG4gICAgICAgIHJldHVybiBzY2g7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGRlbGV0ZSBzY2gudmFsaWRhdGU7XG4gICAgICAgIGRlbGV0ZSBzY2gudmFsaWRhdGVOYW1lO1xuICAgICAgICBpZiAoc291cmNlQ29kZSlcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiRXJyb3IgY29tcGlsaW5nIHNjaGVtYSwgZnVuY3Rpb24gY29kZTpcIiwgc291cmNlQ29kZSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiXFxuXFxuXFxuICoqKiBcXG5cIiwgc291cmNlQ29kZSwgdGhpcy5vcHRzKVxuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5fY29tcGlsYXRpb25zLmRlbGV0ZShzY2gpO1xuICAgIH1cbn1cbmV4cG9ydHMuY29tcGlsZVNjaGVtYSA9IGNvbXBpbGVTY2hlbWE7XG5mdW5jdGlvbiByZXNvbHZlUmVmKHJvb3QsIGJhc2VJZCwgcmVmKSB7XG4gICAgdmFyIF9hO1xuICAgIHJlZiA9IHJlc29sdmVfMS5yZXNvbHZlVXJsKGJhc2VJZCwgcmVmKTtcbiAgICBjb25zdCBzY2hPckZ1bmMgPSByb290LnJlZnNbcmVmXTtcbiAgICBpZiAoc2NoT3JGdW5jKVxuICAgICAgICByZXR1cm4gc2NoT3JGdW5jO1xuICAgIGxldCBfc2NoID0gcmVzb2x2ZS5jYWxsKHRoaXMsIHJvb3QsIHJlZik7XG4gICAgaWYgKF9zY2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSAoX2EgPSByb290LmxvY2FsUmVmcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3JlZl07IC8vIFRPRE8gbWF5YmUgbG9jYWxSZWZzIHNob3VsZCBob2xkIFNjaGVtYUVudlxuICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIGlmIChzY2hlbWEpXG4gICAgICAgICAgICBfc2NoID0gbmV3IFNjaGVtYUVudih7IHNjaGVtYSwgc2NoZW1hSWQsIHJvb3QsIGJhc2VJZCB9KTtcbiAgICB9XG4gICAgaWYgKF9zY2ggPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIHJldHVybiAocm9vdC5yZWZzW3JlZl0gPSBpbmxpbmVPckNvbXBpbGUuY2FsbCh0aGlzLCBfc2NoKSk7XG59XG5leHBvcnRzLnJlc29sdmVSZWYgPSByZXNvbHZlUmVmO1xuZnVuY3Rpb24gaW5saW5lT3JDb21waWxlKHNjaCkge1xuICAgIGlmIChyZXNvbHZlXzEuaW5saW5lUmVmKHNjaC5zY2hlbWEsIHRoaXMub3B0cy5pbmxpbmVSZWZzKSlcbiAgICAgICAgcmV0dXJuIHNjaC5zY2hlbWE7XG4gICAgcmV0dXJuIHNjaC52YWxpZGF0ZSA/IHNjaCA6IGNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2gpO1xufVxuLy8gSW5kZXggb2Ygc2NoZW1hIGNvbXBpbGF0aW9uIGluIHRoZSBjdXJyZW50bHkgY29tcGlsZWQgbGlzdFxuZnVuY3Rpb24gZ2V0Q29tcGlsaW5nU2NoZW1hKHNjaEVudikge1xuICAgIGZvciAoY29uc3Qgc2NoIG9mIHRoaXMuX2NvbXBpbGF0aW9ucykge1xuICAgICAgICBpZiAoc2FtZVNjaGVtYUVudihzY2gsIHNjaEVudikpXG4gICAgICAgICAgICByZXR1cm4gc2NoO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0Q29tcGlsaW5nU2NoZW1hID0gZ2V0Q29tcGlsaW5nU2NoZW1hO1xuZnVuY3Rpb24gc2FtZVNjaGVtYUVudihzMSwgczIpIHtcbiAgICByZXR1cm4gczEuc2NoZW1hID09PSBzMi5zY2hlbWEgJiYgczEucm9vdCA9PT0gczIucm9vdCAmJiBzMS5iYXNlSWQgPT09IHMyLmJhc2VJZDtcbn1cbi8vIHJlc29sdmUgYW5kIGNvbXBpbGUgdGhlIHJlZmVyZW5jZXMgKCRyZWYpXG4vLyBUT0RPIHJldHVybnMgQW55U2NoZW1hT2JqZWN0IChpZiB0aGUgc2NoZW1hIGNhbiBiZSBpbmxpbmVkKSBvciB2YWxpZGF0aW9uIGZ1bmN0aW9uXG5mdW5jdGlvbiByZXNvbHZlKHJvb3QsIC8vIGluZm9ybWF0aW9uIGFib3V0IHRoZSByb290IHNjaGVtYSBmb3IgdGhlIGN1cnJlbnQgc2NoZW1hXG5yZWYgLy8gcmVmZXJlbmNlIHRvIHJlc29sdmVcbikge1xuICAgIGxldCBzY2g7XG4gICAgd2hpbGUgKHR5cGVvZiAoc2NoID0gdGhpcy5yZWZzW3JlZl0pID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJlZiA9IHNjaDtcbiAgICByZXR1cm4gc2NoIHx8IHRoaXMuc2NoZW1hc1tyZWZdIHx8IHJlc29sdmVTY2hlbWEuY2FsbCh0aGlzLCByb290LCByZWYpO1xufVxuLy8gUmVzb2x2ZSBzY2hlbWEsIGl0cyByb290IGFuZCBiYXNlSWRcbmZ1bmN0aW9uIHJlc29sdmVTY2hlbWEocm9vdCwgLy8gcm9vdCBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHNjaGVtYSwgcmVmcyBUT0RPIGJlbG93IFNjaGVtYUVudiBpcyBhc3NpZ25lZCB0byBpdFxucmVmIC8vIHJlZmVyZW5jZSB0byByZXNvbHZlXG4pIHtcbiAgICBjb25zdCBwID0gVVJJLnBhcnNlKHJlZik7XG4gICAgY29uc3QgcmVmUGF0aCA9IHJlc29sdmVfMS5fZ2V0RnVsbFBhdGgocCk7XG4gICAgbGV0IGJhc2VJZCA9IHJlc29sdmVfMS5nZXRGdWxsUGF0aChyb290LmJhc2VJZCk7XG4gICAgLy8gVE9ETyBgT2JqZWN0LmtleXMocm9vdC5zY2hlbWEpLmxlbmd0aCA+IDBgIHNob3VsZCBub3QgYmUgbmVlZGVkIC0gYnV0IHJlbW92aW5nIGJyZWFrcyAyIHRlc3RzXG4gICAgaWYgKE9iamVjdC5rZXlzKHJvb3Quc2NoZW1hKS5sZW5ndGggPiAwICYmIHJlZlBhdGggPT09IGJhc2VJZCkge1xuICAgICAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCByb290KTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSByZXNvbHZlXzEubm9ybWFsaXplSWQocmVmUGF0aCk7XG4gICAgY29uc3Qgc2NoT3JSZWYgPSB0aGlzLnJlZnNbaWRdIHx8IHRoaXMuc2NoZW1hc1tpZF07XG4gICAgaWYgKHR5cGVvZiBzY2hPclJlZiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IHNjaCA9IHJlc29sdmVTY2hlbWEuY2FsbCh0aGlzLCByb290LCBzY2hPclJlZik7XG4gICAgICAgIGlmICh0eXBlb2YgKHNjaCA9PT0gbnVsbCB8fCBzY2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaC5zY2hlbWEpICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCBzY2gpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChzY2hPclJlZiA9PT0gbnVsbCB8fCBzY2hPclJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoT3JSZWYuc2NoZW1hKSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghc2NoT3JSZWYudmFsaWRhdGUpXG4gICAgICAgIGNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2hPclJlZik7XG4gICAgaWYgKGlkID09PSByZXNvbHZlXzEubm9ybWFsaXplSWQocmVmKSkge1xuICAgICAgICBjb25zdCB7IHNjaGVtYSB9ID0gc2NoT3JSZWY7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgY29uc3Qgc2NoSWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICBpZiAoc2NoSWQpXG4gICAgICAgICAgICBiYXNlSWQgPSByZXNvbHZlXzEucmVzb2x2ZVVybChiYXNlSWQsIHNjaElkKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTY2hlbWFFbnYoeyBzY2hlbWEsIHNjaGVtYUlkLCByb290LCBiYXNlSWQgfSk7XG4gICAgfVxuICAgIHJldHVybiBnZXRKc29uUG9pbnRlci5jYWxsKHRoaXMsIHAsIHNjaE9yUmVmKTtcbn1cbmV4cG9ydHMucmVzb2x2ZVNjaGVtYSA9IHJlc29sdmVTY2hlbWE7XG5jb25zdCBQUkVWRU5UX1NDT1BFX0NIQU5HRSA9IG5ldyBTZXQoW1xuICAgIFwicHJvcGVydGllc1wiLFxuICAgIFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgICBcImVudW1cIixcbiAgICBcImRlcGVuZGVuY2llc1wiLFxuICAgIFwiZGVmaW5pdGlvbnNcIixcbl0pO1xuZnVuY3Rpb24gZ2V0SnNvblBvaW50ZXIocGFyc2VkUmVmLCB7IGJhc2VJZCwgc2NoZW1hLCByb290IH0pIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCgoX2EgPSBwYXJzZWRSZWYuZnJhZ21lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgIT09IFwiL1wiKVxuICAgICAgICByZXR1cm47XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnNlZFJlZi5mcmFnbWVudC5zbGljZSgxKS5zcGxpdChcIi9cIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNjaGVtYSA9IHNjaGVtYVt1dGlsXzEudW5lc2NhcGVGcmFnbWVudChwYXJ0KV07XG4gICAgICAgIGlmIChzY2hlbWEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gVE9ETyBQUkVWRU5UX1NDT1BFX0NIQU5HRSBjb3VsZCBiZSBkZWZpbmVkIGluIGtleXdvcmQgZGVmP1xuICAgICAgICBjb25zdCBzY2hJZCA9IHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBzY2hlbWFbdGhpcy5vcHRzLnNjaGVtYUlkXTtcbiAgICAgICAgaWYgKCFQUkVWRU5UX1NDT1BFX0NIQU5HRS5oYXMocGFydCkgJiYgc2NoSWQpIHtcbiAgICAgICAgICAgIGJhc2VJZCA9IHJlc29sdmVfMS5yZXNvbHZlVXJsKGJhc2VJZCwgc2NoSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBlbnY7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgIT0gXCJib29sZWFuXCIgJiYgc2NoZW1hLiRyZWYgJiYgIXV0aWxfMS5zY2hlbWFIYXNSdWxlc0J1dFJlZihzY2hlbWEsIHRoaXMuUlVMRVMpKSB7XG4gICAgICAgIGNvbnN0ICRyZWYgPSByZXNvbHZlXzEucmVzb2x2ZVVybChiYXNlSWQsIHNjaGVtYS4kcmVmKTtcbiAgICAgICAgZW52ID0gcmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsICRyZWYpO1xuICAgIH1cbiAgICAvLyBldmVuIHRob3VnaCByZXNvbHV0aW9uIGZhaWxlZCB3ZSBuZWVkIHRvIHJldHVybiBTY2hlbWFFbnYgdG8gdGhyb3cgZXhjZXB0aW9uXG4gICAgLy8gc28gdGhhdCBjb21waWxlQXN5bmMgbG9hZHMgbWlzc2luZyBzY2hlbWEuXG4gICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgIGVudiA9IGVudiB8fCBuZXcgU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkIH0pO1xuICAgIGlmIChlbnYuc2NoZW1hICE9PSBlbnYucm9vdC5zY2hlbWEpXG4gICAgICAgIHJldHVybiBlbnY7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db2RlR2VuID0gZXhwb3J0cy5OYW1lID0gZXhwb3J0cy5uaWwgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyID0gZXhwb3J0cy5fID0gZXhwb3J0cy5LZXl3b3JkQ3h0ID0gdm9pZCAwO1xudmFyIHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3ZhbGlkYXRlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiS2V5d29yZEN4dFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdGVfMS5LZXl3b3JkQ3h0OyB9IH0pO1xudmFyIGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvY29kZWdlblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5fOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5naWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyaW5naWZ5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmlsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEubmlsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLk5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb2RlR2VuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuQ29kZUdlbjsgfSB9KTtcbmNvbnN0IHZhbGlkYXRpb25fZXJyb3JfMSA9IHJlcXVpcmUoXCIuL3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiKTtcbmNvbnN0IHJlZl9lcnJvcl8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9yZWZfZXJyb3JcIik7XG5jb25zdCBydWxlc18xID0gcmVxdWlyZShcIi4vY29tcGlsZS9ydWxlc1wiKTtcbmNvbnN0IGNvbXBpbGVfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGVcIik7XG5jb25zdCBjb2RlZ2VuXzIgPSByZXF1aXJlKFwiLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCByZXNvbHZlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3Jlc29sdmVcIik7XG5jb25zdCBkYXRhVHlwZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS92YWxpZGF0ZS9kYXRhVHlwZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0ICRkYXRhUmVmU2NoZW1hID0gcmVxdWlyZShcIi4vcmVmcy9kYXRhLmpzb25cIik7XG5jb25zdCBNRVRBX0lHTk9SRV9PUFRJT05TID0gW1wicmVtb3ZlQWRkaXRpb25hbFwiLCBcInVzZURlZmF1bHRzXCIsIFwiY29lcmNlVHlwZXNcIl07XG5jb25zdCBFWFRfU0NPUEVfTkFNRVMgPSBuZXcgU2V0KFtcbiAgICBcInZhbGlkYXRlXCIsXG4gICAgXCJzZXJpYWxpemVcIixcbiAgICBcInBhcnNlXCIsXG4gICAgXCJ3cmFwcGVyXCIsXG4gICAgXCJyb290XCIsXG4gICAgXCJzY2hlbWFcIixcbiAgICBcImtleXdvcmRcIixcbiAgICBcInBhdHRlcm5cIixcbiAgICBcImZvcm1hdHNcIixcbiAgICBcInZhbGlkYXRlJGRhdGFcIixcbiAgICBcImZ1bmNcIixcbiAgICBcIm9ialwiLFxuICAgIFwiRXJyb3JcIixcbl0pO1xuY29uc3QgcmVtb3ZlZE9wdGlvbnMgPSB7XG4gICAgZXJyb3JEYXRhUGF0aDogXCJcIixcbiAgICBmb3JtYXQ6IFwiYHZhbGlkYXRlRm9ybWF0czogZmFsc2VgIGNhbiBiZSB1c2VkIGluc3RlYWQuXCIsXG4gICAgbnVsbGFibGU6ICdcIm51bGxhYmxlXCIga2V5d29yZCBpcyBzdXBwb3J0ZWQgYnkgZGVmYXVsdC4nLFxuICAgIGpzb25Qb2ludGVyczogXCJEZXByZWNhdGVkIGpzUHJvcGVydHlTeW50YXggY2FuIGJlIHVzZWQgaW5zdGVhZC5cIixcbiAgICBleHRlbmRSZWZzOiBcIkRlcHJlY2F0ZWQgaWdub3JlS2V5d29yZHNXaXRoUmVmIGNhbiBiZSB1c2VkIGluc3RlYWQuXCIsXG4gICAgbWlzc2luZ1JlZnM6IFwiUGFzcyBlbXB0eSBzY2hlbWEgd2l0aCAkaWQgdGhhdCBzaG91bGQgYmUgaWdub3JlZCB0byBhanYuYWRkU2NoZW1hLlwiLFxuICAgIHByb2Nlc3NDb2RlOiBcIlVzZSBvcHRpb24gYGNvZGU6IHtwcm9jZXNzOiAoY29kZSwgc2NoZW1hRW52OiBvYmplY3QpID0+IHN0cmluZ31gXCIsXG4gICAgc291cmNlQ29kZTogXCJVc2Ugb3B0aW9uIGBjb2RlOiB7c291cmNlOiB0cnVlfWBcIixcbiAgICBzdHJpY3REZWZhdWx0czogXCJJdCBpcyBkZWZhdWx0IG5vdywgc2VlIG9wdGlvbiBgc3RyaWN0YC5cIixcbiAgICBzdHJpY3RLZXl3b3JkczogXCJJdCBpcyBkZWZhdWx0IG5vdywgc2VlIG9wdGlvbiBgc3RyaWN0YC5cIixcbiAgICB1bmlxdWVJdGVtczogJ1widW5pcXVlSXRlbXNcIiBrZXl3b3JkIGlzIGFsd2F5cyB2YWxpZGF0ZWQuJyxcbiAgICB1bmtub3duRm9ybWF0czogXCJEaXNhYmxlIHN0cmljdCBtb2RlIG9yIHBhc3MgYHRydWVgIHRvIGBhanYuYWRkRm9ybWF0YCAob3IgYGZvcm1hdHNgIG9wdGlvbikuXCIsXG4gICAgY2FjaGU6IFwiTWFwIGlzIHVzZWQgYXMgY2FjaGUsIHNjaGVtYSBvYmplY3QgYXMga2V5LlwiLFxuICAgIHNlcmlhbGl6ZTogXCJNYXAgaXMgdXNlZCBhcyBjYWNoZSwgc2NoZW1hIG9iamVjdCBhcyBrZXkuXCIsXG4gICAgYWp2RXJyb3JzOiBcIkl0IGlzIGRlZmF1bHQgbm93LlwiLFxufTtcbmNvbnN0IGRlcHJlY2F0ZWRPcHRpb25zID0ge1xuICAgIGlnbm9yZUtleXdvcmRzV2l0aFJlZjogXCJcIixcbiAgICBqc1Byb3BlcnR5U3ludGF4OiBcIlwiLFxuICAgIHVuaWNvZGU6ICdcIm1pbkxlbmd0aFwiL1wibWF4TGVuZ3RoXCIgYWNjb3VudCBmb3IgdW5pY29kZSBjaGFyYWN0ZXJzIGJ5IGRlZmF1bHQuJyxcbn07XG5jb25zdCBNQVhfRVhQUkVTU0lPTiA9IDIwMDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiByZXF1aXJlZE9wdGlvbnMobykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tLCBfbywgX3AsIF9xLCBfciwgX3MsIF90LCBfdSwgX3YsIF93LCBfeDtcbiAgICBjb25zdCBzID0gby5zdHJpY3Q7XG4gICAgY29uc3QgX29wdHogPSAoX2EgPSBvLmNvZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpbWl6ZTtcbiAgICBjb25zdCBvcHRpbWl6ZSA9IF9vcHR6ID09PSB0cnVlIHx8IF9vcHR6ID09PSB1bmRlZmluZWQgPyAxIDogX29wdHogfHwgMDtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdHJpY3RTY2hlbWE6IChfYyA9IChfYiA9IG8uc3RyaWN0U2NoZW1hKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB0cnVlLFxuICAgICAgICBzdHJpY3ROdW1iZXJzOiAoX2UgPSAoX2QgPSBvLnN0cmljdE51bWJlcnMpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHMpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHRydWUsXG4gICAgICAgIHN0cmljdFR5cGVzOiAoX2cgPSAoX2YgPSBvLnN0cmljdFR5cGVzKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBzKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBcImxvZ1wiLFxuICAgICAgICBzdHJpY3RUdXBsZXM6IChfaiA9IChfaCA9IG8uc3RyaWN0VHVwbGVzKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiBzKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiBcImxvZ1wiLFxuICAgICAgICBzdHJpY3RSZXF1aXJlZDogKF9sID0gKF9rID0gby5zdHJpY3RSZXF1aXJlZCkgIT09IG51bGwgJiYgX2sgIT09IHZvaWQgMCA/IF9rIDogcykgIT09IG51bGwgJiYgX2wgIT09IHZvaWQgMCA/IF9sIDogZmFsc2UsXG4gICAgICAgIGNvZGU6IG8uY29kZSA/IHsgLi4uby5jb2RlLCBvcHRpbWl6ZSB9IDogeyBvcHRpbWl6ZSB9LFxuICAgICAgICBsb29wUmVxdWlyZWQ6IChfbSA9IG8ubG9vcFJlcXVpcmVkKSAhPT0gbnVsbCAmJiBfbSAhPT0gdm9pZCAwID8gX20gOiBNQVhfRVhQUkVTU0lPTixcbiAgICAgICAgbG9vcEVudW06IChfbyA9IG8ubG9vcEVudW0pICE9PSBudWxsICYmIF9vICE9PSB2b2lkIDAgPyBfbyA6IE1BWF9FWFBSRVNTSU9OLFxuICAgICAgICBtZXRhOiAoX3AgPSBvLm1ldGEpICE9PSBudWxsICYmIF9wICE9PSB2b2lkIDAgPyBfcCA6IHRydWUsXG4gICAgICAgIG1lc3NhZ2VzOiAoX3EgPSBvLm1lc3NhZ2VzKSAhPT0gbnVsbCAmJiBfcSAhPT0gdm9pZCAwID8gX3EgOiB0cnVlLFxuICAgICAgICBpbmxpbmVSZWZzOiAoX3IgPSBvLmlubGluZVJlZnMpICE9PSBudWxsICYmIF9yICE9PSB2b2lkIDAgPyBfciA6IHRydWUsXG4gICAgICAgIHNjaGVtYUlkOiAoX3MgPSBvLnNjaGVtYUlkKSAhPT0gbnVsbCAmJiBfcyAhPT0gdm9pZCAwID8gX3MgOiBcIiRpZFwiLFxuICAgICAgICBhZGRVc2VkU2NoZW1hOiAoX3QgPSBvLmFkZFVzZWRTY2hlbWEpICE9PSBudWxsICYmIF90ICE9PSB2b2lkIDAgPyBfdCA6IHRydWUsXG4gICAgICAgIHZhbGlkYXRlU2NoZW1hOiAoX3UgPSBvLnZhbGlkYXRlU2NoZW1hKSAhPT0gbnVsbCAmJiBfdSAhPT0gdm9pZCAwID8gX3UgOiB0cnVlLFxuICAgICAgICB2YWxpZGF0ZUZvcm1hdHM6IChfdiA9IG8udmFsaWRhdGVGb3JtYXRzKSAhPT0gbnVsbCAmJiBfdiAhPT0gdm9pZCAwID8gX3YgOiB0cnVlLFxuICAgICAgICB1bmljb2RlUmVnRXhwOiAoX3cgPSBvLnVuaWNvZGVSZWdFeHApICE9PSBudWxsICYmIF93ICE9PSB2b2lkIDAgPyBfdyA6IHRydWUsXG4gICAgICAgIGludDMycmFuZ2U6IChfeCA9IG8uaW50MzJyYW5nZSkgIT09IG51bGwgJiYgX3ggIT09IHZvaWQgMCA/IF94IDogdHJ1ZSxcbiAgICB9O1xufVxuY2xhc3MgQWp2IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICAgICAgdGhpcy5zY2hlbWFzID0ge307XG4gICAgICAgIHRoaXMucmVmcyA9IHt9O1xuICAgICAgICB0aGlzLmZvcm1hdHMgPSB7fTtcbiAgICAgICAgdGhpcy5fY29tcGlsYXRpb25zID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl9sb2FkaW5nID0ge307XG4gICAgICAgIHRoaXMuX2NhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICBvcHRzID0gdGhpcy5vcHRzID0geyAuLi5vcHRzLCAuLi5yZXF1aXJlZE9wdGlvbnMob3B0cykgfTtcbiAgICAgICAgY29uc3QgeyBlczUsIGxpbmVzIH0gPSB0aGlzLm9wdHMuY29kZTtcbiAgICAgICAgdGhpcy5zY29wZSA9IG5ldyBjb2RlZ2VuXzIuVmFsdWVTY29wZSh7IHNjb3BlOiB7fSwgcHJlZml4ZXM6IEVYVF9TQ09QRV9OQU1FUywgZXM1LCBsaW5lcyB9KTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBnZXRMb2dnZXIob3B0cy5sb2dnZXIpO1xuICAgICAgICBjb25zdCBmb3JtYXRPcHQgPSBvcHRzLnZhbGlkYXRlRm9ybWF0cztcbiAgICAgICAgb3B0cy52YWxpZGF0ZUZvcm1hdHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5SVUxFUyA9IHJ1bGVzXzEuZ2V0UnVsZXMoKTtcbiAgICAgICAgY2hlY2tPcHRpb25zLmNhbGwodGhpcywgcmVtb3ZlZE9wdGlvbnMsIG9wdHMsIFwiTk9UIFNVUFBPUlRFRFwiKTtcbiAgICAgICAgY2hlY2tPcHRpb25zLmNhbGwodGhpcywgZGVwcmVjYXRlZE9wdGlvbnMsIG9wdHMsIFwiREVQUkVDQVRFRFwiLCBcIndhcm5cIik7XG4gICAgICAgIHRoaXMuX21ldGFPcHRzID0gZ2V0TWV0YVNjaGVtYU9wdGlvbnMuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKG9wdHMuZm9ybWF0cylcbiAgICAgICAgICAgIGFkZEluaXRpYWxGb3JtYXRzLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX2FkZFZvY2FidWxhcmllcygpO1xuICAgICAgICB0aGlzLl9hZGREZWZhdWx0TWV0YVNjaGVtYSgpO1xuICAgICAgICBpZiAob3B0cy5rZXl3b3JkcylcbiAgICAgICAgICAgIGFkZEluaXRpYWxLZXl3b3Jkcy5jYWxsKHRoaXMsIG9wdHMua2V5d29yZHMpO1xuICAgICAgICBpZiAodHlwZW9mIG9wdHMubWV0YSA9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgdGhpcy5hZGRNZXRhU2NoZW1hKG9wdHMubWV0YSk7XG4gICAgICAgIGFkZEluaXRpYWxTY2hlbWFzLmNhbGwodGhpcyk7XG4gICAgICAgIG9wdHMudmFsaWRhdGVGb3JtYXRzID0gZm9ybWF0T3B0O1xuICAgIH1cbiAgICBfYWRkVm9jYWJ1bGFyaWVzKCkge1xuICAgICAgICB0aGlzLmFkZEtleXdvcmQoXCIkYXN5bmNcIik7XG4gICAgfVxuICAgIF9hZGREZWZhdWx0TWV0YVNjaGVtYSgpIHtcbiAgICAgICAgY29uc3QgeyAkZGF0YSwgbWV0YSwgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgbGV0IF9kYXRhUmVmU2NoZW1hID0gJGRhdGFSZWZTY2hlbWE7XG4gICAgICAgIGlmIChzY2hlbWFJZCA9PT0gXCJpZFwiKSB7XG4gICAgICAgICAgICBfZGF0YVJlZlNjaGVtYSA9IHsgLi4uJGRhdGFSZWZTY2hlbWEgfTtcbiAgICAgICAgICAgIF9kYXRhUmVmU2NoZW1hLmlkID0gX2RhdGFSZWZTY2hlbWEuJGlkO1xuICAgICAgICAgICAgZGVsZXRlIF9kYXRhUmVmU2NoZW1hLiRpZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YSAmJiAkZGF0YSlcbiAgICAgICAgICAgIHRoaXMuYWRkTWV0YVNjaGVtYShfZGF0YVJlZlNjaGVtYSwgX2RhdGFSZWZTY2hlbWFbc2NoZW1hSWRdLCBmYWxzZSk7XG4gICAgfVxuICAgIGRlZmF1bHRNZXRhKCkge1xuICAgICAgICBjb25zdCB7IG1ldGEsIHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIHJldHVybiAodGhpcy5vcHRzLmRlZmF1bHRNZXRhID0gdHlwZW9mIG1ldGEgPT0gXCJvYmplY3RcIiA/IG1ldGFbc2NoZW1hSWRdIHx8IG1ldGEgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICB2YWxpZGF0ZShzY2hlbWFLZXlSZWYsIC8vIGtleSwgcmVmIG9yIHNjaGVtYSBvYmplY3RcbiAgICBkYXRhIC8vIHRvIGJlIHZhbGlkYXRlZFxuICAgICkge1xuICAgICAgICBsZXQgdjtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWFLZXlSZWYgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdiA9IHRoaXMuZ2V0U2NoZW1hKHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICBpZiAoIXYpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBzY2hlbWEgd2l0aCBrZXkgb3IgcmVmIFwiJHtzY2hlbWFLZXlSZWZ9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLmNvbXBpbGUoc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZCA9IHYoZGF0YSk7XG4gICAgICAgIGlmICghKFwiJGFzeW5jXCIgaW4gdikpXG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IHYuZXJyb3JzO1xuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfVxuICAgIGNvbXBpbGUoc2NoZW1hLCBfbWV0YSkge1xuICAgICAgICBjb25zdCBzY2ggPSB0aGlzLl9hZGRTY2hlbWEoc2NoZW1hLCBfbWV0YSk7XG4gICAgICAgIHJldHVybiAoc2NoLnZhbGlkYXRlIHx8IHRoaXMuX2NvbXBpbGVTY2hlbWFFbnYoc2NoKSk7XG4gICAgfVxuICAgIGNvbXBpbGVBc3luYyhzY2hlbWEsIG1ldGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdHMubG9hZFNjaGVtYSAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9wdGlvbnMubG9hZFNjaGVtYSBzaG91bGQgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGxvYWRTY2hlbWEgfSA9IHRoaXMub3B0cztcbiAgICAgICAgcmV0dXJuIHJ1bkNvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHNjaGVtYSwgbWV0YSk7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHJ1bkNvbXBpbGVBc3luYyhfc2NoZW1hLCBfbWV0YSkge1xuICAgICAgICAgICAgYXdhaXQgbG9hZE1ldGFTY2hlbWEuY2FsbCh0aGlzLCBfc2NoZW1hLiRzY2hlbWEpO1xuICAgICAgICAgICAgY29uc3Qgc2NoID0gdGhpcy5fYWRkU2NoZW1hKF9zY2hlbWEsIF9tZXRhKTtcbiAgICAgICAgICAgIHJldHVybiBzY2gudmFsaWRhdGUgfHwgX2NvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHNjaCk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gbG9hZE1ldGFTY2hlbWEoJHJlZikge1xuICAgICAgICAgICAgaWYgKCRyZWYgJiYgIXRoaXMuZ2V0U2NoZW1hKCRyZWYpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcnVuQ29tcGlsZUFzeW5jLmNhbGwodGhpcywgeyAkcmVmIH0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIF9jb21waWxlQXN5bmMoc2NoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiByZWZfZXJyb3JfMS5kZWZhdWx0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICBjaGVja0xvYWRlZC5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGxvYWRNaXNzaW5nU2NoZW1hLmNhbGwodGhpcywgZS5taXNzaW5nU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHNjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tMb2FkZWQoeyBtaXNzaW5nU2NoZW1hOiByZWYsIG1pc3NpbmdSZWYgfSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVmc1tyZWZdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbnlTY2hlbWEgJHtyZWZ9IGlzIGxvYWRlZCBidXQgJHttaXNzaW5nUmVmfSBjYW5ub3QgYmUgcmVzb2x2ZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBsb2FkTWlzc2luZ1NjaGVtYShyZWYpIHtcbiAgICAgICAgICAgIGNvbnN0IF9zY2hlbWEgPSBhd2FpdCBfbG9hZFNjaGVtYS5jYWxsKHRoaXMsIHJlZik7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVmc1tyZWZdKVxuICAgICAgICAgICAgICAgIGF3YWl0IGxvYWRNZXRhU2NoZW1hLmNhbGwodGhpcywgX3NjaGVtYS4kc2NoZW1hKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWZzW3JlZl0pXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWEoX3NjaGVtYSwgcmVmLCBtZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBfbG9hZFNjaGVtYShyZWYpIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLl9sb2FkaW5nW3JlZl07XG4gICAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0ICh0aGlzLl9sb2FkaW5nW3JlZl0gPSBsb2FkU2NoZW1hKHJlZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xvYWRpbmdbcmVmXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBZGRzIHNjaGVtYSB0byB0aGUgaW5zdGFuY2VcbiAgICBhZGRTY2hlbWEoc2NoZW1hLCAvLyBJZiBhcnJheSBpcyBwYXNzZWQsIGBrZXlgIHdpbGwgYmUgaWdub3JlZFxuICAgIGtleSwgLy8gT3B0aW9uYWwgc2NoZW1hIGtleS4gQ2FuIGJlIHBhc3NlZCB0byBgdmFsaWRhdGVgIG1ldGhvZCBpbnN0ZWFkIG9mIHNjaGVtYSBvYmplY3Qgb3IgaWQvcmVmLiBPbmUgc2NoZW1hIHBlciBpbnN0YW5jZSBjYW4gaGF2ZSBlbXB0eSBgaWRgIGFuZCBga2V5YC5cbiAgICBfbWV0YSwgLy8gdHJ1ZSBpZiBzY2hlbWEgaXMgYSBtZXRhLXNjaGVtYS4gVXNlZCBpbnRlcm5hbGx5LCBhZGRNZXRhU2NoZW1hIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gICAgX3ZhbGlkYXRlU2NoZW1hID0gdGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hIC8vIGZhbHNlIHRvIHNraXAgc2NoZW1hIHZhbGlkYXRpb24uIFVzZWQgaW50ZXJuYWxseSwgb3B0aW9uIHZhbGlkYXRlU2NoZW1hIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gICAgKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2NoIG9mIHNjaGVtYSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNjaGVtYShzY2gsIHVuZGVmaW5lZCwgX21ldGEsIF92YWxpZGF0ZVNjaGVtYSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgICAgICBpZCA9IHNjaGVtYVtzY2hlbWFJZF07XG4gICAgICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgaWQgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2NoZW1hICR7c2NoZW1hSWR9IG11c3QgYmUgc3RyaW5nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKGtleSB8fCBpZCk7XG4gICAgICAgIHRoaXMuX2NoZWNrVW5pcXVlKGtleSk7XG4gICAgICAgIHRoaXMuc2NoZW1hc1trZXldID0gdGhpcy5fYWRkU2NoZW1hKHNjaGVtYSwgX21ldGEsIGtleSwgX3ZhbGlkYXRlU2NoZW1hLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEFkZCBzY2hlbWEgdGhhdCB3aWxsIGJlIHVzZWQgdG8gdmFsaWRhdGUgb3RoZXIgc2NoZW1hc1xuICAgIC8vIG9wdGlvbnMgaW4gTUVUQV9JR05PUkVfT1BUSU9OUyBhcmUgYWx3YXkgc2V0IHRvIGZhbHNlXG4gICAgYWRkTWV0YVNjaGVtYShzY2hlbWEsIGtleSwgLy8gc2NoZW1hIGtleVxuICAgIF92YWxpZGF0ZVNjaGVtYSA9IHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSAvLyBmYWxzZSB0byBza2lwIHNjaGVtYSB2YWxpZGF0aW9uLCBjYW4gYmUgdXNlZCB0byBvdmVycmlkZSB2YWxpZGF0ZVNjaGVtYSBvcHRpb24gZm9yIG1ldGEtc2NoZW1hXG4gICAgKSB7XG4gICAgICAgIHRoaXMuYWRkU2NoZW1hKHNjaGVtYSwga2V5LCB0cnVlLCBfdmFsaWRhdGVTY2hlbWEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gIFZhbGlkYXRlIHNjaGVtYSBhZ2FpbnN0IGl0cyBtZXRhLXNjaGVtYVxuICAgIHZhbGlkYXRlU2NoZW1hKHNjaGVtYSwgdGhyb3dPckxvZ0Vycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCAkc2NoZW1hO1xuICAgICAgICAkc2NoZW1hID0gc2NoZW1hLiRzY2hlbWE7XG4gICAgICAgIGlmICgkc2NoZW1hICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mICRzY2hlbWEgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJHNjaGVtYSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgICRzY2hlbWEgPSAkc2NoZW1hIHx8IHRoaXMub3B0cy5kZWZhdWx0TWV0YSB8fCB0aGlzLmRlZmF1bHRNZXRhKCk7XG4gICAgICAgIGlmICghJHNjaGVtYSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIm1ldGEtc2NoZW1hIG5vdCBhdmFpbGFibGVcIik7XG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZCA9IHRoaXMudmFsaWRhdGUoJHNjaGVtYSwgc2NoZW1hKTtcbiAgICAgICAgaWYgKCF2YWxpZCAmJiB0aHJvd09yTG9nRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBcInNjaGVtYSBpcyBpbnZhbGlkOiBcIiArIHRoaXMuZXJyb3JzVGV4dCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSA9PT0gXCJsb2dcIilcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cbiAgICAvLyBHZXQgY29tcGlsZWQgc2NoZW1hIGJ5IGBrZXlgIG9yIGByZWZgLlxuICAgIC8vIChga2V5YCB0aGF0IHdhcyBwYXNzZWQgdG8gYGFkZFNjaGVtYWAgb3IgZnVsbCBzY2hlbWEgcmVmZXJlbmNlIC0gYHNjaGVtYS4kaWRgIG9yIHJlc29sdmVkIGlkKVxuICAgIGdldFNjaGVtYShrZXlSZWYpIHtcbiAgICAgICAgbGV0IHNjaDtcbiAgICAgICAgd2hpbGUgKHR5cGVvZiAoc2NoID0gZ2V0U2NoRW52LmNhbGwodGhpcywga2V5UmVmKSkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGtleVJlZiA9IHNjaDtcbiAgICAgICAgaWYgKHNjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgICAgICBjb25zdCByb290ID0gbmV3IGNvbXBpbGVfMS5TY2hlbWFFbnYoeyBzY2hlbWE6IHt9LCBzY2hlbWFJZCB9KTtcbiAgICAgICAgICAgIHNjaCA9IGNvbXBpbGVfMS5yZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwga2V5UmVmKTtcbiAgICAgICAgICAgIGlmICghc2NoKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMucmVmc1trZXlSZWZdID0gc2NoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoc2NoLnZhbGlkYXRlIHx8IHRoaXMuX2NvbXBpbGVTY2hlbWFFbnYoc2NoKSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBjYWNoZWQgc2NoZW1hKHMpLlxuICAgIC8vIElmIG5vIHBhcmFtZXRlciBpcyBwYXNzZWQgYWxsIHNjaGVtYXMgYnV0IG1ldGEtc2NoZW1hcyBhcmUgcmVtb3ZlZC5cbiAgICAvLyBJZiBSZWdFeHAgaXMgcGFzc2VkIGFsbCBzY2hlbWFzIHdpdGgga2V5L2lkIG1hdGNoaW5nIHBhdHRlcm4gYnV0IG1ldGEtc2NoZW1hcyBhcmUgcmVtb3ZlZC5cbiAgICAvLyBFdmVuIGlmIHNjaGVtYSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIHNjaGVtYXMgaXQgc3RpbGwgY2FuIGJlIHJlbW92ZWQgYXMgb3RoZXIgc2NoZW1hcyBoYXZlIGxvY2FsIHJlZmVyZW5jZXMuXG4gICAgcmVtb3ZlU2NoZW1hKHNjaGVtYUtleVJlZikge1xuICAgICAgICBpZiAoc2NoZW1hS2V5UmVmIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMuc2NoZW1hcywgc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5yZWZzLCBzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0eXBlb2Ygc2NoZW1hS2V5UmVmKSB7XG4gICAgICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnNjaGVtYXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5yZWZzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoID0gZ2V0U2NoRW52LmNhbGwodGhpcywgc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaCA9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5kZWxldGUoc2NoLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2NoZW1hc1tzY2hlbWFLZXlSZWZdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlZnNbc2NoZW1hS2V5UmVmXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gc2NoZW1hS2V5UmVmO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmRlbGV0ZShjYWNoZUtleSk7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gc2NoZW1hS2V5UmVmW3RoaXMub3B0cy5zY2hlbWFJZF07XG4gICAgICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkID0gcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2NoZW1hc1tpZF07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlZnNbaWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2LnJlbW92ZVNjaGVtYTogaW52YWxpZCBwYXJhbWV0ZXJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWRkIFwidm9jYWJ1bGFyeVwiIC0gYSBjb2xsZWN0aW9uIG9mIGtleXdvcmRzXG4gICAgYWRkVm9jYWJ1bGFyeShkZWZpbml0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IGRlZiBvZiBkZWZpbml0aW9ucylcbiAgICAgICAgICAgIHRoaXMuYWRkS2V5d29yZChkZWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkS2V5d29yZChrd2RPckRlZiwgZGVmIC8vIGRlcHJlY2F0ZWRcbiAgICApIHtcbiAgICAgICAgbGV0IGtleXdvcmQ7XG4gICAgICAgIGlmICh0eXBlb2Yga3dkT3JEZWYgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAga2V5d29yZCA9IGt3ZE9yRGVmO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWYgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJ0aGVzZSBwYXJhbWV0ZXJzIGFyZSBkZXByZWNhdGVkLCBzZWUgZG9jcyBmb3IgYWRkS2V5d29yZFwiKTtcbiAgICAgICAgICAgICAgICBkZWYua2V5d29yZCA9IGtleXdvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGt3ZE9yRGVmID09IFwib2JqZWN0XCIgJiYgZGVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlZiA9IGt3ZE9yRGVmO1xuICAgICAgICAgICAga2V5d29yZCA9IGRlZi5rZXl3b3JkO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5d29yZCkgJiYgIWtleXdvcmQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWRkS2V5d29yZHM6IGtleXdvcmQgbXVzdCBiZSBzdHJpbmcgb3Igbm9uLWVtcHR5IGFycmF5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhZGRLZXl3b3JkcyBwYXJhbWV0ZXJzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrS2V5d29yZC5jYWxsKHRoaXMsIGtleXdvcmQsIGRlZik7XG4gICAgICAgIGlmICghZGVmKSB7XG4gICAgICAgICAgICB1dGlsXzEuZWFjaEl0ZW0oa2V5d29yZCwgKGt3ZCkgPT4gYWRkUnVsZS5jYWxsKHRoaXMsIGt3ZCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAga2V5d29yZE1ldGFzY2hlbWEuY2FsbCh0aGlzLCBkZWYpO1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgLi4uZGVmLFxuICAgICAgICAgICAgdHlwZTogZGF0YVR5cGVfMS5nZXRKU09OVHlwZXMoZGVmLnR5cGUpLFxuICAgICAgICAgICAgc2NoZW1hVHlwZTogZGF0YVR5cGVfMS5nZXRKU09OVHlwZXMoZGVmLnNjaGVtYVR5cGUpLFxuICAgICAgICB9O1xuICAgICAgICB1dGlsXzEuZWFjaEl0ZW0oa2V5d29yZCwgZGVmaW5pdGlvbi50eXBlLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgPyAoaykgPT4gYWRkUnVsZS5jYWxsKHRoaXMsIGssIGRlZmluaXRpb24pXG4gICAgICAgICAgICA6IChrKSA9PiBkZWZpbml0aW9uLnR5cGUuZm9yRWFjaCgodCkgPT4gYWRkUnVsZS5jYWxsKHRoaXMsIGssIGRlZmluaXRpb24sIHQpKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRLZXl3b3JkKGtleXdvcmQpIHtcbiAgICAgICAgY29uc3QgcnVsZSA9IHRoaXMuUlVMRVMuYWxsW2tleXdvcmRdO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHJ1bGUgPT0gXCJvYmplY3RcIiA/IHJ1bGUuZGVmaW5pdGlvbiA6ICEhcnVsZTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGtleXdvcmRcbiAgICByZW1vdmVLZXl3b3JkKGtleXdvcmQpIHtcbiAgICAgICAgLy8gVE9ETyByZXR1cm4gdHlwZSBzaG91bGQgYmUgQWp2XG4gICAgICAgIGNvbnN0IHsgUlVMRVMgfSA9IHRoaXM7XG4gICAgICAgIGRlbGV0ZSBSVUxFUy5rZXl3b3Jkc1trZXl3b3JkXTtcbiAgICAgICAgZGVsZXRlIFJVTEVTLmFsbFtrZXl3b3JkXTtcbiAgICAgICAgZm9yIChjb25zdCBncm91cCBvZiBSVUxFUy5ydWxlcykge1xuICAgICAgICAgICAgY29uc3QgaSA9IGdyb3VwLnJ1bGVzLmZpbmRJbmRleCgocnVsZSkgPT4gcnVsZS5rZXl3b3JkID09PSBrZXl3b3JkKTtcbiAgICAgICAgICAgIGlmIChpID49IDApXG4gICAgICAgICAgICAgICAgZ3JvdXAucnVsZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBBZGQgZm9ybWF0XG4gICAgYWRkRm9ybWF0KG5hbWUsIGZvcm1hdCkge1xuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgZm9ybWF0ID0gbmV3IFJlZ0V4cChmb3JtYXQpO1xuICAgICAgICB0aGlzLmZvcm1hdHNbbmFtZV0gPSBmb3JtYXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBlcnJvcnNUZXh0KGVycm9ycyA9IHRoaXMuZXJyb3JzLCAvLyBvcHRpb25hbCBhcnJheSBvZiB2YWxpZGF0aW9uIGVycm9yc1xuICAgIHsgc2VwYXJhdG9yID0gXCIsIFwiLCBkYXRhVmFyID0gXCJkYXRhXCIgfSA9IHt9IC8vIG9wdGlvbmFsIG9wdGlvbnMgd2l0aCBwcm9wZXJ0aWVzIGBzZXBhcmF0b3JgIGFuZCBgZGF0YVZhcmBcbiAgICApIHtcbiAgICAgICAgaWYgKCFlcnJvcnMgfHwgZXJyb3JzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBcIk5vIGVycm9yc1wiO1xuICAgICAgICByZXR1cm4gZXJyb3JzXG4gICAgICAgICAgICAubWFwKChlKSA9PiBgJHtkYXRhVmFyfSR7ZS5pbnN0YW5jZVBhdGh9ICR7ZS5tZXNzYWdlfWApXG4gICAgICAgICAgICAucmVkdWNlKCh0ZXh0LCBtc2cpID0+IHRleHQgKyBzZXBhcmF0b3IgKyBtc2cpO1xuICAgIH1cbiAgICAkZGF0YU1ldGFTY2hlbWEobWV0YVNjaGVtYSwga2V5d29yZHNKc29uUG9pbnRlcnMpIHtcbiAgICAgICAgY29uc3QgcnVsZXMgPSB0aGlzLlJVTEVTLmFsbDtcbiAgICAgICAgbWV0YVNjaGVtYSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobWV0YVNjaGVtYSkpO1xuICAgICAgICBmb3IgKGNvbnN0IGpzb25Qb2ludGVyIG9mIGtleXdvcmRzSnNvblBvaW50ZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50cyA9IGpzb25Qb2ludGVyLnNwbGl0KFwiL1wiKS5zbGljZSgxKTsgLy8gZmlyc3Qgc2VnbWVudCBpcyBhbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgIGxldCBrZXl3b3JkcyA9IG1ldGFTY2hlbWE7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNlZyBvZiBzZWdtZW50cylcbiAgICAgICAgICAgICAgICBrZXl3b3JkcyA9IGtleXdvcmRzW3NlZ107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBydWxlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBydWxlc1trZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcnVsZSAhPSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7ICRkYXRhIH0gPSBydWxlLmRlZmluaXRpb247XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0ga2V5d29yZHNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoJGRhdGEgJiYgc2NoZW1hKVxuICAgICAgICAgICAgICAgICAgICBrZXl3b3Jkc1trZXldID0gc2NoZW1hT3JEYXRhKHNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGFTY2hlbWE7XG4gICAgfVxuICAgIF9yZW1vdmVBbGxTY2hlbWFzKHNjaGVtYXMsIHJlZ2V4KSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5UmVmIGluIHNjaGVtYXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaCA9IHNjaGVtYXNba2V5UmVmXTtcbiAgICAgICAgICAgIGlmICghcmVnZXggfHwgcmVnZXgudGVzdChrZXlSZWYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2ggPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hc1trZXlSZWZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2ggJiYgIXNjaC5tZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmRlbGV0ZShzY2guc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYXNba2V5UmVmXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2FkZFNjaGVtYShzY2hlbWEsIG1ldGEsIGJhc2VJZCwgdmFsaWRhdGVTY2hlbWEgPSB0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEsIGFkZFNjaGVtYSA9IHRoaXMub3B0cy5hZGRVc2VkU2NoZW1hKSB7XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZCA9IHNjaGVtYVtzY2hlbWFJZF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLmp0ZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgbXVzdCBiZSBvYmplY3RcIik7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hICE9IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNjaGVtYSBtdXN0IGJlIG9iamVjdCBvciBib29sZWFuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzY2ggPSB0aGlzLl9jYWNoZS5nZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKHNjaCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHNjaDtcbiAgICAgICAgY29uc3QgbG9jYWxSZWZzID0gcmVzb2x2ZV8xLmdldFNjaGVtYVJlZnMuY2FsbCh0aGlzLCBzY2hlbWEpO1xuICAgICAgICBiYXNlSWQgPSByZXNvbHZlXzEubm9ybWFsaXplSWQoaWQgfHwgYmFzZUlkKTtcbiAgICAgICAgc2NoID0gbmV3IGNvbXBpbGVfMS5TY2hlbWFFbnYoeyBzY2hlbWEsIHNjaGVtYUlkLCBtZXRhLCBiYXNlSWQsIGxvY2FsUmVmcyB9KTtcbiAgICAgICAgdGhpcy5fY2FjaGUuc2V0KHNjaC5zY2hlbWEsIHNjaCk7XG4gICAgICAgIGlmIChhZGRTY2hlbWEgJiYgIWJhc2VJZC5zdGFydHNXaXRoKFwiI1wiKSkge1xuICAgICAgICAgICAgLy8gVE9ETyBhdG0gaXQgaXMgYWxsb3dlZCB0byBvdmVyd3JpdGUgc2NoZW1hcyB3aXRob3V0IGlkIChpbnN0ZWFkIG9mIG5vdCBhZGRpbmcgdGhlbSlcbiAgICAgICAgICAgIGlmIChiYXNlSWQpXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tVbmlxdWUoYmFzZUlkKTtcbiAgICAgICAgICAgIHRoaXMucmVmc1tiYXNlSWRdID0gc2NoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWxpZGF0ZVNjaGVtYSlcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVTY2hlbWEoc2NoZW1hLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHNjaDtcbiAgICB9XG4gICAgX2NoZWNrVW5pcXVlKGlkKSB7XG4gICAgICAgIGlmICh0aGlzLnNjaGVtYXNbaWRdIHx8IHRoaXMucmVmc1tpZF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2NoZW1hIHdpdGgga2V5IG9yIGlkIFwiJHtpZH1cIiBhbHJlYWR5IGV4aXN0c2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jb21waWxlU2NoZW1hRW52KHNjaCkge1xuICAgICAgICBpZiAoc2NoLm1ldGEpXG4gICAgICAgICAgICB0aGlzLl9jb21waWxlTWV0YVNjaGVtYShzY2gpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjb21waWxlXzEuY29tcGlsZVNjaGVtYS5jYWxsKHRoaXMsIHNjaCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXNjaC52YWxpZGF0ZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICAgICAgcmV0dXJuIHNjaC52YWxpZGF0ZTtcbiAgICB9XG4gICAgX2NvbXBpbGVNZXRhU2NoZW1hKHNjaCkge1xuICAgICAgICBjb25zdCBjdXJyZW50T3B0cyA9IHRoaXMub3B0cztcbiAgICAgICAgdGhpcy5vcHRzID0gdGhpcy5fbWV0YU9wdHM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb21waWxlXzEuY29tcGlsZVNjaGVtYS5jYWxsKHRoaXMsIHNjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLm9wdHMgPSBjdXJyZW50T3B0cztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEFqdjtcbkFqdi5WYWxpZGF0aW9uRXJyb3IgPSB2YWxpZGF0aW9uX2Vycm9yXzEuZGVmYXVsdDtcbkFqdi5NaXNzaW5nUmVmRXJyb3IgPSByZWZfZXJyb3JfMS5kZWZhdWx0O1xuZnVuY3Rpb24gY2hlY2tPcHRpb25zKGNoZWNrT3B0cywgb3B0aW9ucywgbXNnLCBsb2cgPSBcImVycm9yXCIpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGVja09wdHMpIHtcbiAgICAgICAgY29uc3Qgb3B0ID0ga2V5O1xuICAgICAgICBpZiAob3B0IGluIG9wdGlvbnMpXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcltsb2ddKGAke21zZ306IG9wdGlvbiAke2tleX0uICR7Y2hlY2tPcHRzW29wdF19YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U2NoRW52KGtleVJlZikge1xuICAgIGtleVJlZiA9IHJlc29sdmVfMS5ub3JtYWxpemVJZChrZXlSZWYpOyAvLyBUT0RPIHRlc3RzIGZhaWwgd2l0aG91dCB0aGlzIGxpbmVcbiAgICByZXR1cm4gdGhpcy5zY2hlbWFzW2tleVJlZl0gfHwgdGhpcy5yZWZzW2tleVJlZl07XG59XG5mdW5jdGlvbiBhZGRJbml0aWFsU2NoZW1hcygpIHtcbiAgICBjb25zdCBvcHRzU2NoZW1hcyA9IHRoaXMub3B0cy5zY2hlbWFzO1xuICAgIGlmICghb3B0c1NjaGVtYXMpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRzU2NoZW1hcykpXG4gICAgICAgIHRoaXMuYWRkU2NoZW1hKG9wdHNTY2hlbWFzKTtcbiAgICBlbHNlXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wdHNTY2hlbWFzKVxuICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWEob3B0c1NjaGVtYXNba2V5XSwga2V5KTtcbn1cbmZ1bmN0aW9uIGFkZEluaXRpYWxGb3JtYXRzKCkge1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLm9wdHMuZm9ybWF0cykge1xuICAgICAgICBjb25zdCBmb3JtYXQgPSB0aGlzLm9wdHMuZm9ybWF0c1tuYW1lXTtcbiAgICAgICAgaWYgKGZvcm1hdClcbiAgICAgICAgICAgIHRoaXMuYWRkRm9ybWF0KG5hbWUsIGZvcm1hdCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkSW5pdGlhbEtleXdvcmRzKGRlZnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZWZzKSkge1xuICAgICAgICB0aGlzLmFkZFZvY2FidWxhcnkoZGVmcyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIud2FybihcImtleXdvcmRzIG9wdGlvbiBhcyBtYXAgaXMgZGVwcmVjYXRlZCwgcGFzcyBhcnJheVwiKTtcbiAgICBmb3IgKGNvbnN0IGtleXdvcmQgaW4gZGVmcykge1xuICAgICAgICBjb25zdCBkZWYgPSBkZWZzW2tleXdvcmRdO1xuICAgICAgICBpZiAoIWRlZi5rZXl3b3JkKVxuICAgICAgICAgICAgZGVmLmtleXdvcmQgPSBrZXl3b3JkO1xuICAgICAgICB0aGlzLmFkZEtleXdvcmQoZGVmKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRNZXRhU2NoZW1hT3B0aW9ucygpIHtcbiAgICBjb25zdCBtZXRhT3B0cyA9IHsgLi4udGhpcy5vcHRzIH07XG4gICAgZm9yIChjb25zdCBvcHQgb2YgTUVUQV9JR05PUkVfT1BUSU9OUylcbiAgICAgICAgZGVsZXRlIG1ldGFPcHRzW29wdF07XG4gICAgcmV0dXJuIG1ldGFPcHRzO1xufVxuY29uc3Qgbm9Mb2dzID0geyBsb2coKSB7IH0sIHdhcm4oKSB7IH0sIGVycm9yKCkgeyB9IH07XG5mdW5jdGlvbiBnZXRMb2dnZXIobG9nZ2VyKSB7XG4gICAgaWYgKGxvZ2dlciA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybiBub0xvZ3M7XG4gICAgaWYgKGxvZ2dlciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gY29uc29sZTtcbiAgICBpZiAobG9nZ2VyLmxvZyAmJiBsb2dnZXIud2FybiAmJiBsb2dnZXIuZXJyb3IpXG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibG9nZ2VyIG11c3QgaW1wbGVtZW50IGxvZywgd2FybiBhbmQgZXJyb3IgbWV0aG9kc1wiKTtcbn1cbmNvbnN0IEtFWVdPUkRfTkFNRSA9IC9eW2Etel8kXVthLXowLTlfJDotXSokL2k7XG5mdW5jdGlvbiBjaGVja0tleXdvcmQoa2V5d29yZCwgZGVmKSB7XG4gICAgY29uc3QgeyBSVUxFUyB9ID0gdGhpcztcbiAgICB1dGlsXzEuZWFjaEl0ZW0oa2V5d29yZCwgKGt3ZCkgPT4ge1xuICAgICAgICBpZiAoUlVMRVMua2V5d29yZHNba3dkXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5d29yZCAke2t3ZH0gaXMgYWxyZWFkeSBkZWZpbmVkYCk7XG4gICAgICAgIGlmICghS0VZV09SRF9OQU1FLnRlc3Qoa3dkKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5d29yZCAke2t3ZH0gaGFzIGludmFsaWQgbmFtZWApO1xuICAgIH0pO1xuICAgIGlmICghZGVmKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGRlZi4kZGF0YSAmJiAhKFwiY29kZVwiIGluIGRlZiB8fCBcInZhbGlkYXRlXCIgaW4gZGVmKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyRkYXRhIGtleXdvcmQgbXVzdCBoYXZlIFwiY29kZVwiIG9yIFwidmFsaWRhdGVcIiBmdW5jdGlvbicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZFJ1bGUoa2V5d29yZCwgZGVmaW5pdGlvbiwgZGF0YVR5cGUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcG9zdCA9IGRlZmluaXRpb24gPT09IG51bGwgfHwgZGVmaW5pdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVmaW5pdGlvbi5wb3N0O1xuICAgIGlmIChkYXRhVHlwZSAmJiBwb3N0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tleXdvcmQgd2l0aCBcInBvc3RcIiBmbGFnIGNhbm5vdCBoYXZlIFwidHlwZVwiJyk7XG4gICAgY29uc3QgeyBSVUxFUyB9ID0gdGhpcztcbiAgICBsZXQgcnVsZUdyb3VwID0gcG9zdCA/IFJVTEVTLnBvc3QgOiBSVUxFUy5ydWxlcy5maW5kKCh7IHR5cGU6IHQgfSkgPT4gdCA9PT0gZGF0YVR5cGUpO1xuICAgIGlmICghcnVsZUdyb3VwKSB7XG4gICAgICAgIHJ1bGVHcm91cCA9IHsgdHlwZTogZGF0YVR5cGUsIHJ1bGVzOiBbXSB9O1xuICAgICAgICBSVUxFUy5ydWxlcy5wdXNoKHJ1bGVHcm91cCk7XG4gICAgfVxuICAgIFJVTEVTLmtleXdvcmRzW2tleXdvcmRdID0gdHJ1ZTtcbiAgICBpZiAoIWRlZmluaXRpb24pXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBydWxlID0ge1xuICAgICAgICBrZXl3b3JkLFxuICAgICAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgICAgICAuLi5kZWZpbml0aW9uLFxuICAgICAgICAgICAgdHlwZTogZGF0YVR5cGVfMS5nZXRKU09OVHlwZXMoZGVmaW5pdGlvbi50eXBlKSxcbiAgICAgICAgICAgIHNjaGVtYVR5cGU6IGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKGRlZmluaXRpb24uc2NoZW1hVHlwZSksXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBpZiAoZGVmaW5pdGlvbi5iZWZvcmUpXG4gICAgICAgIGFkZEJlZm9yZVJ1bGUuY2FsbCh0aGlzLCBydWxlR3JvdXAsIHJ1bGUsIGRlZmluaXRpb24uYmVmb3JlKTtcbiAgICBlbHNlXG4gICAgICAgIHJ1bGVHcm91cC5ydWxlcy5wdXNoKHJ1bGUpO1xuICAgIFJVTEVTLmFsbFtrZXl3b3JkXSA9IHJ1bGU7XG4gICAgKF9hID0gZGVmaW5pdGlvbi5pbXBsZW1lbnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCgoa3dkKSA9PiB0aGlzLmFkZEtleXdvcmQoa3dkKSk7XG59XG5mdW5jdGlvbiBhZGRCZWZvcmVSdWxlKHJ1bGVHcm91cCwgcnVsZSwgYmVmb3JlKSB7XG4gICAgY29uc3QgaSA9IHJ1bGVHcm91cC5ydWxlcy5maW5kSW5kZXgoKF9ydWxlKSA9PiBfcnVsZS5rZXl3b3JkID09PSBiZWZvcmUpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgICAgcnVsZUdyb3VwLnJ1bGVzLnNwbGljZShpLCAwLCBydWxlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJ1bGVHcm91cC5ydWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBydWxlICR7YmVmb3JlfSBpcyBub3QgZGVmaW5lZGApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGtleXdvcmRNZXRhc2NoZW1hKGRlZikge1xuICAgIGxldCB7IG1ldGFTY2hlbWEgfSA9IGRlZjtcbiAgICBpZiAobWV0YVNjaGVtYSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGRlZi4kZGF0YSAmJiB0aGlzLm9wdHMuJGRhdGEpXG4gICAgICAgIG1ldGFTY2hlbWEgPSBzY2hlbWFPckRhdGEobWV0YVNjaGVtYSk7XG4gICAgZGVmLnZhbGlkYXRlU2NoZW1hID0gdGhpcy5jb21waWxlKG1ldGFTY2hlbWEsIHRydWUpO1xufVxuY29uc3QgJGRhdGFSZWYgPSB7XG4gICAgJHJlZjogXCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vYWp2LXZhbGlkYXRvci9hanYvbWFzdGVyL2xpYi9yZWZzL2RhdGEuanNvbiNcIixcbn07XG5mdW5jdGlvbiBzY2hlbWFPckRhdGEoc2NoZW1hKSB7XG4gICAgcmV0dXJuIHsgYW55T2Y6IFtzY2hlbWEsICRkYXRhUmVmXSB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29yZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImlkXCIsXG4gICAgY29kZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOT1QgU1VQUE9SVEVEOiBrZXl3b3JkIFwiaWRcIiwgdXNlIFwiJGlkXCIgZm9yIHNjaGVtYSBJRCcpO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNhbGxSZWYgPSBleHBvcnRzLmdldFZhbGlkYXRlID0gdm9pZCAwO1xuY29uc3QgcmVmX2Vycm9yXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9yZWZfZXJyb3JcIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvbmFtZXNcIik7XG5jb25zdCBjb21waWxlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCIkcmVmXCIsXG4gICAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hOiAkcmVmLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IGJhc2VJZCwgc2NoZW1hRW52OiBlbnYsIHZhbGlkYXRlTmFtZSwgb3B0cywgc2VsZiB9ID0gaXQ7XG4gICAgICAgIGNvbnN0IHsgcm9vdCB9ID0gZW52O1xuICAgICAgICBpZiAoKCRyZWYgPT09IFwiI1wiIHx8ICRyZWYgPT09IFwiIy9cIikgJiYgYmFzZUlkID09PSByb290LmJhc2VJZClcbiAgICAgICAgICAgIHJldHVybiBjYWxsUm9vdFJlZigpO1xuICAgICAgICBjb25zdCBzY2hPckVudiA9IGNvbXBpbGVfMS5yZXNvbHZlUmVmLmNhbGwoc2VsZiwgcm9vdCwgYmFzZUlkLCAkcmVmKTtcbiAgICAgICAgaWYgKHNjaE9yRW52ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgcmVmX2Vycm9yXzEuZGVmYXVsdChiYXNlSWQsICRyZWYpO1xuICAgICAgICBpZiAoc2NoT3JFbnYgaW5zdGFuY2VvZiBjb21waWxlXzEuU2NoZW1hRW52KVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxWYWxpZGF0ZShzY2hPckVudik7XG4gICAgICAgIHJldHVybiBpbmxpbmVSZWZTY2hlbWEoc2NoT3JFbnYpO1xuICAgICAgICBmdW5jdGlvbiBjYWxsUm9vdFJlZigpIHtcbiAgICAgICAgICAgIGlmIChlbnYgPT09IHJvb3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxSZWYoY3h0LCB2YWxpZGF0ZU5hbWUsIGVudiwgZW52LiRhc3luYyk7XG4gICAgICAgICAgICBjb25zdCByb290TmFtZSA9IGdlbi5zY29wZVZhbHVlKFwicm9vdFwiLCB7IHJlZjogcm9vdCB9KTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsUmVmKGN4dCwgY29kZWdlbl8xLl8gYCR7cm9vdE5hbWV9LnZhbGlkYXRlYCwgcm9vdCwgcm9vdC4kYXN5bmMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhbGxWYWxpZGF0ZShzY2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBnZXRWYWxpZGF0ZShjeHQsIHNjaCk7XG4gICAgICAgICAgICBjYWxsUmVmKGN4dCwgdiwgc2NoLCBzY2guJGFzeW5jKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbmxpbmVSZWZTY2hlbWEoc2NoKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hOYW1lID0gZ2VuLnNjb3BlVmFsdWUoXCJzY2hlbWFcIiwgb3B0cy5jb2RlLnNvdXJjZSA9PT0gdHJ1ZSA/IHsgcmVmOiBzY2gsIGNvZGU6IGNvZGVnZW5fMS5zdHJpbmdpZnkoc2NoKSB9IDogeyByZWY6IHNjaCB9KTtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlczogW10sXG4gICAgICAgICAgICAgICAgc2NoZW1hUGF0aDogY29kZWdlbl8xLm5pbCxcbiAgICAgICAgICAgICAgICB0b3BTY2hlbWFSZWY6IHNjaE5hbWUsXG4gICAgICAgICAgICAgICAgZXJyU2NoZW1hUGF0aDogJHJlZixcbiAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQpO1xuICAgICAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZnVuY3Rpb24gZ2V0VmFsaWRhdGUoY3h0LCBzY2gpIHtcbiAgICBjb25zdCB7IGdlbiB9ID0gY3h0O1xuICAgIHJldHVybiBzY2gudmFsaWRhdGVcbiAgICAgICAgPyBnZW4uc2NvcGVWYWx1ZShcInZhbGlkYXRlXCIsIHsgcmVmOiBzY2gudmFsaWRhdGUgfSlcbiAgICAgICAgOiBjb2RlZ2VuXzEuXyBgJHtnZW4uc2NvcGVWYWx1ZShcIndyYXBwZXJcIiwgeyByZWY6IHNjaCB9KX0udmFsaWRhdGVgO1xufVxuZXhwb3J0cy5nZXRWYWxpZGF0ZSA9IGdldFZhbGlkYXRlO1xuZnVuY3Rpb24gY2FsbFJlZihjeHQsIHYsIHNjaCwgJGFzeW5jKSB7XG4gICAgY29uc3QgeyBnZW4sIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgeyBhbGxFcnJvcnMsIHNjaGVtYUVudjogZW52LCBvcHRzIH0gPSBpdDtcbiAgICBjb25zdCBwYXNzQ3h0ID0gb3B0cy5wYXNzQ29udGV4dCA/IG5hbWVzXzEuZGVmYXVsdC50aGlzIDogY29kZWdlbl8xLm5pbDtcbiAgICBpZiAoJGFzeW5jKVxuICAgICAgICBjYWxsQXN5bmNSZWYoKTtcbiAgICBlbHNlXG4gICAgICAgIGNhbGxTeW5jUmVmKCk7XG4gICAgZnVuY3Rpb24gY2FsbEFzeW5jUmVmKCkge1xuICAgICAgICBpZiAoIWVudi4kYXN5bmMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBzY2hlbWEgcmVmZXJlbmNlZCBieSBzeW5jIHNjaGVtYVwiKTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIik7XG4gICAgICAgIGdlbi50cnkoKCkgPT4ge1xuICAgICAgICAgICAgZ2VuLmNvZGUoY29kZWdlbl8xLl8gYGF3YWl0ICR7Y29kZV8xLmNhbGxWYWxpZGF0ZUNvZGUoY3h0LCB2LCBwYXNzQ3h0KX1gKTtcbiAgICAgICAgICAgIGFkZEV2YWx1YXRlZEZyb20odik7IC8vIFRPRE8gd2lsbCBub3Qgd29yayB3aXRoIGFzeW5jLCBpdCBoYXMgdG8gYmUgcmV0dXJuZWQgd2l0aCB0aGUgcmVzdWx0XG4gICAgICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgfSwgKGUpID0+IHtcbiAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgISgke2V9IGluc3RhbmNlb2YgJHtpdC5WYWxpZGF0aW9uRXJyb3J9KWAsICgpID0+IGdlbi50aHJvdyhlKSk7XG4gICAgICAgICAgICBhZGRFcnJvcnNGcm9tKGUpO1xuICAgICAgICAgICAgaWYgKCFhbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FsbFN5bmNSZWYoKSB7XG4gICAgICAgIGN4dC5yZXN1bHQoY29kZV8xLmNhbGxWYWxpZGF0ZUNvZGUoY3h0LCB2LCBwYXNzQ3h0KSwgKCkgPT4gYWRkRXZhbHVhdGVkRnJvbSh2KSwgKCkgPT4gYWRkRXJyb3JzRnJvbSh2KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZEVycm9yc0Zyb20oc291cmNlKSB7XG4gICAgICAgIGNvbnN0IGVycnMgPSBjb2RlZ2VuXzEuXyBgJHtzb3VyY2V9LmVycm9yc2A7XG4gICAgICAgIGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfSA9PT0gbnVsbCA/ICR7ZXJyc30gOiAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5jb25jYXQoJHtlcnJzfSlgKTsgLy8gVE9ETyB0YWdnZWRcbiAgICAgICAgZ2VuLmFzc2lnbihuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30ubGVuZ3RoYCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZEV2YWx1YXRlZEZyb20oc291cmNlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFpdC5vcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBzY2hFdmFsdWF0ZWQgPSAoX2EgPSBzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2gudmFsaWRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ldmFsdWF0ZWQ7XG4gICAgICAgIC8vIFRPRE8gcmVmYWN0b3JcbiAgICAgICAgaWYgKGl0LnByb3BzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoc2NoRXZhbHVhdGVkICYmICFzY2hFdmFsdWF0ZWQuZHluYW1pY1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaEV2YWx1YXRlZC5wcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgc2NoRXZhbHVhdGVkLnByb3BzLCBpdC5wcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBnZW4udmFyKFwicHJvcHNcIiwgY29kZWdlbl8xLl8gYCR7c291cmNlfS5ldmFsdWF0ZWQucHJvcHNgKTtcbiAgICAgICAgICAgICAgICBpdC5wcm9wcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5wcm9wcyhnZW4sIHByb3BzLCBpdC5wcm9wcywgY29kZWdlbl8xLk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5pdGVtcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHNjaEV2YWx1YXRlZCAmJiAhc2NoRXZhbHVhdGVkLmR5bmFtaWNJdGVtcykge1xuICAgICAgICAgICAgICAgIGlmIChzY2hFdmFsdWF0ZWQuaXRlbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpdC5pdGVtcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5pdGVtcyhnZW4sIHNjaEV2YWx1YXRlZC5pdGVtcywgaXQuaXRlbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gZ2VuLnZhcihcIml0ZW1zXCIsIGNvZGVnZW5fMS5fIGAke3NvdXJjZX0uZXZhbHVhdGVkLml0ZW1zYCk7XG4gICAgICAgICAgICAgICAgaXQuaXRlbXMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBpdGVtcywgaXQuaXRlbXMsIGNvZGVnZW5fMS5OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuY2FsbFJlZiA9IGNhbGxSZWY7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBpZF8xID0gcmVxdWlyZShcIi4vaWRcIik7XG5jb25zdCByZWZfMSA9IHJlcXVpcmUoXCIuL3JlZlwiKTtcbmNvbnN0IGNvcmUgPSBbXG4gICAgXCIkc2NoZW1hXCIsXG4gICAgXCIkaWRcIixcbiAgICBcIiRkZWZzXCIsXG4gICAgXCIkdm9jYWJ1bGFyeVwiLFxuICAgIHsga2V5d29yZDogXCIkY29tbWVudFwiIH0sXG4gICAgXCJkZWZpbml0aW9uc1wiLFxuICAgIGlkXzEuZGVmYXVsdCxcbiAgICByZWZfMS5kZWZhdWx0LFxuXTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBvcHMgPSBjb2RlZ2VuXzEub3BlcmF0b3JzO1xuY29uc3QgS1dEcyA9IHtcbiAgICBtYXhpbXVtOiB7IG9rU3RyOiBcIjw9XCIsIG9rOiBvcHMuTFRFLCBmYWlsOiBvcHMuR1QgfSxcbiAgICBtaW5pbXVtOiB7IG9rU3RyOiBcIj49XCIsIG9rOiBvcHMuR1RFLCBmYWlsOiBvcHMuTFQgfSxcbiAgICBleGNsdXNpdmVNYXhpbXVtOiB7IG9rU3RyOiBcIjxcIiwgb2s6IG9wcy5MVCwgZmFpbDogb3BzLkdURSB9LFxuICAgIGV4Y2x1c2l2ZU1pbmltdW06IHsgb2tTdHI6IFwiPlwiLCBvazogb3BzLkdULCBmYWlsOiBvcHMuTFRFIH0sXG59O1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBtdXN0IGJlICR7S1dEc1trZXl3b3JkXS5va1N0cn0gJHtzY2hlbWFDb2RlfWAsXG4gICAgcGFyYW1zOiAoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pID0+IGNvZGVnZW5fMS5fIGB7Y29tcGFyaXNvbjogJHtLV0RzW2tleXdvcmRdLm9rU3RyfSwgbGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogT2JqZWN0LmtleXMoS1dEcyksXG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSB9ID0gY3h0O1xuICAgICAgICBjeHQuZmFpbCRkYXRhKGNvZGVnZW5fMS5fIGAke2RhdGF9ICR7S1dEc1trZXl3b3JkXS5mYWlsfSAke3NjaGVtYUNvZGV9IHx8IGlzTmFOKCR7ZGF0YX0pYCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW1pdE51bWJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBzY2hlbWFDb2RlIH0pID0+IGNvZGVnZW5fMS5zdHIgYG11c3QgYmUgbXVsdGlwbGUgb2YgJHtzY2hlbWFDb2RlfWAsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+IGNvZGVnZW5fMS5fIGB7bXVsdGlwbGVPZjogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIm11bHRpcGxlT2ZcIixcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIC8vIGNvbnN0IGJkdCA9IGJhZCREYXRhVHlwZShzY2hlbWFDb2RlLCA8c3RyaW5nPmRlZi5zY2hlbWFUeXBlLCAkZGF0YSlcbiAgICAgICAgY29uc3QgcHJlYyA9IGl0Lm9wdHMubXVsdGlwbGVPZlByZWNpc2lvbjtcbiAgICAgICAgY29uc3QgcmVzID0gZ2VuLmxldChcInJlc1wiKTtcbiAgICAgICAgY29uc3QgaW52YWxpZCA9IHByZWNcbiAgICAgICAgICAgID8gY29kZWdlbl8xLl8gYE1hdGguYWJzKE1hdGgucm91bmQoJHtyZXN9KSAtICR7cmVzfSkgPiAxZS0ke3ByZWN9YFxuICAgICAgICAgICAgOiBjb2RlZ2VuXzEuXyBgJHtyZXN9ICE9PSBwYXJzZUludCgke3Jlc30pYDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YShjb2RlZ2VuXzEuXyBgKCR7c2NoZW1hQ29kZX0gPT09IDAgfHwgKCR7cmVzfSA9ICR7ZGF0YX0vJHtzY2hlbWFDb2RlfSwgJHtpbnZhbGlkfSkpYCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aXBsZU9mLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmdcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXN0aWVqcy9wdW55Y29kZS5qcyAtIHB1bnljb2RlLnVjczIuZGVjb2RlXG5mdW5jdGlvbiB1Y3MybGVuZ3RoKHN0cikge1xuICAgIGNvbnN0IGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgbGV0IHZhbHVlO1xuICAgIHdoaWxlIChwb3MgPCBsZW4pIHtcbiAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgIHZhbHVlID0gc3RyLmNoYXJDb2RlQXQocG9zKyspO1xuICAgICAgICBpZiAodmFsdWUgPj0gMHhkODAwICYmIHZhbHVlIDw9IDB4ZGJmZiAmJiBwb3MgPCBsZW4pIHtcbiAgICAgICAgICAgIC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuICAgICAgICAgICAgdmFsdWUgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKCh2YWx1ZSAmIDB4ZmMwMCkgPT09IDB4ZGMwMClcbiAgICAgICAgICAgICAgICBwb3MrKzsgLy8gbG93IHN1cnJvZ2F0ZVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZW5ndGg7XG59XG5leHBvcnRzLmRlZmF1bHQgPSB1Y3MybGVuZ3RoO1xudWNzMmxlbmd0aC5jb2RlID0gJ3JlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL3VjczJsZW5ndGhcIikuZGVmYXVsdCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11Y3MybGVuZ3RoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCB1Y3MybGVuZ3RoXzEgPSByZXF1aXJlKFwiLi4vLi4vcnVudGltZS91Y3MybGVuZ3RoXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZSh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkge1xuICAgICAgICBjb25zdCBjb21wID0ga2V5d29yZCA9PT0gXCJtYXhMZW5ndGhcIiA/IFwibW9yZVwiIDogXCJmZXdlclwiO1xuICAgICAgICByZXR1cm4gY29kZWdlbl8xLnN0ciBgbXVzdCBOT1QgaGF2ZSAke2NvbXB9IHRoYW4gJHtzY2hlbWFDb2RlfSBjaGFyYWN0ZXJzYDtcbiAgICB9LFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuXyBge2xpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFtcIm1heExlbmd0aFwiLCBcIm1pbkxlbmd0aFwiXSxcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4TGVuZ3RoXCIgPyBjb2RlZ2VuXzEub3BlcmF0b3JzLkdUIDogY29kZWdlbl8xLm9wZXJhdG9ycy5MVDtcbiAgICAgICAgY29uc3QgbGVuID0gaXQub3B0cy51bmljb2RlID09PSBmYWxzZSA/IGNvZGVnZW5fMS5fIGAke2RhdGF9Lmxlbmd0aGAgOiBjb2RlZ2VuXzEuXyBgJHt1dGlsXzEudXNlRnVuYyhjeHQuZ2VuLCB1Y3MybGVuZ3RoXzEuZGVmYXVsdCl9KCR7ZGF0YX0pYDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YShjb2RlZ2VuXzEuXyBgJHtsZW59ICR7b3B9ICR7c2NoZW1hQ29kZX1gKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0TGVuZ3RoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBtdXN0IG1hdGNoIHBhdHRlcm4gXCIke3NjaGVtYUNvZGV9XCJgLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuXyBge3BhdHRlcm46ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJwYXR0ZXJuXCIsXG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLy8gVE9ETyByZWdleHAgc2hvdWxkIGJlIHdyYXBwZWQgaW4gdHJ5L2NhdGNoc1xuICAgICAgICBjb25zdCB1ID0gaXQub3B0cy51bmljb2RlUmVnRXhwID8gXCJ1XCIgOiBcIlwiO1xuICAgICAgICBjb25zdCByZWdFeHAgPSAkZGF0YSA/IGNvZGVnZW5fMS5fIGAobmV3IFJlZ0V4cCgke3NjaGVtYUNvZGV9LCAke3V9KSlgIDogY29kZV8xLnVzZVBhdHRlcm4oY3h0LCBzY2hlbWEpO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKGNvZGVnZW5fMS5fIGAhJHtyZWdFeHB9LnRlc3QoJHtkYXRhfSlgKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdHRlcm4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZSh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkge1xuICAgICAgICBjb25zdCBjb21wID0ga2V5d29yZCA9PT0gXCJtYXhQcm9wZXJ0aWVzXCIgPyBcIm1vcmVcIiA6IFwiZmV3ZXJcIjtcbiAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5zdHIgYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gaXRlbXNgO1xuICAgIH0sXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+IGNvZGVnZW5fMS5fIGB7bGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogW1wibWF4UHJvcGVydGllc1wiLCBcIm1pblByb3BlcnRpZXNcIl0sXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSB9ID0gY3h0O1xuICAgICAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4UHJvcGVydGllc1wiID8gY29kZWdlbl8xLm9wZXJhdG9ycy5HVCA6IGNvZGVnZW5fMS5vcGVyYXRvcnMuTFQ7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoY29kZWdlbl8xLl8gYE9iamVjdC5rZXlzKCR7ZGF0YX0pLmxlbmd0aCAke29wfSAke3NjaGVtYUNvZGV9YCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW1pdFByb3BlcnRpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eSB9IH0pID0+IGNvZGVnZW5fMS5zdHIgYG11c3QgaGF2ZSByZXF1aXJlZCBwcm9wZXJ0eSAnJHttaXNzaW5nUHJvcGVydHl9J2AsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5IH0gfSkgPT4gY29kZWdlbl8xLl8gYHttaXNzaW5nUHJvcGVydHk6ICR7bWlzc2luZ1Byb3BlcnR5fX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInJlcXVpcmVkXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgc2NoZW1hQ29kZSwgZGF0YSwgJGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgb3B0cyB9ID0gaXQ7XG4gICAgICAgIGlmICghJGRhdGEgJiYgc2NoZW1hLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdXNlTG9vcCA9IHNjaGVtYS5sZW5ndGggPj0gb3B0cy5sb29wUmVxdWlyZWQ7XG4gICAgICAgIGlmIChpdC5hbGxFcnJvcnMpXG4gICAgICAgICAgICBhbGxFcnJvcnNNb2RlKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGV4aXRPbkVycm9yTW9kZSgpO1xuICAgICAgICBpZiAob3B0cy5zdHJpY3RSZXF1aXJlZCkge1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBjeHQucGFyZW50U2NoZW1hLnByb3BlcnRpZXM7XG4gICAgICAgICAgICBjb25zdCB7IGRlZmluZWRQcm9wZXJ0aWVzIH0gPSBjeHQuaXQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlcXVpcmVkS2V5IG9mIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGlmICgocHJvcHMgPT09IG51bGwgfHwgcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BzW3JlcXVpcmVkS2V5XSkgPT09IHVuZGVmaW5lZCAmJiAhZGVmaW5lZFByb3BlcnRpZXMuaGFzKHJlcXVpcmVkS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWFQYXRoID0gaXQuc2NoZW1hRW52LmJhc2VJZCArIGl0LmVyclNjaGVtYVBhdGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IGByZXF1aXJlZCBwcm9wZXJ0eSBcIiR7cmVxdWlyZWRLZXl9XCIgaXMgbm90IGRlZmluZWQgYXQgXCIke3NjaGVtYVBhdGh9XCIgKHN0cmljdFJlcXVpcmVkKWA7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5jaGVja1N0cmljdE1vZGUoaXQsIG1zZywgaXQub3B0cy5zdHJpY3RSZXF1aXJlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFsbEVycm9yc01vZGUoKSB7XG4gICAgICAgICAgICBpZiAodXNlTG9vcCB8fCAkZGF0YSkge1xuICAgICAgICAgICAgICAgIGN4dC5ibG9jayRkYXRhKGNvZGVnZW5fMS5uaWwsIGxvb3BBbGxSZXF1aXJlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2Ygc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGVfMS5jaGVja1JlcG9ydE1pc3NpbmdQcm9wKGN4dCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGV4aXRPbkVycm9yTW9kZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pc3NpbmcgPSBnZW4ubGV0KFwibWlzc2luZ1wiKTtcbiAgICAgICAgICAgIGlmICh1c2VMb29wIHx8ICRkYXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsICgpID0+IGxvb3BVbnRpbE1pc3NpbmcobWlzc2luZywgdmFsaWQpKTtcbiAgICAgICAgICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVfMS5jaGVja01pc3NpbmdQcm9wKGN4dCwgc2NoZW1hLCBtaXNzaW5nKSk7XG4gICAgICAgICAgICAgICAgY29kZV8xLnJlcG9ydE1pc3NpbmdQcm9wKGN4dCwgbWlzc2luZyk7XG4gICAgICAgICAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb29wQWxsUmVxdWlyZWQoKSB7XG4gICAgICAgICAgICBnZW4uZm9yT2YoXCJwcm9wXCIsIHNjaGVtYUNvZGUsIChwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IG1pc3NpbmdQcm9wZXJ0eTogcHJvcCB9KTtcbiAgICAgICAgICAgICAgICBnZW4uaWYoY29kZV8xLm5vUHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBvcHRzLm93blByb3BlcnRpZXMpLCAoKSA9PiBjeHQuZXJyb3IoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb29wVW50aWxNaXNzaW5nKG1pc3NpbmcsIHZhbGlkKSB7XG4gICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgbWlzc2luZ1Byb3BlcnR5OiBtaXNzaW5nIH0pO1xuICAgICAgICAgICAgZ2VuLmZvck9mKG1pc3NpbmcsIHNjaGVtYUNvZGUsICgpID0+IHtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBjb2RlXzEucHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBtaXNzaW5nLCBvcHRzLm93blByb3BlcnRpZXMpKTtcbiAgICAgICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLm5vdCh2YWxpZCksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5icmVhaygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgY29kZWdlbl8xLm5pbCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcXVpcmVkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2UoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pIHtcbiAgICAgICAgY29uc3QgY29tcCA9IGtleXdvcmQgPT09IFwibWF4SXRlbXNcIiA/IFwibW9yZVwiIDogXCJmZXdlclwiO1xuICAgICAgICByZXR1cm4gY29kZWdlbl8xLnN0ciBgbXVzdCBOT1QgaGF2ZSAke2NvbXB9IHRoYW4gJHtzY2hlbWFDb2RlfSBpdGVtc2A7XG4gICAgfSxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLl8gYHtsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBbXCJtYXhJdGVtc1wiLCBcIm1pbkl0ZW1zXCJdLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSB9ID0gY3h0O1xuICAgICAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4SXRlbXNcIiA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuR1QgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLkxUO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKGNvZGVnZW5fMS5fIGAke2RhdGF9Lmxlbmd0aCAke29wfSAke3NjaGVtYUNvZGV9YCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW1pdEl0ZW1zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Fqdi12YWxpZGF0b3IvYWp2L2lzc3Vlcy84ODlcbmNvbnN0IGVxdWFsID0gcmVxdWlyZShcImZhc3QtZGVlcC1lcXVhbFwiKTtcbmVxdWFsLmNvZGUgPSAncmVxdWlyZShcImFqdi9kaXN0L3J1bnRpbWUvZXF1YWxcIikuZGVmYXVsdCc7XG5leHBvcnRzLmRlZmF1bHQgPSBlcXVhbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVxdWFsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZGF0YVR5cGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlL2RhdGFUeXBlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcXVhbF8xID0gcmVxdWlyZShcIi4uLy4uL3J1bnRpbWUvZXF1YWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgaSwgaiB9IH0pID0+IGNvZGVnZW5fMS5zdHIgYG11c3QgTk9UIGhhdmUgZHVwbGljYXRlIGl0ZW1zIChpdGVtcyAjIyAke2p9IGFuZCAke2l9IGFyZSBpZGVudGljYWwpYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBpLCBqIH0gfSkgPT4gY29kZWdlbl8xLl8gYHtpOiAke2l9LCBqOiAke2p9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwidW5pcXVlSXRlbXNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogXCJib29sZWFuXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKCEkZGF0YSAmJiAhc2NoZW1hKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiKTtcbiAgICAgICAgY29uc3QgaXRlbVR5cGVzID0gcGFyZW50U2NoZW1hLml0ZW1zID8gZGF0YVR5cGVfMS5nZXRTY2hlbWFUeXBlcyhwYXJlbnRTY2hlbWEuaXRlbXMpIDogW107XG4gICAgICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCB2YWxpZGF0ZVVuaXF1ZUl0ZW1zLCBjb2RlZ2VuXzEuXyBgJHtzY2hlbWFDb2RlfSA9PT0gZmFsc2VgKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVVbmlxdWVJdGVtcygpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBnZW4ubGV0KFwiaVwiLCBjb2RlZ2VuXzEuXyBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICAgICAgICAgIGNvbnN0IGogPSBnZW4ubGV0KFwialwiKTtcbiAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBpLCBqIH0pO1xuICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7aX0gPiAxYCwgKCkgPT4gKGNhbk9wdGltaXplKCkgPyBsb29wTiA6IGxvb3BOMikoaSwgaikpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhbk9wdGltaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1UeXBlcy5sZW5ndGggPiAwICYmICFpdGVtVHlwZXMuc29tZSgodCkgPT4gdCA9PT0gXCJvYmplY3RcIiB8fCB0ID09PSBcImFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BOKGksIGopIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBnZW4ubmFtZShcIml0ZW1cIik7XG4gICAgICAgICAgICBjb25zdCB3cm9uZ1R5cGUgPSBkYXRhVHlwZV8xLmNoZWNrRGF0YVR5cGVzKGl0ZW1UeXBlcywgaXRlbSwgaXQub3B0cy5zdHJpY3ROdW1iZXJzLCBkYXRhVHlwZV8xLkRhdGFUeXBlLldyb25nKTtcbiAgICAgICAgICAgIGNvbnN0IGluZGljZXMgPSBnZW4uY29uc3QoXCJpbmRpY2VzXCIsIGNvZGVnZW5fMS5fIGB7fWApO1xuICAgICAgICAgICAgZ2VuLmZvcihjb2RlZ2VuXzEuXyBgOyR7aX0tLTtgLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZ2VuLmxldChpdGVtLCBjb2RlZ2VuXzEuXyBgJHtkYXRhfVske2l9XWApO1xuICAgICAgICAgICAgICAgIGdlbi5pZih3cm9uZ1R5cGUsIGNvZGVnZW5fMS5fIGBjb250aW51ZWApO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtVHlwZXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGB0eXBlb2YgJHtpdGVtfSA9PSBcInN0cmluZ1wiYCwgY29kZWdlbl8xLl8gYCR7aXRlbX0gKz0gXCJfXCJgKTtcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmlmKGNvZGVnZW5fMS5fIGB0eXBlb2YgJHtpbmRpY2VzfVske2l0ZW19XSA9PSBcIm51bWJlclwiYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKGosIGNvZGVnZW5fMS5fIGAke2luZGljZXN9WyR7aXRlbX1dYCk7XG4gICAgICAgICAgICAgICAgICAgIGN4dC5lcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuYnJlYWsoKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY29kZShjb2RlZ2VuXzEuXyBgJHtpbmRpY2VzfVske2l0ZW19XSA9ICR7aX1gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BOMihpLCBqKSB7XG4gICAgICAgICAgICBjb25zdCBlcWwgPSB1dGlsXzEudXNlRnVuYyhnZW4sIGVxdWFsXzEuZGVmYXVsdCk7XG4gICAgICAgICAgICBjb25zdCBvdXRlciA9IGdlbi5uYW1lKFwib3V0ZXJcIik7XG4gICAgICAgICAgICBnZW4ubGFiZWwob3V0ZXIpLmZvcihjb2RlZ2VuXzEuXyBgOyR7aX0tLTtgLCAoKSA9PiBnZW4uZm9yKGNvZGVnZW5fMS5fIGAke2p9ID0gJHtpfTsgJHtqfS0tO2AsICgpID0+IGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtlcWx9KCR7ZGF0YX1bJHtpfV0sICR7ZGF0YX1bJHtqfV0pYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGN4dC5lcnJvcigpO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhayhvdXRlcik7XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmlxdWVJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXF1YWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL2VxdWFsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IGJlIGVxdWFsIHRvIGNvbnN0YW50XCIsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+IGNvZGVnZW5fMS5fIGB7YWxsb3dlZFZhbHVlOiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiY29uc3RcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYUNvZGUsIHNjaGVtYSB9ID0gY3h0O1xuICAgICAgICBpZiAoJGRhdGEgfHwgKHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICBjeHQuZmFpbCRkYXRhKGNvZGVnZW5fMS5fIGAhJHt1dGlsXzEudXNlRnVuYyhnZW4sIGVxdWFsXzEuZGVmYXVsdCl9KCR7ZGF0YX0sICR7c2NoZW1hQ29kZX0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjeHQuZmFpbChjb2RlZ2VuXzEuXyBgJHtzY2hlbWF9ICE9PSAke2RhdGF9YCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcXVhbF8xID0gcmVxdWlyZShcIi4uLy4uL3J1bnRpbWUvZXF1YWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiBcIm11c3QgYmUgZXF1YWwgdG8gb25lIG9mIHRoZSBhbGxvd2VkIHZhbHVlc1wiLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuXyBge2FsbG93ZWRWYWx1ZXM6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJlbnVtXCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoISRkYXRhICYmIHNjaGVtYS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbnVtIG11c3QgaGF2ZSBub24tZW1wdHkgYXJyYXlcIik7XG4gICAgICAgIGNvbnN0IHVzZUxvb3AgPSBzY2hlbWEubGVuZ3RoID49IGl0Lm9wdHMubG9vcEVudW07XG4gICAgICAgIGNvbnN0IGVxbCA9IHV0aWxfMS51c2VGdW5jKGdlbiwgZXF1YWxfMS5kZWZhdWx0KTtcbiAgICAgICAgbGV0IHZhbGlkO1xuICAgICAgICBpZiAodXNlTG9vcCB8fCAkZGF0YSkge1xuICAgICAgICAgICAgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIik7XG4gICAgICAgICAgICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgbG9vcEVudW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgICAgICBjb25zdCB2U2NoZW1hID0gZ2VuLmNvbnN0KFwidlNjaGVtYVwiLCBzY2hlbWFDb2RlKTtcbiAgICAgICAgICAgIHZhbGlkID0gY29kZWdlbl8xLm9yKC4uLnNjaGVtYS5tYXAoKF94LCBpKSA9PiBlcXVhbENvZGUodlNjaGVtYSwgaSkpKTtcbiAgICAgICAgfVxuICAgICAgICBjeHQucGFzcyh2YWxpZCk7XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BFbnVtKCkge1xuICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpO1xuICAgICAgICAgICAgZ2VuLmZvck9mKFwidlwiLCBzY2hlbWFDb2RlLCAodikgPT4gZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2VxbH0oJHtkYXRhfSwgJHt2fSlgLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKS5icmVhaygpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZXF1YWxDb2RlKHZTY2hlbWEsIGkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaCA9IHNjaGVtYVtpXTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygc2NoID09PSBcIm9iamVjdFwiICYmIHNjaCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gY29kZWdlbl8xLl8gYCR7ZXFsfSgke2RhdGF9LCAke3ZTY2hlbWF9WyR7aX1dKWBcbiAgICAgICAgICAgICAgICA6IGNvZGVnZW5fMS5fIGAke2RhdGF9ID09PSAke3NjaH1gO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnVtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgbGltaXROdW1iZXJfMSA9IHJlcXVpcmUoXCIuL2xpbWl0TnVtYmVyXCIpO1xuY29uc3QgbXVsdGlwbGVPZl8xID0gcmVxdWlyZShcIi4vbXVsdGlwbGVPZlwiKTtcbmNvbnN0IGxpbWl0TGVuZ3RoXzEgPSByZXF1aXJlKFwiLi9saW1pdExlbmd0aFwiKTtcbmNvbnN0IHBhdHRlcm5fMSA9IHJlcXVpcmUoXCIuL3BhdHRlcm5cIik7XG5jb25zdCBsaW1pdFByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL2xpbWl0UHJvcGVydGllc1wiKTtcbmNvbnN0IHJlcXVpcmVkXzEgPSByZXF1aXJlKFwiLi9yZXF1aXJlZFwiKTtcbmNvbnN0IGxpbWl0SXRlbXNfMSA9IHJlcXVpcmUoXCIuL2xpbWl0SXRlbXNcIik7XG5jb25zdCB1bmlxdWVJdGVtc18xID0gcmVxdWlyZShcIi4vdW5pcXVlSXRlbXNcIik7XG5jb25zdCBjb25zdF8xID0gcmVxdWlyZShcIi4vY29uc3RcIik7XG5jb25zdCBlbnVtXzEgPSByZXF1aXJlKFwiLi9lbnVtXCIpO1xuY29uc3QgdmFsaWRhdGlvbiA9IFtcbiAgICAvLyBudW1iZXJcbiAgICBsaW1pdE51bWJlcl8xLmRlZmF1bHQsXG4gICAgbXVsdGlwbGVPZl8xLmRlZmF1bHQsXG4gICAgLy8gc3RyaW5nXG4gICAgbGltaXRMZW5ndGhfMS5kZWZhdWx0LFxuICAgIHBhdHRlcm5fMS5kZWZhdWx0LFxuICAgIC8vIG9iamVjdFxuICAgIGxpbWl0UHJvcGVydGllc18xLmRlZmF1bHQsXG4gICAgcmVxdWlyZWRfMS5kZWZhdWx0LFxuICAgIC8vIGFycmF5XG4gICAgbGltaXRJdGVtc18xLmRlZmF1bHQsXG4gICAgdW5pcXVlSXRlbXNfMS5kZWZhdWx0LFxuICAgIC8vIGFueVxuICAgIHsga2V5d29yZDogXCJ0eXBlXCIsIHNjaGVtYVR5cGU6IFtcInN0cmluZ1wiLCBcImFycmF5XCJdIH0sXG4gICAgeyBrZXl3b3JkOiBcIm51bGxhYmxlXCIsIHNjaGVtYVR5cGU6IFwiYm9vbGVhblwiIH0sXG4gICAgY29uc3RfMS5kZWZhdWx0LFxuICAgIGVudW1fMS5kZWZhdWx0LFxuXTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZhbGlkYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBsZW4gfSB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBtdXN0IE5PVCBoYXZlIG1vcmUgdGhhbiAke2xlbn0gaXRlbXNgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IGxlbiB9IH0pID0+IGNvZGVnZW5fMS5fIGB7bGltaXQ6ICR7bGVufX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImFkZGl0aW9uYWxJdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJib29sZWFuXCIsIFwib2JqZWN0XCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IGl0ZW1zIH0gPSBwYXJlbnRTY2hlbWE7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgICAgIHV0aWxfMS5jaGVja1N0cmljdE1vZGUoaXQsICdcImFkZGl0aW9uYWxJdGVtc1wiIGlzIGlnbm9yZWQgd2hlbiBcIml0ZW1zXCIgaXMgbm90IGFuIGFycmF5IG9mIHNjaGVtYXMnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyhjeHQsIGl0ZW1zKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zKGN4dCwgaXRlbXMpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBkYXRhLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgIGl0Lml0ZW1zID0gdHJ1ZTtcbiAgICBjb25zdCBsZW4gPSBnZW4uY29uc3QoXCJsZW5cIiwgY29kZWdlbl8xLl8gYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7IGxlbjogaXRlbXMubGVuZ3RoIH0pO1xuICAgICAgICBjeHQucGFzcyhjb2RlZ2VuXzEuXyBgJHtsZW59IDw9ICR7aXRlbXMubGVuZ3RofWApO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgIXV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSkge1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi52YXIoXCJ2YWxpZFwiLCBjb2RlZ2VuXzEuXyBgJHtsZW59IDw9ICR7aXRlbXMubGVuZ3RofWApOyAvLyBUT0RPIHZhclxuICAgICAgICBnZW4uaWYoY29kZWdlbl8xLm5vdCh2YWxpZCksICgpID0+IHZhbGlkYXRlSXRlbXModmFsaWQpKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyh2YWxpZCkge1xuICAgICAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIGl0ZW1zLmxlbmd0aCwgbGVuLCAoaSkgPT4ge1xuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQsIGRhdGFQcm9wOiBpLCBkYXRhUHJvcFR5cGU6IHV0aWxfMS5UeXBlLk51bSB9LCB2YWxpZCk7XG4gICAgICAgICAgICBpZiAoIWl0LmFsbEVycm9ycylcbiAgICAgICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLm5vdCh2YWxpZCksICgpID0+IGdlbi5icmVhaygpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyA9IHZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkaXRpb25hbEl0ZW1zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZVR1cGxlID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIml0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImFycmF5XCIsIFwiYm9vbGVhblwiXSxcbiAgICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IHNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZVR1cGxlKGN4dCwgXCJhZGRpdGlvbmFsSXRlbXNcIiwgc2NoZW1hKTtcbiAgICAgICAgaXQuaXRlbXMgPSB0cnVlO1xuICAgICAgICBpZiAodXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjeHQub2soY29kZV8xLnZhbGlkYXRlQXJyYXkoY3h0KSk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZVR1cGxlKGN4dCwgZXh0cmFJdGVtcywgc2NoQXJyID0gY3h0LnNjaGVtYSkge1xuICAgIGNvbnN0IHsgZ2VuLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgY2hlY2tTdHJpY3RUdXBsZShwYXJlbnRTY2hlbWEpO1xuICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIHNjaEFyci5sZW5ndGggJiYgaXQuaXRlbXMgIT09IHRydWUpIHtcbiAgICAgICAgaXQuaXRlbXMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBzY2hBcnIubGVuZ3RoLCBpdC5pdGVtcyk7XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICBjb25zdCBsZW4gPSBnZW4uY29uc3QoXCJsZW5cIiwgY29kZWdlbl8xLl8gYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgc2NoQXJyLmZvckVhY2goKHNjaCwgaSkgPT4ge1xuICAgICAgICBpZiAodXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2gpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7bGVufSA+ICR7aX1gLCAoKSA9PiBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgICAgZGF0YVByb3A6IGksXG4gICAgICAgIH0sIHZhbGlkKSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gY2hlY2tTdHJpY3RUdXBsZShzY2gpIHtcbiAgICAgICAgY29uc3QgeyBvcHRzLCBlcnJTY2hlbWFQYXRoIH0gPSBpdDtcbiAgICAgICAgY29uc3QgbCA9IHNjaEFyci5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGZ1bGxUdXBsZSA9IGwgPT09IHNjaC5taW5JdGVtcyAmJiAobCA9PT0gc2NoLm1heEl0ZW1zIHx8IHNjaFtleHRyYUl0ZW1zXSA9PT0gZmFsc2UpO1xuICAgICAgICBpZiAob3B0cy5zdHJpY3RUdXBsZXMgJiYgIWZ1bGxUdXBsZSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYFwiJHtrZXl3b3JkfVwiIGlzICR7bH0tdHVwbGUsIGJ1dCBtaW5JdGVtcyBvciBtYXhJdGVtcy8ke2V4dHJhSXRlbXN9IGFyZSBub3Qgc3BlY2lmaWVkIG9yIGRpZmZlcmVudCBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiYDtcbiAgICAgICAgICAgIHV0aWxfMS5jaGVja1N0cmljdE1vZGUoaXQsIG1zZywgb3B0cy5zdHJpY3RUdXBsZXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVR1cGxlID0gdmFsaWRhdGVUdXBsZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWl0ZW1zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgaXRlbXNfMSA9IHJlcXVpcmUoXCIuL2l0ZW1zXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicHJlZml4SXRlbXNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogW1wiYXJyYXlcIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgY29kZTogKGN4dCkgPT4gaXRlbXNfMS52YWxpZGF0ZVR1cGxlKGN4dCwgXCJpdGVtc1wiKSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVmaXhJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBhZGRpdGlvbmFsSXRlbXNfMSA9IHJlcXVpcmUoXCIuL2FkZGl0aW9uYWxJdGVtc1wiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBsZW4gfSB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBtdXN0IE5PVCBoYXZlIG1vcmUgdGhhbiAke2xlbn0gaXRlbXNgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IGxlbiB9IH0pID0+IGNvZGVnZW5fMS5fIGB7bGltaXQ6ICR7bGVufX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIml0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBwcmVmaXhJdGVtcyB9ID0gcGFyZW50U2NoZW1hO1xuICAgICAgICBpdC5pdGVtcyA9IHRydWU7XG4gICAgICAgIGlmICh1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChwcmVmaXhJdGVtcylcbiAgICAgICAgICAgIGFkZGl0aW9uYWxJdGVtc18xLnZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zKGN4dCwgcHJlZml4SXRlbXMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjeHQub2soY29kZV8xLnZhbGlkYXRlQXJyYXkoY3h0KSk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pdGVtczIwMjAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBtaW4sIG1heCB9IH0pID0+IG1heCA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gY29kZWdlbl8xLnN0ciBgbXVzdCBjb250YWluIGF0IGxlYXN0ICR7bWlufSB2YWxpZCBpdGVtKHMpYFxuICAgICAgICA6IGNvZGVnZW5fMS5zdHIgYG11c3QgY29udGFpbiBhdCBsZWFzdCAke21pbn0gYW5kIG5vIG1vcmUgdGhhbiAke21heH0gdmFsaWQgaXRlbShzKWAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgbWluLCBtYXggfSB9KSA9PiBtYXggPT09IHVuZGVmaW5lZCA/IGNvZGVnZW5fMS5fIGB7bWluQ29udGFpbnM6ICR7bWlufX1gIDogY29kZWdlbl8xLl8gYHttaW5Db250YWluczogJHttaW59LCBtYXhDb250YWluczogJHttYXh9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiY29udGFpbnNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGxldCBtaW47XG4gICAgICAgIGxldCBtYXg7XG4gICAgICAgIGNvbnN0IHsgbWluQ29udGFpbnMsIG1heENvbnRhaW5zIH0gPSBwYXJlbnRTY2hlbWE7XG4gICAgICAgIGlmIChpdC5vcHRzLm5leHQpIHtcbiAgICAgICAgICAgIG1pbiA9IG1pbkNvbnRhaW5zID09PSB1bmRlZmluZWQgPyAxIDogbWluQ29udGFpbnM7XG4gICAgICAgICAgICBtYXggPSBtYXhDb250YWlucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1pbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsIGNvZGVnZW5fMS5fIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHsgbWluLCBtYXggfSk7XG4gICAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCAmJiBtaW4gPT09IDApIHtcbiAgICAgICAgICAgIHV0aWxfMS5jaGVja1N0cmljdE1vZGUoaXQsIGBcIm1pbkNvbnRhaW5zXCIgPT0gMCB3aXRob3V0IFwibWF4Q29udGFpbnNcIjogXCJjb250YWluc1wiIGtleXdvcmQgaWdub3JlZGApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXggIT09IHVuZGVmaW5lZCAmJiBtaW4gPiBtYXgpIHtcbiAgICAgICAgICAgIHV0aWxfMS5jaGVja1N0cmljdE1vZGUoaXQsIGBcIm1pbkNvbnRhaW5zXCIgPiBcIm1heENvbnRhaW5zXCIgaXMgYWx3YXlzIGludmFsaWRgKTtcbiAgICAgICAgICAgIGN4dC5mYWlsKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSkge1xuICAgICAgICAgICAgbGV0IGNvbmQgPSBjb2RlZ2VuXzEuXyBgJHtsZW59ID49ICR7bWlufWA7XG4gICAgICAgICAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29uZCA9IGNvZGVnZW5fMS5fIGAke2NvbmR9ICYmICR7bGVufSA8PSAke21heH1gO1xuICAgICAgICAgICAgY3h0LnBhc3MoY29uZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaXQuaXRlbXMgPSB0cnVlO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCAmJiBtaW4gPT09IDEpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlSXRlbXModmFsaWQsICgpID0+IGdlbi5pZih2YWxpZCwgKCkgPT4gZ2VuLmJyZWFrKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdlbi5sZXQodmFsaWQsIGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIik7XG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IGdlbi5sZXQoXCJjb3VudFwiLCAwKTtcbiAgICAgICAgICAgIHZhbGlkYXRlSXRlbXMoc2NoVmFsaWQsICgpID0+IGdlbi5pZihzY2hWYWxpZCwgKCkgPT4gY2hlY2tMaW1pdHMoY291bnQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3h0LnJlc3VsdCh2YWxpZCwgKCkgPT4gY3h0LnJlc2V0KCkpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUl0ZW1zKF92YWxpZCwgYmxvY2spIHtcbiAgICAgICAgICAgIGdlbi5mb3JSYW5nZShcImlcIiwgMCwgbGVuLCAoaSkgPT4ge1xuICAgICAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcImNvbnRhaW5zXCIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBpLFxuICAgICAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IHV0aWxfMS5UeXBlLk51bSxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LCBfdmFsaWQpO1xuICAgICAgICAgICAgICAgIGJsb2NrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGVja0xpbWl0cyhjb3VudCkge1xuICAgICAgICAgICAgZ2VuLmNvZGUoY29kZWdlbl8xLl8gYCR7Y291bnR9KytgKTtcbiAgICAgICAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtjb3VudH0gPj0gJHttaW59YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkuYnJlYWsoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7Y291bnR9ID4gJHttYXh9YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmJyZWFrKCkpO1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2NvdW50fSA+PSAke21pbn1gLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRhaW5zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZVNjaGVtYURlcHMgPSBleHBvcnRzLnZhbGlkYXRlUHJvcGVydHlEZXBzID0gZXhwb3J0cy5lcnJvciA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5leHBvcnRzLmVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBwcm9wZXJ0eSwgZGVwc0NvdW50LCBkZXBzIH0gfSkgPT4ge1xuICAgICAgICBjb25zdCBwcm9wZXJ0eV9pZXMgPSBkZXBzQ291bnQgPT09IDEgPyBcInByb3BlcnR5XCIgOiBcInByb3BlcnRpZXNcIjtcbiAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5zdHIgYG11c3QgaGF2ZSAke3Byb3BlcnR5X2llc30gJHtkZXBzfSB3aGVuIHByb3BlcnR5ICR7cHJvcGVydHl9IGlzIHByZXNlbnRgO1xuICAgIH0sXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgcHJvcGVydHksIGRlcHNDb3VudCwgZGVwcywgbWlzc2luZ1Byb3BlcnR5IH0gfSkgPT4gY29kZWdlbl8xLl8gYHtwcm9wZXJ0eTogJHtwcm9wZXJ0eX0sXG4gICAgbWlzc2luZ1Byb3BlcnR5OiAke21pc3NpbmdQcm9wZXJ0eX0sXG4gICAgZGVwc0NvdW50OiAke2RlcHNDb3VudH0sXG4gICAgZGVwczogJHtkZXBzfX1gLCAvLyBUT0RPIGNoYW5nZSB0byByZWZlcmVuY2Vcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJkZXBlbmRlbmNpZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gICAgZXJyb3I6IGV4cG9ydHMuZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgW3Byb3BEZXBzLCBzY2hEZXBzXSA9IHNwbGl0RGVwZW5kZW5jaWVzKGN4dCk7XG4gICAgICAgIHZhbGlkYXRlUHJvcGVydHlEZXBzKGN4dCwgcHJvcERlcHMpO1xuICAgICAgICB2YWxpZGF0ZVNjaGVtYURlcHMoY3h0LCBzY2hEZXBzKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHNwbGl0RGVwZW5kZW5jaWVzKHsgc2NoZW1hIH0pIHtcbiAgICBjb25zdCBwcm9wZXJ0eURlcHMgPSB7fTtcbiAgICBjb25zdCBzY2hlbWFEZXBzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGlmIChrZXkgPT09IFwiX19wcm90b19fXCIpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgZGVwcyA9IEFycmF5LmlzQXJyYXkoc2NoZW1hW2tleV0pID8gcHJvcGVydHlEZXBzIDogc2NoZW1hRGVwcztcbiAgICAgICAgZGVwc1trZXldID0gc2NoZW1hW2tleV07XG4gICAgfVxuICAgIHJldHVybiBbcHJvcGVydHlEZXBzLCBzY2hlbWFEZXBzXTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHlEZXBzKGN4dCwgcHJvcGVydHlEZXBzID0gY3h0LnNjaGVtYSkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgIGlmIChPYmplY3Qua2V5cyhwcm9wZXJ0eURlcHMpLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG1pc3NpbmcgPSBnZW4ubGV0KFwibWlzc2luZ1wiKTtcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcGVydHlEZXBzKSB7XG4gICAgICAgIGNvbnN0IGRlcHMgPSBwcm9wZXJ0eURlcHNbcHJvcF07XG4gICAgICAgIGlmIChkZXBzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBoYXNQcm9wZXJ0eSA9IGNvZGVfMS5wcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3AsIGl0Lm9wdHMub3duUHJvcGVydGllcyk7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoe1xuICAgICAgICAgICAgcHJvcGVydHk6IHByb3AsXG4gICAgICAgICAgICBkZXBzQ291bnQ6IGRlcHMubGVuZ3RoLFxuICAgICAgICAgICAgZGVwczogZGVwcy5qb2luKFwiLCBcIiksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgICAgICBnZW4uaWYoaGFzUHJvcGVydHksICgpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlcFByb3Agb2YgZGVwcykge1xuICAgICAgICAgICAgICAgICAgICBjb2RlXzEuY2hlY2tSZXBvcnRNaXNzaW5nUHJvcChjeHQsIGRlcFByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2hhc1Byb3BlcnR5fSAmJiAoJHtjb2RlXzEuY2hlY2tNaXNzaW5nUHJvcChjeHQsIGRlcHMsIG1pc3NpbmcpfSlgKTtcbiAgICAgICAgICAgIGNvZGVfMS5yZXBvcnRNaXNzaW5nUHJvcChjeHQsIG1pc3NpbmcpO1xuICAgICAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVQcm9wZXJ0eURlcHMgPSB2YWxpZGF0ZVByb3BlcnR5RGVwcztcbmZ1bmN0aW9uIHZhbGlkYXRlU2NoZW1hRGVwcyhjeHQsIHNjaGVtYURlcHMgPSBjeHQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBzY2hlbWFEZXBzKSB7XG4gICAgICAgIGlmICh1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYURlcHNbcHJvcF0pKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGdlbi5pZihjb2RlXzEucHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHsga2V5d29yZCwgc2NoZW1hUHJvcDogcHJvcCB9LCB2YWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHZhbGlkKTtcbiAgICAgICAgfSwgKCkgPT4gZ2VuLnZhcih2YWxpZCwgdHJ1ZSkgLy8gVE9ETyB2YXJcbiAgICAgICAgKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlU2NoZW1hRGVwcyA9IHZhbGlkYXRlU2NoZW1hRGVwcztcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlcGVuZGVuY2llcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJwcm9wZXJ0eSBuYW1lIG11c3QgYmUgdmFsaWRcIixcbiAgICBwYXJhbXM6ICh7IHBhcmFtcyB9KSA9PiBjb2RlZ2VuXzEuXyBge3Byb3BlcnR5TmFtZTogJHtwYXJhbXMucHJvcGVydHlOYW1lfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInByb3BlcnR5TmFtZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBnZW4uZm9ySW4oXCJrZXlcIiwgZGF0YSwgKGtleSkgPT4ge1xuICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IHByb3BlcnR5TmFtZToga2V5IH0pO1xuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJwcm9wZXJ0eU5hbWVzXCIsXG4gICAgICAgICAgICAgICAgZGF0YToga2V5LFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlczogW1wic3RyaW5nXCJdLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZToga2V5LFxuICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLm5vdCh2YWxpZCksICgpID0+IHtcbiAgICAgICAgICAgICAgICBjeHQuZXJyb3IodHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpdC5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5icmVhaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcGVydHlOYW1lcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9uYW1lc1wiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiBcIm11c3QgTk9UIGhhdmUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXCIsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXMgfSkgPT4gY29kZWdlbl8xLl8gYHthZGRpdGlvbmFsUHJvcGVydHk6ICR7cGFyYW1zLmFkZGl0aW9uYWxQcm9wZXJ0eX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLFxuICAgIHR5cGU6IFtcIm9iamVjdFwiXSxcbiAgICBzY2hlbWFUeXBlOiBbXCJib29sZWFuXCIsIFwib2JqZWN0XCJdLFxuICAgIGFsbG93VW5kZWZpbmVkOiB0cnVlLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgZGF0YSwgZXJyc0NvdW50LCBpdCB9ID0gY3h0O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFlcnJzQ291bnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgIGNvbnN0IHsgYWxsRXJyb3JzLCBvcHRzIH0gPSBpdDtcbiAgICAgICAgaXQucHJvcHMgPSB0cnVlO1xuICAgICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsICE9PSBcImFsbFwiICYmIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgcHJvcHMgPSBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcyhwYXJlbnRTY2hlbWEucHJvcGVydGllcyk7XG4gICAgICAgIGNvbnN0IHBhdFByb3BzID0gY29kZV8xLmFsbFNjaGVtYVByb3BlcnRpZXMocGFyZW50U2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKTtcbiAgICAgICAgY2hlY2tBZGRpdGlvbmFsUHJvcGVydGllcygpO1xuICAgICAgICBjeHQub2soY29kZWdlbl8xLl8gYCR7ZXJyc0NvdW50fSA9PT0gJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfWApO1xuICAgICAgICBmdW5jdGlvbiBjaGVja0FkZGl0aW9uYWxQcm9wZXJ0aWVzKCkge1xuICAgICAgICAgICAgZ2VuLmZvckluKFwia2V5XCIsIGRhdGEsIChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BzLmxlbmd0aCAmJiAhcGF0UHJvcHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydHlDb2RlKGtleSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoaXNBZGRpdGlvbmFsKGtleSksICgpID0+IGFkZGl0aW9uYWxQcm9wZXJ0eUNvZGUoa2V5KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0FkZGl0aW9uYWwoa2V5KSB7XG4gICAgICAgICAgICBsZXQgZGVmaW5lZFByb3A7XG4gICAgICAgICAgICBpZiAocHJvcHMubGVuZ3RoID4gOCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gbWF5YmUgYW4gb3B0aW9uIGluc3RlYWQgb2YgaGFyZC1jb2RlZCA4P1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzU2NoZW1hID0gdXRpbF8xLnNjaGVtYVJlZk9yVmFsKGl0LCBwYXJlbnRTY2hlbWEucHJvcGVydGllcywgXCJwcm9wZXJ0aWVzXCIpO1xuICAgICAgICAgICAgICAgIGRlZmluZWRQcm9wID0gY29kZV8xLmlzT3duUHJvcGVydHkoZ2VuLCBwcm9wc1NjaGVtYSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlZmluZWRQcm9wID0gY29kZWdlbl8xLm9yKC4uLnByb3BzLm1hcCgocCkgPT4gY29kZWdlbl8xLl8gYCR7a2V5fSA9PT0gJHtwfWApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZmluZWRQcm9wID0gY29kZWdlbl8xLm5pbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRQcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9IGNvZGVnZW5fMS5vcihkZWZpbmVkUHJvcCwgLi4ucGF0UHJvcHMubWFwKChwKSA9PiBjb2RlZ2VuXzEuXyBgJHtjb2RlXzEudXNlUGF0dGVybihjeHQsIHApfS50ZXN0KCR7a2V5fSlgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLm5vdChkZWZpbmVkUHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVsZXRlQWRkaXRpb25hbChrZXkpIHtcbiAgICAgICAgICAgIGdlbi5jb2RlKGNvZGVnZW5fMS5fIGBkZWxldGUgJHtkYXRhfVske2tleX1dYCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkaXRpb25hbFByb3BlcnR5Q29kZShrZXkpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLnJlbW92ZUFkZGl0aW9uYWwgPT09IFwiYWxsXCIgfHwgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCAmJiBzY2hlbWEgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZUFkZGl0aW9uYWwoa2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBhZGRpdGlvbmFsUHJvcGVydHk6IGtleSB9KTtcbiAgICAgICAgICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmJyZWFrKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnJlbW92ZUFkZGl0aW9uYWwgPT09IFwiZmFpbGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5QWRkaXRpb25hbFNjaGVtYShrZXksIHZhbGlkLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEubm90KHZhbGlkKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3h0LnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVBZGRpdGlvbmFsKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlBZGRpdGlvbmFsU2NoZW1hKGtleSwgdmFsaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEubm90KHZhbGlkKSwgKCkgPT4gZ2VuLmJyZWFrKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcHBseUFkZGl0aW9uYWxTY2hlbWEoa2V5LCB2YWxpZCwgZXJyb3JzKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJzY2hlbWEgPSB7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBrZXksXG4gICAgICAgICAgICAgICAgZGF0YVByb3BUeXBlOiB1dGlsXzEuVHlwZS5TdHIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGVycm9ycyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHN1YnNjaGVtYSwge1xuICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhbGxFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYShzdWJzY2hlbWEsIHZhbGlkKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkaXRpb25hbFByb3BlcnRpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB2YWxpZGF0ZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBhZGRpdGlvbmFsUHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vYWRkaXRpb25hbFByb3BlcnRpZXNcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJwcm9wZXJ0aWVzXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKGl0Lm9wdHMucmVtb3ZlQWRkaXRpb25hbCA9PT0gXCJhbGxcIiAmJiBwYXJlbnRTY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXNfMS5kZWZhdWx0LmNvZGUobmV3IHZhbGlkYXRlXzEuS2V5d29yZEN4dChpdCwgYWRkaXRpb25hbFByb3BlcnRpZXNfMS5kZWZhdWx0LCBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbGxQcm9wcyA9IGNvZGVfMS5hbGxTY2hlbWFQcm9wZXJ0aWVzKHNjaGVtYSk7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBhbGxQcm9wcykge1xuICAgICAgICAgICAgaXQuZGVmaW5lZFByb3BlcnRpZXMuYWRkKHByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIGFsbFByb3BzLmxlbmd0aCAmJiBpdC5wcm9wcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgaXQucHJvcHMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCB1dGlsXzEudG9IYXNoKGFsbFByb3BzKSwgaXQucHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBhbGxQcm9wcy5maWx0ZXIoKHApID0+ICF1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYVtwXSkpO1xuICAgICAgICBpZiAocHJvcGVydGllcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChoYXNEZWZhdWx0KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgYXBwbHlQcm9wZXJ0eVNjaGVtYShwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlXzEucHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpKTtcbiAgICAgICAgICAgICAgICBhcHBseVByb3BlcnR5U2NoZW1hKHByb3ApO1xuICAgICAgICAgICAgICAgIGlmICghaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICBnZW4uZWxzZSgpLnZhcih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZ2VuLmVuZElmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjeHQuaXQuZGVmaW5lZFByb3BlcnRpZXMuYWRkKHByb3ApO1xuICAgICAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYXNEZWZhdWx0KHByb3ApIHtcbiAgICAgICAgICAgIHJldHVybiBpdC5vcHRzLnVzZURlZmF1bHRzICYmICFpdC5jb21wb3NpdGVSdWxlICYmIHNjaGVtYVtwcm9wXS5kZWZhdWx0ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXBwbHlQcm9wZXJ0eVNjaGVtYShwcm9wKSB7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcInByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICBzY2hlbWFQcm9wOiBwcm9wLFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBwcm9wLFxuICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wZXJ0aWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IHV0aWxfMiA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJwYXR0ZXJuUHJvcGVydGllc1wiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBkYXRhLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgb3B0cyB9ID0gaXQ7XG4gICAgICAgIGNvbnN0IHBhdHRlcm5zID0gY29kZV8xLmFsbFNjaGVtYVByb3BlcnRpZXMoc2NoZW1hKTtcbiAgICAgICAgY29uc3QgYWx3YXlzVmFsaWRQYXR0ZXJucyA9IHBhdHRlcm5zLmZpbHRlcigocCkgPT4gdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWFbcF0pKTtcbiAgICAgICAgaWYgKHBhdHRlcm5zLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgKGFsd2F5c1ZhbGlkUGF0dGVybnMubGVuZ3RoID09PSBwYXR0ZXJucy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAoIWl0Lm9wdHMudW5ldmFsdWF0ZWQgfHwgaXQucHJvcHMgPT09IHRydWUpKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoZWNrUHJvcGVydGllcyA9IG9wdHMuc3RyaWN0U2NoZW1hICYmICFvcHRzLmFsbG93TWF0Y2hpbmdQcm9wZXJ0aWVzICYmIHBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGlmIChpdC5wcm9wcyAhPT0gdHJ1ZSAmJiAhKGl0LnByb3BzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpKSB7XG4gICAgICAgICAgICBpdC5wcm9wcyA9IHV0aWxfMi5ldmFsdWF0ZWRQcm9wc1RvTmFtZShnZW4sIGl0LnByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSBpdDtcbiAgICAgICAgdmFsaWRhdGVQYXR0ZXJuUHJvcGVydGllcygpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZVBhdHRlcm5Qcm9wZXJ0aWVzKCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXQgb2YgcGF0dGVybnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tQcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgICAgICBjaGVja01hdGNoaW5nUHJvcGVydGllcyhwYXQpO1xuICAgICAgICAgICAgICAgIGlmIChpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHBhdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZW4udmFyKHZhbGlkLCB0cnVlKTsgLy8gVE9ETyB2YXJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHBhdCk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZih2YWxpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTWF0Y2hpbmdQcm9wZXJ0aWVzKHBhdCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIGNoZWNrUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGlmIChuZXcgUmVnRXhwKHBhdCkudGVzdChwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCBgcHJvcGVydHkgJHtwcm9wfSBtYXRjaGVzIHBhdHRlcm4gJHtwYXR9ICh1c2UgYWxsb3dNYXRjaGluZ1Byb3BlcnRpZXMpYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpIHtcbiAgICAgICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2NvZGVfMS51c2VQYXR0ZXJuKGN4dCwgcGF0KX0udGVzdCgke2tleX0pYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbHdheXNWYWxpZCA9IGFsd2F5c1ZhbGlkUGF0dGVybnMuaW5jbHVkZXMocGF0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbHdheXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5d29yZDogXCJwYXR0ZXJuUHJvcGVydGllc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYVByb3A6IHBhdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJvcDoga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogdXRpbF8yLlR5cGUuU3RyLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIHByb3BzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke3Byb3BzfVske2tleX1dYCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWFsd2F5c1ZhbGlkICYmICFpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbiBzaG9ydC1jaXJjdWl0IGlmIGB1bmV2YWx1YXRlZFByb3BlcnRpZXNgIGlzIG5vdCBzdXBwb3J0ZWQgKG9wdHMubmV4dCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBpZiBhbGwgcHJvcGVydGllcyB3ZXJlIGV2YWx1YXRlZCAocHJvcHMgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLm5vdCh2YWxpZCksICgpID0+IGdlbi5icmVhaygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdHRlcm5Qcm9wZXJ0aWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIm5vdFwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSkge1xuICAgICAgICAgICAgY3h0LmZhaWwoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAga2V5d29yZDogXCJub3RcIixcbiAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICBjcmVhdGVFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgYWxsRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICBjeHQuZmFpbFJlc3VsdCh2YWxpZCwgKCkgPT4gY3h0LnJlc2V0KCksICgpID0+IGN4dC5lcnJvcigpKTtcbiAgICB9LFxuICAgIGVycm9yOiB7IG1lc3NhZ2U6IFwibXVzdCBOT1QgYmUgdmFsaWRcIiB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYW55T2ZcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgY29kZTogY29kZV8xLnZhbGlkYXRlVW5pb24sXG4gICAgZXJyb3I6IHsgbWVzc2FnZTogXCJtdXN0IG1hdGNoIGEgc2NoZW1hIGluIGFueU9mXCIgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbnlPZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IG1hdGNoIGV4YWN0bHkgb25lIHNjaGVtYSBpbiBvbmVPZlwiLFxuICAgIHBhcmFtczogKHsgcGFyYW1zIH0pID0+IGNvZGVnZW5fMS5fIGB7cGFzc2luZ1NjaGVtYXM6ICR7cGFyYW1zLnBhc3Npbmd9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwib25lT2ZcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgIGlmIChpdC5vcHRzLmRpc2NyaW1pbmF0b3IgJiYgcGFyZW50U2NoZW1hLmRpc2NyaW1pbmF0b3IpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHNjaEFyciA9IHNjaGVtYTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgZmFsc2UpO1xuICAgICAgICBjb25zdCBwYXNzaW5nID0gZ2VuLmxldChcInBhc3NpbmdcIiwgbnVsbCk7XG4gICAgICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIik7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBwYXNzaW5nIH0pO1xuICAgICAgICAvLyBUT0RPIHBvc3NpYmx5IGZhaWwgc3RyYWlnaHQgYXdheSAod2l0aCB3YXJuaW5nIG9yIGV4Y2VwdGlvbikgaWYgdGhlcmUgYXJlIHR3byBlbXB0eSBhbHdheXMgdmFsaWQgc2NoZW1hc1xuICAgICAgICBnZW4uYmxvY2sodmFsaWRhdGVPbmVPZik7XG4gICAgICAgIGN4dC5yZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZU9uZU9mKCkge1xuICAgICAgICAgICAgc2NoQXJyLmZvckVhY2goKHNjaCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzY2hDeHQ7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoKSkge1xuICAgICAgICAgICAgICAgICAgICBnZW4udmFyKHNjaFZhbGlkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5d29yZDogXCJvbmVPZlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hUHJvcDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0sIHNjaFZhbGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAgICAgLmlmKGNvZGVnZW5fMS5fIGAke3NjaFZhbGlkfSAmJiAke3ZhbGlkfWApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXNzaWduKHZhbGlkLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hc3NpZ24ocGFzc2luZywgY29kZWdlbl8xLl8gYFske3Bhc3Npbmd9LCAke2l9XWApXG4gICAgICAgICAgICAgICAgICAgICAgICAuZWxzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZW4uaWYoc2NoVmFsaWQsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24ocGFzc2luZywgaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hDeHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0LCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b25lT2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYWxsT2ZcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIHNjaGVtYS5mb3JFYWNoKChzY2gsIGkpID0+IHtcbiAgICAgICAgICAgIGlmICh1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQ6IFwiYWxsT2ZcIiwgc2NoZW1hUHJvcDogaSB9LCB2YWxpZCk7XG4gICAgICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWxsT2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtcyB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBtdXN0IG1hdGNoIFwiJHtwYXJhbXMuaWZDbGF1c2V9XCIgc2NoZW1hYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtcyB9KSA9PiBjb2RlZ2VuXzEuXyBge2ZhaWxpbmdLZXl3b3JkOiAke3BhcmFtcy5pZkNsYXVzZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpZlwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKHBhcmVudFNjaGVtYS50aGVuID09PSB1bmRlZmluZWQgJiYgcGFyZW50U2NoZW1hLmVsc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZShpdCwgJ1wiaWZcIiB3aXRob3V0IFwidGhlblwiIGFuZCBcImVsc2VcIiBpcyBpZ25vcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzVGhlbiA9IGhhc1NjaGVtYShpdCwgXCJ0aGVuXCIpO1xuICAgICAgICBjb25zdCBoYXNFbHNlID0gaGFzU2NoZW1hKGl0LCBcImVsc2VcIik7XG4gICAgICAgIGlmICghaGFzVGhlbiAmJiAhaGFzRWxzZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIik7XG4gICAgICAgIHZhbGlkYXRlSWYoKTtcbiAgICAgICAgY3h0LnJlc2V0KCk7XG4gICAgICAgIGlmIChoYXNUaGVuICYmIGhhc0Vsc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGlmQ2xhdXNlID0gZ2VuLmxldChcImlmQ2xhdXNlXCIpO1xuICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IGlmQ2xhdXNlIH0pO1xuICAgICAgICAgICAgZ2VuLmlmKHNjaFZhbGlkLCB2YWxpZGF0ZUNsYXVzZShcInRoZW5cIiwgaWZDbGF1c2UpLCB2YWxpZGF0ZUNsYXVzZShcImVsc2VcIiwgaWZDbGF1c2UpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYXNUaGVuKSB7XG4gICAgICAgICAgICBnZW4uaWYoc2NoVmFsaWQsIHZhbGlkYXRlQ2xhdXNlKFwidGhlblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLm5vdChzY2hWYWxpZCksIHZhbGlkYXRlQ2xhdXNlKFwiZWxzZVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3h0LnBhc3ModmFsaWQsICgpID0+IGN4dC5lcnJvcih0cnVlKSk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlSWYoKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcImlmXCIsXG4gICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFsbEVycm9yczogZmFsc2UsXG4gICAgICAgICAgICB9LCBzY2hWYWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUNsYXVzZShrZXl3b3JkLCBpZkNsYXVzZSkge1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHsga2V5d29yZCB9LCBzY2hWYWxpZCk7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgICAgIGN4dC5tZXJnZVZhbGlkRXZhbHVhdGVkKHNjaEN4dCwgdmFsaWQpO1xuICAgICAgICAgICAgICAgIGlmIChpZkNsYXVzZSlcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihpZkNsYXVzZSwgY29kZWdlbl8xLl8gYCR7a2V5d29yZH1gKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBpZkNsYXVzZToga2V5d29yZCB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmZ1bmN0aW9uIGhhc1NjaGVtYShpdCwga2V5d29yZCkge1xuICAgIGNvbnN0IHNjaGVtYSA9IGl0LnNjaGVtYVtrZXl3b3JkXTtcbiAgICByZXR1cm4gc2NoZW1hICE9PSB1bmRlZmluZWQgJiYgIXV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlmLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBbXCJ0aGVuXCIsIFwiZWxzZVwiXSxcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIGNvZGUoeyBrZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGl0IH0pIHtcbiAgICAgICAgaWYgKHBhcmVudFNjaGVtYS5pZiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZShpdCwgYFwiJHtrZXl3b3JkfVwiIHdpdGhvdXQgXCJpZlwiIGlzIGlnbm9yZWRgKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRoZW5FbHNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYWRkaXRpb25hbEl0ZW1zXzEgPSByZXF1aXJlKFwiLi9hZGRpdGlvbmFsSXRlbXNcIik7XG5jb25zdCBwcmVmaXhJdGVtc18xID0gcmVxdWlyZShcIi4vcHJlZml4SXRlbXNcIik7XG5jb25zdCBpdGVtc18xID0gcmVxdWlyZShcIi4vaXRlbXNcIik7XG5jb25zdCBpdGVtczIwMjBfMSA9IHJlcXVpcmUoXCIuL2l0ZW1zMjAyMFwiKTtcbmNvbnN0IGNvbnRhaW5zXzEgPSByZXF1aXJlKFwiLi9jb250YWluc1wiKTtcbmNvbnN0IGRlcGVuZGVuY2llc18xID0gcmVxdWlyZShcIi4vZGVwZW5kZW5jaWVzXCIpO1xuY29uc3QgcHJvcGVydHlOYW1lc18xID0gcmVxdWlyZShcIi4vcHJvcGVydHlOYW1lc1wiKTtcbmNvbnN0IGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9hZGRpdGlvbmFsUHJvcGVydGllc1wiKTtcbmNvbnN0IHByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnRpZXNcIik7XG5jb25zdCBwYXR0ZXJuUHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vcGF0dGVyblByb3BlcnRpZXNcIik7XG5jb25zdCBub3RfMSA9IHJlcXVpcmUoXCIuL25vdFwiKTtcbmNvbnN0IGFueU9mXzEgPSByZXF1aXJlKFwiLi9hbnlPZlwiKTtcbmNvbnN0IG9uZU9mXzEgPSByZXF1aXJlKFwiLi9vbmVPZlwiKTtcbmNvbnN0IGFsbE9mXzEgPSByZXF1aXJlKFwiLi9hbGxPZlwiKTtcbmNvbnN0IGlmXzEgPSByZXF1aXJlKFwiLi9pZlwiKTtcbmNvbnN0IHRoZW5FbHNlXzEgPSByZXF1aXJlKFwiLi90aGVuRWxzZVwiKTtcbmZ1bmN0aW9uIGdldEFwcGxpY2F0b3IoZHJhZnQyMDIwID0gZmFsc2UpIHtcbiAgICBjb25zdCBhcHBsaWNhdG9yID0gW1xuICAgICAgICAvLyBhbnlcbiAgICAgICAgbm90XzEuZGVmYXVsdCxcbiAgICAgICAgYW55T2ZfMS5kZWZhdWx0LFxuICAgICAgICBvbmVPZl8xLmRlZmF1bHQsXG4gICAgICAgIGFsbE9mXzEuZGVmYXVsdCxcbiAgICAgICAgaWZfMS5kZWZhdWx0LFxuICAgICAgICB0aGVuRWxzZV8xLmRlZmF1bHQsXG4gICAgICAgIC8vIG9iamVjdFxuICAgICAgICBwcm9wZXJ0eU5hbWVzXzEuZGVmYXVsdCxcbiAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXNfMS5kZWZhdWx0LFxuICAgICAgICBkZXBlbmRlbmNpZXNfMS5kZWZhdWx0LFxuICAgICAgICBwcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICAgICAgcGF0dGVyblByb3BlcnRpZXNfMS5kZWZhdWx0LFxuICAgIF07XG4gICAgLy8gYXJyYXlcbiAgICBpZiAoZHJhZnQyMDIwKVxuICAgICAgICBhcHBsaWNhdG9yLnB1c2gocHJlZml4SXRlbXNfMS5kZWZhdWx0LCBpdGVtczIwMjBfMS5kZWZhdWx0KTtcbiAgICBlbHNlXG4gICAgICAgIGFwcGxpY2F0b3IucHVzaChhZGRpdGlvbmFsSXRlbXNfMS5kZWZhdWx0LCBpdGVtc18xLmRlZmF1bHQpO1xuICAgIGFwcGxpY2F0b3IucHVzaChjb250YWluc18xLmRlZmF1bHQpO1xuICAgIHJldHVybiBhcHBsaWNhdG9yO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0QXBwbGljYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLnN0ciBgbXVzdCBtYXRjaCBmb3JtYXQgXCIke3NjaGVtYUNvZGV9XCJgLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuXyBge2Zvcm1hdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImZvcm1hdFwiLFxuICAgIHR5cGU6IFtcIm51bWJlclwiLCBcInN0cmluZ1wiXSxcbiAgICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0LCBydWxlVHlwZSkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvcHRzLCBlcnJTY2hlbWFQYXRoLCBzY2hlbWFFbnYsIHNlbGYgfSA9IGl0O1xuICAgICAgICBpZiAoIW9wdHMudmFsaWRhdGVGb3JtYXRzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoJGRhdGEpXG4gICAgICAgICAgICB2YWxpZGF0ZSREYXRhRm9ybWF0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHZhbGlkYXRlRm9ybWF0KCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlJERhdGFGb3JtYXQoKSB7XG4gICAgICAgICAgICBjb25zdCBmbXRzID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAgICAgICAgICByZWY6IHNlbGYuZm9ybWF0cyxcbiAgICAgICAgICAgICAgICBjb2RlOiBvcHRzLmNvZGUuZm9ybWF0cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZkRlZiA9IGdlbi5jb25zdChcImZEZWZcIiwgY29kZWdlbl8xLl8gYCR7Zm10c31bJHtzY2hlbWFDb2RlfV1gKTtcbiAgICAgICAgICAgIGNvbnN0IGZUeXBlID0gZ2VuLmxldChcImZUeXBlXCIpO1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gZ2VuLmxldChcImZvcm1hdFwiKTtcbiAgICAgICAgICAgIC8vIFRPRE8gc2ltcGxpZnlcbiAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgdHlwZW9mICR7ZkRlZn0gPT0gXCJvYmplY3RcIiAmJiAhKCR7ZkRlZn0gaW5zdGFuY2VvZiBSZWdFeHApYCwgKCkgPT4gZ2VuLmFzc2lnbihmVHlwZSwgY29kZWdlbl8xLl8gYCR7ZkRlZn0udHlwZSB8fCBcInN0cmluZ1wiYCkuYXNzaWduKGZvcm1hdCwgY29kZWdlbl8xLl8gYCR7ZkRlZn0udmFsaWRhdGVgKSwgKCkgPT4gZ2VuLmFzc2lnbihmVHlwZSwgY29kZWdlbl8xLl8gYFwic3RyaW5nXCJgKS5hc3NpZ24oZm9ybWF0LCBmRGVmKSk7XG4gICAgICAgICAgICBjeHQuZmFpbCRkYXRhKGNvZGVnZW5fMS5vcih1bmtub3duRm10KCksIGludmFsaWRGbXQoKSkpO1xuICAgICAgICAgICAgZnVuY3Rpb24gdW5rbm93bkZtdCgpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5zdHJpY3RTY2hlbWEgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLm5pbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLl8gYCR7c2NoZW1hQ29kZX0gJiYgISR7Zm9ybWF0fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBpbnZhbGlkRm10KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxGb3JtYXQgPSBzY2hlbWFFbnYuJGFzeW5jXG4gICAgICAgICAgICAgICAgICAgID8gY29kZWdlbl8xLl8gYCgke2ZEZWZ9LmFzeW5jID8gYXdhaXQgJHtmb3JtYXR9KCR7ZGF0YX0pIDogJHtmb3JtYXR9KCR7ZGF0YX0pKWBcbiAgICAgICAgICAgICAgICAgICAgOiBjb2RlZ2VuXzEuXyBgJHtmb3JtYXR9KCR7ZGF0YX0pYDtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZERhdGEgPSBjb2RlZ2VuXzEuXyBgKHR5cGVvZiAke2Zvcm1hdH0gPT0gXCJmdW5jdGlvblwiID8gJHtjYWxsRm9ybWF0fSA6ICR7Zm9ybWF0fS50ZXN0KCR7ZGF0YX0pKWA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5fIGAke2Zvcm1hdH0gJiYgJHtmb3JtYXR9ICE9PSB0cnVlICYmICR7ZlR5cGV9ID09PSAke3J1bGVUeXBlfSAmJiAhJHt2YWxpZERhdGF9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdERlZiA9IHNlbGYuZm9ybWF0c1tzY2hlbWFdO1xuICAgICAgICAgICAgaWYgKCFmb3JtYXREZWYpIHtcbiAgICAgICAgICAgICAgICB1bmtub3duRm9ybWF0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdERlZiA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBbZm10VHlwZSwgZm9ybWF0LCBmbXRSZWZdID0gZ2V0Rm9ybWF0KGZvcm1hdERlZik7XG4gICAgICAgICAgICBpZiAoZm10VHlwZSA9PT0gcnVsZVR5cGUpXG4gICAgICAgICAgICAgICAgY3h0LnBhc3ModmFsaWRDb25kaXRpb24oKSk7XG4gICAgICAgICAgICBmdW5jdGlvbiB1bmtub3duRm9ybWF0KCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnN0cmljdFNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2dnZXIud2Fybih1bmtub3duTXNnKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih1bmtub3duTXNnKCkpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVua25vd25Nc2coKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgdW5rbm93biBmb3JtYXQgXCIke3NjaGVtYX1cIiBpZ25vcmVkIGluIHNjaGVtYSBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRGb3JtYXQoZm10RGVmKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGZtdERlZiBpbnN0YW5jZW9mIFJlZ0V4cFxuICAgICAgICAgICAgICAgICAgICA/IGNvZGVnZW5fMS5yZWdleHBDb2RlKGZtdERlZilcbiAgICAgICAgICAgICAgICAgICAgOiBvcHRzLmNvZGUuZm9ybWF0c1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb2RlZ2VuXzEuXyBgJHtvcHRzLmNvZGUuZm9ybWF0c30ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eShzY2hlbWEpfWBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZtdCA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7IGtleTogc2NoZW1hLCByZWY6IGZtdERlZiwgY29kZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZtdERlZiA9PSBcIm9iamVjdFwiICYmICEoZm10RGVmIGluc3RhbmNlb2YgUmVnRXhwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2ZtdERlZi50eXBlIHx8IFwic3RyaW5nXCIsIGZtdERlZi52YWxpZGF0ZSwgY29kZWdlbl8xLl8gYCR7Zm10fS52YWxpZGF0ZWBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1wic3RyaW5nXCIsIGZtdERlZiwgZm10XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHZhbGlkQ29uZGl0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm9ybWF0RGVmID09IFwib2JqZWN0XCIgJiYgIShmb3JtYXREZWYgaW5zdGFuY2VvZiBSZWdFeHApICYmIGZvcm1hdERlZi5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNjaGVtYUVudi4kYXN5bmMpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBmb3JtYXQgaW4gc3luYyBzY2hlbWFcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgYXdhaXQgJHtmbXRSZWZ9KCR7ZGF0YX0pYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBmb3JtYXQgPT0gXCJmdW5jdGlvblwiID8gY29kZWdlbl8xLl8gYCR7Zm10UmVmfSgke2RhdGF9KWAgOiBjb2RlZ2VuXzEuXyBgJHtmbXRSZWZ9LnRlc3QoJHtkYXRhfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBmb3JtYXRfMSA9IHJlcXVpcmUoXCIuL2Zvcm1hdFwiKTtcbmNvbnN0IGZvcm1hdCA9IFtmb3JtYXRfMS5kZWZhdWx0XTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZvcm1hdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb250ZW50Vm9jYWJ1bGFyeSA9IGV4cG9ydHMubWV0YWRhdGFWb2NhYnVsYXJ5ID0gdm9pZCAwO1xuZXhwb3J0cy5tZXRhZGF0YVZvY2FidWxhcnkgPSBbXG4gICAgXCJ0aXRsZVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIixcbiAgICBcImRlZmF1bHRcIixcbiAgICBcImRlcHJlY2F0ZWRcIixcbiAgICBcInJlYWRPbmx5XCIsXG4gICAgXCJ3cml0ZU9ubHlcIixcbiAgICBcImV4YW1wbGVzXCIsXG5dO1xuZXhwb3J0cy5jb250ZW50Vm9jYWJ1bGFyeSA9IFtcbiAgICBcImNvbnRlbnRNZWRpYVR5cGVcIixcbiAgICBcImNvbnRlbnRFbmNvZGluZ1wiLFxuICAgIFwiY29udGVudFNjaGVtYVwiLFxuXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldGFkYXRhLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbmNvbnN0IHZhbGlkYXRpb25fMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRpb25cIik7XG5jb25zdCBhcHBsaWNhdG9yXzEgPSByZXF1aXJlKFwiLi9hcHBsaWNhdG9yXCIpO1xuY29uc3QgZm9ybWF0XzEgPSByZXF1aXJlKFwiLi9mb3JtYXRcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBkcmFmdDdWb2NhYnVsYXJpZXMgPSBbXG4gICAgY29yZV8xLmRlZmF1bHQsXG4gICAgdmFsaWRhdGlvbl8xLmRlZmF1bHQsXG4gICAgYXBwbGljYXRvcl8xLmRlZmF1bHQoKSxcbiAgICBmb3JtYXRfMS5kZWZhdWx0LFxuICAgIG1ldGFkYXRhXzEubWV0YWRhdGFWb2NhYnVsYXJ5LFxuICAgIG1ldGFkYXRhXzEuY29udGVudFZvY2FidWxhcnksXG5dO1xuZXhwb3J0cy5kZWZhdWx0ID0gZHJhZnQ3Vm9jYWJ1bGFyaWVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHJhZnQ3LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EaXNjckVycm9yID0gdm9pZCAwO1xudmFyIERpc2NyRXJyb3I7XG4oZnVuY3Rpb24gKERpc2NyRXJyb3IpIHtcbiAgICBEaXNjckVycm9yW1wiVGFnXCJdID0gXCJ0YWdcIjtcbiAgICBEaXNjckVycm9yW1wiTWFwcGluZ1wiXSA9IFwibWFwcGluZ1wiO1xufSkoRGlzY3JFcnJvciA9IGV4cG9ydHMuRGlzY3JFcnJvciB8fCAoZXhwb3J0cy5EaXNjckVycm9yID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vZGlzY3JpbWluYXRvci90eXBlc1wiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBkaXNjckVycm9yLCB0YWdOYW1lIH0gfSkgPT4gZGlzY3JFcnJvciA9PT0gdHlwZXNfMS5EaXNjckVycm9yLlRhZ1xuICAgICAgICA/IGB0YWcgXCIke3RhZ05hbWV9XCIgbXVzdCBiZSBzdHJpbmdgXG4gICAgICAgIDogYHZhbHVlIG9mIHRhZyBcIiR7dGFnTmFtZX1cIiBtdXN0IGJlIGluIG9uZU9mYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBkaXNjckVycm9yLCB0YWcsIHRhZ05hbWUgfSB9KSA9PiBjb2RlZ2VuXzEuXyBge2Vycm9yOiAke2Rpc2NyRXJyb3J9LCB0YWc6ICR7dGFnTmFtZX0sIHRhZ1ZhbHVlOiAke3RhZ319YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJkaXNjcmltaW5hdG9yXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvbmVPZiB9ID0gcGFyZW50U2NoZW1hO1xuICAgICAgICBpZiAoIWl0Lm9wdHMuZGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgZGlzY3JpbWluYXRvciBvcHRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFnTmFtZSA9IHNjaGVtYS5wcm9wZXJ0eU5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgdGFnTmFtZSAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgcHJvcGVydHlOYW1lXCIpO1xuICAgICAgICBpZiAoc2NoZW1hLm1hcHBpbmcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiBtYXBwaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIGlmICghb25lT2YpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiByZXF1aXJlcyBvbmVPZiBrZXl3b3JkXCIpO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IHRhZyA9IGdlbi5jb25zdChcInRhZ1wiLCBjb2RlZ2VuXzEuXyBgJHtkYXRhfSR7Y29kZWdlbl8xLmdldFByb3BlcnR5KHRhZ05hbWUpfWApO1xuICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYHR5cGVvZiAke3RhZ30gPT0gXCJzdHJpbmdcImAsICgpID0+IHZhbGlkYXRlTWFwcGluZygpLCAoKSA9PiBjeHQuZXJyb3IoZmFsc2UsIHsgZGlzY3JFcnJvcjogdHlwZXNfMS5EaXNjckVycm9yLlRhZywgdGFnLCB0YWdOYW1lIH0pKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVNYXBwaW5nKCkge1xuICAgICAgICAgICAgY29uc3QgbWFwcGluZyA9IGdldE1hcHBpbmcoKTtcbiAgICAgICAgICAgIGdlbi5pZihmYWxzZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhZ1ZhbHVlIGluIG1hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICBnZW4uZWxzZUlmKGNvZGVnZW5fMS5fIGAke3RhZ30gPT09ICR7dGFnVmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgYXBwbHlUYWdTY2hlbWEobWFwcGluZ1t0YWdWYWx1ZV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbi5lbHNlKCk7XG4gICAgICAgICAgICBjeHQuZXJyb3IoZmFsc2UsIHsgZGlzY3JFcnJvcjogdHlwZXNfMS5EaXNjckVycm9yLk1hcHBpbmcsIHRhZywgdGFnTmFtZSB9KTtcbiAgICAgICAgICAgIGdlbi5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5VGFnU2NoZW1hKHNjaGVtYVByb3ApIHtcbiAgICAgICAgICAgIGNvbnN0IF92YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHsga2V5d29yZDogXCJvbmVPZlwiLCBzY2hlbWFQcm9wIH0sIF92YWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0LCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gX3ZhbGlkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldE1hcHBpbmcoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBvbmVPZk1hcHBpbmcgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHRvcFJlcXVpcmVkID0gaGFzUmVxdWlyZWQocGFyZW50U2NoZW1hKTtcbiAgICAgICAgICAgIGxldCB0YWdSZXF1aXJlZCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9uZU9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoID0gb25lT2ZbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcFNjaCA9IChfYSA9IHNjaC5wcm9wZXJ0aWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbdGFnTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wU2NoICE9IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBvbmVPZiBzY2hlbWFzIG11c3QgaGF2ZSBcInByb3BlcnRpZXMvJHt0YWdOYW1lfVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhZ1JlcXVpcmVkID0gdGFnUmVxdWlyZWQgJiYgKHRvcFJlcXVpcmVkIHx8IGhhc1JlcXVpcmVkKHNjaCkpO1xuICAgICAgICAgICAgICAgIGFkZE1hcHBpbmdzKHByb3BTY2gsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0YWdSZXF1aXJlZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IFwiJHt0YWdOYW1lfVwiIG11c3QgYmUgcmVxdWlyZWRgKTtcbiAgICAgICAgICAgIHJldHVybiBvbmVPZk1hcHBpbmc7XG4gICAgICAgICAgICBmdW5jdGlvbiBoYXNSZXF1aXJlZCh7IHJlcXVpcmVkIH0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShyZXF1aXJlZCkgJiYgcmVxdWlyZWQuaW5jbHVkZXModGFnTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRNYXBwaW5ncyhzY2gsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NoLmNvbnN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZE1hcHBpbmcoc2NoLmNvbnN0LCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoLmVudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0YWdWYWx1ZSBvZiBzY2guZW51bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTWFwcGluZyh0YWdWYWx1ZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogXCJwcm9wZXJ0aWVzLyR7dGFnTmFtZX1cIiBtdXN0IGhhdmUgXCJjb25zdFwiIG9yIFwiZW51bVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkTWFwcGluZyh0YWdWYWx1ZSwgaSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFnVmFsdWUgIT0gXCJzdHJpbmdcIiB8fCB0YWdWYWx1ZSBpbiBvbmVPZk1hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBcIiR7dGFnTmFtZX1cIiB2YWx1ZXMgbXVzdCBiZSB1bmlxdWUgc3RyaW5nc2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbmVPZk1hcHBpbmdbdGFnVmFsdWVdID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvZGVHZW4gPSBleHBvcnRzLk5hbWUgPSBleHBvcnRzLm5pbCA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLl8gPSBleHBvcnRzLktleXdvcmRDeHQgPSB2b2lkIDA7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuY29uc3QgZHJhZnQ3XzEgPSByZXF1aXJlKFwiLi92b2NhYnVsYXJpZXMvZHJhZnQ3XCIpO1xuY29uc3QgZGlzY3JpbWluYXRvcl8xID0gcmVxdWlyZShcIi4vdm9jYWJ1bGFyaWVzL2Rpc2NyaW1pbmF0b3JcIik7XG5jb25zdCBkcmFmdDdNZXRhU2NoZW1hID0gcmVxdWlyZShcIi4vcmVmcy9qc29uLXNjaGVtYS1kcmFmdC0wNy5qc29uXCIpO1xuY29uc3QgTUVUQV9TVVBQT1JUX0RBVEEgPSBbXCIvcHJvcGVydGllc1wiXTtcbmNvbnN0IE1FVEFfU0NIRU1BX0lEID0gXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYVwiO1xuY2xhc3MgQWp2IGV4dGVuZHMgY29yZV8xLmRlZmF1bHQge1xuICAgIF9hZGRWb2NhYnVsYXJpZXMoKSB7XG4gICAgICAgIHN1cGVyLl9hZGRWb2NhYnVsYXJpZXMoKTtcbiAgICAgICAgZHJhZnQ3XzEuZGVmYXVsdC5mb3JFYWNoKCh2KSA9PiB0aGlzLmFkZFZvY2FidWxhcnkodikpO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmRpc2NyaW1pbmF0b3IpXG4gICAgICAgICAgICB0aGlzLmFkZEtleXdvcmQoZGlzY3JpbWluYXRvcl8xLmRlZmF1bHQpO1xuICAgIH1cbiAgICBfYWRkRGVmYXVsdE1ldGFTY2hlbWEoKSB7XG4gICAgICAgIHN1cGVyLl9hZGREZWZhdWx0TWV0YVNjaGVtYSgpO1xuICAgICAgICBpZiAoIXRoaXMub3B0cy5tZXRhKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBtZXRhU2NoZW1hID0gdGhpcy5vcHRzLiRkYXRhXG4gICAgICAgICAgICA/IHRoaXMuJGRhdGFNZXRhU2NoZW1hKGRyYWZ0N01ldGFTY2hlbWEsIE1FVEFfU1VQUE9SVF9EQVRBKVxuICAgICAgICAgICAgOiBkcmFmdDdNZXRhU2NoZW1hO1xuICAgICAgICB0aGlzLmFkZE1ldGFTY2hlbWEobWV0YVNjaGVtYSwgTUVUQV9TQ0hFTUFfSUQsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5yZWZzW1wiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9zY2hlbWFcIl0gPSBNRVRBX1NDSEVNQV9JRDtcbiAgICB9XG4gICAgZGVmYXVsdE1ldGEoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5vcHRzLmRlZmF1bHRNZXRhID1cbiAgICAgICAgICAgIHN1cGVyLmRlZmF1bHRNZXRhKCkgfHwgKHRoaXMuZ2V0U2NoZW1hKE1FVEFfU0NIRU1BX0lEKSA/IE1FVEFfU0NIRU1BX0lEIDogdW5kZWZpbmVkKSk7XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQWp2O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQWp2O1xudmFyIHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3ZhbGlkYXRlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiS2V5d29yZEN4dFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdGVfMS5LZXl3b3JkQ3h0OyB9IH0pO1xudmFyIGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvY29kZWdlblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5fOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5naWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyaW5naWZ5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmlsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEubmlsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLk5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb2RlR2VuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuQ29kZUdlbjsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFqdi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZm9ybWF0TmFtZXMgPSBleHBvcnRzLmZhc3RGb3JtYXRzID0gZXhwb3J0cy5mdWxsRm9ybWF0cyA9IHZvaWQgMDtcbmZ1bmN0aW9uIGZtdERlZih2YWxpZGF0ZSwgY29tcGFyZSkge1xuICAgIHJldHVybiB7IHZhbGlkYXRlLCBjb21wYXJlIH07XG59XG5leHBvcnRzLmZ1bGxGb3JtYXRzID0ge1xuICAgIC8vIGRhdGU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICBkYXRlOiBmbXREZWYoZGF0ZSwgY29tcGFyZURhdGUpLFxuICAgIC8vIGRhdGUtdGltZTogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICAgIHRpbWU6IGZtdERlZih0aW1lLCBjb21wYXJlVGltZSksXG4gICAgXCJkYXRlLXRpbWVcIjogZm10RGVmKGRhdGVfdGltZSwgY29tcGFyZURhdGVUaW1lKSxcbiAgICAvLyBkdXJhdGlvbjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjYXBwZW5kaXgtQVxuICAgIGR1cmF0aW9uOiAvXlAoPyEkKSgoXFxkK1kpPyhcXGQrTSk/KFxcZCtEKT8oVCg/PVxcZCkoXFxkK0gpPyhcXGQrTSk/KFxcZCtTKT8pP3woXFxkK1cpPykkLyxcbiAgICB1cmksXG4gICAgXCJ1cmktcmVmZXJlbmNlXCI6IC9eKD86W2Etel1bYS16MC05K1xcLS5dKjopPyg/OlxcLz9cXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06XXwlWzAtOWEtZl17Mn0pKkApPyg/OlxcWyg/Oig/Oig/Oig/OlswLTlhLWZdezEsNH06KXs2fXw6Oig/OlswLTlhLWZdezEsNH06KXs1fXwoPzpbMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXs0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwxfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezN9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDJ9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7Mn18KD86KD86WzAtOWEtZl17MSw0fTopezAsM31bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH06fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDR9WzAtOWEtZl17MSw0fSk/OjopKD86WzAtOWEtZl17MSw0fTpbMC05YS1mXXsxLDR9fCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSl8KD86KD86WzAtOWEtZl17MSw0fTopezAsNX1bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH18KD86KD86WzAtOWEtZl17MSw0fTopezAsNn1bMC05YS1mXXsxLDR9KT86Oil8W1Z2XVswLTlhLWZdK1xcLlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdKylcXF18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pfCg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9XXwlWzAtOWEtZl17Mn0pKikoPzo6XFxkKik/KD86XFwvKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSopKnxcXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopP3woPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopPyg/OlxcPyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyg/OiMoPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8kL2ksXG4gICAgLy8gdXJpLXRlbXBsYXRlOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjU3MFxuICAgIFwidXJpLXRlbXBsYXRlXCI6IC9eKD86KD86W15cXHgwMC1cXHgyMFwiJzw+JVxcXFxeYHt8fV18JVswLTlhLWZdezJ9KXxcXHtbKyMuLzs/Jj0sIUB8XT8oPzpbYS16MC05X118JVswLTlhLWZdezJ9KSsoPzo6WzEtOV1bMC05XXswLDN9fFxcKik/KD86LCg/OlthLXowLTlfXXwlWzAtOWEtZl17Mn0pKyg/OjpbMS05XVswLTldezAsM318XFwqKT8pKlxcfSkqJC9pLFxuICAgIC8vIEZvciB0aGUgc291cmNlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9kcGVyaW5pLzcyOTI5NFxuICAgIC8vIEZvciB0ZXN0IGNhc2VzOiBodHRwczovL21hdGhpYXNieW5lbnMuYmUvZGVtby91cmwtcmVnZXhcbiAgICB1cmw6IC9eKD86aHR0cHM/fGZ0cCk6XFwvXFwvKD86XFxTKyg/OjpcXFMqKT9AKT8oPzooPyEoPzoxMHwxMjcpKD86XFwuXFxkezEsM30pezN9KSg/ISg/OjE2OVxcLjI1NHwxOTJcXC4xNjgpKD86XFwuXFxkezEsM30pezJ9KSg/ITE3MlxcLig/OjFbNi05XXwyXFxkfDNbMC0xXSkoPzpcXC5cXGR7MSwzfSl7Mn0pKD86WzEtOV1cXGQ/fDFcXGRcXGR8MlswMV1cXGR8MjJbMC0zXSkoPzpcXC4oPzoxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSl7Mn0oPzpcXC4oPzpbMS05XVxcZD98MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC00XSkpfCg/Oig/OlthLXowLTlcXHV7MDBhMX0tXFx1e2ZmZmZ9XSstKSpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rKSg/OlxcLig/OlthLXowLTlcXHV7MDBhMX0tXFx1e2ZmZmZ9XSstKSpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rKSooPzpcXC4oPzpbYS16XFx1ezAwYTF9LVxcdXtmZmZmfV17Mix9KSkpKD86OlxcZHsyLDV9KT8oPzpcXC9bXlxcc10qKT8kL2l1LFxuICAgIGVtYWlsOiAvXlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSsoPzpcXC5bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKSpAKD86W2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pP1xcLikrW2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pPyQvaSxcbiAgICBob3N0bmFtZTogL14oPz0uezEsMjUzfVxcLj8kKVthLXowLTldKD86W2EtejAtOS1dezAsNjF9W2EtejAtOV0pPyg/OlxcLlthLXowLTldKD86Wy0wLTlhLXpdezAsNjF9WzAtOWEtel0pPykqXFwuPyQvaSxcbiAgICAvLyBvcHRpbWl6ZWQgaHR0cHM6Ly93d3cuc2FmYXJpYm9va3NvbmxpbmUuY29tL2xpYnJhcnkvdmlldy9yZWd1bGFyLWV4cHJlc3Npb25zLWNvb2tib29rLzk3ODA1OTY4MDI4MzcvY2gwN3MxNi5odG1sXG4gICAgaXB2NDogL14oPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykkLyxcbiAgICBpcHY2OiAvXigoKFswLTlhLWZdezEsNH06KXs3fShbMC05YS1mXXsxLDR9fDopKXwoKFswLTlhLWZdezEsNH06KXs2fSg6WzAtOWEtZl17MSw0fXwoKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCgoWzAtOWEtZl17MSw0fTopezV9KCgoOlswLTlhLWZdezEsNH0pezEsMn0pfDooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCgoWzAtOWEtZl17MSw0fTopezR9KCgoOlswLTlhLWZdezEsNH0pezEsM30pfCgoOlswLTlhLWZdezEsNH0pPzooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXszfSgoKDpbMC05YS1mXXsxLDR9KXsxLDR9KXwoKDpbMC05YS1mXXsxLDR9KXswLDJ9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezJ9KCgoOlswLTlhLWZdezEsNH0pezEsNX0pfCgoOlswLTlhLWZdezEsNH0pezAsM306KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7MX0oKCg6WzAtOWEtZl17MSw0fSl7MSw2fSl8KCg6WzAtOWEtZl17MSw0fSl7MCw0fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoOigoKDpbMC05YS1mXXsxLDR9KXsxLDd9KXwoKDpbMC05YS1mXXsxLDR9KXswLDV9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpKSQvaSxcbiAgICByZWdleCxcbiAgICAvLyB1dWlkOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0MTIyXG4gICAgdXVpZDogL14oPzp1cm46dXVpZDopP1swLTlhLWZdezh9LSg/OlswLTlhLWZdezR9LSl7M31bMC05YS1mXXsxMn0kL2ksXG4gICAgLy8gSlNPTi1wb2ludGVyOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjkwMVxuICAgIC8vIHVyaSBmcmFnbWVudDogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjYXBwZW5kaXgtQVxuICAgIFwianNvbi1wb2ludGVyXCI6IC9eKD86XFwvKD86W15+L118fjB8fjEpKikqJC8sXG4gICAgXCJqc29uLXBvaW50ZXItdXJpLWZyYWdtZW50XCI6IC9eIyg/OlxcLyg/OlthLXowLTlfXFwtLiEkJicoKSorLDs6PUBdfCVbMC05YS1mXXsyfXx+MHx+MSkqKSokL2ksXG4gICAgLy8gcmVsYXRpdmUgSlNPTi1wb2ludGVyOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1sdWZmLXJlbGF0aXZlLWpzb24tcG9pbnRlci0wMFxuICAgIFwicmVsYXRpdmUtanNvbi1wb2ludGVyXCI6IC9eKD86MHxbMS05XVswLTldKikoPzojfCg/OlxcLyg/Oltefi9dfH4wfH4xKSopKikkLyxcbiAgICAvLyB0aGUgZm9sbG93aW5nIGZvcm1hdHMgYXJlIHVzZWQgYnkgdGhlIG9wZW5hcGkgc3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9zcGVjLm9wZW5hcGlzLm9yZy9vYXMvdjMuMC4wI2RhdGEtdHlwZXNcbiAgICAvLyBieXRlOiBodHRwczovL2dpdGh1Yi5jb20vbWlndWVsbW90YS9pcy1iYXNlNjRcbiAgICBieXRlLFxuICAgIC8vIHNpZ25lZCAzMiBiaXQgaW50ZWdlclxuICAgIGludDMyOiB7IHR5cGU6IFwibnVtYmVyXCIsIHZhbGlkYXRlOiB2YWxpZGF0ZUludDMyIH0sXG4gICAgLy8gc2lnbmVkIDY0IGJpdCBpbnRlZ2VyXG4gICAgaW50NjQ6IHsgdHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlSW50NjQgfSxcbiAgICAvLyBDLXR5cGUgZmxvYXRcbiAgICBmbG9hdDogeyB0eXBlOiBcIm51bWJlclwiLCB2YWxpZGF0ZTogdmFsaWRhdGVOdW1iZXIgfSxcbiAgICAvLyBDLXR5cGUgZG91YmxlXG4gICAgZG91YmxlOiB7IHR5cGU6IFwibnVtYmVyXCIsIHZhbGlkYXRlOiB2YWxpZGF0ZU51bWJlciB9LFxuICAgIC8vIGhpbnQgdG8gdGhlIFVJIHRvIGhpZGUgaW5wdXQgc3RyaW5nc1xuICAgIHBhc3N3b3JkOiB0cnVlLFxuICAgIC8vIHVuY2hlY2tlZCBzdHJpbmcgcGF5bG9hZFxuICAgIGJpbmFyeTogdHJ1ZSxcbn07XG5leHBvcnRzLmZhc3RGb3JtYXRzID0ge1xuICAgIC4uLmV4cG9ydHMuZnVsbEZvcm1hdHMsXG4gICAgZGF0ZTogZm10RGVmKC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkJC8sIGNvbXBhcmVEYXRlKSxcbiAgICB0aW1lOiBmbXREZWYoL14oPzpbMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZHwyMzo1OTo2MCkoPzpcXC5cXGQrKT8oPzp6fFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/KT8kL2ksIGNvbXBhcmVUaW1lKSxcbiAgICBcImRhdGUtdGltZVwiOiBmbXREZWYoL15cXGRcXGRcXGRcXGQtWzAtMV1cXGQtWzAtM11cXGRbdFxcc10oPzpbMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZHwyMzo1OTo2MCkoPzpcXC5cXGQrKT8oPzp6fFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/KSQvaSwgY29tcGFyZURhdGVUaW1lKSxcbiAgICAvLyB1cmk6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvaXMtbXktanNvbi12YWxpZC9ibG9iL21hc3Rlci9mb3JtYXRzLmpzXG4gICAgdXJpOiAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KSg/OlxcLz9cXC8pP1teXFxzXSokL2ksXG4gICAgXCJ1cmktcmVmZXJlbmNlXCI6IC9eKD86KD86W2Etel1bYS16MC05K1xcLS5dKjopP1xcLz9cXC8pPyg/OlteXFxcXFxccyNdW15cXHMjXSopPyg/OiNbXlxcXFxcXHNdKik/JC9pLFxuICAgIC8vIGVtYWlsIChzb3VyY2VzIGZyb20ganNlbiB2YWxpZGF0b3IpOlxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjAxMzIzL3VzaW5nLWEtcmVndWxhci1leHByZXNzaW9uLXRvLXZhbGlkYXRlLWFuLWVtYWlsLWFkZHJlc3MjYW5zd2VyLTg4MjkzNjNcbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9mb3Jtcy5odG1sI3ZhbGlkLWUtbWFpbC1hZGRyZXNzIChzZWFyY2ggZm9yICd3aWxmdWwgdmlvbGF0aW9uJylcbiAgICBlbWFpbDogL15bYS16MC05LiEjJCUmJyorLz0/Xl9ge3x9fi1dK0BbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8oPzpcXC5bYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8pKiQvaSxcbn07XG5leHBvcnRzLmZvcm1hdE5hbWVzID0gT2JqZWN0LmtleXMoZXhwb3J0cy5mdWxsRm9ybWF0cyk7XG5mdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNhcHBlbmRpeC1DXG4gICAgcmV0dXJuIHllYXIgJSA0ID09PSAwICYmICh5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApO1xufVxuY29uc3QgREFURSA9IC9eKFxcZFxcZFxcZFxcZCktKFxcZFxcZCktKFxcZFxcZCkkLztcbmNvbnN0IERBWVMgPSBbMCwgMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07XG5mdW5jdGlvbiBkYXRlKHN0cikge1xuICAgIC8vIGZ1bGwtZGF0ZSBmcm9tIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICBjb25zdCBtYXRjaGVzID0gREFURS5leGVjKHN0cik7XG4gICAgaWYgKCFtYXRjaGVzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgeWVhciA9ICttYXRjaGVzWzFdO1xuICAgIGNvbnN0IG1vbnRoID0gK21hdGNoZXNbMl07XG4gICAgY29uc3QgZGF5ID0gK21hdGNoZXNbM107XG4gICAgcmV0dXJuIChtb250aCA+PSAxICYmXG4gICAgICAgIG1vbnRoIDw9IDEyICYmXG4gICAgICAgIGRheSA+PSAxICYmXG4gICAgICAgIGRheSA8PSAobW9udGggPT09IDIgJiYgaXNMZWFwWWVhcih5ZWFyKSA/IDI5IDogREFZU1ttb250aF0pKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVEYXRlKGQxLCBkMikge1xuICAgIGlmICghKGQxICYmIGQyKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZiAoZDEgPiBkMilcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKGQxIDwgZDIpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICByZXR1cm4gMDtcbn1cbmNvbnN0IFRJTUUgPSAvXihcXGRcXGQpOihcXGRcXGQpOihcXGRcXGQpKFxcLlxcZCspPyh6fFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/KT8kL2k7XG5mdW5jdGlvbiB0aW1lKHN0ciwgd2l0aFRpbWVab25lKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IFRJTUUuZXhlYyhzdHIpO1xuICAgIGlmICghbWF0Y2hlcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGhvdXIgPSArbWF0Y2hlc1sxXTtcbiAgICBjb25zdCBtaW51dGUgPSArbWF0Y2hlc1syXTtcbiAgICBjb25zdCBzZWNvbmQgPSArbWF0Y2hlc1szXTtcbiAgICBjb25zdCB0aW1lWm9uZSA9IG1hdGNoZXNbNV07XG4gICAgcmV0dXJuICgoKGhvdXIgPD0gMjMgJiYgbWludXRlIDw9IDU5ICYmIHNlY29uZCA8PSA1OSkgfHxcbiAgICAgICAgKGhvdXIgPT09IDIzICYmIG1pbnV0ZSA9PT0gNTkgJiYgc2Vjb25kID09PSA2MCkpICYmXG4gICAgICAgICghd2l0aFRpbWVab25lIHx8IHRpbWVab25lICE9PSBcIlwiKSk7XG59XG5mdW5jdGlvbiBjb21wYXJlVGltZSh0MSwgdDIpIHtcbiAgICBpZiAoISh0MSAmJiB0MikpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgYTEgPSBUSU1FLmV4ZWModDEpO1xuICAgIGNvbnN0IGEyID0gVElNRS5leGVjKHQyKTtcbiAgICBpZiAoIShhMSAmJiBhMikpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgdDEgPSBhMVsxXSArIGExWzJdICsgYTFbM10gKyAoYTFbNF0gfHwgXCJcIik7XG4gICAgdDIgPSBhMlsxXSArIGEyWzJdICsgYTJbM10gKyAoYTJbNF0gfHwgXCJcIik7XG4gICAgaWYgKHQxID4gdDIpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmICh0MSA8IHQyKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgcmV0dXJuIDA7XG59XG5jb25zdCBEQVRFX1RJTUVfU0VQQVJBVE9SID0gL3R8XFxzL2k7XG5mdW5jdGlvbiBkYXRlX3RpbWUoc3RyKSB7XG4gICAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICAgIGNvbnN0IGRhdGVUaW1lID0gc3RyLnNwbGl0KERBVEVfVElNRV9TRVBBUkFUT1IpO1xuICAgIHJldHVybiBkYXRlVGltZS5sZW5ndGggPT09IDIgJiYgZGF0ZShkYXRlVGltZVswXSkgJiYgdGltZShkYXRlVGltZVsxXSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBjb21wYXJlRGF0ZVRpbWUoZHQxLCBkdDIpIHtcbiAgICBpZiAoIShkdDEgJiYgZHQyKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBbZDEsIHQxXSA9IGR0MS5zcGxpdChEQVRFX1RJTUVfU0VQQVJBVE9SKTtcbiAgICBjb25zdCBbZDIsIHQyXSA9IGR0Mi5zcGxpdChEQVRFX1RJTUVfU0VQQVJBVE9SKTtcbiAgICBjb25zdCByZXMgPSBjb21wYXJlRGF0ZShkMSwgZDIpO1xuICAgIGlmIChyZXMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzIHx8IGNvbXBhcmVUaW1lKHQxLCB0Mik7XG59XG5jb25zdCBOT1RfVVJJX0ZSQUdNRU5UID0gL1xcL3w6LztcbmNvbnN0IFVSSSA9IC9eKD86W2Etel1bYS16MC05K1xcLS5dKjopKD86XFwvP1xcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdfCVbMC05YS1mXXsyfSkqQCk/KD86XFxbKD86KD86KD86KD86WzAtOWEtZl17MSw0fTopezZ9fDo6KD86WzAtOWEtZl17MSw0fTopezV9fCg/OlswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDF9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7M318KD86KD86WzAtOWEtZl17MSw0fTopezAsMn1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXsyfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwzfVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fTp8KD86KD86WzAtOWEtZl17MSw0fTopezAsNH1bMC05YS1mXXsxLDR9KT86OikoPzpbMC05YS1mXXsxLDR9OlswLTlhLWZdezEsNH18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw1fVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw2fVswLTlhLWZdezEsNH0pPzo6KXxbVnZdWzAtOWEtZl0rXFwuW2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol0rKVxcXXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPyl8KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9XXwlWzAtOWEtZl17Mn0pKikoPzo6XFxkKik/KD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSp8XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopP3woPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKikoPzpcXD8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/KD86Iyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8kL2k7XG5mdW5jdGlvbiB1cmkoc3RyKSB7XG4gICAgLy8gaHR0cDovL2ptcndhcmUuY29tL2FydGljbGVzLzIwMDkvdXJpX3JlZ2V4cC9VUklfcmVnZXguaHRtbCArIG9wdGlvbmFsIHByb3RvY29sICsgcmVxdWlyZWQgXCIuXCJcbiAgICByZXR1cm4gTk9UX1VSSV9GUkFHTUVOVC50ZXN0KHN0cikgJiYgVVJJLnRlc3Qoc3RyKTtcbn1cbmNvbnN0IEJZVEUgPSAvXig/OltBLVphLXowLTkrL117NH0pKig/OltBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PSk/JC9nbTtcbmZ1bmN0aW9uIGJ5dGUoc3RyKSB7XG4gICAgQllURS5sYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiBCWVRFLnRlc3Qoc3RyKTtcbn1cbmNvbnN0IE1JTl9JTlQzMiA9IC0oMiAqKiAzMSk7XG5jb25zdCBNQVhfSU5UMzIgPSAyICoqIDMxIC0gMTtcbmZ1bmN0aW9uIHZhbGlkYXRlSW50MzIodmFsdWUpIHtcbiAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgJiYgdmFsdWUgPD0gTUFYX0lOVDMyICYmIHZhbHVlID49IE1JTl9JTlQzMjtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlSW50NjQodmFsdWUpIHtcbiAgICAvLyBKU09OIGFuZCBqYXZhc2NyaXB0IG1heCBJbnQgaXMgMioqNTMsIHNvIGFueSBpbnQgdGhhdCBwYXNzZXMgaXNJbnRlZ2VyIGlzIHZhbGlkIGZvciBJbnQ2NFxuICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyKCkge1xuICAgIHJldHVybiB0cnVlO1xufVxuY29uc3QgWl9BTkNIT1IgPSAvW15cXFxcXVxcXFxaLztcbmZ1bmN0aW9uIHJlZ2V4KHN0cikge1xuICAgIGlmIChaX0FOQ0hPUi50ZXN0KHN0cikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBuZXcgUmVnRXhwKHN0cik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZm9ybWF0TGltaXREZWZpbml0aW9uID0gdm9pZCAwO1xuY29uc3QgYWp2XzEgPSByZXF1aXJlKFwiYWp2XCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcImFqdi9kaXN0L2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IG9wcyA9IGNvZGVnZW5fMS5vcGVyYXRvcnM7XG5jb25zdCBLV0RzID0ge1xuICAgIGZvcm1hdE1heGltdW06IHsgb2tTdHI6IFwiPD1cIiwgb2s6IG9wcy5MVEUsIGZhaWw6IG9wcy5HVCB9LFxuICAgIGZvcm1hdE1pbmltdW06IHsgb2tTdHI6IFwiPj1cIiwgb2s6IG9wcy5HVEUsIGZhaWw6IG9wcy5MVCB9LFxuICAgIGZvcm1hdEV4Y2x1c2l2ZU1heGltdW06IHsgb2tTdHI6IFwiPFwiLCBvazogb3BzLkxULCBmYWlsOiBvcHMuR1RFIH0sXG4gICAgZm9ybWF0RXhjbHVzaXZlTWluaW11bTogeyBva1N0cjogXCI+XCIsIG9rOiBvcHMuR1QsIGZhaWw6IG9wcy5MVEUgfSxcbn07XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pID0+IGNvZGVnZW5fMS5zdHIgYHNob3VsZCBiZSAke0tXRHNba2V5d29yZF0ub2tTdHJ9ICR7c2NoZW1hQ29kZX1gLFxuICAgIHBhcmFtczogKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuXyBge2NvbXBhcmlzb246ICR7S1dEc1trZXl3b3JkXS5va1N0cn0sIGxpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuZXhwb3J0cy5mb3JtYXRMaW1pdERlZmluaXRpb24gPSB7XG4gICAga2V5d29yZDogT2JqZWN0LmtleXMoS1dEcyksXG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWFDb2RlLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgICAgICBpZiAoIW9wdHMudmFsaWRhdGVGb3JtYXRzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBmQ3h0ID0gbmV3IGFqdl8xLktleXdvcmRDeHQoaXQsIHNlbGYuUlVMRVMuYWxsLmZvcm1hdC5kZWZpbml0aW9uLCBcImZvcm1hdFwiKTtcbiAgICAgICAgaWYgKGZDeHQuJGRhdGEpXG4gICAgICAgICAgICB2YWxpZGF0ZSREYXRhRm9ybWF0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHZhbGlkYXRlRm9ybWF0KCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlJERhdGFGb3JtYXQoKSB7XG4gICAgICAgICAgICBjb25zdCBmbXRzID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAgICAgICAgICByZWY6IHNlbGYuZm9ybWF0cyxcbiAgICAgICAgICAgICAgICBjb2RlOiBvcHRzLmNvZGUuZm9ybWF0cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZm10ID0gZ2VuLmNvbnN0KFwiZm10XCIsIGNvZGVnZW5fMS5fIGAke2ZtdHN9WyR7ZkN4dC5zY2hlbWFDb2RlfV1gKTtcbiAgICAgICAgICAgIGN4dC5mYWlsJGRhdGEoY29kZWdlbl8xLm9yKGNvZGVnZW5fMS5fIGB0eXBlb2YgJHtmbXR9ICE9IFwib2JqZWN0XCJgLCBjb2RlZ2VuXzEuXyBgJHtmbXR9IGluc3RhbmNlb2YgUmVnRXhwYCwgY29kZWdlbl8xLl8gYHR5cGVvZiAke2ZtdH0uY29tcGFyZSAhPSBcImZ1bmN0aW9uXCJgLCBjb21wYXJlQ29kZShmbXQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoKSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXQgPSBmQ3h0LnNjaGVtYTtcbiAgICAgICAgICAgIGNvbnN0IGZtdERlZiA9IHNlbGYuZm9ybWF0c1tmb3JtYXRdO1xuICAgICAgICAgICAgaWYgKCFmbXREZWYgfHwgZm10RGVmID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm10RGVmICE9IFwib2JqZWN0XCIgfHxcbiAgICAgICAgICAgICAgICBmbXREZWYgaW5zdGFuY2VvZiBSZWdFeHAgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgZm10RGVmLmNvbXBhcmUgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7a2V5d29yZH1cIjogZm9ybWF0IFwiJHtmb3JtYXR9XCIgZG9lcyBub3QgZGVmaW5lIFwiY29tcGFyZVwiIGZ1bmN0aW9uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmbXQgPSBnZW4uc2NvcGVWYWx1ZShcImZvcm1hdHNcIiwge1xuICAgICAgICAgICAgICAgIGtleTogZm9ybWF0LFxuICAgICAgICAgICAgICAgIHJlZjogZm10RGVmLFxuICAgICAgICAgICAgICAgIGNvZGU6IG9wdHMuY29kZS5mb3JtYXRzID8gY29kZWdlbl8xLl8gYCR7b3B0cy5jb2RlLmZvcm1hdHN9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkoZm9ybWF0KX1gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjeHQuZmFpbCRkYXRhKGNvbXBhcmVDb2RlKGZtdCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvbXBhcmVDb2RlKGZtdCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5fIGAke2ZtdH0uY29tcGFyZSgke2RhdGF9LCAke3NjaGVtYUNvZGV9KSAke0tXRHNba2V5d29yZF0uZmFpbH0gMGA7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1wiZm9ybWF0XCJdLFxufTtcbmNvbnN0IGZvcm1hdExpbWl0UGx1Z2luID0gKGFqdikgPT4ge1xuICAgIGFqdi5hZGRLZXl3b3JkKGV4cG9ydHMuZm9ybWF0TGltaXREZWZpbml0aW9uKTtcbiAgICByZXR1cm4gYWp2O1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZvcm1hdExpbWl0UGx1Z2luO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBmb3JtYXRzXzEgPSByZXF1aXJlKFwiLi9mb3JtYXRzXCIpO1xuY29uc3QgbGltaXRfMSA9IHJlcXVpcmUoXCIuL2xpbWl0XCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcImFqdi9kaXN0L2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGZ1bGxOYW1lID0gbmV3IGNvZGVnZW5fMS5OYW1lKFwiZnVsbEZvcm1hdHNcIik7XG5jb25zdCBmYXN0TmFtZSA9IG5ldyBjb2RlZ2VuXzEuTmFtZShcImZhc3RGb3JtYXRzXCIpO1xuY29uc3QgZm9ybWF0c1BsdWdpbiA9IChhanYsIG9wdHMgPSB7IGtleXdvcmRzOiB0cnVlIH0pID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgICAgICBhZGRGb3JtYXRzKGFqdiwgb3B0cywgZm9ybWF0c18xLmZ1bGxGb3JtYXRzLCBmdWxsTmFtZSk7XG4gICAgICAgIHJldHVybiBhanY7XG4gICAgfVxuICAgIGNvbnN0IFtmb3JtYXRzLCBleHBvcnROYW1lXSA9IG9wdHMubW9kZSA9PT0gXCJmYXN0XCIgPyBbZm9ybWF0c18xLmZhc3RGb3JtYXRzLCBmYXN0TmFtZV0gOiBbZm9ybWF0c18xLmZ1bGxGb3JtYXRzLCBmdWxsTmFtZV07XG4gICAgY29uc3QgbGlzdCA9IG9wdHMuZm9ybWF0cyB8fCBmb3JtYXRzXzEuZm9ybWF0TmFtZXM7XG4gICAgYWRkRm9ybWF0cyhhanYsIGxpc3QsIGZvcm1hdHMsIGV4cG9ydE5hbWUpO1xuICAgIGlmIChvcHRzLmtleXdvcmRzKVxuICAgICAgICBsaW1pdF8xLmRlZmF1bHQoYWp2KTtcbiAgICByZXR1cm4gYWp2O1xufTtcbmZvcm1hdHNQbHVnaW4uZ2V0ID0gKG5hbWUsIG1vZGUgPSBcImZ1bGxcIikgPT4ge1xuICAgIGNvbnN0IGZvcm1hdHMgPSBtb2RlID09PSBcImZhc3RcIiA/IGZvcm1hdHNfMS5mYXN0Rm9ybWF0cyA6IGZvcm1hdHNfMS5mdWxsRm9ybWF0cztcbiAgICBjb25zdCBmID0gZm9ybWF0c1tuYW1lXTtcbiAgICBpZiAoIWYpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBmb3JtYXQgXCIke25hbWV9XCJgKTtcbiAgICByZXR1cm4gZjtcbn07XG5mdW5jdGlvbiBhZGRGb3JtYXRzKGFqdiwgbGlzdCwgZnMsIGV4cG9ydE5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIF9iO1xuICAgIChfYSA9IChfYiA9IGFqdi5vcHRzLmNvZGUpLmZvcm1hdHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYi5mb3JtYXRzID0gY29kZWdlbl8xLl8gYHJlcXVpcmUoXCJhanYtZm9ybWF0cy9kaXN0L2Zvcm1hdHNcIikuJHtleHBvcnROYW1lfWApO1xuICAgIGZvciAoY29uc3QgZiBvZiBsaXN0KVxuICAgICAgICBhanYuYWRkRm9ybWF0KGYsIGZzW2ZdKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZvcm1hdHNQbHVnaW47XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBmb3JtYXRzUGx1Z2luO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjb3B5UHJvcGVydHkgPSAodG8sIGZyb20sIHByb3BlcnR5LCBpZ25vcmVOb25Db25maWd1cmFibGUpID0+IHtcblx0Ly8gYEZ1bmN0aW9uI2xlbmd0aGAgc2hvdWxkIHJlZmxlY3QgdGhlIHBhcmFtZXRlcnMgb2YgYHRvYCBub3QgYGZyb21gIHNpbmNlIHdlIGtlZXAgaXRzIGJvZHkuXG5cdC8vIGBGdW5jdGlvbiNwcm90b3R5cGVgIGlzIG5vbi13cml0YWJsZSBhbmQgbm9uLWNvbmZpZ3VyYWJsZSBzbyBjYW4gbmV2ZXIgYmUgbW9kaWZpZWQuXG5cdGlmIChwcm9wZXJ0eSA9PT0gJ2xlbmd0aCcgfHwgcHJvcGVydHkgPT09ICdwcm90b3R5cGUnKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gYEZ1bmN0aW9uI2FyZ3VtZW50c2AgYW5kIGBGdW5jdGlvbiNjYWxsZXJgIHNob3VsZCBub3QgYmUgY29waWVkLiBUaGV5IHdlcmUgcmVwb3J0ZWQgdG8gYmUgcHJlc2VudCBpbiBgUmVmbGVjdC5vd25LZXlzYCBmb3Igc29tZSBkZXZpY2VzIGluIFJlYWN0IE5hdGl2ZSAoIzQxKSwgc28gd2UgZXhwbGljaXRseSBpZ25vcmUgdGhlbSBoZXJlLlxuXHRpZiAocHJvcGVydHkgPT09ICdhcmd1bWVudHMnIHx8IHByb3BlcnR5ID09PSAnY2FsbGVyJykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IHRvRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG8sIHByb3BlcnR5KTtcblx0Y29uc3QgZnJvbURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGZyb20sIHByb3BlcnR5KTtcblxuXHRpZiAoIWNhbkNvcHlQcm9wZXJ0eSh0b0Rlc2NyaXB0b3IsIGZyb21EZXNjcmlwdG9yKSAmJiBpZ25vcmVOb25Db25maWd1cmFibGUpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkodG8sIHByb3BlcnR5LCBmcm9tRGVzY3JpcHRvcik7XG59O1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5KClgIHRocm93cyBpZiB0aGUgcHJvcGVydHkgZXhpc3RzLCBpcyBub3QgY29uZmlndXJhYmxlIGFuZCBlaXRoZXI6XG4vLyAgLSBvbmUgaXRzIGRlc2NyaXB0b3JzIGlzIGNoYW5nZWRcbi8vICAtIGl0IGlzIG5vbi13cml0YWJsZSBhbmQgaXRzIHZhbHVlIGlzIGNoYW5nZWRcbmNvbnN0IGNhbkNvcHlQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0b0Rlc2NyaXB0b3IsIGZyb21EZXNjcmlwdG9yKSB7XG5cdHJldHVybiB0b0Rlc2NyaXB0b3IgPT09IHVuZGVmaW5lZCB8fCB0b0Rlc2NyaXB0b3IuY29uZmlndXJhYmxlIHx8IChcblx0XHR0b0Rlc2NyaXB0b3Iud3JpdGFibGUgPT09IGZyb21EZXNjcmlwdG9yLndyaXRhYmxlICYmXG5cdFx0dG9EZXNjcmlwdG9yLmVudW1lcmFibGUgPT09IGZyb21EZXNjcmlwdG9yLmVudW1lcmFibGUgJiZcblx0XHR0b0Rlc2NyaXB0b3IuY29uZmlndXJhYmxlID09PSBmcm9tRGVzY3JpcHRvci5jb25maWd1cmFibGUgJiZcblx0XHQodG9EZXNjcmlwdG9yLndyaXRhYmxlIHx8IHRvRGVzY3JpcHRvci52YWx1ZSA9PT0gZnJvbURlc2NyaXB0b3IudmFsdWUpXG5cdCk7XG59O1xuXG5jb25zdCBjaGFuZ2VQcm90b3R5cGUgPSAodG8sIGZyb20pID0+IHtcblx0Y29uc3QgZnJvbVByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihmcm9tKTtcblx0aWYgKGZyb21Qcm90b3R5cGUgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0bykpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRPYmplY3Quc2V0UHJvdG90eXBlT2YodG8sIGZyb21Qcm90b3R5cGUpO1xufTtcblxuY29uc3Qgd3JhcHBlZFRvU3RyaW5nID0gKHdpdGhOYW1lLCBmcm9tQm9keSkgPT4gYC8qIFdyYXBwZWQgJHt3aXRoTmFtZX0qL1xcbiR7ZnJvbUJvZHl9YDtcblxuY29uc3QgdG9TdHJpbmdEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihGdW5jdGlvbi5wcm90b3R5cGUsICd0b1N0cmluZycpO1xuY29uc3QgdG9TdHJpbmdOYW1lID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcsICduYW1lJyk7XG5cbi8vIFdlIGNhbGwgYGZyb20udG9TdHJpbmcoKWAgZWFybHkgKG5vdCBsYXppbHkpIHRvIGVuc3VyZSBgZnJvbWAgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuLy8gV2UgdXNlIGBiaW5kKClgIGluc3RlYWQgb2YgYSBjbG9zdXJlIGZvciB0aGUgc2FtZSByZWFzb24uXG4vLyBDYWxsaW5nIGBmcm9tLnRvU3RyaW5nKClgIGVhcmx5IGFsc28gYWxsb3dzIGNhY2hpbmcgaXQgaW4gY2FzZSBgdG8udG9TdHJpbmcoKWAgaXMgY2FsbGVkIHNldmVyYWwgdGltZXMuXG5jb25zdCBjaGFuZ2VUb1N0cmluZyA9ICh0bywgZnJvbSwgbmFtZSkgPT4ge1xuXHRjb25zdCB3aXRoTmFtZSA9IG5hbWUgPT09ICcnID8gJycgOiBgd2l0aCAke25hbWUudHJpbSgpfSgpIGA7XG5cdGNvbnN0IG5ld1RvU3RyaW5nID0gd3JhcHBlZFRvU3RyaW5nLmJpbmQobnVsbCwgd2l0aE5hbWUsIGZyb20udG9TdHJpbmcoKSk7XG5cdC8vIEVuc3VyZSBgdG8udG9TdHJpbmcudG9TdHJpbmdgIGlzIG5vbi1lbnVtZXJhYmxlIGFuZCBoYXMgdGhlIHNhbWUgYHNhbWVgXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdUb1N0cmluZywgJ25hbWUnLCB0b1N0cmluZ05hbWUpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkodG8sICd0b1N0cmluZycsIHsuLi50b1N0cmluZ0Rlc2NyaXB0b3IsIHZhbHVlOiBuZXdUb1N0cmluZ30pO1xufTtcblxuY29uc3QgbWltaWNGbiA9ICh0bywgZnJvbSwge2lnbm9yZU5vbkNvbmZpZ3VyYWJsZSA9IGZhbHNlfSA9IHt9KSA9PiB7XG5cdGNvbnN0IHtuYW1lfSA9IHRvO1xuXG5cdGZvciAoY29uc3QgcHJvcGVydHkgb2YgUmVmbGVjdC5vd25LZXlzKGZyb20pKSB7XG5cdFx0Y29weVByb3BlcnR5KHRvLCBmcm9tLCBwcm9wZXJ0eSwgaWdub3JlTm9uQ29uZmlndXJhYmxlKTtcblx0fVxuXG5cdGNoYW5nZVByb3RvdHlwZSh0bywgZnJvbSk7XG5cdGNoYW5nZVRvU3RyaW5nKHRvLCBmcm9tLCBuYW1lKTtcblxuXHRyZXR1cm4gdG87XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1pbWljRm47XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBtaW1pY0ZuID0gcmVxdWlyZSgnbWltaWMtZm4nKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoaW5wdXRGdW5jdGlvbiwgb3B0aW9ucyA9IHt9KSA9PiB7XG5cdGlmICh0eXBlb2YgaW5wdXRGdW5jdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIHRoZSBmaXJzdCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uLCBnb3QgXFxgJHt0eXBlb2YgaW5wdXRGdW5jdGlvbn1cXGBgKTtcblx0fVxuXG5cdGNvbnN0IHtcblx0XHR3YWl0ID0gMCxcblx0XHRiZWZvcmUgPSBmYWxzZSxcblx0XHRhZnRlciA9IHRydWVcblx0fSA9IG9wdGlvbnM7XG5cblx0aWYgKCFiZWZvcmUgJiYgIWFmdGVyKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdCb3RoIGBiZWZvcmVgIGFuZCBgYWZ0ZXJgIGFyZSBmYWxzZSwgZnVuY3Rpb24gd291bGRuXFwndCBiZSBjYWxsZWQuJyk7XG5cdH1cblxuXHRsZXQgdGltZW91dDtcblx0bGV0IHJlc3VsdDtcblxuXHRjb25zdCBkZWJvdW5jZWRGdW5jdGlvbiA9IGZ1bmN0aW9uICguLi5hcmd1bWVudHNfKSB7XG5cdFx0Y29uc3QgY29udGV4dCA9IHRoaXM7XG5cblx0XHRjb25zdCBsYXRlciA9ICgpID0+IHtcblx0XHRcdHRpbWVvdXQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmIChhZnRlcikge1xuXHRcdFx0XHRyZXN1bHQgPSBpbnB1dEZ1bmN0aW9uLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50c18pO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRjb25zdCBzaG91bGRDYWxsTm93ID0gYmVmb3JlICYmICF0aW1lb3V0O1xuXHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHR0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG5cblx0XHRpZiAoc2hvdWxkQ2FsbE5vdykge1xuXHRcdFx0cmVzdWx0ID0gaW5wdXRGdW5jdGlvbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHNfKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdG1pbWljRm4oZGVib3VuY2VkRnVuY3Rpb24sIGlucHV0RnVuY3Rpb24pO1xuXG5cdGRlYm91bmNlZEZ1bmN0aW9uLmNhbmNlbCA9ICgpID0+IHtcblx0XHRpZiAodGltZW91dCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHRcdFx0dGltZW91dCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIGRlYm91bmNlZEZ1bmN0aW9uO1xufTtcbiIsIi8vIE5vdGU6IHRoaXMgaXMgdGhlIHNlbXZlci5vcmcgdmVyc2lvbiBvZiB0aGUgc3BlYyB0aGF0IGl0IGltcGxlbWVudHNcbi8vIE5vdCBuZWNlc3NhcmlseSB0aGUgcGFja2FnZSB2ZXJzaW9uIG9mIHRoaXMgY29kZS5cbmNvbnN0IFNFTVZFUl9TUEVDX1ZFUlNJT04gPSAnMi4wLjAnXG5cbmNvbnN0IE1BWF9MRU5HVEggPSAyNTZcbmNvbnN0IE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyA5MDA3MTk5MjU0NzQwOTkxXG5cbi8vIE1heCBzYWZlIHNlZ21lbnQgbGVuZ3RoIGZvciBjb2VyY2lvbi5cbmNvbnN0IE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggPSAxNlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgU0VNVkVSX1NQRUNfVkVSU0lPTixcbiAgTUFYX0xFTkdUSCxcbiAgTUFYX1NBRkVfSU5URUdFUixcbiAgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSFxufVxuIiwiY29uc3QgZGVidWcgPSAoXG4gIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICBwcm9jZXNzLmVudiAmJlxuICBwcm9jZXNzLmVudi5OT0RFX0RFQlVHICYmXG4gIC9cXGJzZW12ZXJcXGIvaS50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcpXG4pID8gKC4uLmFyZ3MpID0+IGNvbnNvbGUuZXJyb3IoJ1NFTVZFUicsIC4uLmFyZ3MpXG4gIDogKCkgPT4ge31cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJ1Z1xuIiwiY29uc3QgeyBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4vZGVidWcnKVxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge31cblxuLy8gVGhlIGFjdHVhbCByZWdleHBzIGdvIG9uIGV4cG9ydHMucmVcbmNvbnN0IHJlID0gZXhwb3J0cy5yZSA9IFtdXG5jb25zdCBzcmMgPSBleHBvcnRzLnNyYyA9IFtdXG5jb25zdCB0ID0gZXhwb3J0cy50ID0ge31cbmxldCBSID0gMFxuXG5jb25zdCBjcmVhdGVUb2tlbiA9IChuYW1lLCB2YWx1ZSwgaXNHbG9iYWwpID0+IHtcbiAgY29uc3QgaW5kZXggPSBSKytcbiAgZGVidWcoaW5kZXgsIHZhbHVlKVxuICB0W25hbWVdID0gaW5kZXhcbiAgc3JjW2luZGV4XSA9IHZhbHVlXG4gIHJlW2luZGV4XSA9IG5ldyBSZWdFeHAodmFsdWUsIGlzR2xvYmFsID8gJ2cnIDogdW5kZWZpbmVkKVxufVxuXG4vLyBUaGUgZm9sbG93aW5nIFJlZ3VsYXIgRXhwcmVzc2lvbnMgY2FuIGJlIHVzZWQgZm9yIHRva2VuaXppbmcsXG4vLyB2YWxpZGF0aW5nLCBhbmQgcGFyc2luZyBTZW1WZXIgdmVyc2lvbiBzdHJpbmdzLlxuXG4vLyAjIyBOdW1lcmljIElkZW50aWZpZXJcbi8vIEEgc2luZ2xlIGAwYCwgb3IgYSBub24temVybyBkaWdpdCBmb2xsb3dlZCBieSB6ZXJvIG9yIG1vcmUgZGlnaXRzLlxuXG5jcmVhdGVUb2tlbignTlVNRVJJQ0lERU5USUZJRVInLCAnMHxbMS05XVxcXFxkKicpXG5jcmVhdGVUb2tlbignTlVNRVJJQ0lERU5USUZJRVJMT09TRScsICdbMC05XSsnKVxuXG4vLyAjIyBOb24tbnVtZXJpYyBJZGVudGlmaWVyXG4vLyBaZXJvIG9yIG1vcmUgZGlnaXRzLCBmb2xsb3dlZCBieSBhIGxldHRlciBvciBoeXBoZW4sIGFuZCB0aGVuIHplcm8gb3Jcbi8vIG1vcmUgbGV0dGVycywgZGlnaXRzLCBvciBoeXBoZW5zLlxuXG5jcmVhdGVUb2tlbignTk9OTlVNRVJJQ0lERU5USUZJRVInLCAnXFxcXGQqW2EtekEtWi1dW2EtekEtWjAtOS1dKicpXG5cbi8vICMjIE1haW4gVmVyc2lvblxuLy8gVGhyZWUgZG90LXNlcGFyYXRlZCBudW1lcmljIGlkZW50aWZpZXJzLlxuXG5jcmVhdGVUb2tlbignTUFJTlZFUlNJT04nLCBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pYClcblxuY3JlYXRlVG9rZW4oJ01BSU5WRVJTSU9OTE9PU0UnLCBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19KWApXG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb24gSWRlbnRpZmllclxuLy8gQSBudW1lcmljIGlkZW50aWZpZXIsIG9yIGEgbm9uLW51bWVyaWMgaWRlbnRpZmllci5cblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0VJREVOVElGSUVSJywgYCg/OiR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdXG59fCR7c3JjW3QuTk9OTlVNRVJJQ0lERU5USUZJRVJdfSlgKVxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRScsIGAoPzoke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdXG59fCR7c3JjW3QuTk9OTlVNRVJJQ0lERU5USUZJRVJdfSlgKVxuXG4vLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uXG4vLyBIeXBoZW4sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIGRvdC1zZXBhcmF0ZWQgcHJlLXJlbGVhc2UgdmVyc2lvblxuLy8gaWRlbnRpZmllcnMuXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFJywgYCg/Oi0oJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUl1cbn0oPzpcXFxcLiR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJdfSkqKSlgKVxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRUxPT1NFJywgYCg/Oi0/KCR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV1cbn0oPzpcXFxcLiR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV19KSopKWApXG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhIElkZW50aWZpZXJcbi8vIEFueSBjb21iaW5hdGlvbiBvZiBkaWdpdHMsIGxldHRlcnMsIG9yIGh5cGhlbnMuXG5cbmNyZWF0ZVRva2VuKCdCVUlMRElERU5USUZJRVInLCAnWzAtOUEtWmEtei1dKycpXG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhXG4vLyBQbHVzIHNpZ24sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIHBlcmlvZC1zZXBhcmF0ZWQgYnVpbGQgbWV0YWRhdGFcbi8vIGlkZW50aWZpZXJzLlxuXG5jcmVhdGVUb2tlbignQlVJTEQnLCBgKD86XFxcXCsoJHtzcmNbdC5CVUlMRElERU5USUZJRVJdXG59KD86XFxcXC4ke3NyY1t0LkJVSUxESURFTlRJRklFUl19KSopKWApXG5cbi8vICMjIEZ1bGwgVmVyc2lvbiBTdHJpbmdcbi8vIEEgbWFpbiB2ZXJzaW9uLCBmb2xsb3dlZCBvcHRpb25hbGx5IGJ5IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiBhbmRcbi8vIGJ1aWxkIG1ldGFkYXRhLlxuXG4vLyBOb3RlIHRoYXQgdGhlIG9ubHkgbWFqb3IsIG1pbm9yLCBwYXRjaCwgYW5kIHByZS1yZWxlYXNlIHNlY3Rpb25zIG9mXG4vLyB0aGUgdmVyc2lvbiBzdHJpbmcgYXJlIGNhcHR1cmluZyBncm91cHMuICBUaGUgYnVpbGQgbWV0YWRhdGEgaXMgbm90IGFcbi8vIGNhcHR1cmluZyBncm91cCwgYmVjYXVzZSBpdCBzaG91bGQgbm90IGV2ZXIgYmUgdXNlZCBpbiB2ZXJzaW9uXG4vLyBjb21wYXJpc29uLlxuXG5jcmVhdGVUb2tlbignRlVMTFBMQUlOJywgYHY/JHtzcmNbdC5NQUlOVkVSU0lPTl1cbn0ke3NyY1t0LlBSRVJFTEVBU0VdfT8ke1xuICBzcmNbdC5CVUlMRF19P2ApXG5cbmNyZWF0ZVRva2VuKCdGVUxMJywgYF4ke3NyY1t0LkZVTExQTEFJTl19JGApXG5cbi8vIGxpa2UgZnVsbCwgYnV0IGFsbG93cyB2MS4yLjMgYW5kID0xLjIuMywgd2hpY2ggcGVvcGxlIGRvIHNvbWV0aW1lcy5cbi8vIGFsc28sIDEuMC4wYWxwaGExIChwcmVyZWxlYXNlIHdpdGhvdXQgdGhlIGh5cGhlbikgd2hpY2ggaXMgcHJldHR5XG4vLyBjb21tb24gaW4gdGhlIG5wbSByZWdpc3RyeS5cbmNyZWF0ZVRva2VuKCdMT09TRVBMQUlOJywgYFt2PVxcXFxzXSoke3NyY1t0Lk1BSU5WRVJTSU9OTE9PU0VdXG59JHtzcmNbdC5QUkVSRUxFQVNFTE9PU0VdfT8ke1xuICBzcmNbdC5CVUlMRF19P2ApXG5cbmNyZWF0ZVRva2VuKCdMT09TRScsIGBeJHtzcmNbdC5MT09TRVBMQUlOXX0kYClcblxuY3JlYXRlVG9rZW4oJ0dUTFQnLCAnKCg/Ojx8Pik/PT8pJylcblxuLy8gU29tZXRoaW5nIGxpa2UgXCIyLipcIiBvciBcIjEuMi54XCIuXG4vLyBOb3RlIHRoYXQgXCJ4LnhcIiBpcyBhIHZhbGlkIHhSYW5nZSBpZGVudGlmZXIsIG1lYW5pbmcgXCJhbnkgdmVyc2lvblwiXG4vLyBPbmx5IHRoZSBmaXJzdCBpdGVtIGlzIHN0cmljdGx5IHJlcXVpcmVkLlxuY3JlYXRlVG9rZW4oJ1hSQU5HRUlERU5USUZJRVJMT09TRScsIGAke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfXx4fFh8XFxcXCpgKVxuY3JlYXRlVG9rZW4oJ1hSQU5HRUlERU5USUZJRVInLCBgJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19fHh8WHxcXFxcKmApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0VQTEFJTicsIGBbdj1cXFxcc10qKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJdfSlgICtcbiAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYCg/OiR7c3JjW3QuUFJFUkVMRUFTRV19KT8ke1xuICAgICAgICAgICAgICAgICAgICAgc3JjW3QuQlVJTERdfT9gICtcbiAgICAgICAgICAgICAgICAgICBgKT8pP2ApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0VQTEFJTkxPT1NFJywgYFt2PVxcXFxzXSooJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKD86JHtzcmNbdC5QUkVSRUxFQVNFTE9PU0VdfSk/JHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjW3QuQlVJTERdfT9gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGApPyk/YClcblxuY3JlYXRlVG9rZW4oJ1hSQU5HRScsIGBeJHtzcmNbdC5HVExUXX1cXFxccyoke3NyY1t0LlhSQU5HRVBMQUlOXX0kYClcbmNyZWF0ZVRva2VuKCdYUkFOR0VMT09TRScsIGBeJHtzcmNbdC5HVExUXX1cXFxccyoke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKVxuXG4vLyBDb2VyY2lvbi5cbi8vIEV4dHJhY3QgYW55dGhpbmcgdGhhdCBjb3VsZCBjb25jZWl2YWJseSBiZSBhIHBhcnQgb2YgYSB2YWxpZCBzZW12ZXJcbmNyZWF0ZVRva2VuKCdDT0VSQ0UnLCBgJHsnKF58W15cXFxcZF0pJyArXG4gICAgICAgICAgICAgICcoXFxcXGR7MSwnfSR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KWAgK1xuICAgICAgICAgICAgICBgKD86XFxcXC4oXFxcXGR7MSwke01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEh9fSkpP2AgK1xuICAgICAgICAgICAgICBgKD86XFxcXC4oXFxcXGR7MSwke01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEh9fSkpP2AgK1xuICAgICAgICAgICAgICBgKD86JHxbXlxcXFxkXSlgKVxuY3JlYXRlVG9rZW4oJ0NPRVJDRVJUTCcsIHNyY1t0LkNPRVJDRV0sIHRydWUpXG5cbi8vIFRpbGRlIHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJyZWFzb25hYmx5IGF0IG9yIGdyZWF0ZXIgdGhhblwiXG5jcmVhdGVUb2tlbignTE9ORVRJTERFJywgJyg/On4+PyknKVxuXG5jcmVhdGVUb2tlbignVElMREVUUklNJywgYChcXFxccyopJHtzcmNbdC5MT05FVElMREVdfVxcXFxzK2AsIHRydWUpXG5leHBvcnRzLnRpbGRlVHJpbVJlcGxhY2UgPSAnJDF+J1xuXG5jcmVhdGVUb2tlbignVElMREUnLCBgXiR7c3JjW3QuTE9ORVRJTERFXX0ke3NyY1t0LlhSQU5HRVBMQUlOXX0kYClcbmNyZWF0ZVRva2VuKCdUSUxERUxPT1NFJywgYF4ke3NyY1t0LkxPTkVUSUxERV19JHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQ2FyZXQgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcImF0IGxlYXN0IGFuZCBiYWNrd2FyZHMgY29tcGF0aWJsZSB3aXRoXCJcbmNyZWF0ZVRva2VuKCdMT05FQ0FSRVQnLCAnKD86XFxcXF4pJylcblxuY3JlYXRlVG9rZW4oJ0NBUkVUVFJJTScsIGAoXFxcXHMqKSR7c3JjW3QuTE9ORUNBUkVUXX1cXFxccytgLCB0cnVlKVxuZXhwb3J0cy5jYXJldFRyaW1SZXBsYWNlID0gJyQxXidcblxuY3JlYXRlVG9rZW4oJ0NBUkVUJywgYF4ke3NyY1t0LkxPTkVDQVJFVF19JHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignQ0FSRVRMT09TRScsIGBeJHtzcmNbdC5MT05FQ0FSRVRdfSR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19JGApXG5cbi8vIEEgc2ltcGxlIGd0L2x0L2VxIHRoaW5nLCBvciBqdXN0IFwiXCIgdG8gaW5kaWNhdGUgXCJhbnkgdmVyc2lvblwiXG5jcmVhdGVUb2tlbignQ09NUEFSQVRPUkxPT1NFJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKigke3NyY1t0LkxPT1NFUExBSU5dfSkkfF4kYClcbmNyZWF0ZVRva2VuKCdDT01QQVJBVE9SJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKigke3NyY1t0LkZVTExQTEFJTl19KSR8XiRgKVxuXG4vLyBBbiBleHByZXNzaW9uIHRvIHN0cmlwIGFueSB3aGl0ZXNwYWNlIGJldHdlZW4gdGhlIGd0bHQgYW5kIHRoZSB0aGluZ1xuLy8gaXQgbW9kaWZpZXMsIHNvIHRoYXQgYD4gMS4yLjNgID09PiBgPjEuMi4zYFxuY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1JUUklNJywgYChcXFxccyopJHtzcmNbdC5HVExUXVxufVxcXFxzKigke3NyY1t0LkxPT1NFUExBSU5dfXwke3NyY1t0LlhSQU5HRVBMQUlOXX0pYCwgdHJ1ZSlcbmV4cG9ydHMuY29tcGFyYXRvclRyaW1SZXBsYWNlID0gJyQxJDIkMydcblxuLy8gU29tZXRoaW5nIGxpa2UgYDEuMi4zIC0gMS4yLjRgXG4vLyBOb3RlIHRoYXQgdGhlc2UgYWxsIHVzZSB0aGUgbG9vc2UgZm9ybSwgYmVjYXVzZSB0aGV5J2xsIGJlXG4vLyBjaGVja2VkIGFnYWluc3QgZWl0aGVyIHRoZSBzdHJpY3Qgb3IgbG9vc2UgY29tcGFyYXRvciBmb3JtXG4vLyBsYXRlci5cbmNyZWF0ZVRva2VuKCdIWVBIRU5SQU5HRScsIGBeXFxcXHMqKCR7c3JjW3QuWFJBTkdFUExBSU5dfSlgICtcbiAgICAgICAgICAgICAgICAgICBgXFxcXHMrLVxcXFxzK2AgK1xuICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5YUkFOR0VQTEFJTl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGBcXFxccyokYClcblxuY3JlYXRlVG9rZW4oJ0hZUEhFTlJBTkdFTE9PU0UnLCBgXlxcXFxzKigke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcXFxccystXFxcXHMrYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYFxcXFxzKiRgKVxuXG4vLyBTdGFyIHJhbmdlcyBiYXNpY2FsbHkganVzdCBhbGxvdyBhbnl0aGluZyBhdCBhbGwuXG5jcmVhdGVUb2tlbignU1RBUicsICcoPHw+KT89P1xcXFxzKlxcXFwqJylcbi8vID49MC4wLjAgaXMgbGlrZSBhIHN0YXJcbmNyZWF0ZVRva2VuKCdHVEUwJywgJ15cXFxccyo+PVxcXFxzKjBcXC4wXFwuMFxcXFxzKiQnKVxuY3JlYXRlVG9rZW4oJ0dURTBQUkUnLCAnXlxcXFxzKj49XFxcXHMqMFxcLjBcXC4wLTBcXFxccyokJylcbiIsIi8vIHBhcnNlIG91dCBqdXN0IHRoZSBvcHRpb25zIHdlIGNhcmUgYWJvdXQgc28gd2UgYWx3YXlzIGdldCBhIGNvbnNpc3RlbnRcbi8vIG9iaiB3aXRoIGtleXMgaW4gYSBjb25zaXN0ZW50IG9yZGVyLlxuY29uc3Qgb3B0cyA9IFsnaW5jbHVkZVByZXJlbGVhc2UnLCAnbG9vc2UnLCAncnRsJ11cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IG9wdGlvbnMgPT5cbiAgIW9wdGlvbnMgPyB7fVxuICA6IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyA/IHsgbG9vc2U6IHRydWUgfVxuICA6IG9wdHMuZmlsdGVyKGsgPT4gb3B0aW9uc1trXSkucmVkdWNlKChvcHRpb25zLCBrKSA9PiB7XG4gICAgb3B0aW9uc1trXSA9IHRydWVcbiAgICByZXR1cm4gb3B0aW9uc1xuICB9LCB7fSlcbm1vZHVsZS5leHBvcnRzID0gcGFyc2VPcHRpb25zXG4iLCJjb25zdCBudW1lcmljID0gL15bMC05XSskL1xuY29uc3QgY29tcGFyZUlkZW50aWZpZXJzID0gKGEsIGIpID0+IHtcbiAgY29uc3QgYW51bSA9IG51bWVyaWMudGVzdChhKVxuICBjb25zdCBibnVtID0gbnVtZXJpYy50ZXN0KGIpXG5cbiAgaWYgKGFudW0gJiYgYm51bSkge1xuICAgIGEgPSArYVxuICAgIGIgPSArYlxuICB9XG5cbiAgcmV0dXJuIGEgPT09IGIgPyAwXG4gICAgOiAoYW51bSAmJiAhYm51bSkgPyAtMVxuICAgIDogKGJudW0gJiYgIWFudW0pID8gMVxuICAgIDogYSA8IGIgPyAtMVxuICAgIDogMVxufVxuXG5jb25zdCByY29tcGFyZUlkZW50aWZpZXJzID0gKGEsIGIpID0+IGNvbXBhcmVJZGVudGlmaWVycyhiLCBhKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29tcGFyZUlkZW50aWZpZXJzLFxuICByY29tcGFyZUlkZW50aWZpZXJzXG59XG4iLCJjb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IHsgTUFYX0xFTkdUSCwgTUFYX1NBRkVfSU5URUdFUiB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvY29uc3RhbnRzJylcbmNvbnN0IHsgcmUsIHQgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCB7IGNvbXBhcmVJZGVudGlmaWVycyB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaWRlbnRpZmllcnMnKVxuY2xhc3MgU2VtVmVyIHtcbiAgY29uc3RydWN0b3IgKHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgICAgaWYgKHZlcnNpb24ubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSAmJlxuICAgICAgICAgIHZlcnNpb24uaW5jbHVkZVByZXJlbGVhc2UgPT09ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgICAgICByZXR1cm4gdmVyc2lvblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmVyc2lvbiA9IHZlcnNpb24udmVyc2lvblxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFZlcnNpb246ICR7dmVyc2lvbn1gKVxuICAgIH1cblxuICAgIGlmICh2ZXJzaW9uLmxlbmd0aCA+IE1BWF9MRU5HVEgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIGB2ZXJzaW9uIGlzIGxvbmdlciB0aGFuICR7TUFYX0xFTkdUSH0gY2hhcmFjdGVyc2BcbiAgICAgIClcbiAgICB9XG5cbiAgICBkZWJ1ZygnU2VtVmVyJywgdmVyc2lvbiwgb3B0aW9ucylcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICAgIC8vIHRoaXMgaXNuJ3QgYWN0dWFsbHkgcmVsZXZhbnQgZm9yIHZlcnNpb25zLCBidXQga2VlcCBpdCBzbyB0aGF0IHdlXG4gICAgLy8gZG9uJ3QgcnVuIGludG8gdHJvdWJsZSBwYXNzaW5nIHRoaXMub3B0aW9ucyBhcm91bmQuXG4gICAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuXG4gICAgY29uc3QgbSA9IHZlcnNpb24udHJpbSgpLm1hdGNoKG9wdGlvbnMubG9vc2UgPyByZVt0LkxPT1NFXSA6IHJlW3QuRlVMTF0pXG5cbiAgICBpZiAoIW0pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgVmVyc2lvbjogJHt2ZXJzaW9ufWApXG4gICAgfVxuXG4gICAgdGhpcy5yYXcgPSB2ZXJzaW9uXG5cbiAgICAvLyB0aGVzZSBhcmUgYWN0dWFsbHkgbnVtYmVyc1xuICAgIHRoaXMubWFqb3IgPSArbVsxXVxuICAgIHRoaXMubWlub3IgPSArbVsyXVxuICAgIHRoaXMucGF0Y2ggPSArbVszXVxuXG4gICAgaWYgKHRoaXMubWFqb3IgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMubWFqb3IgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1ham9yIHZlcnNpb24nKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm1pbm9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1pbm9yIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtaW5vciB2ZXJzaW9uJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXRjaCA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5wYXRjaCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcGF0Y2ggdmVyc2lvbicpXG4gICAgfVxuXG4gICAgLy8gbnVtYmVyaWZ5IGFueSBwcmVyZWxlYXNlIG51bWVyaWMgaWRzXG4gICAgaWYgKCFtWzRdKSB7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBtWzRdLnNwbGl0KCcuJykubWFwKChpZCkgPT4ge1xuICAgICAgICBpZiAoL15bMC05XSskLy50ZXN0KGlkKSkge1xuICAgICAgICAgIGNvbnN0IG51bSA9ICtpZFxuICAgICAgICAgIGlmIChudW0gPj0gMCAmJiBudW0gPCBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLmJ1aWxkID0gbVs1XSA/IG1bNV0uc3BsaXQoJy4nKSA6IFtdXG4gICAgdGhpcy5mb3JtYXQoKVxuICB9XG5cbiAgZm9ybWF0ICgpIHtcbiAgICB0aGlzLnZlcnNpb24gPSBgJHt0aGlzLm1ham9yfS4ke3RoaXMubWlub3J9LiR7dGhpcy5wYXRjaH1gXG4gICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAgIHRoaXMudmVyc2lvbiArPSBgLSR7dGhpcy5wcmVyZWxlYXNlLmpvaW4oJy4nKX1gXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnZlcnNpb25cbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJzaW9uXG4gIH1cblxuICBjb21wYXJlIChvdGhlcikge1xuICAgIGRlYnVnKCdTZW1WZXIuY29tcGFyZScsIHRoaXMudmVyc2lvbiwgdGhpcy5vcHRpb25zLCBvdGhlcilcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3RoZXIgPT09ICdzdHJpbmcnICYmIG90aGVyID09PSB0aGlzLnZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH1cbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIGlmIChvdGhlci52ZXJzaW9uID09PSB0aGlzLnZlcnNpb24pIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZU1haW4ob3RoZXIpIHx8IHRoaXMuY29tcGFyZVByZShvdGhlcilcbiAgfVxuXG4gIGNvbXBhcmVNYWluIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1ham9yLCBvdGhlci5tYWpvcikgfHxcbiAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1pbm9yLCBvdGhlci5taW5vcikgfHxcbiAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLnBhdGNoLCBvdGhlci5wYXRjaClcbiAgICApXG4gIH1cblxuICBjb21wYXJlUHJlIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgLy8gTk9UIGhhdmluZyBhIHByZXJlbGVhc2UgaXMgPiBoYXZpbmcgb25lXG4gICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmIG90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH0gZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIGxldCBpID0gMFxuICAgIGRvIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLnByZXJlbGVhc2VbaV1cbiAgICAgIGNvbnN0IGIgPSBvdGhlci5wcmVyZWxlYXNlW2ldXG4gICAgICBkZWJ1ZygncHJlcmVsZWFzZSBjb21wYXJlJywgaSwgYSwgYilcbiAgICAgIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9IGVsc2UgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfSBlbHNlIGlmIChhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9IGVsc2UgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYilcbiAgICAgIH1cbiAgICB9IHdoaWxlICgrK2kpXG4gIH1cblxuICBjb21wYXJlQnVpbGQgKG90aGVyKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICBsZXQgaSA9IDBcbiAgICBkbyB7XG4gICAgICBjb25zdCBhID0gdGhpcy5idWlsZFtpXVxuICAgICAgY29uc3QgYiA9IG90aGVyLmJ1aWxkW2ldXG4gICAgICBkZWJ1ZygncHJlcmVsZWFzZSBjb21wYXJlJywgaSwgYSwgYilcbiAgICAgIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9IGVsc2UgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfSBlbHNlIGlmIChhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9IGVsc2UgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYilcbiAgICAgIH1cbiAgICB9IHdoaWxlICgrK2kpXG4gIH1cblxuICAvLyBwcmVtaW5vciB3aWxsIGJ1bXAgdGhlIHZlcnNpb24gdXAgdG8gdGhlIG5leHQgbWlub3IgcmVsZWFzZSwgYW5kIGltbWVkaWF0ZWx5XG4gIC8vIGRvd24gdG8gcHJlLXJlbGVhc2UuIHByZW1ham9yIGFuZCBwcmVwYXRjaCB3b3JrIHRoZSBzYW1lIHdheS5cbiAgaW5jIChyZWxlYXNlLCBpZGVudGlmaWVyKSB7XG4gICAgc3dpdGNoIChyZWxlYXNlKSB7XG4gICAgICBjYXNlICdwcmVtYWpvcic6XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMubWlub3IgPSAwXG4gICAgICAgIHRoaXMubWFqb3IrK1xuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3ByZW1pbm9yJzpcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5taW5vcisrXG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncHJlcGF0Y2gnOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGFscmVhZHkgYSBwcmVyZWxlYXNlLCBpdCB3aWxsIGJ1bXAgdG8gdGhlIG5leHQgdmVyc2lvblxuICAgICAgICAvLyBkcm9wIGFueSBwcmVyZWxlYXNlcyB0aGF0IG1pZ2h0IGFscmVhZHkgZXhpc3QsIHNpbmNlIHRoZXkgYXJlIG5vdFxuICAgICAgICAvLyByZWxldmFudCBhdCB0aGlzIHBvaW50LlxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyKVxuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgICAgYnJlYWtcbiAgICAgIC8vIElmIHRoZSBpbnB1dCBpcyBhIG5vbi1wcmVyZWxlYXNlIHZlcnNpb24sIHRoaXMgYWN0cyB0aGUgc2FtZSBhc1xuICAgICAgLy8gcHJlcGF0Y2guXG4gICAgICBjYXNlICdwcmVyZWxlYXNlJzpcbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdtYWpvcic6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmUtbWFqb3IgdmVyc2lvbiwgYnVtcCB1cCB0byB0aGUgc2FtZSBtYWpvciB2ZXJzaW9uLlxuICAgICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1ham9yLlxuICAgICAgICAvLyAxLjAuMC01IGJ1bXBzIHRvIDEuMC4wXG4gICAgICAgIC8vIDEuMS4wIGJ1bXBzIHRvIDIuMC4wXG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLm1pbm9yICE9PSAwIHx8XG4gICAgICAgICAgdGhpcy5wYXRjaCAhPT0gMCB8fFxuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5tYWpvcisrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5taW5vciA9IDBcbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ21pbm9yJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1taW5vciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1pbm9yIHZlcnNpb24uXG4gICAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWlub3IuXG4gICAgICAgIC8vIDEuMi4wLTUgYnVtcHMgdG8gMS4yLjBcbiAgICAgICAgLy8gMS4yLjEgYnVtcHMgdG8gMS4zLjBcbiAgICAgICAgaWYgKHRoaXMucGF0Y2ggIT09IDAgfHwgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMubWlub3IrK1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwYXRjaCc6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgbm90IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiwgaXQgd2lsbCBpbmNyZW1lbnQgdGhlIHBhdGNoLlxuICAgICAgICAvLyBJZiBpdCBpcyBhIHByZS1yZWxlYXNlIGl0IHdpbGwgYnVtcCB1cCB0byB0aGUgc2FtZSBwYXRjaCB2ZXJzaW9uLlxuICAgICAgICAvLyAxLjIuMC01IHBhdGNoZXMgdG8gMS4yLjBcbiAgICAgICAgLy8gMS4yLjAgcGF0Y2hlcyB0byAxLjIuMVxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMucGF0Y2grK1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICAgIGJyZWFrXG4gICAgICAvLyBUaGlzIHByb2JhYmx5IHNob3VsZG4ndCBiZSB1c2VkIHB1YmxpY2x5LlxuICAgICAgLy8gMS4wLjAgJ3ByZScgd291bGQgYmVjb21lIDEuMC4wLTAgd2hpY2ggaXMgdGhlIHdyb25nIGRpcmVjdGlvbi5cbiAgICAgIGNhc2UgJ3ByZSc6XG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gWzBdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGkgPSB0aGlzLnByZXJlbGVhc2UubGVuZ3RoXG4gICAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJlcmVsZWFzZVtpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlW2ldKytcbiAgICAgICAgICAgICAgaSA9IC0yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgLy8gZGlkbid0IGluY3JlbWVudCBhbnl0aGluZ1xuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLnB1c2goMClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkZW50aWZpZXIpIHtcbiAgICAgICAgICAvLyAxLjIuMC1iZXRhLjEgYnVtcHMgdG8gMS4yLjAtYmV0YS4yLFxuICAgICAgICAgIC8vIDEuMi4wLWJldGEuZm9vYmx6IG9yIDEuMi4wLWJldGEgYnVtcHMgdG8gMS4yLjAtYmV0YS4wXG4gICAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZVswXSA9PT0gaWRlbnRpZmllcikge1xuICAgICAgICAgICAgaWYgKGlzTmFOKHRoaXMucHJlcmVsZWFzZVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW2lkZW50aWZpZXIsIDBdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCAwXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVha1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5jcmVtZW50IGFyZ3VtZW50OiAke3JlbGVhc2V9YClcbiAgICB9XG4gICAgdGhpcy5mb3JtYXQoKVxuICAgIHRoaXMucmF3ID0gdGhpcy52ZXJzaW9uXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbVZlclxuIiwiY29uc3Qge01BWF9MRU5HVEh9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvY29uc3RhbnRzJylcbmNvbnN0IHsgcmUsIHQgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCBwYXJzZSA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucylcblxuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgIHJldHVybiB2ZXJzaW9uXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGlmICh2ZXJzaW9uLmxlbmd0aCA+IE1BWF9MRU5HVEgpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LkxPT1NFXSA6IHJlW3QuRlVMTF1cbiAgaWYgKCFyLnRlc3QodmVyc2lvbikpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZVxuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHZhbGlkID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgdiA9IHBhcnNlKHZlcnNpb24sIG9wdGlvbnMpXG4gIHJldHVybiB2ID8gdi52ZXJzaW9uIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZFxuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IGNsZWFuID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcyA9IHBhcnNlKHZlcnNpb24udHJpbSgpLnJlcGxhY2UoL15bPXZdKy8sICcnKSwgb3B0aW9ucylcbiAgcmV0dXJuIHMgPyBzLnZlcnNpb24gOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IGNsZWFuXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5cbmNvbnN0IGluYyA9ICh2ZXJzaW9uLCByZWxlYXNlLCBvcHRpb25zLCBpZGVudGlmaWVyKSA9PiB7XG4gIGlmICh0eXBlb2YgKG9wdGlvbnMpID09PSAnc3RyaW5nJykge1xuICAgIGlkZW50aWZpZXIgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZFxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKS5pbmMocmVsZWFzZSwgaWRlbnRpZmllcikudmVyc2lvblxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gaW5jXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBjb21wYXJlID0gKGEsIGIsIGxvb3NlKSA9PlxuICBuZXcgU2VtVmVyKGEsIGxvb3NlKS5jb21wYXJlKG5ldyBTZW1WZXIoYiwgbG9vc2UpKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZXEgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID09PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGVxXG4iLCJjb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgZXEgPSByZXF1aXJlKCcuL2VxJylcblxuY29uc3QgZGlmZiA9ICh2ZXJzaW9uMSwgdmVyc2lvbjIpID0+IHtcbiAgaWYgKGVxKHZlcnNpb24xLCB2ZXJzaW9uMikpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHYxID0gcGFyc2UodmVyc2lvbjEpXG4gICAgY29uc3QgdjIgPSBwYXJzZSh2ZXJzaW9uMilcbiAgICBjb25zdCBoYXNQcmUgPSB2MS5wcmVyZWxlYXNlLmxlbmd0aCB8fCB2Mi5wcmVyZWxlYXNlLmxlbmd0aFxuICAgIGNvbnN0IHByZWZpeCA9IGhhc1ByZSA/ICdwcmUnIDogJydcbiAgICBjb25zdCBkZWZhdWx0UmVzdWx0ID0gaGFzUHJlID8gJ3ByZXJlbGVhc2UnIDogJydcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2MSkge1xuICAgICAgaWYgKGtleSA9PT0gJ21ham9yJyB8fCBrZXkgPT09ICdtaW5vcicgfHwga2V5ID09PSAncGF0Y2gnKSB7XG4gICAgICAgIGlmICh2MVtrZXldICE9PSB2MltrZXldKSB7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeCArIGtleVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0UmVzdWx0IC8vIG1heSBiZSB1bmRlZmluZWRcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBkaWZmXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBtYWpvciA9IChhLCBsb29zZSkgPT4gbmV3IFNlbVZlcihhLCBsb29zZSkubWFqb3Jcbm1vZHVsZS5leHBvcnRzID0gbWFqb3JcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IG1pbm9yID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5taW5vclxubW9kdWxlLmV4cG9ydHMgPSBtaW5vclxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgcGF0Y2ggPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLnBhdGNoXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoXG4iLCJjb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgcHJlcmVsZWFzZSA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHBhcnNlZCA9IHBhcnNlKHZlcnNpb24sIG9wdGlvbnMpXG4gIHJldHVybiAocGFyc2VkICYmIHBhcnNlZC5wcmVyZWxlYXNlLmxlbmd0aCkgPyBwYXJzZWQucHJlcmVsZWFzZSA6IG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gcHJlcmVsZWFzZVxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCByY29tcGFyZSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShiLCBhLCBsb29zZSlcbm1vZHVsZS5leHBvcnRzID0gcmNvbXBhcmVcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgY29tcGFyZUxvb3NlID0gKGEsIGIpID0+IGNvbXBhcmUoYSwgYiwgdHJ1ZSlcbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZUxvb3NlXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBjb21wYXJlQnVpbGQgPSAoYSwgYiwgbG9vc2UpID0+IHtcbiAgY29uc3QgdmVyc2lvbkEgPSBuZXcgU2VtVmVyKGEsIGxvb3NlKVxuICBjb25zdCB2ZXJzaW9uQiA9IG5ldyBTZW1WZXIoYiwgbG9vc2UpXG4gIHJldHVybiB2ZXJzaW9uQS5jb21wYXJlKHZlcnNpb25CKSB8fCB2ZXJzaW9uQS5jb21wYXJlQnVpbGQodmVyc2lvbkIpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVCdWlsZFxuIiwiY29uc3QgY29tcGFyZUJ1aWxkID0gcmVxdWlyZSgnLi9jb21wYXJlLWJ1aWxkJylcbmNvbnN0IHNvcnQgPSAobGlzdCwgbG9vc2UpID0+IGxpc3Quc29ydCgoYSwgYikgPT4gY29tcGFyZUJ1aWxkKGEsIGIsIGxvb3NlKSlcbm1vZHVsZS5leHBvcnRzID0gc29ydFxuIiwiY29uc3QgY29tcGFyZUJ1aWxkID0gcmVxdWlyZSgnLi9jb21wYXJlLWJ1aWxkJylcbmNvbnN0IHJzb3J0ID0gKGxpc3QsIGxvb3NlKSA9PiBsaXN0LnNvcnQoKGEsIGIpID0+IGNvbXBhcmVCdWlsZChiLCBhLCBsb29zZSkpXG5tb2R1bGUuZXhwb3J0cyA9IHJzb3J0XG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGd0ID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+IDBcbm1vZHVsZS5leHBvcnRzID0gZ3RcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbHQgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpIDwgMFxubW9kdWxlLmV4cG9ydHMgPSBsdFxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBuZXEgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpICE9PSAwXG5tb2R1bGUuZXhwb3J0cyA9IG5lcVxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBndGUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID49IDBcbm1vZHVsZS5leHBvcnRzID0gZ3RlXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGx0ZSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPD0gMFxubW9kdWxlLmV4cG9ydHMgPSBsdGVcbiIsImNvbnN0IGVxID0gcmVxdWlyZSgnLi9lcScpXG5jb25zdCBuZXEgPSByZXF1aXJlKCcuL25lcScpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4vZ3QnKVxuY29uc3QgZ3RlID0gcmVxdWlyZSgnLi9ndGUnKVxuY29uc3QgbHQgPSByZXF1aXJlKCcuL2x0JylcbmNvbnN0IGx0ZSA9IHJlcXVpcmUoJy4vbHRlJylcblxuY29uc3QgY21wID0gKGEsIG9wLCBiLCBsb29zZSkgPT4ge1xuICBzd2l0Y2ggKG9wKSB7XG4gICAgY2FzZSAnPT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpXG4gICAgICAgIGEgPSBhLnZlcnNpb25cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpXG4gICAgICAgIGIgPSBiLnZlcnNpb25cbiAgICAgIHJldHVybiBhID09PSBiXG5cbiAgICBjYXNlICchPT0nOlxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JylcbiAgICAgICAgYSA9IGEudmVyc2lvblxuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0JylcbiAgICAgICAgYiA9IGIudmVyc2lvblxuICAgICAgcmV0dXJuIGEgIT09IGJcblxuICAgIGNhc2UgJyc6XG4gICAgY2FzZSAnPSc6XG4gICAgY2FzZSAnPT0nOlxuICAgICAgcmV0dXJuIGVxKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnIT0nOlxuICAgICAgcmV0dXJuIG5lcShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJz4nOlxuICAgICAgcmV0dXJuIGd0KGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPj0nOlxuICAgICAgcmV0dXJuIGd0ZShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJzwnOlxuICAgICAgcmV0dXJuIGx0KGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPD0nOlxuICAgICAgcmV0dXJuIGx0ZShhLCBiLCBsb29zZSlcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIG9wZXJhdG9yOiAke29wfWApXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gY21wXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3Qge3JlLCB0fSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcblxuY29uc3QgY29lcmNlID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICByZXR1cm4gdmVyc2lvblxuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnbnVtYmVyJykge1xuICAgIHZlcnNpb24gPSBTdHJpbmcodmVyc2lvbilcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICBsZXQgbWF0Y2ggPSBudWxsXG4gIGlmICghb3B0aW9ucy5ydGwpIHtcbiAgICBtYXRjaCA9IHZlcnNpb24ubWF0Y2gocmVbdC5DT0VSQ0VdKVxuICB9IGVsc2Uge1xuICAgIC8vIEZpbmQgdGhlIHJpZ2h0LW1vc3QgY29lcmNpYmxlIHN0cmluZyB0aGF0IGRvZXMgbm90IHNoYXJlXG4gICAgLy8gYSB0ZXJtaW51cyB3aXRoIGEgbW9yZSBsZWZ0LXdhcmQgY29lcmNpYmxlIHN0cmluZy5cbiAgICAvLyBFZywgJzEuMi4zLjQnIHdhbnRzIHRvIGNvZXJjZSAnMi4zLjQnLCBub3QgJzMuNCcgb3IgJzQnXG4gICAgLy9cbiAgICAvLyBXYWxrIHRocm91Z2ggdGhlIHN0cmluZyBjaGVja2luZyB3aXRoIGEgL2cgcmVnZXhwXG4gICAgLy8gTWFudWFsbHkgc2V0IHRoZSBpbmRleCBzbyBhcyB0byBwaWNrIHVwIG92ZXJsYXBwaW5nIG1hdGNoZXMuXG4gICAgLy8gU3RvcCB3aGVuIHdlIGdldCBhIG1hdGNoIHRoYXQgZW5kcyBhdCB0aGUgc3RyaW5nIGVuZCwgc2luY2Ugbm9cbiAgICAvLyBjb2VyY2libGUgc3RyaW5nIGNhbiBiZSBtb3JlIHJpZ2h0LXdhcmQgd2l0aG91dCB0aGUgc2FtZSB0ZXJtaW51cy5cbiAgICBsZXQgbmV4dFxuICAgIHdoaWxlICgobmV4dCA9IHJlW3QuQ09FUkNFUlRMXS5leGVjKHZlcnNpb24pKSAmJlxuICAgICAgICAoIW1hdGNoIHx8IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoICE9PSB2ZXJzaW9uLmxlbmd0aClcbiAgICApIHtcbiAgICAgIGlmICghbWF0Y2ggfHxcbiAgICAgICAgICAgIG5leHQuaW5kZXggKyBuZXh0WzBdLmxlbmd0aCAhPT0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpIHtcbiAgICAgICAgbWF0Y2ggPSBuZXh0XG4gICAgICB9XG4gICAgICByZVt0LkNPRVJDRVJUTF0ubGFzdEluZGV4ID0gbmV4dC5pbmRleCArIG5leHRbMV0ubGVuZ3RoICsgbmV4dFsyXS5sZW5ndGhcbiAgICB9XG4gICAgLy8gbGVhdmUgaXQgaW4gYSBjbGVhbiBzdGF0ZVxuICAgIHJlW3QuQ09FUkNFUlRMXS5sYXN0SW5kZXggPSAtMVxuICB9XG5cbiAgaWYgKG1hdGNoID09PSBudWxsKVxuICAgIHJldHVybiBudWxsXG5cbiAgcmV0dXJuIHBhcnNlKGAke21hdGNoWzJdfS4ke21hdGNoWzNdIHx8ICcwJ30uJHttYXRjaFs0XSB8fCAnMCd9YCwgb3B0aW9ucylcbn1cbm1vZHVsZS5leHBvcnRzID0gY29lcmNlXG4iLCIndXNlIHN0cmljdCdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFlhbGxpc3QpIHtcbiAgWWFsbGlzdC5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKiAoKSB7XG4gICAgZm9yIChsZXQgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXI7IHdhbGtlciA9IHdhbGtlci5uZXh0KSB7XG4gICAgICB5aWVsZCB3YWxrZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xubW9kdWxlLmV4cG9ydHMgPSBZYWxsaXN0XG5cbllhbGxpc3QuTm9kZSA9IE5vZGVcbllhbGxpc3QuY3JlYXRlID0gWWFsbGlzdFxuXG5mdW5jdGlvbiBZYWxsaXN0IChsaXN0KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIShzZWxmIGluc3RhbmNlb2YgWWFsbGlzdCkpIHtcbiAgICBzZWxmID0gbmV3IFlhbGxpc3QoKVxuICB9XG5cbiAgc2VsZi50YWlsID0gbnVsbFxuICBzZWxmLmhlYWQgPSBudWxsXG4gIHNlbGYubGVuZ3RoID0gMFxuXG4gIGlmIChsaXN0ICYmIHR5cGVvZiBsaXN0LmZvckVhY2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICBsaXN0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHNlbGYucHVzaChpdGVtKVxuICAgIH0pXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHNlbGYucHVzaChhcmd1bWVudHNbaV0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlbGZcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVtb3ZlTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlLmxpc3QgIT09IHRoaXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92aW5nIG5vZGUgd2hpY2ggZG9lcyBub3QgYmVsb25nIHRvIHRoaXMgbGlzdCcpXG4gIH1cblxuICB2YXIgbmV4dCA9IG5vZGUubmV4dFxuICB2YXIgcHJldiA9IG5vZGUucHJldlxuXG4gIGlmIChuZXh0KSB7XG4gICAgbmV4dC5wcmV2ID0gcHJldlxuICB9XG5cbiAgaWYgKHByZXYpIHtcbiAgICBwcmV2Lm5leHQgPSBuZXh0XG4gIH1cblxuICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkID0gbmV4dFxuICB9XG4gIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwgPSBwcmV2XG4gIH1cblxuICBub2RlLmxpc3QubGVuZ3RoLS1cbiAgbm9kZS5uZXh0ID0gbnVsbFxuICBub2RlLnByZXYgPSBudWxsXG4gIG5vZGUubGlzdCA9IG51bGxcblxuICByZXR1cm4gbmV4dFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS51bnNoaWZ0Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlID09PSB0aGlzLmhlYWQpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChub2RlLmxpc3QpIHtcbiAgICBub2RlLmxpc3QucmVtb3ZlTm9kZShub2RlKVxuICB9XG5cbiAgdmFyIGhlYWQgPSB0aGlzLmhlYWRcbiAgbm9kZS5saXN0ID0gdGhpc1xuICBub2RlLm5leHQgPSBoZWFkXG4gIGlmIChoZWFkKSB7XG4gICAgaGVhZC5wcmV2ID0gbm9kZVxuICB9XG5cbiAgdGhpcy5oZWFkID0gbm9kZVxuICBpZiAoIXRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbCA9IG5vZGVcbiAgfVxuICB0aGlzLmxlbmd0aCsrXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnB1c2hOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IHRoaXMudGFpbCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKG5vZGUubGlzdCkge1xuICAgIG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpXG4gIH1cblxuICB2YXIgdGFpbCA9IHRoaXMudGFpbFxuICBub2RlLmxpc3QgPSB0aGlzXG4gIG5vZGUucHJldiA9IHRhaWxcbiAgaWYgKHRhaWwpIHtcbiAgICB0YWlsLm5leHQgPSBub2RlXG4gIH1cblxuICB0aGlzLnRhaWwgPSBub2RlXG4gIGlmICghdGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkID0gbm9kZVxuICB9XG4gIHRoaXMubGVuZ3RoKytcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgcHVzaCh0aGlzLCBhcmd1bWVudHNbaV0pXG4gIH1cbiAgcmV0dXJuIHRoaXMubGVuZ3RoXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHVuc2hpZnQodGhpcywgYXJndW1lbnRzW2ldKVxuICB9XG4gIHJldHVybiB0aGlzLmxlbmd0aFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy50YWlsKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgdmFyIHJlcyA9IHRoaXMudGFpbC52YWx1ZVxuICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwucHJldlxuICBpZiAodGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsLm5leHQgPSBudWxsXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5oZWFkID0gbnVsbFxuICB9XG4gIHRoaXMubGVuZ3RoLS1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICB2YXIgcmVzID0gdGhpcy5oZWFkLnZhbHVlXG4gIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0XG4gIGlmICh0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQucHJldiA9IG51bGxcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRhaWwgPSBudWxsXG4gIH1cbiAgdGhpcy5sZW5ndGgtLVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLmhlYWQsIGkgPSAwOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgaSwgdGhpcylcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLmZvckVhY2hSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy50YWlsLCBpID0gdGhpcy5sZW5ndGggLSAxOyB3YWxrZXIgIT09IG51bGw7IGktLSkge1xuICAgIGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgaSwgdGhpcylcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChuKSB7XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgbjsgaSsrKSB7XG4gICAgLy8gYWJvcnQgb3V0IG9mIHRoZSBsaXN0IGVhcmx5IGlmIHdlIGhpdCBhIGN5Y2xlXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICBpZiAoaSA9PT0gbiAmJiB3YWxrZXIgIT09IG51bGwpIHtcbiAgICByZXR1cm4gd2Fsa2VyLnZhbHVlXG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZ2V0UmV2ZXJzZSA9IGZ1bmN0aW9uIChuKSB7XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgbjsgaSsrKSB7XG4gICAgLy8gYWJvcnQgb3V0IG9mIHRoZSBsaXN0IGVhcmx5IGlmIHdlIGhpdCBhIGN5Y2xlXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuICBpZiAoaSA9PT0gbiAmJiB3YWxrZXIgIT09IG51bGwpIHtcbiAgICByZXR1cm4gd2Fsa2VyLnZhbHVlXG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgdmFyIHJlcyA9IG5ldyBZYWxsaXN0KClcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgcmVzLnB1c2goZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCB0aGlzKSlcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUubWFwUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIHZhciByZXMgPSBuZXcgWWFsbGlzdCgpXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgIHJlcy5wdXNoKGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgdGhpcykpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChmbiwgaW5pdGlhbCkge1xuICB2YXIgYWNjXG4gIHZhciB3YWxrZXIgPSB0aGlzLmhlYWRcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgYWNjID0gaW5pdGlhbFxuICB9IGVsc2UgaWYgKHRoaXMuaGVhZCkge1xuICAgIHdhbGtlciA9IHRoaXMuaGVhZC5uZXh0XG4gICAgYWNjID0gdGhpcy5oZWFkLnZhbHVlXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGxpc3Qgd2l0aCBubyBpbml0aWFsIHZhbHVlJylcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGFjYyA9IGZuKGFjYywgd2Fsa2VyLnZhbHVlLCBpKVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cblxuICByZXR1cm4gYWNjXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJlZHVjZVJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIGluaXRpYWwpIHtcbiAgdmFyIGFjY1xuICB2YXIgd2Fsa2VyID0gdGhpcy50YWlsXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIGFjYyA9IGluaXRpYWxcbiAgfSBlbHNlIGlmICh0aGlzLnRhaWwpIHtcbiAgICB3YWxrZXIgPSB0aGlzLnRhaWwucHJldlxuICAgIGFjYyA9IHRoaXMudGFpbC52YWx1ZVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBsaXN0IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpXG4gIH1cblxuICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyB3YWxrZXIgIT09IG51bGw7IGktLSkge1xuICAgIGFjYyA9IGZuKGFjYywgd2Fsa2VyLnZhbHVlLCBpKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cblxuICByZXR1cm4gYWNjXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYXJyW2ldID0gd2Fsa2VyLnZhbHVlXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICByZXR1cm4gYXJyXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnRvQXJyYXlSZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGFycltpXSA9IHdhbGtlci52YWx1ZVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgcmV0dXJuIGFyclxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICB0byA9IHRvIHx8IHRoaXMubGVuZ3RoXG4gIGlmICh0byA8IDApIHtcbiAgICB0byArPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZyb20gPSBmcm9tIHx8IDBcbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSArPSB0aGlzLmxlbmd0aFxuICB9XG4gIHZhciByZXQgPSBuZXcgWWFsbGlzdCgpXG4gIGlmICh0byA8IGZyb20gfHwgdG8gPCAwKSB7XG4gICAgcmV0dXJuIHJldFxuICB9XG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gPSAwXG4gIH1cbiAgaWYgKHRvID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0byA9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBmcm9tOyBpKyspIHtcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIGZvciAoOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IHRvOyBpKyssIHdhbGtlciA9IHdhbGtlci5uZXh0KSB7XG4gICAgcmV0LnB1c2god2Fsa2VyLnZhbHVlKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2xpY2VSZXZlcnNlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gIHRvID0gdG8gfHwgdGhpcy5sZW5ndGhcbiAgaWYgKHRvIDwgMCkge1xuICAgIHRvICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZnJvbSA9IGZyb20gfHwgMFxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgdmFyIHJldCA9IG5ldyBZYWxsaXN0KClcbiAgaWYgKHRvIDwgZnJvbSB8fCB0byA8IDApIHtcbiAgICByZXR1cm4gcmV0XG4gIH1cbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSA9IDBcbiAgfVxuICBpZiAodG8gPiB0aGlzLmxlbmd0aCkge1xuICAgIHRvID0gdGhpcy5sZW5ndGhcbiAgfVxuICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGgsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPiB0bzsgaS0tKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuICBmb3IgKDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPiBmcm9tOyBpLS0sIHdhbGtlciA9IHdhbGtlci5wcmV2KSB7XG4gICAgcmV0LnB1c2god2Fsa2VyLnZhbHVlKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc3BsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBkZWxldGVDb3VudCwgLi4ubm9kZXMpIHtcbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICBzdGFydCA9IHRoaXMubGVuZ3RoIC0gMVxuICB9XG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IHRoaXMubGVuZ3RoICsgc3RhcnQ7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IHN0YXJ0OyBpKyspIHtcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG5cbiAgdmFyIHJldCA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyB3YWxrZXIgJiYgaSA8IGRlbGV0ZUNvdW50OyBpKyspIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpXG4gICAgd2Fsa2VyID0gdGhpcy5yZW1vdmVOb2RlKHdhbGtlcilcbiAgfVxuICBpZiAod2Fsa2VyID09PSBudWxsKSB7XG4gICAgd2Fsa2VyID0gdGhpcy50YWlsXG4gIH1cblxuICBpZiAod2Fsa2VyICE9PSB0aGlzLmhlYWQgJiYgd2Fsa2VyICE9PSB0aGlzLnRhaWwpIHtcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHdhbGtlciA9IGluc2VydCh0aGlzLCB3YWxrZXIsIG5vZGVzW2ldKVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoZWFkID0gdGhpcy5oZWFkXG4gIHZhciB0YWlsID0gdGhpcy50YWlsXG4gIGZvciAodmFyIHdhbGtlciA9IGhlYWQ7IHdhbGtlciAhPT0gbnVsbDsgd2Fsa2VyID0gd2Fsa2VyLnByZXYpIHtcbiAgICB2YXIgcCA9IHdhbGtlci5wcmV2XG4gICAgd2Fsa2VyLnByZXYgPSB3YWxrZXIubmV4dFxuICAgIHdhbGtlci5uZXh0ID0gcFxuICB9XG4gIHRoaXMuaGVhZCA9IHRhaWxcbiAgdGhpcy50YWlsID0gaGVhZFxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBpbnNlcnQgKHNlbGYsIG5vZGUsIHZhbHVlKSB7XG4gIHZhciBpbnNlcnRlZCA9IG5vZGUgPT09IHNlbGYuaGVhZCA/XG4gICAgbmV3IE5vZGUodmFsdWUsIG51bGwsIG5vZGUsIHNlbGYpIDpcbiAgICBuZXcgTm9kZSh2YWx1ZSwgbm9kZSwgbm9kZS5uZXh0LCBzZWxmKVxuXG4gIGlmIChpbnNlcnRlZC5uZXh0ID09PSBudWxsKSB7XG4gICAgc2VsZi50YWlsID0gaW5zZXJ0ZWRcbiAgfVxuICBpZiAoaW5zZXJ0ZWQucHJldiA9PT0gbnVsbCkge1xuICAgIHNlbGYuaGVhZCA9IGluc2VydGVkXG4gIH1cblxuICBzZWxmLmxlbmd0aCsrXG5cbiAgcmV0dXJuIGluc2VydGVkXG59XG5cbmZ1bmN0aW9uIHB1c2ggKHNlbGYsIGl0ZW0pIHtcbiAgc2VsZi50YWlsID0gbmV3IE5vZGUoaXRlbSwgc2VsZi50YWlsLCBudWxsLCBzZWxmKVxuICBpZiAoIXNlbGYuaGVhZCkge1xuICAgIHNlbGYuaGVhZCA9IHNlbGYudGFpbFxuICB9XG4gIHNlbGYubGVuZ3RoKytcbn1cblxuZnVuY3Rpb24gdW5zaGlmdCAoc2VsZiwgaXRlbSkge1xuICBzZWxmLmhlYWQgPSBuZXcgTm9kZShpdGVtLCBudWxsLCBzZWxmLmhlYWQsIHNlbGYpXG4gIGlmICghc2VsZi50YWlsKSB7XG4gICAgc2VsZi50YWlsID0gc2VsZi5oZWFkXG4gIH1cbiAgc2VsZi5sZW5ndGgrK1xufVxuXG5mdW5jdGlvbiBOb2RlICh2YWx1ZSwgcHJldiwgbmV4dCwgbGlzdCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTm9kZSkpIHtcbiAgICByZXR1cm4gbmV3IE5vZGUodmFsdWUsIHByZXYsIG5leHQsIGxpc3QpXG4gIH1cblxuICB0aGlzLmxpc3QgPSBsaXN0XG4gIHRoaXMudmFsdWUgPSB2YWx1ZVxuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5uZXh0ID0gdGhpc1xuICAgIHRoaXMucHJldiA9IHByZXZcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnByZXYgPSBudWxsXG4gIH1cblxuICBpZiAobmV4dCkge1xuICAgIG5leHQucHJldiA9IHRoaXNcbiAgICB0aGlzLm5leHQgPSBuZXh0XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5uZXh0ID0gbnVsbFxuICB9XG59XG5cbnRyeSB7XG4gIC8vIGFkZCBpZiBzdXBwb3J0IGZvciBTeW1ib2wuaXRlcmF0b3IgaXMgcHJlc2VudFxuICByZXF1aXJlKCcuL2l0ZXJhdG9yLmpzJykoWWFsbGlzdClcbn0gY2F0Y2ggKGVyKSB7fVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8vIEEgbGlua2VkIGxpc3QgdG8ga2VlcCB0cmFjayBvZiByZWNlbnRseS11c2VkLW5lc3NcbmNvbnN0IFlhbGxpc3QgPSByZXF1aXJlKCd5YWxsaXN0JylcblxuY29uc3QgTUFYID0gU3ltYm9sKCdtYXgnKVxuY29uc3QgTEVOR1RIID0gU3ltYm9sKCdsZW5ndGgnKVxuY29uc3QgTEVOR1RIX0NBTENVTEFUT1IgPSBTeW1ib2woJ2xlbmd0aENhbGN1bGF0b3InKVxuY29uc3QgQUxMT1dfU1RBTEUgPSBTeW1ib2woJ2FsbG93U3RhbGUnKVxuY29uc3QgTUFYX0FHRSA9IFN5bWJvbCgnbWF4QWdlJylcbmNvbnN0IERJU1BPU0UgPSBTeW1ib2woJ2Rpc3Bvc2UnKVxuY29uc3QgTk9fRElTUE9TRV9PTl9TRVQgPSBTeW1ib2woJ25vRGlzcG9zZU9uU2V0JylcbmNvbnN0IExSVV9MSVNUID0gU3ltYm9sKCdscnVMaXN0JylcbmNvbnN0IENBQ0hFID0gU3ltYm9sKCdjYWNoZScpXG5jb25zdCBVUERBVEVfQUdFX09OX0dFVCA9IFN5bWJvbCgndXBkYXRlQWdlT25HZXQnKVxuXG5jb25zdCBuYWl2ZUxlbmd0aCA9ICgpID0+IDFcblxuLy8gbHJ1TGlzdCBpcyBhIHlhbGxpc3Qgd2hlcmUgdGhlIGhlYWQgaXMgdGhlIHlvdW5nZXN0XG4vLyBpdGVtLCBhbmQgdGhlIHRhaWwgaXMgdGhlIG9sZGVzdC4gIHRoZSBsaXN0IGNvbnRhaW5zIHRoZSBIaXRcbi8vIG9iamVjdHMgYXMgdGhlIGVudHJpZXMuXG4vLyBFYWNoIEhpdCBvYmplY3QgaGFzIGEgcmVmZXJlbmNlIHRvIGl0cyBZYWxsaXN0Lk5vZGUuICBUaGlzXG4vLyBuZXZlciBjaGFuZ2VzLlxuLy9cbi8vIGNhY2hlIGlzIGEgTWFwIChvciBQc2V1ZG9NYXApIHRoYXQgbWF0Y2hlcyB0aGUga2V5cyB0b1xuLy8gdGhlIFlhbGxpc3QuTm9kZSBvYmplY3QuXG5jbGFzcyBMUlVDYWNoZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJylcbiAgICAgIG9wdGlvbnMgPSB7IG1heDogb3B0aW9ucyB9XG5cbiAgICBpZiAoIW9wdGlvbnMpXG4gICAgICBvcHRpb25zID0ge31cblxuICAgIGlmIChvcHRpb25zLm1heCAmJiAodHlwZW9mIG9wdGlvbnMubWF4ICE9PSAnbnVtYmVyJyB8fCBvcHRpb25zLm1heCA8IDApKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJylcbiAgICAvLyBLaW5kIG9mIHdlaXJkIHRvIGhhdmUgYSBkZWZhdWx0IG1heCBvZiBJbmZpbml0eSwgYnV0IG9oIHdlbGwuXG4gICAgY29uc3QgbWF4ID0gdGhpc1tNQVhdID0gb3B0aW9ucy5tYXggfHwgSW5maW5pdHlcblxuICAgIGNvbnN0IGxjID0gb3B0aW9ucy5sZW5ndGggfHwgbmFpdmVMZW5ndGhcbiAgICB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSA9ICh0eXBlb2YgbGMgIT09ICdmdW5jdGlvbicpID8gbmFpdmVMZW5ndGggOiBsY1xuICAgIHRoaXNbQUxMT1dfU1RBTEVdID0gb3B0aW9ucy5zdGFsZSB8fCBmYWxzZVxuICAgIGlmIChvcHRpb25zLm1heEFnZSAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhBZ2UgIT09ICdudW1iZXInKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4QWdlIG11c3QgYmUgYSBudW1iZXInKVxuICAgIHRoaXNbTUFYX0FHRV0gPSBvcHRpb25zLm1heEFnZSB8fCAwXG4gICAgdGhpc1tESVNQT1NFXSA9IG9wdGlvbnMuZGlzcG9zZVxuICAgIHRoaXNbTk9fRElTUE9TRV9PTl9TRVRdID0gb3B0aW9ucy5ub0Rpc3Bvc2VPblNldCB8fCBmYWxzZVxuICAgIHRoaXNbVVBEQVRFX0FHRV9PTl9HRVRdID0gb3B0aW9ucy51cGRhdGVBZ2VPbkdldCB8fCBmYWxzZVxuICAgIHRoaXMucmVzZXQoKVxuICB9XG5cbiAgLy8gcmVzaXplIHRoZSBjYWNoZSB3aGVuIHRoZSBtYXggY2hhbmdlcy5cbiAgc2V0IG1heCAobUwpIHtcbiAgICBpZiAodHlwZW9mIG1MICE9PSAnbnVtYmVyJyB8fCBtTCA8IDApXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXggbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKVxuXG4gICAgdGhpc1tNQVhdID0gbUwgfHwgSW5maW5pdHlcbiAgICB0cmltKHRoaXMpXG4gIH1cbiAgZ2V0IG1heCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTUFYXVxuICB9XG5cbiAgc2V0IGFsbG93U3RhbGUgKGFsbG93U3RhbGUpIHtcbiAgICB0aGlzW0FMTE9XX1NUQUxFXSA9ICEhYWxsb3dTdGFsZVxuICB9XG4gIGdldCBhbGxvd1N0YWxlICgpIHtcbiAgICByZXR1cm4gdGhpc1tBTExPV19TVEFMRV1cbiAgfVxuXG4gIHNldCBtYXhBZ2UgKG1BKSB7XG4gICAgaWYgKHR5cGVvZiBtQSAhPT0gJ251bWJlcicpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhBZ2UgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKVxuXG4gICAgdGhpc1tNQVhfQUdFXSA9IG1BXG4gICAgdHJpbSh0aGlzKVxuICB9XG4gIGdldCBtYXhBZ2UgKCkge1xuICAgIHJldHVybiB0aGlzW01BWF9BR0VdXG4gIH1cblxuICAvLyByZXNpemUgdGhlIGNhY2hlIHdoZW4gdGhlIGxlbmd0aENhbGN1bGF0b3IgY2hhbmdlcy5cbiAgc2V0IGxlbmd0aENhbGN1bGF0b3IgKGxDKSB7XG4gICAgaWYgKHR5cGVvZiBsQyAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIGxDID0gbmFpdmVMZW5ndGhcblxuICAgIGlmIChsQyAhPT0gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0pIHtcbiAgICAgIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdID0gbENcbiAgICAgIHRoaXNbTEVOR1RIXSA9IDBcbiAgICAgIHRoaXNbTFJVX0xJU1RdLmZvckVhY2goaGl0ID0+IHtcbiAgICAgICAgaGl0Lmxlbmd0aCA9IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKGhpdC52YWx1ZSwgaGl0LmtleSlcbiAgICAgICAgdGhpc1tMRU5HVEhdICs9IGhpdC5sZW5ndGhcbiAgICAgIH0pXG4gICAgfVxuICAgIHRyaW0odGhpcylcbiAgfVxuICBnZXQgbGVuZ3RoQ2FsY3VsYXRvciAoKSB7IHJldHVybiB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSB9XG5cbiAgZ2V0IGxlbmd0aCAoKSB7IHJldHVybiB0aGlzW0xFTkdUSF0gfVxuICBnZXQgaXRlbUNvdW50ICgpIHsgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLmxlbmd0aCB9XG5cbiAgcmZvckVhY2ggKGZuLCB0aGlzcCkge1xuICAgIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICAgIGZvciAobGV0IHdhbGtlciA9IHRoaXNbTFJVX0xJU1RdLnRhaWw7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICAgIGNvbnN0IHByZXYgPSB3YWxrZXIucHJldlxuICAgICAgZm9yRWFjaFN0ZXAodGhpcywgZm4sIHdhbGtlciwgdGhpc3ApXG4gICAgICB3YWxrZXIgPSBwcmV2XG4gICAgfVxuICB9XG5cbiAgZm9yRWFjaCAoZm4sIHRoaXNwKSB7XG4gICAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gICAgZm9yIChsZXQgd2Fsa2VyID0gdGhpc1tMUlVfTElTVF0uaGVhZDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgICAgY29uc3QgbmV4dCA9IHdhbGtlci5uZXh0XG4gICAgICBmb3JFYWNoU3RlcCh0aGlzLCBmbiwgd2Fsa2VyLCB0aGlzcClcbiAgICAgIHdhbGtlciA9IG5leHRcbiAgICB9XG4gIH1cblxuICBrZXlzICgpIHtcbiAgICByZXR1cm4gdGhpc1tMUlVfTElTVF0udG9BcnJheSgpLm1hcChrID0+IGsua2V5KVxuICB9XG5cbiAgdmFsdWVzICgpIHtcbiAgICByZXR1cm4gdGhpc1tMUlVfTElTVF0udG9BcnJheSgpLm1hcChrID0+IGsudmFsdWUpXG4gIH1cblxuICByZXNldCAoKSB7XG4gICAgaWYgKHRoaXNbRElTUE9TRV0gJiZcbiAgICAgICAgdGhpc1tMUlVfTElTVF0gJiZcbiAgICAgICAgdGhpc1tMUlVfTElTVF0ubGVuZ3RoKSB7XG4gICAgICB0aGlzW0xSVV9MSVNUXS5mb3JFYWNoKGhpdCA9PiB0aGlzW0RJU1BPU0VdKGhpdC5rZXksIGhpdC52YWx1ZSkpXG4gICAgfVxuXG4gICAgdGhpc1tDQUNIRV0gPSBuZXcgTWFwKCkgLy8gaGFzaCBvZiBpdGVtcyBieSBrZXlcbiAgICB0aGlzW0xSVV9MSVNUXSA9IG5ldyBZYWxsaXN0KCkgLy8gbGlzdCBvZiBpdGVtcyBpbiBvcmRlciBvZiB1c2UgcmVjZW5jeVxuICAgIHRoaXNbTEVOR1RIXSA9IDAgLy8gbGVuZ3RoIG9mIGl0ZW1zIGluIHRoZSBsaXN0XG4gIH1cblxuICBkdW1wICgpIHtcbiAgICByZXR1cm4gdGhpc1tMUlVfTElTVF0ubWFwKGhpdCA9PlxuICAgICAgaXNTdGFsZSh0aGlzLCBoaXQpID8gZmFsc2UgOiB7XG4gICAgICAgIGs6IGhpdC5rZXksXG4gICAgICAgIHY6IGhpdC52YWx1ZSxcbiAgICAgICAgZTogaGl0Lm5vdyArIChoaXQubWF4QWdlIHx8IDApXG4gICAgICB9KS50b0FycmF5KCkuZmlsdGVyKGggPT4gaClcbiAgfVxuXG4gIGR1bXBMcnUgKCkge1xuICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXVxuICB9XG5cbiAgc2V0IChrZXksIHZhbHVlLCBtYXhBZ2UpIHtcbiAgICBtYXhBZ2UgPSBtYXhBZ2UgfHwgdGhpc1tNQVhfQUdFXVxuXG4gICAgaWYgKG1heEFnZSAmJiB0eXBlb2YgbWF4QWdlICE9PSAnbnVtYmVyJylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heEFnZSBtdXN0IGJlIGEgbnVtYmVyJylcblxuICAgIGNvbnN0IG5vdyA9IG1heEFnZSA/IERhdGUubm93KCkgOiAwXG4gICAgY29uc3QgbGVuID0gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0odmFsdWUsIGtleSlcblxuICAgIGlmICh0aGlzW0NBQ0hFXS5oYXMoa2V5KSkge1xuICAgICAgaWYgKGxlbiA+IHRoaXNbTUFYXSkge1xuICAgICAgICBkZWwodGhpcywgdGhpc1tDQUNIRV0uZ2V0KGtleSkpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBub2RlID0gdGhpc1tDQUNIRV0uZ2V0KGtleSlcbiAgICAgIGNvbnN0IGl0ZW0gPSBub2RlLnZhbHVlXG5cbiAgICAgIC8vIGRpc3Bvc2Ugb2YgdGhlIG9sZCBvbmUgYmVmb3JlIG92ZXJ3cml0aW5nXG4gICAgICAvLyBzcGxpdCBvdXQgaW50byAyIGlmcyBmb3IgYmV0dGVyIGNvdmVyYWdlIHRyYWNraW5nXG4gICAgICBpZiAodGhpc1tESVNQT1NFXSkge1xuICAgICAgICBpZiAoIXRoaXNbTk9fRElTUE9TRV9PTl9TRVRdKVxuICAgICAgICAgIHRoaXNbRElTUE9TRV0oa2V5LCBpdGVtLnZhbHVlKVxuICAgICAgfVxuXG4gICAgICBpdGVtLm5vdyA9IG5vd1xuICAgICAgaXRlbS5tYXhBZ2UgPSBtYXhBZ2VcbiAgICAgIGl0ZW0udmFsdWUgPSB2YWx1ZVxuICAgICAgdGhpc1tMRU5HVEhdICs9IGxlbiAtIGl0ZW0ubGVuZ3RoXG4gICAgICBpdGVtLmxlbmd0aCA9IGxlblxuICAgICAgdGhpcy5nZXQoa2V5KVxuICAgICAgdHJpbSh0aGlzKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBjb25zdCBoaXQgPSBuZXcgRW50cnkoa2V5LCB2YWx1ZSwgbGVuLCBub3csIG1heEFnZSlcblxuICAgIC8vIG92ZXJzaXplZCBvYmplY3RzIGZhbGwgb3V0IG9mIGNhY2hlIGF1dG9tYXRpY2FsbHkuXG4gICAgaWYgKGhpdC5sZW5ndGggPiB0aGlzW01BWF0pIHtcbiAgICAgIGlmICh0aGlzW0RJU1BPU0VdKVxuICAgICAgICB0aGlzW0RJU1BPU0VdKGtleSwgdmFsdWUpXG5cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHRoaXNbTEVOR1RIXSArPSBoaXQubGVuZ3RoXG4gICAgdGhpc1tMUlVfTElTVF0udW5zaGlmdChoaXQpXG4gICAgdGhpc1tDQUNIRV0uc2V0KGtleSwgdGhpc1tMUlVfTElTVF0uaGVhZClcbiAgICB0cmltKHRoaXMpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGhhcyAoa2V5KSB7XG4gICAgaWYgKCF0aGlzW0NBQ0hFXS5oYXMoa2V5KSkgcmV0dXJuIGZhbHNlXG4gICAgY29uc3QgaGl0ID0gdGhpc1tDQUNIRV0uZ2V0KGtleSkudmFsdWVcbiAgICByZXR1cm4gIWlzU3RhbGUodGhpcywgaGl0KVxuICB9XG5cbiAgZ2V0IChrZXkpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgdHJ1ZSlcbiAgfVxuXG4gIHBlZWsgKGtleSkge1xuICAgIHJldHVybiBnZXQodGhpcywga2V5LCBmYWxzZSlcbiAgfVxuXG4gIHBvcCAoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXNbTFJVX0xJU1RdLnRhaWxcbiAgICBpZiAoIW5vZGUpXG4gICAgICByZXR1cm4gbnVsbFxuXG4gICAgZGVsKHRoaXMsIG5vZGUpXG4gICAgcmV0dXJuIG5vZGUudmFsdWVcbiAgfVxuXG4gIGRlbCAoa2V5KSB7XG4gICAgZGVsKHRoaXMsIHRoaXNbQ0FDSEVdLmdldChrZXkpKVxuICB9XG5cbiAgbG9hZCAoYXJyKSB7XG4gICAgLy8gcmVzZXQgdGhlIGNhY2hlXG4gICAgdGhpcy5yZXNldCgpXG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpXG4gICAgLy8gQSBwcmV2aW91cyBzZXJpYWxpemVkIGNhY2hlIGhhcyB0aGUgbW9zdCByZWNlbnQgaXRlbXMgZmlyc3RcbiAgICBmb3IgKGxldCBsID0gYXJyLmxlbmd0aCAtIDE7IGwgPj0gMDsgbC0tKSB7XG4gICAgICBjb25zdCBoaXQgPSBhcnJbbF1cbiAgICAgIGNvbnN0IGV4cGlyZXNBdCA9IGhpdC5lIHx8IDBcbiAgICAgIGlmIChleHBpcmVzQXQgPT09IDApXG4gICAgICAgIC8vIHRoZSBpdGVtIHdhcyBjcmVhdGVkIHdpdGhvdXQgZXhwaXJhdGlvbiBpbiBhIG5vbiBhZ2VkIGNhY2hlXG4gICAgICAgIHRoaXMuc2V0KGhpdC5rLCBoaXQudilcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBtYXhBZ2UgPSBleHBpcmVzQXQgLSBub3dcbiAgICAgICAgLy8gZG9udCBhZGQgYWxyZWFkeSBleHBpcmVkIGl0ZW1zXG4gICAgICAgIGlmIChtYXhBZ2UgPiAwKSB7XG4gICAgICAgICAgdGhpcy5zZXQoaGl0LmssIGhpdC52LCBtYXhBZ2UpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcnVuZSAoKSB7XG4gICAgdGhpc1tDQUNIRV0uZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gZ2V0KHRoaXMsIGtleSwgZmFsc2UpKVxuICB9XG59XG5cbmNvbnN0IGdldCA9IChzZWxmLCBrZXksIGRvVXNlKSA9PiB7XG4gIGNvbnN0IG5vZGUgPSBzZWxmW0NBQ0hFXS5nZXQoa2V5KVxuICBpZiAobm9kZSkge1xuICAgIGNvbnN0IGhpdCA9IG5vZGUudmFsdWVcbiAgICBpZiAoaXNTdGFsZShzZWxmLCBoaXQpKSB7XG4gICAgICBkZWwoc2VsZiwgbm9kZSlcbiAgICAgIGlmICghc2VsZltBTExPV19TVEFMRV0pXG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRvVXNlKSB7XG4gICAgICAgIGlmIChzZWxmW1VQREFURV9BR0VfT05fR0VUXSlcbiAgICAgICAgICBub2RlLnZhbHVlLm5vdyA9IERhdGUubm93KClcbiAgICAgICAgc2VsZltMUlVfTElTVF0udW5zaGlmdE5vZGUobm9kZSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhpdC52YWx1ZVxuICB9XG59XG5cbmNvbnN0IGlzU3RhbGUgPSAoc2VsZiwgaGl0KSA9PiB7XG4gIGlmICghaGl0IHx8ICghaGl0Lm1heEFnZSAmJiAhc2VsZltNQVhfQUdFXSkpXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSBoaXQubm93XG4gIHJldHVybiBoaXQubWF4QWdlID8gZGlmZiA+IGhpdC5tYXhBZ2VcbiAgICA6IHNlbGZbTUFYX0FHRV0gJiYgKGRpZmYgPiBzZWxmW01BWF9BR0VdKVxufVxuXG5jb25zdCB0cmltID0gc2VsZiA9PiB7XG4gIGlmIChzZWxmW0xFTkdUSF0gPiBzZWxmW01BWF0pIHtcbiAgICBmb3IgKGxldCB3YWxrZXIgPSBzZWxmW0xSVV9MSVNUXS50YWlsO1xuICAgICAgc2VsZltMRU5HVEhdID4gc2VsZltNQVhdICYmIHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICAgIC8vIFdlIGtub3cgdGhhdCB3ZSdyZSBhYm91dCB0byBkZWxldGUgdGhpcyBvbmUsIGFuZCBhbHNvXG4gICAgICAvLyB3aGF0IHRoZSBuZXh0IGxlYXN0IHJlY2VudGx5IHVzZWQga2V5IHdpbGwgYmUsIHNvIGp1c3RcbiAgICAgIC8vIGdvIGFoZWFkIGFuZCBzZXQgaXQgbm93LlxuICAgICAgY29uc3QgcHJldiA9IHdhbGtlci5wcmV2XG4gICAgICBkZWwoc2VsZiwgd2Fsa2VyKVxuICAgICAgd2Fsa2VyID0gcHJldlxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBkZWwgPSAoc2VsZiwgbm9kZSkgPT4ge1xuICBpZiAobm9kZSkge1xuICAgIGNvbnN0IGhpdCA9IG5vZGUudmFsdWVcbiAgICBpZiAoc2VsZltESVNQT1NFXSlcbiAgICAgIHNlbGZbRElTUE9TRV0oaGl0LmtleSwgaGl0LnZhbHVlKVxuXG4gICAgc2VsZltMRU5HVEhdIC09IGhpdC5sZW5ndGhcbiAgICBzZWxmW0NBQ0hFXS5kZWxldGUoaGl0LmtleSlcbiAgICBzZWxmW0xSVV9MSVNUXS5yZW1vdmVOb2RlKG5vZGUpXG4gIH1cbn1cblxuY2xhc3MgRW50cnkge1xuICBjb25zdHJ1Y3RvciAoa2V5LCB2YWx1ZSwgbGVuZ3RoLCBub3csIG1heEFnZSkge1xuICAgIHRoaXMua2V5ID0ga2V5XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGhcbiAgICB0aGlzLm5vdyA9IG5vd1xuICAgIHRoaXMubWF4QWdlID0gbWF4QWdlIHx8IDBcbiAgfVxufVxuXG5jb25zdCBmb3JFYWNoU3RlcCA9IChzZWxmLCBmbiwgbm9kZSwgdGhpc3ApID0+IHtcbiAgbGV0IGhpdCA9IG5vZGUudmFsdWVcbiAgaWYgKGlzU3RhbGUoc2VsZiwgaGl0KSkge1xuICAgIGRlbChzZWxmLCBub2RlKVxuICAgIGlmICghc2VsZltBTExPV19TVEFMRV0pXG4gICAgICBoaXQgPSB1bmRlZmluZWRcbiAgfVxuICBpZiAoaGl0KVxuICAgIGZuLmNhbGwodGhpc3AsIGhpdC52YWx1ZSwgaGl0LmtleSwgc2VsZilcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMUlVDYWNoZVxuIiwiLy8gaG9pc3RlZCBjbGFzcyBmb3IgY3ljbGljIGRlcGVuZGVuY3lcbmNsYXNzIFJhbmdlIHtcbiAgY29uc3RydWN0b3IgKHJhbmdlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgaWYgKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpIHtcbiAgICAgIGlmIChcbiAgICAgICAgcmFuZ2UubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSAmJlxuICAgICAgICByYW5nZS5pbmNsdWRlUHJlcmVsZWFzZSA9PT0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLnJhdywgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgICAvLyBqdXN0IHB1dCBpdCBpbiB0aGUgc2V0IGFuZCByZXR1cm5cbiAgICAgIHRoaXMucmF3ID0gcmFuZ2UudmFsdWVcbiAgICAgIHRoaXMuc2V0ID0gW1tyYW5nZV1dXG4gICAgICB0aGlzLmZvcm1hdCgpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG4gICAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuXG4gICAgLy8gRmlyc3QsIHNwbGl0IGJhc2VkIG9uIGJvb2xlYW4gb3IgfHxcbiAgICB0aGlzLnJhdyA9IHJhbmdlXG4gICAgdGhpcy5zZXQgPSByYW5nZVxuICAgICAgLnNwbGl0KC9cXHMqXFx8XFx8XFxzKi8pXG4gICAgICAvLyBtYXAgdGhlIHJhbmdlIHRvIGEgMmQgYXJyYXkgb2YgY29tcGFyYXRvcnNcbiAgICAgIC5tYXAocmFuZ2UgPT4gdGhpcy5wYXJzZVJhbmdlKHJhbmdlLnRyaW0oKSkpXG4gICAgICAvLyB0aHJvdyBvdXQgYW55IGNvbXBhcmF0b3IgbGlzdHMgdGhhdCBhcmUgZW1wdHlcbiAgICAgIC8vIHRoaXMgZ2VuZXJhbGx5IG1lYW5zIHRoYXQgaXQgd2FzIG5vdCBhIHZhbGlkIHJhbmdlLCB3aGljaCBpcyBhbGxvd2VkXG4gICAgICAvLyBpbiBsb29zZSBtb2RlLCBidXQgd2lsbCBzdGlsbCB0aHJvdyBpZiB0aGUgV0hPTEUgcmFuZ2UgaXMgaW52YWxpZC5cbiAgICAgIC5maWx0ZXIoYyA9PiBjLmxlbmd0aClcblxuICAgIGlmICghdGhpcy5zZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFNlbVZlciBSYW5nZTogJHtyYW5nZX1gKVxuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmUgYW55IHRoYXQgYXJlIG5vdCB0aGUgbnVsbCBzZXQsIHRocm93IG91dCBudWxsIHNldHMuXG4gICAgaWYgKHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIGtlZXAgdGhlIGZpcnN0IG9uZSwgaW4gY2FzZSB0aGV5J3JlIGFsbCBudWxsIHNldHNcbiAgICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5zZXRbMF1cbiAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXQuZmlsdGVyKGMgPT4gIWlzTnVsbFNldChjWzBdKSlcbiAgICAgIGlmICh0aGlzLnNldC5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMuc2V0ID0gW2ZpcnN0XVxuICAgICAgZWxzZSBpZiAodGhpcy5zZXQubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGFueSB0aGF0IGFyZSAqLCB0aGVuIHRoZSByYW5nZSBpcyBqdXN0ICpcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHRoaXMuc2V0KSB7XG4gICAgICAgICAgaWYgKGMubGVuZ3RoID09PSAxICYmIGlzQW55KGNbMF0pKSB7XG4gICAgICAgICAgICB0aGlzLnNldCA9IFtjXVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZvcm1hdCgpXG4gIH1cblxuICBmb3JtYXQgKCkge1xuICAgIHRoaXMucmFuZ2UgPSB0aGlzLnNldFxuICAgICAgLm1hcCgoY29tcHMpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbXBzLmpvaW4oJyAnKS50cmltKClcbiAgICAgIH0pXG4gICAgICAuam9pbignfHwnKVxuICAgICAgLnRyaW0oKVxuICAgIHJldHVybiB0aGlzLnJhbmdlXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2VcbiAgfVxuXG4gIHBhcnNlUmFuZ2UgKHJhbmdlKSB7XG4gICAgcmFuZ2UgPSByYW5nZS50cmltKClcblxuICAgIC8vIG1lbW9pemUgcmFuZ2UgcGFyc2luZyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgLy8gdGhpcyBpcyBhIHZlcnkgaG90IHBhdGgsIGFuZCBmdWxseSBkZXRlcm1pbmlzdGljLlxuICAgIGNvbnN0IG1lbW9PcHRzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zKS5qb2luKCcsJylcbiAgICBjb25zdCBtZW1vS2V5ID0gYHBhcnNlUmFuZ2U6JHttZW1vT3B0c306JHtyYW5nZX1gXG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KG1lbW9LZXkpXG4gICAgaWYgKGNhY2hlZClcbiAgICAgIHJldHVybiBjYWNoZWRcblxuICAgIGNvbnN0IGxvb3NlID0gdGhpcy5vcHRpb25zLmxvb3NlXG4gICAgLy8gYDEuMi4zIC0gMS4yLjRgID0+IGA+PTEuMi4zIDw9MS4yLjRgXG4gICAgY29uc3QgaHIgPSBsb29zZSA/IHJlW3QuSFlQSEVOUkFOR0VMT09TRV0gOiByZVt0LkhZUEhFTlJBTkdFXVxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShociwgaHlwaGVuUmVwbGFjZSh0aGlzLm9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpKVxuICAgIGRlYnVnKCdoeXBoZW4gcmVwbGFjZScsIHJhbmdlKVxuICAgIC8vIGA+IDEuMi4zIDwgMS4yLjVgID0+IGA+MS4yLjMgPDEuMi41YFxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LkNPTVBBUkFUT1JUUklNXSwgY29tcGFyYXRvclRyaW1SZXBsYWNlKVxuICAgIGRlYnVnKCdjb21wYXJhdG9yIHRyaW0nLCByYW5nZSwgcmVbdC5DT01QQVJBVE9SVFJJTV0pXG5cbiAgICAvLyBgfiAxLjIuM2AgPT4gYH4xLjIuM2BcbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5USUxERVRSSU1dLCB0aWxkZVRyaW1SZXBsYWNlKVxuXG4gICAgLy8gYF4gMS4yLjNgID0+IGBeMS4yLjNgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuQ0FSRVRUUklNXSwgY2FyZXRUcmltUmVwbGFjZSlcblxuICAgIC8vIG5vcm1hbGl6ZSBzcGFjZXNcbiAgICByYW5nZSA9IHJhbmdlLnNwbGl0KC9cXHMrLykuam9pbignICcpXG5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSB0cmltbWVkIGFuZFxuICAgIC8vIHJlYWR5IHRvIGJlIHNwbGl0IGludG8gY29tcGFyYXRvcnMuXG5cbiAgICBjb25zdCBjb21wUmUgPSBsb29zZSA/IHJlW3QuQ09NUEFSQVRPUkxPT1NFXSA6IHJlW3QuQ09NUEFSQVRPUl1cbiAgICBjb25zdCByYW5nZUxpc3QgPSByYW5nZVxuICAgICAgLnNwbGl0KCcgJylcbiAgICAgIC5tYXAoY29tcCA9PiBwYXJzZUNvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKSlcbiAgICAgIC5qb2luKCcgJylcbiAgICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgICAvLyA+PTAuMC4wIGlzIGVxdWl2YWxlbnQgdG8gKlxuICAgICAgLm1hcChjb21wID0+IHJlcGxhY2VHVEUwKGNvbXAsIHRoaXMub3B0aW9ucykpXG4gICAgICAvLyBpbiBsb29zZSBtb2RlLCB0aHJvdyBvdXQgYW55IHRoYXQgYXJlIG5vdCB2YWxpZCBjb21wYXJhdG9yc1xuICAgICAgLmZpbHRlcih0aGlzLm9wdGlvbnMubG9vc2UgPyBjb21wID0+ICEhY29tcC5tYXRjaChjb21wUmUpIDogKCkgPT4gdHJ1ZSlcbiAgICAgIC5tYXAoY29tcCA9PiBuZXcgQ29tcGFyYXRvcihjb21wLCB0aGlzLm9wdGlvbnMpKVxuXG4gICAgLy8gaWYgYW55IGNvbXBhcmF0b3JzIGFyZSB0aGUgbnVsbCBzZXQsIHRoZW4gcmVwbGFjZSB3aXRoIEpVU1QgbnVsbCBzZXRcbiAgICAvLyBpZiBtb3JlIHRoYW4gb25lIGNvbXBhcmF0b3IsIHJlbW92ZSBhbnkgKiBjb21wYXJhdG9yc1xuICAgIC8vIGFsc28sIGRvbid0IGluY2x1ZGUgdGhlIHNhbWUgY29tcGFyYXRvciBtb3JlIHRoYW4gb25jZVxuICAgIGNvbnN0IGwgPSByYW5nZUxpc3QubGVuZ3RoXG4gICAgY29uc3QgcmFuZ2VNYXAgPSBuZXcgTWFwKClcbiAgICBmb3IgKGNvbnN0IGNvbXAgb2YgcmFuZ2VMaXN0KSB7XG4gICAgICBpZiAoaXNOdWxsU2V0KGNvbXApKVxuICAgICAgICByZXR1cm4gW2NvbXBdXG4gICAgICByYW5nZU1hcC5zZXQoY29tcC52YWx1ZSwgY29tcClcbiAgICB9XG4gICAgaWYgKHJhbmdlTWFwLnNpemUgPiAxICYmIHJhbmdlTWFwLmhhcygnJykpXG4gICAgICByYW5nZU1hcC5kZWxldGUoJycpXG5cbiAgICBjb25zdCByZXN1bHQgPSBbLi4ucmFuZ2VNYXAudmFsdWVzKCldXG4gICAgY2FjaGUuc2V0KG1lbW9LZXksIHJlc3VsdClcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBpbnRlcnNlY3RzIChyYW5nZSwgb3B0aW9ucykge1xuICAgIGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIFJhbmdlIGlzIHJlcXVpcmVkJylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXQuc29tZSgodGhpc0NvbXBhcmF0b3JzKSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBpc1NhdGlzZmlhYmxlKHRoaXNDb21wYXJhdG9ycywgb3B0aW9ucykgJiZcbiAgICAgICAgcmFuZ2Uuc2V0LnNvbWUoKHJhbmdlQ29tcGFyYXRvcnMpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXNTYXRpc2ZpYWJsZShyYW5nZUNvbXBhcmF0b3JzLCBvcHRpb25zKSAmJlxuICAgICAgICAgICAgdGhpc0NvbXBhcmF0b3JzLmV2ZXJ5KCh0aGlzQ29tcGFyYXRvcikgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VDb21wYXJhdG9ycy5ldmVyeSgocmFuZ2VDb21wYXJhdG9yKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNDb21wYXJhdG9yLmludGVyc2VjdHMocmFuZ2VDb21wYXJhdG9yLCBvcHRpb25zKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfSlcbiAgfVxuXG4gIC8vIGlmIEFOWSBvZiB0aGUgc2V0cyBtYXRjaCBBTEwgb2YgaXRzIGNvbXBhcmF0b3JzLCB0aGVuIHBhc3NcbiAgdGVzdCAodmVyc2lvbikge1xuICAgIGlmICghdmVyc2lvbikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNldC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRlc3RTZXQodGhpcy5zZXRbaV0sIHZlcnNpb24sIHRoaXMub3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gUmFuZ2VcblxuY29uc3QgTFJVID0gcmVxdWlyZSgnbHJ1LWNhY2hlJylcbmNvbnN0IGNhY2hlID0gbmV3IExSVSh7IG1heDogMTAwMCB9KVxuXG5jb25zdCBwYXJzZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9wYXJzZS1vcHRpb25zJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuL2NvbXBhcmF0b3InKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuL3NlbXZlcicpXG5jb25zdCB7XG4gIHJlLFxuICB0LFxuICBjb21wYXJhdG9yVHJpbVJlcGxhY2UsXG4gIHRpbGRlVHJpbVJlcGxhY2UsXG4gIGNhcmV0VHJpbVJlcGxhY2Vcbn0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IGlzTnVsbFNldCA9IGMgPT4gYy52YWx1ZSA9PT0gJzwwLjAuMC0wJ1xuY29uc3QgaXNBbnkgPSBjID0+IGMudmFsdWUgPT09ICcnXG5cbi8vIHRha2UgYSBzZXQgb2YgY29tcGFyYXRvcnMgYW5kIGRldGVybWluZSB3aGV0aGVyIHRoZXJlXG4vLyBleGlzdHMgYSB2ZXJzaW9uIHdoaWNoIGNhbiBzYXRpc2Z5IGl0XG5jb25zdCBpc1NhdGlzZmlhYmxlID0gKGNvbXBhcmF0b3JzLCBvcHRpb25zKSA9PiB7XG4gIGxldCByZXN1bHQgPSB0cnVlXG4gIGNvbnN0IHJlbWFpbmluZ0NvbXBhcmF0b3JzID0gY29tcGFyYXRvcnMuc2xpY2UoKVxuICBsZXQgdGVzdENvbXBhcmF0b3IgPSByZW1haW5pbmdDb21wYXJhdG9ycy5wb3AoKVxuXG4gIHdoaWxlIChyZXN1bHQgJiYgcmVtYWluaW5nQ29tcGFyYXRvcnMubGVuZ3RoKSB7XG4gICAgcmVzdWx0ID0gcmVtYWluaW5nQ29tcGFyYXRvcnMuZXZlcnkoKG90aGVyQ29tcGFyYXRvcikgPT4ge1xuICAgICAgcmV0dXJuIHRlc3RDb21wYXJhdG9yLmludGVyc2VjdHMob3RoZXJDb21wYXJhdG9yLCBvcHRpb25zKVxuICAgIH0pXG5cbiAgICB0ZXN0Q29tcGFyYXRvciA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLnBvcCgpXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIGNvbXByaXNlZCBvZiB4cmFuZ2VzLCB0aWxkZXMsIHN0YXJzLCBhbmQgZ3RsdCdzIGF0IHRoaXMgcG9pbnQuXG4vLyBhbHJlYWR5IHJlcGxhY2VkIHRoZSBoeXBoZW4gcmFuZ2VzXG4vLyB0dXJuIGludG8gYSBzZXQgb2YgSlVTVCBjb21wYXJhdG9ycy5cbmNvbnN0IHBhcnNlQ29tcGFyYXRvciA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdjb21wJywgY29tcCwgb3B0aW9ucylcbiAgY29tcCA9IHJlcGxhY2VDYXJldHMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ2NhcmV0JywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VUaWxkZXMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3RpbGRlcycsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlWFJhbmdlcyhjb21wLCBvcHRpb25zKVxuICBkZWJ1ZygneHJhbmdlJywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VTdGFycyhjb21wLCBvcHRpb25zKVxuICBkZWJ1Zygnc3RhcnMnLCBjb21wKVxuICByZXR1cm4gY29tcFxufVxuXG5jb25zdCBpc1ggPSBpZCA9PiAhaWQgfHwgaWQudG9Mb3dlckNhc2UoKSA9PT0gJ3gnIHx8IGlkID09PSAnKidcblxuLy8gfiwgfj4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyB+MiwgfjIueCwgfjIueC54LCB+PjIsIH4+Mi54IH4+Mi54LnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIH4yLjAsIH4yLjAueCwgfj4yLjAsIH4+Mi4wLnggLS0+ID49Mi4wLjAgPDIuMS4wLTBcbi8vIH4xLjIsIH4xLjIueCwgfj4xLjIsIH4+MS4yLnggLS0+ID49MS4yLjAgPDEuMy4wLTBcbi8vIH4xLjIuMywgfj4xLjIuMyAtLT4gPj0xLjIuMyA8MS4zLjAtMFxuLy8gfjEuMi4wLCB+PjEuMi4wIC0tPiA+PTEuMi4wIDwxLjMuMC0wXG5jb25zdCByZXBsYWNlVGlsZGVzID0gKGNvbXAsIG9wdGlvbnMpID0+XG4gIGNvbXAudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKChjb21wKSA9PiB7XG4gICAgcmV0dXJuIHJlcGxhY2VUaWxkZShjb21wLCBvcHRpb25zKVxuICB9KS5qb2luKCcgJylcblxuY29uc3QgcmVwbGFjZVRpbGRlID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LlRJTERFTE9PU0VdIDogcmVbdC5USUxERV1cbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCAoXywgTSwgbSwgcCwgcHIpID0+IHtcbiAgICBkZWJ1ZygndGlsZGUnLCBjb21wLCBfLCBNLCBtLCBwLCBwcilcbiAgICBsZXQgcmV0XG5cbiAgICBpZiAoaXNYKE0pKSB7XG4gICAgICByZXQgPSAnJ1xuICAgIH0gZWxzZSBpZiAoaXNYKG0pKSB7XG4gICAgICByZXQgPSBgPj0ke019LjAuMCA8JHsrTSArIDF9LjAuMC0wYFxuICAgIH0gZWxzZSBpZiAoaXNYKHApKSB7XG4gICAgICAvLyB+MS4yID09ID49MS4yLjAgPDEuMy4wLTBcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wIDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgfSBlbHNlIGlmIChwcikge1xuICAgICAgZGVidWcoJ3JlcGxhY2VUaWxkZSBwcicsIHByKVxuICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwclxuICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB+MS4yLjMgPT0gPj0xLjIuMyA8MS4zLjAtMFxuICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH1cblxuICAgIGRlYnVnKCd0aWxkZSByZXR1cm4nLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG4vLyBeIC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gXjIsIF4yLngsIF4yLngueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuLy8gXjIuMCwgXjIuMC54IC0tPiA+PTIuMC4wIDwzLjAuMC0wXG4vLyBeMS4yLCBeMS4yLnggLS0+ID49MS4yLjAgPDIuMC4wLTBcbi8vIF4xLjIuMyAtLT4gPj0xLjIuMyA8Mi4wLjAtMFxuLy8gXjEuMi4wIC0tPiA+PTEuMi4wIDwyLjAuMC0wXG5jb25zdCByZXBsYWNlQ2FyZXRzID0gKGNvbXAsIG9wdGlvbnMpID0+XG4gIGNvbXAudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKChjb21wKSA9PiB7XG4gICAgcmV0dXJuIHJlcGxhY2VDYXJldChjb21wLCBvcHRpb25zKVxuICB9KS5qb2luKCcgJylcblxuY29uc3QgcmVwbGFjZUNhcmV0ID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ2NhcmV0JywgY29tcCwgb3B0aW9ucylcbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LkNBUkVUTE9PU0VdIDogcmVbdC5DQVJFVF1cbiAgY29uc3QgeiA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyAnLTAnIDogJydcbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCAoXywgTSwgbSwgcCwgcHIpID0+IHtcbiAgICBkZWJ1ZygnY2FyZXQnLCBjb21wLCBfLCBNLCBtLCBwLCBwcilcbiAgICBsZXQgcmV0XG5cbiAgICBpZiAoaXNYKE0pKSB7XG4gICAgICByZXQgPSAnJ1xuICAgIH0gZWxzZSBpZiAoaXNYKG0pKSB7XG4gICAgICByZXQgPSBgPj0ke019LjAuMCR7en0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKGlzWChwKSkge1xuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7en0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wJHt6fSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlQ2FyZXQgcHInLCBwcilcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgaWYgKG0gPT09ICcwJykge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgICB9IDwke019LiR7bX0uJHsrcCArIDF9LTBgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwclxuICAgICAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwclxuICAgICAgICB9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdubyBwcicpXG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwXG4gICAgICAgICAgfSR7en0gPCR7TX0uJHttfS4keytwICsgMX0tMGBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwXG4gICAgICAgICAgfSR7en0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICB9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVidWcoJ2NhcmV0IHJldHVybicsIHJldClcbiAgICByZXR1cm4gcmV0XG4gIH0pXG59XG5cbmNvbnN0IHJlcGxhY2VYUmFuZ2VzID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ3JlcGxhY2VYUmFuZ2VzJywgY29tcCwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAuc3BsaXQoL1xccysvKS5tYXAoKGNvbXApID0+IHtcbiAgICByZXR1cm4gcmVwbGFjZVhSYW5nZShjb21wLCBvcHRpb25zKVxuICB9KS5qb2luKCcgJylcbn1cblxuY29uc3QgcmVwbGFjZVhSYW5nZSA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGNvbXAgPSBjb21wLnRyaW0oKVxuICBjb25zdCByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuWFJBTkdFTE9PU0VdIDogcmVbdC5YUkFOR0VdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpID0+IHtcbiAgICBkZWJ1ZygneFJhbmdlJywgY29tcCwgcmV0LCBndGx0LCBNLCBtLCBwLCBwcilcbiAgICBjb25zdCB4TSA9IGlzWChNKVxuICAgIGNvbnN0IHhtID0geE0gfHwgaXNYKG0pXG4gICAgY29uc3QgeHAgPSB4bSB8fCBpc1gocClcbiAgICBjb25zdCBhbnlYID0geHBcblxuICAgIGlmIChndGx0ID09PSAnPScgJiYgYW55WCkge1xuICAgICAgZ3RsdCA9ICcnXG4gICAgfVxuXG4gICAgLy8gaWYgd2UncmUgaW5jbHVkaW5nIHByZXJlbGVhc2VzIGluIHRoZSBtYXRjaCwgdGhlbiB3ZSBuZWVkXG4gICAgLy8gdG8gZml4IHRoaXMgdG8gLTAsIHRoZSBsb3dlc3QgcG9zc2libGUgcHJlcmVsZWFzZSB2YWx1ZVxuICAgIHByID0gb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/ICctMCcgOiAnJ1xuXG4gICAgaWYgKHhNKSB7XG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nIHx8IGd0bHQgPT09ICc8Jykge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGFsbG93ZWRcbiAgICAgICAgcmV0ID0gJzwwLjAuMC0wJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBmb3JiaWRkZW5cbiAgICAgICAgcmV0ID0gJyonXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChndGx0ICYmIGFueVgpIHtcbiAgICAgIC8vIHdlIGtub3cgcGF0Y2ggaXMgYW4geCwgYmVjYXVzZSB3ZSBoYXZlIGFueSB4IGF0IGFsbC5cbiAgICAgIC8vIHJlcGxhY2UgWCB3aXRoIDBcbiAgICAgIGlmICh4bSkge1xuICAgICAgICBtID0gMFxuICAgICAgfVxuICAgICAgcCA9IDBcblxuICAgICAgaWYgKGd0bHQgPT09ICc+Jykge1xuICAgICAgICAvLyA+MSA9PiA+PTIuMC4wXG4gICAgICAgIC8vID4xLjIgPT4gPj0xLjMuMFxuICAgICAgICBndGx0ID0gJz49J1xuICAgICAgICBpZiAoeG0pIHtcbiAgICAgICAgICBNID0gK00gKyAxXG4gICAgICAgICAgbSA9IDBcbiAgICAgICAgICBwID0gMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSArbSArIDFcbiAgICAgICAgICBwID0gMFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGd0bHQgPT09ICc8PScpIHtcbiAgICAgICAgLy8gPD0wLjcueCBpcyBhY3R1YWxseSA8MC44LjAsIHNpbmNlIGFueSAwLjcueCBzaG91bGRcbiAgICAgICAgLy8gcGFzcy4gIFNpbWlsYXJseSwgPD03LnggaXMgYWN0dWFsbHkgPDguMC4wLCBldGMuXG4gICAgICAgIGd0bHQgPSAnPCdcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSArbSArIDFcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZ3RsdCA9PT0gJzwnKVxuICAgICAgICBwciA9ICctMCdcblxuICAgICAgcmV0ID0gYCR7Z3RsdCArIE19LiR7bX0uJHtwfSR7cHJ9YFxuICAgIH0gZWxzZSBpZiAoeG0pIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uMC4wJHtwcn0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKHhwKSB7XG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7cHJcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9XG5cbiAgICBkZWJ1ZygneFJhbmdlIHJldHVybicsIHJldClcblxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuLy8gQmVjYXVzZSAqIGlzIEFORC1lZCB3aXRoIGV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgY29tcGFyYXRvcixcbi8vIGFuZCAnJyBtZWFucyBcImFueSB2ZXJzaW9uXCIsIGp1c3QgcmVtb3ZlIHRoZSAqcyBlbnRpcmVseS5cbmNvbnN0IHJlcGxhY2VTdGFycyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlU3RhcnMnLCBjb21wLCBvcHRpb25zKVxuICAvLyBMb29zZW5lc3MgaXMgaWdub3JlZCBoZXJlLiAgc3RhciBpcyBhbHdheXMgYXMgbG9vc2UgYXMgaXQgZ2V0cyFcbiAgcmV0dXJuIGNvbXAudHJpbSgpLnJlcGxhY2UocmVbdC5TVEFSXSwgJycpXG59XG5cbmNvbnN0IHJlcGxhY2VHVEUwID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ3JlcGxhY2VHVEUwJywgY29tcCwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAudHJpbSgpXG4gICAgLnJlcGxhY2UocmVbb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/IHQuR1RFMFBSRSA6IHQuR1RFMF0sICcnKVxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHBhc3NlZCB0byBzdHJpbmcucmVwbGFjZShyZVt0LkhZUEhFTlJBTkdFXSlcbi8vIE0sIG0sIHBhdGNoLCBwcmVyZWxlYXNlLCBidWlsZFxuLy8gMS4yIC0gMy40LjUgPT4gPj0xLjIuMCA8PTMuNC41XG4vLyAxLjIuMyAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMC0wIEFueSAzLjQueCB3aWxsIGRvXG4vLyAxLjIgLSAzLjQgPT4gPj0xLjIuMCA8My41LjAtMFxuY29uc3QgaHlwaGVuUmVwbGFjZSA9IGluY1ByID0+ICgkMCxcbiAgZnJvbSwgZk0sIGZtLCBmcCwgZnByLCBmYixcbiAgdG8sIHRNLCB0bSwgdHAsIHRwciwgdGIpID0+IHtcbiAgaWYgKGlzWChmTSkpIHtcbiAgICBmcm9tID0gJydcbiAgfSBlbHNlIGlmIChpc1goZm0pKSB7XG4gICAgZnJvbSA9IGA+PSR7Zk19LjAuMCR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9IGVsc2UgaWYgKGlzWChmcCkpIHtcbiAgICBmcm9tID0gYD49JHtmTX0uJHtmbX0uMCR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9IGVsc2UgaWYgKGZwcikge1xuICAgIGZyb20gPSBgPj0ke2Zyb219YFxuICB9IGVsc2Uge1xuICAgIGZyb20gPSBgPj0ke2Zyb219JHtpbmNQciA/ICctMCcgOiAnJ31gXG4gIH1cblxuICBpZiAoaXNYKHRNKSkge1xuICAgIHRvID0gJydcbiAgfSBlbHNlIGlmIChpc1godG0pKSB7XG4gICAgdG8gPSBgPCR7K3RNICsgMX0uMC4wLTBgXG4gIH0gZWxzZSBpZiAoaXNYKHRwKSkge1xuICAgIHRvID0gYDwke3RNfS4keyt0bSArIDF9LjAtMGBcbiAgfSBlbHNlIGlmICh0cHIpIHtcbiAgICB0byA9IGA8PSR7dE19LiR7dG19LiR7dHB9LSR7dHByfWBcbiAgfSBlbHNlIGlmIChpbmNQcikge1xuICAgIHRvID0gYDwke3RNfS4ke3RtfS4keyt0cCArIDF9LTBgXG4gIH0gZWxzZSB7XG4gICAgdG8gPSBgPD0ke3RvfWBcbiAgfVxuXG4gIHJldHVybiAoYCR7ZnJvbX0gJHt0b31gKS50cmltKClcbn1cblxuY29uc3QgdGVzdFNldCA9IChzZXQsIHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXNldFtpXS50ZXN0KHZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBpZiAodmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgIC8vIEZpbmQgdGhlIHNldCBvZiB2ZXJzaW9ucyB0aGF0IGFyZSBhbGxvd2VkIHRvIGhhdmUgcHJlcmVsZWFzZXNcbiAgICAvLyBGb3IgZXhhbXBsZSwgXjEuMi4zLXByLjEgZGVzdWdhcnMgdG8gPj0xLjIuMy1wci4xIDwyLjAuMFxuICAgIC8vIFRoYXQgc2hvdWxkIGFsbG93IGAxLjIuMy1wci4yYCB0byBwYXNzLlxuICAgIC8vIEhvd2V2ZXIsIGAxLjIuNC1hbHBoYS5ub3RyZWFkeWAgc2hvdWxkIE5PVCBiZSBhbGxvd2VkLFxuICAgIC8vIGV2ZW4gdGhvdWdoIGl0J3Mgd2l0aGluIHRoZSByYW5nZSBzZXQgYnkgdGhlIGNvbXBhcmF0b3JzLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWJ1ZyhzZXRbaV0uc2VtdmVyKVxuICAgICAgaWYgKHNldFtpXS5zZW12ZXIgPT09IENvbXBhcmF0b3IuQU5ZKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBhbGxvd2VkID0gc2V0W2ldLnNlbXZlclxuICAgICAgICBpZiAoYWxsb3dlZC5tYWpvciA9PT0gdmVyc2lvbi5tYWpvciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5taW5vciA9PT0gdmVyc2lvbi5taW5vciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5wYXRjaCA9PT0gdmVyc2lvbi5wYXRjaCkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWZXJzaW9uIGhhcyBhIC1wcmUsIGJ1dCBpdCdzIG5vdCBvbmUgb2YgdGhlIG9uZXMgd2UgbGlrZS5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCJjb25zdCBBTlkgPSBTeW1ib2woJ1NlbVZlciBBTlknKVxuLy8gaG9pc3RlZCBjbGFzcyBmb3IgY3ljbGljIGRlcGVuZGVuY3lcbmNsYXNzIENvbXBhcmF0b3Ige1xuICBzdGF0aWMgZ2V0IEFOWSAoKSB7XG4gICAgcmV0dXJuIEFOWVxuICB9XG4gIGNvbnN0cnVjdG9yIChjb21wLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgaWYgKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgICBpZiAoY29tcC5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlKSB7XG4gICAgICAgIHJldHVybiBjb21wXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wID0gY29tcC52YWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGRlYnVnKCdjb21wYXJhdG9yJywgY29tcCwgb3B0aW9ucylcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICAgIHRoaXMucGFyc2UoY29tcClcblxuICAgIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICB0aGlzLnZhbHVlID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMub3BlcmF0b3IgKyB0aGlzLnNlbXZlci52ZXJzaW9uXG4gICAgfVxuXG4gICAgZGVidWcoJ2NvbXAnLCB0aGlzKVxuICB9XG5cbiAgcGFyc2UgKGNvbXApIHtcbiAgICBjb25zdCByID0gdGhpcy5vcHRpb25zLmxvb3NlID8gcmVbdC5DT01QQVJBVE9STE9PU0VdIDogcmVbdC5DT01QQVJBVE9SXVxuICAgIGNvbnN0IG0gPSBjb21wLm1hdGNoKHIpXG5cbiAgICBpZiAoIW0pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgY29tcGFyYXRvcjogJHtjb21wfWApXG4gICAgfVxuXG4gICAgdGhpcy5vcGVyYXRvciA9IG1bMV0gIT09IHVuZGVmaW5lZCA/IG1bMV0gOiAnJ1xuICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSAnPScpIHtcbiAgICAgIHRoaXMub3BlcmF0b3IgPSAnJ1xuICAgIH1cblxuICAgIC8vIGlmIGl0IGxpdGVyYWxseSBpcyBqdXN0ICc+JyBvciAnJyB0aGVuIGFsbG93IGFueXRoaW5nLlxuICAgIGlmICghbVsyXSkge1xuICAgICAgdGhpcy5zZW12ZXIgPSBBTllcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW12ZXIgPSBuZXcgU2VtVmVyKG1bMl0sIHRoaXMub3B0aW9ucy5sb29zZSlcbiAgICB9XG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVcbiAgfVxuXG4gIHRlc3QgKHZlcnNpb24pIHtcbiAgICBkZWJ1ZygnQ29tcGFyYXRvci50ZXN0JywgdmVyc2lvbiwgdGhpcy5vcHRpb25zLmxvb3NlKVxuXG4gICAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkgfHwgdmVyc2lvbiA9PT0gQU5ZKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMub3B0aW9ucylcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbXAodmVyc2lvbiwgdGhpcy5vcGVyYXRvciwgdGhpcy5zZW12ZXIsIHRoaXMub3B0aW9ucylcbiAgfVxuXG4gIGludGVyc2VjdHMgKGNvbXAsIG9wdGlvbnMpIHtcbiAgICBpZiAoIShjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgQ29tcGFyYXRvciBpcyByZXF1aXJlZCcpXG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgbG9vc2U6ICEhb3B0aW9ucyxcbiAgICAgICAgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgICBpZiAodGhpcy52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmFuZ2UoY29tcC52YWx1ZSwgb3B0aW9ucykudGVzdCh0aGlzLnZhbHVlKVxuICAgIH0gZWxzZSBpZiAoY29tcC5vcGVyYXRvciA9PT0gJycpIHtcbiAgICAgIGlmIChjb21wLnZhbHVlID09PSAnJykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYW5nZSh0aGlzLnZhbHVlLCBvcHRpb25zKS50ZXN0KGNvbXAuc2VtdmVyKVxuICAgIH1cblxuICAgIGNvbnN0IHNhbWVEaXJlY3Rpb25JbmNyZWFzaW5nID1cbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiZcbiAgICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc+JylcbiAgICBjb25zdCBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyA9XG4gICAgICAodGhpcy5vcGVyYXRvciA9PT0gJzw9JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPCcpICYmXG4gICAgICAoY29tcC5vcGVyYXRvciA9PT0gJzw9JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPCcpXG4gICAgY29uc3Qgc2FtZVNlbVZlciA9IHRoaXMuc2VtdmVyLnZlcnNpb24gPT09IGNvbXAuc2VtdmVyLnZlcnNpb25cbiAgICBjb25zdCBkaWZmZXJlbnREaXJlY3Rpb25zSW5jbHVzaXZlID1cbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8PScpICYmXG4gICAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPD0nKVxuICAgIGNvbnN0IG9wcG9zaXRlRGlyZWN0aW9uc0xlc3NUaGFuID1cbiAgICAgIGNtcCh0aGlzLnNlbXZlciwgJzwnLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiZcbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiZcbiAgICAgICAgKGNvbXAub3BlcmF0b3IgPT09ICc8PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzwnKVxuICAgIGNvbnN0IG9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuID1cbiAgICAgIGNtcCh0aGlzLnNlbXZlciwgJz4nLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiZcbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPD0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8JykgJiZcbiAgICAgICAgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJz4nKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIHNhbWVEaXJlY3Rpb25JbmNyZWFzaW5nIHx8XG4gICAgICBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyB8fFxuICAgICAgKHNhbWVTZW1WZXIgJiYgZGlmZmVyZW50RGlyZWN0aW9uc0luY2x1c2l2ZSkgfHxcbiAgICAgIG9wcG9zaXRlRGlyZWN0aW9uc0xlc3NUaGFuIHx8XG4gICAgICBvcHBvc2l0ZURpcmVjdGlvbnNHcmVhdGVyVGhhblxuICAgIClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBhcmF0b3JcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCB7cmUsIHR9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuY29uc3QgY21wID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NtcCcpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4vc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi9yYW5nZScpXG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3Qgc2F0aXNmaWVzID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIHRyeSB7XG4gICAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHJhbmdlLnRlc3QodmVyc2lvbilcbn1cbm1vZHVsZS5leHBvcnRzID0gc2F0aXNmaWVzXG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuXG4vLyBNb3N0bHkganVzdCBmb3IgdGVzdGluZyBhbmQgbGVnYWN5IEFQSSByZWFzb25zXG5jb25zdCB0b0NvbXBhcmF0b3JzID0gKHJhbmdlLCBvcHRpb25zKSA9PlxuICBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpLnNldFxuICAgIC5tYXAoY29tcCA9PiBjb21wLm1hcChjID0+IGMudmFsdWUpLmpvaW4oJyAnKS50cmltKCkuc3BsaXQoJyAnKSlcblxubW9kdWxlLmV4cG9ydHMgPSB0b0NvbXBhcmF0b3JzXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuXG5jb25zdCBtYXhTYXRpc2Z5aW5nID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBsZXQgbWF4ID0gbnVsbFxuICBsZXQgbWF4U1YgPSBudWxsXG4gIGxldCByYW5nZU9iaiA9IG51bGxcbiAgdHJ5IHtcbiAgICByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZlcnNpb25zLmZvckVhY2goKHYpID0+IHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkge1xuICAgICAgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtYXggfHwgbWF4U1YuY29tcGFyZSh2KSA9PT0gLTEpIHtcbiAgICAgICAgLy8gY29tcGFyZShtYXgsIHYsIHRydWUpXG4gICAgICAgIG1heCA9IHZcbiAgICAgICAgbWF4U1YgPSBuZXcgU2VtVmVyKG1heCwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBtYXhcbn1cbm1vZHVsZS5leHBvcnRzID0gbWF4U2F0aXNmeWluZ1xuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IG1pblNhdGlzZnlpbmcgPSAodmVyc2lvbnMsIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIGxldCBtaW4gPSBudWxsXG4gIGxldCBtaW5TViA9IG51bGxcbiAgbGV0IHJhbmdlT2JqID0gbnVsbFxuICB0cnkge1xuICAgIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmVyc2lvbnMuZm9yRWFjaCgodikgPT4ge1xuICAgIGlmIChyYW5nZU9iai50ZXN0KHYpKSB7XG4gICAgICAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgICBpZiAoIW1pbiB8fCBtaW5TVi5jb21wYXJlKHYpID09PSAxKSB7XG4gICAgICAgIC8vIGNvbXBhcmUobWluLCB2LCB0cnVlKVxuICAgICAgICBtaW4gPSB2XG4gICAgICAgIG1pblNWID0gbmV3IFNlbVZlcihtaW4sIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWluXG59XG5tb2R1bGUuZXhwb3J0cyA9IG1pblNhdGlzZnlpbmdcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9ndCcpXG5cbmNvbnN0IG1pblZlcnNpb24gPSAocmFuZ2UsIGxvb3NlKSA9PiB7XG4gIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSlcblxuICBsZXQgbWludmVyID0gbmV3IFNlbVZlcignMC4wLjAnKVxuICBpZiAocmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgbWludmVyID0gbmV3IFNlbVZlcignMC4wLjAtMCcpXG4gIGlmIChyYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICBtaW52ZXIgPSBudWxsXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV1cblxuICAgIGxldCBzZXRNaW4gPSBudWxsXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaCgoY29tcGFyYXRvcikgPT4ge1xuICAgICAgLy8gQ2xvbmUgdG8gYXZvaWQgbWFuaXB1bGF0aW5nIHRoZSBjb21wYXJhdG9yJ3Mgc2VtdmVyIG9iamVjdC5cbiAgICAgIGNvbnN0IGNvbXB2ZXIgPSBuZXcgU2VtVmVyKGNvbXBhcmF0b3Iuc2VtdmVyLnZlcnNpb24pXG4gICAgICBzd2l0Y2ggKGNvbXBhcmF0b3Iub3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgaWYgKGNvbXB2ZXIucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbXB2ZXIucGF0Y2grK1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wdmVyLnByZXJlbGVhc2UucHVzaCgwKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb21wdmVyLnJhdyA9IGNvbXB2ZXIuZm9ybWF0KClcbiAgICAgICAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICcnOlxuICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgaWYgKCFzZXRNaW4gfHwgZ3QoY29tcHZlciwgc2V0TWluKSkge1xuICAgICAgICAgICAgc2V0TWluID0gY29tcHZlclxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgIC8qIElnbm9yZSBtYXhpbXVtIHZlcnNpb25zICovXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgb3BlcmF0aW9uOiAke2NvbXBhcmF0b3Iub3BlcmF0b3J9YClcbiAgICAgIH1cbiAgICB9KVxuICAgIGlmIChzZXRNaW4gJiYgKCFtaW52ZXIgfHwgZ3QobWludmVyLCBzZXRNaW4pKSlcbiAgICAgIG1pbnZlciA9IHNldE1pblxuICB9XG5cbiAgaWYgKG1pbnZlciAmJiByYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBtaW5WZXJzaW9uXG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgdmFsaWRSYW5nZSA9IChyYW5nZSwgb3B0aW9ucykgPT4ge1xuICB0cnkge1xuICAgIC8vIFJldHVybiAnKicgaW5zdGVhZCBvZiAnJyBzbyB0aGF0IHRydXRoaW5lc3Mgd29ya3MuXG4gICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIGl0J3MgaW52YWxpZCBhbnl3YXlcbiAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKS5yYW5nZSB8fCAnKidcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkUmFuZ2VcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuLi9jbGFzc2VzL2NvbXBhcmF0b3InKVxuY29uc3Qge0FOWX0gPSBDb21wYXJhdG9yXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcycpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9ndCcpXG5jb25zdCBsdCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9sdCcpXG5jb25zdCBsdGUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvbHRlJylcbmNvbnN0IGd0ZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9ndGUnKVxuXG5jb25zdCBvdXRzaWRlID0gKHZlcnNpb24sIHJhbmdlLCBoaWxvLCBvcHRpb25zKSA9PiB7XG4gIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpXG4gIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuXG4gIGxldCBndGZuLCBsdGVmbiwgbHRmbiwgY29tcCwgZWNvbXBcbiAgc3dpdGNoIChoaWxvKSB7XG4gICAgY2FzZSAnPic6XG4gICAgICBndGZuID0gZ3RcbiAgICAgIGx0ZWZuID0gbHRlXG4gICAgICBsdGZuID0gbHRcbiAgICAgIGNvbXAgPSAnPidcbiAgICAgIGVjb21wID0gJz49J1xuICAgICAgYnJlYWtcbiAgICBjYXNlICc8JzpcbiAgICAgIGd0Zm4gPSBsdFxuICAgICAgbHRlZm4gPSBndGVcbiAgICAgIGx0Zm4gPSBndFxuICAgICAgY29tcCA9ICc8J1xuICAgICAgZWNvbXAgPSAnPD0nXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNdXN0IHByb3ZpZGUgYSBoaWxvIHZhbCBvZiBcIjxcIiBvciBcIj5cIicpXG4gIH1cblxuICAvLyBJZiBpdCBzYXRpc2ZpZXMgdGhlIHJhbmdlIGl0IGlzIG5vdCBvdXRzaWRlXG4gIGlmIChzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBGcm9tIG5vdyBvbiwgdmFyaWFibGUgdGVybXMgYXJlIGFzIGlmIHdlJ3JlIGluIFwiZ3RyXCIgbW9kZS5cbiAgLy8gYnV0IG5vdGUgdGhhdCBldmVyeXRoaW5nIGlzIGZsaXBwZWQgZm9yIHRoZSBcImx0clwiIGZ1bmN0aW9uLlxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV1cblxuICAgIGxldCBoaWdoID0gbnVsbFxuICAgIGxldCBsb3cgPSBudWxsXG5cbiAgICBjb21wYXJhdG9ycy5mb3JFYWNoKChjb21wYXJhdG9yKSA9PiB7XG4gICAgICBpZiAoY29tcGFyYXRvci5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgICBjb21wYXJhdG9yID0gbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKVxuICAgICAgfVxuICAgICAgaGlnaCA9IGhpZ2ggfHwgY29tcGFyYXRvclxuICAgICAgbG93ID0gbG93IHx8IGNvbXBhcmF0b3JcbiAgICAgIGlmIChndGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBoaWdoLnNlbXZlciwgb3B0aW9ucykpIHtcbiAgICAgICAgaGlnaCA9IGNvbXBhcmF0b3JcbiAgICAgIH0gZWxzZSBpZiAobHRmbihjb21wYXJhdG9yLnNlbXZlciwgbG93LnNlbXZlciwgb3B0aW9ucykpIHtcbiAgICAgICAgbG93ID0gY29tcGFyYXRvclxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBJZiB0aGUgZWRnZSB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGEgb3BlcmF0b3IgdGhlbiBvdXIgdmVyc2lvblxuICAgIC8vIGlzbid0IG91dHNpZGUgaXRcbiAgICBpZiAoaGlnaC5vcGVyYXRvciA9PT0gY29tcCB8fCBoaWdoLm9wZXJhdG9yID09PSBlY29tcCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGxvd2VzdCB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGFuIG9wZXJhdG9yIGFuZCBvdXIgdmVyc2lvblxuICAgIC8vIGlzIGxlc3MgdGhhbiBpdCB0aGVuIGl0IGlzbid0IGhpZ2hlciB0aGFuIHRoZSByYW5nZVxuICAgIGlmICgoIWxvdy5vcGVyYXRvciB8fCBsb3cub3BlcmF0b3IgPT09IGNvbXApICYmXG4gICAgICAgIGx0ZWZuKHZlcnNpb24sIGxvdy5zZW12ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2UgaWYgKGxvdy5vcGVyYXRvciA9PT0gZWNvbXAgJiYgbHRmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3V0c2lkZVxuIiwiLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlLlxuY29uc3Qgb3V0c2lkZSA9IHJlcXVpcmUoJy4vb3V0c2lkZScpXG5jb25zdCBndHIgPSAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpID0+IG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc+Jywgb3B0aW9ucylcbm1vZHVsZS5leHBvcnRzID0gZ3RyXG4iLCJjb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9vdXRzaWRlJylcbi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGxlc3MgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZVxuY29uc3QgbHRyID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPCcsIG9wdGlvbnMpXG5tb2R1bGUuZXhwb3J0cyA9IGx0clxuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IGludGVyc2VjdHMgPSAocjEsIHIyLCBvcHRpb25zKSA9PiB7XG4gIHIxID0gbmV3IFJhbmdlKHIxLCBvcHRpb25zKVxuICByMiA9IG5ldyBSYW5nZShyMiwgb3B0aW9ucylcbiAgcmV0dXJuIHIxLmludGVyc2VjdHMocjIpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGludGVyc2VjdHNcbiIsIi8vIGdpdmVuIGEgc2V0IG9mIHZlcnNpb25zIGFuZCBhIHJhbmdlLCBjcmVhdGUgYSBcInNpbXBsaWZpZWRcIiByYW5nZVxuLy8gdGhhdCBpbmNsdWRlcyB0aGUgc2FtZSB2ZXJzaW9ucyB0aGF0IHRoZSBvcmlnaW5hbCByYW5nZSBkb2VzXG4vLyBJZiB0aGUgb3JpZ2luYWwgcmFuZ2UgaXMgc2hvcnRlciB0aGFuIHRoZSBzaW1wbGlmaWVkIG9uZSwgcmV0dXJuIHRoYXQuXG5jb25zdCBzYXRpc2ZpZXMgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzJylcbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvY29tcGFyZS5qcycpXG5tb2R1bGUuZXhwb3J0cyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgc2V0ID0gW11cbiAgbGV0IG1pbiA9IG51bGxcbiAgbGV0IHByZXYgPSBudWxsXG4gIGNvbnN0IHYgPSB2ZXJzaW9ucy5zb3J0KChhLCBiKSA9PiBjb21wYXJlKGEsIGIsIG9wdGlvbnMpKVxuICBmb3IgKGNvbnN0IHZlcnNpb24gb2Ygdikge1xuICAgIGNvbnN0IGluY2x1ZGVkID0gc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKVxuICAgIGlmIChpbmNsdWRlZCkge1xuICAgICAgcHJldiA9IHZlcnNpb25cbiAgICAgIGlmICghbWluKVxuICAgICAgICBtaW4gPSB2ZXJzaW9uXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgIHNldC5wdXNoKFttaW4sIHByZXZdKVxuICAgICAgfVxuICAgICAgcHJldiA9IG51bGxcbiAgICAgIG1pbiA9IG51bGxcbiAgICB9XG4gIH1cbiAgaWYgKG1pbilcbiAgICBzZXQucHVzaChbbWluLCBudWxsXSlcblxuICBjb25zdCByYW5nZXMgPSBbXVxuICBmb3IgKGNvbnN0IFttaW4sIG1heF0gb2Ygc2V0KSB7XG4gICAgaWYgKG1pbiA9PT0gbWF4KVxuICAgICAgcmFuZ2VzLnB1c2gobWluKVxuICAgIGVsc2UgaWYgKCFtYXggJiYgbWluID09PSB2WzBdKVxuICAgICAgcmFuZ2VzLnB1c2goJyonKVxuICAgIGVsc2UgaWYgKCFtYXgpXG4gICAgICByYW5nZXMucHVzaChgPj0ke21pbn1gKVxuICAgIGVsc2UgaWYgKG1pbiA9PT0gdlswXSlcbiAgICAgIHJhbmdlcy5wdXNoKGA8PSR7bWF4fWApXG4gICAgZWxzZVxuICAgICAgcmFuZ2VzLnB1c2goYCR7bWlufSAtICR7bWF4fWApXG4gIH1cbiAgY29uc3Qgc2ltcGxpZmllZCA9IHJhbmdlcy5qb2luKCcgfHwgJylcbiAgY29uc3Qgb3JpZ2luYWwgPSB0eXBlb2YgcmFuZ2UucmF3ID09PSAnc3RyaW5nJyA/IHJhbmdlLnJhdyA6IFN0cmluZyhyYW5nZSlcbiAgcmV0dXJuIHNpbXBsaWZpZWQubGVuZ3RoIDwgb3JpZ2luYWwubGVuZ3RoID8gc2ltcGxpZmllZCA6IHJhbmdlXG59XG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UuanMnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvY29tcGFyYXRvci5qcycpXG5jb25zdCB7IEFOWSB9ID0gQ29tcGFyYXRvclxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcy5qcycpXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NvbXBhcmUuanMnKVxuXG4vLyBDb21wbGV4IHJhbmdlIGByMSB8fCByMiB8fCAuLi5gIGlzIGEgc3Vic2V0IG9mIGBSMSB8fCBSMiB8fCAuLi5gIGlmZjpcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgaXMgYSBudWxsIHNldCwgT1Jcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgd2hpY2ggaXMgbm90IGEgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2Zcbi8vICAgc29tZSBgUjEsIFIyLCAuLi5gXG4vL1xuLy8gU2ltcGxlIHJhbmdlIGBjMSBjMiAuLi5gIGlzIGEgc3Vic2V0IG9mIHNpbXBsZSByYW5nZSBgQzEgQzIgLi4uYCBpZmY6XG4vLyAtIElmIGMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBJZiBDIGlzIG9ubHkgdGhlIEFOWSBjb21wYXJhdG9yLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgaWYgaW4gcHJlcmVsZWFzZSBtb2RlLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBlbHNlIHJlcGxhY2UgYyB3aXRoIGBbPj0wLjAuMF1gXG4vLyAtIElmIEMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBpZiBpbiBwcmVyZWxlYXNlIG1vZGUsIHJldHVybiB0cnVlXG4vLyAgIC0gZWxzZSByZXBsYWNlIEMgd2l0aCBgWz49MC4wLjBdYFxuLy8gLSBMZXQgRVEgYmUgdGhlIHNldCBvZiA9IGNvbXBhcmF0b3JzIGluIGNcbi8vIC0gSWYgRVEgaXMgbW9yZSB0aGFuIG9uZSwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gLSBMZXQgR1QgYmUgdGhlIGhpZ2hlc3QgPiBvciA+PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gTGV0IExUIGJlIHRoZSBsb3dlc3QgPCBvciA8PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gSWYgR1QgYW5kIExULCBhbmQgR1Quc2VtdmVyID4gTFQuc2VtdmVyLCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAtIElmIGFueSBDIGlzIGEgPSByYW5nZSwgYW5kIEdUIG9yIExUIGFyZSBzZXQsIHJldHVybiBmYWxzZVxuLy8gLSBJZiBFUVxuLy8gICAtIElmIEdULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBHVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIExULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBMVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIEVRIHNhdGlzZmllcyBldmVyeSBDLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgcmV0dXJuIGZhbHNlXG4vLyAtIElmIEdUXG4vLyAgIC0gSWYgR1Quc2VtdmVyIGlzIGxvd2VyIHRoYW4gYW55ID4gb3IgPj0gY29tcCBpbiBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVCBpcyA+PSwgYW5kIEdULnNlbXZlciBkb2VzIG5vdCBzYXRpc2Z5IGV2ZXJ5IEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIEdULnNlbXZlciBoYXMgYSBwcmVyZWxlYXNlLCBhbmQgbm90IGluIHByZXJlbGVhc2UgbW9kZVxuLy8gICAgIC0gSWYgbm8gQyBoYXMgYSBwcmVyZWxlYXNlIGFuZCB0aGUgR1Quc2VtdmVyIHR1cGxlLCByZXR1cm4gZmFsc2Vcbi8vIC0gSWYgTFRcbi8vICAgLSBJZiBMVC5zZW12ZXIgaXMgZ3JlYXRlciB0aGFuIGFueSA8IG9yIDw9IGNvbXAgaW4gQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgTFQgaXMgPD0sIGFuZCBMVC5zZW12ZXIgZG9lcyBub3Qgc2F0aXNmeSBldmVyeSBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVC5zZW12ZXIgaGFzIGEgcHJlcmVsZWFzZSwgYW5kIG5vdCBpbiBwcmVyZWxlYXNlIG1vZGVcbi8vICAgICAtIElmIG5vIEMgaGFzIGEgcHJlcmVsZWFzZSBhbmQgdGhlIExULnNlbXZlciB0dXBsZSwgcmV0dXJuIGZhbHNlXG4vLyAtIEVsc2UgcmV0dXJuIHRydWVcblxuY29uc3Qgc3Vic2V0ID0gKHN1YiwgZG9tLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKHN1YiA9PT0gZG9tKVxuICAgIHJldHVybiB0cnVlXG5cbiAgc3ViID0gbmV3IFJhbmdlKHN1Yiwgb3B0aW9ucylcbiAgZG9tID0gbmV3IFJhbmdlKGRvbSwgb3B0aW9ucylcbiAgbGV0IHNhd05vbk51bGwgPSBmYWxzZVxuXG4gIE9VVEVSOiBmb3IgKGNvbnN0IHNpbXBsZVN1YiBvZiBzdWIuc2V0KSB7XG4gICAgZm9yIChjb25zdCBzaW1wbGVEb20gb2YgZG9tLnNldCkge1xuICAgICAgY29uc3QgaXNTdWIgPSBzaW1wbGVTdWJzZXQoc2ltcGxlU3ViLCBzaW1wbGVEb20sIG9wdGlvbnMpXG4gICAgICBzYXdOb25OdWxsID0gc2F3Tm9uTnVsbCB8fCBpc1N1YiAhPT0gbnVsbFxuICAgICAgaWYgKGlzU3ViKVxuICAgICAgICBjb250aW51ZSBPVVRFUlxuICAgIH1cbiAgICAvLyB0aGUgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2YgZXZlcnl0aGluZywgYnV0IG51bGwgc2ltcGxlIHJhbmdlcyBpblxuICAgIC8vIGEgY29tcGxleCByYW5nZSBzaG91bGQgYmUgaWdub3JlZC4gIHNvIGlmIHdlIHNhdyBhIG5vbi1udWxsIHJhbmdlLFxuICAgIC8vIHRoZW4gd2Uga25vdyB0aGlzIGlzbid0IGEgc3Vic2V0LCBidXQgaWYgRVZFUlkgc2ltcGxlIHJhbmdlIHdhcyBudWxsLFxuICAgIC8vIHRoZW4gaXQgaXMgYSBzdWJzZXQuXG4gICAgaWYgKHNhd05vbk51bGwpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5jb25zdCBzaW1wbGVTdWJzZXQgPSAoc3ViLCBkb20sIG9wdGlvbnMpID0+IHtcbiAgaWYgKHN1YiA9PT0gZG9tKVxuICAgIHJldHVybiB0cnVlXG5cbiAgaWYgKHN1Yi5sZW5ndGggPT09IDEgJiYgc3ViWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgaWYgKGRvbS5sZW5ndGggPT09IDEgJiYgZG9tWzBdLnNlbXZlciA9PT0gQU5ZKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICBlbHNlIGlmIChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKVxuICAgICAgc3ViID0gWyBuZXcgQ29tcGFyYXRvcignPj0wLjAuMC0wJykgXVxuICAgIGVsc2VcbiAgICAgIHN1YiA9IFsgbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKSBdXG4gIH1cblxuICBpZiAoZG9tLmxlbmd0aCA9PT0gMSAmJiBkb21bMF0uc2VtdmVyID09PSBBTlkpIHtcbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSlcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZWxzZVxuICAgICAgZG9tID0gWyBuZXcgQ29tcGFyYXRvcignPj0wLjAuMCcpIF1cbiAgfVxuXG4gIGNvbnN0IGVxU2V0ID0gbmV3IFNldCgpXG4gIGxldCBndCwgbHRcbiAgZm9yIChjb25zdCBjIG9mIHN1Yikge1xuICAgIGlmIChjLm9wZXJhdG9yID09PSAnPicgfHwgYy5vcGVyYXRvciA9PT0gJz49JylcbiAgICAgIGd0ID0gaGlnaGVyR1QoZ3QsIGMsIG9wdGlvbnMpXG4gICAgZWxzZSBpZiAoYy5vcGVyYXRvciA9PT0gJzwnIHx8IGMub3BlcmF0b3IgPT09ICc8PScpXG4gICAgICBsdCA9IGxvd2VyTFQobHQsIGMsIG9wdGlvbnMpXG4gICAgZWxzZVxuICAgICAgZXFTZXQuYWRkKGMuc2VtdmVyKVxuICB9XG5cbiAgaWYgKGVxU2V0LnNpemUgPiAxKVxuICAgIHJldHVybiBudWxsXG5cbiAgbGV0IGd0bHRDb21wXG4gIGlmIChndCAmJiBsdCkge1xuICAgIGd0bHRDb21wID0gY29tcGFyZShndC5zZW12ZXIsIGx0LnNlbXZlciwgb3B0aW9ucylcbiAgICBpZiAoZ3RsdENvbXAgPiAwKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICBlbHNlIGlmIChndGx0Q29tcCA9PT0gMCAmJiAoZ3Qub3BlcmF0b3IgIT09ICc+PScgfHwgbHQub3BlcmF0b3IgIT09ICc8PScpKVxuICAgICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIHdpbGwgaXRlcmF0ZSBvbmUgb3IgemVybyB0aW1lc1xuICBmb3IgKGNvbnN0IGVxIG9mIGVxU2V0KSB7XG4gICAgaWYgKGd0ICYmICFzYXRpc2ZpZXMoZXEsIFN0cmluZyhndCksIG9wdGlvbnMpKVxuICAgICAgcmV0dXJuIG51bGxcblxuICAgIGlmIChsdCAmJiAhc2F0aXNmaWVzKGVxLCBTdHJpbmcobHQpLCBvcHRpb25zKSlcbiAgICAgIHJldHVybiBudWxsXG5cbiAgICBmb3IgKGNvbnN0IGMgb2YgZG9tKSB7XG4gICAgICBpZiAoIXNhdGlzZmllcyhlcSwgU3RyaW5nKGMpLCBvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGxldCBoaWdoZXIsIGxvd2VyXG4gIGxldCBoYXNEb21MVCwgaGFzRG9tR1RcbiAgLy8gaWYgdGhlIHN1YnNldCBoYXMgYSBwcmVyZWxlYXNlLCB3ZSBuZWVkIGEgY29tcGFyYXRvciBpbiB0aGUgc3VwZXJzZXRcbiAgLy8gd2l0aCB0aGUgc2FtZSB0dXBsZSBhbmQgYSBwcmVyZWxlYXNlLCBvciBpdCdzIG5vdCBhIHN1YnNldFxuICBsZXQgbmVlZERvbUxUUHJlID0gbHQgJiZcbiAgICAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJlxuICAgIGx0LnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA/IGx0LnNlbXZlciA6IGZhbHNlXG4gIGxldCBuZWVkRG9tR1RQcmUgPSBndCAmJlxuICAgICFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgZ3Quc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID8gZ3Quc2VtdmVyIDogZmFsc2VcbiAgLy8gZXhjZXB0aW9uOiA8MS4yLjMtMCBpcyB0aGUgc2FtZSBhcyA8MS4yLjNcbiAgaWYgKG5lZWREb21MVFByZSAmJiBuZWVkRG9tTFRQcmUucHJlcmVsZWFzZS5sZW5ndGggPT09IDEgJiZcbiAgICAgIGx0Lm9wZXJhdG9yID09PSAnPCcgJiYgbmVlZERvbUxUUHJlLnByZXJlbGVhc2VbMF0gPT09IDApIHtcbiAgICBuZWVkRG9tTFRQcmUgPSBmYWxzZVxuICB9XG5cbiAgZm9yIChjb25zdCBjIG9mIGRvbSkge1xuICAgIGhhc0RvbUdUID0gaGFzRG9tR1QgfHwgYy5vcGVyYXRvciA9PT0gJz4nIHx8IGMub3BlcmF0b3IgPT09ICc+PSdcbiAgICBoYXNEb21MVCA9IGhhc0RvbUxUIHx8IGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nXG4gICAgaWYgKGd0KSB7XG4gICAgICBpZiAobmVlZERvbUdUUHJlKSB7XG4gICAgICAgIGlmIChjLnNlbXZlci5wcmVyZWxlYXNlICYmIGMuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICBjLnNlbXZlci5tYWpvciA9PT0gbmVlZERvbUdUUHJlLm1ham9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5taW5vciA9PT0gbmVlZERvbUdUUHJlLm1pbm9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5wYXRjaCA9PT0gbmVlZERvbUdUUHJlLnBhdGNoKSB7XG4gICAgICAgICAgbmVlZERvbUdUUHJlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGMub3BlcmF0b3IgPT09ICc+JyB8fCBjLm9wZXJhdG9yID09PSAnPj0nKSB7XG4gICAgICAgIGhpZ2hlciA9IGhpZ2hlckdUKGd0LCBjLCBvcHRpb25zKVxuICAgICAgICBpZiAoaGlnaGVyID09PSBjICYmIGhpZ2hlciAhPT0gZ3QpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9IGVsc2UgaWYgKGd0Lm9wZXJhdG9yID09PSAnPj0nICYmICFzYXRpc2ZpZXMoZ3Quc2VtdmVyLCBTdHJpbmcoYyksIG9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKGx0KSB7XG4gICAgICBpZiAobmVlZERvbUxUUHJlKSB7XG4gICAgICAgIGlmIChjLnNlbXZlci5wcmVyZWxlYXNlICYmIGMuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICBjLnNlbXZlci5tYWpvciA9PT0gbmVlZERvbUxUUHJlLm1ham9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5taW5vciA9PT0gbmVlZERvbUxUUHJlLm1pbm9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5wYXRjaCA9PT0gbmVlZERvbUxUUHJlLnBhdGNoKSB7XG4gICAgICAgICAgbmVlZERvbUxUUHJlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nKSB7XG4gICAgICAgIGxvd2VyID0gbG93ZXJMVChsdCwgYywgb3B0aW9ucylcbiAgICAgICAgaWYgKGxvd2VyID09PSBjICYmIGxvd2VyICE9PSBsdClcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0gZWxzZSBpZiAobHQub3BlcmF0b3IgPT09ICc8PScgJiYgIXNhdGlzZmllcyhsdC5zZW12ZXIsIFN0cmluZyhjKSwgb3B0aW9ucykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAoIWMub3BlcmF0b3IgJiYgKGx0IHx8IGd0KSAmJiBndGx0Q29tcCAhPT0gMClcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gaWYgdGhlcmUgd2FzIGEgPCBvciA+LCBhbmQgbm90aGluZyBpbiB0aGUgZG9tLCB0aGVuIG11c3QgYmUgZmFsc2VcbiAgLy8gVU5MRVNTIGl0IHdhcyBsaW1pdGVkIGJ5IGFub3RoZXIgcmFuZ2UgaW4gdGhlIG90aGVyIGRpcmVjdGlvbi5cbiAgLy8gRWcsID4xLjAuMCA8MS4wLjEgaXMgc3RpbGwgYSBzdWJzZXQgb2YgPDIuMC4wXG4gIGlmIChndCAmJiBoYXNEb21MVCAmJiAhbHQgJiYgZ3RsdENvbXAgIT09IDApXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgaWYgKGx0ICYmIGhhc0RvbUdUICYmICFndCAmJiBndGx0Q29tcCAhPT0gMClcbiAgICByZXR1cm4gZmFsc2VcblxuICAvLyB3ZSBuZWVkZWQgYSBwcmVyZWxlYXNlIHJhbmdlIGluIGEgc3BlY2lmaWMgdHVwbGUsIGJ1dCBkaWRuJ3QgZ2V0IG9uZVxuICAvLyB0aGVuIHRoaXMgaXNuJ3QgYSBzdWJzZXQuICBlZyA+PTEuMi4zLXByZSBpcyBub3QgYSBzdWJzZXQgb2YgPj0xLjAuMCxcbiAgLy8gYmVjYXVzZSBpdCBpbmNsdWRlcyBwcmVyZWxlYXNlcyBpbiB0aGUgMS4yLjMgdHVwbGVcbiAgaWYgKG5lZWREb21HVFByZSB8fCBuZWVkRG9tTFRQcmUpXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gPj0xLjIuMyBpcyBsb3dlciB0aGFuID4xLjIuM1xuY29uc3QgaGlnaGVyR1QgPSAoYSwgYiwgb3B0aW9ucykgPT4ge1xuICBpZiAoIWEpXG4gICAgcmV0dXJuIGJcbiAgY29uc3QgY29tcCA9IGNvbXBhcmUoYS5zZW12ZXIsIGIuc2VtdmVyLCBvcHRpb25zKVxuICByZXR1cm4gY29tcCA+IDAgPyBhXG4gICAgOiBjb21wIDwgMCA/IGJcbiAgICA6IGIub3BlcmF0b3IgPT09ICc+JyAmJiBhLm9wZXJhdG9yID09PSAnPj0nID8gYlxuICAgIDogYVxufVxuXG4vLyA8PTEuMi4zIGlzIGhpZ2hlciB0aGFuIDwxLjIuM1xuY29uc3QgbG93ZXJMVCA9IChhLCBiLCBvcHRpb25zKSA9PiB7XG4gIGlmICghYSlcbiAgICByZXR1cm4gYlxuICBjb25zdCBjb21wID0gY29tcGFyZShhLnNlbXZlciwgYi5zZW12ZXIsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wIDwgMCA/IGFcbiAgICA6IGNvbXAgPiAwID8gYlxuICAgIDogYi5vcGVyYXRvciA9PT0gJzwnICYmIGEub3BlcmF0b3IgPT09ICc8PScgPyBiXG4gICAgOiBhXG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3Vic2V0XG4iLCIvLyBqdXN0IHByZS1sb2FkIGFsbCB0aGUgc3R1ZmYgdGhhdCBpbmRleC5qcyBsYXppbHkgZXhwb3J0c1xuY29uc3QgaW50ZXJuYWxSZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvcmUnKVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlOiBpbnRlcm5hbFJlLnJlLFxuICBzcmM6IGludGVybmFsUmUuc3JjLFxuICB0b2tlbnM6IGludGVybmFsUmUudCxcbiAgU0VNVkVSX1NQRUNfVkVSU0lPTjogcmVxdWlyZSgnLi9pbnRlcm5hbC9jb25zdGFudHMnKS5TRU1WRVJfU1BFQ19WRVJTSU9OLFxuICBTZW1WZXI6IHJlcXVpcmUoJy4vY2xhc3Nlcy9zZW12ZXInKSxcbiAgY29tcGFyZUlkZW50aWZpZXJzOiByZXF1aXJlKCcuL2ludGVybmFsL2lkZW50aWZpZXJzJykuY29tcGFyZUlkZW50aWZpZXJzLFxuICByY29tcGFyZUlkZW50aWZpZXJzOiByZXF1aXJlKCcuL2ludGVybmFsL2lkZW50aWZpZXJzJykucmNvbXBhcmVJZGVudGlmaWVycyxcbiAgcGFyc2U6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3BhcnNlJyksXG4gIHZhbGlkOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy92YWxpZCcpLFxuICBjbGVhbjogcmVxdWlyZSgnLi9mdW5jdGlvbnMvY2xlYW4nKSxcbiAgaW5jOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9pbmMnKSxcbiAgZGlmZjogcmVxdWlyZSgnLi9mdW5jdGlvbnMvZGlmZicpLFxuICBtYWpvcjogcmVxdWlyZSgnLi9mdW5jdGlvbnMvbWFqb3InKSxcbiAgbWlub3I6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL21pbm9yJyksXG4gIHBhdGNoOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wYXRjaCcpLFxuICBwcmVyZWxlYXNlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wcmVyZWxlYXNlJyksXG4gIGNvbXBhcmU6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvbXBhcmUnKSxcbiAgcmNvbXBhcmU6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3Jjb21wYXJlJyksXG4gIGNvbXBhcmVMb29zZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29tcGFyZS1sb29zZScpLFxuICBjb21wYXJlQnVpbGQ6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvbXBhcmUtYnVpbGQnKSxcbiAgc29ydDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvc29ydCcpLFxuICByc29ydDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvcnNvcnQnKSxcbiAgZ3Q6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2d0JyksXG4gIGx0OiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9sdCcpLFxuICBlcTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvZXEnKSxcbiAgbmVxOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9uZXEnKSxcbiAgZ3RlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9ndGUnKSxcbiAgbHRlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9sdGUnKSxcbiAgY21wOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jbXAnKSxcbiAgY29lcmNlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb2VyY2UnKSxcbiAgQ29tcGFyYXRvcjogcmVxdWlyZSgnLi9jbGFzc2VzL2NvbXBhcmF0b3InKSxcbiAgUmFuZ2U6IHJlcXVpcmUoJy4vY2xhc3Nlcy9yYW5nZScpLFxuICBzYXRpc2ZpZXM6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3NhdGlzZmllcycpLFxuICB0b0NvbXBhcmF0b3JzOiByZXF1aXJlKCcuL3Jhbmdlcy90by1jb21wYXJhdG9ycycpLFxuICBtYXhTYXRpc2Z5aW5nOiByZXF1aXJlKCcuL3Jhbmdlcy9tYXgtc2F0aXNmeWluZycpLFxuICBtaW5TYXRpc2Z5aW5nOiByZXF1aXJlKCcuL3Jhbmdlcy9taW4tc2F0aXNmeWluZycpLFxuICBtaW5WZXJzaW9uOiByZXF1aXJlKCcuL3Jhbmdlcy9taW4tdmVyc2lvbicpLFxuICB2YWxpZFJhbmdlOiByZXF1aXJlKCcuL3Jhbmdlcy92YWxpZCcpLFxuICBvdXRzaWRlOiByZXF1aXJlKCcuL3Jhbmdlcy9vdXRzaWRlJyksXG4gIGd0cjogcmVxdWlyZSgnLi9yYW5nZXMvZ3RyJyksXG4gIGx0cjogcmVxdWlyZSgnLi9yYW5nZXMvbHRyJyksXG4gIGludGVyc2VjdHM6IHJlcXVpcmUoJy4vcmFuZ2VzL2ludGVyc2VjdHMnKSxcbiAgc2ltcGxpZnlSYW5nZTogcmVxdWlyZSgnLi9yYW5nZXMvc2ltcGxpZnknKSxcbiAgc3Vic2V0OiByZXF1aXJlKCcuL3Jhbmdlcy9zdWJzZXQnKSxcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgbWltaWNGbiA9ICh0bywgZnJvbSkgPT4ge1xuXHRmb3IgKGNvbnN0IHByb3Agb2YgUmVmbGVjdC5vd25LZXlzKGZyb20pKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCBwcm9wLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGZyb20sIHByb3ApKTtcblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWltaWNGbjtcbi8vIFRPRE86IFJlbW92ZSB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbWltaWNGbjtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IG1pbWljRm4gPSByZXF1aXJlKCdtaW1pYy1mbicpO1xuXG5jb25zdCBjYWxsZWRGdW5jdGlvbnMgPSBuZXcgV2Vha01hcCgpO1xuXG5jb25zdCBvbmV0aW1lID0gKGZ1bmN0aW9uXywgb3B0aW9ucyA9IHt9KSA9PiB7XG5cdGlmICh0eXBlb2YgZnVuY3Rpb25fICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBmdW5jdGlvbicpO1xuXHR9XG5cblx0bGV0IHJldHVyblZhbHVlO1xuXHRsZXQgY2FsbENvdW50ID0gMDtcblx0Y29uc3QgZnVuY3Rpb25OYW1lID0gZnVuY3Rpb25fLmRpc3BsYXlOYW1lIHx8IGZ1bmN0aW9uXy5uYW1lIHx8ICc8YW5vbnltb3VzPic7XG5cblx0Y29uc3Qgb25ldGltZSA9IGZ1bmN0aW9uICguLi5hcmd1bWVudHNfKSB7XG5cdFx0Y2FsbGVkRnVuY3Rpb25zLnNldChvbmV0aW1lLCArK2NhbGxDb3VudCk7XG5cblx0XHRpZiAoY2FsbENvdW50ID09PSAxKSB7XG5cdFx0XHRyZXR1cm5WYWx1ZSA9IGZ1bmN0aW9uXy5hcHBseSh0aGlzLCBhcmd1bWVudHNfKTtcblx0XHRcdGZ1bmN0aW9uXyA9IG51bGw7XG5cdFx0fSBlbHNlIGlmIChvcHRpb25zLnRocm93ID09PSB0cnVlKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEZ1bmN0aW9uIFxcYCR7ZnVuY3Rpb25OYW1lfVxcYCBjYW4gb25seSBiZSBjYWxsZWQgb25jZWApO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0fTtcblxuXHRtaW1pY0ZuKG9uZXRpbWUsIGZ1bmN0aW9uXyk7XG5cdGNhbGxlZEZ1bmN0aW9ucy5zZXQob25ldGltZSwgY2FsbENvdW50KTtcblxuXHRyZXR1cm4gb25ldGltZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gb25ldGltZTtcbi8vIFRPRE86IFJlbW92ZSB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gb25ldGltZTtcblxubW9kdWxlLmV4cG9ydHMuY2FsbENvdW50ID0gZnVuY3Rpb25fID0+IHtcblx0aWYgKCFjYWxsZWRGdW5jdGlvbnMuaGFzKGZ1bmN0aW9uXykpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYFRoZSBnaXZlbiBmdW5jdGlvbiBcXGAke2Z1bmN0aW9uXy5uYW1lfVxcYCBpcyBub3Qgd3JhcHBlZCBieSB0aGUgXFxgb25ldGltZVxcYCBwYWNrYWdlYCk7XG5cdH1cblxuXHRyZXR1cm4gY2FsbGVkRnVuY3Rpb25zLmdldChmdW5jdGlvbl8pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9hLCBfYjtcbnZhciBfQ29uZl92YWxpZGF0b3IsIF9Db25mX2VuY3J5cHRpb25LZXksIF9Db25mX29wdGlvbnMsIF9Db25mX2RlZmF1bHRWYWx1ZXM7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBkb3RQcm9wID0gcmVxdWlyZShcImRvdC1wcm9wXCIpO1xuY29uc3QgcGtnVXAgPSByZXF1aXJlKFwicGtnLXVwXCIpO1xuY29uc3QgZW52UGF0aHMgPSByZXF1aXJlKFwiZW52LXBhdGhzXCIpO1xuY29uc3QgYXRvbWljYWxseSA9IHJlcXVpcmUoXCJhdG9taWNhbGx5XCIpO1xuY29uc3QgYWp2XzEgPSByZXF1aXJlKFwiYWp2XCIpO1xuY29uc3QgYWp2X2Zvcm1hdHNfMSA9IHJlcXVpcmUoXCJhanYtZm9ybWF0c1wiKTtcbmNvbnN0IGRlYm91bmNlRm4gPSByZXF1aXJlKFwiZGVib3VuY2UtZm5cIik7XG5jb25zdCBzZW12ZXIgPSByZXF1aXJlKFwic2VtdmVyXCIpO1xuY29uc3Qgb25ldGltZSA9IHJlcXVpcmUoXCJvbmV0aW1lXCIpO1xuY29uc3QgZW5jcnlwdGlvbkFsZ29yaXRobSA9ICdhZXMtMjU2LWNiYyc7XG5jb25zdCBjcmVhdGVQbGFpbk9iamVjdCA9ICgpID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn07XG5jb25zdCBpc0V4aXN0ID0gKGRhdGEpID0+IHtcbiAgICByZXR1cm4gZGF0YSAhPT0gdW5kZWZpbmVkICYmIGRhdGEgIT09IG51bGw7XG59O1xubGV0IHBhcmVudERpciA9ICcnO1xudHJ5IHtcbiAgICAvLyBQcmV2ZW50IGNhY2hpbmcgb2YgdGhpcyBtb2R1bGUgc28gbW9kdWxlLnBhcmVudCBpcyBhbHdheXMgYWNjdXJhdGUuXG4gICAgLy8gTm90ZTogVGhpcyB0cmljayB3b24ndCB3b3JrIHdpdGggRVNNIG9yIGluc2lkZSBhIHdlYndvcmtlclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGVcbiAgICBkZWxldGUgcmVxdWlyZS5jYWNoZVtfX2ZpbGVuYW1lXTtcbiAgICBwYXJlbnREaXIgPSBwYXRoLmRpcm5hbWUoKF9iID0gKF9hID0gbW9kdWxlLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbGVuYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnLicpO1xufVxuY2F0Y2ggKF9jKSB7IH1cbmNvbnN0IGNoZWNrVmFsdWVUeXBlID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICBjb25zdCBub25Kc29uVHlwZXMgPSBuZXcgU2V0KFtcbiAgICAgICAgJ3VuZGVmaW5lZCcsXG4gICAgICAgICdzeW1ib2wnLFxuICAgICAgICAnZnVuY3Rpb24nXG4gICAgXSk7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBpZiAobm9uSnNvblR5cGVzLmhhcyh0eXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBTZXR0aW5nIGEgdmFsdWUgb2YgdHlwZSBcXGAke3R5cGV9XFxgIGZvciBrZXkgXFxgJHtrZXl9XFxgIGlzIG5vdCBhbGxvd2VkIGFzIGl0J3Mgbm90IHN1cHBvcnRlZCBieSBKU09OYCk7XG4gICAgfVxufTtcbmNvbnN0IElOVEVSTkFMX0tFWSA9ICdfX2ludGVybmFsX18nO1xuY29uc3QgTUlHUkFUSU9OX0tFWSA9IGAke0lOVEVSTkFMX0tFWX0ubWlncmF0aW9ucy52ZXJzaW9uYDtcbmNsYXNzIENvbmYge1xuICAgIGNvbnN0cnVjdG9yKHBhcnRpYWxPcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBfQ29uZl92YWxpZGF0b3Iuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Db25mX2VuY3J5cHRpb25LZXkuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Db25mX29wdGlvbnMuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Db25mX2RlZmF1bHRWYWx1ZXMuc2V0KHRoaXMsIHt9KTtcbiAgICAgICAgdGhpcy5fZGVzZXJpYWxpemUgPSB2YWx1ZSA9PiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgdGhpcy5fc2VyaWFsaXplID0gdmFsdWUgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIHVuZGVmaW5lZCwgJ1xcdCcpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgY29uZmlnTmFtZTogJ2NvbmZpZycsXG4gICAgICAgICAgICBmaWxlRXh0ZW5zaW9uOiAnanNvbicsXG4gICAgICAgICAgICBwcm9qZWN0U3VmZml4OiAnbm9kZWpzJyxcbiAgICAgICAgICAgIGNsZWFySW52YWxpZENvbmZpZzogZmFsc2UsXG4gICAgICAgICAgICBhY2Nlc3NQcm9wZXJ0aWVzQnlEb3ROb3RhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIC4uLnBhcnRpYWxPcHRpb25zXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGdldFBhY2thZ2VEYXRhID0gb25ldGltZSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYWNrYWdlUGF0aCA9IHBrZ1VwLnN5bmMoeyBjd2Q6IHBhcmVudERpciB9KTtcbiAgICAgICAgICAgIC8vIENhbid0IHVzZSBgcmVxdWlyZWAgYmVjYXVzZSBvZiBXZWJwYWNrIGJlaW5nIGFubm95aW5nOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay9pc3N1ZXMvMTk2XG4gICAgICAgICAgICBjb25zdCBwYWNrYWdlRGF0YSA9IHBhY2thZ2VQYXRoICYmIEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKHBhY2thZ2VQYXRoLCAndXRmOCcpKTtcbiAgICAgICAgICAgIHJldHVybiBwYWNrYWdlRGF0YSAhPT0gbnVsbCAmJiBwYWNrYWdlRGF0YSAhPT0gdm9pZCAwID8gcGFja2FnZURhdGEgOiB7fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghb3B0aW9ucy5jd2QpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wcm9qZWN0TmFtZSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucHJvamVjdE5hbWUgPSBnZXRQYWNrYWdlRGF0YSgpLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMucHJvamVjdE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3QgbmFtZSBjb3VsZCBub3QgYmUgaW5mZXJyZWQuIFBsZWFzZSBzcGVjaWZ5IHRoZSBgcHJvamVjdE5hbWVgIG9wdGlvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMuY3dkID0gZW52UGF0aHMob3B0aW9ucy5wcm9qZWN0TmFtZSwgeyBzdWZmaXg6IG9wdGlvbnMucHJvamVjdFN1ZmZpeCB9KS5jb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ29uZl9vcHRpb25zLCBvcHRpb25zLCBcImZcIik7XG4gICAgICAgIGlmIChvcHRpb25zLnNjaGVtYSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnNjaGVtYSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgYHNjaGVtYWAgb3B0aW9uIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWp2ID0gbmV3IGFqdl8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgICAgIGFsbEVycm9yczogdHJ1ZSxcbiAgICAgICAgICAgICAgICB1c2VEZWZhdWx0czogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhanZfZm9ybWF0c18xLmRlZmF1bHQoYWp2KTtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBvcHRpb25zLnNjaGVtYVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NvbmZfdmFsaWRhdG9yLCBhanYuY29tcGlsZShzY2hlbWEpLCBcImZcIik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zLnNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9kZWZhdWx0VmFsdWVzLCBcImZcIilba2V5XSA9IHZhbHVlLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Db25mX2RlZmF1bHRWYWx1ZXMsIHtcbiAgICAgICAgICAgICAgICAuLi5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX2RlZmF1bHRWYWx1ZXMsIFwiZlwiKSxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLmRlZmF1bHRzXG4gICAgICAgICAgICB9LCBcImZcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc2VyaWFsaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXJpYWxpemUgPSBvcHRpb25zLnNlcmlhbGl6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5kZXNlcmlhbGl6ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGVzZXJpYWxpemUgPSBvcHRpb25zLmRlc2VyaWFsaXplO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRzID0gbmV3IGV2ZW50c18xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Db25mX2VuY3J5cHRpb25LZXksIG9wdGlvbnMuZW5jcnlwdGlvbktleSwgXCJmXCIpO1xuICAgICAgICBjb25zdCBmaWxlRXh0ZW5zaW9uID0gb3B0aW9ucy5maWxlRXh0ZW5zaW9uID8gYC4ke29wdGlvbnMuZmlsZUV4dGVuc2lvbn1gIDogJyc7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGgucmVzb2x2ZShvcHRpb25zLmN3ZCwgYCR7KF9hID0gb3B0aW9ucy5jb25maWdOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnY29uZmlnJ30ke2ZpbGVFeHRlbnNpb259YCk7XG4gICAgICAgIGNvbnN0IGZpbGVTdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gT2JqZWN0LmFzc2lnbihjcmVhdGVQbGFpbk9iamVjdCgpLCBvcHRpb25zLmRlZmF1bHRzLCBmaWxlU3RvcmUpO1xuICAgICAgICB0aGlzLl92YWxpZGF0ZShzdG9yZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKGZpbGVTdG9yZSwgc3RvcmUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYikge1xuICAgICAgICAgICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLndhdGNoKSB7XG4gICAgICAgICAgICB0aGlzLl93YXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm1pZ3JhdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wcm9qZWN0VmVyc2lvbikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucHJvamVjdFZlcnNpb24gPSBnZXRQYWNrYWdlRGF0YSgpLnZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMucHJvamVjdFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3QgdmVyc2lvbiBjb3VsZCBub3QgYmUgaW5mZXJyZWQuIFBsZWFzZSBzcGVjaWZ5IHRoZSBgcHJvamVjdFZlcnNpb25gIG9wdGlvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21pZ3JhdGUob3B0aW9ucy5taWdyYXRpb25zLCBvcHRpb25zLnByb2plY3RWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfb3B0aW9ucywgXCJmXCIpLmFjY2Vzc1Byb3BlcnRpZXNCeURvdE5vdGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0KGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0b3JlIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ga2V5IGluIHN0b3JlID8gc3RvcmVba2V5XSA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBrZXkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBrZXlcXGAgdG8gYmUgb2YgdHlwZSBcXGBzdHJpbmdcXGAgb3IgXFxgb2JqZWN0XFxgLCBnb3QgJHt0eXBlb2Yga2V5fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnb2JqZWN0JyAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVc2UgYGRlbGV0ZSgpYCB0byBjbGVhciB2YWx1ZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY29udGFpbnNSZXNlcnZlZEtleShrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQbGVhc2UgZG9uJ3QgdXNlIHRoZSAke0lOVEVSTkFMX0tFWX0ga2V5LCBhcyBpdCdzIHVzZWQgdG8gbWFuYWdlIHRoaXMgbW9kdWxlIGludGVybmFsIG9wZXJhdGlvbnMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdG9yZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc2V0ID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNoZWNrVmFsdWVUeXBlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfb3B0aW9ucywgXCJmXCIpLmFjY2Vzc1Byb3BlcnRpZXNCeURvdE5vdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZG90UHJvcC5zZXQoc3RvcmUsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RvcmVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdCA9IGtleTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICBzZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayBpZiBhbiBpdGVtIGV4aXN0cy5cblxuICAgIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIGNoZWNrLlxuICAgICovXG4gICAgaGFzKGtleSkge1xuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9vcHRpb25zLCBcImZcIikuYWNjZXNzUHJvcGVydGllc0J5RG90Tm90YXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBkb3RQcm9wLmhhcyh0aGlzLnN0b3JlLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXkgaW4gdGhpcy5zdG9yZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVzZXQgaXRlbXMgdG8gdGhlaXIgZGVmYXVsdCB2YWx1ZXMsIGFzIGRlZmluZWQgYnkgdGhlIGBkZWZhdWx0c2Agb3IgYHNjaGVtYWAgb3B0aW9uLlxuXG4gICAgQHNlZSBgY2xlYXIoKWAgdG8gcmVzZXQgYWxsIGl0ZW1zLlxuXG4gICAgQHBhcmFtIGtleXMgLSBUaGUga2V5cyBvZiB0aGUgaXRlbXMgdG8gcmVzZXQuXG4gICAgKi9cbiAgICByZXNldCguLi5rZXlzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIGlmIChpc0V4aXN0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZGVmYXVsdFZhbHVlcywgXCJmXCIpW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX2RlZmF1bHRWYWx1ZXMsIFwiZlwiKVtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBEZWxldGUgYW4gaXRlbS5cblxuICAgIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIGRlbGV0ZS5cbiAgICAqL1xuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgY29uc3QgeyBzdG9yZSB9ID0gdGhpcztcbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfb3B0aW9ucywgXCJmXCIpLmFjY2Vzc1Byb3BlcnRpZXNCeURvdE5vdGF0aW9uKSB7XG4gICAgICAgICAgICBkb3RQcm9wLmRlbGV0ZShzdG9yZSwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGVcbiAgICAgICAgICAgIGRlbGV0ZSBzdG9yZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVsZXRlIGFsbCBpdGVtcy5cblxuICAgIFRoaXMgcmVzZXRzIGtub3duIGl0ZW1zIHRvIHRoZWlyIGRlZmF1bHQgdmFsdWVzLCBpZiBkZWZpbmVkIGJ5IHRoZSBgZGVmYXVsdHNgIG9yIGBzY2hlbWFgIG9wdGlvbi5cbiAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnN0b3JlID0gY3JlYXRlUGxhaW5PYmplY3QoKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9kZWZhdWx0VmFsdWVzLCBcImZcIikpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgV2F0Y2hlcyB0aGUgZ2l2ZW4gYGtleWAsIGNhbGxpbmcgYGNhbGxiYWNrYCBvbiBhbnkgY2hhbmdlcy5cblxuICAgIEBwYXJhbSBrZXkgLSBUaGUga2V5IHdvIHdhdGNoLlxuICAgIEBwYXJhbSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgb24gYW55IGNoYW5nZXMuIFdoZW4gYSBga2V5YCBpcyBmaXJzdCBzZXQgYG9sZFZhbHVlYCB3aWxsIGJlIGB1bmRlZmluZWRgLCBhbmQgd2hlbiBhIGtleSBpcyBkZWxldGVkIGBuZXdWYWx1ZWAgd2lsbCBiZSBgdW5kZWZpbmVkYC5cbiAgICBAcmV0dXJucyBBIGZ1bmN0aW9uLCB0aGF0IHdoZW4gY2FsbGVkLCB3aWxsIHVuc3Vic2NyaWJlLlxuICAgICovXG4gICAgb25EaWRDaGFuZ2Uoa2V5LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFxcYGtleVxcYCB0byBiZSBvZiB0eXBlIFxcYHN0cmluZ1xcYCwgZ290ICR7dHlwZW9mIGtleX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBjYWxsYmFja1xcYCB0byBiZSBvZiB0eXBlIFxcYGZ1bmN0aW9uXFxgLCBnb3QgJHt0eXBlb2YgY2FsbGJhY2t9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUNoYW5nZSgoKSA9PiB0aGlzLmdldChrZXkpLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgIFdhdGNoZXMgdGhlIHdob2xlIGNvbmZpZyBvYmplY3QsIGNhbGxpbmcgYGNhbGxiYWNrYCBvbiBhbnkgY2hhbmdlcy5cblxuICAgIEBwYXJhbSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgb24gYW55IGNoYW5nZXMuIFdoZW4gYSBga2V5YCBpcyBmaXJzdCBzZXQgYG9sZFZhbHVlYCB3aWxsIGJlIGB1bmRlZmluZWRgLCBhbmQgd2hlbiBhIGtleSBpcyBkZWxldGVkIGBuZXdWYWx1ZWAgd2lsbCBiZSBgdW5kZWZpbmVkYC5cbiAgICBAcmV0dXJucyBBIGZ1bmN0aW9uLCB0aGF0IHdoZW4gY2FsbGVkLCB3aWxsIHVuc3Vic2NyaWJlLlxuICAgICovXG4gICAgb25EaWRBbnlDaGFuZ2UoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgY2FsbGJhY2tcXGAgdG8gYmUgb2YgdHlwZSBcXGBmdW5jdGlvblxcYCwgZ290ICR7dHlwZW9mIGNhbGxiYWNrfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVDaGFuZ2UoKCkgPT4gdGhpcy5zdG9yZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc3RvcmUpLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0IHN0b3JlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGZzLnJlYWRGaWxlU3luYyh0aGlzLnBhdGgsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZW5jcnlwdGlvbktleSwgXCJmXCIpID8gbnVsbCA6ICd1dGY4Jyk7XG4gICAgICAgICAgICBjb25zdCBkYXRhU3RyaW5nID0gdGhpcy5fZW5jcnlwdERhdGEoZGF0YSk7XG4gICAgICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZWREYXRhID0gdGhpcy5fZGVzZXJpYWxpemUoZGF0YVN0cmluZyk7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0ZShkZXNlcmlhbGl6ZWREYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGNyZWF0ZVBsYWluT2JqZWN0KCksIGRlc2VyaWFsaXplZERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5zdXJlRGlyZWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVBsYWluT2JqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9vcHRpb25zLCBcImZcIikuY2xlYXJJbnZhbGlkQ29uZmlnICYmIGVycm9yLm5hbWUgPT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUGxhaW5PYmplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldCBzdG9yZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9lbnN1cmVEaXJlY3RvcnkoKTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGUodmFsdWUpO1xuICAgICAgICB0aGlzLl93cml0ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ2NoYW5nZScpO1xuICAgIH1cbiAgICAqWyhfQ29uZl92YWxpZGF0b3IgPSBuZXcgV2Vha01hcCgpLCBfQ29uZl9lbmNyeXB0aW9uS2V5ID0gbmV3IFdlYWtNYXAoKSwgX0NvbmZfb3B0aW9ucyA9IG5ldyBXZWFrTWFwKCksIF9Db25mX2RlZmF1bHRWYWx1ZXMgPSBuZXcgV2Vha01hcCgpLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5zdG9yZSkpIHtcbiAgICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZW5jcnlwdERhdGEoZGF0YSkge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZW5jcnlwdGlvbktleSwgXCJmXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBhbiBpbml0aWFsaXphdGlvbiB2ZWN0b3IgaGFzIGJlZW4gdXNlZCB0byBlbmNyeXB0IHRoZSBkYXRhXG4gICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBcImZcIikpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5zbGljZSgxNiwgMTcpLnRvU3RyaW5nKCkgPT09ICc6Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhbGl6YXRpb25WZWN0b3IgPSBkYXRhLnNsaWNlKDAsIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhc3N3b3JkID0gY3J5cHRvLnBia2RmMlN5bmMoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBcImZcIiksIGluaXRpYWxpemF0aW9uVmVjdG9yLnRvU3RyaW5nKCksIDEwMDAwLCAzMiwgJ3NoYTUxMicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihlbmNyeXB0aW9uQWxnb3JpdGhtLCBwYXNzd29yZCwgaW5pdGlhbGl6YXRpb25WZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IEJ1ZmZlci5jb25jYXQoW2RlY2lwaGVyLnVwZGF0ZShCdWZmZXIuZnJvbShkYXRhLnNsaWNlKDE3KSkpLCBkZWNpcGhlci5maW5hbCgpXSkudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyKGVuY3J5cHRpb25BbGdvcml0aG0sIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZW5jcnlwdGlvbktleSwgXCJmXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBCdWZmZXIuY29uY2F0KFtkZWNpcGhlci51cGRhdGUoQnVmZmVyLmZyb20oZGF0YSkpLCBkZWNpcGhlci5maW5hbCgpXSkudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYikgeyB9XG4gICAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIF9oYW5kbGVDaGFuZ2UoZ2V0dGVyLCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgY3VycmVudFZhbHVlID0gZ2V0dGVyKCk7XG4gICAgICAgIGNvbnN0IG9uQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGdldHRlcigpO1xuICAgICAgICAgICAgaWYgKHV0aWxfMS5pc0RlZXBTdHJpY3RFcXVhbChuZXdWYWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB0aGlzLmV2ZW50cy5yZW1vdmVMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIH1cbiAgICBfdmFsaWRhdGUoZGF0YSkge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfdmFsaWRhdG9yLCBcImZcIikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfdmFsaWRhdG9yLCBcImZcIikuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICAgICAgaWYgKHZhbGlkIHx8ICFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX3ZhbGlkYXRvciwgXCJmXCIpLmVycm9ycykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfdmFsaWRhdG9yLCBcImZcIikuZXJyb3JzXG4gICAgICAgICAgICAubWFwKCh7IGluc3RhbmNlUGF0aCwgbWVzc2FnZSA9ICcnIH0pID0+IGBcXGAke2luc3RhbmNlUGF0aC5zbGljZSgxKX1cXGAgJHttZXNzYWdlfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmZpZyBzY2hlbWEgdmlvbGF0aW9uOiAnICsgZXJyb3JzLmpvaW4oJzsgJykpO1xuICAgIH1cbiAgICBfZW5zdXJlRGlyZWN0b3J5KCkge1xuICAgICAgICAvLyBFbnN1cmUgdGhlIGRpcmVjdG9yeSBleGlzdHMgYXMgaXQgY291bGQgaGF2ZSBiZWVuIGRlbGV0ZWQgaW4gdGhlIG1lYW50aW1lLlxuICAgICAgICBmcy5ta2RpclN5bmMocGF0aC5kaXJuYW1lKHRoaXMucGF0aCksIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIH1cbiAgICBfd3JpdGUodmFsdWUpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLl9zZXJpYWxpemUodmFsdWUpO1xuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBcImZcIikpIHtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxpemF0aW9uVmVjdG9yID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KTtcbiAgICAgICAgICAgIGNvbnN0IHBhc3N3b3JkID0gY3J5cHRvLnBia2RmMlN5bmMoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBcImZcIiksIGluaXRpYWxpemF0aW9uVmVjdG9yLnRvU3RyaW5nKCksIDEwMDAwLCAzMiwgJ3NoYTUxMicpO1xuICAgICAgICAgICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KGVuY3J5cHRpb25BbGdvcml0aG0sIHBhc3N3b3JkLCBpbml0aWFsaXphdGlvblZlY3Rvcik7XG4gICAgICAgICAgICBkYXRhID0gQnVmZmVyLmNvbmNhdChbaW5pdGlhbGl6YXRpb25WZWN0b3IsIEJ1ZmZlci5mcm9tKCc6JyksIGNpcGhlci51cGRhdGUoQnVmZmVyLmZyb20oZGF0YSkpLCBjaXBoZXIuZmluYWwoKV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlbXBvcmFyeSB3b3JrYXJvdW5kIGZvciBDb25mIGJlaW5nIHBhY2thZ2VkIGluIGEgVWJ1bnR1IFNuYXAgYXBwLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9jb25mL3B1bGwvODJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52LlNOQVApIHtcbiAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmModGhpcy5wYXRoLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXRvbWljYWxseS53cml0ZUZpbGVTeW5jKHRoaXMucGF0aCwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBGaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvZWxlY3Ryb24tc3RvcmUvaXNzdWVzLzEwNlxuICAgICAgICAgICAgICAgIC8vIFNvbWV0aW1lcyBvbiBXaW5kb3dzLCB3ZSB3aWxsIGdldCBhbiBFWERFViBlcnJvciB3aGVuIGF0b21pYyB3cml0aW5nXG4gICAgICAgICAgICAgICAgLy8gKGV2ZW4gdGhvdWdoIHRvIHRoZSBzYW1lIGRpcmVjdG9yeSksIHNvIHdlIGZhbGwgYmFjayB0byBub24gYXRvbWljIHdyaXRlXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICdFWERFVicpIHtcbiAgICAgICAgICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyh0aGlzLnBhdGgsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF93YXRjaCgpIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlRGlyZWN0b3J5KCk7XG4gICAgICAgIGlmICghZnMuZXhpc3RzU3luYyh0aGlzLnBhdGgpKSB7XG4gICAgICAgICAgICB0aGlzLl93cml0ZShjcmVhdGVQbGFpbk9iamVjdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgICAgICAgICAgZnMud2F0Y2godGhpcy5wYXRoLCB7IHBlcnNpc3RlbnQ6IGZhbHNlIH0sIGRlYm91bmNlRm4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIE9uIExpbnV4IGFuZCBXaW5kb3dzLCB3cml0aW5nIHRvIHRoZSBjb25maWcgZmlsZSBlbWl0cyBhIGByZW5hbWVgIGV2ZW50LCBzbyB3ZSBza2lwIGNoZWNraW5nIHRoZSBldmVudCB0eXBlLlxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ2NoYW5nZScpO1xuICAgICAgICAgICAgfSwgeyB3YWl0OiAxMDAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnMud2F0Y2hGaWxlKHRoaXMucGF0aCwgeyBwZXJzaXN0ZW50OiBmYWxzZSB9LCBkZWJvdW5jZUZuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KCdjaGFuZ2UnKTtcbiAgICAgICAgICAgIH0sIHsgd2FpdDogNTAwMCB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX21pZ3JhdGUobWlncmF0aW9ucywgdmVyc2lvblRvTWlncmF0ZSkge1xuICAgICAgICBsZXQgcHJldmlvdXNNaWdyYXRlZFZlcnNpb24gPSB0aGlzLl9nZXQoTUlHUkFUSU9OX0tFWSwgJzAuMC4wJyk7XG4gICAgICAgIGNvbnN0IG5ld2VyVmVyc2lvbnMgPSBPYmplY3Qua2V5cyhtaWdyYXRpb25zKVxuICAgICAgICAgICAgLmZpbHRlcihjYW5kaWRhdGVWZXJzaW9uID0+IHRoaXMuX3Nob3VsZFBlcmZvcm1NaWdyYXRpb24oY2FuZGlkYXRlVmVyc2lvbiwgcHJldmlvdXNNaWdyYXRlZFZlcnNpb24sIHZlcnNpb25Ub01pZ3JhdGUpKTtcbiAgICAgICAgbGV0IHN0b3JlQmFja3VwID0geyAuLi50aGlzLnN0b3JlIH07XG4gICAgICAgIGZvciAoY29uc3QgdmVyc2lvbiBvZiBuZXdlclZlcnNpb25zKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pZ3JhdGlvbiA9IG1pZ3JhdGlvbnNbdmVyc2lvbl07XG4gICAgICAgICAgICAgICAgbWlncmF0aW9uKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldChNSUdSQVRJT05fS0VZLCB2ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c01pZ3JhdGVkVmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgICAgICAgc3RvcmVCYWNrdXAgPSB7IC4uLnRoaXMuc3RvcmUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZUJhY2t1cDtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyB0aGUgbWlncmF0aW9uISBDaGFuZ2VzIGFwcGxpZWQgdG8gdGhlIHN0b3JlIHVudGlsIHRoaXMgZmFpbGVkIG1pZ3JhdGlvbiB3aWxsIGJlIHJlc3RvcmVkLiAke2Vycm9yfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pc1ZlcnNpb25JblJhbmdlRm9ybWF0KHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uKSB8fCAhc2VtdmVyLmVxKHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uLCB2ZXJzaW9uVG9NaWdyYXRlKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0KE1JR1JBVElPTl9LRVksIHZlcnNpb25Ub01pZ3JhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jb250YWluc1Jlc2VydmVkS2V5KGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnNLZXkgPSBPYmplY3Qua2V5cyhrZXkpWzBdO1xuICAgICAgICAgICAgaWYgKGZpcnNLZXkgPT09IElOVEVSTkFMX0tFWSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX29wdGlvbnMsIFwiZlwiKS5hY2Nlc3NQcm9wZXJ0aWVzQnlEb3ROb3RhdGlvbikge1xuICAgICAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKGAke0lOVEVSTkFMX0tFWX0uYCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9pc1ZlcnNpb25JblJhbmdlRm9ybWF0KHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHNlbXZlci5jbGVhbih2ZXJzaW9uKSA9PT0gbnVsbDtcbiAgICB9XG4gICAgX3Nob3VsZFBlcmZvcm1NaWdyYXRpb24oY2FuZGlkYXRlVmVyc2lvbiwgcHJldmlvdXNNaWdyYXRlZFZlcnNpb24sIHZlcnNpb25Ub01pZ3JhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVmVyc2lvbkluUmFuZ2VGb3JtYXQoY2FuZGlkYXRlVmVyc2lvbikpIHtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c01pZ3JhdGVkVmVyc2lvbiAhPT0gJzAuMC4wJyAmJiBzZW12ZXIuc2F0aXNmaWVzKHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uLCBjYW5kaWRhdGVWZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZW12ZXIuc2F0aXNmaWVzKHZlcnNpb25Ub01pZ3JhdGUsIGNhbmRpZGF0ZVZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZW12ZXIubHRlKGNhbmRpZGF0ZVZlcnNpb24sIHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZW12ZXIuZ3QoY2FuZGlkYXRlVmVyc2lvbiwgdmVyc2lvblRvTWlncmF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX2dldChrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gZG90UHJvcC5nZXQodGhpcy5zdG9yZSwga2V5LCBkZWZhdWx0VmFsdWUpO1xuICAgIH1cbiAgICBfc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgeyBzdG9yZSB9ID0gdGhpcztcbiAgICAgICAgZG90UHJvcC5zZXQoc3RvcmUsIGtleSwgdmFsdWUpO1xuICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ29uZjtcbi8vIEZvciBDb21tb25KUyBkZWZhdWx0IGV4cG9ydCBzdXBwb3J0XG5tb2R1bGUuZXhwb3J0cyA9IENvbmY7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQ29uZjtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCB7YXBwLCBpcGNNYWluLCBpcGNSZW5kZXJlciwgc2hlbGx9ID0gcmVxdWlyZSgnZWxlY3Ryb24nKTtcbmNvbnN0IENvbmYgPSByZXF1aXJlKCdjb25mJyk7XG5cbmxldCBpc0luaXRpYWxpemVkID0gZmFsc2U7XG5cbi8vIFNldCB1cCB0aGUgYGlwY01haW5gIGhhbmRsZXIgZm9yIGNvbW11bmljYXRpb24gYmV0d2VlbiByZW5kZXJlciBhbmQgbWFpbiBwcm9jZXNzLlxuY29uc3QgaW5pdERhdGFMaXN0ZW5lciA9ICgpID0+IHtcblx0aWYgKCFpcGNNYWluIHx8ICFhcHApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0VsZWN0cm9uIFN0b3JlOiBZb3UgbmVlZCB0byBjYWxsIGAuaW5pdFJlbmRlcmVyKClgIGZyb20gdGhlIG1haW4gcHJvY2Vzcy4nKTtcblx0fVxuXG5cdGNvbnN0IGFwcERhdGEgPSB7XG5cdFx0ZGVmYXVsdEN3ZDogYXBwLmdldFBhdGgoJ3VzZXJEYXRhJyksXG5cdFx0YXBwVmVyc2lvbjogYXBwLmdldFZlcnNpb24oKVxuXHR9O1xuXG5cdGlmIChpc0luaXRpYWxpemVkKSB7XG5cdFx0cmV0dXJuIGFwcERhdGE7XG5cdH1cblxuXHRpcGNNYWluLm9uKCdlbGVjdHJvbi1zdG9yZS1nZXQtZGF0YScsIGV2ZW50ID0+IHtcblx0XHRldmVudC5yZXR1cm5WYWx1ZSA9IGFwcERhdGE7XG5cdH0pO1xuXG5cdGlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG5cdHJldHVybiBhcHBEYXRhO1xufTtcblxuY2xhc3MgRWxlY3Ryb25TdG9yZSBleHRlbmRzIENvbmYge1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0bGV0IGRlZmF1bHRDd2Q7XG5cdFx0bGV0IGFwcFZlcnNpb247XG5cblx0XHQvLyBJZiB3ZSBhcmUgaW4gdGhlIHJlbmRlcmVyIHByb2Nlc3MsIHdlIGNvbW11bmljYXRlIHdpdGggdGhlIG1haW4gcHJvY2Vzc1xuXHRcdC8vIHRvIGdldCB0aGUgcmVxdWlyZWQgZGF0YSBmb3IgdGhlIG1vZHVsZSBvdGhlcndpc2UsIHdlIHB1bGwgZnJvbSB0aGUgbWFpbiBwcm9jZXNzLlxuXHRcdGlmIChpcGNSZW5kZXJlcikge1xuXHRcdFx0Y29uc3QgYXBwRGF0YSA9IGlwY1JlbmRlcmVyLnNlbmRTeW5jKCdlbGVjdHJvbi1zdG9yZS1nZXQtZGF0YScpO1xuXG5cdFx0XHRpZiAoIWFwcERhdGEpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFbGVjdHJvbiBTdG9yZTogWW91IG5lZWQgdG8gY2FsbCBgLmluaXRSZW5kZXJlcigpYCBmcm9tIHRoZSBtYWluIHByb2Nlc3MuJyk7XG5cdFx0XHR9XG5cblx0XHRcdCh7ZGVmYXVsdEN3ZCwgYXBwVmVyc2lvbn0gPSBhcHBEYXRhKTtcblx0XHR9IGVsc2UgaWYgKGlwY01haW4gJiYgYXBwKSB7XG5cdFx0XHQoe2RlZmF1bHRDd2QsIGFwcFZlcnNpb259ID0gaW5pdERhdGFMaXN0ZW5lcigpKTtcblx0XHR9XG5cblx0XHRvcHRpb25zID0ge1xuXHRcdFx0bmFtZTogJ2NvbmZpZycsXG5cdFx0XHQuLi5vcHRpb25zXG5cdFx0fTtcblxuXHRcdGlmICghb3B0aW9ucy5wcm9qZWN0VmVyc2lvbikge1xuXHRcdFx0b3B0aW9ucy5wcm9qZWN0VmVyc2lvbiA9IGFwcFZlcnNpb247XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuY3dkKSB7XG5cdFx0XHRvcHRpb25zLmN3ZCA9IHBhdGguaXNBYnNvbHV0ZShvcHRpb25zLmN3ZCkgPyBvcHRpb25zLmN3ZCA6IHBhdGguam9pbihkZWZhdWx0Q3dkLCBvcHRpb25zLmN3ZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9wdGlvbnMuY3dkID0gZGVmYXVsdEN3ZDtcblx0XHR9XG5cblx0XHRvcHRpb25zLmNvbmZpZ05hbWUgPSBvcHRpb25zLm5hbWU7XG5cdFx0ZGVsZXRlIG9wdGlvbnMubmFtZTtcblxuXHRcdHN1cGVyKG9wdGlvbnMpO1xuXHR9XG5cblx0c3RhdGljIGluaXRSZW5kZXJlcigpIHtcblx0XHRpbml0RGF0YUxpc3RlbmVyKCk7XG5cdH1cblxuXHRvcGVuSW5FZGl0b3IoKSB7XG5cdFx0c2hlbGwub3BlblBhdGgodGhpcy5wYXRoKTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVsZWN0cm9uU3RvcmU7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1taXhlZC1zcGFjZXMtYW5kLXRhYnMgKi9cbmltcG9ydCBTdG9yZSBmcm9tICdlbGVjdHJvbi1zdG9yZSc7XG5cbmNvbnN0IHNjaGVtYSA9IHtcblx0bm90ZXM6IHtcblx0XHR0eXBlOiAnb2JqZWN0JyxcbiAgICBwYXR0ZXJuUHJvcGVydGllczoge1xuICAgICAgJ1tBLVphLXowLTlfLV0nOiB7XG4gICAgICBcdHR5cGU6ICdvYmplY3QnLFxuICAgICAgXHRwcm9wZXJ0aWVzOiB7XG4gICAgICBcdFx0aWQ6IHsgdHlwZTogJ3N0cmluZycsIGRlZmF1bHQ6ICcnIH0sXG4gICAgICBcdFx0dGl0bGU6IHsgdHlwZTogJ3N0cmluZycsIGRlZmF1bHQ6ICcnIH0sXG4gICAgICBcdFx0Y29udGVudDogeyB0eXBlOiAnb2JqZWN0JywgZGVmYXVsdDogeyB0eXBlOiAnZG9jJywgY29udGVudDogW10gfSB9LFxuICAgICAgXHRcdGxhYmVsczogeyB0eXBlOiAnYXJyYXknLCBkZWZhdWx0OiBbXSB9LFxuICAgICAgXHRcdGNyZWF0ZWRBdDogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogRGF0ZS5ub3coKSB9LFxuICAgICAgXHRcdHVwZGF0ZWRBdDogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogRGF0ZS5ub3coKSB9LFxuICAgICAgXHRcdGlzQm9va21hcmtlZDogeyB0eXBlOiAnYm9vbGVhbicsIGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICBcdFx0aXNBcmNoaXZlZDogeyB0eXBlOiAnYm9vbGVhbicsIGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgICAgbGFzdEN1cnNvclBvc2l0aW9uOiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAwIH0sXG4gICAgICBcdH0sXG4gICAgICB9LFxuICAgIH0sXG5cdH0sXG4gIGxhYmVsczoge1xuICAgIHR5cGU6ICdhcnJheScsXG4gIH0sXG59O1xuXG5jb25zdCBzdG9yZSA9IG5ldyBTdG9yZSh7XG5cdHNjaGVtYSxcbiAgZW5jcnlwdGlvbktleTogaW1wb3J0Lm1ldGEuZW52LlZJVEVfRU5DUllQVF9LRVksXG59KTtcblxuLy8gc3RvcmUub25EaWRDaGFuZ2UoJ25vdGVzJywgKHZhbHVlKSA9PiB7XG4vLyAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbi8vIH0pO1xuXG5leHBvcnQgZGVmYXVsdCBzdG9yZTtcbiIsImltcG9ydCBTdG9yZSBmcm9tICdlbGVjdHJvbi1zdG9yZSc7XG5pbXBvcnQgeyBhcHAgfSBmcm9tICdlbGVjdHJvbic7XG5cbmNvbnN0IHNjaGVtYSA9IHtcblx0ZGF0YURpcjoge1xuXHRcdHR5cGU6ICdzdHJpbmcnLFxuXHRcdGRlZmF1bHQ6IGFwcC5nZXRQYXRoKCd1c2VyRGF0YScpLFxuXHR9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgbmV3IFN0b3JlKHsgbmFtZTogJ3NldHRpbmdzJywgc2NoZW1hLCBlbmNyeXB0aW9uS2V5OiBwcm9jZXNzLmVudi5WSVRFX0VOQ1JZUFRfS0VZIH0pO1xuIiwiaW1wb3J0IGRhdGEgZnJvbSAnLi9tb2R1bGVzL2RhdGEuc3RvcmUnO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4vbW9kdWxlcy9zZXR0aW5ncy5zdG9yZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblx0ZGF0YSxcblx0c2V0dGluZ3MsXG59O1xuIiwiaW1wb3J0IHsgYXBwLCBCcm93c2VyV2luZG93LCBkaWFsb2csIHByb3RvY29sLCBuYXRpdmVUaGVtZSwgc2hlbGwgfSBmcm9tICdlbGVjdHJvbic7XG5pbXBvcnQgeyBpcGNNYWluIH0gZnJvbSAnZWxlY3Ryb24tYmV0dGVyLWlwYyc7XG5pbXBvcnQgeyBqb2luLCBub3JtYWxpemUgfSBmcm9tICdwYXRoJztcbmltcG9ydCB7IFVSTCB9IGZyb20gJ3VybCc7XG5pbXBvcnQgeyByZW1vdmUsIHJlYWRKc29uLCBlbnN1cmVEaXIsIGNvcHksIG91dHB1dEpzb24sIHBhdGhFeGlzdHNTeW5jIH0gZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHN0b3JlIGZyb20gJy4vc3RvcmUnO1xuXG5jb25zdCBpc1NpbmdsZUluc3RhbmNlID0gYXBwLnJlcXVlc3RTaW5nbGVJbnN0YW5jZUxvY2soKTtcblxuaWYgKCFpc1NpbmdsZUluc3RhbmNlKSB7XG4gIGFwcC5xdWl0KCk7XG4gIHByb2Nlc3MuZXhpdCgwKTtcbn1cblxuYXBwLmRpc2FibGVIYXJkd2FyZUFjY2VsZXJhdGlvbigpO1xuXG4vKipcbiAqIFdvcmthcm91bmQgZm9yIFR5cGVTY3JpcHQgYnVnXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvNDE0NjgjaXNzdWVjb21tZW50LTcyNzU0MzQwMFxuICovXG5jb25zdCBlbnYgPSBpbXBvcnQubWV0YS5lbnY7XG5cbmxldCBtYWluV2luZG93ID0gbnVsbDtcblxuY29uc3QgY3JlYXRlV2luZG93ID0gYXN5bmMgKCkgPT4ge1xuICBtYWluV2luZG93ID0gbmV3IEJyb3dzZXJXaW5kb3coe1xuICAgIHNob3c6IGZhbHNlLFxuICAgIHdpZHRoOiA5NTAsXG4gICAgaGVpZ2h0OiA2MDAsXG4gICAgd2ViUHJlZmVyZW5jZXM6IHtcbiAgICAgIHByZWxvYWQ6IGpvaW4oX19kaXJuYW1lLCAnLi4vLi4vcHJlbG9hZC9kaXN0L2luZGV4LmNqcycpLFxuICAgICAgY29udGV4dElzb2xhdGlvbjogZW52Lk1PREUgIT09ICd0ZXN0JyxcbiAgICAgIGVuYWJsZVJlbW90ZU1vZHVsZTogZW52Lk1PREUgPT09ICd0ZXN0JyxcbiAgICAgIG5vZGVJbnRlZ3JhdGlvbjogdHJ1ZSxcbiAgICB9LFxuICB9KTtcblxuICBtYWluV2luZG93LnNldE1lbnVCYXJWaXNpYmlsaXR5KGZhbHNlKTtcblxuICBtYWluV2luZG93Lm9uKCdyZWFkeS10by1zaG93JywgKCkgPT4ge1xuICAgIG1haW5XaW5kb3c/LnNob3coKTtcblxuICAgIGlmIChlbnYuTU9ERSA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgbWFpbldpbmRvdz8ud2ViQ29udGVudHMub3BlbkRldlRvb2xzKCk7XG4gICAgfVxuICB9KTtcblxuICBtYWluV2luZG93Py53ZWJDb250ZW50cy5zZXRXaW5kb3dPcGVuSGFuZGxlcihmdW5jdGlvbihkZXRhaWxzKSB7XG4gICAgY29uc3QgdXJsID0gZGV0YWlscy51cmw7XG4gICAgaWYgKHVybC5zdGFydHNXaXRoKCdub3RlOi8vJykpIHJldHVybjtcblxuICAgIHNoZWxsLm9wZW5FeHRlcm5hbCh1cmwpO1xuICAgIHJldHVybiB7XG4gICAgICBhY3Rpb246ICdkZW55JyxcbiAgICB9O1xuICB9KTtcblxuICBjb25zdCBwYWdlVXJsID0gZW52Lk1PREUgPT09ICdkZXZlbG9wbWVudCdcbiAgICA/IGVudi5WSVRFX0RFVl9TRVJWRVJfVVJMXG4gICAgOiBuZXcgVVJMKCcuLi9yZW5kZXJlci9kaXN0L2luZGV4Lmh0bWwnLCAnZmlsZTovLycgKyBfX2Rpcm5hbWUpLnRvU3RyaW5nKCk7XG5cbiAgYXdhaXQgbWFpbldpbmRvdy5sb2FkVVJMKHBhZ2VVcmwpO1xufTtcblxuYXBwLm9uKCdOU0FwcGxpY2F0aW9uRGVsZWdhdGUuYXBwbGljYXRpb25TdXBwb3J0c1NlY3VyZVJlc3RvcmFibGVTdGF0ZScsICgpID0+IHtcbiAgcmV0dXJuIHRydWU7XG59KTtcblxuYXBwLm9uKCdzZWNvbmQtaW5zdGFuY2UnLCAoKSA9PiB7XG4gIGlmIChtYWluV2luZG93KSB7XG4gICAgaWYgKG1haW5XaW5kb3cuaXNNaW5pbWl6ZWQoKSkgbWFpbldpbmRvdy5yZXN0b3JlKCk7XG4gICAgbWFpbldpbmRvdy5mb2N1cygpO1xuICB9XG59KTtcblxuYXBwLm9uKCd3aW5kb3ctYWxsLWNsb3NlZCcsICgpID0+IHtcbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gIT09ICdkYXJ3aW4nKSB7XG4gICAgYXBwLnF1aXQoKTtcbiAgfVxufSk7XG5cbmxldCB6b29tTGV2ZWwgPSAxLjA7XG5cbmFwcC53aGVuUmVhZHkoKVxuICAudGhlbihhc3luYyAoKSA9PiB7XG4gICAgcHJvdG9jb2wucmVnaXN0ZXJGaWxlUHJvdG9jb2woJ2Fzc2V0cycsIChyZXF1ZXN0LCBjYWxsYmFjaykgPT4ge1xuICAgICAgY29uc3QgdXJsID0gcmVxdWVzdC51cmwuc3Vic3RyKDkpO1xuXG4gICAgICBjb25zdCBkaXIgPSBzdG9yZS5zZXR0aW5ncy5nZXQoJ2RhdGFEaXInKTtcbiAgICAgIGNvbnN0IGltZ1BhdGggPSBgJHtkaXJ9L25vdGVzLWFzc2V0cy8ke3VybH1gO1xuXG4gICAgICBjYWxsYmFjayh7IHBhdGg6IG5vcm1hbGl6ZShpbWdQYXRoKSB9KTtcbiAgICB9KTtcblxuICAgIGF3YWl0IGVuc3VyZURpcihqb2luKGFwcC5nZXRQYXRoKCd1c2VyRGF0YScpLCAnbm90ZXMtYXNzZXRzJykpO1xuICAgIGF3YWl0IGNyZWF0ZVdpbmRvdygpO1xuICB9KVxuICAuY2F0Y2goKGUpID0+IGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCBjcmVhdGUgd2luZG93OicsIGUpKTtcblxuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignYXBwOmluZm8nLCAoKSA9PiAoe1xuICBuYW1lOiBhcHAuZ2V0TmFtZSgpLFxuICB2ZXJzaW9uOiBhcHAuZ2V0VmVyc2lvbigpLFxufSkpO1xuXG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdhcHA6c3BlbGxjaGVjaycsIChpc0VuYWJsZWQpID0+IHtcbiAgICBtYWluV2luZG93LndlYkNvbnRlbnRzLnNlc3Npb24uc2V0U3BlbGxDaGVja2VyRW5hYmxlZChpc0VuYWJsZWQpO1xufSk7XG5cbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2FwcDpzZXQtem9vbScsIChuZXdab29tTGV2ZWwpID0+IHtcbiAgbWFpbldpbmRvdy53ZWJDb250ZW50cy56b29tRmFjdG9yID0gbmV3Wm9vbUxldmVsO1xuICB6b29tTGV2ZWwgPSBuZXdab29tTGV2ZWw7XG59KTtcblxuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignZGlhbG9nOm9wZW4nLCAocHJvcHMpID0+IGRpYWxvZy5zaG93T3BlbkRpYWxvZyhwcm9wcykpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignZGlhbG9nOm1lc3NhZ2UnLCAocHJvcHMpID0+IGRpYWxvZy5zaG93TWVzc2FnZUJveChwcm9wcykpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignZGlhbG9nOnNhdmUnLCAocHJvcHMpID0+IGRpYWxvZy5zaG93U2F2ZURpYWxvZyhwcm9wcykpO1xuXG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdmczpjb3B5JywgKHsgcGF0aCwgZGVzdCB9KSA9PiBjb3B5KHBhdGgsIGRlc3QpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2ZzOm91dHB1dC1qc29uJywgKHsgcGF0aCwgZGF0YSB9KSA9PiBvdXRwdXRKc29uKHBhdGgsIGRhdGEpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2ZzOnJlYWQtanNvbicsIChwYXRoKSA9PiByZWFkSnNvbihwYXRoKSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdmczplbnN1cmVEaXInLCAocGF0aCkgPT4gZW5zdXJlRGlyKHBhdGgpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2ZzOnBhdGhFeGlzdHMnLCAocGF0aCkgPT4gcGF0aEV4aXN0c1N5bmMocGF0aCkpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignZnM6cmVtb3ZlJywgKHBhdGgpID0+IHJlbW92ZShwYXRoKSk7XG5cbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2hlbHBlcjpyZWxhdW5jaCcsIChvcHRpb25zID0ge30pID0+IHtcbiAgYXBwLnJlbGF1bmNoKHsgYXJnczogcHJvY2Vzcy5hcmd2LnNsaWNlKDEpLmNvbmNhdChbJy0tcmVsYXVuY2gnXSksIC4uLm9wdGlvbnMgfSk7XG4gIGFwcC5leGl0KDApO1xufSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdoZWxwZXI6Z2V0LXBhdGgnLCAobmFtZSkgPT4gYXBwLmdldFBhdGgobmFtZSkpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignaGVscGVyOmlzLWRhcmstdGhlbWUnLCAoKSA9PiBuYXRpdmVUaGVtZS5zaG91bGRVc2VEYXJrQ29sb3JzKTtcblxuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignc3RvcmFnZTpzdG9yZScsIChuYW1lKSA9PiBzdG9yZVtuYW1lXT8uc3RvcmUpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignc3RvcmFnZTpyZXBsYWNlJywgKHsgbmFtZSwgZGF0YSB9KSA9PiAoc3RvcmVbbmFtZV0uc3RvcmUgPSBkYXRhKSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdzdG9yYWdlOmdldCcsICh7IG5hbWUsIGtleSwgZGVmIH0pID0+IHN0b3JlW25hbWVdPy5nZXQoa2V5LCBkZWYpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ3N0b3JhZ2U6c2V0JywgKHsgbmFtZSwga2V5LCB2YWx1ZSB9KSA9PiBzdG9yZVtuYW1lXT8uc2V0KGtleSwgdmFsdWUpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ3N0b3JhZ2U6ZGVsZXRlJywgKHsgbmFtZSwga2V5IH0pID0+IHN0b3JlW25hbWVdPy5kZWxldGUoa2V5KSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdzdG9yYWdlOmhhcycsICh7IG5hbWUsIGtleSB9KSA9PiBzdG9yZVtuYW1lXT8uaGFzKGtleSkpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignc3RvcmFnZTpjbGVhcicsIChuYW1lKSA9PiBzdG9yZVtuYW1lXT8uY2xlYXIoKSk7XG4iXSwibmFtZXMiOlsianNvbiIsInV0aWwiLCJpZCIsInJlcXVpcmUkJDEiLCJyZXF1aXJlJCQyIiwiaXBjTWFpbiIsInJlc29sdmUiLCJ3aW5kb3ciLCJlcnJvciIsImNoYW5uZWwiLCJkYXRhIiwiaXBjUmVuZGVyZXIiLCJyZXF1aXJlJCQwIiwidW5pdmVyc2FsaWZ5IiwiY29uc3RhbnRzIiwicG9seWZpbGxzIiwicGF0Y2giLCJmcyIsInBhdGgiLCJlcnIiLCJlcnIyIiwiZXIiLCJlcjIiLCJsZWdhY3kiLCJzZWxmIiwiY2xvbmUiLCJjb3B5IiwicmVxdWlyZSQkMyIsImRlYnVnIiwiZ2xvYmFsIiwicmVhZEZpbGUiLCJvcHRpb25zIiwiY2IiLCJ3cml0ZUZpbGUiLCJjb3B5RmlsZSIsInNyYyIsImRlc3QiLCJmbGFncyIsIm1vZGUiLCJ1IiwiZXhwb3J0cyIsImJ1ZmZlciIsImJ1ZmZlcnMiLCJ1dGlscyIsImNoZWNrUGF0aCIsImRlZmF1bHRzIiwibWFrZURpciIsIm1rZGlycyIsInBhdGhFeGlzdHMiLCJ1dGltZXNNaWxsaXMiLCJ1dGltZXNNaWxsaXNTeW5jIiwiZ2V0U3RhdHMiLCJvcHRzIiwiZmlsZSIsImFyZUlkZW50aWNhbCIsInN0YXQiLCJyZXF1aXJlJCQ0IiwicmVxdWlyZSQkNSIsIm9uRGlyIiwib25GaWxlIiwib25MaW5rIiwiZmlsZUlzTm90V3JpdGFibGUiLCJtYWtlRmlsZVdyaXRhYmxlIiwiaXRlbXMiLCJkZXN0U3RhdCIsIm1rZGlyc1N5bmMiLCJjb3B5U3luYyIsInJlbW92ZSIsInJlbW92ZVN5bmMiLCJta2RpciIsImVtcHR5RGlyIiwiY3JlYXRlRmlsZSIsImNyZWF0ZUZpbGVTeW5jIiwiY3JlYXRlTGluayIsImNyZWF0ZUxpbmtTeW5jIiwic3ltbGlua1BhdGhzIiwic3ltbGlua1BhdGhzU3luYyIsImV4aXN0cyIsInN5bWxpbmtUeXBlIiwidHlwZSIsInN5bWxpbmtUeXBlU3luYyIsInJlcXVpcmUkJDYiLCJyZXF1aXJlJCQ3IiwiY3JlYXRlU3ltbGluayIsImNyZWF0ZVN5bWxpbmtTeW5jIiwic3RyaW5naWZ5Iiwic3RyaXBCb20iLCJyZWFkRmlsZVN5bmMiLCJ3cml0ZUZpbGVTeW5jIiwianNvbmZpbGUiLCJqc29uRmlsZSIsIm91dHB1dEZpbGUiLCJvdXRwdXRGaWxlU3luYyIsIm1vdmUiLCJkb1JlbmFtZSIsIm1vdmVBY3Jvc3NEZXZpY2UiLCJyZXF1aXJlJCQ4IiwicmVxdWlyZSQkOSIsImlzT2JqIiwicGF0aEV4aXN0c01vZHVsZSIsInBUcnkiLCJwVHJ5TW9kdWxlIiwicExpbWl0IiwiZW5xdWV1ZSIsInBMaW1pdE1vZHVsZSIsInBMb2NhdGUiLCJsaW1pdCIsImxvY2F0ZVBhdGhNb2R1bGUiLCJmaW5kVXBNb2R1bGUiLCJwa2dVcE1vZHVsZSIsImN3ZCIsImVudiIsImVudlBhdGhzTW9kdWxlIiwiY29uc3RzXzEiLCJjb2RlIiwiZnNfMSIsInV0aWxfMSIsImRpc3QiLCJuYW1lcyIsImNvZGVfMSIsIlVzZWRWYWx1ZVN0YXRlIiwiZGVmIiwiTm9kZSIsIm5vdCIsImNvZGVnZW5fMSIsInNjaGVtYSIsInJ1bGVzIiwia2V5d29yZCIsIlR5cGUiLCJuYW1lc18xIiwiZXJyb3JzXzEiLCJ2YWxpZCIsImFwcGxpY2FiaWxpdHlfMSIsIkRhdGFUeXBlIiwidHlwZXMiLCJ0IiwiZGF0YVR5cGUiLCJwcm9wZXJ0aWVzIiwicGF0dGVybiIsInZhbGlkYXRlIiwiZXJyb3JzIiwiX2EiLCJzdWJzY2hlbWEiLCJ0cmF2ZXJzZSIsImpzb25TY2hlbWFUcmF2ZXJzZU1vZHVsZSIsInRoaXMiLCJzb3VyY2UiLCJIRVhESUckJCIsIlBDVF9FTkNPREVEJCIsIlVOUkVTRVJWRUQkJCIsImVycm9yJDEiLCJ1Y3MyZW5jb2RlIiwiYmFzaWNUb0RpZ2l0IiwiZGlnaXRUb0Jhc2ljIiwiYWRhcHQiLCJkZWNvZGUiLCJlbmNvZGUiLCJ0b1VuaWNvZGUiLCJ0b0FTQ0lJIiwiZGVjb2RlVW5yZXNlcnZlZCIsInBhcnNlIiwiYmFzZSIsImVxdWFsIiwic2VyaWFsaXplIiwiVVJJIiwicmVmIiwiZGF0YVR5cGVfMSIsInJlc29sdmVfMSIsInJlcXVpcmUkJDEwIiwiVmFsaWRhdGlvbkVycm9yIiwidmFsaWRhdGVfMSIsInZhbGlkYXRpb25fZXJyb3JfMSIsInJlZl9lcnJvcl8xIiwiY29tcGlsZV8xIiwiJHNjaGVtYSIsImRlZmluaXRpb25zIiwiZm9ybWF0IiwiY29yZV8xIiwidWNzMmxlbmd0aF8xIiwiZXF1YWxfMSIsInZhbGlkYXRpb25fMSIsIml0ZW1zXzEiLCJhZGRpdGlvbmFsSXRlbXNfMSIsInByZWZpeEl0ZW1zIiwiYWRkaXRpb25hbFByb3BlcnRpZXNfMSIsInJlcXVpcmUkJDExIiwicmVxdWlyZSQkMTIiLCJyZXF1aXJlJCQxMyIsInJlcXVpcmUkJDE0IiwicmVxdWlyZSQkMTUiLCJhcHBsaWNhdG9yIiwiZm9ybWF0XzIiLCJmb3JtYXRfMSIsIm9uZU9mIiwicmVxdWlyZWQiLCJtb2R1bGUiLCJjb21wYXJlIiwib3BzIiwiS1dEcyIsImFqdiIsImZvcm1hdHMiLCJtaW1pY0ZuIiwiTUFYX0xFTkdUSCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIIiwicmUiLCJwYXJzZU9wdGlvbnMiLCJjb21wYXJlSWRlbnRpZmllcnMiLCJzZW12ZXIiLCJTZW1WZXIiLCJlcSIsImNvbXBhcmVCdWlsZCIsImd0IiwibHQiLCJuZXEiLCJndGUiLCJsdGUiLCJZYWxsaXN0IiwiZGlmZiIsIlJhbmdlIiwicmFuZ2UiLCJDb21wYXJhdG9yIiwiY29tcCIsIkFOWSIsImNtcCIsInNhdGlzZmllcyIsImNvbXBhcmF0b3IiLCJvdXRzaWRlIiwibWluIiwicmVxdWlyZSQkMTYiLCJyZXF1aXJlJCQxNyIsInJlcXVpcmUkJDE4IiwicmVxdWlyZSQkMTkiLCJyZXF1aXJlJCQyMCIsInJlcXVpcmUkJDIxIiwicmVxdWlyZSQkMjIiLCJyZXF1aXJlJCQyMyIsInJlcXVpcmUkJDI0IiwicmVxdWlyZSQkMjUiLCJyZXF1aXJlJCQyNiIsInJlcXVpcmUkJDI3IiwicmVxdWlyZSQkMjgiLCJyZXF1aXJlJCQyOSIsInJlcXVpcmUkJDMwIiwicmVxdWlyZSQkMzEiLCJyZXF1aXJlJCQzMiIsInJlcXVpcmUkJDMzIiwicmVxdWlyZSQkMzQiLCJyZXF1aXJlJCQzNSIsInJlcXVpcmUkJDM2IiwicmVxdWlyZSQkMzciLCJyZXF1aXJlJCQzOCIsInJlcXVpcmUkJDM5IiwicmVxdWlyZSQkNDAiLCJtaW1pY0ZuTW9kdWxlIiwib25ldGltZSIsIm9uZXRpbWVNb2R1bGUiLCJkb3RQcm9wIiwicGtnVXAiLCJlbnZQYXRocyIsImRlYm91bmNlRm4iLCJDb25mIiwic3RvcmUiLCJfYiIsImtleSIsInZhbHVlIiwiZGVmaW5lX2ltcG9ydF9tZXRhX2Vudl9kZWZhdWx0IiwiYXBwIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBRUEsTUFBTSxpQkFBaUIsTUFBTTtBQUFBLElBQzVCLFlBQVksU0FBUztBQUNwQixZQUFNLFNBQVMscUJBQXFCLE9BQU8sQ0FBQztBQUM1QyxhQUFPLGVBQWUsTUFBTSxRQUFRO0FBQUEsUUFDbkMsT0FBTztBQUFBLFFBQ1AsY0FBYztBQUFBLFFBQ2QsVUFBVTtBQUFBLE1BQ2IsQ0FBRztBQUVELFVBQUksTUFBTSxtQkFBbUI7QUFDNUIsY0FBTSxrQkFBa0IsTUFBTSxRQUFRO0FBQUEsTUFDdEM7QUFBQSxJQUNEO0FBQUEsSUFFRCxPQUFPLHFCQUFxQixTQUFTO0FBQ3BDLFVBQUk7QUFDSCxlQUFPLEtBQUssVUFBVSxPQUFPO0FBQUEsTUFDaEMsUUFBVTtBQUNQLGVBQU8sT0FBTyxPQUFPO0FBQUEsTUFDckI7QUFBQSxJQUNEO0FBQUEsRUFDRDtBQUVELFFBQU0sbUJBQW1CO0FBQUEsSUFDeEIsRUFBQyxVQUFVLFFBQVEsWUFBWSxNQUFLO0FBQUEsSUFDcEMsRUFBQyxVQUFVLFdBQVcsWUFBWSxNQUFLO0FBQUEsSUFDdkMsRUFBQyxVQUFVLFNBQVMsWUFBWSxNQUFLO0FBQUEsSUFDckMsRUFBQyxVQUFVLFFBQVEsWUFBWSxLQUFJO0FBQUEsRUFDcEM7QUFFQSxRQUFNLFdBQVcsT0FBTyxnQkFBZ0I7QUFFeEMsUUFBTSxTQUFTLFVBQVE7QUFDdEIsU0FBSyxRQUFRLElBQUk7QUFDakIsVUFBTUEsUUFBTyxLQUFLO0FBQ2xCLFdB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LFVBQVU7QUFBQSxFQUMvQjtBQUNGO0FBRUEsTUFBQSxXQUFlLElBQUksTUFBTSxFQUFFLE1BQU0sWUFBWSxRQUFRLGVBQWUsUUFBUSxJQUFJLGtCQUFrQjtBQ1BsRyxNQUFlLFFBQUE7QUFBQSxFQUNmLE1BQUNqUTtBQUFBQSxFQUNBO0FBQ0Q7QUNOQSxJQUFDLGlDQUFBLEVBQUEscUJBQXVCLDBCQUEwQixVQUFZLEtBQUssTUFBUSxlQUFlLEtBQU8sTUFBTSxNQUFRLE9BQU8sS0FBTyxNQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyIsInhfZ29vZ2xlX2lnbm9yZUxpc3QiOlswLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDI2LDI3LDI4LDI5LDMwLDMxLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDM5LDQwLDQxLDQyLDQzLDQ0LDQ1LDQ2LDQ3LDQ4LDQ5LDUwLDUxLDUyLDUzLDU0LDU1LDU2LDU3LDU4LDU5LDYwLDYxLDYyLDYzLDY0LDY1LDY2LDY3LDY4LDY5LDcwLDcxLDcyLDczLDc0LDc1LDc2LDc3LDc4LDc5LDgwLDgxLDgyLDgzLDg0LDg1LDg2LDg3LDg4LDg5LDkwLDkxLDkyLDkzLDk0LDk1LDk2LDk3LDk4LDk5LDEwMCwxMDEsMTAyLDEwMywxMDQsMTA1LDEwNiwxMDcsMTA4LDEwOSwxMTAsMTExLDExMiwxMTMsMTE0LDExNSwxMTYsMTE3LDExOCwxMTksMTIwLDEyMSwxMjIsMTIzLDEyNCwxMjUsMTI2LDEyNywxMjgsMTI5LDEzMCwxMzEsMTMyLDEzMywxMzQsMTM1LDEzNiwxMzcsMTM4LDEzOSwxNDAsMTQxLDE0MiwxNDMsMTQ0LDE0NSwxNDYsMTQ3LDE0OCwxNDksMTUwLDE1MSwxNTIsMTUzLDE1NCwxNTUsMTU2LDE1NywxNTgsMTU5LDE2MCwxNjEsMTYyLDE2MywxNjQsMTY1LDE2NiwxNjcsMTY4LDE2OSwxNzAsMTcxLDE3MiwxNzMsMTc0LDE3NSwxNzYsMTc3XX0=
