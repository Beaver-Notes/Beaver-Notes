"use strict";
const require$$0 = require("electron");
const require$$1 = require("path");
require("url");
const require$$0$3 = require("fs");
const require$$0$1 = require("constants");
const require$$0$2 = require("stream");
const require$$4 = require("util");
const require$$5 = require("assert");
const require$$3$1 = require("crypto");
const require$$5$1 = require("events");
const require$$1$1 = require("os");
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var serializeError_1;
var hasRequiredSerializeError;
function requireSerializeError() {
  if (hasRequiredSerializeError)
    return serializeError_1;
  hasRequiredSerializeError = 1;
  class NonError extends Error {
    constructor(message) {
      super(NonError._prepareSuperMessage(message));
      Object.defineProperty(this, "name", {
        value: "NonError",
        configurable: true,
        writable: true
      });
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, NonError);
      }
    }
    static _prepareSuperMessage(message) {
      try {
        return JSON.stringify(message);
      } catch {
        return String(message);
      }
    }
  }
  const commonProperties = [
    { property: "name", enumerable: false },
    { property: "message", enumerable: false },
    { property: "stack", enumerable: false },
    { property: "code", enumerable: true }
  ];
  const isCalled = Symbol(".toJSON called");
  const toJSON = (from) => {
    from[isCalled] = true;
    const json2 = from.toJSON();
    delete from[isCalled];
    return json2;
  };
  const destroyCircular = ({
    from,
    seen,
    to_,
    forceEnumerable,
    maxDepth,
    depth
  }) => {
    const to = to_ || (Array.isArray(from) ? [] : {});
    seen.push(from);
    if (depth >= maxDepth) {
      return to;
    }
    if (typeof from.toJSON === "function" && from[isCalled] !== true) {
      return toJSON(from);
    }
    for (const [key, value] of Object.entries(from)) {
      if (typeof Buffer === "function" && Buffer.isBuffer(value)) {
        to[key] = "[object Buffer]";
        continue;
      }
      if (typeof value === "function") {
        continue;
      }
      if (!value || typeof value !== "object") {
        to[key] = value;
        continue;
      }
      if (!seen.includes(from[key])) {
        depth++;
        to[key] = destroyCircular({
          from: from[key],
          seen: seen.slice(),
          forceEnumerable,
          maxDepth,
          depth
        });
        continue;
      }
      to[key] = "[Circular]";
    }
    for (const { property, enumerable } of commonProperties) {
      if (typeof from[property] === "string") {
        Object.defineProperty(to, property, {
          value: from[property],
          enumerable: forceEnumerable ? true : enumerable,
          configurable: true,
          writable: true
        });
      }
    }
    return to;
  };
  const serializeError = (value, options = {}) => {
    const { maxDepth = Number.POSITIVE_INFINITY } = options;
    if (typeof value === "object" && value !== null) {
      return destroyCircular({
        from: value,
        seen: [],
        forceEnumerable: true,
        maxDepth,
        depth: 0
      });
    }
    if (typeof value === "function") {
      return `[Function: ${value.name || "anonymous"}]`;
    }
    return value;
  };
  const deserializeError = (value, options = {}) => {
    const { maxDepth = Number.POSITIVE_INFINITY } = options;
    if (value instanceof Error) {
      return value;
    }
    if (typeof value === "object" && value !== null && !Array.isArray(value)) {
      const newError = new Error();
      destroyCircular({
        from: value,
        seen: [],
        to_: newError,
        maxDepth,
        depth: 0
      });
      return newError;
    }
    return new NonError(value);
  };
  serializeError_1 = {
    serializeError,
    deserializeError
  };
  return serializeError_1;
}
var util$2 = {};
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil)
    return util$2;
  hasRequiredUtil = 1;
  const getUniqueId = () => `${Date.now()}-${Math.random()}`;
  const getSendChannel = (channel) => `%better-ipc-send-channel-${channel}`;
  const getRendererSendChannel = (channel) => `%better-ipc-send-channel-${channel}`;
  util$2.currentWindowChannel = "%better-ipc-current-window";
  util$2.getSendChannel = getSendChannel;
  util$2.getRendererSendChannel = getRendererSendChannel;
  util$2.getResponseChannels = (channel) => {
    const id2 = getUniqueId();
    return {
      sendChannel: getSendChannel(channel),
      dataChannel: `%better-ipc-response-data-channel-${channel}-${id2}`,
      errorChannel: `%better-ipc-response-error-channel-${channel}-${id2}`
    };
  };
  util$2.getRendererResponseChannels = (channel) => {
    const id2 = getUniqueId();
    return {
      sendChannel: getRendererSendChannel(channel),
      dataChannel: `%better-ipc-response-data-channel-${channel}-${id2}`,
      errorChannel: `%better-ipc-response-error-channel-${channel}-${id2}`
    };
  };
  return util$2;
}
var renderer;
var hasRequiredRenderer;
function requireRenderer() {
  if (hasRequiredRenderer)
    return renderer;
  hasRequiredRenderer = 1;
  const electron = require$$0;
  const { serializeError, deserializeError } = requireSerializeError();
  const util2 = requireUtil();
  const { ipcRenderer: ipcRenderer2 } = electron;
  const ipc = Object.create(ipcRenderer2 || {});
  ipc.callMain = (channel, data) => new Promise((resolve2, reject) => {
    const { sendChannel, dataChannel, errorChannel } = util2.getResponseChannels(channel);
    const cleanup = () => {
      ipcRenderer2.off(dataChannel, onData);
      ipcRenderer2.off(errorChannel, onError);
    };
    const onData = (_event, result) => {
      cleanup();
      resolve2(result);
    };
    const onError = (_event, error2) => {
      cleanup();
      reject(deserializeError(error2));
    };
    ipcRenderer2.once(dataChannel, onData);
    ipcRenderer2.once(errorChannel, onError);
    const completeData = {
      dataChannel,
      errorChannel,
      userData: data
    };
    ipcRenderer2.send(sendChannel, completeData);
  });
  ipc.answerMain = (channel, callback) => {
    const sendChannel = util2.getRendererSendChannel(channel);
    const listener = async (_event, data) => {
      const { dataChannel, errorChannel, userData } = data;
      try {
        ipcRenderer2.send(dataChannel, await callback(userData));
      } catch (error2) {
        ipcRenderer2.send(errorChannel, serializeError(error2));
      }
    };
    ipcRenderer2.on(sendChannel, listener);
    return () => {
      ipcRenderer2.off(sendChannel, listener);
    };
  };
  renderer = ipc;
  return renderer;
}
var main;
var hasRequiredMain;
function requireMain() {
  if (hasRequiredMain)
    return main;
  hasRequiredMain = 1;
  const electron = require$$0;
  const { serializeError, deserializeError } = requireSerializeError();
  const util2 = requireUtil();
  const { ipcMain: ipcMain2, BrowserWindow } = electron;
  const ipc = Object.create(ipcMain2 || {});
  ipc.callRenderer = (browserWindow, channel, data) => new Promise((resolve2, reject) => {
    if (!browserWindow) {
      throw new Error("Browser window required");
    }
    const { sendChannel, dataChannel, errorChannel } = util2.getRendererResponseChannels(channel);
    const cleanup = () => {
      ipcMain2.off(dataChannel, onData);
      ipcMain2.off(errorChannel, onError);
    };
    const onData = (event, result) => {
      const window2 = BrowserWindow.fromWebContents(event.sender);
      if (window2.id === browserWindow.id) {
        cleanup();
        resolve2(result);
      }
    };
    const onError = (event, error2) => {
      const window2 = BrowserWindow.fromWebContents(event.sender);
      if (window2.id === browserWindow.id) {
        cleanup();
        reject(deserializeError(error2));
      }
    };
    ipcMain2.on(dataChannel, onData);
    ipcMain2.on(errorChannel, onError);
    const completeData = {
      dataChannel,
      errorChannel,
      userData: data
    };
    if (browserWindow.webContents) {
      browserWindow.webContents.send(sendChannel, completeData);
    }
  });
  ipc.callFocusedRenderer = async (...args) => {
    const focusedWindow = BrowserWindow.getFocusedWindow();
    if (!focusedWindow) {
      throw new Error("No browser window in focus");
    }
    return ipc.callRenderer(focusedWindow, ...args);
  };
  ipc.answerRenderer = (browserWindowOrChannel, channelOrCallback, callbackOrNothing) => {
    let window2;
    let channel;
    let callback;
    if (callbackOrNothing === void 0) {
      channel = browserWindowOrChannel;
      callback = channelOrCallback;
    } else {
      window2 = browserWindowOrChannel;
      channel = channelOrCallback;
      callback = callbackOrNothing;
      if (!window2) {
        throw new Error("Browser window required");
      }
    }
    const sendChannel = util2.getSendChannel(channel);
    const listener = async (event, data) => {
      const browserWindow = BrowserWindow.fromWebContents(event.sender);
      if (window2 && window2.id !== browserWindow.id) {
        return;
      }
      const send = (channel2, data2) => {
        if (!(browserWindow && browserWindow.isDestroyed())) {
          event.sender.send(channel2, data2);
        }
      };
      const { dataChannel, errorChannel, userData } = data;
      try {
        send(dataChannel, await callback(userData, browserWindow));
      } catch (error2) {
        send(errorChannel, serializeError(error2));
      }
    };
    ipcMain2.on(sendChannel, listener);
    return () => {
      ipcMain2.off(sendChannel, listener);
    };
  };
  ipc.sendToRenderers = (channel, data) => {
    for (const browserWindow of BrowserWindow.getAllWindows()) {
      if (browserWindow.webContents) {
        browserWindow.webContents.send(channel, data);
      }
    }
  };
  main = ipc;
  return main;
}
var ipcMain$1;
if (process.type === "renderer") {
  requireRenderer();
} else {
  ipcMain$1 = requireMain();
}
var fs$k = {};
var universalify$1 = {};
universalify$1.fromCallback = function(fn) {
  return Object.defineProperty(function(...args) {
    if (typeof args[args.length - 1] === "function")
      fn.apply(this, args);
    else {
      return new Promise((resolve2, reject) => {
        args.push((err, res) => err != null ? reject(err) : resolve2(res));
        fn.apply(this, args);
      });
    }
  }, "name", { value: fn.name });
};
universalify$1.fromPromise = function(fn) {
  return Object.defineProperty(function(...args) {
    const cb = args[args.length - 1];
    if (typeof cb !== "function")
      return fn.apply(this, args);
    else {
      args.pop();
      fn.apply(this, args).then((r) => cb(null, r), cb);
    }
  }, "name", { value: fn.name });
};
var constants$2 = require$$0$1;
var origCwd = process.cwd;
var cwd = null;
var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process);
  return cwd;
};
try {
  process.cwd();
} catch (er) {
}
if (typeof process.chdir === "function") {
  var chdir = process.chdir;
  process.chdir = function(d) {
    cwd = null;
    chdir.call(process, d);
  };
  if (Object.setPrototypeOf)
    Object.setPrototypeOf(process.chdir, chdir);
}
var polyfills$1 = patch$3;
function patch$3(fs2) {
  if (constants$2.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs2);
  }
  if (!fs2.lutimes) {
    patchLutimes(fs2);
  }
  fs2.chown = chownFix(fs2.chown);
  fs2.fchown = chownFix(fs2.fchown);
  fs2.lchown = chownFix(fs2.lchown);
  fs2.chmod = chmodFix(fs2.chmod);
  fs2.fchmod = chmodFix(fs2.fchmod);
  fs2.lchmod = chmodFix(fs2.lchmod);
  fs2.chownSync = chownFixSync(fs2.chownSync);
  fs2.fchownSync = chownFixSync(fs2.fchownSync);
  fs2.lchownSync = chownFixSync(fs2.lchownSync);
  fs2.chmodSync = chmodFixSync(fs2.chmodSync);
  fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
  fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
  fs2.stat = statFix(fs2.stat);
  fs2.fstat = statFix(fs2.fstat);
  fs2.lstat = statFix(fs2.lstat);
  fs2.statSync = statFixSync(fs2.statSync);
  fs2.fstatSync = statFixSync(fs2.fstatSync);
  fs2.lstatSync = statFixSync(fs2.lstatSync);
  if (fs2.chmod && !fs2.lchmod) {
    fs2.lchmod = function(path2, mode, cb) {
      if (cb)
        process.nextTick(cb);
    };
    fs2.lchmodSync = function() {
    };
  }
  if (fs2.chown && !fs2.lchown) {
    fs2.lchown = function(path2, uid, gid, cb) {
      if (cb)
        process.nextTick(cb);
    };
    fs2.lchownSync = function() {
    };
  }
  if (platform === "win32") {
    fs2.rename = typeof fs2.rename !== "function" ? fs2.rename : function(fs$rename) {
      function rename2(from, to, cb) {
        var start = Date.now();
        var backoff = 0;
        fs$rename(from, to, function CB(er) {
          if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
            setTimeout(function() {
              fs2.stat(to, function(stater, st) {
                if (stater && stater.code === "ENOENT")
                  fs$rename(from, to, CB);
                else
                  cb(er);
              });
            }, backoff);
            if (backoff < 100)
              backoff += 10;
            return;
          }
          if (cb)
            cb(er);
        });
      }
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(rename2, fs$rename);
      return rename2;
    }(fs2.rename);
  }
  fs2.read = typeof fs2.read !== "function" ? fs2.read : function(fs$read) {
    function read(fd, buffer, offset, length, position, callback_) {
      var callback;
      if (callback_ && typeof callback_ === "function") {
        var eagCounter = 0;
        callback = function(er, _, __) {
          if (er && er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
          }
          callback_.apply(this, arguments);
        };
      }
      return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
    }
    if (Object.setPrototypeOf)
      Object.setPrototypeOf(read, fs$read);
    return read;
  }(fs2.read);
  fs2.readSync = typeof fs2.readSync !== "function" ? fs2.readSync : /* @__PURE__ */ function(fs$readSync) {
    return function(fd, buffer, offset, length, position) {
      var eagCounter = 0;
      while (true) {
        try {
          return fs$readSync.call(fs2, fd, buffer, offset, length, position);
        } catch (er) {
          if (er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            continue;
          }
          throw er;
        }
      }
    };
  }(fs2.readSync);
  function patchLchmod(fs3) {
    fs3.lchmod = function(path2, mode, callback) {
      fs3.open(
        path2,
        constants$2.O_WRONLY | constants$2.O_SYMLINK,
        mode,
        function(err, fd) {
          if (err) {
            if (callback)
              callback(err);
            return;
          }
          fs3.fchmod(fd, mode, function(err2) {
            fs3.close(fd, function(err22) {
              if (callback)
                callback(err2 || err22);
            });
          });
        }
      );
    };
    fs3.lchmodSync = function(path2, mode) {
      var fd = fs3.openSync(path2, constants$2.O_WRONLY | constants$2.O_SYMLINK, mode);
      var threw = true;
      var ret;
      try {
        ret = fs3.fchmodSync(fd, mode);
        threw = false;
      } finally {
        if (threw) {
          try {
            fs3.closeSync(fd);
          } catch (er) {
          }
        } else {
          fs3.closeSync(fd);
        }
      }
      return ret;
    };
  }
  function patchLutimes(fs3) {
    if (constants$2.hasOwnProperty("O_SYMLINK") && fs3.futimes) {
      fs3.lutimes = function(path2, at, mt, cb) {
        fs3.open(path2, constants$2.O_SYMLINK, function(er, fd) {
          if (er) {
            if (cb)
              cb(er);
            return;
          }
          fs3.futimes(fd, at, mt, function(er2) {
            fs3.close(fd, function(er22) {
              if (cb)
                cb(er2 || er22);
            });
          });
        });
      };
      fs3.lutimesSync = function(path2, at, mt) {
        var fd = fs3.openSync(path2, constants$2.O_SYMLINK);
        var ret;
        var threw = true;
        try {
          ret = fs3.futimesSync(fd, at, mt);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs3.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs3.closeSync(fd);
          }
        }
        return ret;
      };
    } else if (fs3.futimes) {
      fs3.lutimes = function(_a, _b, _c, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs3.lutimesSync = function() {
      };
    }
  }
  function chmodFix(orig) {
    if (!orig)
      return orig;
    return function(target, mode, cb) {
      return orig.call(fs2, target, mode, function(er) {
        if (chownErOk(er))
          er = null;
        if (cb)
          cb.apply(this, arguments);
      });
    };
  }
  function chmodFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, mode) {
      try {
        return orig.call(fs2, target, mode);
      } catch (er) {
        if (!chownErOk(er))
          throw er;
      }
    };
  }
  function chownFix(orig) {
    if (!orig)
      return orig;
    return function(target, uid, gid, cb) {
      return orig.call(fs2, target, uid, gid, function(er) {
        if (chownErOk(er))
          er = null;
        if (cb)
          cb.apply(this, arguments);
      });
    };
  }
  function chownFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, uid, gid) {
      try {
        return orig.call(fs2, target, uid, gid);
      } catch (er) {
        if (!chownErOk(er))
          throw er;
      }
    };
  }
  function statFix(orig) {
    if (!orig)
      return orig;
    return function(target, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      function callback(er, stats) {
        if (stats) {
          if (stats.uid < 0)
            stats.uid += 4294967296;
          if (stats.gid < 0)
            stats.gid += 4294967296;
        }
        if (cb)
          cb.apply(this, arguments);
      }
      return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
    };
  }
  function statFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, options) {
      var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
      if (stats) {
        if (stats.uid < 0)
          stats.uid += 4294967296;
        if (stats.gid < 0)
          stats.gid += 4294967296;
      }
      return stats;
    };
  }
  function chownErOk(er) {
    if (!er)
      return true;
    if (er.code === "ENOSYS")
      return true;
    var nonroot = !process.getuid || process.getuid() !== 0;
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true;
    }
    return false;
  }
}
var Stream = require$$0$2.Stream;
var legacyStreams = legacy$1;
function legacy$1(fs2) {
  return {
    ReadStream,
    WriteStream
  };
  function ReadStream(path2, options) {
    if (!(this instanceof ReadStream))
      return new ReadStream(path2, options);
    Stream.call(this);
    var self2 = this;
    this.path = path2;
    this.fd = null;
    this.readable = true;
    this.paused = false;
    this.flags = "r";
    this.mode = 438;
    this.bufferSize = 64 * 1024;
    options = options || {};
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }
    if (this.encoding)
      this.setEncoding(this.encoding);
    if (this.start !== void 0) {
      if ("number" !== typeof this.start) {
        throw TypeError("start must be a Number");
      }
      if (this.end === void 0) {
        this.end = Infinity;
      } else if ("number" !== typeof this.end) {
        throw TypeError("end must be a Number");
      }
      if (this.start > this.end) {
        throw new Error("start must be <= end");
      }
      this.pos = this.start;
    }
    if (this.fd !== null) {
      process.nextTick(function() {
        self2._read();
      });
      return;
    }
    fs2.open(this.path, this.flags, this.mode, function(err, fd) {
      if (err) {
        self2.emit("error", err);
        self2.readable = false;
        return;
      }
      self2.fd = fd;
      self2.emit("open", fd);
      self2._read();
    });
  }
  function WriteStream(path2, options) {
    if (!(this instanceof WriteStream))
      return new WriteStream(path2, options);
    Stream.call(this);
    this.path = path2;
    this.fd = null;
    this.writable = true;
    this.flags = "w";
    this.encoding = "binary";
    this.mode = 438;
    this.bytesWritten = 0;
    options = options || {};
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }
    if (this.start !== void 0) {
      if ("number" !== typeof this.start) {
        throw TypeError("start must be a Number");
      }
      if (this.start < 0) {
        throw new Error("start must be >= zero");
      }
      this.pos = this.start;
    }
    this.busy = false;
    this._queue = [];
    if (this.fd === null) {
      this._open = fs2.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
      this.flush();
    }
  }
}
var clone_1 = clone$1;
var getPrototypeOf = Object.getPrototypeOf || function(obj) {
  return obj.__proto__;
};
function clone$1(obj) {
  if (obj === null || typeof obj !== "object")
    return obj;
  if (obj instanceof Object)
    var copy2 = { __proto__: getPrototypeOf(obj) };
  else
    var copy2 = /* @__PURE__ */ Object.create(null);
  Object.getOwnPropertyNames(obj).forEach(function(key) {
    Object.defineProperty(copy2, key, Object.getOwnPropertyDescriptor(obj, key));
  });
  return copy2;
}
var fs$j = require$$0$3;
var polyfills = polyfills$1;
var legacy = legacyStreams;
var clone = clone_1;
var util$1 = require$$4;
var gracefulQueue;
var previousSymbol;
if (typeof Symbol === "function" && typeof Symbol.for === "function") {
  gracefulQueue = Symbol.for("graceful-fs.queue");
  previousSymbol = Symbol.for("graceful-fs.previous");
} else {
  gracefulQueue = "___graceful-fs.queue";
  previousSymbol = "___graceful-fs.previous";
}
function noop() {
}
function publishQueue(context, queue) {
  Object.defineProperty(context, gracefulQueue, {
    get: function() {
      return queue;
    }
  });
}
var debug$2 = noop;
if (util$1.debuglog)
  debug$2 = util$1.debuglog("gfs4");
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
  debug$2 = function() {
    var m = util$1.format.apply(util$1, arguments);
    m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
    console.error(m);
  };
if (!fs$j[gracefulQueue]) {
  var queue = commonjsGlobal[gracefulQueue] || [];
  publishQueue(fs$j, queue);
  fs$j.close = function(fs$close) {
    function close(fd, cb) {
      return fs$close.call(fs$j, fd, function(err) {
        if (!err) {
          resetQueue();
        }
        if (typeof cb === "function")
          cb.apply(this, arguments);
      });
    }
    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    });
    return close;
  }(fs$j.close);
  fs$j.closeSync = function(fs$closeSync) {
    function closeSync(fd) {
      fs$closeSync.apply(fs$j, arguments);
      resetQueue();
    }
    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    });
    return closeSync;
  }(fs$j.closeSync);
  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
    process.on("exit", function() {
      debug$2(fs$j[gracefulQueue]);
      require$$5.equal(fs$j[gracefulQueue].length, 0);
    });
  }
}
if (!commonjsGlobal[gracefulQueue]) {
  publishQueue(commonjsGlobal, fs$j[gracefulQueue]);
}
var gracefulFs = patch$2(clone(fs$j));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs$j.__patched) {
  gracefulFs = patch$2(fs$j);
  fs$j.__patched = true;
}
function patch$2(fs2) {
  polyfills(fs2);
  fs2.gracefulify = patch$2;
  fs2.createReadStream = createReadStream;
  fs2.createWriteStream = createWriteStream;
  var fs$readFile = fs2.readFile;
  fs2.readFile = readFile2;
  function readFile2(path2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$readFile(path2, options, cb);
    function go$readFile(path3, options2, cb2, startTime) {
      return fs$readFile(path3, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$readFile, [path3, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$writeFile = fs2.writeFile;
  fs2.writeFile = writeFile2;
  function writeFile2(path2, data, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$writeFile(path2, data, options, cb);
    function go$writeFile(path3, data2, options2, cb2, startTime) {
      return fs$writeFile(path3, data2, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$writeFile, [path3, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$appendFile = fs2.appendFile;
  if (fs$appendFile)
    fs2.appendFile = appendFile;
  function appendFile(path2, data, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$appendFile(path2, data, options, cb);
    function go$appendFile(path3, data2, options2, cb2, startTime) {
      return fs$appendFile(path3, data2, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$appendFile, [path3, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$copyFile = fs2.copyFile;
  if (fs$copyFile)
    fs2.copyFile = copyFile2;
  function copyFile2(src, dest, flags, cb) {
    if (typeof flags === "function") {
      cb = flags;
      flags = 0;
    }
    return go$copyFile(src, dest, flags, cb);
    function go$copyFile(src2, dest2, flags2, cb2, startTime) {
      return fs$copyFile(src2, dest2, flags2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$readdir = fs2.readdir;
  fs2.readdir = readdir;
  var noReaddirOptionVersions = /^v[0-5]\./;
  function readdir(path2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path3, options2, cb2, startTime) {
      return fs$readdir(path3, fs$readdirCallback(
        path3,
        options2,
        cb2,
        startTime
      ));
    } : function go$readdir2(path3, options2, cb2, startTime) {
      return fs$readdir(path3, options2, fs$readdirCallback(
        path3,
        options2,
        cb2,
        startTime
      ));
    };
    return go$readdir(path2, options, cb);
    function fs$readdirCallback(path3, options2, cb2, startTime) {
      return function(err, files) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([
            go$readdir,
            [path3, options2, cb2],
            err,
            startTime || Date.now(),
            Date.now()
          ]);
        else {
          if (files && files.sort)
            files.sort();
          if (typeof cb2 === "function")
            cb2.call(this, err, files);
        }
      };
    }
  }
  if (process.version.substr(0, 4) === "v0.8") {
    var legStreams = legacy(fs2);
    ReadStream = legStreams.ReadStream;
    WriteStream = legStreams.WriteStream;
  }
  var fs$ReadStream = fs2.ReadStream;
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype);
    ReadStream.prototype.open = ReadStream$open;
  }
  var fs$WriteStream = fs2.WriteStream;
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype);
    WriteStream.prototype.open = WriteStream$open;
  }
  Object.defineProperty(fs2, "ReadStream", {
    get: function() {
      return ReadStream;
    },
    set: function(val) {
      ReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(fs2, "WriteStream", {
    get: function() {
      return WriteStream;
    },
    set: function(val) {
      WriteStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileReadStream = ReadStream;
  Object.defineProperty(fs2, "FileReadStream", {
    get: function() {
      return FileReadStream;
    },
    set: function(val) {
      FileReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileWriteStream = WriteStream;
  Object.defineProperty(fs2, "FileWriteStream", {
    get: function() {
      return FileWriteStream;
    },
    set: function(val) {
      FileWriteStream = val;
    },
    enumerable: true,
    configurable: true
  });
  function ReadStream(path2, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this;
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
  }
  function ReadStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function(err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy();
        that.emit("error", err);
      } else {
        that.fd = fd;
        that.emit("open", fd);
        that.read();
      }
    });
  }
  function WriteStream(path2, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this;
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
  }
  function WriteStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function(err, fd) {
      if (err) {
        that.destroy();
        that.emit("error", err);
      } else {
        that.fd = fd;
        that.emit("open", fd);
      }
    });
  }
  function createReadStream(path2, options) {
    return new fs2.ReadStream(path2, options);
  }
  function createWriteStream(path2, options) {
    return new fs2.WriteStream(path2, options);
  }
  var fs$open = fs2.open;
  fs2.open = open;
  function open(path2, flags, mode, cb) {
    if (typeof mode === "function")
      cb = mode, mode = null;
    return go$open(path2, flags, mode, cb);
    function go$open(path3, flags2, mode2, cb2, startTime) {
      return fs$open(path3, flags2, mode2, function(err, fd) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$open, [path3, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  return fs2;
}
function enqueue(elem) {
  debug$2("ENQUEUE", elem[0].name, elem[1]);
  fs$j[gracefulQueue].push(elem);
  retry();
}
var retryTimer;
function resetQueue() {
  var now = Date.now();
  for (var i = 0; i < fs$j[gracefulQueue].length; ++i) {
    if (fs$j[gracefulQueue][i].length > 2) {
      fs$j[gracefulQueue][i][3] = now;
      fs$j[gracefulQueue][i][4] = now;
    }
  }
  retry();
}
function retry() {
  clearTimeout(retryTimer);
  retryTimer = void 0;
  if (fs$j[gracefulQueue].length === 0)
    return;
  var elem = fs$j[gracefulQueue].shift();
  var fn = elem[0];
  var args = elem[1];
  var err = elem[2];
  var startTime = elem[3];
  var lastTime = elem[4];
  if (startTime === void 0) {
    debug$2("RETRY", fn.name, args);
    fn.apply(null, args);
  } else if (Date.now() - startTime >= 6e4) {
    debug$2("TIMEOUT", fn.name, args);
    var cb = args.pop();
    if (typeof cb === "function")
      cb.call(null, err);
  } else {
    var sinceAttempt = Date.now() - lastTime;
    var sinceStart = Math.max(lastTime - startTime, 1);
    var desiredDelay = Math.min(sinceStart * 1.2, 100);
    if (sinceAttempt >= desiredDelay) {
      debug$2("RETRY", fn.name, args);
      fn.apply(null, args.concat([startTime]));
    } else {
      fs$j[gracefulQueue].push(elem);
    }
  }
  if (retryTimer === void 0) {
    retryTimer = setTimeout(retry, 0);
  }
}
(function(exports2) {
  const u2 = universalify$1.fromCallback;
  const fs2 = gracefulFs;
  const api = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((key) => {
    return typeof fs2[key] === "function";
  });
  Object.assign(exports2, fs2);
  api.forEach((method) => {
    exports2[method] = u2(fs2[method]);
  });
  exports2.exists = function(filename, callback) {
    if (typeof callback === "function") {
      return fs2.exists(filename, callback);
    }
    return new Promise((resolve2) => {
      return fs2.exists(filename, resolve2);
    });
  };
  exports2.read = function(fd, buffer, offset, length, position, callback) {
    if (typeof callback === "function") {
      return fs2.read(fd, buffer, offset, length, position, callback);
    }
    return new Promise((resolve2, reject) => {
      fs2.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
        if (err)
          return reject(err);
        resolve2({ bytesRead, buffer: buffer2 });
      });
    });
  };
  exports2.write = function(fd, buffer, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs2.write(fd, buffer, ...args);
    }
    return new Promise((resolve2, reject) => {
      fs2.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
        if (err)
          return reject(err);
        resolve2({ bytesWritten, buffer: buffer2 });
      });
    });
  };
  exports2.readv = function(fd, buffers, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs2.readv(fd, buffers, ...args);
    }
    return new Promise((resolve2, reject) => {
      fs2.readv(fd, buffers, ...args, (err, bytesRead, buffers2) => {
        if (err)
          return reject(err);
        resolve2({ bytesRead, buffers: buffers2 });
      });
    });
  };
  exports2.writev = function(fd, buffers, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs2.writev(fd, buffers, ...args);
    }
    return new Promise((resolve2, reject) => {
      fs2.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
        if (err)
          return reject(err);
        resolve2({ bytesWritten, buffers: buffers2 });
      });
    });
  };
  if (typeof fs2.realpath.native === "function") {
    exports2.realpath.native = u2(fs2.realpath.native);
  } else {
    process.emitWarning(
      "fs.realpath.native is not a function. Is fs being monkey-patched?",
      "Warning",
      "fs-extra-WARN0003"
    );
  }
})(fs$k);
var makeDir$1 = {};
var utils$1 = {};
const path$h = require$$1;
utils$1.checkPath = function checkPath(pth) {
  if (process.platform === "win32") {
    const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path$h.parse(pth).root, ""));
    if (pathHasInvalidWinCharacters) {
      const error2 = new Error(`Path contains invalid characters: ${pth}`);
      error2.code = "EINVAL";
      throw error2;
    }
  }
};
const fs$i = fs$k;
const { checkPath: checkPath2 } = utils$1;
const getMode = (options) => {
  const defaults2 = { mode: 511 };
  if (typeof options === "number")
    return options;
  return { ...defaults2, ...options }.mode;
};
makeDir$1.makeDir = async (dir, options) => {
  checkPath2(dir);
  return fs$i.mkdir(dir, {
    mode: getMode(options),
    recursive: true
  });
};
makeDir$1.makeDirSync = (dir, options) => {
  checkPath2(dir);
  return fs$i.mkdirSync(dir, {
    mode: getMode(options),
    recursive: true
  });
};
const u$e = universalify$1.fromPromise;
const { makeDir: _makeDir, makeDirSync } = makeDir$1;
const makeDir = u$e(_makeDir);
var mkdirs$2 = {
  mkdirs: makeDir,
  mkdirsSync: makeDirSync,
  // alias
  mkdirp: makeDir,
  mkdirpSync: makeDirSync,
  ensureDir: makeDir,
  ensureDirSync: makeDirSync
};
const u$d = universalify$1.fromPromise;
const fs$h = fs$k;
function pathExists$8(path2) {
  return fs$h.access(path2).then(() => true).catch(() => false);
}
var pathExists_1 = {
  pathExists: u$d(pathExists$8),
  pathExistsSync: fs$h.existsSync
};
const fs$g = fs$k;
const u$c = universalify$1.fromPromise;
async function utimesMillis$1(path2, atime, mtime) {
  const fd = await fs$g.open(path2, "r+");
  let closeErr = null;
  try {
    await fs$g.futimes(fd, atime, mtime);
  } finally {
    try {
      await fs$g.close(fd);
    } catch (e) {
      closeErr = e;
    }
  }
  if (closeErr) {
    throw closeErr;
  }
}
function utimesMillisSync$1(path2, atime, mtime) {
  const fd = fs$g.openSync(path2, "r+");
  fs$g.futimesSync(fd, atime, mtime);
  return fs$g.closeSync(fd);
}
var utimes = {
  utimesMillis: u$c(utimesMillis$1),
  utimesMillisSync: utimesMillisSync$1
};
const fs$f = fs$k;
const path$g = require$$1;
const u$b = universalify$1.fromPromise;
function getStats$1(src, dest, opts) {
  const statFunc = opts.dereference ? (file2) => fs$f.stat(file2, { bigint: true }) : (file2) => fs$f.lstat(file2, { bigint: true });
  return Promise.all([
    statFunc(src),
    statFunc(dest).catch((err) => {
      if (err.code === "ENOENT")
        return null;
      throw err;
    })
  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
}
function getStatsSync(src, dest, opts) {
  let destStat;
  const statFunc = opts.dereference ? (file2) => fs$f.statSync(file2, { bigint: true }) : (file2) => fs$f.lstatSync(file2, { bigint: true });
  const srcStat = statFunc(src);
  try {
    destStat = statFunc(dest);
  } catch (err) {
    if (err.code === "ENOENT")
      return { srcStat, destStat: null };
    throw err;
  }
  return { srcStat, destStat };
}
async function checkPaths(src, dest, funcName, opts) {
  const { srcStat, destStat } = await getStats$1(src, dest, opts);
  if (destStat) {
    if (areIdentical$2(srcStat, destStat)) {
      const srcBaseName = path$g.basename(src);
      const destBaseName = path$g.basename(dest);
      if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
        return { srcStat, destStat, isChangingCase: true };
      }
      throw new Error("Source and destination must not be the same.");
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
    }
  }
  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new Error(errMsg(src, dest, funcName));
  }
  return { srcStat, destStat };
}
function checkPathsSync(src, dest, funcName, opts) {
  const { srcStat, destStat } = getStatsSync(src, dest, opts);
  if (destStat) {
    if (areIdentical$2(srcStat, destStat)) {
      const srcBaseName = path$g.basename(src);
      const destBaseName = path$g.basename(dest);
      if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
        return { srcStat, destStat, isChangingCase: true };
      }
      throw new Error("Source and destination must not be the same.");
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
    }
  }
  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new Error(errMsg(src, dest, funcName));
  }
  return { srcStat, destStat };
}
async function checkParentPaths(src, srcStat, dest, funcName) {
  const srcParent = path$g.resolve(path$g.dirname(src));
  const destParent = path$g.resolve(path$g.dirname(dest));
  if (destParent === srcParent || destParent === path$g.parse(destParent).root)
    return;
  let destStat;
  try {
    destStat = await fs$f.stat(destParent, { bigint: true });
  } catch (err) {
    if (err.code === "ENOENT")
      return;
    throw err;
  }
  if (areIdentical$2(srcStat, destStat)) {
    throw new Error(errMsg(src, dest, funcName));
  }
  return checkParentPaths(src, srcStat, destParent, funcName);
}
function checkParentPathsSync(src, srcStat, dest, funcName) {
  const srcParent = path$g.resolve(path$g.dirname(src));
  const destParent = path$g.resolve(path$g.dirname(dest));
  if (destParent === srcParent || destParent === path$g.parse(destParent).root)
    return;
  let destStat;
  try {
    destStat = fs$f.statSync(destParent, { bigint: true });
  } catch (err) {
    if (err.code === "ENOENT")
      return;
    throw err;
  }
  if (areIdentical$2(srcStat, destStat)) {
    throw new Error(errMsg(src, dest, funcName));
  }
  return checkParentPathsSync(src, srcStat, destParent, funcName);
}
function areIdentical$2(srcStat, destStat) {
  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
}
function isSrcSubdir(src, dest) {
  const srcArr = path$g.resolve(src).split(path$g.sep).filter((i) => i);
  const destArr = path$g.resolve(dest).split(path$g.sep).filter((i) => i);
  return srcArr.every((cur, i) => destArr[i] === cur);
}
function errMsg(src, dest, funcName) {
  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
}
var stat$4 = {
  // checkPaths
  checkPaths: u$b(checkPaths),
  checkPathsSync,
  // checkParent
  checkParentPaths: u$b(checkParentPaths),
  checkParentPathsSync,
  // Misc
  isSrcSubdir,
  areIdentical: areIdentical$2
};
const fs$e = fs$k;
const path$f = require$$1;
const { mkdirs: mkdirs$1 } = mkdirs$2;
const { pathExists: pathExists$7 } = pathExists_1;
const { utimesMillis } = utimes;
const stat$3 = stat$4;
async function copy$2(src, dest, opts = {}) {
  if (typeof opts === "function") {
    opts = { filter: opts };
  }
  opts.clobber = "clobber" in opts ? !!opts.clobber : true;
  opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
  if (opts.preserveTimestamps && process.arch === "ia32") {
    process.emitWarning(
      "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
      "Warning",
      "fs-extra-WARN0001"
    );
  }
  const { srcStat, destStat } = await stat$3.checkPaths(src, dest, "copy", opts);
  await stat$3.checkParentPaths(src, srcStat, dest, "copy");
  const include = await runFilter(src, dest, opts);
  if (!include)
    return;
  const destParent = path$f.dirname(dest);
  const dirExists = await pathExists$7(destParent);
  if (!dirExists) {
    await mkdirs$1(destParent);
  }
  await getStatsAndPerformCopy(destStat, src, dest, opts);
}
async function runFilter(src, dest, opts) {
  if (!opts.filter)
    return true;
  return opts.filter(src, dest);
}
async function getStatsAndPerformCopy(destStat, src, dest, opts) {
  const statFn = opts.dereference ? fs$e.stat : fs$e.lstat;
  const srcStat = await statFn(src);
  if (srcStat.isDirectory())
    return onDir$1(srcStat, destStat, src, dest, opts);
  if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
    return onFile$1(srcStat, destStat, src, dest, opts);
  if (srcStat.isSymbolicLink())
    return onLink$1(destStat, src, dest, opts);
  if (srcStat.isSocket())
    throw new Error(`Cannot copy a socket file: ${src}`);
  if (srcStat.isFIFO())
    throw new Error(`Cannot copy a FIFO pipe: ${src}`);
  throw new Error(`Unknown file: ${src}`);
}
async function onFile$1(srcStat, destStat, src, dest, opts) {
  if (!destStat)
    return copyFile$1(srcStat, src, dest, opts);
  if (opts.overwrite) {
    await fs$e.unlink(dest);
    return copyFile$1(srcStat, src, dest, opts);
  }
  if (opts.errorOnExist) {
    throw new Error(`'${dest}' already exists`);
  }
}
async function copyFile$1(srcStat, src, dest, opts) {
  await fs$e.copyFile(src, dest);
  if (opts.preserveTimestamps) {
    if (fileIsNotWritable$1(srcStat.mode)) {
      await makeFileWritable$1(dest, srcStat.mode);
    }
    const updatedSrcStat = await fs$e.stat(src);
    await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
  }
  return fs$e.chmod(dest, srcStat.mode);
}
function fileIsNotWritable$1(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable$1(dest, srcMode) {
  return fs$e.chmod(dest, srcMode | 128);
}
async function onDir$1(srcStat, destStat, src, dest, opts) {
  if (!destStat) {
    await fs$e.mkdir(dest);
  }
  const items2 = await fs$e.readdir(src);
  await Promise.all(items2.map(async (item) => {
    const srcItem = path$f.join(src, item);
    const destItem = path$f.join(dest, item);
    const include = await runFilter(srcItem, destItem, opts);
    if (!include)
      return;
    const { destStat: destStat2 } = await stat$3.checkPaths(srcItem, destItem, "copy", opts);
    return getStatsAndPerformCopy(destStat2, srcItem, destItem, opts);
  }));
  if (!destStat) {
    await fs$e.chmod(dest, srcStat.mode);
  }
}
async function onLink$1(destStat, src, dest, opts) {
  let resolvedSrc = await fs$e.readlink(src);
  if (opts.dereference) {
    resolvedSrc = path$f.resolve(process.cwd(), resolvedSrc);
  }
  if (!destStat) {
    return fs$e.symlink(resolvedSrc, dest);
  }
  let resolvedDest = null;
  try {
    resolvedDest = await fs$e.readlink(dest);
  } catch (e) {
    if (e.code === "EINVAL" || e.code === "UNKNOWN")
      return fs$e.symlink(resolvedSrc, dest);
    throw e;
  }
  if (opts.dereference) {
    resolvedDest = path$f.resolve(process.cwd(), resolvedDest);
  }
  if (stat$3.isSrcSubdir(resolvedSrc, resolvedDest)) {
    throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
  }
  if (stat$3.isSrcSubdir(resolvedDest, resolvedSrc)) {
    throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
  }
  await fs$e.unlink(dest);
  return fs$e.symlink(resolvedSrc, dest);
}
var copy_1 = copy$2;
const fs$d = gracefulFs;
const path$e = require$$1;
const mkdirsSync$1 = mkdirs$2.mkdirsSync;
const utimesMillisSync = utimes.utimesMillisSync;
const stat$2 = stat$4;
function copySync$1(src, dest, opts) {
  if (typeof opts === "function") {
    opts = { filter: opts };
  }
  opts = opts || {};
  opts.clobber = "clobber" in opts ? !!opts.clobber : true;
  opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
  if (opts.preserveTimestamps && process.arch === "ia32") {
    process.emitWarning(
      "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
      "Warning",
      "fs-extra-WARN0002"
    );
  }
  const { srcStat, destStat } = stat$2.checkPathsSync(src, dest, "copy", opts);
  stat$2.checkParentPathsSync(src, srcStat, dest, "copy");
  if (opts.filter && !opts.filter(src, dest))
    return;
  const destParent = path$e.dirname(dest);
  if (!fs$d.existsSync(destParent))
    mkdirsSync$1(destParent);
  return getStats(destStat, src, dest, opts);
}
function getStats(destStat, src, dest, opts) {
  const statSync = opts.dereference ? fs$d.statSync : fs$d.lstatSync;
  const srcStat = statSync(src);
  if (srcStat.isDirectory())
    return onDir(srcStat, destStat, src, dest, opts);
  else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
    return onFile(srcStat, destStat, src, dest, opts);
  else if (srcStat.isSymbolicLink())
    return onLink(destStat, src, dest, opts);
  else if (srcStat.isSocket())
    throw new Error(`Cannot copy a socket file: ${src}`);
  else if (srcStat.isFIFO())
    throw new Error(`Cannot copy a FIFO pipe: ${src}`);
  throw new Error(`Unknown file: ${src}`);
}
function onFile(srcStat, destStat, src, dest, opts) {
  if (!destStat)
    return copyFile(srcStat, src, dest, opts);
  return mayCopyFile(srcStat, src, dest, opts);
}
function mayCopyFile(srcStat, src, dest, opts) {
  if (opts.overwrite) {
    fs$d.unlinkSync(dest);
    return copyFile(srcStat, src, dest, opts);
  } else if (opts.errorOnExist) {
    throw new Error(`'${dest}' already exists`);
  }
}
function copyFile(srcStat, src, dest, opts) {
  fs$d.copyFileSync(src, dest);
  if (opts.preserveTimestamps)
    handleTimestamps(srcStat.mode, src, dest);
  return setDestMode(dest, srcStat.mode);
}
function handleTimestamps(srcMode, src, dest) {
  if (fileIsNotWritable(srcMode))
    makeFileWritable(dest, srcMode);
  return setDestTimestamps(src, dest);
}
function fileIsNotWritable(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable(dest, srcMode) {
  return setDestMode(dest, srcMode | 128);
}
function setDestMode(dest, srcMode) {
  return fs$d.chmodSync(dest, srcMode);
}
function setDestTimestamps(src, dest) {
  const updatedSrcStat = fs$d.statSync(src);
  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
}
function onDir(srcStat, destStat, src, dest, opts) {
  if (!destStat)
    return mkDirAndCopy(srcStat.mode, src, dest, opts);
  return copyDir(src, dest, opts);
}
function mkDirAndCopy(srcMode, src, dest, opts) {
  fs$d.mkdirSync(dest);
  copyDir(src, dest, opts);
  return setDestMode(dest, srcMode);
}
function copyDir(src, dest, opts) {
  fs$d.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
}
function copyDirItem(item, src, dest, opts) {
  const srcItem = path$e.join(src, item);
  const destItem = path$e.join(dest, item);
  if (opts.filter && !opts.filter(srcItem, destItem))
    return;
  const { destStat } = stat$2.checkPathsSync(srcItem, destItem, "copy", opts);
  return getStats(destStat, srcItem, destItem, opts);
}
function onLink(destStat, src, dest, opts) {
  let resolvedSrc = fs$d.readlinkSync(src);
  if (opts.dereference) {
    resolvedSrc = path$e.resolve(process.cwd(), resolvedSrc);
  }
  if (!destStat) {
    return fs$d.symlinkSync(resolvedSrc, dest);
  } else {
    let resolvedDest;
    try {
      resolvedDest = fs$d.readlinkSync(dest);
    } catch (err) {
      if (err.code === "EINVAL" || err.code === "UNKNOWN")
        return fs$d.symlinkSync(resolvedSrc, dest);
      throw err;
    }
    if (opts.dereference) {
      resolvedDest = path$e.resolve(process.cwd(), resolvedDest);
    }
    if (stat$2.isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
    }
    if (stat$2.isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
    }
    return copyLink(resolvedSrc, dest);
  }
}
function copyLink(resolvedSrc, dest) {
  fs$d.unlinkSync(dest);
  return fs$d.symlinkSync(resolvedSrc, dest);
}
var copySync_1 = copySync$1;
const u$a = universalify$1.fromPromise;
var copy$1 = {
  copy: u$a(copy_1),
  copySync: copySync_1
};
const fs$c = gracefulFs;
const u$9 = universalify$1.fromCallback;
function remove$2(path2, callback) {
  fs$c.rm(path2, { recursive: true, force: true }, callback);
}
function removeSync$1(path2) {
  fs$c.rmSync(path2, { recursive: true, force: true });
}
var remove_1 = {
  remove: u$9(remove$2),
  removeSync: removeSync$1
};
const u$8 = universalify$1.fromPromise;
const fs$b = fs$k;
const path$d = require$$1;
const mkdir$3 = mkdirs$2;
const remove$1 = remove_1;
const emptyDir = u$8(async function emptyDir2(dir) {
  let items2;
  try {
    items2 = await fs$b.readdir(dir);
  } catch {
    return mkdir$3.mkdirs(dir);
  }
  return Promise.all(items2.map((item) => remove$1.remove(path$d.join(dir, item))));
});
function emptyDirSync(dir) {
  let items2;
  try {
    items2 = fs$b.readdirSync(dir);
  } catch {
    return mkdir$3.mkdirsSync(dir);
  }
  items2.forEach((item) => {
    item = path$d.join(dir, item);
    remove$1.removeSync(item);
  });
}
var empty = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
};
const u$7 = universalify$1.fromPromise;
const path$c = require$$1;
const fs$a = fs$k;
const mkdir$2 = mkdirs$2;
async function createFile$1(file2) {
  let stats;
  try {
    stats = await fs$a.stat(file2);
  } catch {
  }
  if (stats && stats.isFile())
    return;
  const dir = path$c.dirname(file2);
  let dirStats = null;
  try {
    dirStats = await fs$a.stat(dir);
  } catch (err) {
    if (err.code === "ENOENT") {
      await mkdir$2.mkdirs(dir);
      await fs$a.writeFile(file2, "");
      return;
    } else {
      throw err;
    }
  }
  if (dirStats.isDirectory()) {
    await fs$a.writeFile(file2, "");
  } else {
    await fs$a.readdir(dir);
  }
}
function createFileSync$1(file2) {
  let stats;
  try {
    stats = fs$a.statSync(file2);
  } catch {
  }
  if (stats && stats.isFile())
    return;
  const dir = path$c.dirname(file2);
  try {
    if (!fs$a.statSync(dir).isDirectory()) {
      fs$a.readdirSync(dir);
    }
  } catch (err) {
    if (err && err.code === "ENOENT")
      mkdir$2.mkdirsSync(dir);
    else
      throw err;
  }
  fs$a.writeFileSync(file2, "");
}
var file = {
  createFile: u$7(createFile$1),
  createFileSync: createFileSync$1
};
const u$6 = universalify$1.fromPromise;
const path$b = require$$1;
const fs$9 = fs$k;
const mkdir$1 = mkdirs$2;
const { pathExists: pathExists$6 } = pathExists_1;
const { areIdentical: areIdentical$1 } = stat$4;
async function createLink$1(srcpath, dstpath) {
  let dstStat;
  try {
    dstStat = await fs$9.lstat(dstpath);
  } catch {
  }
  let srcStat;
  try {
    srcStat = await fs$9.lstat(srcpath);
  } catch (err) {
    err.message = err.message.replace("lstat", "ensureLink");
    throw err;
  }
  if (dstStat && areIdentical$1(srcStat, dstStat))
    return;
  const dir = path$b.dirname(dstpath);
  const dirExists = await pathExists$6(dir);
  if (!dirExists) {
    await mkdir$1.mkdirs(dir);
  }
  await fs$9.link(srcpath, dstpath);
}
function createLinkSync$1(srcpath, dstpath) {
  let dstStat;
  try {
    dstStat = fs$9.lstatSync(dstpath);
  } catch {
  }
  try {
    const srcStat = fs$9.lstatSync(srcpath);
    if (dstStat && areIdentical$1(srcStat, dstStat))
      return;
  } catch (err) {
    err.message = err.message.replace("lstat", "ensureLink");
    throw err;
  }
  const dir = path$b.dirname(dstpath);
  const dirExists = fs$9.existsSync(dir);
  if (dirExists)
    return fs$9.linkSync(srcpath, dstpath);
  mkdir$1.mkdirsSync(dir);
  return fs$9.linkSync(srcpath, dstpath);
}
var link = {
  createLink: u$6(createLink$1),
  createLinkSync: createLinkSync$1
};
const path$a = require$$1;
const fs$8 = fs$k;
const { pathExists: pathExists$5 } = pathExists_1;
const u$5 = universalify$1.fromPromise;
async function symlinkPaths$1(srcpath, dstpath) {
  if (path$a.isAbsolute(srcpath)) {
    try {
      await fs$8.lstat(srcpath);
    } catch (err) {
      err.message = err.message.replace("lstat", "ensureSymlink");
      throw err;
    }
    return {
      toCwd: srcpath,
      toDst: srcpath
    };
  }
  const dstdir = path$a.dirname(dstpath);
  const relativeToDst = path$a.join(dstdir, srcpath);
  const exists = await pathExists$5(relativeToDst);
  if (exists) {
    return {
      toCwd: relativeToDst,
      toDst: srcpath
    };
  }
  try {
    await fs$8.lstat(srcpath);
  } catch (err) {
    err.message = err.message.replace("lstat", "ensureSymlink");
    throw err;
  }
  return {
    toCwd: srcpath,
    toDst: path$a.relative(dstdir, srcpath)
  };
}
function symlinkPathsSync$1(srcpath, dstpath) {
  if (path$a.isAbsolute(srcpath)) {
    const exists2 = fs$8.existsSync(srcpath);
    if (!exists2)
      throw new Error("absolute srcpath does not exist");
    return {
      toCwd: srcpath,
      toDst: srcpath
    };
  }
  const dstdir = path$a.dirname(dstpath);
  const relativeToDst = path$a.join(dstdir, srcpath);
  const exists = fs$8.existsSync(relativeToDst);
  if (exists) {
    return {
      toCwd: relativeToDst,
      toDst: srcpath
    };
  }
  const srcExists = fs$8.existsSync(srcpath);
  if (!srcExists)
    throw new Error("relative srcpath does not exist");
  return {
    toCwd: srcpath,
    toDst: path$a.relative(dstdir, srcpath)
  };
}
var symlinkPaths_1 = {
  symlinkPaths: u$5(symlinkPaths$1),
  symlinkPathsSync: symlinkPathsSync$1
};
const fs$7 = fs$k;
const u$4 = universalify$1.fromPromise;
async function symlinkType$1(srcpath, type2) {
  if (type2)
    return type2;
  let stats;
  try {
    stats = await fs$7.lstat(srcpath);
  } catch {
    return "file";
  }
  return stats && stats.isDirectory() ? "dir" : "file";
}
function symlinkTypeSync$1(srcpath, type2) {
  if (type2)
    return type2;
  let stats;
  try {
    stats = fs$7.lstatSync(srcpath);
  } catch {
    return "file";
  }
  return stats && stats.isDirectory() ? "dir" : "file";
}
var symlinkType_1 = {
  symlinkType: u$4(symlinkType$1),
  symlinkTypeSync: symlinkTypeSync$1
};
const u$3 = universalify$1.fromPromise;
const path$9 = require$$1;
const fs$6 = fs$k;
const { mkdirs, mkdirsSync } = mkdirs$2;
const { symlinkPaths, symlinkPathsSync } = symlinkPaths_1;
const { symlinkType, symlinkTypeSync } = symlinkType_1;
const { pathExists: pathExists$4 } = pathExists_1;
const { areIdentical } = stat$4;
async function createSymlink$1(srcpath, dstpath, type2) {
  let stats;
  try {
    stats = await fs$6.lstat(dstpath);
  } catch {
  }
  if (stats && stats.isSymbolicLink()) {
    const [srcStat, dstStat] = await Promise.all([
      fs$6.stat(srcpath),
      fs$6.stat(dstpath)
    ]);
    if (areIdentical(srcStat, dstStat))
      return;
  }
  const relative = await symlinkPaths(srcpath, dstpath);
  srcpath = relative.toDst;
  const toType = await symlinkType(relative.toCwd, type2);
  const dir = path$9.dirname(dstpath);
  if (!await pathExists$4(dir)) {
    await mkdirs(dir);
  }
  return fs$6.symlink(srcpath, dstpath, toType);
}
function createSymlinkSync$1(srcpath, dstpath, type2) {
  let stats;
  try {
    stats = fs$6.lstatSync(dstpath);
  } catch {
  }
  if (stats && stats.isSymbolicLink()) {
    const srcStat = fs$6.statSync(srcpath);
    const dstStat = fs$6.statSync(dstpath);
    if (areIdentical(srcStat, dstStat))
      return;
  }
  const relative = symlinkPathsSync(srcpath, dstpath);
  srcpath = relative.toDst;
  type2 = symlinkTypeSync(relative.toCwd, type2);
  const dir = path$9.dirname(dstpath);
  const exists = fs$6.existsSync(dir);
  if (exists)
    return fs$6.symlinkSync(srcpath, dstpath, type2);
  mkdirsSync(dir);
  return fs$6.symlinkSync(srcpath, dstpath, type2);
}
var symlink = {
  createSymlink: u$3(createSymlink$1),
  createSymlinkSync: createSymlinkSync$1
};
const { createFile, createFileSync } = file;
const { createLink, createLinkSync } = link;
const { createSymlink, createSymlinkSync } = symlink;
var ensure = {
  // file
  createFile,
  createFileSync,
  ensureFile: createFile,
  ensureFileSync: createFileSync,
  // link
  createLink,
  createLinkSync,
  ensureLink: createLink,
  ensureLinkSync: createLinkSync,
  // symlink
  createSymlink,
  createSymlinkSync,
  ensureSymlink: createSymlink,
  ensureSymlinkSync: createSymlinkSync
};
function stringify$3(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
  const EOF = finalEOL ? EOL : "";
  const str = JSON.stringify(obj, replacer, spaces);
  return str.replace(/\n/g, EOL) + EOF;
}
function stripBom$1(content) {
  if (Buffer.isBuffer(content))
    content = content.toString("utf8");
  return content.replace(/^\uFEFF/, "");
}
var utils = { stringify: stringify$3, stripBom: stripBom$1 };
let _fs;
try {
  _fs = gracefulFs;
} catch (_) {
  _fs = require$$0$3;
}
const universalify = universalify$1;
const { stringify: stringify$2, stripBom } = utils;
async function _readFile(file2, options = {}) {
  if (typeof options === "string") {
    options = { encoding: options };
  }
  const fs2 = options.fs || _fs;
  const shouldThrow = "throws" in options ? options.throws : true;
  let data = await universalify.fromCallback(fs2.readFile)(file2, options);
  data = stripBom(data);
  let obj;
  try {
    obj = JSON.parse(data, options ? options.reviver : null);
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file2}: ${err.message}`;
      throw err;
    } else {
      return null;
    }
  }
  return obj;
}
const readFile$1 = universalify.fromPromise(_readFile);
function readFileSync$1(file2, options = {}) {
  if (typeof options === "string") {
    options = { encoding: options };
  }
  const fs2 = options.fs || _fs;
  const shouldThrow = "throws" in options ? options.throws : true;
  try {
    let content = fs2.readFileSync(file2, options);
    content = stripBom(content);
    return JSON.parse(content, options.reviver);
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file2}: ${err.message}`;
      throw err;
    } else {
      return null;
    }
  }
}
async function _writeFile(file2, obj, options = {}) {
  const fs2 = options.fs || _fs;
  const str = stringify$2(obj, options);
  await universalify.fromCallback(fs2.writeFile)(file2, str, options);
}
const writeFile$1 = universalify.fromPromise(_writeFile);
function writeFileSync$1(file2, obj, options = {}) {
  const fs2 = options.fs || _fs;
  const str = stringify$2(obj, options);
  return fs2.writeFileSync(file2, str, options);
}
const jsonfile$1 = {
  readFile: readFile$1,
  readFileSync: readFileSync$1,
  writeFile: writeFile$1,
  writeFileSync: writeFileSync$1
};
var jsonfile_1 = jsonfile$1;
const jsonFile$1 = jsonfile_1;
var jsonfile = {
  // jsonfile exports
  readJson: jsonFile$1.readFile,
  readJsonSync: jsonFile$1.readFileSync,
  writeJson: jsonFile$1.writeFile,
  writeJsonSync: jsonFile$1.writeFileSync
};
const u$2 = universalify$1.fromPromise;
const fs$5 = fs$k;
const path$8 = require$$1;
const mkdir = mkdirs$2;
const pathExists$3 = pathExists_1.pathExists;
async function outputFile$1(file2, data, encoding = "utf-8") {
  const dir = path$8.dirname(file2);
  if (!await pathExists$3(dir)) {
    await mkdir.mkdirs(dir);
  }
  return fs$5.writeFile(file2, data, encoding);
}
function outputFileSync$1(file2, ...args) {
  const dir = path$8.dirname(file2);
  if (!fs$5.existsSync(dir)) {
    mkdir.mkdirsSync(dir);
  }
  fs$5.writeFileSync(file2, ...args);
}
var outputFile_1 = {
  outputFile: u$2(outputFile$1),
  outputFileSync: outputFileSync$1
};
const { stringify: stringify$1 } = utils;
const { outputFile } = outputFile_1;
async function outputJson(file2, data, options = {}) {
  const str = stringify$1(data, options);
  await outputFile(file2, str, options);
}
var outputJson_1 = outputJson;
const { stringify } = utils;
const { outputFileSync } = outputFile_1;
function outputJsonSync(file2, data, options) {
  const str = stringify(data, options);
  outputFileSync(file2, str, options);
}
var outputJsonSync_1 = outputJsonSync;
const u$1 = universalify$1.fromPromise;
const jsonFile = jsonfile;
jsonFile.outputJson = u$1(outputJson_1);
jsonFile.outputJsonSync = outputJsonSync_1;
jsonFile.outputJSON = jsonFile.outputJson;
jsonFile.outputJSONSync = jsonFile.outputJsonSync;
jsonFile.writeJSON = jsonFile.writeJson;
jsonFile.writeJSONSync = jsonFile.writeJsonSync;
jsonFile.readJSON = jsonFile.readJson;
jsonFile.readJSONSync = jsonFile.readJsonSync;
var json = jsonFile;
const fs$4 = fs$k;
const path$7 = require$$1;
const { copy } = copy$1;
const { remove } = remove_1;
const { mkdirp } = mkdirs$2;
const { pathExists: pathExists$2 } = pathExists_1;
const stat$1 = stat$4;
async function move$1(src, dest, opts = {}) {
  const overwrite = opts.overwrite || opts.clobber || false;
  const { srcStat, isChangingCase = false } = await stat$1.checkPaths(src, dest, "move", opts);
  await stat$1.checkParentPaths(src, srcStat, dest, "move");
  const destParent = path$7.dirname(dest);
  const parsedParentPath = path$7.parse(destParent);
  if (parsedParentPath.root !== destParent) {
    await mkdirp(destParent);
  }
  return doRename$1(src, dest, overwrite, isChangingCase);
}
async function doRename$1(src, dest, overwrite, isChangingCase) {
  if (!isChangingCase) {
    if (overwrite) {
      await remove(dest);
    } else if (await pathExists$2(dest)) {
      throw new Error("dest already exists.");
    }
  }
  try {
    await fs$4.rename(src, dest);
  } catch (err) {
    if (err.code !== "EXDEV") {
      throw err;
    }
    await moveAcrossDevice$1(src, dest, overwrite);
  }
}
async function moveAcrossDevice$1(src, dest, overwrite) {
  const opts = {
    overwrite,
    errorOnExist: true,
    preserveTimestamps: true
  };
  await copy(src, dest, opts);
  return remove(src);
}
var move_1 = move$1;
const fs$3 = gracefulFs;
const path$6 = require$$1;
const copySync = copy$1.copySync;
const removeSync = remove_1.removeSync;
const mkdirpSync = mkdirs$2.mkdirpSync;
const stat = stat$4;
function moveSync(src, dest, opts) {
  opts = opts || {};
  const overwrite = opts.overwrite || opts.clobber || false;
  const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, "move", opts);
  stat.checkParentPathsSync(src, srcStat, dest, "move");
  if (!isParentRoot(dest))
    mkdirpSync(path$6.dirname(dest));
  return doRename(src, dest, overwrite, isChangingCase);
}
function isParentRoot(dest) {
  const parent = path$6.dirname(dest);
  const parsedPath = path$6.parse(parent);
  return parsedPath.root === parent;
}
function doRename(src, dest, overwrite, isChangingCase) {
  if (isChangingCase)
    return rename(src, dest, overwrite);
  if (overwrite) {
    removeSync(dest);
    return rename(src, dest, overwrite);
  }
  if (fs$3.existsSync(dest))
    throw new Error("dest already exists.");
  return rename(src, dest, overwrite);
}
function rename(src, dest, overwrite) {
  try {
    fs$3.renameSync(src, dest);
  } catch (err) {
    if (err.code !== "EXDEV")
      throw err;
    return moveAcrossDevice(src, dest, overwrite);
  }
}
function moveAcrossDevice(src, dest, overwrite) {
  const opts = {
    overwrite,
    errorOnExist: true,
    preserveTimestamps: true
  };
  copySync(src, dest, opts);
  return removeSync(src);
}
var moveSync_1 = moveSync;
const u = universalify$1.fromPromise;
var move = {
  move: u(move_1),
  moveSync: moveSync_1
};
var lib = {
  // Export promiseified graceful-fs:
  ...fs$k,
  // Export extra methods:
  ...copy$1,
  ...empty,
  ...ensure,
  ...json,
  ...mkdirs$2,
  ...move,
  ...outputFile_1,
  ...pathExists_1,
  ...remove_1
};
var source = { exports: {} };
var isObj$1 = (value) => {
  const type2 = typeof value;
  return value !== null && (type2 === "object" || type2 === "function");
};
const isObj = isObj$1;
const disallowedKeys = /* @__PURE__ */ new Set([
  "__proto__",
  "prototype",
  "constructor"
]);
const isValidPath = (pathSegments) => !pathSegments.some((segment) => disallowedKeys.has(segment));
function getPathSegments(path2) {
  const pathArray = path2.split(".");
  const parts = [];
  for (let i = 0; i < pathArray.length; i++) {
    let p = pathArray[i];
    while (p[p.length - 1] === "\\" && pathArray[i + 1] !== void 0) {
      p = p.slice(0, -1) + ".";
      p += pathArray[++i];
    }
    parts.push(p);
  }
  if (!isValidPath(parts)) {
    return [];
  }
  return parts;
}
var dotProp = {
  get(object, path2, value) {
    if (!isObj(object) || typeof path2 !== "string") {
      return value === void 0 ? object : value;
    }
    const pathArray = getPathSegments(path2);
    if (pathArray.length === 0) {
      return;
    }
    for (let i = 0; i < pathArray.length; i++) {
      object = object[pathArray[i]];
      if (object === void 0 || object === null) {
        if (i !== pathArray.length - 1) {
          return value;
        }
        break;
      }
    }
    return object === void 0 ? value : object;
  },
  set(object, path2, value) {
    if (!isObj(object) || typeof path2 !== "string") {
      return object;
    }
    const root = object;
    const pathArray = getPathSegments(path2);
    for (let i = 0; i < pathArray.length; i++) {
      const p = pathArray[i];
      if (!isObj(object[p])) {
        object[p] = {};
      }
      if (i === pathArray.length - 1) {
        object[p] = value;
      }
      object = object[p];
    }
    return root;
  },
  delete(object, path2) {
    if (!isObj(object) || typeof path2 !== "string") {
      return false;
    }
    const pathArray = getPathSegments(path2);
    for (let i = 0; i < pathArray.length; i++) {
      const p = pathArray[i];
      if (i === pathArray.length - 1) {
        delete object[p];
        return true;
      }
      object = object[p];
      if (!isObj(object)) {
        return false;
      }
    }
  },
  has(object, path2) {
    if (!isObj(object) || typeof path2 !== "string") {
      return false;
    }
    const pathArray = getPathSegments(path2);
    if (pathArray.length === 0) {
      return false;
    }
    for (let i = 0; i < pathArray.length; i++) {
      if (isObj(object)) {
        if (!(pathArray[i] in object)) {
          return false;
        }
        object = object[pathArray[i]];
      } else {
        return false;
      }
    }
    return true;
  }
};
var pkgUp = { exports: {} };
var findUp$1 = { exports: {} };
var locatePath$1 = { exports: {} };
var pathExists$1 = { exports: {} };
const fs$2 = require$$0$3;
pathExists$1.exports = (fp) => new Promise((resolve2) => {
  fs$2.access(fp, (err) => {
    resolve2(!err);
  });
});
pathExists$1.exports.sync = (fp) => {
  try {
    fs$2.accessSync(fp);
    return true;
  } catch (err) {
    return false;
  }
};
var pathExistsExports = pathExists$1.exports;
var pLimit$2 = { exports: {} };
var pTry$2 = { exports: {} };
const pTry$1 = (fn, ...arguments_) => new Promise((resolve2) => {
  resolve2(fn(...arguments_));
});
pTry$2.exports = pTry$1;
pTry$2.exports.default = pTry$1;
var pTryExports = pTry$2.exports;
const pTry = pTryExports;
const pLimit$1 = (concurrency) => {
  if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
    return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
  }
  const queue = [];
  let activeCount = 0;
  const next = () => {
    activeCount--;
    if (queue.length > 0) {
      queue.shift()();
    }
  };
  const run = (fn, resolve2, ...args) => {
    activeCount++;
    const result = pTry(fn, ...args);
    resolve2(result);
    result.then(next, next);
  };
  const enqueue2 = (fn, resolve2, ...args) => {
    if (activeCount < concurrency) {
      run(fn, resolve2, ...args);
    } else {
      queue.push(run.bind(null, fn, resolve2, ...args));
    }
  };
  const generator = (fn, ...args) => new Promise((resolve2) => enqueue2(fn, resolve2, ...args));
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue.length
    },
    clearQueue: {
      value: () => {
        queue.length = 0;
      }
    }
  });
  return generator;
};
pLimit$2.exports = pLimit$1;
pLimit$2.exports.default = pLimit$1;
var pLimitExports = pLimit$2.exports;
const pLimit = pLimitExports;
class EndError extends Error {
  constructor(value) {
    super();
    this.value = value;
  }
}
const testElement = (el, tester) => Promise.resolve(el).then(tester);
const finder = (el) => Promise.all(el).then((val) => val[1] === true && Promise.reject(new EndError(val[0])));
var pLocate$1 = (iterable, tester, opts) => {
  opts = Object.assign({
    concurrency: Infinity,
    preserveOrder: true
  }, opts);
  const limit2 = pLimit(opts.concurrency);
  const items2 = [...iterable].map((el) => [el, limit2(testElement, el, tester)]);
  const checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);
  return Promise.all(items2.map((el) => checkLimit(finder, el))).then(() => {
  }).catch((err) => err instanceof EndError ? err.value : Promise.reject(err));
};
const path$5 = require$$1;
const pathExists = pathExistsExports;
const pLocate = pLocate$1;
locatePath$1.exports = (iterable, options) => {
  options = Object.assign({
    cwd: process.cwd()
  }, options);
  return pLocate(iterable, (el) => pathExists(path$5.resolve(options.cwd, el)), options);
};
locatePath$1.exports.sync = (iterable, options) => {
  options = Object.assign({
    cwd: process.cwd()
  }, options);
  for (const el of iterable) {
    if (pathExists.sync(path$5.resolve(options.cwd, el))) {
      return el;
    }
  }
};
var locatePathExports = locatePath$1.exports;
const path$4 = require$$1;
const locatePath = locatePathExports;
findUp$1.exports = (filename, opts = {}) => {
  const startDir = path$4.resolve(opts.cwd || "");
  const { root } = path$4.parse(startDir);
  const filenames = [].concat(filename);
  return new Promise((resolve2) => {
    (function find(dir) {
      locatePath(filenames, { cwd: dir }).then((file2) => {
        if (file2) {
          resolve2(path$4.join(dir, file2));
        } else if (dir === root) {
          resolve2(null);
        } else {
          find(path$4.dirname(dir));
        }
      });
    })(startDir);
  });
};
findUp$1.exports.sync = (filename, opts = {}) => {
  let dir = path$4.resolve(opts.cwd || "");
  const { root } = path$4.parse(dir);
  const filenames = [].concat(filename);
  while (true) {
    const file2 = locatePath.sync(filenames, { cwd: dir });
    if (file2) {
      return path$4.join(dir, file2);
    }
    if (dir === root) {
      return null;
    }
    dir = path$4.dirname(dir);
  }
};
var findUpExports = findUp$1.exports;
const findUp = findUpExports;
pkgUp.exports = async ({ cwd: cwd2 } = {}) => findUp("package.json", { cwd: cwd2 });
pkgUp.exports.sync = ({ cwd: cwd2 } = {}) => findUp.sync("package.json", { cwd: cwd2 });
var pkgUpExports = pkgUp.exports;
var envPaths$1 = { exports: {} };
const path$3 = require$$1;
const os = require$$1$1;
const homedir = os.homedir();
const tmpdir = os.tmpdir();
const { env: env$1 } = process;
const macos = (name) => {
  const library = path$3.join(homedir, "Library");
  return {
    data: path$3.join(library, "Application Support", name),
    config: path$3.join(library, "Preferences", name),
    cache: path$3.join(library, "Caches", name),
    log: path$3.join(library, "Logs", name),
    temp: path$3.join(tmpdir, name)
  };
};
const windows = (name) => {
  const appData = env$1.APPDATA || path$3.join(homedir, "AppData", "Roaming");
  const localAppData = env$1.LOCALAPPDATA || path$3.join(homedir, "AppData", "Local");
  return {
    // Data/config/cache/log are invented by me as Windows isn't opinionated about this
    data: path$3.join(localAppData, name, "Data"),
    config: path$3.join(appData, name, "Config"),
    cache: path$3.join(localAppData, name, "Cache"),
    log: path$3.join(localAppData, name, "Log"),
    temp: path$3.join(tmpdir, name)
  };
};
const linux = (name) => {
  const username = path$3.basename(homedir);
  return {
    data: path$3.join(env$1.XDG_DATA_HOME || path$3.join(homedir, ".local", "share"), name),
    config: path$3.join(env$1.XDG_CONFIG_HOME || path$3.join(homedir, ".config"), name),
    cache: path$3.join(env$1.XDG_CACHE_HOME || path$3.join(homedir, ".cache"), name),
    // https://wiki.debian.org/XDGBaseDirectorySpecification#state
    log: path$3.join(env$1.XDG_STATE_HOME || path$3.join(homedir, ".local", "state"), name),
    temp: path$3.join(tmpdir, username, name)
  };
};
const envPaths = (name, options) => {
  if (typeof name !== "string") {
    throw new TypeError(`Expected string, got ${typeof name}`);
  }
  options = Object.assign({ suffix: "nodejs" }, options);
  if (options.suffix) {
    name += `-${options.suffix}`;
  }
  if (process.platform === "darwin") {
    return macos(name);
  }
  if (process.platform === "win32") {
    return windows(name);
  }
  return linux(name);
};
envPaths$1.exports = envPaths;
envPaths$1.exports.default = envPaths;
var envPathsExports = envPaths$1.exports;
var dist$1 = {};
var consts = {};
Object.defineProperty(consts, "__esModule", { value: true });
consts.NOOP = consts.LIMIT_FILES_DESCRIPTORS = consts.LIMIT_BASENAME_LENGTH = consts.IS_USER_ROOT = consts.IS_POSIX = consts.DEFAULT_TIMEOUT_SYNC = consts.DEFAULT_TIMEOUT_ASYNC = consts.DEFAULT_WRITE_OPTIONS = consts.DEFAULT_READ_OPTIONS = consts.DEFAULT_FOLDER_MODE = consts.DEFAULT_FILE_MODE = consts.DEFAULT_ENCODING = void 0;
const DEFAULT_ENCODING = "utf8";
consts.DEFAULT_ENCODING = DEFAULT_ENCODING;
const DEFAULT_FILE_MODE = 438;
consts.DEFAULT_FILE_MODE = DEFAULT_FILE_MODE;
const DEFAULT_FOLDER_MODE = 511;
consts.DEFAULT_FOLDER_MODE = DEFAULT_FOLDER_MODE;
const DEFAULT_READ_OPTIONS = {};
consts.DEFAULT_READ_OPTIONS = DEFAULT_READ_OPTIONS;
const DEFAULT_WRITE_OPTIONS = {};
consts.DEFAULT_WRITE_OPTIONS = DEFAULT_WRITE_OPTIONS;
const DEFAULT_TIMEOUT_ASYNC = 5e3;
consts.DEFAULT_TIMEOUT_ASYNC = DEFAULT_TIMEOUT_ASYNC;
const DEFAULT_TIMEOUT_SYNC = 100;
consts.DEFAULT_TIMEOUT_SYNC = DEFAULT_TIMEOUT_SYNC;
const IS_POSIX = !!process.getuid;
consts.IS_POSIX = IS_POSIX;
const IS_USER_ROOT = process.getuid ? !process.getuid() : false;
consts.IS_USER_ROOT = IS_USER_ROOT;
const LIMIT_BASENAME_LENGTH = 128;
consts.LIMIT_BASENAME_LENGTH = LIMIT_BASENAME_LENGTH;
const LIMIT_FILES_DESCRIPTORS = 1e4;
consts.LIMIT_FILES_DESCRIPTORS = LIMIT_FILES_DESCRIPTORS;
const NOOP = () => {
};
consts.NOOP = NOOP;
var fs$1 = {};
var attemptify = {};
Object.defineProperty(attemptify, "__esModule", { value: true });
attemptify.attemptifySync = attemptify.attemptifyAsync = void 0;
const consts_1$4 = consts;
const attemptifyAsync = (fn, onError = consts_1$4.NOOP) => {
  return function() {
    return fn.apply(void 0, arguments).catch(onError);
  };
};
attemptify.attemptifyAsync = attemptifyAsync;
const attemptifySync = (fn, onError = consts_1$4.NOOP) => {
  return function() {
    try {
      return fn.apply(void 0, arguments);
    } catch (error2) {
      return onError(error2);
    }
  };
};
attemptify.attemptifySync = attemptifySync;
var fs_handlers = {};
Object.defineProperty(fs_handlers, "__esModule", { value: true });
const consts_1$3 = consts;
const Handlers = {
  isChangeErrorOk: (error2) => {
    const { code: code2 } = error2;
    if (code2 === "ENOSYS")
      return true;
    if (!consts_1$3.IS_USER_ROOT && (code2 === "EINVAL" || code2 === "EPERM"))
      return true;
    return false;
  },
  isRetriableError: (error2) => {
    const { code: code2 } = error2;
    if (code2 === "EMFILE" || code2 === "ENFILE" || code2 === "EAGAIN" || code2 === "EBUSY" || code2 === "EACCESS" || code2 === "EACCS" || code2 === "EPERM")
      return true;
    return false;
  },
  onChangeError: (error2) => {
    if (Handlers.isChangeErrorOk(error2))
      return;
    throw error2;
  }
};
fs_handlers.default = Handlers;
var retryify = {};
var retryify_queue = {};
Object.defineProperty(retryify_queue, "__esModule", { value: true });
const consts_1$2 = consts;
const RetryfyQueue = {
  interval: 25,
  intervalId: void 0,
  limit: consts_1$2.LIMIT_FILES_DESCRIPTORS,
  queueActive: /* @__PURE__ */ new Set(),
  queueWaiting: /* @__PURE__ */ new Set(),
  init: () => {
    if (RetryfyQueue.intervalId)
      return;
    RetryfyQueue.intervalId = setInterval(RetryfyQueue.tick, RetryfyQueue.interval);
  },
  reset: () => {
    if (!RetryfyQueue.intervalId)
      return;
    clearInterval(RetryfyQueue.intervalId);
    delete RetryfyQueue.intervalId;
  },
  add: (fn) => {
    RetryfyQueue.queueWaiting.add(fn);
    if (RetryfyQueue.queueActive.size < RetryfyQueue.limit / 2) {
      RetryfyQueue.tick();
    } else {
      RetryfyQueue.init();
    }
  },
  remove: (fn) => {
    RetryfyQueue.queueWaiting.delete(fn);
    RetryfyQueue.queueActive.delete(fn);
  },
  schedule: () => {
    return new Promise((resolve2) => {
      const cleanup = () => RetryfyQueue.remove(resolver);
      const resolver = () => resolve2(cleanup);
      RetryfyQueue.add(resolver);
    });
  },
  tick: () => {
    if (RetryfyQueue.queueActive.size >= RetryfyQueue.limit)
      return;
    if (!RetryfyQueue.queueWaiting.size)
      return RetryfyQueue.reset();
    for (const fn of RetryfyQueue.queueWaiting) {
      if (RetryfyQueue.queueActive.size >= RetryfyQueue.limit)
        break;
      RetryfyQueue.queueWaiting.delete(fn);
      RetryfyQueue.queueActive.add(fn);
      fn();
    }
  }
};
retryify_queue.default = RetryfyQueue;
Object.defineProperty(retryify, "__esModule", { value: true });
retryify.retryifySync = retryify.retryifyAsync = void 0;
const retryify_queue_1 = retryify_queue;
const retryifyAsync = (fn, isRetriableError) => {
  return function(timestamp) {
    return function attempt() {
      return retryify_queue_1.default.schedule().then((cleanup) => {
        return fn.apply(void 0, arguments).then((result) => {
          cleanup();
          return result;
        }, (error2) => {
          cleanup();
          if (Date.now() >= timestamp)
            throw error2;
          if (isRetriableError(error2)) {
            const delay = Math.round(100 + 400 * Math.random()), delayPromise = new Promise((resolve2) => setTimeout(resolve2, delay));
            return delayPromise.then(() => attempt.apply(void 0, arguments));
          }
          throw error2;
        });
      });
    };
  };
};
retryify.retryifyAsync = retryifyAsync;
const retryifySync = (fn, isRetriableError) => {
  return function(timestamp) {
    return function attempt() {
      try {
        return fn.apply(void 0, arguments);
      } catch (error2) {
        if (Date.now() > timestamp)
          throw error2;
        if (isRetriableError(error2))
          return attempt.apply(void 0, arguments);
        throw error2;
      }
    };
  };
};
retryify.retryifySync = retryifySync;
Object.defineProperty(fs$1, "__esModule", { value: true });
const fs = require$$0$3;
const util_1$q = require$$4;
const attemptify_1 = attemptify;
const fs_handlers_1 = fs_handlers;
const retryify_1 = retryify;
const FS = {
  chmodAttempt: attemptify_1.attemptifyAsync(util_1$q.promisify(fs.chmod), fs_handlers_1.default.onChangeError),
  chownAttempt: attemptify_1.attemptifyAsync(util_1$q.promisify(fs.chown), fs_handlers_1.default.onChangeError),
  closeAttempt: attemptify_1.attemptifyAsync(util_1$q.promisify(fs.close)),
  fsyncAttempt: attemptify_1.attemptifyAsync(util_1$q.promisify(fs.fsync)),
  mkdirAttempt: attemptify_1.attemptifyAsync(util_1$q.promisify(fs.mkdir)),
  realpathAttempt: attemptify_1.attemptifyAsync(util_1$q.promisify(fs.realpath)),
  statAttempt: attemptify_1.attemptifyAsync(util_1$q.promisify(fs.stat)),
  unlinkAttempt: attemptify_1.attemptifyAsync(util_1$q.promisify(fs.unlink)),
  closeRetry: retryify_1.retryifyAsync(util_1$q.promisify(fs.close), fs_handlers_1.default.isRetriableError),
  fsyncRetry: retryify_1.retryifyAsync(util_1$q.promisify(fs.fsync), fs_handlers_1.default.isRetriableError),
  openRetry: retryify_1.retryifyAsync(util_1$q.promisify(fs.open), fs_handlers_1.default.isRetriableError),
  readFileRetry: retryify_1.retryifyAsync(util_1$q.promisify(fs.readFile), fs_handlers_1.default.isRetriableError),
  renameRetry: retryify_1.retryifyAsync(util_1$q.promisify(fs.rename), fs_handlers_1.default.isRetriableError),
  statRetry: retryify_1.retryifyAsync(util_1$q.promisify(fs.stat), fs_handlers_1.default.isRetriableError),
  writeRetry: retryify_1.retryifyAsync(util_1$q.promisify(fs.write), fs_handlers_1.default.isRetriableError),
  chmodSyncAttempt: attemptify_1.attemptifySync(fs.chmodSync, fs_handlers_1.default.onChangeError),
  chownSyncAttempt: attemptify_1.attemptifySync(fs.chownSync, fs_handlers_1.default.onChangeError),
  closeSyncAttempt: attemptify_1.attemptifySync(fs.closeSync),
  mkdirSyncAttempt: attemptify_1.attemptifySync(fs.mkdirSync),
  realpathSyncAttempt: attemptify_1.attemptifySync(fs.realpathSync),
  statSyncAttempt: attemptify_1.attemptifySync(fs.statSync),
  unlinkSyncAttempt: attemptify_1.attemptifySync(fs.unlinkSync),
  closeSyncRetry: retryify_1.retryifySync(fs.closeSync, fs_handlers_1.default.isRetriableError),
  fsyncSyncRetry: retryify_1.retryifySync(fs.fsyncSync, fs_handlers_1.default.isRetriableError),
  openSyncRetry: retryify_1.retryifySync(fs.openSync, fs_handlers_1.default.isRetriableError),
  readFileSyncRetry: retryify_1.retryifySync(fs.readFileSync, fs_handlers_1.default.isRetriableError),
  renameSyncRetry: retryify_1.retryifySync(fs.renameSync, fs_handlers_1.default.isRetriableError),
  statSyncRetry: retryify_1.retryifySync(fs.statSync, fs_handlers_1.default.isRetriableError),
  writeSyncRetry: retryify_1.retryifySync(fs.writeSync, fs_handlers_1.default.isRetriableError)
};
fs$1.default = FS;
var lang = {};
Object.defineProperty(lang, "__esModule", { value: true });
const Lang = {
  isFunction: (x) => {
    return typeof x === "function";
  },
  isString: (x) => {
    return typeof x === "string";
  },
  isUndefined: (x) => {
    return typeof x === "undefined";
  }
};
lang.default = Lang;
var scheduler = {};
Object.defineProperty(scheduler, "__esModule", { value: true });
const Queues = {};
const Scheduler = {
  next: (id2) => {
    const queue = Queues[id2];
    if (!queue)
      return;
    queue.shift();
    const job = queue[0];
    if (job) {
      job(() => Scheduler.next(id2));
    } else {
      delete Queues[id2];
    }
  },
  schedule: (id2) => {
    return new Promise((resolve2) => {
      let queue = Queues[id2];
      if (!queue)
        queue = Queues[id2] = [];
      queue.push(resolve2);
      if (queue.length > 1)
        return;
      resolve2(() => Scheduler.next(id2));
    });
  }
};
scheduler.default = Scheduler;
var temp = {};
Object.defineProperty(temp, "__esModule", { value: true });
const path$2 = require$$1;
const consts_1$1 = consts;
const fs_1$1 = fs$1;
const Temp = {
  store: {},
  create: (filePath) => {
    const randomness = `000000${Math.floor(Math.random() * 16777215).toString(16)}`.slice(-6), timestamp = Date.now().toString().slice(-10), prefix = "tmp-", suffix = `.${prefix}${timestamp}${randomness}`, tempPath = `${filePath}${suffix}`;
    return tempPath;
  },
  get: (filePath, creator, purge = true) => {
    const tempPath = Temp.truncate(creator(filePath));
    if (tempPath in Temp.store)
      return Temp.get(filePath, creator, purge);
    Temp.store[tempPath] = purge;
    const disposer = () => delete Temp.store[tempPath];
    return [tempPath, disposer];
  },
  purge: (filePath) => {
    if (!Temp.store[filePath])
      return;
    delete Temp.store[filePath];
    fs_1$1.default.unlinkAttempt(filePath);
  },
  purgeSync: (filePath) => {
    if (!Temp.store[filePath])
      return;
    delete Temp.store[filePath];
    fs_1$1.default.unlinkSyncAttempt(filePath);
  },
  purgeSyncAll: () => {
    for (const filePath in Temp.store) {
      Temp.purgeSync(filePath);
    }
  },
  truncate: (filePath) => {
    const basename = path$2.basename(filePath);
    if (basename.length <= consts_1$1.LIMIT_BASENAME_LENGTH)
      return filePath;
    const truncable = /^(\.?)(.*?)((?:\.[^.]+)?(?:\.tmp-\d{10}[a-f0-9]{6})?)$/.exec(basename);
    if (!truncable)
      return filePath;
    const truncationLength = basename.length - consts_1$1.LIMIT_BASENAME_LENGTH;
    return `${filePath.slice(0, -basename.length)}${truncable[1]}${truncable[2].slice(0, -truncationLength)}${truncable[3]}`;
  }
};
process.on("exit", Temp.purgeSyncAll);
temp.default = Temp;
Object.defineProperty(dist$1, "__esModule", { value: true });
dist$1.writeFileSync = dist$1.writeFile = dist$1.readFileSync = dist$1.readFile = void 0;
const path$1 = require$$1;
const consts_1 = consts;
const fs_1 = fs$1;
const lang_1 = lang;
const scheduler_1 = scheduler;
const temp_1 = temp;
function readFile(filePath, options = consts_1.DEFAULT_READ_OPTIONS) {
  var _a;
  if (lang_1.default.isString(options))
    return readFile(filePath, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_ASYNC);
  return fs_1.default.readFileRetry(timeout)(filePath, options);
}
dist$1.readFile = readFile;
function readFileSync(filePath, options = consts_1.DEFAULT_READ_OPTIONS) {
  var _a;
  if (lang_1.default.isString(options))
    return readFileSync(filePath, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_SYNC);
  return fs_1.default.readFileSyncRetry(timeout)(filePath, options);
}
dist$1.readFileSync = readFileSync;
const writeFile = (filePath, data, options, callback) => {
  if (lang_1.default.isFunction(options))
    return writeFile(filePath, data, consts_1.DEFAULT_WRITE_OPTIONS, options);
  const promise = writeFileAsync(filePath, data, options);
  if (callback)
    promise.then(callback, callback);
  return promise;
};
dist$1.writeFile = writeFile;
const writeFileAsync = async (filePath, data, options = consts_1.DEFAULT_WRITE_OPTIONS) => {
  var _a;
  if (lang_1.default.isString(options))
    return writeFileAsync(filePath, data, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_ASYNC);
  let schedulerCustomDisposer = null, schedulerDisposer = null, tempDisposer = null, tempPath = null, fd = null;
  try {
    if (options.schedule)
      schedulerCustomDisposer = await options.schedule(filePath);
    schedulerDisposer = await scheduler_1.default.schedule(filePath);
    filePath = await fs_1.default.realpathAttempt(filePath) || filePath;
    [tempPath, tempDisposer] = temp_1.default.get(filePath, options.tmpCreate || temp_1.default.create, !(options.tmpPurge === false));
    const useStatChown = consts_1.IS_POSIX && lang_1.default.isUndefined(options.chown), useStatMode = lang_1.default.isUndefined(options.mode);
    if (useStatChown || useStatMode) {
      const stat2 = await fs_1.default.statAttempt(filePath);
      if (stat2) {
        options = { ...options };
        if (useStatChown)
          options.chown = { uid: stat2.uid, gid: stat2.gid };
        if (useStatMode)
          options.mode = stat2.mode;
      }
    }
    const parentPath = path$1.dirname(filePath);
    await fs_1.default.mkdirAttempt(parentPath, {
      mode: consts_1.DEFAULT_FOLDER_MODE,
      recursive: true
    });
    fd = await fs_1.default.openRetry(timeout)(tempPath, "w", options.mode || consts_1.DEFAULT_FILE_MODE);
    if (options.tmpCreated)
      options.tmpCreated(tempPath);
    if (lang_1.default.isString(data)) {
      await fs_1.default.writeRetry(timeout)(fd, data, 0, options.encoding || consts_1.DEFAULT_ENCODING);
    } else if (!lang_1.default.isUndefined(data)) {
      await fs_1.default.writeRetry(timeout)(fd, data, 0, data.length, 0);
    }
    if (options.fsync !== false) {
      if (options.fsyncWait !== false) {
        await fs_1.default.fsyncRetry(timeout)(fd);
      } else {
        fs_1.default.fsyncAttempt(fd);
      }
    }
    await fs_1.default.closeRetry(timeout)(fd);
    fd = null;
    if (options.chown)
      await fs_1.default.chownAttempt(tempPath, options.chown.uid, options.chown.gid);
    if (options.mode)
      await fs_1.default.chmodAttempt(tempPath, options.mode);
    try {
      await fs_1.default.renameRetry(timeout)(tempPath, filePath);
    } catch (error2) {
      if (error2.code !== "ENAMETOOLONG")
        throw error2;
      await fs_1.default.renameRetry(timeout)(tempPath, temp_1.default.truncate(filePath));
    }
    tempDisposer();
    tempPath = null;
  } finally {
    if (fd)
      await fs_1.default.closeAttempt(fd);
    if (tempPath)
      temp_1.default.purge(tempPath);
    if (schedulerCustomDisposer)
      schedulerCustomDisposer();
    if (schedulerDisposer)
      schedulerDisposer();
  }
};
const writeFileSync = (filePath, data, options = consts_1.DEFAULT_WRITE_OPTIONS) => {
  var _a;
  if (lang_1.default.isString(options))
    return writeFileSync(filePath, data, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_SYNC);
  let tempDisposer = null, tempPath = null, fd = null;
  try {
    filePath = fs_1.default.realpathSyncAttempt(filePath) || filePath;
    [tempPath, tempDisposer] = temp_1.default.get(filePath, options.tmpCreate || temp_1.default.create, !(options.tmpPurge === false));
    const useStatChown = consts_1.IS_POSIX && lang_1.default.isUndefined(options.chown), useStatMode = lang_1.default.isUndefined(options.mode);
    if (useStatChown || useStatMode) {
      const stat2 = fs_1.default.statSyncAttempt(filePath);
      if (stat2) {
        options = { ...options };
        if (useStatChown)
          options.chown = { uid: stat2.uid, gid: stat2.gid };
        if (useStatMode)
          options.mode = stat2.mode;
      }
    }
    const parentPath = path$1.dirname(filePath);
    fs_1.default.mkdirSyncAttempt(parentPath, {
      mode: consts_1.DEFAULT_FOLDER_MODE,
      recursive: true
    });
    fd = fs_1.default.openSyncRetry(timeout)(tempPath, "w", options.mode || consts_1.DEFAULT_FILE_MODE);
    if (options.tmpCreated)
      options.tmpCreated(tempPath);
    if (lang_1.default.isString(data)) {
      fs_1.default.writeSyncRetry(timeout)(fd, data, 0, options.encoding || consts_1.DEFAULT_ENCODING);
    } else if (!lang_1.default.isUndefined(data)) {
      fs_1.default.writeSyncRetry(timeout)(fd, data, 0, data.length, 0);
    }
    if (options.fsync !== false) {
      if (options.fsyncWait !== false) {
        fs_1.default.fsyncSyncRetry(timeout)(fd);
      } else {
        fs_1.default.fsyncAttempt(fd);
      }
    }
    fs_1.default.closeSyncRetry(timeout)(fd);
    fd = null;
    if (options.chown)
      fs_1.default.chownSyncAttempt(tempPath, options.chown.uid, options.chown.gid);
    if (options.mode)
      fs_1.default.chmodSyncAttempt(tempPath, options.mode);
    try {
      fs_1.default.renameSyncRetry(timeout)(tempPath, filePath);
    } catch (error2) {
      if (error2.code !== "ENAMETOOLONG")
        throw error2;
      fs_1.default.renameSyncRetry(timeout)(tempPath, temp_1.default.truncate(filePath));
    }
    tempDisposer();
    tempPath = null;
  } finally {
    if (fd)
      fs_1.default.closeSyncAttempt(fd);
    if (tempPath)
      temp_1.default.purge(tempPath);
  }
};
dist$1.writeFileSync = writeFileSync;
var ajv = { exports: {} };
var core$2 = {};
var validate = {};
var boolSchema = {};
var errors = {};
var codegen = {};
var code$1 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.regexpCode = exports2.getEsmExportName = exports2.getProperty = exports2.safeStringify = exports2.stringify = exports2.strConcat = exports2.addCodeArg = exports2.str = exports2._ = exports2.nil = exports2._Code = exports2.Name = exports2.IDENTIFIER = exports2._CodeOrName = void 0;
  class _CodeOrName {
  }
  exports2._CodeOrName = _CodeOrName;
  exports2.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class Name extends _CodeOrName {
    constructor(s) {
      super();
      if (!exports2.IDENTIFIER.test(s))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = s;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  exports2.Name = Name;
  class _Code extends _CodeOrName {
    constructor(code2) {
      super();
      this._items = typeof code2 === "string" ? [code2] : code2;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return false;
      const item = this._items[0];
      return item === "" || item === '""';
    }
    get str() {
      var _a;
      return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
    }
    get names() {
      var _a;
      return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names2, c) => {
        if (c instanceof Name)
          names2[c.str] = (names2[c.str] || 0) + 1;
        return names2;
      }, {});
    }
  }
  exports2._Code = _Code;
  exports2.nil = new _Code("");
  function _(strs, ...args) {
    const code2 = [strs[0]];
    let i = 0;
    while (i < args.length) {
      addCodeArg(code2, args[i]);
      code2.push(strs[++i]);
    }
    return new _Code(code2);
  }
  exports2._ = _;
  const plus = new _Code("+");
  function str(strs, ...args) {
    const expr = [safeStringify(strs[0])];
    let i = 0;
    while (i < args.length) {
      expr.push(plus);
      addCodeArg(expr, args[i]);
      expr.push(plus, safeStringify(strs[++i]));
    }
    optimize(expr);
    return new _Code(expr);
  }
  exports2.str = str;
  function addCodeArg(code2, arg) {
    if (arg instanceof _Code)
      code2.push(...arg._items);
    else if (arg instanceof Name)
      code2.push(arg);
    else
      code2.push(interpolate(arg));
  }
  exports2.addCodeArg = addCodeArg;
  function optimize(expr) {
    let i = 1;
    while (i < expr.length - 1) {
      if (expr[i] === plus) {
        const res = mergeExprItems(expr[i - 1], expr[i + 1]);
        if (res !== void 0) {
          expr.splice(i - 1, 3, res);
          continue;
        }
        expr[i++] = "+";
      }
      i++;
    }
  }
  function mergeExprItems(a, b) {
    if (b === '""')
      return a;
    if (a === '""')
      return b;
    if (typeof a == "string") {
      if (b instanceof Name || a[a.length - 1] !== '"')
        return;
      if (typeof b != "string")
        return `${a.slice(0, -1)}${b}"`;
      if (b[0] === '"')
        return a.slice(0, -1) + b.slice(1);
      return;
    }
    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
      return `"${a}${b.slice(1)}`;
    return;
  }
  function strConcat(c1, c2) {
    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
  }
  exports2.strConcat = strConcat;
  function interpolate(x) {
    return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
  }
  function stringify2(x) {
    return new _Code(safeStringify(x));
  }
  exports2.stringify = stringify2;
  function safeStringify(x) {
    return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  exports2.safeStringify = safeStringify;
  function getProperty(key) {
    return typeof key == "string" && exports2.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
  }
  exports2.getProperty = getProperty;
  function getEsmExportName(key) {
    if (typeof key == "string" && exports2.IDENTIFIER.test(key)) {
      return new _Code(`${key}`);
    }
    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
  }
  exports2.getEsmExportName = getEsmExportName;
  function regexpCode(rx) {
    return new _Code(rx.toString());
  }
  exports2.regexpCode = regexpCode;
})(code$1);
var scope = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ValueScope = exports2.ValueScopeName = exports2.Scope = exports2.varKinds = exports2.UsedValueState = void 0;
  const code_12 = code$1;
  class ValueError extends Error {
    constructor(name) {
      super(`CodeGen: "code" for ${name} not defined`);
      this.value = name.value;
    }
  }
  var UsedValueState;
  (function(UsedValueState2) {
    UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
    UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
  })(UsedValueState = exports2.UsedValueState || (exports2.UsedValueState = {}));
  exports2.varKinds = {
    const: new code_12.Name("const"),
    let: new code_12.Name("let"),
    var: new code_12.Name("var")
  };
  class Scope {
    constructor({ prefixes, parent } = {}) {
      this._names = {};
      this._prefixes = prefixes;
      this._parent = parent;
    }
    toName(nameOrPrefix) {
      return nameOrPrefix instanceof code_12.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix) {
      return new code_12.Name(this._newName(prefix));
    }
    _newName(prefix) {
      const ng = this._names[prefix] || this._nameGroup(prefix);
      return `${prefix}${ng.index++}`;
    }
    _nameGroup(prefix) {
      var _a, _b;
      if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
        throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
      }
      return this._names[prefix] = { prefix, index: 0 };
    }
  }
  exports2.Scope = Scope;
  class ValueScopeName extends code_12.Name {
    constructor(prefix, nameStr) {
      super(nameStr);
      this.prefix = prefix;
    }
    setValue(value, { property, itemIndex }) {
      this.value = value;
      this.scopePath = (0, code_12._)`.${new code_12.Name(property)}[${itemIndex}]`;
    }
  }
  exports2.ValueScopeName = ValueScopeName;
  const line = (0, code_12._)`\n`;
  class ValueScope extends Scope {
    constructor(opts) {
      super(opts);
      this._values = {};
      this._scope = opts.scope;
      this.opts = { ...opts, _n: opts.lines ? line : code_12.nil };
    }
    get() {
      return this._scope;
    }
    name(prefix) {
      return new ValueScopeName(prefix, this._newName(prefix));
    }
    value(nameOrPrefix, value) {
      var _a;
      if (value.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const name = this.toName(nameOrPrefix);
      const { prefix } = name;
      const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
      let vs = this._values[prefix];
      if (vs) {
        const _name = vs.get(valueKey);
        if (_name)
          return _name;
      } else {
        vs = this._values[prefix] = /* @__PURE__ */ new Map();
      }
      vs.set(valueKey, name);
      const s = this._scope[prefix] || (this._scope[prefix] = []);
      const itemIndex = s.length;
      s[itemIndex] = value.ref;
      name.setValue(value, { property: prefix, itemIndex });
      return name;
    }
    getValue(prefix, keyOrRef) {
      const vs = this._values[prefix];
      if (!vs)
        return;
      return vs.get(keyOrRef);
    }
    scopeRefs(scopeName, values = this._values) {
      return this._reduceValues(values, (name) => {
        if (name.scopePath === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return (0, code_12._)`${scopeName}${name.scopePath}`;
      });
    }
    scopeCode(values = this._values, usedValues, getCode) {
      return this._reduceValues(values, (name) => {
        if (name.value === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return name.value.code;
      }, usedValues, getCode);
    }
    _reduceValues(values, valueCode, usedValues = {}, getCode) {
      let code2 = code_12.nil;
      for (const prefix in values) {
        const vs = values[prefix];
        if (!vs)
          continue;
        const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
        vs.forEach((name) => {
          if (nameSet.has(name))
            return;
          nameSet.set(name, UsedValueState.Started);
          let c = valueCode(name);
          if (c) {
            const def2 = this.opts.es5 ? exports2.varKinds.var : exports2.varKinds.const;
            code2 = (0, code_12._)`${code2}${def2} ${name} = ${c};${this.opts._n}`;
          } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
            code2 = (0, code_12._)`${code2}${c}${this.opts._n}`;
          } else {
            throw new ValueError(name);
          }
          nameSet.set(name, UsedValueState.Completed);
        });
      }
      return code2;
    }
  }
  exports2.ValueScope = ValueScope;
})(scope);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.or = exports2.and = exports2.not = exports2.CodeGen = exports2.operators = exports2.varKinds = exports2.ValueScopeName = exports2.ValueScope = exports2.Scope = exports2.Name = exports2.regexpCode = exports2.stringify = exports2.getProperty = exports2.nil = exports2.strConcat = exports2.str = exports2._ = void 0;
  const code_12 = code$1;
  const scope_1 = scope;
  var code_2 = code$1;
  Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
    return code_2._;
  } });
  Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
    return code_2.str;
  } });
  Object.defineProperty(exports2, "strConcat", { enumerable: true, get: function() {
    return code_2.strConcat;
  } });
  Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
    return code_2.nil;
  } });
  Object.defineProperty(exports2, "getProperty", { enumerable: true, get: function() {
    return code_2.getProperty;
  } });
  Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
    return code_2.stringify;
  } });
  Object.defineProperty(exports2, "regexpCode", { enumerable: true, get: function() {
    return code_2.regexpCode;
  } });
  Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
    return code_2.Name;
  } });
  var scope_2 = scope;
  Object.defineProperty(exports2, "Scope", { enumerable: true, get: function() {
    return scope_2.Scope;
  } });
  Object.defineProperty(exports2, "ValueScope", { enumerable: true, get: function() {
    return scope_2.ValueScope;
  } });
  Object.defineProperty(exports2, "ValueScopeName", { enumerable: true, get: function() {
    return scope_2.ValueScopeName;
  } });
  Object.defineProperty(exports2, "varKinds", { enumerable: true, get: function() {
    return scope_2.varKinds;
  } });
  exports2.operators = {
    GT: new code_12._Code(">"),
    GTE: new code_12._Code(">="),
    LT: new code_12._Code("<"),
    LTE: new code_12._Code("<="),
    EQ: new code_12._Code("==="),
    NEQ: new code_12._Code("!=="),
    NOT: new code_12._Code("!"),
    OR: new code_12._Code("||"),
    AND: new code_12._Code("&&"),
    ADD: new code_12._Code("+")
  };
  class Node2 {
    optimizeNodes() {
      return this;
    }
    optimizeNames(_names, _constants) {
      return this;
    }
  }
  class Def extends Node2 {
    constructor(varKind, name, rhs) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.rhs = rhs;
    }
    render({ es5, _n }) {
      const varKind = es5 ? scope_1.varKinds.var : this.varKind;
      const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${varKind} ${this.name}${rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (!names2[this.name.str])
        return;
      if (this.rhs)
        this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      return this.rhs instanceof code_12._CodeOrName ? this.rhs.names : {};
    }
  }
  class Assign extends Node2 {
    constructor(lhs, rhs, sideEffects) {
      super();
      this.lhs = lhs;
      this.rhs = rhs;
      this.sideEffects = sideEffects;
    }
    render({ _n }) {
      return `${this.lhs} = ${this.rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (this.lhs instanceof code_12.Name && !names2[this.lhs.str] && !this.sideEffects)
        return;
      this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      const names2 = this.lhs instanceof code_12.Name ? {} : { ...this.lhs.names };
      return addExprNames(names2, this.rhs);
    }
  }
  class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
      super(lhs, rhs, sideEffects);
      this.op = op;
    }
    render({ _n }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
    }
  }
  class Label extends Node2 {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      return `${this.label}:` + _n;
    }
  }
  class Break extends Node2 {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      const label = this.label ? ` ${this.label}` : "";
      return `break${label};` + _n;
    }
  }
  class Throw extends Node2 {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render({ _n }) {
      return `throw ${this.error};` + _n;
    }
    get names() {
      return this.error.names;
    }
  }
  class AnyCode extends Node2 {
    constructor(code2) {
      super();
      this.code = code2;
    }
    render({ _n }) {
      return `${this.code};` + _n;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      this.code = optimizeExpr(this.code, names2, constants2);
      return this;
    }
    get names() {
      return this.code instanceof code_12._CodeOrName ? this.code.names : {};
    }
  }
  class ParentNode extends Node2 {
    constructor(nodes = []) {
      super();
      this.nodes = nodes;
    }
    render(opts) {
      return this.nodes.reduce((code2, n) => code2 + n.render(opts), "");
    }
    optimizeNodes() {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i].optimizeNodes();
        if (Array.isArray(n))
          nodes.splice(i, 1, ...n);
        else if (n)
          nodes[i] = n;
        else
          nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i];
        if (n.optimizeNames(names2, constants2))
          continue;
        subtractNames(names2, n.names);
        nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((names2, n) => addNames(names2, n.names), {});
    }
  }
  class BlockNode extends ParentNode {
    render(opts) {
      return "{" + opts._n + super.render(opts) + "}" + opts._n;
    }
  }
  class Root extends ParentNode {
  }
  class Else extends BlockNode {
  }
  Else.kind = "else";
  class If extends BlockNode {
    constructor(condition, nodes) {
      super(nodes);
      this.condition = condition;
    }
    render(opts) {
      let code2 = `if(${this.condition})` + super.render(opts);
      if (this.else)
        code2 += "else " + this.else.render(opts);
      return code2;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const cond = this.condition;
      if (cond === true)
        return this.nodes;
      let e = this.else;
      if (e) {
        const ns = e.optimizeNodes();
        e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
      }
      if (e) {
        if (cond === false)
          return e instanceof If ? e : e.nodes;
        if (this.nodes.length)
          return this;
        return new If(not2(cond), e instanceof If ? [e] : e.nodes);
      }
      if (cond === false || !this.nodes.length)
        return void 0;
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a;
      this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants2);
      if (!(super.optimizeNames(names2, constants2) || this.else))
        return;
      this.condition = optimizeExpr(this.condition, names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      addExprNames(names2, this.condition);
      if (this.else)
        addNames(names2, this.else.names);
      return names2;
    }
  }
  If.kind = "if";
  class For extends BlockNode {
  }
  For.kind = "for";
  class ForLoop extends For {
    constructor(iteration) {
      super();
      this.iteration = iteration;
    }
    render(opts) {
      return `for(${this.iteration})` + super.render(opts);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iteration = optimizeExpr(this.iteration, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iteration.names);
    }
  }
  class ForRange extends For {
    constructor(varKind, name, from, to) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.from = from;
      this.to = to;
    }
    render(opts) {
      const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
      const { name, from, to } = this;
      return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
    }
    get names() {
      const names2 = addExprNames(super.names, this.from);
      return addExprNames(names2, this.to);
    }
  }
  class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
      super();
      this.loop = loop;
      this.varKind = varKind;
      this.name = name;
      this.iterable = iterable;
    }
    render(opts) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iterable = optimizeExpr(this.iterable, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iterable.names);
    }
  }
  class Func extends BlockNode {
    constructor(name, args, async) {
      super();
      this.name = name;
      this.args = args;
      this.async = async;
    }
    render(opts) {
      const _async = this.async ? "async " : "";
      return `${_async}function ${this.name}(${this.args})` + super.render(opts);
    }
  }
  Func.kind = "func";
  class Return extends ParentNode {
    render(opts) {
      return "return " + super.render(opts);
    }
  }
  Return.kind = "return";
  class Try extends BlockNode {
    render(opts) {
      let code2 = "try" + super.render(opts);
      if (this.catch)
        code2 += this.catch.render(opts);
      if (this.finally)
        code2 += this.finally.render(opts);
      return code2;
    }
    optimizeNodes() {
      var _a, _b;
      super.optimizeNodes();
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a, _b;
      super.optimizeNames(names2, constants2);
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants2);
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      if (this.catch)
        addNames(names2, this.catch.names);
      if (this.finally)
        addNames(names2, this.finally.names);
      return names2;
    }
  }
  class Catch extends BlockNode {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render(opts) {
      return `catch(${this.error})` + super.render(opts);
    }
  }
  Catch.kind = "catch";
  class Finally extends BlockNode {
    render(opts) {
      return "finally" + super.render(opts);
    }
  }
  Finally.kind = "finally";
  class CodeGen {
    constructor(extScope, opts = {}) {
      this._values = {};
      this._blockStarts = [];
      this._constants = {};
      this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
      this._extScope = extScope;
      this._scope = new scope_1.Scope({ parent: extScope });
      this._nodes = [new Root()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(prefix) {
      return this._scope.name(prefix);
    }
    // reserves unique name in the external scope
    scopeName(prefix) {
      return this._extScope.name(prefix);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(prefixOrName, value) {
      const name = this._extScope.value(prefixOrName, value);
      const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
      vs.add(name);
      return name;
    }
    getScopeValue(prefix, keyOrRef) {
      return this._extScope.getValue(prefix, keyOrRef);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(scopeName) {
      return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant) {
      const name = this._scope.toName(nameOrPrefix);
      if (rhs !== void 0 && constant)
        this._constants[name.str] = rhs;
      this._leafNode(new Def(varKind, name, rhs));
      return name;
    }
    // `const` declaration (`var` in es5 mode)
    const(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    // `var` declaration with optional assignment
    var(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    // assignment code
    assign(lhs, rhs, sideEffects) {
      return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    // `+=` code
    add(lhs, rhs) {
      return this._leafNode(new AssignOp(lhs, exports2.operators.ADD, rhs));
    }
    // appends passed SafeExpr to code or executes Block
    code(c) {
      if (typeof c == "function")
        c();
      else if (c !== code_12.nil)
        this._leafNode(new AnyCode(c));
      return this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...keyValues) {
      const code2 = ["{"];
      for (const [key, value] of keyValues) {
        if (code2.length > 1)
          code2.push(",");
        code2.push(key);
        if (key !== value || this.opts.es5) {
          code2.push(":");
          (0, code_12.addCodeArg)(code2, value);
        }
      }
      code2.push("}");
      return new code_12._Code(code2);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(condition, thenBody, elseBody) {
      this._blockNode(new If(condition));
      if (thenBody && elseBody) {
        this.code(thenBody).else().code(elseBody).endIf();
      } else if (thenBody) {
        this.code(thenBody).endIf();
      } else if (elseBody) {
        throw new Error('CodeGen: "else" body without "then" body');
      }
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(condition) {
      return this._elseNode(new If(condition));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new Else());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(If, Else);
    }
    _for(node, forBody) {
      this._blockNode(node);
      if (forBody)
        this.code(forBody).endFor();
      return this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(iteration, forBody) {
      return this._for(new ForLoop(iteration), forBody);
    }
    // `for` statement for a range of values
    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
      const name = this._scope.toName(nameOrPrefix);
      if (this.opts.es5) {
        const arr = iterable instanceof code_12.Name ? iterable : this.var("_arr", iterable);
        return this.forRange("_i", 0, (0, code_12._)`${arr}.length`, (i) => {
          this.var(name, (0, code_12._)`${arr}[${i}]`);
          forBody(name);
        });
      }
      return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
      if (this.opts.ownProperties) {
        return this.forOf(nameOrPrefix, (0, code_12._)`Object.keys(${obj})`, forBody);
      }
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(For);
    }
    // `label` statement
    label(label) {
      return this._leafNode(new Label(label));
    }
    // `break` statement
    break(label) {
      return this._leafNode(new Break(label));
    }
    // `return` statement
    return(value) {
      const node = new Return();
      this._blockNode(node);
      this.code(value);
      if (node.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(Return);
    }
    // `try` statement
    try(tryBody, catchCode, finallyCode) {
      if (!catchCode && !finallyCode)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const node = new Try();
      this._blockNode(node);
      this.code(tryBody);
      if (catchCode) {
        const error2 = this.name("e");
        this._currNode = node.catch = new Catch(error2);
        catchCode(error2);
      }
      if (finallyCode) {
        this._currNode = node.finally = new Finally();
        this.code(finallyCode);
      }
      return this._endBlockNode(Catch, Finally);
    }
    // `throw` statement
    throw(error2) {
      return this._leafNode(new Throw(error2));
    }
    // start self-balancing block
    block(body, nodeCount) {
      this._blockStarts.push(this._nodes.length);
      if (body)
        this.code(body).endBlock(nodeCount);
      return this;
    }
    // end the current self-balancing block
    endBlock(nodeCount) {
      const len = this._blockStarts.pop();
      if (len === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const toClose = this._nodes.length - len;
      if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
        throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
      }
      this._nodes.length = len;
      return this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(name, args = code_12.nil, async, funcBody) {
      this._blockNode(new Func(name, args, async));
      if (funcBody)
        this.code(funcBody).endFunc();
      return this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(Func);
    }
    optimize(n = 1) {
      while (n-- > 0) {
        this._root.optimizeNodes();
        this._root.optimizeNames(this._root.names, this._constants);
      }
    }
    _leafNode(node) {
      this._currNode.nodes.push(node);
      return this;
    }
    _blockNode(node) {
      this._currNode.nodes.push(node);
      this._nodes.push(node);
    }
    _endBlockNode(N1, N2) {
      const n = this._currNode;
      if (n instanceof N1 || N2 && n instanceof N2) {
        this._nodes.pop();
        return this;
      }
      throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
    }
    _elseNode(node) {
      const n = this._currNode;
      if (!(n instanceof If)) {
        throw new Error('CodeGen: "else" without "if"');
      }
      this._currNode = n.else = node;
      return this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const ns = this._nodes;
      return ns[ns.length - 1];
    }
    set _currNode(node) {
      const ns = this._nodes;
      ns[ns.length - 1] = node;
    }
  }
  exports2.CodeGen = CodeGen;
  function addNames(names2, from) {
    for (const n in from)
      names2[n] = (names2[n] || 0) + (from[n] || 0);
    return names2;
  }
  function addExprNames(names2, from) {
    return from instanceof code_12._CodeOrName ? addNames(names2, from.names) : names2;
  }
  function optimizeExpr(expr, names2, constants2) {
    if (expr instanceof code_12.Name)
      return replaceName(expr);
    if (!canOptimize(expr))
      return expr;
    return new code_12._Code(expr._items.reduce((items2, c) => {
      if (c instanceof code_12.Name)
        c = replaceName(c);
      if (c instanceof code_12._Code)
        items2.push(...c._items);
      else
        items2.push(c);
      return items2;
    }, []));
    function replaceName(n) {
      const c = constants2[n.str];
      if (c === void 0 || names2[n.str] !== 1)
        return n;
      delete names2[n.str];
      return c;
    }
    function canOptimize(e) {
      return e instanceof code_12._Code && e._items.some((c) => c instanceof code_12.Name && names2[c.str] === 1 && constants2[c.str] !== void 0);
    }
  }
  function subtractNames(names2, from) {
    for (const n in from)
      names2[n] = (names2[n] || 0) - (from[n] || 0);
  }
  function not2(x) {
    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_12._)`!${par(x)}`;
  }
  exports2.not = not2;
  const andCode = mappend(exports2.operators.AND);
  function and(...args) {
    return args.reduce(andCode);
  }
  exports2.and = and;
  const orCode = mappend(exports2.operators.OR);
  function or(...args) {
    return args.reduce(orCode);
  }
  exports2.or = or;
  function mappend(op) {
    return (x, y) => x === code_12.nil ? y : y === code_12.nil ? x : (0, code_12._)`${par(x)} ${op} ${par(y)}`;
  }
  function par(x) {
    return x instanceof code_12.Name ? x : (0, code_12._)`(${x})`;
  }
})(codegen);
var util = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.checkStrictMode = exports2.getErrorPath = exports2.Type = exports2.useFunc = exports2.setEvaluated = exports2.evaluatedPropsToName = exports2.mergeEvaluated = exports2.eachItem = exports2.unescapeJsonPointer = exports2.escapeJsonPointer = exports2.escapeFragment = exports2.unescapeFragment = exports2.schemaRefOrVal = exports2.schemaHasRulesButRef = exports2.schemaHasRules = exports2.checkUnknownRules = exports2.alwaysValidSchema = exports2.toHash = void 0;
  const codegen_12 = codegen;
  const code_12 = code$1;
  function toHash(arr) {
    const hash = {};
    for (const item of arr)
      hash[item] = true;
    return hash;
  }
  exports2.toHash = toHash;
  function alwaysValidSchema(it, schema2) {
    if (typeof schema2 == "boolean")
      return schema2;
    if (Object.keys(schema2).length === 0)
      return true;
    checkUnknownRules(it, schema2);
    return !schemaHasRules(schema2, it.self.RULES.all);
  }
  exports2.alwaysValidSchema = alwaysValidSchema;
  function checkUnknownRules(it, schema2 = it.schema) {
    const { opts, self: self2 } = it;
    if (!opts.strictSchema)
      return;
    if (typeof schema2 === "boolean")
      return;
    const rules2 = self2.RULES.keywords;
    for (const key in schema2) {
      if (!rules2[key])
        checkStrictMode(it, `unknown keyword: "${key}"`);
    }
  }
  exports2.checkUnknownRules = checkUnknownRules;
  function schemaHasRules(schema2, rules2) {
    if (typeof schema2 == "boolean")
      return !schema2;
    for (const key in schema2)
      if (rules2[key])
        return true;
    return false;
  }
  exports2.schemaHasRules = schemaHasRules;
  function schemaHasRulesButRef(schema2, RULES) {
    if (typeof schema2 == "boolean")
      return !schema2;
    for (const key in schema2)
      if (key !== "$ref" && RULES.all[key])
        return true;
    return false;
  }
  exports2.schemaHasRulesButRef = schemaHasRulesButRef;
  function schemaRefOrVal({ topSchemaRef, schemaPath }, schema2, keyword2, $data) {
    if (!$data) {
      if (typeof schema2 == "number" || typeof schema2 == "boolean")
        return schema2;
      if (typeof schema2 == "string")
        return (0, codegen_12._)`${schema2}`;
    }
    return (0, codegen_12._)`${topSchemaRef}${schemaPath}${(0, codegen_12.getProperty)(keyword2)}`;
  }
  exports2.schemaRefOrVal = schemaRefOrVal;
  function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
  }
  exports2.unescapeFragment = unescapeFragment;
  function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
  }
  exports2.escapeFragment = escapeFragment;
  function escapeJsonPointer(str) {
    if (typeof str == "number")
      return `${str}`;
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  exports2.escapeJsonPointer = escapeJsonPointer;
  function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  exports2.unescapeJsonPointer = unescapeJsonPointer;
  function eachItem(xs, f) {
    if (Array.isArray(xs)) {
      for (const x of xs)
        f(x);
    } else {
      f(xs);
    }
  }
  exports2.eachItem = eachItem;
  function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
    return (gen, from, to, toName) => {
      const res = to === void 0 ? from : to instanceof codegen_12.Name ? (from instanceof codegen_12.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_12.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
      return toName === codegen_12.Name && !(res instanceof codegen_12.Name) ? resultToName(gen, res) : res;
    };
  }
  exports2.mergeEvaluated = {
    props: makeMergeEvaluated({
      mergeNames: (gen, from, to) => gen.if((0, codegen_12._)`${to} !== true && ${from} !== undefined`, () => {
        gen.if((0, codegen_12._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_12._)`${to} || {}`).code((0, codegen_12._)`Object.assign(${to}, ${from})`));
      }),
      mergeToName: (gen, from, to) => gen.if((0, codegen_12._)`${to} !== true`, () => {
        if (from === true) {
          gen.assign(to, true);
        } else {
          gen.assign(to, (0, codegen_12._)`${to} || {}`);
          setEvaluated(gen, to, from);
        }
      }),
      mergeValues: (from, to) => from === true ? true : { ...from, ...to },
      resultToName: evaluatedPropsToName
    }),
    items: makeMergeEvaluated({
      mergeNames: (gen, from, to) => gen.if((0, codegen_12._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_12._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
      mergeToName: (gen, from, to) => gen.if((0, codegen_12._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_12._)`${to} > ${from} ? ${to} : ${from}`)),
      mergeValues: (from, to) => from === true ? true : Math.max(from, to),
      resultToName: (gen, items2) => gen.var("items", items2)
    })
  };
  function evaluatedPropsToName(gen, ps) {
    if (ps === true)
      return gen.var("props", true);
    const props = gen.var("props", (0, codegen_12._)`{}`);
    if (ps !== void 0)
      setEvaluated(gen, props, ps);
    return props;
  }
  exports2.evaluatedPropsToName = evaluatedPropsToName;
  function setEvaluated(gen, props, ps) {
    Object.keys(ps).forEach((p) => gen.assign((0, codegen_12._)`${props}${(0, codegen_12.getProperty)(p)}`, true));
  }
  exports2.setEvaluated = setEvaluated;
  const snippets = {};
  function useFunc(gen, f) {
    return gen.scopeValue("func", {
      ref: f,
      code: snippets[f.code] || (snippets[f.code] = new code_12._Code(f.code))
    });
  }
  exports2.useFunc = useFunc;
  var Type;
  (function(Type2) {
    Type2[Type2["Num"] = 0] = "Num";
    Type2[Type2["Str"] = 1] = "Str";
  })(Type = exports2.Type || (exports2.Type = {}));
  function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
    if (dataProp instanceof codegen_12.Name) {
      const isNumber = dataPropType === Type.Num;
      return jsPropertySyntax ? isNumber ? (0, codegen_12._)`"[" + ${dataProp} + "]"` : (0, codegen_12._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_12._)`"/" + ${dataProp}` : (0, codegen_12._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return jsPropertySyntax ? (0, codegen_12.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
  }
  exports2.getErrorPath = getErrorPath;
  function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
    if (!mode)
      return;
    msg = `strict mode: ${msg}`;
    if (mode === true)
      throw new Error(msg);
    it.self.logger.warn(msg);
  }
  exports2.checkStrictMode = checkStrictMode;
})(util);
var names$1 = {};
Object.defineProperty(names$1, "__esModule", { value: true });
const codegen_1$t = codegen;
const names = {
  // validation function arguments
  data: new codegen_1$t.Name("data"),
  // args passed from referencing schema
  valCxt: new codegen_1$t.Name("valCxt"),
  instancePath: new codegen_1$t.Name("instancePath"),
  parentData: new codegen_1$t.Name("parentData"),
  parentDataProperty: new codegen_1$t.Name("parentDataProperty"),
  rootData: new codegen_1$t.Name("rootData"),
  dynamicAnchors: new codegen_1$t.Name("dynamicAnchors"),
  // function scoped variables
  vErrors: new codegen_1$t.Name("vErrors"),
  errors: new codegen_1$t.Name("errors"),
  this: new codegen_1$t.Name("this"),
  // "globals"
  self: new codegen_1$t.Name("self"),
  scope: new codegen_1$t.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new codegen_1$t.Name("json"),
  jsonPos: new codegen_1$t.Name("jsonPos"),
  jsonLen: new codegen_1$t.Name("jsonLen"),
  jsonPart: new codegen_1$t.Name("jsonPart")
};
names$1.default = names;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.extendErrors = exports2.resetErrorsCount = exports2.reportExtraError = exports2.reportError = exports2.keyword$DataError = exports2.keywordError = void 0;
  const codegen_12 = codegen;
  const util_12 = util;
  const names_12 = names$1;
  exports2.keywordError = {
    message: ({ keyword: keyword2 }) => (0, codegen_12.str)`must pass "${keyword2}" keyword validation`
  };
  exports2.keyword$DataError = {
    message: ({ keyword: keyword2, schemaType }) => schemaType ? (0, codegen_12.str)`"${keyword2}" keyword must be ${schemaType} ($data)` : (0, codegen_12.str)`"${keyword2}" keyword is invalid ($data)`
  };
  function reportError(cxt, error2 = exports2.keywordError, errorPaths, overrideAllErrors) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
      addError(gen, errObj);
    } else {
      returnErrors(it, (0, codegen_12._)`[${errObj}]`);
    }
  }
  exports2.reportError = reportError;
  function reportExtraError(cxt, error2 = exports2.keywordError, errorPaths) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
      returnErrors(it, names_12.default.vErrors);
    }
  }
  exports2.reportExtraError = reportExtraError;
  function resetErrorsCount(gen, errsCount) {
    gen.assign(names_12.default.errors, errsCount);
    gen.if((0, codegen_12._)`${names_12.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_12._)`${names_12.default.vErrors}.length`, errsCount), () => gen.assign(names_12.default.vErrors, null)));
  }
  exports2.resetErrorsCount = resetErrorsCount;
  function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it }) {
    if (errsCount === void 0)
      throw new Error("ajv implementation error");
    const err = gen.name("err");
    gen.forRange("i", errsCount, names_12.default.errors, (i) => {
      gen.const(err, (0, codegen_12._)`${names_12.default.vErrors}[${i}]`);
      gen.if((0, codegen_12._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_12._)`${err}.instancePath`, (0, codegen_12.strConcat)(names_12.default.instancePath, it.errorPath)));
      gen.assign((0, codegen_12._)`${err}.schemaPath`, (0, codegen_12.str)`${it.errSchemaPath}/${keyword2}`);
      if (it.opts.verbose) {
        gen.assign((0, codegen_12._)`${err}.schema`, schemaValue);
        gen.assign((0, codegen_12._)`${err}.data`, data);
      }
    });
  }
  exports2.extendErrors = extendErrors;
  function addError(gen, errObj) {
    const err = gen.const("err", errObj);
    gen.if((0, codegen_12._)`${names_12.default.vErrors} === null`, () => gen.assign(names_12.default.vErrors, (0, codegen_12._)`[${err}]`), (0, codegen_12._)`${names_12.default.vErrors}.push(${err})`);
    gen.code((0, codegen_12._)`${names_12.default.errors}++`);
  }
  function returnErrors(it, errs) {
    const { gen, validateName, schemaEnv } = it;
    if (schemaEnv.$async) {
      gen.throw((0, codegen_12._)`new ${it.ValidationError}(${errs})`);
    } else {
      gen.assign((0, codegen_12._)`${validateName}.errors`, errs);
      gen.return(false);
    }
  }
  const E = {
    keyword: new codegen_12.Name("keyword"),
    schemaPath: new codegen_12.Name("schemaPath"),
    params: new codegen_12.Name("params"),
    propertyName: new codegen_12.Name("propertyName"),
    message: new codegen_12.Name("message"),
    schema: new codegen_12.Name("schema"),
    parentSchema: new codegen_12.Name("parentSchema")
  };
  function errorObjectCode(cxt, error2, errorPaths) {
    const { createErrors } = cxt.it;
    if (createErrors === false)
      return (0, codegen_12._)`{}`;
    return errorObject(cxt, error2, errorPaths);
  }
  function errorObject(cxt, error2, errorPaths = {}) {
    const { gen, it } = cxt;
    const keyValues = [
      errorInstancePath(it, errorPaths),
      errorSchemaPath(cxt, errorPaths)
    ];
    extraErrorProps(cxt, error2, keyValues);
    return gen.object(...keyValues);
  }
  function errorInstancePath({ errorPath }, { instancePath }) {
    const instPath = instancePath ? (0, codegen_12.str)`${errorPath}${(0, util_12.getErrorPath)(instancePath, util_12.Type.Str)}` : errorPath;
    return [names_12.default.instancePath, (0, codegen_12.strConcat)(names_12.default.instancePath, instPath)];
  }
  function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
    let schPath = parentSchema ? errSchemaPath : (0, codegen_12.str)`${errSchemaPath}/${keyword2}`;
    if (schemaPath) {
      schPath = (0, codegen_12.str)`${schPath}${(0, util_12.getErrorPath)(schemaPath, util_12.Type.Str)}`;
    }
    return [E.schemaPath, schPath];
  }
  function extraErrorProps(cxt, { params, message }, keyValues) {
    const { keyword: keyword2, data, schemaValue, it } = cxt;
    const { opts, propertyName, topSchemaRef, schemaPath } = it;
    keyValues.push([E.keyword, keyword2], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_12._)`{}`]);
    if (opts.messages) {
      keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts.verbose) {
      keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_12._)`${topSchemaRef}${schemaPath}`], [names_12.default.data, data]);
    }
    if (propertyName)
      keyValues.push([E.propertyName, propertyName]);
  }
})(errors);
Object.defineProperty(boolSchema, "__esModule", { value: true });
boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
const errors_1$2 = errors;
const codegen_1$s = codegen;
const names_1$6 = names$1;
const boolError = {
  message: "boolean schema is false"
};
function topBoolOrEmptySchema(it) {
  const { gen, schema: schema2, validateName } = it;
  if (schema2 === false) {
    falseSchemaError(it, false);
  } else if (typeof schema2 == "object" && schema2.$async === true) {
    gen.return(names_1$6.default.data);
  } else {
    gen.assign((0, codegen_1$s._)`${validateName}.errors`, null);
    gen.return(true);
  }
}
boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
function boolOrEmptySchema(it, valid2) {
  const { gen, schema: schema2 } = it;
  if (schema2 === false) {
    gen.var(valid2, false);
    falseSchemaError(it);
  } else {
    gen.var(valid2, true);
  }
}
boolSchema.boolOrEmptySchema = boolOrEmptySchema;
function falseSchemaError(it, overrideAllErrors) {
  const { gen, data } = it;
  const cxt = {
    gen,
    keyword: "false schema",
    data,
    schema: false,
    schemaCode: false,
    schemaValue: false,
    params: {},
    it
  };
  (0, errors_1$2.reportError)(cxt, boolError, void 0, overrideAllErrors);
}
var dataType = {};
var rules = {};
Object.defineProperty(rules, "__esModule", { value: true });
rules.getRules = rules.isJSONType = void 0;
const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
const jsonTypes = new Set(_jsonTypes);
function isJSONType(x) {
  return typeof x == "string" && jsonTypes.has(x);
}
rules.isJSONType = isJSONType;
function getRules() {
  const groups = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...groups, integer: true, boolean: true, null: true },
    rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
rules.getRules = getRules;
var applicability = {};
Object.defineProperty(applicability, "__esModule", { value: true });
applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
function schemaHasRulesForType({ schema: schema2, self: self2 }, type2) {
  const group = self2.RULES.types[type2];
  return group && group !== true && shouldUseGroup(schema2, group);
}
applicability.schemaHasRulesForType = schemaHasRulesForType;
function shouldUseGroup(schema2, group) {
  return group.rules.some((rule) => shouldUseRule(schema2, rule));
}
applicability.shouldUseGroup = shouldUseGroup;
function shouldUseRule(schema2, rule) {
  var _a;
  return schema2[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema2[kwd] !== void 0));
}
applicability.shouldUseRule = shouldUseRule;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.reportTypeError = exports2.checkDataTypes = exports2.checkDataType = exports2.coerceAndCheckDataType = exports2.getJSONTypes = exports2.getSchemaTypes = exports2.DataType = void 0;
  const rules_1 = rules;
  const applicability_12 = applicability;
  const errors_12 = errors;
  const codegen_12 = codegen;
  const util_12 = util;
  var DataType;
  (function(DataType2) {
    DataType2[DataType2["Correct"] = 0] = "Correct";
    DataType2[DataType2["Wrong"] = 1] = "Wrong";
  })(DataType = exports2.DataType || (exports2.DataType = {}));
  function getSchemaTypes(schema2) {
    const types2 = getJSONTypes(schema2.type);
    const hasNull = types2.includes("null");
    if (hasNull) {
      if (schema2.nullable === false)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!types2.length && schema2.nullable !== void 0) {
        throw new Error('"nullable" cannot be used without "type"');
      }
      if (schema2.nullable === true)
        types2.push("null");
    }
    return types2;
  }
  exports2.getSchemaTypes = getSchemaTypes;
  function getJSONTypes(ts) {
    const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
    if (types2.every(rules_1.isJSONType))
      return types2;
    throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
  }
  exports2.getJSONTypes = getJSONTypes;
  function coerceAndCheckDataType(it, types2) {
    const { gen, data, opts } = it;
    const coerceTo = coerceToTypes(types2, opts.coerceTypes);
    const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_12.schemaHasRulesForType)(it, types2[0]));
    if (checkTypes) {
      const wrongType = checkDataTypes(types2, data, opts.strictNumbers, DataType.Wrong);
      gen.if(wrongType, () => {
        if (coerceTo.length)
          coerceData(it, types2, coerceTo);
        else
          reportTypeError(it);
      });
    }
    return checkTypes;
  }
  exports2.coerceAndCheckDataType = coerceAndCheckDataType;
  const COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function coerceToTypes(types2, coerceTypes) {
    return coerceTypes ? types2.filter((t2) => COERCIBLE.has(t2) || coerceTypes === "array" && t2 === "array") : [];
  }
  function coerceData(it, types2, coerceTo) {
    const { gen, data, opts } = it;
    const dataType2 = gen.let("dataType", (0, codegen_12._)`typeof ${data}`);
    const coerced = gen.let("coerced", (0, codegen_12._)`undefined`);
    if (opts.coerceTypes === "array") {
      gen.if((0, codegen_12._)`${dataType2} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_12._)`${data}[0]`).assign(dataType2, (0, codegen_12._)`typeof ${data}`).if(checkDataTypes(types2, data, opts.strictNumbers), () => gen.assign(coerced, data)));
    }
    gen.if((0, codegen_12._)`${coerced} !== undefined`);
    for (const t2 of coerceTo) {
      if (COERCIBLE.has(t2) || t2 === "array" && opts.coerceTypes === "array") {
        coerceSpecificType(t2);
      }
    }
    gen.else();
    reportTypeError(it);
    gen.endIf();
    gen.if((0, codegen_12._)`${coerced} !== undefined`, () => {
      gen.assign(data, coerced);
      assignParentData(it, coerced);
    });
    function coerceSpecificType(t2) {
      switch (t2) {
        case "string":
          gen.elseIf((0, codegen_12._)`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, (0, codegen_12._)`"" + ${data}`).elseIf((0, codegen_12._)`${data} === null`).assign(coerced, (0, codegen_12._)`""`);
          return;
        case "number":
          gen.elseIf((0, codegen_12._)`${dataType2} == "boolean" || ${data} === null
              || (${dataType2} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_12._)`+${data}`);
          return;
        case "integer":
          gen.elseIf((0, codegen_12._)`${dataType2} === "boolean" || ${data} === null
              || (${dataType2} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_12._)`+${data}`);
          return;
        case "boolean":
          gen.elseIf((0, codegen_12._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_12._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
          return;
        case "null":
          gen.elseIf((0, codegen_12._)`${data} === "" || ${data} === 0 || ${data} === false`);
          gen.assign(coerced, null);
          return;
        case "array":
          gen.elseIf((0, codegen_12._)`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_12._)`[${data}]`);
      }
    }
  }
  function assignParentData({ gen, parentData, parentDataProperty }, expr) {
    gen.if((0, codegen_12._)`${parentData} !== undefined`, () => gen.assign((0, codegen_12._)`${parentData}[${parentDataProperty}]`, expr));
  }
  function checkDataType(dataType2, data, strictNums, correct = DataType.Correct) {
    const EQ = correct === DataType.Correct ? codegen_12.operators.EQ : codegen_12.operators.NEQ;
    let cond;
    switch (dataType2) {
      case "null":
        return (0, codegen_12._)`${data} ${EQ} null`;
      case "array":
        cond = (0, codegen_12._)`Array.isArray(${data})`;
        break;
      case "object":
        cond = (0, codegen_12._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
        break;
      case "integer":
        cond = numCond((0, codegen_12._)`!(${data} % 1) && !isNaN(${data})`);
        break;
      case "number":
        cond = numCond();
        break;
      default:
        return (0, codegen_12._)`typeof ${data} ${EQ} ${dataType2}`;
    }
    return correct === DataType.Correct ? cond : (0, codegen_12.not)(cond);
    function numCond(_cond = codegen_12.nil) {
      return (0, codegen_12.and)((0, codegen_12._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_12._)`isFinite(${data})` : codegen_12.nil);
    }
  }
  exports2.checkDataType = checkDataType;
  function checkDataTypes(dataTypes, data, strictNums, correct) {
    if (dataTypes.length === 1) {
      return checkDataType(dataTypes[0], data, strictNums, correct);
    }
    let cond;
    const types2 = (0, util_12.toHash)(dataTypes);
    if (types2.array && types2.object) {
      const notObj = (0, codegen_12._)`typeof ${data} != "object"`;
      cond = types2.null ? notObj : (0, codegen_12._)`!${data} || ${notObj}`;
      delete types2.null;
      delete types2.array;
      delete types2.object;
    } else {
      cond = codegen_12.nil;
    }
    if (types2.number)
      delete types2.integer;
    for (const t2 in types2)
      cond = (0, codegen_12.and)(cond, checkDataType(t2, data, strictNums, correct));
    return cond;
  }
  exports2.checkDataTypes = checkDataTypes;
  const typeError = {
    message: ({ schema: schema2 }) => `must be ${schema2}`,
    params: ({ schema: schema2, schemaValue }) => typeof schema2 == "string" ? (0, codegen_12._)`{type: ${schema2}}` : (0, codegen_12._)`{type: ${schemaValue}}`
  };
  function reportTypeError(it) {
    const cxt = getTypeErrorContext(it);
    (0, errors_12.reportError)(cxt, typeError);
  }
  exports2.reportTypeError = reportTypeError;
  function getTypeErrorContext(it) {
    const { gen, data, schema: schema2 } = it;
    const schemaCode = (0, util_12.schemaRefOrVal)(it, schema2, "type");
    return {
      gen,
      keyword: "type",
      data,
      schema: schema2.type,
      schemaCode,
      schemaValue: schemaCode,
      parentSchema: schema2,
      params: {},
      it
    };
  }
})(dataType);
var defaults = {};
Object.defineProperty(defaults, "__esModule", { value: true });
defaults.assignDefaults = void 0;
const codegen_1$r = codegen;
const util_1$p = util;
function assignDefaults(it, ty) {
  const { properties: properties2, items: items2 } = it.schema;
  if (ty === "object" && properties2) {
    for (const key in properties2) {
      assignDefault(it, key, properties2[key].default);
    }
  } else if (ty === "array" && Array.isArray(items2)) {
    items2.forEach((sch, i) => assignDefault(it, i, sch.default));
  }
}
defaults.assignDefaults = assignDefaults;
function assignDefault(it, prop, defaultValue) {
  const { gen, compositeRule, data, opts } = it;
  if (defaultValue === void 0)
    return;
  const childData = (0, codegen_1$r._)`${data}${(0, codegen_1$r.getProperty)(prop)}`;
  if (compositeRule) {
    (0, util_1$p.checkStrictMode)(it, `default is ignored for: ${childData}`);
    return;
  }
  let condition = (0, codegen_1$r._)`${childData} === undefined`;
  if (opts.useDefaults === "empty") {
    condition = (0, codegen_1$r._)`${condition} || ${childData} === null || ${childData} === ""`;
  }
  gen.if(condition, (0, codegen_1$r._)`${childData} = ${(0, codegen_1$r.stringify)(defaultValue)}`);
}
var keyword = {};
var code = {};
Object.defineProperty(code, "__esModule", { value: true });
code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
const codegen_1$q = codegen;
const util_1$o = util;
const names_1$5 = names$1;
const util_2$1 = util;
function checkReportMissingProp(cxt, prop) {
  const { gen, data, it } = cxt;
  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
    cxt.setParams({ missingProperty: (0, codegen_1$q._)`${prop}` }, true);
    cxt.error();
  });
}
code.checkReportMissingProp = checkReportMissingProp;
function checkMissingProp({ gen, data, it: { opts } }, properties2, missing) {
  return (0, codegen_1$q.or)(...properties2.map((prop) => (0, codegen_1$q.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1$q._)`${missing} = ${prop}`)));
}
code.checkMissingProp = checkMissingProp;
function reportMissingProp(cxt, missing) {
  cxt.setParams({ missingProperty: missing }, true);
  cxt.error();
}
code.reportMissingProp = reportMissingProp;
function hasPropFunc(gen) {
  return gen.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: (0, codegen_1$q._)`Object.prototype.hasOwnProperty`
  });
}
code.hasPropFunc = hasPropFunc;
function isOwnProperty(gen, data, property) {
  return (0, codegen_1$q._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
}
code.isOwnProperty = isOwnProperty;
function propertyInData(gen, data, property, ownProperties) {
  const cond = (0, codegen_1$q._)`${data}${(0, codegen_1$q.getProperty)(property)} !== undefined`;
  return ownProperties ? (0, codegen_1$q._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
}
code.propertyInData = propertyInData;
function noPropertyInData(gen, data, property, ownProperties) {
  const cond = (0, codegen_1$q._)`${data}${(0, codegen_1$q.getProperty)(property)} === undefined`;
  return ownProperties ? (0, codegen_1$q.or)(cond, (0, codegen_1$q.not)(isOwnProperty(gen, data, property))) : cond;
}
code.noPropertyInData = noPropertyInData;
function allSchemaProperties(schemaMap) {
  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
}
code.allSchemaProperties = allSchemaProperties;
function schemaProperties(it, schemaMap) {
  return allSchemaProperties(schemaMap).filter((p) => !(0, util_1$o.alwaysValidSchema)(it, schemaMap[p]));
}
code.schemaProperties = schemaProperties;
function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
  const dataAndSchema = passSchema ? (0, codegen_1$q._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
  const valCxt = [
    [names_1$5.default.instancePath, (0, codegen_1$q.strConcat)(names_1$5.default.instancePath, errorPath)],
    [names_1$5.default.parentData, it.parentData],
    [names_1$5.default.parentDataProperty, it.parentDataProperty],
    [names_1$5.default.rootData, names_1$5.default.rootData]
  ];
  if (it.opts.dynamicRef)
    valCxt.push([names_1$5.default.dynamicAnchors, names_1$5.default.dynamicAnchors]);
  const args = (0, codegen_1$q._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
  return context !== codegen_1$q.nil ? (0, codegen_1$q._)`${func}.call(${context}, ${args})` : (0, codegen_1$q._)`${func}(${args})`;
}
code.callValidateCode = callValidateCode;
const newRegExp = (0, codegen_1$q._)`new RegExp`;
function usePattern({ gen, it: { opts } }, pattern2) {
  const u2 = opts.unicodeRegExp ? "u" : "";
  const { regExp } = opts.code;
  const rx = regExp(pattern2, u2);
  return gen.scopeValue("pattern", {
    key: rx.toString(),
    ref: rx,
    code: (0, codegen_1$q._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2$1.useFunc)(gen, regExp)}(${pattern2}, ${u2})`
  });
}
code.usePattern = usePattern;
function validateArray(cxt) {
  const { gen, data, keyword: keyword2, it } = cxt;
  const valid2 = gen.name("valid");
  if (it.allErrors) {
    const validArr = gen.let("valid", true);
    validateItems(() => gen.assign(validArr, false));
    return validArr;
  }
  gen.var(valid2, true);
  validateItems(() => gen.break());
  return valid2;
  function validateItems(notValid) {
    const len = gen.const("len", (0, codegen_1$q._)`${data}.length`);
    gen.forRange("i", 0, len, (i) => {
      cxt.subschema({
        keyword: keyword2,
        dataProp: i,
        dataPropType: util_1$o.Type.Num
      }, valid2);
      gen.if((0, codegen_1$q.not)(valid2), notValid);
    });
  }
}
code.validateArray = validateArray;
function validateUnion(cxt) {
  const { gen, schema: schema2, keyword: keyword2, it } = cxt;
  if (!Array.isArray(schema2))
    throw new Error("ajv implementation error");
  const alwaysValid = schema2.some((sch) => (0, util_1$o.alwaysValidSchema)(it, sch));
  if (alwaysValid && !it.opts.unevaluated)
    return;
  const valid2 = gen.let("valid", false);
  const schValid = gen.name("_valid");
  gen.block(() => schema2.forEach((_sch, i) => {
    const schCxt = cxt.subschema({
      keyword: keyword2,
      schemaProp: i,
      compositeRule: true
    }, schValid);
    gen.assign(valid2, (0, codegen_1$q._)`${valid2} || ${schValid}`);
    const merged = cxt.mergeValidEvaluated(schCxt, schValid);
    if (!merged)
      gen.if((0, codegen_1$q.not)(valid2));
  }));
  cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
}
code.validateUnion = validateUnion;
Object.defineProperty(keyword, "__esModule", { value: true });
keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
const codegen_1$p = codegen;
const names_1$4 = names$1;
const code_1$9 = code;
const errors_1$1 = errors;
function macroKeywordCode(cxt, def2) {
  const { gen, keyword: keyword2, schema: schema2, parentSchema, it } = cxt;
  const macroSchema = def2.macro.call(it.self, schema2, parentSchema, it);
  const schemaRef = useKeyword(gen, keyword2, macroSchema);
  if (it.opts.validateSchema !== false)
    it.self.validateSchema(macroSchema, true);
  const valid2 = gen.name("valid");
  cxt.subschema({
    schema: macroSchema,
    schemaPath: codegen_1$p.nil,
    errSchemaPath: `${it.errSchemaPath}/${keyword2}`,
    topSchemaRef: schemaRef,
    compositeRule: true
  }, valid2);
  cxt.pass(valid2, () => cxt.error(true));
}
keyword.macroKeywordCode = macroKeywordCode;
function funcKeywordCode(cxt, def2) {
  var _a;
  const { gen, keyword: keyword2, schema: schema2, parentSchema, $data, it } = cxt;
  checkAsyncKeyword(it, def2);
  const validate2 = !$data && def2.compile ? def2.compile.call(it.self, schema2, parentSchema, it) : def2.validate;
  const validateRef = useKeyword(gen, keyword2, validate2);
  const valid2 = gen.let("valid");
  cxt.block$data(valid2, validateKeyword);
  cxt.ok((_a = def2.valid) !== null && _a !== void 0 ? _a : valid2);
  function validateKeyword() {
    if (def2.errors === false) {
      assignValid();
      if (def2.modifying)
        modifyData(cxt);
      reportErrs(() => cxt.error());
    } else {
      const ruleErrs = def2.async ? validateAsync() : validateSync();
      if (def2.modifying)
        modifyData(cxt);
      reportErrs(() => addErrs(cxt, ruleErrs));
    }
  }
  function validateAsync() {
    const ruleErrs = gen.let("ruleErrs", null);
    gen.try(() => assignValid((0, codegen_1$p._)`await `), (e) => gen.assign(valid2, false).if((0, codegen_1$p._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1$p._)`${e}.errors`), () => gen.throw(e)));
    return ruleErrs;
  }
  function validateSync() {
    const validateErrs = (0, codegen_1$p._)`${validateRef}.errors`;
    gen.assign(validateErrs, null);
    assignValid(codegen_1$p.nil);
    return validateErrs;
  }
  function assignValid(_await = def2.async ? (0, codegen_1$p._)`await ` : codegen_1$p.nil) {
    const passCxt = it.opts.passContext ? names_1$4.default.this : names_1$4.default.self;
    const passSchema = !("compile" in def2 && !$data || def2.schema === false);
    gen.assign(valid2, (0, codegen_1$p._)`${_await}${(0, code_1$9.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def2.modifying);
  }
  function reportErrs(errors2) {
    var _a2;
    gen.if((0, codegen_1$p.not)((_a2 = def2.valid) !== null && _a2 !== void 0 ? _a2 : valid2), errors2);
  }
}
keyword.funcKeywordCode = funcKeywordCode;
function modifyData(cxt) {
  const { gen, data, it } = cxt;
  gen.if(it.parentData, () => gen.assign(data, (0, codegen_1$p._)`${it.parentData}[${it.parentDataProperty}]`));
}
function addErrs(cxt, errs) {
  const { gen } = cxt;
  gen.if((0, codegen_1$p._)`Array.isArray(${errs})`, () => {
    gen.assign(names_1$4.default.vErrors, (0, codegen_1$p._)`${names_1$4.default.vErrors} === null ? ${errs} : ${names_1$4.default.vErrors}.concat(${errs})`).assign(names_1$4.default.errors, (0, codegen_1$p._)`${names_1$4.default.vErrors}.length`);
    (0, errors_1$1.extendErrors)(cxt);
  }, () => cxt.error());
}
function checkAsyncKeyword({ schemaEnv }, def2) {
  if (def2.async && !schemaEnv.$async)
    throw new Error("async keyword in sync schema");
}
function useKeyword(gen, keyword2, result) {
  if (result === void 0)
    throw new Error(`keyword "${keyword2}" failed to compile`);
  return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1$p.stringify)(result) });
}
function validSchemaType(schema2, schemaType, allowUndefined = false) {
  return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema2) : st === "object" ? schema2 && typeof schema2 == "object" && !Array.isArray(schema2) : typeof schema2 == st || allowUndefined && typeof schema2 == "undefined");
}
keyword.validSchemaType = validSchemaType;
function validateKeywordUsage({ schema: schema2, opts, self: self2, errSchemaPath }, def2, keyword2) {
  if (Array.isArray(def2.keyword) ? !def2.keyword.includes(keyword2) : def2.keyword !== keyword2) {
    throw new Error("ajv implementation error");
  }
  const deps = def2.dependencies;
  if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema2, kwd))) {
    throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
  }
  if (def2.validateSchema) {
    const valid2 = def2.validateSchema(schema2[keyword2]);
    if (!valid2) {
      const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def2.validateSchema.errors);
      if (opts.validateSchema === "log")
        self2.logger.error(msg);
      else
        throw new Error(msg);
    }
  }
}
keyword.validateKeywordUsage = validateKeywordUsage;
var subschema = {};
Object.defineProperty(subschema, "__esModule", { value: true });
subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
const codegen_1$o = codegen;
const util_1$n = util;
function getSubschema(it, { keyword: keyword2, schemaProp, schema: schema2, schemaPath, errSchemaPath, topSchemaRef }) {
  if (keyword2 !== void 0 && schema2 !== void 0) {
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  }
  if (keyword2 !== void 0) {
    const sch = it.schema[keyword2];
    return schemaProp === void 0 ? {
      schema: sch,
      schemaPath: (0, codegen_1$o._)`${it.schemaPath}${(0, codegen_1$o.getProperty)(keyword2)}`,
      errSchemaPath: `${it.errSchemaPath}/${keyword2}`
    } : {
      schema: sch[schemaProp],
      schemaPath: (0, codegen_1$o._)`${it.schemaPath}${(0, codegen_1$o.getProperty)(keyword2)}${(0, codegen_1$o.getProperty)(schemaProp)}`,
      errSchemaPath: `${it.errSchemaPath}/${keyword2}/${(0, util_1$n.escapeFragment)(schemaProp)}`
    };
  }
  if (schema2 !== void 0) {
    if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    }
    return {
      schema: schema2,
      schemaPath,
      topSchemaRef,
      errSchemaPath
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
subschema.getSubschema = getSubschema;
function extendSubschemaData(subschema2, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
  if (data !== void 0 && dataProp !== void 0) {
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  }
  const { gen } = it;
  if (dataProp !== void 0) {
    const { errorPath, dataPathArr, opts } = it;
    const nextData = gen.let("data", (0, codegen_1$o._)`${it.data}${(0, codegen_1$o.getProperty)(dataProp)}`, true);
    dataContextProps(nextData);
    subschema2.errorPath = (0, codegen_1$o.str)`${errorPath}${(0, util_1$n.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
    subschema2.parentDataProperty = (0, codegen_1$o._)`${dataProp}`;
    subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
  }
  if (data !== void 0) {
    const nextData = data instanceof codegen_1$o.Name ? data : gen.let("data", data, true);
    dataContextProps(nextData);
    if (propertyName !== void 0)
      subschema2.propertyName = propertyName;
  }
  if (dataTypes)
    subschema2.dataTypes = dataTypes;
  function dataContextProps(_nextData) {
    subschema2.data = _nextData;
    subschema2.dataLevel = it.dataLevel + 1;
    subschema2.dataTypes = [];
    it.definedProperties = /* @__PURE__ */ new Set();
    subschema2.parentData = it.data;
    subschema2.dataNames = [...it.dataNames, _nextData];
  }
}
subschema.extendSubschemaData = extendSubschemaData;
function extendSubschemaMode(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
  if (compositeRule !== void 0)
    subschema2.compositeRule = compositeRule;
  if (createErrors !== void 0)
    subschema2.createErrors = createErrors;
  if (allErrors !== void 0)
    subschema2.allErrors = allErrors;
  subschema2.jtdDiscriminator = jtdDiscriminator;
  subschema2.jtdMetadata = jtdMetadata;
}
subschema.extendSubschemaMode = extendSubschemaMode;
var resolve$1 = {};
var fastDeepEqual = function equal(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    if (a.constructor !== b.constructor)
      return false;
    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!equal(a[i], b[i]))
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
        return false;
    for (i = length; i-- !== 0; ) {
      var key = keys[i];
      if (!equal(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
};
var jsonSchemaTraverse = { exports: {} };
var traverse$1 = jsonSchemaTraverse.exports = function(schema2, opts, cb) {
  if (typeof opts == "function") {
    cb = opts;
    opts = {};
  }
  cb = opts.cb || cb;
  var pre = typeof cb == "function" ? cb : cb.pre || function() {
  };
  var post = cb.post || function() {
  };
  _traverse(opts, pre, post, schema2, "", schema2);
};
traverse$1.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true,
  if: true,
  then: true,
  else: true
};
traverse$1.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};
traverse$1.propsKeywords = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};
traverse$1.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};
function _traverse(opts, pre, post, schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema2 && typeof schema2 == "object" && !Array.isArray(schema2)) {
    pre(schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema2) {
      var sch = schema2[key];
      if (Array.isArray(sch)) {
        if (key in traverse$1.arrayKeywords) {
          for (var i = 0; i < sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema2, i);
        }
      } else if (key in traverse$1.propsKeywords) {
        if (sch && typeof sch == "object") {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema2, prop);
        }
      } else if (key in traverse$1.keywords || opts.allKeys && !(key in traverse$1.skipKeywords)) {
        _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema2);
      }
    }
    post(schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}
function escapeJsonPtr(str) {
  return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
var jsonSchemaTraverseExports = jsonSchemaTraverse.exports;
Object.defineProperty(resolve$1, "__esModule", { value: true });
resolve$1.getSchemaRefs = resolve$1.resolveUrl = resolve$1.normalizeId = resolve$1._getFullPath = resolve$1.getFullPath = resolve$1.inlineRef = void 0;
const util_1$m = util;
const equal$2 = fastDeepEqual;
const traverse = jsonSchemaTraverseExports;
const SIMPLE_INLINED = /* @__PURE__ */ new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function inlineRef(schema2, limit2 = true) {
  if (typeof schema2 == "boolean")
    return true;
  if (limit2 === true)
    return !hasRef(schema2);
  if (!limit2)
    return false;
  return countKeys(schema2) <= limit2;
}
resolve$1.inlineRef = inlineRef;
const REF_KEYWORDS = /* @__PURE__ */ new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function hasRef(schema2) {
  for (const key in schema2) {
    if (REF_KEYWORDS.has(key))
      return true;
    const sch = schema2[key];
    if (Array.isArray(sch) && sch.some(hasRef))
      return true;
    if (typeof sch == "object" && hasRef(sch))
      return true;
  }
  return false;
}
function countKeys(schema2) {
  let count = 0;
  for (const key in schema2) {
    if (key === "$ref")
      return Infinity;
    count++;
    if (SIMPLE_INLINED.has(key))
      continue;
    if (typeof schema2[key] == "object") {
      (0, util_1$m.eachItem)(schema2[key], (sch) => count += countKeys(sch));
    }
    if (count === Infinity)
      return Infinity;
  }
  return count;
}
function getFullPath(resolver, id2 = "", normalize) {
  if (normalize !== false)
    id2 = normalizeId(id2);
  const p = resolver.parse(id2);
  return _getFullPath(resolver, p);
}
resolve$1.getFullPath = getFullPath;
function _getFullPath(resolver, p) {
  const serialized = resolver.serialize(p);
  return serialized.split("#")[0] + "#";
}
resolve$1._getFullPath = _getFullPath;
const TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id2) {
  return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
}
resolve$1.normalizeId = normalizeId;
function resolveUrl(resolver, baseId, id2) {
  id2 = normalizeId(id2);
  return resolver.resolve(baseId, id2);
}
resolve$1.resolveUrl = resolveUrl;
const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
function getSchemaRefs(schema2, baseId) {
  if (typeof schema2 == "boolean")
    return {};
  const { schemaId, uriResolver } = this.opts;
  const schId = normalizeId(schema2[schemaId] || baseId);
  const baseIds = { "": schId };
  const pathPrefix = getFullPath(uriResolver, schId, false);
  const localRefs = {};
  const schemaRefs = /* @__PURE__ */ new Set();
  traverse(schema2, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
    if (parentJsonPtr === void 0)
      return;
    const fullPath = pathPrefix + jsonPtr;
    let baseId2 = baseIds[parentJsonPtr];
    if (typeof sch[schemaId] == "string")
      baseId2 = addRef.call(this, sch[schemaId]);
    addAnchor.call(this, sch.$anchor);
    addAnchor.call(this, sch.$dynamicAnchor);
    baseIds[jsonPtr] = baseId2;
    function addRef(ref2) {
      const _resolve = this.opts.uriResolver.resolve;
      ref2 = normalizeId(baseId2 ? _resolve(baseId2, ref2) : ref2);
      if (schemaRefs.has(ref2))
        throw ambiguos(ref2);
      schemaRefs.add(ref2);
      let schOrRef = this.refs[ref2];
      if (typeof schOrRef == "string")
        schOrRef = this.refs[schOrRef];
      if (typeof schOrRef == "object") {
        checkAmbiguosRef(sch, schOrRef.schema, ref2);
      } else if (ref2 !== normalizeId(fullPath)) {
        if (ref2[0] === "#") {
          checkAmbiguosRef(sch, localRefs[ref2], ref2);
          localRefs[ref2] = sch;
        } else {
          this.refs[ref2] = fullPath;
        }
      }
      return ref2;
    }
    function addAnchor(anchor) {
      if (typeof anchor == "string") {
        if (!ANCHOR.test(anchor))
          throw new Error(`invalid anchor "${anchor}"`);
        addRef.call(this, `#${anchor}`);
      }
    }
  });
  return localRefs;
  function checkAmbiguosRef(sch1, sch2, ref2) {
    if (sch2 !== void 0 && !equal$2(sch1, sch2))
      throw ambiguos(ref2);
  }
  function ambiguos(ref2) {
    return new Error(`reference "${ref2}" resolves to more than one schema`);
  }
}
resolve$1.getSchemaRefs = getSchemaRefs;
Object.defineProperty(validate, "__esModule", { value: true });
validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
const boolSchema_1 = boolSchema;
const dataType_1$1 = dataType;
const applicability_1 = applicability;
const dataType_2 = dataType;
const defaults_1 = defaults;
const keyword_1 = keyword;
const subschema_1 = subschema;
const codegen_1$n = codegen;
const names_1$3 = names$1;
const resolve_1$2 = resolve$1;
const util_1$l = util;
const errors_1 = errors;
function validateFunctionCode(it) {
  if (isSchemaObj(it)) {
    checkKeywords(it);
    if (schemaCxtHasRules(it)) {
      topSchemaObjCode(it);
      return;
    }
  }
  validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
}
validate.validateFunctionCode = validateFunctionCode;
function validateFunction({ gen, validateName, schema: schema2, schemaEnv, opts }, body) {
  if (opts.code.es5) {
    gen.func(validateName, (0, codegen_1$n._)`${names_1$3.default.data}, ${names_1$3.default.valCxt}`, schemaEnv.$async, () => {
      gen.code((0, codegen_1$n._)`"use strict"; ${funcSourceUrl(schema2, opts)}`);
      destructureValCxtES5(gen, opts);
      gen.code(body);
    });
  } else {
    gen.func(validateName, (0, codegen_1$n._)`${names_1$3.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema2, opts)).code(body));
  }
}
function destructureValCxt(opts) {
  return (0, codegen_1$n._)`{${names_1$3.default.instancePath}="", ${names_1$3.default.parentData}, ${names_1$3.default.parentDataProperty}, ${names_1$3.default.rootData}=${names_1$3.default.data}${opts.dynamicRef ? (0, codegen_1$n._)`, ${names_1$3.default.dynamicAnchors}={}` : codegen_1$n.nil}}={}`;
}
function destructureValCxtES5(gen, opts) {
  gen.if(names_1$3.default.valCxt, () => {
    gen.var(names_1$3.default.instancePath, (0, codegen_1$n._)`${names_1$3.default.valCxt}.${names_1$3.default.instancePath}`);
    gen.var(names_1$3.default.parentData, (0, codegen_1$n._)`${names_1$3.default.valCxt}.${names_1$3.default.parentData}`);
    gen.var(names_1$3.default.parentDataProperty, (0, codegen_1$n._)`${names_1$3.default.valCxt}.${names_1$3.default.parentDataProperty}`);
    gen.var(names_1$3.default.rootData, (0, codegen_1$n._)`${names_1$3.default.valCxt}.${names_1$3.default.rootData}`);
    if (opts.dynamicRef)
      gen.var(names_1$3.default.dynamicAnchors, (0, codegen_1$n._)`${names_1$3.default.valCxt}.${names_1$3.default.dynamicAnchors}`);
  }, () => {
    gen.var(names_1$3.default.instancePath, (0, codegen_1$n._)`""`);
    gen.var(names_1$3.default.parentData, (0, codegen_1$n._)`undefined`);
    gen.var(names_1$3.default.parentDataProperty, (0, codegen_1$n._)`undefined`);
    gen.var(names_1$3.default.rootData, names_1$3.default.data);
    if (opts.dynamicRef)
      gen.var(names_1$3.default.dynamicAnchors, (0, codegen_1$n._)`{}`);
  });
}
function topSchemaObjCode(it) {
  const { schema: schema2, opts, gen } = it;
  validateFunction(it, () => {
    if (opts.$comment && schema2.$comment)
      commentKeyword(it);
    checkNoDefault(it);
    gen.let(names_1$3.default.vErrors, null);
    gen.let(names_1$3.default.errors, 0);
    if (opts.unevaluated)
      resetEvaluated(it);
    typeAndKeywords(it);
    returnResults(it);
  });
  return;
}
function resetEvaluated(it) {
  const { gen, validateName } = it;
  it.evaluated = gen.const("evaluated", (0, codegen_1$n._)`${validateName}.evaluated`);
  gen.if((0, codegen_1$n._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1$n._)`${it.evaluated}.props`, (0, codegen_1$n._)`undefined`));
  gen.if((0, codegen_1$n._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1$n._)`${it.evaluated}.items`, (0, codegen_1$n._)`undefined`));
}
function funcSourceUrl(schema2, opts) {
  const schId = typeof schema2 == "object" && schema2[opts.schemaId];
  return schId && (opts.code.source || opts.code.process) ? (0, codegen_1$n._)`/*# sourceURL=${schId} */` : codegen_1$n.nil;
}
function subschemaCode(it, valid2) {
  if (isSchemaObj(it)) {
    checkKeywords(it);
    if (schemaCxtHasRules(it)) {
      subSchemaObjCode(it, valid2);
      return;
    }
  }
  (0, boolSchema_1.boolOrEmptySchema)(it, valid2);
}
function schemaCxtHasRules({ schema: schema2, self: self2 }) {
  if (typeof schema2 == "boolean")
    return !schema2;
  for (const key in schema2)
    if (self2.RULES.all[key])
      return true;
  return false;
}
function isSchemaObj(it) {
  return typeof it.schema != "boolean";
}
function subSchemaObjCode(it, valid2) {
  const { schema: schema2, gen, opts } = it;
  if (opts.$comment && schema2.$comment)
    commentKeyword(it);
  updateContext(it);
  checkAsyncSchema(it);
  const errsCount = gen.const("_errs", names_1$3.default.errors);
  typeAndKeywords(it, errsCount);
  gen.var(valid2, (0, codegen_1$n._)`${errsCount} === ${names_1$3.default.errors}`);
}
function checkKeywords(it) {
  (0, util_1$l.checkUnknownRules)(it);
  checkRefsAndKeywords(it);
}
function typeAndKeywords(it, errsCount) {
  if (it.opts.jtd)
    return schemaKeywords(it, [], false, errsCount);
  const types2 = (0, dataType_1$1.getSchemaTypes)(it.schema);
  const checkedTypes = (0, dataType_1$1.coerceAndCheckDataType)(it, types2);
  schemaKeywords(it, types2, !checkedTypes, errsCount);
}
function checkRefsAndKeywords(it) {
  const { schema: schema2, errSchemaPath, opts, self: self2 } = it;
  if (schema2.$ref && opts.ignoreKeywordsWithRef && (0, util_1$l.schemaHasRulesButRef)(schema2, self2.RULES)) {
    self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
  }
}
function checkNoDefault(it) {
  const { schema: schema2, opts } = it;
  if (schema2.default !== void 0 && opts.useDefaults && opts.strictSchema) {
    (0, util_1$l.checkStrictMode)(it, "default is ignored in the schema root");
  }
}
function updateContext(it) {
  const schId = it.schema[it.opts.schemaId];
  if (schId)
    it.baseId = (0, resolve_1$2.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
}
function checkAsyncSchema(it) {
  if (it.schema.$async && !it.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function commentKeyword({ gen, schemaEnv, schema: schema2, errSchemaPath, opts }) {
  const msg = schema2.$comment;
  if (opts.$comment === true) {
    gen.code((0, codegen_1$n._)`${names_1$3.default.self}.logger.log(${msg})`);
  } else if (typeof opts.$comment == "function") {
    const schemaPath = (0, codegen_1$n.str)`${errSchemaPath}/$comment`;
    const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
    gen.code((0, codegen_1$n._)`${names_1$3.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
  }
}
function returnResults(it) {
  const { gen, schemaEnv, validateName, ValidationError: ValidationError2, opts } = it;
  if (schemaEnv.$async) {
    gen.if((0, codegen_1$n._)`${names_1$3.default.errors} === 0`, () => gen.return(names_1$3.default.data), () => gen.throw((0, codegen_1$n._)`new ${ValidationError2}(${names_1$3.default.vErrors})`));
  } else {
    gen.assign((0, codegen_1$n._)`${validateName}.errors`, names_1$3.default.vErrors);
    if (opts.unevaluated)
      assignEvaluated(it);
    gen.return((0, codegen_1$n._)`${names_1$3.default.errors} === 0`);
  }
}
function assignEvaluated({ gen, evaluated, props, items: items2 }) {
  if (props instanceof codegen_1$n.Name)
    gen.assign((0, codegen_1$n._)`${evaluated}.props`, props);
  if (items2 instanceof codegen_1$n.Name)
    gen.assign((0, codegen_1$n._)`${evaluated}.items`, items2);
}
function schemaKeywords(it, types2, typeErrors, errsCount) {
  const { gen, schema: schema2, data, allErrors, opts, self: self2 } = it;
  const { RULES } = self2;
  if (schema2.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1$l.schemaHasRulesButRef)(schema2, RULES))) {
    gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
    return;
  }
  if (!opts.jtd)
    checkStrictTypes(it, types2);
  gen.block(() => {
    for (const group of RULES.rules)
      groupKeywords(group);
    groupKeywords(RULES.post);
  });
  function groupKeywords(group) {
    if (!(0, applicability_1.shouldUseGroup)(schema2, group))
      return;
    if (group.type) {
      gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
      iterateKeywords(it, group);
      if (types2.length === 1 && types2[0] === group.type && typeErrors) {
        gen.else();
        (0, dataType_2.reportTypeError)(it);
      }
      gen.endIf();
    } else {
      iterateKeywords(it, group);
    }
    if (!allErrors)
      gen.if((0, codegen_1$n._)`${names_1$3.default.errors} === ${errsCount || 0}`);
  }
}
function iterateKeywords(it, group) {
  const { gen, schema: schema2, opts: { useDefaults } } = it;
  if (useDefaults)
    (0, defaults_1.assignDefaults)(it, group.type);
  gen.block(() => {
    for (const rule of group.rules) {
      if ((0, applicability_1.shouldUseRule)(schema2, rule)) {
        keywordCode(it, rule.keyword, rule.definition, group.type);
      }
    }
  });
}
function checkStrictTypes(it, types2) {
  if (it.schemaEnv.meta || !it.opts.strictTypes)
    return;
  checkContextTypes(it, types2);
  if (!it.opts.allowUnionTypes)
    checkMultipleTypes(it, types2);
  checkKeywordTypes(it, it.dataTypes);
}
function checkContextTypes(it, types2) {
  if (!types2.length)
    return;
  if (!it.dataTypes.length) {
    it.dataTypes = types2;
    return;
  }
  types2.forEach((t2) => {
    if (!includesType(it.dataTypes, t2)) {
      strictTypesError(it, `type "${t2}" not allowed by context "${it.dataTypes.join(",")}"`);
    }
  });
  narrowSchemaTypes(it, types2);
}
function checkMultipleTypes(it, ts) {
  if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
    strictTypesError(it, "use allowUnionTypes to allow union type keyword");
  }
}
function checkKeywordTypes(it, ts) {
  const rules2 = it.self.RULES.all;
  for (const keyword2 in rules2) {
    const rule = rules2[keyword2];
    if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
      const { type: type2 } = rule.definition;
      if (type2.length && !type2.some((t2) => hasApplicableType(ts, t2))) {
        strictTypesError(it, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
      }
    }
  }
}
function hasApplicableType(schTs, kwdT) {
  return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
}
function includesType(ts, t2) {
  return ts.includes(t2) || t2 === "integer" && ts.includes("number");
}
function narrowSchemaTypes(it, withTypes) {
  const ts = [];
  for (const t2 of it.dataTypes) {
    if (includesType(withTypes, t2))
      ts.push(t2);
    else if (withTypes.includes("integer") && t2 === "number")
      ts.push("integer");
  }
  it.dataTypes = ts;
}
function strictTypesError(it, msg) {
  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
  msg += ` at "${schemaPath}" (strictTypes)`;
  (0, util_1$l.checkStrictMode)(it, msg, it.opts.strictTypes);
}
class KeywordCxt {
  constructor(it, def2, keyword2) {
    (0, keyword_1.validateKeywordUsage)(it, def2, keyword2);
    this.gen = it.gen;
    this.allErrors = it.allErrors;
    this.keyword = keyword2;
    this.data = it.data;
    this.schema = it.schema[keyword2];
    this.$data = def2.$data && it.opts.$data && this.schema && this.schema.$data;
    this.schemaValue = (0, util_1$l.schemaRefOrVal)(it, this.schema, keyword2, this.$data);
    this.schemaType = def2.schemaType;
    this.parentSchema = it.schema;
    this.params = {};
    this.it = it;
    this.def = def2;
    if (this.$data) {
      this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
    } else {
      this.schemaCode = this.schemaValue;
      if (!(0, keyword_1.validSchemaType)(this.schema, def2.schemaType, def2.allowUndefined)) {
        throw new Error(`${keyword2} value must be ${JSON.stringify(def2.schemaType)}`);
      }
    }
    if ("code" in def2 ? def2.trackErrors : def2.errors !== false) {
      this.errsCount = it.gen.const("_errs", names_1$3.default.errors);
    }
  }
  result(condition, successAction, failAction) {
    this.failResult((0, codegen_1$n.not)(condition), successAction, failAction);
  }
  failResult(condition, successAction, failAction) {
    this.gen.if(condition);
    if (failAction)
      failAction();
    else
      this.error();
    if (successAction) {
      this.gen.else();
      successAction();
      if (this.allErrors)
        this.gen.endIf();
    } else {
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
  }
  pass(condition, failAction) {
    this.failResult((0, codegen_1$n.not)(condition), void 0, failAction);
  }
  fail(condition) {
    if (condition === void 0) {
      this.error();
      if (!this.allErrors)
        this.gen.if(false);
      return;
    }
    this.gen.if(condition);
    this.error();
    if (this.allErrors)
      this.gen.endIf();
    else
      this.gen.else();
  }
  fail$data(condition) {
    if (!this.$data)
      return this.fail(condition);
    const { schemaCode } = this;
    this.fail((0, codegen_1$n._)`${schemaCode} !== undefined && (${(0, codegen_1$n.or)(this.invalid$data(), condition)})`);
  }
  error(append, errorParams, errorPaths) {
    if (errorParams) {
      this.setParams(errorParams);
      this._error(append, errorPaths);
      this.setParams({});
      return;
    }
    this._error(append, errorPaths);
  }
  _error(append, errorPaths) {
    (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
  }
  $dataError() {
    (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(cond) {
    if (!this.allErrors)
      this.gen.if(cond);
  }
  setParams(obj, assign) {
    if (assign)
      Object.assign(this.params, obj);
    else
      this.params = obj;
  }
  block$data(valid2, codeBlock, $dataValid = codegen_1$n.nil) {
    this.gen.block(() => {
      this.check$data(valid2, $dataValid);
      codeBlock();
    });
  }
  check$data(valid2 = codegen_1$n.nil, $dataValid = codegen_1$n.nil) {
    if (!this.$data)
      return;
    const { gen, schemaCode, schemaType, def: def2 } = this;
    gen.if((0, codegen_1$n.or)((0, codegen_1$n._)`${schemaCode} === undefined`, $dataValid));
    if (valid2 !== codegen_1$n.nil)
      gen.assign(valid2, true);
    if (schemaType.length || def2.validateSchema) {
      gen.elseIf(this.invalid$data());
      this.$dataError();
      if (valid2 !== codegen_1$n.nil)
        gen.assign(valid2, false);
    }
    gen.else();
  }
  invalid$data() {
    const { gen, schemaCode, schemaType, def: def2, it } = this;
    return (0, codegen_1$n.or)(wrong$DataType(), invalid$DataSchema());
    function wrong$DataType() {
      if (schemaType.length) {
        if (!(schemaCode instanceof codegen_1$n.Name))
          throw new Error("ajv implementation error");
        const st = Array.isArray(schemaType) ? schemaType : [schemaType];
        return (0, codegen_1$n._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
      }
      return codegen_1$n.nil;
    }
    function invalid$DataSchema() {
      if (def2.validateSchema) {
        const validateSchemaRef = gen.scopeValue("validate$data", { ref: def2.validateSchema });
        return (0, codegen_1$n._)`!${validateSchemaRef}(${schemaCode})`;
      }
      return codegen_1$n.nil;
    }
  }
  subschema(appl, valid2) {
    const subschema2 = (0, subschema_1.getSubschema)(this.it, appl);
    (0, subschema_1.extendSubschemaData)(subschema2, this.it, appl);
    (0, subschema_1.extendSubschemaMode)(subschema2, appl);
    const nextContext = { ...this.it, ...subschema2, items: void 0, props: void 0 };
    subschemaCode(nextContext, valid2);
    return nextContext;
  }
  mergeEvaluated(schemaCxt, toName) {
    const { it, gen } = this;
    if (!it.opts.unevaluated)
      return;
    if (it.props !== true && schemaCxt.props !== void 0) {
      it.props = util_1$l.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
    }
    if (it.items !== true && schemaCxt.items !== void 0) {
      it.items = util_1$l.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
    }
  }
  mergeValidEvaluated(schemaCxt, valid2) {
    const { it, gen } = this;
    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
      gen.if(valid2, () => this.mergeEvaluated(schemaCxt, codegen_1$n.Name));
      return true;
    }
  }
}
validate.KeywordCxt = KeywordCxt;
function keywordCode(it, keyword2, def2, ruleType) {
  const cxt = new KeywordCxt(it, def2, keyword2);
  if ("code" in def2) {
    def2.code(cxt, ruleType);
  } else if (cxt.$data && def2.validate) {
    (0, keyword_1.funcKeywordCode)(cxt, def2);
  } else if ("macro" in def2) {
    (0, keyword_1.macroKeywordCode)(cxt, def2);
  } else if (def2.compile || def2.validate) {
    (0, keyword_1.funcKeywordCode)(cxt, def2);
  }
}
const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, { dataLevel, dataNames, dataPathArr }) {
  let jsonPointer;
  let data;
  if ($data === "")
    return names_1$3.default.rootData;
  if ($data[0] === "/") {
    if (!JSON_POINTER.test($data))
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    jsonPointer = $data;
    data = names_1$3.default.rootData;
  } else {
    const matches = RELATIVE_JSON_POINTER.exec($data);
    if (!matches)
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    const up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer === "#") {
      if (up >= dataLevel)
        throw new Error(errorMsg("property/index", up));
      return dataPathArr[dataLevel - up];
    }
    if (up > dataLevel)
      throw new Error(errorMsg("data", up));
    data = dataNames[dataLevel - up];
    if (!jsonPointer)
      return data;
  }
  let expr = data;
  const segments = jsonPointer.split("/");
  for (const segment of segments) {
    if (segment) {
      data = (0, codegen_1$n._)`${data}${(0, codegen_1$n.getProperty)((0, util_1$l.unescapeJsonPointer)(segment))}`;
      expr = (0, codegen_1$n._)`${expr} && ${data}`;
    }
  }
  return expr;
  function errorMsg(pointerType, up) {
    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
  }
}
validate.getData = getData;
var validation_error = {};
Object.defineProperty(validation_error, "__esModule", { value: true });
class ValidationError extends Error {
  constructor(errors2) {
    super("validation failed");
    this.errors = errors2;
    this.ajv = this.validation = true;
  }
}
validation_error.default = ValidationError;
var ref_error = {};
Object.defineProperty(ref_error, "__esModule", { value: true });
const resolve_1$1 = resolve$1;
class MissingRefError extends Error {
  constructor(resolver, baseId, ref2, msg) {
    super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
    this.missingRef = (0, resolve_1$1.resolveUrl)(resolver, baseId, ref2);
    this.missingSchema = (0, resolve_1$1.normalizeId)((0, resolve_1$1.getFullPath)(resolver, this.missingRef));
  }
}
ref_error.default = MissingRefError;
var compile = {};
Object.defineProperty(compile, "__esModule", { value: true });
compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
const codegen_1$m = codegen;
const validation_error_1 = validation_error;
const names_1$2 = names$1;
const resolve_1 = resolve$1;
const util_1$k = util;
const validate_1$1 = validate;
class SchemaEnv {
  constructor(env2) {
    var _a;
    this.refs = {};
    this.dynamicAnchors = {};
    let schema2;
    if (typeof env2.schema == "object")
      schema2 = env2.schema;
    this.schema = env2.schema;
    this.schemaId = env2.schemaId;
    this.root = env2.root || this;
    this.baseId = (_a = env2.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema2 === null || schema2 === void 0 ? void 0 : schema2[env2.schemaId || "$id"]);
    this.schemaPath = env2.schemaPath;
    this.localRefs = env2.localRefs;
    this.meta = env2.meta;
    this.$async = schema2 === null || schema2 === void 0 ? void 0 : schema2.$async;
    this.refs = {};
  }
}
compile.SchemaEnv = SchemaEnv;
function compileSchema(sch) {
  const _sch = getCompilingSchema.call(this, sch);
  if (_sch)
    return _sch;
  const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
  const { es5, lines } = this.opts.code;
  const { ownProperties } = this.opts;
  const gen = new codegen_1$m.CodeGen(this.scope, { es5, lines, ownProperties });
  let _ValidationError;
  if (sch.$async) {
    _ValidationError = gen.scopeValue("Error", {
      ref: validation_error_1.default,
      code: (0, codegen_1$m._)`require("ajv/dist/runtime/validation_error").default`
    });
  }
  const validateName = gen.scopeName("validate");
  sch.validateName = validateName;
  const schemaCxt = {
    gen,
    allErrors: this.opts.allErrors,
    data: names_1$2.default.data,
    parentData: names_1$2.default.parentData,
    parentDataProperty: names_1$2.default.parentDataProperty,
    dataNames: [names_1$2.default.data],
    dataPathArr: [codegen_1$m.nil],
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
    topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1$m.stringify)(sch.schema) } : { ref: sch.schema }),
    validateName,
    ValidationError: _ValidationError,
    schema: sch.schema,
    schemaEnv: sch,
    rootId,
    baseId: sch.baseId || rootId,
    schemaPath: codegen_1$m.nil,
    errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, codegen_1$m._)`""`,
    opts: this.opts,
    self: this
  };
  let sourceCode;
  try {
    this._compilations.add(sch);
    (0, validate_1$1.validateFunctionCode)(schemaCxt);
    gen.optimize(this.opts.code.optimize);
    const validateCode = gen.toString();
    sourceCode = `${gen.scopeRefs(names_1$2.default.scope)}return ${validateCode}`;
    if (this.opts.code.process)
      sourceCode = this.opts.code.process(sourceCode, sch);
    const makeValidate = new Function(`${names_1$2.default.self}`, `${names_1$2.default.scope}`, sourceCode);
    const validate2 = makeValidate(this, this.scope.get());
    this.scope.value(validateName, { ref: validate2 });
    validate2.errors = null;
    validate2.schema = sch.schema;
    validate2.schemaEnv = sch;
    if (sch.$async)
      validate2.$async = true;
    if (this.opts.code.source === true) {
      validate2.source = { validateName, validateCode, scopeValues: gen._values };
    }
    if (this.opts.unevaluated) {
      const { props, items: items2 } = schemaCxt;
      validate2.evaluated = {
        props: props instanceof codegen_1$m.Name ? void 0 : props,
        items: items2 instanceof codegen_1$m.Name ? void 0 : items2,
        dynamicProps: props instanceof codegen_1$m.Name,
        dynamicItems: items2 instanceof codegen_1$m.Name
      };
      if (validate2.source)
        validate2.source.evaluated = (0, codegen_1$m.stringify)(validate2.evaluated);
    }
    sch.validate = validate2;
    return sch;
  } catch (e) {
    delete sch.validate;
    delete sch.validateName;
    if (sourceCode)
      this.logger.error("Error compiling schema, function code:", sourceCode);
    throw e;
  } finally {
    this._compilations.delete(sch);
  }
}
compile.compileSchema = compileSchema;
function resolveRef(root, baseId, ref2) {
  var _a;
  ref2 = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref2);
  const schOrFunc = root.refs[ref2];
  if (schOrFunc)
    return schOrFunc;
  let _sch = resolve.call(this, root, ref2);
  if (_sch === void 0) {
    const schema2 = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref2];
    const { schemaId } = this.opts;
    if (schema2)
      _sch = new SchemaEnv({ schema: schema2, schemaId, root, baseId });
  }
  if (_sch === void 0)
    return;
  return root.refs[ref2] = inlineOrCompile.call(this, _sch);
}
compile.resolveRef = resolveRef;
function inlineOrCompile(sch) {
  if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
    return sch.schema;
  return sch.validate ? sch : compileSchema.call(this, sch);
}
function getCompilingSchema(schEnv) {
  for (const sch of this._compilations) {
    if (sameSchemaEnv(sch, schEnv))
      return sch;
  }
}
compile.getCompilingSchema = getCompilingSchema;
function sameSchemaEnv(s1, s2) {
  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
}
function resolve(root, ref2) {
  let sch;
  while (typeof (sch = this.refs[ref2]) == "string")
    ref2 = sch;
  return sch || this.schemas[ref2] || resolveSchema.call(this, root, ref2);
}
function resolveSchema(root, ref2) {
  const p = this.opts.uriResolver.parse(ref2);
  const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
  let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
  if (Object.keys(root.schema).length > 0 && refPath === baseId) {
    return getJsonPointer.call(this, p, root);
  }
  const id2 = (0, resolve_1.normalizeId)(refPath);
  const schOrRef = this.refs[id2] || this.schemas[id2];
  if (typeof schOrRef == "string") {
    const sch = resolveSchema.call(this, root, schOrRef);
    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
      return;
    return getJsonPointer.call(this, p, sch);
  }
  if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
    return;
  if (!schOrRef.validate)
    compileSchema.call(this, schOrRef);
  if (id2 === (0, resolve_1.normalizeId)(ref2)) {
    const { schema: schema2 } = schOrRef;
    const { schemaId } = this.opts;
    const schId = schema2[schemaId];
    if (schId)
      baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
    return new SchemaEnv({ schema: schema2, schemaId, root, baseId });
  }
  return getJsonPointer.call(this, p, schOrRef);
}
compile.resolveSchema = resolveSchema;
const PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function getJsonPointer(parsedRef, { baseId, schema: schema2, root }) {
  var _a;
  if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
    return;
  for (const part of parsedRef.fragment.slice(1).split("/")) {
    if (typeof schema2 === "boolean")
      return;
    const partSchema = schema2[(0, util_1$k.unescapeFragment)(part)];
    if (partSchema === void 0)
      return;
    schema2 = partSchema;
    const schId = typeof schema2 === "object" && schema2[this.opts.schemaId];
    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
      baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
    }
  }
  let env2;
  if (typeof schema2 != "boolean" && schema2.$ref && !(0, util_1$k.schemaHasRulesButRef)(schema2, this.RULES)) {
    const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema2.$ref);
    env2 = resolveSchema.call(this, root, $ref);
  }
  const { schemaId } = this.opts;
  env2 = env2 || new SchemaEnv({ schema: schema2, schemaId, root, baseId });
  if (env2.schema !== env2.root.schema)
    return env2;
  return void 0;
}
const $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
const type$1 = "object";
const required$1 = [
  "$data"
];
const properties$2 = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
};
const additionalProperties$1 = false;
const require$$9 = {
  $id: $id$1,
  description,
  type: type$1,
  required: required$1,
  properties: properties$2,
  additionalProperties: additionalProperties$1
};
var uri$1 = {};
var uri_all = { exports: {} };
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function(module2, exports2) {
  (function(global2, factory) {
    factory(exports2);
  })(commonjsGlobal, function(exports3) {
    function merge() {
      for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
        sets[_key] = arguments[_key];
      }
      if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
          sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join("");
      } else {
        return sets[0];
      }
    }
    function subexp(str) {
      return "(?:" + str + ")";
    }
    function typeOf(o) {
      return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
    }
    function toUpperCase(str) {
      return str.toUpperCase();
    }
    function toArray(obj) {
      return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
    }
    function assign(target, source2) {
      var obj = target;
      if (source2) {
        for (var key in source2) {
          obj[key] = source2[key];
        }
      }
      return obj;
    }
    function buildExps(isIRI) {
      var ALPHA$$ = "[A-Za-z]", DIGIT$$ = "[0-9]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$);
      subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*");
      subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*");
      var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+");
      subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+");
      subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*");
      var PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]"));
      subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+");
      subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*");
      return {
        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
        //RFC 6874, with relaxed parsing rules
      };
    }
    var URI_PROTOCOL = buildExps(false);
    var IRI_PROTOCOL = buildExps(true);
    var slicedToArray = /* @__PURE__ */ function() {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"])
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    var toConsumableArray = function(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
          arr2[i] = arr[i];
        return arr2;
      } else {
        return Array.from(arr);
      }
    };
    var maxInt = 2147483647;
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter = "-";
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7E]/;
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    var errors2 = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    function error$12(type2) {
      throw new RangeError(errors2[type2]);
    }
    function map(array, fn) {
      var result = [];
      var length = array.length;
      while (length--) {
        result[length] = fn(array[length]);
      }
      return result;
    }
    function mapDomain(string, fn) {
      var parts = string.split("@");
      var result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string = parts[1];
      }
      string = string.replace(regexSeparators, ".");
      var labels = string.split(".");
      var encoded = map(labels, fn).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      var output = [];
      var counter = 0;
      var length = string.length;
      while (counter < length) {
        var value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          var extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    var ucs2encode = function ucs2encode2(array) {
      return String.fromCodePoint.apply(String, toConsumableArray(array));
    };
    var basicToDigit = function basicToDigit2(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    };
    var digitToBasic = function digitToBasic2(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    var adapt = function adapt2(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (
        ;
        /* no initialization */
        delta > baseMinusTMin * tMax >> 1;
        k += base
      ) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var decode = function decode2(input) {
      var output = [];
      var inputLength = input.length;
      var i = 0;
      var n = initialN;
      var bias = initialBias;
      var basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (var j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error$12("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        var oldi = i;
        for (
          var w = 1, k = base;
          ;
          /* no condition */
          k += base
        ) {
          if (index >= inputLength) {
            error$12("invalid-input");
          }
          var digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base || digit > floor((maxInt - i) / w)) {
            error$12("overflow");
          }
          i += digit * w;
          var t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t2) {
            break;
          }
          var baseMinusT = base - t2;
          if (w > floor(maxInt / baseMinusT)) {
            error$12("overflow");
          }
          w *= baseMinusT;
        }
        var out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error$12("overflow");
        }
        n += floor(i / out);
        i %= out;
        output.splice(i++, 0, n);
      }
      return String.fromCodePoint.apply(String, output);
    };
    var encode = function encode2(input) {
      var output = [];
      input = ucs2decode(input);
      var inputLength = input.length;
      var n = initialN;
      var delta = 0;
      var bias = initialBias;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _currentValue2 = _step.value;
          if (_currentValue2 < 128) {
            output.push(stringFromCharCode(_currentValue2));
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      var basicLength = output.length;
      var handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        var m = maxInt;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = void 0;
        try {
          for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var currentValue = _step2.value;
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
        var handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error$12("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = void 0;
        try {
          for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _currentValue = _step3.value;
            if (_currentValue < n && ++delta > maxInt) {
              error$12("overflow");
            }
            if (_currentValue == n) {
              var q = delta;
              for (
                var k = base;
                ;
                /* no condition */
                k += base
              ) {
                var t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t2) {
                  break;
                }
                var qMinusT = q - t2;
                var baseMinusT = base - t2;
                output.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    };
    var toUnicode = function toUnicode2(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    var toASCII = function toASCII2(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    var punycode = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      "version": "2.1.0",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode,
      "encode": encode,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    var SCHEMES = {};
    function pctEncChar(chr) {
      var c = chr.charCodeAt(0);
      var e = void 0;
      if (c < 16)
        e = "%0" + c.toString(16).toUpperCase();
      else if (c < 128)
        e = "%" + c.toString(16).toUpperCase();
      else if (c < 2048)
        e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      else
        e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      return e;
    }
    function pctDecChars(str) {
      var newStr = "";
      var i = 0;
      var il = str.length;
      while (i < il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
          newStr += String.fromCharCode(c);
          i += 3;
        } else if (c >= 194 && c < 224) {
          if (il - i >= 6) {
            var c2 = parseInt(str.substr(i + 4, 2), 16);
            newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
          } else {
            newStr += str.substr(i, 6);
          }
          i += 6;
        } else if (c >= 224) {
          if (il - i >= 9) {
            var _c = parseInt(str.substr(i + 4, 2), 16);
            var c3 = parseInt(str.substr(i + 7, 2), 16);
            newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
          } else {
            newStr += str.substr(i, 9);
          }
          i += 9;
        } else {
          newStr += str.substr(i, 3);
          i += 3;
        }
      }
      return newStr;
    }
    function _normalizeComponentEncoding(components, protocol) {
      function decodeUnreserved2(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
      }
      if (components.scheme)
        components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
      if (components.userinfo !== void 0)
        components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.host !== void 0)
        components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.path !== void 0)
        components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.query !== void 0)
        components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.fragment !== void 0)
        components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      return components;
    }
    function _stripLeadingZeros(str) {
      return str.replace(/^0*(.*)/, "$1") || "0";
    }
    function _normalizeIPv4(host, protocol) {
      var matches = host.match(protocol.IPV4ADDRESS) || [];
      var _matches = slicedToArray(matches, 2), address = _matches[1];
      if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
      } else {
        return host;
      }
    }
    function _normalizeIPv6(host, protocol) {
      var matches = host.match(protocol.IPV6ADDRESS) || [];
      var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
      if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
          fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
        }
        if (isLastFieldIPv4Address) {
          fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function(acc, field, index) {
          if (!field || field === "0") {
            var lastLongest = acc[acc.length - 1];
            if (lastLongest && lastLongest.index + lastLongest.length === index) {
              lastLongest.length++;
            } else {
              acc.push({ index, length: 1 });
            }
          }
          return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function(a, b) {
          return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
          var newFirst = fields.slice(0, longestZeroFields.index);
          var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
          newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
          newHost = fields.join(":");
        }
        if (zone) {
          newHost += "%" + zone;
        }
        return newHost;
      } else {
        return host;
      }
    }
    var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
    var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
    function parse2(uriString) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var components = {};
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      if (options.reference === "suffix")
        uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
      var matches = uriString.match(URI_PARSE);
      if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
          components.scheme = matches[1];
          components.userinfo = matches[3];
          components.host = matches[4];
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = matches[7];
          components.fragment = matches[8];
          if (isNaN(components.port)) {
            components.port = matches[5];
          }
        } else {
          components.scheme = matches[1] || void 0;
          components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
          components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
          components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
          if (isNaN(components.port)) {
            components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
          }
        }
        if (components.host) {
          components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
          components.reference = "same-document";
        } else if (components.scheme === void 0) {
          components.reference = "relative";
        } else if (components.fragment === void 0) {
          components.reference = "absolute";
        } else {
          components.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
          components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
            try {
              components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
            }
          }
          _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
          _normalizeComponentEncoding(components, protocol);
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(components, options);
        }
      } else {
        components.error = components.error || "URI can not be parsed.";
      }
      return components;
    }
    function _recomposeAuthority(components, options) {
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
          return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    var RDS1 = /^\.\.?\//;
    var RDS2 = /^\/\.(\/|$)/;
    var RDS3 = /^\/\.\.(\/|$)/;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
    function removeDotSegments(input) {
      var output = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          var im = input.match(RDS5);
          if (im) {
            var s = im[0];
            input = input.slice(s.length);
            output.push(s);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output.join("");
    }
    function serialize(components) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize)
        schemeHandler.serialize(components, options);
      if (components.host) {
        if (protocol.IPV6ADDRESS.test(components.host))
          ;
        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
          try {
            components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
          } catch (e) {
            components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
          }
        }
      }
      _normalizeComponentEncoding(components, protocol);
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
      }
      var authority = _recomposeAuthority(components, options);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        var s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0) {
          s = s.replace(/^\/\//, "/%2F");
        }
        uriTokens.push(s);
      }
      if (components.query !== void 0) {
        uriTokens.push("?");
        uriTokens.push(components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
      }
      return uriTokens.join("");
    }
    function resolveComponents(base2, relative) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var skipNormalization = arguments[3];
      var target = {};
      if (!skipNormalization) {
        base2 = parse2(serialize(base2, options), options);
        relative = parse2(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base2.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base2.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                target.path = "/" + relative.path;
              } else if (!base2.path) {
                target.path = relative.path;
              } else {
                target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base2.userinfo;
          target.host = base2.host;
          target.port = base2.port;
        }
        target.scheme = base2.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function resolve2(baseURI, relativeURI, options) {
      var schemelessOptions = assign({ scheme: "null" }, options);
      return serialize(resolveComponents(parse2(baseURI, schemelessOptions), parse2(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
    }
    function normalize(uri2, options) {
      if (typeof uri2 === "string") {
        uri2 = serialize(parse2(uri2, options), options);
      } else if (typeOf(uri2) === "object") {
        uri2 = parse2(serialize(uri2, options), options);
      }
      return uri2;
    }
    function equal3(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = serialize(parse2(uriA, options), options);
      } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
      }
      if (typeof uriB === "string") {
        uriB = serialize(parse2(uriB, options), options);
      } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
      }
      return uriA === uriB;
    }
    function escapeComponent(str, options) {
      return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
    }
    function unescapeComponent(str, options) {
      return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
    }
    var handler = {
      scheme: "http",
      domainHost: true,
      parse: function parse3(components, options) {
        if (!components.host) {
          components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
      },
      serialize: function serialize2(components, options) {
        var secure = String(components.scheme).toLowerCase() === "https";
        if (components.port === (secure ? 443 : 80) || components.port === "") {
          components.port = void 0;
        }
        if (!components.path) {
          components.path = "/";
        }
        return components;
      }
    };
    var handler$1 = {
      scheme: "https",
      domainHost: handler.domainHost,
      parse: handler.parse,
      serialize: handler.serialize
    };
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    var handler$2 = {
      scheme: "ws",
      domainHost: true,
      parse: function parse3(components, options) {
        var wsComponents = components;
        wsComponents.secure = isSecure(wsComponents);
        wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
        wsComponents.path = void 0;
        wsComponents.query = void 0;
        return wsComponents;
      },
      serialize: function serialize2(wsComponents, options) {
        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
          wsComponents.port = void 0;
        }
        if (typeof wsComponents.secure === "boolean") {
          wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
          wsComponents.secure = void 0;
        }
        if (wsComponents.resourceName) {
          var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path2 = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
          wsComponents.path = path2 && path2 !== "/" ? path2 : void 0;
          wsComponents.query = query;
          wsComponents.resourceName = void 0;
        }
        wsComponents.fragment = void 0;
        return wsComponents;
      }
    };
    var handler$3 = {
      scheme: "wss",
      domainHost: handler$2.domainHost,
      parse: handler$2.parse,
      serialize: handler$2.serialize
    };
    var O = {};
    var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]";
    var HEXDIG$$ = "[0-9A-Fa-f]";
    var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
    var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
    var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
    var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
    var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
    var UNRESERVED = new RegExp(UNRESERVED$$, "g");
    var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
    var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
    var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
    var NOT_HFVALUE = NOT_HFNAME;
    function decodeUnreserved(str) {
      var decStr = pctDecChars(str);
      return !decStr.match(UNRESERVED) ? str : decStr;
    }
    var handler$4 = {
      scheme: "mailto",
      parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = void 0;
        if (mailtoComponents.query) {
          var unknownHeaders = false;
          var headers = {};
          var hfields = mailtoComponents.query.split("&");
          for (var x = 0, xl = hfields.length; x < xl; ++x) {
            var hfield = hfields[x].split("=");
            switch (hfield[0]) {
              case "to":
                var toAddrs = hfield[1].split(",");
                for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                  to.push(toAddrs[_x]);
                }
                break;
              case "subject":
                mailtoComponents.subject = unescapeComponent(hfield[1], options);
                break;
              case "body":
                mailtoComponents.body = unescapeComponent(hfield[1], options);
                break;
              default:
                unknownHeaders = true;
                headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                break;
            }
          }
          if (unknownHeaders)
            mailtoComponents.headers = headers;
        }
        mailtoComponents.query = void 0;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
          var addr = to[_x2].split("@");
          addr[0] = unescapeComponent(addr[0]);
          if (!options.unicodeSupport) {
            try {
              addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
            } catch (e) {
              mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
            }
          } else {
            addr[1] = unescapeComponent(addr[1], options).toLowerCase();
          }
          to[_x2] = addr.join("@");
        }
        return mailtoComponents;
      },
      serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray(mailtoComponents.to);
        if (to) {
          for (var x = 0, xl = to.length; x < xl; ++x) {
            var toAddr = String(to[x]);
            var atIdx = toAddr.lastIndexOf("@");
            var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
            var domain = toAddr.slice(atIdx + 1);
            try {
              domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
            } catch (e) {
              components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
            to[x] = localPart + "@" + domain;
          }
          components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject)
          headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body)
          headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
          if (headers[name] !== O[name]) {
            fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
          }
        }
        if (fields.length) {
          components.query = fields.join("&");
        }
        return components;
      }
    };
    var URN_PARSE = /^([^\:]+)\:(.*)/;
    var handler$5 = {
      scheme: "urn",
      parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = matches[1].toLowerCase();
          var nss = matches[2];
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          urnComponents.nid = nid;
          urnComponents.nss = nss;
          urnComponents.path = void 0;
          if (schemeHandler) {
            urnComponents = schemeHandler.parse(urnComponents, options);
          }
        } else {
          urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
      },
      serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
          urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
      }
    };
    var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
    var handler$6 = {
      scheme: "urn:uuid",
      parse: function parse3(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = void 0;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
          uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
      },
      serialize: function serialize2(uuidComponents, options) {
        var urnComponents = uuidComponents;
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
      }
    };
    SCHEMES[handler.scheme] = handler;
    SCHEMES[handler$1.scheme] = handler$1;
    SCHEMES[handler$2.scheme] = handler$2;
    SCHEMES[handler$3.scheme] = handler$3;
    SCHEMES[handler$4.scheme] = handler$4;
    SCHEMES[handler$5.scheme] = handler$5;
    SCHEMES[handler$6.scheme] = handler$6;
    exports3.SCHEMES = SCHEMES;
    exports3.pctEncChar = pctEncChar;
    exports3.pctDecChars = pctDecChars;
    exports3.parse = parse2;
    exports3.removeDotSegments = removeDotSegments;
    exports3.serialize = serialize;
    exports3.resolveComponents = resolveComponents;
    exports3.resolve = resolve2;
    exports3.normalize = normalize;
    exports3.equal = equal3;
    exports3.escapeComponent = escapeComponent;
    exports3.unescapeComponent = unescapeComponent;
    Object.defineProperty(exports3, "__esModule", { value: true });
  });
})(uri_all, uri_all.exports);
var uri_allExports = uri_all.exports;
Object.defineProperty(uri$1, "__esModule", { value: true });
const uri = uri_allExports;
uri.code = 'require("ajv/dist/runtime/uri").default';
uri$1.default = uri;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
  var validate_12 = validate;
  Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  const validation_error_12 = validation_error;
  const ref_error_12 = ref_error;
  const rules_1 = rules;
  const compile_12 = compile;
  const codegen_2 = codegen;
  const resolve_12 = resolve$1;
  const dataType_12 = dataType;
  const util_12 = util;
  const $dataRefSchema = require$$9;
  const uri_1 = uri$1;
  const defaultRegExp = (str, flags) => new RegExp(str, flags);
  defaultRegExp.code = "new RegExp";
  const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
  const EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]);
  const removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  };
  const deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  };
  const MAX_EXPRESSION = 200;
  function requiredOptions(o) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
    const s = o.strict;
    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
    const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
    return {
      strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
      strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
      strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
      strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
      strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
      code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
      loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
      loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
      meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
      messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
      inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
      schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
      addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
      validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
      validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
      unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
      int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
      uriResolver
    };
  }
  class Ajv {
    constructor(opts = {}) {
      this.schemas = {};
      this.refs = {};
      this.formats = {};
      this._compilations = /* @__PURE__ */ new Set();
      this._loading = {};
      this._cache = /* @__PURE__ */ new Map();
      opts = this.opts = { ...opts, ...requiredOptions(opts) };
      const { es5, lines } = this.opts.code;
      this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
      this.logger = getLogger(opts.logger);
      const formatOpt = opts.validateFormats;
      opts.validateFormats = false;
      this.RULES = (0, rules_1.getRules)();
      checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
      checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
      this._metaOpts = getMetaSchemaOptions.call(this);
      if (opts.formats)
        addInitialFormats.call(this);
      this._addVocabularies();
      this._addDefaultMetaSchema();
      if (opts.keywords)
        addInitialKeywords.call(this, opts.keywords);
      if (typeof opts.meta == "object")
        this.addMetaSchema(opts.meta);
      addInitialSchemas.call(this);
      opts.validateFormats = formatOpt;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data, meta, schemaId } = this.opts;
      let _dataRefSchema = $dataRefSchema;
      if (schemaId === "id") {
        _dataRefSchema = { ...$dataRefSchema };
        _dataRefSchema.id = _dataRefSchema.$id;
        delete _dataRefSchema.$id;
      }
      if (meta && $data)
        this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
      const { meta, schemaId } = this.opts;
      return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
    }
    validate(schemaKeyRef, data) {
      let v;
      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v)
          throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
      } else {
        v = this.compile(schemaKeyRef);
      }
      const valid2 = v(data);
      if (!("$async" in v))
        this.errors = v.errors;
      return valid2;
    }
    compile(schema2, _meta) {
      const sch = this._addSchema(schema2, _meta);
      return sch.validate || this._compileSchemaEnv(sch);
    }
    compileAsync(schema2, meta) {
      if (typeof this.opts.loadSchema != "function") {
        throw new Error("options.loadSchema should be a function");
      }
      const { loadSchema } = this.opts;
      return runCompileAsync.call(this, schema2, meta);
      async function runCompileAsync(_schema, _meta) {
        await loadMetaSchema.call(this, _schema.$schema);
        const sch = this._addSchema(_schema, _meta);
        return sch.validate || _compileAsync.call(this, sch);
      }
      async function loadMetaSchema($ref) {
        if ($ref && !this.getSchema($ref)) {
          await runCompileAsync.call(this, { $ref }, true);
        }
      }
      async function _compileAsync(sch) {
        try {
          return this._compileSchemaEnv(sch);
        } catch (e) {
          if (!(e instanceof ref_error_12.default))
            throw e;
          checkLoaded.call(this, e);
          await loadMissingSchema.call(this, e.missingSchema);
          return _compileAsync.call(this, sch);
        }
      }
      function checkLoaded({ missingSchema: ref2, missingRef }) {
        if (this.refs[ref2]) {
          throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
        }
      }
      async function loadMissingSchema(ref2) {
        const _schema = await _loadSchema.call(this, ref2);
        if (!this.refs[ref2])
          await loadMetaSchema.call(this, _schema.$schema);
        if (!this.refs[ref2])
          this.addSchema(_schema, ref2, meta);
      }
      async function _loadSchema(ref2) {
        const p = this._loading[ref2];
        if (p)
          return p;
        try {
          return await (this._loading[ref2] = loadSchema(ref2));
        } finally {
          delete this._loading[ref2];
        }
      }
    }
    // Adds schema to the instance
    addSchema(schema2, key, _meta, _validateSchema = this.opts.validateSchema) {
      if (Array.isArray(schema2)) {
        for (const sch of schema2)
          this.addSchema(sch, void 0, _meta, _validateSchema);
        return this;
      }
      let id2;
      if (typeof schema2 === "object") {
        const { schemaId } = this.opts;
        id2 = schema2[schemaId];
        if (id2 !== void 0 && typeof id2 != "string") {
          throw new Error(`schema ${schemaId} must be string`);
        }
      }
      key = (0, resolve_12.normalizeId)(key || id2);
      this._checkUnique(key);
      this.schemas[key] = this._addSchema(schema2, _meta, key, _validateSchema, true);
      return this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(schema2, key, _validateSchema = this.opts.validateSchema) {
      this.addSchema(schema2, key, true, _validateSchema);
      return this;
    }
    //  Validate schema against its meta-schema
    validateSchema(schema2, throwOrLogError) {
      if (typeof schema2 == "boolean")
        return true;
      let $schema2;
      $schema2 = schema2.$schema;
      if ($schema2 !== void 0 && typeof $schema2 != "string") {
        throw new Error("$schema must be a string");
      }
      $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
      if (!$schema2) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      const valid2 = this.validate($schema2, schema2);
      if (!valid2 && throwOrLogError) {
        const message = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid2;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(keyRef) {
      let sch;
      while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
        keyRef = sch;
      if (sch === void 0) {
        const { schemaId } = this.opts;
        const root = new compile_12.SchemaEnv({ schema: {}, schemaId });
        sch = compile_12.resolveSchema.call(this, root, keyRef);
        if (!sch)
          return;
        this.refs[keyRef] = sch;
      }
      return sch.validate || this._compileSchemaEnv(sch);
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        this._removeAllSchemas(this.schemas, schemaKeyRef);
        this._removeAllSchemas(this.refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          this._removeAllSchemas(this.schemas);
          this._removeAllSchemas(this.refs);
          this._cache.clear();
          return this;
        case "string": {
          const sch = getSchEnv.call(this, schemaKeyRef);
          if (typeof sch == "object")
            this._cache.delete(sch.schema);
          delete this.schemas[schemaKeyRef];
          delete this.refs[schemaKeyRef];
          return this;
        }
        case "object": {
          const cacheKey = schemaKeyRef;
          this._cache.delete(cacheKey);
          let id2 = schemaKeyRef[this.opts.schemaId];
          if (id2) {
            id2 = (0, resolve_12.normalizeId)(id2);
            delete this.schemas[id2];
            delete this.refs[id2];
          }
          return this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(definitions2) {
      for (const def2 of definitions2)
        this.addKeyword(def2);
      return this;
    }
    addKeyword(kwdOrDef, def2) {
      let keyword2;
      if (typeof kwdOrDef == "string") {
        keyword2 = kwdOrDef;
        if (typeof def2 == "object") {
          this.logger.warn("these parameters are deprecated, see docs for addKeyword");
          def2.keyword = keyword2;
        }
      } else if (typeof kwdOrDef == "object" && def2 === void 0) {
        def2 = kwdOrDef;
        keyword2 = def2.keyword;
        if (Array.isArray(keyword2) && !keyword2.length) {
          throw new Error("addKeywords: keyword must be string or non-empty array");
        }
      } else {
        throw new Error("invalid addKeywords parameters");
      }
      checkKeyword.call(this, keyword2, def2);
      if (!def2) {
        (0, util_12.eachItem)(keyword2, (kwd) => addRule.call(this, kwd));
        return this;
      }
      keywordMetaschema.call(this, def2);
      const definition = {
        ...def2,
        type: (0, dataType_12.getJSONTypes)(def2.type),
        schemaType: (0, dataType_12.getJSONTypes)(def2.schemaType)
      };
      (0, util_12.eachItem)(keyword2, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t2) => addRule.call(this, k, definition, t2)));
      return this;
    }
    getKeyword(keyword2) {
      const rule = this.RULES.all[keyword2];
      return typeof rule == "object" ? rule.definition : !!rule;
    }
    // Remove keyword
    removeKeyword(keyword2) {
      const { RULES } = this;
      delete RULES.keywords[keyword2];
      delete RULES.all[keyword2];
      for (const group of RULES.rules) {
        const i = group.rules.findIndex((rule) => rule.keyword === keyword2);
        if (i >= 0)
          group.rules.splice(i, 1);
      }
      return this;
    }
    // Add format
    addFormat(name, format2) {
      if (typeof format2 == "string")
        format2 = new RegExp(format2);
      this.formats[name] = format2;
      return this;
    }
    errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
      if (!errors2 || errors2.length === 0)
        return "No errors";
      return errors2.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
      const rules2 = this.RULES.all;
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      for (const jsonPointer of keywordsJsonPointers) {
        const segments = jsonPointer.split("/").slice(1);
        let keywords = metaSchema;
        for (const seg of segments)
          keywords = keywords[seg];
        for (const key in rules2) {
          const rule = rules2[key];
          if (typeof rule != "object")
            continue;
          const { $data } = rule.definition;
          const schema2 = keywords[key];
          if ($data && schema2)
            keywords[key] = schemaOrData(schema2);
        }
      }
      return metaSchema;
    }
    _removeAllSchemas(schemas, regex) {
      for (const keyRef in schemas) {
        const sch = schemas[keyRef];
        if (!regex || regex.test(keyRef)) {
          if (typeof sch == "string") {
            delete schemas[keyRef];
          } else if (sch && !sch.meta) {
            this._cache.delete(sch.schema);
            delete schemas[keyRef];
          }
        }
      }
    }
    _addSchema(schema2, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
      let id2;
      const { schemaId } = this.opts;
      if (typeof schema2 == "object") {
        id2 = schema2[schemaId];
      } else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        else if (typeof schema2 != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let sch = this._cache.get(schema2);
      if (sch !== void 0)
        return sch;
      baseId = (0, resolve_12.normalizeId)(id2 || baseId);
      const localRefs = resolve_12.getSchemaRefs.call(this, schema2, baseId);
      sch = new compile_12.SchemaEnv({ schema: schema2, schemaId, meta, baseId, localRefs });
      this._cache.set(sch.schema, sch);
      if (addSchema && !baseId.startsWith("#")) {
        if (baseId)
          this._checkUnique(baseId);
        this.refs[baseId] = sch;
      }
      if (validateSchema)
        this.validateSchema(schema2, true);
      return sch;
    }
    _checkUnique(id2) {
      if (this.schemas[id2] || this.refs[id2]) {
        throw new Error(`schema with key or id "${id2}" already exists`);
      }
    }
    _compileSchemaEnv(sch) {
      if (sch.meta)
        this._compileMetaSchema(sch);
      else
        compile_12.compileSchema.call(this, sch);
      if (!sch.validate)
        throw new Error("ajv implementation error");
      return sch.validate;
    }
    _compileMetaSchema(sch) {
      const currentOpts = this.opts;
      this.opts = this._metaOpts;
      try {
        compile_12.compileSchema.call(this, sch);
      } finally {
        this.opts = currentOpts;
      }
    }
  }
  exports2.default = Ajv;
  Ajv.ValidationError = validation_error_12.default;
  Ajv.MissingRefError = ref_error_12.default;
  function checkOptions(checkOpts, options, msg, log = "error") {
    for (const key in checkOpts) {
      const opt = key;
      if (opt in options)
        this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
    }
  }
  function getSchEnv(keyRef) {
    keyRef = (0, resolve_12.normalizeId)(keyRef);
    return this.schemas[keyRef] || this.refs[keyRef];
  }
  function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
      return;
    if (Array.isArray(optsSchemas))
      this.addSchema(optsSchemas);
    else
      for (const key in optsSchemas)
        this.addSchema(optsSchemas[key], key);
  }
  function addInitialFormats() {
    for (const name in this.opts.formats) {
      const format2 = this.opts.formats[name];
      if (format2)
        this.addFormat(name, format2);
    }
  }
  function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
      this.addVocabulary(defs);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword2 in defs) {
      const def2 = defs[keyword2];
      if (!def2.keyword)
        def2.keyword = keyword2;
      this.addKeyword(def2);
    }
  }
  function getMetaSchemaOptions() {
    const metaOpts = { ...this.opts };
    for (const opt of META_IGNORE_OPTIONS)
      delete metaOpts[opt];
    return metaOpts;
  }
  const noLogs = { log() {
  }, warn() {
  }, error() {
  } };
  function getLogger(logger) {
    if (logger === false)
      return noLogs;
    if (logger === void 0)
      return console;
    if (logger.log && logger.warn && logger.error)
      return logger;
    throw new Error("logger must implement log, warn and error methods");
  }
  const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
  function checkKeyword(keyword2, def2) {
    const { RULES } = this;
    (0, util_12.eachItem)(keyword2, (kwd) => {
      if (RULES.keywords[kwd])
        throw new Error(`Keyword ${kwd} is already defined`);
      if (!KEYWORD_NAME.test(kwd))
        throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def2)
      return;
    if (def2.$data && !("code" in def2 || "validate" in def2)) {
      throw new Error('$data keyword must have "code" or "validate" function');
    }
  }
  function addRule(keyword2, definition, dataType2) {
    var _a;
    const post = definition === null || definition === void 0 ? void 0 : definition.post;
    if (dataType2 && post)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t2 }) => t2 === dataType2);
    if (!ruleGroup) {
      ruleGroup = { type: dataType2, rules: [] };
      RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword2] = true;
    if (!definition)
      return;
    const rule = {
      keyword: keyword2,
      definition: {
        ...definition,
        type: (0, dataType_12.getJSONTypes)(definition.type),
        schemaType: (0, dataType_12.getJSONTypes)(definition.schemaType)
      }
    };
    if (definition.before)
      addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
      ruleGroup.rules.push(rule);
    RULES.all[keyword2] = rule;
    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
  }
  function addBeforeRule(ruleGroup, rule, before) {
    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i >= 0) {
      ruleGroup.rules.splice(i, 0, rule);
    } else {
      ruleGroup.rules.push(rule);
      this.logger.warn(`rule ${before} is not defined`);
    }
  }
  function keywordMetaschema(def2) {
    let { metaSchema } = def2;
    if (metaSchema === void 0)
      return;
    if (def2.$data && this.opts.$data)
      metaSchema = schemaOrData(metaSchema);
    def2.validateSchema = this.compile(metaSchema, true);
  }
  const $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function schemaOrData(schema2) {
    return { anyOf: [schema2, $dataRef] };
  }
})(core$2);
var draft7 = {};
var core$1 = {};
var id = {};
Object.defineProperty(id, "__esModule", { value: true });
const def$s = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
id.default = def$s;
var ref = {};
Object.defineProperty(ref, "__esModule", { value: true });
ref.callRef = ref.getValidate = void 0;
const ref_error_1 = ref_error;
const code_1$8 = code;
const codegen_1$l = codegen;
const names_1$1 = names$1;
const compile_1$1 = compile;
const util_1$j = util;
const def$r = {
  keyword: "$ref",
  schemaType: "string",
  code(cxt) {
    const { gen, schema: $ref, it } = cxt;
    const { baseId, schemaEnv: env2, validateName, opts, self: self2 } = it;
    const { root } = env2;
    if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
      return callRootRef();
    const schOrEnv = compile_1$1.resolveRef.call(self2, root, baseId, $ref);
    if (schOrEnv === void 0)
      throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
    if (schOrEnv instanceof compile_1$1.SchemaEnv)
      return callValidate(schOrEnv);
    return inlineRefSchema(schOrEnv);
    function callRootRef() {
      if (env2 === root)
        return callRef(cxt, validateName, env2, env2.$async);
      const rootName = gen.scopeValue("root", { ref: root });
      return callRef(cxt, (0, codegen_1$l._)`${rootName}.validate`, root, root.$async);
    }
    function callValidate(sch) {
      const v = getValidate(cxt, sch);
      callRef(cxt, v, sch, sch.$async);
    }
    function inlineRefSchema(sch) {
      const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1$l.stringify)(sch) } : { ref: sch });
      const valid2 = gen.name("valid");
      const schCxt = cxt.subschema({
        schema: sch,
        dataTypes: [],
        schemaPath: codegen_1$l.nil,
        topSchemaRef: schName,
        errSchemaPath: $ref
      }, valid2);
      cxt.mergeEvaluated(schCxt);
      cxt.ok(valid2);
    }
  }
};
function getValidate(cxt, sch) {
  const { gen } = cxt;
  return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1$l._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
}
ref.getValidate = getValidate;
function callRef(cxt, v, sch, $async) {
  const { gen, it } = cxt;
  const { allErrors, schemaEnv: env2, opts } = it;
  const passCxt = opts.passContext ? names_1$1.default.this : codegen_1$l.nil;
  if ($async)
    callAsyncRef();
  else
    callSyncRef();
  function callAsyncRef() {
    if (!env2.$async)
      throw new Error("async schema referenced by sync schema");
    const valid2 = gen.let("valid");
    gen.try(() => {
      gen.code((0, codegen_1$l._)`await ${(0, code_1$8.callValidateCode)(cxt, v, passCxt)}`);
      addEvaluatedFrom(v);
      if (!allErrors)
        gen.assign(valid2, true);
    }, (e) => {
      gen.if((0, codegen_1$l._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
      addErrorsFrom(e);
      if (!allErrors)
        gen.assign(valid2, false);
    });
    cxt.ok(valid2);
  }
  function callSyncRef() {
    cxt.result((0, code_1$8.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
  }
  function addErrorsFrom(source2) {
    const errs = (0, codegen_1$l._)`${source2}.errors`;
    gen.assign(names_1$1.default.vErrors, (0, codegen_1$l._)`${names_1$1.default.vErrors} === null ? ${errs} : ${names_1$1.default.vErrors}.concat(${errs})`);
    gen.assign(names_1$1.default.errors, (0, codegen_1$l._)`${names_1$1.default.vErrors}.length`);
  }
  function addEvaluatedFrom(source2) {
    var _a;
    if (!it.opts.unevaluated)
      return;
    const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
    if (it.props !== true) {
      if (schEvaluated && !schEvaluated.dynamicProps) {
        if (schEvaluated.props !== void 0) {
          it.props = util_1$j.mergeEvaluated.props(gen, schEvaluated.props, it.props);
        }
      } else {
        const props = gen.var("props", (0, codegen_1$l._)`${source2}.evaluated.props`);
        it.props = util_1$j.mergeEvaluated.props(gen, props, it.props, codegen_1$l.Name);
      }
    }
    if (it.items !== true) {
      if (schEvaluated && !schEvaluated.dynamicItems) {
        if (schEvaluated.items !== void 0) {
          it.items = util_1$j.mergeEvaluated.items(gen, schEvaluated.items, it.items);
        }
      } else {
        const items2 = gen.var("items", (0, codegen_1$l._)`${source2}.evaluated.items`);
        it.items = util_1$j.mergeEvaluated.items(gen, items2, it.items, codegen_1$l.Name);
      }
    }
  }
}
ref.callRef = callRef;
ref.default = def$r;
Object.defineProperty(core$1, "__esModule", { value: true });
const id_1 = id;
const ref_1 = ref;
const core = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  id_1.default,
  ref_1.default
];
core$1.default = core;
var validation$1 = {};
var limitNumber = {};
Object.defineProperty(limitNumber, "__esModule", { value: true });
const codegen_1$k = codegen;
const ops = codegen_1$k.operators;
const KWDs = {
  maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
  minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
  exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
  exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
};
const error$i = {
  message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1$k.str)`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
  params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1$k._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
};
const def$q = {
  keyword: Object.keys(KWDs),
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$i,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    cxt.fail$data((0, codegen_1$k._)`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
  }
};
limitNumber.default = def$q;
var multipleOf = {};
Object.defineProperty(multipleOf, "__esModule", { value: true });
const codegen_1$j = codegen;
const error$h = {
  message: ({ schemaCode }) => (0, codegen_1$j.str)`must be multiple of ${schemaCode}`,
  params: ({ schemaCode }) => (0, codegen_1$j._)`{multipleOf: ${schemaCode}}`
};
const def$p = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$h,
  code(cxt) {
    const { gen, data, schemaCode, it } = cxt;
    const prec = it.opts.multipleOfPrecision;
    const res = gen.let("res");
    const invalid = prec ? (0, codegen_1$j._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1$j._)`${res} !== parseInt(${res})`;
    cxt.fail$data((0, codegen_1$j._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
  }
};
multipleOf.default = def$p;
var limitLength = {};
var ucs2length$1 = {};
Object.defineProperty(ucs2length$1, "__esModule", { value: true });
function ucs2length(str) {
  const len = str.length;
  let length = 0;
  let pos = 0;
  let value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 55296 && value <= 56319 && pos < len) {
      value = str.charCodeAt(pos);
      if ((value & 64512) === 56320)
        pos++;
    }
  }
  return length;
}
ucs2length$1.default = ucs2length;
ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(limitLength, "__esModule", { value: true });
const codegen_1$i = codegen;
const util_1$i = util;
const ucs2length_1 = ucs2length$1;
const error$g = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxLength" ? "more" : "fewer";
    return (0, codegen_1$i.str)`must NOT have ${comp} than ${schemaCode} characters`;
  },
  params: ({ schemaCode }) => (0, codegen_1$i._)`{limit: ${schemaCode}}`
};
const def$o = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: true,
  error: error$g,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode, it } = cxt;
    const op = keyword2 === "maxLength" ? codegen_1$i.operators.GT : codegen_1$i.operators.LT;
    const len = it.opts.unicode === false ? (0, codegen_1$i._)`${data}.length` : (0, codegen_1$i._)`${(0, util_1$i.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
    cxt.fail$data((0, codegen_1$i._)`${len} ${op} ${schemaCode}`);
  }
};
limitLength.default = def$o;
var pattern = {};
Object.defineProperty(pattern, "__esModule", { value: true });
const code_1$7 = code;
const codegen_1$h = codegen;
const error$f = {
  message: ({ schemaCode }) => (0, codegen_1$h.str)`must match pattern "${schemaCode}"`,
  params: ({ schemaCode }) => (0, codegen_1$h._)`{pattern: ${schemaCode}}`
};
const def$n = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: true,
  error: error$f,
  code(cxt) {
    const { data, $data, schema: schema2, schemaCode, it } = cxt;
    const u2 = it.opts.unicodeRegExp ? "u" : "";
    const regExp = $data ? (0, codegen_1$h._)`(new RegExp(${schemaCode}, ${u2}))` : (0, code_1$7.usePattern)(cxt, schema2);
    cxt.fail$data((0, codegen_1$h._)`!${regExp}.test(${data})`);
  }
};
pattern.default = def$n;
var limitProperties = {};
Object.defineProperty(limitProperties, "__esModule", { value: true });
const codegen_1$g = codegen;
const error$e = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxProperties" ? "more" : "fewer";
    return (0, codegen_1$g.str)`must NOT have ${comp} than ${schemaCode} properties`;
  },
  params: ({ schemaCode }) => (0, codegen_1$g._)`{limit: ${schemaCode}}`
};
const def$m = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: true,
  error: error$e,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxProperties" ? codegen_1$g.operators.GT : codegen_1$g.operators.LT;
    cxt.fail$data((0, codegen_1$g._)`Object.keys(${data}).length ${op} ${schemaCode}`);
  }
};
limitProperties.default = def$m;
var required = {};
Object.defineProperty(required, "__esModule", { value: true });
const code_1$6 = code;
const codegen_1$f = codegen;
const util_1$h = util;
const error$d = {
  message: ({ params: { missingProperty } }) => (0, codegen_1$f.str)`must have required property '${missingProperty}'`,
  params: ({ params: { missingProperty } }) => (0, codegen_1$f._)`{missingProperty: ${missingProperty}}`
};
const def$l = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: true,
  error: error$d,
  code(cxt) {
    const { gen, schema: schema2, schemaCode, data, $data, it } = cxt;
    const { opts } = it;
    if (!$data && schema2.length === 0)
      return;
    const useLoop = schema2.length >= opts.loopRequired;
    if (it.allErrors)
      allErrorsMode();
    else
      exitOnErrorMode();
    if (opts.strictRequired) {
      const props = cxt.parentSchema.properties;
      const { definedProperties } = cxt.it;
      for (const requiredKey of schema2) {
        if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
          const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
          (0, util_1$h.checkStrictMode)(it, msg, it.opts.strictRequired);
        }
      }
    }
    function allErrorsMode() {
      if (useLoop || $data) {
        cxt.block$data(codegen_1$f.nil, loopAllRequired);
      } else {
        for (const prop of schema2) {
          (0, code_1$6.checkReportMissingProp)(cxt, prop);
        }
      }
    }
    function exitOnErrorMode() {
      const missing = gen.let("missing");
      if (useLoop || $data) {
        const valid2 = gen.let("valid", true);
        cxt.block$data(valid2, () => loopUntilMissing(missing, valid2));
        cxt.ok(valid2);
      } else {
        gen.if((0, code_1$6.checkMissingProp)(cxt, schema2, missing));
        (0, code_1$6.reportMissingProp)(cxt, missing);
        gen.else();
      }
    }
    function loopAllRequired() {
      gen.forOf("prop", schemaCode, (prop) => {
        cxt.setParams({ missingProperty: prop });
        gen.if((0, code_1$6.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
      });
    }
    function loopUntilMissing(missing, valid2) {
      cxt.setParams({ missingProperty: missing });
      gen.forOf(missing, schemaCode, () => {
        gen.assign(valid2, (0, code_1$6.propertyInData)(gen, data, missing, opts.ownProperties));
        gen.if((0, codegen_1$f.not)(valid2), () => {
          cxt.error();
          gen.break();
        });
      }, codegen_1$f.nil);
    }
  }
};
required.default = def$l;
var limitItems = {};
Object.defineProperty(limitItems, "__esModule", { value: true });
const codegen_1$e = codegen;
const error$c = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxItems" ? "more" : "fewer";
    return (0, codegen_1$e.str)`must NOT have ${comp} than ${schemaCode} items`;
  },
  params: ({ schemaCode }) => (0, codegen_1$e._)`{limit: ${schemaCode}}`
};
const def$k = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: true,
  error: error$c,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxItems" ? codegen_1$e.operators.GT : codegen_1$e.operators.LT;
    cxt.fail$data((0, codegen_1$e._)`${data}.length ${op} ${schemaCode}`);
  }
};
limitItems.default = def$k;
var uniqueItems = {};
var equal$1 = {};
Object.defineProperty(equal$1, "__esModule", { value: true });
const equal2 = fastDeepEqual;
equal2.code = 'require("ajv/dist/runtime/equal").default';
equal$1.default = equal2;
Object.defineProperty(uniqueItems, "__esModule", { value: true });
const dataType_1 = dataType;
const codegen_1$d = codegen;
const util_1$g = util;
const equal_1$2 = equal$1;
const error$b = {
  message: ({ params: { i, j } }) => (0, codegen_1$d.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
  params: ({ params: { i, j } }) => (0, codegen_1$d._)`{i: ${i}, j: ${j}}`
};
const def$j = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: true,
  error: error$b,
  code(cxt) {
    const { gen, data, $data, schema: schema2, parentSchema, schemaCode, it } = cxt;
    if (!$data && !schema2)
      return;
    const valid2 = gen.let("valid");
    const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
    cxt.block$data(valid2, validateUniqueItems, (0, codegen_1$d._)`${schemaCode} === false`);
    cxt.ok(valid2);
    function validateUniqueItems() {
      const i = gen.let("i", (0, codegen_1$d._)`${data}.length`);
      const j = gen.let("j");
      cxt.setParams({ i, j });
      gen.assign(valid2, true);
      gen.if((0, codegen_1$d._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
    }
    function canOptimize() {
      return itemTypes.length > 0 && !itemTypes.some((t2) => t2 === "object" || t2 === "array");
    }
    function loopN(i, j) {
      const item = gen.name("item");
      const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
      const indices = gen.const("indices", (0, codegen_1$d._)`{}`);
      gen.for((0, codegen_1$d._)`;${i}--;`, () => {
        gen.let(item, (0, codegen_1$d._)`${data}[${i}]`);
        gen.if(wrongType, (0, codegen_1$d._)`continue`);
        if (itemTypes.length > 1)
          gen.if((0, codegen_1$d._)`typeof ${item} == "string"`, (0, codegen_1$d._)`${item} += "_"`);
        gen.if((0, codegen_1$d._)`typeof ${indices}[${item}] == "number"`, () => {
          gen.assign(j, (0, codegen_1$d._)`${indices}[${item}]`);
          cxt.error();
          gen.assign(valid2, false).break();
        }).code((0, codegen_1$d._)`${indices}[${item}] = ${i}`);
      });
    }
    function loopN2(i, j) {
      const eql = (0, util_1$g.useFunc)(gen, equal_1$2.default);
      const outer = gen.name("outer");
      gen.label(outer).for((0, codegen_1$d._)`;${i}--;`, () => gen.for((0, codegen_1$d._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1$d._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
        cxt.error();
        gen.assign(valid2, false).break(outer);
      })));
    }
  }
};
uniqueItems.default = def$j;
var _const = {};
Object.defineProperty(_const, "__esModule", { value: true });
const codegen_1$c = codegen;
const util_1$f = util;
const equal_1$1 = equal$1;
const error$a = {
  message: "must be equal to constant",
  params: ({ schemaCode }) => (0, codegen_1$c._)`{allowedValue: ${schemaCode}}`
};
const def$i = {
  keyword: "const",
  $data: true,
  error: error$a,
  code(cxt) {
    const { gen, data, $data, schemaCode, schema: schema2 } = cxt;
    if ($data || schema2 && typeof schema2 == "object") {
      cxt.fail$data((0, codegen_1$c._)`!${(0, util_1$f.useFunc)(gen, equal_1$1.default)}(${data}, ${schemaCode})`);
    } else {
      cxt.fail((0, codegen_1$c._)`${schema2} !== ${data}`);
    }
  }
};
_const.default = def$i;
var _enum = {};
Object.defineProperty(_enum, "__esModule", { value: true });
const codegen_1$b = codegen;
const util_1$e = util;
const equal_1 = equal$1;
const error$9 = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode }) => (0, codegen_1$b._)`{allowedValues: ${schemaCode}}`
};
const def$h = {
  keyword: "enum",
  schemaType: "array",
  $data: true,
  error: error$9,
  code(cxt) {
    const { gen, data, $data, schema: schema2, schemaCode, it } = cxt;
    if (!$data && schema2.length === 0)
      throw new Error("enum must have non-empty array");
    const useLoop = schema2.length >= it.opts.loopEnum;
    let eql;
    const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1$e.useFunc)(gen, equal_1.default);
    let valid2;
    if (useLoop || $data) {
      valid2 = gen.let("valid");
      cxt.block$data(valid2, loopEnum);
    } else {
      if (!Array.isArray(schema2))
        throw new Error("ajv implementation error");
      const vSchema = gen.const("vSchema", schemaCode);
      valid2 = (0, codegen_1$b.or)(...schema2.map((_x, i) => equalCode(vSchema, i)));
    }
    cxt.pass(valid2);
    function loopEnum() {
      gen.assign(valid2, false);
      gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1$b._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid2, true).break()));
    }
    function equalCode(vSchema, i) {
      const sch = schema2[i];
      return typeof sch === "object" && sch !== null ? (0, codegen_1$b._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1$b._)`${data} === ${sch}`;
    }
  }
};
_enum.default = def$h;
Object.defineProperty(validation$1, "__esModule", { value: true });
const limitNumber_1 = limitNumber;
const multipleOf_1 = multipleOf;
const limitLength_1 = limitLength;
const pattern_1 = pattern;
const limitProperties_1 = limitProperties;
const required_1 = required;
const limitItems_1 = limitItems;
const uniqueItems_1 = uniqueItems;
const const_1 = _const;
const enum_1 = _enum;
const validation = [
  // number
  limitNumber_1.default,
  multipleOf_1.default,
  // string
  limitLength_1.default,
  pattern_1.default,
  // object
  limitProperties_1.default,
  required_1.default,
  // array
  limitItems_1.default,
  uniqueItems_1.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  const_1.default,
  enum_1.default
];
validation$1.default = validation;
var applicator = {};
var additionalItems = {};
Object.defineProperty(additionalItems, "__esModule", { value: true });
additionalItems.validateAdditionalItems = void 0;
const codegen_1$a = codegen;
const util_1$d = util;
const error$8 = {
  message: ({ params: { len } }) => (0, codegen_1$a.str)`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => (0, codegen_1$a._)`{limit: ${len}}`
};
const def$g = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: error$8,
  code(cxt) {
    const { parentSchema, it } = cxt;
    const { items: items2 } = parentSchema;
    if (!Array.isArray(items2)) {
      (0, util_1$d.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    validateAdditionalItems(cxt, items2);
  }
};
function validateAdditionalItems(cxt, items2) {
  const { gen, schema: schema2, data, keyword: keyword2, it } = cxt;
  it.items = true;
  const len = gen.const("len", (0, codegen_1$a._)`${data}.length`);
  if (schema2 === false) {
    cxt.setParams({ len: items2.length });
    cxt.pass((0, codegen_1$a._)`${len} <= ${items2.length}`);
  } else if (typeof schema2 == "object" && !(0, util_1$d.alwaysValidSchema)(it, schema2)) {
    const valid2 = gen.var("valid", (0, codegen_1$a._)`${len} <= ${items2.length}`);
    gen.if((0, codegen_1$a.not)(valid2), () => validateItems(valid2));
    cxt.ok(valid2);
  }
  function validateItems(valid2) {
    gen.forRange("i", items2.length, len, (i) => {
      cxt.subschema({ keyword: keyword2, dataProp: i, dataPropType: util_1$d.Type.Num }, valid2);
      if (!it.allErrors)
        gen.if((0, codegen_1$a.not)(valid2), () => gen.break());
    });
  }
}
additionalItems.validateAdditionalItems = validateAdditionalItems;
additionalItems.default = def$g;
var prefixItems = {};
var items = {};
Object.defineProperty(items, "__esModule", { value: true });
items.validateTuple = void 0;
const codegen_1$9 = codegen;
const util_1$c = util;
const code_1$5 = code;
const def$f = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(cxt) {
    const { schema: schema2, it } = cxt;
    if (Array.isArray(schema2))
      return validateTuple(cxt, "additionalItems", schema2);
    it.items = true;
    if ((0, util_1$c.alwaysValidSchema)(it, schema2))
      return;
    cxt.ok((0, code_1$5.validateArray)(cxt));
  }
};
function validateTuple(cxt, extraItems, schArr = cxt.schema) {
  const { gen, parentSchema, data, keyword: keyword2, it } = cxt;
  checkStrictTuple(parentSchema);
  if (it.opts.unevaluated && schArr.length && it.items !== true) {
    it.items = util_1$c.mergeEvaluated.items(gen, schArr.length, it.items);
  }
  const valid2 = gen.name("valid");
  const len = gen.const("len", (0, codegen_1$9._)`${data}.length`);
  schArr.forEach((sch, i) => {
    if ((0, util_1$c.alwaysValidSchema)(it, sch))
      return;
    gen.if((0, codegen_1$9._)`${len} > ${i}`, () => cxt.subschema({
      keyword: keyword2,
      schemaProp: i,
      dataProp: i
    }, valid2));
    cxt.ok(valid2);
  });
  function checkStrictTuple(sch) {
    const { opts, errSchemaPath } = it;
    const l = schArr.length;
    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
    if (opts.strictTuples && !fullTuple) {
      const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
      (0, util_1$c.checkStrictMode)(it, msg, opts.strictTuples);
    }
  }
}
items.validateTuple = validateTuple;
items.default = def$f;
Object.defineProperty(prefixItems, "__esModule", { value: true });
const items_1$1 = items;
const def$e = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (cxt) => (0, items_1$1.validateTuple)(cxt, "items")
};
prefixItems.default = def$e;
var items2020 = {};
Object.defineProperty(items2020, "__esModule", { value: true });
const codegen_1$8 = codegen;
const util_1$b = util;
const code_1$4 = code;
const additionalItems_1$1 = additionalItems;
const error$7 = {
  message: ({ params: { len } }) => (0, codegen_1$8.str)`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => (0, codegen_1$8._)`{limit: ${len}}`
};
const def$d = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: error$7,
  code(cxt) {
    const { schema: schema2, parentSchema, it } = cxt;
    const { prefixItems: prefixItems2 } = parentSchema;
    it.items = true;
    if ((0, util_1$b.alwaysValidSchema)(it, schema2))
      return;
    if (prefixItems2)
      (0, additionalItems_1$1.validateAdditionalItems)(cxt, prefixItems2);
    else
      cxt.ok((0, code_1$4.validateArray)(cxt));
  }
};
items2020.default = def$d;
var contains = {};
Object.defineProperty(contains, "__esModule", { value: true });
const codegen_1$7 = codegen;
const util_1$a = util;
const error$6 = {
  message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$7.str)`must contain at least ${min} valid item(s)` : (0, codegen_1$7.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
  params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$7._)`{minContains: ${min}}` : (0, codegen_1$7._)`{minContains: ${min}, maxContains: ${max}}`
};
const def$c = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: true,
  error: error$6,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, it } = cxt;
    let min;
    let max;
    const { minContains, maxContains } = parentSchema;
    if (it.opts.next) {
      min = minContains === void 0 ? 1 : minContains;
      max = maxContains;
    } else {
      min = 1;
    }
    const len = gen.const("len", (0, codegen_1$7._)`${data}.length`);
    cxt.setParams({ min, max });
    if (max === void 0 && min === 0) {
      (0, util_1$a.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
      return;
    }
    if (max !== void 0 && min > max) {
      (0, util_1$a.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
      cxt.fail();
      return;
    }
    if ((0, util_1$a.alwaysValidSchema)(it, schema2)) {
      let cond = (0, codegen_1$7._)`${len} >= ${min}`;
      if (max !== void 0)
        cond = (0, codegen_1$7._)`${cond} && ${len} <= ${max}`;
      cxt.pass(cond);
      return;
    }
    it.items = true;
    const valid2 = gen.name("valid");
    if (max === void 0 && min === 1) {
      validateItems(valid2, () => gen.if(valid2, () => gen.break()));
    } else if (min === 0) {
      gen.let(valid2, true);
      if (max !== void 0)
        gen.if((0, codegen_1$7._)`${data}.length > 0`, validateItemsWithCount);
    } else {
      gen.let(valid2, false);
      validateItemsWithCount();
    }
    cxt.result(valid2, () => cxt.reset());
    function validateItemsWithCount() {
      const schValid = gen.name("_valid");
      const count = gen.let("count", 0);
      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
    }
    function validateItems(_valid, block) {
      gen.forRange("i", 0, len, (i) => {
        cxt.subschema({
          keyword: "contains",
          dataProp: i,
          dataPropType: util_1$a.Type.Num,
          compositeRule: true
        }, _valid);
        block();
      });
    }
    function checkLimits(count) {
      gen.code((0, codegen_1$7._)`${count}++`);
      if (max === void 0) {
        gen.if((0, codegen_1$7._)`${count} >= ${min}`, () => gen.assign(valid2, true).break());
      } else {
        gen.if((0, codegen_1$7._)`${count} > ${max}`, () => gen.assign(valid2, false).break());
        if (min === 1)
          gen.assign(valid2, true);
        else
          gen.if((0, codegen_1$7._)`${count} >= ${min}`, () => gen.assign(valid2, true));
      }
    }
  }
};
contains.default = def$c;
var dependencies = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.validateSchemaDeps = exports2.validatePropertyDeps = exports2.error = void 0;
  const codegen_12 = codegen;
  const util_12 = util;
  const code_12 = code;
  exports2.error = {
    message: ({ params: { property, depsCount, deps } }) => {
      const property_ies = depsCount === 1 ? "property" : "properties";
      return (0, codegen_12.str)`must have ${property_ies} ${deps} when property ${property} is present`;
    },
    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_12._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
    // TODO change to reference
  };
  const def2 = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports2.error,
    code(cxt) {
      const [propDeps, schDeps] = splitDependencies(cxt);
      validatePropertyDeps(cxt, propDeps);
      validateSchemaDeps(cxt, schDeps);
    }
  };
  function splitDependencies({ schema: schema2 }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key in schema2) {
      if (key === "__proto__")
        continue;
      const deps = Array.isArray(schema2[key]) ? propertyDeps : schemaDeps;
      deps[key] = schema2[key];
    }
    return [propertyDeps, schemaDeps];
  }
  function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
    const { gen, data, it } = cxt;
    if (Object.keys(propertyDeps).length === 0)
      return;
    const missing = gen.let("missing");
    for (const prop in propertyDeps) {
      const deps = propertyDeps[prop];
      if (deps.length === 0)
        continue;
      const hasProperty = (0, code_12.propertyInData)(gen, data, prop, it.opts.ownProperties);
      cxt.setParams({
        property: prop,
        depsCount: deps.length,
        deps: deps.join(", ")
      });
      if (it.allErrors) {
        gen.if(hasProperty, () => {
          for (const depProp of deps) {
            (0, code_12.checkReportMissingProp)(cxt, depProp);
          }
        });
      } else {
        gen.if((0, codegen_12._)`${hasProperty} && (${(0, code_12.checkMissingProp)(cxt, deps, missing)})`);
        (0, code_12.reportMissingProp)(cxt, missing);
        gen.else();
      }
    }
  }
  exports2.validatePropertyDeps = validatePropertyDeps;
  function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
    const { gen, data, keyword: keyword2, it } = cxt;
    const valid2 = gen.name("valid");
    for (const prop in schemaDeps) {
      if ((0, util_12.alwaysValidSchema)(it, schemaDeps[prop]))
        continue;
      gen.if(
        (0, code_12.propertyInData)(gen, data, prop, it.opts.ownProperties),
        () => {
          const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid2);
          cxt.mergeValidEvaluated(schCxt, valid2);
        },
        () => gen.var(valid2, true)
        // TODO var
      );
      cxt.ok(valid2);
    }
  }
  exports2.validateSchemaDeps = validateSchemaDeps;
  exports2.default = def2;
})(dependencies);
var propertyNames = {};
Object.defineProperty(propertyNames, "__esModule", { value: true });
const codegen_1$6 = codegen;
const util_1$9 = util;
const error$5 = {
  message: "property name must be valid",
  params: ({ params }) => (0, codegen_1$6._)`{propertyName: ${params.propertyName}}`
};
const def$b = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: error$5,
  code(cxt) {
    const { gen, schema: schema2, data, it } = cxt;
    if ((0, util_1$9.alwaysValidSchema)(it, schema2))
      return;
    const valid2 = gen.name("valid");
    gen.forIn("key", data, (key) => {
      cxt.setParams({ propertyName: key });
      cxt.subschema({
        keyword: "propertyNames",
        data: key,
        dataTypes: ["string"],
        propertyName: key,
        compositeRule: true
      }, valid2);
      gen.if((0, codegen_1$6.not)(valid2), () => {
        cxt.error(true);
        if (!it.allErrors)
          gen.break();
      });
    });
    cxt.ok(valid2);
  }
};
propertyNames.default = def$b;
var additionalProperties = {};
Object.defineProperty(additionalProperties, "__esModule", { value: true });
const code_1$3 = code;
const codegen_1$5 = codegen;
const names_1 = names$1;
const util_1$8 = util;
const error$4 = {
  message: "must NOT have additional properties",
  params: ({ params }) => (0, codegen_1$5._)`{additionalProperty: ${params.additionalProperty}}`
};
const def$a = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: true,
  trackErrors: true,
  error: error$4,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, errsCount, it } = cxt;
    if (!errsCount)
      throw new Error("ajv implementation error");
    const { allErrors, opts } = it;
    it.props = true;
    if (opts.removeAdditional !== "all" && (0, util_1$8.alwaysValidSchema)(it, schema2))
      return;
    const props = (0, code_1$3.allSchemaProperties)(parentSchema.properties);
    const patProps = (0, code_1$3.allSchemaProperties)(parentSchema.patternProperties);
    checkAdditionalProperties();
    cxt.ok((0, codegen_1$5._)`${errsCount} === ${names_1.default.errors}`);
    function checkAdditionalProperties() {
      gen.forIn("key", data, (key) => {
        if (!props.length && !patProps.length)
          additionalPropertyCode(key);
        else
          gen.if(isAdditional(key), () => additionalPropertyCode(key));
      });
    }
    function isAdditional(key) {
      let definedProp;
      if (props.length > 8) {
        const propsSchema = (0, util_1$8.schemaRefOrVal)(it, parentSchema.properties, "properties");
        definedProp = (0, code_1$3.isOwnProperty)(gen, propsSchema, key);
      } else if (props.length) {
        definedProp = (0, codegen_1$5.or)(...props.map((p) => (0, codegen_1$5._)`${key} === ${p}`));
      } else {
        definedProp = codegen_1$5.nil;
      }
      if (patProps.length) {
        definedProp = (0, codegen_1$5.or)(definedProp, ...patProps.map((p) => (0, codegen_1$5._)`${(0, code_1$3.usePattern)(cxt, p)}.test(${key})`));
      }
      return (0, codegen_1$5.not)(definedProp);
    }
    function deleteAdditional(key) {
      gen.code((0, codegen_1$5._)`delete ${data}[${key}]`);
    }
    function additionalPropertyCode(key) {
      if (opts.removeAdditional === "all" || opts.removeAdditional && schema2 === false) {
        deleteAdditional(key);
        return;
      }
      if (schema2 === false) {
        cxt.setParams({ additionalProperty: key });
        cxt.error();
        if (!allErrors)
          gen.break();
        return;
      }
      if (typeof schema2 == "object" && !(0, util_1$8.alwaysValidSchema)(it, schema2)) {
        const valid2 = gen.name("valid");
        if (opts.removeAdditional === "failing") {
          applyAdditionalSchema(key, valid2, false);
          gen.if((0, codegen_1$5.not)(valid2), () => {
            cxt.reset();
            deleteAdditional(key);
          });
        } else {
          applyAdditionalSchema(key, valid2);
          if (!allErrors)
            gen.if((0, codegen_1$5.not)(valid2), () => gen.break());
        }
      }
    }
    function applyAdditionalSchema(key, valid2, errors2) {
      const subschema2 = {
        keyword: "additionalProperties",
        dataProp: key,
        dataPropType: util_1$8.Type.Str
      };
      if (errors2 === false) {
        Object.assign(subschema2, {
          compositeRule: true,
          createErrors: false,
          allErrors: false
        });
      }
      cxt.subschema(subschema2, valid2);
    }
  }
};
additionalProperties.default = def$a;
var properties$1 = {};
Object.defineProperty(properties$1, "__esModule", { value: true });
const validate_1 = validate;
const code_1$2 = code;
const util_1$7 = util;
const additionalProperties_1$1 = additionalProperties;
const def$9 = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, it } = cxt;
    if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
      additionalProperties_1$1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1$1.default, "additionalProperties"));
    }
    const allProps = (0, code_1$2.allSchemaProperties)(schema2);
    for (const prop of allProps) {
      it.definedProperties.add(prop);
    }
    if (it.opts.unevaluated && allProps.length && it.props !== true) {
      it.props = util_1$7.mergeEvaluated.props(gen, (0, util_1$7.toHash)(allProps), it.props);
    }
    const properties2 = allProps.filter((p) => !(0, util_1$7.alwaysValidSchema)(it, schema2[p]));
    if (properties2.length === 0)
      return;
    const valid2 = gen.name("valid");
    for (const prop of properties2) {
      if (hasDefault(prop)) {
        applyPropertySchema(prop);
      } else {
        gen.if((0, code_1$2.propertyInData)(gen, data, prop, it.opts.ownProperties));
        applyPropertySchema(prop);
        if (!it.allErrors)
          gen.else().var(valid2, true);
        gen.endIf();
      }
      cxt.it.definedProperties.add(prop);
      cxt.ok(valid2);
    }
    function hasDefault(prop) {
      return it.opts.useDefaults && !it.compositeRule && schema2[prop].default !== void 0;
    }
    function applyPropertySchema(prop) {
      cxt.subschema({
        keyword: "properties",
        schemaProp: prop,
        dataProp: prop
      }, valid2);
    }
  }
};
properties$1.default = def$9;
var patternProperties = {};
Object.defineProperty(patternProperties, "__esModule", { value: true });
const code_1$1 = code;
const codegen_1$4 = codegen;
const util_1$6 = util;
const util_2 = util;
const def$8 = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema: schema2, data, parentSchema, it } = cxt;
    const { opts } = it;
    const patterns = (0, code_1$1.allSchemaProperties)(schema2);
    const alwaysValidPatterns = patterns.filter((p) => (0, util_1$6.alwaysValidSchema)(it, schema2[p]));
    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
      return;
    }
    const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
    const valid2 = gen.name("valid");
    if (it.props !== true && !(it.props instanceof codegen_1$4.Name)) {
      it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
    }
    const { props } = it;
    validatePatternProperties();
    function validatePatternProperties() {
      for (const pat of patterns) {
        if (checkProperties)
          checkMatchingProperties(pat);
        if (it.allErrors) {
          validateProperties(pat);
        } else {
          gen.var(valid2, true);
          validateProperties(pat);
          gen.if(valid2);
        }
      }
    }
    function checkMatchingProperties(pat) {
      for (const prop in checkProperties) {
        if (new RegExp(pat).test(prop)) {
          (0, util_1$6.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
        }
      }
    }
    function validateProperties(pat) {
      gen.forIn("key", data, (key) => {
        gen.if((0, codegen_1$4._)`${(0, code_1$1.usePattern)(cxt, pat)}.test(${key})`, () => {
          const alwaysValid = alwaysValidPatterns.includes(pat);
          if (!alwaysValid) {
            cxt.subschema({
              keyword: "patternProperties",
              schemaProp: pat,
              dataProp: key,
              dataPropType: util_2.Type.Str
            }, valid2);
          }
          if (it.opts.unevaluated && props !== true) {
            gen.assign((0, codegen_1$4._)`${props}[${key}]`, true);
          } else if (!alwaysValid && !it.allErrors) {
            gen.if((0, codegen_1$4.not)(valid2), () => gen.break());
          }
        });
      });
    }
  }
};
patternProperties.default = def$8;
var not = {};
Object.defineProperty(not, "__esModule", { value: true });
const util_1$5 = util;
const def$7 = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  code(cxt) {
    const { gen, schema: schema2, it } = cxt;
    if ((0, util_1$5.alwaysValidSchema)(it, schema2)) {
      cxt.fail();
      return;
    }
    const valid2 = gen.name("valid");
    cxt.subschema({
      keyword: "not",
      compositeRule: true,
      createErrors: false,
      allErrors: false
    }, valid2);
    cxt.failResult(valid2, () => cxt.reset(), () => cxt.error());
  },
  error: { message: "must NOT be valid" }
};
not.default = def$7;
var anyOf = {};
Object.defineProperty(anyOf, "__esModule", { value: true });
const code_1 = code;
const def$6 = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: true,
  code: code_1.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
anyOf.default = def$6;
var oneOf = {};
Object.defineProperty(oneOf, "__esModule", { value: true });
const codegen_1$3 = codegen;
const util_1$4 = util;
const error$3 = {
  message: "must match exactly one schema in oneOf",
  params: ({ params }) => (0, codegen_1$3._)`{passingSchemas: ${params.passing}}`
};
const def$5 = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: true,
  error: error$3,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, it } = cxt;
    if (!Array.isArray(schema2))
      throw new Error("ajv implementation error");
    if (it.opts.discriminator && parentSchema.discriminator)
      return;
    const schArr = schema2;
    const valid2 = gen.let("valid", false);
    const passing = gen.let("passing", null);
    const schValid = gen.name("_valid");
    cxt.setParams({ passing });
    gen.block(validateOneOf);
    cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
    function validateOneOf() {
      schArr.forEach((sch, i) => {
        let schCxt;
        if ((0, util_1$4.alwaysValidSchema)(it, sch)) {
          gen.var(schValid, true);
        } else {
          schCxt = cxt.subschema({
            keyword: "oneOf",
            schemaProp: i,
            compositeRule: true
          }, schValid);
        }
        if (i > 0) {
          gen.if((0, codegen_1$3._)`${schValid} && ${valid2}`).assign(valid2, false).assign(passing, (0, codegen_1$3._)`[${passing}, ${i}]`).else();
        }
        gen.if(schValid, () => {
          gen.assign(valid2, true);
          gen.assign(passing, i);
          if (schCxt)
            cxt.mergeEvaluated(schCxt, codegen_1$3.Name);
        });
      });
    }
  }
};
oneOf.default = def$5;
var allOf = {};
Object.defineProperty(allOf, "__esModule", { value: true });
const util_1$3 = util;
const def$4 = {
  keyword: "allOf",
  schemaType: "array",
  code(cxt) {
    const { gen, schema: schema2, it } = cxt;
    if (!Array.isArray(schema2))
      throw new Error("ajv implementation error");
    const valid2 = gen.name("valid");
    schema2.forEach((sch, i) => {
      if ((0, util_1$3.alwaysValidSchema)(it, sch))
        return;
      const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid2);
      cxt.ok(valid2);
      cxt.mergeEvaluated(schCxt);
    });
  }
};
allOf.default = def$4;
var _if = {};
Object.defineProperty(_if, "__esModule", { value: true });
const codegen_1$2 = codegen;
const util_1$2 = util;
const error$2 = {
  message: ({ params }) => (0, codegen_1$2.str)`must match "${params.ifClause}" schema`,
  params: ({ params }) => (0, codegen_1$2._)`{failingKeyword: ${params.ifClause}}`
};
const def$3 = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  error: error$2,
  code(cxt) {
    const { gen, parentSchema, it } = cxt;
    if (parentSchema.then === void 0 && parentSchema.else === void 0) {
      (0, util_1$2.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
    }
    const hasThen = hasSchema(it, "then");
    const hasElse = hasSchema(it, "else");
    if (!hasThen && !hasElse)
      return;
    const valid2 = gen.let("valid", true);
    const schValid = gen.name("_valid");
    validateIf();
    cxt.reset();
    if (hasThen && hasElse) {
      const ifClause = gen.let("ifClause");
      cxt.setParams({ ifClause });
      gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
    } else if (hasThen) {
      gen.if(schValid, validateClause("then"));
    } else {
      gen.if((0, codegen_1$2.not)(schValid), validateClause("else"));
    }
    cxt.pass(valid2, () => cxt.error(true));
    function validateIf() {
      const schCxt = cxt.subschema({
        keyword: "if",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, schValid);
      cxt.mergeEvaluated(schCxt);
    }
    function validateClause(keyword2, ifClause) {
      return () => {
        const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
        gen.assign(valid2, schValid);
        cxt.mergeValidEvaluated(schCxt, valid2);
        if (ifClause)
          gen.assign(ifClause, (0, codegen_1$2._)`${keyword2}`);
        else
          cxt.setParams({ ifClause: keyword2 });
      };
    }
  }
};
function hasSchema(it, keyword2) {
  const schema2 = it.schema[keyword2];
  return schema2 !== void 0 && !(0, util_1$2.alwaysValidSchema)(it, schema2);
}
_if.default = def$3;
var thenElse = {};
Object.defineProperty(thenElse, "__esModule", { value: true });
const util_1$1 = util;
const def$2 = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: keyword2, parentSchema, it }) {
    if (parentSchema.if === void 0)
      (0, util_1$1.checkStrictMode)(it, `"${keyword2}" without "if" is ignored`);
  }
};
thenElse.default = def$2;
Object.defineProperty(applicator, "__esModule", { value: true });
const additionalItems_1 = additionalItems;
const prefixItems_1 = prefixItems;
const items_1 = items;
const items2020_1 = items2020;
const contains_1 = contains;
const dependencies_1 = dependencies;
const propertyNames_1 = propertyNames;
const additionalProperties_1 = additionalProperties;
const properties_1 = properties$1;
const patternProperties_1 = patternProperties;
const not_1 = not;
const anyOf_1 = anyOf;
const oneOf_1 = oneOf;
const allOf_1 = allOf;
const if_1 = _if;
const thenElse_1 = thenElse;
function getApplicator(draft2020 = false) {
  const applicator2 = [
    // any
    not_1.default,
    anyOf_1.default,
    oneOf_1.default,
    allOf_1.default,
    if_1.default,
    thenElse_1.default,
    // object
    propertyNames_1.default,
    additionalProperties_1.default,
    dependencies_1.default,
    properties_1.default,
    patternProperties_1.default
  ];
  if (draft2020)
    applicator2.push(prefixItems_1.default, items2020_1.default);
  else
    applicator2.push(additionalItems_1.default, items_1.default);
  applicator2.push(contains_1.default);
  return applicator2;
}
applicator.default = getApplicator;
var format$2 = {};
var format$1 = {};
Object.defineProperty(format$1, "__esModule", { value: true });
const codegen_1$1 = codegen;
const error$1 = {
  message: ({ schemaCode }) => (0, codegen_1$1.str)`must match format "${schemaCode}"`,
  params: ({ schemaCode }) => (0, codegen_1$1._)`{format: ${schemaCode}}`
};
const def$1 = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: true,
  error: error$1,
  code(cxt, ruleType) {
    const { gen, data, $data, schema: schema2, schemaCode, it } = cxt;
    const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
    if (!opts.validateFormats)
      return;
    if ($data)
      validate$DataFormat();
    else
      validateFormat();
    function validate$DataFormat() {
      const fmts = gen.scopeValue("formats", {
        ref: self2.formats,
        code: opts.code.formats
      });
      const fDef = gen.const("fDef", (0, codegen_1$1._)`${fmts}[${schemaCode}]`);
      const fType = gen.let("fType");
      const format2 = gen.let("format");
      gen.if((0, codegen_1$1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1$1._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1$1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1$1._)`"string"`).assign(format2, fDef));
      cxt.fail$data((0, codegen_1$1.or)(unknownFmt(), invalidFmt()));
      function unknownFmt() {
        if (opts.strictSchema === false)
          return codegen_1$1.nil;
        return (0, codegen_1$1._)`${schemaCode} && !${format2}`;
      }
      function invalidFmt() {
        const callFormat = schemaEnv.$async ? (0, codegen_1$1._)`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : (0, codegen_1$1._)`${format2}(${data})`;
        const validData = (0, codegen_1$1._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
        return (0, codegen_1$1._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
      }
    }
    function validateFormat() {
      const formatDef = self2.formats[schema2];
      if (!formatDef) {
        unknownFormat();
        return;
      }
      if (formatDef === true)
        return;
      const [fmtType, format2, fmtRef] = getFormat(formatDef);
      if (fmtType === ruleType)
        cxt.pass(validCondition());
      function unknownFormat() {
        if (opts.strictSchema === false) {
          self2.logger.warn(unknownMsg());
          return;
        }
        throw new Error(unknownMsg());
        function unknownMsg() {
          return `unknown format "${schema2}" ignored in schema at path "${errSchemaPath}"`;
        }
      }
      function getFormat(fmtDef) {
        const code2 = fmtDef instanceof RegExp ? (0, codegen_1$1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1$1._)`${opts.code.formats}${(0, codegen_1$1.getProperty)(schema2)}` : void 0;
        const fmt = gen.scopeValue("formats", { key: schema2, ref: fmtDef, code: code2 });
        if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
          return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1$1._)`${fmt}.validate`];
        }
        return ["string", fmtDef, fmt];
      }
      function validCondition() {
        if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
          if (!schemaEnv.$async)
            throw new Error("async format in sync schema");
          return (0, codegen_1$1._)`await ${fmtRef}(${data})`;
        }
        return typeof format2 == "function" ? (0, codegen_1$1._)`${fmtRef}(${data})` : (0, codegen_1$1._)`${fmtRef}.test(${data})`;
      }
    }
  }
};
format$1.default = def$1;
Object.defineProperty(format$2, "__esModule", { value: true });
const format_1$1 = format$1;
const format = [format_1$1.default];
format$2.default = format;
var metadata = {};
Object.defineProperty(metadata, "__esModule", { value: true });
metadata.contentVocabulary = metadata.metadataVocabulary = void 0;
metadata.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
metadata.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(draft7, "__esModule", { value: true });
const core_1 = core$1;
const validation_1 = validation$1;
const applicator_1 = applicator;
const format_1 = format$2;
const metadata_1 = metadata;
const draft7Vocabularies = [
  core_1.default,
  validation_1.default,
  (0, applicator_1.default)(),
  format_1.default,
  metadata_1.metadataVocabulary,
  metadata_1.contentVocabulary
];
draft7.default = draft7Vocabularies;
var discriminator = {};
var types = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.DiscrError = void 0;
  (function(DiscrError) {
    DiscrError["Tag"] = "tag";
    DiscrError["Mapping"] = "mapping";
  })(exports2.DiscrError || (exports2.DiscrError = {}));
})(types);
Object.defineProperty(discriminator, "__esModule", { value: true });
const codegen_1 = codegen;
const types_1 = types;
const compile_1 = compile;
const util_1 = util;
const error = {
  message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
  params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
};
const def = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error,
  code(cxt) {
    const { gen, data, schema: schema2, parentSchema, it } = cxt;
    const { oneOf: oneOf2 } = parentSchema;
    if (!it.opts.discriminator) {
      throw new Error("discriminator: requires discriminator option");
    }
    const tagName = schema2.propertyName;
    if (typeof tagName != "string")
      throw new Error("discriminator: requires propertyName");
    if (schema2.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!oneOf2)
      throw new Error("discriminator: requires oneOf keyword");
    const valid2 = gen.let("valid", false);
    const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
    gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
    cxt.ok(valid2);
    function validateMapping() {
      const mapping = getMapping();
      gen.if(false);
      for (const tagValue in mapping) {
        gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
        gen.assign(valid2, applyTagSchema(mapping[tagValue]));
      }
      gen.else();
      cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
      gen.endIf();
    }
    function applyTagSchema(schemaProp) {
      const _valid = gen.name("valid");
      const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
      cxt.mergeEvaluated(schCxt, codegen_1.Name);
      return _valid;
    }
    function getMapping() {
      var _a;
      const oneOfMapping = {};
      const topRequired = hasRequired(parentSchema);
      let tagRequired = true;
      for (let i = 0; i < oneOf2.length; i++) {
        let sch = oneOf2[i];
        if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
          sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);
          if (sch instanceof compile_1.SchemaEnv)
            sch = sch.schema;
        }
        const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
        if (typeof propSch != "object") {
          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
        }
        tagRequired = tagRequired && (topRequired || hasRequired(sch));
        addMappings(propSch, i);
      }
      if (!tagRequired)
        throw new Error(`discriminator: "${tagName}" must be required`);
      return oneOfMapping;
      function hasRequired({ required: required2 }) {
        return Array.isArray(required2) && required2.includes(tagName);
      }
      function addMappings(sch, i) {
        if (sch.const) {
          addMapping(sch.const, i);
        } else if (sch.enum) {
          for (const tagValue of sch.enum) {
            addMapping(tagValue, i);
          }
        } else {
          throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
        }
      }
      function addMapping(tagValue, i) {
        if (typeof tagValue != "string" || tagValue in oneOfMapping) {
          throw new Error(`discriminator: "${tagName}" values must be unique strings`);
        }
        oneOfMapping[tagValue] = i;
      }
    }
  }
};
discriminator.default = def;
const $schema = "http://json-schema.org/draft-07/schema#";
const $id = "http://json-schema.org/draft-07/schema#";
const title = "Core schema meta-schema";
const definitions = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        "default": 0
      }
    ]
  },
  simpleTypes: {
    "enum": [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: true,
    "default": []
  }
};
const type = [
  "object",
  "boolean"
];
const properties = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  "default": true,
  readOnly: {
    type: "boolean",
    "default": false
  },
  examples: {
    type: "array",
    items: true
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    "default": true
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    "default": false
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    "default": {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  "const": true,
  "enum": {
    type: "array",
    items: true,
    minItems: 1,
    uniqueItems: true
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: true
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  "if": {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  "else": {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
};
const require$$3 = {
  $schema,
  $id,
  title,
  definitions,
  type,
  properties,
  "default": true
};
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.MissingRefError = exports2.ValidationError = exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
  const core_12 = core$2;
  const draft7_1 = draft7;
  const discriminator_1 = discriminator;
  const draft7MetaSchema = require$$3;
  const META_SUPPORT_DATA = ["/properties"];
  const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
  class Ajv extends core_12.default {
    _addVocabularies() {
      super._addVocabularies();
      draft7_1.default.forEach((v) => this.addVocabulary(v));
      if (this.opts.discriminator)
        this.addKeyword(discriminator_1.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      if (!this.opts.meta)
        return;
      const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
      this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
      this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
    }
  }
  module2.exports = exports2 = Ajv;
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.default = Ajv;
  var validate_12 = validate;
  Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  var validation_error_12 = validation_error;
  Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
    return validation_error_12.default;
  } });
  var ref_error_12 = ref_error;
  Object.defineProperty(exports2, "MissingRefError", { enumerable: true, get: function() {
    return ref_error_12.default;
  } });
})(ajv, ajv.exports);
var ajvExports = ajv.exports;
var dist = { exports: {} };
var formats = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.formatNames = exports2.fastFormats = exports2.fullFormats = void 0;
  function fmtDef(validate2, compare2) {
    return { validate: validate2, compare: compare2 };
  }
  exports2.fullFormats = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: fmtDef(date, compareDate),
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: fmtDef(time, compareTime),
    "date-time": fmtDef(date_time, compareDateTime),
    // duration: https://tools.ietf.org/html/rfc3339#appendix-A
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri: uri2,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    // uri-template: https://tools.ietf.org/html/rfc6570
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    // For the source: https://gist.github.com/dperini/729294
    // For test cases: https://mathiasbynens.be/demo/url-regex
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex,
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
    // byte: https://github.com/miguelmota/is-base64
    byte,
    // signed 32 bit integer
    int32: { type: "number", validate: validateInt32 },
    // signed 64 bit integer
    int64: { type: "number", validate: validateInt64 },
    // C-type float
    float: { type: "number", validate: validateNumber },
    // C-type double
    double: { type: "number", validate: validateNumber },
    // hint to the UI to hide input strings
    password: true,
    // unchecked string payload
    binary: true
  };
  exports2.fastFormats = {
    ...exports2.fullFormats,
    date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
    time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
    "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
  };
  exports2.formatNames = Object.keys(exports2.fullFormats);
  function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function date(str) {
    const matches = DATE.exec(str);
    if (!matches)
      return false;
    const year = +matches[1];
    const month = +matches[2];
    const day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
  }
  function compareDate(d1, d2) {
    if (!(d1 && d2))
      return void 0;
    if (d1 > d2)
      return 1;
    if (d1 < d2)
      return -1;
    return 0;
  }
  const TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
  function time(str, withTimeZone) {
    const matches = TIME.exec(str);
    if (!matches)
      return false;
    const hour = +matches[1];
    const minute = +matches[2];
    const second = +matches[3];
    const timeZone = matches[5];
    return (hour <= 23 && minute <= 59 && second <= 59 || hour === 23 && minute === 59 && second === 60) && (!withTimeZone || timeZone !== "");
  }
  function compareTime(t1, t2) {
    if (!(t1 && t2))
      return void 0;
    const a1 = TIME.exec(t1);
    const a2 = TIME.exec(t2);
    if (!(a1 && a2))
      return void 0;
    t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
    t2 = a2[1] + a2[2] + a2[3] + (a2[4] || "");
    if (t1 > t2)
      return 1;
    if (t1 < t2)
      return -1;
    return 0;
  }
  const DATE_TIME_SEPARATOR = /t|\s/i;
  function date_time(str) {
    const dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true);
  }
  function compareDateTime(dt1, dt2) {
    if (!(dt1 && dt2))
      return void 0;
    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
    const res = compareDate(d1, d2);
    if (res === void 0)
      return void 0;
    return res || compareTime(t1, t2);
  }
  const NOT_URI_FRAGMENT = /\/|:/;
  const URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function uri2(str) {
    return NOT_URI_FRAGMENT.test(str) && URI.test(str);
  }
  const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function byte(str) {
    BYTE.lastIndex = 0;
    return BYTE.test(str);
  }
  const MIN_INT32 = -(2 ** 31);
  const MAX_INT32 = 2 ** 31 - 1;
  function validateInt32(value) {
    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
  }
  function validateInt64(value) {
    return Number.isInteger(value);
  }
  function validateNumber() {
    return true;
  }
  const Z_ANCHOR = /[^\\]\\Z/;
  function regex(str) {
    if (Z_ANCHOR.test(str))
      return false;
    try {
      new RegExp(str);
      return true;
    } catch (e) {
      return false;
    }
  }
})(formats);
var limit = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.formatLimitDefinition = void 0;
  const ajv_1 = ajvExports;
  const codegen_12 = codegen;
  const ops2 = codegen_12.operators;
  const KWDs2 = {
    formatMaximum: { okStr: "<=", ok: ops2.LTE, fail: ops2.GT },
    formatMinimum: { okStr: ">=", ok: ops2.GTE, fail: ops2.LT },
    formatExclusiveMaximum: { okStr: "<", ok: ops2.LT, fail: ops2.GTE },
    formatExclusiveMinimum: { okStr: ">", ok: ops2.GT, fail: ops2.LTE }
  };
  const error2 = {
    message: ({ keyword: keyword2, schemaCode }) => codegen_12.str`should be ${KWDs2[keyword2].okStr} ${schemaCode}`,
    params: ({ keyword: keyword2, schemaCode }) => codegen_12._`{comparison: ${KWDs2[keyword2].okStr}, limit: ${schemaCode}}`
  };
  exports2.formatLimitDefinition = {
    keyword: Object.keys(KWDs2),
    type: "string",
    schemaType: "string",
    $data: true,
    error: error2,
    code(cxt) {
      const { gen, data, schemaCode, keyword: keyword2, it } = cxt;
      const { opts, self: self2 } = it;
      if (!opts.validateFormats)
        return;
      const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
      if (fCxt.$data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen.scopeValue("formats", {
          ref: self2.formats,
          code: opts.code.formats
        });
        const fmt = gen.const("fmt", codegen_12._`${fmts}[${fCxt.schemaCode}]`);
        cxt.fail$data(codegen_12.or(codegen_12._`typeof ${fmt} != "object"`, codegen_12._`${fmt} instanceof RegExp`, codegen_12._`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
      }
      function validateFormat() {
        const format2 = fCxt.schema;
        const fmtDef = self2.formats[format2];
        if (!fmtDef || fmtDef === true)
          return;
        if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
          throw new Error(`"${keyword2}": format "${format2}" does not define "compare" function`);
        }
        const fmt = gen.scopeValue("formats", {
          key: format2,
          ref: fmtDef,
          code: opts.code.formats ? codegen_12._`${opts.code.formats}${codegen_12.getProperty(format2)}` : void 0
        });
        cxt.fail$data(compareCode(fmt));
      }
      function compareCode(fmt) {
        return codegen_12._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs2[keyword2].fail} 0`;
      }
    },
    dependencies: ["format"]
  };
  const formatLimitPlugin = (ajv2) => {
    ajv2.addKeyword(exports2.formatLimitDefinition);
    return ajv2;
  };
  exports2.default = formatLimitPlugin;
})(limit);
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  const formats_1 = formats;
  const limit_1 = limit;
  const codegen_12 = codegen;
  const fullName = new codegen_12.Name("fullFormats");
  const fastName = new codegen_12.Name("fastFormats");
  const formatsPlugin = (ajv2, opts = { keywords: true }) => {
    if (Array.isArray(opts)) {
      addFormats(ajv2, opts, formats_1.fullFormats, fullName);
      return ajv2;
    }
    const [formats2, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
    const list = opts.formats || formats_1.formatNames;
    addFormats(ajv2, list, formats2, exportName);
    if (opts.keywords)
      limit_1.default(ajv2);
    return ajv2;
  };
  formatsPlugin.get = (name, mode = "full") => {
    const formats2 = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
    const f = formats2[name];
    if (!f)
      throw new Error(`Unknown format "${name}"`);
    return f;
  };
  function addFormats(ajv2, list, fs2, exportName) {
    var _a;
    var _b;
    (_a = (_b = ajv2.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = codegen_12._`require("ajv-formats/dist/formats").${exportName}`;
    for (const f of list)
      ajv2.addFormat(f, fs2[f]);
  }
  module2.exports = exports2 = formatsPlugin;
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.default = formatsPlugin;
})(dist, dist.exports);
var distExports = dist.exports;
const copyProperty = (to, from, property, ignoreNonConfigurable) => {
  if (property === "length" || property === "prototype") {
    return;
  }
  if (property === "arguments" || property === "caller") {
    return;
  }
  const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
  const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
    return;
  }
  Object.defineProperty(to, property, fromDescriptor);
};
const canCopyProperty = function(toDescriptor, fromDescriptor) {
  return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
};
const changePrototype = (to, from) => {
  const fromPrototype = Object.getPrototypeOf(from);
  if (fromPrototype === Object.getPrototypeOf(to)) {
    return;
  }
  Object.setPrototypeOf(to, fromPrototype);
};
const wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
const toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
const toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
const changeToString = (to, from, name) => {
  const withName = name === "" ? "" : `with ${name.trim()}() `;
  const newToString = wrappedToString.bind(null, withName, from.toString());
  Object.defineProperty(newToString, "name", toStringName);
  Object.defineProperty(to, "toString", { ...toStringDescriptor, value: newToString });
};
const mimicFn$4 = (to, from, { ignoreNonConfigurable = false } = {}) => {
  const { name } = to;
  for (const property of Reflect.ownKeys(from)) {
    copyProperty(to, from, property, ignoreNonConfigurable);
  }
  changePrototype(to, from);
  changeToString(to, from, name);
  return to;
};
var mimicFn_1 = mimicFn$4;
const mimicFn$3 = mimicFn_1;
var debounceFn = (inputFunction, options = {}) => {
  if (typeof inputFunction !== "function") {
    throw new TypeError(`Expected the first argument to be a function, got \`${typeof inputFunction}\``);
  }
  const {
    wait = 0,
    before = false,
    after = true
  } = options;
  if (!before && !after) {
    throw new Error("Both `before` and `after` are false, function wouldn't be called.");
  }
  let timeout;
  let result;
  const debouncedFunction = function(...arguments_) {
    const context = this;
    const later = () => {
      timeout = void 0;
      if (after) {
        result = inputFunction.apply(context, arguments_);
      }
    };
    const shouldCallNow = before && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (shouldCallNow) {
      result = inputFunction.apply(context, arguments_);
    }
    return result;
  };
  mimicFn$3(debouncedFunction, inputFunction);
  debouncedFunction.cancel = () => {
    if (timeout) {
      clearTimeout(timeout);
      timeout = void 0;
    }
  };
  return debouncedFunction;
};
var re$2 = { exports: {} };
const SEMVER_SPEC_VERSION = "2.0.0";
const MAX_LENGTH$1 = 256;
const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991;
const MAX_SAFE_COMPONENT_LENGTH = 16;
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH$1 - 6;
const RELEASE_TYPES = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var constants$1 = {
  MAX_LENGTH: MAX_LENGTH$1,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const debug$1 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
};
var debug_1 = debug$1;
(function(module2, exports2) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2,
    MAX_SAFE_BUILD_LENGTH: MAX_SAFE_BUILD_LENGTH2,
    MAX_LENGTH: MAX_LENGTH2
  } = constants$1;
  const debug2 = debug_1;
  exports2 = module2.exports = {};
  const re2 = exports2.re = [];
  const safeRe = exports2.safeRe = [];
  const src = exports2.src = [];
  const t2 = exports2.t = {};
  let R = 0;
  const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  const safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH2],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH2]
  ];
  const makeSafeRegex = (value) => {
    for (const [token, max] of safeRegexReplacements) {
      value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value;
  };
  const createToken = (name, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index = R++;
    debug2(name, index, value);
    t2[name] = index;
    src[index] = value;
    re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NUMERICIDENTIFIER]}|${src[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NUMERICIDENTIFIERLOOSE]}|${src[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`);
  createToken("FULL", `^${src[t2.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`);
  createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:$|[^\\d])`);
  createToken("COERCERTL", src[t2.COERCE], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true);
  exports2.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true);
  exports2.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true);
  exports2.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(re$2, re$2.exports);
var reExports = re$2.exports;
const looseOption = Object.freeze({ loose: true });
const emptyOpts = Object.freeze({});
const parseOptions$1 = (options) => {
  if (!options) {
    return emptyOpts;
  }
  if (typeof options !== "object") {
    return looseOption;
  }
  return options;
};
var parseOptions_1 = parseOptions$1;
const numeric = /^[0-9]+$/;
const compareIdentifiers$1 = (a, b) => {
  const anum = numeric.test(a);
  const bnum = numeric.test(b);
  if (anum && bnum) {
    a = +a;
    b = +b;
  }
  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);
var identifiers$1 = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
const debug = debug_1;
const { MAX_LENGTH, MAX_SAFE_INTEGER } = constants$1;
const { safeRe: re$1, t: t$1 } = reExports;
const parseOptions = parseOptions_1;
const { compareIdentifiers } = identifiers$1;
let SemVer$d = class SemVer {
  constructor(version, options) {
    options = parseOptions(options);
    if (version instanceof SemVer) {
      if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      );
    }
    debug("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    const m = version.trim().match(options.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL]);
    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`);
    }
    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map((id2) => {
        if (/^[0-9]+$/.test(id2)) {
          const num = +id2;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id2;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join(".")}`;
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  }
  comparePre(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    let i = 0;
    do {
      const a = this.prerelease[i];
      const b = other.prerelease[i];
      debug("prerelease compare", i, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    let i = 0;
    do {
      const a = this.build[i];
      const b = other.build[i];
      debug("prerelease compare", i, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(release, identifier, identifierBase) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier, identifierBase);
        this.inc("pre", identifier, identifierBase);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier, identifierBase);
        }
        this.inc("pre", identifier, identifierBase);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre": {
        const base = Number(identifierBase) ? 1 : 0;
        if (!identifier && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (this.prerelease.length === 0) {
          this.prerelease = [base];
        } else {
          let i = this.prerelease.length;
          while (--i >= 0) {
            if (typeof this.prerelease[i] === "number") {
              this.prerelease[i]++;
              i = -2;
            }
          }
          if (i === -1) {
            if (identifier === this.prerelease.join(".") && identifierBase === false) {
              throw new Error("invalid increment argument: identifier already exists");
            }
            this.prerelease.push(base);
          }
        }
        if (identifier) {
          let prerelease2 = [identifier, base];
          if (identifierBase === false) {
            prerelease2 = [identifier];
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease2;
            }
          } else {
            this.prerelease = prerelease2;
          }
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${release}`);
    }
    this.raw = this.format();
    if (this.build.length) {
      this.raw += `+${this.build.join(".")}`;
    }
    return this;
  }
};
var semver$1 = SemVer$d;
const SemVer$c = semver$1;
const parse$6 = (version, options, throwErrors = false) => {
  if (version instanceof SemVer$c) {
    return version;
  }
  try {
    return new SemVer$c(version, options);
  } catch (er) {
    if (!throwErrors) {
      return null;
    }
    throw er;
  }
};
var parse_1 = parse$6;
const parse$5 = parse_1;
const valid$2 = (version, options) => {
  const v = parse$5(version, options);
  return v ? v.version : null;
};
var valid_1 = valid$2;
const parse$4 = parse_1;
const clean$1 = (version, options) => {
  const s = parse$4(version.trim().replace(/^[=v]+/, ""), options);
  return s ? s.version : null;
};
var clean_1 = clean$1;
const SemVer$b = semver$1;
const inc$1 = (version, release, options, identifier, identifierBase) => {
  if (typeof options === "string") {
    identifierBase = identifier;
    identifier = options;
    options = void 0;
  }
  try {
    return new SemVer$b(
      version instanceof SemVer$b ? version.version : version,
      options
    ).inc(release, identifier, identifierBase).version;
  } catch (er) {
    return null;
  }
};
var inc_1 = inc$1;
const parse$3 = parse_1;
const diff$1 = (version1, version2) => {
  const v1 = parse$3(version1, null, true);
  const v2 = parse$3(version2, null, true);
  const comparison = v1.compare(v2);
  if (comparison === 0) {
    return null;
  }
  const v1Higher = comparison > 0;
  const highVersion = v1Higher ? v1 : v2;
  const lowVersion = v1Higher ? v2 : v1;
  const highHasPre = !!highVersion.prerelease.length;
  const lowHasPre = !!lowVersion.prerelease.length;
  if (lowHasPre && !highHasPre) {
    if (!lowVersion.patch && !lowVersion.minor) {
      return "major";
    }
    if (highVersion.patch) {
      return "patch";
    }
    if (highVersion.minor) {
      return "minor";
    }
    return "major";
  }
  const prefix = highHasPre ? "pre" : "";
  if (v1.major !== v2.major) {
    return prefix + "major";
  }
  if (v1.minor !== v2.minor) {
    return prefix + "minor";
  }
  if (v1.patch !== v2.patch) {
    return prefix + "patch";
  }
  return "prerelease";
};
var diff_1 = diff$1;
const SemVer$a = semver$1;
const major$1 = (a, loose) => new SemVer$a(a, loose).major;
var major_1 = major$1;
const SemVer$9 = semver$1;
const minor$1 = (a, loose) => new SemVer$9(a, loose).minor;
var minor_1 = minor$1;
const SemVer$8 = semver$1;
const patch$1 = (a, loose) => new SemVer$8(a, loose).patch;
var patch_1 = patch$1;
const parse$2 = parse_1;
const prerelease$1 = (version, options) => {
  const parsed = parse$2(version, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
var prerelease_1 = prerelease$1;
const SemVer$7 = semver$1;
const compare$b = (a, b, loose) => new SemVer$7(a, loose).compare(new SemVer$7(b, loose));
var compare_1 = compare$b;
const compare$a = compare_1;
const rcompare$1 = (a, b, loose) => compare$a(b, a, loose);
var rcompare_1 = rcompare$1;
const compare$9 = compare_1;
const compareLoose$1 = (a, b) => compare$9(a, b, true);
var compareLoose_1 = compareLoose$1;
const SemVer$6 = semver$1;
const compareBuild$3 = (a, b, loose) => {
  const versionA = new SemVer$6(a, loose);
  const versionB = new SemVer$6(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
var compareBuild_1 = compareBuild$3;
const compareBuild$2 = compareBuild_1;
const sort$1 = (list, loose) => list.sort((a, b) => compareBuild$2(a, b, loose));
var sort_1 = sort$1;
const compareBuild$1 = compareBuild_1;
const rsort$1 = (list, loose) => list.sort((a, b) => compareBuild$1(b, a, loose));
var rsort_1 = rsort$1;
const compare$8 = compare_1;
const gt$4 = (a, b, loose) => compare$8(a, b, loose) > 0;
var gt_1 = gt$4;
const compare$7 = compare_1;
const lt$3 = (a, b, loose) => compare$7(a, b, loose) < 0;
var lt_1 = lt$3;
const compare$6 = compare_1;
const eq$2 = (a, b, loose) => compare$6(a, b, loose) === 0;
var eq_1 = eq$2;
const compare$5 = compare_1;
const neq$2 = (a, b, loose) => compare$5(a, b, loose) !== 0;
var neq_1 = neq$2;
const compare$4 = compare_1;
const gte$3 = (a, b, loose) => compare$4(a, b, loose) >= 0;
var gte_1 = gte$3;
const compare$3 = compare_1;
const lte$3 = (a, b, loose) => compare$3(a, b, loose) <= 0;
var lte_1 = lte$3;
const eq$1 = eq_1;
const neq$1 = neq_1;
const gt$3 = gt_1;
const gte$2 = gte_1;
const lt$2 = lt_1;
const lte$2 = lte_1;
const cmp$1 = (a, op, b, loose) => {
  switch (op) {
    case "===":
      if (typeof a === "object") {
        a = a.version;
      }
      if (typeof b === "object") {
        b = b.version;
      }
      return a === b;
    case "!==":
      if (typeof a === "object") {
        a = a.version;
      }
      if (typeof b === "object") {
        b = b.version;
      }
      return a !== b;
    case "":
    case "=":
    case "==":
      return eq$1(a, b, loose);
    case "!=":
      return neq$1(a, b, loose);
    case ">":
      return gt$3(a, b, loose);
    case ">=":
      return gte$2(a, b, loose);
    case "<":
      return lt$2(a, b, loose);
    case "<=":
      return lte$2(a, b, loose);
    default:
      throw new TypeError(`Invalid operator: ${op}`);
  }
};
var cmp_1 = cmp$1;
const SemVer$5 = semver$1;
const parse$1 = parse_1;
const { safeRe: re, t } = reExports;
const coerce$1 = (version, options) => {
  if (version instanceof SemVer$5) {
    return version;
  }
  if (typeof version === "number") {
    version = String(version);
  }
  if (typeof version !== "string") {
    return null;
  }
  options = options || {};
  let match = null;
  if (!options.rtl) {
    match = version.match(re[t.COERCE]);
  } else {
    let next;
    while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
    }
    re[t.COERCERTL].lastIndex = -1;
  }
  if (match === null) {
    return null;
  }
  return parse$1(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
};
var coerce_1 = coerce$1;
var iterator;
var hasRequiredIterator;
function requireIterator() {
  if (hasRequiredIterator)
    return iterator;
  hasRequiredIterator = 1;
  iterator = function(Yallist2) {
    Yallist2.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head; walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
  return iterator;
}
var yallist = Yallist$1;
Yallist$1.Node = Node;
Yallist$1.create = Yallist$1;
function Yallist$1(list) {
  var self2 = this;
  if (!(self2 instanceof Yallist$1)) {
    self2 = new Yallist$1();
  }
  self2.tail = null;
  self2.head = null;
  self2.length = 0;
  if (list && typeof list.forEach === "function") {
    list.forEach(function(item) {
      self2.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self2.push(arguments[i]);
    }
  }
  return self2;
}
Yallist$1.prototype.removeNode = function(node) {
  if (node.list !== this) {
    throw new Error("removing node which does not belong to this list");
  }
  var next = node.next;
  var prev = node.prev;
  if (next) {
    next.prev = prev;
  }
  if (prev) {
    prev.next = next;
  }
  if (node === this.head) {
    this.head = next;
  }
  if (node === this.tail) {
    this.tail = prev;
  }
  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;
  return next;
};
Yallist$1.prototype.unshiftNode = function(node) {
  if (node === this.head) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var head = this.head;
  node.list = this;
  node.next = head;
  if (head) {
    head.prev = node;
  }
  this.head = node;
  if (!this.tail) {
    this.tail = node;
  }
  this.length++;
};
Yallist$1.prototype.pushNode = function(node) {
  if (node === this.tail) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var tail = this.tail;
  node.list = this;
  node.prev = tail;
  if (tail) {
    tail.next = node;
  }
  this.tail = node;
  if (!this.head) {
    this.head = node;
  }
  this.length++;
};
Yallist$1.prototype.push = function() {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i]);
  }
  return this.length;
};
Yallist$1.prototype.unshift = function() {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i]);
  }
  return this.length;
};
Yallist$1.prototype.pop = function() {
  if (!this.tail) {
    return void 0;
  }
  var res = this.tail.value;
  this.tail = this.tail.prev;
  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.shift = function() {
  if (!this.head) {
    return void 0;
  }
  var res = this.head.value;
  this.head = this.head.next;
  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.forEach = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.next;
  }
};
Yallist$1.prototype.forEachReverse = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.prev;
  }
};
Yallist$1.prototype.get = function(n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    walker = walker.next;
  }
  if (i === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.getReverse = function(n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    walker = walker.prev;
  }
  if (i === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.map = function(fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.head; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }
  return res;
};
Yallist$1.prototype.mapReverse = function(fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.tail; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }
  return res;
};
Yallist$1.prototype.reduce = function(fn, initial) {
  var acc;
  var walker = this.head;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i);
    walker = walker.next;
  }
  return acc;
};
Yallist$1.prototype.reduceReverse = function(fn, initial) {
  var acc;
  var walker = this.tail;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i);
    walker = walker.prev;
  }
  return acc;
};
Yallist$1.prototype.toArray = function() {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.next;
  }
  return arr;
};
Yallist$1.prototype.toArrayReverse = function() {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.prev;
  }
  return arr;
};
Yallist$1.prototype.slice = function(from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next;
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.sliceReverse = function(from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev;
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.splice = function(start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1;
  }
  if (start < 0) {
    start = this.length + start;
  }
  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next;
  }
  var ret = [];
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }
  if (walker === null) {
    walker = this.tail;
  }
  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }
  for (var i = 0; i < nodes.length; i++) {
    walker = insert(this, walker, nodes[i]);
  }
  return ret;
};
Yallist$1.prototype.reverse = function() {
  var head = this.head;
  var tail = this.tail;
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }
  this.head = tail;
  this.tail = head;
  return this;
};
function insert(self2, node, value) {
  var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
  if (inserted.next === null) {
    self2.tail = inserted;
  }
  if (inserted.prev === null) {
    self2.head = inserted;
  }
  self2.length++;
  return inserted;
}
function push(self2, item) {
  self2.tail = new Node(item, self2.tail, null, self2);
  if (!self2.head) {
    self2.head = self2.tail;
  }
  self2.length++;
}
function unshift(self2, item) {
  self2.head = new Node(item, null, self2.head, self2);
  if (!self2.tail) {
    self2.tail = self2.head;
  }
  self2.length++;
}
function Node(value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list);
  }
  this.list = list;
  this.value = value;
  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }
  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}
try {
  requireIterator()(Yallist$1);
} catch (er) {
}
const Yallist = yallist;
const MAX = Symbol("max");
const LENGTH = Symbol("length");
const LENGTH_CALCULATOR = Symbol("lengthCalculator");
const ALLOW_STALE = Symbol("allowStale");
const MAX_AGE = Symbol("maxAge");
const DISPOSE = Symbol("dispose");
const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
const LRU_LIST = Symbol("lruList");
const CACHE = Symbol("cache");
const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
const naiveLength = () => 1;
class LRUCache {
  constructor(options) {
    if (typeof options === "number")
      options = { max: options };
    if (!options)
      options = {};
    if (options.max && (typeof options.max !== "number" || options.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[MAX] = options.max || Infinity;
    const lc = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  }
  // resize the cache when the max changes.
  set max(mL) {
    if (typeof mL !== "number" || mL < 0)
      throw new TypeError("max must be a non-negative number");
    this[MAX] = mL || Infinity;
    trim(this);
  }
  get max() {
    return this[MAX];
  }
  set allowStale(allowStale) {
    this[ALLOW_STALE] = !!allowStale;
  }
  get allowStale() {
    return this[ALLOW_STALE];
  }
  set maxAge(mA) {
    if (typeof mA !== "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[MAX_AGE] = mA;
    trim(this);
  }
  get maxAge() {
    return this[MAX_AGE];
  }
  // resize the cache when the lengthCalculator changes.
  set lengthCalculator(lC) {
    if (typeof lC !== "function")
      lC = naiveLength;
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC;
      this[LENGTH] = 0;
      this[LRU_LIST].forEach((hit) => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
        this[LENGTH] += hit.length;
      });
    }
    trim(this);
  }
  get lengthCalculator() {
    return this[LENGTH_CALCULATOR];
  }
  get length() {
    return this[LENGTH];
  }
  get itemCount() {
    return this[LRU_LIST].length;
  }
  rforEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].tail; walker !== null; ) {
      const prev = walker.prev;
      forEachStep(this, fn, walker, thisp);
      walker = prev;
    }
  }
  forEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].head; walker !== null; ) {
      const next = walker.next;
      forEachStep(this, fn, walker, thisp);
      walker = next;
    }
  }
  keys() {
    return this[LRU_LIST].toArray().map((k) => k.key);
  }
  values() {
    return this[LRU_LIST].toArray().map((k) => k.value);
  }
  reset() {
    if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
      this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
    }
    this[CACHE] = /* @__PURE__ */ new Map();
    this[LRU_LIST] = new Yallist();
    this[LENGTH] = 0;
  }
  dump() {
    return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
      k: hit.key,
      v: hit.value,
      e: hit.now + (hit.maxAge || 0)
    }).toArray().filter((h) => h);
  }
  dumpLru() {
    return this[LRU_LIST];
  }
  set(key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE];
    if (maxAge && typeof maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    const now = maxAge ? Date.now() : 0;
    const len = this[LENGTH_CALCULATOR](value, key);
    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key));
        return false;
      }
      const node = this[CACHE].get(key);
      const item = node.value;
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value);
      }
      item.now = now;
      item.maxAge = maxAge;
      item.value = value;
      this[LENGTH] += len - item.length;
      item.length = len;
      this.get(key);
      trim(this);
      return true;
    }
    const hit = new Entry(key, value, len, now, maxAge);
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value);
      return false;
    }
    this[LENGTH] += hit.length;
    this[LRU_LIST].unshift(hit);
    this[CACHE].set(key, this[LRU_LIST].head);
    trim(this);
    return true;
  }
  has(key) {
    if (!this[CACHE].has(key))
      return false;
    const hit = this[CACHE].get(key).value;
    return !isStale(this, hit);
  }
  get(key) {
    return get(this, key, true);
  }
  peek(key) {
    return get(this, key, false);
  }
  pop() {
    const node = this[LRU_LIST].tail;
    if (!node)
      return null;
    del(this, node);
    return node.value;
  }
  del(key) {
    del(this, this[CACHE].get(key));
  }
  load(arr) {
    this.reset();
    const now = Date.now();
    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l];
      const expiresAt = hit.e || 0;
      if (expiresAt === 0)
        this.set(hit.k, hit.v);
      else {
        const maxAge = expiresAt - now;
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge);
        }
      }
    }
  }
  prune() {
    this[CACHE].forEach((value, key) => get(this, key, false));
  }
}
const get = (self2, key, doUse) => {
  const node = self2[CACHE].get(key);
  if (node) {
    const hit = node.value;
    if (isStale(self2, hit)) {
      del(self2, node);
      if (!self2[ALLOW_STALE])
        return void 0;
    } else {
      if (doUse) {
        if (self2[UPDATE_AGE_ON_GET])
          node.value.now = Date.now();
        self2[LRU_LIST].unshiftNode(node);
      }
    }
    return hit.value;
  }
};
const isStale = (self2, hit) => {
  if (!hit || !hit.maxAge && !self2[MAX_AGE])
    return false;
  const diff2 = Date.now() - hit.now;
  return hit.maxAge ? diff2 > hit.maxAge : self2[MAX_AGE] && diff2 > self2[MAX_AGE];
};
const trim = (self2) => {
  if (self2[LENGTH] > self2[MAX]) {
    for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
      const prev = walker.prev;
      del(self2, walker);
      walker = prev;
    }
  }
};
const del = (self2, node) => {
  if (node) {
    const hit = node.value;
    if (self2[DISPOSE])
      self2[DISPOSE](hit.key, hit.value);
    self2[LENGTH] -= hit.length;
    self2[CACHE].delete(hit.key);
    self2[LRU_LIST].removeNode(node);
  }
};
class Entry {
  constructor(key, value, length, now, maxAge) {
    this.key = key;
    this.value = value;
    this.length = length;
    this.now = now;
    this.maxAge = maxAge || 0;
  }
}
const forEachStep = (self2, fn, node, thisp) => {
  let hit = node.value;
  if (isStale(self2, hit)) {
    del(self2, node);
    if (!self2[ALLOW_STALE])
      hit = void 0;
  }
  if (hit)
    fn.call(thisp, hit.value, hit.key, self2);
};
var lruCache = LRUCache;
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange)
    return range;
  hasRequiredRange = 1;
  class Range2 {
    constructor(range2, options) {
      options = parseOptions2(options);
      if (range2 instanceof Range2) {
        if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
          return range2;
        } else {
          return new Range2(range2.raw, options);
        }
      }
      if (range2 instanceof Comparator2) {
        this.raw = range2.value;
        this.set = [[range2]];
        this.format();
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range2.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.format();
    }
    format() {
      this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range2) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range2;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re2[t2.HYPHENRANGELOOSE] : re2[t2.HYPHENRANGE];
      range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug2("hyphen replace", range2);
      range2 = range2.replace(re2[t2.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range2);
      range2 = range2.replace(re2[t2.TILDETRIM], tildeTrimReplace);
      debug2("tilde trim", range2);
      range2 = range2.replace(re2[t2.CARETTRIM], caretTrimReplace);
      debug2("caret trim", range2);
      let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug2("loose invalid filter", comp, this.options);
          return !!comp.match(re2[t2.COMPARATORLOOSE]);
        });
      }
      debug2("range list", rangeList);
      const rangeMap = /* @__PURE__ */ new Map();
      const comparators = rangeList.map((comp) => new Comparator2(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range2, options) {
      if (!(range2 instanceof Range2)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer3(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range = Range2;
  const LRU = lruCache;
  const cache = new LRU({ max: 1e3 });
  const parseOptions2 = parseOptions_1;
  const Comparator2 = requireComparator();
  const debug2 = debug_1;
  const SemVer3 = semver$1;
  const {
    safeRe: re2,
    t: t2,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = reExports;
  const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = constants$1;
  const isNullSet = (c) => c.value === "<0.0.0-0";
  const isAny = (c) => c.value === "";
  const isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  const parseComparator = (comp, options) => {
    debug2("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug2("caret", comp);
    comp = replaceTildes(comp, options);
    debug2("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug2("xrange", comp);
    comp = replaceStars(comp, options);
    debug2("stars", comp);
    return comp;
  };
  const isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
  const replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
  };
  const replaceTilde = (comp, options) => {
    const r = options.loose ? re2[t2.TILDELOOSE] : re2[t2.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug2("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug2("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug2("tilde return", ret);
      return ret;
    });
  };
  const replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
  };
  const replaceCaret = (comp, options) => {
    debug2("caret", comp, options);
    const r = options.loose ? re2[t2.CARETLOOSE] : re2[t2.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug2("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug2("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug2("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug2("caret return", ret);
      return ret;
    });
  };
  const replaceXRanges = (comp, options) => {
    debug2("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
  };
  const replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re2[t2.XRANGELOOSE] : re2[t2.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug2("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug2("xRange return", ret);
      return ret;
    });
  };
  const replaceStars = (comp, options) => {
    debug2("replaceStars", comp, options);
    return comp.trim().replace(re2[t2.STAR], "");
  };
  const replaceGTE0 = (comp, options) => {
    debug2("replaceGTE0", comp, options);
    return comp.trim().replace(re2[options.includePrerelease ? t2.GTE0PRE : t2.GTE0], "");
  };
  const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  const testSet = (set, version, options) => {
    for (let i = 0; i < set.length; i++) {
      if (!set[i].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (let i = 0; i < set.length; i++) {
        debug2(set[i].semver);
        if (set[i].semver === Comparator2.ANY) {
          continue;
        }
        if (set[i].semver.prerelease.length > 0) {
          const allowed = set[i].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range;
}
var comparator;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator)
    return comparator;
  hasRequiredComparator = 1;
  const ANY2 = Symbol("SemVer ANY");
  class Comparator2 {
    static get ANY() {
      return ANY2;
    }
    constructor(comp, options) {
      options = parseOptions2(options);
      if (comp instanceof Comparator2) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug2("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY2) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re2[t2.COMPARATORLOOSE] : re2[t2.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY2;
      } else {
        this.semver = new SemVer3(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version) {
      debug2("Comparator.test", version, this.options.loose);
      if (this.semver === ANY2 || version === ANY2) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer3(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp2(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator2)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range2(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range2(this.value, options).test(comp.semver);
      }
      options = parseOptions2(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp2(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp2(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  comparator = Comparator2;
  const parseOptions2 = parseOptions_1;
  const { safeRe: re2, t: t2 } = reExports;
  const cmp2 = cmp_1;
  const debug2 = debug_1;
  const SemVer3 = semver$1;
  const Range2 = requireRange();
  return comparator;
}
const Range$9 = requireRange();
const satisfies$4 = (version, range2, options) => {
  try {
    range2 = new Range$9(range2, options);
  } catch (er) {
    return false;
  }
  return range2.test(version);
};
var satisfies_1 = satisfies$4;
const Range$8 = requireRange();
const toComparators$1 = (range2, options) => new Range$8(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
var toComparators_1 = toComparators$1;
const SemVer$4 = semver$1;
const Range$7 = requireRange();
const maxSatisfying$1 = (versions, range2, options) => {
  let max = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$7(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!max || maxSV.compare(v) === -1) {
        max = v;
        maxSV = new SemVer$4(max, options);
      }
    }
  });
  return max;
};
var maxSatisfying_1 = maxSatisfying$1;
const SemVer$3 = semver$1;
const Range$6 = requireRange();
const minSatisfying$1 = (versions, range2, options) => {
  let min = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$6(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!min || minSV.compare(v) === 1) {
        min = v;
        minSV = new SemVer$3(min, options);
      }
    }
  });
  return min;
};
var minSatisfying_1 = minSatisfying$1;
const SemVer$2 = semver$1;
const Range$5 = requireRange();
const gt$2 = gt_1;
const minVersion$1 = (range2, loose) => {
  range2 = new Range$5(range2, loose);
  let minver = new SemVer$2("0.0.0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = new SemVer$2("0.0.0-0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = null;
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let setMin = null;
    comparators.forEach((comparator2) => {
      const compver = new SemVer$2(comparator2.semver.version);
      switch (comparator2.operator) {
        case ">":
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
        case "":
        case ">=":
          if (!setMin || gt$2(compver, setMin)) {
            setMin = compver;
          }
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${comparator2.operator}`);
      }
    });
    if (setMin && (!minver || gt$2(minver, setMin))) {
      minver = setMin;
    }
  }
  if (minver && range2.test(minver)) {
    return minver;
  }
  return null;
};
var minVersion_1 = minVersion$1;
const Range$4 = requireRange();
const validRange$1 = (range2, options) => {
  try {
    return new Range$4(range2, options).range || "*";
  } catch (er) {
    return null;
  }
};
var valid$1 = validRange$1;
const SemVer$1 = semver$1;
const Comparator$2 = requireComparator();
const { ANY: ANY$1 } = Comparator$2;
const Range$3 = requireRange();
const satisfies$3 = satisfies_1;
const gt$1 = gt_1;
const lt$1 = lt_1;
const lte$1 = lte_1;
const gte$1 = gte_1;
const outside$3 = (version, range2, hilo, options) => {
  version = new SemVer$1(version, options);
  range2 = new Range$3(range2, options);
  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case ">":
      gtfn = gt$1;
      ltefn = lte$1;
      ltfn = lt$1;
      comp = ">";
      ecomp = ">=";
      break;
    case "<":
      gtfn = lt$1;
      ltefn = gte$1;
      ltfn = gt$1;
      comp = "<";
      ecomp = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (satisfies$3(version, range2, options)) {
    return false;
  }
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let high = null;
    let low = null;
    comparators.forEach((comparator2) => {
      if (comparator2.semver === ANY$1) {
        comparator2 = new Comparator$2(">=0.0.0");
      }
      high = high || comparator2;
      low = low || comparator2;
      if (gtfn(comparator2.semver, high.semver, options)) {
        high = comparator2;
      } else if (ltfn(comparator2.semver, low.semver, options)) {
        low = comparator2;
      }
    });
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }
    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }
  return true;
};
var outside_1 = outside$3;
const outside$2 = outside_1;
const gtr$1 = (version, range2, options) => outside$2(version, range2, ">", options);
var gtr_1 = gtr$1;
const outside$1 = outside_1;
const ltr$1 = (version, range2, options) => outside$1(version, range2, "<", options);
var ltr_1 = ltr$1;
const Range$2 = requireRange();
const intersects$1 = (r1, r2, options) => {
  r1 = new Range$2(r1, options);
  r2 = new Range$2(r2, options);
  return r1.intersects(r2, options);
};
var intersects_1 = intersects$1;
const satisfies$2 = satisfies_1;
const compare$2 = compare_1;
var simplify = (versions, range2, options) => {
  const set = [];
  let first = null;
  let prev = null;
  const v = versions.sort((a, b) => compare$2(a, b, options));
  for (const version of v) {
    const included = satisfies$2(version, range2, options);
    if (included) {
      prev = version;
      if (!first) {
        first = version;
      }
    } else {
      if (prev) {
        set.push([first, prev]);
      }
      prev = null;
      first = null;
    }
  }
  if (first) {
    set.push([first, null]);
  }
  const ranges = [];
  for (const [min, max] of set) {
    if (min === max) {
      ranges.push(min);
    } else if (!max && min === v[0]) {
      ranges.push("*");
    } else if (!max) {
      ranges.push(`>=${min}`);
    } else if (min === v[0]) {
      ranges.push(`<=${max}`);
    } else {
      ranges.push(`${min} - ${max}`);
    }
  }
  const simplified = ranges.join(" || ");
  const original = typeof range2.raw === "string" ? range2.raw : String(range2);
  return simplified.length < original.length ? simplified : range2;
};
const Range$1 = requireRange();
const Comparator$1 = requireComparator();
const { ANY } = Comparator$1;
const satisfies$1 = satisfies_1;
const compare$1 = compare_1;
const subset$1 = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true;
  }
  sub = new Range$1(sub, options);
  dom = new Range$1(dom, options);
  let sawNonNull = false;
  OUTER:
    for (const simpleSub of sub.set) {
      for (const simpleDom of dom.set) {
        const isSub = simpleSubset(simpleSub, simpleDom, options);
        sawNonNull = sawNonNull || isSub !== null;
        if (isSub) {
          continue OUTER;
        }
      }
      if (sawNonNull) {
        return false;
      }
    }
  return true;
};
const minimumVersionWithPreRelease = [new Comparator$1(">=0.0.0-0")];
const minimumVersion = [new Comparator$1(">=0.0.0")];
const simpleSubset = (sub, dom, options) => {
  if (sub === dom) {
    return true;
  }
  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true;
    } else if (options.includePrerelease) {
      sub = minimumVersionWithPreRelease;
    } else {
      sub = minimumVersion;
    }
  }
  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true;
    } else {
      dom = minimumVersion;
    }
  }
  const eqSet = /* @__PURE__ */ new Set();
  let gt2, lt2;
  for (const c of sub) {
    if (c.operator === ">" || c.operator === ">=") {
      gt2 = higherGT(gt2, c, options);
    } else if (c.operator === "<" || c.operator === "<=") {
      lt2 = lowerLT(lt2, c, options);
    } else {
      eqSet.add(c.semver);
    }
  }
  if (eqSet.size > 1) {
    return null;
  }
  let gtltComp;
  if (gt2 && lt2) {
    gtltComp = compare$1(gt2.semver, lt2.semver, options);
    if (gtltComp > 0) {
      return null;
    } else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<=")) {
      return null;
    }
  }
  for (const eq2 of eqSet) {
    if (gt2 && !satisfies$1(eq2, String(gt2), options)) {
      return null;
    }
    if (lt2 && !satisfies$1(eq2, String(lt2), options)) {
      return null;
    }
    for (const c of dom) {
      if (!satisfies$1(eq2, String(c), options)) {
        return false;
      }
    }
    return true;
  }
  let higher, lower;
  let hasDomLT, hasDomGT;
  let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
  let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }
  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
    hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
    if (gt2) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false;
        }
      }
      if (c.operator === ">" || c.operator === ">=") {
        higher = higherGT(gt2, c, options);
        if (higher === c && higher !== gt2) {
          return false;
        }
      } else if (gt2.operator === ">=" && !satisfies$1(gt2.semver, String(c), options)) {
        return false;
      }
    }
    if (lt2) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false;
        }
      }
      if (c.operator === "<" || c.operator === "<=") {
        lower = lowerLT(lt2, c, options);
        if (lower === c && lower !== lt2) {
          return false;
        }
      } else if (lt2.operator === "<=" && !satisfies$1(lt2.semver, String(c), options)) {
        return false;
      }
    }
    if (!c.operator && (lt2 || gt2) && gtltComp !== 0) {
      return false;
    }
  }
  if (gt2 && hasDomLT && !lt2 && gtltComp !== 0) {
    return false;
  }
  if (lt2 && hasDomGT && !gt2 && gtltComp !== 0) {
    return false;
  }
  if (needDomGTPre || needDomLTPre) {
    return false;
  }
  return true;
};
const higherGT = (a, b, options) => {
  if (!a) {
    return b;
  }
  const comp = compare$1(a.semver, b.semver, options);
  return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
};
const lowerLT = (a, b, options) => {
  if (!a) {
    return b;
  }
  const comp = compare$1(a.semver, b.semver, options);
  return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
};
var subset_1 = subset$1;
const internalRe = reExports;
const constants = constants$1;
const SemVer2 = semver$1;
const identifiers = identifiers$1;
const parse = parse_1;
const valid = valid_1;
const clean = clean_1;
const inc = inc_1;
const diff = diff_1;
const major = major_1;
const minor = minor_1;
const patch = patch_1;
const prerelease = prerelease_1;
const compare = compare_1;
const rcompare = rcompare_1;
const compareLoose = compareLoose_1;
const compareBuild = compareBuild_1;
const sort = sort_1;
const rsort = rsort_1;
const gt = gt_1;
const lt = lt_1;
const eq = eq_1;
const neq = neq_1;
const gte = gte_1;
const lte = lte_1;
const cmp = cmp_1;
const coerce = coerce_1;
const Comparator = requireComparator();
const Range = requireRange();
const satisfies = satisfies_1;
const toComparators = toComparators_1;
const maxSatisfying = maxSatisfying_1;
const minSatisfying = minSatisfying_1;
const minVersion = minVersion_1;
const validRange = valid$1;
const outside = outside_1;
const gtr = gtr_1;
const ltr = ltr_1;
const intersects = intersects_1;
const simplifyRange = simplify;
const subset = subset_1;
var semver = {
  parse,
  valid,
  clean,
  inc,
  diff,
  major,
  minor,
  patch,
  prerelease,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer: SemVer2,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers
};
var onetime$1 = { exports: {} };
var mimicFn$2 = { exports: {} };
const mimicFn$1 = (to, from) => {
  for (const prop of Reflect.ownKeys(from)) {
    Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
  }
  return to;
};
mimicFn$2.exports = mimicFn$1;
mimicFn$2.exports.default = mimicFn$1;
var mimicFnExports = mimicFn$2.exports;
const mimicFn = mimicFnExports;
const calledFunctions = /* @__PURE__ */ new WeakMap();
const onetime = (function_, options = {}) => {
  if (typeof function_ !== "function") {
    throw new TypeError("Expected a function");
  }
  let returnValue;
  let callCount = 0;
  const functionName = function_.displayName || function_.name || "<anonymous>";
  const onetime2 = function(...arguments_) {
    calledFunctions.set(onetime2, ++callCount);
    if (callCount === 1) {
      returnValue = function_.apply(this, arguments_);
      function_ = null;
    } else if (options.throw === true) {
      throw new Error(`Function \`${functionName}\` can only be called once`);
    }
    return returnValue;
  };
  mimicFn(onetime2, function_);
  calledFunctions.set(onetime2, callCount);
  return onetime2;
};
onetime$1.exports = onetime;
onetime$1.exports.default = onetime;
onetime$1.exports.callCount = (function_) => {
  if (!calledFunctions.has(function_)) {
    throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
  }
  return calledFunctions.get(function_);
};
var onetimeExports = onetime$1.exports;
(function(module2, exports2) {
  var __classPrivateFieldSet = commonjsGlobal && commonjsGlobal.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = commonjsGlobal && commonjsGlobal.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _a, _b;
  var _Conf_validator, _Conf_encryptionKey, _Conf_options, _Conf_defaultValues;
  Object.defineProperty(exports2, "__esModule", { value: true });
  const util_12 = require$$4;
  const fs2 = require$$0$3;
  const path2 = require$$1;
  const crypto = require$$3$1;
  const assert = require$$5;
  const events_1 = require$$5$1;
  const dotProp$1 = dotProp;
  const pkgUp2 = pkgUpExports;
  const envPaths2 = envPathsExports;
  const atomically = dist$1;
  const ajv_1 = ajvExports;
  const ajv_formats_1 = distExports;
  const debounceFn$1 = debounceFn;
  const semver$12 = semver;
  const onetime2 = onetimeExports;
  const encryptionAlgorithm = "aes-256-cbc";
  const createPlainObject = () => {
    return /* @__PURE__ */ Object.create(null);
  };
  const isExist = (data) => {
    return data !== void 0 && data !== null;
  };
  let parentDir = "";
  try {
    delete require.cache[__filename];
    parentDir = path2.dirname((_b = (_a = module2.parent) === null || _a === void 0 ? void 0 : _a.filename) !== null && _b !== void 0 ? _b : ".");
  } catch (_c) {
  }
  const checkValueType = (key, value) => {
    const nonJsonTypes = /* @__PURE__ */ new Set([
      "undefined",
      "symbol",
      "function"
    ]);
    const type2 = typeof value;
    if (nonJsonTypes.has(type2)) {
      throw new TypeError(`Setting a value of type \`${type2}\` for key \`${key}\` is not allowed as it's not supported by JSON`);
    }
  };
  const INTERNAL_KEY = "__internal__";
  const MIGRATION_KEY = `${INTERNAL_KEY}.migrations.version`;
  class Conf2 {
    constructor(partialOptions = {}) {
      var _a2;
      _Conf_validator.set(this, void 0);
      _Conf_encryptionKey.set(this, void 0);
      _Conf_options.set(this, void 0);
      _Conf_defaultValues.set(this, {});
      this._deserialize = (value) => JSON.parse(value);
      this._serialize = (value) => JSON.stringify(value, void 0, "	");
      const options = {
        configName: "config",
        fileExtension: "json",
        projectSuffix: "nodejs",
        clearInvalidConfig: false,
        accessPropertiesByDotNotation: true,
        configFileMode: 438,
        ...partialOptions
      };
      const getPackageData = onetime2(() => {
        const packagePath = pkgUp2.sync({ cwd: parentDir });
        const packageData = packagePath && JSON.parse(fs2.readFileSync(packagePath, "utf8"));
        return packageData !== null && packageData !== void 0 ? packageData : {};
      });
      if (!options.cwd) {
        if (!options.projectName) {
          options.projectName = getPackageData().name;
        }
        if (!options.projectName) {
          throw new Error("Project name could not be inferred. Please specify the `projectName` option.");
        }
        options.cwd = envPaths2(options.projectName, { suffix: options.projectSuffix }).config;
      }
      __classPrivateFieldSet(this, _Conf_options, options, "f");
      if (options.schema) {
        if (typeof options.schema !== "object") {
          throw new TypeError("The `schema` option must be an object.");
        }
        const ajv2 = new ajv_1.default({
          allErrors: true,
          useDefaults: true
        });
        (0, ajv_formats_1.default)(ajv2);
        const schema2 = {
          type: "object",
          properties: options.schema
        };
        __classPrivateFieldSet(this, _Conf_validator, ajv2.compile(schema2), "f");
        for (const [key, value] of Object.entries(options.schema)) {
          if (value === null || value === void 0 ? void 0 : value.default) {
            __classPrivateFieldGet(this, _Conf_defaultValues, "f")[key] = value.default;
          }
        }
      }
      if (options.defaults) {
        __classPrivateFieldSet(this, _Conf_defaultValues, {
          ...__classPrivateFieldGet(this, _Conf_defaultValues, "f"),
          ...options.defaults
        }, "f");
      }
      if (options.serialize) {
        this._serialize = options.serialize;
      }
      if (options.deserialize) {
        this._deserialize = options.deserialize;
      }
      this.events = new events_1.EventEmitter();
      __classPrivateFieldSet(this, _Conf_encryptionKey, options.encryptionKey, "f");
      const fileExtension = options.fileExtension ? `.${options.fileExtension}` : "";
      this.path = path2.resolve(options.cwd, `${(_a2 = options.configName) !== null && _a2 !== void 0 ? _a2 : "config"}${fileExtension}`);
      const fileStore = this.store;
      const store2 = Object.assign(createPlainObject(), options.defaults, fileStore);
      this._validate(store2);
      try {
        assert.deepEqual(fileStore, store2);
      } catch (_b2) {
        this.store = store2;
      }
      if (options.watch) {
        this._watch();
      }
      if (options.migrations) {
        if (!options.projectVersion) {
          options.projectVersion = getPackageData().version;
        }
        if (!options.projectVersion) {
          throw new Error("Project version could not be inferred. Please specify the `projectVersion` option.");
        }
        this._migrate(options.migrations, options.projectVersion, options.beforeEachMigration);
      }
    }
    get(key, defaultValue) {
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        return this._get(key, defaultValue);
      }
      const { store: store2 } = this;
      return key in store2 ? store2[key] : defaultValue;
    }
    set(key, value) {
      if (typeof key !== "string" && typeof key !== "object") {
        throw new TypeError(`Expected \`key\` to be of type \`string\` or \`object\`, got ${typeof key}`);
      }
      if (typeof key !== "object" && value === void 0) {
        throw new TypeError("Use `delete()` to clear values");
      }
      if (this._containsReservedKey(key)) {
        throw new TypeError(`Please don't use the ${INTERNAL_KEY} key, as it's used to manage this module internal operations.`);
      }
      const { store: store2 } = this;
      const set = (key2, value2) => {
        checkValueType(key2, value2);
        if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
          dotProp$1.set(store2, key2, value2);
        } else {
          store2[key2] = value2;
        }
      };
      if (typeof key === "object") {
        const object = key;
        for (const [key2, value2] of Object.entries(object)) {
          set(key2, value2);
        }
      } else {
        set(key, value);
      }
      this.store = store2;
    }
    /**
    	    Check if an item exists.
    
    	    @param key - The key of the item to check.
    	    */
    has(key) {
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        return dotProp$1.has(this.store, key);
      }
      return key in this.store;
    }
    /**
    	    Reset items to their default values, as defined by the `defaults` or `schema` option.
    
    	    @see `clear()` to reset all items.
    
    	    @param keys - The keys of the items to reset.
    	    */
    reset(...keys) {
      for (const key of keys) {
        if (isExist(__classPrivateFieldGet(this, _Conf_defaultValues, "f")[key])) {
          this.set(key, __classPrivateFieldGet(this, _Conf_defaultValues, "f")[key]);
        }
      }
    }
    /**
    	    Delete an item.
    
    	    @param key - The key of the item to delete.
    	    */
    delete(key) {
      const { store: store2 } = this;
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        dotProp$1.delete(store2, key);
      } else {
        delete store2[key];
      }
      this.store = store2;
    }
    /**
    	    Delete all items.
    
    	    This resets known items to their default values, if defined by the `defaults` or `schema` option.
    	    */
    clear() {
      this.store = createPlainObject();
      for (const key of Object.keys(__classPrivateFieldGet(this, _Conf_defaultValues, "f"))) {
        this.reset(key);
      }
    }
    /**
    	    Watches the given `key`, calling `callback` on any changes.
    
    	    @param key - The key wo watch.
    	    @param callback - A callback function that is called on any changes. When a `key` is first set `oldValue` will be `undefined`, and when a key is deleted `newValue` will be `undefined`.
    	    @returns A function, that when called, will unsubscribe.
    	    */
    onDidChange(key, callback) {
      if (typeof key !== "string") {
        throw new TypeError(`Expected \`key\` to be of type \`string\`, got ${typeof key}`);
      }
      if (typeof callback !== "function") {
        throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof callback}`);
      }
      return this._handleChange(() => this.get(key), callback);
    }
    /**
    	    Watches the whole config object, calling `callback` on any changes.
    
    	    @param callback - A callback function that is called on any changes. When a `key` is first set `oldValue` will be `undefined`, and when a key is deleted `newValue` will be `undefined`.
    	    @returns A function, that when called, will unsubscribe.
    	    */
    onDidAnyChange(callback) {
      if (typeof callback !== "function") {
        throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof callback}`);
      }
      return this._handleChange(() => this.store, callback);
    }
    get size() {
      return Object.keys(this.store).length;
    }
    get store() {
      try {
        const data = fs2.readFileSync(this.path, __classPrivateFieldGet(this, _Conf_encryptionKey, "f") ? null : "utf8");
        const dataString = this._encryptData(data);
        const deserializedData = this._deserialize(dataString);
        this._validate(deserializedData);
        return Object.assign(createPlainObject(), deserializedData);
      } catch (error2) {
        if ((error2 === null || error2 === void 0 ? void 0 : error2.code) === "ENOENT") {
          this._ensureDirectory();
          return createPlainObject();
        }
        if (__classPrivateFieldGet(this, _Conf_options, "f").clearInvalidConfig && error2.name === "SyntaxError") {
          return createPlainObject();
        }
        throw error2;
      }
    }
    set store(value) {
      this._ensureDirectory();
      this._validate(value);
      this._write(value);
      this.events.emit("change");
    }
    *[(_Conf_validator = /* @__PURE__ */ new WeakMap(), _Conf_encryptionKey = /* @__PURE__ */ new WeakMap(), _Conf_options = /* @__PURE__ */ new WeakMap(), _Conf_defaultValues = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
      for (const [key, value] of Object.entries(this.store)) {
        yield [key, value];
      }
    }
    _encryptData(data) {
      if (!__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
        return data.toString();
      }
      try {
        if (__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
          try {
            if (data.slice(16, 17).toString() === ":") {
              const initializationVector = data.slice(0, 16);
              const password = crypto.pbkdf2Sync(__classPrivateFieldGet(this, _Conf_encryptionKey, "f"), initializationVector.toString(), 1e4, 32, "sha512");
              const decipher = crypto.createDecipheriv(encryptionAlgorithm, password, initializationVector);
              data = Buffer.concat([decipher.update(Buffer.from(data.slice(17))), decipher.final()]).toString("utf8");
            } else {
              const decipher = crypto.createDecipher(encryptionAlgorithm, __classPrivateFieldGet(this, _Conf_encryptionKey, "f"));
              data = Buffer.concat([decipher.update(Buffer.from(data)), decipher.final()]).toString("utf8");
            }
          } catch (_a2) {
          }
        }
      } catch (_b2) {
      }
      return data.toString();
    }
    _handleChange(getter, callback) {
      let currentValue = getter();
      const onChange = () => {
        const oldValue = currentValue;
        const newValue = getter();
        if ((0, util_12.isDeepStrictEqual)(newValue, oldValue)) {
          return;
        }
        currentValue = newValue;
        callback.call(this, newValue, oldValue);
      };
      this.events.on("change", onChange);
      return () => this.events.removeListener("change", onChange);
    }
    _validate(data) {
      if (!__classPrivateFieldGet(this, _Conf_validator, "f")) {
        return;
      }
      const valid2 = __classPrivateFieldGet(this, _Conf_validator, "f").call(this, data);
      if (valid2 || !__classPrivateFieldGet(this, _Conf_validator, "f").errors) {
        return;
      }
      const errors2 = __classPrivateFieldGet(this, _Conf_validator, "f").errors.map(({ instancePath, message = "" }) => `\`${instancePath.slice(1)}\` ${message}`);
      throw new Error("Config schema violation: " + errors2.join("; "));
    }
    _ensureDirectory() {
      fs2.mkdirSync(path2.dirname(this.path), { recursive: true });
    }
    _write(value) {
      let data = this._serialize(value);
      if (__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
        const initializationVector = crypto.randomBytes(16);
        const password = crypto.pbkdf2Sync(__classPrivateFieldGet(this, _Conf_encryptionKey, "f"), initializationVector.toString(), 1e4, 32, "sha512");
        const cipher = crypto.createCipheriv(encryptionAlgorithm, password, initializationVector);
        data = Buffer.concat([initializationVector, Buffer.from(":"), cipher.update(Buffer.from(data)), cipher.final()]);
      }
      if (process.env.SNAP) {
        fs2.writeFileSync(this.path, data, { mode: __classPrivateFieldGet(this, _Conf_options, "f").configFileMode });
      } else {
        try {
          atomically.writeFileSync(this.path, data, { mode: __classPrivateFieldGet(this, _Conf_options, "f").configFileMode });
        } catch (error2) {
          if ((error2 === null || error2 === void 0 ? void 0 : error2.code) === "EXDEV") {
            fs2.writeFileSync(this.path, data, { mode: __classPrivateFieldGet(this, _Conf_options, "f").configFileMode });
            return;
          }
          throw error2;
        }
      }
    }
    _watch() {
      this._ensureDirectory();
      if (!fs2.existsSync(this.path)) {
        this._write(createPlainObject());
      }
      if (process.platform === "win32") {
        fs2.watch(this.path, { persistent: false }, debounceFn$1(() => {
          this.events.emit("change");
        }, { wait: 100 }));
      } else {
        fs2.watchFile(this.path, { persistent: false }, debounceFn$1(() => {
          this.events.emit("change");
        }, { wait: 5e3 }));
      }
    }
    _migrate(migrations, versionToMigrate, beforeEachMigration) {
      let previousMigratedVersion = this._get(MIGRATION_KEY, "0.0.0");
      const newerVersions = Object.keys(migrations).filter((candidateVersion) => this._shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate));
      let storeBackup = { ...this.store };
      for (const version of newerVersions) {
        try {
          if (beforeEachMigration) {
            beforeEachMigration(this, {
              fromVersion: previousMigratedVersion,
              toVersion: version,
              finalVersion: versionToMigrate,
              versions: newerVersions
            });
          }
          const migration = migrations[version];
          migration(this);
          this._set(MIGRATION_KEY, version);
          previousMigratedVersion = version;
          storeBackup = { ...this.store };
        } catch (error2) {
          this.store = storeBackup;
          throw new Error(`Something went wrong during the migration! Changes applied to the store until this failed migration will be restored. ${error2}`);
        }
      }
      if (this._isVersionInRangeFormat(previousMigratedVersion) || !semver$12.eq(previousMigratedVersion, versionToMigrate)) {
        this._set(MIGRATION_KEY, versionToMigrate);
      }
    }
    _containsReservedKey(key) {
      if (typeof key === "object") {
        const firsKey = Object.keys(key)[0];
        if (firsKey === INTERNAL_KEY) {
          return true;
        }
      }
      if (typeof key !== "string") {
        return false;
      }
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        if (key.startsWith(`${INTERNAL_KEY}.`)) {
          return true;
        }
        return false;
      }
      return false;
    }
    _isVersionInRangeFormat(version) {
      return semver$12.clean(version) === null;
    }
    _shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate) {
      if (this._isVersionInRangeFormat(candidateVersion)) {
        if (previousMigratedVersion !== "0.0.0" && semver$12.satisfies(previousMigratedVersion, candidateVersion)) {
          return false;
        }
        return semver$12.satisfies(versionToMigrate, candidateVersion);
      }
      if (semver$12.lte(candidateVersion, previousMigratedVersion)) {
        return false;
      }
      if (semver$12.gt(candidateVersion, versionToMigrate)) {
        return false;
      }
      return true;
    }
    _get(key, defaultValue) {
      return dotProp$1.get(this.store, key, defaultValue);
    }
    _set(key, value) {
      const { store: store2 } = this;
      dotProp$1.set(store2, key, value);
      this.store = store2;
    }
  }
  exports2.default = Conf2;
  module2.exports = Conf2;
  module2.exports.default = Conf2;
})(source, source.exports);
var sourceExports = source.exports;
const path = require$$1;
const { app, ipcMain, ipcRenderer, shell } = require$$0;
const Conf = sourceExports;
let isInitialized = false;
const initDataListener = () => {
  if (!ipcMain || !app) {
    throw new Error("Electron Store: You need to call `.initRenderer()` from the main process.");
  }
  const appData = {
    defaultCwd: app.getPath("userData"),
    appVersion: app.getVersion()
  };
  if (isInitialized) {
    return appData;
  }
  ipcMain.on("electron-store-get-data", (event) => {
    event.returnValue = appData;
  });
  isInitialized = true;
  return appData;
};
class ElectronStore extends Conf {
  constructor(options) {
    let defaultCwd;
    let appVersion;
    if (ipcRenderer) {
      const appData = ipcRenderer.sendSync("electron-store-get-data");
      if (!appData) {
        throw new Error("Electron Store: You need to call `.initRenderer()` from the main process.");
      }
      ({ defaultCwd, appVersion } = appData);
    } else if (ipcMain && app) {
      ({ defaultCwd, appVersion } = initDataListener());
    }
    options = {
      name: "config",
      ...options
    };
    if (!options.projectVersion) {
      options.projectVersion = appVersion;
    }
    if (options.cwd) {
      options.cwd = path.isAbsolute(options.cwd) ? options.cwd : path.join(defaultCwd, options.cwd);
    } else {
      options.cwd = defaultCwd;
    }
    options.configName = options.name;
    delete options.name;
    super(options);
  }
  static initRenderer() {
    initDataListener();
  }
  openInEditor() {
    shell.openPath(this.path);
  }
}
var electronStore = ElectronStore;
const Store = /* @__PURE__ */ getDefaultExportFromCjs(electronStore);
var define_import_meta_env_default$1 = { VITE_DEV_SERVER_URL: "http://localhost:5173/", BASE_URL: "/", MODE: "development", DEV: true, PROD: false, SSR: false };
const schema$1 = {
  notes: {
    type: "object",
    patternProperties: {
      "[A-Za-z0-9_-]": {
        type: "object",
        properties: {
          id: { type: "string", default: "" },
          title: { type: "string", default: "" },
          content: { type: "object", default: { type: "doc", content: [] } },
          labels: { type: "array", default: [] },
          createdAt: { type: "number", default: Date.now() },
          updatedAt: { type: "number", default: Date.now() },
          isBookmarked: { type: "boolean", default: false },
          isArchived: { type: "boolean", default: false },
          lastCursorPosition: { type: "number", default: 0 }
        }
      }
    }
  },
  labels: {
    type: "array"
  }
};
const store$1 = new Store({
  schema: schema$1,
  encryptionKey: define_import_meta_env_default$1.VITE_ENCRYPT_KEY
});
const schema = {
  dataDir: {
    type: "string",
    default: require$$0.app.getPath("userData")
  }
};
const settings = new Store({ name: "settings", schema, encryptionKey: process.env.VITE_ENCRYPT_KEY });
const store = {
  data: store$1,
  settings
};
var define_import_meta_env_default = { VITE_DEV_SERVER_URL: "http://localhost:5173/", BASE_URL: "/", MODE: "development", DEV: true, PROD: false, SSR: false };
const isSingleInstance = require$$0.app.requestSingleInstanceLock();
if (!isSingleInstance) {
  require$$0.app.quit();
  process.exit(0);
}
require$$0.app.disableHardwareAcceleration();
const env = define_import_meta_env_default;
let mainWindow = null;
const createWindow = async () => {
  mainWindow = new require$$0.BrowserWindow({
    show: false,
    width: 950,
    height: 600,
    webPreferences: {
      preload: require$$1.join(__dirname, "../../preload/dist/index.cjs"),
      contextIsolation: env.MODE !== "test",
      enableRemoteModule: env.MODE === "test",
      nodeIntegration: true
    }
  });
  mainWindow.setMenuBarVisibility(false);
  mainWindow.on("ready-to-show", () => {
    mainWindow == null ? void 0 : mainWindow.show();
    {
      mainWindow == null ? void 0 : mainWindow.webContents.openDevTools();
    }
  });
  mainWindow == null ? void 0 : mainWindow.webContents.on("new-window", function(event, url) {
    event.preventDefault();
    if (url.startsWith("note://"))
      return;
    require$$0.shell.openExternal(url);
  });
  const pageUrl = env.VITE_DEV_SERVER_URL;
  await mainWindow.loadURL(pageUrl);
};
require$$0.app.on("NSApplicationDelegate.applicationSupportsSecureRestorableState", () => {
  return true;
});
require$$0.app.on("second-instance", () => {
  if (mainWindow) {
    if (mainWindow.isMinimized())
      mainWindow.restore();
    mainWindow.focus();
  }
});
require$$0.app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    require$$0.app.quit();
  }
});
require$$0.app.whenReady().then(async () => {
  require$$0.protocol.registerFileProtocol("assets", (request, callback) => {
    const url = request.url.substr(9);
    const dir = store.settings.get("dataDir");
    const imgPath = `${dir}/notes-assets/${url}`;
    callback({ path: require$$1.normalize(imgPath) });
  });
  await lib.ensureDir(require$$1.join(require$$0.app.getPath("userData"), "notes-assets"));
  await createWindow();
}).catch((e) => console.error("Failed create window:", e));
ipcMain$1.answerRenderer("app:info", () => ({
  name: require$$0.app.getName(),
  version: require$$0.app.getVersion()
}));
ipcMain$1.answerRenderer("dialog:open", (props) => require$$0.dialog.showOpenDialog(props));
ipcMain$1.answerRenderer("dialog:message", (props) => require$$0.dialog.showMessageBox(props));
ipcMain$1.answerRenderer("dialog:save", (props) => require$$0.dialog.showSaveDialog(props));
ipcMain$1.answerRenderer("fs:copy", ({ path: path2, dest }) => lib.copy(path2, dest));
ipcMain$1.answerRenderer("fs:output-json", ({ path: path2, data }) => lib.outputJson(path2, data));
ipcMain$1.answerRenderer("fs:read-json", (path2) => lib.readJson(path2));
ipcMain$1.answerRenderer("fs:ensureDir", (path2) => lib.ensureDir(path2));
ipcMain$1.answerRenderer("fs:pathExists", (path2) => lib.pathExistsSync(path2));
ipcMain$1.answerRenderer("fs:remove", (path2) => lib.remove(path2));
ipcMain$1.answerRenderer("helper:relaunch", (options = {}) => {
  require$$0.app.relaunch({ args: process.argv.slice(1).concat(["--relaunch"]), ...options });
  require$$0.app.exit(0);
});
ipcMain$1.answerRenderer("helper:get-path", (name) => require$$0.app.getPath(name));
ipcMain$1.answerRenderer("helper:is-dark-theme", () => require$$0.nativeTheme.shouldUseDarkColors);
ipcMain$1.answerRenderer("storage:store", (name) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.store;
});
ipcMain$1.answerRenderer("storage:replace", ({ name, data }) => store[name].store = data);
ipcMain$1.answerRenderer("storage:get", ({ name, key, def: def2 }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.get(key, def2);
});
ipcMain$1.answerRenderer("storage:set", ({ name, key, value }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.set(key, value);
});
ipcMain$1.answerRenderer("storage:delete", ({ name, key }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.delete(key);
});
ipcMain$1.answerRenderer("storage:has", ({ name, key }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.has(key);
});
ipcMain$1.answerRenderer("storage:clear", (name) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.clear();
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguY2pzIiwic291cmNlcyI6WyIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VyaWFsaXplLWVycm9yL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWJldHRlci1pcGMvc291cmNlL3V0aWwuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tYmV0dGVyLWlwYy9zb3VyY2UvcmVuZGVyZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tYmV0dGVyLWlwYy9zb3VyY2UvbWFpbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1iZXR0ZXItaXBjL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3VuaXZlcnNhbGlmeS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9wb2x5ZmlsbHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvbGVnYWN5LXN0cmVhbXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvY2xvbmUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvZ3JhY2VmdWwtZnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2ZzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9ta2RpcnMvdXRpbHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21rZGlycy9tYWtlLWRpci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvbWtkaXJzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9wYXRoLWV4aXN0cy9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvdXRpbC91dGltZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3V0aWwvc3RhdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvY29weS9jb3B5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5L2NvcHktc3luYy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvY29weS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvcmVtb3ZlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbXB0eS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL2ZpbGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9saW5rLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvc3ltbGluay1wYXRocy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL3N5bWxpbmstdHlwZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL3N5bWxpbmsuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qc29uZmlsZS91dGlscy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qc29uZmlsZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvanNvbi9qc29uZmlsZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvb3V0cHV0LWZpbGUvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2pzb24vb3V0cHV0LWpzb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2pzb24vb3V0cHV0LWpzb24tc3luYy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvanNvbi9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvbW92ZS9tb3ZlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9tb3ZlL21vdmUtc3luYy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvbW92ZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvaXMtb2JqL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RvdC1wcm9wL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3BrZy11cC9ub2RlX21vZHVsZXMvcGF0aC1leGlzdHMvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcC10cnkvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcC1saW1pdC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wa2ctdXAvbm9kZV9tb2R1bGVzL3AtbG9jYXRlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3BrZy11cC9ub2RlX21vZHVsZXMvbG9jYXRlLXBhdGgvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcGtnLXVwL25vZGVfbW9kdWxlcy9maW5kLXVwL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3BrZy11cC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbnYtcGF0aHMvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L2NvbnN0cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hdG9taWNhbGx5L2Rpc3QvdXRpbHMvYXR0ZW1wdGlmeS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hdG9taWNhbGx5L2Rpc3QvdXRpbHMvZnNfaGFuZGxlcnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL3JldHJ5aWZ5X3F1ZXVlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC91dGlscy9yZXRyeWlmeS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hdG9taWNhbGx5L2Rpc3QvdXRpbHMvZnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL2xhbmcuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL3NjaGVkdWxlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hdG9taWNhbGx5L2Rpc3QvdXRpbHMvdGVtcC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hdG9taWNhbGx5L2Rpc3QvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuL2NvZGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuL3Njb3BlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvY29kZWdlbi9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3V0aWwuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9uYW1lcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2Vycm9ycy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2Jvb2xTY2hlbWEuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9ydWxlcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2FwcGxpY2FiaWxpdHkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9kYXRhVHlwZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2RlZmF1bHRzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9jb2RlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUva2V5d29yZC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL3N1YnNjaGVtYS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mYXN0LWRlZXAtZXF1YWwvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtdHJhdmVyc2UvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9yZXNvbHZlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS92YWxpZGF0aW9uX2Vycm9yLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvcmVmX2Vycm9yLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvdXJpLWpzL2Rpc3QvZXM1L3VyaS5hbGwuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS91cmkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29yZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvY29yZS9pZC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvY29yZS9yZWYuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvcmUvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbGltaXROdW1iZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbXVsdGlwbGVPZi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9ydW50aW1lL3VjczJsZW5ndGguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbGltaXRMZW5ndGguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vcGF0dGVybi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdFByb3BlcnRpZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vcmVxdWlyZWQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbGltaXRJdGVtcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9ydW50aW1lL2VxdWFsLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL3VuaXF1ZUl0ZW1zLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2NvbnN0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2VudW0uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWRkaXRpb25hbEl0ZW1zLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2l0ZW1zLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3ByZWZpeEl0ZW1zLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2l0ZW1zMjAyMC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9jb250YWlucy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9kZXBlbmRlbmNpZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJvcGVydHlOYW1lcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9hZGRpdGlvbmFsUHJvcGVydGllcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wcm9wZXJ0aWVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3BhdHRlcm5Qcm9wZXJ0aWVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL25vdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9hbnlPZi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9vbmVPZi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9hbGxPZi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pZi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci90aGVuRWxzZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvZm9ybWF0L2Zvcm1hdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvZm9ybWF0L2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9tZXRhZGF0YS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvZHJhZnQ3LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9kaXNjcmltaW5hdG9yL3R5cGVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9kaXNjcmltaW5hdG9yL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2Fqdi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYtZm9ybWF0cy9kaXN0L2Zvcm1hdHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvZGlzdC9saW1pdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYtZm9ybWF0cy9kaXN0L2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RlYm91bmNlLWZuL25vZGVfbW9kdWxlcy9taW1pYy1mbi9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZWJvdW5jZS1mbi9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvY29uc3RhbnRzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9kZWJ1Zy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvcmUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL3BhcnNlLW9wdGlvbnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2lkZW50aWZpZXJzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL3NlbXZlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3BhcnNlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvdmFsaWQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jbGVhbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2luYy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2RpZmYuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9tYWpvci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL21pbm9yLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcGF0Y2guanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wcmVyZWxlYXNlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3Jjb21wYXJlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS1sb29zZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUtYnVpbGQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zb3J0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcnNvcnQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9ndC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZXEuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9uZXEuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9ndGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9sdGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jbXAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb2VyY2UuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMveWFsbGlzdC9pdGVyYXRvci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy95YWxsaXN0L3lhbGxpc3QuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbHJ1LWNhY2hlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL3JhbmdlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL2NvbXBhcmF0b3IuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zYXRpc2ZpZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy90by1jb21wYXJhdG9ycy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21heC1zYXRpc2Z5aW5nLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWluLXNhdGlzZnlpbmcuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9taW4tdmVyc2lvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3ZhbGlkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvb3V0c2lkZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2d0ci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2x0ci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2ludGVyc2VjdHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zaW1wbGlmeS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3N1YnNldC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zZW12ZXIvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbWltaWMtZm4vaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvb25ldGltZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL2Rpc3Qvc291cmNlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXN0b3JlL2luZGV4LmpzIiwiLi4vc3JjL3N0b3JlL21vZHVsZXMvZGF0YS5zdG9yZS5qcyIsIi4uL3NyYy9zdG9yZS9tb2R1bGVzL3NldHRpbmdzLnN0b3JlLmpzIiwiLi4vc3JjL3N0b3JlL2luZGV4LmpzIiwiLi4vc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY2xhc3MgTm9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcblx0XHRzdXBlcihOb25FcnJvci5fcHJlcGFyZVN1cGVyTWVzc2FnZShtZXNzYWdlKSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYW1lJywge1xuXHRcdFx0dmFsdWU6ICdOb25FcnJvcicsXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHR3cml0YWJsZTogdHJ1ZVxuXHRcdH0pO1xuXG5cdFx0aWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG5cdFx0XHRFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBOb25FcnJvcik7XG5cdFx0fVxuXHR9XG5cblx0c3RhdGljIF9wcmVwYXJlU3VwZXJNZXNzYWdlKG1lc3NhZ2UpIHtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpO1xuXHRcdH0gY2F0Y2gge1xuXHRcdFx0cmV0dXJuIFN0cmluZyhtZXNzYWdlKTtcblx0XHR9XG5cdH1cbn1cblxuY29uc3QgY29tbW9uUHJvcGVydGllcyA9IFtcblx0e3Byb3BlcnR5OiAnbmFtZScsIGVudW1lcmFibGU6IGZhbHNlfSxcblx0e3Byb3BlcnR5OiAnbWVzc2FnZScsIGVudW1lcmFibGU6IGZhbHNlfSxcblx0e3Byb3BlcnR5OiAnc3RhY2snLCBlbnVtZXJhYmxlOiBmYWxzZX0sXG5cdHtwcm9wZXJ0eTogJ2NvZGUnLCBlbnVtZXJhYmxlOiB0cnVlfVxuXTtcblxuY29uc3QgaXNDYWxsZWQgPSBTeW1ib2woJy50b0pTT04gY2FsbGVkJyk7XG5cbmNvbnN0IHRvSlNPTiA9IGZyb20gPT4ge1xuXHRmcm9tW2lzQ2FsbGVkXSA9IHRydWU7XG5cdGNvbnN0IGpzb24gPSBmcm9tLnRvSlNPTigpO1xuXHRkZWxldGUgZnJvbVtpc0NhbGxlZF07XG5cdHJldHVybiBqc29uO1xufTtcblxuY29uc3QgZGVzdHJveUNpcmN1bGFyID0gKHtcblx0ZnJvbSxcblx0c2Vlbixcblx0dG9fLFxuXHRmb3JjZUVudW1lcmFibGUsXG5cdG1heERlcHRoLFxuXHRkZXB0aFxufSkgPT4ge1xuXHRjb25zdCB0byA9IHRvXyB8fCAoQXJyYXkuaXNBcnJheShmcm9tKSA/IFtdIDoge30pO1xuXG5cdHNlZW4ucHVzaChmcm9tKTtcblxuXHRpZiAoZGVwdGggPj0gbWF4RGVwdGgpIHtcblx0XHRyZXR1cm4gdG87XG5cdH1cblxuXHRpZiAodHlwZW9mIGZyb20udG9KU09OID09PSAnZnVuY3Rpb24nICYmIGZyb21baXNDYWxsZWRdICE9PSB0cnVlKSB7XG5cdFx0cmV0dXJuIHRvSlNPTihmcm9tKTtcblx0fVxuXG5cdGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZyb20pKSB7XG5cdFx0aWYgKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuXHRcdFx0dG9ba2V5XSA9ICdbb2JqZWN0IEJ1ZmZlcl0nO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG5cdFx0XHR0b1trZXldID0gdmFsdWU7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoIXNlZW4uaW5jbHVkZXMoZnJvbVtrZXldKSkge1xuXHRcdFx0ZGVwdGgrKztcblxuXHRcdFx0dG9ba2V5XSA9IGRlc3Ryb3lDaXJjdWxhcih7XG5cdFx0XHRcdGZyb206IGZyb21ba2V5XSxcblx0XHRcdFx0c2Vlbjogc2Vlbi5zbGljZSgpLFxuXHRcdFx0XHRmb3JjZUVudW1lcmFibGUsXG5cdFx0XHRcdG1heERlcHRoLFxuXHRcdFx0XHRkZXB0aFxuXHRcdFx0fSk7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHR0b1trZXldID0gJ1tDaXJjdWxhcl0nO1xuXHR9XG5cblx0Zm9yIChjb25zdCB7cHJvcGVydHksIGVudW1lcmFibGV9IG9mIGNvbW1vblByb3BlcnRpZXMpIHtcblx0XHRpZiAodHlwZW9mIGZyb21bcHJvcGVydHldID09PSAnc3RyaW5nJykge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCBwcm9wZXJ0eSwge1xuXHRcdFx0XHR2YWx1ZTogZnJvbVtwcm9wZXJ0eV0sXG5cdFx0XHRcdGVudW1lcmFibGU6IGZvcmNlRW51bWVyYWJsZSA/IHRydWUgOiBlbnVtZXJhYmxlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5jb25zdCBzZXJpYWxpemVFcnJvciA9ICh2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG5cdGNvbnN0IHttYXhEZXB0aCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWX0gPSBvcHRpb25zO1xuXG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG5cdFx0cmV0dXJuIGRlc3Ryb3lDaXJjdWxhcih7XG5cdFx0XHRmcm9tOiB2YWx1ZSxcblx0XHRcdHNlZW46IFtdLFxuXHRcdFx0Zm9yY2VFbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0bWF4RGVwdGgsXG5cdFx0XHRkZXB0aDogMFxuXHRcdH0pO1xuXHR9XG5cblx0Ly8gUGVvcGxlIHNvbWV0aW1lcyB0aHJvdyB0aGluZ3MgYmVzaWRlcyBFcnJvciBvYmplY3Rz4oCmXG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcblx0XHQvLyBgSlNPTi5zdHJpbmdpZnkoKWAgZGlzY2FyZHMgZnVuY3Rpb25zLiBXZSBkbyB0b28sIHVubGVzcyBhIGZ1bmN0aW9uIGlzIHRocm93biBkaXJlY3RseS5cblx0XHRyZXR1cm4gYFtGdW5jdGlvbjogJHsodmFsdWUubmFtZSB8fCAnYW5vbnltb3VzJyl9XWA7XG5cdH1cblxuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG5jb25zdCBkZXNlcmlhbGl6ZUVycm9yID0gKHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcblx0Y29uc3Qge21heERlcHRoID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfSA9IG9wdGlvbnM7XG5cblx0aWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblxuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRjb25zdCBuZXdFcnJvciA9IG5ldyBFcnJvcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHVuaWNvcm4vZXJyb3ItbWVzc2FnZVxuXHRcdGRlc3Ryb3lDaXJjdWxhcih7XG5cdFx0XHRmcm9tOiB2YWx1ZSxcblx0XHRcdHNlZW46IFtdLFxuXHRcdFx0dG9fOiBuZXdFcnJvcixcblx0XHRcdG1heERlcHRoLFxuXHRcdFx0ZGVwdGg6IDBcblx0XHR9KTtcblx0XHRyZXR1cm4gbmV3RXJyb3I7XG5cdH1cblxuXHRyZXR1cm4gbmV3IE5vbkVycm9yKHZhbHVlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRzZXJpYWxpemVFcnJvcixcblx0ZGVzZXJpYWxpemVFcnJvclxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZ2V0VW5pcXVlSWQgPSAoKSA9PiBgJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCl9YDtcblxuY29uc3QgZ2V0U2VuZENoYW5uZWwgPSBjaGFubmVsID0+IGAlYmV0dGVyLWlwYy1zZW5kLWNoYW5uZWwtJHtjaGFubmVsfWA7XG5jb25zdCBnZXRSZW5kZXJlclNlbmRDaGFubmVsID0gY2hhbm5lbCA9PiBgJWJldHRlci1pcGMtc2VuZC1jaGFubmVsLSR7Y2hhbm5lbH1gO1xuXG5tb2R1bGUuZXhwb3J0cy5jdXJyZW50V2luZG93Q2hhbm5lbCA9ICclYmV0dGVyLWlwYy1jdXJyZW50LXdpbmRvdyc7XG5cbm1vZHVsZS5leHBvcnRzLmdldFNlbmRDaGFubmVsID0gZ2V0U2VuZENoYW5uZWw7XG5tb2R1bGUuZXhwb3J0cy5nZXRSZW5kZXJlclNlbmRDaGFubmVsID0gZ2V0UmVuZGVyZXJTZW5kQ2hhbm5lbDtcblxubW9kdWxlLmV4cG9ydHMuZ2V0UmVzcG9uc2VDaGFubmVscyA9IGNoYW5uZWwgPT4ge1xuXHRjb25zdCBpZCA9IGdldFVuaXF1ZUlkKCk7XG5cdHJldHVybiB7XG5cdFx0c2VuZENoYW5uZWw6IGdldFNlbmRDaGFubmVsKGNoYW5uZWwpLFxuXHRcdGRhdGFDaGFubmVsOiBgJWJldHRlci1pcGMtcmVzcG9uc2UtZGF0YS1jaGFubmVsLSR7Y2hhbm5lbH0tJHtpZH1gLFxuXHRcdGVycm9yQ2hhbm5lbDogYCViZXR0ZXItaXBjLXJlc3BvbnNlLWVycm9yLWNoYW5uZWwtJHtjaGFubmVsfS0ke2lkfWBcblx0fTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmdldFJlbmRlcmVyUmVzcG9uc2VDaGFubmVscyA9IGNoYW5uZWwgPT4ge1xuXHRjb25zdCBpZCA9IGdldFVuaXF1ZUlkKCk7XG5cdHJldHVybiB7XG5cdFx0c2VuZENoYW5uZWw6IGdldFJlbmRlcmVyU2VuZENoYW5uZWwoY2hhbm5lbCksXG5cdFx0ZGF0YUNoYW5uZWw6IGAlYmV0dGVyLWlwYy1yZXNwb25zZS1kYXRhLWNoYW5uZWwtJHtjaGFubmVsfS0ke2lkfWAsXG5cdFx0ZXJyb3JDaGFubmVsOiBgJWJldHRlci1pcGMtcmVzcG9uc2UtZXJyb3ItY2hhbm5lbC0ke2NoYW5uZWx9LSR7aWR9YFxuXHR9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IGVsZWN0cm9uID0gcmVxdWlyZSgnZWxlY3Ryb24nKTtcbmNvbnN0IHtzZXJpYWxpemVFcnJvciwgZGVzZXJpYWxpemVFcnJvcn0gPSByZXF1aXJlKCdzZXJpYWxpemUtZXJyb3InKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwuanMnKTtcblxuY29uc3Qge2lwY1JlbmRlcmVyfSA9IGVsZWN0cm9uO1xuY29uc3QgaXBjID0gT2JqZWN0LmNyZWF0ZShpcGNSZW5kZXJlciB8fCB7fSk7XG5cbmlwYy5jYWxsTWFpbiA9IChjaGFubmVsLCBkYXRhKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdGNvbnN0IHtzZW5kQ2hhbm5lbCwgZGF0YUNoYW5uZWwsIGVycm9yQ2hhbm5lbH0gPSB1dGlsLmdldFJlc3BvbnNlQ2hhbm5lbHMoY2hhbm5lbCk7XG5cblx0Y29uc3QgY2xlYW51cCA9ICgpID0+IHtcblx0XHRpcGNSZW5kZXJlci5vZmYoZGF0YUNoYW5uZWwsIG9uRGF0YSk7XG5cdFx0aXBjUmVuZGVyZXIub2ZmKGVycm9yQ2hhbm5lbCwgb25FcnJvcik7XG5cdH07XG5cblx0Y29uc3Qgb25EYXRhID0gKF9ldmVudCwgcmVzdWx0KSA9PiB7XG5cdFx0Y2xlYW51cCgpO1xuXHRcdHJlc29sdmUocmVzdWx0KTtcblx0fTtcblxuXHRjb25zdCBvbkVycm9yID0gKF9ldmVudCwgZXJyb3IpID0+IHtcblx0XHRjbGVhbnVwKCk7XG5cdFx0cmVqZWN0KGRlc2VyaWFsaXplRXJyb3IoZXJyb3IpKTtcblx0fTtcblxuXHRpcGNSZW5kZXJlci5vbmNlKGRhdGFDaGFubmVsLCBvbkRhdGEpO1xuXHRpcGNSZW5kZXJlci5vbmNlKGVycm9yQ2hhbm5lbCwgb25FcnJvcik7XG5cblx0Y29uc3QgY29tcGxldGVEYXRhID0ge1xuXHRcdGRhdGFDaGFubmVsLFxuXHRcdGVycm9yQ2hhbm5lbCxcblx0XHR1c2VyRGF0YTogZGF0YVxuXHR9O1xuXG5cdGlwY1JlbmRlcmVyLnNlbmQoc2VuZENoYW5uZWwsIGNvbXBsZXRlRGF0YSk7XG59KTtcblxuaXBjLmFuc3dlck1haW4gPSAoY2hhbm5lbCwgY2FsbGJhY2spID0+IHtcblx0Y29uc3Qgc2VuZENoYW5uZWwgPSB1dGlsLmdldFJlbmRlcmVyU2VuZENoYW5uZWwoY2hhbm5lbCk7XG5cblx0Y29uc3QgbGlzdGVuZXIgPSBhc3luYyAoX2V2ZW50LCBkYXRhKSA9PiB7XG5cdFx0Y29uc3Qge2RhdGFDaGFubmVsLCBlcnJvckNoYW5uZWwsIHVzZXJEYXRhfSA9IGRhdGE7XG5cblx0XHR0cnkge1xuXHRcdFx0aXBjUmVuZGVyZXIuc2VuZChkYXRhQ2hhbm5lbCwgYXdhaXQgY2FsbGJhY2sodXNlckRhdGEpKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aXBjUmVuZGVyZXIuc2VuZChlcnJvckNoYW5uZWwsIHNlcmlhbGl6ZUVycm9yKGVycm9yKSk7XG5cdFx0fVxuXHR9O1xuXG5cdGlwY1JlbmRlcmVyLm9uKHNlbmRDaGFubmVsLCBsaXN0ZW5lcik7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpcGNSZW5kZXJlci5vZmYoc2VuZENoYW5uZWwsIGxpc3RlbmVyKTtcblx0fTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXBjO1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgZWxlY3Ryb24gPSByZXF1aXJlKCdlbGVjdHJvbicpO1xuY29uc3Qge3NlcmlhbGl6ZUVycm9yLCBkZXNlcmlhbGl6ZUVycm9yfSA9IHJlcXVpcmUoJ3NlcmlhbGl6ZS1lcnJvcicpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbC5qcycpO1xuXG5jb25zdCB7aXBjTWFpbiwgQnJvd3NlcldpbmRvd30gPSBlbGVjdHJvbjtcbmNvbnN0IGlwYyA9IE9iamVjdC5jcmVhdGUoaXBjTWFpbiB8fCB7fSk7XG5cbmlwYy5jYWxsUmVuZGVyZXIgPSAoYnJvd3NlcldpbmRvdywgY2hhbm5lbCwgZGF0YSkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRpZiAoIWJyb3dzZXJXaW5kb3cpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Jyb3dzZXIgd2luZG93IHJlcXVpcmVkJyk7XG5cdH1cblxuXHRjb25zdCB7c2VuZENoYW5uZWwsIGRhdGFDaGFubmVsLCBlcnJvckNoYW5uZWx9ID0gdXRpbC5nZXRSZW5kZXJlclJlc3BvbnNlQ2hhbm5lbHMoY2hhbm5lbCk7XG5cblx0Y29uc3QgY2xlYW51cCA9ICgpID0+IHtcblx0XHRpcGNNYWluLm9mZihkYXRhQ2hhbm5lbCwgb25EYXRhKTtcblx0XHRpcGNNYWluLm9mZihlcnJvckNoYW5uZWwsIG9uRXJyb3IpO1xuXHR9O1xuXG5cdGNvbnN0IG9uRGF0YSA9IChldmVudCwgcmVzdWx0KSA9PiB7XG5cdFx0Y29uc3Qgd2luZG93ID0gQnJvd3NlcldpbmRvdy5mcm9tV2ViQ29udGVudHMoZXZlbnQuc2VuZGVyKTtcblx0XHRpZiAod2luZG93LmlkID09PSBicm93c2VyV2luZG93LmlkKSB7XG5cdFx0XHRjbGVhbnVwKCk7XG5cdFx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cdFx0fVxuXHR9O1xuXG5cdGNvbnN0IG9uRXJyb3IgPSAoZXZlbnQsIGVycm9yKSA9PiB7XG5cdFx0Y29uc3Qgd2luZG93ID0gQnJvd3NlcldpbmRvdy5mcm9tV2ViQ29udGVudHMoZXZlbnQuc2VuZGVyKTtcblx0XHRpZiAod2luZG93LmlkID09PSBicm93c2VyV2luZG93LmlkKSB7XG5cdFx0XHRjbGVhbnVwKCk7XG5cdFx0XHRyZWplY3QoZGVzZXJpYWxpemVFcnJvcihlcnJvcikpO1xuXHRcdH1cblx0fTtcblxuXHRpcGNNYWluLm9uKGRhdGFDaGFubmVsLCBvbkRhdGEpO1xuXHRpcGNNYWluLm9uKGVycm9yQ2hhbm5lbCwgb25FcnJvcik7XG5cblx0Y29uc3QgY29tcGxldGVEYXRhID0ge1xuXHRcdGRhdGFDaGFubmVsLFxuXHRcdGVycm9yQ2hhbm5lbCxcblx0XHR1c2VyRGF0YTogZGF0YVxuXHR9O1xuXG5cdGlmIChicm93c2VyV2luZG93LndlYkNvbnRlbnRzKSB7XG5cdFx0YnJvd3NlcldpbmRvdy53ZWJDb250ZW50cy5zZW5kKHNlbmRDaGFubmVsLCBjb21wbGV0ZURhdGEpO1xuXHR9XG59KTtcblxuaXBjLmNhbGxGb2N1c2VkUmVuZGVyZXIgPSBhc3luYyAoLi4uYXJncykgPT4ge1xuXHRjb25zdCBmb2N1c2VkV2luZG93ID0gQnJvd3NlcldpbmRvdy5nZXRGb2N1c2VkV2luZG93KCk7XG5cdGlmICghZm9jdXNlZFdpbmRvdykge1xuXHRcdHRocm93IG5ldyBFcnJvcignTm8gYnJvd3NlciB3aW5kb3cgaW4gZm9jdXMnKTtcblx0fVxuXG5cdHJldHVybiBpcGMuY2FsbFJlbmRlcmVyKGZvY3VzZWRXaW5kb3csIC4uLmFyZ3MpO1xufTtcblxuaXBjLmFuc3dlclJlbmRlcmVyID0gKGJyb3dzZXJXaW5kb3dPckNoYW5uZWwsIGNoYW5uZWxPckNhbGxiYWNrLCBjYWxsYmFja09yTm90aGluZykgPT4ge1xuXHRsZXQgd2luZG93O1xuXHRsZXQgY2hhbm5lbDtcblx0bGV0IGNhbGxiYWNrO1xuXG5cdGlmIChjYWxsYmFja09yTm90aGluZyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Y2hhbm5lbCA9IGJyb3dzZXJXaW5kb3dPckNoYW5uZWw7XG5cdFx0Y2FsbGJhY2sgPSBjaGFubmVsT3JDYWxsYmFjaztcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cgPSBicm93c2VyV2luZG93T3JDaGFubmVsO1xuXHRcdGNoYW5uZWwgPSBjaGFubmVsT3JDYWxsYmFjaztcblx0XHRjYWxsYmFjayA9IGNhbGxiYWNrT3JOb3RoaW5nO1xuXG5cdFx0aWYgKCF3aW5kb3cpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignQnJvd3NlciB3aW5kb3cgcmVxdWlyZWQnKTtcblx0XHR9XG5cdH1cblxuXHRjb25zdCBzZW5kQ2hhbm5lbCA9IHV0aWwuZ2V0U2VuZENoYW5uZWwoY2hhbm5lbCk7XG5cblx0Y29uc3QgbGlzdGVuZXIgPSBhc3luYyAoZXZlbnQsIGRhdGEpID0+IHtcblx0XHRjb25zdCBicm93c2VyV2luZG93ID0gQnJvd3NlcldpbmRvdy5mcm9tV2ViQ29udGVudHMoZXZlbnQuc2VuZGVyKTtcblxuXHRcdGlmICh3aW5kb3cgJiYgd2luZG93LmlkICE9PSBicm93c2VyV2luZG93LmlkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3Qgc2VuZCA9IChjaGFubmVsLCBkYXRhKSA9PiB7XG5cdFx0XHRpZiAoIShicm93c2VyV2luZG93ICYmIGJyb3dzZXJXaW5kb3cuaXNEZXN0cm95ZWQoKSkpIHtcblx0XHRcdFx0ZXZlbnQuc2VuZGVyLnNlbmQoY2hhbm5lbCwgZGF0YSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGNvbnN0IHtkYXRhQ2hhbm5lbCwgZXJyb3JDaGFubmVsLCB1c2VyRGF0YX0gPSBkYXRhO1xuXG5cdFx0dHJ5IHtcblx0XHRcdHNlbmQoZGF0YUNoYW5uZWwsIGF3YWl0IGNhbGxiYWNrKHVzZXJEYXRhLCBicm93c2VyV2luZG93KSk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHNlbmQoZXJyb3JDaGFubmVsLCBzZXJpYWxpemVFcnJvcihlcnJvcikpO1xuXHRcdH1cblx0fTtcblxuXHRpcGNNYWluLm9uKHNlbmRDaGFubmVsLCBsaXN0ZW5lcik7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpcGNNYWluLm9mZihzZW5kQ2hhbm5lbCwgbGlzdGVuZXIpO1xuXHR9O1xufTtcblxuaXBjLnNlbmRUb1JlbmRlcmVycyA9IChjaGFubmVsLCBkYXRhKSA9PiB7XG5cdGZvciAoY29uc3QgYnJvd3NlcldpbmRvdyBvZiBCcm93c2VyV2luZG93LmdldEFsbFdpbmRvd3MoKSkge1xuXHRcdGlmIChicm93c2VyV2luZG93LndlYkNvbnRlbnRzKSB7XG5cdFx0XHRicm93c2VyV2luZG93LndlYkNvbnRlbnRzLnNlbmQoY2hhbm5lbCwgZGF0YSk7XG5cdFx0fVxuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlwYztcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuXHRtb2R1bGUuZXhwb3J0cy5pcGNSZW5kZXJlciA9IHJlcXVpcmUoJy4vc291cmNlL3JlbmRlcmVyLmpzJyk7XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cy5pcGNNYWluID0gcmVxdWlyZSgnLi9zb3VyY2UvbWFpbi5qcycpO1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuZnJvbUNhbGxiYWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykgZm4uYXBwbHkodGhpcywgYXJncylcbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGFyZ3MucHVzaCgoZXJyLCByZXMpID0+IChlcnIgIT0gbnVsbCkgPyByZWplY3QoZXJyKSA6IHJlc29sdmUocmVzKSlcbiAgICAgICAgZm4uYXBwbHkodGhpcywgYXJncylcbiAgICAgIH0pXG4gICAgfVxuICB9LCAnbmFtZScsIHsgdmFsdWU6IGZuLm5hbWUgfSlcbn1cblxuZXhwb3J0cy5mcm9tUHJvbWlzZSA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgY29uc3QgY2IgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV1cbiAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncylcbiAgICBlbHNlIHtcbiAgICAgIGFyZ3MucG9wKClcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpLnRoZW4ociA9PiBjYihudWxsLCByKSwgY2IpXG4gICAgfVxuICB9LCAnbmFtZScsIHsgdmFsdWU6IGZuLm5hbWUgfSlcbn1cbiIsInZhciBjb25zdGFudHMgPSByZXF1aXJlKCdjb25zdGFudHMnKVxuXG52YXIgb3JpZ0N3ZCA9IHByb2Nlc3MuY3dkXG52YXIgY3dkID0gbnVsbFxuXG52YXIgcGxhdGZvcm0gPSBwcm9jZXNzLmVudi5HUkFDRUZVTF9GU19QTEFURk9STSB8fCBwcm9jZXNzLnBsYXRmb3JtXG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24oKSB7XG4gIGlmICghY3dkKVxuICAgIGN3ZCA9IG9yaWdDd2QuY2FsbChwcm9jZXNzKVxuICByZXR1cm4gY3dkXG59XG50cnkge1xuICBwcm9jZXNzLmN3ZCgpXG59IGNhdGNoIChlcikge31cblxuLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdW50aWwgbm9kZS5qcyAxMiBpcyByZXF1aXJlZFxuaWYgKHR5cGVvZiBwcm9jZXNzLmNoZGlyID09PSAnZnVuY3Rpb24nKSB7XG4gIHZhciBjaGRpciA9IHByb2Nlc3MuY2hkaXJcbiAgcHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkKSB7XG4gICAgY3dkID0gbnVsbFxuICAgIGNoZGlyLmNhbGwocHJvY2VzcywgZClcbiAgfVxuICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvY2Vzcy5jaGRpciwgY2hkaXIpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGF0Y2hcblxuZnVuY3Rpb24gcGF0Y2ggKGZzKSB7XG4gIC8vIChyZS0paW1wbGVtZW50IHNvbWUgdGhpbmdzIHRoYXQgYXJlIGtub3duIGJ1c3RlZCBvciBtaXNzaW5nLlxuXG4gIC8vIGxjaG1vZCwgYnJva2VuIHByaW9yIHRvIDAuNi4yXG4gIC8vIGJhY2stcG9ydCB0aGUgZml4IGhlcmUuXG4gIGlmIChjb25zdGFudHMuaGFzT3duUHJvcGVydHkoJ09fU1lNTElOSycpICYmXG4gICAgICBwcm9jZXNzLnZlcnNpb24ubWF0Y2goL152MFxcLjZcXC5bMC0yXXxedjBcXC41XFwuLykpIHtcbiAgICBwYXRjaExjaG1vZChmcylcbiAgfVxuXG4gIC8vIGx1dGltZXMgaW1wbGVtZW50YXRpb24sIG9yIG5vLW9wXG4gIGlmICghZnMubHV0aW1lcykge1xuICAgIHBhdGNoTHV0aW1lcyhmcylcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3Mvbm9kZS1ncmFjZWZ1bC1mcy9pc3N1ZXMvNFxuICAvLyBDaG93biBzaG91bGQgbm90IGZhaWwgb24gZWludmFsIG9yIGVwZXJtIGlmIG5vbi1yb290LlxuICAvLyBJdCBzaG91bGQgbm90IGZhaWwgb24gZW5vc3lzIGV2ZXIsIGFzIHRoaXMganVzdCBpbmRpY2F0ZXNcbiAgLy8gdGhhdCBhIGZzIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgaW50ZW5kZWQgb3BlcmF0aW9uLlxuXG4gIGZzLmNob3duID0gY2hvd25GaXgoZnMuY2hvd24pXG4gIGZzLmZjaG93biA9IGNob3duRml4KGZzLmZjaG93bilcbiAgZnMubGNob3duID0gY2hvd25GaXgoZnMubGNob3duKVxuXG4gIGZzLmNobW9kID0gY2htb2RGaXgoZnMuY2htb2QpXG4gIGZzLmZjaG1vZCA9IGNobW9kRml4KGZzLmZjaG1vZClcbiAgZnMubGNobW9kID0gY2htb2RGaXgoZnMubGNobW9kKVxuXG4gIGZzLmNob3duU3luYyA9IGNob3duRml4U3luYyhmcy5jaG93blN5bmMpXG4gIGZzLmZjaG93blN5bmMgPSBjaG93bkZpeFN5bmMoZnMuZmNob3duU3luYylcbiAgZnMubGNob3duU3luYyA9IGNob3duRml4U3luYyhmcy5sY2hvd25TeW5jKVxuXG4gIGZzLmNobW9kU3luYyA9IGNobW9kRml4U3luYyhmcy5jaG1vZFN5bmMpXG4gIGZzLmZjaG1vZFN5bmMgPSBjaG1vZEZpeFN5bmMoZnMuZmNobW9kU3luYylcbiAgZnMubGNobW9kU3luYyA9IGNobW9kRml4U3luYyhmcy5sY2htb2RTeW5jKVxuXG4gIGZzLnN0YXQgPSBzdGF0Rml4KGZzLnN0YXQpXG4gIGZzLmZzdGF0ID0gc3RhdEZpeChmcy5mc3RhdClcbiAgZnMubHN0YXQgPSBzdGF0Rml4KGZzLmxzdGF0KVxuXG4gIGZzLnN0YXRTeW5jID0gc3RhdEZpeFN5bmMoZnMuc3RhdFN5bmMpXG4gIGZzLmZzdGF0U3luYyA9IHN0YXRGaXhTeW5jKGZzLmZzdGF0U3luYylcbiAgZnMubHN0YXRTeW5jID0gc3RhdEZpeFN5bmMoZnMubHN0YXRTeW5jKVxuXG4gIC8vIGlmIGxjaG1vZC9sY2hvd24gZG8gbm90IGV4aXN0LCB0aGVuIG1ha2UgdGhlbSBuby1vcHNcbiAgaWYgKGZzLmNobW9kICYmICFmcy5sY2htb2QpIHtcbiAgICBmcy5sY2htb2QgPSBmdW5jdGlvbiAocGF0aCwgbW9kZSwgY2IpIHtcbiAgICAgIGlmIChjYikgcHJvY2Vzcy5uZXh0VGljayhjYilcbiAgICB9XG4gICAgZnMubGNobW9kU3luYyA9IGZ1bmN0aW9uICgpIHt9XG4gIH1cbiAgaWYgKGZzLmNob3duICYmICFmcy5sY2hvd24pIHtcbiAgICBmcy5sY2hvd24gPSBmdW5jdGlvbiAocGF0aCwgdWlkLCBnaWQsIGNiKSB7XG4gICAgICBpZiAoY2IpIHByb2Nlc3MubmV4dFRpY2soY2IpXG4gICAgfVxuICAgIGZzLmxjaG93blN5bmMgPSBmdW5jdGlvbiAoKSB7fVxuICB9XG5cbiAgLy8gb24gV2luZG93cywgQS9WIHNvZnR3YXJlIGNhbiBsb2NrIHRoZSBkaXJlY3RvcnksIGNhdXNpbmcgdGhpc1xuICAvLyB0byBmYWlsIHdpdGggYW4gRUFDQ0VTIG9yIEVQRVJNIGlmIHRoZSBkaXJlY3RvcnkgY29udGFpbnMgbmV3bHlcbiAgLy8gY3JlYXRlZCBmaWxlcy4gIFRyeSBhZ2FpbiBvbiBmYWlsdXJlLCBmb3IgdXAgdG8gNjAgc2Vjb25kcy5cblxuICAvLyBTZXQgdGhlIHRpbWVvdXQgdGhpcyBsb25nIGJlY2F1c2Ugc29tZSBXaW5kb3dzIEFudGktVmlydXMsIHN1Y2ggYXMgUGFyaXR5XG4gIC8vIGJpdDksIG1heSBsb2NrIGZpbGVzIGZvciB1cCB0byBhIG1pbnV0ZSwgY2F1c2luZyBucG0gcGFja2FnZSBpbnN0YWxsXG4gIC8vIGZhaWx1cmVzLiBBbHNvLCB0YWtlIGNhcmUgdG8geWllbGQgdGhlIHNjaGVkdWxlci4gV2luZG93cyBzY2hlZHVsaW5nIGdpdmVzXG4gIC8vIENQVSB0byBhIGJ1c3kgbG9vcGluZyBwcm9jZXNzLCB3aGljaCBjYW4gY2F1c2UgdGhlIHByb2dyYW0gY2F1c2luZyB0aGUgbG9ja1xuICAvLyBjb250ZW50aW9uIHRvIGJlIHN0YXJ2ZWQgb2YgQ1BVIGJ5IG5vZGUsIHNvIHRoZSBjb250ZW50aW9uIGRvZXNuJ3QgcmVzb2x2ZS5cbiAgaWYgKHBsYXRmb3JtID09PSBcIndpbjMyXCIpIHtcbiAgICBmcy5yZW5hbWUgPSB0eXBlb2YgZnMucmVuYW1lICE9PSAnZnVuY3Rpb24nID8gZnMucmVuYW1lXG4gICAgOiAoZnVuY3Rpb24gKGZzJHJlbmFtZSkge1xuICAgICAgZnVuY3Rpb24gcmVuYW1lIChmcm9tLCB0bywgY2IpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKVxuICAgICAgICB2YXIgYmFja29mZiA9IDA7XG4gICAgICAgIGZzJHJlbmFtZShmcm9tLCB0bywgZnVuY3Rpb24gQ0IgKGVyKSB7XG4gICAgICAgICAgaWYgKGVyXG4gICAgICAgICAgICAgICYmIChlci5jb2RlID09PSBcIkVBQ0NFU1wiIHx8IGVyLmNvZGUgPT09IFwiRVBFUk1cIiB8fCBlci5jb2RlID09PSBcIkVCVVNZXCIpXG4gICAgICAgICAgICAgICYmIERhdGUubm93KCkgLSBzdGFydCA8IDYwMDAwKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBmcy5zdGF0KHRvLCBmdW5jdGlvbiAoc3RhdGVyLCBzdCkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZXIgJiYgc3RhdGVyLmNvZGUgPT09IFwiRU5PRU5UXCIpXG4gICAgICAgICAgICAgICAgICBmcyRyZW5hbWUoZnJvbSwgdG8sIENCKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICBjYihlcilcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0sIGJhY2tvZmYpXG4gICAgICAgICAgICBpZiAoYmFja29mZiA8IDEwMClcbiAgICAgICAgICAgICAgYmFja29mZiArPSAxMDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNiKSBjYihlcilcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIE9iamVjdC5zZXRQcm90b3R5cGVPZihyZW5hbWUsIGZzJHJlbmFtZSlcbiAgICAgIHJldHVybiByZW5hbWVcbiAgICB9KShmcy5yZW5hbWUpXG4gIH1cblxuICAvLyBpZiByZWFkKCkgcmV0dXJucyBFQUdBSU4sIHRoZW4ganVzdCB0cnkgaXQgYWdhaW4uXG4gIGZzLnJlYWQgPSB0eXBlb2YgZnMucmVhZCAhPT0gJ2Z1bmN0aW9uJyA/IGZzLnJlYWRcbiAgOiAoZnVuY3Rpb24gKGZzJHJlYWQpIHtcbiAgICBmdW5jdGlvbiByZWFkIChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrXykge1xuICAgICAgdmFyIGNhbGxiYWNrXG4gICAgICBpZiAoY2FsbGJhY2tfICYmIHR5cGVvZiBjYWxsYmFja18gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGVhZ0NvdW50ZXIgPSAwXG4gICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKGVyLCBfLCBfXykge1xuICAgICAgICAgIGlmIChlciAmJiBlci5jb2RlID09PSAnRUFHQUlOJyAmJiBlYWdDb3VudGVyIDwgMTApIHtcbiAgICAgICAgICAgIGVhZ0NvdW50ZXIgKytcbiAgICAgICAgICAgIHJldHVybiBmcyRyZWFkLmNhbGwoZnMsIGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmcyRyZWFkLmNhbGwoZnMsIGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spXG4gICAgfVxuXG4gICAgLy8gVGhpcyBlbnN1cmVzIGB1dGlsLnByb21pc2lmeWAgd29ya3MgYXMgaXQgZG9lcyBmb3IgbmF0aXZlIGBmcy5yZWFkYC5cbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSBPYmplY3Quc2V0UHJvdG90eXBlT2YocmVhZCwgZnMkcmVhZClcbiAgICByZXR1cm4gcmVhZFxuICB9KShmcy5yZWFkKVxuXG4gIGZzLnJlYWRTeW5jID0gdHlwZW9mIGZzLnJlYWRTeW5jICE9PSAnZnVuY3Rpb24nID8gZnMucmVhZFN5bmNcbiAgOiAoZnVuY3Rpb24gKGZzJHJlYWRTeW5jKSB7IHJldHVybiBmdW5jdGlvbiAoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XG4gICAgdmFyIGVhZ0NvdW50ZXIgPSAwXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmcyRyZWFkU3luYy5jYWxsKGZzLCBmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBpZiAoZXIuY29kZSA9PT0gJ0VBR0FJTicgJiYgZWFnQ291bnRlciA8IDEwKSB7XG4gICAgICAgICAgZWFnQ291bnRlciArK1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJcbiAgICAgIH1cbiAgICB9XG4gIH19KShmcy5yZWFkU3luYylcblxuICBmdW5jdGlvbiBwYXRjaExjaG1vZCAoZnMpIHtcbiAgICBmcy5sY2htb2QgPSBmdW5jdGlvbiAocGF0aCwgbW9kZSwgY2FsbGJhY2spIHtcbiAgICAgIGZzLm9wZW4oIHBhdGhcbiAgICAgICAgICAgICAsIGNvbnN0YW50cy5PX1dST05MWSB8IGNvbnN0YW50cy5PX1NZTUxJTktcbiAgICAgICAgICAgICAsIG1vZGVcbiAgICAgICAgICAgICAsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVycilcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICAvLyBwcmVmZXIgdG8gcmV0dXJuIHRoZSBjaG1vZCBlcnJvciwgaWYgb25lIG9jY3VycyxcbiAgICAgICAgLy8gYnV0IHN0aWxsIHRyeSB0byBjbG9zZSwgYW5kIHJlcG9ydCBjbG9zaW5nIGVycm9ycyBpZiB0aGV5IG9jY3VyLlxuICAgICAgICBmcy5mY2htb2QoZmQsIG1vZGUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBmcy5jbG9zZShmZCwgZnVuY3Rpb24oZXJyMikge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIgfHwgZXJyMilcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmcy5sY2htb2RTeW5jID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUpIHtcbiAgICAgIHZhciBmZCA9IGZzLm9wZW5TeW5jKHBhdGgsIGNvbnN0YW50cy5PX1dST05MWSB8IGNvbnN0YW50cy5PX1NZTUxJTkssIG1vZGUpXG5cbiAgICAgIC8vIHByZWZlciB0byByZXR1cm4gdGhlIGNobW9kIGVycm9yLCBpZiBvbmUgb2NjdXJzLFxuICAgICAgLy8gYnV0IHN0aWxsIHRyeSB0byBjbG9zZSwgYW5kIHJlcG9ydCBjbG9zaW5nIGVycm9ycyBpZiB0aGV5IG9jY3VyLlxuICAgICAgdmFyIHRocmV3ID0gdHJ1ZVxuICAgICAgdmFyIHJldFxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0ID0gZnMuZmNobW9kU3luYyhmZCwgbW9kZSlcbiAgICAgICAgdGhyZXcgPSBmYWxzZVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRocmV3KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgICB9IGNhdGNoIChlcikge31cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXRcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaEx1dGltZXMgKGZzKSB7XG4gICAgaWYgKGNvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eShcIk9fU1lNTElOS1wiKSAmJiBmcy5mdXRpbWVzKSB7XG4gICAgICBmcy5sdXRpbWVzID0gZnVuY3Rpb24gKHBhdGgsIGF0LCBtdCwgY2IpIHtcbiAgICAgICAgZnMub3BlbihwYXRoLCBjb25zdGFudHMuT19TWU1MSU5LLCBmdW5jdGlvbiAoZXIsIGZkKSB7XG4gICAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICBpZiAoY2IpIGNiKGVyKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGZzLmZ1dGltZXMoZmQsIGF0LCBtdCwgZnVuY3Rpb24gKGVyKSB7XG4gICAgICAgICAgICBmcy5jbG9zZShmZCwgZnVuY3Rpb24gKGVyMikge1xuICAgICAgICAgICAgICBpZiAoY2IpIGNiKGVyIHx8IGVyMilcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgZnMubHV0aW1lc1N5bmMgPSBmdW5jdGlvbiAocGF0aCwgYXQsIG10KSB7XG4gICAgICAgIHZhciBmZCA9IGZzLm9wZW5TeW5jKHBhdGgsIGNvbnN0YW50cy5PX1NZTUxJTkspXG4gICAgICAgIHZhciByZXRcbiAgICAgICAgdmFyIHRocmV3ID0gdHJ1ZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldCA9IGZzLmZ1dGltZXNTeW5jKGZkLCBhdCwgbXQpXG4gICAgICAgICAgdGhyZXcgPSBmYWxzZVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmICh0aHJldykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZnMuY2xvc2VTeW5jKGZkKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXIpIHt9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldFxuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChmcy5mdXRpbWVzKSB7XG4gICAgICBmcy5sdXRpbWVzID0gZnVuY3Rpb24gKF9hLCBfYiwgX2MsIGNiKSB7IGlmIChjYikgcHJvY2Vzcy5uZXh0VGljayhjYikgfVxuICAgICAgZnMubHV0aW1lc1N5bmMgPSBmdW5jdGlvbiAoKSB7fVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNobW9kRml4IChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBtb2RlLCBjYikge1xuICAgICAgcmV0dXJuIG9yaWcuY2FsbChmcywgdGFyZ2V0LCBtb2RlLCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgICAgaWYgKGNob3duRXJPayhlcikpIGVyID0gbnVsbFxuICAgICAgICBpZiAoY2IpIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2htb2RGaXhTeW5jIChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBtb2RlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIG1vZGUpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBpZiAoIWNob3duRXJPayhlcikpIHRocm93IGVyXG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICBmdW5jdGlvbiBjaG93bkZpeCAob3JpZykge1xuICAgIGlmICghb3JpZykgcmV0dXJuIG9yaWdcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgdWlkLCBnaWQsIGNiKSB7XG4gICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIHVpZCwgZ2lkLCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgICAgaWYgKGNob3duRXJPayhlcikpIGVyID0gbnVsbFxuICAgICAgICBpZiAoY2IpIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hvd25GaXhTeW5jIChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCB1aWQsIGdpZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG9yaWcuY2FsbChmcywgdGFyZ2V0LCB1aWQsIGdpZClcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGlmICghY2hvd25Fck9rKGVyKSkgdGhyb3cgZXJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdGF0Rml4IChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIC8vIE9sZGVyIHZlcnNpb25zIG9mIE5vZGUgZXJyb25lb3VzbHkgcmV0dXJuZWQgc2lnbmVkIGludGVnZXJzIGZvclxuICAgIC8vIHVpZCArIGdpZC5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucywgY2IpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYiA9IG9wdGlvbnNcbiAgICAgICAgb3B0aW9ucyA9IG51bGxcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrIChlciwgc3RhdHMpIHtcbiAgICAgICAgaWYgKHN0YXRzKSB7XG4gICAgICAgICAgaWYgKHN0YXRzLnVpZCA8IDApIHN0YXRzLnVpZCArPSAweDEwMDAwMDAwMFxuICAgICAgICAgIGlmIChzdGF0cy5naWQgPCAwKSBzdGF0cy5naWQgKz0gMHgxMDAwMDAwMDBcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2IpIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zID8gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgICAgICA6IG9yaWcuY2FsbChmcywgdGFyZ2V0LCBjYWxsYmFjaylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdGF0Rml4U3luYyAob3JpZykge1xuICAgIGlmICghb3JpZykgcmV0dXJuIG9yaWdcbiAgICAvLyBPbGRlciB2ZXJzaW9ucyBvZiBOb2RlIGVycm9uZW91c2x5IHJldHVybmVkIHNpZ25lZCBpbnRlZ2VycyBmb3JcbiAgICAvLyB1aWQgKyBnaWQuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzdGF0cyA9IG9wdGlvbnMgPyBvcmlnLmNhbGwoZnMsIHRhcmdldCwgb3B0aW9ucylcbiAgICAgICAgOiBvcmlnLmNhbGwoZnMsIHRhcmdldClcbiAgICAgIGlmIChzdGF0cykge1xuICAgICAgICBpZiAoc3RhdHMudWlkIDwgMCkgc3RhdHMudWlkICs9IDB4MTAwMDAwMDAwXG4gICAgICAgIGlmIChzdGF0cy5naWQgPCAwKSBzdGF0cy5naWQgKz0gMHgxMDAwMDAwMDBcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGF0cztcbiAgICB9XG4gIH1cblxuICAvLyBFTk9TWVMgbWVhbnMgdGhhdCB0aGUgZnMgZG9lc24ndCBzdXBwb3J0IHRoZSBvcC4gSnVzdCBpZ25vcmVcbiAgLy8gdGhhdCwgYmVjYXVzZSBpdCBkb2Vzbid0IG1hdHRlci5cbiAgLy9cbiAgLy8gaWYgdGhlcmUncyBubyBnZXR1aWQsIG9yIGlmIGdldHVpZCgpIGlzIHNvbWV0aGluZyBvdGhlclxuICAvLyB0aGFuIDAsIGFuZCB0aGUgZXJyb3IgaXMgRUlOVkFMIG9yIEVQRVJNLCB0aGVuIGp1c3QgaWdub3JlXG4gIC8vIGl0LlxuICAvL1xuICAvLyBUaGlzIHNwZWNpZmljIGNhc2UgaXMgYSBzaWxlbnQgZmFpbHVyZSBpbiBjcCwgaW5zdGFsbCwgdGFyLFxuICAvLyBhbmQgbW9zdCBvdGhlciB1bml4IHRvb2xzIHRoYXQgbWFuYWdlIHBlcm1pc3Npb25zLlxuICAvL1xuICAvLyBXaGVuIHJ1bm5pbmcgYXMgcm9vdCwgb3IgaWYgb3RoZXIgdHlwZXMgb2YgZXJyb3JzIGFyZVxuICAvLyBlbmNvdW50ZXJlZCwgdGhlbiBpdCdzIHN0cmljdC5cbiAgZnVuY3Rpb24gY2hvd25Fck9rIChlcikge1xuICAgIGlmICghZXIpXG4gICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgaWYgKGVyLmNvZGUgPT09IFwiRU5PU1lTXCIpXG4gICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgdmFyIG5vbnJvb3QgPSAhcHJvY2Vzcy5nZXR1aWQgfHwgcHJvY2Vzcy5nZXR1aWQoKSAhPT0gMFxuICAgIGlmIChub25yb290KSB7XG4gICAgICBpZiAoZXIuY29kZSA9PT0gXCJFSU5WQUxcIiB8fCBlci5jb2RlID09PSBcIkVQRVJNXCIpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbiIsInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW1cblxubW9kdWxlLmV4cG9ydHMgPSBsZWdhY3lcblxuZnVuY3Rpb24gbGVnYWN5IChmcykge1xuICByZXR1cm4ge1xuICAgIFJlYWRTdHJlYW06IFJlYWRTdHJlYW0sXG4gICAgV3JpdGVTdHJlYW06IFdyaXRlU3RyZWFtXG4gIH1cblxuICBmdW5jdGlvbiBSZWFkU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRTdHJlYW0pKSByZXR1cm4gbmV3IFJlYWRTdHJlYW0ocGF0aCwgb3B0aW9ucyk7XG5cbiAgICBTdHJlYW0uY2FsbCh0aGlzKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5mZCA9IG51bGw7XG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuZmxhZ3MgPSAncic7XG4gICAgdGhpcy5tb2RlID0gNDM4OyAvKj0wNjY2Ki9cbiAgICB0aGlzLmJ1ZmZlclNpemUgPSA2NCAqIDEwMjQ7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIE1peGluIG9wdGlvbnMgaW50byB0aGlzXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVuY29kaW5nKSB0aGlzLnNldEVuY29kaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgaWYgKHRoaXMuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdGhpcy5zdGFydCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ3N0YXJ0IG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZW5kID0gSW5maW5pdHk7XG4gICAgICB9IGVsc2UgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdGhpcy5lbmQpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdlbmQgbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdGFydCA+IHRoaXMuZW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQgbXVzdCBiZSA8PSBlbmQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZkICE9PSBudWxsKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLl9yZWFkKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmcy5vcGVuKHRoaXMucGF0aCwgdGhpcy5mbGFncywgdGhpcy5tb2RlLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgc2VsZi5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNlbGYuZmQgPSBmZDtcbiAgICAgIHNlbGYuZW1pdCgnb3BlbicsIGZkKTtcbiAgICAgIHNlbGYuX3JlYWQoKTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gV3JpdGVTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGVTdHJlYW0pKSByZXR1cm4gbmV3IFdyaXRlU3RyZWFtKHBhdGgsIG9wdGlvbnMpO1xuXG4gICAgU3RyZWFtLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuZmQgPSBudWxsO1xuICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gICAgdGhpcy5mbGFncyA9ICd3JztcbiAgICB0aGlzLmVuY29kaW5nID0gJ2JpbmFyeSc7XG4gICAgdGhpcy5tb2RlID0gNDM4OyAvKj0wNjY2Ki9cbiAgICB0aGlzLmJ5dGVzV3JpdHRlbiA9IDA7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIE1peGluIG9wdGlvbnMgaW50byB0aGlzXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIHRoaXMuc3RhcnQpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdzdGFydCBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGFydCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydCBtdXN0IGJlID49IHplcm8nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0O1xuICAgIH1cblxuICAgIHRoaXMuYnVzeSA9IGZhbHNlO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG5cbiAgICBpZiAodGhpcy5mZCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fb3BlbiA9IGZzLm9wZW47XG4gICAgICB0aGlzLl9xdWV1ZS5wdXNoKFt0aGlzLl9vcGVuLCB0aGlzLnBhdGgsIHRoaXMuZmxhZ3MsIHRoaXMubW9kZSwgdW5kZWZpbmVkXSk7XG4gICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVxuXG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqLl9fcHJvdG9fX1xufVxuXG5mdW5jdGlvbiBjbG9uZSAob2JqKSB7XG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpXG4gICAgcmV0dXJuIG9ialxuXG4gIGlmIChvYmogaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgdmFyIGNvcHkgPSB7IF9fcHJvdG9fXzogZ2V0UHJvdG90eXBlT2Yob2JqKSB9XG4gIGVsc2VcbiAgICB2YXIgY29weSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb3B5LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpKVxuICB9KVxuXG4gIHJldHVybiBjb3B5XG59XG4iLCJ2YXIgZnMgPSByZXF1aXJlKCdmcycpXG52YXIgcG9seWZpbGxzID0gcmVxdWlyZSgnLi9wb2x5ZmlsbHMuanMnKVxudmFyIGxlZ2FjeSA9IHJlcXVpcmUoJy4vbGVnYWN5LXN0cmVhbXMuanMnKVxudmFyIGNsb25lID0gcmVxdWlyZSgnLi9jbG9uZS5qcycpXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gbm9kZSAwLnggcG9seWZpbGwgKi9cbnZhciBncmFjZWZ1bFF1ZXVlXG52YXIgcHJldmlvdXNTeW1ib2xcblxuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgLSBub2RlIDAueCBwb2x5ZmlsbCAqL1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5mb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgZ3JhY2VmdWxRdWV1ZSA9IFN5bWJvbC5mb3IoJ2dyYWNlZnVsLWZzLnF1ZXVlJylcbiAgLy8gVGhpcyBpcyB1c2VkIGluIHRlc3RpbmcgYnkgZnV0dXJlIHZlcnNpb25zXG4gIHByZXZpb3VzU3ltYm9sID0gU3ltYm9sLmZvcignZ3JhY2VmdWwtZnMucHJldmlvdXMnKVxufSBlbHNlIHtcbiAgZ3JhY2VmdWxRdWV1ZSA9ICdfX19ncmFjZWZ1bC1mcy5xdWV1ZSdcbiAgcHJldmlvdXNTeW1ib2wgPSAnX19fZ3JhY2VmdWwtZnMucHJldmlvdXMnXG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuZnVuY3Rpb24gcHVibGlzaFF1ZXVlKGNvbnRleHQsIHF1ZXVlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb250ZXh0LCBncmFjZWZ1bFF1ZXVlLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBxdWV1ZVxuICAgIH1cbiAgfSlcbn1cblxudmFyIGRlYnVnID0gbm9vcFxuaWYgKHV0aWwuZGVidWdsb2cpXG4gIGRlYnVnID0gdXRpbC5kZWJ1Z2xvZygnZ2ZzNCcpXG5lbHNlIGlmICgvXFxiZ2ZzNFxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJykpXG4gIGRlYnVnID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG0gPSB1dGlsLmZvcm1hdC5hcHBseSh1dGlsLCBhcmd1bWVudHMpXG4gICAgbSA9ICdHRlM0OiAnICsgbS5zcGxpdCgvXFxuLykuam9pbignXFxuR0ZTNDogJylcbiAgICBjb25zb2xlLmVycm9yKG0pXG4gIH1cblxuLy8gT25jZSB0aW1lIGluaXRpYWxpemF0aW9uXG5pZiAoIWZzW2dyYWNlZnVsUXVldWVdKSB7XG4gIC8vIFRoaXMgcXVldWUgY2FuIGJlIHNoYXJlZCBieSBtdWx0aXBsZSBsb2FkZWQgaW5zdGFuY2VzXG4gIHZhciBxdWV1ZSA9IGdsb2JhbFtncmFjZWZ1bFF1ZXVlXSB8fCBbXVxuICBwdWJsaXNoUXVldWUoZnMsIHF1ZXVlKVxuXG4gIC8vIFBhdGNoIGZzLmNsb3NlL2Nsb3NlU3luYyB0byBzaGFyZWQgcXVldWUgdmVyc2lvbiwgYmVjYXVzZSB3ZSBuZWVkXG4gIC8vIHRvIHJldHJ5KCkgd2hlbmV2ZXIgYSBjbG9zZSBoYXBwZW5zICphbnl3aGVyZSogaW4gdGhlIHByb2dyYW0uXG4gIC8vIFRoaXMgaXMgZXNzZW50aWFsIHdoZW4gbXVsdGlwbGUgZ3JhY2VmdWwtZnMgaW5zdGFuY2VzIGFyZVxuICAvLyBpbiBwbGF5IGF0IHRoZSBzYW1lIHRpbWUuXG4gIGZzLmNsb3NlID0gKGZ1bmN0aW9uIChmcyRjbG9zZSkge1xuICAgIGZ1bmN0aW9uIGNsb3NlIChmZCwgY2IpIHtcbiAgICAgIHJldHVybiBmcyRjbG9zZS5jYWxsKGZzLCBmZCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIHVzZXMgdGhlIGdyYWNlZnVsLWZzIHNoYXJlZCBxdWV1ZVxuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIHJlc2V0UXVldWUoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9KVxuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbG9zZSwgcHJldmlvdXNTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmcyRjbG9zZVxuICAgIH0pXG4gICAgcmV0dXJuIGNsb3NlXG4gIH0pKGZzLmNsb3NlKVxuXG4gIGZzLmNsb3NlU3luYyA9IChmdW5jdGlvbiAoZnMkY2xvc2VTeW5jKSB7XG4gICAgZnVuY3Rpb24gY2xvc2VTeW5jIChmZCkge1xuICAgICAgLy8gVGhpcyBmdW5jdGlvbiB1c2VzIHRoZSBncmFjZWZ1bC1mcyBzaGFyZWQgcXVldWVcbiAgICAgIGZzJGNsb3NlU3luYy5hcHBseShmcywgYXJndW1lbnRzKVxuICAgICAgcmVzZXRRdWV1ZSgpXG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb3NlU3luYywgcHJldmlvdXNTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmcyRjbG9zZVN5bmNcbiAgICB9KVxuICAgIHJldHVybiBjbG9zZVN5bmNcbiAgfSkoZnMuY2xvc2VTeW5jKVxuXG4gIGlmICgvXFxiZ2ZzNFxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJykpIHtcbiAgICBwcm9jZXNzLm9uKCdleGl0JywgZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zyhmc1tncmFjZWZ1bFF1ZXVlXSlcbiAgICAgIHJlcXVpcmUoJ2Fzc2VydCcpLmVxdWFsKGZzW2dyYWNlZnVsUXVldWVdLmxlbmd0aCwgMClcbiAgICB9KVxuICB9XG59XG5cbmlmICghZ2xvYmFsW2dyYWNlZnVsUXVldWVdKSB7XG4gIHB1Ymxpc2hRdWV1ZShnbG9iYWwsIGZzW2dyYWNlZnVsUXVldWVdKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaChjbG9uZShmcykpXG5pZiAocHJvY2Vzcy5lbnYuVEVTVF9HUkFDRUZVTF9GU19HTE9CQUxfUEFUQ0ggJiYgIWZzLl9fcGF0Y2hlZCkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcGF0Y2goZnMpXG4gICAgZnMuX19wYXRjaGVkID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcGF0Y2ggKGZzKSB7XG4gIC8vIEV2ZXJ5dGhpbmcgdGhhdCByZWZlcmVuY2VzIHRoZSBvcGVuKCkgZnVuY3Rpb24gbmVlZHMgdG8gYmUgaW4gaGVyZVxuICBwb2x5ZmlsbHMoZnMpXG4gIGZzLmdyYWNlZnVsaWZ5ID0gcGF0Y2hcblxuICBmcy5jcmVhdGVSZWFkU3RyZWFtID0gY3JlYXRlUmVhZFN0cmVhbVxuICBmcy5jcmVhdGVXcml0ZVN0cmVhbSA9IGNyZWF0ZVdyaXRlU3RyZWFtXG4gIHZhciBmcyRyZWFkRmlsZSA9IGZzLnJlYWRGaWxlXG4gIGZzLnJlYWRGaWxlID0gcmVhZEZpbGVcbiAgZnVuY3Rpb24gcmVhZEZpbGUgKHBhdGgsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBvcHRpb25zLCBvcHRpb25zID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJHJlYWRGaWxlKHBhdGgsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kcmVhZEZpbGUgKHBhdGgsIG9wdGlvbnMsIGNiLCBzdGFydFRpbWUpIHtcbiAgICAgIHJldHVybiBmcyRyZWFkRmlsZShwYXRoLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJHJlYWRGaWxlLCBbcGF0aCwgb3B0aW9ucywgY2JdLCBlcnIsIHN0YXJ0VGltZSB8fCBEYXRlLm5vdygpLCBEYXRlLm5vdygpXSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICB2YXIgZnMkd3JpdGVGaWxlID0gZnMud3JpdGVGaWxlXG4gIGZzLndyaXRlRmlsZSA9IHdyaXRlRmlsZVxuICBmdW5jdGlvbiB3cml0ZUZpbGUgKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBvcHRpb25zLCBvcHRpb25zID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJHdyaXRlRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBjYilcblxuICAgIGZ1bmN0aW9uIGdvJHdyaXRlRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IsIHN0YXJ0VGltZSkge1xuICAgICAgcmV0dXJuIGZzJHdyaXRlRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJHdyaXRlRmlsZSwgW3BhdGgsIGRhdGEsIG9wdGlvbnMsIGNiXSwgZXJyLCBzdGFydFRpbWUgfHwgRGF0ZS5ub3coKSwgRGF0ZS5ub3coKV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgdmFyIGZzJGFwcGVuZEZpbGUgPSBmcy5hcHBlbmRGaWxlXG4gIGlmIChmcyRhcHBlbmRGaWxlKVxuICAgIGZzLmFwcGVuZEZpbGUgPSBhcHBlbmRGaWxlXG4gIGZ1bmN0aW9uIGFwcGVuZEZpbGUgKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBvcHRpb25zLCBvcHRpb25zID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJGFwcGVuZEZpbGUocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpXG5cbiAgICBmdW5jdGlvbiBnbyRhcHBlbmRGaWxlIChwYXRoLCBkYXRhLCBvcHRpb25zLCBjYiwgc3RhcnRUaW1lKSB7XG4gICAgICByZXR1cm4gZnMkYXBwZW5kRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJGFwcGVuZEZpbGUsIFtwYXRoLCBkYXRhLCBvcHRpb25zLCBjYl0sIGVyciwgc3RhcnRUaW1lIHx8IERhdGUubm93KCksIERhdGUubm93KCldKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyRjb3B5RmlsZSA9IGZzLmNvcHlGaWxlXG4gIGlmIChmcyRjb3B5RmlsZSlcbiAgICBmcy5jb3B5RmlsZSA9IGNvcHlGaWxlXG4gIGZ1bmN0aW9uIGNvcHlGaWxlIChzcmMsIGRlc3QsIGZsYWdzLCBjYikge1xuICAgIGlmICh0eXBlb2YgZmxhZ3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gZmxhZ3NcbiAgICAgIGZsYWdzID0gMFxuICAgIH1cbiAgICByZXR1cm4gZ28kY29weUZpbGUoc3JjLCBkZXN0LCBmbGFncywgY2IpXG5cbiAgICBmdW5jdGlvbiBnbyRjb3B5RmlsZSAoc3JjLCBkZXN0LCBmbGFncywgY2IsIHN0YXJ0VGltZSkge1xuICAgICAgcmV0dXJuIGZzJGNvcHlGaWxlKHNyYywgZGVzdCwgZmxhZ3MsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kY29weUZpbGUsIFtzcmMsIGRlc3QsIGZsYWdzLCBjYl0sIGVyciwgc3RhcnRUaW1lIHx8IERhdGUubm93KCksIERhdGUubm93KCldKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyRyZWFkZGlyID0gZnMucmVhZGRpclxuICBmcy5yZWFkZGlyID0gcmVhZGRpclxuICB2YXIgbm9SZWFkZGlyT3B0aW9uVmVyc2lvbnMgPSAvXnZbMC01XVxcLi9cbiAgZnVuY3Rpb24gcmVhZGRpciAocGF0aCwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG9wdGlvbnMsIG9wdGlvbnMgPSBudWxsXG5cbiAgICB2YXIgZ28kcmVhZGRpciA9IG5vUmVhZGRpck9wdGlvblZlcnNpb25zLnRlc3QocHJvY2Vzcy52ZXJzaW9uKVxuICAgICAgPyBmdW5jdGlvbiBnbyRyZWFkZGlyIChwYXRoLCBvcHRpb25zLCBjYiwgc3RhcnRUaW1lKSB7XG4gICAgICAgIHJldHVybiBmcyRyZWFkZGlyKHBhdGgsIGZzJHJlYWRkaXJDYWxsYmFjayhcbiAgICAgICAgICBwYXRoLCBvcHRpb25zLCBjYiwgc3RhcnRUaW1lXG4gICAgICAgICkpXG4gICAgICB9XG4gICAgICA6IGZ1bmN0aW9uIGdvJHJlYWRkaXIgKHBhdGgsIG9wdGlvbnMsIGNiLCBzdGFydFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGZzJHJlYWRkaXIocGF0aCwgb3B0aW9ucywgZnMkcmVhZGRpckNhbGxiYWNrKFxuICAgICAgICAgIHBhdGgsIG9wdGlvbnMsIGNiLCBzdGFydFRpbWVcbiAgICAgICAgKSlcbiAgICAgIH1cblxuICAgIHJldHVybiBnbyRyZWFkZGlyKHBhdGgsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZnMkcmVhZGRpckNhbGxiYWNrIChwYXRoLCBvcHRpb25zLCBjYiwgc3RhcnRUaW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGVyciwgZmlsZXMpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbXG4gICAgICAgICAgICBnbyRyZWFkZGlyLFxuICAgICAgICAgICAgW3BhdGgsIG9wdGlvbnMsIGNiXSxcbiAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgIHN0YXJ0VGltZSB8fCBEYXRlLm5vdygpLFxuICAgICAgICAgICAgRGF0ZS5ub3coKVxuICAgICAgICAgIF0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChmaWxlcyAmJiBmaWxlcy5zb3J0KVxuICAgICAgICAgICAgZmlsZXMuc29ydCgpXG5cbiAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IuY2FsbCh0aGlzLCBlcnIsIGZpbGVzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MudmVyc2lvbi5zdWJzdHIoMCwgNCkgPT09ICd2MC44Jykge1xuICAgIHZhciBsZWdTdHJlYW1zID0gbGVnYWN5KGZzKVxuICAgIFJlYWRTdHJlYW0gPSBsZWdTdHJlYW1zLlJlYWRTdHJlYW1cbiAgICBXcml0ZVN0cmVhbSA9IGxlZ1N0cmVhbXMuV3JpdGVTdHJlYW1cbiAgfVxuXG4gIHZhciBmcyRSZWFkU3RyZWFtID0gZnMuUmVhZFN0cmVhbVxuICBpZiAoZnMkUmVhZFN0cmVhbSkge1xuICAgIFJlYWRTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShmcyRSZWFkU3RyZWFtLnByb3RvdHlwZSlcbiAgICBSZWFkU3RyZWFtLnByb3RvdHlwZS5vcGVuID0gUmVhZFN0cmVhbSRvcGVuXG4gIH1cblxuICB2YXIgZnMkV3JpdGVTdHJlYW0gPSBmcy5Xcml0ZVN0cmVhbVxuICBpZiAoZnMkV3JpdGVTdHJlYW0pIHtcbiAgICBXcml0ZVN0cmVhbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGZzJFdyaXRlU3RyZWFtLnByb3RvdHlwZSlcbiAgICBXcml0ZVN0cmVhbS5wcm90b3R5cGUub3BlbiA9IFdyaXRlU3RyZWFtJG9wZW5cbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmcywgJ1JlYWRTdHJlYW0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gUmVhZFN0cmVhbVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBSZWFkU3RyZWFtID0gdmFsXG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnMsICdXcml0ZVN0cmVhbScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBXcml0ZVN0cmVhbVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBXcml0ZVN0cmVhbSA9IHZhbFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcblxuICAvLyBsZWdhY3kgbmFtZXNcbiAgdmFyIEZpbGVSZWFkU3RyZWFtID0gUmVhZFN0cmVhbVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnMsICdGaWxlUmVhZFN0cmVhbScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBGaWxlUmVhZFN0cmVhbVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBGaWxlUmVhZFN0cmVhbSA9IHZhbFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcbiAgdmFyIEZpbGVXcml0ZVN0cmVhbSA9IFdyaXRlU3RyZWFtXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmcywgJ0ZpbGVXcml0ZVN0cmVhbScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBGaWxlV3JpdGVTdHJlYW1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgRmlsZVdyaXRlU3RyZWFtID0gdmFsXG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxuXG4gIGZ1bmN0aW9uIFJlYWRTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFJlYWRTdHJlYW0pXG4gICAgICByZXR1cm4gZnMkUmVhZFN0cmVhbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0aGlzXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIFJlYWRTdHJlYW0uYXBwbHkoT2JqZWN0LmNyZWF0ZShSZWFkU3RyZWFtLnByb3RvdHlwZSksIGFyZ3VtZW50cylcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlYWRTdHJlYW0kb3BlbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgb3Blbih0aGF0LnBhdGgsIHRoYXQuZmxhZ3MsIHRoYXQubW9kZSwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKHRoYXQuYXV0b0Nsb3NlKVxuICAgICAgICAgIHRoYXQuZGVzdHJveSgpXG5cbiAgICAgICAgdGhhdC5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoYXQuZmQgPSBmZFxuICAgICAgICB0aGF0LmVtaXQoJ29wZW4nLCBmZClcbiAgICAgICAgdGhhdC5yZWFkKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gV3JpdGVTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFdyaXRlU3RyZWFtKVxuICAgICAgcmV0dXJuIGZzJFdyaXRlU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRoaXNcbiAgICBlbHNlXG4gICAgICByZXR1cm4gV3JpdGVTdHJlYW0uYXBwbHkoT2JqZWN0LmNyZWF0ZShXcml0ZVN0cmVhbS5wcm90b3R5cGUpLCBhcmd1bWVudHMpXG4gIH1cblxuICBmdW5jdGlvbiBXcml0ZVN0cmVhbSRvcGVuICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICBvcGVuKHRoYXQucGF0aCwgdGhhdC5mbGFncywgdGhhdC5tb2RlLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGF0LmRlc3Ryb3koKVxuICAgICAgICB0aGF0LmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhhdC5mZCA9IGZkXG4gICAgICAgIHRoYXQuZW1pdCgnb3BlbicsIGZkKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSZWFkU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBmcy5SZWFkU3RyZWFtKHBhdGgsIG9wdGlvbnMpXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVXcml0ZVN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgZnMuV3JpdGVTdHJlYW0ocGF0aCwgb3B0aW9ucylcbiAgfVxuXG4gIHZhciBmcyRvcGVuID0gZnMub3BlblxuICBmcy5vcGVuID0gb3BlblxuICBmdW5jdGlvbiBvcGVuIChwYXRoLCBmbGFncywgbW9kZSwgY2IpIHtcbiAgICBpZiAodHlwZW9mIG1vZGUgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG1vZGUsIG1vZGUgPSBudWxsXG5cbiAgICByZXR1cm4gZ28kb3BlbihwYXRoLCBmbGFncywgbW9kZSwgY2IpXG5cbiAgICBmdW5jdGlvbiBnbyRvcGVuIChwYXRoLCBmbGFncywgbW9kZSwgY2IsIHN0YXJ0VGltZSkge1xuICAgICAgcmV0dXJuIGZzJG9wZW4ocGF0aCwgZmxhZ3MsIG1vZGUsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJG9wZW4sIFtwYXRoLCBmbGFncywgbW9kZSwgY2JdLCBlcnIsIHN0YXJ0VGltZSB8fCBEYXRlLm5vdygpLCBEYXRlLm5vdygpXSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnNcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZSAoZWxlbSkge1xuICBkZWJ1ZygnRU5RVUVVRScsIGVsZW1bMF0ubmFtZSwgZWxlbVsxXSlcbiAgZnNbZ3JhY2VmdWxRdWV1ZV0ucHVzaChlbGVtKVxuICByZXRyeSgpXG59XG5cbi8vIGtlZXAgdHJhY2sgb2YgdGhlIHRpbWVvdXQgYmV0d2VlbiByZXRyeSgpIGNhbGxzXG52YXIgcmV0cnlUaW1lclxuXG4vLyByZXNldCB0aGUgc3RhcnRUaW1lIGFuZCBsYXN0VGltZSB0byBub3dcbi8vIHRoaXMgcmVzZXRzIHRoZSBzdGFydCBvZiB0aGUgNjAgc2Vjb25kIG92ZXJhbGwgdGltZW91dCBhcyB3ZWxsIGFzIHRoZVxuLy8gZGVsYXkgYmV0d2VlbiBhdHRlbXB0cyBzbyB0aGF0IHdlJ2xsIHJldHJ5IHRoZXNlIGpvYnMgc29vbmVyXG5mdW5jdGlvbiByZXNldFF1ZXVlICgpIHtcbiAgdmFyIG5vdyA9IERhdGUubm93KClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmc1tncmFjZWZ1bFF1ZXVlXS5sZW5ndGg7ICsraSkge1xuICAgIC8vIGVudHJpZXMgdGhhdCBhcmUgb25seSBhIGxlbmd0aCBvZiAyIGFyZSBmcm9tIGFuIG9sZGVyIHZlcnNpb24sIGRvbid0XG4gICAgLy8gYm90aGVyIG1vZGlmeWluZyB0aG9zZSBzaW5jZSB0aGV5J2xsIGJlIHJldHJpZWQgYW55d2F5LlxuICAgIGlmIChmc1tncmFjZWZ1bFF1ZXVlXVtpXS5sZW5ndGggPiAyKSB7XG4gICAgICBmc1tncmFjZWZ1bFF1ZXVlXVtpXVszXSA9IG5vdyAvLyBzdGFydFRpbWVcbiAgICAgIGZzW2dyYWNlZnVsUXVldWVdW2ldWzRdID0gbm93IC8vIGxhc3RUaW1lXG4gICAgfVxuICB9XG4gIC8vIGNhbGwgcmV0cnkgdG8gbWFrZSBzdXJlIHdlJ3JlIGFjdGl2ZWx5IHByb2Nlc3NpbmcgdGhlIHF1ZXVlXG4gIHJldHJ5KClcbn1cblxuZnVuY3Rpb24gcmV0cnkgKCkge1xuICAvLyBjbGVhciB0aGUgdGltZXIgYW5kIHJlbW92ZSBpdCB0byBoZWxwIHByZXZlbnQgdW5pbnRlbmRlZCBjb25jdXJyZW5jeVxuICBjbGVhclRpbWVvdXQocmV0cnlUaW1lcilcbiAgcmV0cnlUaW1lciA9IHVuZGVmaW5lZFxuXG4gIGlmIChmc1tncmFjZWZ1bFF1ZXVlXS5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuXG5cbiAgdmFyIGVsZW0gPSBmc1tncmFjZWZ1bFF1ZXVlXS5zaGlmdCgpXG4gIHZhciBmbiA9IGVsZW1bMF1cbiAgdmFyIGFyZ3MgPSBlbGVtWzFdXG4gIC8vIHRoZXNlIGl0ZW1zIG1heSBiZSB1bnNldCBpZiB0aGV5IHdlcmUgYWRkZWQgYnkgYW4gb2xkZXIgZ3JhY2VmdWwtZnNcbiAgdmFyIGVyciA9IGVsZW1bMl1cbiAgdmFyIHN0YXJ0VGltZSA9IGVsZW1bM11cbiAgdmFyIGxhc3RUaW1lID0gZWxlbVs0XVxuXG4gIC8vIGlmIHdlIGRvbid0IGhhdmUgYSBzdGFydFRpbWUgd2UgaGF2ZSBubyB3YXkgb2Yga25vd2luZyBpZiB3ZSd2ZSB3YWl0ZWRcbiAgLy8gbG9uZyBlbm91Z2gsIHNvIGdvIGFoZWFkIGFuZCByZXRyeSB0aGlzIGl0ZW0gbm93XG4gIGlmIChzdGFydFRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIGRlYnVnKCdSRVRSWScsIGZuLm5hbWUsIGFyZ3MpXG4gICAgZm4uYXBwbHkobnVsbCwgYXJncylcbiAgfSBlbHNlIGlmIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lID49IDYwMDAwKSB7XG4gICAgLy8gaXQncyBiZWVuIG1vcmUgdGhhbiA2MCBzZWNvbmRzIHRvdGFsLCBiYWlsIG5vd1xuICAgIGRlYnVnKCdUSU1FT1VUJywgZm4ubmFtZSwgYXJncylcbiAgICB2YXIgY2IgPSBhcmdzLnBvcCgpXG4gICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiLmNhbGwobnVsbCwgZXJyKVxuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBhbW91bnQgb2YgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGF0dGVtcHQgYW5kIHJpZ2h0IG5vd1xuICAgIHZhciBzaW5jZUF0dGVtcHQgPSBEYXRlLm5vdygpIC0gbGFzdFRpbWVcbiAgICAvLyB0aGUgYW1vdW50IG9mIHRpbWUgYmV0d2VlbiB3aGVuIHdlIGZpcnN0IHRyaWVkLCBhbmQgd2hlbiB3ZSBsYXN0IHRyaWVkXG4gICAgLy8gcm91bmRlZCB1cCB0byBhdCBsZWFzdCAxXG4gICAgdmFyIHNpbmNlU3RhcnQgPSBNYXRoLm1heChsYXN0VGltZSAtIHN0YXJ0VGltZSwgMSlcbiAgICAvLyBiYWNrb2ZmLiB3YWl0IGxvbmdlciB0aGFuIHRoZSB0b3RhbCB0aW1lIHdlJ3ZlIGJlZW4gcmV0cnlpbmcsIGJ1dCBvbmx5XG4gICAgLy8gdXAgdG8gYSBtYXhpbXVtIG9mIDEwMG1zXG4gICAgdmFyIGRlc2lyZWREZWxheSA9IE1hdGgubWluKHNpbmNlU3RhcnQgKiAxLjIsIDEwMClcbiAgICAvLyBpdCdzIGJlZW4gbG9uZyBlbm91Z2ggc2luY2UgdGhlIGxhc3QgcmV0cnksIGRvIGl0IGFnYWluXG4gICAgaWYgKHNpbmNlQXR0ZW1wdCA+PSBkZXNpcmVkRGVsYXkpIHtcbiAgICAgIGRlYnVnKCdSRVRSWScsIGZuLm5hbWUsIGFyZ3MpXG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChbc3RhcnRUaW1lXSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIHdlIGNhbid0IGRvIHRoaXMgam9iIHlldCwgcHVzaCBpdCB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuICAgICAgLy8gYW5kIGxldCB0aGUgbmV4dCBpdGVyYXRpb24gY2hlY2sgYWdhaW5cbiAgICAgIGZzW2dyYWNlZnVsUXVldWVdLnB1c2goZWxlbSlcbiAgICB9XG4gIH1cblxuICAvLyBzY2hlZHVsZSBvdXIgbmV4dCBydW4gaWYgb25lIGlzbid0IGFscmVhZHkgc2NoZWR1bGVkXG4gIGlmIChyZXRyeVRpbWVyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXRyeVRpbWVyID0gc2V0VGltZW91dChyZXRyeSwgMClcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG4vLyBUaGlzIGlzIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbm9ybWFsaXplL216XG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNiBKb25hdGhhbiBPbmcgbWVAam9uZ2xlYmVycnkuY29tIGFuZCBDb250cmlidXRvcnNcbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuXG5jb25zdCBhcGkgPSBbXG4gICdhY2Nlc3MnLFxuICAnYXBwZW5kRmlsZScsXG4gICdjaG1vZCcsXG4gICdjaG93bicsXG4gICdjbG9zZScsXG4gICdjb3B5RmlsZScsXG4gICdmY2htb2QnLFxuICAnZmNob3duJyxcbiAgJ2ZkYXRhc3luYycsXG4gICdmc3RhdCcsXG4gICdmc3luYycsXG4gICdmdHJ1bmNhdGUnLFxuICAnZnV0aW1lcycsXG4gICdsY2htb2QnLFxuICAnbGNob3duJyxcbiAgJ2xpbmsnLFxuICAnbHN0YXQnLFxuICAnbWtkaXInLFxuICAnbWtkdGVtcCcsXG4gICdvcGVuJyxcbiAgJ29wZW5kaXInLFxuICAncmVhZGRpcicsXG4gICdyZWFkRmlsZScsXG4gICdyZWFkbGluaycsXG4gICdyZWFscGF0aCcsXG4gICdyZW5hbWUnLFxuICAncm0nLFxuICAncm1kaXInLFxuICAnc3RhdCcsXG4gICdzeW1saW5rJyxcbiAgJ3RydW5jYXRlJyxcbiAgJ3VubGluaycsXG4gICd1dGltZXMnLFxuICAnd3JpdGVGaWxlJ1xuXS5maWx0ZXIoa2V5ID0+IHtcbiAgLy8gU29tZSBjb21tYW5kcyBhcmUgbm90IGF2YWlsYWJsZSBvbiBzb21lIHN5c3RlbXMuIEV4OlxuICAvLyBmcy5jcCB3YXMgYWRkZWQgaW4gTm9kZS5qcyB2MTYuNy4wXG4gIC8vIGZzLmxjaG93biBpcyBub3QgYXZhaWxhYmxlIG9uIGF0IGxlYXN0IHNvbWUgTGludXhcbiAgcmV0dXJuIHR5cGVvZiBmc1trZXldID09PSAnZnVuY3Rpb24nXG59KVxuXG4vLyBFeHBvcnQgY2xvbmVkIGZzOlxuT2JqZWN0LmFzc2lnbihleHBvcnRzLCBmcylcblxuLy8gVW5pdmVyc2FsaWZ5IGFzeW5jIG1ldGhvZHM6XG5hcGkuZm9yRWFjaChtZXRob2QgPT4ge1xuICBleHBvcnRzW21ldGhvZF0gPSB1KGZzW21ldGhvZF0pXG59KVxuXG4vLyBXZSBkaWZmZXIgZnJvbSBtei9mcyBpbiB0aGF0IHdlIHN0aWxsIHNoaXAgdGhlIG9sZCwgYnJva2VuLCBmcy5leGlzdHMoKVxuLy8gc2luY2Ugd2UgYXJlIGEgZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgdGhlIG5hdGl2ZSBtb2R1bGVcbmV4cG9ydHMuZXhpc3RzID0gZnVuY3Rpb24gKGZpbGVuYW1lLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZzLmV4aXN0cyhmaWxlbmFtZSwgY2FsbGJhY2spXG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHJldHVybiBmcy5leGlzdHMoZmlsZW5hbWUsIHJlc29sdmUpXG4gIH0pXG59XG5cbi8vIGZzLnJlYWQoKSwgZnMud3JpdGUoKSwgZnMucmVhZHYoKSwgJiBmcy53cml0ZXYoKSBuZWVkIHNwZWNpYWwgdHJlYXRtZW50IGR1ZSB0byBtdWx0aXBsZSBjYWxsYmFjayBhcmdzXG5cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnMucmVhZChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKVxuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnMucmVhZChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIChlcnIsIGJ5dGVzUmVhZCwgYnVmZmVyKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgIHJlc29sdmUoeyBieXRlc1JlYWQsIGJ1ZmZlciB9KVxuICAgIH0pXG4gIH0pXG59XG5cbi8vIEZ1bmN0aW9uIHNpZ25hdHVyZSBjYW4gYmVcbi8vIGZzLndyaXRlKGZkLCBidWZmZXJbLCBvZmZzZXRbLCBsZW5ndGhbLCBwb3NpdGlvbl1dXSwgY2FsbGJhY2spXG4vLyBPUlxuLy8gZnMud3JpdGUoZmQsIHN0cmluZ1ssIHBvc2l0aW9uWywgZW5jb2RpbmddXSwgY2FsbGJhY2spXG4vLyBXZSBuZWVkIHRvIGhhbmRsZSBib3RoIGNhc2VzLCBzbyB3ZSB1c2UgLi4uYXJnc1xuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChmZCwgYnVmZmVyLCAuLi5hcmdzKSB7XG4gIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZzLndyaXRlKGZkLCBidWZmZXIsIC4uLmFyZ3MpXG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZzLndyaXRlKGZkLCBidWZmZXIsIC4uLmFyZ3MsIChlcnIsIGJ5dGVzV3JpdHRlbiwgYnVmZmVyKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgIHJlc29sdmUoeyBieXRlc1dyaXR0ZW4sIGJ1ZmZlciB9KVxuICAgIH0pXG4gIH0pXG59XG5cbi8vIEZ1bmN0aW9uIHNpZ25hdHVyZSBpc1xuLy8gcy5yZWFkdihmZCwgYnVmZmVyc1ssIHBvc2l0aW9uXSwgY2FsbGJhY2spXG4vLyBXZSBuZWVkIHRvIGhhbmRsZSB0aGUgb3B0aW9uYWwgYXJnLCBzbyB3ZSB1c2UgLi4uYXJnc1xuZXhwb3J0cy5yZWFkdiA9IGZ1bmN0aW9uIChmZCwgYnVmZmVycywgLi4uYXJncykge1xuICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmcy5yZWFkdihmZCwgYnVmZmVycywgLi4uYXJncylcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnMucmVhZHYoZmQsIGJ1ZmZlcnMsIC4uLmFyZ3MsIChlcnIsIGJ5dGVzUmVhZCwgYnVmZmVycykgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICByZXNvbHZlKHsgYnl0ZXNSZWFkLCBidWZmZXJzIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuLy8gRnVuY3Rpb24gc2lnbmF0dXJlIGlzXG4vLyBzLndyaXRldihmZCwgYnVmZmVyc1ssIHBvc2l0aW9uXSwgY2FsbGJhY2spXG4vLyBXZSBuZWVkIHRvIGhhbmRsZSB0aGUgb3B0aW9uYWwgYXJnLCBzbyB3ZSB1c2UgLi4uYXJnc1xuZXhwb3J0cy53cml0ZXYgPSBmdW5jdGlvbiAoZmQsIGJ1ZmZlcnMsIC4uLmFyZ3MpIHtcbiAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnMud3JpdGV2KGZkLCBidWZmZXJzLCAuLi5hcmdzKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmcy53cml0ZXYoZmQsIGJ1ZmZlcnMsIC4uLmFyZ3MsIChlcnIsIGJ5dGVzV3JpdHRlbiwgYnVmZmVycykgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICByZXNvbHZlKHsgYnl0ZXNXcml0dGVuLCBidWZmZXJzIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuLy8gZnMucmVhbHBhdGgubmF0aXZlIHNvbWV0aW1lcyBub3QgYXZhaWxhYmxlIGlmIGZzIGlzIG1vbmtleS1wYXRjaGVkXG5pZiAodHlwZW9mIGZzLnJlYWxwYXRoLm5hdGl2ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICBleHBvcnRzLnJlYWxwYXRoLm5hdGl2ZSA9IHUoZnMucmVhbHBhdGgubmF0aXZlKVxufSBlbHNlIHtcbiAgcHJvY2Vzcy5lbWl0V2FybmluZyhcbiAgICAnZnMucmVhbHBhdGgubmF0aXZlIGlzIG5vdCBhIGZ1bmN0aW9uLiBJcyBmcyBiZWluZyBtb25rZXktcGF0Y2hlZD8nLFxuICAgICdXYXJuaW5nJywgJ2ZzLWV4dHJhLVdBUk4wMDAzJ1xuICApXG59XG4iLCIvLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9tYWtlLWRpclxuLy8gQ29weXJpZ2h0IChjKSBTaW5kcmUgU29yaHVzIDxzaW5kcmVzb3JodXNAZ21haWwuY29tPiAoc2luZHJlc29yaHVzLmNvbSlcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuJ3VzZSBzdHJpY3QnXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvODk4N1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2xpYnV2L2xpYnV2L3B1bGwvMTA4OFxubW9kdWxlLmV4cG9ydHMuY2hlY2tQYXRoID0gZnVuY3Rpb24gY2hlY2tQYXRoIChwdGgpIHtcbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICBjb25zdCBwYXRoSGFzSW52YWxpZFdpbkNoYXJhY3RlcnMgPSAvWzw+OlwifD8qXS8udGVzdChwdGgucmVwbGFjZShwYXRoLnBhcnNlKHB0aCkucm9vdCwgJycpKVxuXG4gICAgaWYgKHBhdGhIYXNJbnZhbGlkV2luQ2hhcmFjdGVycykge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYFBhdGggY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzOiAke3B0aH1gKVxuICAgICAgZXJyb3IuY29kZSA9ICdFSU5WQUwnXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL2ZzJylcbmNvbnN0IHsgY2hlY2tQYXRoIH0gPSByZXF1aXJlKCcuL3V0aWxzJylcblxuY29uc3QgZ2V0TW9kZSA9IG9wdGlvbnMgPT4ge1xuICBjb25zdCBkZWZhdWx0cyA9IHsgbW9kZTogMG83NzcgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSByZXR1cm4gb3B0aW9uc1xuICByZXR1cm4gKHsgLi4uZGVmYXVsdHMsIC4uLm9wdGlvbnMgfSkubW9kZVxufVxuXG5tb2R1bGUuZXhwb3J0cy5tYWtlRGlyID0gYXN5bmMgKGRpciwgb3B0aW9ucykgPT4ge1xuICBjaGVja1BhdGgoZGlyKVxuXG4gIHJldHVybiBmcy5ta2RpcihkaXIsIHtcbiAgICBtb2RlOiBnZXRNb2RlKG9wdGlvbnMpLFxuICAgIHJlY3Vyc2l2ZTogdHJ1ZVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cy5tYWtlRGlyU3luYyA9IChkaXIsIG9wdGlvbnMpID0+IHtcbiAgY2hlY2tQYXRoKGRpcilcblxuICByZXR1cm4gZnMubWtkaXJTeW5jKGRpciwge1xuICAgIG1vZGU6IGdldE1vZGUob3B0aW9ucyksXG4gICAgcmVjdXJzaXZlOiB0cnVlXG4gIH0pXG59XG4iLCIndXNlIHN0cmljdCdcbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tUHJvbWlzZVxuY29uc3QgeyBtYWtlRGlyOiBfbWFrZURpciwgbWFrZURpclN5bmMgfSA9IHJlcXVpcmUoJy4vbWFrZS1kaXInKVxuY29uc3QgbWFrZURpciA9IHUoX21ha2VEaXIpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBta2RpcnM6IG1ha2VEaXIsXG4gIG1rZGlyc1N5bmM6IG1ha2VEaXJTeW5jLFxuICAvLyBhbGlhc1xuICBta2RpcnA6IG1ha2VEaXIsXG4gIG1rZGlycFN5bmM6IG1ha2VEaXJTeW5jLFxuICBlbnN1cmVEaXI6IG1ha2VEaXIsXG4gIGVuc3VyZURpclN5bmM6IG1ha2VEaXJTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tUHJvbWlzZVxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5cbmZ1bmN0aW9uIHBhdGhFeGlzdHMgKHBhdGgpIHtcbiAgcmV0dXJuIGZzLmFjY2VzcyhwYXRoKS50aGVuKCgpID0+IHRydWUpLmNhdGNoKCgpID0+IGZhbHNlKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGF0aEV4aXN0czogdShwYXRoRXhpc3RzKSxcbiAgcGF0aEV4aXN0c1N5bmM6IGZzLmV4aXN0c1N5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL2ZzJylcbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tUHJvbWlzZVxuXG5hc3luYyBmdW5jdGlvbiB1dGltZXNNaWxsaXMgKHBhdGgsIGF0aW1lLCBtdGltZSkge1xuICAvLyBpZiAoIUhBU19NSUxMSVNfUkVTKSByZXR1cm4gZnMudXRpbWVzKHBhdGgsIGF0aW1lLCBtdGltZSwgY2FsbGJhY2spXG4gIGNvbnN0IGZkID0gYXdhaXQgZnMub3BlbihwYXRoLCAncisnKVxuXG4gIGxldCBjbG9zZUVyciA9IG51bGxcblxuICB0cnkge1xuICAgIGF3YWl0IGZzLmZ1dGltZXMoZmQsIGF0aW1lLCBtdGltZSlcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZnMuY2xvc2UoZmQpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2xvc2VFcnIgPSBlXG4gICAgfVxuICB9XG5cbiAgaWYgKGNsb3NlRXJyKSB7XG4gICAgdGhyb3cgY2xvc2VFcnJcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGltZXNNaWxsaXNTeW5jIChwYXRoLCBhdGltZSwgbXRpbWUpIHtcbiAgY29uc3QgZmQgPSBmcy5vcGVuU3luYyhwYXRoLCAncisnKVxuICBmcy5mdXRpbWVzU3luYyhmZCwgYXRpbWUsIG10aW1lKVxuICByZXR1cm4gZnMuY2xvc2VTeW5jKGZkKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdXRpbWVzTWlsbGlzOiB1KHV0aW1lc01pbGxpcyksXG4gIHV0aW1lc01pbGxpc1N5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL2ZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tUHJvbWlzZVxuXG5mdW5jdGlvbiBnZXRTdGF0cyAoc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGNvbnN0IHN0YXRGdW5jID0gb3B0cy5kZXJlZmVyZW5jZVxuICAgID8gKGZpbGUpID0+IGZzLnN0YXQoZmlsZSwgeyBiaWdpbnQ6IHRydWUgfSlcbiAgICA6IChmaWxlKSA9PiBmcy5sc3RhdChmaWxlLCB7IGJpZ2ludDogdHJ1ZSB9KVxuICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgIHN0YXRGdW5jKHNyYyksXG4gICAgc3RhdEZ1bmMoZGVzdCkuY2F0Y2goZXJyID0+IHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHJldHVybiBudWxsXG4gICAgICB0aHJvdyBlcnJcbiAgICB9KVxuICBdKS50aGVuKChbc3JjU3RhdCwgZGVzdFN0YXRdKSA9PiAoeyBzcmNTdGF0LCBkZXN0U3RhdCB9KSlcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdHNTeW5jIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgbGV0IGRlc3RTdGF0XG4gIGNvbnN0IHN0YXRGdW5jID0gb3B0cy5kZXJlZmVyZW5jZVxuICAgID8gKGZpbGUpID0+IGZzLnN0YXRTeW5jKGZpbGUsIHsgYmlnaW50OiB0cnVlIH0pXG4gICAgOiAoZmlsZSkgPT4gZnMubHN0YXRTeW5jKGZpbGUsIHsgYmlnaW50OiB0cnVlIH0pXG4gIGNvbnN0IHNyY1N0YXQgPSBzdGF0RnVuYyhzcmMpXG4gIHRyeSB7XG4gICAgZGVzdFN0YXQgPSBzdGF0RnVuYyhkZXN0KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgPT09ICdFTk9FTlQnKSByZXR1cm4geyBzcmNTdGF0LCBkZXN0U3RhdDogbnVsbCB9XG4gICAgdGhyb3cgZXJyXG4gIH1cbiAgcmV0dXJuIHsgc3JjU3RhdCwgZGVzdFN0YXQgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjaGVja1BhdGhzIChzcmMsIGRlc3QsIGZ1bmNOYW1lLCBvcHRzKSB7XG4gIGNvbnN0IHsgc3JjU3RhdCwgZGVzdFN0YXQgfSA9IGF3YWl0IGdldFN0YXRzKHNyYywgZGVzdCwgb3B0cylcbiAgaWYgKGRlc3RTdGF0KSB7XG4gICAgaWYgKGFyZUlkZW50aWNhbChzcmNTdGF0LCBkZXN0U3RhdCkpIHtcbiAgICAgIGNvbnN0IHNyY0Jhc2VOYW1lID0gcGF0aC5iYXNlbmFtZShzcmMpXG4gICAgICBjb25zdCBkZXN0QmFzZU5hbWUgPSBwYXRoLmJhc2VuYW1lKGRlc3QpXG4gICAgICBpZiAoZnVuY05hbWUgPT09ICdtb3ZlJyAmJlxuICAgICAgICBzcmNCYXNlTmFtZSAhPT0gZGVzdEJhc2VOYW1lICYmXG4gICAgICAgIHNyY0Jhc2VOYW1lLnRvTG93ZXJDYXNlKCkgPT09IGRlc3RCYXNlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIHJldHVybiB7IHNyY1N0YXQsIGRlc3RTdGF0LCBpc0NoYW5naW5nQ2FzZTogdHJ1ZSB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NvdXJjZSBhbmQgZGVzdGluYXRpb24gbXVzdCBub3QgYmUgdGhlIHNhbWUuJylcbiAgICB9XG4gICAgaWYgKHNyY1N0YXQuaXNEaXJlY3RvcnkoKSAmJiAhZGVzdFN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgb3ZlcndyaXRlIG5vbi1kaXJlY3RvcnkgJyR7ZGVzdH0nIHdpdGggZGlyZWN0b3J5ICcke3NyY30nLmApXG4gICAgfVxuICAgIGlmICghc3JjU3RhdC5pc0RpcmVjdG9yeSgpICYmIGRlc3RTdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IG92ZXJ3cml0ZSBkaXJlY3RvcnkgJyR7ZGVzdH0nIHdpdGggbm9uLWRpcmVjdG9yeSAnJHtzcmN9Jy5gKVxuICAgIH1cbiAgfVxuXG4gIGlmIChzcmNTdGF0LmlzRGlyZWN0b3J5KCkgJiYgaXNTcmNTdWJkaXIoc3JjLCBkZXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2coc3JjLCBkZXN0LCBmdW5jTmFtZSkpXG4gIH1cblxuICByZXR1cm4geyBzcmNTdGF0LCBkZXN0U3RhdCB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUGF0aHNTeW5jIChzcmMsIGRlc3QsIGZ1bmNOYW1lLCBvcHRzKSB7XG4gIGNvbnN0IHsgc3JjU3RhdCwgZGVzdFN0YXQgfSA9IGdldFN0YXRzU3luYyhzcmMsIGRlc3QsIG9wdHMpXG5cbiAgaWYgKGRlc3RTdGF0KSB7XG4gICAgaWYgKGFyZUlkZW50aWNhbChzcmNTdGF0LCBkZXN0U3RhdCkpIHtcbiAgICAgIGNvbnN0IHNyY0Jhc2VOYW1lID0gcGF0aC5iYXNlbmFtZShzcmMpXG4gICAgICBjb25zdCBkZXN0QmFzZU5hbWUgPSBwYXRoLmJhc2VuYW1lKGRlc3QpXG4gICAgICBpZiAoZnVuY05hbWUgPT09ICdtb3ZlJyAmJlxuICAgICAgICBzcmNCYXNlTmFtZSAhPT0gZGVzdEJhc2VOYW1lICYmXG4gICAgICAgIHNyY0Jhc2VOYW1lLnRvTG93ZXJDYXNlKCkgPT09IGRlc3RCYXNlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIHJldHVybiB7IHNyY1N0YXQsIGRlc3RTdGF0LCBpc0NoYW5naW5nQ2FzZTogdHJ1ZSB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NvdXJjZSBhbmQgZGVzdGluYXRpb24gbXVzdCBub3QgYmUgdGhlIHNhbWUuJylcbiAgICB9XG4gICAgaWYgKHNyY1N0YXQuaXNEaXJlY3RvcnkoKSAmJiAhZGVzdFN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgb3ZlcndyaXRlIG5vbi1kaXJlY3RvcnkgJyR7ZGVzdH0nIHdpdGggZGlyZWN0b3J5ICcke3NyY30nLmApXG4gICAgfVxuICAgIGlmICghc3JjU3RhdC5pc0RpcmVjdG9yeSgpICYmIGRlc3RTdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IG92ZXJ3cml0ZSBkaXJlY3RvcnkgJyR7ZGVzdH0nIHdpdGggbm9uLWRpcmVjdG9yeSAnJHtzcmN9Jy5gKVxuICAgIH1cbiAgfVxuXG4gIGlmIChzcmNTdGF0LmlzRGlyZWN0b3J5KCkgJiYgaXNTcmNTdWJkaXIoc3JjLCBkZXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2coc3JjLCBkZXN0LCBmdW5jTmFtZSkpXG4gIH1cbiAgcmV0dXJuIHsgc3JjU3RhdCwgZGVzdFN0YXQgfVxufVxuXG4vLyByZWN1cnNpdmVseSBjaGVjayBpZiBkZXN0IHBhcmVudCBpcyBhIHN1YmRpcmVjdG9yeSBvZiBzcmMuXG4vLyBJdCB3b3JrcyBmb3IgYWxsIGZpbGUgdHlwZXMgaW5jbHVkaW5nIHN5bWxpbmtzIHNpbmNlIGl0XG4vLyBjaGVja3MgdGhlIHNyYyBhbmQgZGVzdCBpbm9kZXMuIEl0IHN0YXJ0cyBmcm9tIHRoZSBkZWVwZXN0XG4vLyBwYXJlbnQgYW5kIHN0b3BzIG9uY2UgaXQgcmVhY2hlcyB0aGUgc3JjIHBhcmVudCBvciB0aGUgcm9vdCBwYXRoLlxuYXN5bmMgZnVuY3Rpb24gY2hlY2tQYXJlbnRQYXRocyAoc3JjLCBzcmNTdGF0LCBkZXN0LCBmdW5jTmFtZSkge1xuICBjb25zdCBzcmNQYXJlbnQgPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKHNyYykpXG4gIGNvbnN0IGRlc3RQYXJlbnQgPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKGRlc3QpKVxuICBpZiAoZGVzdFBhcmVudCA9PT0gc3JjUGFyZW50IHx8IGRlc3RQYXJlbnQgPT09IHBhdGgucGFyc2UoZGVzdFBhcmVudCkucm9vdCkgcmV0dXJuXG5cbiAgbGV0IGRlc3RTdGF0XG4gIHRyeSB7XG4gICAgZGVzdFN0YXQgPSBhd2FpdCBmcy5zdGF0KGRlc3RQYXJlbnQsIHsgYmlnaW50OiB0cnVlIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHJldHVyblxuICAgIHRocm93IGVyclxuICB9XG5cbiAgaWYgKGFyZUlkZW50aWNhbChzcmNTdGF0LCBkZXN0U3RhdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKHNyYywgZGVzdCwgZnVuY05hbWUpKVxuICB9XG5cbiAgcmV0dXJuIGNoZWNrUGFyZW50UGF0aHMoc3JjLCBzcmNTdGF0LCBkZXN0UGFyZW50LCBmdW5jTmFtZSlcbn1cblxuZnVuY3Rpb24gY2hlY2tQYXJlbnRQYXRoc1N5bmMgKHNyYywgc3JjU3RhdCwgZGVzdCwgZnVuY05hbWUpIHtcbiAgY29uc3Qgc3JjUGFyZW50ID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShzcmMpKVxuICBjb25zdCBkZXN0UGFyZW50ID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShkZXN0KSlcbiAgaWYgKGRlc3RQYXJlbnQgPT09IHNyY1BhcmVudCB8fCBkZXN0UGFyZW50ID09PSBwYXRoLnBhcnNlKGRlc3RQYXJlbnQpLnJvb3QpIHJldHVyblxuICBsZXQgZGVzdFN0YXRcbiAgdHJ5IHtcbiAgICBkZXN0U3RhdCA9IGZzLnN0YXRTeW5jKGRlc3RQYXJlbnQsIHsgYmlnaW50OiB0cnVlIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHJldHVyblxuICAgIHRocm93IGVyclxuICB9XG4gIGlmIChhcmVJZGVudGljYWwoc3JjU3RhdCwgZGVzdFN0YXQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyhzcmMsIGRlc3QsIGZ1bmNOYW1lKSlcbiAgfVxuICByZXR1cm4gY2hlY2tQYXJlbnRQYXRoc1N5bmMoc3JjLCBzcmNTdGF0LCBkZXN0UGFyZW50LCBmdW5jTmFtZSlcbn1cblxuZnVuY3Rpb24gYXJlSWRlbnRpY2FsIChzcmNTdGF0LCBkZXN0U3RhdCkge1xuICByZXR1cm4gZGVzdFN0YXQuaW5vICYmIGRlc3RTdGF0LmRldiAmJiBkZXN0U3RhdC5pbm8gPT09IHNyY1N0YXQuaW5vICYmIGRlc3RTdGF0LmRldiA9PT0gc3JjU3RhdC5kZXZcbn1cblxuLy8gcmV0dXJuIHRydWUgaWYgZGVzdCBpcyBhIHN1YmRpciBvZiBzcmMsIG90aGVyd2lzZSBmYWxzZS5cbi8vIEl0IG9ubHkgY2hlY2tzIHRoZSBwYXRoIHN0cmluZ3MuXG5mdW5jdGlvbiBpc1NyY1N1YmRpciAoc3JjLCBkZXN0KSB7XG4gIGNvbnN0IHNyY0FyciA9IHBhdGgucmVzb2x2ZShzcmMpLnNwbGl0KHBhdGguc2VwKS5maWx0ZXIoaSA9PiBpKVxuICBjb25zdCBkZXN0QXJyID0gcGF0aC5yZXNvbHZlKGRlc3QpLnNwbGl0KHBhdGguc2VwKS5maWx0ZXIoaSA9PiBpKVxuICByZXR1cm4gc3JjQXJyLmV2ZXJ5KChjdXIsIGkpID0+IGRlc3RBcnJbaV0gPT09IGN1cilcbn1cblxuZnVuY3Rpb24gZXJyTXNnIChzcmMsIGRlc3QsIGZ1bmNOYW1lKSB7XG4gIHJldHVybiBgQ2Fubm90ICR7ZnVuY05hbWV9ICcke3NyY30nIHRvIGEgc3ViZGlyZWN0b3J5IG9mIGl0c2VsZiwgJyR7ZGVzdH0nLmBcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGNoZWNrUGF0aHNcbiAgY2hlY2tQYXRoczogdShjaGVja1BhdGhzKSxcbiAgY2hlY2tQYXRoc1N5bmMsXG4gIC8vIGNoZWNrUGFyZW50XG4gIGNoZWNrUGFyZW50UGF0aHM6IHUoY2hlY2tQYXJlbnRQYXRocyksXG4gIGNoZWNrUGFyZW50UGF0aHNTeW5jLFxuICAvLyBNaXNjXG4gIGlzU3JjU3ViZGlyLFxuICBhcmVJZGVudGljYWxcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL2ZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IHsgbWtkaXJzIH0gPSByZXF1aXJlKCcuLi9ta2RpcnMnKVxuY29uc3QgeyBwYXRoRXhpc3RzIH0gPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpXG5jb25zdCB7IHV0aW1lc01pbGxpcyB9ID0gcmVxdWlyZSgnLi4vdXRpbC91dGltZXMnKVxuY29uc3Qgc3RhdCA9IHJlcXVpcmUoJy4uL3V0aWwvc3RhdCcpXG5cbmFzeW5jIGZ1bmN0aW9uIGNvcHkgKHNyYywgZGVzdCwgb3B0cyA9IHt9KSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdHMgPSB7IGZpbHRlcjogb3B0cyB9XG4gIH1cblxuICBvcHRzLmNsb2JiZXIgPSAnY2xvYmJlcicgaW4gb3B0cyA/ICEhb3B0cy5jbG9iYmVyIDogdHJ1ZSAvLyBkZWZhdWx0IHRvIHRydWUgZm9yIG5vd1xuICBvcHRzLm92ZXJ3cml0ZSA9ICdvdmVyd3JpdGUnIGluIG9wdHMgPyAhIW9wdHMub3ZlcndyaXRlIDogb3B0cy5jbG9iYmVyIC8vIG92ZXJ3cml0ZSBmYWxscyBiYWNrIHRvIGNsb2JiZXJcblxuICAvLyBXYXJuIGFib3V0IHVzaW5nIHByZXNlcnZlVGltZXN0YW1wcyBvbiAzMi1iaXQgbm9kZVxuICBpZiAob3B0cy5wcmVzZXJ2ZVRpbWVzdGFtcHMgJiYgcHJvY2Vzcy5hcmNoID09PSAnaWEzMicpIHtcbiAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKFxuICAgICAgJ1VzaW5nIHRoZSBwcmVzZXJ2ZVRpbWVzdGFtcHMgb3B0aW9uIGluIDMyLWJpdCBub2RlIGlzIG5vdCByZWNvbW1lbmRlZDtcXG5cXG4nICtcbiAgICAgICdcXHRzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pwcmljaGFyZHNvbi9ub2RlLWZzLWV4dHJhL2lzc3Vlcy8yNjknLFxuICAgICAgJ1dhcm5pbmcnLCAnZnMtZXh0cmEtV0FSTjAwMDEnXG4gICAgKVxuICB9XG5cbiAgY29uc3QgeyBzcmNTdGF0LCBkZXN0U3RhdCB9ID0gYXdhaXQgc3RhdC5jaGVja1BhdGhzKHNyYywgZGVzdCwgJ2NvcHknLCBvcHRzKVxuXG4gIGF3YWl0IHN0YXQuY2hlY2tQYXJlbnRQYXRocyhzcmMsIHNyY1N0YXQsIGRlc3QsICdjb3B5JylcblxuICBjb25zdCBpbmNsdWRlID0gYXdhaXQgcnVuRmlsdGVyKHNyYywgZGVzdCwgb3B0cylcblxuICBpZiAoIWluY2x1ZGUpIHJldHVyblxuXG4gIC8vIGNoZWNrIGlmIHRoZSBwYXJlbnQgb2YgZGVzdCBleGlzdHMsIGFuZCBjcmVhdGUgaXQgaWYgaXQgZG9lc24ndCBleGlzdFxuICBjb25zdCBkZXN0UGFyZW50ID0gcGF0aC5kaXJuYW1lKGRlc3QpXG4gIGNvbnN0IGRpckV4aXN0cyA9IGF3YWl0IHBhdGhFeGlzdHMoZGVzdFBhcmVudClcbiAgaWYgKCFkaXJFeGlzdHMpIHtcbiAgICBhd2FpdCBta2RpcnMoZGVzdFBhcmVudClcbiAgfVxuXG4gIGF3YWl0IGdldFN0YXRzQW5kUGVyZm9ybUNvcHkoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcbn1cblxuYXN5bmMgZnVuY3Rpb24gcnVuRmlsdGVyIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgaWYgKCFvcHRzLmZpbHRlcikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIG9wdHMuZmlsdGVyKHNyYywgZGVzdClcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0U3RhdHNBbmRQZXJmb3JtQ29weSAoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBjb25zdCBzdGF0Rm4gPSBvcHRzLmRlcmVmZXJlbmNlID8gZnMuc3RhdCA6IGZzLmxzdGF0XG4gIGNvbnN0IHNyY1N0YXQgPSBhd2FpdCBzdGF0Rm4oc3JjKVxuXG4gIGlmIChzcmNTdGF0LmlzRGlyZWN0b3J5KCkpIHJldHVybiBvbkRpcihzcmNTdGF0LCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxuXG4gIGlmIChcbiAgICBzcmNTdGF0LmlzRmlsZSgpIHx8XG4gICAgc3JjU3RhdC5pc0NoYXJhY3RlckRldmljZSgpIHx8XG4gICAgc3JjU3RhdC5pc0Jsb2NrRGV2aWNlKClcbiAgKSByZXR1cm4gb25GaWxlKHNyY1N0YXQsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG5cbiAgaWYgKHNyY1N0YXQuaXNTeW1ib2xpY0xpbmsoKSkgcmV0dXJuIG9uTGluayhkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxuICBpZiAoc3JjU3RhdC5pc1NvY2tldCgpKSB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb3B5IGEgc29ja2V0IGZpbGU6ICR7c3JjfWApXG4gIGlmIChzcmNTdGF0LmlzRklGTygpKSB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb3B5IGEgRklGTyBwaXBlOiAke3NyY31gKVxuICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZmlsZTogJHtzcmN9YClcbn1cblxuYXN5bmMgZnVuY3Rpb24gb25GaWxlIChzcmNTdGF0LCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmICghZGVzdFN0YXQpIHJldHVybiBjb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG5cbiAgaWYgKG9wdHMub3ZlcndyaXRlKSB7XG4gICAgYXdhaXQgZnMudW5saW5rKGRlc3QpXG4gICAgcmV0dXJuIGNvcHlGaWxlKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cylcbiAgfVxuICBpZiAob3B0cy5lcnJvck9uRXhpc3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCcke2Rlc3R9JyBhbHJlYWR5IGV4aXN0c2ApXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gY29weUZpbGUgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBhd2FpdCBmcy5jb3B5RmlsZShzcmMsIGRlc3QpXG4gIGlmIChvcHRzLnByZXNlcnZlVGltZXN0YW1wcykge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgZmlsZSBpcyB3cml0YWJsZSBiZWZvcmUgc2V0dGluZyB0aGUgdGltZXN0YW1wXG4gICAgLy8gb3RoZXJ3aXNlIG9wZW4gZmFpbHMgd2l0aCBFUEVSTSB3aGVuIGludm9rZWQgd2l0aCAncisnXG4gICAgLy8gKHRocm91Z2ggdXRpbWVzIGNhbGwpXG4gICAgaWYgKGZpbGVJc05vdFdyaXRhYmxlKHNyY1N0YXQubW9kZSkpIHtcbiAgICAgIGF3YWl0IG1ha2VGaWxlV3JpdGFibGUoZGVzdCwgc3JjU3RhdC5tb2RlKVxuICAgIH1cblxuICAgIC8vIFNldCB0aW1lc3RhbXBzIGFuZCBtb2RlIGNvcnJlc3BvbmRpbmdseVxuXG4gICAgLy8gTm90ZSB0aGF0IFRoZSBpbml0aWFsIHNyY1N0YXQuYXRpbWUgY2Fubm90IGJlIHRydXN0ZWRcbiAgICAvLyBiZWNhdXNlIGl0IGlzIG1vZGlmaWVkIGJ5IHRoZSByZWFkKDIpIHN5c3RlbSBjYWxsXG4gICAgLy8gKFNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL2ZzLmh0bWwjZnNfc3RhdF90aW1lX3ZhbHVlcylcbiAgICBjb25zdCB1cGRhdGVkU3JjU3RhdCA9IGF3YWl0IGZzLnN0YXQoc3JjKVxuICAgIGF3YWl0IHV0aW1lc01pbGxpcyhkZXN0LCB1cGRhdGVkU3JjU3RhdC5hdGltZSwgdXBkYXRlZFNyY1N0YXQubXRpbWUpXG4gIH1cblxuICByZXR1cm4gZnMuY2htb2QoZGVzdCwgc3JjU3RhdC5tb2RlKVxufVxuXG5mdW5jdGlvbiBmaWxlSXNOb3RXcml0YWJsZSAoc3JjTW9kZSkge1xuICByZXR1cm4gKHNyY01vZGUgJiAwbzIwMCkgPT09IDBcbn1cblxuZnVuY3Rpb24gbWFrZUZpbGVXcml0YWJsZSAoZGVzdCwgc3JjTW9kZSkge1xuICByZXR1cm4gZnMuY2htb2QoZGVzdCwgc3JjTW9kZSB8IDBvMjAwKVxufVxuXG5hc3luYyBmdW5jdGlvbiBvbkRpciAoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICAvLyB0aGUgZGVzdCBkaXJlY3RvcnkgbWlnaHQgbm90IGV4aXN0LCBjcmVhdGUgaXRcbiAgaWYgKCFkZXN0U3RhdCkge1xuICAgIGF3YWl0IGZzLm1rZGlyKGRlc3QpXG4gIH1cblxuICBjb25zdCBpdGVtcyA9IGF3YWl0IGZzLnJlYWRkaXIoc3JjKVxuXG4gIC8vIGxvb3AgdGhyb3VnaCB0aGUgZmlsZXMgaW4gdGhlIGN1cnJlbnQgZGlyZWN0b3J5IHRvIGNvcHkgZXZlcnl0aGluZ1xuICBhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAoYXN5bmMgaXRlbSA9PiB7XG4gICAgY29uc3Qgc3JjSXRlbSA9IHBhdGguam9pbihzcmMsIGl0ZW0pXG4gICAgY29uc3QgZGVzdEl0ZW0gPSBwYXRoLmpvaW4oZGVzdCwgaXRlbSlcblxuICAgIC8vIHNraXAgdGhlIGl0ZW0gaWYgaXQgaXMgbWF0Y2hlcyBieSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG4gICAgY29uc3QgaW5jbHVkZSA9IGF3YWl0IHJ1bkZpbHRlcihzcmNJdGVtLCBkZXN0SXRlbSwgb3B0cylcbiAgICBpZiAoIWluY2x1ZGUpIHJldHVyblxuXG4gICAgY29uc3QgeyBkZXN0U3RhdCB9ID0gYXdhaXQgc3RhdC5jaGVja1BhdGhzKHNyY0l0ZW0sIGRlc3RJdGVtLCAnY29weScsIG9wdHMpXG5cbiAgICAvLyBJZiB0aGUgaXRlbSBpcyBhIGNvcHlhYmxlIGZpbGUsIGBnZXRTdGF0c0FuZFBlcmZvcm1Db3B5YCB3aWxsIGNvcHkgaXRcbiAgICAvLyBJZiB0aGUgaXRlbSBpcyBhIGRpcmVjdG9yeSwgYGdldFN0YXRzQW5kUGVyZm9ybUNvcHlgIHdpbGwgY2FsbCBgb25EaXJgIHJlY3Vyc2l2ZWx5XG4gICAgcmV0dXJuIGdldFN0YXRzQW5kUGVyZm9ybUNvcHkoZGVzdFN0YXQsIHNyY0l0ZW0sIGRlc3RJdGVtLCBvcHRzKVxuICB9KSlcblxuICBpZiAoIWRlc3RTdGF0KSB7XG4gICAgYXdhaXQgZnMuY2htb2QoZGVzdCwgc3JjU3RhdC5tb2RlKVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG9uTGluayAoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBsZXQgcmVzb2x2ZWRTcmMgPSBhd2FpdCBmcy5yZWFkbGluayhzcmMpXG4gIGlmIChvcHRzLmRlcmVmZXJlbmNlKSB7XG4gICAgcmVzb2x2ZWRTcmMgPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgcmVzb2x2ZWRTcmMpXG4gIH1cbiAgaWYgKCFkZXN0U3RhdCkge1xuICAgIHJldHVybiBmcy5zeW1saW5rKHJlc29sdmVkU3JjLCBkZXN0KVxuICB9XG5cbiAgbGV0IHJlc29sdmVkRGVzdCA9IG51bGxcbiAgdHJ5IHtcbiAgICByZXNvbHZlZERlc3QgPSBhd2FpdCBmcy5yZWFkbGluayhkZXN0KVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gZGVzdCBleGlzdHMgYW5kIGlzIGEgcmVndWxhciBmaWxlIG9yIGRpcmVjdG9yeSxcbiAgICAvLyBXaW5kb3dzIG1heSB0aHJvdyBVTktOT1dOIGVycm9yLiBJZiBkZXN0IGFscmVhZHkgZXhpc3RzLFxuICAgIC8vIGZzIHRocm93cyBlcnJvciBhbnl3YXksIHNvIG5vIG5lZWQgdG8gZ3VhcmQgYWdhaW5zdCBpdCBoZXJlLlxuICAgIGlmIChlLmNvZGUgPT09ICdFSU5WQUwnIHx8IGUuY29kZSA9PT0gJ1VOS05PV04nKSByZXR1cm4gZnMuc3ltbGluayhyZXNvbHZlZFNyYywgZGVzdClcbiAgICB0aHJvdyBlXG4gIH1cbiAgaWYgKG9wdHMuZGVyZWZlcmVuY2UpIHtcbiAgICByZXNvbHZlZERlc3QgPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgcmVzb2x2ZWREZXN0KVxuICB9XG4gIGlmIChzdGF0LmlzU3JjU3ViZGlyKHJlc29sdmVkU3JjLCByZXNvbHZlZERlc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29weSAnJHtyZXNvbHZlZFNyY30nIHRvIGEgc3ViZGlyZWN0b3J5IG9mIGl0c2VsZiwgJyR7cmVzb2x2ZWREZXN0fScuYClcbiAgfVxuXG4gIC8vIGRvIG5vdCBjb3B5IGlmIHNyYyBpcyBhIHN1YmRpciBvZiBkZXN0IHNpbmNlIHVubGlua2luZ1xuICAvLyBkZXN0IGluIHRoaXMgY2FzZSB3b3VsZCByZXN1bHQgaW4gcmVtb3Zpbmcgc3JjIGNvbnRlbnRzXG4gIC8vIGFuZCB0aGVyZWZvcmUgYSBicm9rZW4gc3ltbGluayB3b3VsZCBiZSBjcmVhdGVkLlxuICBpZiAoc3RhdC5pc1NyY1N1YmRpcihyZXNvbHZlZERlc3QsIHJlc29sdmVkU3JjKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IG92ZXJ3cml0ZSAnJHtyZXNvbHZlZERlc3R9JyB3aXRoICcke3Jlc29sdmVkU3JjfScuYClcbiAgfVxuXG4gIC8vIGNvcHkgdGhlIGxpbmtcbiAgYXdhaXQgZnMudW5saW5rKGRlc3QpXG4gIHJldHVybiBmcy5zeW1saW5rKHJlc29sdmVkU3JjLCBkZXN0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlyc1N5bmMgPSByZXF1aXJlKCcuLi9ta2RpcnMnKS5ta2RpcnNTeW5jXG5jb25zdCB1dGltZXNNaWxsaXNTeW5jID0gcmVxdWlyZSgnLi4vdXRpbC91dGltZXMnKS51dGltZXNNaWxsaXNTeW5jXG5jb25zdCBzdGF0ID0gcmVxdWlyZSgnLi4vdXRpbC9zdGF0JylcblxuZnVuY3Rpb24gY29weVN5bmMgKHNyYywgZGVzdCwgb3B0cykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRzID0geyBmaWx0ZXI6IG9wdHMgfVxuICB9XG5cbiAgb3B0cyA9IG9wdHMgfHwge31cbiAgb3B0cy5jbG9iYmVyID0gJ2Nsb2JiZXInIGluIG9wdHMgPyAhIW9wdHMuY2xvYmJlciA6IHRydWUgLy8gZGVmYXVsdCB0byB0cnVlIGZvciBub3dcbiAgb3B0cy5vdmVyd3JpdGUgPSAnb3ZlcndyaXRlJyBpbiBvcHRzID8gISFvcHRzLm92ZXJ3cml0ZSA6IG9wdHMuY2xvYmJlciAvLyBvdmVyd3JpdGUgZmFsbHMgYmFjayB0byBjbG9iYmVyXG5cbiAgLy8gV2FybiBhYm91dCB1c2luZyBwcmVzZXJ2ZVRpbWVzdGFtcHMgb24gMzItYml0IG5vZGVcbiAgaWYgKG9wdHMucHJlc2VydmVUaW1lc3RhbXBzICYmIHByb2Nlc3MuYXJjaCA9PT0gJ2lhMzInKSB7XG4gICAgcHJvY2Vzcy5lbWl0V2FybmluZyhcbiAgICAgICdVc2luZyB0aGUgcHJlc2VydmVUaW1lc3RhbXBzIG9wdGlvbiBpbiAzMi1iaXQgbm9kZSBpcyBub3QgcmVjb21tZW5kZWQ7XFxuXFxuJyArXG4gICAgICAnXFx0c2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcHJpY2hhcmRzb24vbm9kZS1mcy1leHRyYS9pc3N1ZXMvMjY5JyxcbiAgICAgICdXYXJuaW5nJywgJ2ZzLWV4dHJhLVdBUk4wMDAyJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHsgc3JjU3RhdCwgZGVzdFN0YXQgfSA9IHN0YXQuY2hlY2tQYXRoc1N5bmMoc3JjLCBkZXN0LCAnY29weScsIG9wdHMpXG4gIHN0YXQuY2hlY2tQYXJlbnRQYXRoc1N5bmMoc3JjLCBzcmNTdGF0LCBkZXN0LCAnY29weScpXG4gIGlmIChvcHRzLmZpbHRlciAmJiAhb3B0cy5maWx0ZXIoc3JjLCBkZXN0KSkgcmV0dXJuXG4gIGNvbnN0IGRlc3RQYXJlbnQgPSBwYXRoLmRpcm5hbWUoZGVzdClcbiAgaWYgKCFmcy5leGlzdHNTeW5jKGRlc3RQYXJlbnQpKSBta2RpcnNTeW5jKGRlc3RQYXJlbnQpXG4gIHJldHVybiBnZXRTdGF0cyhkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxufVxuXG5mdW5jdGlvbiBnZXRTdGF0cyAoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBjb25zdCBzdGF0U3luYyA9IG9wdHMuZGVyZWZlcmVuY2UgPyBmcy5zdGF0U3luYyA6IGZzLmxzdGF0U3luY1xuICBjb25zdCBzcmNTdGF0ID0gc3RhdFN5bmMoc3JjKVxuXG4gIGlmIChzcmNTdGF0LmlzRGlyZWN0b3J5KCkpIHJldHVybiBvbkRpcihzcmNTdGF0LCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxuICBlbHNlIGlmIChzcmNTdGF0LmlzRmlsZSgpIHx8XG4gICAgICAgICAgIHNyY1N0YXQuaXNDaGFyYWN0ZXJEZXZpY2UoKSB8fFxuICAgICAgICAgICBzcmNTdGF0LmlzQmxvY2tEZXZpY2UoKSkgcmV0dXJuIG9uRmlsZShzcmNTdGF0LCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxuICBlbHNlIGlmIChzcmNTdGF0LmlzU3ltYm9saWNMaW5rKCkpIHJldHVybiBvbkxpbmsoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcbiAgZWxzZSBpZiAoc3JjU3RhdC5pc1NvY2tldCgpKSB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb3B5IGEgc29ja2V0IGZpbGU6ICR7c3JjfWApXG4gIGVsc2UgaWYgKHNyY1N0YXQuaXNGSUZPKCkpIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvcHkgYSBGSUZPIHBpcGU6ICR7c3JjfWApXG4gIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBmaWxlOiAke3NyY31gKVxufVxuXG5mdW5jdGlvbiBvbkZpbGUgKHNyY1N0YXQsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgaWYgKCFkZXN0U3RhdCkgcmV0dXJuIGNvcHlGaWxlKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cylcbiAgcmV0dXJuIG1heUNvcHlGaWxlKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cylcbn1cblxuZnVuY3Rpb24gbWF5Q29weUZpbGUgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBpZiAob3B0cy5vdmVyd3JpdGUpIHtcbiAgICBmcy51bmxpbmtTeW5jKGRlc3QpXG4gICAgcmV0dXJuIGNvcHlGaWxlKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cylcbiAgfSBlbHNlIGlmIChvcHRzLmVycm9yT25FeGlzdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJyR7ZGVzdH0nIGFscmVhZHkgZXhpc3RzYClcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5RmlsZSAoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGZzLmNvcHlGaWxlU3luYyhzcmMsIGRlc3QpXG4gIGlmIChvcHRzLnByZXNlcnZlVGltZXN0YW1wcykgaGFuZGxlVGltZXN0YW1wcyhzcmNTdGF0Lm1vZGUsIHNyYywgZGVzdClcbiAgcmV0dXJuIHNldERlc3RNb2RlKGRlc3QsIHNyY1N0YXQubW9kZSlcbn1cblxuZnVuY3Rpb24gaGFuZGxlVGltZXN0YW1wcyAoc3JjTW9kZSwgc3JjLCBkZXN0KSB7XG4gIC8vIE1ha2Ugc3VyZSB0aGUgZmlsZSBpcyB3cml0YWJsZSBiZWZvcmUgc2V0dGluZyB0aGUgdGltZXN0YW1wXG4gIC8vIG90aGVyd2lzZSBvcGVuIGZhaWxzIHdpdGggRVBFUk0gd2hlbiBpbnZva2VkIHdpdGggJ3IrJ1xuICAvLyAodGhyb3VnaCB1dGltZXMgY2FsbClcbiAgaWYgKGZpbGVJc05vdFdyaXRhYmxlKHNyY01vZGUpKSBtYWtlRmlsZVdyaXRhYmxlKGRlc3QsIHNyY01vZGUpXG4gIHJldHVybiBzZXREZXN0VGltZXN0YW1wcyhzcmMsIGRlc3QpXG59XG5cbmZ1bmN0aW9uIGZpbGVJc05vdFdyaXRhYmxlIChzcmNNb2RlKSB7XG4gIHJldHVybiAoc3JjTW9kZSAmIDBvMjAwKSA9PT0gMFxufVxuXG5mdW5jdGlvbiBtYWtlRmlsZVdyaXRhYmxlIChkZXN0LCBzcmNNb2RlKSB7XG4gIHJldHVybiBzZXREZXN0TW9kZShkZXN0LCBzcmNNb2RlIHwgMG8yMDApXG59XG5cbmZ1bmN0aW9uIHNldERlc3RNb2RlIChkZXN0LCBzcmNNb2RlKSB7XG4gIHJldHVybiBmcy5jaG1vZFN5bmMoZGVzdCwgc3JjTW9kZSlcbn1cblxuZnVuY3Rpb24gc2V0RGVzdFRpbWVzdGFtcHMgKHNyYywgZGVzdCkge1xuICAvLyBUaGUgaW5pdGlhbCBzcmNTdGF0LmF0aW1lIGNhbm5vdCBiZSB0cnVzdGVkXG4gIC8vIGJlY2F1c2UgaXQgaXMgbW9kaWZpZWQgYnkgdGhlIHJlYWQoMikgc3lzdGVtIGNhbGxcbiAgLy8gKFNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL2ZzLmh0bWwjZnNfc3RhdF90aW1lX3ZhbHVlcylcbiAgY29uc3QgdXBkYXRlZFNyY1N0YXQgPSBmcy5zdGF0U3luYyhzcmMpXG4gIHJldHVybiB1dGltZXNNaWxsaXNTeW5jKGRlc3QsIHVwZGF0ZWRTcmNTdGF0LmF0aW1lLCB1cGRhdGVkU3JjU3RhdC5tdGltZSlcbn1cblxuZnVuY3Rpb24gb25EaXIgKHNyY1N0YXQsIGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgaWYgKCFkZXN0U3RhdCkgcmV0dXJuIG1rRGlyQW5kQ29weShzcmNTdGF0Lm1vZGUsIHNyYywgZGVzdCwgb3B0cylcbiAgcmV0dXJuIGNvcHlEaXIoc3JjLCBkZXN0LCBvcHRzKVxufVxuXG5mdW5jdGlvbiBta0RpckFuZENvcHkgKHNyY01vZGUsIHNyYywgZGVzdCwgb3B0cykge1xuICBmcy5ta2RpclN5bmMoZGVzdClcbiAgY29weURpcihzcmMsIGRlc3QsIG9wdHMpXG4gIHJldHVybiBzZXREZXN0TW9kZShkZXN0LCBzcmNNb2RlKVxufVxuXG5mdW5jdGlvbiBjb3B5RGlyIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgZnMucmVhZGRpclN5bmMoc3JjKS5mb3JFYWNoKGl0ZW0gPT4gY29weURpckl0ZW0oaXRlbSwgc3JjLCBkZXN0LCBvcHRzKSlcbn1cblxuZnVuY3Rpb24gY29weURpckl0ZW0gKGl0ZW0sIHNyYywgZGVzdCwgb3B0cykge1xuICBjb25zdCBzcmNJdGVtID0gcGF0aC5qb2luKHNyYywgaXRlbSlcbiAgY29uc3QgZGVzdEl0ZW0gPSBwYXRoLmpvaW4oZGVzdCwgaXRlbSlcbiAgaWYgKG9wdHMuZmlsdGVyICYmICFvcHRzLmZpbHRlcihzcmNJdGVtLCBkZXN0SXRlbSkpIHJldHVyblxuICBjb25zdCB7IGRlc3RTdGF0IH0gPSBzdGF0LmNoZWNrUGF0aHNTeW5jKHNyY0l0ZW0sIGRlc3RJdGVtLCAnY29weScsIG9wdHMpXG4gIHJldHVybiBnZXRTdGF0cyhkZXN0U3RhdCwgc3JjSXRlbSwgZGVzdEl0ZW0sIG9wdHMpXG59XG5cbmZ1bmN0aW9uIG9uTGluayAoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBsZXQgcmVzb2x2ZWRTcmMgPSBmcy5yZWFkbGlua1N5bmMoc3JjKVxuICBpZiAob3B0cy5kZXJlZmVyZW5jZSkge1xuICAgIHJlc29sdmVkU3JjID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIHJlc29sdmVkU3JjKVxuICB9XG5cbiAgaWYgKCFkZXN0U3RhdCkge1xuICAgIHJldHVybiBmcy5zeW1saW5rU3luYyhyZXNvbHZlZFNyYywgZGVzdClcbiAgfSBlbHNlIHtcbiAgICBsZXQgcmVzb2x2ZWREZXN0XG4gICAgdHJ5IHtcbiAgICAgIHJlc29sdmVkRGVzdCA9IGZzLnJlYWRsaW5rU3luYyhkZXN0KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gZGVzdCBleGlzdHMgYW5kIGlzIGEgcmVndWxhciBmaWxlIG9yIGRpcmVjdG9yeSxcbiAgICAgIC8vIFdpbmRvd3MgbWF5IHRocm93IFVOS05PV04gZXJyb3IuIElmIGRlc3QgYWxyZWFkeSBleGlzdHMsXG4gICAgICAvLyBmcyB0aHJvd3MgZXJyb3IgYW55d2F5LCBzbyBubyBuZWVkIHRvIGd1YXJkIGFnYWluc3QgaXQgaGVyZS5cbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VJTlZBTCcgfHwgZXJyLmNvZGUgPT09ICdVTktOT1dOJykgcmV0dXJuIGZzLnN5bWxpbmtTeW5jKHJlc29sdmVkU3JjLCBkZXN0KVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICAgIGlmIChvcHRzLmRlcmVmZXJlbmNlKSB7XG4gICAgICByZXNvbHZlZERlc3QgPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgcmVzb2x2ZWREZXN0KVxuICAgIH1cbiAgICBpZiAoc3RhdC5pc1NyY1N1YmRpcihyZXNvbHZlZFNyYywgcmVzb2x2ZWREZXN0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29weSAnJHtyZXNvbHZlZFNyY30nIHRvIGEgc3ViZGlyZWN0b3J5IG9mIGl0c2VsZiwgJyR7cmVzb2x2ZWREZXN0fScuYClcbiAgICB9XG5cbiAgICAvLyBwcmV2ZW50IGNvcHkgaWYgc3JjIGlzIGEgc3ViZGlyIG9mIGRlc3Qgc2luY2UgdW5saW5raW5nXG4gICAgLy8gZGVzdCBpbiB0aGlzIGNhc2Ugd291bGQgcmVzdWx0IGluIHJlbW92aW5nIHNyYyBjb250ZW50c1xuICAgIC8vIGFuZCB0aGVyZWZvcmUgYSBicm9rZW4gc3ltbGluayB3b3VsZCBiZSBjcmVhdGVkLlxuICAgIGlmIChzdGF0LmlzU3JjU3ViZGlyKHJlc29sdmVkRGVzdCwgcmVzb2x2ZWRTcmMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBvdmVyd3JpdGUgJyR7cmVzb2x2ZWREZXN0fScgd2l0aCAnJHtyZXNvbHZlZFNyY30nLmApXG4gICAgfVxuICAgIHJldHVybiBjb3B5TGluayhyZXNvbHZlZFNyYywgZGVzdClcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5TGluayAocmVzb2x2ZWRTcmMsIGRlc3QpIHtcbiAgZnMudW5saW5rU3luYyhkZXN0KVxuICByZXR1cm4gZnMuc3ltbGlua1N5bmMocmVzb2x2ZWRTcmMsIGRlc3QpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bmNcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2Vcbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb3B5OiB1KHJlcXVpcmUoJy4vY29weScpKSxcbiAgY29weVN5bmM6IHJlcXVpcmUoJy4vY29weS1zeW5jJylcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcblxuZnVuY3Rpb24gcmVtb3ZlIChwYXRoLCBjYWxsYmFjaykge1xuICBmcy5ybShwYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSwgY2FsbGJhY2spXG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN5bmMgKHBhdGgpIHtcbiAgZnMucm1TeW5jKHBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlLCBmb3JjZTogdHJ1ZSB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmVtb3ZlOiB1KHJlbW92ZSksXG4gIHJlbW92ZVN5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2VcbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgbWtkaXIgPSByZXF1aXJlKCcuLi9ta2RpcnMnKVxuY29uc3QgcmVtb3ZlID0gcmVxdWlyZSgnLi4vcmVtb3ZlJylcblxuY29uc3QgZW1wdHlEaXIgPSB1KGFzeW5jIGZ1bmN0aW9uIGVtcHR5RGlyIChkaXIpIHtcbiAgbGV0IGl0ZW1zXG4gIHRyeSB7XG4gICAgaXRlbXMgPSBhd2FpdCBmcy5yZWFkZGlyKGRpcilcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG1rZGlyLm1rZGlycyhkaXIpXG4gIH1cblxuICByZXR1cm4gUHJvbWlzZS5hbGwoaXRlbXMubWFwKGl0ZW0gPT4gcmVtb3ZlLnJlbW92ZShwYXRoLmpvaW4oZGlyLCBpdGVtKSkpKVxufSlcblxuZnVuY3Rpb24gZW1wdHlEaXJTeW5jIChkaXIpIHtcbiAgbGV0IGl0ZW1zXG4gIHRyeSB7XG4gICAgaXRlbXMgPSBmcy5yZWFkZGlyU3luYyhkaXIpXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBta2Rpci5ta2RpcnNTeW5jKGRpcilcbiAgfVxuXG4gIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgaXRlbSA9IHBhdGguam9pbihkaXIsIGl0ZW0pXG4gICAgcmVtb3ZlLnJlbW92ZVN5bmMoaXRlbSlcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVtcHR5RGlyU3luYyxcbiAgZW1wdHlkaXJTeW5jOiBlbXB0eURpclN5bmMsXG4gIGVtcHR5RGlyLFxuICBlbXB0eWRpcjogZW1wdHlEaXJcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2VcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vZnMnKVxuY29uc3QgbWtkaXIgPSByZXF1aXJlKCcuLi9ta2RpcnMnKVxuXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVGaWxlIChmaWxlKSB7XG4gIGxldCBzdGF0c1xuICB0cnkge1xuICAgIHN0YXRzID0gYXdhaXQgZnMuc3RhdChmaWxlKVxuICB9IGNhdGNoIHsgfVxuICBpZiAoc3RhdHMgJiYgc3RhdHMuaXNGaWxlKCkpIHJldHVyblxuXG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShmaWxlKVxuXG4gIGxldCBkaXJTdGF0cyA9IG51bGxcbiAgdHJ5IHtcbiAgICBkaXJTdGF0cyA9IGF3YWl0IGZzLnN0YXQoZGlyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBpZiB0aGUgZGlyZWN0b3J5IGRvZXNuJ3QgZXhpc3QsIG1ha2UgaXRcbiAgICBpZiAoZXJyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICBhd2FpdCBta2Rpci5ta2RpcnMoZGlyKVxuICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKGZpbGUsICcnKVxuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJTdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKGZpbGUsICcnKVxuICB9IGVsc2Uge1xuICAgIC8vIHBhcmVudCBpcyBub3QgYSBkaXJlY3RvcnlcbiAgICAvLyBUaGlzIGlzIGp1c3QgdG8gY2F1c2UgYW4gaW50ZXJuYWwgRU5PVERJUiBlcnJvciB0byBiZSB0aHJvd25cbiAgICBhd2FpdCBmcy5yZWFkZGlyKGRpcilcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWxlU3luYyAoZmlsZSkge1xuICBsZXQgc3RhdHNcbiAgdHJ5IHtcbiAgICBzdGF0cyA9IGZzLnN0YXRTeW5jKGZpbGUpXG4gIH0gY2F0Y2ggeyB9XG4gIGlmIChzdGF0cyAmJiBzdGF0cy5pc0ZpbGUoKSkgcmV0dXJuXG5cbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGUpXG4gIHRyeSB7XG4gICAgaWYgKCFmcy5zdGF0U3luYyhkaXIpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIC8vIHBhcmVudCBpcyBub3QgYSBkaXJlY3RvcnlcbiAgICAgIC8vIFRoaXMgaXMganVzdCB0byBjYXVzZSBhbiBpbnRlcm5hbCBFTk9URElSIGVycm9yIHRvIGJlIHRocm93blxuICAgICAgZnMucmVhZGRpclN5bmMoZGlyKVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gSWYgdGhlIHN0YXQgY2FsbCBhYm92ZSBmYWlsZWQgYmVjYXVzZSB0aGUgZGlyZWN0b3J5IGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBpdFxuICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09ICdFTk9FTlQnKSBta2Rpci5ta2RpcnNTeW5jKGRpcilcbiAgICBlbHNlIHRocm93IGVyclxuICB9XG5cbiAgZnMud3JpdGVGaWxlU3luYyhmaWxlLCAnJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZUZpbGU6IHUoY3JlYXRlRmlsZSksXG4gIGNyZWF0ZUZpbGVTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21Qcm9taXNlXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL2ZzJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHsgcGF0aEV4aXN0cyB9ID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKVxuY29uc3QgeyBhcmVJZGVudGljYWwgfSA9IHJlcXVpcmUoJy4uL3V0aWwvc3RhdCcpXG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUxpbmsgKHNyY3BhdGgsIGRzdHBhdGgpIHtcbiAgbGV0IGRzdFN0YXRcbiAgdHJ5IHtcbiAgICBkc3RTdGF0ID0gYXdhaXQgZnMubHN0YXQoZHN0cGF0aClcbiAgfSBjYXRjaCB7XG4gICAgLy8gaWdub3JlIGVycm9yXG4gIH1cblxuICBsZXQgc3JjU3RhdFxuICB0cnkge1xuICAgIHNyY1N0YXQgPSBhd2FpdCBmcy5sc3RhdChzcmNwYXRoKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIubWVzc2FnZSA9IGVyci5tZXNzYWdlLnJlcGxhY2UoJ2xzdGF0JywgJ2Vuc3VyZUxpbmsnKVxuICAgIHRocm93IGVyclxuICB9XG5cbiAgaWYgKGRzdFN0YXQgJiYgYXJlSWRlbnRpY2FsKHNyY1N0YXQsIGRzdFN0YXQpKSByZXR1cm5cblxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcblxuICBjb25zdCBkaXJFeGlzdHMgPSBhd2FpdCBwYXRoRXhpc3RzKGRpcilcblxuICBpZiAoIWRpckV4aXN0cykge1xuICAgIGF3YWl0IG1rZGlyLm1rZGlycyhkaXIpXG4gIH1cblxuICBhd2FpdCBmcy5saW5rKHNyY3BhdGgsIGRzdHBhdGgpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtTeW5jIChzcmNwYXRoLCBkc3RwYXRoKSB7XG4gIGxldCBkc3RTdGF0XG4gIHRyeSB7XG4gICAgZHN0U3RhdCA9IGZzLmxzdGF0U3luYyhkc3RwYXRoKVxuICB9IGNhdGNoIHt9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBzcmNTdGF0ID0gZnMubHN0YXRTeW5jKHNyY3BhdGgpXG4gICAgaWYgKGRzdFN0YXQgJiYgYXJlSWRlbnRpY2FsKHNyY1N0YXQsIGRzdFN0YXQpKSByZXR1cm5cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLm1lc3NhZ2UgPSBlcnIubWVzc2FnZS5yZXBsYWNlKCdsc3RhdCcsICdlbnN1cmVMaW5rJylcbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShkc3RwYXRoKVxuICBjb25zdCBkaXJFeGlzdHMgPSBmcy5leGlzdHNTeW5jKGRpcilcbiAgaWYgKGRpckV4aXN0cykgcmV0dXJuIGZzLmxpbmtTeW5jKHNyY3BhdGgsIGRzdHBhdGgpXG4gIG1rZGlyLm1rZGlyc1N5bmMoZGlyKVxuXG4gIHJldHVybiBmcy5saW5rU3luYyhzcmNwYXRoLCBkc3RwYXRoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlTGluazogdShjcmVhdGVMaW5rKSxcbiAgY3JlYXRlTGlua1N5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL2ZzJylcbmNvbnN0IHsgcGF0aEV4aXN0cyB9ID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKVxuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2VcblxuLyoqXG4gKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgdHdvIHR5cGVzIG9mIHBhdGhzLCBvbmUgcmVsYXRpdmUgdG8gc3ltbGluaywgYW5kIG9uZVxuICogcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuIENoZWNrcyBpZiBwYXRoIGlzIGFic29sdXRlIG9yXG4gKiByZWxhdGl2ZS4gSWYgdGhlIHBhdGggaXMgcmVsYXRpdmUsIHRoaXMgZnVuY3Rpb24gY2hlY2tzIGlmIHRoZSBwYXRoIGlzXG4gKiByZWxhdGl2ZSB0byBzeW1saW5rIG9yIHJlbGF0aXZlIHRvIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuIFRoaXMgaXMgYW5cbiAqIGluaXRpYXRpdmUgdG8gZmluZCBhIHNtYXJ0ZXIgYHNyY3BhdGhgIHRvIHN1cHBseSB3aGVuIGJ1aWxkaW5nIHN5bWxpbmtzLlxuICogVGhpcyBhbGxvd3MgeW91IHRvIGRldGVybWluZSB3aGljaCBwYXRoIHRvIHVzZSBvdXQgb2Ygb25lIG9mIHRocmVlIHBvc3NpYmxlXG4gKiB0eXBlcyBvZiBzb3VyY2UgcGF0aHMuIFRoZSBmaXJzdCBpcyBhbiBhYnNvbHV0ZSBwYXRoLiBUaGlzIGlzIGRldGVjdGVkIGJ5XG4gKiBgcGF0aC5pc0Fic29sdXRlKClgLiBXaGVuIGFuIGFic29sdXRlIHBhdGggaXMgcHJvdmlkZWQsIGl0IGlzIGNoZWNrZWQgdG9cbiAqIHNlZSBpZiBpdCBleGlzdHMuIElmIGl0IGRvZXMgaXQncyB1c2VkLCBpZiBub3QgYW4gZXJyb3IgaXMgcmV0dXJuZWRcbiAqIChjYWxsYmFjaykvIHRocm93biAoc3luYykuIFRoZSBvdGhlciB0d28gb3B0aW9ucyBmb3IgYHNyY3BhdGhgIGFyZSBhXG4gKiByZWxhdGl2ZSB1cmwuIEJ5IGRlZmF1bHQgTm9kZSdzIGBmcy5zeW1saW5rYCB3b3JrcyBieSBjcmVhdGluZyBhIHN5bWxpbmtcbiAqIHVzaW5nIGBkc3RwYXRoYCBhbmQgZXhwZWN0cyB0aGUgYHNyY3BhdGhgIHRvIGJlIHJlbGF0aXZlIHRvIHRoZSBuZXdseVxuICogY3JlYXRlZCBzeW1saW5rLiBJZiB5b3UgcHJvdmlkZSBhIGBzcmNwYXRoYCB0aGF0IGRvZXMgbm90IGV4aXN0IG9uIHRoZSBmaWxlXG4gKiBzeXN0ZW0gaXQgcmVzdWx0cyBpbiBhIGJyb2tlbiBzeW1saW5rLiBUbyBtaW5pbWl6ZSB0aGlzLCB0aGUgZnVuY3Rpb25cbiAqIGNoZWNrcyB0byBzZWUgaWYgdGhlICdyZWxhdGl2ZSB0byBzeW1saW5rJyBzb3VyY2UgZmlsZSBleGlzdHMsIGFuZCBpZiBpdFxuICogZG9lcyBpdCB3aWxsIHVzZSBpdC4gSWYgaXQgZG9lcyBub3QsIGl0IGNoZWNrcyBpZiB0aGVyZSdzIGEgZmlsZSB0aGF0XG4gKiBleGlzdHMgdGhhdCBpcyByZWxhdGl2ZSB0byB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeSwgaWYgZG9lcyBpdHMgdXNlZC5cbiAqIFRoaXMgcHJlc2VydmVzIHRoZSBleHBlY3RhdGlvbnMgb2YgdGhlIG9yaWdpbmFsIGZzLnN5bWxpbmsgc3BlYyBhbmQgYWRkc1xuICogdGhlIGFiaWxpdHkgdG8gcGFzcyBpbiBgcmVsYXRpdmUgdG8gY3VycmVudCB3b3JraW5nIGRpcmVjb3RyeWAgcGF0aHMuXG4gKi9cblxuYXN5bmMgZnVuY3Rpb24gc3ltbGlua1BhdGhzIChzcmNwYXRoLCBkc3RwYXRoKSB7XG4gIGlmIChwYXRoLmlzQWJzb2x1dGUoc3JjcGF0aCkpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZnMubHN0YXQoc3JjcGF0aClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVyci5tZXNzYWdlID0gZXJyLm1lc3NhZ2UucmVwbGFjZSgnbHN0YXQnLCAnZW5zdXJlU3ltbGluaycpXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG9Dd2Q6IHNyY3BhdGgsXG4gICAgICB0b0RzdDogc3JjcGF0aFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGRzdGRpciA9IHBhdGguZGlybmFtZShkc3RwYXRoKVxuICBjb25zdCByZWxhdGl2ZVRvRHN0ID0gcGF0aC5qb2luKGRzdGRpciwgc3JjcGF0aClcblxuICBjb25zdCBleGlzdHMgPSBhd2FpdCBwYXRoRXhpc3RzKHJlbGF0aXZlVG9Ec3QpXG4gIGlmIChleGlzdHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9Dd2Q6IHJlbGF0aXZlVG9Ec3QsXG4gICAgICB0b0RzdDogc3JjcGF0aFxuICAgIH1cbiAgfVxuXG4gIHRyeSB7XG4gICAgYXdhaXQgZnMubHN0YXQoc3JjcGF0aClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLm1lc3NhZ2UgPSBlcnIubWVzc2FnZS5yZXBsYWNlKCdsc3RhdCcsICdlbnN1cmVTeW1saW5rJylcbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9Dd2Q6IHNyY3BhdGgsXG4gICAgdG9Ec3Q6IHBhdGgucmVsYXRpdmUoZHN0ZGlyLCBzcmNwYXRoKVxuICB9XG59XG5cbmZ1bmN0aW9uIHN5bWxpbmtQYXRoc1N5bmMgKHNyY3BhdGgsIGRzdHBhdGgpIHtcbiAgaWYgKHBhdGguaXNBYnNvbHV0ZShzcmNwYXRoKSkge1xuICAgIGNvbnN0IGV4aXN0cyA9IGZzLmV4aXN0c1N5bmMoc3JjcGF0aClcbiAgICBpZiAoIWV4aXN0cykgdGhyb3cgbmV3IEVycm9yKCdhYnNvbHV0ZSBzcmNwYXRoIGRvZXMgbm90IGV4aXN0JylcbiAgICByZXR1cm4ge1xuICAgICAgdG9Dd2Q6IHNyY3BhdGgsXG4gICAgICB0b0RzdDogc3JjcGF0aFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGRzdGRpciA9IHBhdGguZGlybmFtZShkc3RwYXRoKVxuICBjb25zdCByZWxhdGl2ZVRvRHN0ID0gcGF0aC5qb2luKGRzdGRpciwgc3JjcGF0aClcbiAgY29uc3QgZXhpc3RzID0gZnMuZXhpc3RzU3luYyhyZWxhdGl2ZVRvRHN0KVxuICBpZiAoZXhpc3RzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvQ3dkOiByZWxhdGl2ZVRvRHN0LFxuICAgICAgdG9Ec3Q6IHNyY3BhdGhcbiAgICB9XG4gIH1cblxuICBjb25zdCBzcmNFeGlzdHMgPSBmcy5leGlzdHNTeW5jKHNyY3BhdGgpXG4gIGlmICghc3JjRXhpc3RzKSB0aHJvdyBuZXcgRXJyb3IoJ3JlbGF0aXZlIHNyY3BhdGggZG9lcyBub3QgZXhpc3QnKVxuICByZXR1cm4ge1xuICAgIHRvQ3dkOiBzcmNwYXRoLFxuICAgIHRvRHN0OiBwYXRoLnJlbGF0aXZlKGRzdGRpciwgc3JjcGF0aClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3ltbGlua1BhdGhzOiB1KHN5bWxpbmtQYXRocyksXG4gIHN5bWxpbmtQYXRoc1N5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL2ZzJylcbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tUHJvbWlzZVxuXG5hc3luYyBmdW5jdGlvbiBzeW1saW5rVHlwZSAoc3JjcGF0aCwgdHlwZSkge1xuICBpZiAodHlwZSkgcmV0dXJuIHR5cGVcblxuICBsZXQgc3RhdHNcbiAgdHJ5IHtcbiAgICBzdGF0cyA9IGF3YWl0IGZzLmxzdGF0KHNyY3BhdGgpXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAnZmlsZSdcbiAgfVxuXG4gIHJldHVybiAoc3RhdHMgJiYgc3RhdHMuaXNEaXJlY3RvcnkoKSkgPyAnZGlyJyA6ICdmaWxlJ1xufVxuXG5mdW5jdGlvbiBzeW1saW5rVHlwZVN5bmMgKHNyY3BhdGgsIHR5cGUpIHtcbiAgaWYgKHR5cGUpIHJldHVybiB0eXBlXG5cbiAgbGV0IHN0YXRzXG4gIHRyeSB7XG4gICAgc3RhdHMgPSBmcy5sc3RhdFN5bmMoc3JjcGF0aClcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICdmaWxlJ1xuICB9XG4gIHJldHVybiAoc3RhdHMgJiYgc3RhdHMuaXNEaXJlY3RvcnkoKSkgPyAnZGlyJyA6ICdmaWxlJ1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3ltbGlua1R5cGU6IHUoc3ltbGlua1R5cGUpLFxuICBzeW1saW5rVHlwZVN5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2VcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vZnMnKVxuXG5jb25zdCB7IG1rZGlycywgbWtkaXJzU3luYyB9ID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcblxuY29uc3QgeyBzeW1saW5rUGF0aHMsIHN5bWxpbmtQYXRoc1N5bmMgfSA9IHJlcXVpcmUoJy4vc3ltbGluay1wYXRocycpXG5jb25zdCB7IHN5bWxpbmtUeXBlLCBzeW1saW5rVHlwZVN5bmMgfSA9IHJlcXVpcmUoJy4vc3ltbGluay10eXBlJylcblxuY29uc3QgeyBwYXRoRXhpc3RzIH0gPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpXG5cbmNvbnN0IHsgYXJlSWRlbnRpY2FsIH0gPSByZXF1aXJlKCcuLi91dGlsL3N0YXQnKVxuXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVTeW1saW5rIChzcmNwYXRoLCBkc3RwYXRoLCB0eXBlKSB7XG4gIGxldCBzdGF0c1xuICB0cnkge1xuICAgIHN0YXRzID0gYXdhaXQgZnMubHN0YXQoZHN0cGF0aClcbiAgfSBjYXRjaCB7IH1cblxuICBpZiAoc3RhdHMgJiYgc3RhdHMuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgIGNvbnN0IFtzcmNTdGF0LCBkc3RTdGF0XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIGZzLnN0YXQoc3JjcGF0aCksXG4gICAgICBmcy5zdGF0KGRzdHBhdGgpXG4gICAgXSlcblxuICAgIGlmIChhcmVJZGVudGljYWwoc3JjU3RhdCwgZHN0U3RhdCkpIHJldHVyblxuICB9XG5cbiAgY29uc3QgcmVsYXRpdmUgPSBhd2FpdCBzeW1saW5rUGF0aHMoc3JjcGF0aCwgZHN0cGF0aClcbiAgc3JjcGF0aCA9IHJlbGF0aXZlLnRvRHN0XG4gIGNvbnN0IHRvVHlwZSA9IGF3YWl0IHN5bWxpbmtUeXBlKHJlbGF0aXZlLnRvQ3dkLCB0eXBlKVxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcblxuICBpZiAoIShhd2FpdCBwYXRoRXhpc3RzKGRpcikpKSB7XG4gICAgYXdhaXQgbWtkaXJzKGRpcilcbiAgfVxuXG4gIHJldHVybiBmcy5zeW1saW5rKHNyY3BhdGgsIGRzdHBhdGgsIHRvVHlwZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3ltbGlua1N5bmMgKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUpIHtcbiAgbGV0IHN0YXRzXG4gIHRyeSB7XG4gICAgc3RhdHMgPSBmcy5sc3RhdFN5bmMoZHN0cGF0aClcbiAgfSBjYXRjaCB7IH1cbiAgaWYgKHN0YXRzICYmIHN0YXRzLmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICBjb25zdCBzcmNTdGF0ID0gZnMuc3RhdFN5bmMoc3JjcGF0aClcbiAgICBjb25zdCBkc3RTdGF0ID0gZnMuc3RhdFN5bmMoZHN0cGF0aClcbiAgICBpZiAoYXJlSWRlbnRpY2FsKHNyY1N0YXQsIGRzdFN0YXQpKSByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHJlbGF0aXZlID0gc3ltbGlua1BhdGhzU3luYyhzcmNwYXRoLCBkc3RwYXRoKVxuICBzcmNwYXRoID0gcmVsYXRpdmUudG9Ec3RcbiAgdHlwZSA9IHN5bWxpbmtUeXBlU3luYyhyZWxhdGl2ZS50b0N3ZCwgdHlwZSlcbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGRzdHBhdGgpXG4gIGNvbnN0IGV4aXN0cyA9IGZzLmV4aXN0c1N5bmMoZGlyKVxuICBpZiAoZXhpc3RzKSByZXR1cm4gZnMuc3ltbGlua1N5bmMoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSlcbiAgbWtkaXJzU3luYyhkaXIpXG4gIHJldHVybiBmcy5zeW1saW5rU3luYyhzcmNwYXRoLCBkc3RwYXRoLCB0eXBlKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlU3ltbGluazogdShjcmVhdGVTeW1saW5rKSxcbiAgY3JlYXRlU3ltbGlua1N5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGNyZWF0ZUZpbGUsIGNyZWF0ZUZpbGVTeW5jIH0gPSByZXF1aXJlKCcuL2ZpbGUnKVxuY29uc3QgeyBjcmVhdGVMaW5rLCBjcmVhdGVMaW5rU3luYyB9ID0gcmVxdWlyZSgnLi9saW5rJylcbmNvbnN0IHsgY3JlYXRlU3ltbGluaywgY3JlYXRlU3ltbGlua1N5bmMgfSA9IHJlcXVpcmUoJy4vc3ltbGluaycpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBmaWxlXG4gIGNyZWF0ZUZpbGUsXG4gIGNyZWF0ZUZpbGVTeW5jLFxuICBlbnN1cmVGaWxlOiBjcmVhdGVGaWxlLFxuICBlbnN1cmVGaWxlU3luYzogY3JlYXRlRmlsZVN5bmMsXG4gIC8vIGxpbmtcbiAgY3JlYXRlTGluayxcbiAgY3JlYXRlTGlua1N5bmMsXG4gIGVuc3VyZUxpbms6IGNyZWF0ZUxpbmssXG4gIGVuc3VyZUxpbmtTeW5jOiBjcmVhdGVMaW5rU3luYyxcbiAgLy8gc3ltbGlua1xuICBjcmVhdGVTeW1saW5rLFxuICBjcmVhdGVTeW1saW5rU3luYyxcbiAgZW5zdXJlU3ltbGluazogY3JlYXRlU3ltbGluayxcbiAgZW5zdXJlU3ltbGlua1N5bmM6IGNyZWF0ZVN5bWxpbmtTeW5jXG59XG4iLCJmdW5jdGlvbiBzdHJpbmdpZnkgKG9iaiwgeyBFT0wgPSAnXFxuJywgZmluYWxFT0wgPSB0cnVlLCByZXBsYWNlciA9IG51bGwsIHNwYWNlcyB9ID0ge30pIHtcbiAgY29uc3QgRU9GID0gZmluYWxFT0wgPyBFT0wgOiAnJ1xuICBjb25zdCBzdHIgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VyLCBzcGFjZXMpXG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXG4vZywgRU9MKSArIEVPRlxufVxuXG5mdW5jdGlvbiBzdHJpcEJvbSAoY29udGVudCkge1xuICAvLyB3ZSBkbyB0aGlzIGJlY2F1c2UgSlNPTi5wYXJzZSB3b3VsZCBjb252ZXJ0IGl0IHRvIGEgdXRmOCBzdHJpbmcgaWYgZW5jb2Rpbmcgd2Fzbid0IHNwZWNpZmllZFxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNvbnRlbnQpKSBjb250ZW50ID0gY29udGVudC50b1N0cmluZygndXRmOCcpXG4gIHJldHVybiBjb250ZW50LnJlcGxhY2UoL15cXHVGRUZGLywgJycpXG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBzdHJpbmdpZnksIHN0cmlwQm9tIH1cbiIsImxldCBfZnNcbnRyeSB7XG4gIF9mcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbn0gY2F0Y2ggKF8pIHtcbiAgX2ZzID0gcmVxdWlyZSgnZnMnKVxufVxuY29uc3QgdW5pdmVyc2FsaWZ5ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JylcbmNvbnN0IHsgc3RyaW5naWZ5LCBzdHJpcEJvbSB9ID0gcmVxdWlyZSgnLi91dGlscycpXG5cbmFzeW5jIGZ1bmN0aW9uIF9yZWFkRmlsZSAoZmlsZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zID0geyBlbmNvZGluZzogb3B0aW9ucyB9XG4gIH1cblxuICBjb25zdCBmcyA9IG9wdGlvbnMuZnMgfHwgX2ZzXG5cbiAgY29uc3Qgc2hvdWxkVGhyb3cgPSAndGhyb3dzJyBpbiBvcHRpb25zID8gb3B0aW9ucy50aHJvd3MgOiB0cnVlXG5cbiAgbGV0IGRhdGEgPSBhd2FpdCB1bml2ZXJzYWxpZnkuZnJvbUNhbGxiYWNrKGZzLnJlYWRGaWxlKShmaWxlLCBvcHRpb25zKVxuXG4gIGRhdGEgPSBzdHJpcEJvbShkYXRhKVxuXG4gIGxldCBvYmpcbiAgdHJ5IHtcbiAgICBvYmogPSBKU09OLnBhcnNlKGRhdGEsIG9wdGlvbnMgPyBvcHRpb25zLnJldml2ZXIgOiBudWxsKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoc2hvdWxkVGhyb3cpIHtcbiAgICAgIGVyci5tZXNzYWdlID0gYCR7ZmlsZX06ICR7ZXJyLm1lc3NhZ2V9YFxuICAgICAgdGhyb3cgZXJyXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9ialxufVxuXG5jb25zdCByZWFkRmlsZSA9IHVuaXZlcnNhbGlmeS5mcm9tUHJvbWlzZShfcmVhZEZpbGUpXG5cbmZ1bmN0aW9uIHJlYWRGaWxlU3luYyAoZmlsZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zID0geyBlbmNvZGluZzogb3B0aW9ucyB9XG4gIH1cblxuICBjb25zdCBmcyA9IG9wdGlvbnMuZnMgfHwgX2ZzXG5cbiAgY29uc3Qgc2hvdWxkVGhyb3cgPSAndGhyb3dzJyBpbiBvcHRpb25zID8gb3B0aW9ucy50aHJvd3MgOiB0cnVlXG5cbiAgdHJ5IHtcbiAgICBsZXQgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhmaWxlLCBvcHRpb25zKVxuICAgIGNvbnRlbnQgPSBzdHJpcEJvbShjb250ZW50KVxuICAgIHJldHVybiBKU09OLnBhcnNlKGNvbnRlbnQsIG9wdGlvbnMucmV2aXZlcilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHNob3VsZFRocm93KSB7XG4gICAgICBlcnIubWVzc2FnZSA9IGAke2ZpbGV9OiAke2Vyci5tZXNzYWdlfWBcbiAgICAgIHRocm93IGVyclxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBfd3JpdGVGaWxlIChmaWxlLCBvYmosIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBmcyA9IG9wdGlvbnMuZnMgfHwgX2ZzXG5cbiAgY29uc3Qgc3RyID0gc3RyaW5naWZ5KG9iaiwgb3B0aW9ucylcblxuICBhd2FpdCB1bml2ZXJzYWxpZnkuZnJvbUNhbGxiYWNrKGZzLndyaXRlRmlsZSkoZmlsZSwgc3RyLCBvcHRpb25zKVxufVxuXG5jb25zdCB3cml0ZUZpbGUgPSB1bml2ZXJzYWxpZnkuZnJvbVByb21pc2UoX3dyaXRlRmlsZSlcblxuZnVuY3Rpb24gd3JpdGVGaWxlU3luYyAoZmlsZSwgb2JqLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgZnMgPSBvcHRpb25zLmZzIHx8IF9mc1xuXG4gIGNvbnN0IHN0ciA9IHN0cmluZ2lmeShvYmosIG9wdGlvbnMpXG4gIC8vIG5vdCBzdXJlIGlmIGZzLndyaXRlRmlsZVN5bmMgcmV0dXJucyBhbnl0aGluZywgYnV0IGp1c3QgaW4gY2FzZVxuICByZXR1cm4gZnMud3JpdGVGaWxlU3luYyhmaWxlLCBzdHIsIG9wdGlvbnMpXG59XG5cbmNvbnN0IGpzb25maWxlID0ge1xuICByZWFkRmlsZSxcbiAgcmVhZEZpbGVTeW5jLFxuICB3cml0ZUZpbGUsXG4gIHdyaXRlRmlsZVN5bmNcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBqc29uZmlsZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGpzb25GaWxlID0gcmVxdWlyZSgnanNvbmZpbGUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8ganNvbmZpbGUgZXhwb3J0c1xuICByZWFkSnNvbjoganNvbkZpbGUucmVhZEZpbGUsXG4gIHJlYWRKc29uU3luYzoganNvbkZpbGUucmVhZEZpbGVTeW5jLFxuICB3cml0ZUpzb246IGpzb25GaWxlLndyaXRlRmlsZSxcbiAgd3JpdGVKc29uU3luYzoganNvbkZpbGUud3JpdGVGaWxlU3luY1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tUHJvbWlzZVxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBta2RpciA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKS5wYXRoRXhpc3RzXG5cbmFzeW5jIGZ1bmN0aW9uIG91dHB1dEZpbGUgKGZpbGUsIGRhdGEsIGVuY29kaW5nID0gJ3V0Zi04Jykge1xuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZmlsZSlcblxuICBpZiAoIShhd2FpdCBwYXRoRXhpc3RzKGRpcikpKSB7XG4gICAgYXdhaXQgbWtkaXIubWtkaXJzKGRpcilcbiAgfVxuXG4gIHJldHVybiBmcy53cml0ZUZpbGUoZmlsZSwgZGF0YSwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIG91dHB1dEZpbGVTeW5jIChmaWxlLCAuLi5hcmdzKSB7XG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShmaWxlKVxuICBpZiAoIWZzLmV4aXN0c1N5bmMoZGlyKSkge1xuICAgIG1rZGlyLm1rZGlyc1N5bmMoZGlyKVxuICB9XG5cbiAgZnMud3JpdGVGaWxlU3luYyhmaWxlLCAuLi5hcmdzKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgb3V0cHV0RmlsZTogdShvdXRwdXRGaWxlKSxcbiAgb3V0cHV0RmlsZVN5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHN0cmluZ2lmeSB9ID0gcmVxdWlyZSgnanNvbmZpbGUvdXRpbHMnKVxuY29uc3QgeyBvdXRwdXRGaWxlIH0gPSByZXF1aXJlKCcuLi9vdXRwdXQtZmlsZScpXG5cbmFzeW5jIGZ1bmN0aW9uIG91dHB1dEpzb24gKGZpbGUsIGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBzdHIgPSBzdHJpbmdpZnkoZGF0YSwgb3B0aW9ucylcblxuICBhd2FpdCBvdXRwdXRGaWxlKGZpbGUsIHN0ciwgb3B0aW9ucylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdXRwdXRKc29uXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBzdHJpbmdpZnkgfSA9IHJlcXVpcmUoJ2pzb25maWxlL3V0aWxzJylcbmNvbnN0IHsgb3V0cHV0RmlsZVN5bmMgfSA9IHJlcXVpcmUoJy4uL291dHB1dC1maWxlJylcblxuZnVuY3Rpb24gb3V0cHV0SnNvblN5bmMgKGZpbGUsIGRhdGEsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc3RyID0gc3RyaW5naWZ5KGRhdGEsIG9wdGlvbnMpXG5cbiAgb3V0cHV0RmlsZVN5bmMoZmlsZSwgc3RyLCBvcHRpb25zKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG91dHB1dEpzb25TeW5jXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21Qcm9taXNlXG5jb25zdCBqc29uRmlsZSA9IHJlcXVpcmUoJy4vanNvbmZpbGUnKVxuXG5qc29uRmlsZS5vdXRwdXRKc29uID0gdShyZXF1aXJlKCcuL291dHB1dC1qc29uJykpXG5qc29uRmlsZS5vdXRwdXRKc29uU3luYyA9IHJlcXVpcmUoJy4vb3V0cHV0LWpzb24tc3luYycpXG4vLyBhbGlhc2VzXG5qc29uRmlsZS5vdXRwdXRKU09OID0ganNvbkZpbGUub3V0cHV0SnNvblxuanNvbkZpbGUub3V0cHV0SlNPTlN5bmMgPSBqc29uRmlsZS5vdXRwdXRKc29uU3luY1xuanNvbkZpbGUud3JpdGVKU09OID0ganNvbkZpbGUud3JpdGVKc29uXG5qc29uRmlsZS53cml0ZUpTT05TeW5jID0ganNvbkZpbGUud3JpdGVKc29uU3luY1xuanNvbkZpbGUucmVhZEpTT04gPSBqc29uRmlsZS5yZWFkSnNvblxuanNvbkZpbGUucmVhZEpTT05TeW5jID0ganNvbkZpbGUucmVhZEpzb25TeW5jXG5cbm1vZHVsZS5leHBvcnRzID0ganNvbkZpbGVcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL2ZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IHsgY29weSB9ID0gcmVxdWlyZSgnLi4vY29weScpXG5jb25zdCB7IHJlbW92ZSB9ID0gcmVxdWlyZSgnLi4vcmVtb3ZlJylcbmNvbnN0IHsgbWtkaXJwIH0gPSByZXF1aXJlKCcuLi9ta2RpcnMnKVxuY29uc3QgeyBwYXRoRXhpc3RzIH0gPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpXG5jb25zdCBzdGF0ID0gcmVxdWlyZSgnLi4vdXRpbC9zdGF0JylcblxuYXN5bmMgZnVuY3Rpb24gbW92ZSAoc3JjLCBkZXN0LCBvcHRzID0ge30pIHtcbiAgY29uc3Qgb3ZlcndyaXRlID0gb3B0cy5vdmVyd3JpdGUgfHwgb3B0cy5jbG9iYmVyIHx8IGZhbHNlXG5cbiAgY29uc3QgeyBzcmNTdGF0LCBpc0NoYW5naW5nQ2FzZSA9IGZhbHNlIH0gPSBhd2FpdCBzdGF0LmNoZWNrUGF0aHMoc3JjLCBkZXN0LCAnbW92ZScsIG9wdHMpXG5cbiAgYXdhaXQgc3RhdC5jaGVja1BhcmVudFBhdGhzKHNyYywgc3JjU3RhdCwgZGVzdCwgJ21vdmUnKVxuXG4gIC8vIElmIHRoZSBwYXJlbnQgb2YgZGVzdCBpcyBub3Qgcm9vdCwgbWFrZSBzdXJlIGl0IGV4aXN0cyBiZWZvcmUgcHJvY2VlZGluZ1xuICBjb25zdCBkZXN0UGFyZW50ID0gcGF0aC5kaXJuYW1lKGRlc3QpXG4gIGNvbnN0IHBhcnNlZFBhcmVudFBhdGggPSBwYXRoLnBhcnNlKGRlc3RQYXJlbnQpXG4gIGlmIChwYXJzZWRQYXJlbnRQYXRoLnJvb3QgIT09IGRlc3RQYXJlbnQpIHtcbiAgICBhd2FpdCBta2RpcnAoZGVzdFBhcmVudClcbiAgfVxuXG4gIHJldHVybiBkb1JlbmFtZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgaXNDaGFuZ2luZ0Nhc2UpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRvUmVuYW1lIChzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgaXNDaGFuZ2luZ0Nhc2UpIHtcbiAgaWYgKCFpc0NoYW5naW5nQ2FzZSkge1xuICAgIGlmIChvdmVyd3JpdGUpIHtcbiAgICAgIGF3YWl0IHJlbW92ZShkZXN0KVxuICAgIH0gZWxzZSBpZiAoYXdhaXQgcGF0aEV4aXN0cyhkZXN0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZXN0IGFscmVhZHkgZXhpc3RzLicpXG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUcnkgdy8gcmVuYW1lIGZpcnN0LCBhbmQgdHJ5IGNvcHkgKyByZW1vdmUgaWYgRVhERVZcbiAgICBhd2FpdCBmcy5yZW5hbWUoc3JjLCBkZXN0KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgIT09ICdFWERFVicpIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgICBhd2FpdCBtb3ZlQWNyb3NzRGV2aWNlKHNyYywgZGVzdCwgb3ZlcndyaXRlKVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG1vdmVBY3Jvc3NEZXZpY2UgKHNyYywgZGVzdCwgb3ZlcndyaXRlKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgb3ZlcndyaXRlLFxuICAgIGVycm9yT25FeGlzdDogdHJ1ZSxcbiAgICBwcmVzZXJ2ZVRpbWVzdGFtcHM6IHRydWVcbiAgfVxuXG4gIGF3YWl0IGNvcHkoc3JjLCBkZXN0LCBvcHRzKVxuICByZXR1cm4gcmVtb3ZlKHNyYylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtb3ZlXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBjb3B5U3luYyA9IHJlcXVpcmUoJy4uL2NvcHknKS5jb3B5U3luY1xuY29uc3QgcmVtb3ZlU3luYyA9IHJlcXVpcmUoJy4uL3JlbW92ZScpLnJlbW92ZVN5bmNcbmNvbnN0IG1rZGlycFN5bmMgPSByZXF1aXJlKCcuLi9ta2RpcnMnKS5ta2RpcnBTeW5jXG5jb25zdCBzdGF0ID0gcmVxdWlyZSgnLi4vdXRpbC9zdGF0JylcblxuZnVuY3Rpb24gbW92ZVN5bmMgKHNyYywgZGVzdCwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fVxuICBjb25zdCBvdmVyd3JpdGUgPSBvcHRzLm92ZXJ3cml0ZSB8fCBvcHRzLmNsb2JiZXIgfHwgZmFsc2VcblxuICBjb25zdCB7IHNyY1N0YXQsIGlzQ2hhbmdpbmdDYXNlID0gZmFsc2UgfSA9IHN0YXQuY2hlY2tQYXRoc1N5bmMoc3JjLCBkZXN0LCAnbW92ZScsIG9wdHMpXG4gIHN0YXQuY2hlY2tQYXJlbnRQYXRoc1N5bmMoc3JjLCBzcmNTdGF0LCBkZXN0LCAnbW92ZScpXG4gIGlmICghaXNQYXJlbnRSb290KGRlc3QpKSBta2RpcnBTeW5jKHBhdGguZGlybmFtZShkZXN0KSlcbiAgcmV0dXJuIGRvUmVuYW1lKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBpc0NoYW5naW5nQ2FzZSlcbn1cblxuZnVuY3Rpb24gaXNQYXJlbnRSb290IChkZXN0KSB7XG4gIGNvbnN0IHBhcmVudCA9IHBhdGguZGlybmFtZShkZXN0KVxuICBjb25zdCBwYXJzZWRQYXRoID0gcGF0aC5wYXJzZShwYXJlbnQpXG4gIHJldHVybiBwYXJzZWRQYXRoLnJvb3QgPT09IHBhcmVudFxufVxuXG5mdW5jdGlvbiBkb1JlbmFtZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGlzQ2hhbmdpbmdDYXNlKSB7XG4gIGlmIChpc0NoYW5naW5nQ2FzZSkgcmV0dXJuIHJlbmFtZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSlcbiAgaWYgKG92ZXJ3cml0ZSkge1xuICAgIHJlbW92ZVN5bmMoZGVzdClcbiAgICByZXR1cm4gcmVuYW1lKHNyYywgZGVzdCwgb3ZlcndyaXRlKVxuICB9XG4gIGlmIChmcy5leGlzdHNTeW5jKGRlc3QpKSB0aHJvdyBuZXcgRXJyb3IoJ2Rlc3QgYWxyZWFkeSBleGlzdHMuJylcbiAgcmV0dXJuIHJlbmFtZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSlcbn1cblxuZnVuY3Rpb24gcmVuYW1lIChzcmMsIGRlc3QsIG92ZXJ3cml0ZSkge1xuICB0cnkge1xuICAgIGZzLnJlbmFtZVN5bmMoc3JjLCBkZXN0KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgIT09ICdFWERFVicpIHRocm93IGVyclxuICAgIHJldHVybiBtb3ZlQWNyb3NzRGV2aWNlKHNyYywgZGVzdCwgb3ZlcndyaXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vdmVBY3Jvc3NEZXZpY2UgKHNyYywgZGVzdCwgb3ZlcndyaXRlKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgb3ZlcndyaXRlLFxuICAgIGVycm9yT25FeGlzdDogdHJ1ZSxcbiAgICBwcmVzZXJ2ZVRpbWVzdGFtcHM6IHRydWVcbiAgfVxuICBjb3B5U3luYyhzcmMsIGRlc3QsIG9wdHMpXG4gIHJldHVybiByZW1vdmVTeW5jKHNyYylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtb3ZlU3luY1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tUHJvbWlzZVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1vdmU6IHUocmVxdWlyZSgnLi9tb3ZlJykpLFxuICBtb3ZlU3luYzogcmVxdWlyZSgnLi9tb3ZlLXN5bmMnKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBFeHBvcnQgcHJvbWlzZWlmaWVkIGdyYWNlZnVsLWZzOlxuICAuLi5yZXF1aXJlKCcuL2ZzJyksXG4gIC8vIEV4cG9ydCBleHRyYSBtZXRob2RzOlxuICAuLi5yZXF1aXJlKCcuL2NvcHknKSxcbiAgLi4ucmVxdWlyZSgnLi9lbXB0eScpLFxuICAuLi5yZXF1aXJlKCcuL2Vuc3VyZScpLFxuICAuLi5yZXF1aXJlKCcuL2pzb24nKSxcbiAgLi4ucmVxdWlyZSgnLi9ta2RpcnMnKSxcbiAgLi4ucmVxdWlyZSgnLi9tb3ZlJyksXG4gIC4uLnJlcXVpcmUoJy4vb3V0cHV0LWZpbGUnKSxcbiAgLi4ucmVxdWlyZSgnLi9wYXRoLWV4aXN0cycpLFxuICAuLi5yZXF1aXJlKCcuL3JlbW92ZScpXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gdmFsdWUgPT4ge1xuXHRjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXHRyZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IGlzT2JqID0gcmVxdWlyZSgnaXMtb2JqJyk7XG5cbmNvbnN0IGRpc2FsbG93ZWRLZXlzID0gbmV3IFNldChbXG5cdCdfX3Byb3RvX18nLFxuXHQncHJvdG90eXBlJyxcblx0J2NvbnN0cnVjdG9yJ1xuXSk7XG5cbmNvbnN0IGlzVmFsaWRQYXRoID0gcGF0aFNlZ21lbnRzID0+ICFwYXRoU2VnbWVudHMuc29tZShzZWdtZW50ID0+IGRpc2FsbG93ZWRLZXlzLmhhcyhzZWdtZW50KSk7XG5cbmZ1bmN0aW9uIGdldFBhdGhTZWdtZW50cyhwYXRoKSB7XG5cdGNvbnN0IHBhdGhBcnJheSA9IHBhdGguc3BsaXQoJy4nKTtcblx0Y29uc3QgcGFydHMgPSBbXTtcblxuXHRmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhBcnJheS5sZW5ndGg7IGkrKykge1xuXHRcdGxldCBwID0gcGF0aEFycmF5W2ldO1xuXG5cdFx0d2hpbGUgKHBbcC5sZW5ndGggLSAxXSA9PT0gJ1xcXFwnICYmIHBhdGhBcnJheVtpICsgMV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cCA9IHAuc2xpY2UoMCwgLTEpICsgJy4nO1xuXHRcdFx0cCArPSBwYXRoQXJyYXlbKytpXTtcblx0XHR9XG5cblx0XHRwYXJ0cy5wdXNoKHApO1xuXHR9XG5cblx0aWYgKCFpc1ZhbGlkUGF0aChwYXJ0cykpIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblxuXHRyZXR1cm4gcGFydHM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRnZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuXHRcdGlmICghaXNPYmoob2JqZWN0KSB8fCB0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gb2JqZWN0IDogdmFsdWU7XG5cdFx0fVxuXG5cdFx0Y29uc3QgcGF0aEFycmF5ID0gZ2V0UGF0aFNlZ21lbnRzKHBhdGgpO1xuXHRcdGlmIChwYXRoQXJyYXkubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoQXJyYXkubGVuZ3RoOyBpKyspIHtcblx0XHRcdG9iamVjdCA9IG9iamVjdFtwYXRoQXJyYXlbaV1dO1xuXG5cdFx0XHRpZiAob2JqZWN0ID09PSB1bmRlZmluZWQgfHwgb2JqZWN0ID09PSBudWxsKSB7XG5cdFx0XHRcdC8vIGBvYmplY3RgIGlzIGVpdGhlciBgdW5kZWZpbmVkYCBvciBgbnVsbGAgc28gd2Ugd2FudCB0byBzdG9wIHRoZSBsb29wLCBhbmRcblx0XHRcdFx0Ly8gaWYgdGhpcyBpcyBub3QgdGhlIGxhc3QgYml0IG9mIHRoZSBwYXRoLCBhbmRcblx0XHRcdFx0Ly8gaWYgaXQgZGlkJ3QgcmV0dXJuIGB1bmRlZmluZWRgXG5cdFx0XHRcdC8vIGl0IHdvdWxkIHJldHVybiBgbnVsbGAgaWYgYG9iamVjdGAgaXMgYG51bGxgXG5cdFx0XHRcdC8vIGJ1dCB3ZSB3YW50IGBnZXQoe2ZvbzogbnVsbH0sICdmb28uYmFyJylgIHRvIGVxdWFsIGB1bmRlZmluZWRgLCBvciB0aGUgc3VwcGxpZWQgdmFsdWUsIG5vdCBgbnVsbGBcblx0XHRcdFx0aWYgKGkgIT09IHBhdGhBcnJheS5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iamVjdCA9PT0gdW5kZWZpbmVkID8gdmFsdWUgOiBvYmplY3Q7XG5cdH0sXG5cblx0c2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcblx0XHRpZiAoIWlzT2JqKG9iamVjdCkgfHwgdHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gb2JqZWN0O1xuXHRcdH1cblxuXHRcdGNvbnN0IHJvb3QgPSBvYmplY3Q7XG5cdFx0Y29uc3QgcGF0aEFycmF5ID0gZ2V0UGF0aFNlZ21lbnRzKHBhdGgpO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoQXJyYXkubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IHAgPSBwYXRoQXJyYXlbaV07XG5cblx0XHRcdGlmICghaXNPYmoob2JqZWN0W3BdKSkge1xuXHRcdFx0XHRvYmplY3RbcF0gPSB7fTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGkgPT09IHBhdGhBcnJheS5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdG9iamVjdFtwXSA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHRvYmplY3QgPSBvYmplY3RbcF07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJvb3Q7XG5cdH0sXG5cblx0ZGVsZXRlKG9iamVjdCwgcGF0aCkge1xuXHRcdGlmICghaXNPYmoob2JqZWN0KSB8fCB0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRjb25zdCBwYXRoQXJyYXkgPSBnZXRQYXRoU2VnbWVudHMocGF0aCk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhBcnJheS5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgcCA9IHBhdGhBcnJheVtpXTtcblxuXHRcdFx0aWYgKGkgPT09IHBhdGhBcnJheS5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdGRlbGV0ZSBvYmplY3RbcF07XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRvYmplY3QgPSBvYmplY3RbcF07XG5cblx0XHRcdGlmICghaXNPYmoob2JqZWN0KSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGhhcyhvYmplY3QsIHBhdGgpIHtcblx0XHRpZiAoIWlzT2JqKG9iamVjdCkgfHwgdHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Y29uc3QgcGF0aEFycmF5ID0gZ2V0UGF0aFNlZ21lbnRzKHBhdGgpO1xuXHRcdGlmIChwYXRoQXJyYXkubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vbm8tZm9yLWxvb3Bcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhBcnJheS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGlzT2JqKG9iamVjdCkpIHtcblx0XHRcdFx0aWYgKCEocGF0aEFycmF5W2ldIGluIG9iamVjdCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvYmplY3QgPSBvYmplY3RbcGF0aEFycmF5W2ldXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmcCA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcblx0ZnMuYWNjZXNzKGZwLCBlcnIgPT4ge1xuXHRcdHJlc29sdmUoIWVycik7XG5cdH0pO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzLnN5bmMgPSBmcCA9PiB7XG5cdHRyeSB7XG5cdFx0ZnMuYWNjZXNzU3luYyhmcCk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgcFRyeSA9IChmbiwgLi4uYXJndW1lbnRzXykgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG5cdHJlc29sdmUoZm4oLi4uYXJndW1lbnRzXykpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcFRyeTtcbi8vIFRPRE86IHJlbW92ZSB0aGlzIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb25cbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBwVHJ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcFRyeSA9IHJlcXVpcmUoJ3AtdHJ5Jyk7XG5cbmNvbnN0IHBMaW1pdCA9IGNvbmN1cnJlbmN5ID0+IHtcblx0aWYgKCEoKE51bWJlci5pc0ludGVnZXIoY29uY3VycmVuY3kpIHx8IGNvbmN1cnJlbmN5ID09PSBJbmZpbml0eSkgJiYgY29uY3VycmVuY3kgPiAwKSkge1xuXHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBgY29uY3VycmVuY3lgIHRvIGJlIGEgbnVtYmVyIGZyb20gMSBhbmQgdXAnKSk7XG5cdH1cblxuXHRjb25zdCBxdWV1ZSA9IFtdO1xuXHRsZXQgYWN0aXZlQ291bnQgPSAwO1xuXG5cdGNvbnN0IG5leHQgPSAoKSA9PiB7XG5cdFx0YWN0aXZlQ291bnQtLTtcblxuXHRcdGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG5cdFx0XHRxdWV1ZS5zaGlmdCgpKCk7XG5cdFx0fVxuXHR9O1xuXG5cdGNvbnN0IHJ1biA9IChmbiwgcmVzb2x2ZSwgLi4uYXJncykgPT4ge1xuXHRcdGFjdGl2ZUNvdW50Kys7XG5cblx0XHRjb25zdCByZXN1bHQgPSBwVHJ5KGZuLCAuLi5hcmdzKTtcblxuXHRcdHJlc29sdmUocmVzdWx0KTtcblxuXHRcdHJlc3VsdC50aGVuKG5leHQsIG5leHQpO1xuXHR9O1xuXG5cdGNvbnN0IGVucXVldWUgPSAoZm4sIHJlc29sdmUsIC4uLmFyZ3MpID0+IHtcblx0XHRpZiAoYWN0aXZlQ291bnQgPCBjb25jdXJyZW5jeSkge1xuXHRcdFx0cnVuKGZuLCByZXNvbHZlLCAuLi5hcmdzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cXVldWUucHVzaChydW4uYmluZChudWxsLCBmbiwgcmVzb2x2ZSwgLi4uYXJncykpO1xuXHRcdH1cblx0fTtcblxuXHRjb25zdCBnZW5lcmF0b3IgPSAoZm4sIC4uLmFyZ3MpID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gZW5xdWV1ZShmbiwgcmVzb2x2ZSwgLi4uYXJncykpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhnZW5lcmF0b3IsIHtcblx0XHRhY3RpdmVDb3VudDoge1xuXHRcdFx0Z2V0OiAoKSA9PiBhY3RpdmVDb3VudFxuXHRcdH0sXG5cdFx0cGVuZGluZ0NvdW50OiB7XG5cdFx0XHRnZXQ6ICgpID0+IHF1ZXVlLmxlbmd0aFxuXHRcdH0sXG5cdFx0Y2xlYXJRdWV1ZToge1xuXHRcdFx0dmFsdWU6ICgpID0+IHtcblx0XHRcdFx0cXVldWUubGVuZ3RoID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBnZW5lcmF0b3I7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBMaW1pdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBwTGltaXQ7XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBwTGltaXQgPSByZXF1aXJlKCdwLWxpbWl0Jyk7XG5cbmNsYXNzIEVuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHR9XG59XG5cbi8vIFRoZSBpbnB1dCBjYW4gYWxzbyBiZSBhIHByb21pc2UsIHNvIHdlIGBQcm9taXNlLnJlc29sdmUoKWAgaXRcbmNvbnN0IHRlc3RFbGVtZW50ID0gKGVsLCB0ZXN0ZXIpID0+IFByb21pc2UucmVzb2x2ZShlbCkudGhlbih0ZXN0ZXIpO1xuXG4vLyBUaGUgaW5wdXQgY2FuIGFsc28gYmUgYSBwcm9taXNlLCBzbyB3ZSBgUHJvbWlzZS5hbGwoKWAgdGhlbSBib3RoXG5jb25zdCBmaW5kZXIgPSBlbCA9PiBQcm9taXNlLmFsbChlbCkudGhlbih2YWwgPT4gdmFsWzFdID09PSB0cnVlICYmIFByb21pc2UucmVqZWN0KG5ldyBFbmRFcnJvcih2YWxbMF0pKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGl0ZXJhYmxlLCB0ZXN0ZXIsIG9wdHMpID0+IHtcblx0b3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdGNvbmN1cnJlbmN5OiBJbmZpbml0eSxcblx0XHRwcmVzZXJ2ZU9yZGVyOiB0cnVlXG5cdH0sIG9wdHMpO1xuXG5cdGNvbnN0IGxpbWl0ID0gcExpbWl0KG9wdHMuY29uY3VycmVuY3kpO1xuXG5cdC8vIFN0YXJ0IGFsbCB0aGUgcHJvbWlzZXMgY29uY3VycmVudGx5IHdpdGggb3B0aW9uYWwgbGltaXRcblx0Y29uc3QgaXRlbXMgPSBbLi4uaXRlcmFibGVdLm1hcChlbCA9PiBbZWwsIGxpbWl0KHRlc3RFbGVtZW50LCBlbCwgdGVzdGVyKV0pO1xuXG5cdC8vIENoZWNrIHRoZSBwcm9taXNlcyBlaXRoZXIgc2VyaWFsbHkgb3IgY29uY3VycmVudGx5XG5cdGNvbnN0IGNoZWNrTGltaXQgPSBwTGltaXQob3B0cy5wcmVzZXJ2ZU9yZGVyID8gMSA6IEluZmluaXR5KTtcblxuXHRyZXR1cm4gUHJvbWlzZS5hbGwoaXRlbXMubWFwKGVsID0+IGNoZWNrTGltaXQoZmluZGVyLCBlbCkpKVxuXHRcdC50aGVuKCgpID0+IHt9KVxuXHRcdC5jYXRjaChlcnIgPT4gZXJyIGluc3RhbmNlb2YgRW5kRXJyb3IgPyBlcnIudmFsdWUgOiBQcm9taXNlLnJlamVjdChlcnIpKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgcGF0aEV4aXN0cyA9IHJlcXVpcmUoJ3BhdGgtZXhpc3RzJyk7XG5jb25zdCBwTG9jYXRlID0gcmVxdWlyZSgncC1sb2NhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoaXRlcmFibGUsIG9wdGlvbnMpID0+IHtcblx0b3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdGN3ZDogcHJvY2Vzcy5jd2QoKVxuXHR9LCBvcHRpb25zKTtcblxuXHRyZXR1cm4gcExvY2F0ZShpdGVyYWJsZSwgZWwgPT4gcGF0aEV4aXN0cyhwYXRoLnJlc29sdmUob3B0aW9ucy5jd2QsIGVsKSksIG9wdGlvbnMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuc3luYyA9IChpdGVyYWJsZSwgb3B0aW9ucykgPT4ge1xuXHRvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0Y3dkOiBwcm9jZXNzLmN3ZCgpXG5cdH0sIG9wdGlvbnMpO1xuXG5cdGZvciAoY29uc3QgZWwgb2YgaXRlcmFibGUpIHtcblx0XHRpZiAocGF0aEV4aXN0cy5zeW5jKHBhdGgucmVzb2x2ZShvcHRpb25zLmN3ZCwgZWwpKSkge1xuXHRcdFx0cmV0dXJuIGVsO1xuXHRcdH1cblx0fVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBsb2NhdGVQYXRoID0gcmVxdWlyZSgnbG9jYXRlLXBhdGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZmlsZW5hbWUsIG9wdHMgPSB7fSkgPT4ge1xuXHRjb25zdCBzdGFydERpciA9IHBhdGgucmVzb2x2ZShvcHRzLmN3ZCB8fCAnJyk7XG5cdGNvbnN0IHtyb290fSA9IHBhdGgucGFyc2Uoc3RhcnREaXIpO1xuXG5cdGNvbnN0IGZpbGVuYW1lcyA9IFtdLmNvbmNhdChmaWxlbmFtZSk7XG5cblx0cmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuXHRcdChmdW5jdGlvbiBmaW5kKGRpcikge1xuXHRcdFx0bG9jYXRlUGF0aChmaWxlbmFtZXMsIHtjd2Q6IGRpcn0pLnRoZW4oZmlsZSA9PiB7XG5cdFx0XHRcdGlmIChmaWxlKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShwYXRoLmpvaW4oZGlyLCBmaWxlKSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZGlyID09PSByb290KSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShudWxsKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmaW5kKHBhdGguZGlybmFtZShkaXIpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSkoc3RhcnREaXIpO1xuXHR9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnN5bmMgPSAoZmlsZW5hbWUsIG9wdHMgPSB7fSkgPT4ge1xuXHRsZXQgZGlyID0gcGF0aC5yZXNvbHZlKG9wdHMuY3dkIHx8ICcnKTtcblx0Y29uc3Qge3Jvb3R9ID0gcGF0aC5wYXJzZShkaXIpO1xuXG5cdGNvbnN0IGZpbGVuYW1lcyA9IFtdLmNvbmNhdChmaWxlbmFtZSk7XG5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuXHR3aGlsZSAodHJ1ZSkge1xuXHRcdGNvbnN0IGZpbGUgPSBsb2NhdGVQYXRoLnN5bmMoZmlsZW5hbWVzLCB7Y3dkOiBkaXJ9KTtcblxuXHRcdGlmIChmaWxlKSB7XG5cdFx0XHRyZXR1cm4gcGF0aC5qb2luKGRpciwgZmlsZSk7XG5cdFx0fVxuXG5cdFx0aWYgKGRpciA9PT0gcm9vdCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0ZGlyID0gcGF0aC5kaXJuYW1lKGRpcik7XG5cdH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBmaW5kVXAgPSByZXF1aXJlKCdmaW5kLXVwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXN5bmMgKHtjd2R9ID0ge30pID0+IGZpbmRVcCgncGFja2FnZS5qc29uJywge2N3ZH0pO1xubW9kdWxlLmV4cG9ydHMuc3luYyA9ICh7Y3dkfSA9IHt9KSA9PiBmaW5kVXAuc3luYygncGFja2FnZS5qc29uJywge2N3ZH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcblxuY29uc3QgaG9tZWRpciA9IG9zLmhvbWVkaXIoKTtcbmNvbnN0IHRtcGRpciA9IG9zLnRtcGRpcigpO1xuY29uc3Qge2Vudn0gPSBwcm9jZXNzO1xuXG5jb25zdCBtYWNvcyA9IG5hbWUgPT4ge1xuXHRjb25zdCBsaWJyYXJ5ID0gcGF0aC5qb2luKGhvbWVkaXIsICdMaWJyYXJ5Jyk7XG5cblx0cmV0dXJuIHtcblx0XHRkYXRhOiBwYXRoLmpvaW4obGlicmFyeSwgJ0FwcGxpY2F0aW9uIFN1cHBvcnQnLCBuYW1lKSxcblx0XHRjb25maWc6IHBhdGguam9pbihsaWJyYXJ5LCAnUHJlZmVyZW5jZXMnLCBuYW1lKSxcblx0XHRjYWNoZTogcGF0aC5qb2luKGxpYnJhcnksICdDYWNoZXMnLCBuYW1lKSxcblx0XHRsb2c6IHBhdGguam9pbihsaWJyYXJ5LCAnTG9ncycsIG5hbWUpLFxuXHRcdHRlbXA6IHBhdGguam9pbih0bXBkaXIsIG5hbWUpXG5cdH07XG59O1xuXG5jb25zdCB3aW5kb3dzID0gbmFtZSA9PiB7XG5cdGNvbnN0IGFwcERhdGEgPSBlbnYuQVBQREFUQSB8fCBwYXRoLmpvaW4oaG9tZWRpciwgJ0FwcERhdGEnLCAnUm9hbWluZycpO1xuXHRjb25zdCBsb2NhbEFwcERhdGEgPSBlbnYuTE9DQUxBUFBEQVRBIHx8IHBhdGguam9pbihob21lZGlyLCAnQXBwRGF0YScsICdMb2NhbCcpO1xuXG5cdHJldHVybiB7XG5cdFx0Ly8gRGF0YS9jb25maWcvY2FjaGUvbG9nIGFyZSBpbnZlbnRlZCBieSBtZSBhcyBXaW5kb3dzIGlzbid0IG9waW5pb25hdGVkIGFib3V0IHRoaXNcblx0XHRkYXRhOiBwYXRoLmpvaW4obG9jYWxBcHBEYXRhLCBuYW1lLCAnRGF0YScpLFxuXHRcdGNvbmZpZzogcGF0aC5qb2luKGFwcERhdGEsIG5hbWUsICdDb25maWcnKSxcblx0XHRjYWNoZTogcGF0aC5qb2luKGxvY2FsQXBwRGF0YSwgbmFtZSwgJ0NhY2hlJyksXG5cdFx0bG9nOiBwYXRoLmpvaW4obG9jYWxBcHBEYXRhLCBuYW1lLCAnTG9nJyksXG5cdFx0dGVtcDogcGF0aC5qb2luKHRtcGRpciwgbmFtZSlcblx0fTtcbn07XG5cbi8vIGh0dHBzOi8vc3BlY2lmaWNhdGlvbnMuZnJlZWRlc2t0b3Aub3JnL2Jhc2VkaXItc3BlYy9iYXNlZGlyLXNwZWMtbGF0ZXN0Lmh0bWxcbmNvbnN0IGxpbnV4ID0gbmFtZSA9PiB7XG5cdGNvbnN0IHVzZXJuYW1lID0gcGF0aC5iYXNlbmFtZShob21lZGlyKTtcblxuXHRyZXR1cm4ge1xuXHRcdGRhdGE6IHBhdGguam9pbihlbnYuWERHX0RBVEFfSE9NRSB8fCBwYXRoLmpvaW4oaG9tZWRpciwgJy5sb2NhbCcsICdzaGFyZScpLCBuYW1lKSxcblx0XHRjb25maWc6IHBhdGguam9pbihlbnYuWERHX0NPTkZJR19IT01FIHx8IHBhdGguam9pbihob21lZGlyLCAnLmNvbmZpZycpLCBuYW1lKSxcblx0XHRjYWNoZTogcGF0aC5qb2luKGVudi5YREdfQ0FDSEVfSE9NRSB8fCBwYXRoLmpvaW4oaG9tZWRpciwgJy5jYWNoZScpLCBuYW1lKSxcblx0XHQvLyBodHRwczovL3dpa2kuZGViaWFuLm9yZy9YREdCYXNlRGlyZWN0b3J5U3BlY2lmaWNhdGlvbiNzdGF0ZVxuXHRcdGxvZzogcGF0aC5qb2luKGVudi5YREdfU1RBVEVfSE9NRSB8fCBwYXRoLmpvaW4oaG9tZWRpciwgJy5sb2NhbCcsICdzdGF0ZScpLCBuYW1lKSxcblx0XHR0ZW1wOiBwYXRoLmpvaW4odG1wZGlyLCB1c2VybmFtZSwgbmFtZSlcblx0fTtcbn07XG5cbmNvbnN0IGVudlBhdGhzID0gKG5hbWUsIG9wdGlvbnMpID0+IHtcblx0aWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIG5hbWV9YCk7XG5cdH1cblxuXHRvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7c3VmZml4OiAnbm9kZWpzJ30sIG9wdGlvbnMpO1xuXG5cdGlmIChvcHRpb25zLnN1ZmZpeCkge1xuXHRcdC8vIEFkZCBzdWZmaXggdG8gcHJldmVudCBwb3NzaWJsZSBjb25mbGljdCB3aXRoIG5hdGl2ZSBhcHBzXG5cdFx0bmFtZSArPSBgLSR7b3B0aW9ucy5zdWZmaXh9YDtcblx0fVxuXG5cdGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJykge1xuXHRcdHJldHVybiBtYWNvcyhuYW1lKTtcblx0fVxuXG5cdGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG5cdFx0cmV0dXJuIHdpbmRvd3MobmFtZSk7XG5cdH1cblxuXHRyZXR1cm4gbGludXgobmFtZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVudlBhdGhzO1xuLy8gVE9ETzogUmVtb3ZlIHRoaXMgZm9yIHRoZSBuZXh0IG1ham9yIHJlbGVhc2Vcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBlbnZQYXRocztcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogQ09OU1RTICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5PT1AgPSBleHBvcnRzLkxJTUlUX0ZJTEVTX0RFU0NSSVBUT1JTID0gZXhwb3J0cy5MSU1JVF9CQVNFTkFNRV9MRU5HVEggPSBleHBvcnRzLklTX1VTRVJfUk9PVCA9IGV4cG9ydHMuSVNfUE9TSVggPSBleHBvcnRzLkRFRkFVTFRfVElNRU9VVF9TWU5DID0gZXhwb3J0cy5ERUZBVUxUX1RJTUVPVVRfQVNZTkMgPSBleHBvcnRzLkRFRkFVTFRfV1JJVEVfT1BUSU9OUyA9IGV4cG9ydHMuREVGQVVMVF9SRUFEX09QVElPTlMgPSBleHBvcnRzLkRFRkFVTFRfRk9MREVSX01PREUgPSBleHBvcnRzLkRFRkFVTFRfRklMRV9NT0RFID0gZXhwb3J0cy5ERUZBVUxUX0VOQ09ESU5HID0gdm9pZCAwO1xuY29uc3QgREVGQVVMVF9FTkNPRElORyA9ICd1dGY4JztcbmV4cG9ydHMuREVGQVVMVF9FTkNPRElORyA9IERFRkFVTFRfRU5DT0RJTkc7XG5jb25zdCBERUZBVUxUX0ZJTEVfTU9ERSA9IDBvNjY2O1xuZXhwb3J0cy5ERUZBVUxUX0ZJTEVfTU9ERSA9IERFRkFVTFRfRklMRV9NT0RFO1xuY29uc3QgREVGQVVMVF9GT0xERVJfTU9ERSA9IDBvNzc3O1xuZXhwb3J0cy5ERUZBVUxUX0ZPTERFUl9NT0RFID0gREVGQVVMVF9GT0xERVJfTU9ERTtcbmNvbnN0IERFRkFVTFRfUkVBRF9PUFRJT05TID0ge307XG5leHBvcnRzLkRFRkFVTFRfUkVBRF9PUFRJT05TID0gREVGQVVMVF9SRUFEX09QVElPTlM7XG5jb25zdCBERUZBVUxUX1dSSVRFX09QVElPTlMgPSB7fTtcbmV4cG9ydHMuREVGQVVMVF9XUklURV9PUFRJT05TID0gREVGQVVMVF9XUklURV9PUFRJT05TO1xuY29uc3QgREVGQVVMVF9USU1FT1VUX0FTWU5DID0gNTAwMDtcbmV4cG9ydHMuREVGQVVMVF9USU1FT1VUX0FTWU5DID0gREVGQVVMVF9USU1FT1VUX0FTWU5DO1xuY29uc3QgREVGQVVMVF9USU1FT1VUX1NZTkMgPSAxMDA7XG5leHBvcnRzLkRFRkFVTFRfVElNRU9VVF9TWU5DID0gREVGQVVMVF9USU1FT1VUX1NZTkM7XG5jb25zdCBJU19QT1NJWCA9ICEhcHJvY2Vzcy5nZXR1aWQ7XG5leHBvcnRzLklTX1BPU0lYID0gSVNfUE9TSVg7XG5jb25zdCBJU19VU0VSX1JPT1QgPSBwcm9jZXNzLmdldHVpZCA/ICFwcm9jZXNzLmdldHVpZCgpIDogZmFsc2U7XG5leHBvcnRzLklTX1VTRVJfUk9PVCA9IElTX1VTRVJfUk9PVDtcbmNvbnN0IExJTUlUX0JBU0VOQU1FX0xFTkdUSCA9IDEyODsgLy9UT0RPOiBmZXRjaCB0aGUgcmVhbCBsaW1pdCBmcm9tIHRoZSBmaWxlc3lzdGVtIC8vVE9ETzogZmV0Y2ggdGhlIHdob2xlLXBhdGggbGVuZ3RoIGxpbWl0IHRvb1xuZXhwb3J0cy5MSU1JVF9CQVNFTkFNRV9MRU5HVEggPSBMSU1JVF9CQVNFTkFNRV9MRU5HVEg7XG5jb25zdCBMSU1JVF9GSUxFU19ERVNDUklQVE9SUyA9IDEwMDAwOyAvL1RPRE86IGZldGNoIHRoZSByZWFsIGxpbWl0IGZyb20gdGhlIGZpbGVzeXN0ZW1cbmV4cG9ydHMuTElNSVRfRklMRVNfREVTQ1JJUFRPUlMgPSBMSU1JVF9GSUxFU19ERVNDUklQVE9SUztcbmNvbnN0IE5PT1AgPSAoKSA9PiB7IH07XG5leHBvcnRzLk5PT1AgPSBOT09QO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBJTVBPUlQgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXR0ZW1wdGlmeVN5bmMgPSBleHBvcnRzLmF0dGVtcHRpZnlBc3luYyA9IHZvaWQgMDtcbmNvbnN0IGNvbnN0c18xID0gcmVxdWlyZShcIi4uL2NvbnN0c1wiKTtcbi8qIEFUVEVNUFRJRlkgKi9cbi8vVE9ETzogTWF5YmUgcHVibGlzaCB0aGlzIGFzIGEgc3RhbmRhbG9uZSBwYWNrYWdlXG4vL0ZJWE1FOiBUaGUgdHlwZSBjYXN0aW5ncyBoZXJlIGFyZW4ndCBleGFjdGx5IGNvcnJlY3RcbmNvbnN0IGF0dGVtcHRpZnlBc3luYyA9IChmbiwgb25FcnJvciA9IGNvbnN0c18xLk5PT1ApID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpLmNhdGNoKG9uRXJyb3IpO1xuICAgIH07XG59O1xuZXhwb3J0cy5hdHRlbXB0aWZ5QXN5bmMgPSBhdHRlbXB0aWZ5QXN5bmM7XG5jb25zdCBhdHRlbXB0aWZ5U3luYyA9IChmbiwgb25FcnJvciA9IGNvbnN0c18xLk5PT1ApID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuZXhwb3J0cy5hdHRlbXB0aWZ5U3luYyA9IGF0dGVtcHRpZnlTeW5jO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBJTVBPUlQgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbnN0c18xID0gcmVxdWlyZShcIi4uL2NvbnN0c1wiKTtcbi8qIEZTIEhBTkRMRVJTICovXG5jb25zdCBIYW5kbGVycyA9IHtcbiAgICBpc0NoYW5nZUVycm9yT2s6IChlcnJvcikgPT4ge1xuICAgICAgICBjb25zdCB7IGNvZGUgfSA9IGVycm9yO1xuICAgICAgICBpZiAoY29kZSA9PT0gJ0VOT1NZUycpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCFjb25zdHNfMS5JU19VU0VSX1JPT1QgJiYgKGNvZGUgPT09ICdFSU5WQUwnIHx8IGNvZGUgPT09ICdFUEVSTScpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGlzUmV0cmlhYmxlRXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICBjb25zdCB7IGNvZGUgfSA9IGVycm9yO1xuICAgICAgICBpZiAoY29kZSA9PT0gJ0VNRklMRScgfHwgY29kZSA9PT0gJ0VORklMRScgfHwgY29kZSA9PT0gJ0VBR0FJTicgfHwgY29kZSA9PT0gJ0VCVVNZJyB8fCBjb2RlID09PSAnRUFDQ0VTUycgfHwgY29kZSA9PT0gJ0VBQ0NTJyB8fCBjb2RlID09PSAnRVBFUk0nKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIG9uQ2hhbmdlRXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICBpZiAoSGFuZGxlcnMuaXNDaGFuZ2VFcnJvck9rKGVycm9yKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufTtcbi8qIEVYUE9SVCAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gSGFuZGxlcnM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIElNUE9SVCAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29uc3RzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RzXCIpO1xuLyogUkVUUllJRlkgUVVFVUUgKi9cbmNvbnN0IFJldHJ5ZnlRdWV1ZSA9IHtcbiAgICBpbnRlcnZhbDogMjUsXG4gICAgaW50ZXJ2YWxJZDogdW5kZWZpbmVkLFxuICAgIGxpbWl0OiBjb25zdHNfMS5MSU1JVF9GSUxFU19ERVNDUklQVE9SUyxcbiAgICBxdWV1ZUFjdGl2ZTogbmV3IFNldCgpLFxuICAgIHF1ZXVlV2FpdGluZzogbmV3IFNldCgpLFxuICAgIGluaXQ6ICgpID0+IHtcbiAgICAgICAgaWYgKFJldHJ5ZnlRdWV1ZS5pbnRlcnZhbElkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBSZXRyeWZ5UXVldWUuaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKFJldHJ5ZnlRdWV1ZS50aWNrLCBSZXRyeWZ5UXVldWUuaW50ZXJ2YWwpO1xuICAgIH0sXG4gICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgICAgaWYgKCFSZXRyeWZ5UXVldWUuaW50ZXJ2YWxJZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChSZXRyeWZ5UXVldWUuaW50ZXJ2YWxJZCk7XG4gICAgICAgIGRlbGV0ZSBSZXRyeWZ5UXVldWUuaW50ZXJ2YWxJZDtcbiAgICB9LFxuICAgIGFkZDogKGZuKSA9PiB7XG4gICAgICAgIFJldHJ5ZnlRdWV1ZS5xdWV1ZVdhaXRpbmcuYWRkKGZuKTtcbiAgICAgICAgaWYgKFJldHJ5ZnlRdWV1ZS5xdWV1ZUFjdGl2ZS5zaXplIDwgKFJldHJ5ZnlRdWV1ZS5saW1pdCAvIDIpKSB7IC8vIEFjdGl2ZSBxdWV1ZSBub3QgdW5kZXIgcHJlYXNzdXJlLCBleGVjdXRpbmcgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIFJldHJ5ZnlRdWV1ZS50aWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBSZXRyeWZ5UXVldWUuaW5pdCgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW1vdmU6IChmbikgPT4ge1xuICAgICAgICBSZXRyeWZ5UXVldWUucXVldWVXYWl0aW5nLmRlbGV0ZShmbik7XG4gICAgICAgIFJldHJ5ZnlRdWV1ZS5xdWV1ZUFjdGl2ZS5kZWxldGUoZm4pO1xuICAgIH0sXG4gICAgc2NoZWR1bGU6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IFJldHJ5ZnlRdWV1ZS5yZW1vdmUocmVzb2x2ZXIpO1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSAoKSA9PiByZXNvbHZlKGNsZWFudXApO1xuICAgICAgICAgICAgUmV0cnlmeVF1ZXVlLmFkZChyZXNvbHZlcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgdGljazogKCkgPT4ge1xuICAgICAgICBpZiAoUmV0cnlmeVF1ZXVlLnF1ZXVlQWN0aXZlLnNpemUgPj0gUmV0cnlmeVF1ZXVlLmxpbWl0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIVJldHJ5ZnlRdWV1ZS5xdWV1ZVdhaXRpbmcuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBSZXRyeWZ5UXVldWUucmVzZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCBmbiBvZiBSZXRyeWZ5UXVldWUucXVldWVXYWl0aW5nKSB7XG4gICAgICAgICAgICBpZiAoUmV0cnlmeVF1ZXVlLnF1ZXVlQWN0aXZlLnNpemUgPj0gUmV0cnlmeVF1ZXVlLmxpbWl0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgUmV0cnlmeVF1ZXVlLnF1ZXVlV2FpdGluZy5kZWxldGUoZm4pO1xuICAgICAgICAgICAgUmV0cnlmeVF1ZXVlLnF1ZXVlQWN0aXZlLmFkZChmbik7XG4gICAgICAgICAgICBmbigpO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qIEVYUE9SVCAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gUmV0cnlmeVF1ZXVlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBJTVBPUlQgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmV0cnlpZnlTeW5jID0gZXhwb3J0cy5yZXRyeWlmeUFzeW5jID0gdm9pZCAwO1xuY29uc3QgcmV0cnlpZnlfcXVldWVfMSA9IHJlcXVpcmUoXCIuL3JldHJ5aWZ5X3F1ZXVlXCIpO1xuLyogUkVUUllJRlkgKi9cbmNvbnN0IHJldHJ5aWZ5QXN5bmMgPSAoZm4sIGlzUmV0cmlhYmxlRXJyb3IpID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRpbWVzdGFtcCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gYXR0ZW1wdCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXRyeWlmeV9xdWV1ZV8xLmRlZmF1bHQuc2NoZWR1bGUoKS50aGVuKGNsZWFudXAgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChEYXRlLm5vdygpID49IHRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZXRyaWFibGVFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gTWF0aC5yb3VuZCgxMDAgKyAoNDAwICogTWF0aC5yYW5kb20oKSkpLCBkZWxheVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWxheVByb21pc2UudGhlbigoKSA9PiBhdHRlbXB0LmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xufTtcbmV4cG9ydHMucmV0cnlpZnlBc3luYyA9IHJldHJ5aWZ5QXN5bmM7XG5jb25zdCByZXRyeWlmeVN5bmMgPSAoZm4sIGlzUmV0cmlhYmxlRXJyb3IpID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRpbWVzdGFtcCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gYXR0ZW1wdCgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChEYXRlLm5vdygpID4gdGltZXN0YW1wKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXRyaWFibGVFcnJvcihlcnJvcikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRlbXB0LmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xufTtcbmV4cG9ydHMucmV0cnlpZnlTeW5jID0gcmV0cnlpZnlTeW5jO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBJTVBPUlQgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcInV0aWxcIik7XG5jb25zdCBhdHRlbXB0aWZ5XzEgPSByZXF1aXJlKFwiLi9hdHRlbXB0aWZ5XCIpO1xuY29uc3QgZnNfaGFuZGxlcnNfMSA9IHJlcXVpcmUoXCIuL2ZzX2hhbmRsZXJzXCIpO1xuY29uc3QgcmV0cnlpZnlfMSA9IHJlcXVpcmUoXCIuL3JldHJ5aWZ5XCIpO1xuLyogRlMgKi9cbmNvbnN0IEZTID0ge1xuICAgIGNobW9kQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLmNobW9kKSwgZnNfaGFuZGxlcnNfMS5kZWZhdWx0Lm9uQ2hhbmdlRXJyb3IpLFxuICAgIGNob3duQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLmNob3duKSwgZnNfaGFuZGxlcnNfMS5kZWZhdWx0Lm9uQ2hhbmdlRXJyb3IpLFxuICAgIGNsb3NlQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLmNsb3NlKSksXG4gICAgZnN5bmNBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMuZnN5bmMpKSxcbiAgICBta2RpckF0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5ta2RpcikpLFxuICAgIHJlYWxwYXRoQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLnJlYWxwYXRoKSksXG4gICAgc3RhdEF0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5zdGF0KSksXG4gICAgdW5saW5rQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLnVubGluaykpLFxuICAgIGNsb3NlUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLmNsb3NlKSwgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIGZzeW5jUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLmZzeW5jKSwgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIG9wZW5SZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMub3BlbiksIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICByZWFkRmlsZVJldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5yZWFkRmlsZSksIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICByZW5hbWVSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMucmVuYW1lKSwgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIHN0YXRSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMuc3RhdCksIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICB3cml0ZVJldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy53cml0ZSksIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICBjaG1vZFN5bmNBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeVN5bmMoZnMuY2htb2RTeW5jLCBmc19oYW5kbGVyc18xLmRlZmF1bHQub25DaGFuZ2VFcnJvciksXG4gICAgY2hvd25TeW5jQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlTeW5jKGZzLmNob3duU3luYywgZnNfaGFuZGxlcnNfMS5kZWZhdWx0Lm9uQ2hhbmdlRXJyb3IpLFxuICAgIGNsb3NlU3luY0F0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5U3luYyhmcy5jbG9zZVN5bmMpLFxuICAgIG1rZGlyU3luY0F0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5U3luYyhmcy5ta2RpclN5bmMpLFxuICAgIHJlYWxwYXRoU3luY0F0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5U3luYyhmcy5yZWFscGF0aFN5bmMpLFxuICAgIHN0YXRTeW5jQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlTeW5jKGZzLnN0YXRTeW5jKSxcbiAgICB1bmxpbmtTeW5jQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlTeW5jKGZzLnVubGlua1N5bmMpLFxuICAgIGNsb3NlU3luY1JldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5U3luYyhmcy5jbG9zZVN5bmMsIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICBmc3luY1N5bmNSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeVN5bmMoZnMuZnN5bmNTeW5jLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgb3BlblN5bmNSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeVN5bmMoZnMub3BlblN5bmMsIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICByZWFkRmlsZVN5bmNSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeVN5bmMoZnMucmVhZEZpbGVTeW5jLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgcmVuYW1lU3luY1JldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5U3luYyhmcy5yZW5hbWVTeW5jLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgc3RhdFN5bmNSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeVN5bmMoZnMuc3RhdFN5bmMsIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICB3cml0ZVN5bmNSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeVN5bmMoZnMud3JpdGVTeW5jLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvcilcbn07XG4vKiBFWFBPUlQgKi9cbmV4cG9ydHMuZGVmYXVsdCA9IEZTO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBMQU5HICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBMYW5nID0ge1xuICAgIGlzRnVuY3Rpb246ICh4KSA9PiB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9LFxuICAgIGlzU3RyaW5nOiAoeCkgPT4ge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdzdHJpbmcnO1xuICAgIH0sXG4gICAgaXNVbmRlZmluZWQ6ICh4KSA9PiB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxufTtcbi8qIEVYUE9SVCAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gTGFuZztcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogSU1QT1JUICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiBWQVJJQUJMRVMgKi9cbmNvbnN0IFF1ZXVlcyA9IHt9O1xuLyogU0NIRURVTEVSICovXG4vL1RPRE86IE1heWJlIHB1Ymxpc2ggdGhpcyBhcyBhIHN0YW5kYWxvbmUgcGFja2FnZVxuY29uc3QgU2NoZWR1bGVyID0ge1xuICAgIG5leHQ6IChpZCkgPT4ge1xuICAgICAgICBjb25zdCBxdWV1ZSA9IFF1ZXVlc1tpZF07XG4gICAgICAgIGlmICghcXVldWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGNvbnN0IGpvYiA9IHF1ZXVlWzBdO1xuICAgICAgICBpZiAoam9iKSB7XG4gICAgICAgICAgICBqb2IoKCkgPT4gU2NoZWR1bGVyLm5leHQoaWQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBRdWV1ZXNbaWRdO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzY2hlZHVsZTogKGlkKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGxldCBxdWV1ZSA9IFF1ZXVlc1tpZF07XG4gICAgICAgICAgICBpZiAoIXF1ZXVlKVxuICAgICAgICAgICAgICAgIHF1ZXVlID0gUXVldWVzW2lkXSA9IFtdO1xuICAgICAgICAgICAgcXVldWUucHVzaChyZXNvbHZlKTtcbiAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAxKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHJlc29sdmUoKCkgPT4gU2NoZWR1bGVyLm5leHQoaWQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbi8qIEVYUE9SVCAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gU2NoZWR1bGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBJTVBPUlQgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IGNvbnN0c18xID0gcmVxdWlyZShcIi4uL2NvbnN0c1wiKTtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiLi9mc1wiKTtcbi8qIFRFTVAgKi9cbi8vVE9ETzogTWF5YmUgcHVibGlzaCB0aGlzIGFzIGEgc3RhbmRhbG9uZSBwYWNrYWdlXG5jb25zdCBUZW1wID0ge1xuICAgIHN0b3JlOiB7fSxcbiAgICBjcmVhdGU6IChmaWxlUGF0aCkgPT4ge1xuICAgICAgICBjb25zdCByYW5kb21uZXNzID0gYDAwMDAwMCR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTY3NzcyMTUpLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC02KSwgLy8gNiByYW5kb20tZW5vdWdoIGhleCBjaGFyYWN0ZXJzXG4gICAgICAgIHRpbWVzdGFtcCA9IERhdGUubm93KCkudG9TdHJpbmcoKS5zbGljZSgtMTApLCAvLyAxMCBwcmVjaXNlIHRpbWVzdGFtcCBkaWdpdHNcbiAgICAgICAgcHJlZml4ID0gJ3RtcC0nLCBzdWZmaXggPSBgLiR7cHJlZml4fSR7dGltZXN0YW1wfSR7cmFuZG9tbmVzc31gLCB0ZW1wUGF0aCA9IGAke2ZpbGVQYXRofSR7c3VmZml4fWA7XG4gICAgICAgIHJldHVybiB0ZW1wUGF0aDtcbiAgICB9LFxuICAgIGdldDogKGZpbGVQYXRoLCBjcmVhdG9yLCBwdXJnZSA9IHRydWUpID0+IHtcbiAgICAgICAgY29uc3QgdGVtcFBhdGggPSBUZW1wLnRydW5jYXRlKGNyZWF0b3IoZmlsZVBhdGgpKTtcbiAgICAgICAgaWYgKHRlbXBQYXRoIGluIFRlbXAuc3RvcmUpXG4gICAgICAgICAgICByZXR1cm4gVGVtcC5nZXQoZmlsZVBhdGgsIGNyZWF0b3IsIHB1cmdlKTsgLy8gQ29sbGlzaW9uIGZvdW5kLCB0cnkgYWdhaW5cbiAgICAgICAgVGVtcC5zdG9yZVt0ZW1wUGF0aF0gPSBwdXJnZTtcbiAgICAgICAgY29uc3QgZGlzcG9zZXIgPSAoKSA9PiBkZWxldGUgVGVtcC5zdG9yZVt0ZW1wUGF0aF07XG4gICAgICAgIHJldHVybiBbdGVtcFBhdGgsIGRpc3Bvc2VyXTtcbiAgICB9LFxuICAgIHB1cmdlOiAoZmlsZVBhdGgpID0+IHtcbiAgICAgICAgaWYgKCFUZW1wLnN0b3JlW2ZpbGVQYXRoXSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZGVsZXRlIFRlbXAuc3RvcmVbZmlsZVBhdGhdO1xuICAgICAgICBmc18xLmRlZmF1bHQudW5saW5rQXR0ZW1wdChmaWxlUGF0aCk7XG4gICAgfSxcbiAgICBwdXJnZVN5bmM6IChmaWxlUGF0aCkgPT4ge1xuICAgICAgICBpZiAoIVRlbXAuc3RvcmVbZmlsZVBhdGhdKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBkZWxldGUgVGVtcC5zdG9yZVtmaWxlUGF0aF07XG4gICAgICAgIGZzXzEuZGVmYXVsdC51bmxpbmtTeW5jQXR0ZW1wdChmaWxlUGF0aCk7XG4gICAgfSxcbiAgICBwdXJnZVN5bmNBbGw6ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBmaWxlUGF0aCBpbiBUZW1wLnN0b3JlKSB7XG4gICAgICAgICAgICBUZW1wLnB1cmdlU3luYyhmaWxlUGF0aCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRydW5jYXRlOiAoZmlsZVBhdGgpID0+IHtcbiAgICAgICAgY29uc3QgYmFzZW5hbWUgPSBwYXRoLmJhc2VuYW1lKGZpbGVQYXRoKTtcbiAgICAgICAgaWYgKGJhc2VuYW1lLmxlbmd0aCA8PSBjb25zdHNfMS5MSU1JVF9CQVNFTkFNRV9MRU5HVEgpXG4gICAgICAgICAgICByZXR1cm4gZmlsZVBhdGg7IC8vRklYTUU6IFJvdWdoIGFuZCBxdWljayBhdHRlbXB0IGF0IGRldGVjdGluZyBvayBsZW5ndGhzXG4gICAgICAgIGNvbnN0IHRydW5jYWJsZSA9IC9eKFxcLj8pKC4qPykoKD86XFwuW14uXSspPyg/OlxcLnRtcC1cXGR7MTB9W2EtZjAtOV17Nn0pPykkLy5leGVjKGJhc2VuYW1lKTtcbiAgICAgICAgaWYgKCF0cnVuY2FibGUpXG4gICAgICAgICAgICByZXR1cm4gZmlsZVBhdGg7IC8vRklYTUU6IE5vIHRydW5jYWJsZSBwYXJ0IGRldGVjdGVkLCBjYW4ndCByZWFsbHkgZG8gbXVjaCB3aXRob3V0IGFsc28gY2hhbmdpbmcgdGhlIHBhcmVudCBwYXRoLCB3aGljaCBpcyB1bnNhZmUsIGhvcGluZyBmb3IgdGhlIGJlc3QgaGVyZVxuICAgICAgICBjb25zdCB0cnVuY2F0aW9uTGVuZ3RoID0gYmFzZW5hbWUubGVuZ3RoIC0gY29uc3RzXzEuTElNSVRfQkFTRU5BTUVfTEVOR1RIO1xuICAgICAgICByZXR1cm4gYCR7ZmlsZVBhdGguc2xpY2UoMCwgLWJhc2VuYW1lLmxlbmd0aCl9JHt0cnVuY2FibGVbMV19JHt0cnVuY2FibGVbMl0uc2xpY2UoMCwgLXRydW5jYXRpb25MZW5ndGgpfSR7dHJ1bmNhYmxlWzNdfWA7IC8vRklYTUU6IFRoZSB0cnVuY2FibGUgcGFydCBtaWdodCBiZSBzaG9ydGVyIHRoYW4gbmVlZGVkIGhlcmVcbiAgICB9XG59O1xuLyogSU5JVCAqL1xucHJvY2Vzcy5vbignZXhpdCcsIFRlbXAucHVyZ2VTeW5jQWxsKTsgLy8gRW5zdXJpbmcgcHVyZ2VhYmxlIHRlbXAgZmlsZXMgYXJlIHB1cmdlZCBvbiBleGl0XG4vKiBFWFBPUlQgKi9cbmV4cG9ydHMuZGVmYXVsdCA9IFRlbXA7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIElNUE9SVCAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy53cml0ZUZpbGVTeW5jID0gZXhwb3J0cy53cml0ZUZpbGUgPSBleHBvcnRzLnJlYWRGaWxlU3luYyA9IGV4cG9ydHMucmVhZEZpbGUgPSB2b2lkIDA7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBjb25zdHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0c1wiKTtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiLi91dGlscy9mc1wiKTtcbmNvbnN0IGxhbmdfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2xhbmdcIik7XG5jb25zdCBzY2hlZHVsZXJfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL3NjaGVkdWxlclwiKTtcbmNvbnN0IHRlbXBfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL3RlbXBcIik7XG5mdW5jdGlvbiByZWFkRmlsZShmaWxlUGF0aCwgb3B0aW9ucyA9IGNvbnN0c18xLkRFRkFVTFRfUkVBRF9PUFRJT05TKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChsYW5nXzEuZGVmYXVsdC5pc1N0cmluZyhvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIHJlYWRGaWxlKGZpbGVQYXRoLCB7IGVuY29kaW5nOiBvcHRpb25zIH0pO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBEYXRlLm5vdygpICsgKChfYSA9IG9wdGlvbnMudGltZW91dCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29uc3RzXzEuREVGQVVMVF9USU1FT1VUX0FTWU5DKTtcbiAgICByZXR1cm4gZnNfMS5kZWZhdWx0LnJlYWRGaWxlUmV0cnkodGltZW91dCkoZmlsZVBhdGgsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5yZWFkRmlsZSA9IHJlYWRGaWxlO1xuO1xuZnVuY3Rpb24gcmVhZEZpbGVTeW5jKGZpbGVQYXRoLCBvcHRpb25zID0gY29uc3RzXzEuREVGQVVMVF9SRUFEX09QVElPTlMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGxhbmdfMS5kZWZhdWx0LmlzU3RyaW5nKG9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gcmVhZEZpbGVTeW5jKGZpbGVQYXRoLCB7IGVuY29kaW5nOiBvcHRpb25zIH0pO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBEYXRlLm5vdygpICsgKChfYSA9IG9wdGlvbnMudGltZW91dCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29uc3RzXzEuREVGQVVMVF9USU1FT1VUX1NZTkMpO1xuICAgIHJldHVybiBmc18xLmRlZmF1bHQucmVhZEZpbGVTeW5jUmV0cnkodGltZW91dCkoZmlsZVBhdGgsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5yZWFkRmlsZVN5bmMgPSByZWFkRmlsZVN5bmM7XG47XG5jb25zdCB3cml0ZUZpbGUgPSAoZmlsZVBhdGgsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gICAgaWYgKGxhbmdfMS5kZWZhdWx0LmlzRnVuY3Rpb24ob3B0aW9ucykpXG4gICAgICAgIHJldHVybiB3cml0ZUZpbGUoZmlsZVBhdGgsIGRhdGEsIGNvbnN0c18xLkRFRkFVTFRfV1JJVEVfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgY29uc3QgcHJvbWlzZSA9IHdyaXRlRmlsZUFzeW5jKGZpbGVQYXRoLCBkYXRhLCBvcHRpb25zKTtcbiAgICBpZiAoY2FsbGJhY2spXG4gICAgICAgIHByb21pc2UudGhlbihjYWxsYmFjaywgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufTtcbmV4cG9ydHMud3JpdGVGaWxlID0gd3JpdGVGaWxlO1xuY29uc3Qgd3JpdGVGaWxlQXN5bmMgPSBhc3luYyAoZmlsZVBhdGgsIGRhdGEsIG9wdGlvbnMgPSBjb25zdHNfMS5ERUZBVUxUX1dSSVRFX09QVElPTlMpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGxhbmdfMS5kZWZhdWx0LmlzU3RyaW5nKG9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gd3JpdGVGaWxlQXN5bmMoZmlsZVBhdGgsIGRhdGEsIHsgZW5jb2Rpbmc6IG9wdGlvbnMgfSk7XG4gICAgY29uc3QgdGltZW91dCA9IERhdGUubm93KCkgKyAoKF9hID0gb3B0aW9ucy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb25zdHNfMS5ERUZBVUxUX1RJTUVPVVRfQVNZTkMpO1xuICAgIGxldCBzY2hlZHVsZXJDdXN0b21EaXNwb3NlciA9IG51bGwsIHNjaGVkdWxlckRpc3Bvc2VyID0gbnVsbCwgdGVtcERpc3Bvc2VyID0gbnVsbCwgdGVtcFBhdGggPSBudWxsLCBmZCA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2NoZWR1bGUpXG4gICAgICAgICAgICBzY2hlZHVsZXJDdXN0b21EaXNwb3NlciA9IGF3YWl0IG9wdGlvbnMuc2NoZWR1bGUoZmlsZVBhdGgpO1xuICAgICAgICBzY2hlZHVsZXJEaXNwb3NlciA9IGF3YWl0IHNjaGVkdWxlcl8xLmRlZmF1bHQuc2NoZWR1bGUoZmlsZVBhdGgpO1xuICAgICAgICBmaWxlUGF0aCA9IGF3YWl0IGZzXzEuZGVmYXVsdC5yZWFscGF0aEF0dGVtcHQoZmlsZVBhdGgpIHx8IGZpbGVQYXRoO1xuICAgICAgICBbdGVtcFBhdGgsIHRlbXBEaXNwb3Nlcl0gPSB0ZW1wXzEuZGVmYXVsdC5nZXQoZmlsZVBhdGgsIG9wdGlvbnMudG1wQ3JlYXRlIHx8IHRlbXBfMS5kZWZhdWx0LmNyZWF0ZSwgIShvcHRpb25zLnRtcFB1cmdlID09PSBmYWxzZSkpO1xuICAgICAgICBjb25zdCB1c2VTdGF0Q2hvd24gPSBjb25zdHNfMS5JU19QT1NJWCAmJiBsYW5nXzEuZGVmYXVsdC5pc1VuZGVmaW5lZChvcHRpb25zLmNob3duKSwgdXNlU3RhdE1vZGUgPSBsYW5nXzEuZGVmYXVsdC5pc1VuZGVmaW5lZChvcHRpb25zLm1vZGUpO1xuICAgICAgICBpZiAodXNlU3RhdENob3duIHx8IHVzZVN0YXRNb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ID0gYXdhaXQgZnNfMS5kZWZhdWx0LnN0YXRBdHRlbXB0KGZpbGVQYXRoKTtcbiAgICAgICAgICAgIGlmIChzdGF0KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgICAgIGlmICh1c2VTdGF0Q2hvd24pXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2hvd24gPSB7IHVpZDogc3RhdC51aWQsIGdpZDogc3RhdC5naWQgfTtcbiAgICAgICAgICAgICAgICBpZiAodXNlU3RhdE1vZGUpXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubW9kZSA9IHN0YXQubW9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnRQYXRoID0gcGF0aC5kaXJuYW1lKGZpbGVQYXRoKTtcbiAgICAgICAgYXdhaXQgZnNfMS5kZWZhdWx0Lm1rZGlyQXR0ZW1wdChwYXJlbnRQYXRoLCB7XG4gICAgICAgICAgICBtb2RlOiBjb25zdHNfMS5ERUZBVUxUX0ZPTERFUl9NT0RFLFxuICAgICAgICAgICAgcmVjdXJzaXZlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBmZCA9IGF3YWl0IGZzXzEuZGVmYXVsdC5vcGVuUmV0cnkodGltZW91dCkodGVtcFBhdGgsICd3Jywgb3B0aW9ucy5tb2RlIHx8IGNvbnN0c18xLkRFRkFVTFRfRklMRV9NT0RFKTtcbiAgICAgICAgaWYgKG9wdGlvbnMudG1wQ3JlYXRlZClcbiAgICAgICAgICAgIG9wdGlvbnMudG1wQ3JlYXRlZCh0ZW1wUGF0aCk7XG4gICAgICAgIGlmIChsYW5nXzEuZGVmYXVsdC5pc1N0cmluZyhkYXRhKSkge1xuICAgICAgICAgICAgYXdhaXQgZnNfMS5kZWZhdWx0LndyaXRlUmV0cnkodGltZW91dCkoZmQsIGRhdGEsIDAsIG9wdGlvbnMuZW5jb2RpbmcgfHwgY29uc3RzXzEuREVGQVVMVF9FTkNPRElORyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWxhbmdfMS5kZWZhdWx0LmlzVW5kZWZpbmVkKGRhdGEpKSB7XG4gICAgICAgICAgICBhd2FpdCBmc18xLmRlZmF1bHQud3JpdGVSZXRyeSh0aW1lb3V0KShmZCwgZGF0YSwgMCwgZGF0YS5sZW5ndGgsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmZzeW5jICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZnN5bmNXYWl0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGZzXzEuZGVmYXVsdC5mc3luY1JldHJ5KHRpbWVvdXQpKGZkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZzXzEuZGVmYXVsdC5mc3luY0F0dGVtcHQoZmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGZzXzEuZGVmYXVsdC5jbG9zZVJldHJ5KHRpbWVvdXQpKGZkKTtcbiAgICAgICAgZmQgPSBudWxsO1xuICAgICAgICBpZiAob3B0aW9ucy5jaG93bilcbiAgICAgICAgICAgIGF3YWl0IGZzXzEuZGVmYXVsdC5jaG93bkF0dGVtcHQodGVtcFBhdGgsIG9wdGlvbnMuY2hvd24udWlkLCBvcHRpb25zLmNob3duLmdpZCk7XG4gICAgICAgIGlmIChvcHRpb25zLm1vZGUpXG4gICAgICAgICAgICBhd2FpdCBmc18xLmRlZmF1bHQuY2htb2RBdHRlbXB0KHRlbXBQYXRoLCBvcHRpb25zLm1vZGUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZnNfMS5kZWZhdWx0LnJlbmFtZVJldHJ5KHRpbWVvdXQpKHRlbXBQYXRoLCBmaWxlUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IuY29kZSAhPT0gJ0VOQU1FVE9PTE9ORycpXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICBhd2FpdCBmc18xLmRlZmF1bHQucmVuYW1lUmV0cnkodGltZW91dCkodGVtcFBhdGgsIHRlbXBfMS5kZWZhdWx0LnRydW5jYXRlKGZpbGVQYXRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcERpc3Bvc2VyKCk7XG4gICAgICAgIHRlbXBQYXRoID0gbnVsbDtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGlmIChmZClcbiAgICAgICAgICAgIGF3YWl0IGZzXzEuZGVmYXVsdC5jbG9zZUF0dGVtcHQoZmQpO1xuICAgICAgICBpZiAodGVtcFBhdGgpXG4gICAgICAgICAgICB0ZW1wXzEuZGVmYXVsdC5wdXJnZSh0ZW1wUGF0aCk7XG4gICAgICAgIGlmIChzY2hlZHVsZXJDdXN0b21EaXNwb3NlcilcbiAgICAgICAgICAgIHNjaGVkdWxlckN1c3RvbURpc3Bvc2VyKCk7XG4gICAgICAgIGlmIChzY2hlZHVsZXJEaXNwb3NlcilcbiAgICAgICAgICAgIHNjaGVkdWxlckRpc3Bvc2VyKCk7XG4gICAgfVxufTtcbmNvbnN0IHdyaXRlRmlsZVN5bmMgPSAoZmlsZVBhdGgsIGRhdGEsIG9wdGlvbnMgPSBjb25zdHNfMS5ERUZBVUxUX1dSSVRFX09QVElPTlMpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGxhbmdfMS5kZWZhdWx0LmlzU3RyaW5nKG9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gd3JpdGVGaWxlU3luYyhmaWxlUGF0aCwgZGF0YSwgeyBlbmNvZGluZzogb3B0aW9ucyB9KTtcbiAgICBjb25zdCB0aW1lb3V0ID0gRGF0ZS5ub3coKSArICgoX2EgPSBvcHRpb25zLnRpbWVvdXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbnN0c18xLkRFRkFVTFRfVElNRU9VVF9TWU5DKTtcbiAgICBsZXQgdGVtcERpc3Bvc2VyID0gbnVsbCwgdGVtcFBhdGggPSBudWxsLCBmZCA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgICAgZmlsZVBhdGggPSBmc18xLmRlZmF1bHQucmVhbHBhdGhTeW5jQXR0ZW1wdChmaWxlUGF0aCkgfHwgZmlsZVBhdGg7XG4gICAgICAgIFt0ZW1wUGF0aCwgdGVtcERpc3Bvc2VyXSA9IHRlbXBfMS5kZWZhdWx0LmdldChmaWxlUGF0aCwgb3B0aW9ucy50bXBDcmVhdGUgfHwgdGVtcF8xLmRlZmF1bHQuY3JlYXRlLCAhKG9wdGlvbnMudG1wUHVyZ2UgPT09IGZhbHNlKSk7XG4gICAgICAgIGNvbnN0IHVzZVN0YXRDaG93biA9IGNvbnN0c18xLklTX1BPU0lYICYmIGxhbmdfMS5kZWZhdWx0LmlzVW5kZWZpbmVkKG9wdGlvbnMuY2hvd24pLCB1c2VTdGF0TW9kZSA9IGxhbmdfMS5kZWZhdWx0LmlzVW5kZWZpbmVkKG9wdGlvbnMubW9kZSk7XG4gICAgICAgIGlmICh1c2VTdGF0Q2hvd24gfHwgdXNlU3RhdE1vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXQgPSBmc18xLmRlZmF1bHQuc3RhdFN5bmNBdHRlbXB0KGZpbGVQYXRoKTtcbiAgICAgICAgICAgIGlmIChzdGF0KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgICAgIGlmICh1c2VTdGF0Q2hvd24pXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2hvd24gPSB7IHVpZDogc3RhdC51aWQsIGdpZDogc3RhdC5naWQgfTtcbiAgICAgICAgICAgICAgICBpZiAodXNlU3RhdE1vZGUpXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubW9kZSA9IHN0YXQubW9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnRQYXRoID0gcGF0aC5kaXJuYW1lKGZpbGVQYXRoKTtcbiAgICAgICAgZnNfMS5kZWZhdWx0Lm1rZGlyU3luY0F0dGVtcHQocGFyZW50UGF0aCwge1xuICAgICAgICAgICAgbW9kZTogY29uc3RzXzEuREVGQVVMVF9GT0xERVJfTU9ERSxcbiAgICAgICAgICAgIHJlY3Vyc2l2ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgZmQgPSBmc18xLmRlZmF1bHQub3BlblN5bmNSZXRyeSh0aW1lb3V0KSh0ZW1wUGF0aCwgJ3cnLCBvcHRpb25zLm1vZGUgfHwgY29uc3RzXzEuREVGQVVMVF9GSUxFX01PREUpO1xuICAgICAgICBpZiAob3B0aW9ucy50bXBDcmVhdGVkKVxuICAgICAgICAgICAgb3B0aW9ucy50bXBDcmVhdGVkKHRlbXBQYXRoKTtcbiAgICAgICAgaWYgKGxhbmdfMS5kZWZhdWx0LmlzU3RyaW5nKGRhdGEpKSB7XG4gICAgICAgICAgICBmc18xLmRlZmF1bHQud3JpdGVTeW5jUmV0cnkodGltZW91dCkoZmQsIGRhdGEsIDAsIG9wdGlvbnMuZW5jb2RpbmcgfHwgY29uc3RzXzEuREVGQVVMVF9FTkNPRElORyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWxhbmdfMS5kZWZhdWx0LmlzVW5kZWZpbmVkKGRhdGEpKSB7XG4gICAgICAgICAgICBmc18xLmRlZmF1bHQud3JpdGVTeW5jUmV0cnkodGltZW91dCkoZmQsIGRhdGEsIDAsIGRhdGEubGVuZ3RoLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5mc3luYyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZzeW5jV2FpdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBmc18xLmRlZmF1bHQuZnN5bmNTeW5jUmV0cnkodGltZW91dCkoZmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZnNfMS5kZWZhdWx0LmZzeW5jQXR0ZW1wdChmZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnNfMS5kZWZhdWx0LmNsb3NlU3luY1JldHJ5KHRpbWVvdXQpKGZkKTtcbiAgICAgICAgZmQgPSBudWxsO1xuICAgICAgICBpZiAob3B0aW9ucy5jaG93bilcbiAgICAgICAgICAgIGZzXzEuZGVmYXVsdC5jaG93blN5bmNBdHRlbXB0KHRlbXBQYXRoLCBvcHRpb25zLmNob3duLnVpZCwgb3B0aW9ucy5jaG93bi5naWQpO1xuICAgICAgICBpZiAob3B0aW9ucy5tb2RlKVxuICAgICAgICAgICAgZnNfMS5kZWZhdWx0LmNobW9kU3luY0F0dGVtcHQodGVtcFBhdGgsIG9wdGlvbnMubW9kZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmc18xLmRlZmF1bHQucmVuYW1lU3luY1JldHJ5KHRpbWVvdXQpKHRlbXBQYXRoLCBmaWxlUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IuY29kZSAhPT0gJ0VOQU1FVE9PTE9ORycpXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICBmc18xLmRlZmF1bHQucmVuYW1lU3luY1JldHJ5KHRpbWVvdXQpKHRlbXBQYXRoLCB0ZW1wXzEuZGVmYXVsdC50cnVuY2F0ZShmaWxlUGF0aCkpO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBEaXNwb3NlcigpO1xuICAgICAgICB0ZW1wUGF0aCA9IG51bGw7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBpZiAoZmQpXG4gICAgICAgICAgICBmc18xLmRlZmF1bHQuY2xvc2VTeW5jQXR0ZW1wdChmZCk7XG4gICAgICAgIGlmICh0ZW1wUGF0aClcbiAgICAgICAgICAgIHRlbXBfMS5kZWZhdWx0LnB1cmdlKHRlbXBQYXRoKTtcbiAgICB9XG59O1xuZXhwb3J0cy53cml0ZUZpbGVTeW5jID0gd3JpdGVGaWxlU3luYztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWdleHBDb2RlID0gZXhwb3J0cy5nZXRFc21FeHBvcnROYW1lID0gZXhwb3J0cy5nZXRQcm9wZXJ0eSA9IGV4cG9ydHMuc2FmZVN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJDb25jYXQgPSBleHBvcnRzLmFkZENvZGVBcmcgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuXyA9IGV4cG9ydHMubmlsID0gZXhwb3J0cy5fQ29kZSA9IGV4cG9ydHMuTmFtZSA9IGV4cG9ydHMuSURFTlRJRklFUiA9IGV4cG9ydHMuX0NvZGVPck5hbWUgPSB2b2lkIDA7XG5jbGFzcyBfQ29kZU9yTmFtZSB7XG59XG5leHBvcnRzLl9Db2RlT3JOYW1lID0gX0NvZGVPck5hbWU7XG5leHBvcnRzLklERU5USUZJRVIgPSAvXlthLXokX11bYS16JF8wLTldKiQvaTtcbmNsYXNzIE5hbWUgZXh0ZW5kcyBfQ29kZU9yTmFtZSB7XG4gICAgY29uc3RydWN0b3Iocykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoIWV4cG9ydHMuSURFTlRJRklFUi50ZXN0KHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogbmFtZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclwiKTtcbiAgICAgICAgdGhpcy5zdHIgPSBzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyO1xuICAgIH1cbiAgICBlbXB0eVN0cigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB7IFt0aGlzLnN0cl06IDEgfTtcbiAgICB9XG59XG5leHBvcnRzLk5hbWUgPSBOYW1lO1xuY2xhc3MgX0NvZGUgZXh0ZW5kcyBfQ29kZU9yTmFtZSB7XG4gICAgY29uc3RydWN0b3IoY29kZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9pdGVtcyA9IHR5cGVvZiBjb2RlID09PSBcInN0cmluZ1wiID8gW2NvZGVdIDogY29kZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cjtcbiAgICB9XG4gICAgZW1wdHlTdHIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pdGVtcy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbXNbMF07XG4gICAgICAgIHJldHVybiBpdGVtID09PSBcIlwiIHx8IGl0ZW0gPT09ICdcIlwiJztcbiAgICB9XG4gICAgZ2V0IHN0cigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuX3N0cikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHRoaXMuX3N0ciA9IHRoaXMuX2l0ZW1zLnJlZHVjZSgocywgYykgPT4gYCR7c30ke2N9YCwgXCJcIikpKTtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5fbmFtZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICh0aGlzLl9uYW1lcyA9IHRoaXMuX2l0ZW1zLnJlZHVjZSgobmFtZXMsIGMpID0+IHtcbiAgICAgICAgICAgIGlmIChjIGluc3RhbmNlb2YgTmFtZSlcbiAgICAgICAgICAgICAgICBuYW1lc1tjLnN0cl0gPSAobmFtZXNbYy5zdHJdIHx8IDApICsgMTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lcztcbiAgICAgICAgfSwge30pKSk7XG4gICAgfVxufVxuZXhwb3J0cy5fQ29kZSA9IF9Db2RlO1xuZXhwb3J0cy5uaWwgPSBuZXcgX0NvZGUoXCJcIik7XG5mdW5jdGlvbiBfKHN0cnMsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjb2RlID0gW3N0cnNbMF1dO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGFkZENvZGVBcmcoY29kZSwgYXJnc1tpXSk7XG4gICAgICAgIGNvZGUucHVzaChzdHJzWysraV0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9Db2RlKGNvZGUpO1xufVxuZXhwb3J0cy5fID0gXztcbmNvbnN0IHBsdXMgPSBuZXcgX0NvZGUoXCIrXCIpO1xuZnVuY3Rpb24gc3RyKHN0cnMsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBleHByID0gW3NhZmVTdHJpbmdpZnkoc3Ryc1swXSldO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGV4cHIucHVzaChwbHVzKTtcbiAgICAgICAgYWRkQ29kZUFyZyhleHByLCBhcmdzW2ldKTtcbiAgICAgICAgZXhwci5wdXNoKHBsdXMsIHNhZmVTdHJpbmdpZnkoc3Ryc1srK2ldKSk7XG4gICAgfVxuICAgIG9wdGltaXplKGV4cHIpO1xuICAgIHJldHVybiBuZXcgX0NvZGUoZXhwcik7XG59XG5leHBvcnRzLnN0ciA9IHN0cjtcbmZ1bmN0aW9uIGFkZENvZGVBcmcoY29kZSwgYXJnKSB7XG4gICAgaWYgKGFyZyBpbnN0YW5jZW9mIF9Db2RlKVxuICAgICAgICBjb2RlLnB1c2goLi4uYXJnLl9pdGVtcyk7XG4gICAgZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgTmFtZSlcbiAgICAgICAgY29kZS5wdXNoKGFyZyk7XG4gICAgZWxzZVxuICAgICAgICBjb2RlLnB1c2goaW50ZXJwb2xhdGUoYXJnKSk7XG59XG5leHBvcnRzLmFkZENvZGVBcmcgPSBhZGRDb2RlQXJnO1xuZnVuY3Rpb24gb3B0aW1pemUoZXhwcikge1xuICAgIGxldCBpID0gMTtcbiAgICB3aGlsZSAoaSA8IGV4cHIubGVuZ3RoIC0gMSkge1xuICAgICAgICBpZiAoZXhwcltpXSA9PT0gcGx1cykge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gbWVyZ2VFeHBySXRlbXMoZXhwcltpIC0gMV0sIGV4cHJbaSArIDFdKTtcbiAgICAgICAgICAgIGlmIChyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGV4cHIuc3BsaWNlKGkgLSAxLCAzLCByZXMpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwcltpKytdID0gXCIrXCI7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlRXhwckl0ZW1zKGEsIGIpIHtcbiAgICBpZiAoYiA9PT0gJ1wiXCInKVxuICAgICAgICByZXR1cm4gYTtcbiAgICBpZiAoYSA9PT0gJ1wiXCInKVxuICAgICAgICByZXR1cm4gYjtcbiAgICBpZiAodHlwZW9mIGEgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoYiBpbnN0YW5jZW9mIE5hbWUgfHwgYVthLmxlbmd0aCAtIDFdICE9PSAnXCInKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIGIgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiBgJHthLnNsaWNlKDAsIC0xKX0ke2J9XCJgO1xuICAgICAgICBpZiAoYlswXSA9PT0gJ1wiJylcbiAgICAgICAgICAgIHJldHVybiBhLnNsaWNlKDAsIC0xKSArIGIuc2xpY2UoMSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBiID09IFwic3RyaW5nXCIgJiYgYlswXSA9PT0gJ1wiJyAmJiAhKGEgaW5zdGFuY2VvZiBOYW1lKSlcbiAgICAgICAgcmV0dXJuIGBcIiR7YX0ke2Iuc2xpY2UoMSl9YDtcbiAgICByZXR1cm47XG59XG5mdW5jdGlvbiBzdHJDb25jYXQoYzEsIGMyKSB7XG4gICAgcmV0dXJuIGMyLmVtcHR5U3RyKCkgPyBjMSA6IGMxLmVtcHR5U3RyKCkgPyBjMiA6IHN0ciBgJHtjMX0ke2MyfWA7XG59XG5leHBvcnRzLnN0ckNvbmNhdCA9IHN0ckNvbmNhdDtcbi8vIFRPRE8gZG8gbm90IGFsbG93IGFycmF5cyBoZXJlXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHggPT0gXCJib29sZWFuXCIgfHwgeCA9PT0gbnVsbFxuICAgICAgICA/IHhcbiAgICAgICAgOiBzYWZlU3RyaW5naWZ5KEFycmF5LmlzQXJyYXkoeCkgPyB4LmpvaW4oXCIsXCIpIDogeCk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkoeCkge1xuICAgIHJldHVybiBuZXcgX0NvZGUoc2FmZVN0cmluZ2lmeSh4KSk7XG59XG5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbmZ1bmN0aW9uIHNhZmVTdHJpbmdpZnkoeCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh4KVxuICAgICAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCBcIlxcXFx1MjAyOFwiKVxuICAgICAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCBcIlxcXFx1MjAyOVwiKTtcbn1cbmV4cG9ydHMuc2FmZVN0cmluZ2lmeSA9IHNhZmVTdHJpbmdpZnk7XG5mdW5jdGlvbiBnZXRQcm9wZXJ0eShrZXkpIHtcbiAgICByZXR1cm4gdHlwZW9mIGtleSA9PSBcInN0cmluZ1wiICYmIGV4cG9ydHMuSURFTlRJRklFUi50ZXN0KGtleSkgPyBuZXcgX0NvZGUoYC4ke2tleX1gKSA6IF8gYFske2tleX1dYDtcbn1cbmV4cG9ydHMuZ2V0UHJvcGVydHkgPSBnZXRQcm9wZXJ0eTtcbi8vRG9lcyBiZXN0IGVmZm9ydCB0byBmb3JtYXQgdGhlIG5hbWUgcHJvcGVybHlcbmZ1bmN0aW9uIGdldEVzbUV4cG9ydE5hbWUoa2V5KSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiAmJiBleHBvcnRzLklERU5USUZJRVIudGVzdChrZXkpKSB7XG4gICAgICAgIHJldHVybiBuZXcgX0NvZGUoYCR7a2V5fWApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IGludmFsaWQgZXhwb3J0IG5hbWU6ICR7a2V5fSwgdXNlIGV4cGxpY2l0ICRpZCBuYW1lIG1hcHBpbmdgKTtcbn1cbmV4cG9ydHMuZ2V0RXNtRXhwb3J0TmFtZSA9IGdldEVzbUV4cG9ydE5hbWU7XG5mdW5jdGlvbiByZWdleHBDb2RlKHJ4KSB7XG4gICAgcmV0dXJuIG5ldyBfQ29kZShyeC50b1N0cmluZygpKTtcbn1cbmV4cG9ydHMucmVnZXhwQ29kZSA9IHJlZ2V4cENvZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WYWx1ZVNjb3BlID0gZXhwb3J0cy5WYWx1ZVNjb3BlTmFtZSA9IGV4cG9ydHMuU2NvcGUgPSBleHBvcnRzLnZhcktpbmRzID0gZXhwb3J0cy5Vc2VkVmFsdWVTdGF0ZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuL2NvZGVcIik7XG5jbGFzcyBWYWx1ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgc3VwZXIoYENvZGVHZW46IFwiY29kZVwiIGZvciAke25hbWV9IG5vdCBkZWZpbmVkYCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBuYW1lLnZhbHVlO1xuICAgIH1cbn1cbnZhciBVc2VkVmFsdWVTdGF0ZTtcbihmdW5jdGlvbiAoVXNlZFZhbHVlU3RhdGUpIHtcbiAgICBVc2VkVmFsdWVTdGF0ZVtVc2VkVmFsdWVTdGF0ZVtcIlN0YXJ0ZWRcIl0gPSAwXSA9IFwiU3RhcnRlZFwiO1xuICAgIFVzZWRWYWx1ZVN0YXRlW1VzZWRWYWx1ZVN0YXRlW1wiQ29tcGxldGVkXCJdID0gMV0gPSBcIkNvbXBsZXRlZFwiO1xufSkoVXNlZFZhbHVlU3RhdGUgPSBleHBvcnRzLlVzZWRWYWx1ZVN0YXRlIHx8IChleHBvcnRzLlVzZWRWYWx1ZVN0YXRlID0ge30pKTtcbmV4cG9ydHMudmFyS2luZHMgPSB7XG4gICAgY29uc3Q6IG5ldyBjb2RlXzEuTmFtZShcImNvbnN0XCIpLFxuICAgIGxldDogbmV3IGNvZGVfMS5OYW1lKFwibGV0XCIpLFxuICAgIHZhcjogbmV3IGNvZGVfMS5OYW1lKFwidmFyXCIpLFxufTtcbmNsYXNzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHByZWZpeGVzLCBwYXJlbnQgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMuX25hbWVzID0ge307XG4gICAgICAgIHRoaXMuX3ByZWZpeGVzID0gcHJlZml4ZXM7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgdG9OYW1lKG5hbWVPclByZWZpeCkge1xuICAgICAgICByZXR1cm4gbmFtZU9yUHJlZml4IGluc3RhbmNlb2YgY29kZV8xLk5hbWUgPyBuYW1lT3JQcmVmaXggOiB0aGlzLm5hbWUobmFtZU9yUHJlZml4KTtcbiAgICB9XG4gICAgbmFtZShwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjb2RlXzEuTmFtZSh0aGlzLl9uZXdOYW1lKHByZWZpeCkpO1xuICAgIH1cbiAgICBfbmV3TmFtZShwcmVmaXgpIHtcbiAgICAgICAgY29uc3QgbmcgPSB0aGlzLl9uYW1lc1twcmVmaXhdIHx8IHRoaXMuX25hbWVHcm91cChwcmVmaXgpO1xuICAgICAgICByZXR1cm4gYCR7cHJlZml4fSR7bmcuaW5kZXgrK31gO1xuICAgIH1cbiAgICBfbmFtZUdyb3VwKHByZWZpeCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoKChfYiA9IChfYSA9IHRoaXMuX3BhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9wcmVmaXhlcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhhcyhwcmVmaXgpKSB8fCAodGhpcy5fcHJlZml4ZXMgJiYgIXRoaXMuX3ByZWZpeGVzLmhhcyhwcmVmaXgpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBwcmVmaXggXCIke3ByZWZpeH1cIiBpcyBub3QgYWxsb3dlZCBpbiB0aGlzIHNjb3BlYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLl9uYW1lc1twcmVmaXhdID0geyBwcmVmaXgsIGluZGV4OiAwIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuU2NvcGUgPSBTY29wZTtcbmNsYXNzIFZhbHVlU2NvcGVOYW1lIGV4dGVuZHMgY29kZV8xLk5hbWUge1xuICAgIGNvbnN0cnVjdG9yKHByZWZpeCwgbmFtZVN0cikge1xuICAgICAgICBzdXBlcihuYW1lU3RyKTtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgfVxuICAgIHNldFZhbHVlKHZhbHVlLCB7IHByb3BlcnR5LCBpdGVtSW5kZXggfSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc2NvcGVQYXRoID0gKDAsIGNvZGVfMS5fKSBgLiR7bmV3IGNvZGVfMS5OYW1lKHByb3BlcnR5KX1bJHtpdGVtSW5kZXh9XWA7XG4gICAgfVxufVxuZXhwb3J0cy5WYWx1ZVNjb3BlTmFtZSA9IFZhbHVlU2NvcGVOYW1lO1xuY29uc3QgbGluZSA9ICgwLCBjb2RlXzEuXykgYFxcbmA7XG5jbGFzcyBWYWx1ZVNjb3BlIGV4dGVuZHMgU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IHt9O1xuICAgICAgICB0aGlzLl9zY29wZSA9IG9wdHMuc2NvcGU7XG4gICAgICAgIHRoaXMub3B0cyA9IHsgLi4ub3B0cywgX246IG9wdHMubGluZXMgPyBsaW5lIDogY29kZV8xLm5pbCB9O1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY29wZTtcbiAgICB9XG4gICAgbmFtZShwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZVNjb3BlTmFtZShwcmVmaXgsIHRoaXMuX25ld05hbWUocHJlZml4KSk7XG4gICAgfVxuICAgIHZhbHVlKG5hbWVPclByZWZpeCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodmFsdWUucmVmID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb2RlR2VuOiByZWYgbXVzdCBiZSBwYXNzZWQgaW4gdmFsdWVcIik7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLnRvTmFtZShuYW1lT3JQcmVmaXgpO1xuICAgICAgICBjb25zdCB7IHByZWZpeCB9ID0gbmFtZTtcbiAgICAgICAgY29uc3QgdmFsdWVLZXkgPSAoX2EgPSB2YWx1ZS5rZXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbHVlLnJlZjtcbiAgICAgICAgbGV0IHZzID0gdGhpcy5fdmFsdWVzW3ByZWZpeF07XG4gICAgICAgIGlmICh2cykge1xuICAgICAgICAgICAgY29uc3QgX25hbWUgPSB2cy5nZXQodmFsdWVLZXkpO1xuICAgICAgICAgICAgaWYgKF9uYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiBfbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZzID0gdGhpcy5fdmFsdWVzW3ByZWZpeF0gPSBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdnMuc2V0KHZhbHVlS2V5LCBuYW1lKTtcbiAgICAgICAgY29uc3QgcyA9IHRoaXMuX3Njb3BlW3ByZWZpeF0gfHwgKHRoaXMuX3Njb3BlW3ByZWZpeF0gPSBbXSk7XG4gICAgICAgIGNvbnN0IGl0ZW1JbmRleCA9IHMubGVuZ3RoO1xuICAgICAgICBzW2l0ZW1JbmRleF0gPSB2YWx1ZS5yZWY7XG4gICAgICAgIG5hbWUuc2V0VmFsdWUodmFsdWUsIHsgcHJvcGVydHk6IHByZWZpeCwgaXRlbUluZGV4IH0pO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgZ2V0VmFsdWUocHJlZml4LCBrZXlPclJlZikge1xuICAgICAgICBjb25zdCB2cyA9IHRoaXMuX3ZhbHVlc1twcmVmaXhdO1xuICAgICAgICBpZiAoIXZzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gdnMuZ2V0KGtleU9yUmVmKTtcbiAgICB9XG4gICAgc2NvcGVSZWZzKHNjb3BlTmFtZSwgdmFsdWVzID0gdGhpcy5fdmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWR1Y2VWYWx1ZXModmFsdWVzLCAobmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWUuc2NvcGVQYXRoID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBuYW1lIFwiJHtuYW1lfVwiIGhhcyBubyB2YWx1ZWApO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlXzEuXykgYCR7c2NvcGVOYW1lfSR7bmFtZS5zY29wZVBhdGh9YDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNjb3BlQ29kZSh2YWx1ZXMgPSB0aGlzLl92YWx1ZXMsIHVzZWRWYWx1ZXMsIGdldENvZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZHVjZVZhbHVlcyh2YWx1ZXMsIChuYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAobmFtZS52YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogbmFtZSBcIiR7bmFtZX1cIiBoYXMgbm8gdmFsdWVgKTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lLnZhbHVlLmNvZGU7XG4gICAgICAgIH0sIHVzZWRWYWx1ZXMsIGdldENvZGUpO1xuICAgIH1cbiAgICBfcmVkdWNlVmFsdWVzKHZhbHVlcywgdmFsdWVDb2RlLCB1c2VkVmFsdWVzID0ge30sIGdldENvZGUpIHtcbiAgICAgICAgbGV0IGNvZGUgPSBjb2RlXzEubmlsO1xuICAgICAgICBmb3IgKGNvbnN0IHByZWZpeCBpbiB2YWx1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZzID0gdmFsdWVzW3ByZWZpeF07XG4gICAgICAgICAgICBpZiAoIXZzKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgbmFtZVNldCA9ICh1c2VkVmFsdWVzW3ByZWZpeF0gPSB1c2VkVmFsdWVzW3ByZWZpeF0gfHwgbmV3IE1hcCgpKTtcbiAgICAgICAgICAgIHZzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZVNldC5oYXMobmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBuYW1lU2V0LnNldChuYW1lLCBVc2VkVmFsdWVTdGF0ZS5TdGFydGVkKTtcbiAgICAgICAgICAgICAgICBsZXQgYyA9IHZhbHVlQ29kZShuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWYgPSB0aGlzLm9wdHMuZXM1ID8gZXhwb3J0cy52YXJLaW5kcy52YXIgOiBleHBvcnRzLnZhcktpbmRzLmNvbnN0O1xuICAgICAgICAgICAgICAgICAgICBjb2RlID0gKDAsIGNvZGVfMS5fKSBgJHtjb2RlfSR7ZGVmfSAke25hbWV9ID0gJHtjfTske3RoaXMub3B0cy5fbn1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoYyA9IGdldENvZGUgPT09IG51bGwgfHwgZ2V0Q29kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2V0Q29kZShuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9ICgwLCBjb2RlXzEuXykgYCR7Y29kZX0ke2N9JHt0aGlzLm9wdHMuX259YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuYW1lU2V0LnNldChuYW1lLCBVc2VkVmFsdWVTdGF0ZS5Db21wbGV0ZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxufVxuZXhwb3J0cy5WYWx1ZVNjb3BlID0gVmFsdWVTY29wZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjb3BlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vciA9IGV4cG9ydHMuYW5kID0gZXhwb3J0cy5ub3QgPSBleHBvcnRzLkNvZGVHZW4gPSBleHBvcnRzLm9wZXJhdG9ycyA9IGV4cG9ydHMudmFyS2luZHMgPSBleHBvcnRzLlZhbHVlU2NvcGVOYW1lID0gZXhwb3J0cy5WYWx1ZVNjb3BlID0gZXhwb3J0cy5TY29wZSA9IGV4cG9ydHMuTmFtZSA9IGV4cG9ydHMucmVnZXhwQ29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZXhwb3J0cy5nZXRQcm9wZXJ0eSA9IGV4cG9ydHMubmlsID0gZXhwb3J0cy5zdHJDb25jYXQgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuXyA9IHZvaWQgMDtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuL2NvZGVcIik7XG5jb25zdCBzY29wZV8xID0gcmVxdWlyZShcIi4vc2NvcGVcIik7XG52YXIgY29kZV8yID0gcmVxdWlyZShcIi4vY29kZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5fOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuc3RyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyQ29uY2F0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuc3RyQ29uY2F0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmlsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIubmlsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0UHJvcGVydHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5nZXRQcm9wZXJ0eTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLnN0cmluZ2lmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlZ2V4cENvZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5yZWdleHBDb2RlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLk5hbWU7IH0gfSk7XG52YXIgc2NvcGVfMiA9IHJlcXVpcmUoXCIuL3Njb3BlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2NvcGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjb3BlXzIuU2NvcGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWYWx1ZVNjb3BlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY29wZV8yLlZhbHVlU2NvcGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWYWx1ZVNjb3BlTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NvcGVfMi5WYWx1ZVNjb3BlTmFtZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZhcktpbmRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY29wZV8yLnZhcktpbmRzOyB9IH0pO1xuZXhwb3J0cy5vcGVyYXRvcnMgPSB7XG4gICAgR1Q6IG5ldyBjb2RlXzEuX0NvZGUoXCI+XCIpLFxuICAgIEdURTogbmV3IGNvZGVfMS5fQ29kZShcIj49XCIpLFxuICAgIExUOiBuZXcgY29kZV8xLl9Db2RlKFwiPFwiKSxcbiAgICBMVEU6IG5ldyBjb2RlXzEuX0NvZGUoXCI8PVwiKSxcbiAgICBFUTogbmV3IGNvZGVfMS5fQ29kZShcIj09PVwiKSxcbiAgICBORVE6IG5ldyBjb2RlXzEuX0NvZGUoXCIhPT1cIiksXG4gICAgTk9UOiBuZXcgY29kZV8xLl9Db2RlKFwiIVwiKSxcbiAgICBPUjogbmV3IGNvZGVfMS5fQ29kZShcInx8XCIpLFxuICAgIEFORDogbmV3IGNvZGVfMS5fQ29kZShcIiYmXCIpLFxuICAgIEFERDogbmV3IGNvZGVfMS5fQ29kZShcIitcIiksXG59O1xuY2xhc3MgTm9kZSB7XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMoX25hbWVzLCBfY29uc3RhbnRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmNsYXNzIERlZiBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKHZhcktpbmQsIG5hbWUsIHJocykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhcktpbmQgPSB2YXJLaW5kO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnJocyA9IHJocztcbiAgICB9XG4gICAgcmVuZGVyKHsgZXM1LCBfbiB9KSB7XG4gICAgICAgIGNvbnN0IHZhcktpbmQgPSBlczUgPyBzY29wZV8xLnZhcktpbmRzLnZhciA6IHRoaXMudmFyS2luZDtcbiAgICAgICAgY29uc3QgcmhzID0gdGhpcy5yaHMgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBgID0gJHt0aGlzLnJoc31gO1xuICAgICAgICByZXR1cm4gYCR7dmFyS2luZH0gJHt0aGlzLm5hbWV9JHtyaHN9O2AgKyBfbjtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGlmICghbmFtZXNbdGhpcy5uYW1lLnN0cl0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnJocylcbiAgICAgICAgICAgIHRoaXMucmhzID0gb3B0aW1pemVFeHByKHRoaXMucmhzLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmhzIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlT3JOYW1lID8gdGhpcy5yaHMubmFtZXMgOiB7fTtcbiAgICB9XG59XG5jbGFzcyBBc3NpZ24gZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihsaHMsIHJocywgc2lkZUVmZmVjdHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5saHMgPSBsaHM7XG4gICAgICAgIHRoaXMucmhzID0gcmhzO1xuICAgICAgICB0aGlzLnNpZGVFZmZlY3RzID0gc2lkZUVmZmVjdHM7XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubGhzfSA9ICR7dGhpcy5yaHN9O2AgKyBfbjtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGlmICh0aGlzLmxocyBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lICYmICFuYW1lc1t0aGlzLmxocy5zdHJdICYmICF0aGlzLnNpZGVFZmZlY3RzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJocyA9IG9wdGltaXplRXhwcih0aGlzLnJocywgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gdGhpcy5saHMgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSA/IHt9IDogeyAuLi50aGlzLmxocy5uYW1lcyB9O1xuICAgICAgICByZXR1cm4gYWRkRXhwck5hbWVzKG5hbWVzLCB0aGlzLnJocyk7XG4gICAgfVxufVxuY2xhc3MgQXNzaWduT3AgZXh0ZW5kcyBBc3NpZ24ge1xuICAgIGNvbnN0cnVjdG9yKGxocywgb3AsIHJocywgc2lkZUVmZmVjdHMpIHtcbiAgICAgICAgc3VwZXIobGhzLCByaHMsIHNpZGVFZmZlY3RzKTtcbiAgICAgICAgdGhpcy5vcCA9IG9wO1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmxoc30gJHt0aGlzLm9wfT0gJHt0aGlzLnJoc307YCArIF9uO1xuICAgIH1cbn1cbmNsYXNzIExhYmVsIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IobGFiZWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgICB0aGlzLm5hbWVzID0ge307XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubGFiZWx9OmAgKyBfbjtcbiAgICB9XG59XG5jbGFzcyBCcmVhayBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGxhYmVsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgdGhpcy5uYW1lcyA9IHt9O1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy5sYWJlbCA/IGAgJHt0aGlzLmxhYmVsfWAgOiBcIlwiO1xuICAgICAgICByZXR1cm4gYGJyZWFrJHtsYWJlbH07YCArIF9uO1xuICAgIH1cbn1cbmNsYXNzIFRocm93IGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IoZXJyb3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgdGhyb3cgJHt0aGlzLmVycm9yfTtgICsgX247XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IubmFtZXM7XG4gICAgfVxufVxuY2xhc3MgQW55Q29kZSBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb2RlfTtgICsgX247XG4gICAgfVxuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvZGV9YCA/IHRoaXMgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICB0aGlzLmNvZGUgPSBvcHRpbWl6ZUV4cHIodGhpcy5jb2RlLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZSBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZU9yTmFtZSA/IHRoaXMuY29kZS5uYW1lcyA6IHt9O1xuICAgIH1cbn1cbmNsYXNzIFBhcmVudE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlcyA9IFtdKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXMucmVkdWNlKChjb2RlLCBuKSA9PiBjb2RlICsgbi5yZW5kZXIob3B0cyksIFwiXCIpO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICBjb25zdCB7IG5vZGVzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgY29uc3QgbiA9IG5vZGVzW2ldLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG4pKVxuICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxLCAuLi5uKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG4pXG4gICAgICAgICAgICAgICAgbm9kZXNbaV0gPSBuO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXMubGVuZ3RoID4gMCA/IHRoaXMgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBjb25zdCB7IG5vZGVzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgLy8gaXRlcmF0aW5nIGJhY2t3YXJkcyBpbXByb3ZlcyAxLXBhc3Mgb3B0aW1pemF0aW9uXG4gICAgICAgICAgICBjb25zdCBuID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAobi5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgc3VidHJhY3ROYW1lcyhuYW1lcywgbi5uYW1lcyk7XG4gICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzLmxlbmd0aCA+IDAgPyB0aGlzIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLnJlZHVjZSgobmFtZXMsIG4pID0+IGFkZE5hbWVzKG5hbWVzLCBuLm5hbWVzKSwge30pO1xuICAgIH1cbn1cbmNsYXNzIEJsb2NrTm9kZSBleHRlbmRzIFBhcmVudE5vZGUge1xuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBcIntcIiArIG9wdHMuX24gKyBzdXBlci5yZW5kZXIob3B0cykgKyBcIn1cIiArIG9wdHMuX247XG4gICAgfVxufVxuY2xhc3MgUm9vdCBleHRlbmRzIFBhcmVudE5vZGUge1xufVxuY2xhc3MgRWxzZSBleHRlbmRzIEJsb2NrTm9kZSB7XG59XG5FbHNlLmtpbmQgPSBcImVsc2VcIjtcbmNsYXNzIElmIGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25kaXRpb24sIG5vZGVzKSB7XG4gICAgICAgIHN1cGVyKG5vZGVzKTtcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIGxldCBjb2RlID0gYGlmKCR7dGhpcy5jb25kaXRpb259KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgICAgIGlmICh0aGlzLmVsc2UpXG4gICAgICAgICAgICBjb2RlICs9IFwiZWxzZSBcIiArIHRoaXMuZWxzZS5yZW5kZXIob3B0cyk7XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICBzdXBlci5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgIGNvbnN0IGNvbmQgPSB0aGlzLmNvbmRpdGlvbjtcbiAgICAgICAgaWYgKGNvbmQgPT09IHRydWUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlczsgLy8gZWxzZSBpcyBpZ25vcmVkIGhlcmVcbiAgICAgICAgbGV0IGUgPSB0aGlzLmVsc2U7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBjb25zdCBucyA9IGUub3B0aW1pemVOb2RlcygpO1xuICAgICAgICAgICAgZSA9IHRoaXMuZWxzZSA9IEFycmF5LmlzQXJyYXkobnMpID8gbmV3IEVsc2UobnMpIDogbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIGlmIChjb25kID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIElmID8gZSA6IGUubm9kZXM7XG4gICAgICAgICAgICBpZiAodGhpcy5ub2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gbmV3IElmKG5vdChjb25kKSwgZSBpbnN0YW5jZW9mIElmID8gW2VdIDogZS5ub2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmQgPT09IGZhbHNlIHx8ICF0aGlzLm5vZGVzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmVsc2UgPSAoX2EgPSB0aGlzLmVsc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICBpZiAoIShzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHx8IHRoaXMuZWxzZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gb3B0aW1pemVFeHByKHRoaXMuY29uZGl0aW9uLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBzdXBlci5uYW1lcztcbiAgICAgICAgYWRkRXhwck5hbWVzKG5hbWVzLCB0aGlzLmNvbmRpdGlvbik7XG4gICAgICAgIGlmICh0aGlzLmVsc2UpXG4gICAgICAgICAgICBhZGROYW1lcyhuYW1lcywgdGhpcy5lbHNlLm5hbWVzKTtcbiAgICAgICAgcmV0dXJuIG5hbWVzO1xuICAgIH1cbn1cbklmLmtpbmQgPSBcImlmXCI7XG5jbGFzcyBGb3IgZXh0ZW5kcyBCbG9ja05vZGUge1xufVxuRm9yLmtpbmQgPSBcImZvclwiO1xuY2xhc3MgRm9yTG9vcCBleHRlbmRzIEZvciB7XG4gICAgY29uc3RydWN0b3IoaXRlcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaXRlcmF0aW9uID0gaXRlcmF0aW9uO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gYGZvcigke3RoaXMuaXRlcmF0aW9ufSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgaWYgKCFzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLml0ZXJhdGlvbiA9IG9wdGltaXplRXhwcih0aGlzLml0ZXJhdGlvbiwgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiBhZGROYW1lcyhzdXBlci5uYW1lcywgdGhpcy5pdGVyYXRpb24ubmFtZXMpO1xuICAgIH1cbn1cbmNsYXNzIEZvclJhbmdlIGV4dGVuZHMgRm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YXJLaW5kLCBuYW1lLCBmcm9tLCB0bykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhcktpbmQgPSB2YXJLaW5kO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIGNvbnN0IHZhcktpbmQgPSBvcHRzLmVzNSA/IHNjb3BlXzEudmFyS2luZHMudmFyIDogdGhpcy52YXJLaW5kO1xuICAgICAgICBjb25zdCB7IG5hbWUsIGZyb20sIHRvIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gYGZvcigke3ZhcktpbmR9ICR7bmFtZX09JHtmcm9tfTsgJHtuYW1lfTwke3RvfTsgJHtuYW1lfSsrKWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBhZGRFeHByTmFtZXMoc3VwZXIubmFtZXMsIHRoaXMuZnJvbSk7XG4gICAgICAgIHJldHVybiBhZGRFeHByTmFtZXMobmFtZXMsIHRoaXMudG8pO1xuICAgIH1cbn1cbmNsYXNzIEZvckl0ZXIgZXh0ZW5kcyBGb3Ige1xuICAgIGNvbnN0cnVjdG9yKGxvb3AsIHZhcktpbmQsIG5hbWUsIGl0ZXJhYmxlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubG9vcCA9IGxvb3A7XG4gICAgICAgIHRoaXMudmFyS2luZCA9IHZhcktpbmQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaXRlcmFibGUgPSBpdGVyYWJsZTtcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGBmb3IoJHt0aGlzLnZhcktpbmR9ICR7dGhpcy5uYW1lfSAke3RoaXMubG9vcH0gJHt0aGlzLml0ZXJhYmxlfSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgaWYgKCFzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLml0ZXJhYmxlID0gb3B0aW1pemVFeHByKHRoaXMuaXRlcmFibGUsIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gYWRkTmFtZXMoc3VwZXIubmFtZXMsIHRoaXMuaXRlcmFibGUubmFtZXMpO1xuICAgIH1cbn1cbmNsYXNzIEZ1bmMgZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGFyZ3MsIGFzeW5jKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMuYXN5bmMgPSBhc3luYztcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgY29uc3QgX2FzeW5jID0gdGhpcy5hc3luYyA/IFwiYXN5bmMgXCIgOiBcIlwiO1xuICAgICAgICByZXR1cm4gYCR7X2FzeW5jfWZ1bmN0aW9uICR7dGhpcy5uYW1lfSgke3RoaXMuYXJnc30pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG59XG5GdW5jLmtpbmQgPSBcImZ1bmNcIjtcbmNsYXNzIFJldHVybiBleHRlbmRzIFBhcmVudE5vZGUge1xuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBcInJldHVybiBcIiArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG59XG5SZXR1cm4ua2luZCA9IFwicmV0dXJuXCI7XG5jbGFzcyBUcnkgZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIGxldCBjb2RlID0gXCJ0cnlcIiArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICAgICAgaWYgKHRoaXMuY2F0Y2gpXG4gICAgICAgICAgICBjb2RlICs9IHRoaXMuY2F0Y2gucmVuZGVyKG9wdHMpO1xuICAgICAgICBpZiAodGhpcy5maW5hbGx5KVxuICAgICAgICAgICAgY29kZSArPSB0aGlzLmZpbmFsbHkucmVuZGVyKG9wdHMpO1xuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgc3VwZXIub3B0aW1pemVOb2RlcygpO1xuICAgICAgICAoX2EgPSB0aGlzLmNhdGNoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW1pemVOb2RlcygpO1xuICAgICAgICAoX2IgPSB0aGlzLmZpbmFsbHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgKF9hID0gdGhpcy5jYXRjaCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIChfYiA9IHRoaXMuZmluYWxseSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gc3VwZXIubmFtZXM7XG4gICAgICAgIGlmICh0aGlzLmNhdGNoKVxuICAgICAgICAgICAgYWRkTmFtZXMobmFtZXMsIHRoaXMuY2F0Y2gubmFtZXMpO1xuICAgICAgICBpZiAodGhpcy5maW5hbGx5KVxuICAgICAgICAgICAgYWRkTmFtZXMobmFtZXMsIHRoaXMuZmluYWxseS5uYW1lcyk7XG4gICAgICAgIHJldHVybiBuYW1lcztcbiAgICB9XG59XG5jbGFzcyBDYXRjaCBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgY29uc3RydWN0b3IoZXJyb3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gYGNhdGNoKCR7dGhpcy5lcnJvcn0pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG59XG5DYXRjaC5raW5kID0gXCJjYXRjaFwiO1xuY2xhc3MgRmluYWxseSBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIFwiZmluYWxseVwiICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbn1cbkZpbmFsbHkua2luZCA9IFwiZmluYWxseVwiO1xuY2xhc3MgQ29kZUdlbiB7XG4gICAgY29uc3RydWN0b3IoZXh0U2NvcGUsIG9wdHMgPSB7fSkge1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fYmxvY2tTdGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5fY29uc3RhbnRzID0ge307XG4gICAgICAgIHRoaXMub3B0cyA9IHsgLi4ub3B0cywgX246IG9wdHMubGluZXMgPyBcIlxcblwiIDogXCJcIiB9O1xuICAgICAgICB0aGlzLl9leHRTY29wZSA9IGV4dFNjb3BlO1xuICAgICAgICB0aGlzLl9zY29wZSA9IG5ldyBzY29wZV8xLlNjb3BlKHsgcGFyZW50OiBleHRTY29wZSB9KTtcbiAgICAgICAgdGhpcy5fbm9kZXMgPSBbbmV3IFJvb3QoKV07XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdC5yZW5kZXIodGhpcy5vcHRzKTtcbiAgICB9XG4gICAgLy8gcmV0dXJucyB1bmlxdWUgbmFtZSBpbiB0aGUgaW50ZXJuYWwgc2NvcGVcbiAgICBuYW1lKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NvcGUubmFtZShwcmVmaXgpO1xuICAgIH1cbiAgICAvLyByZXNlcnZlcyB1bmlxdWUgbmFtZSBpbiB0aGUgZXh0ZXJuYWwgc2NvcGVcbiAgICBzY29wZU5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5uYW1lKHByZWZpeCk7XG4gICAgfVxuICAgIC8vIHJlc2VydmVzIHVuaXF1ZSBuYW1lIGluIHRoZSBleHRlcm5hbCBzY29wZSBhbmQgYXNzaWducyB2YWx1ZSB0byBpdFxuICAgIHNjb3BlVmFsdWUocHJlZml4T3JOYW1lLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fZXh0U2NvcGUudmFsdWUocHJlZml4T3JOYW1lLCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHZzID0gdGhpcy5fdmFsdWVzW25hbWUucHJlZml4XSB8fCAodGhpcy5fdmFsdWVzW25hbWUucHJlZml4XSA9IG5ldyBTZXQoKSk7XG4gICAgICAgIHZzLmFkZChuYW1lKTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIGdldFNjb3BlVmFsdWUocHJlZml4LCBrZXlPclJlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUuZ2V0VmFsdWUocHJlZml4LCBrZXlPclJlZik7XG4gICAgfVxuICAgIC8vIHJldHVybiBjb2RlIHRoYXQgYXNzaWducyB2YWx1ZXMgaW4gdGhlIGV4dGVybmFsIHNjb3BlIHRvIHRoZSBuYW1lcyB0aGF0IGFyZSB1c2VkIGludGVybmFsbHlcbiAgICAvLyAoc2FtZSBuYW1lcyB0aGF0IHdlcmUgcmV0dXJuZWQgYnkgZ2VuLnNjb3BlTmFtZSBvciBnZW4uc2NvcGVWYWx1ZSlcbiAgICBzY29wZVJlZnMoc2NvcGVOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5zY29wZVJlZnMoc2NvcGVOYW1lLCB0aGlzLl92YWx1ZXMpO1xuICAgIH1cbiAgICBzY29wZUNvZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5zY29wZUNvZGUodGhpcy5fdmFsdWVzKTtcbiAgICB9XG4gICAgX2RlZih2YXJLaW5kLCBuYW1lT3JQcmVmaXgsIHJocywgY29uc3RhbnQpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX3Njb3BlLnRvTmFtZShuYW1lT3JQcmVmaXgpO1xuICAgICAgICBpZiAocmhzICE9PSB1bmRlZmluZWQgJiYgY29uc3RhbnQpXG4gICAgICAgICAgICB0aGlzLl9jb25zdGFudHNbbmFtZS5zdHJdID0gcmhzO1xuICAgICAgICB0aGlzLl9sZWFmTm9kZShuZXcgRGVmKHZhcktpbmQsIG5hbWUsIHJocykpO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgLy8gYGNvbnN0YCBkZWNsYXJhdGlvbiAoYHZhcmAgaW4gZXM1IG1vZGUpXG4gICAgY29uc3QobmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmKHNjb3BlXzEudmFyS2luZHMuY29uc3QsIG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpO1xuICAgIH1cbiAgICAvLyBgbGV0YCBkZWNsYXJhdGlvbiB3aXRoIG9wdGlvbmFsIGFzc2lnbm1lbnQgKGB2YXJgIGluIGVzNSBtb2RlKVxuICAgIGxldChuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYoc2NvcGVfMS52YXJLaW5kcy5sZXQsIG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpO1xuICAgIH1cbiAgICAvLyBgdmFyYCBkZWNsYXJhdGlvbiB3aXRoIG9wdGlvbmFsIGFzc2lnbm1lbnRcbiAgICB2YXIobmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmKHNjb3BlXzEudmFyS2luZHMudmFyLCBuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KTtcbiAgICB9XG4gICAgLy8gYXNzaWdubWVudCBjb2RlXG4gICAgYXNzaWduKGxocywgcmhzLCBzaWRlRWZmZWN0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IEFzc2lnbihsaHMsIHJocywgc2lkZUVmZmVjdHMpKTtcbiAgICB9XG4gICAgLy8gYCs9YCBjb2RlXG4gICAgYWRkKGxocywgcmhzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgQXNzaWduT3AobGhzLCBleHBvcnRzLm9wZXJhdG9ycy5BREQsIHJocykpO1xuICAgIH1cbiAgICAvLyBhcHBlbmRzIHBhc3NlZCBTYWZlRXhwciB0byBjb2RlIG9yIGV4ZWN1dGVzIEJsb2NrXG4gICAgY29kZShjKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBjKCk7XG4gICAgICAgIGVsc2UgaWYgKGMgIT09IGNvZGVfMS5uaWwpXG4gICAgICAgICAgICB0aGlzLl9sZWFmTm9kZShuZXcgQW55Q29kZShjKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyByZXR1cm5zIGNvZGUgZm9yIG9iamVjdCBsaXRlcmFsIGZvciB0aGUgcGFzc2VkIGFyZ3VtZW50IGxpc3Qgb2Yga2V5LXZhbHVlIHBhaXJzXG4gICAgb2JqZWN0KC4uLmtleVZhbHVlcykge1xuICAgICAgICBjb25zdCBjb2RlID0gW1wie1wiXTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Yga2V5VmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAoY29kZS5sZW5ndGggPiAxKVxuICAgICAgICAgICAgICAgIGNvZGUucHVzaChcIixcIik7XG4gICAgICAgICAgICBjb2RlLnB1c2goa2V5KTtcbiAgICAgICAgICAgIGlmIChrZXkgIT09IHZhbHVlIHx8IHRoaXMub3B0cy5lczUpIHtcbiAgICAgICAgICAgICAgICBjb2RlLnB1c2goXCI6XCIpO1xuICAgICAgICAgICAgICAgICgwLCBjb2RlXzEuYWRkQ29kZUFyZykoY29kZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvZGUucHVzaChcIn1cIik7XG4gICAgICAgIHJldHVybiBuZXcgY29kZV8xLl9Db2RlKGNvZGUpO1xuICAgIH1cbiAgICAvLyBgaWZgIGNsYXVzZSAob3Igc3RhdGVtZW50IGlmIGB0aGVuQm9keWAgYW5kLCBvcHRpb25hbGx5LCBgZWxzZUJvZHlgIGFyZSBwYXNzZWQpXG4gICAgaWYoY29uZGl0aW9uLCB0aGVuQm9keSwgZWxzZUJvZHkpIHtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5ldyBJZihjb25kaXRpb24pKTtcbiAgICAgICAgaWYgKHRoZW5Cb2R5ICYmIGVsc2VCb2R5KSB7XG4gICAgICAgICAgICB0aGlzLmNvZGUodGhlbkJvZHkpLmVsc2UoKS5jb2RlKGVsc2VCb2R5KS5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoZW5Cb2R5KSB7XG4gICAgICAgICAgICB0aGlzLmNvZGUodGhlbkJvZHkpLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxzZUJvZHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJlbHNlXCIgYm9keSB3aXRob3V0IFwidGhlblwiIGJvZHknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gYGVsc2UgaWZgIGNsYXVzZSAtIGludmFsaWQgd2l0aG91dCBgaWZgIG9yIGFmdGVyIGBlbHNlYCBjbGF1c2VzXG4gICAgZWxzZUlmKGNvbmRpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxzZU5vZGUobmV3IElmKGNvbmRpdGlvbikpO1xuICAgIH1cbiAgICAvLyBgZWxzZWAgY2xhdXNlIC0gb25seSB2YWxpZCBhZnRlciBgaWZgIG9yIGBlbHNlIGlmYCBjbGF1c2VzXG4gICAgZWxzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vsc2VOb2RlKG5ldyBFbHNlKCkpO1xuICAgIH1cbiAgICAvLyBlbmQgYGlmYCBzdGF0ZW1lbnQgKG5lZWRlZCBpZiBnZW4uaWYgd2FzIHVzZWQgb25seSB3aXRoIGNvbmRpdGlvbilcbiAgICBlbmRJZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShJZiwgRWxzZSk7XG4gICAgfVxuICAgIF9mb3Iobm9kZSwgZm9yQm9keSkge1xuICAgICAgICB0aGlzLl9ibG9ja05vZGUobm9kZSk7XG4gICAgICAgIGlmIChmb3JCb2R5KVxuICAgICAgICAgICAgdGhpcy5jb2RlKGZvckJvZHkpLmVuZEZvcigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gYSBnZW5lcmljIGBmb3JgIGNsYXVzZSAob3Igc3RhdGVtZW50IGlmIGBmb3JCb2R5YCBpcyBwYXNzZWQpXG4gICAgZm9yKGl0ZXJhdGlvbiwgZm9yQm9keSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JMb29wKGl0ZXJhdGlvbiksIGZvckJvZHkpO1xuICAgIH1cbiAgICAvLyBgZm9yYCBzdGF0ZW1lbnQgZm9yIGEgcmFuZ2Ugb2YgdmFsdWVzXG4gICAgZm9yUmFuZ2UobmFtZU9yUHJlZml4LCBmcm9tLCB0bywgZm9yQm9keSwgdmFyS2luZCA9IHRoaXMub3B0cy5lczUgPyBzY29wZV8xLnZhcktpbmRzLnZhciA6IHNjb3BlXzEudmFyS2luZHMubGV0KSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9yUmFuZ2UodmFyS2luZCwgbmFtZSwgZnJvbSwgdG8pLCAoKSA9PiBmb3JCb2R5KG5hbWUpKTtcbiAgICB9XG4gICAgLy8gYGZvci1vZmAgc3RhdGVtZW50IChpbiBlczUgbW9kZSByZXBsYWNlIHdpdGggYSBub3JtYWwgZm9yIGxvb3ApXG4gICAgZm9yT2YobmFtZU9yUHJlZml4LCBpdGVyYWJsZSwgZm9yQm9keSwgdmFyS2luZCA9IHNjb3BlXzEudmFyS2luZHMuY29uc3QpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX3Njb3BlLnRvTmFtZShuYW1lT3JQcmVmaXgpO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmVzNSkge1xuICAgICAgICAgICAgY29uc3QgYXJyID0gaXRlcmFibGUgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSA/IGl0ZXJhYmxlIDogdGhpcy52YXIoXCJfYXJyXCIsIGl0ZXJhYmxlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvclJhbmdlKFwiX2lcIiwgMCwgKDAsIGNvZGVfMS5fKSBgJHthcnJ9Lmxlbmd0aGAsIChpKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy52YXIobmFtZSwgKDAsIGNvZGVfMS5fKSBgJHthcnJ9WyR7aX1dYCk7XG4gICAgICAgICAgICAgICAgZm9yQm9keShuYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvckl0ZXIoXCJvZlwiLCB2YXJLaW5kLCBuYW1lLCBpdGVyYWJsZSksICgpID0+IGZvckJvZHkobmFtZSkpO1xuICAgIH1cbiAgICAvLyBgZm9yLWluYCBzdGF0ZW1lbnQuXG4gICAgLy8gV2l0aCBvcHRpb24gYG93blByb3BlcnRpZXNgIHJlcGxhY2VkIHdpdGggYSBgZm9yLW9mYCBsb29wIGZvciBvYmplY3Qga2V5c1xuICAgIGZvckluKG5hbWVPclByZWZpeCwgb2JqLCBmb3JCb2R5LCB2YXJLaW5kID0gdGhpcy5vcHRzLmVzNSA/IHNjb3BlXzEudmFyS2luZHMudmFyIDogc2NvcGVfMS52YXJLaW5kcy5jb25zdCkge1xuICAgICAgICBpZiAodGhpcy5vcHRzLm93blByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvck9mKG5hbWVPclByZWZpeCwgKDAsIGNvZGVfMS5fKSBgT2JqZWN0LmtleXMoJHtvYmp9KWAsIGZvckJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9ySXRlcihcImluXCIsIHZhcktpbmQsIG5hbWUsIG9iaiksICgpID0+IGZvckJvZHkobmFtZSkpO1xuICAgIH1cbiAgICAvLyBlbmQgYGZvcmAgbG9vcFxuICAgIGVuZEZvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShGb3IpO1xuICAgIH1cbiAgICAvLyBgbGFiZWxgIHN0YXRlbWVudFxuICAgIGxhYmVsKGxhYmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgTGFiZWwobGFiZWwpKTtcbiAgICB9XG4gICAgLy8gYGJyZWFrYCBzdGF0ZW1lbnRcbiAgICBicmVhayhsYWJlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IEJyZWFrKGxhYmVsKSk7XG4gICAgfVxuICAgIC8vIGByZXR1cm5gIHN0YXRlbWVudFxuICAgIHJldHVybih2YWx1ZSkge1xuICAgICAgICBjb25zdCBub2RlID0gbmV3IFJldHVybigpO1xuICAgICAgICB0aGlzLl9ibG9ja05vZGUobm9kZSk7XG4gICAgICAgIHRoaXMuY29kZSh2YWx1ZSk7XG4gICAgICAgIGlmIChub2RlLm5vZGVzLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJyZXR1cm5cIiBzaG91bGQgaGF2ZSBvbmUgbm9kZScpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKFJldHVybik7XG4gICAgfVxuICAgIC8vIGB0cnlgIHN0YXRlbWVudFxuICAgIHRyeSh0cnlCb2R5LCBjYXRjaENvZGUsIGZpbmFsbHlDb2RlKSB7XG4gICAgICAgIGlmICghY2F0Y2hDb2RlICYmICFmaW5hbGx5Q29kZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJ0cnlcIiB3aXRob3V0IFwiY2F0Y2hcIiBhbmQgXCJmaW5hbGx5XCInKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBUcnkoKTtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5vZGUpO1xuICAgICAgICB0aGlzLmNvZGUodHJ5Qm9keSk7XG4gICAgICAgIGlmIChjYXRjaENvZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5uYW1lKFwiZVwiKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJOb2RlID0gbm9kZS5jYXRjaCA9IG5ldyBDYXRjaChlcnJvcik7XG4gICAgICAgICAgICBjYXRjaENvZGUoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaW5hbGx5Q29kZSkge1xuICAgICAgICAgICAgdGhpcy5fY3Vyck5vZGUgPSBub2RlLmZpbmFsbHkgPSBuZXcgRmluYWxseSgpO1xuICAgICAgICAgICAgdGhpcy5jb2RlKGZpbmFsbHlDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKENhdGNoLCBGaW5hbGx5KTtcbiAgICB9XG4gICAgLy8gYHRocm93YCBzdGF0ZW1lbnRcbiAgICB0aHJvdyhlcnJvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IFRocm93KGVycm9yKSk7XG4gICAgfVxuICAgIC8vIHN0YXJ0IHNlbGYtYmFsYW5jaW5nIGJsb2NrXG4gICAgYmxvY2soYm9keSwgbm9kZUNvdW50KSB7XG4gICAgICAgIHRoaXMuX2Jsb2NrU3RhcnRzLnB1c2godGhpcy5fbm9kZXMubGVuZ3RoKTtcbiAgICAgICAgaWYgKGJvZHkpXG4gICAgICAgICAgICB0aGlzLmNvZGUoYm9keSkuZW5kQmxvY2sobm9kZUNvdW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGVuZCB0aGUgY3VycmVudCBzZWxmLWJhbGFuY2luZyBibG9ja1xuICAgIGVuZEJsb2NrKG5vZGVDb3VudCkge1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLl9ibG9ja1N0YXJ0cy5wb3AoKTtcbiAgICAgICAgaWYgKGxlbiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogbm90IGluIHNlbGYtYmFsYW5jaW5nIGJsb2NrXCIpO1xuICAgICAgICBjb25zdCB0b0Nsb3NlID0gdGhpcy5fbm9kZXMubGVuZ3RoIC0gbGVuO1xuICAgICAgICBpZiAodG9DbG9zZSA8IDAgfHwgKG5vZGVDb3VudCAhPT0gdW5kZWZpbmVkICYmIHRvQ2xvc2UgIT09IG5vZGVDb3VudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogd3JvbmcgbnVtYmVyIG9mIG5vZGVzOiAke3RvQ2xvc2V9IHZzICR7bm9kZUNvdW50fSBleHBlY3RlZGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25vZGVzLmxlbmd0aCA9IGxlbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGBmdW5jdGlvbmAgaGVhZGluZyAob3IgZGVmaW5pdGlvbiBpZiBmdW5jQm9keSBpcyBwYXNzZWQpXG4gICAgZnVuYyhuYW1lLCBhcmdzID0gY29kZV8xLm5pbCwgYXN5bmMsIGZ1bmNCb2R5KSB7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShuZXcgRnVuYyhuYW1lLCBhcmdzLCBhc3luYykpO1xuICAgICAgICBpZiAoZnVuY0JvZHkpXG4gICAgICAgICAgICB0aGlzLmNvZGUoZnVuY0JvZHkpLmVuZEZ1bmMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGVuZCBmdW5jdGlvbiBkZWZpbml0aW9uXG4gICAgZW5kRnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShGdW5jKTtcbiAgICB9XG4gICAgb3B0aW1pemUobiA9IDEpIHtcbiAgICAgICAgd2hpbGUgKG4tLSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3Qub3B0aW1pemVOb2RlcygpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdC5vcHRpbWl6ZU5hbWVzKHRoaXMuX3Jvb3QubmFtZXMsIHRoaXMuX2NvbnN0YW50cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2xlYWZOb2RlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5fY3Vyck5vZGUubm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIF9ibG9ja05vZGUobm9kZSkge1xuICAgICAgICB0aGlzLl9jdXJyTm9kZS5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB0aGlzLl9ub2Rlcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgICBfZW5kQmxvY2tOb2RlKE4xLCBOMikge1xuICAgICAgICBjb25zdCBuID0gdGhpcy5fY3Vyck5vZGU7XG4gICAgICAgIGlmIChuIGluc3RhbmNlb2YgTjEgfHwgKE4yICYmIG4gaW5zdGFuY2VvZiBOMikpIHtcbiAgICAgICAgICAgIHRoaXMuX25vZGVzLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBub3QgaW4gYmxvY2sgXCIke04yID8gYCR7TjEua2luZH0vJHtOMi5raW5kfWAgOiBOMS5raW5kfVwiYCk7XG4gICAgfVxuICAgIF9lbHNlTm9kZShub2RlKSB7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLl9jdXJyTm9kZTtcbiAgICAgICAgaWYgKCEobiBpbnN0YW5jZW9mIElmKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlR2VuOiBcImVsc2VcIiB3aXRob3V0IFwiaWZcIicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnJOb2RlID0gbi5lbHNlID0gbm9kZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBfcm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vZGVzWzBdO1xuICAgIH1cbiAgICBnZXQgX2N1cnJOb2RlKCkge1xuICAgICAgICBjb25zdCBucyA9IHRoaXMuX25vZGVzO1xuICAgICAgICByZXR1cm4gbnNbbnMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHNldCBfY3Vyck5vZGUobm9kZSkge1xuICAgICAgICBjb25zdCBucyA9IHRoaXMuX25vZGVzO1xuICAgICAgICBuc1tucy5sZW5ndGggLSAxXSA9IG5vZGU7XG4gICAgfVxufVxuZXhwb3J0cy5Db2RlR2VuID0gQ29kZUdlbjtcbmZ1bmN0aW9uIGFkZE5hbWVzKG5hbWVzLCBmcm9tKSB7XG4gICAgZm9yIChjb25zdCBuIGluIGZyb20pXG4gICAgICAgIG5hbWVzW25dID0gKG5hbWVzW25dIHx8IDApICsgKGZyb21bbl0gfHwgMCk7XG4gICAgcmV0dXJuIG5hbWVzO1xufVxuZnVuY3Rpb24gYWRkRXhwck5hbWVzKG5hbWVzLCBmcm9tKSB7XG4gICAgcmV0dXJuIGZyb20gaW5zdGFuY2VvZiBjb2RlXzEuX0NvZGVPck5hbWUgPyBhZGROYW1lcyhuYW1lcywgZnJvbS5uYW1lcykgOiBuYW1lcztcbn1cbmZ1bmN0aW9uIG9wdGltaXplRXhwcihleHByLCBuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSlcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VOYW1lKGV4cHIpO1xuICAgIGlmICghY2FuT3B0aW1pemUoZXhwcikpXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIHJldHVybiBuZXcgY29kZV8xLl9Db2RlKGV4cHIuX2l0ZW1zLnJlZHVjZSgoaXRlbXMsIGMpID0+IHtcbiAgICAgICAgaWYgKGMgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSlcbiAgICAgICAgICAgIGMgPSByZXBsYWNlTmFtZShjKTtcbiAgICAgICAgaWYgKGMgaW5zdGFuY2VvZiBjb2RlXzEuX0NvZGUpXG4gICAgICAgICAgICBpdGVtcy5wdXNoKC4uLmMuX2l0ZW1zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgaXRlbXMucHVzaChjKTtcbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0sIFtdKSk7XG4gICAgZnVuY3Rpb24gcmVwbGFjZU5hbWUobikge1xuICAgICAgICBjb25zdCBjID0gY29uc3RhbnRzW24uc3RyXTtcbiAgICAgICAgaWYgKGMgPT09IHVuZGVmaW5lZCB8fCBuYW1lc1tuLnN0cl0gIT09IDEpXG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgZGVsZXRlIG5hbWVzW24uc3RyXTtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbk9wdGltaXplKGUpIHtcbiAgICAgICAgcmV0dXJuIChlIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlICYmXG4gICAgICAgICAgICBlLl9pdGVtcy5zb21lKChjKSA9PiBjIGluc3RhbmNlb2YgY29kZV8xLk5hbWUgJiYgbmFtZXNbYy5zdHJdID09PSAxICYmIGNvbnN0YW50c1tjLnN0cl0gIT09IHVuZGVmaW5lZCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN1YnRyYWN0TmFtZXMobmFtZXMsIGZyb20pIHtcbiAgICBmb3IgKGNvbnN0IG4gaW4gZnJvbSlcbiAgICAgICAgbmFtZXNbbl0gPSAobmFtZXNbbl0gfHwgMCkgLSAoZnJvbVtuXSB8fCAwKTtcbn1cbmZ1bmN0aW9uIG5vdCh4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09IFwiYm9vbGVhblwiIHx8IHR5cGVvZiB4ID09IFwibnVtYmVyXCIgfHwgeCA9PT0gbnVsbCA/ICF4IDogKDAsIGNvZGVfMS5fKSBgISR7cGFyKHgpfWA7XG59XG5leHBvcnRzLm5vdCA9IG5vdDtcbmNvbnN0IGFuZENvZGUgPSBtYXBwZW5kKGV4cG9ydHMub3BlcmF0b3JzLkFORCk7XG4vLyBib29sZWFuIEFORCAoJiYpIGV4cHJlc3Npb24gd2l0aCB0aGUgcGFzc2VkIGFyZ3VtZW50c1xuZnVuY3Rpb24gYW5kKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gYXJncy5yZWR1Y2UoYW5kQ29kZSk7XG59XG5leHBvcnRzLmFuZCA9IGFuZDtcbmNvbnN0IG9yQ29kZSA9IG1hcHBlbmQoZXhwb3J0cy5vcGVyYXRvcnMuT1IpO1xuLy8gYm9vbGVhbiBPUiAofHwpIGV4cHJlc3Npb24gd2l0aCB0aGUgcGFzc2VkIGFyZ3VtZW50c1xuZnVuY3Rpb24gb3IoLi4uYXJncykge1xuICAgIHJldHVybiBhcmdzLnJlZHVjZShvckNvZGUpO1xufVxuZXhwb3J0cy5vciA9IG9yO1xuZnVuY3Rpb24gbWFwcGVuZChvcCkge1xuICAgIHJldHVybiAoeCwgeSkgPT4gKHggPT09IGNvZGVfMS5uaWwgPyB5IDogeSA9PT0gY29kZV8xLm5pbCA/IHggOiAoMCwgY29kZV8xLl8pIGAke3Bhcih4KX0gJHtvcH0gJHtwYXIoeSl9YCk7XG59XG5mdW5jdGlvbiBwYXIoeCkge1xuICAgIHJldHVybiB4IGluc3RhbmNlb2YgY29kZV8xLk5hbWUgPyB4IDogKDAsIGNvZGVfMS5fKSBgKCR7eH0pYDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jaGVja1N0cmljdE1vZGUgPSBleHBvcnRzLmdldEVycm9yUGF0aCA9IGV4cG9ydHMuVHlwZSA9IGV4cG9ydHMudXNlRnVuYyA9IGV4cG9ydHMuc2V0RXZhbHVhdGVkID0gZXhwb3J0cy5ldmFsdWF0ZWRQcm9wc1RvTmFtZSA9IGV4cG9ydHMubWVyZ2VFdmFsdWF0ZWQgPSBleHBvcnRzLmVhY2hJdGVtID0gZXhwb3J0cy51bmVzY2FwZUpzb25Qb2ludGVyID0gZXhwb3J0cy5lc2NhcGVKc29uUG9pbnRlciA9IGV4cG9ydHMuZXNjYXBlRnJhZ21lbnQgPSBleHBvcnRzLnVuZXNjYXBlRnJhZ21lbnQgPSBleHBvcnRzLnNjaGVtYVJlZk9yVmFsID0gZXhwb3J0cy5zY2hlbWFIYXNSdWxlc0J1dFJlZiA9IGV4cG9ydHMuc2NoZW1hSGFzUnVsZXMgPSBleHBvcnRzLmNoZWNrVW5rbm93blJ1bGVzID0gZXhwb3J0cy5hbHdheXNWYWxpZFNjaGVtYSA9IGV4cG9ydHMudG9IYXNoID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4vY29kZWdlblwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW4vY29kZVwiKTtcbi8vIFRPRE8gcmVmYWN0b3IgdG8gdXNlIFNldFxuZnVuY3Rpb24gdG9IYXNoKGFycikge1xuICAgIGNvbnN0IGhhc2ggPSB7fTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKVxuICAgICAgICBoYXNoW2l0ZW1dID0gdHJ1ZTtcbiAgICByZXR1cm4gaGFzaDtcbn1cbmV4cG9ydHMudG9IYXNoID0gdG9IYXNoO1xuZnVuY3Rpb24gYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIGlmIChPYmplY3Qua2V5cyhzY2hlbWEpLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2hlY2tVbmtub3duUnVsZXMoaXQsIHNjaGVtYSk7XG4gICAgcmV0dXJuICFzY2hlbWFIYXNSdWxlcyhzY2hlbWEsIGl0LnNlbGYuUlVMRVMuYWxsKTtcbn1cbmV4cG9ydHMuYWx3YXlzVmFsaWRTY2hlbWEgPSBhbHdheXNWYWxpZFNjaGVtYTtcbmZ1bmN0aW9uIGNoZWNrVW5rbm93blJ1bGVzKGl0LCBzY2hlbWEgPSBpdC5zY2hlbWEpIHtcbiAgICBjb25zdCB7IG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgIGlmICghb3B0cy5zdHJpY3RTY2hlbWEpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBydWxlcyA9IHNlbGYuUlVMRVMua2V5d29yZHM7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGlmICghcnVsZXNba2V5XSlcbiAgICAgICAgICAgIGNoZWNrU3RyaWN0TW9kZShpdCwgYHVua25vd24ga2V5d29yZDogXCIke2tleX1cImApO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tVbmtub3duUnVsZXMgPSBjaGVja1Vua25vd25SdWxlcztcbmZ1bmN0aW9uIHNjaGVtYUhhc1J1bGVzKHNjaGVtYSwgcnVsZXMpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuICFzY2hlbWE7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKVxuICAgICAgICBpZiAocnVsZXNba2V5XSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuc2NoZW1hSGFzUnVsZXMgPSBzY2hlbWFIYXNSdWxlcztcbmZ1bmN0aW9uIHNjaGVtYUhhc1J1bGVzQnV0UmVmKHNjaGVtYSwgUlVMRVMpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuICFzY2hlbWE7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKVxuICAgICAgICBpZiAoa2V5ICE9PSBcIiRyZWZcIiAmJiBSVUxFUy5hbGxba2V5XSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuc2NoZW1hSGFzUnVsZXNCdXRSZWYgPSBzY2hlbWFIYXNSdWxlc0J1dFJlZjtcbmZ1bmN0aW9uIHNjaGVtYVJlZk9yVmFsKHsgdG9wU2NoZW1hUmVmLCBzY2hlbWFQYXRoIH0sIHNjaGVtYSwga2V5d29yZCwgJGRhdGEpIHtcbiAgICBpZiAoISRkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hlbWF9YDtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7dG9wU2NoZW1hUmVmfSR7c2NoZW1hUGF0aH0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKGtleXdvcmQpfWA7XG59XG5leHBvcnRzLnNjaGVtYVJlZk9yVmFsID0gc2NoZW1hUmVmT3JWYWw7XG5mdW5jdGlvbiB1bmVzY2FwZUZyYWdtZW50KHN0cikge1xuICAgIHJldHVybiB1bmVzY2FwZUpzb25Qb2ludGVyKGRlY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbn1cbmV4cG9ydHMudW5lc2NhcGVGcmFnbWVudCA9IHVuZXNjYXBlRnJhZ21lbnQ7XG5mdW5jdGlvbiBlc2NhcGVGcmFnbWVudChzdHIpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGVzY2FwZUpzb25Qb2ludGVyKHN0cikpO1xufVxuZXhwb3J0cy5lc2NhcGVGcmFnbWVudCA9IGVzY2FwZUZyYWdtZW50O1xuZnVuY3Rpb24gZXNjYXBlSnNvblBvaW50ZXIoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgPT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIGAke3N0cn1gO1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcLy9nLCBcIn4xXCIpO1xufVxuZXhwb3J0cy5lc2NhcGVKc29uUG9pbnRlciA9IGVzY2FwZUpzb25Qb2ludGVyO1xuZnVuY3Rpb24gdW5lc2NhcGVKc29uUG9pbnRlcihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL34xL2csIFwiL1wiKS5yZXBsYWNlKC9+MC9nLCBcIn5cIik7XG59XG5leHBvcnRzLnVuZXNjYXBlSnNvblBvaW50ZXIgPSB1bmVzY2FwZUpzb25Qb2ludGVyO1xuZnVuY3Rpb24gZWFjaEl0ZW0oeHMsIGYpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh4cykpIHtcbiAgICAgICAgZm9yIChjb25zdCB4IG9mIHhzKVxuICAgICAgICAgICAgZih4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGYoeHMpO1xuICAgIH1cbn1cbmV4cG9ydHMuZWFjaEl0ZW0gPSBlYWNoSXRlbTtcbmZ1bmN0aW9uIG1ha2VNZXJnZUV2YWx1YXRlZCh7IG1lcmdlTmFtZXMsIG1lcmdlVG9OYW1lLCBtZXJnZVZhbHVlcywgcmVzdWx0VG9OYW1lLCB9KSB7XG4gICAgcmV0dXJuIChnZW4sIGZyb20sIHRvLCB0b05hbWUpID0+IHtcbiAgICAgICAgY29uc3QgcmVzID0gdG8gPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBmcm9tXG4gICAgICAgICAgICA6IHRvIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWVcbiAgICAgICAgICAgICAgICA/IChmcm9tIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUgPyBtZXJnZU5hbWVzKGdlbiwgZnJvbSwgdG8pIDogbWVyZ2VUb05hbWUoZ2VuLCBmcm9tLCB0byksIHRvKVxuICAgICAgICAgICAgICAgIDogZnJvbSBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lXG4gICAgICAgICAgICAgICAgICAgID8gKG1lcmdlVG9OYW1lKGdlbiwgdG8sIGZyb20pLCBmcm9tKVxuICAgICAgICAgICAgICAgICAgICA6IG1lcmdlVmFsdWVzKGZyb20sIHRvKTtcbiAgICAgICAgcmV0dXJuIHRvTmFtZSA9PT0gY29kZWdlbl8xLk5hbWUgJiYgIShyZXMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSkgPyByZXN1bHRUb05hbWUoZ2VuLCByZXMpIDogcmVzO1xuICAgIH07XG59XG5leHBvcnRzLm1lcmdlRXZhbHVhdGVkID0ge1xuICAgIHByb3BzOiBtYWtlTWVyZ2VFdmFsdWF0ZWQoe1xuICAgICAgICBtZXJnZU5hbWVzOiAoZ2VuLCBmcm9tLCB0bykgPT4gZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7dG99ICE9PSB0cnVlICYmICR7ZnJvbX0gIT09IHVuZGVmaW5lZGAsICgpID0+IHtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2Zyb219ID09PSB0cnVlYCwgKCkgPT4gZ2VuLmFzc2lnbih0bywgdHJ1ZSksICgpID0+IGdlbi5hc3NpZ24odG8sICgwLCBjb2RlZ2VuXzEuXykgYCR7dG99IHx8IHt9YCkuY29kZSgoMCwgY29kZWdlbl8xLl8pIGBPYmplY3QuYXNzaWduKCR7dG99LCAke2Zyb219KWApKTtcbiAgICAgICAgfSksXG4gICAgICAgIG1lcmdlVG9OYW1lOiAoZ2VuLCBmcm9tLCB0bykgPT4gZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7dG99ICE9PSB0cnVlYCwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZyb20gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHRvLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odG8sICgwLCBjb2RlZ2VuXzEuXykgYCR7dG99IHx8IHt9YCk7XG4gICAgICAgICAgICAgICAgc2V0RXZhbHVhdGVkKGdlbiwgdG8sIGZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgbWVyZ2VWYWx1ZXM6IChmcm9tLCB0bykgPT4gKGZyb20gPT09IHRydWUgPyB0cnVlIDogeyAuLi5mcm9tLCAuLi50byB9KSxcbiAgICAgICAgcmVzdWx0VG9OYW1lOiBldmFsdWF0ZWRQcm9wc1RvTmFtZSxcbiAgICB9KSxcbiAgICBpdGVtczogbWFrZU1lcmdlRXZhbHVhdGVkKHtcbiAgICAgICAgbWVyZ2VOYW1lczogKGdlbiwgZnJvbSwgdG8pID0+IGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke3RvfSAhPT0gdHJ1ZSAmJiAke2Zyb219ICE9PSB1bmRlZmluZWRgLCAoKSA9PiBnZW4uYXNzaWduKHRvLCAoMCwgY29kZWdlbl8xLl8pIGAke2Zyb219ID09PSB0cnVlID8gdHJ1ZSA6ICR7dG99ID4gJHtmcm9tfSA/ICR7dG99IDogJHtmcm9tfWApKSxcbiAgICAgICAgbWVyZ2VUb05hbWU6IChnZW4sIGZyb20sIHRvKSA9PiBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHt0b30gIT09IHRydWVgLCAoKSA9PiBnZW4uYXNzaWduKHRvLCBmcm9tID09PSB0cnVlID8gdHJ1ZSA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7dG99ID4gJHtmcm9tfSA/ICR7dG99IDogJHtmcm9tfWApKSxcbiAgICAgICAgbWVyZ2VWYWx1ZXM6IChmcm9tLCB0bykgPT4gKGZyb20gPT09IHRydWUgPyB0cnVlIDogTWF0aC5tYXgoZnJvbSwgdG8pKSxcbiAgICAgICAgcmVzdWx0VG9OYW1lOiAoZ2VuLCBpdGVtcykgPT4gZ2VuLnZhcihcIml0ZW1zXCIsIGl0ZW1zKSxcbiAgICB9KSxcbn07XG5mdW5jdGlvbiBldmFsdWF0ZWRQcm9wc1RvTmFtZShnZW4sIHBzKSB7XG4gICAgaWYgKHBzID09PSB0cnVlKVxuICAgICAgICByZXR1cm4gZ2VuLnZhcihcInByb3BzXCIsIHRydWUpO1xuICAgIGNvbnN0IHByb3BzID0gZ2VuLnZhcihcInByb3BzXCIsICgwLCBjb2RlZ2VuXzEuXykgYHt9YCk7XG4gICAgaWYgKHBzICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHNldEV2YWx1YXRlZChnZW4sIHByb3BzLCBwcyk7XG4gICAgcmV0dXJuIHByb3BzO1xufVxuZXhwb3J0cy5ldmFsdWF0ZWRQcm9wc1RvTmFtZSA9IGV2YWx1YXRlZFByb3BzVG9OYW1lO1xuZnVuY3Rpb24gc2V0RXZhbHVhdGVkKGdlbiwgcHJvcHMsIHBzKSB7XG4gICAgT2JqZWN0LmtleXMocHMpLmZvckVhY2goKHApID0+IGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtwcm9wc30keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKHApfWAsIHRydWUpKTtcbn1cbmV4cG9ydHMuc2V0RXZhbHVhdGVkID0gc2V0RXZhbHVhdGVkO1xuY29uc3Qgc25pcHBldHMgPSB7fTtcbmZ1bmN0aW9uIHVzZUZ1bmMoZ2VuLCBmKSB7XG4gICAgcmV0dXJuIGdlbi5zY29wZVZhbHVlKFwiZnVuY1wiLCB7XG4gICAgICAgIHJlZjogZixcbiAgICAgICAgY29kZTogc25pcHBldHNbZi5jb2RlXSB8fCAoc25pcHBldHNbZi5jb2RlXSA9IG5ldyBjb2RlXzEuX0NvZGUoZi5jb2RlKSksXG4gICAgfSk7XG59XG5leHBvcnRzLnVzZUZ1bmMgPSB1c2VGdW5jO1xudmFyIFR5cGU7XG4oZnVuY3Rpb24gKFR5cGUpIHtcbiAgICBUeXBlW1R5cGVbXCJOdW1cIl0gPSAwXSA9IFwiTnVtXCI7XG4gICAgVHlwZVtUeXBlW1wiU3RyXCJdID0gMV0gPSBcIlN0clwiO1xufSkoVHlwZSA9IGV4cG9ydHMuVHlwZSB8fCAoZXhwb3J0cy5UeXBlID0ge30pKTtcbmZ1bmN0aW9uIGdldEVycm9yUGF0aChkYXRhUHJvcCwgZGF0YVByb3BUeXBlLCBqc1Byb3BlcnR5U3ludGF4KSB7XG4gICAgLy8gbGV0IHBhdGhcbiAgICBpZiAoZGF0YVByb3AgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSkge1xuICAgICAgICBjb25zdCBpc051bWJlciA9IGRhdGFQcm9wVHlwZSA9PT0gVHlwZS5OdW07XG4gICAgICAgIHJldHVybiBqc1Byb3BlcnR5U3ludGF4XG4gICAgICAgICAgICA/IGlzTnVtYmVyXG4gICAgICAgICAgICAgICAgPyAoMCwgY29kZWdlbl8xLl8pIGBcIltcIiArICR7ZGF0YVByb3B9ICsgXCJdXCJgXG4gICAgICAgICAgICAgICAgOiAoMCwgY29kZWdlbl8xLl8pIGBcIlsnXCIgKyAke2RhdGFQcm9wfSArIFwiJ11cImBcbiAgICAgICAgICAgIDogaXNOdW1iZXJcbiAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYFwiL1wiICsgJHtkYXRhUHJvcH1gXG4gICAgICAgICAgICAgICAgOiAoMCwgY29kZWdlbl8xLl8pIGBcIi9cIiArICR7ZGF0YVByb3B9LnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXFxcLy9nLCBcIn4xXCIpYDsgLy8gVE9ETyBtYXliZSB1c2UgZ2xvYmFsIGVzY2FwZVBvaW50ZXJcbiAgICB9XG4gICAgcmV0dXJuIGpzUHJvcGVydHlTeW50YXggPyAoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShkYXRhUHJvcCkudG9TdHJpbmcoKSA6IFwiL1wiICsgZXNjYXBlSnNvblBvaW50ZXIoZGF0YVByb3ApO1xufVxuZXhwb3J0cy5nZXRFcnJvclBhdGggPSBnZXRFcnJvclBhdGg7XG5mdW5jdGlvbiBjaGVja1N0cmljdE1vZGUoaXQsIG1zZywgbW9kZSA9IGl0Lm9wdHMuc3RyaWN0U2NoZW1hKSB7XG4gICAgaWYgKCFtb2RlKVxuICAgICAgICByZXR1cm47XG4gICAgbXNnID0gYHN0cmljdCBtb2RlOiAke21zZ31gO1xuICAgIGlmIChtb2RlID09PSB0cnVlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICBpdC5zZWxmLmxvZ2dlci53YXJuKG1zZyk7XG59XG5leHBvcnRzLmNoZWNrU3RyaWN0TW9kZSA9IGNoZWNrU3RyaWN0TW9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXMgPSB7XG4gICAgLy8gdmFsaWRhdGlvbiBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICBkYXRhOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJkYXRhXCIpLFxuICAgIC8vIGFyZ3MgcGFzc2VkIGZyb20gcmVmZXJlbmNpbmcgc2NoZW1hXG4gICAgdmFsQ3h0OiBuZXcgY29kZWdlbl8xLk5hbWUoXCJ2YWxDeHRcIiksXG4gICAgaW5zdGFuY2VQYXRoOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJpbnN0YW5jZVBhdGhcIiksXG4gICAgcGFyZW50RGF0YTogbmV3IGNvZGVnZW5fMS5OYW1lKFwicGFyZW50RGF0YVwiKSxcbiAgICBwYXJlbnREYXRhUHJvcGVydHk6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmVudERhdGFQcm9wZXJ0eVwiKSxcbiAgICByb290RGF0YTogbmV3IGNvZGVnZW5fMS5OYW1lKFwicm9vdERhdGFcIiksXG4gICAgZHluYW1pY0FuY2hvcnM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImR5bmFtaWNBbmNob3JzXCIpLFxuICAgIC8vIGZ1bmN0aW9uIHNjb3BlZCB2YXJpYWJsZXNcbiAgICB2RXJyb3JzOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJ2RXJyb3JzXCIpLFxuICAgIGVycm9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwiZXJyb3JzXCIpLFxuICAgIHRoaXM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInRoaXNcIiksXG4gICAgLy8gXCJnbG9iYWxzXCJcbiAgICBzZWxmOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJzZWxmXCIpLFxuICAgIHNjb3BlOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJzY29wZVwiKSxcbiAgICAvLyBKVEQgc2VyaWFsaXplL3BhcnNlIG5hbWUgZm9yIEpTT04gc3RyaW5nIGFuZCBwb3NpdGlvblxuICAgIGpzb246IG5ldyBjb2RlZ2VuXzEuTmFtZShcImpzb25cIiksXG4gICAganNvblBvczogbmV3IGNvZGVnZW5fMS5OYW1lKFwianNvblBvc1wiKSxcbiAgICBqc29uTGVuOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJqc29uTGVuXCIpLFxuICAgIGpzb25QYXJ0OiBuZXcgY29kZWdlbl8xLk5hbWUoXCJqc29uUGFydFwiKSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBuYW1lcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hbWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHRlbmRFcnJvcnMgPSBleHBvcnRzLnJlc2V0RXJyb3JzQ291bnQgPSBleHBvcnRzLnJlcG9ydEV4dHJhRXJyb3IgPSBleHBvcnRzLnJlcG9ydEVycm9yID0gZXhwb3J0cy5rZXl3b3JkJERhdGFFcnJvciA9IGV4cG9ydHMua2V5d29yZEVycm9yID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4vY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4vbmFtZXNcIik7XG5leHBvcnRzLmtleXdvcmRFcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBrZXl3b3JkIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBwYXNzIFwiJHtrZXl3b3JkfVwiIGtleXdvcmQgdmFsaWRhdGlvbmAsXG59O1xuZXhwb3J0cy5rZXl3b3JkJERhdGFFcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBrZXl3b3JkLCBzY2hlbWFUeXBlIH0pID0+IHNjaGVtYVR5cGVcbiAgICAgICAgPyAoMCwgY29kZWdlbl8xLnN0cikgYFwiJHtrZXl3b3JkfVwiIGtleXdvcmQgbXVzdCBiZSAke3NjaGVtYVR5cGV9ICgkZGF0YSlgXG4gICAgICAgIDogKDAsIGNvZGVnZW5fMS5zdHIpIGBcIiR7a2V5d29yZH1cIiBrZXl3b3JkIGlzIGludmFsaWQgKCRkYXRhKWAsXG59O1xuZnVuY3Rpb24gcmVwb3J0RXJyb3IoY3h0LCBlcnJvciA9IGV4cG9ydHMua2V5d29yZEVycm9yLCBlcnJvclBhdGhzLCBvdmVycmlkZUFsbEVycm9ycykge1xuICAgIGNvbnN0IHsgaXQgfSA9IGN4dDtcbiAgICBjb25zdCB7IGdlbiwgY29tcG9zaXRlUnVsZSwgYWxsRXJyb3JzIH0gPSBpdDtcbiAgICBjb25zdCBlcnJPYmogPSBlcnJvck9iamVjdENvZGUoY3h0LCBlcnJvciwgZXJyb3JQYXRocyk7XG4gICAgaWYgKG92ZXJyaWRlQWxsRXJyb3JzICE9PSBudWxsICYmIG92ZXJyaWRlQWxsRXJyb3JzICE9PSB2b2lkIDAgPyBvdmVycmlkZUFsbEVycm9ycyA6IChjb21wb3NpdGVSdWxlIHx8IGFsbEVycm9ycykpIHtcbiAgICAgICAgYWRkRXJyb3IoZ2VuLCBlcnJPYmopO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuRXJyb3JzKGl0LCAoMCwgY29kZWdlbl8xLl8pIGBbJHtlcnJPYmp9XWApO1xuICAgIH1cbn1cbmV4cG9ydHMucmVwb3J0RXJyb3IgPSByZXBvcnRFcnJvcjtcbmZ1bmN0aW9uIHJlcG9ydEV4dHJhRXJyb3IoY3h0LCBlcnJvciA9IGV4cG9ydHMua2V5d29yZEVycm9yLCBlcnJvclBhdGhzKSB7XG4gICAgY29uc3QgeyBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHsgZ2VuLCBjb21wb3NpdGVSdWxlLCBhbGxFcnJvcnMgfSA9IGl0O1xuICAgIGNvbnN0IGVyck9iaiA9IGVycm9yT2JqZWN0Q29kZShjeHQsIGVycm9yLCBlcnJvclBhdGhzKTtcbiAgICBhZGRFcnJvcihnZW4sIGVyck9iaik7XG4gICAgaWYgKCEoY29tcG9zaXRlUnVsZSB8fCBhbGxFcnJvcnMpKSB7XG4gICAgICAgIHJldHVybkVycm9ycyhpdCwgbmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMpO1xuICAgIH1cbn1cbmV4cG9ydHMucmVwb3J0RXh0cmFFcnJvciA9IHJlcG9ydEV4dHJhRXJyb3I7XG5mdW5jdGlvbiByZXNldEVycm9yc0NvdW50KGdlbiwgZXJyc0NvdW50KSB7XG4gICAgZ2VuLmFzc2lnbihuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCBlcnJzQ291bnQpO1xuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfSAhPT0gbnVsbGAsICgpID0+IGdlbi5pZihlcnJzQ291bnQsICgpID0+IGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30ubGVuZ3RoYCwgZXJyc0NvdW50KSwgKCkgPT4gZ2VuLmFzc2lnbihuYW1lc18xLmRlZmF1bHQudkVycm9ycywgbnVsbCkpKTtcbn1cbmV4cG9ydHMucmVzZXRFcnJvcnNDb3VudCA9IHJlc2V0RXJyb3JzQ291bnQ7XG5mdW5jdGlvbiBleHRlbmRFcnJvcnMoeyBnZW4sIGtleXdvcmQsIHNjaGVtYVZhbHVlLCBkYXRhLCBlcnJzQ291bnQsIGl0LCB9KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGVycnNDb3VudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgY29uc3QgZXJyID0gZ2VuLm5hbWUoXCJlcnJcIik7XG4gICAgZ2VuLmZvclJhbmdlKFwiaVwiLCBlcnJzQ291bnQsIG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsIChpKSA9PiB7XG4gICAgICAgIGdlbi5jb25zdChlcnIsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9WyR7aX1dYCk7XG4gICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2Vycn0uaW5zdGFuY2VQYXRoID09PSB1bmRlZmluZWRgLCAoKSA9PiBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5pbnN0YW5jZVBhdGhgLCAoMCwgY29kZWdlbl8xLnN0ckNvbmNhdCkobmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgaXQuZXJyb3JQYXRoKSkpO1xuICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5zY2hlbWFQYXRoYCwgKDAsIGNvZGVnZW5fMS5zdHIpIGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gKTtcbiAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke2Vycn0uc2NoZW1hYCwgc2NoZW1hVmFsdWUpO1xuICAgICAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke2Vycn0uZGF0YWAsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLmV4dGVuZEVycm9ycyA9IGV4dGVuZEVycm9ycztcbmZ1bmN0aW9uIGFkZEVycm9yKGdlbiwgZXJyT2JqKSB7XG4gICAgY29uc3QgZXJyID0gZ2VuLmNvbnN0KFwiZXJyXCIsIGVyck9iaik7XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9ID09PSBudWxsYCwgKCkgPT4gZ2VuLmFzc2lnbihuYW1lc18xLmRlZmF1bHQudkVycm9ycywgKDAsIGNvZGVnZW5fMS5fKSBgWyR7ZXJyfV1gKSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30ucHVzaCgke2Vycn0pYCk7XG4gICAgZ2VuLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfSsrYCk7XG59XG5mdW5jdGlvbiByZXR1cm5FcnJvcnMoaXQsIGVycnMpIHtcbiAgICBjb25zdCB7IGdlbiwgdmFsaWRhdGVOYW1lLCBzY2hlbWFFbnYgfSA9IGl0O1xuICAgIGlmIChzY2hlbWFFbnYuJGFzeW5jKSB7XG4gICAgICAgIGdlbi50aHJvdygoMCwgY29kZWdlbl8xLl8pIGBuZXcgJHtpdC5WYWxpZGF0aW9uRXJyb3J9KCR7ZXJyc30pYCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7dmFsaWRhdGVOYW1lfS5lcnJvcnNgLCBlcnJzKTtcbiAgICAgICAgZ2VuLnJldHVybihmYWxzZSk7XG4gICAgfVxufVxuY29uc3QgRSA9IHtcbiAgICBrZXl3b3JkOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJrZXl3b3JkXCIpLFxuICAgIHNjaGVtYVBhdGg6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNjaGVtYVBhdGhcIiksXG4gICAgcGFyYW1zOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwYXJhbXNcIiksXG4gICAgcHJvcGVydHlOYW1lOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwcm9wZXJ0eU5hbWVcIiksXG4gICAgbWVzc2FnZTogbmV3IGNvZGVnZW5fMS5OYW1lKFwibWVzc2FnZVwiKSxcbiAgICBzY2hlbWE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNjaGVtYVwiKSxcbiAgICBwYXJlbnRTY2hlbWE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmVudFNjaGVtYVwiKSxcbn07XG5mdW5jdGlvbiBlcnJvck9iamVjdENvZGUoY3h0LCBlcnJvciwgZXJyb3JQYXRocykge1xuICAgIGNvbnN0IHsgY3JlYXRlRXJyb3JzIH0gPSBjeHQuaXQ7XG4gICAgaWYgKGNyZWF0ZUVycm9ycyA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGB7fWA7XG4gICAgcmV0dXJuIGVycm9yT2JqZWN0KGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpO1xufVxuZnVuY3Rpb24gZXJyb3JPYmplY3QoY3h0LCBlcnJvciwgZXJyb3JQYXRocyA9IHt9KSB7XG4gICAgY29uc3QgeyBnZW4sIGl0IH0gPSBjeHQ7XG4gICAgY29uc3Qga2V5VmFsdWVzID0gW1xuICAgICAgICBlcnJvckluc3RhbmNlUGF0aChpdCwgZXJyb3JQYXRocyksXG4gICAgICAgIGVycm9yU2NoZW1hUGF0aChjeHQsIGVycm9yUGF0aHMpLFxuICAgIF07XG4gICAgZXh0cmFFcnJvclByb3BzKGN4dCwgZXJyb3IsIGtleVZhbHVlcyk7XG4gICAgcmV0dXJuIGdlbi5vYmplY3QoLi4ua2V5VmFsdWVzKTtcbn1cbmZ1bmN0aW9uIGVycm9ySW5zdGFuY2VQYXRoKHsgZXJyb3JQYXRoIH0sIHsgaW5zdGFuY2VQYXRoIH0pIHtcbiAgICBjb25zdCBpbnN0UGF0aCA9IGluc3RhbmNlUGF0aFxuICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuc3RyKSBgJHtlcnJvclBhdGh9JHsoMCwgdXRpbF8xLmdldEVycm9yUGF0aCkoaW5zdGFuY2VQYXRoLCB1dGlsXzEuVHlwZS5TdHIpfWBcbiAgICAgICAgOiBlcnJvclBhdGg7XG4gICAgcmV0dXJuIFtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCAoMCwgY29kZWdlbl8xLnN0ckNvbmNhdCkobmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgaW5zdFBhdGgpXTtcbn1cbmZ1bmN0aW9uIGVycm9yU2NoZW1hUGF0aCh7IGtleXdvcmQsIGl0OiB7IGVyclNjaGVtYVBhdGggfSB9LCB7IHNjaGVtYVBhdGgsIHBhcmVudFNjaGVtYSB9KSB7XG4gICAgbGV0IHNjaFBhdGggPSBwYXJlbnRTY2hlbWEgPyBlcnJTY2hlbWFQYXRoIDogKDAsIGNvZGVnZW5fMS5zdHIpIGAke2VyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gO1xuICAgIGlmIChzY2hlbWFQYXRoKSB7XG4gICAgICAgIHNjaFBhdGggPSAoMCwgY29kZWdlbl8xLnN0cikgYCR7c2NoUGF0aH0keygwLCB1dGlsXzEuZ2V0RXJyb3JQYXRoKShzY2hlbWFQYXRoLCB1dGlsXzEuVHlwZS5TdHIpfWA7XG4gICAgfVxuICAgIHJldHVybiBbRS5zY2hlbWFQYXRoLCBzY2hQYXRoXTtcbn1cbmZ1bmN0aW9uIGV4dHJhRXJyb3JQcm9wcyhjeHQsIHsgcGFyYW1zLCBtZXNzYWdlIH0sIGtleVZhbHVlcykge1xuICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hVmFsdWUsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgeyBvcHRzLCBwcm9wZXJ0eU5hbWUsIHRvcFNjaGVtYVJlZiwgc2NoZW1hUGF0aCB9ID0gaXQ7XG4gICAga2V5VmFsdWVzLnB1c2goW0Uua2V5d29yZCwga2V5d29yZF0sIFtFLnBhcmFtcywgdHlwZW9mIHBhcmFtcyA9PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMoY3h0KSA6IHBhcmFtcyB8fCAoMCwgY29kZWdlbl8xLl8pIGB7fWBdKTtcbiAgICBpZiAob3B0cy5tZXNzYWdlcykge1xuICAgICAgICBrZXlWYWx1ZXMucHVzaChbRS5tZXNzYWdlLCB0eXBlb2YgbWVzc2FnZSA9PSBcImZ1bmN0aW9uXCIgPyBtZXNzYWdlKGN4dCkgOiBtZXNzYWdlXSk7XG4gICAgfVxuICAgIGlmIChvcHRzLnZlcmJvc2UpIHtcbiAgICAgICAga2V5VmFsdWVzLnB1c2goW0Uuc2NoZW1hLCBzY2hlbWFWYWx1ZV0sIFtFLnBhcmVudFNjaGVtYSwgKDAsIGNvZGVnZW5fMS5fKSBgJHt0b3BTY2hlbWFSZWZ9JHtzY2hlbWFQYXRofWBdLCBbbmFtZXNfMS5kZWZhdWx0LmRhdGEsIGRhdGFdKTtcbiAgICB9XG4gICAgaWYgKHByb3BlcnR5TmFtZSlcbiAgICAgICAga2V5VmFsdWVzLnB1c2goW0UucHJvcGVydHlOYW1lLCBwcm9wZXJ0eU5hbWVdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYm9vbE9yRW1wdHlTY2hlbWEgPSBleHBvcnRzLnRvcEJvb2xPckVtcHR5U2NoZW1hID0gdm9pZCAwO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uL25hbWVzXCIpO1xuY29uc3QgYm9vbEVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwiYm9vbGVhbiBzY2hlbWEgaXMgZmFsc2VcIixcbn07XG5mdW5jdGlvbiB0b3BCb29sT3JFbXB0eVNjaGVtYShpdCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHZhbGlkYXRlTmFtZSB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZmFsc2VTY2hlbWFFcnJvcihpdCwgZmFsc2UpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgc2NoZW1hLiRhc3luYyA9PT0gdHJ1ZSkge1xuICAgICAgICBnZW4ucmV0dXJuKG5hbWVzXzEuZGVmYXVsdC5kYXRhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIG51bGwpO1xuICAgICAgICBnZW4ucmV0dXJuKHRydWUpO1xuICAgIH1cbn1cbmV4cG9ydHMudG9wQm9vbE9yRW1wdHlTY2hlbWEgPSB0b3BCb29sT3JFbXB0eVNjaGVtYTtcbmZ1bmN0aW9uIGJvb2xPckVtcHR5U2NoZW1hKGl0LCB2YWxpZCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEgfSA9IGl0O1xuICAgIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgIGdlbi52YXIodmFsaWQsIGZhbHNlKTsgLy8gVE9ETyB2YXJcbiAgICAgICAgZmFsc2VTY2hlbWFFcnJvcihpdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW4udmFyKHZhbGlkLCB0cnVlKTsgLy8gVE9ETyB2YXJcbiAgICB9XG59XG5leHBvcnRzLmJvb2xPckVtcHR5U2NoZW1hID0gYm9vbE9yRW1wdHlTY2hlbWE7XG5mdW5jdGlvbiBmYWxzZVNjaGVtYUVycm9yKGl0LCBvdmVycmlkZUFsbEVycm9ycykge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhIH0gPSBpdDtcbiAgICAvLyBUT0RPIG1heWJlIHNvbWUgb3RoZXIgaW50ZXJmYWNlIHNob3VsZCBiZSB1c2VkIGZvciBub24ta2V5d29yZCB2YWxpZGF0aW9uIGVycm9ycy4uLlxuICAgIGNvbnN0IGN4dCA9IHtcbiAgICAgICAgZ2VuLFxuICAgICAgICBrZXl3b3JkOiBcImZhbHNlIHNjaGVtYVwiLFxuICAgICAgICBkYXRhLFxuICAgICAgICBzY2hlbWE6IGZhbHNlLFxuICAgICAgICBzY2hlbWFDb2RlOiBmYWxzZSxcbiAgICAgICAgc2NoZW1hVmFsdWU6IGZhbHNlLFxuICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICBpdCxcbiAgICB9O1xuICAgICgwLCBlcnJvcnNfMS5yZXBvcnRFcnJvcikoY3h0LCBib29sRXJyb3IsIHVuZGVmaW5lZCwgb3ZlcnJpZGVBbGxFcnJvcnMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9vbFNjaGVtYS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0UnVsZXMgPSBleHBvcnRzLmlzSlNPTlR5cGUgPSB2b2lkIDA7XG5jb25zdCBfanNvblR5cGVzID0gW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiaW50ZWdlclwiLCBcImJvb2xlYW5cIiwgXCJudWxsXCIsIFwib2JqZWN0XCIsIFwiYXJyYXlcIl07XG5jb25zdCBqc29uVHlwZXMgPSBuZXcgU2V0KF9qc29uVHlwZXMpO1xuZnVuY3Rpb24gaXNKU09OVHlwZSh4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09IFwic3RyaW5nXCIgJiYganNvblR5cGVzLmhhcyh4KTtcbn1cbmV4cG9ydHMuaXNKU09OVHlwZSA9IGlzSlNPTlR5cGU7XG5mdW5jdGlvbiBnZXRSdWxlcygpIHtcbiAgICBjb25zdCBncm91cHMgPSB7XG4gICAgICAgIG51bWJlcjogeyB0eXBlOiBcIm51bWJlclwiLCBydWxlczogW10gfSxcbiAgICAgICAgc3RyaW5nOiB7IHR5cGU6IFwic3RyaW5nXCIsIHJ1bGVzOiBbXSB9LFxuICAgICAgICBhcnJheTogeyB0eXBlOiBcImFycmF5XCIsIHJ1bGVzOiBbXSB9LFxuICAgICAgICBvYmplY3Q6IHsgdHlwZTogXCJvYmplY3RcIiwgcnVsZXM6IFtdIH0sXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlczogeyAuLi5ncm91cHMsIGludGVnZXI6IHRydWUsIGJvb2xlYW46IHRydWUsIG51bGw6IHRydWUgfSxcbiAgICAgICAgcnVsZXM6IFt7IHJ1bGVzOiBbXSB9LCBncm91cHMubnVtYmVyLCBncm91cHMuc3RyaW5nLCBncm91cHMuYXJyYXksIGdyb3Vwcy5vYmplY3RdLFxuICAgICAgICBwb3N0OiB7IHJ1bGVzOiBbXSB9LFxuICAgICAgICBhbGw6IHt9LFxuICAgICAgICBrZXl3b3Jkczoge30sXG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0UnVsZXMgPSBnZXRSdWxlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ1bGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaG91bGRVc2VSdWxlID0gZXhwb3J0cy5zaG91bGRVc2VHcm91cCA9IGV4cG9ydHMuc2NoZW1hSGFzUnVsZXNGb3JUeXBlID0gdm9pZCAwO1xuZnVuY3Rpb24gc2NoZW1hSGFzUnVsZXNGb3JUeXBlKHsgc2NoZW1hLCBzZWxmIH0sIHR5cGUpIHtcbiAgICBjb25zdCBncm91cCA9IHNlbGYuUlVMRVMudHlwZXNbdHlwZV07XG4gICAgcmV0dXJuIGdyb3VwICYmIGdyb3VwICE9PSB0cnVlICYmIHNob3VsZFVzZUdyb3VwKHNjaGVtYSwgZ3JvdXApO1xufVxuZXhwb3J0cy5zY2hlbWFIYXNSdWxlc0ZvclR5cGUgPSBzY2hlbWFIYXNSdWxlc0ZvclR5cGU7XG5mdW5jdGlvbiBzaG91bGRVc2VHcm91cChzY2hlbWEsIGdyb3VwKSB7XG4gICAgcmV0dXJuIGdyb3VwLnJ1bGVzLnNvbWUoKHJ1bGUpID0+IHNob3VsZFVzZVJ1bGUoc2NoZW1hLCBydWxlKSk7XG59XG5leHBvcnRzLnNob3VsZFVzZUdyb3VwID0gc2hvdWxkVXNlR3JvdXA7XG5mdW5jdGlvbiBzaG91bGRVc2VSdWxlKHNjaGVtYSwgcnVsZSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKHNjaGVtYVtydWxlLmtleXdvcmRdICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgKChfYSA9IHJ1bGUuZGVmaW5pdGlvbi5pbXBsZW1lbnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZSgoa3dkKSA9PiBzY2hlbWFba3dkXSAhPT0gdW5kZWZpbmVkKSkpO1xufVxuZXhwb3J0cy5zaG91bGRVc2VSdWxlID0gc2hvdWxkVXNlUnVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcGxpY2FiaWxpdHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlcG9ydFR5cGVFcnJvciA9IGV4cG9ydHMuY2hlY2tEYXRhVHlwZXMgPSBleHBvcnRzLmNoZWNrRGF0YVR5cGUgPSBleHBvcnRzLmNvZXJjZUFuZENoZWNrRGF0YVR5cGUgPSBleHBvcnRzLmdldEpTT05UeXBlcyA9IGV4cG9ydHMuZ2V0U2NoZW1hVHlwZXMgPSBleHBvcnRzLkRhdGFUeXBlID0gdm9pZCAwO1xuY29uc3QgcnVsZXNfMSA9IHJlcXVpcmUoXCIuLi9ydWxlc1wiKTtcbmNvbnN0IGFwcGxpY2FiaWxpdHlfMSA9IHJlcXVpcmUoXCIuL2FwcGxpY2FiaWxpdHlcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIERhdGFUeXBlO1xuKGZ1bmN0aW9uIChEYXRhVHlwZSkge1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wiQ29ycmVjdFwiXSA9IDBdID0gXCJDb3JyZWN0XCI7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJXcm9uZ1wiXSA9IDFdID0gXCJXcm9uZ1wiO1xufSkoRGF0YVR5cGUgPSBleHBvcnRzLkRhdGFUeXBlIHx8IChleHBvcnRzLkRhdGFUeXBlID0ge30pKTtcbmZ1bmN0aW9uIGdldFNjaGVtYVR5cGVzKHNjaGVtYSkge1xuICAgIGNvbnN0IHR5cGVzID0gZ2V0SlNPTlR5cGVzKHNjaGVtYS50eXBlKTtcbiAgICBjb25zdCBoYXNOdWxsID0gdHlwZXMuaW5jbHVkZXMoXCJudWxsXCIpO1xuICAgIGlmIChoYXNOdWxsKSB7XG4gICAgICAgIGlmIChzY2hlbWEubnVsbGFibGUgPT09IGZhbHNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZTogbnVsbCBjb250cmFkaWN0cyBudWxsYWJsZTogZmFsc2VcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIXR5cGVzLmxlbmd0aCAmJiBzY2hlbWEubnVsbGFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm51bGxhYmxlXCIgY2Fubm90IGJlIHVzZWQgd2l0aG91dCBcInR5cGVcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEubnVsbGFibGUgPT09IHRydWUpXG4gICAgICAgICAgICB0eXBlcy5wdXNoKFwibnVsbFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVzO1xufVxuZXhwb3J0cy5nZXRTY2hlbWFUeXBlcyA9IGdldFNjaGVtYVR5cGVzO1xuZnVuY3Rpb24gZ2V0SlNPTlR5cGVzKHRzKSB7XG4gICAgY29uc3QgdHlwZXMgPSBBcnJheS5pc0FycmF5KHRzKSA/IHRzIDogdHMgPyBbdHNdIDogW107XG4gICAgaWYgKHR5cGVzLmV2ZXJ5KHJ1bGVzXzEuaXNKU09OVHlwZSkpXG4gICAgICAgIHJldHVybiB0eXBlcztcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0eXBlIG11c3QgYmUgSlNPTlR5cGUgb3IgSlNPTlR5cGVbXTogXCIgKyB0eXBlcy5qb2luKFwiLFwiKSk7XG59XG5leHBvcnRzLmdldEpTT05UeXBlcyA9IGdldEpTT05UeXBlcztcbmZ1bmN0aW9uIGNvZXJjZUFuZENoZWNrRGF0YVR5cGUoaXQsIHR5cGVzKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIG9wdHMgfSA9IGl0O1xuICAgIGNvbnN0IGNvZXJjZVRvID0gY29lcmNlVG9UeXBlcyh0eXBlcywgb3B0cy5jb2VyY2VUeXBlcyk7XG4gICAgY29uc3QgY2hlY2tUeXBlcyA9IHR5cGVzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgIShjb2VyY2VUby5sZW5ndGggPT09IDAgJiYgdHlwZXMubGVuZ3RoID09PSAxICYmICgwLCBhcHBsaWNhYmlsaXR5XzEuc2NoZW1hSGFzUnVsZXNGb3JUeXBlKShpdCwgdHlwZXNbMF0pKTtcbiAgICBpZiAoY2hlY2tUeXBlcykge1xuICAgICAgICBjb25zdCB3cm9uZ1R5cGUgPSBjaGVja0RhdGFUeXBlcyh0eXBlcywgZGF0YSwgb3B0cy5zdHJpY3ROdW1iZXJzLCBEYXRhVHlwZS5Xcm9uZyk7XG4gICAgICAgIGdlbi5pZih3cm9uZ1R5cGUsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChjb2VyY2VUby5sZW5ndGgpXG4gICAgICAgICAgICAgICAgY29lcmNlRGF0YShpdCwgdHlwZXMsIGNvZXJjZVRvKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXBvcnRUeXBlRXJyb3IoaXQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNoZWNrVHlwZXM7XG59XG5leHBvcnRzLmNvZXJjZUFuZENoZWNrRGF0YVR5cGUgPSBjb2VyY2VBbmRDaGVja0RhdGFUeXBlO1xuY29uc3QgQ09FUkNJQkxFID0gbmV3IFNldChbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJpbnRlZ2VyXCIsIFwiYm9vbGVhblwiLCBcIm51bGxcIl0pO1xuZnVuY3Rpb24gY29lcmNlVG9UeXBlcyh0eXBlcywgY29lcmNlVHlwZXMpIHtcbiAgICByZXR1cm4gY29lcmNlVHlwZXNcbiAgICAgICAgPyB0eXBlcy5maWx0ZXIoKHQpID0+IENPRVJDSUJMRS5oYXModCkgfHwgKGNvZXJjZVR5cGVzID09PSBcImFycmF5XCIgJiYgdCA9PT0gXCJhcnJheVwiKSlcbiAgICAgICAgOiBbXTtcbn1cbmZ1bmN0aW9uIGNvZXJjZURhdGEoaXQsIHR5cGVzLCBjb2VyY2VUbykge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBvcHRzIH0gPSBpdDtcbiAgICBjb25zdCBkYXRhVHlwZSA9IGdlbi5sZXQoXCJkYXRhVHlwZVwiLCAoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtkYXRhfWApO1xuICAgIGNvbnN0IGNvZXJjZWQgPSBnZW4ubGV0KFwiY29lcmNlZFwiLCAoMCwgY29kZWdlbl8xLl8pIGB1bmRlZmluZWRgKTtcbiAgICBpZiAob3B0cy5jb2VyY2VUeXBlcyA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGFUeXBlfSA9PSAnb2JqZWN0JyAmJiBBcnJheS5pc0FycmF5KCR7ZGF0YX0pICYmICR7ZGF0YX0ubGVuZ3RoID09IDFgLCAoKSA9PiBnZW5cbiAgICAgICAgICAgIC5hc3NpZ24oZGF0YSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfVswXWApXG4gICAgICAgICAgICAuYXNzaWduKGRhdGFUeXBlLCAoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtkYXRhfWApXG4gICAgICAgICAgICAuaWYoY2hlY2tEYXRhVHlwZXModHlwZXMsIGRhdGEsIG9wdHMuc3RyaWN0TnVtYmVycyksICgpID0+IGdlbi5hc3NpZ24oY29lcmNlZCwgZGF0YSkpKTtcbiAgICB9XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7Y29lcmNlZH0gIT09IHVuZGVmaW5lZGApO1xuICAgIGZvciAoY29uc3QgdCBvZiBjb2VyY2VUbykge1xuICAgICAgICBpZiAoQ09FUkNJQkxFLmhhcyh0KSB8fCAodCA9PT0gXCJhcnJheVwiICYmIG9wdHMuY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIikpIHtcbiAgICAgICAgICAgIGNvZXJjZVNwZWNpZmljVHlwZSh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZW4uZWxzZSgpO1xuICAgIHJlcG9ydFR5cGVFcnJvcihpdCk7XG4gICAgZ2VuLmVuZElmKCk7XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7Y29lcmNlZH0gIT09IHVuZGVmaW5lZGAsICgpID0+IHtcbiAgICAgICAgZ2VuLmFzc2lnbihkYXRhLCBjb2VyY2VkKTtcbiAgICAgICAgYXNzaWduUGFyZW50RGF0YShpdCwgY29lcmNlZCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gY29lcmNlU3BlY2lmaWNUeXBlKHQpIHtcbiAgICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhVHlwZX0gPT0gXCJudW1iZXJcIiB8fCAke2RhdGFUeXBlfSA9PSBcImJvb2xlYW5cImApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgKDAsIGNvZGVnZW5fMS5fKSBgXCJcIiArICR7ZGF0YX1gKVxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gPT09IG51bGxgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsICgwLCBjb2RlZ2VuXzEuXykgYFwiXCJgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhVHlwZX0gPT0gXCJib29sZWFuXCIgfHwgJHtkYXRhfSA9PT0gbnVsbFxuICAgICAgICAgICAgICB8fCAoJHtkYXRhVHlwZX0gPT0gXCJzdHJpbmdcIiAmJiAke2RhdGF9ICYmICR7ZGF0YX0gPT0gKyR7ZGF0YX0pYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCAoMCwgY29kZWdlbl8xLl8pIGArJHtkYXRhfWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJpbnRlZ2VyXCI6XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhVHlwZX0gPT09IFwiYm9vbGVhblwiIHx8ICR7ZGF0YX0gPT09IG51bGxcbiAgICAgICAgICAgICAgfHwgKCR7ZGF0YVR5cGV9ID09PSBcInN0cmluZ1wiICYmICR7ZGF0YX0gJiYgJHtkYXRhfSA9PSArJHtkYXRhfSAmJiAhKCR7ZGF0YX0gJSAxKSlgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsICgwLCBjb2RlZ2VuXzEuXykgYCske2RhdGF9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9ID09PSBcImZhbHNlXCIgfHwgJHtkYXRhfSA9PT0gMCB8fCAke2RhdGF9ID09PSBudWxsYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9ID09PSBcInRydWVcIiB8fCAke2RhdGF9ID09PSAxYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwibnVsbFwiOlxuICAgICAgICAgICAgICAgIGdlbi5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSA9PT0gXCJcIiB8fCAke2RhdGF9ID09PSAwIHx8ICR7ZGF0YX0gPT09IGZhbHNlYCk7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihjb2VyY2VkLCBudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGFUeXBlfSA9PT0gXCJzdHJpbmdcIiB8fCAke2RhdGFUeXBlfSA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgICB8fCAke2RhdGFUeXBlfSA9PT0gXCJib29sZWFuXCIgfHwgJHtkYXRhfSA9PT0gbnVsbGApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgKDAsIGNvZGVnZW5fMS5fKSBgWyR7ZGF0YX1dYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhc3NpZ25QYXJlbnREYXRhKHsgZ2VuLCBwYXJlbnREYXRhLCBwYXJlbnREYXRhUHJvcGVydHkgfSwgZXhwcikge1xuICAgIC8vIFRPRE8gdXNlIGdlbi5wcm9wZXJ0eVxuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke3BhcmVudERhdGF9ICE9PSB1bmRlZmluZWRgLCAoKSA9PiBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7cGFyZW50RGF0YX1bJHtwYXJlbnREYXRhUHJvcGVydHl9XWAsIGV4cHIpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrRGF0YVR5cGUoZGF0YVR5cGUsIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QgPSBEYXRhVHlwZS5Db3JyZWN0KSB7XG4gICAgY29uc3QgRVEgPSBjb3JyZWN0ID09PSBEYXRhVHlwZS5Db3JyZWN0ID8gY29kZWdlbl8xLm9wZXJhdG9ycy5FUSA6IGNvZGVnZW5fMS5vcGVyYXRvcnMuTkVRO1xuICAgIGxldCBjb25kO1xuICAgIHN3aXRjaCAoZGF0YVR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm51bGxcIjpcbiAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9ICR7RVF9IG51bGxgO1xuICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgIGNvbmQgPSAoMCwgY29kZWdlbl8xLl8pIGBBcnJheS5pc0FycmF5KCR7ZGF0YX0pYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICBjb25kID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSAmJiB0eXBlb2YgJHtkYXRhfSA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KCR7ZGF0YX0pYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW50ZWdlclwiOlxuICAgICAgICAgICAgY29uZCA9IG51bUNvbmQoKDAsIGNvZGVnZW5fMS5fKSBgISgke2RhdGF9ICUgMSkgJiYgIWlzTmFOKCR7ZGF0YX0pYCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgY29uZCA9IG51bUNvbmQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2RhdGF9ICR7RVF9ICR7ZGF0YVR5cGV9YDtcbiAgICB9XG4gICAgcmV0dXJuIGNvcnJlY3QgPT09IERhdGFUeXBlLkNvcnJlY3QgPyBjb25kIDogKDAsIGNvZGVnZW5fMS5ub3QpKGNvbmQpO1xuICAgIGZ1bmN0aW9uIG51bUNvbmQoX2NvbmQgPSBjb2RlZ2VuXzEubmlsKSB7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLmFuZCkoKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZGF0YX0gPT0gXCJudW1iZXJcImAsIF9jb25kLCBzdHJpY3ROdW1zID8gKDAsIGNvZGVnZW5fMS5fKSBgaXNGaW5pdGUoJHtkYXRhfSlgIDogY29kZWdlbl8xLm5pbCk7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja0RhdGFUeXBlID0gY2hlY2tEYXRhVHlwZTtcbmZ1bmN0aW9uIGNoZWNrRGF0YVR5cGVzKGRhdGFUeXBlcywgZGF0YSwgc3RyaWN0TnVtcywgY29ycmVjdCkge1xuICAgIGlmIChkYXRhVHlwZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBjaGVja0RhdGFUeXBlKGRhdGFUeXBlc1swXSwgZGF0YSwgc3RyaWN0TnVtcywgY29ycmVjdCk7XG4gICAgfVxuICAgIGxldCBjb25kO1xuICAgIGNvbnN0IHR5cGVzID0gKDAsIHV0aWxfMS50b0hhc2gpKGRhdGFUeXBlcyk7XG4gICAgaWYgKHR5cGVzLmFycmF5ICYmIHR5cGVzLm9iamVjdCkge1xuICAgICAgICBjb25zdCBub3RPYmogPSAoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtkYXRhfSAhPSBcIm9iamVjdFwiYDtcbiAgICAgICAgY29uZCA9IHR5cGVzLm51bGwgPyBub3RPYmogOiAoMCwgY29kZWdlbl8xLl8pIGAhJHtkYXRhfSB8fCAke25vdE9ian1gO1xuICAgICAgICBkZWxldGUgdHlwZXMubnVsbDtcbiAgICAgICAgZGVsZXRlIHR5cGVzLmFycmF5O1xuICAgICAgICBkZWxldGUgdHlwZXMub2JqZWN0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uZCA9IGNvZGVnZW5fMS5uaWw7XG4gICAgfVxuICAgIGlmICh0eXBlcy5udW1iZXIpXG4gICAgICAgIGRlbGV0ZSB0eXBlcy5pbnRlZ2VyO1xuICAgIGZvciAoY29uc3QgdCBpbiB0eXBlcylcbiAgICAgICAgY29uZCA9ICgwLCBjb2RlZ2VuXzEuYW5kKShjb25kLCBjaGVja0RhdGFUeXBlKHQsIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QpKTtcbiAgICByZXR1cm4gY29uZDtcbn1cbmV4cG9ydHMuY2hlY2tEYXRhVHlwZXMgPSBjaGVja0RhdGFUeXBlcztcbmNvbnN0IHR5cGVFcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBzY2hlbWEgfSkgPT4gYG11c3QgYmUgJHtzY2hlbWF9YCxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYSwgc2NoZW1hVmFsdWUgfSkgPT4gdHlwZW9mIHNjaGVtYSA9PSBcInN0cmluZ1wiID8gKDAsIGNvZGVnZW5fMS5fKSBge3R5cGU6ICR7c2NoZW1hfX1gIDogKDAsIGNvZGVnZW5fMS5fKSBge3R5cGU6ICR7c2NoZW1hVmFsdWV9fWAsXG59O1xuZnVuY3Rpb24gcmVwb3J0VHlwZUVycm9yKGl0KSB7XG4gICAgY29uc3QgY3h0ID0gZ2V0VHlwZUVycm9yQ29udGV4dChpdCk7XG4gICAgKDAsIGVycm9yc18xLnJlcG9ydEVycm9yKShjeHQsIHR5cGVFcnJvcik7XG59XG5leHBvcnRzLnJlcG9ydFR5cGVFcnJvciA9IHJlcG9ydFR5cGVFcnJvcjtcbmZ1bmN0aW9uIGdldFR5cGVFcnJvckNvbnRleHQoaXQpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgc2NoZW1hIH0gPSBpdDtcbiAgICBjb25zdCBzY2hlbWFDb2RlID0gKDAsIHV0aWxfMS5zY2hlbWFSZWZPclZhbCkoaXQsIHNjaGVtYSwgXCJ0eXBlXCIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGdlbixcbiAgICAgICAga2V5d29yZDogXCJ0eXBlXCIsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hLnR5cGUsXG4gICAgICAgIHNjaGVtYUNvZGUsXG4gICAgICAgIHNjaGVtYVZhbHVlOiBzY2hlbWFDb2RlLFxuICAgICAgICBwYXJlbnRTY2hlbWE6IHNjaGVtYSxcbiAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgaXQsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGFUeXBlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3NpZ25EZWZhdWx0cyA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5mdW5jdGlvbiBhc3NpZ25EZWZhdWx0cyhpdCwgdHkpIHtcbiAgICBjb25zdCB7IHByb3BlcnRpZXMsIGl0ZW1zIH0gPSBpdC5zY2hlbWE7XG4gICAgaWYgKHR5ID09PSBcIm9iamVjdFwiICYmIHByb3BlcnRpZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgYXNzaWduRGVmYXVsdChpdCwga2V5LCBwcm9wZXJ0aWVzW2tleV0uZGVmYXVsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHkgPT09IFwiYXJyYXlcIiAmJiBBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICBpdGVtcy5mb3JFYWNoKChzY2gsIGkpID0+IGFzc2lnbkRlZmF1bHQoaXQsIGksIHNjaC5kZWZhdWx0KSk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NpZ25EZWZhdWx0cyA9IGFzc2lnbkRlZmF1bHRzO1xuZnVuY3Rpb24gYXNzaWduRGVmYXVsdChpdCwgcHJvcCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgY29uc3QgeyBnZW4sIGNvbXBvc2l0ZVJ1bGUsIGRhdGEsIG9wdHMgfSA9IGl0O1xuICAgIGlmIChkZWZhdWx0VmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGNoaWxkRGF0YSA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKHByb3ApfWA7XG4gICAgaWYgKGNvbXBvc2l0ZVJ1bGUpIHtcbiAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBgZGVmYXVsdCBpcyBpZ25vcmVkIGZvcjogJHtjaGlsZERhdGF9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGNvbmRpdGlvbiA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7Y2hpbGREYXRhfSA9PT0gdW5kZWZpbmVkYDtcbiAgICBpZiAob3B0cy51c2VEZWZhdWx0cyA9PT0gXCJlbXB0eVwiKSB7XG4gICAgICAgIGNvbmRpdGlvbiA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7Y29uZGl0aW9ufSB8fCAke2NoaWxkRGF0YX0gPT09IG51bGwgfHwgJHtjaGlsZERhdGF9ID09PSBcIlwiYDtcbiAgICB9XG4gICAgLy8gYCR7Y2hpbGREYXRhfSA9PT0gdW5kZWZpbmVkYCArXG4gICAgLy8gKG9wdHMudXNlRGVmYXVsdHMgPT09IFwiZW1wdHlcIiA/IGAgfHwgJHtjaGlsZERhdGF9ID09PSBudWxsIHx8ICR7Y2hpbGREYXRhfSA9PT0gXCJcImAgOiBcIlwiKVxuICAgIGdlbi5pZihjb25kaXRpb24sICgwLCBjb2RlZ2VuXzEuXykgYCR7Y2hpbGREYXRhfSA9ICR7KDAsIGNvZGVnZW5fMS5zdHJpbmdpZnkpKGRlZmF1bHRWYWx1ZSl9YCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVVbmlvbiA9IGV4cG9ydHMudmFsaWRhdGVBcnJheSA9IGV4cG9ydHMudXNlUGF0dGVybiA9IGV4cG9ydHMuY2FsbFZhbGlkYXRlQ29kZSA9IGV4cG9ydHMuc2NoZW1hUHJvcGVydGllcyA9IGV4cG9ydHMuYWxsU2NoZW1hUHJvcGVydGllcyA9IGV4cG9ydHMubm9Qcm9wZXJ0eUluRGF0YSA9IGV4cG9ydHMucHJvcGVydHlJbkRhdGEgPSBleHBvcnRzLmlzT3duUHJvcGVydHkgPSBleHBvcnRzLmhhc1Byb3BGdW5jID0gZXhwb3J0cy5yZXBvcnRNaXNzaW5nUHJvcCA9IGV4cG9ydHMuY2hlY2tNaXNzaW5nUHJvcCA9IGV4cG9ydHMuY2hlY2tSZXBvcnRNaXNzaW5nUHJvcCA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21waWxlL25hbWVzXCIpO1xuY29uc3QgdXRpbF8yID0gcmVxdWlyZShcIi4uL2NvbXBpbGUvdXRpbFwiKTtcbmZ1bmN0aW9uIGNoZWNrUmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBwcm9wKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgZ2VuLmlmKG5vUHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpLCAoKSA9PiB7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBtaXNzaW5nUHJvcGVydHk6ICgwLCBjb2RlZ2VuXzEuXykgYCR7cHJvcH1gIH0sIHRydWUpO1xuICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY2hlY2tSZXBvcnRNaXNzaW5nUHJvcCA9IGNoZWNrUmVwb3J0TWlzc2luZ1Byb3A7XG5mdW5jdGlvbiBjaGVja01pc3NpbmdQcm9wKHsgZ2VuLCBkYXRhLCBpdDogeyBvcHRzIH0gfSwgcHJvcGVydGllcywgbWlzc2luZykge1xuICAgIHJldHVybiAoMCwgY29kZWdlbl8xLm9yKSguLi5wcm9wZXJ0aWVzLm1hcCgocHJvcCkgPT4gKDAsIGNvZGVnZW5fMS5hbmQpKG5vUHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBvcHRzLm93blByb3BlcnRpZXMpLCAoMCwgY29kZWdlbl8xLl8pIGAke21pc3Npbmd9ID0gJHtwcm9wfWApKSk7XG59XG5leHBvcnRzLmNoZWNrTWlzc2luZ1Byb3AgPSBjaGVja01pc3NpbmdQcm9wO1xuZnVuY3Rpb24gcmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBtaXNzaW5nKSB7XG4gICAgY3h0LnNldFBhcmFtcyh7IG1pc3NpbmdQcm9wZXJ0eTogbWlzc2luZyB9LCB0cnVlKTtcbiAgICBjeHQuZXJyb3IoKTtcbn1cbmV4cG9ydHMucmVwb3J0TWlzc2luZ1Byb3AgPSByZXBvcnRNaXNzaW5nUHJvcDtcbmZ1bmN0aW9uIGhhc1Byb3BGdW5jKGdlbikge1xuICAgIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcImZ1bmNcIiwge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICAgIHJlZjogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICAgY29kZTogKDAsIGNvZGVnZW5fMS5fKSBgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eWAsXG4gICAgfSk7XG59XG5leHBvcnRzLmhhc1Byb3BGdW5jID0gaGFzUHJvcEZ1bmM7XG5mdW5jdGlvbiBpc093blByb3BlcnR5KGdlbiwgZGF0YSwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgJHtoYXNQcm9wRnVuYyhnZW4pfS5jYWxsKCR7ZGF0YX0sICR7cHJvcGVydHl9KWA7XG59XG5leHBvcnRzLmlzT3duUHJvcGVydHkgPSBpc093blByb3BlcnR5O1xuZnVuY3Rpb24gcHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wZXJ0eSwgb3duUHJvcGVydGllcykge1xuICAgIGNvbnN0IGNvbmQgPSAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShwcm9wZXJ0eSl9ICE9PSB1bmRlZmluZWRgO1xuICAgIHJldHVybiBvd25Qcm9wZXJ0aWVzID8gKDAsIGNvZGVnZW5fMS5fKSBgJHtjb25kfSAmJiAke2lzT3duUHJvcGVydHkoZ2VuLCBkYXRhLCBwcm9wZXJ0eSl9YCA6IGNvbmQ7XG59XG5leHBvcnRzLnByb3BlcnR5SW5EYXRhID0gcHJvcGVydHlJbkRhdGE7XG5mdW5jdGlvbiBub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcGVydHksIG93blByb3BlcnRpZXMpIHtcbiAgICBjb25zdCBjb25kID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkocHJvcGVydHkpfSA9PT0gdW5kZWZpbmVkYDtcbiAgICByZXR1cm4gb3duUHJvcGVydGllcyA/ICgwLCBjb2RlZ2VuXzEub3IpKGNvbmQsICgwLCBjb2RlZ2VuXzEubm90KShpc093blByb3BlcnR5KGdlbiwgZGF0YSwgcHJvcGVydHkpKSkgOiBjb25kO1xufVxuZXhwb3J0cy5ub1Byb3BlcnR5SW5EYXRhID0gbm9Qcm9wZXJ0eUluRGF0YTtcbmZ1bmN0aW9uIGFsbFNjaGVtYVByb3BlcnRpZXMoc2NoZW1hTWFwKSB7XG4gICAgcmV0dXJuIHNjaGVtYU1hcCA/IE9iamVjdC5rZXlzKHNjaGVtYU1hcCkuZmlsdGVyKChwKSA9PiBwICE9PSBcIl9fcHJvdG9fX1wiKSA6IFtdO1xufVxuZXhwb3J0cy5hbGxTY2hlbWFQcm9wZXJ0aWVzID0gYWxsU2NoZW1hUHJvcGVydGllcztcbmZ1bmN0aW9uIHNjaGVtYVByb3BlcnRpZXMoaXQsIHNjaGVtYU1hcCkge1xuICAgIHJldHVybiBhbGxTY2hlbWFQcm9wZXJ0aWVzKHNjaGVtYU1hcCkuZmlsdGVyKChwKSA9PiAhKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYU1hcFtwXSkpO1xufVxuZXhwb3J0cy5zY2hlbWFQcm9wZXJ0aWVzID0gc2NoZW1hUHJvcGVydGllcztcbmZ1bmN0aW9uIGNhbGxWYWxpZGF0ZUNvZGUoeyBzY2hlbWFDb2RlLCBkYXRhLCBpdDogeyBnZW4sIHRvcFNjaGVtYVJlZiwgc2NoZW1hUGF0aCwgZXJyb3JQYXRoIH0sIGl0IH0sIGZ1bmMsIGNvbnRleHQsIHBhc3NTY2hlbWEpIHtcbiAgICBjb25zdCBkYXRhQW5kU2NoZW1hID0gcGFzc1NjaGVtYSA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7c2NoZW1hQ29kZX0sICR7ZGF0YX0sICR7dG9wU2NoZW1hUmVmfSR7c2NoZW1hUGF0aH1gIDogZGF0YTtcbiAgICBjb25zdCB2YWxDeHQgPSBbXG4gICAgICAgIFtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCAoMCwgY29kZWdlbl8xLnN0ckNvbmNhdCkobmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgZXJyb3JQYXRoKV0sXG4gICAgICAgIFtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YSwgaXQucGFyZW50RGF0YV0sXG4gICAgICAgIFtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5LCBpdC5wYXJlbnREYXRhUHJvcGVydHldLFxuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhLCBuYW1lc18xLmRlZmF1bHQucm9vdERhdGFdLFxuICAgIF07XG4gICAgaWYgKGl0Lm9wdHMuZHluYW1pY1JlZilcbiAgICAgICAgdmFsQ3h0LnB1c2goW25hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9ycywgbmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzXSk7XG4gICAgY29uc3QgYXJncyA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YUFuZFNjaGVtYX0sICR7Z2VuLm9iamVjdCguLi52YWxDeHQpfWA7XG4gICAgcmV0dXJuIGNvbnRleHQgIT09IGNvZGVnZW5fMS5uaWwgPyAoMCwgY29kZWdlbl8xLl8pIGAke2Z1bmN9LmNhbGwoJHtjb250ZXh0fSwgJHthcmdzfSlgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHtmdW5jfSgke2FyZ3N9KWA7XG59XG5leHBvcnRzLmNhbGxWYWxpZGF0ZUNvZGUgPSBjYWxsVmFsaWRhdGVDb2RlO1xuY29uc3QgbmV3UmVnRXhwID0gKDAsIGNvZGVnZW5fMS5fKSBgbmV3IFJlZ0V4cGA7XG5mdW5jdGlvbiB1c2VQYXR0ZXJuKHsgZ2VuLCBpdDogeyBvcHRzIH0gfSwgcGF0dGVybikge1xuICAgIGNvbnN0IHUgPSBvcHRzLnVuaWNvZGVSZWdFeHAgPyBcInVcIiA6IFwiXCI7XG4gICAgY29uc3QgeyByZWdFeHAgfSA9IG9wdHMuY29kZTtcbiAgICBjb25zdCByeCA9IHJlZ0V4cChwYXR0ZXJuLCB1KTtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJwYXR0ZXJuXCIsIHtcbiAgICAgICAga2V5OiByeC50b1N0cmluZygpLFxuICAgICAgICByZWY6IHJ4LFxuICAgICAgICBjb2RlOiAoMCwgY29kZWdlbl8xLl8pIGAke3JlZ0V4cC5jb2RlID09PSBcIm5ldyBSZWdFeHBcIiA/IG5ld1JlZ0V4cCA6ICgwLCB1dGlsXzIudXNlRnVuYykoZ2VuLCByZWdFeHApfSgke3BhdHRlcm59LCAke3V9KWAsXG4gICAgfSk7XG59XG5leHBvcnRzLnVzZVBhdHRlcm4gPSB1c2VQYXR0ZXJuO1xuZnVuY3Rpb24gdmFsaWRhdGVBcnJheShjeHQpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgICAgICBjb25zdCB2YWxpZEFyciA9IGdlbi5sZXQoXCJ2YWxpZFwiLCB0cnVlKTtcbiAgICAgICAgdmFsaWRhdGVJdGVtcygoKSA9PiBnZW4uYXNzaWduKHZhbGlkQXJyLCBmYWxzZSkpO1xuICAgICAgICByZXR1cm4gdmFsaWRBcnI7XG4gICAgfVxuICAgIGdlbi52YXIodmFsaWQsIHRydWUpO1xuICAgIHZhbGlkYXRlSXRlbXMoKCkgPT4gZ2VuLmJyZWFrKCkpO1xuICAgIHJldHVybiB2YWxpZDtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUl0ZW1zKG5vdFZhbGlkKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgICAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIDAsIGxlbiwgKGkpID0+IHtcbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgICAgICAgZGF0YVByb3A6IGksXG4gICAgICAgICAgICAgICAgZGF0YVByb3BUeXBlOiB1dGlsXzEuVHlwZS5OdW0sXG4gICAgICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgbm90VmFsaWQpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlQXJyYXkgPSB2YWxpZGF0ZUFycmF5O1xuZnVuY3Rpb24gdmFsaWRhdGVVbmlvbihjeHQpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgY29uc3QgYWx3YXlzVmFsaWQgPSBzY2hlbWEuc29tZSgoc2NoKSA9PiAoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoKSk7XG4gICAgaWYgKGFsd2F5c1ZhbGlkICYmICFpdC5vcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgZmFsc2UpO1xuICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIik7XG4gICAgZ2VuLmJsb2NrKCgpID0+IHNjaGVtYS5mb3JFYWNoKChfc2NoLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICAgIHNjaGVtYVByb3A6IGksXG4gICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICB9LCBzY2hWYWxpZCk7XG4gICAgICAgIGdlbi5hc3NpZ24odmFsaWQsICgwLCBjb2RlZ2VuXzEuXykgYCR7dmFsaWR9IHx8ICR7c2NoVmFsaWR9YCk7XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IGN4dC5tZXJnZVZhbGlkRXZhbHVhdGVkKHNjaEN4dCwgc2NoVmFsaWQpO1xuICAgICAgICAvLyBjYW4gc2hvcnQtY2lyY3VpdCBpZiBgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzL0l0ZW1zYCBub3Qgc3VwcG9ydGVkIChvcHRzLnVuZXZhbHVhdGVkICE9PSB0cnVlKVxuICAgICAgICAvLyBvciBpZiBhbGwgcHJvcGVydGllcyBhbmQgaXRlbXMgd2VyZSBldmFsdWF0ZWQgKGl0LnByb3BzID09PSB0cnVlICYmIGl0Lml0ZW1zID09PSB0cnVlKVxuICAgICAgICBpZiAoIW1lcmdlZClcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpKTtcbiAgICB9KSk7XG4gICAgY3h0LnJlc3VsdCh2YWxpZCwgKCkgPT4gY3h0LnJlc2V0KCksICgpID0+IGN4dC5lcnJvcih0cnVlKSk7XG59XG5leHBvcnRzLnZhbGlkYXRlVW5pb24gPSB2YWxpZGF0ZVVuaW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVLZXl3b3JkVXNhZ2UgPSBleHBvcnRzLnZhbGlkU2NoZW1hVHlwZSA9IGV4cG9ydHMuZnVuY0tleXdvcmRDb2RlID0gZXhwb3J0cy5tYWNyb0tleXdvcmRDb2RlID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uL25hbWVzXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uLy4uL3ZvY2FidWxhcmllcy9jb2RlXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuZnVuY3Rpb24gbWFjcm9LZXl3b3JkQ29kZShjeHQsIGRlZikge1xuICAgIGNvbnN0IHsgZ2VuLCBrZXl3b3JkLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCBtYWNyb1NjaGVtYSA9IGRlZi5tYWNyby5jYWxsKGl0LnNlbGYsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCk7XG4gICAgY29uc3Qgc2NoZW1hUmVmID0gdXNlS2V5d29yZChnZW4sIGtleXdvcmQsIG1hY3JvU2NoZW1hKTtcbiAgICBpZiAoaXQub3B0cy52YWxpZGF0ZVNjaGVtYSAhPT0gZmFsc2UpXG4gICAgICAgIGl0LnNlbGYudmFsaWRhdGVTY2hlbWEobWFjcm9TY2hlbWEsIHRydWUpO1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgc2NoZW1hOiBtYWNyb1NjaGVtYSxcbiAgICAgICAgc2NoZW1hUGF0aDogY29kZWdlbl8xLm5pbCxcbiAgICAgICAgZXJyU2NoZW1hUGF0aDogYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWAsXG4gICAgICAgIHRvcFNjaGVtYVJlZjogc2NoZW1hUmVmLFxuICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgIH0sIHZhbGlkKTtcbiAgICBjeHQucGFzcyh2YWxpZCwgKCkgPT4gY3h0LmVycm9yKHRydWUpKTtcbn1cbmV4cG9ydHMubWFjcm9LZXl3b3JkQ29kZSA9IG1hY3JvS2V5d29yZENvZGU7XG5mdW5jdGlvbiBmdW5jS2V5d29yZENvZGUoY3h0LCBkZWYpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBnZW4sIGtleXdvcmQsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCAkZGF0YSwgaXQgfSA9IGN4dDtcbiAgICBjaGVja0FzeW5jS2V5d29yZChpdCwgZGVmKTtcbiAgICBjb25zdCB2YWxpZGF0ZSA9ICEkZGF0YSAmJiBkZWYuY29tcGlsZSA/IGRlZi5jb21waWxlLmNhbGwoaXQuc2VsZiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0KSA6IGRlZi52YWxpZGF0ZTtcbiAgICBjb25zdCB2YWxpZGF0ZVJlZiA9IHVzZUtleXdvcmQoZ2VuLCBrZXl3b3JkLCB2YWxpZGF0ZSk7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIik7XG4gICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsIHZhbGlkYXRlS2V5d29yZCk7XG4gICAgY3h0Lm9rKChfYSA9IGRlZi52YWxpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFsaWQpO1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlS2V5d29yZCgpIHtcbiAgICAgICAgaWYgKGRlZi5lcnJvcnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBhc3NpZ25WYWxpZCgpO1xuICAgICAgICAgICAgaWYgKGRlZi5tb2RpZnlpbmcpXG4gICAgICAgICAgICAgICAgbW9kaWZ5RGF0YShjeHQpO1xuICAgICAgICAgICAgcmVwb3J0RXJycygoKSA9PiBjeHQuZXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBydWxlRXJycyA9IGRlZi5hc3luYyA/IHZhbGlkYXRlQXN5bmMoKSA6IHZhbGlkYXRlU3luYygpO1xuICAgICAgICAgICAgaWYgKGRlZi5tb2RpZnlpbmcpXG4gICAgICAgICAgICAgICAgbW9kaWZ5RGF0YShjeHQpO1xuICAgICAgICAgICAgcmVwb3J0RXJycygoKSA9PiBhZGRFcnJzKGN4dCwgcnVsZUVycnMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUFzeW5jKCkge1xuICAgICAgICBjb25zdCBydWxlRXJycyA9IGdlbi5sZXQoXCJydWxlRXJyc1wiLCBudWxsKTtcbiAgICAgICAgZ2VuLnRyeSgoKSA9PiBhc3NpZ25WYWxpZCgoMCwgY29kZWdlbl8xLl8pIGBhd2FpdCBgKSwgKGUpID0+IGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5pZigoMCwgY29kZWdlbl8xLl8pIGAke2V9IGluc3RhbmNlb2YgJHtpdC5WYWxpZGF0aW9uRXJyb3J9YCwgKCkgPT4gZ2VuLmFzc2lnbihydWxlRXJycywgKDAsIGNvZGVnZW5fMS5fKSBgJHtlfS5lcnJvcnNgKSwgKCkgPT4gZ2VuLnRocm93KGUpKSk7XG4gICAgICAgIHJldHVybiBydWxlRXJycztcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVTeW5jKCkge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZUVycnMgPSAoMCwgY29kZWdlbl8xLl8pIGAke3ZhbGlkYXRlUmVmfS5lcnJvcnNgO1xuICAgICAgICBnZW4uYXNzaWduKHZhbGlkYXRlRXJycywgbnVsbCk7XG4gICAgICAgIGFzc2lnblZhbGlkKGNvZGVnZW5fMS5uaWwpO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVFcnJzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NpZ25WYWxpZChfYXdhaXQgPSBkZWYuYXN5bmMgPyAoMCwgY29kZWdlbl8xLl8pIGBhd2FpdCBgIDogY29kZWdlbl8xLm5pbCkge1xuICAgICAgICBjb25zdCBwYXNzQ3h0ID0gaXQub3B0cy5wYXNzQ29udGV4dCA/IG5hbWVzXzEuZGVmYXVsdC50aGlzIDogbmFtZXNfMS5kZWZhdWx0LnNlbGY7XG4gICAgICAgIGNvbnN0IHBhc3NTY2hlbWEgPSAhKChcImNvbXBpbGVcIiBpbiBkZWYgJiYgISRkYXRhKSB8fCBkZWYuc2NoZW1hID09PSBmYWxzZSk7XG4gICAgICAgIGdlbi5hc3NpZ24odmFsaWQsICgwLCBjb2RlZ2VuXzEuXykgYCR7X2F3YWl0fSR7KDAsIGNvZGVfMS5jYWxsVmFsaWRhdGVDb2RlKShjeHQsIHZhbGlkYXRlUmVmLCBwYXNzQ3h0LCBwYXNzU2NoZW1hKX1gLCBkZWYubW9kaWZ5aW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVwb3J0RXJycyhlcnJvcnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKChfYSA9IGRlZi52YWxpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFsaWQpLCBlcnJvcnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuZnVuY0tleXdvcmRDb2RlID0gZnVuY0tleXdvcmRDb2RlO1xuZnVuY3Rpb24gbW9kaWZ5RGF0YShjeHQpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICBnZW4uaWYoaXQucGFyZW50RGF0YSwgKCkgPT4gZ2VuLmFzc2lnbihkYXRhLCAoMCwgY29kZWdlbl8xLl8pIGAke2l0LnBhcmVudERhdGF9WyR7aXQucGFyZW50RGF0YVByb3BlcnR5fV1gKSk7XG59XG5mdW5jdGlvbiBhZGRFcnJzKGN4dCwgZXJycykge1xuICAgIGNvbnN0IHsgZ2VuIH0gPSBjeHQ7XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYEFycmF5LmlzQXJyYXkoJHtlcnJzfSlgLCAoKSA9PiB7XG4gICAgICAgIGdlblxuICAgICAgICAgICAgLmFzc2lnbihuYW1lc18xLmRlZmF1bHQudkVycm9ycywgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30gPT09IG51bGwgPyAke2VycnN9IDogJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30uY29uY2F0KCR7ZXJyc30pYClcbiAgICAgICAgICAgIC5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LmVycm9ycywgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30ubGVuZ3RoYCk7XG4gICAgICAgICgwLCBlcnJvcnNfMS5leHRlbmRFcnJvcnMpKGN4dCk7XG4gICAgfSwgKCkgPT4gY3h0LmVycm9yKCkpO1xufVxuZnVuY3Rpb24gY2hlY2tBc3luY0tleXdvcmQoeyBzY2hlbWFFbnYgfSwgZGVmKSB7XG4gICAgaWYgKGRlZi5hc3luYyAmJiAhc2NoZW1hRW52LiRhc3luYylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMga2V5d29yZCBpbiBzeW5jIHNjaGVtYVwiKTtcbn1cbmZ1bmN0aW9uIHVzZUtleXdvcmQoZ2VuLCBrZXl3b3JkLCByZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihga2V5d29yZCBcIiR7a2V5d29yZH1cIiBmYWlsZWQgdG8gY29tcGlsZWApO1xuICAgIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcImtleXdvcmRcIiwgdHlwZW9mIHJlc3VsdCA9PSBcImZ1bmN0aW9uXCIgPyB7IHJlZjogcmVzdWx0IH0gOiB7IHJlZjogcmVzdWx0LCBjb2RlOiAoMCwgY29kZWdlbl8xLnN0cmluZ2lmeSkocmVzdWx0KSB9KTtcbn1cbmZ1bmN0aW9uIHZhbGlkU2NoZW1hVHlwZShzY2hlbWEsIHNjaGVtYVR5cGUsIGFsbG93VW5kZWZpbmVkID0gZmFsc2UpIHtcbiAgICAvLyBUT0RPIGFkZCB0ZXN0c1xuICAgIHJldHVybiAoIXNjaGVtYVR5cGUubGVuZ3RoIHx8XG4gICAgICAgIHNjaGVtYVR5cGUuc29tZSgoc3QpID0+IHN0ID09PSBcImFycmF5XCJcbiAgICAgICAgICAgID8gQXJyYXkuaXNBcnJheShzY2hlbWEpXG4gICAgICAgICAgICA6IHN0ID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICAgICAgPyBzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHNjaGVtYSlcbiAgICAgICAgICAgICAgICA6IHR5cGVvZiBzY2hlbWEgPT0gc3QgfHwgKGFsbG93VW5kZWZpbmVkICYmIHR5cGVvZiBzY2hlbWEgPT0gXCJ1bmRlZmluZWRcIikpKTtcbn1cbmV4cG9ydHMudmFsaWRTY2hlbWFUeXBlID0gdmFsaWRTY2hlbWFUeXBlO1xuZnVuY3Rpb24gdmFsaWRhdGVLZXl3b3JkVXNhZ2UoeyBzY2hlbWEsIG9wdHMsIHNlbGYsIGVyclNjaGVtYVBhdGggfSwgZGVmLCBrZXl3b3JkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmLmtleXdvcmQpID8gIWRlZi5rZXl3b3JkLmluY2x1ZGVzKGtleXdvcmQpIDogZGVmLmtleXdvcmQgIT09IGtleXdvcmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgIH1cbiAgICBjb25zdCBkZXBzID0gZGVmLmRlcGVuZGVuY2llcztcbiAgICBpZiAoZGVwcyA9PT0gbnVsbCB8fCBkZXBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZXBzLnNvbWUoKGt3ZCkgPT4gIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzY2hlbWEsIGt3ZCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFyZW50IHNjaGVtYSBtdXN0IGhhdmUgZGVwZW5kZW5jaWVzIG9mICR7a2V5d29yZH06ICR7ZGVwcy5qb2luKFwiLFwiKX1gKTtcbiAgICB9XG4gICAgaWYgKGRlZi52YWxpZGF0ZVNjaGVtYSkge1xuICAgICAgICBjb25zdCB2YWxpZCA9IGRlZi52YWxpZGF0ZVNjaGVtYShzY2hlbWFba2V5d29yZF0pO1xuICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBga2V5d29yZCBcIiR7a2V5d29yZH1cIiB2YWx1ZSBpcyBpbnZhbGlkIGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCI6IGAgK1xuICAgICAgICAgICAgICAgIHNlbGYuZXJyb3JzVGV4dChkZWYudmFsaWRhdGVTY2hlbWEuZXJyb3JzKTtcbiAgICAgICAgICAgIGlmIChvcHRzLnZhbGlkYXRlU2NoZW1hID09PSBcImxvZ1wiKVxuICAgICAgICAgICAgICAgIHNlbGYubG9nZ2VyLmVycm9yKG1zZyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlS2V5d29yZFVzYWdlID0gdmFsaWRhdGVLZXl3b3JkVXNhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXl3b3JkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHRlbmRTdWJzY2hlbWFNb2RlID0gZXhwb3J0cy5leHRlbmRTdWJzY2hlbWFEYXRhID0gZXhwb3J0cy5nZXRTdWJzY2hlbWEgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuZnVuY3Rpb24gZ2V0U3Vic2NoZW1hKGl0LCB7IGtleXdvcmQsIHNjaGVtYVByb3AsIHNjaGVtYSwgc2NoZW1hUGF0aCwgZXJyU2NoZW1hUGF0aCwgdG9wU2NoZW1hUmVmIH0pIHtcbiAgICBpZiAoa2V5d29yZCAhPT0gdW5kZWZpbmVkICYmIHNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYm90aCBcImtleXdvcmRcIiBhbmQgXCJzY2hlbWFcIiBwYXNzZWQsIG9ubHkgb25lIGFsbG93ZWQnKTtcbiAgICB9XG4gICAgaWYgKGtleXdvcmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBzY2ggPSBpdC5zY2hlbWFba2V5d29yZF07XG4gICAgICAgIHJldHVybiBzY2hlbWFQcm9wID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoLFxuICAgICAgICAgICAgICAgIHNjaGVtYVBhdGg6ICgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuc2NoZW1hUGF0aH0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKGtleXdvcmQpfWAsXG4gICAgICAgICAgICAgICAgZXJyU2NoZW1hUGF0aDogYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWAsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHNjaFtzY2hlbWFQcm9wXSxcbiAgICAgICAgICAgICAgICBzY2hlbWFQYXRoOiAoMCwgY29kZWdlbl8xLl8pIGAke2l0LnNjaGVtYVBhdGh9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShrZXl3b3JkKX0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKHNjaGVtYVByb3ApfWAsXG4gICAgICAgICAgICAgICAgZXJyU2NoZW1hUGF0aDogYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfS8keygwLCB1dGlsXzEuZXNjYXBlRnJhZ21lbnQpKHNjaGVtYVByb3ApfWAsXG4gICAgICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoc2NoZW1hICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHNjaGVtYVBhdGggPT09IHVuZGVmaW5lZCB8fCBlcnJTY2hlbWFQYXRoID09PSB1bmRlZmluZWQgfHwgdG9wU2NoZW1hUmVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJzY2hlbWFQYXRoXCIsIFwiZXJyU2NoZW1hUGF0aFwiIGFuZCBcInRvcFNjaGVtYVJlZlwiIGFyZSByZXF1aXJlZCB3aXRoIFwic2NoZW1hXCInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgc2NoZW1hUGF0aCxcbiAgICAgICAgICAgIHRvcFNjaGVtYVJlZixcbiAgICAgICAgICAgIGVyclNjaGVtYVBhdGgsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignZWl0aGVyIFwia2V5d29yZFwiIG9yIFwic2NoZW1hXCIgbXVzdCBiZSBwYXNzZWQnKTtcbn1cbmV4cG9ydHMuZ2V0U3Vic2NoZW1hID0gZ2V0U3Vic2NoZW1hO1xuZnVuY3Rpb24gZXh0ZW5kU3Vic2NoZW1hRGF0YShzdWJzY2hlbWEsIGl0LCB7IGRhdGFQcm9wLCBkYXRhUHJvcFR5cGU6IGRwVHlwZSwgZGF0YSwgZGF0YVR5cGVzLCBwcm9wZXJ0eU5hbWUgfSkge1xuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQgJiYgZGF0YVByb3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGggXCJkYXRhXCIgYW5kIFwiZGF0YVByb3BcIiBwYXNzZWQsIG9ubHkgb25lIGFsbG93ZWQnKTtcbiAgICB9XG4gICAgY29uc3QgeyBnZW4gfSA9IGl0O1xuICAgIGlmIChkYXRhUHJvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHsgZXJyb3JQYXRoLCBkYXRhUGF0aEFyciwgb3B0cyB9ID0gaXQ7XG4gICAgICAgIGNvbnN0IG5leHREYXRhID0gZ2VuLmxldChcImRhdGFcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5kYXRhfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoZGF0YVByb3ApfWAsIHRydWUpO1xuICAgICAgICBkYXRhQ29udGV4dFByb3BzKG5leHREYXRhKTtcbiAgICAgICAgc3Vic2NoZW1hLmVycm9yUGF0aCA9ICgwLCBjb2RlZ2VuXzEuc3RyKSBgJHtlcnJvclBhdGh9JHsoMCwgdXRpbF8xLmdldEVycm9yUGF0aCkoZGF0YVByb3AsIGRwVHlwZSwgb3B0cy5qc1Byb3BlcnR5U3ludGF4KX1gO1xuICAgICAgICBzdWJzY2hlbWEucGFyZW50RGF0YVByb3BlcnR5ID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhUHJvcH1gO1xuICAgICAgICBzdWJzY2hlbWEuZGF0YVBhdGhBcnIgPSBbLi4uZGF0YVBhdGhBcnIsIHN1YnNjaGVtYS5wYXJlbnREYXRhUHJvcGVydHldO1xuICAgIH1cbiAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IG5leHREYXRhID0gZGF0YSBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lID8gZGF0YSA6IGdlbi5sZXQoXCJkYXRhXCIsIGRhdGEsIHRydWUpOyAvLyByZXBsYWNlYWJsZSBpZiB1c2VkIG9uY2U/XG4gICAgICAgIGRhdGFDb250ZXh0UHJvcHMobmV4dERhdGEpO1xuICAgICAgICBpZiAocHJvcGVydHlOYW1lICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBzdWJzY2hlbWEucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xuICAgICAgICAvLyBUT0RPIHNvbWV0aGluZyBpcyBwb3NzaWJseSB3cm9uZyBoZXJlIHdpdGggbm90IGNoYW5naW5nIHBhcmVudERhdGFQcm9wZXJ0eSBhbmQgbm90IGFwcGVuZGluZyBkYXRhUGF0aEFyclxuICAgIH1cbiAgICBpZiAoZGF0YVR5cGVzKVxuICAgICAgICBzdWJzY2hlbWEuZGF0YVR5cGVzID0gZGF0YVR5cGVzO1xuICAgIGZ1bmN0aW9uIGRhdGFDb250ZXh0UHJvcHMoX25leHREYXRhKSB7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhID0gX25leHREYXRhO1xuICAgICAgICBzdWJzY2hlbWEuZGF0YUxldmVsID0gaXQuZGF0YUxldmVsICsgMTtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFUeXBlcyA9IFtdO1xuICAgICAgICBpdC5kZWZpbmVkUHJvcGVydGllcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgc3Vic2NoZW1hLnBhcmVudERhdGEgPSBpdC5kYXRhO1xuICAgICAgICBzdWJzY2hlbWEuZGF0YU5hbWVzID0gWy4uLml0LmRhdGFOYW1lcywgX25leHREYXRhXTtcbiAgICB9XG59XG5leHBvcnRzLmV4dGVuZFN1YnNjaGVtYURhdGEgPSBleHRlbmRTdWJzY2hlbWFEYXRhO1xuZnVuY3Rpb24gZXh0ZW5kU3Vic2NoZW1hTW9kZShzdWJzY2hlbWEsIHsganRkRGlzY3JpbWluYXRvciwganRkTWV0YWRhdGEsIGNvbXBvc2l0ZVJ1bGUsIGNyZWF0ZUVycm9ycywgYWxsRXJyb3JzIH0pIHtcbiAgICBpZiAoY29tcG9zaXRlUnVsZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBzdWJzY2hlbWEuY29tcG9zaXRlUnVsZSA9IGNvbXBvc2l0ZVJ1bGU7XG4gICAgaWYgKGNyZWF0ZUVycm9ycyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBzdWJzY2hlbWEuY3JlYXRlRXJyb3JzID0gY3JlYXRlRXJyb3JzO1xuICAgIGlmIChhbGxFcnJvcnMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgc3Vic2NoZW1hLmFsbEVycm9ycyA9IGFsbEVycm9ycztcbiAgICBzdWJzY2hlbWEuanRkRGlzY3JpbWluYXRvciA9IGp0ZERpc2NyaW1pbmF0b3I7IC8vIG5vdCBpbmhlcml0ZWRcbiAgICBzdWJzY2hlbWEuanRkTWV0YWRhdGEgPSBqdGRNZXRhZGF0YTsgLy8gbm90IGluaGVyaXRlZFxufVxuZXhwb3J0cy5leHRlbmRTdWJzY2hlbWFNb2RlID0gZXh0ZW5kU3Vic2NoZW1hTW9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnNjaGVtYS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbi8vIGRvIG5vdCBlZGl0IC5qcyBmaWxlcyBkaXJlY3RseSAtIGVkaXQgc3JjL2luZGV4LmpzdFxuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XG4gICAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBsZW5ndGgsIGksIGtleXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICBpZiAoIWVxdWFsKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuXG4gICAgaWYgKGEuY29uc3RydWN0b3IgPT09IFJlZ0V4cCkgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgICBpZiAoYS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyB0cnVlIGlmIGJvdGggTmFOLCBmYWxzZSBvdGhlcndpc2VcbiAgcmV0dXJuIGEhPT1hICYmIGIhPT1iO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRyYXZlcnNlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2NoZW1hLCBvcHRzLCBjYikge1xuICAvLyBMZWdhY3kgc3VwcG9ydCBmb3IgdjAuMy4xIGFuZCBlYXJsaWVyLlxuICBpZiAodHlwZW9mIG9wdHMgPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cblxuICBjYiA9IG9wdHMuY2IgfHwgY2I7XG4gIHZhciBwcmUgPSAodHlwZW9mIGNiID09ICdmdW5jdGlvbicpID8gY2IgOiBjYi5wcmUgfHwgZnVuY3Rpb24oKSB7fTtcbiAgdmFyIHBvc3QgPSBjYi5wb3N0IHx8IGZ1bmN0aW9uKCkge307XG5cbiAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoZW1hLCAnJywgc2NoZW1hKTtcbn07XG5cblxudHJhdmVyc2Uua2V5d29yZHMgPSB7XG4gIGFkZGl0aW9uYWxJdGVtczogdHJ1ZSxcbiAgaXRlbXM6IHRydWUsXG4gIGNvbnRhaW5zOiB0cnVlLFxuICBhZGRpdGlvbmFsUHJvcGVydGllczogdHJ1ZSxcbiAgcHJvcGVydHlOYW1lczogdHJ1ZSxcbiAgbm90OiB0cnVlLFxuICBpZjogdHJ1ZSxcbiAgdGhlbjogdHJ1ZSxcbiAgZWxzZTogdHJ1ZVxufTtcblxudHJhdmVyc2UuYXJyYXlLZXl3b3JkcyA9IHtcbiAgaXRlbXM6IHRydWUsXG4gIGFsbE9mOiB0cnVlLFxuICBhbnlPZjogdHJ1ZSxcbiAgb25lT2Y6IHRydWVcbn07XG5cbnRyYXZlcnNlLnByb3BzS2V5d29yZHMgPSB7XG4gICRkZWZzOiB0cnVlLFxuICBkZWZpbml0aW9uczogdHJ1ZSxcbiAgcHJvcGVydGllczogdHJ1ZSxcbiAgcGF0dGVyblByb3BlcnRpZXM6IHRydWUsXG4gIGRlcGVuZGVuY2llczogdHJ1ZVxufTtcblxudHJhdmVyc2Uuc2tpcEtleXdvcmRzID0ge1xuICBkZWZhdWx0OiB0cnVlLFxuICBlbnVtOiB0cnVlLFxuICBjb25zdDogdHJ1ZSxcbiAgcmVxdWlyZWQ6IHRydWUsXG4gIG1heGltdW06IHRydWUsXG4gIG1pbmltdW06IHRydWUsXG4gIGV4Y2x1c2l2ZU1heGltdW06IHRydWUsXG4gIGV4Y2x1c2l2ZU1pbmltdW06IHRydWUsXG4gIG11bHRpcGxlT2Y6IHRydWUsXG4gIG1heExlbmd0aDogdHJ1ZSxcbiAgbWluTGVuZ3RoOiB0cnVlLFxuICBwYXR0ZXJuOiB0cnVlLFxuICBmb3JtYXQ6IHRydWUsXG4gIG1heEl0ZW1zOiB0cnVlLFxuICBtaW5JdGVtczogdHJ1ZSxcbiAgdW5pcXVlSXRlbXM6IHRydWUsXG4gIG1heFByb3BlcnRpZXM6IHRydWUsXG4gIG1pblByb3BlcnRpZXM6IHRydWVcbn07XG5cblxuZnVuY3Rpb24gX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoZW1hLCBqc29uUHRyLCByb290U2NoZW1hLCBwYXJlbnRKc29uUHRyLCBwYXJlbnRLZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGtleUluZGV4KSB7XG4gIGlmIChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgcHJlKHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCk7XG4gICAgZm9yICh2YXIga2V5IGluIHNjaGVtYSkge1xuICAgICAgdmFyIHNjaCA9IHNjaGVtYVtrZXldO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoKSkge1xuICAgICAgICBpZiAoa2V5IGluIHRyYXZlcnNlLmFycmF5S2V5d29yZHMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8c2NoLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoW2ldLCBqc29uUHRyICsgJy8nICsga2V5ICsgJy8nICsgaSwgcm9vdFNjaGVtYSwganNvblB0ciwga2V5LCBzY2hlbWEsIGkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSBpbiB0cmF2ZXJzZS5wcm9wc0tleXdvcmRzKSB7XG4gICAgICAgIGlmIChzY2ggJiYgdHlwZW9mIHNjaCA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc2NoKVxuICAgICAgICAgICAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoW3Byb3BdLCBqc29uUHRyICsgJy8nICsga2V5ICsgJy8nICsgZXNjYXBlSnNvblB0cihwcm9wKSwgcm9vdFNjaGVtYSwganNvblB0ciwga2V5LCBzY2hlbWEsIHByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSBpbiB0cmF2ZXJzZS5rZXl3b3JkcyB8fCAob3B0cy5hbGxLZXlzICYmICEoa2V5IGluIHRyYXZlcnNlLnNraXBLZXl3b3JkcykpKSB7XG4gICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaCwganNvblB0ciArICcvJyArIGtleSwgcm9vdFNjaGVtYSwganNvblB0ciwga2V5LCBzY2hlbWEpO1xuICAgICAgfVxuICAgIH1cbiAgICBwb3N0KHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBlc2NhcGVKc29uUHRyKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL34vZywgJ34wJykucmVwbGFjZSgvXFwvL2csICd+MScpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFNjaGVtYVJlZnMgPSBleHBvcnRzLnJlc29sdmVVcmwgPSBleHBvcnRzLm5vcm1hbGl6ZUlkID0gZXhwb3J0cy5fZ2V0RnVsbFBhdGggPSBleHBvcnRzLmdldEZ1bGxQYXRoID0gZXhwb3J0cy5pbmxpbmVSZWYgPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgZXF1YWwgPSByZXF1aXJlKFwiZmFzdC1kZWVwLWVxdWFsXCIpO1xuY29uc3QgdHJhdmVyc2UgPSByZXF1aXJlKFwianNvbi1zY2hlbWEtdHJhdmVyc2VcIik7XG4vLyBUT0RPIHJlZmFjdG9yIHRvIHVzZSBrZXl3b3JkIGRlZmluaXRpb25zXG5jb25zdCBTSU1QTEVfSU5MSU5FRCA9IG5ldyBTZXQoW1xuICAgIFwidHlwZVwiLFxuICAgIFwiZm9ybWF0XCIsXG4gICAgXCJwYXR0ZXJuXCIsXG4gICAgXCJtYXhMZW5ndGhcIixcbiAgICBcIm1pbkxlbmd0aFwiLFxuICAgIFwibWF4UHJvcGVydGllc1wiLFxuICAgIFwibWluUHJvcGVydGllc1wiLFxuICAgIFwibWF4SXRlbXNcIixcbiAgICBcIm1pbkl0ZW1zXCIsXG4gICAgXCJtYXhpbXVtXCIsXG4gICAgXCJtaW5pbXVtXCIsXG4gICAgXCJ1bmlxdWVJdGVtc1wiLFxuICAgIFwibXVsdGlwbGVPZlwiLFxuICAgIFwicmVxdWlyZWRcIixcbiAgICBcImVudW1cIixcbiAgICBcImNvbnN0XCIsXG5dKTtcbmZ1bmN0aW9uIGlubGluZVJlZihzY2hlbWEsIGxpbWl0ID0gdHJ1ZSkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAobGltaXQgPT09IHRydWUpXG4gICAgICAgIHJldHVybiAhaGFzUmVmKHNjaGVtYSk7XG4gICAgaWYgKCFsaW1pdClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBjb3VudEtleXMoc2NoZW1hKSA8PSBsaW1pdDtcbn1cbmV4cG9ydHMuaW5saW5lUmVmID0gaW5saW5lUmVmO1xuY29uc3QgUkVGX0tFWVdPUkRTID0gbmV3IFNldChbXG4gICAgXCIkcmVmXCIsXG4gICAgXCIkcmVjdXJzaXZlUmVmXCIsXG4gICAgXCIkcmVjdXJzaXZlQW5jaG9yXCIsXG4gICAgXCIkZHluYW1pY1JlZlwiLFxuICAgIFwiJGR5bmFtaWNBbmNob3JcIixcbl0pO1xuZnVuY3Rpb24gaGFzUmVmKHNjaGVtYSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBpZiAoUkVGX0tFWVdPUkRTLmhhcyhrZXkpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnN0IHNjaCA9IHNjaGVtYVtrZXldO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2gpICYmIHNjaC5zb21lKGhhc1JlZikpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2ggPT0gXCJvYmplY3RcIiAmJiBoYXNSZWYoc2NoKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjb3VudEtleXMoc2NoZW1hKSB7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCIkcmVmXCIpXG4gICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICAgIGlmIChTSU1QTEVfSU5MSU5FRC5oYXMoa2V5KSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYVtrZXldID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICgwLCB1dGlsXzEuZWFjaEl0ZW0pKHNjaGVtYVtrZXldLCAoc2NoKSA9PiAoY291bnQgKz0gY291bnRLZXlzKHNjaCkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY291bnQgPT09IEluZmluaXR5KVxuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG59XG5mdW5jdGlvbiBnZXRGdWxsUGF0aChyZXNvbHZlciwgaWQgPSBcIlwiLCBub3JtYWxpemUpIHtcbiAgICBpZiAobm9ybWFsaXplICE9PSBmYWxzZSlcbiAgICAgICAgaWQgPSBub3JtYWxpemVJZChpZCk7XG4gICAgY29uc3QgcCA9IHJlc29sdmVyLnBhcnNlKGlkKTtcbiAgICByZXR1cm4gX2dldEZ1bGxQYXRoKHJlc29sdmVyLCBwKTtcbn1cbmV4cG9ydHMuZ2V0RnVsbFBhdGggPSBnZXRGdWxsUGF0aDtcbmZ1bmN0aW9uIF9nZXRGdWxsUGF0aChyZXNvbHZlciwgcCkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSByZXNvbHZlci5zZXJpYWxpemUocCk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQuc3BsaXQoXCIjXCIpWzBdICsgXCIjXCI7XG59XG5leHBvcnRzLl9nZXRGdWxsUGF0aCA9IF9nZXRGdWxsUGF0aDtcbmNvbnN0IFRSQUlMSU5HX1NMQVNIX0hBU0ggPSAvI1xcLz8kLztcbmZ1bmN0aW9uIG5vcm1hbGl6ZUlkKGlkKSB7XG4gICAgcmV0dXJuIGlkID8gaWQucmVwbGFjZShUUkFJTElOR19TTEFTSF9IQVNILCBcIlwiKSA6IFwiXCI7XG59XG5leHBvcnRzLm5vcm1hbGl6ZUlkID0gbm9ybWFsaXplSWQ7XG5mdW5jdGlvbiByZXNvbHZlVXJsKHJlc29sdmVyLCBiYXNlSWQsIGlkKSB7XG4gICAgaWQgPSBub3JtYWxpemVJZChpZCk7XG4gICAgcmV0dXJuIHJlc29sdmVyLnJlc29sdmUoYmFzZUlkLCBpZCk7XG59XG5leHBvcnRzLnJlc29sdmVVcmwgPSByZXNvbHZlVXJsO1xuY29uc3QgQU5DSE9SID0gL15bYS16X11bLWEtejAtOS5fXSokL2k7XG5mdW5jdGlvbiBnZXRTY2hlbWFSZWZzKHNjaGVtYSwgYmFzZUlkKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICBjb25zdCB7IHNjaGVtYUlkLCB1cmlSZXNvbHZlciB9ID0gdGhpcy5vcHRzO1xuICAgIGNvbnN0IHNjaElkID0gbm9ybWFsaXplSWQoc2NoZW1hW3NjaGVtYUlkXSB8fCBiYXNlSWQpO1xuICAgIGNvbnN0IGJhc2VJZHMgPSB7IFwiXCI6IHNjaElkIH07XG4gICAgY29uc3QgcGF0aFByZWZpeCA9IGdldEZ1bGxQYXRoKHVyaVJlc29sdmVyLCBzY2hJZCwgZmFsc2UpO1xuICAgIGNvbnN0IGxvY2FsUmVmcyA9IHt9O1xuICAgIGNvbnN0IHNjaGVtYVJlZnMgPSBuZXcgU2V0KCk7XG4gICAgdHJhdmVyc2Uoc2NoZW1hLCB7IGFsbEtleXM6IHRydWUgfSwgKHNjaCwganNvblB0ciwgXywgcGFyZW50SnNvblB0cikgPT4ge1xuICAgICAgICBpZiAocGFyZW50SnNvblB0ciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGhQcmVmaXggKyBqc29uUHRyO1xuICAgICAgICBsZXQgYmFzZUlkID0gYmFzZUlkc1twYXJlbnRKc29uUHRyXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hbc2NoZW1hSWRdID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBiYXNlSWQgPSBhZGRSZWYuY2FsbCh0aGlzLCBzY2hbc2NoZW1hSWRdKTtcbiAgICAgICAgYWRkQW5jaG9yLmNhbGwodGhpcywgc2NoLiRhbmNob3IpO1xuICAgICAgICBhZGRBbmNob3IuY2FsbCh0aGlzLCBzY2guJGR5bmFtaWNBbmNob3IpO1xuICAgICAgICBiYXNlSWRzW2pzb25QdHJdID0gYmFzZUlkO1xuICAgICAgICBmdW5jdGlvbiBhZGRSZWYocmVmKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICAgICAgICBjb25zdCBfcmVzb2x2ZSA9IHRoaXMub3B0cy51cmlSZXNvbHZlci5yZXNvbHZlO1xuICAgICAgICAgICAgcmVmID0gbm9ybWFsaXplSWQoYmFzZUlkID8gX3Jlc29sdmUoYmFzZUlkLCByZWYpIDogcmVmKTtcbiAgICAgICAgICAgIGlmIChzY2hlbWFSZWZzLmhhcyhyZWYpKVxuICAgICAgICAgICAgICAgIHRocm93IGFtYmlndW9zKHJlZik7XG4gICAgICAgICAgICBzY2hlbWFSZWZzLmFkZChyZWYpO1xuICAgICAgICAgICAgbGV0IHNjaE9yUmVmID0gdGhpcy5yZWZzW3JlZl07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaE9yUmVmID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgc2NoT3JSZWYgPSB0aGlzLnJlZnNbc2NoT3JSZWZdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hPclJlZiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tBbWJpZ3Vvc1JlZihzY2gsIHNjaE9yUmVmLnNjaGVtYSwgcmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlZiAhPT0gbm9ybWFsaXplSWQoZnVsbFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZlswXSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tBbWJpZ3Vvc1JlZihzY2gsIGxvY2FsUmVmc1tyZWZdLCByZWYpO1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFJlZnNbcmVmXSA9IHNjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmc1tyZWZdID0gZnVsbFBhdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlZjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRBbmNob3IoYW5jaG9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFuY2hvciA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBTkNIT1IudGVzdChhbmNob3IpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgYW5jaG9yIFwiJHthbmNob3J9XCJgKTtcbiAgICAgICAgICAgICAgICBhZGRSZWYuY2FsbCh0aGlzLCBgIyR7YW5jaG9yfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGxvY2FsUmVmcztcbiAgICBmdW5jdGlvbiBjaGVja0FtYmlndW9zUmVmKHNjaDEsIHNjaDIsIHJlZikge1xuICAgICAgICBpZiAoc2NoMiAhPT0gdW5kZWZpbmVkICYmICFlcXVhbChzY2gxLCBzY2gyKSlcbiAgICAgICAgICAgIHRocm93IGFtYmlndW9zKHJlZik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFtYmlndW9zKHJlZikge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKGByZWZlcmVuY2UgXCIke3JlZn1cIiByZXNvbHZlcyB0byBtb3JlIHRoYW4gb25lIHNjaGVtYWApO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0U2NoZW1hUmVmcyA9IGdldFNjaGVtYVJlZnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXREYXRhID0gZXhwb3J0cy5LZXl3b3JkQ3h0ID0gZXhwb3J0cy52YWxpZGF0ZUZ1bmN0aW9uQ29kZSA9IHZvaWQgMDtcbmNvbnN0IGJvb2xTY2hlbWFfMSA9IHJlcXVpcmUoXCIuL2Jvb2xTY2hlbWFcIik7XG5jb25zdCBkYXRhVHlwZV8xID0gcmVxdWlyZShcIi4vZGF0YVR5cGVcIik7XG5jb25zdCBhcHBsaWNhYmlsaXR5XzEgPSByZXF1aXJlKFwiLi9hcHBsaWNhYmlsaXR5XCIpO1xuY29uc3QgZGF0YVR5cGVfMiA9IHJlcXVpcmUoXCIuL2RhdGFUeXBlXCIpO1xuY29uc3QgZGVmYXVsdHNfMSA9IHJlcXVpcmUoXCIuL2RlZmF1bHRzXCIpO1xuY29uc3Qga2V5d29yZF8xID0gcmVxdWlyZShcIi4va2V5d29yZFwiKTtcbmNvbnN0IHN1YnNjaGVtYV8xID0gcmVxdWlyZShcIi4vc3Vic2NoZW1hXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uL25hbWVzXCIpO1xuY29uc3QgcmVzb2x2ZV8xID0gcmVxdWlyZShcIi4uL3Jlc29sdmVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbi8vIHNjaGVtYSBjb21waWxhdGlvbiAtIGdlbmVyYXRlcyB2YWxpZGF0aW9uIGZ1bmN0aW9uLCBzdWJzY2hlbWFDb2RlIChiZWxvdykgaXMgdXNlZCBmb3Igc3Vic2NoZW1hc1xuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvZGUoaXQpIHtcbiAgICBpZiAoaXNTY2hlbWFPYmooaXQpKSB7XG4gICAgICAgIGNoZWNrS2V5d29yZHMoaXQpO1xuICAgICAgICBpZiAoc2NoZW1hQ3h0SGFzUnVsZXMoaXQpKSB7XG4gICAgICAgICAgICB0b3BTY2hlbWFPYmpDb2RlKGl0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YWxpZGF0ZUZ1bmN0aW9uKGl0LCAoKSA9PiAoMCwgYm9vbFNjaGVtYV8xLnRvcEJvb2xPckVtcHR5U2NoZW1hKShpdCkpO1xufVxuZXhwb3J0cy52YWxpZGF0ZUZ1bmN0aW9uQ29kZSA9IHZhbGlkYXRlRnVuY3Rpb25Db2RlO1xuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbih7IGdlbiwgdmFsaWRhdGVOYW1lLCBzY2hlbWEsIHNjaGVtYUVudiwgb3B0cyB9LCBib2R5KSB7XG4gICAgaWYgKG9wdHMuY29kZS5lczUpIHtcbiAgICAgICAgZ2VuLmZ1bmModmFsaWRhdGVOYW1lLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5kYXRhfSwgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fWAsIHNjaGVtYUVudi4kYXN5bmMsICgpID0+IHtcbiAgICAgICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYFwidXNlIHN0cmljdFwiOyAke2Z1bmNTb3VyY2VVcmwoc2NoZW1hLCBvcHRzKX1gKTtcbiAgICAgICAgICAgIGRlc3RydWN0dXJlVmFsQ3h0RVM1KGdlbiwgb3B0cyk7XG4gICAgICAgICAgICBnZW4uY29kZShib2R5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW4uZnVuYyh2YWxpZGF0ZU5hbWUsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LmRhdGF9LCAke2Rlc3RydWN0dXJlVmFsQ3h0KG9wdHMpfWAsIHNjaGVtYUVudi4kYXN5bmMsICgpID0+IGdlbi5jb2RlKGZ1bmNTb3VyY2VVcmwoc2NoZW1hLCBvcHRzKSkuY29kZShib2R5KSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVzdHJ1Y3R1cmVWYWxDeHQob3B0cykge1xuICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGB7JHtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRofT1cIlwiLCAke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhfSwgJHtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5fSwgJHtuYW1lc18xLmRlZmF1bHQucm9vdERhdGF9PSR7bmFtZXNfMS5kZWZhdWx0LmRhdGF9JHtvcHRzLmR5bmFtaWNSZWYgPyAoMCwgY29kZWdlbl8xLl8pIGAsICR7bmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzfT17fWAgOiBjb2RlZ2VuXzEubmlsfX09e31gO1xufVxuZnVuY3Rpb24gZGVzdHJ1Y3R1cmVWYWxDeHRFUzUoZ2VuLCBvcHRzKSB7XG4gICAgZ2VuLmlmKG5hbWVzXzEuZGVmYXVsdC52YWxDeHQsICgpID0+IHtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aH1gKTtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fS4ke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhfWApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHksICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5fWApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5yb290RGF0YSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fS4ke25hbWVzXzEuZGVmYXVsdC5yb290RGF0YX1gKTtcbiAgICAgICAgaWYgKG9wdHMuZHluYW1pY1JlZilcbiAgICAgICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzfWApO1xuICAgIH0sICgpID0+IHtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCAoMCwgY29kZWdlbl8xLl8pIGBcIlwiYCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGEsICgwLCBjb2RlZ2VuXzEuXykgYHVuZGVmaW5lZGApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHksICgwLCBjb2RlZ2VuXzEuXykgYHVuZGVmaW5lZGApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5yb290RGF0YSwgbmFtZXNfMS5kZWZhdWx0LmRhdGEpO1xuICAgICAgICBpZiAob3B0cy5keW5hbWljUmVmKVxuICAgICAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnMsICgwLCBjb2RlZ2VuXzEuXykgYHt9YCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB0b3BTY2hlbWFPYmpDb2RlKGl0KSB7XG4gICAgY29uc3QgeyBzY2hlbWEsIG9wdHMsIGdlbiB9ID0gaXQ7XG4gICAgdmFsaWRhdGVGdW5jdGlvbihpdCwgKCkgPT4ge1xuICAgICAgICBpZiAob3B0cy4kY29tbWVudCAmJiBzY2hlbWEuJGNvbW1lbnQpXG4gICAgICAgICAgICBjb21tZW50S2V5d29yZChpdCk7XG4gICAgICAgIGNoZWNrTm9EZWZhdWx0KGl0KTtcbiAgICAgICAgZ2VuLmxldChuYW1lc18xLmRlZmF1bHQudkVycm9ycywgbnVsbCk7XG4gICAgICAgIGdlbi5sZXQobmFtZXNfMS5kZWZhdWx0LmVycm9ycywgMCk7XG4gICAgICAgIGlmIChvcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICAgICAgcmVzZXRFdmFsdWF0ZWQoaXQpO1xuICAgICAgICB0eXBlQW5kS2V5d29yZHMoaXQpO1xuICAgICAgICByZXR1cm5SZXN1bHRzKGl0KTtcbiAgICB9KTtcbiAgICByZXR1cm47XG59XG5mdW5jdGlvbiByZXNldEV2YWx1YXRlZChpdCkge1xuICAgIC8vIFRPRE8gbWF5YmUgc29tZSBob29rIHRvIGV4ZWN1dGUgaXQgaW4gdGhlIGVuZCB0byBjaGVjayB3aGV0aGVyIHByb3BzL2l0ZW1zIGFyZSBOYW1lLCBhcyBpbiBhc3NpZ25FdmFsdWF0ZWRcbiAgICBjb25zdCB7IGdlbiwgdmFsaWRhdGVOYW1lIH0gPSBpdDtcbiAgICBpdC5ldmFsdWF0ZWQgPSBnZW4uY29uc3QoXCJldmFsdWF0ZWRcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZGF0ZU5hbWV9LmV2YWx1YXRlZGApO1xuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2l0LmV2YWx1YXRlZH0uZHluYW1pY1Byb3BzYCwgKCkgPT4gZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke2l0LmV2YWx1YXRlZH0ucHJvcHNgLCAoMCwgY29kZWdlbl8xLl8pIGB1bmRlZmluZWRgKSk7XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuZXZhbHVhdGVkfS5keW5hbWljSXRlbXNgLCAoKSA9PiBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuZXZhbHVhdGVkfS5pdGVtc2AsICgwLCBjb2RlZ2VuXzEuXykgYHVuZGVmaW5lZGApKTtcbn1cbmZ1bmN0aW9uIGZ1bmNTb3VyY2VVcmwoc2NoZW1hLCBvcHRzKSB7XG4gICAgY29uc3Qgc2NoSWQgPSB0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgc2NoZW1hW29wdHMuc2NoZW1hSWRdO1xuICAgIHJldHVybiBzY2hJZCAmJiAob3B0cy5jb2RlLnNvdXJjZSB8fCBvcHRzLmNvZGUucHJvY2VzcykgPyAoMCwgY29kZWdlbl8xLl8pIGAvKiMgc291cmNlVVJMPSR7c2NoSWR9ICovYCA6IGNvZGVnZW5fMS5uaWw7XG59XG4vLyBzY2hlbWEgY29tcGlsYXRpb24gLSB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgcmVjdXJzaXZlbHkgdG8gZ2VuZXJhdGUgY29kZSBmb3Igc3ViLXNjaGVtYXNcbmZ1bmN0aW9uIHN1YnNjaGVtYUNvZGUoaXQsIHZhbGlkKSB7XG4gICAgaWYgKGlzU2NoZW1hT2JqKGl0KSkge1xuICAgICAgICBjaGVja0tleXdvcmRzKGl0KTtcbiAgICAgICAgaWYgKHNjaGVtYUN4dEhhc1J1bGVzKGl0KSkge1xuICAgICAgICAgICAgc3ViU2NoZW1hT2JqQ29kZShpdCwgdmFsaWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgICgwLCBib29sU2NoZW1hXzEuYm9vbE9yRW1wdHlTY2hlbWEpKGl0LCB2YWxpZCk7XG59XG5mdW5jdGlvbiBzY2hlbWFDeHRIYXNSdWxlcyh7IHNjaGVtYSwgc2VsZiB9KSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiAhc2NoZW1hO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSlcbiAgICAgICAgaWYgKHNlbGYuUlVMRVMuYWxsW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1NjaGVtYU9iaihpdCkge1xuICAgIHJldHVybiB0eXBlb2YgaXQuc2NoZW1hICE9IFwiYm9vbGVhblwiO1xufVxuZnVuY3Rpb24gc3ViU2NoZW1hT2JqQ29kZShpdCwgdmFsaWQpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgZ2VuLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAob3B0cy4kY29tbWVudCAmJiBzY2hlbWEuJGNvbW1lbnQpXG4gICAgICAgIGNvbW1lbnRLZXl3b3JkKGl0KTtcbiAgICB1cGRhdGVDb250ZXh0KGl0KTtcbiAgICBjaGVja0FzeW5jU2NoZW1hKGl0KTtcbiAgICBjb25zdCBlcnJzQ291bnQgPSBnZW4uY29uc3QoXCJfZXJyc1wiLCBuYW1lc18xLmRlZmF1bHQuZXJyb3JzKTtcbiAgICB0eXBlQW5kS2V5d29yZHMoaXQsIGVycnNDb3VudCk7XG4gICAgLy8gVE9ETyB2YXJcbiAgICBnZW4udmFyKHZhbGlkLCAoMCwgY29kZWdlbl8xLl8pIGAke2VycnNDb3VudH0gPT09ICR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc31gKTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5d29yZHMoaXQpIHtcbiAgICAoMCwgdXRpbF8xLmNoZWNrVW5rbm93blJ1bGVzKShpdCk7XG4gICAgY2hlY2tSZWZzQW5kS2V5d29yZHMoaXQpO1xufVxuZnVuY3Rpb24gdHlwZUFuZEtleXdvcmRzKGl0LCBlcnJzQ291bnQpIHtcbiAgICBpZiAoaXQub3B0cy5qdGQpXG4gICAgICAgIHJldHVybiBzY2hlbWFLZXl3b3JkcyhpdCwgW10sIGZhbHNlLCBlcnJzQ291bnQpO1xuICAgIGNvbnN0IHR5cGVzID0gKDAsIGRhdGFUeXBlXzEuZ2V0U2NoZW1hVHlwZXMpKGl0LnNjaGVtYSk7XG4gICAgY29uc3QgY2hlY2tlZFR5cGVzID0gKDAsIGRhdGFUeXBlXzEuY29lcmNlQW5kQ2hlY2tEYXRhVHlwZSkoaXQsIHR5cGVzKTtcbiAgICBzY2hlbWFLZXl3b3JkcyhpdCwgdHlwZXMsICFjaGVja2VkVHlwZXMsIGVycnNDb3VudCk7XG59XG5mdW5jdGlvbiBjaGVja1JlZnNBbmRLZXl3b3JkcyhpdCkge1xuICAgIGNvbnN0IHsgc2NoZW1hLCBlcnJTY2hlbWFQYXRoLCBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hLiRyZWYgJiYgb3B0cy5pZ25vcmVLZXl3b3Jkc1dpdGhSZWYgJiYgKDAsIHV0aWxfMS5zY2hlbWFIYXNSdWxlc0J1dFJlZikoc2NoZW1hLCBzZWxmLlJVTEVTKSkge1xuICAgICAgICBzZWxmLmxvZ2dlci53YXJuKGAkcmVmOiBrZXl3b3JkcyBpZ25vcmVkIGluIHNjaGVtYSBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tOb0RlZmF1bHQoaXQpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgb3B0cyB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYS5kZWZhdWx0ICE9PSB1bmRlZmluZWQgJiYgb3B0cy51c2VEZWZhdWx0cyAmJiBvcHRzLnN0cmljdFNjaGVtYSkge1xuICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIFwiZGVmYXVsdCBpcyBpZ25vcmVkIGluIHRoZSBzY2hlbWEgcm9vdFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0KGl0KSB7XG4gICAgY29uc3Qgc2NoSWQgPSBpdC5zY2hlbWFbaXQub3B0cy5zY2hlbWFJZF07XG4gICAgaWYgKHNjaElkKVxuICAgICAgICBpdC5iYXNlSWQgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKGl0Lm9wdHMudXJpUmVzb2x2ZXIsIGl0LmJhc2VJZCwgc2NoSWQpO1xufVxuZnVuY3Rpb24gY2hlY2tBc3luY1NjaGVtYShpdCkge1xuICAgIGlmIChpdC5zY2hlbWEuJGFzeW5jICYmICFpdC5zY2hlbWFFbnYuJGFzeW5jKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBzY2hlbWEgaW4gc3luYyBzY2hlbWFcIik7XG59XG5mdW5jdGlvbiBjb21tZW50S2V5d29yZCh7IGdlbiwgc2NoZW1hRW52LCBzY2hlbWEsIGVyclNjaGVtYVBhdGgsIG9wdHMgfSkge1xuICAgIGNvbnN0IG1zZyA9IHNjaGVtYS4kY29tbWVudDtcbiAgICBpZiAob3B0cy4kY29tbWVudCA9PT0gdHJ1ZSkge1xuICAgICAgICBnZW4uY29kZSgoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5zZWxmfS5sb2dnZXIubG9nKCR7bXNnfSlgKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9wdHMuJGNvbW1lbnQgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYVBhdGggPSAoMCwgY29kZWdlbl8xLnN0cikgYCR7ZXJyU2NoZW1hUGF0aH0vJGNvbW1lbnRgO1xuICAgICAgICBjb25zdCByb290TmFtZSA9IGdlbi5zY29wZVZhbHVlKFwicm9vdFwiLCB7IHJlZjogc2NoZW1hRW52LnJvb3QgfSk7XG4gICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnNlbGZ9Lm9wdHMuJGNvbW1lbnQoJHttc2d9LCAke3NjaGVtYVBhdGh9LCAke3Jvb3ROYW1lfS5zY2hlbWEpYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmV0dXJuUmVzdWx0cyhpdCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWFFbnYsIHZhbGlkYXRlTmFtZSwgVmFsaWRhdGlvbkVycm9yLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hRW52LiRhc3luYykge1xuICAgICAgICAvLyBUT0RPIGFzc2lnbiB1bmV2YWx1YXRlZFxuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfSA9PT0gMGAsICgpID0+IGdlbi5yZXR1cm4obmFtZXNfMS5kZWZhdWx0LmRhdGEpLCAoKSA9PiBnZW4udGhyb3coKDAsIGNvZGVnZW5fMS5fKSBgbmV3ICR7VmFsaWRhdGlvbkVycm9yfSgke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfSlgKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7dmFsaWRhdGVOYW1lfS5lcnJvcnNgLCBuYW1lc18xLmRlZmF1bHQudkVycm9ycyk7XG4gICAgICAgIGlmIChvcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICAgICAgYXNzaWduRXZhbHVhdGVkKGl0KTtcbiAgICAgICAgZ2VuLnJldHVybigoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9ID09PSAwYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzaWduRXZhbHVhdGVkKHsgZ2VuLCBldmFsdWF0ZWQsIHByb3BzLCBpdGVtcyB9KSB7XG4gICAgaWYgKHByb3BzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpXG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtldmFsdWF0ZWR9LnByb3BzYCwgcHJvcHMpO1xuICAgIGlmIChpdGVtcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKVxuICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXZhbHVhdGVkfS5pdGVtc2AsIGl0ZW1zKTtcbn1cbmZ1bmN0aW9uIHNjaGVtYUtleXdvcmRzKGl0LCB0eXBlcywgdHlwZUVycm9ycywgZXJyc0NvdW50KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwgYWxsRXJyb3JzLCBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICBjb25zdCB7IFJVTEVTIH0gPSBzZWxmO1xuICAgIGlmIChzY2hlbWEuJHJlZiAmJiAob3B0cy5pZ25vcmVLZXl3b3Jkc1dpdGhSZWYgfHwgISgwLCB1dGlsXzEuc2NoZW1hSGFzUnVsZXNCdXRSZWYpKHNjaGVtYSwgUlVMRVMpKSkge1xuICAgICAgICBnZW4uYmxvY2soKCkgPT4ga2V5d29yZENvZGUoaXQsIFwiJHJlZlwiLCBSVUxFUy5hbGwuJHJlZi5kZWZpbml0aW9uKSk7IC8vIFRPRE8gdHlwZWNhc3RcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW9wdHMuanRkKVxuICAgICAgICBjaGVja1N0cmljdFR5cGVzKGl0LCB0eXBlcyk7XG4gICAgZ2VuLmJsb2NrKCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBncm91cCBvZiBSVUxFUy5ydWxlcylcbiAgICAgICAgICAgIGdyb3VwS2V5d29yZHMoZ3JvdXApO1xuICAgICAgICBncm91cEtleXdvcmRzKFJVTEVTLnBvc3QpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGdyb3VwS2V5d29yZHMoZ3JvdXApIHtcbiAgICAgICAgaWYgKCEoMCwgYXBwbGljYWJpbGl0eV8xLnNob3VsZFVzZUdyb3VwKShzY2hlbWEsIGdyb3VwKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGdyb3VwLnR5cGUpIHtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgZGF0YVR5cGVfMi5jaGVja0RhdGFUeXBlKShncm91cC50eXBlLCBkYXRhLCBvcHRzLnN0cmljdE51bWJlcnMpKTtcbiAgICAgICAgICAgIGl0ZXJhdGVLZXl3b3JkcyhpdCwgZ3JvdXApO1xuICAgICAgICAgICAgaWYgKHR5cGVzLmxlbmd0aCA9PT0gMSAmJiB0eXBlc1swXSA9PT0gZ3JvdXAudHlwZSAmJiB0eXBlRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICAgICAgICAgICAgICAoMCwgZGF0YVR5cGVfMi5yZXBvcnRUeXBlRXJyb3IpKGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbi5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0ZUtleXdvcmRzKGl0LCBncm91cCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyBtYWtlIGl0IFwib2tcIiBjYWxsP1xuICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9ID09PSAke2VycnNDb3VudCB8fCAwfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGl0ZXJhdGVLZXl3b3JkcyhpdCwgZ3JvdXApIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBvcHRzOiB7IHVzZURlZmF1bHRzIH0sIH0gPSBpdDtcbiAgICBpZiAodXNlRGVmYXVsdHMpXG4gICAgICAgICgwLCBkZWZhdWx0c18xLmFzc2lnbkRlZmF1bHRzKShpdCwgZ3JvdXAudHlwZSk7XG4gICAgZ2VuLmJsb2NrKCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBydWxlIG9mIGdyb3VwLnJ1bGVzKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGFwcGxpY2FiaWxpdHlfMS5zaG91bGRVc2VSdWxlKShzY2hlbWEsIHJ1bGUpKSB7XG4gICAgICAgICAgICAgICAga2V5d29yZENvZGUoaXQsIHJ1bGUua2V5d29yZCwgcnVsZS5kZWZpbml0aW9uLCBncm91cC50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gY2hlY2tTdHJpY3RUeXBlcyhpdCwgdHlwZXMpIHtcbiAgICBpZiAoaXQuc2NoZW1hRW52Lm1ldGEgfHwgIWl0Lm9wdHMuc3RyaWN0VHlwZXMpXG4gICAgICAgIHJldHVybjtcbiAgICBjaGVja0NvbnRleHRUeXBlcyhpdCwgdHlwZXMpO1xuICAgIGlmICghaXQub3B0cy5hbGxvd1VuaW9uVHlwZXMpXG4gICAgICAgIGNoZWNrTXVsdGlwbGVUeXBlcyhpdCwgdHlwZXMpO1xuICAgIGNoZWNrS2V5d29yZFR5cGVzKGl0LCBpdC5kYXRhVHlwZXMpO1xufVxuZnVuY3Rpb24gY2hlY2tDb250ZXh0VHlwZXMoaXQsIHR5cGVzKSB7XG4gICAgaWYgKCF0eXBlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIWl0LmRhdGFUeXBlcy5sZW5ndGgpIHtcbiAgICAgICAgaXQuZGF0YVR5cGVzID0gdHlwZXM7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHlwZXMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgICBpZiAoIWluY2x1ZGVzVHlwZShpdC5kYXRhVHlwZXMsIHQpKSB7XG4gICAgICAgICAgICBzdHJpY3RUeXBlc0Vycm9yKGl0LCBgdHlwZSBcIiR7dH1cIiBub3QgYWxsb3dlZCBieSBjb250ZXh0IFwiJHtpdC5kYXRhVHlwZXMuam9pbihcIixcIil9XCJgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIG5hcnJvd1NjaGVtYVR5cGVzKGl0LCB0eXBlcyk7XG59XG5mdW5jdGlvbiBjaGVja011bHRpcGxlVHlwZXMoaXQsIHRzKSB7XG4gICAgaWYgKHRzLmxlbmd0aCA+IDEgJiYgISh0cy5sZW5ndGggPT09IDIgJiYgdHMuaW5jbHVkZXMoXCJudWxsXCIpKSkge1xuICAgICAgICBzdHJpY3RUeXBlc0Vycm9yKGl0LCBcInVzZSBhbGxvd1VuaW9uVHlwZXMgdG8gYWxsb3cgdW5pb24gdHlwZSBrZXl3b3JkXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrS2V5d29yZFR5cGVzKGl0LCB0cykge1xuICAgIGNvbnN0IHJ1bGVzID0gaXQuc2VsZi5SVUxFUy5hbGw7XG4gICAgZm9yIChjb25zdCBrZXl3b3JkIGluIHJ1bGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSBydWxlc1trZXl3b3JkXTtcbiAgICAgICAgaWYgKHR5cGVvZiBydWxlID09IFwib2JqZWN0XCIgJiYgKDAsIGFwcGxpY2FiaWxpdHlfMS5zaG91bGRVc2VSdWxlKShpdC5zY2hlbWEsIHJ1bGUpKSB7XG4gICAgICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHJ1bGUuZGVmaW5pdGlvbjtcbiAgICAgICAgICAgIGlmICh0eXBlLmxlbmd0aCAmJiAhdHlwZS5zb21lKCh0KSA9PiBoYXNBcHBsaWNhYmxlVHlwZSh0cywgdCkpKSB7XG4gICAgICAgICAgICAgICAgc3RyaWN0VHlwZXNFcnJvcihpdCwgYG1pc3NpbmcgdHlwZSBcIiR7dHlwZS5qb2luKFwiLFwiKX1cIiBmb3Iga2V5d29yZCBcIiR7a2V5d29yZH1cImApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQXBwbGljYWJsZVR5cGUoc2NoVHMsIGt3ZFQpIHtcbiAgICByZXR1cm4gc2NoVHMuaW5jbHVkZXMoa3dkVCkgfHwgKGt3ZFQgPT09IFwibnVtYmVyXCIgJiYgc2NoVHMuaW5jbHVkZXMoXCJpbnRlZ2VyXCIpKTtcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzVHlwZSh0cywgdCkge1xuICAgIHJldHVybiB0cy5pbmNsdWRlcyh0KSB8fCAodCA9PT0gXCJpbnRlZ2VyXCIgJiYgdHMuaW5jbHVkZXMoXCJudW1iZXJcIikpO1xufVxuZnVuY3Rpb24gbmFycm93U2NoZW1hVHlwZXMoaXQsIHdpdGhUeXBlcykge1xuICAgIGNvbnN0IHRzID0gW107XG4gICAgZm9yIChjb25zdCB0IG9mIGl0LmRhdGFUeXBlcykge1xuICAgICAgICBpZiAoaW5jbHVkZXNUeXBlKHdpdGhUeXBlcywgdCkpXG4gICAgICAgICAgICB0cy5wdXNoKHQpO1xuICAgICAgICBlbHNlIGlmICh3aXRoVHlwZXMuaW5jbHVkZXMoXCJpbnRlZ2VyXCIpICYmIHQgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0cy5wdXNoKFwiaW50ZWdlclwiKTtcbiAgICB9XG4gICAgaXQuZGF0YVR5cGVzID0gdHM7XG59XG5mdW5jdGlvbiBzdHJpY3RUeXBlc0Vycm9yKGl0LCBtc2cpIHtcbiAgICBjb25zdCBzY2hlbWFQYXRoID0gaXQuc2NoZW1hRW52LmJhc2VJZCArIGl0LmVyclNjaGVtYVBhdGg7XG4gICAgbXNnICs9IGAgYXQgXCIke3NjaGVtYVBhdGh9XCIgKHN0cmljdFR5cGVzKWA7XG4gICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBtc2csIGl0Lm9wdHMuc3RyaWN0VHlwZXMpO1xufVxuY2xhc3MgS2V5d29yZEN4dCB7XG4gICAgY29uc3RydWN0b3IoaXQsIGRlZiwga2V5d29yZCkge1xuICAgICAgICAoMCwga2V5d29yZF8xLnZhbGlkYXRlS2V5d29yZFVzYWdlKShpdCwgZGVmLCBrZXl3b3JkKTtcbiAgICAgICAgdGhpcy5nZW4gPSBpdC5nZW47XG4gICAgICAgIHRoaXMuYWxsRXJyb3JzID0gaXQuYWxsRXJyb3JzO1xuICAgICAgICB0aGlzLmtleXdvcmQgPSBrZXl3b3JkO1xuICAgICAgICB0aGlzLmRhdGEgPSBpdC5kYXRhO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IGl0LnNjaGVtYVtrZXl3b3JkXTtcbiAgICAgICAgdGhpcy4kZGF0YSA9IGRlZi4kZGF0YSAmJiBpdC5vcHRzLiRkYXRhICYmIHRoaXMuc2NoZW1hICYmIHRoaXMuc2NoZW1hLiRkYXRhO1xuICAgICAgICB0aGlzLnNjaGVtYVZhbHVlID0gKDAsIHV0aWxfMS5zY2hlbWFSZWZPclZhbCkoaXQsIHRoaXMuc2NoZW1hLCBrZXl3b3JkLCB0aGlzLiRkYXRhKTtcbiAgICAgICAgdGhpcy5zY2hlbWFUeXBlID0gZGVmLnNjaGVtYVR5cGU7XG4gICAgICAgIHRoaXMucGFyZW50U2NoZW1hID0gaXQuc2NoZW1hO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHt9O1xuICAgICAgICB0aGlzLml0ID0gaXQ7XG4gICAgICAgIHRoaXMuZGVmID0gZGVmO1xuICAgICAgICBpZiAodGhpcy4kZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5zY2hlbWFDb2RlID0gaXQuZ2VuLmNvbnN0KFwidlNjaGVtYVwiLCBnZXREYXRhKHRoaXMuJGRhdGEsIGl0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVtYUNvZGUgPSB0aGlzLnNjaGVtYVZhbHVlO1xuICAgICAgICAgICAgaWYgKCEoMCwga2V5d29yZF8xLnZhbGlkU2NoZW1hVHlwZSkodGhpcy5zY2hlbWEsIGRlZi5zY2hlbWFUeXBlLCBkZWYuYWxsb3dVbmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2tleXdvcmR9IHZhbHVlIG11c3QgYmUgJHtKU09OLnN0cmluZ2lmeShkZWYuc2NoZW1hVHlwZSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiY29kZVwiIGluIGRlZiA/IGRlZi50cmFja0Vycm9ycyA6IGRlZi5lcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLmVycnNDb3VudCA9IGl0Lmdlbi5jb25zdChcIl9lcnJzXCIsIG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VsdChjb25kaXRpb24sIHN1Y2Nlc3NBY3Rpb24sIGZhaWxBY3Rpb24pIHtcbiAgICAgICAgdGhpcy5mYWlsUmVzdWx0KCgwLCBjb2RlZ2VuXzEubm90KShjb25kaXRpb24pLCBzdWNjZXNzQWN0aW9uLCBmYWlsQWN0aW9uKTtcbiAgICB9XG4gICAgZmFpbFJlc3VsdChjb25kaXRpb24sIHN1Y2Nlc3NBY3Rpb24sIGZhaWxBY3Rpb24pIHtcbiAgICAgICAgdGhpcy5nZW4uaWYoY29uZGl0aW9uKTtcbiAgICAgICAgaWYgKGZhaWxBY3Rpb24pXG4gICAgICAgICAgICBmYWlsQWN0aW9uKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3NBY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuLmVsc2UoKTtcbiAgICAgICAgICAgIHN1Y2Nlc3NBY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbEVycm9ycylcbiAgICAgICAgICAgICAgICB0aGlzLmdlbi5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuLmVuZElmKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5nZW4uZWxzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhc3MoY29uZGl0aW9uLCBmYWlsQWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZmFpbFJlc3VsdCgoMCwgY29kZWdlbl8xLm5vdCkoY29uZGl0aW9uKSwgdW5kZWZpbmVkLCBmYWlsQWN0aW9uKTtcbiAgICB9XG4gICAgZmFpbChjb25kaXRpb24pIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuLmlmKGZhbHNlKTsgLy8gdGhpcyBicmFuY2ggd2lsbCBiZSByZW1vdmVkIGJ5IGdlbi5vcHRpbWl6ZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2VuLmlmKGNvbmRpdGlvbik7XG4gICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgaWYgKHRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgdGhpcy5nZW4uZW5kSWYoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5nZW4uZWxzZSgpO1xuICAgIH1cbiAgICBmYWlsJGRhdGEoY29uZGl0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy4kZGF0YSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWwoY29uZGl0aW9uKTtcbiAgICAgICAgY29uc3QgeyBzY2hlbWFDb2RlIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmZhaWwoKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hlbWFDb2RlfSAhPT0gdW5kZWZpbmVkICYmICgkeygwLCBjb2RlZ2VuXzEub3IpKHRoaXMuaW52YWxpZCRkYXRhKCksIGNvbmRpdGlvbil9KWApO1xuICAgIH1cbiAgICBlcnJvcihhcHBlbmQsIGVycm9yUGFyYW1zLCBlcnJvclBhdGhzKSB7XG4gICAgICAgIGlmIChlcnJvclBhcmFtcykge1xuICAgICAgICAgICAgdGhpcy5zZXRQYXJhbXMoZXJyb3JQYXJhbXMpO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IoYXBwZW5kLCBlcnJvclBhdGhzKTtcbiAgICAgICAgICAgIHRoaXMuc2V0UGFyYW1zKHt9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lcnJvcihhcHBlbmQsIGVycm9yUGF0aHMpO1xuICAgIH1cbiAgICBfZXJyb3IoYXBwZW5kLCBlcnJvclBhdGhzKSB7XG4gICAgICAgIDtcbiAgICAgICAgKGFwcGVuZCA/IGVycm9yc18xLnJlcG9ydEV4dHJhRXJyb3IgOiBlcnJvcnNfMS5yZXBvcnRFcnJvcikodGhpcywgdGhpcy5kZWYuZXJyb3IsIGVycm9yUGF0aHMpO1xuICAgIH1cbiAgICAkZGF0YUVycm9yKCkge1xuICAgICAgICAoMCwgZXJyb3JzXzEucmVwb3J0RXJyb3IpKHRoaXMsIHRoaXMuZGVmLiRkYXRhRXJyb3IgfHwgZXJyb3JzXzEua2V5d29yZCREYXRhRXJyb3IpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyc0NvdW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZCBcInRyYWNrRXJyb3JzXCIgdG8ga2V5d29yZCBkZWZpbml0aW9uJyk7XG4gICAgICAgICgwLCBlcnJvcnNfMS5yZXNldEVycm9yc0NvdW50KSh0aGlzLmdlbiwgdGhpcy5lcnJzQ291bnQpO1xuICAgIH1cbiAgICBvayhjb25kKSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICB0aGlzLmdlbi5pZihjb25kKTtcbiAgICB9XG4gICAgc2V0UGFyYW1zKG9iaiwgYXNzaWduKSB7XG4gICAgICAgIGlmIChhc3NpZ24pXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMucGFyYW1zLCBvYmopO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnBhcmFtcyA9IG9iajtcbiAgICB9XG4gICAgYmxvY2skZGF0YSh2YWxpZCwgY29kZUJsb2NrLCAkZGF0YVZhbGlkID0gY29kZWdlbl8xLm5pbCkge1xuICAgICAgICB0aGlzLmdlbi5ibG9jaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrJGRhdGEodmFsaWQsICRkYXRhVmFsaWQpO1xuICAgICAgICAgICAgY29kZUJsb2NrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjaGVjayRkYXRhKHZhbGlkID0gY29kZWdlbl8xLm5pbCwgJGRhdGFWYWxpZCA9IGNvZGVnZW5fMS5uaWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRkYXRhKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hQ29kZSwgc2NoZW1hVHlwZSwgZGVmIH0gPSB0aGlzO1xuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5vcikoKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hlbWFDb2RlfSA9PT0gdW5kZWZpbmVkYCwgJGRhdGFWYWxpZCkpO1xuICAgICAgICBpZiAodmFsaWQgIT09IGNvZGVnZW5fMS5uaWwpXG4gICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgaWYgKHNjaGVtYVR5cGUubGVuZ3RoIHx8IGRlZi52YWxpZGF0ZVNjaGVtYSkge1xuICAgICAgICAgICAgZ2VuLmVsc2VJZih0aGlzLmludmFsaWQkZGF0YSgpKTtcbiAgICAgICAgICAgIHRoaXMuJGRhdGFFcnJvcigpO1xuICAgICAgICAgICAgaWYgKHZhbGlkICE9PSBjb2RlZ2VuXzEubmlsKVxuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBnZW4uZWxzZSgpO1xuICAgIH1cbiAgICBpbnZhbGlkJGRhdGEoKSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWFDb2RlLCBzY2hlbWFUeXBlLCBkZWYsIGl0IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5vcikod3JvbmckRGF0YVR5cGUoKSwgaW52YWxpZCREYXRhU2NoZW1hKCkpO1xuICAgICAgICBmdW5jdGlvbiB3cm9uZyREYXRhVHlwZSgpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWFUeXBlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICghKHNjaGVtYUNvZGUgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdCA9IEFycmF5LmlzQXJyYXkoc2NoZW1hVHlwZSkgPyBzY2hlbWFUeXBlIDogW3NjaGVtYVR5cGVdO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAkeygwLCBkYXRhVHlwZV8yLmNoZWNrRGF0YVR5cGVzKShzdCwgc2NoZW1hQ29kZSwgaXQub3B0cy5zdHJpY3ROdW1iZXJzLCBkYXRhVHlwZV8yLkRhdGFUeXBlLldyb25nKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5uaWw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW52YWxpZCREYXRhU2NoZW1hKCkge1xuICAgICAgICAgICAgaWYgKGRlZi52YWxpZGF0ZVNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRlU2NoZW1hUmVmID0gZ2VuLnNjb3BlVmFsdWUoXCJ2YWxpZGF0ZSRkYXRhXCIsIHsgcmVmOiBkZWYudmFsaWRhdGVTY2hlbWEgfSk7IC8vIFRPRE8gdmFsdWUuY29kZSBmb3Igc3RhbmRhbG9uZVxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAhJHt2YWxpZGF0ZVNjaGVtYVJlZn0oJHtzY2hlbWFDb2RlfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5uaWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Vic2NoZW1hKGFwcGwsIHZhbGlkKSB7XG4gICAgICAgIGNvbnN0IHN1YnNjaGVtYSA9ICgwLCBzdWJzY2hlbWFfMS5nZXRTdWJzY2hlbWEpKHRoaXMuaXQsIGFwcGwpO1xuICAgICAgICAoMCwgc3Vic2NoZW1hXzEuZXh0ZW5kU3Vic2NoZW1hRGF0YSkoc3Vic2NoZW1hLCB0aGlzLml0LCBhcHBsKTtcbiAgICAgICAgKDAsIHN1YnNjaGVtYV8xLmV4dGVuZFN1YnNjaGVtYU1vZGUpKHN1YnNjaGVtYSwgYXBwbCk7XG4gICAgICAgIGNvbnN0IG5leHRDb250ZXh0ID0geyAuLi50aGlzLml0LCAuLi5zdWJzY2hlbWEsIGl0ZW1zOiB1bmRlZmluZWQsIHByb3BzOiB1bmRlZmluZWQgfTtcbiAgICAgICAgc3Vic2NoZW1hQ29kZShuZXh0Q29udGV4dCwgdmFsaWQpO1xuICAgICAgICByZXR1cm4gbmV4dENvbnRleHQ7XG4gICAgfVxuICAgIG1lcmdlRXZhbHVhdGVkKHNjaGVtYUN4dCwgdG9OYW1lKSB7XG4gICAgICAgIGNvbnN0IHsgaXQsIGdlbiB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFpdC5vcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoaXQucHJvcHMgIT09IHRydWUgJiYgc2NoZW1hQ3h0LnByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgc2NoZW1hQ3h0LnByb3BzLCBpdC5wcm9wcywgdG9OYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQuaXRlbXMgIT09IHRydWUgJiYgc2NoZW1hQ3h0Lml0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgc2NoZW1hQ3h0Lml0ZW1zLCBpdC5pdGVtcywgdG9OYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtZXJnZVZhbGlkRXZhbHVhdGVkKHNjaGVtYUN4dCwgdmFsaWQpIHtcbiAgICAgICAgY29uc3QgeyBpdCwgZ2VuIH0gPSB0aGlzO1xuICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiAoaXQucHJvcHMgIT09IHRydWUgfHwgaXQuaXRlbXMgIT09IHRydWUpKSB7XG4gICAgICAgICAgICBnZW4uaWYodmFsaWQsICgpID0+IHRoaXMubWVyZ2VFdmFsdWF0ZWQoc2NoZW1hQ3h0LCBjb2RlZ2VuXzEuTmFtZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLktleXdvcmRDeHQgPSBLZXl3b3JkQ3h0O1xuZnVuY3Rpb24ga2V5d29yZENvZGUoaXQsIGtleXdvcmQsIGRlZiwgcnVsZVR5cGUpIHtcbiAgICBjb25zdCBjeHQgPSBuZXcgS2V5d29yZEN4dChpdCwgZGVmLCBrZXl3b3JkKTtcbiAgICBpZiAoXCJjb2RlXCIgaW4gZGVmKSB7XG4gICAgICAgIGRlZi5jb2RlKGN4dCwgcnVsZVR5cGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjeHQuJGRhdGEgJiYgZGVmLnZhbGlkYXRlKSB7XG4gICAgICAgICgwLCBrZXl3b3JkXzEuZnVuY0tleXdvcmRDb2RlKShjeHQsIGRlZik7XG4gICAgfVxuICAgIGVsc2UgaWYgKFwibWFjcm9cIiBpbiBkZWYpIHtcbiAgICAgICAgKDAsIGtleXdvcmRfMS5tYWNyb0tleXdvcmRDb2RlKShjeHQsIGRlZik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlZi5jb21waWxlIHx8IGRlZi52YWxpZGF0ZSkge1xuICAgICAgICAoMCwga2V5d29yZF8xLmZ1bmNLZXl3b3JkQ29kZSkoY3h0LCBkZWYpO1xuICAgIH1cbn1cbmNvbnN0IEpTT05fUE9JTlRFUiA9IC9eXFwvKD86W15+XXx+MHx+MSkqJC87XG5jb25zdCBSRUxBVElWRV9KU09OX1BPSU5URVIgPSAvXihbMC05XSspKCN8XFwvKD86W15+XXx+MHx+MSkqKT8kLztcbmZ1bmN0aW9uIGdldERhdGEoJGRhdGEsIHsgZGF0YUxldmVsLCBkYXRhTmFtZXMsIGRhdGFQYXRoQXJyIH0pIHtcbiAgICBsZXQganNvblBvaW50ZXI7XG4gICAgbGV0IGRhdGE7XG4gICAgaWYgKCRkYXRhID09PSBcIlwiKVxuICAgICAgICByZXR1cm4gbmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhO1xuICAgIGlmICgkZGF0YVswXSA9PT0gXCIvXCIpIHtcbiAgICAgICAgaWYgKCFKU09OX1BPSU5URVIudGVzdCgkZGF0YSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSlNPTi1wb2ludGVyOiAkeyRkYXRhfWApO1xuICAgICAgICBqc29uUG9pbnRlciA9ICRkYXRhO1xuICAgICAgICBkYXRhID0gbmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IFJFTEFUSVZFX0pTT05fUE9JTlRFUi5leGVjKCRkYXRhKTtcbiAgICAgICAgaWYgKCFtYXRjaGVzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEpTT04tcG9pbnRlcjogJHskZGF0YX1gKTtcbiAgICAgICAgY29uc3QgdXAgPSArbWF0Y2hlc1sxXTtcbiAgICAgICAganNvblBvaW50ZXIgPSBtYXRjaGVzWzJdO1xuICAgICAgICBpZiAoanNvblBvaW50ZXIgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICBpZiAodXAgPj0gZGF0YUxldmVsKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyhcInByb3BlcnR5L2luZGV4XCIsIHVwKSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVBhdGhBcnJbZGF0YUxldmVsIC0gdXBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cCA+IGRhdGFMZXZlbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyhcImRhdGFcIiwgdXApKTtcbiAgICAgICAgZGF0YSA9IGRhdGFOYW1lc1tkYXRhTGV2ZWwgLSB1cF07XG4gICAgICAgIGlmICghanNvblBvaW50ZXIpXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgbGV0IGV4cHIgPSBkYXRhO1xuICAgIGNvbnN0IHNlZ21lbnRzID0ganNvblBvaW50ZXIuc3BsaXQoXCIvXCIpO1xuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICAgICAgZGF0YSA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKCgwLCB1dGlsXzEudW5lc2NhcGVKc29uUG9pbnRlcikoc2VnbWVudCkpfWA7XG4gICAgICAgICAgICBleHByID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtleHByfSAmJiAke2RhdGF9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwcjtcbiAgICBmdW5jdGlvbiBlcnJvck1zZyhwb2ludGVyVHlwZSwgdXApIHtcbiAgICAgICAgcmV0dXJuIGBDYW5ub3QgYWNjZXNzICR7cG9pbnRlclR5cGV9ICR7dXB9IGxldmVscyB1cCwgY3VycmVudCBsZXZlbCBpcyAke2RhdGFMZXZlbH1gO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0RGF0YSA9IGdldERhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFZhbGlkYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvcnMpIHtcbiAgICAgICAgc3VwZXIoXCJ2YWxpZGF0aW9uIGZhaWxlZFwiKTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHRoaXMuYWp2ID0gdGhpcy52YWxpZGF0aW9uID0gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBWYWxpZGF0aW9uRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0aW9uX2Vycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcmVzb2x2ZV8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZVwiKTtcbmNsYXNzIE1pc3NpbmdSZWZFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNvbHZlciwgYmFzZUlkLCByZWYsIG1zZykge1xuICAgICAgICBzdXBlcihtc2cgfHwgYGNhbid0IHJlc29sdmUgcmVmZXJlbmNlICR7cmVmfSBmcm9tIGlkICR7YmFzZUlkfWApO1xuICAgICAgICB0aGlzLm1pc3NpbmdSZWYgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKHJlc29sdmVyLCBiYXNlSWQsIHJlZik7XG4gICAgICAgIHRoaXMubWlzc2luZ1NjaGVtYSA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKCgwLCByZXNvbHZlXzEuZ2V0RnVsbFBhdGgpKHJlc29sdmVyLCB0aGlzLm1pc3NpbmdSZWYpKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBNaXNzaW5nUmVmRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWZfZXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlc29sdmVTY2hlbWEgPSBleHBvcnRzLmdldENvbXBpbGluZ1NjaGVtYSA9IGV4cG9ydHMucmVzb2x2ZVJlZiA9IGV4cG9ydHMuY29tcGlsZVNjaGVtYSA9IGV4cG9ydHMuU2NoZW1hRW52ID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4vY29kZWdlblwiKTtcbmNvbnN0IHZhbGlkYXRpb25fZXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4vbmFtZXNcIik7XG5jb25zdCByZXNvbHZlXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi92YWxpZGF0ZVwiKTtcbmNsYXNzIFNjaGVtYUVudiB7XG4gICAgY29uc3RydWN0b3IoZW52KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5yZWZzID0ge307XG4gICAgICAgIHRoaXMuZHluYW1pY0FuY2hvcnMgPSB7fTtcbiAgICAgICAgbGV0IHNjaGVtYTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnYuc2NoZW1hID09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICBzY2hlbWEgPSBlbnYuc2NoZW1hO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IGVudi5zY2hlbWE7XG4gICAgICAgIHRoaXMuc2NoZW1hSWQgPSBlbnYuc2NoZW1hSWQ7XG4gICAgICAgIHRoaXMucm9vdCA9IGVudi5yb290IHx8IHRoaXM7XG4gICAgICAgIHRoaXMuYmFzZUlkID0gKF9hID0gZW52LmJhc2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoc2NoZW1hID09PSBudWxsIHx8IHNjaGVtYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoZW1hW2Vudi5zY2hlbWFJZCB8fCBcIiRpZFwiXSk7XG4gICAgICAgIHRoaXMuc2NoZW1hUGF0aCA9IGVudi5zY2hlbWFQYXRoO1xuICAgICAgICB0aGlzLmxvY2FsUmVmcyA9IGVudi5sb2NhbFJlZnM7XG4gICAgICAgIHRoaXMubWV0YSA9IGVudi5tZXRhO1xuICAgICAgICB0aGlzLiRhc3luYyA9IHNjaGVtYSA9PT0gbnVsbCB8fCBzY2hlbWEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaGVtYS4kYXN5bmM7XG4gICAgICAgIHRoaXMucmVmcyA9IHt9O1xuICAgIH1cbn1cbmV4cG9ydHMuU2NoZW1hRW52ID0gU2NoZW1hRW52O1xuLy8gbGV0IGNvZGVTaXplID0gMFxuLy8gbGV0IG5vZGVDb3VudCA9IDBcbi8vIENvbXBpbGVzIHNjaGVtYSBpbiBTY2hlbWFFbnZcbmZ1bmN0aW9uIGNvbXBpbGVTY2hlbWEoc2NoKSB7XG4gICAgLy8gVE9ETyByZWZhY3RvciAtIHJlbW92ZSBjb21waWxhdGlvbnNcbiAgICBjb25zdCBfc2NoID0gZ2V0Q29tcGlsaW5nU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbiAgICBpZiAoX3NjaClcbiAgICAgICAgcmV0dXJuIF9zY2g7XG4gICAgY29uc3Qgcm9vdElkID0gKDAsIHJlc29sdmVfMS5nZXRGdWxsUGF0aCkodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBzY2gucm9vdC5iYXNlSWQpOyAvLyBUT0RPIGlmIGdldEZ1bGxQYXRoIHJlbW92ZWQgMSB0ZXN0cyBmYWlsc1xuICAgIGNvbnN0IHsgZXM1LCBsaW5lcyB9ID0gdGhpcy5vcHRzLmNvZGU7XG4gICAgY29uc3QgeyBvd25Qcm9wZXJ0aWVzIH0gPSB0aGlzLm9wdHM7XG4gICAgY29uc3QgZ2VuID0gbmV3IGNvZGVnZW5fMS5Db2RlR2VuKHRoaXMuc2NvcGUsIHsgZXM1LCBsaW5lcywgb3duUHJvcGVydGllcyB9KTtcbiAgICBsZXQgX1ZhbGlkYXRpb25FcnJvcjtcbiAgICBpZiAoc2NoLiRhc3luYykge1xuICAgICAgICBfVmFsaWRhdGlvbkVycm9yID0gZ2VuLnNjb3BlVmFsdWUoXCJFcnJvclwiLCB7XG4gICAgICAgICAgICByZWY6IHZhbGlkYXRpb25fZXJyb3JfMS5kZWZhdWx0LFxuICAgICAgICAgICAgY29kZTogKDAsIGNvZGVnZW5fMS5fKSBgcmVxdWlyZShcImFqdi9kaXN0L3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiKS5kZWZhdWx0YCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkYXRlTmFtZSA9IGdlbi5zY29wZU5hbWUoXCJ2YWxpZGF0ZVwiKTtcbiAgICBzY2gudmFsaWRhdGVOYW1lID0gdmFsaWRhdGVOYW1lO1xuICAgIGNvbnN0IHNjaGVtYUN4dCA9IHtcbiAgICAgICAgZ2VuLFxuICAgICAgICBhbGxFcnJvcnM6IHRoaXMub3B0cy5hbGxFcnJvcnMsXG4gICAgICAgIGRhdGE6IG5hbWVzXzEuZGVmYXVsdC5kYXRhLFxuICAgICAgICBwYXJlbnREYXRhOiBuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YSxcbiAgICAgICAgcGFyZW50RGF0YVByb3BlcnR5OiBuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5LFxuICAgICAgICBkYXRhTmFtZXM6IFtuYW1lc18xLmRlZmF1bHQuZGF0YV0sXG4gICAgICAgIGRhdGFQYXRoQXJyOiBbY29kZWdlbl8xLm5pbF0sXG4gICAgICAgIGRhdGFMZXZlbDogMCxcbiAgICAgICAgZGF0YVR5cGVzOiBbXSxcbiAgICAgICAgZGVmaW5lZFByb3BlcnRpZXM6IG5ldyBTZXQoKSxcbiAgICAgICAgdG9wU2NoZW1hUmVmOiBnZW4uc2NvcGVWYWx1ZShcInNjaGVtYVwiLCB0aGlzLm9wdHMuY29kZS5zb3VyY2UgPT09IHRydWVcbiAgICAgICAgICAgID8geyByZWY6IHNjaC5zY2hlbWEsIGNvZGU6ICgwLCBjb2RlZ2VuXzEuc3RyaW5naWZ5KShzY2guc2NoZW1hKSB9XG4gICAgICAgICAgICA6IHsgcmVmOiBzY2guc2NoZW1hIH0pLFxuICAgICAgICB2YWxpZGF0ZU5hbWUsXG4gICAgICAgIFZhbGlkYXRpb25FcnJvcjogX1ZhbGlkYXRpb25FcnJvcixcbiAgICAgICAgc2NoZW1hOiBzY2guc2NoZW1hLFxuICAgICAgICBzY2hlbWFFbnY6IHNjaCxcbiAgICAgICAgcm9vdElkLFxuICAgICAgICBiYXNlSWQ6IHNjaC5iYXNlSWQgfHwgcm9vdElkLFxuICAgICAgICBzY2hlbWFQYXRoOiBjb2RlZ2VuXzEubmlsLFxuICAgICAgICBlcnJTY2hlbWFQYXRoOiBzY2guc2NoZW1hUGF0aCB8fCAodGhpcy5vcHRzLmp0ZCA/IFwiXCIgOiBcIiNcIiksXG4gICAgICAgIGVycm9yUGF0aDogKDAsIGNvZGVnZW5fMS5fKSBgXCJcImAsXG4gICAgICAgIG9wdHM6IHRoaXMub3B0cyxcbiAgICAgICAgc2VsZjogdGhpcyxcbiAgICB9O1xuICAgIGxldCBzb3VyY2VDb2RlO1xuICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGF0aW9ucy5hZGQoc2NoKTtcbiAgICAgICAgKDAsIHZhbGlkYXRlXzEudmFsaWRhdGVGdW5jdGlvbkNvZGUpKHNjaGVtYUN4dCk7XG4gICAgICAgIGdlbi5vcHRpbWl6ZSh0aGlzLm9wdHMuY29kZS5vcHRpbWl6ZSk7XG4gICAgICAgIC8vIGdlbi5vcHRpbWl6ZSgxKVxuICAgICAgICBjb25zdCB2YWxpZGF0ZUNvZGUgPSBnZW4udG9TdHJpbmcoKTtcbiAgICAgICAgc291cmNlQ29kZSA9IGAke2dlbi5zY29wZVJlZnMobmFtZXNfMS5kZWZhdWx0LnNjb3BlKX1yZXR1cm4gJHt2YWxpZGF0ZUNvZGV9YDtcbiAgICAgICAgLy8gY29uc29sZS5sb2coKGNvZGVTaXplICs9IHNvdXJjZUNvZGUubGVuZ3RoKSwgKG5vZGVDb3VudCArPSBnZW4ubm9kZUNvdW50KSlcbiAgICAgICAgaWYgKHRoaXMub3B0cy5jb2RlLnByb2Nlc3MpXG4gICAgICAgICAgICBzb3VyY2VDb2RlID0gdGhpcy5vcHRzLmNvZGUucHJvY2Vzcyhzb3VyY2VDb2RlLCBzY2gpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlxcblxcblxcbiAqKiogXFxuXCIsIHNvdXJjZUNvZGUpXG4gICAgICAgIGNvbnN0IG1ha2VWYWxpZGF0ZSA9IG5ldyBGdW5jdGlvbihgJHtuYW1lc18xLmRlZmF1bHQuc2VsZn1gLCBgJHtuYW1lc18xLmRlZmF1bHQuc2NvcGV9YCwgc291cmNlQ29kZSk7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlID0gbWFrZVZhbGlkYXRlKHRoaXMsIHRoaXMuc2NvcGUuZ2V0KCkpO1xuICAgICAgICB0aGlzLnNjb3BlLnZhbHVlKHZhbGlkYXRlTmFtZSwgeyByZWY6IHZhbGlkYXRlIH0pO1xuICAgICAgICB2YWxpZGF0ZS5lcnJvcnMgPSBudWxsO1xuICAgICAgICB2YWxpZGF0ZS5zY2hlbWEgPSBzY2guc2NoZW1hO1xuICAgICAgICB2YWxpZGF0ZS5zY2hlbWFFbnYgPSBzY2g7XG4gICAgICAgIGlmIChzY2guJGFzeW5jKVxuICAgICAgICAgICAgdmFsaWRhdGUuJGFzeW5jID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5jb2RlLnNvdXJjZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFsaWRhdGUuc291cmNlID0geyB2YWxpZGF0ZU5hbWUsIHZhbGlkYXRlQ29kZSwgc2NvcGVWYWx1ZXM6IGdlbi5fdmFsdWVzIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0cy51bmV2YWx1YXRlZCkge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wcywgaXRlbXMgfSA9IHNjaGVtYUN4dDtcbiAgICAgICAgICAgIHZhbGlkYXRlLmV2YWx1YXRlZCA9IHtcbiAgICAgICAgICAgICAgICBwcm9wczogcHJvcHMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSA/IHVuZGVmaW5lZCA6IHByb3BzLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBpdGVtcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lID8gdW5kZWZpbmVkIDogaXRlbXMsXG4gICAgICAgICAgICAgICAgZHluYW1pY1Byb3BzOiBwcm9wcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lLFxuICAgICAgICAgICAgICAgIGR5bmFtaWNJdGVtczogaXRlbXMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodmFsaWRhdGUuc291cmNlKVxuICAgICAgICAgICAgICAgIHZhbGlkYXRlLnNvdXJjZS5ldmFsdWF0ZWQgPSAoMCwgY29kZWdlbl8xLnN0cmluZ2lmeSkodmFsaWRhdGUuZXZhbHVhdGVkKTtcbiAgICAgICAgfVxuICAgICAgICBzY2gudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbiAgICAgICAgcmV0dXJuIHNjaDtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVsZXRlIHNjaC52YWxpZGF0ZTtcbiAgICAgICAgZGVsZXRlIHNjaC52YWxpZGF0ZU5hbWU7XG4gICAgICAgIGlmIChzb3VyY2VDb2RlKVxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJFcnJvciBjb21waWxpbmcgc2NoZW1hLCBmdW5jdGlvbiBjb2RlOlwiLCBzb3VyY2VDb2RlKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJcXG5cXG5cXG4gKioqIFxcblwiLCBzb3VyY2VDb2RlLCB0aGlzLm9wdHMpXG4gICAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0aGlzLl9jb21waWxhdGlvbnMuZGVsZXRlKHNjaCk7XG4gICAgfVxufVxuZXhwb3J0cy5jb21waWxlU2NoZW1hID0gY29tcGlsZVNjaGVtYTtcbmZ1bmN0aW9uIHJlc29sdmVSZWYocm9vdCwgYmFzZUlkLCByZWYpIHtcbiAgICB2YXIgX2E7XG4gICAgcmVmID0gKDAsIHJlc29sdmVfMS5yZXNvbHZlVXJsKSh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgcmVmKTtcbiAgICBjb25zdCBzY2hPckZ1bmMgPSByb290LnJlZnNbcmVmXTtcbiAgICBpZiAoc2NoT3JGdW5jKVxuICAgICAgICByZXR1cm4gc2NoT3JGdW5jO1xuICAgIGxldCBfc2NoID0gcmVzb2x2ZS5jYWxsKHRoaXMsIHJvb3QsIHJlZik7XG4gICAgaWYgKF9zY2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSAoX2EgPSByb290LmxvY2FsUmVmcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3JlZl07IC8vIFRPRE8gbWF5YmUgbG9jYWxSZWZzIHNob3VsZCBob2xkIFNjaGVtYUVudlxuICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIGlmIChzY2hlbWEpXG4gICAgICAgICAgICBfc2NoID0gbmV3IFNjaGVtYUVudih7IHNjaGVtYSwgc2NoZW1hSWQsIHJvb3QsIGJhc2VJZCB9KTtcbiAgICB9XG4gICAgaWYgKF9zY2ggPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIHJldHVybiAocm9vdC5yZWZzW3JlZl0gPSBpbmxpbmVPckNvbXBpbGUuY2FsbCh0aGlzLCBfc2NoKSk7XG59XG5leHBvcnRzLnJlc29sdmVSZWYgPSByZXNvbHZlUmVmO1xuZnVuY3Rpb24gaW5saW5lT3JDb21waWxlKHNjaCkge1xuICAgIGlmICgoMCwgcmVzb2x2ZV8xLmlubGluZVJlZikoc2NoLnNjaGVtYSwgdGhpcy5vcHRzLmlubGluZVJlZnMpKVxuICAgICAgICByZXR1cm4gc2NoLnNjaGVtYTtcbiAgICByZXR1cm4gc2NoLnZhbGlkYXRlID8gc2NoIDogY29tcGlsZVNjaGVtYS5jYWxsKHRoaXMsIHNjaCk7XG59XG4vLyBJbmRleCBvZiBzY2hlbWEgY29tcGlsYXRpb24gaW4gdGhlIGN1cnJlbnRseSBjb21waWxlZCBsaXN0XG5mdW5jdGlvbiBnZXRDb21waWxpbmdTY2hlbWEoc2NoRW52KSB7XG4gICAgZm9yIChjb25zdCBzY2ggb2YgdGhpcy5fY29tcGlsYXRpb25zKSB7XG4gICAgICAgIGlmIChzYW1lU2NoZW1hRW52KHNjaCwgc2NoRW52KSlcbiAgICAgICAgICAgIHJldHVybiBzY2g7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRDb21waWxpbmdTY2hlbWEgPSBnZXRDb21waWxpbmdTY2hlbWE7XG5mdW5jdGlvbiBzYW1lU2NoZW1hRW52KHMxLCBzMikge1xuICAgIHJldHVybiBzMS5zY2hlbWEgPT09IHMyLnNjaGVtYSAmJiBzMS5yb290ID09PSBzMi5yb290ICYmIHMxLmJhc2VJZCA9PT0gczIuYmFzZUlkO1xufVxuLy8gcmVzb2x2ZSBhbmQgY29tcGlsZSB0aGUgcmVmZXJlbmNlcyAoJHJlZilcbi8vIFRPRE8gcmV0dXJucyBBbnlTY2hlbWFPYmplY3QgKGlmIHRoZSBzY2hlbWEgY2FuIGJlIGlubGluZWQpIG9yIHZhbGlkYXRpb24gZnVuY3Rpb25cbmZ1bmN0aW9uIHJlc29sdmUocm9vdCwgLy8gaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJvb3Qgc2NoZW1hIGZvciB0aGUgY3VycmVudCBzY2hlbWFcbnJlZiAvLyByZWZlcmVuY2UgdG8gcmVzb2x2ZVxuKSB7XG4gICAgbGV0IHNjaDtcbiAgICB3aGlsZSAodHlwZW9mIChzY2ggPSB0aGlzLnJlZnNbcmVmXSkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmVmID0gc2NoO1xuICAgIHJldHVybiBzY2ggfHwgdGhpcy5zY2hlbWFzW3JlZl0gfHwgcmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsIHJlZik7XG59XG4vLyBSZXNvbHZlIHNjaGVtYSwgaXRzIHJvb3QgYW5kIGJhc2VJZFxuZnVuY3Rpb24gcmVzb2x2ZVNjaGVtYShyb290LCAvLyByb290IG9iamVjdCB3aXRoIHByb3BlcnRpZXMgc2NoZW1hLCByZWZzIFRPRE8gYmVsb3cgU2NoZW1hRW52IGlzIGFzc2lnbmVkIHRvIGl0XG5yZWYgLy8gcmVmZXJlbmNlIHRvIHJlc29sdmVcbikge1xuICAgIGNvbnN0IHAgPSB0aGlzLm9wdHMudXJpUmVzb2x2ZXIucGFyc2UocmVmKTtcbiAgICBjb25zdCByZWZQYXRoID0gKDAsIHJlc29sdmVfMS5fZ2V0RnVsbFBhdGgpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgcCk7XG4gICAgbGV0IGJhc2VJZCA9ICgwLCByZXNvbHZlXzEuZ2V0RnVsbFBhdGgpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgcm9vdC5iYXNlSWQsIHVuZGVmaW5lZCk7XG4gICAgLy8gVE9ETyBgT2JqZWN0LmtleXMocm9vdC5zY2hlbWEpLmxlbmd0aCA+IDBgIHNob3VsZCBub3QgYmUgbmVlZGVkIC0gYnV0IHJlbW92aW5nIGJyZWFrcyAyIHRlc3RzXG4gICAgaWYgKE9iamVjdC5rZXlzKHJvb3Quc2NoZW1hKS5sZW5ndGggPiAwICYmIHJlZlBhdGggPT09IGJhc2VJZCkge1xuICAgICAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCByb290KTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSAoMCwgcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKShyZWZQYXRoKTtcbiAgICBjb25zdCBzY2hPclJlZiA9IHRoaXMucmVmc1tpZF0gfHwgdGhpcy5zY2hlbWFzW2lkXTtcbiAgICBpZiAodHlwZW9mIHNjaE9yUmVmID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3Qgc2NoID0gcmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsIHNjaE9yUmVmKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoc2NoID09PSBudWxsIHx8IHNjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoLnNjaGVtYSkgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiBnZXRKc29uUG9pbnRlci5jYWxsKHRoaXMsIHAsIHNjaCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHNjaE9yUmVmID09PSBudWxsIHx8IHNjaE9yUmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2hPclJlZi5zY2hlbWEpICE9PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCFzY2hPclJlZi52YWxpZGF0ZSlcbiAgICAgICAgY29tcGlsZVNjaGVtYS5jYWxsKHRoaXMsIHNjaE9yUmVmKTtcbiAgICBpZiAoaWQgPT09ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKHJlZikpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEgfSA9IHNjaE9yUmVmO1xuICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIGNvbnN0IHNjaElkID0gc2NoZW1hW3NjaGVtYUlkXTtcbiAgICAgICAgaWYgKHNjaElkKVxuICAgICAgICAgICAgYmFzZUlkID0gKDAsIHJlc29sdmVfMS5yZXNvbHZlVXJsKSh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgc2NoSWQpO1xuICAgICAgICByZXR1cm4gbmV3IFNjaGVtYUVudih7IHNjaGVtYSwgc2NoZW1hSWQsIHJvb3QsIGJhc2VJZCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcCwgc2NoT3JSZWYpO1xufVxuZXhwb3J0cy5yZXNvbHZlU2NoZW1hID0gcmVzb2x2ZVNjaGVtYTtcbmNvbnN0IFBSRVZFTlRfU0NPUEVfQ0hBTkdFID0gbmV3IFNldChbXG4gICAgXCJwcm9wZXJ0aWVzXCIsXG4gICAgXCJwYXR0ZXJuUHJvcGVydGllc1wiLFxuICAgIFwiZW51bVwiLFxuICAgIFwiZGVwZW5kZW5jaWVzXCIsXG4gICAgXCJkZWZpbml0aW9uc1wiLFxuXSk7XG5mdW5jdGlvbiBnZXRKc29uUG9pbnRlcihwYXJzZWRSZWYsIHsgYmFzZUlkLCBzY2hlbWEsIHJvb3QgfSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoKChfYSA9IHBhcnNlZFJlZi5mcmFnbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSAhPT0gXCIvXCIpXG4gICAgICAgIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFyc2VkUmVmLmZyYWdtZW50LnNsaWNlKDEpLnNwbGl0KFwiL1wiKSkge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHBhcnRTY2hlbWEgPSBzY2hlbWFbKDAsIHV0aWxfMS51bmVzY2FwZUZyYWdtZW50KShwYXJ0KV07XG4gICAgICAgIGlmIChwYXJ0U2NoZW1hID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNjaGVtYSA9IHBhcnRTY2hlbWE7XG4gICAgICAgIC8vIFRPRE8gUFJFVkVOVF9TQ09QRV9DSEFOR0UgY291bGQgYmUgZGVmaW5lZCBpbiBrZXl3b3JkIGRlZj9cbiAgICAgICAgY29uc3Qgc2NoSWQgPSB0eXBlb2Ygc2NoZW1hID09PSBcIm9iamVjdFwiICYmIHNjaGVtYVt0aGlzLm9wdHMuc2NoZW1hSWRdO1xuICAgICAgICBpZiAoIVBSRVZFTlRfU0NPUEVfQ0hBTkdFLmhhcyhwYXJ0KSAmJiBzY2hJZCkge1xuICAgICAgICAgICAgYmFzZUlkID0gKDAsIHJlc29sdmVfMS5yZXNvbHZlVXJsKSh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgc2NoSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBlbnY7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgIT0gXCJib29sZWFuXCIgJiYgc2NoZW1hLiRyZWYgJiYgISgwLCB1dGlsXzEuc2NoZW1hSGFzUnVsZXNCdXRSZWYpKHNjaGVtYSwgdGhpcy5SVUxFUykpIHtcbiAgICAgICAgY29uc3QgJHJlZiA9ICgwLCByZXNvbHZlXzEucmVzb2x2ZVVybCkodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBiYXNlSWQsIHNjaGVtYS4kcmVmKTtcbiAgICAgICAgZW52ID0gcmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsICRyZWYpO1xuICAgIH1cbiAgICAvLyBldmVuIHRob3VnaCByZXNvbHV0aW9uIGZhaWxlZCB3ZSBuZWVkIHRvIHJldHVybiBTY2hlbWFFbnYgdG8gdGhyb3cgZXhjZXB0aW9uXG4gICAgLy8gc28gdGhhdCBjb21waWxlQXN5bmMgbG9hZHMgbWlzc2luZyBzY2hlbWEuXG4gICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgIGVudiA9IGVudiB8fCBuZXcgU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkIH0pO1xuICAgIGlmIChlbnYuc2NoZW1hICE9PSBlbnYucm9vdC5zY2hlbWEpXG4gICAgICAgIHJldHVybiBlbnY7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8qKiBAbGljZW5zZSBVUkkuanMgdjQuNC4xIChjKSAyMDExIEdhcnkgQ291cnQuIExpY2Vuc2U6IGh0dHA6Ly9naXRodWIuY29tL2dhcnljb3VydC91cmktanMgKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5VUkkgPSBnbG9iYWwuVVJJIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBtZXJnZSgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc2V0cyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBzZXRzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGlmIChzZXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc2V0c1swXSA9IHNldHNbMF0uc2xpY2UoMCwgLTEpO1xuICAgICAgICB2YXIgeGwgPSBzZXRzLmxlbmd0aCAtIDE7XG4gICAgICAgIGZvciAodmFyIHggPSAxOyB4IDwgeGw7ICsreCkge1xuICAgICAgICAgICAgc2V0c1t4XSA9IHNldHNbeF0uc2xpY2UoMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHNldHNbeGxdID0gc2V0c1t4bF0uc2xpY2UoMSk7XG4gICAgICAgIHJldHVybiBzZXRzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZXRzWzBdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN1YmV4cChzdHIpIHtcbiAgICByZXR1cm4gXCIoPzpcIiArIHN0ciArIFwiKVwiO1xufVxuZnVuY3Rpb24gdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gbyA9PT0gdW5kZWZpbmVkID8gXCJ1bmRlZmluZWRcIiA6IG8gPT09IG51bGwgPyBcIm51bGxcIiA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zcGxpdChcIiBcIikucG9wKCkuc3BsaXQoXCJdXCIpLnNoaWZ0KCkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHRvVXBwZXJDYXNlKHN0cikge1xuICAgIHJldHVybiBzdHIudG9VcHBlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gdW5kZWZpbmVkICYmIG9iaiAhPT0gbnVsbCA/IG9iaiBpbnN0YW5jZW9mIEFycmF5ID8gb2JqIDogdHlwZW9mIG9iai5sZW5ndGggIT09IFwibnVtYmVyXCIgfHwgb2JqLnNwbGl0IHx8IG9iai5zZXRJbnRlcnZhbCB8fCBvYmouY2FsbCA/IFtvYmpdIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqKSA6IFtdO1xufVxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7XG4gICAgdmFyIG9iaiA9IHRhcmdldDtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gYnVpbGRFeHBzKGlzSVJJKSB7XG4gICAgdmFyIEFMUEhBJCQgPSBcIltBLVphLXpdXCIsXG4gICAgICAgIENSJCA9IFwiW1xcXFx4MERdXCIsXG4gICAgICAgIERJR0lUJCQgPSBcIlswLTldXCIsXG4gICAgICAgIERRVU9URSQkID0gXCJbXFxcXHgyMl1cIixcbiAgICAgICAgSEVYRElHJCQgPSBtZXJnZShESUdJVCQkLCBcIltBLUZhLWZdXCIpLFxuICAgICAgICAvL2Nhc2UtaW5zZW5zaXRpdmVcbiAgICBMRiQkID0gXCJbXFxcXHgwQV1cIixcbiAgICAgICAgU1AkJCA9IFwiW1xcXFx4MjBdXCIsXG4gICAgICAgIFBDVF9FTkNPREVEJCA9IHN1YmV4cChzdWJleHAoXCIlW0VGZWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVbODlBLUZhLWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpKSxcbiAgICAgICAgLy9leHBhbmRlZFxuICAgIEdFTl9ERUxJTVMkJCA9IFwiW1xcXFw6XFxcXC9cXFxcP1xcXFwjXFxcXFtcXFxcXVxcXFxAXVwiLFxuICAgICAgICBTVUJfREVMSU1TJCQgPSBcIltcXFxcIVxcXFwkXFxcXCZcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcO1xcXFw9XVwiLFxuICAgICAgICBSRVNFUlZFRCQkID0gbWVyZ2UoR0VOX0RFTElNUyQkLCBTVUJfREVMSU1TJCQpLFxuICAgICAgICBVQ1NDSEFSJCQgPSBpc0lSSSA/IFwiW1xcXFx4QTAtXFxcXHUyMDBEXFxcXHUyMDEwLVxcXFx1MjAyOVxcXFx1MjAyRi1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl1cIiA6IFwiW11cIixcbiAgICAgICAgLy9zdWJzZXQsIGV4Y2x1ZGVzIGJpZGkgY29udHJvbCBjaGFyYWN0ZXJzXG4gICAgSVBSSVZBVEUkJCA9IGlzSVJJID8gXCJbXFxcXHVFMDAwLVxcXFx1RjhGRl1cIiA6IFwiW11cIixcbiAgICAgICAgLy9zdWJzZXRcbiAgICBVTlJFU0VSVkVEJCQgPSBtZXJnZShBTFBIQSQkLCBESUdJVCQkLCBcIltcXFxcLVxcXFwuXFxcXF9cXFxcfl1cIiwgVUNTQ0hBUiQkKSxcbiAgICAgICAgU0NIRU1FJCA9IHN1YmV4cChBTFBIQSQkICsgbWVyZ2UoQUxQSEEkJCwgRElHSVQkJCwgXCJbXFxcXCtcXFxcLVxcXFwuXVwiKSArIFwiKlwiKSxcbiAgICAgICAgVVNFUklORk8kID0gc3ViZXhwKHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOl1cIikpICsgXCIqXCIpLFxuICAgICAgICBERUNfT0NURVQkID0gc3ViZXhwKHN1YmV4cChcIjI1WzAtNV1cIikgKyBcInxcIiArIHN1YmV4cChcIjJbMC00XVwiICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIjFcIiArIERJR0lUJCQgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiWzEtOV1cIiArIERJR0lUJCQpICsgXCJ8XCIgKyBESUdJVCQkKSxcbiAgICAgICAgREVDX09DVEVUX1JFTEFYRUQkID0gc3ViZXhwKHN1YmV4cChcIjI1WzAtNV1cIikgKyBcInxcIiArIHN1YmV4cChcIjJbMC00XVwiICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIjFcIiArIERJR0lUJCQgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiMD9bMS05XVwiICsgRElHSVQkJCkgKyBcInwwPzA/XCIgKyBESUdJVCQkKSxcbiAgICAgICAgLy9yZWxheGVkIHBhcnNpbmcgcnVsZXNcbiAgICBJUFY0QUREUkVTUyQgPSBzdWJleHAoREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkKSxcbiAgICAgICAgSDE2JCA9IHN1YmV4cChIRVhESUckJCArIFwiezEsNH1cIiksXG4gICAgICAgIExTMzIkID0gc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiICsgSDE2JCkgKyBcInxcIiArIElQVjRBRERSRVNTJCksXG4gICAgICAgIElQVjZBRERSRVNTMSQgPSBzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7Nn1cIiArIExTMzIkKSxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICA2KCBoMTYgXCI6XCIgKSBsczMyXG4gICAgSVBWNkFERFJFU1MyJCA9IHN1YmV4cChcIlxcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezV9XCIgKyBMUzMyJCksXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgIFwiOjpcIiA1KCBoMTYgXCI6XCIgKSBsczMyXG4gICAgSVBWNkFERFJFU1MzJCA9IHN1YmV4cChzdWJleHAoSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcIns0fVwiICsgTFMzMiQpLFxuICAgICAgICAvL1sgICAgICAgICAgICAgICBoMTYgXSBcIjo6XCIgNCggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTNCQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsMX1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7M31cIiArIExTMzIkKSxcbiAgICAgICAgLy9bICoxKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgMyggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTNSQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsMn1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7Mn1cIiArIExTMzIkKSxcbiAgICAgICAgLy9bICoyKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgMiggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTNiQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsM31cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgSDE2JCArIFwiXFxcXDpcIiArIExTMzIkKSxcbiAgICAgICAgLy9bICozKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgaDE2IFwiOlwiICAgbHMzMlxuICAgIElQVjZBRERSRVNTNyQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsNH1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgTFMzMiQpLFxuICAgICAgICAvL1sgKjQoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICAgICAgICAgICAgbHMzMlxuICAgIElQVjZBRERSRVNTOCQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsNX1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgSDE2JCksXG4gICAgICAgIC8vWyAqNSggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgICAgICAgICAgICBoMTZcbiAgICBJUFY2QUREUkVTUzkkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDZ9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiksXG4gICAgICAgIC8vWyAqNiggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiXG4gICAgSVBWNkFERFJFU1MkID0gc3ViZXhwKFtJUFY2QUREUkVTUzEkLCBJUFY2QUREUkVTUzIkLCBJUFY2QUREUkVTUzMkLCBJUFY2QUREUkVTUzQkLCBJUFY2QUREUkVTUzUkLCBJUFY2QUREUkVTUzYkLCBJUFY2QUREUkVTUzckLCBJUFY2QUREUkVTUzgkLCBJUFY2QUREUkVTUzkkXS5qb2luKFwifFwiKSksXG4gICAgICAgIFpPTkVJRCQgPSBzdWJleHAoc3ViZXhwKFVOUkVTRVJWRUQkJCArIFwifFwiICsgUENUX0VOQ09ERUQkKSArIFwiK1wiKSxcbiAgICAgICAgLy9SRkMgNjg3NFxuICAgIElQVjZBRERSWiQgPSBzdWJleHAoSVBWNkFERFJFU1MkICsgXCJcXFxcJTI1XCIgKyBaT05FSUQkKSxcbiAgICAgICAgLy9SRkMgNjg3NFxuICAgIElQVjZBRERSWl9SRUxBWEVEJCA9IHN1YmV4cChJUFY2QUREUkVTUyQgKyBzdWJleHAoXCJcXFxcJTI1fFxcXFwlKD8hXCIgKyBIRVhESUckJCArIFwiezJ9KVwiKSArIFpPTkVJRCQpLFxuICAgICAgICAvL1JGQyA2ODc0LCB3aXRoIHJlbGF4ZWQgcGFyc2luZyBydWxlc1xuICAgIElQVkZVVFVSRSQgPSBzdWJleHAoXCJbdlZdXCIgKyBIRVhESUckJCArIFwiK1xcXFwuXCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpdXCIpICsgXCIrXCIpLFxuICAgICAgICBJUF9MSVRFUkFMJCA9IHN1YmV4cChcIlxcXFxbXCIgKyBzdWJleHAoSVBWNkFERFJaX1JFTEFYRUQkICsgXCJ8XCIgKyBJUFY2QUREUkVTUyQgKyBcInxcIiArIElQVkZVVFVSRSQpICsgXCJcXFxcXVwiKSxcbiAgICAgICAgLy9SRkMgNjg3NFxuICAgIFJFR19OQU1FJCA9IHN1YmV4cChzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCkpICsgXCIqXCIpLFxuICAgICAgICBIT1NUJCA9IHN1YmV4cChJUF9MSVRFUkFMJCArIFwifFwiICsgSVBWNEFERFJFU1MkICsgXCIoPyFcIiArIFJFR19OQU1FJCArIFwiKVwiICsgXCJ8XCIgKyBSRUdfTkFNRSQpLFxuICAgICAgICBQT1JUJCA9IHN1YmV4cChESUdJVCQkICsgXCIqXCIpLFxuICAgICAgICBBVVRIT1JJVFkkID0gc3ViZXhwKHN1YmV4cChVU0VSSU5GTyQgKyBcIkBcIikgKyBcIj9cIiArIEhPU1QkICsgc3ViZXhwKFwiXFxcXDpcIiArIFBPUlQkKSArIFwiP1wiKSxcbiAgICAgICAgUENIQVIkID0gc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBdXCIpKSxcbiAgICAgICAgU0VHTUVOVCQgPSBzdWJleHAoUENIQVIkICsgXCIqXCIpLFxuICAgICAgICBTRUdNRU5UX05aJCA9IHN1YmV4cChQQ0hBUiQgKyBcIitcIiksXG4gICAgICAgIFNFR01FTlRfTlpfTkMkID0gc3ViZXhwKHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcQF1cIikpICsgXCIrXCIpLFxuICAgICAgICBQQVRIX0FCRU1QVFkkID0gc3ViZXhwKHN1YmV4cChcIlxcXFwvXCIgKyBTRUdNRU5UJCkgKyBcIipcIiksXG4gICAgICAgIFBBVEhfQUJTT0xVVEUkID0gc3ViZXhwKFwiXFxcXC9cIiArIHN1YmV4cChTRUdNRU5UX05aJCArIFBBVEhfQUJFTVBUWSQpICsgXCI/XCIpLFxuICAgICAgICAvL3NpbXBsaWZpZWRcbiAgICBQQVRIX05PU0NIRU1FJCA9IHN1YmV4cChTRUdNRU5UX05aX05DJCArIFBBVEhfQUJFTVBUWSQpLFxuICAgICAgICAvL3NpbXBsaWZpZWRcbiAgICBQQVRIX1JPT1RMRVNTJCA9IHN1YmV4cChTRUdNRU5UX05aJCArIFBBVEhfQUJFTVBUWSQpLFxuICAgICAgICAvL3NpbXBsaWZpZWRcbiAgICBQQVRIX0VNUFRZJCA9IFwiKD8hXCIgKyBQQ0hBUiQgKyBcIilcIixcbiAgICAgICAgUEFUSCQgPSBzdWJleHAoUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfTk9TQ0hFTUUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuICAgICAgICBRVUVSWSQgPSBzdWJleHAoc3ViZXhwKFBDSEFSJCArIFwifFwiICsgbWVyZ2UoXCJbXFxcXC9cXFxcP11cIiwgSVBSSVZBVEUkJCkpICsgXCIqXCIpLFxuICAgICAgICBGUkFHTUVOVCQgPSBzdWJleHAoc3ViZXhwKFBDSEFSJCArIFwifFtcXFxcL1xcXFw/XVwiKSArIFwiKlwiKSxcbiAgICAgICAgSElFUl9QQVJUJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvXCIgKyBBVVRIT1JJVFkkICsgUEFUSF9BQkVNUFRZJCkgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuICAgICAgICBVUkkkID0gc3ViZXhwKFNDSEVNRSQgKyBcIlxcXFw6XCIgKyBISUVSX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjXCIgKyBGUkFHTUVOVCQpICsgXCI/XCIpLFxuICAgICAgICBSRUxBVElWRV9QQVJUJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvXCIgKyBBVVRIT1JJVFkkICsgUEFUSF9BQkVNUFRZJCkgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuICAgICAgICBSRUxBVElWRSQgPSBzdWJleHAoUkVMQVRJVkVfUEFSVCQgKyBzdWJleHAoXCJcXFxcP1wiICsgUVVFUlkkKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCNcIiArIEZSQUdNRU5UJCkgKyBcIj9cIiksXG4gICAgICAgIFVSSV9SRUZFUkVOQ0UkID0gc3ViZXhwKFVSSSQgKyBcInxcIiArIFJFTEFUSVZFJCksXG4gICAgICAgIEFCU09MVVRFX1VSSSQgPSBzdWJleHAoU0NIRU1FJCArIFwiXFxcXDpcIiArIEhJRVJfUEFSVCQgKyBzdWJleHAoXCJcXFxcP1wiICsgUVVFUlkkKSArIFwiP1wiKSxcbiAgICAgICAgR0VORVJJQ19SRUYkID0gXCJeKFwiICsgU0NIRU1FJCArIFwiKVxcXFw6XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjKFwiICsgRlJBR01FTlQkICsgXCIpXCIpICsgXCI/JFwiLFxuICAgICAgICBSRUxBVElWRV9SRUYkID0gXCJeKCl7MH1cIiArIHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvKFwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/KVwiKSArIFwiPyhcIiArIFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9FTVBUWSQgKyBcIilcIikgKyBzdWJleHAoXCJcXFxcPyhcIiArIFFVRVJZJCArIFwiKVwiKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCMoXCIgKyBGUkFHTUVOVCQgKyBcIilcIikgKyBcIj8kXCIsXG4gICAgICAgIEFCU09MVVRFX1JFRiQgPSBcIl4oXCIgKyBTQ0hFTUUkICsgXCIpXFxcXDpcIiArIHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvKFwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/KVwiKSArIFwiPyhcIiArIFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQgKyBcIilcIikgKyBzdWJleHAoXCJcXFxcPyhcIiArIFFVRVJZJCArIFwiKVwiKSArIFwiPyRcIixcbiAgICAgICAgU0FNRURPQ19SRUYkID0gXCJeXCIgKyBzdWJleHAoXCJcXFxcIyhcIiArIEZSQUdNRU5UJCArIFwiKVwiKSArIFwiPyRcIixcbiAgICAgICAgQVVUSE9SSVRZX1JFRiQgPSBcIl5cIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPyRcIjtcbiAgICByZXR1cm4ge1xuICAgICAgICBOT1RfU0NIRU1FOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIEFMUEhBJCQsIERJR0lUJCQsIFwiW1xcXFwrXFxcXC1cXFxcLl1cIiksIFwiZ1wiKSxcbiAgICAgICAgTk9UX1VTRVJJTkZPOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFw6XVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX0hPU1Q6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXFtcXFxcXVxcXFw6XVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX1BBVEg6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXC9cXFxcOlxcXFxAXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX1BBVEhfTk9TQ0hFTUU6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXC9cXFxcQF1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9RVUVSWTogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOlxcXFxAXFxcXC9cXFxcP11cIiwgSVBSSVZBVEUkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX0ZSQUdNRU5UOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJV1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBcXFxcL1xcXFw/XVwiKSwgXCJnXCIpLFxuICAgICAgICBFU0NBUEU6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIFVOUkVTRVJWRUQ6IG5ldyBSZWdFeHAoVU5SRVNFUlZFRCQkLCBcImdcIiksXG4gICAgICAgIE9USEVSX0NIQVJTOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJV1cIiwgVU5SRVNFUlZFRCQkLCBSRVNFUlZFRCQkKSwgXCJnXCIpLFxuICAgICAgICBQQ1RfRU5DT0RFRDogbmV3IFJlZ0V4cChQQ1RfRU5DT0RFRCQsIFwiZ1wiKSxcbiAgICAgICAgSVBWNEFERFJFU1M6IG5ldyBSZWdFeHAoXCJeKFwiICsgSVBWNEFERFJFU1MkICsgXCIpJFwiKSxcbiAgICAgICAgSVBWNkFERFJFU1M6IG5ldyBSZWdFeHAoXCJeXFxcXFs/KFwiICsgSVBWNkFERFJFU1MkICsgXCIpXCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXCUyNXxcXFxcJSg/IVwiICsgSEVYRElHJCQgKyBcInsyfSlcIikgKyBcIihcIiArIFpPTkVJRCQgKyBcIilcIikgKyBcIj9cXFxcXT8kXCIpIC8vUkZDIDY4NzQsIHdpdGggcmVsYXhlZCBwYXJzaW5nIHJ1bGVzXG4gICAgfTtcbn1cbnZhciBVUklfUFJPVE9DT0wgPSBidWlsZEV4cHMoZmFsc2UpO1xuXG52YXIgSVJJX1BST1RPQ09MID0gYnVpbGRFeHBzKHRydWUpO1xuXG52YXIgc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHtcbiAgICAgIHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICAgIH1cbiAgfTtcbn0oKTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIHRvQ29uc3VtYWJsZUFycmF5ID0gZnVuY3Rpb24gKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgIHJldHVybiBhcnIyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGFycik7XG4gIH1cbn07XG5cbi8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblxudmFyIG1heEludCA9IDIxNDc0ODM2NDc7IC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuLyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xudmFyIGJhc2UgPSAzNjtcbnZhciB0TWluID0gMTtcbnZhciB0TWF4ID0gMjY7XG52YXIgc2tldyA9IDM4O1xudmFyIGRhbXAgPSA3MDA7XG52YXIgaW5pdGlhbEJpYXMgPSA3MjtcbnZhciBpbml0aWFsTiA9IDEyODsgLy8gMHg4MFxudmFyIGRlbGltaXRlciA9ICctJzsgLy8gJ1xceDJEJ1xuXG4vKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xudmFyIHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vO1xudmFyIHJlZ2V4Tm9uQVNDSUkgPSAvW15cXDAtXFx4N0VdLzsgLy8gbm9uLUFTQ0lJIGNoYXJzXG52YXIgcmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZzsgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG4vKiogRXJyb3IgbWVzc2FnZXMgKi9cbnZhciBlcnJvcnMgPSB7XG5cdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG59O1xuXG4vKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG52YXIgYmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZXJyb3IkMSh0eXBlKSB7XG5cdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG59XG5cbi8qKlxuICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuICogaXRlbS5cbiAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHR2YXIgcmVzdWx0ID0gW107XG5cdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcbiAqIGFkZHJlc3Nlcy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG4gKiBjaGFyYWN0ZXIuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuICogZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHR2YXIgcmVzdWx0ID0gJyc7XG5cdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdH1cblx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcbiAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuICogbWF0Y2hpbmcgVVRGLTE2LlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG4gKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBkZWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG4gKi9cbmZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdHZhciBvdXRwdXQgPSBbXTtcblx0dmFyIGNvdW50ZXIgPSAwO1xuXHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHR2YXIgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdC8vIEl0J3MgYSBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXIuXG5cdFx0XHR2YXIgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7XG5cdFx0XHRcdC8vIExvdyBzdXJyb2dhdGUuXG5cdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJdCdzIGFuIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZVxuXHRcdFx0XHQvLyBuZXh0IGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpci5cblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG4gKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBlbmNvZGVcbiAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG4gKi9cbnZhciB1Y3MyZW5jb2RlID0gZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQuYXBwbHkoU3RyaW5nLCB0b0NvbnN1bWFibGVBcnJheShhcnJheSkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG4gKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cbiAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcbiAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuICovXG52YXIgYmFzaWNUb0RpZ2l0ID0gZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRpZiAoY29kZVBvaW50IC0gMHgzMCA8IDB4MEEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHgxNjtcblx0fVxuXHRpZiAoY29kZVBvaW50IC0gMHg0MSA8IDB4MUEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHg0MTtcblx0fVxuXHRpZiAoY29kZVBvaW50IC0gMHg2MSA8IDB4MUEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHg2MTtcblx0fVxuXHRyZXR1cm4gYmFzZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG4gKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG4gKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cbiAqL1xudmFyIGRpZ2l0VG9CYXNpYyA9IGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcbn07XG5cbi8qKlxuICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgYWRhcHQgPSBmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0dmFyIGsgPSAwO1xuXHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdGZvciAoOyAvKiBubyBpbml0aWFsaXphdGlvbiAqL2RlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHR9XG5cdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuICogc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICovXG52YXIgZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdC8vIERvbid0IHVzZSBVQ1MtMi5cblx0dmFyIG91dHB1dCA9IFtdO1xuXHR2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cdHZhciBpID0gMDtcblx0dmFyIG4gPSBpbml0aWFsTjtcblx0dmFyIGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0dmFyIGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdGJhc2ljID0gMDtcblx0fVxuXG5cdGZvciAodmFyIGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdGVycm9yJDEoJ25vdC1iYXNpYycpO1xuXHRcdH1cblx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0fVxuXG5cdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRmb3IgKHZhciBpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7KSAvKiBubyBmaW5hbCBleHByZXNzaW9uICove1xuXG5cdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHR2YXIgb2xkaSA9IGk7XG5cdFx0Zm9yICh2YXIgdyA9IDEsIGsgPSBiYXNlOzsgLyogbm8gY29uZGl0aW9uICovayArPSBiYXNlKSB7XG5cblx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRlcnJvciQxKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRlcnJvciQxKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdHZhciB0ID0gayA8PSBiaWFzID8gdE1pbiA6IGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXM7XG5cblx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdGVycm9yJDEoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblx0XHR9XG5cblx0XHR2YXIgb3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHR9XG5cblx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdGkgJT0gb3V0O1xuXG5cdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dC5cblx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cdH1cblxuXHRyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQuYXBwbHkoU3RyaW5nLCBvdXRwdXQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICovXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdHZhciBvdXRwdXQgPSBbXTtcblxuXHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBhbiBhcnJheSBvZiBVbmljb2RlIGNvZGUgcG9pbnRzLlxuXHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdC8vIENhY2hlIHRoZSBsZW5ndGguXG5cdHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZS5cblx0dmFyIG4gPSBpbml0aWFsTjtcblx0dmFyIGRlbHRhID0gMDtcblx0dmFyIGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzLlxuXHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG5cdHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuXHR2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cblx0dHJ5IHtcblx0XHRmb3IgKHZhciBfaXRlcmF0b3IgPSBpbnB1dFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcblx0XHRcdHZhciBfY3VycmVudFZhbHVlMiA9IF9zdGVwLnZhbHVlO1xuXG5cdFx0XHRpZiAoX2N1cnJlbnRWYWx1ZTIgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShfY3VycmVudFZhbHVlMikpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0X2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuXHRcdF9pdGVyYXRvckVycm9yID0gZXJyO1xuXHR9IGZpbmFsbHkge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuXHRcdFx0XHRfaXRlcmF0b3IucmV0dXJuKCk7XG5cdFx0XHR9XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuXHRcdFx0XHR0aHJvdyBfaXRlcmF0b3JFcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2YXIgYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXHR2YXIgaGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aDtcblxuXHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIHdpdGggYSBkZWxpbWl0ZXIgdW5sZXNzIGl0J3MgZW1wdHkuXG5cdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdH1cblxuXHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHR2YXIgbSA9IG1heEludDtcblx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuXHRcdHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcblx0XHR2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGZvciAodmFyIF9pdGVyYXRvcjIgPSBpbnB1dFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuXHRcdFx0XHR2YXIgY3VycmVudFZhbHVlID0gX3N0ZXAyLnZhbHVlO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvdy5cblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG5cdFx0XHRfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcblx0XHRcdFx0XHRfaXRlcmF0b3IyLnJldHVybigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG5cdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHR9XG5cblx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdG4gPSBtO1xuXG5cdFx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTtcblx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IzID0gZmFsc2U7XG5cdFx0dmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuXHRcdHRyeSB7XG5cdFx0XHRmb3IgKHZhciBfaXRlcmF0b3IzID0gaW5wdXRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHtcblx0XHRcdFx0dmFyIF9jdXJyZW50VmFsdWUgPSBfc3RlcDMudmFsdWU7XG5cblx0XHRcdFx0aWYgKF9jdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvciQxKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChfY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cblx0XHRcdFx0XHR2YXIgcSA9IGRlbHRhO1xuXHRcdFx0XHRcdGZvciAodmFyIGsgPSBiYXNlOzsgLyogbm8gY29uZGl0aW9uICovayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR2YXIgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiBrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFyIHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdHZhciBiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpKTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7XG5cdFx0XHRfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4pIHtcblx0XHRcdFx0XHRfaXRlcmF0b3IzLnJldHVybigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG5cdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3IzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0KytkZWx0YTtcblx0XHQrK247XG5cdH1cblx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG4gKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuICogY29udmVydCB0byBVbmljb2RlLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG4gKiBzdHJpbmcuXG4gKi9cbnZhciB0b1VuaWNvZGUgPSBmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24gKHN0cmluZykge1xuXHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKSA/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSkgOiBzdHJpbmc7XG5cdH0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cbiAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG4gKiBBU0NJSS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcbiAqIFVuaWNvZGUgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuICogZW1haWwgYWRkcmVzcy5cbiAqL1xudmFyIHRvQVNDSUkgPSBmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uIChzdHJpbmcpIHtcblx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZykgPyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKSA6IHN0cmluZztcblx0fSk7XG59O1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xudmFyIHB1bnljb2RlID0ge1xuXHQvKipcbiAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG4gICogQG1lbWJlck9mIHB1bnljb2RlXG4gICogQHR5cGUgU3RyaW5nXG4gICovXG5cdCd2ZXJzaW9uJzogJzIuMS4wJyxcblx0LyoqXG4gICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcbiAgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuICAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuICAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICAqIEB0eXBlIE9iamVjdFxuICAqL1xuXHQndWNzMic6IHtcblx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHR9LFxuXHQnZGVjb2RlJzogZGVjb2RlLFxuXHQnZW5jb2RlJzogZW5jb2RlLFxuXHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcbn07XG5cbi8qKlxuICogVVJJLmpzXG4gKlxuICogQGZpbGVvdmVydmlldyBBbiBSRkMgMzk4NiBjb21wbGlhbnQsIHNjaGVtZSBleHRlbmRhYmxlIFVSSSBwYXJzaW5nL3ZhbGlkYXRpbmcvcmVzb2x2aW5nIGxpYnJhcnkgZm9yIEphdmFTY3JpcHQuXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86Z2FyeS5jb3VydEBnbWFpbC5jb21cIj5HYXJ5IENvdXJ0PC9hPlxuICogQHNlZSBodHRwOi8vZ2l0aHViLmNvbS9nYXJ5Y291cnQvdXJpLWpzXG4gKi9cbi8qKlxuICogQ29weXJpZ2h0IDIwMTEgR2FyeSBDb3VydC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmVcbiAqIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mXG4gKiAgICAgICBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3RcbiAqICAgICAgIG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gKiAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBHQVJZIENPVVJUIGBgQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRFxuICogV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEdBUlkgQ09VUlQgT1JcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SXG4gKiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG4gKiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUZcbiAqIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICpcbiAqIFRoZSB2aWV3cyBhbmQgY29uY2x1c2lvbnMgY29udGFpbmVkIGluIHRoZSBzb2Z0d2FyZSBhbmQgZG9jdW1lbnRhdGlvbiBhcmUgdGhvc2Ugb2YgdGhlXG4gKiBhdXRob3JzIGFuZCBzaG91bGQgbm90IGJlIGludGVycHJldGVkIGFzIHJlcHJlc2VudGluZyBvZmZpY2lhbCBwb2xpY2llcywgZWl0aGVyIGV4cHJlc3NlZFxuICogb3IgaW1wbGllZCwgb2YgR2FyeSBDb3VydC5cbiAqL1xudmFyIFNDSEVNRVMgPSB7fTtcbmZ1bmN0aW9uIHBjdEVuY0NoYXIoY2hyKSB7XG4gICAgdmFyIGMgPSBjaHIuY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgZSA9IHZvaWQgMDtcbiAgICBpZiAoYyA8IDE2KSBlID0gXCIlMFwiICsgYy50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtlbHNlIGlmIChjIDwgMTI4KSBlID0gXCIlXCIgKyBjLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO2Vsc2UgaWYgKGMgPCAyMDQ4KSBlID0gXCIlXCIgKyAoYyA+PiA2IHwgMTkyKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArIFwiJVwiICsgKGMgJiA2MyB8IDEyOCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7ZWxzZSBlID0gXCIlXCIgKyAoYyA+PiAxMiB8IDIyNCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBcIiVcIiArIChjID4+IDYgJiA2MyB8IDEyOCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBcIiVcIiArIChjICYgNjMgfCAxMjgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBlO1xufVxuZnVuY3Rpb24gcGN0RGVjQ2hhcnMoc3RyKSB7XG4gICAgdmFyIG5ld1N0ciA9IFwiXCI7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBpbCA9IHN0ci5sZW5ndGg7XG4gICAgd2hpbGUgKGkgPCBpbCkge1xuICAgICAgICB2YXIgYyA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDEsIDIpLCAxNik7XG4gICAgICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICAgICAgICBuZXdTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgfSBlbHNlIGlmIChjID49IDE5NCAmJiBjIDwgMjI0KSB7XG4gICAgICAgICAgICBpZiAoaWwgLSBpID49IDYpIHtcbiAgICAgICAgICAgICAgICB2YXIgYzIgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyA0LCAyKSwgMTYpO1xuICAgICAgICAgICAgICAgIG5ld1N0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMzEpIDw8IDYgfCBjMiAmIDYzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U3RyICs9IHN0ci5zdWJzdHIoaSwgNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpICs9IDY7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA+PSAyMjQpIHtcbiAgICAgICAgICAgIGlmIChpbCAtIGkgPj0gOSkge1xuICAgICAgICAgICAgICAgIHZhciBfYyA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDQsIDIpLCAxNik7XG4gICAgICAgICAgICAgICAgdmFyIGMzID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgNywgMiksIDE2KTtcbiAgICAgICAgICAgICAgICBuZXdTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDE1KSA8PCAxMiB8IChfYyAmIDYzKSA8PCA2IHwgYzMgJiA2Myk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSArPSA5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3U3RyICs9IHN0ci5zdWJzdHIoaSwgMyk7XG4gICAgICAgICAgICBpICs9IDM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld1N0cjtcbn1cbmZ1bmN0aW9uIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBwcm90b2NvbCkge1xuICAgIGZ1bmN0aW9uIGRlY29kZVVucmVzZXJ2ZWQoc3RyKSB7XG4gICAgICAgIHZhciBkZWNTdHIgPSBwY3REZWNDaGFycyhzdHIpO1xuICAgICAgICByZXR1cm4gIWRlY1N0ci5tYXRjaChwcm90b2NvbC5VTlJFU0VSVkVEKSA/IHN0ciA6IGRlY1N0cjtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMuc2NoZW1lKSBjb21wb25lbnRzLnNjaGVtZSA9IFN0cmluZyhjb21wb25lbnRzLnNjaGVtZSkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKHByb3RvY29sLk5PVF9TQ0hFTUUsIFwiXCIpO1xuICAgIGlmIChjb21wb25lbnRzLnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMudXNlcmluZm8gPSBTdHJpbmcoY29tcG9uZW50cy51c2VyaW5mbykucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShwcm90b2NvbC5OT1RfVVNFUklORk8sIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICBpZiAoY29tcG9uZW50cy5ob3N0ICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMuaG9zdCA9IFN0cmluZyhjb21wb25lbnRzLmhvc3QpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShwcm90b2NvbC5OT1RfSE9TVCwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgIGlmIChjb21wb25lbnRzLnBhdGggIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5wYXRoID0gU3RyaW5nKGNvbXBvbmVudHMucGF0aCkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShjb21wb25lbnRzLnNjaGVtZSA/IHByb3RvY29sLk5PVF9QQVRIIDogcHJvdG9jb2wuTk9UX1BBVEhfTk9TQ0hFTUUsIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICBpZiAoY29tcG9uZW50cy5xdWVyeSAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLnF1ZXJ5ID0gU3RyaW5nKGNvbXBvbmVudHMucXVlcnkpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UocHJvdG9jb2wuTk9UX1FVRVJZLCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG4gICAgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5mcmFnbWVudCA9IFN0cmluZyhjb21wb25lbnRzLmZyYWdtZW50KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKHByb3RvY29sLk5PVF9GUkFHTUVOVCwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgIHJldHVybiBjb21wb25lbnRzO1xufVxuXG5mdW5jdGlvbiBfc3RyaXBMZWFkaW5nWmVyb3Moc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eMCooLiopLywgXCIkMVwiKSB8fCBcIjBcIjtcbn1cbmZ1bmN0aW9uIF9ub3JtYWxpemVJUHY0KGhvc3QsIHByb3RvY29sKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBob3N0Lm1hdGNoKHByb3RvY29sLklQVjRBRERSRVNTKSB8fCBbXTtcblxuICAgIHZhciBfbWF0Y2hlcyA9IHNsaWNlZFRvQXJyYXkobWF0Y2hlcywgMiksXG4gICAgICAgIGFkZHJlc3MgPSBfbWF0Y2hlc1sxXTtcblxuICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBhZGRyZXNzLnNwbGl0KFwiLlwiKS5tYXAoX3N0cmlwTGVhZGluZ1plcm9zKS5qb2luKFwiLlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaG9zdDtcbiAgICB9XG59XG5mdW5jdGlvbiBfbm9ybWFsaXplSVB2Nihob3N0LCBwcm90b2NvbCkge1xuICAgIHZhciBtYXRjaGVzID0gaG9zdC5tYXRjaChwcm90b2NvbC5JUFY2QUREUkVTUykgfHwgW107XG5cbiAgICB2YXIgX21hdGNoZXMyID0gc2xpY2VkVG9BcnJheShtYXRjaGVzLCAzKSxcbiAgICAgICAgYWRkcmVzcyA9IF9tYXRjaGVzMlsxXSxcbiAgICAgICAgem9uZSA9IF9tYXRjaGVzMlsyXTtcblxuICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgIHZhciBfYWRkcmVzcyR0b0xvd2VyQ2FzZSQgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkuc3BsaXQoJzo6JykucmV2ZXJzZSgpLFxuICAgICAgICAgICAgX2FkZHJlc3MkdG9Mb3dlckNhc2UkMiA9IHNsaWNlZFRvQXJyYXkoX2FkZHJlc3MkdG9Mb3dlckNhc2UkLCAyKSxcbiAgICAgICAgICAgIGxhc3QgPSBfYWRkcmVzcyR0b0xvd2VyQ2FzZSQyWzBdLFxuICAgICAgICAgICAgZmlyc3QgPSBfYWRkcmVzcyR0b0xvd2VyQ2FzZSQyWzFdO1xuXG4gICAgICAgIHZhciBmaXJzdEZpZWxkcyA9IGZpcnN0ID8gZmlyc3Quc3BsaXQoXCI6XCIpLm1hcChfc3RyaXBMZWFkaW5nWmVyb3MpIDogW107XG4gICAgICAgIHZhciBsYXN0RmllbGRzID0gbGFzdC5zcGxpdChcIjpcIikubWFwKF9zdHJpcExlYWRpbmdaZXJvcyk7XG4gICAgICAgIHZhciBpc0xhc3RGaWVsZElQdjRBZGRyZXNzID0gcHJvdG9jb2wuSVBWNEFERFJFU1MudGVzdChsYXN0RmllbGRzW2xhc3RGaWVsZHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICB2YXIgZmllbGRDb3VudCA9IGlzTGFzdEZpZWxkSVB2NEFkZHJlc3MgPyA3IDogODtcbiAgICAgICAgdmFyIGxhc3RGaWVsZHNTdGFydCA9IGxhc3RGaWVsZHMubGVuZ3RoIC0gZmllbGRDb3VudDtcbiAgICAgICAgdmFyIGZpZWxkcyA9IEFycmF5KGZpZWxkQ291bnQpO1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGZpZWxkQ291bnQ7ICsreCkge1xuICAgICAgICAgICAgZmllbGRzW3hdID0gZmlyc3RGaWVsZHNbeF0gfHwgbGFzdEZpZWxkc1tsYXN0RmllbGRzU3RhcnQgKyB4XSB8fCAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMYXN0RmllbGRJUHY0QWRkcmVzcykge1xuICAgICAgICAgICAgZmllbGRzW2ZpZWxkQ291bnQgLSAxXSA9IF9ub3JtYWxpemVJUHY0KGZpZWxkc1tmaWVsZENvdW50IC0gMV0sIHByb3RvY29sKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWxsWmVyb0ZpZWxkcyA9IGZpZWxkcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZmllbGQsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWZpZWxkIHx8IGZpZWxkID09PSBcIjBcIikge1xuICAgICAgICAgICAgICAgIHZhciBsYXN0TG9uZ2VzdCA9IGFjY1thY2MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RMb25nZXN0ICYmIGxhc3RMb25nZXN0LmluZGV4ICsgbGFzdExvbmdlc3QubGVuZ3RoID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0TG9uZ2VzdC5sZW5ndGgrKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhY2MucHVzaCh7IGluZGV4OiBpbmRleCwgbGVuZ3RoOiAxIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgdmFyIGxvbmdlc3RaZXJvRmllbGRzID0gYWxsWmVyb0ZpZWxkcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfSlbMF07XG4gICAgICAgIHZhciBuZXdIb3N0ID0gdm9pZCAwO1xuICAgICAgICBpZiAobG9uZ2VzdFplcm9GaWVsZHMgJiYgbG9uZ2VzdFplcm9GaWVsZHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIG5ld0ZpcnN0ID0gZmllbGRzLnNsaWNlKDAsIGxvbmdlc3RaZXJvRmllbGRzLmluZGV4KTtcbiAgICAgICAgICAgIHZhciBuZXdMYXN0ID0gZmllbGRzLnNsaWNlKGxvbmdlc3RaZXJvRmllbGRzLmluZGV4ICsgbG9uZ2VzdFplcm9GaWVsZHMubGVuZ3RoKTtcbiAgICAgICAgICAgIG5ld0hvc3QgPSBuZXdGaXJzdC5qb2luKFwiOlwiKSArIFwiOjpcIiArIG5ld0xhc3Quam9pbihcIjpcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdIb3N0ID0gZmllbGRzLmpvaW4oXCI6XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh6b25lKSB7XG4gICAgICAgICAgICBuZXdIb3N0ICs9IFwiJVwiICsgem9uZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3SG9zdDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaG9zdDtcbiAgICB9XG59XG52YXIgVVJJX1BBUlNFID0gL14oPzooW146XFwvPyNdKyk6KT8oPzpcXC9cXC8oKD86KFteXFwvPyNAXSopQCk/KFxcW1teXFwvPyNcXF1dK1xcXXxbXlxcLz8jOl0qKSg/OlxcOihcXGQqKSk/KSk/KFtePyNdKikoPzpcXD8oW14jXSopKT8oPzojKCg/Oi58XFxufFxccikqKSk/L2k7XG52YXIgTk9fTUFUQ0hfSVNfVU5ERUZJTkVEID0gXCJcIi5tYXRjaCgvKCl7MH0vKVsxXSA9PT0gdW5kZWZpbmVkO1xuZnVuY3Rpb24gcGFyc2UodXJpU3RyaW5nKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgdmFyIGNvbXBvbmVudHMgPSB7fTtcbiAgICB2YXIgcHJvdG9jb2wgPSBvcHRpb25zLmlyaSAhPT0gZmFsc2UgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0w7XG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlID09PSBcInN1ZmZpeFwiKSB1cmlTdHJpbmcgPSAob3B0aW9ucy5zY2hlbWUgPyBvcHRpb25zLnNjaGVtZSArIFwiOlwiIDogXCJcIikgKyBcIi8vXCIgKyB1cmlTdHJpbmc7XG4gICAgdmFyIG1hdGNoZXMgPSB1cmlTdHJpbmcubWF0Y2goVVJJX1BBUlNFKTtcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICBpZiAoTk9fTUFUQ0hfSVNfVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAvL3N0b3JlIGVhY2ggY29tcG9uZW50XG4gICAgICAgICAgICBjb21wb25lbnRzLnNjaGVtZSA9IG1hdGNoZXNbMV07XG4gICAgICAgICAgICBjb21wb25lbnRzLnVzZXJpbmZvID0gbWF0Y2hlc1szXTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9IG1hdGNoZXNbNF07XG4gICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSBtYXRjaGVzWzZdIHx8IFwiXCI7XG4gICAgICAgICAgICBjb21wb25lbnRzLnF1ZXJ5ID0gbWF0Y2hlc1s3XTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZnJhZ21lbnQgPSBtYXRjaGVzWzhdO1xuICAgICAgICAgICAgLy9maXggcG9ydCBudW1iZXJcbiAgICAgICAgICAgIGlmIChpc05hTihjb21wb25lbnRzLnBvcnQpKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gbWF0Y2hlc1s1XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vSUUgRklYIGZvciBpbXByb3BlciBSZWdFeHAgbWF0Y2hpbmdcbiAgICAgICAgICAgIC8vc3RvcmUgZWFjaCBjb21wb25lbnRcbiAgICAgICAgICAgIGNvbXBvbmVudHMuc2NoZW1lID0gbWF0Y2hlc1sxXSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLnVzZXJpbmZvID0gdXJpU3RyaW5nLmluZGV4T2YoXCJAXCIpICE9PSAtMSA/IG1hdGNoZXNbM10gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLmhvc3QgPSB1cmlTdHJpbmcuaW5kZXhPZihcIi8vXCIpICE9PSAtMSA/IG1hdGNoZXNbNF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSBtYXRjaGVzWzZdIHx8IFwiXCI7XG4gICAgICAgICAgICBjb21wb25lbnRzLnF1ZXJ5ID0gdXJpU3RyaW5nLmluZGV4T2YoXCI/XCIpICE9PSAtMSA/IG1hdGNoZXNbN10gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLmZyYWdtZW50ID0gdXJpU3RyaW5nLmluZGV4T2YoXCIjXCIpICE9PSAtMSA/IG1hdGNoZXNbOF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvL2ZpeCBwb3J0IG51bWJlclxuICAgICAgICAgICAgaWYgKGlzTmFOKGNvbXBvbmVudHMucG9ydCkpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSB1cmlTdHJpbmcubWF0Y2goL1xcL1xcLyg/Oi58XFxuKSpcXDooPzpcXC98XFw/fFxcI3wkKS8pID8gbWF0Y2hlc1s0XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcG9uZW50cy5ob3N0KSB7XG4gICAgICAgICAgICAvL25vcm1hbGl6ZSBJUCBob3N0c1xuICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gX25vcm1hbGl6ZUlQdjYoX25vcm1hbGl6ZUlQdjQoY29tcG9uZW50cy5ob3N0LCBwcm90b2NvbCksIHByb3RvY29sKTtcbiAgICAgICAgfVxuICAgICAgICAvL2RldGVybWluZSByZWZlcmVuY2UgdHlwZVxuICAgICAgICBpZiAoY29tcG9uZW50cy5zY2hlbWUgPT09IHVuZGVmaW5lZCAmJiBjb21wb25lbnRzLnVzZXJpbmZvID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy5ob3N0ID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy5wb3J0ID09PSB1bmRlZmluZWQgJiYgIWNvbXBvbmVudHMucGF0aCAmJiBjb21wb25lbnRzLnF1ZXJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJzYW1lLWRvY3VtZW50XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG9uZW50cy5zY2hlbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5yZWZlcmVuY2UgPSBcInJlbGF0aXZlXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG9uZW50cy5mcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJ1cmlcIjtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciByZWZlcmVuY2UgZXJyb3JzXG4gICAgICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gXCJzdWZmaXhcIiAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gY29tcG9uZW50cy5yZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiVVJJIGlzIG5vdCBhIFwiICsgb3B0aW9ucy5yZWZlcmVuY2UgKyBcIiByZWZlcmVuY2UuXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy9maW5kIHNjaGVtZSBoYW5kbGVyXG4gICAgICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1sob3B0aW9ucy5zY2hlbWUgfHwgY29tcG9uZW50cy5zY2hlbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIC8vY2hlY2sgaWYgc2NoZW1lIGNhbid0IGhhbmRsZSBJUklzXG4gICAgICAgIGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIudW5pY29kZVN1cHBvcnQpKSB7XG4gICAgICAgICAgICAvL2lmIGhvc3QgY29tcG9uZW50IGlzIGEgZG9tYWluIG5hbWVcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRzLmhvc3QgJiYgKG9wdGlvbnMuZG9tYWluSG9zdCB8fCBzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuZG9tYWluSG9zdCkpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgVW5pY29kZSBJRE4gLT4gQVNDSUkgSUROXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gcHVueWNvZGUudG9BU0NJSShjb21wb25lbnRzLmhvc3QucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgcGN0RGVjQ2hhcnMpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gQVNDSUkgdmlhIHB1bnljb2RlOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9jb252ZXJ0IElSSSAtPiBVUklcbiAgICAgICAgICAgIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBVUklfUFJPVE9DT0wpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9ub3JtYWxpemUgZW5jb2RpbmdzXG4gICAgICAgICAgICBfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgcHJvdG9jb2wpO1xuICAgICAgICB9XG4gICAgICAgIC8vcGVyZm9ybSBzY2hlbWUgc3BlY2lmaWMgcGFyc2luZ1xuICAgICAgICBpZiAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLnBhcnNlKSB7XG4gICAgICAgICAgICBzY2hlbWVIYW5kbGVyLnBhcnNlKGNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUkkgY2FuIG5vdCBiZSBwYXJzZWQuXCI7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnRzO1xufVxuXG5mdW5jdGlvbiBfcmVjb21wb3NlQXV0aG9yaXR5KGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgcHJvdG9jb2wgPSBvcHRpb25zLmlyaSAhPT0gZmFsc2UgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0w7XG4gICAgdmFyIHVyaVRva2VucyA9IFtdO1xuICAgIGlmIChjb21wb25lbnRzLnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy51c2VyaW5mbyk7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiQFwiKTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vbm9ybWFsaXplIElQIGhvc3RzLCBhZGQgYnJhY2tldHMgYW5kIGVzY2FwZSB6b25lIHNlcGFyYXRvciBmb3IgSVB2NlxuICAgICAgICB1cmlUb2tlbnMucHVzaChfbm9ybWFsaXplSVB2Nihfbm9ybWFsaXplSVB2NChTdHJpbmcoY29tcG9uZW50cy5ob3N0KSwgcHJvdG9jb2wpLCBwcm90b2NvbCkucmVwbGFjZShwcm90b2NvbC5JUFY2QUREUkVTUywgZnVuY3Rpb24gKF8sICQxLCAkMikge1xuICAgICAgICAgICAgcmV0dXJuIFwiW1wiICsgJDEgKyAoJDIgPyBcIiUyNVwiICsgJDIgOiBcIlwiKSArIFwiXVwiO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29tcG9uZW50cy5wb3J0ID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBjb21wb25lbnRzLnBvcnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goXCI6XCIpO1xuICAgICAgICB1cmlUb2tlbnMucHVzaChTdHJpbmcoY29tcG9uZW50cy5wb3J0KSk7XG4gICAgfVxuICAgIHJldHVybiB1cmlUb2tlbnMubGVuZ3RoID8gdXJpVG9rZW5zLmpvaW4oXCJcIikgOiB1bmRlZmluZWQ7XG59XG5cbnZhciBSRFMxID0gL15cXC5cXC4/XFwvLztcbnZhciBSRFMyID0gL15cXC9cXC4oXFwvfCQpLztcbnZhciBSRFMzID0gL15cXC9cXC5cXC4oXFwvfCQpLztcbnZhciBSRFM1ID0gL15cXC8/KD86LnxcXG4pKj8oPz1cXC98JCkvO1xuZnVuY3Rpb24gcmVtb3ZlRG90U2VnbWVudHMoaW5wdXQpIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgd2hpbGUgKGlucHV0Lmxlbmd0aCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goUkRTMSkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMxLCBcIlwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5tYXRjaChSRFMyKSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzIsIFwiL1wiKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5tYXRjaChSRFMzKSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzMsIFwiL1wiKTtcbiAgICAgICAgICAgIG91dHB1dC5wb3AoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gXCIuXCIgfHwgaW5wdXQgPT09IFwiLi5cIikge1xuICAgICAgICAgICAgaW5wdXQgPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGltID0gaW5wdXQubWF0Y2goUkRTNSk7XG4gICAgICAgICAgICBpZiAoaW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IGltWzBdO1xuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2Uocy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGRvdCBzZWdtZW50IGNvbmRpdGlvblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oXCJcIik7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShjb21wb25lbnRzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgdmFyIHByb3RvY29sID0gb3B0aW9ucy5pcmkgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0w7XG4gICAgdmFyIHVyaVRva2VucyA9IFtdO1xuICAgIC8vZmluZCBzY2hlbWUgaGFuZGxlclxuICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1sob3B0aW9ucy5zY2hlbWUgfHwgY29tcG9uZW50cy5zY2hlbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKV07XG4gICAgLy9wZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBzZXJpYWxpemF0aW9uXG4gICAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUpIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKGNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgIGlmIChjb21wb25lbnRzLmhvc3QpIHtcbiAgICAgICAgLy9pZiBob3N0IGNvbXBvbmVudCBpcyBhbiBJUHY2IGFkZHJlc3NcbiAgICAgICAgaWYgKHByb3RvY29sLklQVjZBRERSRVNTLnRlc3QoY29tcG9uZW50cy5ob3N0KSkge31cbiAgICAgICAgLy9UT0RPOiBub3JtYWxpemUgSVB2NiBhZGRyZXNzIGFzIHBlciBSRkMgNTk1MlxuXG4gICAgICAgIC8vaWYgaG9zdCBjb21wb25lbnQgaXMgYSBkb21haW4gbmFtZVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmRvbWFpbkhvc3QgfHwgc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLmRvbWFpbkhvc3QpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgSUROIHZpYSBwdW55Y29kZVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9ICFvcHRpb25zLmlyaSA/IHB1bnljb2RlLnRvQVNDSUkoY29tcG9uZW50cy5ob3N0LnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHBjdERlY0NoYXJzKS50b0xvd2VyQ2FzZSgpKSA6IHB1bnljb2RlLnRvVW5pY29kZShjb21wb25lbnRzLmhvc3QpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gXCIgKyAoIW9wdGlvbnMuaXJpID8gXCJBU0NJSVwiIDogXCJVbmljb2RlXCIpICsgXCIgdmlhIHB1bnljb2RlOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIH1cbiAgICAvL25vcm1hbGl6ZSBlbmNvZGluZ1xuICAgIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBwcm90b2NvbCk7XG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiICYmIGNvbXBvbmVudHMuc2NoZW1lKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMuc2NoZW1lKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goXCI6XCIpO1xuICAgIH1cbiAgICB2YXIgYXV0aG9yaXR5ID0gX3JlY29tcG9zZUF1dGhvcml0eShjb21wb25lbnRzLCBvcHRpb25zKTtcbiAgICBpZiAoYXV0aG9yaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiKSB7XG4gICAgICAgICAgICB1cmlUb2tlbnMucHVzaChcIi8vXCIpO1xuICAgICAgICB9XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGF1dGhvcml0eSk7XG4gICAgICAgIGlmIChjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5wYXRoLmNoYXJBdCgwKSAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgIHVyaVRva2Vucy5wdXNoKFwiL1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tcG9uZW50cy5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHMgPSBjb21wb25lbnRzLnBhdGg7XG4gICAgICAgIGlmICghb3B0aW9ucy5hYnNvbHV0ZVBhdGggJiYgKCFzY2hlbWVIYW5kbGVyIHx8ICFzY2hlbWVIYW5kbGVyLmFic29sdXRlUGF0aCkpIHtcbiAgICAgICAgICAgIHMgPSByZW1vdmVEb3RTZWdtZW50cyhzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXV0aG9yaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoL15cXC9cXC8vLCBcIi8lMkZcIik7IC8vZG9uJ3QgYWxsb3cgdGhlIHBhdGggdG8gc3RhcnQgd2l0aCBcIi8vXCJcbiAgICAgICAgfVxuICAgICAgICB1cmlUb2tlbnMucHVzaChzKTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cmlUb2tlbnMucHVzaChcIj9cIik7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMucXVlcnkpO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50cy5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiI1wiKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5mcmFnbWVudCk7XG4gICAgfVxuICAgIHJldHVybiB1cmlUb2tlbnMuam9pbihcIlwiKTsgLy9tZXJnZSB0b2tlbnMgaW50byBhIHN0cmluZ1xufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50cyhiYXNlLCByZWxhdGl2ZSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgc2tpcE5vcm1hbGl6YXRpb24gPSBhcmd1bWVudHNbM107XG5cbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgaWYgKCFza2lwTm9ybWFsaXphdGlvbikge1xuICAgICAgICBiYXNlID0gcGFyc2Uoc2VyaWFsaXplKGJhc2UsIG9wdGlvbnMpLCBvcHRpb25zKTsgLy9ub3JtYWxpemUgYmFzZSBjb21wb25lbnRzXG4gICAgICAgIHJlbGF0aXZlID0gcGFyc2Uoc2VyaWFsaXplKHJlbGF0aXZlLCBvcHRpb25zKSwgb3B0aW9ucyk7IC8vbm9ybWFsaXplIHJlbGF0aXZlIGNvbXBvbmVudHNcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKCFvcHRpb25zLnRvbGVyYW50ICYmIHJlbGF0aXZlLnNjaGVtZSkge1xuICAgICAgICB0YXJnZXQuc2NoZW1lID0gcmVsYXRpdmUuc2NoZW1lO1xuICAgICAgICAvL3RhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgICAgIHRhcmdldC51c2VyaW5mbyA9IHJlbGF0aXZlLnVzZXJpbmZvO1xuICAgICAgICB0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoIHx8IFwiXCIpO1xuICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVsYXRpdmUudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvL3RhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgICAgICAgICB0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mbztcbiAgICAgICAgICAgIHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCBcIlwiKTtcbiAgICAgICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGg7XG4gICAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gYmFzZS5xdWVyeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5wYXRoLmNoYXJBdCgwKSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGJhc2UudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCBiYXNlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCBiYXNlLnBvcnQgIT09IHVuZGVmaW5lZCkgJiYgIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBcIi9cIiArIHJlbGF0aXZlLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZWxhdGl2ZS5wYXRoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGguc2xpY2UoMCwgYmFzZS5wYXRoLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpICsgcmVsYXRpdmUucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHRhcmdldC5wYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3RhcmdldC5hdXRob3JpdHkgPSBiYXNlLmF1dGhvcml0eTtcbiAgICAgICAgICAgIHRhcmdldC51c2VyaW5mbyA9IGJhc2UudXNlcmluZm87XG4gICAgICAgICAgICB0YXJnZXQuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgIHRhcmdldC5wb3J0ID0gYmFzZS5wb3J0O1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5zY2hlbWUgPSBiYXNlLnNjaGVtZTtcbiAgICB9XG4gICAgdGFyZ2V0LmZyYWdtZW50ID0gcmVsYXRpdmUuZnJhZ21lbnQ7XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShiYXNlVVJJLCByZWxhdGl2ZVVSSSwgb3B0aW9ucykge1xuICAgIHZhciBzY2hlbWVsZXNzT3B0aW9ucyA9IGFzc2lnbih7IHNjaGVtZTogJ251bGwnIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBzZXJpYWxpemUocmVzb2x2ZUNvbXBvbmVudHMocGFyc2UoYmFzZVVSSSwgc2NoZW1lbGVzc09wdGlvbnMpLCBwYXJzZShyZWxhdGl2ZVVSSSwgc2NoZW1lbGVzc09wdGlvbnMpLCBzY2hlbWVsZXNzT3B0aW9ucywgdHJ1ZSksIHNjaGVtZWxlc3NPcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplKHVyaSwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdXJpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHVyaSA9IHNlcmlhbGl6ZShwYXJzZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVPZih1cmkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHVyaSA9IHBhcnNlKHNlcmlhbGl6ZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHVyaTtcbn1cblxuZnVuY3Rpb24gZXF1YWwodXJpQSwgdXJpQiwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdXJpQSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB1cmlBID0gc2VyaWFsaXplKHBhcnNlKHVyaUEsIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVPZih1cmlBKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB1cmlBID0gc2VyaWFsaXplKHVyaUEsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHVyaUIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdXJpQiA9IHNlcmlhbGl6ZShwYXJzZSh1cmlCLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0eXBlT2YodXJpQikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdXJpQiA9IHNlcmlhbGl6ZSh1cmlCLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHVyaUEgPT09IHVyaUI7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUNvbXBvbmVudChzdHIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gc3RyICYmIHN0ci50b1N0cmluZygpLnJlcGxhY2UoIW9wdGlvbnMgfHwgIW9wdGlvbnMuaXJpID8gVVJJX1BST1RPQ09MLkVTQ0FQRSA6IElSSV9QUk9UT0NPTC5FU0NBUEUsIHBjdEVuY0NoYXIpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZUNvbXBvbmVudChzdHIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gc3RyICYmIHN0ci50b1N0cmluZygpLnJlcGxhY2UoIW9wdGlvbnMgfHwgIW9wdGlvbnMuaXJpID8gVVJJX1BST1RPQ09MLlBDVF9FTkNPREVEIDogSVJJX1BST1RPQ09MLlBDVF9FTkNPREVELCBwY3REZWNDaGFycyk7XG59XG5cbnZhciBoYW5kbGVyID0ge1xuICAgIHNjaGVtZTogXCJodHRwXCIsXG4gICAgZG9tYWluSG9zdDogdHJ1ZSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICAvL3JlcG9ydCBtaXNzaW5nIGhvc3RcbiAgICAgICAgaWYgKCFjb21wb25lbnRzLmhvc3QpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSFRUUCBVUklzIG11c3QgaGF2ZSBhIGhvc3QuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBzZWN1cmUgPSBTdHJpbmcoY29tcG9uZW50cy5zY2hlbWUpLnRvTG93ZXJDYXNlKCkgPT09IFwiaHR0cHNcIjtcbiAgICAgICAgLy9ub3JtYWxpemUgdGhlIGRlZmF1bHQgcG9ydFxuICAgICAgICBpZiAoY29tcG9uZW50cy5wb3J0ID09PSAoc2VjdXJlID8gNDQzIDogODApIHx8IGNvbXBvbmVudHMucG9ydCA9PT0gXCJcIikge1xuICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vbm9ybWFsaXplIHRoZSBlbXB0eSBwYXRoXG4gICAgICAgIGlmICghY29tcG9uZW50cy5wYXRoKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSBcIi9cIjtcbiAgICAgICAgfVxuICAgICAgICAvL05PVEU6IFdlIGRvIG5vdCBwYXJzZSBxdWVyeSBzdHJpbmdzIGZvciBIVFRQIFVSSXNcbiAgICAgICAgLy9hcyBXV1cgRm9ybSBVcmwgRW5jb2RlZCBxdWVyeSBzdHJpbmdzIGFyZSBwYXJ0IG9mIHRoZSBIVE1MNCsgc3BlYyxcbiAgICAgICAgLy9hbmQgbm90IHRoZSBIVFRQIHNwZWMuXG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbn07XG5cbnZhciBoYW5kbGVyJDEgPSB7XG4gICAgc2NoZW1lOiBcImh0dHBzXCIsXG4gICAgZG9tYWluSG9zdDogaGFuZGxlci5kb21haW5Ib3N0LFxuICAgIHBhcnNlOiBoYW5kbGVyLnBhcnNlLFxuICAgIHNlcmlhbGl6ZTogaGFuZGxlci5zZXJpYWxpemVcbn07XG5cbmZ1bmN0aW9uIGlzU2VjdXJlKHdzQ29tcG9uZW50cykge1xuICAgIHJldHVybiB0eXBlb2Ygd3NDb21wb25lbnRzLnNlY3VyZSA9PT0gJ2Jvb2xlYW4nID8gd3NDb21wb25lbnRzLnNlY3VyZSA6IFN0cmluZyh3c0NvbXBvbmVudHMuc2NoZW1lKS50b0xvd2VyQ2FzZSgpID09PSBcIndzc1wiO1xufVxuLy9SRkMgNjQ1NVxudmFyIGhhbmRsZXIkMiA9IHtcbiAgICBzY2hlbWU6IFwid3NcIixcbiAgICBkb21haW5Ib3N0OiB0cnVlLFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB3c0NvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgICAgICAvL2luZGljYXRlIGlmIHRoZSBzZWN1cmUgZmxhZyBpcyBzZXRcbiAgICAgICAgd3NDb21wb25lbnRzLnNlY3VyZSA9IGlzU2VjdXJlKHdzQ29tcG9uZW50cyk7XG4gICAgICAgIC8vY29uc3RydWN0IHJlc291Y2UgbmFtZVxuICAgICAgICB3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lID0gKHdzQ29tcG9uZW50cy5wYXRoIHx8ICcvJykgKyAod3NDb21wb25lbnRzLnF1ZXJ5ID8gJz8nICsgd3NDb21wb25lbnRzLnF1ZXJ5IDogJycpO1xuICAgICAgICB3c0NvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgd3NDb21wb25lbnRzLnF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gd3NDb21wb25lbnRzO1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUod3NDb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIC8vbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcbiAgICAgICAgaWYgKHdzQ29tcG9uZW50cy5wb3J0ID09PSAoaXNTZWN1cmUod3NDb21wb25lbnRzKSA/IDQ0MyA6IDgwKSB8fCB3c0NvbXBvbmVudHMucG9ydCA9PT0gXCJcIikge1xuICAgICAgICAgICAgd3NDb21wb25lbnRzLnBvcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9lbnN1cmUgc2NoZW1lIG1hdGNoZXMgc2VjdXJlIGZsYWdcbiAgICAgICAgaWYgKHR5cGVvZiB3c0NvbXBvbmVudHMuc2VjdXJlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5zY2hlbWUgPSB3c0NvbXBvbmVudHMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuICAgICAgICAgICAgd3NDb21wb25lbnRzLnNlY3VyZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvL3JlY29uc3RydWN0IHBhdGggZnJvbSByZXNvdXJjZSBuYW1lXG4gICAgICAgIGlmICh3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lKSB7XG4gICAgICAgICAgICB2YXIgX3dzQ29tcG9uZW50cyRyZXNvdXJjID0gd3NDb21wb25lbnRzLnJlc291cmNlTmFtZS5zcGxpdCgnPycpLFxuICAgICAgICAgICAgICAgIF93c0NvbXBvbmVudHMkcmVzb3VyYzIgPSBzbGljZWRUb0FycmF5KF93c0NvbXBvbmVudHMkcmVzb3VyYywgMiksXG4gICAgICAgICAgICAgICAgcGF0aCA9IF93c0NvbXBvbmVudHMkcmVzb3VyYzJbMF0sXG4gICAgICAgICAgICAgICAgcXVlcnkgPSBfd3NDb21wb25lbnRzJHJlc291cmMyWzFdO1xuXG4gICAgICAgICAgICB3c0NvbXBvbmVudHMucGF0aCA9IHBhdGggJiYgcGF0aCAhPT0gJy8nID8gcGF0aCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgd3NDb21wb25lbnRzLnJlc291cmNlTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvL2ZvcmJpZCBmcmFnbWVudCBjb21wb25lbnRcbiAgICAgICAgd3NDb21wb25lbnRzLmZyYWdtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gd3NDb21wb25lbnRzO1xuICAgIH1cbn07XG5cbnZhciBoYW5kbGVyJDMgPSB7XG4gICAgc2NoZW1lOiBcIndzc1wiLFxuICAgIGRvbWFpbkhvc3Q6IGhhbmRsZXIkMi5kb21haW5Ib3N0LFxuICAgIHBhcnNlOiBoYW5kbGVyJDIucGFyc2UsXG4gICAgc2VyaWFsaXplOiBoYW5kbGVyJDIuc2VyaWFsaXplXG59O1xuXG52YXIgTyA9IHt9O1xudmFyIGlzSVJJID0gdHJ1ZTtcbi8vUkZDIDM5ODZcbnZhciBVTlJFU0VSVkVEJCQgPSBcIltBLVphLXowLTlcXFxcLVxcXFwuXFxcXF9cXFxcflwiICsgKGlzSVJJID8gXCJcXFxceEEwLVxcXFx1MjAwRFxcXFx1MjAxMC1cXFxcdTIwMjlcXFxcdTIwMkYtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZcIiA6IFwiXCIpICsgXCJdXCI7XG52YXIgSEVYRElHJCQgPSBcIlswLTlBLUZhLWZdXCI7IC8vY2FzZS1pbnNlbnNpdGl2ZVxudmFyIFBDVF9FTkNPREVEJCA9IHN1YmV4cChzdWJleHAoXCIlW0VGZWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVbODlBLUZhLWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpKTsgLy9leHBhbmRlZFxuLy9SRkMgNTMyMiwgZXhjZXB0IHRoZXNlIHN5bWJvbHMgYXMgcGVyIFJGQyA2MDY4OiBAIDogLyA/ICMgWyBdICYgOyA9XG4vL2NvbnN0IEFURVhUJCQgPSBcIltBLVphLXowLTlcXFxcIVxcXFwjXFxcXCRcXFxcJVxcXFwmXFxcXCdcXFxcKlxcXFwrXFxcXC1cXFxcL1xcXFw9XFxcXD9cXFxcXlxcXFxfXFxcXGBcXFxce1xcXFx8XFxcXH1cXFxcfl1cIjtcbi8vY29uc3QgV1NQJCQgPSBcIltcXFxceDIwXFxcXHgwOV1cIjtcbi8vY29uc3QgT0JTX1FURVhUJCQgPSBcIltcXFxceDAxLVxcXFx4MDhcXFxceDBCXFxcXHgwQ1xcXFx4MEUtXFxcXHgxRlxcXFx4N0ZdXCI7ICAvLyglZDEtOCAvICVkMTEtMTIgLyAlZDE0LTMxIC8gJWQxMjcpXG4vL2NvbnN0IFFURVhUJCQgPSBtZXJnZShcIltcXFxceDIxXFxcXHgyMy1cXFxceDVCXFxcXHg1RC1cXFxceDdFXVwiLCBPQlNfUVRFWFQkJCk7ICAvLyVkMzMgLyAlZDM1LTkxIC8gJWQ5My0xMjYgLyBvYnMtcXRleHRcbi8vY29uc3QgVkNIQVIkJCA9IFwiW1xcXFx4MjEtXFxcXHg3RV1cIjtcbi8vY29uc3QgV1NQJCQgPSBcIltcXFxceDIwXFxcXHgwOV1cIjtcbi8vY29uc3QgT0JTX1FQJCA9IHN1YmV4cChcIlxcXFxcXFxcXCIgKyBtZXJnZShcIltcXFxceDAwXFxcXHgwRFxcXFx4MEFdXCIsIE9CU19RVEVYVCQkKSk7ICAvLyVkMCAvIENSIC8gTEYgLyBvYnMtcXRleHRcbi8vY29uc3QgRldTJCA9IHN1YmV4cChzdWJleHAoV1NQJCQgKyBcIipcIiArIFwiXFxcXHgwRFxcXFx4MEFcIikgKyBcIj9cIiArIFdTUCQkICsgXCIrXCIpO1xuLy9jb25zdCBRVU9URURfUEFJUiQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXFxcXFxcIiArIHN1YmV4cChWQ0hBUiQkICsgXCJ8XCIgKyBXU1AkJCkpICsgXCJ8XCIgKyBPQlNfUVAkKTtcbi8vY29uc3QgUVVPVEVEX1NUUklORyQgPSBzdWJleHAoJ1xcXFxcIicgKyBzdWJleHAoRldTJCArIFwiP1wiICsgUUNPTlRFTlQkKSArIFwiKlwiICsgRldTJCArIFwiP1wiICsgJ1xcXFxcIicpO1xudmFyIEFURVhUJCQgPSBcIltBLVphLXowLTlcXFxcIVxcXFwkXFxcXCVcXFxcJ1xcXFwqXFxcXCtcXFxcLVxcXFxeXFxcXF9cXFxcYFxcXFx7XFxcXHxcXFxcfVxcXFx+XVwiO1xudmFyIFFURVhUJCQgPSBcIltcXFxcIVxcXFwkXFxcXCVcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcLVxcXFwuMC05XFxcXDxcXFxcPkEtWlxcXFx4NUUtXFxcXHg3RV1cIjtcbnZhciBWQ0hBUiQkID0gbWVyZ2UoUVRFWFQkJCwgXCJbXFxcXFxcXCJcXFxcXFxcXF1cIik7XG52YXIgU09NRV9ERUxJTVMkJCA9IFwiW1xcXFwhXFxcXCRcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcO1xcXFw6XFxcXEBdXCI7XG52YXIgVU5SRVNFUlZFRCA9IG5ldyBSZWdFeHAoVU5SRVNFUlZFRCQkLCBcImdcIik7XG52YXIgUENUX0VOQ09ERUQgPSBuZXcgUmVnRXhwKFBDVF9FTkNPREVEJCwgXCJnXCIpO1xudmFyIE5PVF9MT0NBTF9QQVJUID0gbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBBVEVYVCQkLCBcIltcXFxcLl1cIiwgJ1tcXFxcXCJdJywgVkNIQVIkJCksIFwiZ1wiKTtcbnZhciBOT1RfSEZOQU1FID0gbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBVTlJFU0VSVkVEJCQsIFNPTUVfREVMSU1TJCQpLCBcImdcIik7XG52YXIgTk9UX0hGVkFMVUUgPSBOT1RfSEZOQU1FO1xuZnVuY3Rpb24gZGVjb2RlVW5yZXNlcnZlZChzdHIpIHtcbiAgICB2YXIgZGVjU3RyID0gcGN0RGVjQ2hhcnMoc3RyKTtcbiAgICByZXR1cm4gIWRlY1N0ci5tYXRjaChVTlJFU0VSVkVEKSA/IHN0ciA6IGRlY1N0cjtcbn1cbnZhciBoYW5kbGVyJDQgPSB7XG4gICAgc2NoZW1lOiBcIm1haWx0b1wiLFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSQkMShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBtYWlsdG9Db21wb25lbnRzID0gY29tcG9uZW50cztcbiAgICAgICAgdmFyIHRvID0gbWFpbHRvQ29tcG9uZW50cy50byA9IG1haWx0b0NvbXBvbmVudHMucGF0aCA/IG1haWx0b0NvbXBvbmVudHMucGF0aC5zcGxpdChcIixcIikgOiBbXTtcbiAgICAgICAgbWFpbHRvQ29tcG9uZW50cy5wYXRoID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFpbHRvQ29tcG9uZW50cy5xdWVyeSkge1xuICAgICAgICAgICAgdmFyIHVua25vd25IZWFkZXJzID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgdmFyIGhmaWVsZHMgPSBtYWlsdG9Db21wb25lbnRzLnF1ZXJ5LnNwbGl0KFwiJlwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwLCB4bCA9IGhmaWVsZHMubGVuZ3RoOyB4IDwgeGw7ICsreCkge1xuICAgICAgICAgICAgICAgIHZhciBoZmllbGQgPSBoZmllbGRzW3hdLnNwbGl0KFwiPVwiKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGhmaWVsZFswXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG9cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b0FkZHJzID0gaGZpZWxkWzFdLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF94ID0gMCwgX3hsID0gdG9BZGRycy5sZW5ndGg7IF94IDwgX3hsOyArK194KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8ucHVzaCh0b0FkZHJzW194XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1YmplY3RcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haWx0b0NvbXBvbmVudHMuc3ViamVjdCA9IHVuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFsxXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haWx0b0NvbXBvbmVudHMuYm9keSA9IHVuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFsxXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVua25vd25IZWFkZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzBdLCBvcHRpb25zKV0gPSB1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVua25vd25IZWFkZXJzKSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIG1haWx0b0NvbXBvbmVudHMucXVlcnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAodmFyIF94MiA9IDAsIF94bDIgPSB0by5sZW5ndGg7IF94MiA8IF94bDI7ICsrX3gyKSB7XG4gICAgICAgICAgICB2YXIgYWRkciA9IHRvW194Ml0uc3BsaXQoXCJAXCIpO1xuICAgICAgICAgICAgYWRkclswXSA9IHVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMF0pO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnVuaWNvZGVTdXBwb3J0KSB7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IFVuaWNvZGUgSUROIC0+IEFTQ0lJIElETlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJbMV0gPSBwdW55Y29kZS50b0FTQ0lJKHVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMV0sIG9wdGlvbnMpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbHRvQ29tcG9uZW50cy5lcnJvciA9IG1haWx0b0NvbXBvbmVudHMuZXJyb3IgfHwgXCJFbWFpbCBhZGRyZXNzJ3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gQVNDSUkgdmlhIHB1bnljb2RlOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRyWzFdID0gdW5lc2NhcGVDb21wb25lbnQoYWRkclsxXSwgb3B0aW9ucykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvW194Ml0gPSBhZGRyLmpvaW4oXCJAXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWlsdG9Db21wb25lbnRzO1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUkJDEobWFpbHRvQ29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgY29tcG9uZW50cyA9IG1haWx0b0NvbXBvbmVudHM7XG4gICAgICAgIHZhciB0byA9IHRvQXJyYXkobWFpbHRvQ29tcG9uZW50cy50byk7XG4gICAgICAgIGlmICh0bykge1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDAsIHhsID0gdG8ubGVuZ3RoOyB4IDwgeGw7ICsreCkge1xuICAgICAgICAgICAgICAgIHZhciB0b0FkZHIgPSBTdHJpbmcodG9beF0pO1xuICAgICAgICAgICAgICAgIHZhciBhdElkeCA9IHRvQWRkci5sYXN0SW5kZXhPZihcIkBcIik7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsUGFydCA9IHRvQWRkci5zbGljZSgwLCBhdElkeCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpLnJlcGxhY2UoTk9UX0xPQ0FMX1BBUlQsIHBjdEVuY0NoYXIpO1xuICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSB0b0FkZHIuc2xpY2UoYXRJZHggKyAxKTtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgSUROIHZpYSBwdW55Y29kZVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbiA9ICFvcHRpb25zLmlyaSA/IHB1bnljb2RlLnRvQVNDSUkodW5lc2NhcGVDb21wb25lbnQoZG9tYWluLCBvcHRpb25zKS50b0xvd2VyQ2FzZSgpKSA6IHB1bnljb2RlLnRvVW5pY29kZShkb21haW4pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJFbWFpbCBhZGRyZXNzJ3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gXCIgKyAoIW9wdGlvbnMuaXJpID8gXCJBU0NJSVwiIDogXCJVbmljb2RlXCIpICsgXCIgdmlhIHB1bnljb2RlOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvW3hdID0gbG9jYWxQYXJ0ICsgXCJAXCIgKyBkb21haW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSB0by5qb2luKFwiLFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVhZGVycyA9IG1haWx0b0NvbXBvbmVudHMuaGVhZGVycyA9IG1haWx0b0NvbXBvbmVudHMuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgaWYgKG1haWx0b0NvbXBvbmVudHMuc3ViamVjdCkgaGVhZGVyc1tcInN1YmplY3RcIl0gPSBtYWlsdG9Db21wb25lbnRzLnN1YmplY3Q7XG4gICAgICAgIGlmIChtYWlsdG9Db21wb25lbnRzLmJvZHkpIGhlYWRlcnNbXCJib2R5XCJdID0gbWFpbHRvQ29tcG9uZW50cy5ib2R5O1xuICAgICAgICB2YXIgZmllbGRzID0gW107XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gaGVhZGVycykge1xuICAgICAgICAgICAgaWYgKGhlYWRlcnNbbmFtZV0gIT09IE9bbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChuYW1lLnJlcGxhY2UoUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKS5yZXBsYWNlKE5PVF9IRk5BTUUsIHBjdEVuY0NoYXIpICsgXCI9XCIgKyBoZWFkZXJzW25hbWVdLnJlcGxhY2UoUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKS5yZXBsYWNlKE5PVF9IRlZBTFVFLCBwY3RFbmNDaGFyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucXVlcnkgPSBmaWVsZHMuam9pbihcIiZcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgfVxufTtcblxudmFyIFVSTl9QQVJTRSA9IC9eKFteXFw6XSspXFw6KC4qKS87XG4vL1JGQyAyMTQxXG52YXIgaGFuZGxlciQ1ID0ge1xuICAgIHNjaGVtZTogXCJ1cm5cIixcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UkJDEoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IGNvbXBvbmVudHMucGF0aCAmJiBjb21wb25lbnRzLnBhdGgubWF0Y2goVVJOX1BBUlNFKTtcbiAgICAgICAgdmFyIHVybkNvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgdmFyIHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudHMuc2NoZW1lIHx8IFwidXJuXCI7XG4gICAgICAgICAgICB2YXIgbmlkID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIG5zcyA9IG1hdGNoZXNbMl07XG4gICAgICAgICAgICB2YXIgdXJuU2NoZW1lID0gc2NoZW1lICsgXCI6XCIgKyAob3B0aW9ucy5uaWQgfHwgbmlkKTtcbiAgICAgICAgICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1t1cm5TY2hlbWVdO1xuICAgICAgICAgICAgdXJuQ29tcG9uZW50cy5uaWQgPSBuaWQ7XG4gICAgICAgICAgICB1cm5Db21wb25lbnRzLm5zcyA9IG5zcztcbiAgICAgICAgICAgIHVybkNvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChzY2hlbWVIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdXJuQ29tcG9uZW50cyA9IHNjaGVtZUhhbmRsZXIucGFyc2UodXJuQ29tcG9uZW50cywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cm5Db21wb25lbnRzLmVycm9yID0gdXJuQ29tcG9uZW50cy5lcnJvciB8fCBcIlVSTiBjYW4gbm90IGJlIHBhcnNlZC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJuQ29tcG9uZW50cztcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplJCQxKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudHMuc2NoZW1lIHx8IFwidXJuXCI7XG4gICAgICAgIHZhciBuaWQgPSB1cm5Db21wb25lbnRzLm5pZDtcbiAgICAgICAgdmFyIHVyblNjaGVtZSA9IHNjaGVtZSArIFwiOlwiICsgKG9wdGlvbnMubmlkIHx8IG5pZCk7XG4gICAgICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1t1cm5TY2hlbWVdO1xuICAgICAgICBpZiAoc2NoZW1lSGFuZGxlcikge1xuICAgICAgICAgICAgdXJuQ29tcG9uZW50cyA9IHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cmlDb21wb25lbnRzID0gdXJuQ29tcG9uZW50cztcbiAgICAgICAgdmFyIG5zcyA9IHVybkNvbXBvbmVudHMubnNzO1xuICAgICAgICB1cmlDb21wb25lbnRzLnBhdGggPSAobmlkIHx8IG9wdGlvbnMubmlkKSArIFwiOlwiICsgbnNzO1xuICAgICAgICByZXR1cm4gdXJpQ29tcG9uZW50cztcbiAgICB9XG59O1xuXG52YXIgVVVJRCA9IC9eWzAtOUEtRmEtZl17OH0oPzpcXC1bMC05QS1GYS1mXXs0fSl7M31cXC1bMC05QS1GYS1mXXsxMn0kLztcbi8vUkZDIDQxMjJcbnZhciBoYW5kbGVyJDYgPSB7XG4gICAgc2NoZW1lOiBcInVybjp1dWlkXCIsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHV1aWRDb21wb25lbnRzID0gdXJuQ29tcG9uZW50cztcbiAgICAgICAgdXVpZENvbXBvbmVudHMudXVpZCA9IHV1aWRDb21wb25lbnRzLm5zcztcbiAgICAgICAgdXVpZENvbXBvbmVudHMubnNzID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgKCF1dWlkQ29tcG9uZW50cy51dWlkIHx8ICF1dWlkQ29tcG9uZW50cy51dWlkLm1hdGNoKFVVSUQpKSkge1xuICAgICAgICAgICAgdXVpZENvbXBvbmVudHMuZXJyb3IgPSB1dWlkQ29tcG9uZW50cy5lcnJvciB8fCBcIlVVSUQgaXMgbm90IHZhbGlkLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dWlkQ29tcG9uZW50cztcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplKHV1aWRDb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB1cm5Db21wb25lbnRzID0gdXVpZENvbXBvbmVudHM7XG4gICAgICAgIC8vbm9ybWFsaXplIFVVSURcbiAgICAgICAgdXJuQ29tcG9uZW50cy5uc3MgPSAodXVpZENvbXBvbmVudHMudXVpZCB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gdXJuQ29tcG9uZW50cztcbiAgICB9XG59O1xuXG5TQ0hFTUVTW2hhbmRsZXIuc2NoZW1lXSA9IGhhbmRsZXI7XG5TQ0hFTUVTW2hhbmRsZXIkMS5zY2hlbWVdID0gaGFuZGxlciQxO1xuU0NIRU1FU1toYW5kbGVyJDIuc2NoZW1lXSA9IGhhbmRsZXIkMjtcblNDSEVNRVNbaGFuZGxlciQzLnNjaGVtZV0gPSBoYW5kbGVyJDM7XG5TQ0hFTUVTW2hhbmRsZXIkNC5zY2hlbWVdID0gaGFuZGxlciQ0O1xuU0NIRU1FU1toYW5kbGVyJDUuc2NoZW1lXSA9IGhhbmRsZXIkNTtcblNDSEVNRVNbaGFuZGxlciQ2LnNjaGVtZV0gPSBoYW5kbGVyJDY7XG5cbmV4cG9ydHMuU0NIRU1FUyA9IFNDSEVNRVM7XG5leHBvcnRzLnBjdEVuY0NoYXIgPSBwY3RFbmNDaGFyO1xuZXhwb3J0cy5wY3REZWNDaGFycyA9IHBjdERlY0NoYXJzO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5yZW1vdmVEb3RTZWdtZW50cyA9IHJlbW92ZURvdFNlZ21lbnRzO1xuZXhwb3J0cy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG5leHBvcnRzLnJlc29sdmVDb21wb25lbnRzID0gcmVzb2x2ZUNvbXBvbmVudHM7XG5leHBvcnRzLnJlc29sdmUgPSByZXNvbHZlO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5leHBvcnRzLmVxdWFsID0gZXF1YWw7XG5leHBvcnRzLmVzY2FwZUNvbXBvbmVudCA9IGVzY2FwZUNvbXBvbmVudDtcbmV4cG9ydHMudW5lc2NhcGVDb21wb25lbnQgPSB1bmVzY2FwZUNvbXBvbmVudDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVyaS5hbGwuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHVyaSA9IHJlcXVpcmUoXCJ1cmktanNcIik7XG51cmkuY29kZSA9ICdyZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS91cmlcIikuZGVmYXVsdCc7XG5leHBvcnRzLmRlZmF1bHQgPSB1cmk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvZGVHZW4gPSBleHBvcnRzLk5hbWUgPSBleHBvcnRzLm5pbCA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLl8gPSBleHBvcnRzLktleXdvcmRDeHQgPSB2b2lkIDA7XG52YXIgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvdmFsaWRhdGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJLZXl3b3JkQ3h0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWxpZGF0ZV8xLktleXdvcmRDeHQ7IH0gfSk7XG52YXIgY29kZWdlbl8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLl87IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5zdHI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJpbmdpZnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5zdHJpbmdpZnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuaWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5uaWw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOYW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuTmFtZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvZGVHZW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5Db2RlR2VuOyB9IH0pO1xuY29uc3QgdmFsaWRhdGlvbl9lcnJvcl8xID0gcmVxdWlyZShcIi4vcnVudGltZS92YWxpZGF0aW9uX2Vycm9yXCIpO1xuY29uc3QgcmVmX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3JlZl9lcnJvclwiKTtcbmNvbnN0IHJ1bGVzXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3J1bGVzXCIpO1xuY29uc3QgY29tcGlsZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZVwiKTtcbmNvbnN0IGNvZGVnZW5fMiA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHJlc29sdmVfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvcmVzb2x2ZVwiKTtcbmNvbnN0IGRhdGFUeXBlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3ZhbGlkYXRlL2RhdGFUeXBlXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgJGRhdGFSZWZTY2hlbWEgPSByZXF1aXJlKFwiLi9yZWZzL2RhdGEuanNvblwiKTtcbmNvbnN0IHVyaV8xID0gcmVxdWlyZShcIi4vcnVudGltZS91cmlcIik7XG5jb25zdCBkZWZhdWx0UmVnRXhwID0gKHN0ciwgZmxhZ3MpID0+IG5ldyBSZWdFeHAoc3RyLCBmbGFncyk7XG5kZWZhdWx0UmVnRXhwLmNvZGUgPSBcIm5ldyBSZWdFeHBcIjtcbmNvbnN0IE1FVEFfSUdOT1JFX09QVElPTlMgPSBbXCJyZW1vdmVBZGRpdGlvbmFsXCIsIFwidXNlRGVmYXVsdHNcIiwgXCJjb2VyY2VUeXBlc1wiXTtcbmNvbnN0IEVYVF9TQ09QRV9OQU1FUyA9IG5ldyBTZXQoW1xuICAgIFwidmFsaWRhdGVcIixcbiAgICBcInNlcmlhbGl6ZVwiLFxuICAgIFwicGFyc2VcIixcbiAgICBcIndyYXBwZXJcIixcbiAgICBcInJvb3RcIixcbiAgICBcInNjaGVtYVwiLFxuICAgIFwia2V5d29yZFwiLFxuICAgIFwicGF0dGVyblwiLFxuICAgIFwiZm9ybWF0c1wiLFxuICAgIFwidmFsaWRhdGUkZGF0YVwiLFxuICAgIFwiZnVuY1wiLFxuICAgIFwib2JqXCIsXG4gICAgXCJFcnJvclwiLFxuXSk7XG5jb25zdCByZW1vdmVkT3B0aW9ucyA9IHtcbiAgICBlcnJvckRhdGFQYXRoOiBcIlwiLFxuICAgIGZvcm1hdDogXCJgdmFsaWRhdGVGb3JtYXRzOiBmYWxzZWAgY2FuIGJlIHVzZWQgaW5zdGVhZC5cIixcbiAgICBudWxsYWJsZTogJ1wibnVsbGFibGVcIiBrZXl3b3JkIGlzIHN1cHBvcnRlZCBieSBkZWZhdWx0LicsXG4gICAganNvblBvaW50ZXJzOiBcIkRlcHJlY2F0ZWQganNQcm9wZXJ0eVN5bnRheCBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICAgIGV4dGVuZFJlZnM6IFwiRGVwcmVjYXRlZCBpZ25vcmVLZXl3b3Jkc1dpdGhSZWYgY2FuIGJlIHVzZWQgaW5zdGVhZC5cIixcbiAgICBtaXNzaW5nUmVmczogXCJQYXNzIGVtcHR5IHNjaGVtYSB3aXRoICRpZCB0aGF0IHNob3VsZCBiZSBpZ25vcmVkIHRvIGFqdi5hZGRTY2hlbWEuXCIsXG4gICAgcHJvY2Vzc0NvZGU6IFwiVXNlIG9wdGlvbiBgY29kZToge3Byb2Nlc3M6IChjb2RlLCBzY2hlbWFFbnY6IG9iamVjdCkgPT4gc3RyaW5nfWBcIixcbiAgICBzb3VyY2VDb2RlOiBcIlVzZSBvcHRpb24gYGNvZGU6IHtzb3VyY2U6IHRydWV9YFwiLFxuICAgIHN0cmljdERlZmF1bHRzOiBcIkl0IGlzIGRlZmF1bHQgbm93LCBzZWUgb3B0aW9uIGBzdHJpY3RgLlwiLFxuICAgIHN0cmljdEtleXdvcmRzOiBcIkl0IGlzIGRlZmF1bHQgbm93LCBzZWUgb3B0aW9uIGBzdHJpY3RgLlwiLFxuICAgIHVuaXF1ZUl0ZW1zOiAnXCJ1bmlxdWVJdGVtc1wiIGtleXdvcmQgaXMgYWx3YXlzIHZhbGlkYXRlZC4nLFxuICAgIHVua25vd25Gb3JtYXRzOiBcIkRpc2FibGUgc3RyaWN0IG1vZGUgb3IgcGFzcyBgdHJ1ZWAgdG8gYGFqdi5hZGRGb3JtYXRgIChvciBgZm9ybWF0c2Agb3B0aW9uKS5cIixcbiAgICBjYWNoZTogXCJNYXAgaXMgdXNlZCBhcyBjYWNoZSwgc2NoZW1hIG9iamVjdCBhcyBrZXkuXCIsXG4gICAgc2VyaWFsaXplOiBcIk1hcCBpcyB1c2VkIGFzIGNhY2hlLCBzY2hlbWEgb2JqZWN0IGFzIGtleS5cIixcbiAgICBhanZFcnJvcnM6IFwiSXQgaXMgZGVmYXVsdCBub3cuXCIsXG59O1xuY29uc3QgZGVwcmVjYXRlZE9wdGlvbnMgPSB7XG4gICAgaWdub3JlS2V5d29yZHNXaXRoUmVmOiBcIlwiLFxuICAgIGpzUHJvcGVydHlTeW50YXg6IFwiXCIsXG4gICAgdW5pY29kZTogJ1wibWluTGVuZ3RoXCIvXCJtYXhMZW5ndGhcIiBhY2NvdW50IGZvciB1bmljb2RlIGNoYXJhY3RlcnMgYnkgZGVmYXVsdC4nLFxufTtcbmNvbnN0IE1BWF9FWFBSRVNTSU9OID0gMjAwO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHJlcXVpcmVkT3B0aW9ucyhvKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX20sIF9vLCBfcCwgX3EsIF9yLCBfcywgX3QsIF91LCBfdiwgX3csIF94LCBfeSwgX3osIF8wO1xuICAgIGNvbnN0IHMgPSBvLnN0cmljdDtcbiAgICBjb25zdCBfb3B0eiA9IChfYSA9IG8uY29kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGltaXplO1xuICAgIGNvbnN0IG9wdGltaXplID0gX29wdHogPT09IHRydWUgfHwgX29wdHogPT09IHVuZGVmaW5lZCA/IDEgOiBfb3B0eiB8fCAwO1xuICAgIGNvbnN0IHJlZ0V4cCA9IChfYyA9IChfYiA9IG8uY29kZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlZ0V4cCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZGVmYXVsdFJlZ0V4cDtcbiAgICBjb25zdCB1cmlSZXNvbHZlciA9IChfZCA9IG8udXJpUmVzb2x2ZXIpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHVyaV8xLmRlZmF1bHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RyaWN0U2NoZW1hOiAoX2YgPSAoX2UgPSBvLnN0cmljdFNjaGVtYSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogcykgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogdHJ1ZSxcbiAgICAgICAgc3RyaWN0TnVtYmVyczogKF9oID0gKF9nID0gby5zdHJpY3ROdW1iZXJzKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBzKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiB0cnVlLFxuICAgICAgICBzdHJpY3RUeXBlczogKF9rID0gKF9qID0gby5zdHJpY3RUeXBlcykgIT09IG51bGwgJiYgX2ogIT09IHZvaWQgMCA/IF9qIDogcykgIT09IG51bGwgJiYgX2sgIT09IHZvaWQgMCA/IF9rIDogXCJsb2dcIixcbiAgICAgICAgc3RyaWN0VHVwbGVzOiAoX20gPSAoX2wgPSBvLnN0cmljdFR1cGxlcykgIT09IG51bGwgJiYgX2wgIT09IHZvaWQgMCA/IF9sIDogcykgIT09IG51bGwgJiYgX20gIT09IHZvaWQgMCA/IF9tIDogXCJsb2dcIixcbiAgICAgICAgc3RyaWN0UmVxdWlyZWQ6IChfcCA9IChfbyA9IG8uc3RyaWN0UmVxdWlyZWQpICE9PSBudWxsICYmIF9vICE9PSB2b2lkIDAgPyBfbyA6IHMpICE9PSBudWxsICYmIF9wICE9PSB2b2lkIDAgPyBfcCA6IGZhbHNlLFxuICAgICAgICBjb2RlOiBvLmNvZGUgPyB7IC4uLm8uY29kZSwgb3B0aW1pemUsIHJlZ0V4cCB9IDogeyBvcHRpbWl6ZSwgcmVnRXhwIH0sXG4gICAgICAgIGxvb3BSZXF1aXJlZDogKF9xID0gby5sb29wUmVxdWlyZWQpICE9PSBudWxsICYmIF9xICE9PSB2b2lkIDAgPyBfcSA6IE1BWF9FWFBSRVNTSU9OLFxuICAgICAgICBsb29wRW51bTogKF9yID0gby5sb29wRW51bSkgIT09IG51bGwgJiYgX3IgIT09IHZvaWQgMCA/IF9yIDogTUFYX0VYUFJFU1NJT04sXG4gICAgICAgIG1ldGE6IChfcyA9IG8ubWV0YSkgIT09IG51bGwgJiYgX3MgIT09IHZvaWQgMCA/IF9zIDogdHJ1ZSxcbiAgICAgICAgbWVzc2FnZXM6IChfdCA9IG8ubWVzc2FnZXMpICE9PSBudWxsICYmIF90ICE9PSB2b2lkIDAgPyBfdCA6IHRydWUsXG4gICAgICAgIGlubGluZVJlZnM6IChfdSA9IG8uaW5saW5lUmVmcykgIT09IG51bGwgJiYgX3UgIT09IHZvaWQgMCA/IF91IDogdHJ1ZSxcbiAgICAgICAgc2NoZW1hSWQ6IChfdiA9IG8uc2NoZW1hSWQpICE9PSBudWxsICYmIF92ICE9PSB2b2lkIDAgPyBfdiA6IFwiJGlkXCIsXG4gICAgICAgIGFkZFVzZWRTY2hlbWE6IChfdyA9IG8uYWRkVXNlZFNjaGVtYSkgIT09IG51bGwgJiYgX3cgIT09IHZvaWQgMCA/IF93IDogdHJ1ZSxcbiAgICAgICAgdmFsaWRhdGVTY2hlbWE6IChfeCA9IG8udmFsaWRhdGVTY2hlbWEpICE9PSBudWxsICYmIF94ICE9PSB2b2lkIDAgPyBfeCA6IHRydWUsXG4gICAgICAgIHZhbGlkYXRlRm9ybWF0czogKF95ID0gby52YWxpZGF0ZUZvcm1hdHMpICE9PSBudWxsICYmIF95ICE9PSB2b2lkIDAgPyBfeSA6IHRydWUsXG4gICAgICAgIHVuaWNvZGVSZWdFeHA6IChfeiA9IG8udW5pY29kZVJlZ0V4cCkgIT09IG51bGwgJiYgX3ogIT09IHZvaWQgMCA/IF96IDogdHJ1ZSxcbiAgICAgICAgaW50MzJyYW5nZTogKF8wID0gby5pbnQzMnJhbmdlKSAhPT0gbnVsbCAmJiBfMCAhPT0gdm9pZCAwID8gXzAgOiB0cnVlLFxuICAgICAgICB1cmlSZXNvbHZlcjogdXJpUmVzb2x2ZXIsXG4gICAgfTtcbn1cbmNsYXNzIEFqdiB7XG4gICAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgICAgIHRoaXMuc2NoZW1hcyA9IHt9O1xuICAgICAgICB0aGlzLnJlZnMgPSB7fTtcbiAgICAgICAgdGhpcy5mb3JtYXRzID0ge307XG4gICAgICAgIHRoaXMuX2NvbXBpbGF0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5fbG9hZGluZyA9IHt9O1xuICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgb3B0cyA9IHRoaXMub3B0cyA9IHsgLi4ub3B0cywgLi4ucmVxdWlyZWRPcHRpb25zKG9wdHMpIH07XG4gICAgICAgIGNvbnN0IHsgZXM1LCBsaW5lcyB9ID0gdGhpcy5vcHRzLmNvZGU7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBuZXcgY29kZWdlbl8yLlZhbHVlU2NvcGUoeyBzY29wZToge30sIHByZWZpeGVzOiBFWFRfU0NPUEVfTkFNRVMsIGVzNSwgbGluZXMgfSk7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gZ2V0TG9nZ2VyKG9wdHMubG9nZ2VyKTtcbiAgICAgICAgY29uc3QgZm9ybWF0T3B0ID0gb3B0cy52YWxpZGF0ZUZvcm1hdHM7XG4gICAgICAgIG9wdHMudmFsaWRhdGVGb3JtYXRzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuUlVMRVMgPSAoMCwgcnVsZXNfMS5nZXRSdWxlcykoKTtcbiAgICAgICAgY2hlY2tPcHRpb25zLmNhbGwodGhpcywgcmVtb3ZlZE9wdGlvbnMsIG9wdHMsIFwiTk9UIFNVUFBPUlRFRFwiKTtcbiAgICAgICAgY2hlY2tPcHRpb25zLmNhbGwodGhpcywgZGVwcmVjYXRlZE9wdGlvbnMsIG9wdHMsIFwiREVQUkVDQVRFRFwiLCBcIndhcm5cIik7XG4gICAgICAgIHRoaXMuX21ldGFPcHRzID0gZ2V0TWV0YVNjaGVtYU9wdGlvbnMuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKG9wdHMuZm9ybWF0cylcbiAgICAgICAgICAgIGFkZEluaXRpYWxGb3JtYXRzLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX2FkZFZvY2FidWxhcmllcygpO1xuICAgICAgICB0aGlzLl9hZGREZWZhdWx0TWV0YVNjaGVtYSgpO1xuICAgICAgICBpZiAob3B0cy5rZXl3b3JkcylcbiAgICAgICAgICAgIGFkZEluaXRpYWxLZXl3b3Jkcy5jYWxsKHRoaXMsIG9wdHMua2V5d29yZHMpO1xuICAgICAgICBpZiAodHlwZW9mIG9wdHMubWV0YSA9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgdGhpcy5hZGRNZXRhU2NoZW1hKG9wdHMubWV0YSk7XG4gICAgICAgIGFkZEluaXRpYWxTY2hlbWFzLmNhbGwodGhpcyk7XG4gICAgICAgIG9wdHMudmFsaWRhdGVGb3JtYXRzID0gZm9ybWF0T3B0O1xuICAgIH1cbiAgICBfYWRkVm9jYWJ1bGFyaWVzKCkge1xuICAgICAgICB0aGlzLmFkZEtleXdvcmQoXCIkYXN5bmNcIik7XG4gICAgfVxuICAgIF9hZGREZWZhdWx0TWV0YVNjaGVtYSgpIHtcbiAgICAgICAgY29uc3QgeyAkZGF0YSwgbWV0YSwgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgbGV0IF9kYXRhUmVmU2NoZW1hID0gJGRhdGFSZWZTY2hlbWE7XG4gICAgICAgIGlmIChzY2hlbWFJZCA9PT0gXCJpZFwiKSB7XG4gICAgICAgICAgICBfZGF0YVJlZlNjaGVtYSA9IHsgLi4uJGRhdGFSZWZTY2hlbWEgfTtcbiAgICAgICAgICAgIF9kYXRhUmVmU2NoZW1hLmlkID0gX2RhdGFSZWZTY2hlbWEuJGlkO1xuICAgICAgICAgICAgZGVsZXRlIF9kYXRhUmVmU2NoZW1hLiRpZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YSAmJiAkZGF0YSlcbiAgICAgICAgICAgIHRoaXMuYWRkTWV0YVNjaGVtYShfZGF0YVJlZlNjaGVtYSwgX2RhdGFSZWZTY2hlbWFbc2NoZW1hSWRdLCBmYWxzZSk7XG4gICAgfVxuICAgIGRlZmF1bHRNZXRhKCkge1xuICAgICAgICBjb25zdCB7IG1ldGEsIHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIHJldHVybiAodGhpcy5vcHRzLmRlZmF1bHRNZXRhID0gdHlwZW9mIG1ldGEgPT0gXCJvYmplY3RcIiA/IG1ldGFbc2NoZW1hSWRdIHx8IG1ldGEgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICB2YWxpZGF0ZShzY2hlbWFLZXlSZWYsIC8vIGtleSwgcmVmIG9yIHNjaGVtYSBvYmplY3RcbiAgICBkYXRhIC8vIHRvIGJlIHZhbGlkYXRlZFxuICAgICkge1xuICAgICAgICBsZXQgdjtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWFLZXlSZWYgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdiA9IHRoaXMuZ2V0U2NoZW1hKHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICBpZiAoIXYpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBzY2hlbWEgd2l0aCBrZXkgb3IgcmVmIFwiJHtzY2hlbWFLZXlSZWZ9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLmNvbXBpbGUoc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZCA9IHYoZGF0YSk7XG4gICAgICAgIGlmICghKFwiJGFzeW5jXCIgaW4gdikpXG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IHYuZXJyb3JzO1xuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfVxuICAgIGNvbXBpbGUoc2NoZW1hLCBfbWV0YSkge1xuICAgICAgICBjb25zdCBzY2ggPSB0aGlzLl9hZGRTY2hlbWEoc2NoZW1hLCBfbWV0YSk7XG4gICAgICAgIHJldHVybiAoc2NoLnZhbGlkYXRlIHx8IHRoaXMuX2NvbXBpbGVTY2hlbWFFbnYoc2NoKSk7XG4gICAgfVxuICAgIGNvbXBpbGVBc3luYyhzY2hlbWEsIG1ldGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdHMubG9hZFNjaGVtYSAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9wdGlvbnMubG9hZFNjaGVtYSBzaG91bGQgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGxvYWRTY2hlbWEgfSA9IHRoaXMub3B0cztcbiAgICAgICAgcmV0dXJuIHJ1bkNvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHNjaGVtYSwgbWV0YSk7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHJ1bkNvbXBpbGVBc3luYyhfc2NoZW1hLCBfbWV0YSkge1xuICAgICAgICAgICAgYXdhaXQgbG9hZE1ldGFTY2hlbWEuY2FsbCh0aGlzLCBfc2NoZW1hLiRzY2hlbWEpO1xuICAgICAgICAgICAgY29uc3Qgc2NoID0gdGhpcy5fYWRkU2NoZW1hKF9zY2hlbWEsIF9tZXRhKTtcbiAgICAgICAgICAgIHJldHVybiBzY2gudmFsaWRhdGUgfHwgX2NvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHNjaCk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gbG9hZE1ldGFTY2hlbWEoJHJlZikge1xuICAgICAgICAgICAgaWYgKCRyZWYgJiYgIXRoaXMuZ2V0U2NoZW1hKCRyZWYpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcnVuQ29tcGlsZUFzeW5jLmNhbGwodGhpcywgeyAkcmVmIH0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIF9jb21waWxlQXN5bmMoc2NoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiByZWZfZXJyb3JfMS5kZWZhdWx0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICBjaGVja0xvYWRlZC5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGxvYWRNaXNzaW5nU2NoZW1hLmNhbGwodGhpcywgZS5taXNzaW5nU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHNjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tMb2FkZWQoeyBtaXNzaW5nU2NoZW1hOiByZWYsIG1pc3NpbmdSZWYgfSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVmc1tyZWZdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbnlTY2hlbWEgJHtyZWZ9IGlzIGxvYWRlZCBidXQgJHttaXNzaW5nUmVmfSBjYW5ub3QgYmUgcmVzb2x2ZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBsb2FkTWlzc2luZ1NjaGVtYShyZWYpIHtcbiAgICAgICAgICAgIGNvbnN0IF9zY2hlbWEgPSBhd2FpdCBfbG9hZFNjaGVtYS5jYWxsKHRoaXMsIHJlZik7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVmc1tyZWZdKVxuICAgICAgICAgICAgICAgIGF3YWl0IGxvYWRNZXRhU2NoZW1hLmNhbGwodGhpcywgX3NjaGVtYS4kc2NoZW1hKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWZzW3JlZl0pXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWEoX3NjaGVtYSwgcmVmLCBtZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBfbG9hZFNjaGVtYShyZWYpIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLl9sb2FkaW5nW3JlZl07XG4gICAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0ICh0aGlzLl9sb2FkaW5nW3JlZl0gPSBsb2FkU2NoZW1hKHJlZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xvYWRpbmdbcmVmXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBZGRzIHNjaGVtYSB0byB0aGUgaW5zdGFuY2VcbiAgICBhZGRTY2hlbWEoc2NoZW1hLCAvLyBJZiBhcnJheSBpcyBwYXNzZWQsIGBrZXlgIHdpbGwgYmUgaWdub3JlZFxuICAgIGtleSwgLy8gT3B0aW9uYWwgc2NoZW1hIGtleS4gQ2FuIGJlIHBhc3NlZCB0byBgdmFsaWRhdGVgIG1ldGhvZCBpbnN0ZWFkIG9mIHNjaGVtYSBvYmplY3Qgb3IgaWQvcmVmLiBPbmUgc2NoZW1hIHBlciBpbnN0YW5jZSBjYW4gaGF2ZSBlbXB0eSBgaWRgIGFuZCBga2V5YC5cbiAgICBfbWV0YSwgLy8gdHJ1ZSBpZiBzY2hlbWEgaXMgYSBtZXRhLXNjaGVtYS4gVXNlZCBpbnRlcm5hbGx5LCBhZGRNZXRhU2NoZW1hIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gICAgX3ZhbGlkYXRlU2NoZW1hID0gdGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hIC8vIGZhbHNlIHRvIHNraXAgc2NoZW1hIHZhbGlkYXRpb24uIFVzZWQgaW50ZXJuYWxseSwgb3B0aW9uIHZhbGlkYXRlU2NoZW1hIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gICAgKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2NoIG9mIHNjaGVtYSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNjaGVtYShzY2gsIHVuZGVmaW5lZCwgX21ldGEsIF92YWxpZGF0ZVNjaGVtYSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgICAgICBpZCA9IHNjaGVtYVtzY2hlbWFJZF07XG4gICAgICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgaWQgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2NoZW1hICR7c2NoZW1hSWR9IG11c3QgYmUgc3RyaW5nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoa2V5IHx8IGlkKTtcbiAgICAgICAgdGhpcy5fY2hlY2tVbmlxdWUoa2V5KTtcbiAgICAgICAgdGhpcy5zY2hlbWFzW2tleV0gPSB0aGlzLl9hZGRTY2hlbWEoc2NoZW1hLCBfbWV0YSwga2V5LCBfdmFsaWRhdGVTY2hlbWEsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gQWRkIHNjaGVtYSB0aGF0IHdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZSBvdGhlciBzY2hlbWFzXG4gICAgLy8gb3B0aW9ucyBpbiBNRVRBX0lHTk9SRV9PUFRJT05TIGFyZSBhbHdheSBzZXQgdG8gZmFsc2VcbiAgICBhZGRNZXRhU2NoZW1hKHNjaGVtYSwga2V5LCAvLyBzY2hlbWEga2V5XG4gICAgX3ZhbGlkYXRlU2NoZW1hID0gdGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hIC8vIGZhbHNlIHRvIHNraXAgc2NoZW1hIHZhbGlkYXRpb24sIGNhbiBiZSB1c2VkIHRvIG92ZXJyaWRlIHZhbGlkYXRlU2NoZW1hIG9wdGlvbiBmb3IgbWV0YS1zY2hlbWFcbiAgICApIHtcbiAgICAgICAgdGhpcy5hZGRTY2hlbWEoc2NoZW1hLCBrZXksIHRydWUsIF92YWxpZGF0ZVNjaGVtYSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyAgVmFsaWRhdGUgc2NoZW1hIGFnYWluc3QgaXRzIG1ldGEtc2NoZW1hXG4gICAgdmFsaWRhdGVTY2hlbWEoc2NoZW1hLCB0aHJvd09yTG9nRXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0ICRzY2hlbWE7XG4gICAgICAgICRzY2hlbWEgPSBzY2hlbWEuJHNjaGVtYTtcbiAgICAgICAgaWYgKCRzY2hlbWEgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgJHNjaGVtYSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIkc2NoZW1hIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgJHNjaGVtYSA9ICRzY2hlbWEgfHwgdGhpcy5vcHRzLmRlZmF1bHRNZXRhIHx8IHRoaXMuZGVmYXVsdE1ldGEoKTtcbiAgICAgICAgaWYgKCEkc2NoZW1hKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwibWV0YS1zY2hlbWEgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbGlkID0gdGhpcy52YWxpZGF0ZSgkc2NoZW1hLCBzY2hlbWEpO1xuICAgICAgICBpZiAoIXZhbGlkICYmIHRocm93T3JMb2dFcnJvcikge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IFwic2NoZW1hIGlzIGludmFsaWQ6IFwiICsgdGhpcy5lcnJvcnNUZXh0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hID09PSBcImxvZ1wiKVxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfVxuICAgIC8vIEdldCBjb21waWxlZCBzY2hlbWEgYnkgYGtleWAgb3IgYHJlZmAuXG4gICAgLy8gKGBrZXlgIHRoYXQgd2FzIHBhc3NlZCB0byBgYWRkU2NoZW1hYCBvciBmdWxsIHNjaGVtYSByZWZlcmVuY2UgLSBgc2NoZW1hLiRpZGAgb3IgcmVzb2x2ZWQgaWQpXG4gICAgZ2V0U2NoZW1hKGtleVJlZikge1xuICAgICAgICBsZXQgc2NoO1xuICAgICAgICB3aGlsZSAodHlwZW9mIChzY2ggPSBnZXRTY2hFbnYuY2FsbCh0aGlzLCBrZXlSZWYpKSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAga2V5UmVmID0gc2NoO1xuICAgICAgICBpZiAoc2NoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBuZXcgY29tcGlsZV8xLlNjaGVtYUVudih7IHNjaGVtYToge30sIHNjaGVtYUlkIH0pO1xuICAgICAgICAgICAgc2NoID0gY29tcGlsZV8xLnJlc29sdmVTY2hlbWEuY2FsbCh0aGlzLCByb290LCBrZXlSZWYpO1xuICAgICAgICAgICAgaWYgKCFzY2gpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5yZWZzW2tleVJlZl0gPSBzY2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChzY2gudmFsaWRhdGUgfHwgdGhpcy5fY29tcGlsZVNjaGVtYUVudihzY2gpKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGNhY2hlZCBzY2hlbWEocykuXG4gICAgLy8gSWYgbm8gcGFyYW1ldGVyIGlzIHBhc3NlZCBhbGwgc2NoZW1hcyBidXQgbWV0YS1zY2hlbWFzIGFyZSByZW1vdmVkLlxuICAgIC8vIElmIFJlZ0V4cCBpcyBwYXNzZWQgYWxsIHNjaGVtYXMgd2l0aCBrZXkvaWQgbWF0Y2hpbmcgcGF0dGVybiBidXQgbWV0YS1zY2hlbWFzIGFyZSByZW1vdmVkLlxuICAgIC8vIEV2ZW4gaWYgc2NoZW1hIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgc2NoZW1hcyBpdCBzdGlsbCBjYW4gYmUgcmVtb3ZlZCBhcyBvdGhlciBzY2hlbWFzIGhhdmUgbG9jYWwgcmVmZXJlbmNlcy5cbiAgICByZW1vdmVTY2hlbWEoc2NoZW1hS2V5UmVmKSB7XG4gICAgICAgIGlmIChzY2hlbWFLZXlSZWYgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5zY2hlbWFzLCBzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnJlZnMsIHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiBzY2hlbWFLZXlSZWYpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMuc2NoZW1hcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnJlZnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2ggPSBnZXRTY2hFbnYuY2FsbCh0aGlzLCBzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmRlbGV0ZShzY2guc2NoZW1hKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zY2hlbWFzW3NjaGVtYUtleVJlZl07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVmc1tzY2hlbWFLZXlSZWZdO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBzY2hlbWFLZXlSZWY7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuZGVsZXRlKGNhY2hlS2V5KTtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSBzY2hlbWFLZXlSZWZbdGhpcy5vcHRzLnNjaGVtYUlkXTtcbiAgICAgICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWQgPSAoMCwgcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKShpZCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNjaGVtYXNbaWRdO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5yZWZzW2lkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdi5yZW1vdmVTY2hlbWE6IGludmFsaWQgcGFyYW1ldGVyXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFkZCBcInZvY2FidWxhcnlcIiAtIGEgY29sbGVjdGlvbiBvZiBrZXl3b3Jkc1xuICAgIGFkZFZvY2FidWxhcnkoZGVmaW5pdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBkZWYgb2YgZGVmaW5pdGlvbnMpXG4gICAgICAgICAgICB0aGlzLmFkZEtleXdvcmQoZGVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkZEtleXdvcmQoa3dkT3JEZWYsIGRlZiAvLyBkZXByZWNhdGVkXG4gICAgKSB7XG4gICAgICAgIGxldCBrZXl3b3JkO1xuICAgICAgICBpZiAodHlwZW9mIGt3ZE9yRGVmID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGtleXdvcmQgPSBrd2RPckRlZjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwidGhlc2UgcGFyYW1ldGVycyBhcmUgZGVwcmVjYXRlZCwgc2VlIGRvY3MgZm9yIGFkZEtleXdvcmRcIik7XG4gICAgICAgICAgICAgICAgZGVmLmtleXdvcmQgPSBrZXl3b3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBrd2RPckRlZiA9PSBcIm9iamVjdFwiICYmIGRlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWYgPSBrd2RPckRlZjtcbiAgICAgICAgICAgIGtleXdvcmQgPSBkZWYua2V5d29yZDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGtleXdvcmQpICYmICFrZXl3b3JkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZEtleXdvcmRzOiBrZXl3b3JkIG11c3QgYmUgc3RyaW5nIG9yIG5vbi1lbXB0eSBhcnJheVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYWRkS2V5d29yZHMgcGFyYW1ldGVyc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja0tleXdvcmQuY2FsbCh0aGlzLCBrZXl3b3JkLCBkZWYpO1xuICAgICAgICBpZiAoIWRlZikge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5lYWNoSXRlbSkoa2V5d29yZCwgKGt3ZCkgPT4gYWRkUnVsZS5jYWxsKHRoaXMsIGt3ZCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAga2V5d29yZE1ldGFzY2hlbWEuY2FsbCh0aGlzLCBkZWYpO1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgLi4uZGVmLFxuICAgICAgICAgICAgdHlwZTogKDAsIGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKShkZWYudHlwZSksXG4gICAgICAgICAgICBzY2hlbWFUeXBlOiAoMCwgZGF0YVR5cGVfMS5nZXRKU09OVHlwZXMpKGRlZi5zY2hlbWFUeXBlKSxcbiAgICAgICAgfTtcbiAgICAgICAgKDAsIHV0aWxfMS5lYWNoSXRlbSkoa2V5d29yZCwgZGVmaW5pdGlvbi50eXBlLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgPyAoaykgPT4gYWRkUnVsZS5jYWxsKHRoaXMsIGssIGRlZmluaXRpb24pXG4gICAgICAgICAgICA6IChrKSA9PiBkZWZpbml0aW9uLnR5cGUuZm9yRWFjaCgodCkgPT4gYWRkUnVsZS5jYWxsKHRoaXMsIGssIGRlZmluaXRpb24sIHQpKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRLZXl3b3JkKGtleXdvcmQpIHtcbiAgICAgICAgY29uc3QgcnVsZSA9IHRoaXMuUlVMRVMuYWxsW2tleXdvcmRdO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHJ1bGUgPT0gXCJvYmplY3RcIiA/IHJ1bGUuZGVmaW5pdGlvbiA6ICEhcnVsZTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGtleXdvcmRcbiAgICByZW1vdmVLZXl3b3JkKGtleXdvcmQpIHtcbiAgICAgICAgLy8gVE9ETyByZXR1cm4gdHlwZSBzaG91bGQgYmUgQWp2XG4gICAgICAgIGNvbnN0IHsgUlVMRVMgfSA9IHRoaXM7XG4gICAgICAgIGRlbGV0ZSBSVUxFUy5rZXl3b3Jkc1trZXl3b3JkXTtcbiAgICAgICAgZGVsZXRlIFJVTEVTLmFsbFtrZXl3b3JkXTtcbiAgICAgICAgZm9yIChjb25zdCBncm91cCBvZiBSVUxFUy5ydWxlcykge1xuICAgICAgICAgICAgY29uc3QgaSA9IGdyb3VwLnJ1bGVzLmZpbmRJbmRleCgocnVsZSkgPT4gcnVsZS5rZXl3b3JkID09PSBrZXl3b3JkKTtcbiAgICAgICAgICAgIGlmIChpID49IDApXG4gICAgICAgICAgICAgICAgZ3JvdXAucnVsZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBBZGQgZm9ybWF0XG4gICAgYWRkRm9ybWF0KG5hbWUsIGZvcm1hdCkge1xuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgZm9ybWF0ID0gbmV3IFJlZ0V4cChmb3JtYXQpO1xuICAgICAgICB0aGlzLmZvcm1hdHNbbmFtZV0gPSBmb3JtYXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBlcnJvcnNUZXh0KGVycm9ycyA9IHRoaXMuZXJyb3JzLCAvLyBvcHRpb25hbCBhcnJheSBvZiB2YWxpZGF0aW9uIGVycm9yc1xuICAgIHsgc2VwYXJhdG9yID0gXCIsIFwiLCBkYXRhVmFyID0gXCJkYXRhXCIgfSA9IHt9IC8vIG9wdGlvbmFsIG9wdGlvbnMgd2l0aCBwcm9wZXJ0aWVzIGBzZXBhcmF0b3JgIGFuZCBgZGF0YVZhcmBcbiAgICApIHtcbiAgICAgICAgaWYgKCFlcnJvcnMgfHwgZXJyb3JzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBcIk5vIGVycm9yc1wiO1xuICAgICAgICByZXR1cm4gZXJyb3JzXG4gICAgICAgICAgICAubWFwKChlKSA9PiBgJHtkYXRhVmFyfSR7ZS5pbnN0YW5jZVBhdGh9ICR7ZS5tZXNzYWdlfWApXG4gICAgICAgICAgICAucmVkdWNlKCh0ZXh0LCBtc2cpID0+IHRleHQgKyBzZXBhcmF0b3IgKyBtc2cpO1xuICAgIH1cbiAgICAkZGF0YU1ldGFTY2hlbWEobWV0YVNjaGVtYSwga2V5d29yZHNKc29uUG9pbnRlcnMpIHtcbiAgICAgICAgY29uc3QgcnVsZXMgPSB0aGlzLlJVTEVTLmFsbDtcbiAgICAgICAgbWV0YVNjaGVtYSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobWV0YVNjaGVtYSkpO1xuICAgICAgICBmb3IgKGNvbnN0IGpzb25Qb2ludGVyIG9mIGtleXdvcmRzSnNvblBvaW50ZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50cyA9IGpzb25Qb2ludGVyLnNwbGl0KFwiL1wiKS5zbGljZSgxKTsgLy8gZmlyc3Qgc2VnbWVudCBpcyBhbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgIGxldCBrZXl3b3JkcyA9IG1ldGFTY2hlbWE7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNlZyBvZiBzZWdtZW50cylcbiAgICAgICAgICAgICAgICBrZXl3b3JkcyA9IGtleXdvcmRzW3NlZ107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBydWxlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBydWxlc1trZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcnVsZSAhPSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7ICRkYXRhIH0gPSBydWxlLmRlZmluaXRpb247XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0ga2V5d29yZHNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoJGRhdGEgJiYgc2NoZW1hKVxuICAgICAgICAgICAgICAgICAgICBrZXl3b3Jkc1trZXldID0gc2NoZW1hT3JEYXRhKHNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGFTY2hlbWE7XG4gICAgfVxuICAgIF9yZW1vdmVBbGxTY2hlbWFzKHNjaGVtYXMsIHJlZ2V4KSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5UmVmIGluIHNjaGVtYXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaCA9IHNjaGVtYXNba2V5UmVmXTtcbiAgICAgICAgICAgIGlmICghcmVnZXggfHwgcmVnZXgudGVzdChrZXlSZWYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2ggPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hc1trZXlSZWZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2ggJiYgIXNjaC5tZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmRlbGV0ZShzY2guc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYXNba2V5UmVmXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2FkZFNjaGVtYShzY2hlbWEsIG1ldGEsIGJhc2VJZCwgdmFsaWRhdGVTY2hlbWEgPSB0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEsIGFkZFNjaGVtYSA9IHRoaXMub3B0cy5hZGRVc2VkU2NoZW1hKSB7XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZCA9IHNjaGVtYVtzY2hlbWFJZF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLmp0ZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgbXVzdCBiZSBvYmplY3RcIik7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hICE9IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNjaGVtYSBtdXN0IGJlIG9iamVjdCBvciBib29sZWFuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzY2ggPSB0aGlzLl9jYWNoZS5nZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKHNjaCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHNjaDtcbiAgICAgICAgYmFzZUlkID0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoaWQgfHwgYmFzZUlkKTtcbiAgICAgICAgY29uc3QgbG9jYWxSZWZzID0gcmVzb2x2ZV8xLmdldFNjaGVtYVJlZnMuY2FsbCh0aGlzLCBzY2hlbWEsIGJhc2VJZCk7XG4gICAgICAgIHNjaCA9IG5ldyBjb21waWxlXzEuU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgbWV0YSwgYmFzZUlkLCBsb2NhbFJlZnMgfSk7XG4gICAgICAgIHRoaXMuX2NhY2hlLnNldChzY2guc2NoZW1hLCBzY2gpO1xuICAgICAgICBpZiAoYWRkU2NoZW1hICYmICFiYXNlSWQuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gYXRtIGl0IGlzIGFsbG93ZWQgdG8gb3ZlcndyaXRlIHNjaGVtYXMgd2l0aG91dCBpZCAoaW5zdGVhZCBvZiBub3QgYWRkaW5nIHRoZW0pXG4gICAgICAgICAgICBpZiAoYmFzZUlkKVxuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrVW5pcXVlKGJhc2VJZCk7XG4gICAgICAgICAgICB0aGlzLnJlZnNbYmFzZUlkXSA9IHNjaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsaWRhdGVTY2hlbWEpXG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlU2NoZW1hKHNjaGVtYSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBzY2g7XG4gICAgfVxuICAgIF9jaGVja1VuaXF1ZShpZCkge1xuICAgICAgICBpZiAodGhpcy5zY2hlbWFzW2lkXSB8fCB0aGlzLnJlZnNbaWRdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNjaGVtYSB3aXRoIGtleSBvciBpZCBcIiR7aWR9XCIgYWxyZWFkeSBleGlzdHNgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY29tcGlsZVNjaGVtYUVudihzY2gpIHtcbiAgICAgICAgaWYgKHNjaC5tZXRhKVxuICAgICAgICAgICAgdGhpcy5fY29tcGlsZU1ldGFTY2hlbWEoc2NoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29tcGlsZV8xLmNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFzY2gudmFsaWRhdGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgIHJldHVybiBzY2gudmFsaWRhdGU7XG4gICAgfVxuICAgIF9jb21waWxlTWV0YVNjaGVtYShzY2gpIHtcbiAgICAgICAgY29uc3QgY3VycmVudE9wdHMgPSB0aGlzLm9wdHM7XG4gICAgICAgIHRoaXMub3B0cyA9IHRoaXMuX21ldGFPcHRzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29tcGlsZV8xLmNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5vcHRzID0gY3VycmVudE9wdHM7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBBanY7XG5BanYuVmFsaWRhdGlvbkVycm9yID0gdmFsaWRhdGlvbl9lcnJvcl8xLmRlZmF1bHQ7XG5BanYuTWlzc2luZ1JlZkVycm9yID0gcmVmX2Vycm9yXzEuZGVmYXVsdDtcbmZ1bmN0aW9uIGNoZWNrT3B0aW9ucyhjaGVja09wdHMsIG9wdGlvbnMsIG1zZywgbG9nID0gXCJlcnJvclwiKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY2hlY2tPcHRzKSB7XG4gICAgICAgIGNvbnN0IG9wdCA9IGtleTtcbiAgICAgICAgaWYgKG9wdCBpbiBvcHRpb25zKVxuICAgICAgICAgICAgdGhpcy5sb2dnZXJbbG9nXShgJHttc2d9OiBvcHRpb24gJHtrZXl9LiAke2NoZWNrT3B0c1tvcHRdfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNjaEVudihrZXlSZWYpIHtcbiAgICBrZXlSZWYgPSAoMCwgcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKShrZXlSZWYpOyAvLyBUT0RPIHRlc3RzIGZhaWwgd2l0aG91dCB0aGlzIGxpbmVcbiAgICByZXR1cm4gdGhpcy5zY2hlbWFzW2tleVJlZl0gfHwgdGhpcy5yZWZzW2tleVJlZl07XG59XG5mdW5jdGlvbiBhZGRJbml0aWFsU2NoZW1hcygpIHtcbiAgICBjb25zdCBvcHRzU2NoZW1hcyA9IHRoaXMub3B0cy5zY2hlbWFzO1xuICAgIGlmICghb3B0c1NjaGVtYXMpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRzU2NoZW1hcykpXG4gICAgICAgIHRoaXMuYWRkU2NoZW1hKG9wdHNTY2hlbWFzKTtcbiAgICBlbHNlXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wdHNTY2hlbWFzKVxuICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWEob3B0c1NjaGVtYXNba2V5XSwga2V5KTtcbn1cbmZ1bmN0aW9uIGFkZEluaXRpYWxGb3JtYXRzKCkge1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLm9wdHMuZm9ybWF0cykge1xuICAgICAgICBjb25zdCBmb3JtYXQgPSB0aGlzLm9wdHMuZm9ybWF0c1tuYW1lXTtcbiAgICAgICAgaWYgKGZvcm1hdClcbiAgICAgICAgICAgIHRoaXMuYWRkRm9ybWF0KG5hbWUsIGZvcm1hdCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkSW5pdGlhbEtleXdvcmRzKGRlZnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZWZzKSkge1xuICAgICAgICB0aGlzLmFkZFZvY2FidWxhcnkoZGVmcyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIud2FybihcImtleXdvcmRzIG9wdGlvbiBhcyBtYXAgaXMgZGVwcmVjYXRlZCwgcGFzcyBhcnJheVwiKTtcbiAgICBmb3IgKGNvbnN0IGtleXdvcmQgaW4gZGVmcykge1xuICAgICAgICBjb25zdCBkZWYgPSBkZWZzW2tleXdvcmRdO1xuICAgICAgICBpZiAoIWRlZi5rZXl3b3JkKVxuICAgICAgICAgICAgZGVmLmtleXdvcmQgPSBrZXl3b3JkO1xuICAgICAgICB0aGlzLmFkZEtleXdvcmQoZGVmKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRNZXRhU2NoZW1hT3B0aW9ucygpIHtcbiAgICBjb25zdCBtZXRhT3B0cyA9IHsgLi4udGhpcy5vcHRzIH07XG4gICAgZm9yIChjb25zdCBvcHQgb2YgTUVUQV9JR05PUkVfT1BUSU9OUylcbiAgICAgICAgZGVsZXRlIG1ldGFPcHRzW29wdF07XG4gICAgcmV0dXJuIG1ldGFPcHRzO1xufVxuY29uc3Qgbm9Mb2dzID0geyBsb2coKSB7IH0sIHdhcm4oKSB7IH0sIGVycm9yKCkgeyB9IH07XG5mdW5jdGlvbiBnZXRMb2dnZXIobG9nZ2VyKSB7XG4gICAgaWYgKGxvZ2dlciA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybiBub0xvZ3M7XG4gICAgaWYgKGxvZ2dlciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gY29uc29sZTtcbiAgICBpZiAobG9nZ2VyLmxvZyAmJiBsb2dnZXIud2FybiAmJiBsb2dnZXIuZXJyb3IpXG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibG9nZ2VyIG11c3QgaW1wbGVtZW50IGxvZywgd2FybiBhbmQgZXJyb3IgbWV0aG9kc1wiKTtcbn1cbmNvbnN0IEtFWVdPUkRfTkFNRSA9IC9eW2Etel8kXVthLXowLTlfJDotXSokL2k7XG5mdW5jdGlvbiBjaGVja0tleXdvcmQoa2V5d29yZCwgZGVmKSB7XG4gICAgY29uc3QgeyBSVUxFUyB9ID0gdGhpcztcbiAgICAoMCwgdXRpbF8xLmVhY2hJdGVtKShrZXl3b3JkLCAoa3dkKSA9PiB7XG4gICAgICAgIGlmIChSVUxFUy5rZXl3b3Jkc1trd2RdKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXl3b3JkICR7a3dkfSBpcyBhbHJlYWR5IGRlZmluZWRgKTtcbiAgICAgICAgaWYgKCFLRVlXT1JEX05BTUUudGVzdChrd2QpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXl3b3JkICR7a3dkfSBoYXMgaW52YWxpZCBuYW1lYCk7XG4gICAgfSk7XG4gICAgaWYgKCFkZWYpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoZGVmLiRkYXRhICYmICEoXCJjb2RlXCIgaW4gZGVmIHx8IFwidmFsaWRhdGVcIiBpbiBkZWYpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignJGRhdGEga2V5d29yZCBtdXN0IGhhdmUgXCJjb2RlXCIgb3IgXCJ2YWxpZGF0ZVwiIGZ1bmN0aW9uJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkUnVsZShrZXl3b3JkLCBkZWZpbml0aW9uLCBkYXRhVHlwZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwb3N0ID0gZGVmaW5pdGlvbiA9PT0gbnVsbCB8fCBkZWZpbml0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWZpbml0aW9uLnBvc3Q7XG4gICAgaWYgKGRhdGFUeXBlICYmIHBvc3QpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigna2V5d29yZCB3aXRoIFwicG9zdFwiIGZsYWcgY2Fubm90IGhhdmUgXCJ0eXBlXCInKTtcbiAgICBjb25zdCB7IFJVTEVTIH0gPSB0aGlzO1xuICAgIGxldCBydWxlR3JvdXAgPSBwb3N0ID8gUlVMRVMucG9zdCA6IFJVTEVTLnJ1bGVzLmZpbmQoKHsgdHlwZTogdCB9KSA9PiB0ID09PSBkYXRhVHlwZSk7XG4gICAgaWYgKCFydWxlR3JvdXApIHtcbiAgICAgICAgcnVsZUdyb3VwID0geyB0eXBlOiBkYXRhVHlwZSwgcnVsZXM6IFtdIH07XG4gICAgICAgIFJVTEVTLnJ1bGVzLnB1c2gocnVsZUdyb3VwKTtcbiAgICB9XG4gICAgUlVMRVMua2V5d29yZHNba2V5d29yZF0gPSB0cnVlO1xuICAgIGlmICghZGVmaW5pdGlvbilcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHJ1bGUgPSB7XG4gICAgICAgIGtleXdvcmQsXG4gICAgICAgIGRlZmluaXRpb246IHtcbiAgICAgICAgICAgIC4uLmRlZmluaXRpb24sXG4gICAgICAgICAgICB0eXBlOiAoMCwgZGF0YVR5cGVfMS5nZXRKU09OVHlwZXMpKGRlZmluaXRpb24udHlwZSksXG4gICAgICAgICAgICBzY2hlbWFUeXBlOiAoMCwgZGF0YVR5cGVfMS5nZXRKU09OVHlwZXMpKGRlZmluaXRpb24uc2NoZW1hVHlwZSksXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBpZiAoZGVmaW5pdGlvbi5iZWZvcmUpXG4gICAgICAgIGFkZEJlZm9yZVJ1bGUuY2FsbCh0aGlzLCBydWxlR3JvdXAsIHJ1bGUsIGRlZmluaXRpb24uYmVmb3JlKTtcbiAgICBlbHNlXG4gICAgICAgIHJ1bGVHcm91cC5ydWxlcy5wdXNoKHJ1bGUpO1xuICAgIFJVTEVTLmFsbFtrZXl3b3JkXSA9IHJ1bGU7XG4gICAgKF9hID0gZGVmaW5pdGlvbi5pbXBsZW1lbnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCgoa3dkKSA9PiB0aGlzLmFkZEtleXdvcmQoa3dkKSk7XG59XG5mdW5jdGlvbiBhZGRCZWZvcmVSdWxlKHJ1bGVHcm91cCwgcnVsZSwgYmVmb3JlKSB7XG4gICAgY29uc3QgaSA9IHJ1bGVHcm91cC5ydWxlcy5maW5kSW5kZXgoKF9ydWxlKSA9PiBfcnVsZS5rZXl3b3JkID09PSBiZWZvcmUpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgICAgcnVsZUdyb3VwLnJ1bGVzLnNwbGljZShpLCAwLCBydWxlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJ1bGVHcm91cC5ydWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBydWxlICR7YmVmb3JlfSBpcyBub3QgZGVmaW5lZGApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGtleXdvcmRNZXRhc2NoZW1hKGRlZikge1xuICAgIGxldCB7IG1ldGFTY2hlbWEgfSA9IGRlZjtcbiAgICBpZiAobWV0YVNjaGVtYSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGRlZi4kZGF0YSAmJiB0aGlzLm9wdHMuJGRhdGEpXG4gICAgICAgIG1ldGFTY2hlbWEgPSBzY2hlbWFPckRhdGEobWV0YVNjaGVtYSk7XG4gICAgZGVmLnZhbGlkYXRlU2NoZW1hID0gdGhpcy5jb21waWxlKG1ldGFTY2hlbWEsIHRydWUpO1xufVxuY29uc3QgJGRhdGFSZWYgPSB7XG4gICAgJHJlZjogXCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vYWp2LXZhbGlkYXRvci9hanYvbWFzdGVyL2xpYi9yZWZzL2RhdGEuanNvbiNcIixcbn07XG5mdW5jdGlvbiBzY2hlbWFPckRhdGEoc2NoZW1hKSB7XG4gICAgcmV0dXJuIHsgYW55T2Y6IFtzY2hlbWEsICRkYXRhUmVmXSB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29yZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImlkXCIsXG4gICAgY29kZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOT1QgU1VQUE9SVEVEOiBrZXl3b3JkIFwiaWRcIiwgdXNlIFwiJGlkXCIgZm9yIHNjaGVtYSBJRCcpO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNhbGxSZWYgPSBleHBvcnRzLmdldFZhbGlkYXRlID0gdm9pZCAwO1xuY29uc3QgcmVmX2Vycm9yXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9yZWZfZXJyb3JcIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvbmFtZXNcIik7XG5jb25zdCBjb21waWxlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCIkcmVmXCIsXG4gICAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hOiAkcmVmLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IGJhc2VJZCwgc2NoZW1hRW52OiBlbnYsIHZhbGlkYXRlTmFtZSwgb3B0cywgc2VsZiB9ID0gaXQ7XG4gICAgICAgIGNvbnN0IHsgcm9vdCB9ID0gZW52O1xuICAgICAgICBpZiAoKCRyZWYgPT09IFwiI1wiIHx8ICRyZWYgPT09IFwiIy9cIikgJiYgYmFzZUlkID09PSByb290LmJhc2VJZClcbiAgICAgICAgICAgIHJldHVybiBjYWxsUm9vdFJlZigpO1xuICAgICAgICBjb25zdCBzY2hPckVudiA9IGNvbXBpbGVfMS5yZXNvbHZlUmVmLmNhbGwoc2VsZiwgcm9vdCwgYmFzZUlkLCAkcmVmKTtcbiAgICAgICAgaWYgKHNjaE9yRW52ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgcmVmX2Vycm9yXzEuZGVmYXVsdChpdC5vcHRzLnVyaVJlc29sdmVyLCBiYXNlSWQsICRyZWYpO1xuICAgICAgICBpZiAoc2NoT3JFbnYgaW5zdGFuY2VvZiBjb21waWxlXzEuU2NoZW1hRW52KVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxWYWxpZGF0ZShzY2hPckVudik7XG4gICAgICAgIHJldHVybiBpbmxpbmVSZWZTY2hlbWEoc2NoT3JFbnYpO1xuICAgICAgICBmdW5jdGlvbiBjYWxsUm9vdFJlZigpIHtcbiAgICAgICAgICAgIGlmIChlbnYgPT09IHJvb3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxSZWYoY3h0LCB2YWxpZGF0ZU5hbWUsIGVudiwgZW52LiRhc3luYyk7XG4gICAgICAgICAgICBjb25zdCByb290TmFtZSA9IGdlbi5zY29wZVZhbHVlKFwicm9vdFwiLCB7IHJlZjogcm9vdCB9KTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsUmVmKGN4dCwgKDAsIGNvZGVnZW5fMS5fKSBgJHtyb290TmFtZX0udmFsaWRhdGVgLCByb290LCByb290LiRhc3luYyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FsbFZhbGlkYXRlKHNjaCkge1xuICAgICAgICAgICAgY29uc3QgdiA9IGdldFZhbGlkYXRlKGN4dCwgc2NoKTtcbiAgICAgICAgICAgIGNhbGxSZWYoY3h0LCB2LCBzY2gsIHNjaC4kYXN5bmMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlubGluZVJlZlNjaGVtYShzY2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaE5hbWUgPSBnZW4uc2NvcGVWYWx1ZShcInNjaGVtYVwiLCBvcHRzLmNvZGUuc291cmNlID09PSB0cnVlID8geyByZWY6IHNjaCwgY29kZTogKDAsIGNvZGVnZW5fMS5zdHJpbmdpZnkpKHNjaCkgfSA6IHsgcmVmOiBzY2ggfSk7XG4gICAgICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHNjaCxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZXM6IFtdLFxuICAgICAgICAgICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5uaWwsXG4gICAgICAgICAgICAgICAgdG9wU2NoZW1hUmVmOiBzY2hOYW1lLFxuICAgICAgICAgICAgICAgIGVyclNjaGVtYVBhdGg6ICRyZWYsXG4gICAgICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0KTtcbiAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmZ1bmN0aW9uIGdldFZhbGlkYXRlKGN4dCwgc2NoKSB7XG4gICAgY29uc3QgeyBnZW4gfSA9IGN4dDtcbiAgICByZXR1cm4gc2NoLnZhbGlkYXRlXG4gICAgICAgID8gZ2VuLnNjb3BlVmFsdWUoXCJ2YWxpZGF0ZVwiLCB7IHJlZjogc2NoLnZhbGlkYXRlIH0pXG4gICAgICAgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHtnZW4uc2NvcGVWYWx1ZShcIndyYXBwZXJcIiwgeyByZWY6IHNjaCB9KX0udmFsaWRhdGVgO1xufVxuZXhwb3J0cy5nZXRWYWxpZGF0ZSA9IGdldFZhbGlkYXRlO1xuZnVuY3Rpb24gY2FsbFJlZihjeHQsIHYsIHNjaCwgJGFzeW5jKSB7XG4gICAgY29uc3QgeyBnZW4sIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgeyBhbGxFcnJvcnMsIHNjaGVtYUVudjogZW52LCBvcHRzIH0gPSBpdDtcbiAgICBjb25zdCBwYXNzQ3h0ID0gb3B0cy5wYXNzQ29udGV4dCA/IG5hbWVzXzEuZGVmYXVsdC50aGlzIDogY29kZWdlbl8xLm5pbDtcbiAgICBpZiAoJGFzeW5jKVxuICAgICAgICBjYWxsQXN5bmNSZWYoKTtcbiAgICBlbHNlXG4gICAgICAgIGNhbGxTeW5jUmVmKCk7XG4gICAgZnVuY3Rpb24gY2FsbEFzeW5jUmVmKCkge1xuICAgICAgICBpZiAoIWVudi4kYXN5bmMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBzY2hlbWEgcmVmZXJlbmNlZCBieSBzeW5jIHNjaGVtYVwiKTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIik7XG4gICAgICAgIGdlbi50cnkoKCkgPT4ge1xuICAgICAgICAgICAgZ2VuLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgYXdhaXQgJHsoMCwgY29kZV8xLmNhbGxWYWxpZGF0ZUNvZGUpKGN4dCwgdiwgcGFzc0N4dCl9YCk7XG4gICAgICAgICAgICBhZGRFdmFsdWF0ZWRGcm9tKHYpOyAvLyBUT0RPIHdpbGwgbm90IHdvcmsgd2l0aCBhc3luYywgaXQgaGFzIHRvIGJlIHJldHVybmVkIHdpdGggdGhlIHJlc3VsdFxuICAgICAgICAgICAgaWYgKCFhbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgIH0sIChlKSA9PiB7XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgISgke2V9IGluc3RhbmNlb2YgJHtpdC5WYWxpZGF0aW9uRXJyb3J9KWAsICgpID0+IGdlbi50aHJvdyhlKSk7XG4gICAgICAgICAgICBhZGRFcnJvcnNGcm9tKGUpO1xuICAgICAgICAgICAgaWYgKCFhbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FsbFN5bmNSZWYoKSB7XG4gICAgICAgIGN4dC5yZXN1bHQoKDAsIGNvZGVfMS5jYWxsVmFsaWRhdGVDb2RlKShjeHQsIHYsIHBhc3NDeHQpLCAoKSA9PiBhZGRFdmFsdWF0ZWRGcm9tKHYpLCAoKSA9PiBhZGRFcnJvcnNGcm9tKHYpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkRXJyb3JzRnJvbShzb3VyY2UpIHtcbiAgICAgICAgY29uc3QgZXJycyA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7c291cmNlfS5lcnJvcnNgO1xuICAgICAgICBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfSA9PT0gbnVsbCA/ICR7ZXJyc30gOiAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5jb25jYXQoJHtlcnJzfSlgKTsgLy8gVE9ETyB0YWdnZWRcbiAgICAgICAgZ2VuLmFzc2lnbihuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5sZW5ndGhgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkRXZhbHVhdGVkRnJvbShzb3VyY2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWl0Lm9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHNjaEV2YWx1YXRlZCA9IChfYSA9IHNjaCA9PT0gbnVsbCB8fCBzY2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaC52YWxpZGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV2YWx1YXRlZDtcbiAgICAgICAgLy8gVE9ETyByZWZhY3RvclxuICAgICAgICBpZiAoaXQucHJvcHMgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChzY2hFdmFsdWF0ZWQgJiYgIXNjaEV2YWx1YXRlZC5keW5hbWljUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NoRXZhbHVhdGVkLnByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXQucHJvcHMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCBzY2hFdmFsdWF0ZWQucHJvcHMsIGl0LnByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wcyA9IGdlbi52YXIoXCJwcm9wc1wiLCAoMCwgY29kZWdlbl8xLl8pIGAke3NvdXJjZX0uZXZhbHVhdGVkLnByb3BzYCk7XG4gICAgICAgICAgICAgICAgaXQucHJvcHMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCBwcm9wcywgaXQucHJvcHMsIGNvZGVnZW5fMS5OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQuaXRlbXMgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChzY2hFdmFsdWF0ZWQgJiYgIXNjaEV2YWx1YXRlZC5keW5hbWljSXRlbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NoRXZhbHVhdGVkLml0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXQuaXRlbXMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBzY2hFdmFsdWF0ZWQuaXRlbXMsIGl0Lml0ZW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtcyA9IGdlbi52YXIoXCJpdGVtc1wiLCAoMCwgY29kZWdlbl8xLl8pIGAke3NvdXJjZX0uZXZhbHVhdGVkLml0ZW1zYCk7XG4gICAgICAgICAgICAgICAgaXQuaXRlbXMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBpdGVtcywgaXQuaXRlbXMsIGNvZGVnZW5fMS5OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuY2FsbFJlZiA9IGNhbGxSZWY7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBpZF8xID0gcmVxdWlyZShcIi4vaWRcIik7XG5jb25zdCByZWZfMSA9IHJlcXVpcmUoXCIuL3JlZlwiKTtcbmNvbnN0IGNvcmUgPSBbXG4gICAgXCIkc2NoZW1hXCIsXG4gICAgXCIkaWRcIixcbiAgICBcIiRkZWZzXCIsXG4gICAgXCIkdm9jYWJ1bGFyeVwiLFxuICAgIHsga2V5d29yZDogXCIkY29tbWVudFwiIH0sXG4gICAgXCJkZWZpbml0aW9uc1wiLFxuICAgIGlkXzEuZGVmYXVsdCxcbiAgICByZWZfMS5kZWZhdWx0LFxuXTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBvcHMgPSBjb2RlZ2VuXzEub3BlcmF0b3JzO1xuY29uc3QgS1dEcyA9IHtcbiAgICBtYXhpbXVtOiB7IG9rU3RyOiBcIjw9XCIsIG9rOiBvcHMuTFRFLCBmYWlsOiBvcHMuR1QgfSxcbiAgICBtaW5pbXVtOiB7IG9rU3RyOiBcIj49XCIsIG9rOiBvcHMuR1RFLCBmYWlsOiBvcHMuTFQgfSxcbiAgICBleGNsdXNpdmVNYXhpbXVtOiB7IG9rU3RyOiBcIjxcIiwgb2s6IG9wcy5MVCwgZmFpbDogb3BzLkdURSB9LFxuICAgIGV4Y2x1c2l2ZU1pbmltdW06IHsgb2tTdHI6IFwiPlwiLCBvazogb3BzLkdULCBmYWlsOiBvcHMuTFRFIH0sXG59O1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgYmUgJHtLV0RzW2tleXdvcmRdLm9rU3RyfSAke3NjaGVtYUNvZGV9YCxcbiAgICBwYXJhbXM6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2NvbXBhcmlzb246ICR7S1dEc1trZXl3b3JkXS5va1N0cn0sIGxpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IE9iamVjdC5rZXlzKEtXRHMpLFxuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGtleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGUgfSA9IGN4dDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9ICR7S1dEc1trZXl3b3JkXS5mYWlsfSAke3NjaGVtYUNvZGV9IHx8IGlzTmFOKCR7ZGF0YX0pYCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW1pdE51bWJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBiZSBtdWx0aXBsZSBvZiAke3NjaGVtYUNvZGV9YCxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge211bHRpcGxlT2Y6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICAvLyBjb25zdCBiZHQgPSBiYWQkRGF0YVR5cGUoc2NoZW1hQ29kZSwgPHN0cmluZz5kZWYuc2NoZW1hVHlwZSwgJGRhdGEpXG4gICAgICAgIGNvbnN0IHByZWMgPSBpdC5vcHRzLm11bHRpcGxlT2ZQcmVjaXNpb247XG4gICAgICAgIGNvbnN0IHJlcyA9IGdlbi5sZXQoXCJyZXNcIik7XG4gICAgICAgIGNvbnN0IGludmFsaWQgPSBwcmVjXG4gICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYE1hdGguYWJzKE1hdGgucm91bmQoJHtyZXN9KSAtICR7cmVzfSkgPiAxZS0ke3ByZWN9YFxuICAgICAgICAgICAgOiAoMCwgY29kZWdlbl8xLl8pIGAke3Jlc30gIT09IHBhcnNlSW50KCR7cmVzfSlgO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEuXykgYCgke3NjaGVtYUNvZGV9ID09PSAwIHx8ICgke3Jlc30gPSAke2RhdGF9LyR7c2NoZW1hQ29kZX0sICR7aW52YWxpZH0pKWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVsdGlwbGVPZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYmVzdGllanMvcHVueWNvZGUuanMgLSBwdW55Y29kZS51Y3MyLmRlY29kZVxuZnVuY3Rpb24gdWNzMmxlbmd0aChzdHIpIHtcbiAgICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGxldCB2YWx1ZTtcbiAgICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgICAgIGxlbmd0aCsrO1xuICAgICAgICB2YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KHBvcysrKTtcbiAgICAgICAgaWYgKHZhbHVlID49IDB4ZDgwMCAmJiB2YWx1ZSA8PSAweGRiZmYgJiYgcG9zIDwgbGVuKSB7XG4gICAgICAgICAgICAvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHZhbHVlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgICAgIGlmICgodmFsdWUgJiAweGZjMDApID09PSAweGRjMDApXG4gICAgICAgICAgICAgICAgcG9zKys7IC8vIGxvdyBzdXJyb2dhdGVcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gdWNzMmxlbmd0aDtcbnVjczJsZW5ndGguY29kZSA9ICdyZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS91Y3MybGVuZ3RoXCIpLmRlZmF1bHQnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dWNzMmxlbmd0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgdWNzMmxlbmd0aF8xID0gcmVxdWlyZShcIi4uLy4uL3J1bnRpbWUvdWNzMmxlbmd0aFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2UoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pIHtcbiAgICAgICAgY29uc3QgY29tcCA9IGtleXdvcmQgPT09IFwibWF4TGVuZ3RoXCIgPyBcIm1vcmVcIiA6IFwiZmV3ZXJcIjtcbiAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBOT1QgaGF2ZSAke2NvbXB9IHRoYW4gJHtzY2hlbWFDb2RlfSBjaGFyYWN0ZXJzYDtcbiAgICB9LFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7bGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogW1wibWF4TGVuZ3RoXCIsIFwibWluTGVuZ3RoXCJdLFxuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGtleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IG9wID0ga2V5d29yZCA9PT0gXCJtYXhMZW5ndGhcIiA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuR1QgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLkxUO1xuICAgICAgICBjb25zdCBsZW4gPSBpdC5vcHRzLnVuaWNvZGUgPT09IGZhbHNlID8gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGhgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHsoMCwgdXRpbF8xLnVzZUZ1bmMpKGN4dC5nZW4sIHVjczJsZW5ndGhfMS5kZWZhdWx0KX0oJHtkYXRhfSlgO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEuXykgYCR7bGVufSAke29wfSAke3NjaGVtYUNvZGV9YCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW1pdExlbmd0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IG1hdGNoIHBhdHRlcm4gXCIke3NjaGVtYUNvZGV9XCJgLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7cGF0dGVybjogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInBhdHRlcm5cIixcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhLCAkZGF0YSwgc2NoZW1hLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICAvLyBUT0RPIHJlZ2V4cCBzaG91bGQgYmUgd3JhcHBlZCBpbiB0cnkvY2F0Y2hzXG4gICAgICAgIGNvbnN0IHUgPSBpdC5vcHRzLnVuaWNvZGVSZWdFeHAgPyBcInVcIiA6IFwiXCI7XG4gICAgICAgIGNvbnN0IHJlZ0V4cCA9ICRkYXRhID8gKDAsIGNvZGVnZW5fMS5fKSBgKG5ldyBSZWdFeHAoJHtzY2hlbWFDb2RlfSwgJHt1fSkpYCA6ICgwLCBjb2RlXzEudXNlUGF0dGVybikoY3h0LCBzY2hlbWEpO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEuXykgYCEke3JlZ0V4cH0udGVzdCgke2RhdGF9KWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0dGVybi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSB7XG4gICAgICAgIGNvbnN0IGNvbXAgPSBrZXl3b3JkID09PSBcIm1heFByb3BlcnRpZXNcIiA/IFwibW9yZVwiIDogXCJmZXdlclwiO1xuICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IE5PVCBoYXZlICR7Y29tcH0gdGhhbiAke3NjaGVtYUNvZGV9IHByb3BlcnRpZXNgO1xuICAgIH0sXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBbXCJtYXhQcm9wZXJ0aWVzXCIsIFwibWluUHJvcGVydGllc1wiXSxcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlIH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IG9wID0ga2V5d29yZCA9PT0gXCJtYXhQcm9wZXJ0aWVzXCIgPyBjb2RlZ2VuXzEub3BlcmF0b3JzLkdUIDogY29kZWdlbl8xLm9wZXJhdG9ycy5MVDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGBPYmplY3Qua2V5cygke2RhdGF9KS5sZW5ndGggJHtvcH0gJHtzY2hlbWFDb2RlfWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXRQcm9wZXJ0aWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBtaXNzaW5nUHJvcGVydHkgfSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgaGF2ZSByZXF1aXJlZCBwcm9wZXJ0eSAnJHttaXNzaW5nUHJvcGVydHl9J2AsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5IH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge21pc3NpbmdQcm9wZXJ0eTogJHttaXNzaW5nUHJvcGVydHl9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicmVxdWlyZWRcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBzY2hlbWFDb2RlLCBkYXRhLCAkZGF0YSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvcHRzIH0gPSBpdDtcbiAgICAgICAgaWYgKCEkZGF0YSAmJiBzY2hlbWEubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB1c2VMb29wID0gc2NoZW1hLmxlbmd0aCA+PSBvcHRzLmxvb3BSZXF1aXJlZDtcbiAgICAgICAgaWYgKGl0LmFsbEVycm9ycylcbiAgICAgICAgICAgIGFsbEVycm9yc01vZGUoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZXhpdE9uRXJyb3JNb2RlKCk7XG4gICAgICAgIGlmIChvcHRzLnN0cmljdFJlcXVpcmVkKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IGN4dC5wYXJlbnRTY2hlbWEucHJvcGVydGllcztcbiAgICAgICAgICAgIGNvbnN0IHsgZGVmaW5lZFByb3BlcnRpZXMgfSA9IGN4dC5pdDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVxdWlyZWRLZXkgb2Ygc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHNbcmVxdWlyZWRLZXldKSA9PT0gdW5kZWZpbmVkICYmICFkZWZpbmVkUHJvcGVydGllcy5oYXMocmVxdWlyZWRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYVBhdGggPSBpdC5zY2hlbWFFbnYuYmFzZUlkICsgaXQuZXJyU2NoZW1hUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbXNnID0gYHJlcXVpcmVkIHByb3BlcnR5IFwiJHtyZXF1aXJlZEtleX1cIiBpcyBub3QgZGVmaW5lZCBhdCBcIiR7c2NoZW1hUGF0aH1cIiAoc3RyaWN0UmVxdWlyZWQpYDtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBtc2csIGl0Lm9wdHMuc3RyaWN0UmVxdWlyZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhbGxFcnJvcnNNb2RlKCkge1xuICAgICAgICAgICAgaWYgKHVzZUxvb3AgfHwgJGRhdGEpIHtcbiAgICAgICAgICAgICAgICBjeHQuYmxvY2skZGF0YShjb2RlZ2VuXzEubmlsLCBsb29wQWxsUmVxdWlyZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgY29kZV8xLmNoZWNrUmVwb3J0TWlzc2luZ1Byb3ApKGN4dCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGV4aXRPbkVycm9yTW9kZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pc3NpbmcgPSBnZW4ubGV0KFwibWlzc2luZ1wiKTtcbiAgICAgICAgICAgIGlmICh1c2VMb29wIHx8ICRkYXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsICgpID0+IGxvb3BVbnRpbE1pc3NpbmcobWlzc2luZywgdmFsaWQpKTtcbiAgICAgICAgICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlXzEuY2hlY2tNaXNzaW5nUHJvcCkoY3h0LCBzY2hlbWEsIG1pc3NpbmcpKTtcbiAgICAgICAgICAgICAgICAoMCwgY29kZV8xLnJlcG9ydE1pc3NpbmdQcm9wKShjeHQsIG1pc3NpbmcpO1xuICAgICAgICAgICAgICAgIGdlbi5lbHNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG9vcEFsbFJlcXVpcmVkKCkge1xuICAgICAgICAgICAgZ2VuLmZvck9mKFwicHJvcFwiLCBzY2hlbWFDb2RlLCAocHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBtaXNzaW5nUHJvcGVydHk6IHByb3AgfSk7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlXzEubm9Qcm9wZXJ0eUluRGF0YSkoZ2VuLCBkYXRhLCBwcm9wLCBvcHRzLm93blByb3BlcnRpZXMpLCAoKSA9PiBjeHQuZXJyb3IoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb29wVW50aWxNaXNzaW5nKG1pc3NpbmcsIHZhbGlkKSB7XG4gICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgbWlzc2luZ1Byb3BlcnR5OiBtaXNzaW5nIH0pO1xuICAgICAgICAgICAgZ2VuLmZvck9mKG1pc3NpbmcsIHNjaGVtYUNvZGUsICgpID0+IHtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCAoMCwgY29kZV8xLnByb3BlcnR5SW5EYXRhKShnZW4sIGRhdGEsIG1pc3NpbmcsIG9wdHMub3duUHJvcGVydGllcykpO1xuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGN4dC5lcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uYnJlYWsoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGNvZGVnZW5fMS5uaWwpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1aXJlZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSB7XG4gICAgICAgIGNvbnN0IGNvbXAgPSBrZXl3b3JkID09PSBcIm1heEl0ZW1zXCIgPyBcIm1vcmVcIiA6IFwiZmV3ZXJcIjtcbiAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBOT1QgaGF2ZSAke2NvbXB9IHRoYW4gJHtzY2hlbWFDb2RlfSBpdGVtc2A7XG4gICAgfSxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2xpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFtcIm1heEl0ZW1zXCIsIFwibWluSXRlbXNcIl0sXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlIH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IG9wID0ga2V5d29yZCA9PT0gXCJtYXhJdGVtc1wiID8gY29kZWdlbl8xLm9wZXJhdG9ycy5HVCA6IGNvZGVnZW5fMS5vcGVyYXRvcnMuTFQ7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGggJHtvcH0gJHtzY2hlbWFDb2RlfWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXRJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hanYtdmFsaWRhdG9yL2Fqdi9pc3N1ZXMvODg5XG5jb25zdCBlcXVhbCA9IHJlcXVpcmUoXCJmYXN0LWRlZXAtZXF1YWxcIik7XG5lcXVhbC5jb2RlID0gJ3JlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL2VxdWFsXCIpLmRlZmF1bHQnO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXF1YWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcXVhbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGRhdGFUeXBlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZS9kYXRhVHlwZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXF1YWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL2VxdWFsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IGksIGogfSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgZHVwbGljYXRlIGl0ZW1zIChpdGVtcyAjIyAke2p9IGFuZCAke2l9IGFyZSBpZGVudGljYWwpYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBpLCBqIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2k6ICR7aX0sIGo6ICR7an19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBcImJvb2xlYW5cIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoISRkYXRhICYmICFzY2hlbWEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgICAgICBjb25zdCBpdGVtVHlwZXMgPSBwYXJlbnRTY2hlbWEuaXRlbXMgPyAoMCwgZGF0YVR5cGVfMS5nZXRTY2hlbWFUeXBlcykocGFyZW50U2NoZW1hLml0ZW1zKSA6IFtdO1xuICAgICAgICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgdmFsaWRhdGVVbmlxdWVJdGVtcywgKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hlbWFDb2RlfSA9PT0gZmFsc2VgKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVVbmlxdWVJdGVtcygpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBnZW4ubGV0KFwiaVwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgICAgICAgICAgY29uc3QgaiA9IGdlbi5sZXQoXCJqXCIpO1xuICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IGksIGogfSk7XG4gICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2l9ID4gMWAsICgpID0+IChjYW5PcHRpbWl6ZSgpID8gbG9vcE4gOiBsb29wTjIpKGksIGopKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYW5PcHRpbWl6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtVHlwZXMubGVuZ3RoID4gMCAmJiAhaXRlbVR5cGVzLnNvbWUoKHQpID0+IHQgPT09IFwib2JqZWN0XCIgfHwgdCA9PT0gXCJhcnJheVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb29wTihpLCBqKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gZ2VuLm5hbWUoXCJpdGVtXCIpO1xuICAgICAgICAgICAgY29uc3Qgd3JvbmdUeXBlID0gKDAsIGRhdGFUeXBlXzEuY2hlY2tEYXRhVHlwZXMpKGl0ZW1UeXBlcywgaXRlbSwgaXQub3B0cy5zdHJpY3ROdW1iZXJzLCBkYXRhVHlwZV8xLkRhdGFUeXBlLldyb25nKTtcbiAgICAgICAgICAgIGNvbnN0IGluZGljZXMgPSBnZW4uY29uc3QoXCJpbmRpY2VzXCIsICgwLCBjb2RlZ2VuXzEuXykgYHt9YCk7XG4gICAgICAgICAgICBnZW4uZm9yKCgwLCBjb2RlZ2VuXzEuXykgYDske2l9LS07YCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGdlbi5sZXQoaXRlbSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfVske2l9XWApO1xuICAgICAgICAgICAgICAgIGdlbi5pZih3cm9uZ1R5cGUsICgwLCBjb2RlZ2VuXzEuXykgYGNvbnRpbnVlYCk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1UeXBlcy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7aXRlbX0gPT0gXCJzdHJpbmdcImAsICgwLCBjb2RlZ2VuXzEuXykgYCR7aXRlbX0gKz0gXCJfXCJgKTtcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmlmKCgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2luZGljZXN9WyR7aXRlbX1dID09IFwibnVtYmVyXCJgLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oaiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtpbmRpY2VzfVske2l0ZW19XWApO1xuICAgICAgICAgICAgICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmJyZWFrKCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgJHtpbmRpY2VzfVske2l0ZW19XSA9ICR7aX1gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BOMihpLCBqKSB7XG4gICAgICAgICAgICBjb25zdCBlcWwgPSAoMCwgdXRpbF8xLnVzZUZ1bmMpKGdlbiwgZXF1YWxfMS5kZWZhdWx0KTtcbiAgICAgICAgICAgIGNvbnN0IG91dGVyID0gZ2VuLm5hbWUoXCJvdXRlclwiKTtcbiAgICAgICAgICAgIGdlbi5sYWJlbChvdXRlcikuZm9yKCgwLCBjb2RlZ2VuXzEuXykgYDske2l9LS07YCwgKCkgPT4gZ2VuLmZvcigoMCwgY29kZWdlbl8xLl8pIGAke2p9ID0gJHtpfTsgJHtqfS0tO2AsICgpID0+IGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2VxbH0oJHtkYXRhfVske2l9XSwgJHtkYXRhfVske2p9XSlgLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmJyZWFrKG91dGVyKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuaXF1ZUl0ZW1zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcXVhbF8xID0gcmVxdWlyZShcIi4uLy4uL3J1bnRpbWUvZXF1YWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiBcIm11c3QgYmUgZXF1YWwgdG8gY29uc3RhbnRcIixcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2FsbG93ZWRWYWx1ZTogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImNvbnN0XCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWFDb2RlLCBzY2hlbWEgfSA9IGN4dDtcbiAgICAgICAgaWYgKCRkYXRhIHx8IChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGAhJHsoMCwgdXRpbF8xLnVzZUZ1bmMpKGdlbiwgZXF1YWxfMS5kZWZhdWx0KX0oJHtkYXRhfSwgJHtzY2hlbWFDb2RlfSlgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN4dC5mYWlsKCgwLCBjb2RlZ2VuXzEuXykgYCR7c2NoZW1hfSAhPT0gJHtkYXRhfWApO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXF1YWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL2VxdWFsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IGJlIGVxdWFsIHRvIG9uZSBvZiB0aGUgYWxsb3dlZCB2YWx1ZXNcIixcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2FsbG93ZWRWYWx1ZXM6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJlbnVtXCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoISRkYXRhICYmIHNjaGVtYS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbnVtIG11c3QgaGF2ZSBub24tZW1wdHkgYXJyYXlcIik7XG4gICAgICAgIGNvbnN0IHVzZUxvb3AgPSBzY2hlbWEubGVuZ3RoID49IGl0Lm9wdHMubG9vcEVudW07XG4gICAgICAgIGxldCBlcWw7XG4gICAgICAgIGNvbnN0IGdldEVxbCA9ICgpID0+IChlcWwgIT09IG51bGwgJiYgZXFsICE9PSB2b2lkIDAgPyBlcWwgOiAoZXFsID0gKDAsIHV0aWxfMS51c2VGdW5jKShnZW4sIGVxdWFsXzEuZGVmYXVsdCkpKTtcbiAgICAgICAgbGV0IHZhbGlkO1xuICAgICAgICBpZiAodXNlTG9vcCB8fCAkZGF0YSkge1xuICAgICAgICAgICAgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIik7XG4gICAgICAgICAgICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgbG9vcEVudW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgICAgICBjb25zdCB2U2NoZW1hID0gZ2VuLmNvbnN0KFwidlNjaGVtYVwiLCBzY2hlbWFDb2RlKTtcbiAgICAgICAgICAgIHZhbGlkID0gKDAsIGNvZGVnZW5fMS5vcikoLi4uc2NoZW1hLm1hcCgoX3gsIGkpID0+IGVxdWFsQ29kZSh2U2NoZW1hLCBpKSkpO1xuICAgICAgICB9XG4gICAgICAgIGN4dC5wYXNzKHZhbGlkKTtcbiAgICAgICAgZnVuY3Rpb24gbG9vcEVudW0oKSB7XG4gICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSk7XG4gICAgICAgICAgICBnZW4uZm9yT2YoXCJ2XCIsIHNjaGVtYUNvZGUsICh2KSA9PiBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtnZXRFcWwoKX0oJHtkYXRhfSwgJHt2fSlgLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKS5icmVhaygpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZXF1YWxDb2RlKHZTY2hlbWEsIGkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaCA9IHNjaGVtYVtpXTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygc2NoID09PSBcIm9iamVjdFwiICYmIHNjaCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gKDAsIGNvZGVnZW5fMS5fKSBgJHtnZXRFcWwoKX0oJHtkYXRhfSwgJHt2U2NoZW1hfVske2l9XSlgXG4gICAgICAgICAgICAgICAgOiAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9ID09PSAke3NjaH1gO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnVtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgbGltaXROdW1iZXJfMSA9IHJlcXVpcmUoXCIuL2xpbWl0TnVtYmVyXCIpO1xuY29uc3QgbXVsdGlwbGVPZl8xID0gcmVxdWlyZShcIi4vbXVsdGlwbGVPZlwiKTtcbmNvbnN0IGxpbWl0TGVuZ3RoXzEgPSByZXF1aXJlKFwiLi9saW1pdExlbmd0aFwiKTtcbmNvbnN0IHBhdHRlcm5fMSA9IHJlcXVpcmUoXCIuL3BhdHRlcm5cIik7XG5jb25zdCBsaW1pdFByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL2xpbWl0UHJvcGVydGllc1wiKTtcbmNvbnN0IHJlcXVpcmVkXzEgPSByZXF1aXJlKFwiLi9yZXF1aXJlZFwiKTtcbmNvbnN0IGxpbWl0SXRlbXNfMSA9IHJlcXVpcmUoXCIuL2xpbWl0SXRlbXNcIik7XG5jb25zdCB1bmlxdWVJdGVtc18xID0gcmVxdWlyZShcIi4vdW5pcXVlSXRlbXNcIik7XG5jb25zdCBjb25zdF8xID0gcmVxdWlyZShcIi4vY29uc3RcIik7XG5jb25zdCBlbnVtXzEgPSByZXF1aXJlKFwiLi9lbnVtXCIpO1xuY29uc3QgdmFsaWRhdGlvbiA9IFtcbiAgICAvLyBudW1iZXJcbiAgICBsaW1pdE51bWJlcl8xLmRlZmF1bHQsXG4gICAgbXVsdGlwbGVPZl8xLmRlZmF1bHQsXG4gICAgLy8gc3RyaW5nXG4gICAgbGltaXRMZW5ndGhfMS5kZWZhdWx0LFxuICAgIHBhdHRlcm5fMS5kZWZhdWx0LFxuICAgIC8vIG9iamVjdFxuICAgIGxpbWl0UHJvcGVydGllc18xLmRlZmF1bHQsXG4gICAgcmVxdWlyZWRfMS5kZWZhdWx0LFxuICAgIC8vIGFycmF5XG4gICAgbGltaXRJdGVtc18xLmRlZmF1bHQsXG4gICAgdW5pcXVlSXRlbXNfMS5kZWZhdWx0LFxuICAgIC8vIGFueVxuICAgIHsga2V5d29yZDogXCJ0eXBlXCIsIHNjaGVtYVR5cGU6IFtcInN0cmluZ1wiLCBcImFycmF5XCJdIH0sXG4gICAgeyBrZXl3b3JkOiBcIm51bGxhYmxlXCIsIHNjaGVtYVR5cGU6IFwiYm9vbGVhblwiIH0sXG4gICAgY29uc3RfMS5kZWZhdWx0LFxuICAgIGVudW1fMS5kZWZhdWx0LFxuXTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZhbGlkYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBsZW4gfSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgbW9yZSB0aGFuICR7bGVufSBpdGVtc2AsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2xpbWl0OiAke2xlbn19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJhZGRpdGlvbmFsSXRlbXNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogW1wiYm9vbGVhblwiLCBcIm9iamVjdFwiXSxcbiAgICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBpdGVtcyB9ID0gcGFyZW50U2NoZW1hO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsICdcImFkZGl0aW9uYWxJdGVtc1wiIGlzIGlnbm9yZWQgd2hlbiBcIml0ZW1zXCIgaXMgbm90IGFuIGFycmF5IG9mIHNjaGVtYXMnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyhjeHQsIGl0ZW1zKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zKGN4dCwgaXRlbXMpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBkYXRhLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgIGl0Lml0ZW1zID0gdHJ1ZTtcbiAgICBjb25zdCBsZW4gPSBnZW4uY29uc3QoXCJsZW5cIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHsgbGVuOiBpdGVtcy5sZW5ndGggfSk7XG4gICAgICAgIGN4dC5wYXNzKCgwLCBjb2RlZ2VuXzEuXykgYCR7bGVufSA8PSAke2l0ZW1zLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmICEoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hKSkge1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi52YXIoXCJ2YWxpZFwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2xlbn0gPD0gJHtpdGVtcy5sZW5ndGh9YCk7IC8vIFRPRE8gdmFyXG4gICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiB2YWxpZGF0ZUl0ZW1zKHZhbGlkKSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXModmFsaWQpIHtcbiAgICAgICAgZ2VuLmZvclJhbmdlKFwiaVwiLCBpdGVtcy5sZW5ndGgsIGxlbiwgKGkpID0+IHtcbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoeyBrZXl3b3JkLCBkYXRhUHJvcDogaSwgZGF0YVByb3BUeXBlOiB1dGlsXzEuVHlwZS5OdW0gfSwgdmFsaWQpO1xuICAgICAgICAgICAgaWYgKCFpdC5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCksICgpID0+IGdlbi5icmVhaygpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyA9IHZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkaXRpb25hbEl0ZW1zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZVR1cGxlID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIml0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImFycmF5XCIsIFwiYm9vbGVhblwiXSxcbiAgICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IHNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZVR1cGxlKGN4dCwgXCJhZGRpdGlvbmFsSXRlbXNcIiwgc2NoZW1hKTtcbiAgICAgICAgaXQuaXRlbXMgPSB0cnVlO1xuICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGN4dC5vaygoMCwgY29kZV8xLnZhbGlkYXRlQXJyYXkpKGN4dCkpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gdmFsaWRhdGVUdXBsZShjeHQsIGV4dHJhSXRlbXMsIHNjaEFyciA9IGN4dC5zY2hlbWEpIHtcbiAgICBjb25zdCB7IGdlbiwgcGFyZW50U2NoZW1hLCBkYXRhLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgIGNoZWNrU3RyaWN0VHVwbGUocGFyZW50U2NoZW1hKTtcbiAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBzY2hBcnIubGVuZ3RoICYmIGl0Lml0ZW1zICE9PSB0cnVlKSB7XG4gICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgc2NoQXJyLmxlbmd0aCwgaXQuaXRlbXMpO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgc2NoQXJyLmZvckVhY2goKHNjaCwgaSkgPT4ge1xuICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2xlbn0gPiAke2l9YCwgKCkgPT4gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgICAgc2NoZW1hUHJvcDogaSxcbiAgICAgICAgICAgIGRhdGFQcm9wOiBpLFxuICAgICAgICB9LCB2YWxpZCkpO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGNoZWNrU3RyaWN0VHVwbGUoc2NoKSB7XG4gICAgICAgIGNvbnN0IHsgb3B0cywgZXJyU2NoZW1hUGF0aCB9ID0gaXQ7XG4gICAgICAgIGNvbnN0IGwgPSBzY2hBcnIubGVuZ3RoO1xuICAgICAgICBjb25zdCBmdWxsVHVwbGUgPSBsID09PSBzY2gubWluSXRlbXMgJiYgKGwgPT09IHNjaC5tYXhJdGVtcyB8fCBzY2hbZXh0cmFJdGVtc10gPT09IGZhbHNlKTtcbiAgICAgICAgaWYgKG9wdHMuc3RyaWN0VHVwbGVzICYmICFmdWxsVHVwbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBcIiR7a2V5d29yZH1cIiBpcyAke2x9LXR1cGxlLCBidXQgbWluSXRlbXMgb3IgbWF4SXRlbXMvJHtleHRyYUl0ZW1zfSBhcmUgbm90IHNwZWNpZmllZCBvciBkaWZmZXJlbnQgYXQgcGF0aCBcIiR7ZXJyU2NoZW1hUGF0aH1cImA7XG4gICAgICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIG1zZywgb3B0cy5zdHJpY3RUdXBsZXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVR1cGxlID0gdmFsaWRhdGVUdXBsZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWl0ZW1zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgaXRlbXNfMSA9IHJlcXVpcmUoXCIuL2l0ZW1zXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicHJlZml4SXRlbXNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogW1wiYXJyYXlcIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgY29kZTogKGN4dCkgPT4gKDAsIGl0ZW1zXzEudmFsaWRhdGVUdXBsZSkoY3h0LCBcIml0ZW1zXCIpLFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWZpeEl0ZW1zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGFkZGl0aW9uYWxJdGVtc18xID0gcmVxdWlyZShcIi4vYWRkaXRpb25hbEl0ZW1zXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IGxlbiB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBOT1QgaGF2ZSBtb3JlIHRoYW4gJHtsZW59IGl0ZW1zYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBsZW4gfSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7bGltaXQ6ICR7bGVufX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIml0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBwcmVmaXhJdGVtcyB9ID0gcGFyZW50U2NoZW1hO1xuICAgICAgICBpdC5pdGVtcyA9IHRydWU7XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHByZWZpeEl0ZW1zKVxuICAgICAgICAgICAgKDAsIGFkZGl0aW9uYWxJdGVtc18xLnZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zKShjeHQsIHByZWZpeEl0ZW1zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY3h0Lm9rKCgwLCBjb2RlXzEudmFsaWRhdGVBcnJheSkoY3h0KSk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pdGVtczIwMjAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBtaW4sIG1heCB9IH0pID0+IG1heCA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgJHttaW59IHZhbGlkIGl0ZW0ocylgXG4gICAgICAgIDogKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgJHttaW59IGFuZCBubyBtb3JlIHRoYW4gJHttYXh9IHZhbGlkIGl0ZW0ocylgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IG1pbiwgbWF4IH0gfSkgPT4gbWF4ID09PSB1bmRlZmluZWQgPyAoMCwgY29kZWdlbl8xLl8pIGB7bWluQ29udGFpbnM6ICR7bWlufX1gIDogKDAsIGNvZGVnZW5fMS5fKSBge21pbkNvbnRhaW5zOiAke21pbn0sIG1heENvbnRhaW5zOiAke21heH19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJjb250YWluc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICAgICAgbGV0IG1pbjtcbiAgICAgICAgbGV0IG1heDtcbiAgICAgICAgY29uc3QgeyBtaW5Db250YWlucywgbWF4Q29udGFpbnMgfSA9IHBhcmVudFNjaGVtYTtcbiAgICAgICAgaWYgKGl0Lm9wdHMubmV4dCkge1xuICAgICAgICAgICAgbWluID0gbWluQ29udGFpbnMgPT09IHVuZGVmaW5lZCA/IDEgOiBtaW5Db250YWlucztcbiAgICAgICAgICAgIG1heCA9IG1heENvbnRhaW5zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWluID0gMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW4gPSBnZW4uY29uc3QoXCJsZW5cIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7IG1pbiwgbWF4IH0pO1xuICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQgJiYgbWluID09PSAwKSB7XG4gICAgICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIGBcIm1pbkNvbnRhaW5zXCIgPT0gMCB3aXRob3V0IFwibWF4Q29udGFpbnNcIjogXCJjb250YWluc1wiIGtleXdvcmQgaWdub3JlZGApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXggIT09IHVuZGVmaW5lZCAmJiBtaW4gPiBtYXgpIHtcbiAgICAgICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgYFwibWluQ29udGFpbnNcIiA+IFwibWF4Q29udGFpbnNcIiBpcyBhbHdheXMgaW52YWxpZGApO1xuICAgICAgICAgICAgY3h0LmZhaWwoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGxldCBjb25kID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtsZW59ID49ICR7bWlufWA7XG4gICAgICAgICAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29uZCA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7Y29uZH0gJiYgJHtsZW59IDw9ICR7bWF4fWA7XG4gICAgICAgICAgICBjeHQucGFzcyhjb25kKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpdC5pdGVtcyA9IHRydWU7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkICYmIG1pbiA9PT0gMSkge1xuICAgICAgICAgICAgdmFsaWRhdGVJdGVtcyh2YWxpZCwgKCkgPT4gZ2VuLmlmKHZhbGlkLCAoKSA9PiBnZW4uYnJlYWsoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1pbiA9PT0gMCkge1xuICAgICAgICAgICAgZ2VuLmxldCh2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoID4gMGAsIHZhbGlkYXRlSXRlbXNXaXRoQ291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2VuLmxldCh2YWxpZCwgZmFsc2UpO1xuICAgICAgICAgICAgdmFsaWRhdGVJdGVtc1dpdGhDb3VudCgpO1xuICAgICAgICB9XG4gICAgICAgIGN4dC5yZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtc1dpdGhDb3VudCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIik7XG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IGdlbi5sZXQoXCJjb3VudFwiLCAwKTtcbiAgICAgICAgICAgIHZhbGlkYXRlSXRlbXMoc2NoVmFsaWQsICgpID0+IGdlbi5pZihzY2hWYWxpZCwgKCkgPT4gY2hlY2tMaW1pdHMoY291bnQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyhfdmFsaWQsIGJsb2NrKSB7XG4gICAgICAgICAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIDAsIGxlbiwgKGkpID0+IHtcbiAgICAgICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZDogXCJjb250YWluc1wiLFxuICAgICAgICAgICAgICAgICAgICBkYXRhUHJvcDogaSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVByb3BUeXBlOiB1dGlsXzEuVHlwZS5OdW0sXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSwgX3ZhbGlkKTtcbiAgICAgICAgICAgICAgICBibG9jaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tMaW1pdHMoY291bnQpIHtcbiAgICAgICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYCR7Y291bnR9KytgKTtcbiAgICAgICAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2NvdW50fSA+PSAke21pbn1gLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKS5icmVhaygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2NvdW50fSA+ICR7bWF4fWAsICgpID0+IGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhaygpKTtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSAxKVxuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2NvdW50fSA+PSAke21pbn1gLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRhaW5zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZVNjaGVtYURlcHMgPSBleHBvcnRzLnZhbGlkYXRlUHJvcGVydHlEZXBzID0gZXhwb3J0cy5lcnJvciA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5leHBvcnRzLmVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBwcm9wZXJ0eSwgZGVwc0NvdW50LCBkZXBzIH0gfSkgPT4ge1xuICAgICAgICBjb25zdCBwcm9wZXJ0eV9pZXMgPSBkZXBzQ291bnQgPT09IDEgPyBcInByb3BlcnR5XCIgOiBcInByb3BlcnRpZXNcIjtcbiAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBoYXZlICR7cHJvcGVydHlfaWVzfSAke2RlcHN9IHdoZW4gcHJvcGVydHkgJHtwcm9wZXJ0eX0gaXMgcHJlc2VudGA7XG4gICAgfSxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBwcm9wZXJ0eSwgZGVwc0NvdW50LCBkZXBzLCBtaXNzaW5nUHJvcGVydHkgfSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7cHJvcGVydHk6ICR7cHJvcGVydHl9LFxuICAgIG1pc3NpbmdQcm9wZXJ0eTogJHttaXNzaW5nUHJvcGVydHl9LFxuICAgIGRlcHNDb3VudDogJHtkZXBzQ291bnR9LFxuICAgIGRlcHM6ICR7ZGVwc319YCwgLy8gVE9ETyBjaGFuZ2UgdG8gcmVmZXJlbmNlXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZGVwZW5kZW5jaWVzXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICAgIGVycm9yOiBleHBvcnRzLmVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IFtwcm9wRGVwcywgc2NoRGVwc10gPSBzcGxpdERlcGVuZGVuY2llcyhjeHQpO1xuICAgICAgICB2YWxpZGF0ZVByb3BlcnR5RGVwcyhjeHQsIHByb3BEZXBzKTtcbiAgICAgICAgdmFsaWRhdGVTY2hlbWFEZXBzKGN4dCwgc2NoRGVwcyk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBzcGxpdERlcGVuZGVuY2llcyh7IHNjaGVtYSB9KSB7XG4gICAgY29uc3QgcHJvcGVydHlEZXBzID0ge307XG4gICAgY29uc3Qgc2NoZW1hRGVwcyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBpZiAoa2V5ID09PSBcIl9fcHJvdG9fX1wiKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGRlcHMgPSBBcnJheS5pc0FycmF5KHNjaGVtYVtrZXldKSA/IHByb3BlcnR5RGVwcyA6IHNjaGVtYURlcHM7XG4gICAgICAgIGRlcHNba2V5XSA9IHNjaGVtYVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gW3Byb3BlcnR5RGVwcywgc2NoZW1hRGVwc107XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5RGVwcyhjeHQsIHByb3BlcnR5RGVwcyA9IGN4dC5zY2hlbWEpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICBpZiAoT2JqZWN0LmtleXMocHJvcGVydHlEZXBzKS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBtaXNzaW5nID0gZ2VuLmxldChcIm1pc3NpbmdcIik7XG4gICAgZm9yIChjb25zdCBwcm9wIGluIHByb3BlcnR5RGVwcykge1xuICAgICAgICBjb25zdCBkZXBzID0gcHJvcGVydHlEZXBzW3Byb3BdO1xuICAgICAgICBpZiAoZGVwcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgaGFzUHJvcGVydHkgPSAoMCwgY29kZV8xLnByb3BlcnR5SW5EYXRhKShnZW4sIGRhdGEsIHByb3AsIGl0Lm9wdHMub3duUHJvcGVydGllcyk7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoe1xuICAgICAgICAgICAgcHJvcGVydHk6IHByb3AsXG4gICAgICAgICAgICBkZXBzQ291bnQ6IGRlcHMubGVuZ3RoLFxuICAgICAgICAgICAgZGVwczogZGVwcy5qb2luKFwiLCBcIiksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgICAgICBnZW4uaWYoaGFzUHJvcGVydHksICgpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlcFByb3Agb2YgZGVwcykge1xuICAgICAgICAgICAgICAgICAgICAoMCwgY29kZV8xLmNoZWNrUmVwb3J0TWlzc2luZ1Byb3ApKGN4dCwgZGVwUHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtoYXNQcm9wZXJ0eX0gJiYgKCR7KDAsIGNvZGVfMS5jaGVja01pc3NpbmdQcm9wKShjeHQsIGRlcHMsIG1pc3NpbmcpfSlgKTtcbiAgICAgICAgICAgICgwLCBjb2RlXzEucmVwb3J0TWlzc2luZ1Byb3ApKGN4dCwgbWlzc2luZyk7XG4gICAgICAgICAgICBnZW4uZWxzZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVByb3BlcnR5RGVwcyA9IHZhbGlkYXRlUHJvcGVydHlEZXBzO1xuZnVuY3Rpb24gdmFsaWRhdGVTY2hlbWFEZXBzKGN4dCwgc2NoZW1hRGVwcyA9IGN4dC5zY2hlbWEpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgZm9yIChjb25zdCBwcm9wIGluIHNjaGVtYURlcHMpIHtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWFEZXBzW3Byb3BdKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBnZW4uaWYoKDAsIGNvZGVfMS5wcm9wZXJ0eUluRGF0YSkoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHsga2V5d29yZCwgc2NoZW1hUHJvcDogcHJvcCB9LCB2YWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHZhbGlkKTtcbiAgICAgICAgfSwgKCkgPT4gZ2VuLnZhcih2YWxpZCwgdHJ1ZSkgLy8gVE9ETyB2YXJcbiAgICAgICAgKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlU2NoZW1hRGVwcyA9IHZhbGlkYXRlU2NoZW1hRGVwcztcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlcGVuZGVuY2llcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJwcm9wZXJ0eSBuYW1lIG11c3QgYmUgdmFsaWRcIixcbiAgICBwYXJhbXM6ICh7IHBhcmFtcyB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7cHJvcGVydHlOYW1lOiAke3BhcmFtcy5wcm9wZXJ0eU5hbWV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicHJvcGVydHlOYW1lc1wiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgZ2VuLmZvckluKFwia2V5XCIsIGRhdGEsIChrZXkpID0+IHtcbiAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBwcm9wZXJ0eU5hbWU6IGtleSB9KTtcbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwicHJvcGVydHlOYW1lc1wiLFxuICAgICAgICAgICAgICAgIGRhdGE6IGtleSxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZXM6IFtcInN0cmluZ1wiXSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWU6IGtleSxcbiAgICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCksICgpID0+IHtcbiAgICAgICAgICAgICAgICBjeHQuZXJyb3IodHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpdC5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5icmVhaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcGVydHlOYW1lcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9uYW1lc1wiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiBcIm11c3QgTk9UIGhhdmUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXCIsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXMgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2FkZGl0aW9uYWxQcm9wZXJ0eTogJHtwYXJhbXMuYWRkaXRpb25hbFByb3BlcnR5fX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsXG4gICAgdHlwZTogW1wib2JqZWN0XCJdLFxuICAgIHNjaGVtYVR5cGU6IFtcImJvb2xlYW5cIiwgXCJvYmplY3RcIl0sXG4gICAgYWxsb3dVbmRlZmluZWQ6IHRydWUsXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBkYXRhLCBlcnJzQ291bnQsIGl0IH0gPSBjeHQ7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWVycnNDb3VudClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICAgICAgY29uc3QgeyBhbGxFcnJvcnMsIG9wdHMgfSA9IGl0O1xuICAgICAgICBpdC5wcm9wcyA9IHRydWU7XG4gICAgICAgIGlmIChvcHRzLnJlbW92ZUFkZGl0aW9uYWwgIT09IFwiYWxsXCIgJiYgKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHByb3BzID0gKDAsIGNvZGVfMS5hbGxTY2hlbWFQcm9wZXJ0aWVzKShwYXJlbnRTY2hlbWEucHJvcGVydGllcyk7XG4gICAgICAgIGNvbnN0IHBhdFByb3BzID0gKDAsIGNvZGVfMS5hbGxTY2hlbWFQcm9wZXJ0aWVzKShwYXJlbnRTY2hlbWEucGF0dGVyblByb3BlcnRpZXMpO1xuICAgICAgICBjaGVja0FkZGl0aW9uYWxQcm9wZXJ0aWVzKCk7XG4gICAgICAgIGN4dC5vaygoMCwgY29kZWdlbl8xLl8pIGAke2VycnNDb3VudH0gPT09ICR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc31gKTtcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tBZGRpdGlvbmFsUHJvcGVydGllcygpIHtcbiAgICAgICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wcy5sZW5ndGggJiYgIXBhdFByb3BzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnR5Q29kZShrZXkpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKGlzQWRkaXRpb25hbChrZXkpLCAoKSA9PiBhZGRpdGlvbmFsUHJvcGVydHlDb2RlKGtleSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNBZGRpdGlvbmFsKGtleSkge1xuICAgICAgICAgICAgbGV0IGRlZmluZWRQcm9wO1xuICAgICAgICAgICAgaWYgKHByb3BzLmxlbmd0aCA+IDgpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIG1heWJlIGFuIG9wdGlvbiBpbnN0ZWFkIG9mIGhhcmQtY29kZWQgOD9cbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wc1NjaGVtYSA9ICgwLCB1dGlsXzEuc2NoZW1hUmVmT3JWYWwpKGl0LCBwYXJlbnRTY2hlbWEucHJvcGVydGllcywgXCJwcm9wZXJ0aWVzXCIpO1xuICAgICAgICAgICAgICAgIGRlZmluZWRQcm9wID0gKDAsIGNvZGVfMS5pc093blByb3BlcnR5KShnZW4sIHByb3BzU2NoZW1hLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lZFByb3AgPSAoMCwgY29kZWdlbl8xLm9yKSguLi5wcm9wcy5tYXAoKHApID0+ICgwLCBjb2RlZ2VuXzEuXykgYCR7a2V5fSA9PT0gJHtwfWApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZmluZWRQcm9wID0gY29kZWdlbl8xLm5pbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRQcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9ICgwLCBjb2RlZ2VuXzEub3IpKGRlZmluZWRQcm9wLCAuLi5wYXRQcm9wcy5tYXAoKHApID0+ICgwLCBjb2RlZ2VuXzEuXykgYCR7KDAsIGNvZGVfMS51c2VQYXR0ZXJuKShjeHQsIHApfS50ZXN0KCR7a2V5fSlgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5ub3QpKGRlZmluZWRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZWxldGVBZGRpdGlvbmFsKGtleSkge1xuICAgICAgICAgICAgZ2VuLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgZGVsZXRlICR7ZGF0YX1bJHtrZXl9XWApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFkZGl0aW9uYWxQcm9wZXJ0eUNvZGUoa2V5KSB7XG4gICAgICAgICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImFsbFwiIHx8IChvcHRzLnJlbW92ZUFkZGl0aW9uYWwgJiYgc2NoZW1hID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGVBZGRpdGlvbmFsKGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgYWRkaXRpb25hbFByb3BlcnR5OiBrZXkgfSk7XG4gICAgICAgICAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFhbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5icmVhaygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgISgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnJlbW92ZUFkZGl0aW9uYWwgPT09IFwiZmFpbGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5QWRkaXRpb25hbFNjaGVtYShrZXksIHZhbGlkLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjeHQucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUFkZGl0aW9uYWwoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhcHBseUFkZGl0aW9uYWxTY2hlbWEoa2V5LCB2YWxpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCksICgpID0+IGdlbi5icmVhaygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXBwbHlBZGRpdGlvbmFsU2NoZW1hKGtleSwgdmFsaWQsIGVycm9ycykge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NoZW1hID0ge1xuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICBkYXRhUHJvcDoga2V5LFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuU3RyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChlcnJvcnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzdWJzY2hlbWEsIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoc3Vic2NoZW1hLCB2YWxpZCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZGl0aW9uYWxQcm9wZXJ0aWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgYWRkaXRpb25hbFByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL2FkZGl0aW9uYWxQcm9wZXJ0aWVzXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicHJvcGVydGllc1wiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmIChpdC5vcHRzLnJlbW92ZUFkZGl0aW9uYWwgPT09IFwiYWxsXCIgJiYgcGFyZW50U2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEuZGVmYXVsdC5jb2RlKG5ldyB2YWxpZGF0ZV8xLktleXdvcmRDeHQoaXQsIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEuZGVmYXVsdCwgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsUHJvcHMgPSAoMCwgY29kZV8xLmFsbFNjaGVtYVByb3BlcnRpZXMpKHNjaGVtYSk7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBhbGxQcm9wcykge1xuICAgICAgICAgICAgaXQuZGVmaW5lZFByb3BlcnRpZXMuYWRkKHByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIGFsbFByb3BzLmxlbmd0aCAmJiBpdC5wcm9wcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgaXQucHJvcHMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCAoMCwgdXRpbF8xLnRvSGFzaCkoYWxsUHJvcHMpLCBpdC5wcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IGFsbFByb3BzLmZpbHRlcigocCkgPT4gISgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWFbcF0pKTtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAoaGFzRGVmYXVsdChwcm9wKSkge1xuICAgICAgICAgICAgICAgIGFwcGx5UHJvcGVydHlTY2hlbWEocHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVfMS5wcm9wZXJ0eUluRGF0YSkoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpKTtcbiAgICAgICAgICAgICAgICBhcHBseVByb3BlcnR5U2NoZW1hKHByb3ApO1xuICAgICAgICAgICAgICAgIGlmICghaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICBnZW4uZWxzZSgpLnZhcih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZ2VuLmVuZElmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjeHQuaXQuZGVmaW5lZFByb3BlcnRpZXMuYWRkKHByb3ApO1xuICAgICAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYXNEZWZhdWx0KHByb3ApIHtcbiAgICAgICAgICAgIHJldHVybiBpdC5vcHRzLnVzZURlZmF1bHRzICYmICFpdC5jb21wb3NpdGVSdWxlICYmIHNjaGVtYVtwcm9wXS5kZWZhdWx0ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXBwbHlQcm9wZXJ0eVNjaGVtYShwcm9wKSB7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcInByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICBzY2hlbWFQcm9wOiBwcm9wLFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBwcm9wLFxuICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wZXJ0aWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IHV0aWxfMiA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJwYXR0ZXJuUHJvcGVydGllc1wiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBkYXRhLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgb3B0cyB9ID0gaXQ7XG4gICAgICAgIGNvbnN0IHBhdHRlcm5zID0gKDAsIGNvZGVfMS5hbGxTY2hlbWFQcm9wZXJ0aWVzKShzY2hlbWEpO1xuICAgICAgICBjb25zdCBhbHdheXNWYWxpZFBhdHRlcm5zID0gcGF0dGVybnMuZmlsdGVyKChwKSA9PiAoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hW3BdKSk7XG4gICAgICAgIGlmIChwYXR0ZXJucy5sZW5ndGggPT09IDAgfHxcbiAgICAgICAgICAgIChhbHdheXNWYWxpZFBhdHRlcm5zLmxlbmd0aCA9PT0gcGF0dGVybnMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgKCFpdC5vcHRzLnVuZXZhbHVhdGVkIHx8IGl0LnByb3BzID09PSB0cnVlKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGVja1Byb3BlcnRpZXMgPSBvcHRzLnN0cmljdFNjaGVtYSAmJiAhb3B0cy5hbGxvd01hdGNoaW5nUHJvcGVydGllcyAmJiBwYXJlbnRTY2hlbWEucHJvcGVydGllcztcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBpZiAoaXQucHJvcHMgIT09IHRydWUgJiYgIShpdC5wcm9wcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKSkge1xuICAgICAgICAgICAgaXQucHJvcHMgPSAoMCwgdXRpbF8yLmV2YWx1YXRlZFByb3BzVG9OYW1lKShnZW4sIGl0LnByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSBpdDtcbiAgICAgICAgdmFsaWRhdGVQYXR0ZXJuUHJvcGVydGllcygpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZVBhdHRlcm5Qcm9wZXJ0aWVzKCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXQgb2YgcGF0dGVybnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tQcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgICAgICBjaGVja01hdGNoaW5nUHJvcGVydGllcyhwYXQpO1xuICAgICAgICAgICAgICAgIGlmIChpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHBhdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZW4udmFyKHZhbGlkLCB0cnVlKTsgLy8gVE9ETyB2YXJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHBhdCk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZih2YWxpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTWF0Y2hpbmdQcm9wZXJ0aWVzKHBhdCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIGNoZWNrUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGlmIChuZXcgUmVnRXhwKHBhdCkudGVzdChwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIGBwcm9wZXJ0eSAke3Byb3B9IG1hdGNoZXMgcGF0dGVybiAke3BhdH0gKHVzZSBhbGxvd01hdGNoaW5nUHJvcGVydGllcylgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzKHBhdCkge1xuICAgICAgICAgICAgZ2VuLmZvckluKFwia2V5XCIsIGRhdGEsIChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHsoMCwgY29kZV8xLnVzZVBhdHRlcm4pKGN4dCwgcGF0KX0udGVzdCgke2tleX0pYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbHdheXNWYWxpZCA9IGFsd2F5c1ZhbGlkUGF0dGVybnMuaW5jbHVkZXMocGF0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbHdheXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5d29yZDogXCJwYXR0ZXJuUHJvcGVydGllc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYVByb3A6IHBhdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJvcDoga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogdXRpbF8yLlR5cGUuU3RyLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIHByb3BzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7cHJvcHN9WyR7a2V5fV1gLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghYWx3YXlzVmFsaWQgJiYgIWl0LmFsbEVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuIHNob3J0LWNpcmN1aXQgaWYgYHVuZXZhbHVhdGVkUHJvcGVydGllc2AgaXMgbm90IHN1cHBvcnRlZCAob3B0cy5uZXh0ID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIGlmIGFsbCBwcm9wZXJ0aWVzIHdlcmUgZXZhbHVhdGVkIChwcm9wcyA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXR0ZXJuUHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJub3RcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hKSkge1xuICAgICAgICAgICAgY3h0LmZhaWwoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAga2V5d29yZDogXCJub3RcIixcbiAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICBjcmVhdGVFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgYWxsRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICBjeHQuZmFpbFJlc3VsdCh2YWxpZCwgKCkgPT4gY3h0LnJlc2V0KCksICgpID0+IGN4dC5lcnJvcigpKTtcbiAgICB9LFxuICAgIGVycm9yOiB7IG1lc3NhZ2U6IFwibXVzdCBOT1QgYmUgdmFsaWRcIiB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYW55T2ZcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgY29kZTogY29kZV8xLnZhbGlkYXRlVW5pb24sXG4gICAgZXJyb3I6IHsgbWVzc2FnZTogXCJtdXN0IG1hdGNoIGEgc2NoZW1hIGluIGFueU9mXCIgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbnlPZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IG1hdGNoIGV4YWN0bHkgb25lIHNjaGVtYSBpbiBvbmVPZlwiLFxuICAgIHBhcmFtczogKHsgcGFyYW1zIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtwYXNzaW5nU2NoZW1hczogJHtwYXJhbXMucGFzc2luZ319YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJvbmVPZlwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICAgICAgaWYgKGl0Lm9wdHMuZGlzY3JpbWluYXRvciAmJiBwYXJlbnRTY2hlbWEuZGlzY3JpbWluYXRvcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgc2NoQXJyID0gc2NoZW1hO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IHBhc3NpbmcgPSBnZW4ubGV0KFwicGFzc2luZ1wiLCBudWxsKTtcbiAgICAgICAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKTtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7IHBhc3NpbmcgfSk7XG4gICAgICAgIC8vIFRPRE8gcG9zc2libHkgZmFpbCBzdHJhaWdodCBhd2F5ICh3aXRoIHdhcm5pbmcgb3IgZXhjZXB0aW9uKSBpZiB0aGVyZSBhcmUgdHdvIGVtcHR5IGFsd2F5cyB2YWxpZCBzY2hlbWFzXG4gICAgICAgIGdlbi5ibG9jayh2YWxpZGF0ZU9uZU9mKTtcbiAgICAgICAgY3h0LnJlc3VsdCh2YWxpZCwgKCkgPT4gY3h0LnJlc2V0KCksICgpID0+IGN4dC5lcnJvcih0cnVlKSk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlT25lT2YoKSB7XG4gICAgICAgICAgICBzY2hBcnIuZm9yRWFjaCgoc2NoLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHNjaEN4dDtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLnZhcihzY2hWYWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwib25lT2ZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYVByb3A6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9LCBzY2hWYWxpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC5pZigoMCwgY29kZWdlbl8xLl8pIGAke3NjaFZhbGlkfSAmJiAke3ZhbGlkfWApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXNzaWduKHZhbGlkLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hc3NpZ24ocGFzc2luZywgKDAsIGNvZGVnZW5fMS5fKSBgWyR7cGFzc2luZ30sICR7aX1dYClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lbHNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdlbi5pZihzY2hWYWxpZCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihwYXNzaW5nLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaEN4dClcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQsIGNvZGVnZW5fMS5OYW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbmVPZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJhbGxPZlwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgc2NoZW1hLmZvckVhY2goKHNjaCwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2gpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoeyBrZXl3b3JkOiBcImFsbE9mXCIsIHNjaGVtYVByb3A6IGkgfSwgdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQpO1xuICAgICAgICB9KTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFsbE9mLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXMgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IG1hdGNoIFwiJHtwYXJhbXMuaWZDbGF1c2V9XCIgc2NoZW1hYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtcyB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7ZmFpbGluZ0tleXdvcmQ6ICR7cGFyYW1zLmlmQ2xhdXNlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImlmXCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAocGFyZW50U2NoZW1hLnRoZW4gPT09IHVuZGVmaW5lZCAmJiBwYXJlbnRTY2hlbWEuZWxzZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsICdcImlmXCIgd2l0aG91dCBcInRoZW5cIiBhbmQgXCJlbHNlXCIgaXMgaWdub3JlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc1RoZW4gPSBoYXNTY2hlbWEoaXQsIFwidGhlblwiKTtcbiAgICAgICAgY29uc3QgaGFzRWxzZSA9IGhhc1NjaGVtYShpdCwgXCJlbHNlXCIpO1xuICAgICAgICBpZiAoIWhhc1RoZW4gJiYgIWhhc0Vsc2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpO1xuICAgICAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgICAgICB2YWxpZGF0ZUlmKCk7XG4gICAgICAgIGN4dC5yZXNldCgpO1xuICAgICAgICBpZiAoaGFzVGhlbiAmJiBoYXNFbHNlKSB7XG4gICAgICAgICAgICBjb25zdCBpZkNsYXVzZSA9IGdlbi5sZXQoXCJpZkNsYXVzZVwiKTtcbiAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBpZkNsYXVzZSB9KTtcbiAgICAgICAgICAgIGdlbi5pZihzY2hWYWxpZCwgdmFsaWRhdGVDbGF1c2UoXCJ0aGVuXCIsIGlmQ2xhdXNlKSwgdmFsaWRhdGVDbGF1c2UoXCJlbHNlXCIsIGlmQ2xhdXNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzVGhlbikge1xuICAgICAgICAgICAgZ2VuLmlmKHNjaFZhbGlkLCB2YWxpZGF0ZUNsYXVzZShcInRoZW5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KShzY2hWYWxpZCksIHZhbGlkYXRlQ2xhdXNlKFwiZWxzZVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3h0LnBhc3ModmFsaWQsICgpID0+IGN4dC5lcnJvcih0cnVlKSk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlSWYoKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcImlmXCIsXG4gICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFsbEVycm9yczogZmFsc2UsXG4gICAgICAgICAgICB9LCBzY2hWYWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUNsYXVzZShrZXl3b3JkLCBpZkNsYXVzZSkge1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHsga2V5d29yZCB9LCBzY2hWYWxpZCk7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgICAgIGN4dC5tZXJnZVZhbGlkRXZhbHVhdGVkKHNjaEN4dCwgdmFsaWQpO1xuICAgICAgICAgICAgICAgIGlmIChpZkNsYXVzZSlcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihpZkNsYXVzZSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtrZXl3b3JkfWApO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IGlmQ2xhdXNlOiBrZXl3b3JkIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZnVuY3Rpb24gaGFzU2NoZW1hKGl0LCBrZXl3b3JkKSB7XG4gICAgY29uc3Qgc2NoZW1hID0gaXQuc2NoZW1hW2tleXdvcmRdO1xuICAgIHJldHVybiBzY2hlbWEgIT09IHVuZGVmaW5lZCAmJiAhKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogW1widGhlblwiLCBcImVsc2VcIl0sXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICBjb2RlKHsga2V5d29yZCwgcGFyZW50U2NoZW1hLCBpdCB9KSB7XG4gICAgICAgIGlmIChwYXJlbnRTY2hlbWEuaWYgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgYFwiJHtrZXl3b3JkfVwiIHdpdGhvdXQgXCJpZlwiIGlzIGlnbm9yZWRgKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRoZW5FbHNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYWRkaXRpb25hbEl0ZW1zXzEgPSByZXF1aXJlKFwiLi9hZGRpdGlvbmFsSXRlbXNcIik7XG5jb25zdCBwcmVmaXhJdGVtc18xID0gcmVxdWlyZShcIi4vcHJlZml4SXRlbXNcIik7XG5jb25zdCBpdGVtc18xID0gcmVxdWlyZShcIi4vaXRlbXNcIik7XG5jb25zdCBpdGVtczIwMjBfMSA9IHJlcXVpcmUoXCIuL2l0ZW1zMjAyMFwiKTtcbmNvbnN0IGNvbnRhaW5zXzEgPSByZXF1aXJlKFwiLi9jb250YWluc1wiKTtcbmNvbnN0IGRlcGVuZGVuY2llc18xID0gcmVxdWlyZShcIi4vZGVwZW5kZW5jaWVzXCIpO1xuY29uc3QgcHJvcGVydHlOYW1lc18xID0gcmVxdWlyZShcIi4vcHJvcGVydHlOYW1lc1wiKTtcbmNvbnN0IGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9hZGRpdGlvbmFsUHJvcGVydGllc1wiKTtcbmNvbnN0IHByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnRpZXNcIik7XG5jb25zdCBwYXR0ZXJuUHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vcGF0dGVyblByb3BlcnRpZXNcIik7XG5jb25zdCBub3RfMSA9IHJlcXVpcmUoXCIuL25vdFwiKTtcbmNvbnN0IGFueU9mXzEgPSByZXF1aXJlKFwiLi9hbnlPZlwiKTtcbmNvbnN0IG9uZU9mXzEgPSByZXF1aXJlKFwiLi9vbmVPZlwiKTtcbmNvbnN0IGFsbE9mXzEgPSByZXF1aXJlKFwiLi9hbGxPZlwiKTtcbmNvbnN0IGlmXzEgPSByZXF1aXJlKFwiLi9pZlwiKTtcbmNvbnN0IHRoZW5FbHNlXzEgPSByZXF1aXJlKFwiLi90aGVuRWxzZVwiKTtcbmZ1bmN0aW9uIGdldEFwcGxpY2F0b3IoZHJhZnQyMDIwID0gZmFsc2UpIHtcbiAgICBjb25zdCBhcHBsaWNhdG9yID0gW1xuICAgICAgICAvLyBhbnlcbiAgICAgICAgbm90XzEuZGVmYXVsdCxcbiAgICAgICAgYW55T2ZfMS5kZWZhdWx0LFxuICAgICAgICBvbmVPZl8xLmRlZmF1bHQsXG4gICAgICAgIGFsbE9mXzEuZGVmYXVsdCxcbiAgICAgICAgaWZfMS5kZWZhdWx0LFxuICAgICAgICB0aGVuRWxzZV8xLmRlZmF1bHQsXG4gICAgICAgIC8vIG9iamVjdFxuICAgICAgICBwcm9wZXJ0eU5hbWVzXzEuZGVmYXVsdCxcbiAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXNfMS5kZWZhdWx0LFxuICAgICAgICBkZXBlbmRlbmNpZXNfMS5kZWZhdWx0LFxuICAgICAgICBwcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICAgICAgcGF0dGVyblByb3BlcnRpZXNfMS5kZWZhdWx0LFxuICAgIF07XG4gICAgLy8gYXJyYXlcbiAgICBpZiAoZHJhZnQyMDIwKVxuICAgICAgICBhcHBsaWNhdG9yLnB1c2gocHJlZml4SXRlbXNfMS5kZWZhdWx0LCBpdGVtczIwMjBfMS5kZWZhdWx0KTtcbiAgICBlbHNlXG4gICAgICAgIGFwcGxpY2F0b3IucHVzaChhZGRpdGlvbmFsSXRlbXNfMS5kZWZhdWx0LCBpdGVtc18xLmRlZmF1bHQpO1xuICAgIGFwcGxpY2F0b3IucHVzaChjb250YWluc18xLmRlZmF1bHQpO1xuICAgIHJldHVybiBhcHBsaWNhdG9yO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0QXBwbGljYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IG1hdGNoIGZvcm1hdCBcIiR7c2NoZW1hQ29kZX1cImAsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtmb3JtYXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJmb3JtYXRcIixcbiAgICB0eXBlOiBbXCJudW1iZXJcIiwgXCJzdHJpbmdcIl0sXG4gICAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCwgcnVsZVR5cGUpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgb3B0cywgZXJyU2NoZW1hUGF0aCwgc2NoZW1hRW52LCBzZWxmIH0gPSBpdDtcbiAgICAgICAgaWYgKCFvcHRzLnZhbGlkYXRlRm9ybWF0cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCRkYXRhKVxuICAgICAgICAgICAgdmFsaWRhdGUkRGF0YUZvcm1hdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2YWxpZGF0ZUZvcm1hdCgpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZSREYXRhRm9ybWF0KCkge1xuICAgICAgICAgICAgY29uc3QgZm10cyA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7XG4gICAgICAgICAgICAgICAgcmVmOiBzZWxmLmZvcm1hdHMsXG4gICAgICAgICAgICAgICAgY29kZTogb3B0cy5jb2RlLmZvcm1hdHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGZEZWYgPSBnZW4uY29uc3QoXCJmRGVmXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7Zm10c31bJHtzY2hlbWFDb2RlfV1gKTtcbiAgICAgICAgICAgIGNvbnN0IGZUeXBlID0gZ2VuLmxldChcImZUeXBlXCIpO1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gZ2VuLmxldChcImZvcm1hdFwiKTtcbiAgICAgICAgICAgIC8vIFRPRE8gc2ltcGxpZnlcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtmRGVmfSA9PSBcIm9iamVjdFwiICYmICEoJHtmRGVmfSBpbnN0YW5jZW9mIFJlZ0V4cClgLCAoKSA9PiBnZW4uYXNzaWduKGZUeXBlLCAoMCwgY29kZWdlbl8xLl8pIGAke2ZEZWZ9LnR5cGUgfHwgXCJzdHJpbmdcImApLmFzc2lnbihmb3JtYXQsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZkRlZn0udmFsaWRhdGVgKSwgKCkgPT4gZ2VuLmFzc2lnbihmVHlwZSwgKDAsIGNvZGVnZW5fMS5fKSBgXCJzdHJpbmdcImApLmFzc2lnbihmb3JtYXQsIGZEZWYpKTtcbiAgICAgICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5vcikodW5rbm93bkZtdCgpLCBpbnZhbGlkRm10KCkpKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHVua25vd25GbXQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMuc3RyaWN0U2NoZW1hID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5uaWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7c2NoZW1hQ29kZX0gJiYgISR7Zm9ybWF0fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBpbnZhbGlkRm10KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxGb3JtYXQgPSBzY2hlbWFFbnYuJGFzeW5jXG4gICAgICAgICAgICAgICAgICAgID8gKDAsIGNvZGVnZW5fMS5fKSBgKCR7ZkRlZn0uYXN5bmMgPyBhd2FpdCAke2Zvcm1hdH0oJHtkYXRhfSkgOiAke2Zvcm1hdH0oJHtkYXRhfSkpYFxuICAgICAgICAgICAgICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7Zm9ybWF0fSgke2RhdGF9KWA7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWREYXRhID0gKDAsIGNvZGVnZW5fMS5fKSBgKHR5cGVvZiAke2Zvcm1hdH0gPT0gXCJmdW5jdGlvblwiID8gJHtjYWxsRm9ybWF0fSA6ICR7Zm9ybWF0fS50ZXN0KCR7ZGF0YX0pKWA7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7Zm9ybWF0fSAmJiAke2Zvcm1hdH0gIT09IHRydWUgJiYgJHtmVHlwZX0gPT09ICR7cnVsZVR5cGV9ICYmICEke3ZhbGlkRGF0YX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KCkge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0RGVmID0gc2VsZi5mb3JtYXRzW3NjaGVtYV07XG4gICAgICAgICAgICBpZiAoIWZvcm1hdERlZikge1xuICAgICAgICAgICAgICAgIHVua25vd25Gb3JtYXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0RGVmID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IFtmbXRUeXBlLCBmb3JtYXQsIGZtdFJlZl0gPSBnZXRGb3JtYXQoZm9ybWF0RGVmKTtcbiAgICAgICAgICAgIGlmIChmbXRUeXBlID09PSBydWxlVHlwZSlcbiAgICAgICAgICAgICAgICBjeHQucGFzcyh2YWxpZENvbmRpdGlvbigpKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHVua25vd25Gb3JtYXQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMuc3RyaWN0U2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmxvZ2dlci53YXJuKHVua25vd25Nc2coKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHVua25vd25Nc2coKSk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdW5rbm93bk1zZygpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGB1bmtub3duIGZvcm1hdCBcIiR7c2NoZW1hfVwiIGlnbm9yZWQgaW4gc2NoZW1hIGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCJgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldEZvcm1hdChmbXREZWYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gZm10RGVmIGluc3RhbmNlb2YgUmVnRXhwXG4gICAgICAgICAgICAgICAgICAgID8gKDAsIGNvZGVnZW5fMS5yZWdleHBDb2RlKShmbXREZWYpXG4gICAgICAgICAgICAgICAgICAgIDogb3B0cy5jb2RlLmZvcm1hdHNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKDAsIGNvZGVnZW5fMS5fKSBgJHtvcHRzLmNvZGUuZm9ybWF0c30keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKHNjaGVtYSl9YFxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZm10ID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHsga2V5OiBzY2hlbWEsIHJlZjogZm10RGVmLCBjb2RlIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm10RGVmID09IFwib2JqZWN0XCIgJiYgIShmbXREZWYgaW5zdGFuY2VvZiBSZWdFeHApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbZm10RGVmLnR5cGUgfHwgXCJzdHJpbmdcIiwgZm10RGVmLnZhbGlkYXRlLCAoMCwgY29kZWdlbl8xLl8pIGAke2ZtdH0udmFsaWRhdGVgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcInN0cmluZ1wiLCBmbXREZWYsIGZtdF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiB2YWxpZENvbmRpdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdERlZiA9PSBcIm9iamVjdFwiICYmICEoZm9ybWF0RGVmIGluc3RhbmNlb2YgUmVnRXhwKSAmJiBmb3JtYXREZWYuYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzY2hlbWFFbnYuJGFzeW5jKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMgZm9ybWF0IGluIHN5bmMgc2NoZW1hXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgYXdhaXQgJHtmbXRSZWZ9KCR7ZGF0YX0pYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBmb3JtYXQgPT0gXCJmdW5jdGlvblwiID8gKDAsIGNvZGVnZW5fMS5fKSBgJHtmbXRSZWZ9KCR7ZGF0YX0pYCA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7Zm10UmVmfS50ZXN0KCR7ZGF0YX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZm9ybWF0XzEgPSByZXF1aXJlKFwiLi9mb3JtYXRcIik7XG5jb25zdCBmb3JtYXQgPSBbZm9ybWF0XzEuZGVmYXVsdF07XG5leHBvcnRzLmRlZmF1bHQgPSBmb3JtYXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29udGVudFZvY2FidWxhcnkgPSBleHBvcnRzLm1ldGFkYXRhVm9jYWJ1bGFyeSA9IHZvaWQgMDtcbmV4cG9ydHMubWV0YWRhdGFWb2NhYnVsYXJ5ID0gW1xuICAgIFwidGl0bGVcIixcbiAgICBcImRlc2NyaXB0aW9uXCIsXG4gICAgXCJkZWZhdWx0XCIsXG4gICAgXCJkZXByZWNhdGVkXCIsXG4gICAgXCJyZWFkT25seVwiLFxuICAgIFwid3JpdGVPbmx5XCIsXG4gICAgXCJleGFtcGxlc1wiLFxuXTtcbmV4cG9ydHMuY29udGVudFZvY2FidWxhcnkgPSBbXG4gICAgXCJjb250ZW50TWVkaWFUeXBlXCIsXG4gICAgXCJjb250ZW50RW5jb2RpbmdcIixcbiAgICBcImNvbnRlbnRTY2hlbWFcIixcbl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRhZGF0YS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5jb25zdCB2YWxpZGF0aW9uXzEgPSByZXF1aXJlKFwiLi92YWxpZGF0aW9uXCIpO1xuY29uc3QgYXBwbGljYXRvcl8xID0gcmVxdWlyZShcIi4vYXBwbGljYXRvclwiKTtcbmNvbnN0IGZvcm1hdF8xID0gcmVxdWlyZShcIi4vZm9ybWF0XCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgZHJhZnQ3Vm9jYWJ1bGFyaWVzID0gW1xuICAgIGNvcmVfMS5kZWZhdWx0LFxuICAgIHZhbGlkYXRpb25fMS5kZWZhdWx0LFxuICAgICgwLCBhcHBsaWNhdG9yXzEuZGVmYXVsdCkoKSxcbiAgICBmb3JtYXRfMS5kZWZhdWx0LFxuICAgIG1ldGFkYXRhXzEubWV0YWRhdGFWb2NhYnVsYXJ5LFxuICAgIG1ldGFkYXRhXzEuY29udGVudFZvY2FidWxhcnksXG5dO1xuZXhwb3J0cy5kZWZhdWx0ID0gZHJhZnQ3Vm9jYWJ1bGFyaWVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHJhZnQ3LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EaXNjckVycm9yID0gdm9pZCAwO1xudmFyIERpc2NyRXJyb3I7XG4oZnVuY3Rpb24gKERpc2NyRXJyb3IpIHtcbiAgICBEaXNjckVycm9yW1wiVGFnXCJdID0gXCJ0YWdcIjtcbiAgICBEaXNjckVycm9yW1wiTWFwcGluZ1wiXSA9IFwibWFwcGluZ1wiO1xufSkoRGlzY3JFcnJvciA9IGV4cG9ydHMuRGlzY3JFcnJvciB8fCAoZXhwb3J0cy5EaXNjckVycm9yID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vZGlzY3JpbWluYXRvci90eXBlc1wiKTtcbmNvbnN0IGNvbXBpbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBkaXNjckVycm9yLCB0YWdOYW1lIH0gfSkgPT4gZGlzY3JFcnJvciA9PT0gdHlwZXNfMS5EaXNjckVycm9yLlRhZ1xuICAgICAgICA/IGB0YWcgXCIke3RhZ05hbWV9XCIgbXVzdCBiZSBzdHJpbmdgXG4gICAgICAgIDogYHZhbHVlIG9mIHRhZyBcIiR7dGFnTmFtZX1cIiBtdXN0IGJlIGluIG9uZU9mYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBkaXNjckVycm9yLCB0YWcsIHRhZ05hbWUgfSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7ZXJyb3I6ICR7ZGlzY3JFcnJvcn0sIHRhZzogJHt0YWdOYW1lfSwgdGFnVmFsdWU6ICR7dGFnfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImRpc2NyaW1pbmF0b3JcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9uZU9mIH0gPSBwYXJlbnRTY2hlbWE7XG4gICAgICAgIGlmICghaXQub3B0cy5kaXNjcmltaW5hdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiByZXF1aXJlcyBkaXNjcmltaW5hdG9yIG9wdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YWdOYW1lID0gc2NoZW1hLnByb3BlcnR5TmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiB0YWdOYW1lICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiByZXF1aXJlcyBwcm9wZXJ0eU5hbWVcIik7XG4gICAgICAgIGlmIChzY2hlbWEubWFwcGluZylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRpc2NyaW1pbmF0b3I6IG1hcHBpbmcgaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgaWYgKCFvbmVPZilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRpc2NyaW1pbmF0b3I6IHJlcXVpcmVzIG9uZU9mIGtleXdvcmRcIik7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIGZhbHNlKTtcbiAgICAgICAgY29uc3QgdGFnID0gZ2VuLmNvbnN0KFwidGFnXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKHRhZ05hbWUpfWApO1xuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7dGFnfSA9PSBcInN0cmluZ1wiYCwgKCkgPT4gdmFsaWRhdGVNYXBwaW5nKCksICgpID0+IGN4dC5lcnJvcihmYWxzZSwgeyBkaXNjckVycm9yOiB0eXBlc18xLkRpc2NyRXJyb3IuVGFnLCB0YWcsIHRhZ05hbWUgfSkpO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZU1hcHBpbmcoKSB7XG4gICAgICAgICAgICBjb25zdCBtYXBwaW5nID0gZ2V0TWFwcGluZygpO1xuICAgICAgICAgICAgZ2VuLmlmKGZhbHNlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGFnVmFsdWUgaW4gbWFwcGluZykge1xuICAgICAgICAgICAgICAgIGdlbi5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHt0YWd9ID09PSAke3RhZ1ZhbHVlfWApO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGFwcGx5VGFnU2NoZW1hKG1hcHBpbmdbdGFnVmFsdWVdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZW4uZWxzZSgpO1xuICAgICAgICAgICAgY3h0LmVycm9yKGZhbHNlLCB7IGRpc2NyRXJyb3I6IHR5cGVzXzEuRGlzY3JFcnJvci5NYXBwaW5nLCB0YWcsIHRhZ05hbWUgfSk7XG4gICAgICAgICAgICBnZW4uZW5kSWYoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcHBseVRhZ1NjaGVtYShzY2hlbWFQcm9wKSB7XG4gICAgICAgICAgICBjb25zdCBfdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQ6IFwib25lT2ZcIiwgc2NoZW1hUHJvcCB9LCBfdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCwgY29kZWdlbl8xLk5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIF92YWxpZDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRNYXBwaW5nKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3Qgb25lT2ZNYXBwaW5nID0ge307XG4gICAgICAgICAgICBjb25zdCB0b3BSZXF1aXJlZCA9IGhhc1JlcXVpcmVkKHBhcmVudFNjaGVtYSk7XG4gICAgICAgICAgICBsZXQgdGFnUmVxdWlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvbmVPZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBzY2ggPSBvbmVPZltpXTtcbiAgICAgICAgICAgICAgICBpZiAoKHNjaCA9PT0gbnVsbCB8fCBzY2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaC4kcmVmKSAmJiAhKDAsIHV0aWxfMS5zY2hlbWFIYXNSdWxlc0J1dFJlZikoc2NoLCBpdC5zZWxmLlJVTEVTKSkge1xuICAgICAgICAgICAgICAgICAgICBzY2ggPSBjb21waWxlXzEucmVzb2x2ZVJlZi5jYWxsKGl0LnNlbGYsIGl0LnNjaGVtYUVudi5yb290LCBpdC5iYXNlSWQsIHNjaCA9PT0gbnVsbCB8fCBzY2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaC4kcmVmKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaCBpbnN0YW5jZW9mIGNvbXBpbGVfMS5TY2hlbWFFbnYpXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2ggPSBzY2guc2NoZW1hO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wU2NoID0gKF9hID0gc2NoID09PSBudWxsIHx8IHNjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoLnByb3BlcnRpZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVt0YWdOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3BTY2ggIT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IG9uZU9mIHN1YnNjaGVtYXMgKG9yIHJlZmVyZW5jZWQgc2NoZW1hcykgbXVzdCBoYXZlIFwicHJvcGVydGllcy8ke3RhZ05hbWV9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFnUmVxdWlyZWQgPSB0YWdSZXF1aXJlZCAmJiAodG9wUmVxdWlyZWQgfHwgaGFzUmVxdWlyZWQoc2NoKSk7XG4gICAgICAgICAgICAgICAgYWRkTWFwcGluZ3MocHJvcFNjaCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRhZ1JlcXVpcmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogXCIke3RhZ05hbWV9XCIgbXVzdCBiZSByZXF1aXJlZGApO1xuICAgICAgICAgICAgcmV0dXJuIG9uZU9mTWFwcGluZztcbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhc1JlcXVpcmVkKHsgcmVxdWlyZWQgfSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJlcXVpcmVkKSAmJiByZXF1aXJlZC5pbmNsdWRlcyh0YWdOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdzKHNjaCwgaSkge1xuICAgICAgICAgICAgICAgIGlmIChzY2guY29uc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkTWFwcGluZyhzY2guY29uc3QsIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2guZW51bSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRhZ1ZhbHVlIG9mIHNjaC5lbnVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRNYXBwaW5nKHRhZ1ZhbHVlLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBcInByb3BlcnRpZXMvJHt0YWdOYW1lfVwiIG11c3QgaGF2ZSBcImNvbnN0XCIgb3IgXCJlbnVtXCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRNYXBwaW5nKHRhZ1ZhbHVlLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YWdWYWx1ZSAhPSBcInN0cmluZ1wiIHx8IHRhZ1ZhbHVlIGluIG9uZU9mTWFwcGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IFwiJHt0YWdOYW1lfVwiIHZhbHVlcyBtdXN0IGJlIHVuaXF1ZSBzdHJpbmdzYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uZU9mTWFwcGluZ1t0YWdWYWx1ZV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWlzc2luZ1JlZkVycm9yID0gZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IgPSBleHBvcnRzLkNvZGVHZW4gPSBleHBvcnRzLk5hbWUgPSBleHBvcnRzLm5pbCA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLl8gPSBleHBvcnRzLktleXdvcmRDeHQgPSB2b2lkIDA7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuY29uc3QgZHJhZnQ3XzEgPSByZXF1aXJlKFwiLi92b2NhYnVsYXJpZXMvZHJhZnQ3XCIpO1xuY29uc3QgZGlzY3JpbWluYXRvcl8xID0gcmVxdWlyZShcIi4vdm9jYWJ1bGFyaWVzL2Rpc2NyaW1pbmF0b3JcIik7XG5jb25zdCBkcmFmdDdNZXRhU2NoZW1hID0gcmVxdWlyZShcIi4vcmVmcy9qc29uLXNjaGVtYS1kcmFmdC0wNy5qc29uXCIpO1xuY29uc3QgTUVUQV9TVVBQT1JUX0RBVEEgPSBbXCIvcHJvcGVydGllc1wiXTtcbmNvbnN0IE1FVEFfU0NIRU1BX0lEID0gXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYVwiO1xuY2xhc3MgQWp2IGV4dGVuZHMgY29yZV8xLmRlZmF1bHQge1xuICAgIF9hZGRWb2NhYnVsYXJpZXMoKSB7XG4gICAgICAgIHN1cGVyLl9hZGRWb2NhYnVsYXJpZXMoKTtcbiAgICAgICAgZHJhZnQ3XzEuZGVmYXVsdC5mb3JFYWNoKCh2KSA9PiB0aGlzLmFkZFZvY2FidWxhcnkodikpO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmRpc2NyaW1pbmF0b3IpXG4gICAgICAgICAgICB0aGlzLmFkZEtleXdvcmQoZGlzY3JpbWluYXRvcl8xLmRlZmF1bHQpO1xuICAgIH1cbiAgICBfYWRkRGVmYXVsdE1ldGFTY2hlbWEoKSB7XG4gICAgICAgIHN1cGVyLl9hZGREZWZhdWx0TWV0YVNjaGVtYSgpO1xuICAgICAgICBpZiAoIXRoaXMub3B0cy5tZXRhKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBtZXRhU2NoZW1hID0gdGhpcy5vcHRzLiRkYXRhXG4gICAgICAgICAgICA/IHRoaXMuJGRhdGFNZXRhU2NoZW1hKGRyYWZ0N01ldGFTY2hlbWEsIE1FVEFfU1VQUE9SVF9EQVRBKVxuICAgICAgICAgICAgOiBkcmFmdDdNZXRhU2NoZW1hO1xuICAgICAgICB0aGlzLmFkZE1ldGFTY2hlbWEobWV0YVNjaGVtYSwgTUVUQV9TQ0hFTUFfSUQsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5yZWZzW1wiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9zY2hlbWFcIl0gPSBNRVRBX1NDSEVNQV9JRDtcbiAgICB9XG4gICAgZGVmYXVsdE1ldGEoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5vcHRzLmRlZmF1bHRNZXRhID1cbiAgICAgICAgICAgIHN1cGVyLmRlZmF1bHRNZXRhKCkgfHwgKHRoaXMuZ2V0U2NoZW1hKE1FVEFfU0NIRU1BX0lEKSA/IE1FVEFfU0NIRU1BX0lEIDogdW5kZWZpbmVkKSk7XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQWp2O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQWp2O1xudmFyIHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3ZhbGlkYXRlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiS2V5d29yZEN4dFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdGVfMS5LZXl3b3JkQ3h0OyB9IH0pO1xudmFyIGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvY29kZWdlblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5fOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5naWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyaW5naWZ5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmlsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEubmlsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLk5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb2RlR2VuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuQ29kZUdlbjsgfSB9KTtcbnZhciB2YWxpZGF0aW9uX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWYWxpZGF0aW9uRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRpb25fZXJyb3JfMS5kZWZhdWx0OyB9IH0pO1xudmFyIHJlZl9lcnJvcl8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9yZWZfZXJyb3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNaXNzaW5nUmVmRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZl9lcnJvcl8xLmRlZmF1bHQ7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hanYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZvcm1hdE5hbWVzID0gZXhwb3J0cy5mYXN0Rm9ybWF0cyA9IGV4cG9ydHMuZnVsbEZvcm1hdHMgPSB2b2lkIDA7XG5mdW5jdGlvbiBmbXREZWYodmFsaWRhdGUsIGNvbXBhcmUpIHtcbiAgICByZXR1cm4geyB2YWxpZGF0ZSwgY29tcGFyZSB9O1xufVxuZXhwb3J0cy5mdWxsRm9ybWF0cyA9IHtcbiAgICAvLyBkYXRlOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgZGF0ZTogZm10RGVmKGRhdGUsIGNvbXBhcmVEYXRlKSxcbiAgICAvLyBkYXRlLXRpbWU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICB0aW1lOiBmbXREZWYodGltZSwgY29tcGFyZVRpbWUpLFxuICAgIFwiZGF0ZS10aW1lXCI6IGZtdERlZihkYXRlX3RpbWUsIGNvbXBhcmVEYXRlVGltZSksXG4gICAgLy8gZHVyYXRpb246IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I2FwcGVuZGl4LUFcbiAgICBkdXJhdGlvbjogL15QKD8hJCkoKFxcZCtZKT8oXFxkK00pPyhcXGQrRCk/KFQoPz1cXGQpKFxcZCtIKT8oXFxkK00pPyhcXGQrUyk/KT98KFxcZCtXKT8pJC8sXG4gICAgdXJpLFxuICAgIFwidXJpLXJlZmVyZW5jZVwiOiAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KT8oPzpcXC8/XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol18JVswLTlhLWZdezJ9KSpAKT8oPzpcXFsoPzooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7Nn18OjooPzpbMC05YS1mXXsxLDR9Oil7NX18KD86WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7NH18KD86KD86WzAtOWEtZl17MSw0fTopezAsMX1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXszfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwyfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezJ9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDN9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9OnwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw0fVswLTlhLWZdezEsNH0pPzo6KSg/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykpfCg/Oig/OlswLTlhLWZdezEsNH06KXswLDV9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDZ9WzAtOWEtZl17MSw0fSk/OjopfFtWdl1bMC05YS1mXStcXC5bYS16MC05XFwtLl9+ISQmJygpKissOz06XSspXFxdfCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KXwoPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PV18JVswLTlhLWZdezJ9KSopKD86OlxcZCopPyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSp8XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT98KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT8oPzpcXD8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8oPzojKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/JC9pLFxuICAgIC8vIHVyaS10ZW1wbGF0ZTogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY1NzBcbiAgICBcInVyaS10ZW1wbGF0ZVwiOiAvXig/Oig/OlteXFx4MDAtXFx4MjBcIic8PiVcXFxcXmB7fH1dfCVbMC05YS1mXXsyfSl8XFx7WysjLi87PyY9LCFAfF0/KD86W2EtejAtOV9dfCVbMC05YS1mXXsyfSkrKD86OlsxLTldWzAtOV17MCwzfXxcXCopPyg/OiwoPzpbYS16MC05X118JVswLTlhLWZdezJ9KSsoPzo6WzEtOV1bMC05XXswLDN9fFxcKik/KSpcXH0pKiQvaSxcbiAgICAvLyBGb3IgdGhlIHNvdXJjZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZHBlcmluaS83MjkyOTRcbiAgICAvLyBGb3IgdGVzdCBjYXNlczogaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL2RlbW8vdXJsLXJlZ2V4XG4gICAgdXJsOiAvXig/Omh0dHBzP3xmdHApOlxcL1xcLyg/OlxcUysoPzo6XFxTKik/QCk/KD86KD8hKD86MTB8MTI3KSg/OlxcLlxcZHsxLDN9KXszfSkoPyEoPzoxNjlcXC4yNTR8MTkyXFwuMTY4KSg/OlxcLlxcZHsxLDN9KXsyfSkoPyExNzJcXC4oPzoxWzYtOV18MlxcZHwzWzAtMV0pKD86XFwuXFxkezEsM30pezJ9KSg/OlsxLTldXFxkP3wxXFxkXFxkfDJbMDFdXFxkfDIyWzAtM10pKD86XFwuKD86MT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkpezJ9KD86XFwuKD86WzEtOV1cXGQ/fDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNF0pKXwoPzooPzpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rLSkqW2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKykoPzpcXC4oPzpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rLSkqW2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKykqKD86XFwuKD86W2EtelxcdXswMGExfS1cXHV7ZmZmZn1dezIsfSkpKSg/OjpcXGR7Miw1fSk/KD86XFwvW15cXHNdKik/JC9pdSxcbiAgICBlbWFpbDogL15bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqQCg/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT8kL2ksXG4gICAgaG9zdG5hbWU6IC9eKD89LnsxLDI1M31cXC4/JClbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8oPzpcXC5bYS16MC05XSg/OlstMC05YS16XXswLDYxfVswLTlhLXpdKT8pKlxcLj8kL2ksXG4gICAgLy8gb3B0aW1pemVkIGh0dHBzOi8vd3d3LnNhZmFyaWJvb2tzb25saW5lLmNvbS9saWJyYXJ5L3ZpZXcvcmVndWxhci1leHByZXNzaW9ucy1jb29rYm9vay85NzgwNTk2ODAyODM3L2NoMDdzMTYuaHRtbFxuICAgIGlwdjQ6IC9eKD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pJC8sXG4gICAgaXB2NjogL14oKChbMC05YS1mXXsxLDR9Oil7N30oWzAtOWEtZl17MSw0fXw6KSl8KChbMC05YS1mXXsxLDR9Oil7Nn0oOlswLTlhLWZdezEsNH18KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlhLWZdezEsNH06KXs1fSgoKDpbMC05YS1mXXsxLDR9KXsxLDJ9KXw6KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlhLWZdezEsNH06KXs0fSgoKDpbMC05YS1mXXsxLDR9KXsxLDN9KXwoKDpbMC05YS1mXXsxLDR9KT86KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7M30oKCg6WzAtOWEtZl17MSw0fSl7MSw0fSl8KCg6WzAtOWEtZl17MSw0fSl7MCwyfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXsyfSgoKDpbMC05YS1mXXsxLDR9KXsxLDV9KXwoKDpbMC05YS1mXXsxLDR9KXswLDN9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezF9KCgoOlswLTlhLWZdezEsNH0pezEsNn0pfCgoOlswLTlhLWZdezEsNH0pezAsNH06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KDooKCg6WzAtOWEtZl17MSw0fSl7MSw3fSl8KCg6WzAtOWEtZl17MSw0fSl7MCw1fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKSkkL2ksXG4gICAgcmVnZXgsXG4gICAgLy8gdXVpZDogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDEyMlxuICAgIHV1aWQ6IC9eKD86dXJuOnV1aWQ6KT9bMC05YS1mXXs4fS0oPzpbMC05YS1mXXs0fS0pezN9WzAtOWEtZl17MTJ9JC9pLFxuICAgIC8vIEpTT04tcG9pbnRlcjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5MDFcbiAgICAvLyB1cmkgZnJhZ21lbnQ6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I2FwcGVuZGl4LUFcbiAgICBcImpzb24tcG9pbnRlclwiOiAvXig/OlxcLyg/Oltefi9dfH4wfH4xKSopKiQvLFxuICAgIFwianNvbi1wb2ludGVyLXVyaS1mcmFnbWVudFwiOiAvXiMoPzpcXC8oPzpbYS16MC05X1xcLS4hJCYnKCkqKyw7Oj1AXXwlWzAtOWEtZl17Mn18fjB8fjEpKikqJC9pLFxuICAgIC8vIHJlbGF0aXZlIEpTT04tcG9pbnRlcjogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtbHVmZi1yZWxhdGl2ZS1qc29uLXBvaW50ZXItMDBcbiAgICBcInJlbGF0aXZlLWpzb24tcG9pbnRlclwiOiAvXig/OjB8WzEtOV1bMC05XSopKD86I3woPzpcXC8oPzpbXn4vXXx+MHx+MSkqKSopJC8sXG4gICAgLy8gdGhlIGZvbGxvd2luZyBmb3JtYXRzIGFyZSB1c2VkIGJ5IHRoZSBvcGVuYXBpIHNwZWNpZmljYXRpb246IGh0dHBzOi8vc3BlYy5vcGVuYXBpcy5vcmcvb2FzL3YzLjAuMCNkYXRhLXR5cGVzXG4gICAgLy8gYnl0ZTogaHR0cHM6Ly9naXRodWIuY29tL21pZ3VlbG1vdGEvaXMtYmFzZTY0XG4gICAgYnl0ZSxcbiAgICAvLyBzaWduZWQgMzIgYml0IGludGVnZXJcbiAgICBpbnQzMjogeyB0eXBlOiBcIm51bWJlclwiLCB2YWxpZGF0ZTogdmFsaWRhdGVJbnQzMiB9LFxuICAgIC8vIHNpZ25lZCA2NCBiaXQgaW50ZWdlclxuICAgIGludDY0OiB7IHR5cGU6IFwibnVtYmVyXCIsIHZhbGlkYXRlOiB2YWxpZGF0ZUludDY0IH0sXG4gICAgLy8gQy10eXBlIGZsb2F0XG4gICAgZmxvYXQ6IHsgdHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlTnVtYmVyIH0sXG4gICAgLy8gQy10eXBlIGRvdWJsZVxuICAgIGRvdWJsZTogeyB0eXBlOiBcIm51bWJlclwiLCB2YWxpZGF0ZTogdmFsaWRhdGVOdW1iZXIgfSxcbiAgICAvLyBoaW50IHRvIHRoZSBVSSB0byBoaWRlIGlucHV0IHN0cmluZ3NcbiAgICBwYXNzd29yZDogdHJ1ZSxcbiAgICAvLyB1bmNoZWNrZWQgc3RyaW5nIHBheWxvYWRcbiAgICBiaW5hcnk6IHRydWUsXG59O1xuZXhwb3J0cy5mYXN0Rm9ybWF0cyA9IHtcbiAgICAuLi5leHBvcnRzLmZ1bGxGb3JtYXRzLFxuICAgIGRhdGU6IGZtdERlZigvXlxcZFxcZFxcZFxcZC1bMC0xXVxcZC1bMC0zXVxcZCQvLCBjb21wYXJlRGF0ZSksXG4gICAgdGltZTogZm10RGVmKC9eKD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPyk/JC9pLCBjb21wYXJlVGltZSksXG4gICAgXCJkYXRlLXRpbWVcIjogZm10RGVmKC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkW3RcXHNdKD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPykkL2ksIGNvbXBhcmVEYXRlVGltZSksXG4gICAgLy8gdXJpOiBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL2lzLW15LWpzb24tdmFsaWQvYmxvYi9tYXN0ZXIvZm9ybWF0cy5qc1xuICAgIHVyaTogL14oPzpbYS16XVthLXowLTkrXFwtLl0qOikoPzpcXC8/XFwvKT9bXlxcc10qJC9pLFxuICAgIFwidXJpLXJlZmVyZW5jZVwiOiAvXig/Oig/OlthLXpdW2EtejAtOStcXC0uXSo6KT9cXC8/XFwvKT8oPzpbXlxcXFxcXHMjXVteXFxzI10qKT8oPzojW15cXFxcXFxzXSopPyQvaSxcbiAgICAvLyBlbWFpbCAoc291cmNlcyBmcm9tIGpzZW4gdmFsaWRhdG9yKTpcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwMTMyMy91c2luZy1hLXJlZ3VsYXItZXhwcmVzc2lvbi10by12YWxpZGF0ZS1hbi1lbWFpbC1hZGRyZXNzI2Fuc3dlci04ODI5MzYzXG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCN2YWxpZC1lLW1haWwtYWRkcmVzcyAoc2VhcmNoIGZvciAnd2lsZnVsIHZpb2xhdGlvbicpXG4gICAgZW1haWw6IC9eW2EtejAtOS4hIyQlJicqKy89P15fYHt8fX4tXStAW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KD86XFwuW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KSokL2ksXG59O1xuZXhwb3J0cy5mb3JtYXROYW1lcyA9IE9iamVjdC5rZXlzKGV4cG9ydHMuZnVsbEZvcm1hdHMpO1xuZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjYXBwZW5kaXgtQ1xuICAgIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbn1cbmNvbnN0IERBVEUgPSAvXihcXGRcXGRcXGRcXGQpLShcXGRcXGQpLShcXGRcXGQpJC87XG5jb25zdCBEQVlTID0gWzAsIDMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xuZnVuY3Rpb24gZGF0ZShzdHIpIHtcbiAgICAvLyBmdWxsLWRhdGUgZnJvbSBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgY29uc3QgbWF0Y2hlcyA9IERBVEUuZXhlYyhzdHIpO1xuICAgIGlmICghbWF0Y2hlcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHllYXIgPSArbWF0Y2hlc1sxXTtcbiAgICBjb25zdCBtb250aCA9ICttYXRjaGVzWzJdO1xuICAgIGNvbnN0IGRheSA9ICttYXRjaGVzWzNdO1xuICAgIHJldHVybiAobW9udGggPj0gMSAmJlxuICAgICAgICBtb250aCA8PSAxMiAmJlxuICAgICAgICBkYXkgPj0gMSAmJlxuICAgICAgICBkYXkgPD0gKG1vbnRoID09PSAyICYmIGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IERBWVNbbW9udGhdKSk7XG59XG5mdW5jdGlvbiBjb21wYXJlRGF0ZShkMSwgZDIpIHtcbiAgICBpZiAoIShkMSAmJiBkMikpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKGQxID4gZDIpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmIChkMSA8IGQyKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgcmV0dXJuIDA7XG59XG5jb25zdCBUSU1FID0gL14oXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKShcXC5cXGQrKT8oenxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPyk/JC9pO1xuZnVuY3Rpb24gdGltZShzdHIsIHdpdGhUaW1lWm9uZSkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBUSU1FLmV4ZWMoc3RyKTtcbiAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBob3VyID0gK21hdGNoZXNbMV07XG4gICAgY29uc3QgbWludXRlID0gK21hdGNoZXNbMl07XG4gICAgY29uc3Qgc2Vjb25kID0gK21hdGNoZXNbM107XG4gICAgY29uc3QgdGltZVpvbmUgPSBtYXRjaGVzWzVdO1xuICAgIHJldHVybiAoKChob3VyIDw9IDIzICYmIG1pbnV0ZSA8PSA1OSAmJiBzZWNvbmQgPD0gNTkpIHx8XG4gICAgICAgIChob3VyID09PSAyMyAmJiBtaW51dGUgPT09IDU5ICYmIHNlY29uZCA9PT0gNjApKSAmJlxuICAgICAgICAoIXdpdGhUaW1lWm9uZSB8fCB0aW1lWm9uZSAhPT0gXCJcIikpO1xufVxuZnVuY3Rpb24gY29tcGFyZVRpbWUodDEsIHQyKSB7XG4gICAgaWYgKCEodDEgJiYgdDIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGExID0gVElNRS5leGVjKHQxKTtcbiAgICBjb25zdCBhMiA9IFRJTUUuZXhlYyh0Mik7XG4gICAgaWYgKCEoYTEgJiYgYTIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHQxID0gYTFbMV0gKyBhMVsyXSArIGExWzNdICsgKGExWzRdIHx8IFwiXCIpO1xuICAgIHQyID0gYTJbMV0gKyBhMlsyXSArIGEyWzNdICsgKGEyWzRdIHx8IFwiXCIpO1xuICAgIGlmICh0MSA+IHQyKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAodDEgPCB0MilcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xufVxuY29uc3QgREFURV9USU1FX1NFUEFSQVRPUiA9IC90fFxccy9pO1xuZnVuY3Rpb24gZGF0ZV90aW1lKHN0cikge1xuICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICBjb25zdCBkYXRlVGltZSA9IHN0ci5zcGxpdChEQVRFX1RJTUVfU0VQQVJBVE9SKTtcbiAgICByZXR1cm4gZGF0ZVRpbWUubGVuZ3RoID09PSAyICYmIGRhdGUoZGF0ZVRpbWVbMF0pICYmIHRpbWUoZGF0ZVRpbWVbMV0sIHRydWUpO1xufVxuZnVuY3Rpb24gY29tcGFyZURhdGVUaW1lKGR0MSwgZHQyKSB7XG4gICAgaWYgKCEoZHQxICYmIGR0MikpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgW2QxLCB0MV0gPSBkdDEuc3BsaXQoREFURV9USU1FX1NFUEFSQVRPUik7XG4gICAgY29uc3QgW2QyLCB0Ml0gPSBkdDIuc3BsaXQoREFURV9USU1FX1NFUEFSQVRPUik7XG4gICAgY29uc3QgcmVzID0gY29tcGFyZURhdGUoZDEsIGQyKTtcbiAgICBpZiAocmVzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlcyB8fCBjb21wYXJlVGltZSh0MSwgdDIpO1xufVxuY29uc3QgTk9UX1VSSV9GUkFHTUVOVCA9IC9cXC98Oi87XG5jb25zdCBVUkkgPSAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KSg/OlxcLz9cXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06XXwlWzAtOWEtZl17Mn0pKkApPyg/OlxcWyg/Oig/Oig/Oig/OlswLTlhLWZdezEsNH06KXs2fXw6Oig/OlswLTlhLWZdezEsNH06KXs1fXwoPzpbMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXs0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwxfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezN9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDJ9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7Mn18KD86KD86WzAtOWEtZl17MSw0fTopezAsM31bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH06fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDR9WzAtOWEtZl17MSw0fSk/OjopKD86WzAtOWEtZl17MSw0fTpbMC05YS1mXXsxLDR9fCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSl8KD86KD86WzAtOWEtZl17MSw0fTopezAsNX1bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH18KD86KD86WzAtOWEtZl17MSw0fTopezAsNn1bMC05YS1mXXsxLDR9KT86Oil8W1Z2XVswLTlhLWZdK1xcLlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdKylcXF18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pfCg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PV18JVswLTlhLWZdezJ9KSopKD86OlxcZCopPyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqfFxcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT98KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopKD86XFw/KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyg/OiMoPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/JC9pO1xuZnVuY3Rpb24gdXJpKHN0cikge1xuICAgIC8vIGh0dHA6Ly9qbXJ3YXJlLmNvbS9hcnRpY2xlcy8yMDA5L3VyaV9yZWdleHAvVVJJX3JlZ2V4Lmh0bWwgKyBvcHRpb25hbCBwcm90b2NvbCArIHJlcXVpcmVkIFwiLlwiXG4gICAgcmV0dXJuIE5PVF9VUklfRlJBR01FTlQudGVzdChzdHIpICYmIFVSSS50ZXN0KHN0cik7XG59XG5jb25zdCBCWVRFID0gL14oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezJ9PT18W0EtWmEtejAtOSsvXXszfT0pPyQvZ207XG5mdW5jdGlvbiBieXRlKHN0cikge1xuICAgIEJZVEUubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gQllURS50ZXN0KHN0cik7XG59XG5jb25zdCBNSU5fSU5UMzIgPSAtKDIgKiogMzEpO1xuY29uc3QgTUFYX0lOVDMyID0gMiAqKiAzMSAtIDE7XG5mdW5jdGlvbiB2YWxpZGF0ZUludDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIodmFsdWUpICYmIHZhbHVlIDw9IE1BWF9JTlQzMiAmJiB2YWx1ZSA+PSBNSU5fSU5UMzI7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUludDY0KHZhbHVlKSB7XG4gICAgLy8gSlNPTiBhbmQgamF2YXNjcmlwdCBtYXggSW50IGlzIDIqKjUzLCBzbyBhbnkgaW50IHRoYXQgcGFzc2VzIGlzSW50ZWdlciBpcyB2YWxpZCBmb3IgSW50NjRcbiAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlcigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IFpfQU5DSE9SID0gL1teXFxcXF1cXFxcWi87XG5mdW5jdGlvbiByZWdleChzdHIpIHtcbiAgICBpZiAoWl9BTkNIT1IudGVzdChzdHIpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IFJlZ0V4cChzdHIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZvcm1hdExpbWl0RGVmaW5pdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGFqdl8xID0gcmVxdWlyZShcImFqdlwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCJhanYvZGlzdC9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBvcHMgPSBjb2RlZ2VuXzEub3BlcmF0b3JzO1xuY29uc3QgS1dEcyA9IHtcbiAgICBmb3JtYXRNYXhpbXVtOiB7IG9rU3RyOiBcIjw9XCIsIG9rOiBvcHMuTFRFLCBmYWlsOiBvcHMuR1QgfSxcbiAgICBmb3JtYXRNaW5pbXVtOiB7IG9rU3RyOiBcIj49XCIsIG9rOiBvcHMuR1RFLCBmYWlsOiBvcHMuTFQgfSxcbiAgICBmb3JtYXRFeGNsdXNpdmVNYXhpbXVtOiB7IG9rU3RyOiBcIjxcIiwgb2s6IG9wcy5MVCwgZmFpbDogb3BzLkdURSB9LFxuICAgIGZvcm1hdEV4Y2x1c2l2ZU1pbmltdW06IHsgb2tTdHI6IFwiPlwiLCBvazogb3BzLkdULCBmYWlsOiBvcHMuTFRFIH0sXG59O1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBzaG91bGQgYmUgJHtLV0RzW2tleXdvcmRdLm9rU3RyfSAke3NjaGVtYUNvZGV9YCxcbiAgICBwYXJhbXM6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLl8gYHtjb21wYXJpc29uOiAke0tXRHNba2V5d29yZF0ub2tTdHJ9LCBsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmV4cG9ydHMuZm9ybWF0TGltaXREZWZpbml0aW9uID0ge1xuICAgIGtleXdvcmQ6IE9iamVjdC5rZXlzKEtXRHMpLFxuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgc2NoZW1hQ29kZSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICAgICAgaWYgKCFvcHRzLnZhbGlkYXRlRm9ybWF0cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZkN4dCA9IG5ldyBhanZfMS5LZXl3b3JkQ3h0KGl0LCBzZWxmLlJVTEVTLmFsbC5mb3JtYXQuZGVmaW5pdGlvbiwgXCJmb3JtYXRcIik7XG4gICAgICAgIGlmIChmQ3h0LiRkYXRhKVxuICAgICAgICAgICAgdmFsaWRhdGUkRGF0YUZvcm1hdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2YWxpZGF0ZUZvcm1hdCgpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZSREYXRhRm9ybWF0KCkge1xuICAgICAgICAgICAgY29uc3QgZm10cyA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7XG4gICAgICAgICAgICAgICAgcmVmOiBzZWxmLmZvcm1hdHMsXG4gICAgICAgICAgICAgICAgY29kZTogb3B0cy5jb2RlLmZvcm1hdHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGZtdCA9IGdlbi5jb25zdChcImZtdFwiLCBjb2RlZ2VuXzEuXyBgJHtmbXRzfVske2ZDeHQuc2NoZW1hQ29kZX1dYCk7XG4gICAgICAgICAgICBjeHQuZmFpbCRkYXRhKGNvZGVnZW5fMS5vcihjb2RlZ2VuXzEuXyBgdHlwZW9mICR7Zm10fSAhPSBcIm9iamVjdFwiYCwgY29kZWdlbl8xLl8gYCR7Zm10fSBpbnN0YW5jZW9mIFJlZ0V4cGAsIGNvZGVnZW5fMS5fIGB0eXBlb2YgJHtmbXR9LmNvbXBhcmUgIT0gXCJmdW5jdGlvblwiYCwgY29tcGFyZUNvZGUoZm10KSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KCkge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gZkN4dC5zY2hlbWE7XG4gICAgICAgICAgICBjb25zdCBmbXREZWYgPSBzZWxmLmZvcm1hdHNbZm9ybWF0XTtcbiAgICAgICAgICAgIGlmICghZm10RGVmIHx8IGZtdERlZiA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZtdERlZiAhPSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICAgICAgZm10RGVmIGluc3RhbmNlb2YgUmVnRXhwIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIGZtdERlZi5jb21wYXJlICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke2tleXdvcmR9XCI6IGZvcm1hdCBcIiR7Zm9ybWF0fVwiIGRvZXMgbm90IGRlZmluZSBcImNvbXBhcmVcIiBmdW5jdGlvbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZm10ID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAgICAgICAgICBrZXk6IGZvcm1hdCxcbiAgICAgICAgICAgICAgICByZWY6IGZtdERlZixcbiAgICAgICAgICAgICAgICBjb2RlOiBvcHRzLmNvZGUuZm9ybWF0cyA/IGNvZGVnZW5fMS5fIGAke29wdHMuY29kZS5mb3JtYXRzfSR7Y29kZWdlbl8xLmdldFByb3BlcnR5KGZvcm1hdCl9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3h0LmZhaWwkZGF0YShjb21wYXJlQ29kZShmbXQpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb21wYXJlQ29kZShmbXQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgJHtmbXR9LmNvbXBhcmUoJHtkYXRhfSwgJHtzY2hlbWFDb2RlfSkgJHtLV0RzW2tleXdvcmRdLmZhaWx9IDBgO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFtcImZvcm1hdFwiXSxcbn07XG5jb25zdCBmb3JtYXRMaW1pdFBsdWdpbiA9IChhanYpID0+IHtcbiAgICBhanYuYWRkS2V5d29yZChleHBvcnRzLmZvcm1hdExpbWl0RGVmaW5pdGlvbik7XG4gICAgcmV0dXJuIGFqdjtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBmb3JtYXRMaW1pdFBsdWdpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZm9ybWF0c18xID0gcmVxdWlyZShcIi4vZm9ybWF0c1wiKTtcbmNvbnN0IGxpbWl0XzEgPSByZXF1aXJlKFwiLi9saW1pdFwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCJhanYvZGlzdC9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBmdWxsTmFtZSA9IG5ldyBjb2RlZ2VuXzEuTmFtZShcImZ1bGxGb3JtYXRzXCIpO1xuY29uc3QgZmFzdE5hbWUgPSBuZXcgY29kZWdlbl8xLk5hbWUoXCJmYXN0Rm9ybWF0c1wiKTtcbmNvbnN0IGZvcm1hdHNQbHVnaW4gPSAoYWp2LCBvcHRzID0geyBrZXl3b3JkczogdHJ1ZSB9KSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0cykpIHtcbiAgICAgICAgYWRkRm9ybWF0cyhhanYsIG9wdHMsIGZvcm1hdHNfMS5mdWxsRm9ybWF0cywgZnVsbE5hbWUpO1xuICAgICAgICByZXR1cm4gYWp2O1xuICAgIH1cbiAgICBjb25zdCBbZm9ybWF0cywgZXhwb3J0TmFtZV0gPSBvcHRzLm1vZGUgPT09IFwiZmFzdFwiID8gW2Zvcm1hdHNfMS5mYXN0Rm9ybWF0cywgZmFzdE5hbWVdIDogW2Zvcm1hdHNfMS5mdWxsRm9ybWF0cywgZnVsbE5hbWVdO1xuICAgIGNvbnN0IGxpc3QgPSBvcHRzLmZvcm1hdHMgfHwgZm9ybWF0c18xLmZvcm1hdE5hbWVzO1xuICAgIGFkZEZvcm1hdHMoYWp2LCBsaXN0LCBmb3JtYXRzLCBleHBvcnROYW1lKTtcbiAgICBpZiAob3B0cy5rZXl3b3JkcylcbiAgICAgICAgbGltaXRfMS5kZWZhdWx0KGFqdik7XG4gICAgcmV0dXJuIGFqdjtcbn07XG5mb3JtYXRzUGx1Z2luLmdldCA9IChuYW1lLCBtb2RlID0gXCJmdWxsXCIpID0+IHtcbiAgICBjb25zdCBmb3JtYXRzID0gbW9kZSA9PT0gXCJmYXN0XCIgPyBmb3JtYXRzXzEuZmFzdEZvcm1hdHMgOiBmb3JtYXRzXzEuZnVsbEZvcm1hdHM7XG4gICAgY29uc3QgZiA9IGZvcm1hdHNbbmFtZV07XG4gICAgaWYgKCFmKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZm9ybWF0IFwiJHtuYW1lfVwiYCk7XG4gICAgcmV0dXJuIGY7XG59O1xuZnVuY3Rpb24gYWRkRm9ybWF0cyhhanYsIGxpc3QsIGZzLCBleHBvcnROYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBfYjtcbiAgICAoX2EgPSAoX2IgPSBhanYub3B0cy5jb2RlKS5mb3JtYXRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2IuZm9ybWF0cyA9IGNvZGVnZW5fMS5fIGByZXF1aXJlKFwiYWp2LWZvcm1hdHMvZGlzdC9mb3JtYXRzXCIpLiR7ZXhwb3J0TmFtZX1gKTtcbiAgICBmb3IgKGNvbnN0IGYgb2YgbGlzdClcbiAgICAgICAgYWp2LmFkZEZvcm1hdChmLCBmc1tmXSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmb3JtYXRzUGx1Z2luO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZm9ybWF0c1BsdWdpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY29weVByb3BlcnR5ID0gKHRvLCBmcm9tLCBwcm9wZXJ0eSwgaWdub3JlTm9uQ29uZmlndXJhYmxlKSA9PiB7XG5cdC8vIGBGdW5jdGlvbiNsZW5ndGhgIHNob3VsZCByZWZsZWN0IHRoZSBwYXJhbWV0ZXJzIG9mIGB0b2Agbm90IGBmcm9tYCBzaW5jZSB3ZSBrZWVwIGl0cyBib2R5LlxuXHQvLyBgRnVuY3Rpb24jcHJvdG90eXBlYCBpcyBub24td3JpdGFibGUgYW5kIG5vbi1jb25maWd1cmFibGUgc28gY2FuIG5ldmVyIGJlIG1vZGlmaWVkLlxuXHRpZiAocHJvcGVydHkgPT09ICdsZW5ndGgnIHx8IHByb3BlcnR5ID09PSAncHJvdG90eXBlJykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIGBGdW5jdGlvbiNhcmd1bWVudHNgIGFuZCBgRnVuY3Rpb24jY2FsbGVyYCBzaG91bGQgbm90IGJlIGNvcGllZC4gVGhleSB3ZXJlIHJlcG9ydGVkIHRvIGJlIHByZXNlbnQgaW4gYFJlZmxlY3Qub3duS2V5c2AgZm9yIHNvbWUgZGV2aWNlcyBpbiBSZWFjdCBOYXRpdmUgKCM0MSksIHNvIHdlIGV4cGxpY2l0bHkgaWdub3JlIHRoZW0gaGVyZS5cblx0aWYgKHByb3BlcnR5ID09PSAnYXJndW1lbnRzJyB8fCBwcm9wZXJ0eSA9PT0gJ2NhbGxlcicpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCB0b0Rlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvLCBwcm9wZXJ0eSk7XG5cdGNvbnN0IGZyb21EZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihmcm9tLCBwcm9wZXJ0eSk7XG5cblx0aWYgKCFjYW5Db3B5UHJvcGVydHkodG9EZXNjcmlwdG9yLCBmcm9tRGVzY3JpcHRvcikgJiYgaWdub3JlTm9uQ29uZmlndXJhYmxlKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCBwcm9wZXJ0eSwgZnJvbURlc2NyaXB0b3IpO1xufTtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpYCB0aHJvd3MgaWYgdGhlIHByb3BlcnR5IGV4aXN0cywgaXMgbm90IGNvbmZpZ3VyYWJsZSBhbmQgZWl0aGVyOlxuLy8gIC0gb25lIGl0cyBkZXNjcmlwdG9ycyBpcyBjaGFuZ2VkXG4vLyAgLSBpdCBpcyBub24td3JpdGFibGUgYW5kIGl0cyB2YWx1ZSBpcyBjaGFuZ2VkXG5jb25zdCBjYW5Db3B5UHJvcGVydHkgPSBmdW5jdGlvbiAodG9EZXNjcmlwdG9yLCBmcm9tRGVzY3JpcHRvcikge1xuXHRyZXR1cm4gdG9EZXNjcmlwdG9yID09PSB1bmRlZmluZWQgfHwgdG9EZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSB8fCAoXG5cdFx0dG9EZXNjcmlwdG9yLndyaXRhYmxlID09PSBmcm9tRGVzY3JpcHRvci53cml0YWJsZSAmJlxuXHRcdHRvRGVzY3JpcHRvci5lbnVtZXJhYmxlID09PSBmcm9tRGVzY3JpcHRvci5lbnVtZXJhYmxlICYmXG5cdFx0dG9EZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9PT0gZnJvbURlc2NyaXB0b3IuY29uZmlndXJhYmxlICYmXG5cdFx0KHRvRGVzY3JpcHRvci53cml0YWJsZSB8fCB0b0Rlc2NyaXB0b3IudmFsdWUgPT09IGZyb21EZXNjcmlwdG9yLnZhbHVlKVxuXHQpO1xufTtcblxuY29uc3QgY2hhbmdlUHJvdG90eXBlID0gKHRvLCBmcm9tKSA9PiB7XG5cdGNvbnN0IGZyb21Qcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnJvbSk7XG5cdGlmIChmcm9tUHJvdG90eXBlID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodG8pKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0T2JqZWN0LnNldFByb3RvdHlwZU9mKHRvLCBmcm9tUHJvdG90eXBlKTtcbn07XG5cbmNvbnN0IHdyYXBwZWRUb1N0cmluZyA9ICh3aXRoTmFtZSwgZnJvbUJvZHkpID0+IGAvKiBXcmFwcGVkICR7d2l0aE5hbWV9Ki9cXG4ke2Zyb21Cb2R5fWA7XG5cbmNvbnN0IHRvU3RyaW5nRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRnVuY3Rpb24ucHJvdG90eXBlLCAndG9TdHJpbmcnKTtcbmNvbnN0IHRvU3RyaW5nTmFtZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLCAnbmFtZScpO1xuXG4vLyBXZSBjYWxsIGBmcm9tLnRvU3RyaW5nKClgIGVhcmx5IChub3QgbGF6aWx5KSB0byBlbnN1cmUgYGZyb21gIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cbi8vIFdlIHVzZSBgYmluZCgpYCBpbnN0ZWFkIG9mIGEgY2xvc3VyZSBmb3IgdGhlIHNhbWUgcmVhc29uLlxuLy8gQ2FsbGluZyBgZnJvbS50b1N0cmluZygpYCBlYXJseSBhbHNvIGFsbG93cyBjYWNoaW5nIGl0IGluIGNhc2UgYHRvLnRvU3RyaW5nKClgIGlzIGNhbGxlZCBzZXZlcmFsIHRpbWVzLlxuY29uc3QgY2hhbmdlVG9TdHJpbmcgPSAodG8sIGZyb20sIG5hbWUpID0+IHtcblx0Y29uc3Qgd2l0aE5hbWUgPSBuYW1lID09PSAnJyA/ICcnIDogYHdpdGggJHtuYW1lLnRyaW0oKX0oKSBgO1xuXHRjb25zdCBuZXdUb1N0cmluZyA9IHdyYXBwZWRUb1N0cmluZy5iaW5kKG51bGwsIHdpdGhOYW1lLCBmcm9tLnRvU3RyaW5nKCkpO1xuXHQvLyBFbnN1cmUgYHRvLnRvU3RyaW5nLnRvU3RyaW5nYCBpcyBub24tZW51bWVyYWJsZSBhbmQgaGFzIHRoZSBzYW1lIGBzYW1lYFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3VG9TdHJpbmcsICduYW1lJywgdG9TdHJpbmdOYW1lKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCAndG9TdHJpbmcnLCB7Li4udG9TdHJpbmdEZXNjcmlwdG9yLCB2YWx1ZTogbmV3VG9TdHJpbmd9KTtcbn07XG5cbmNvbnN0IG1pbWljRm4gPSAodG8sIGZyb20sIHtpZ25vcmVOb25Db25maWd1cmFibGUgPSBmYWxzZX0gPSB7fSkgPT4ge1xuXHRjb25zdCB7bmFtZX0gPSB0bztcblxuXHRmb3IgKGNvbnN0IHByb3BlcnR5IG9mIFJlZmxlY3Qub3duS2V5cyhmcm9tKSkge1xuXHRcdGNvcHlQcm9wZXJ0eSh0bywgZnJvbSwgcHJvcGVydHksIGlnbm9yZU5vbkNvbmZpZ3VyYWJsZSk7XG5cdH1cblxuXHRjaGFuZ2VQcm90b3R5cGUodG8sIGZyb20pO1xuXHRjaGFuZ2VUb1N0cmluZyh0bywgZnJvbSwgbmFtZSk7XG5cblx0cmV0dXJuIHRvO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtaW1pY0ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgbWltaWNGbiA9IHJlcXVpcmUoJ21pbWljLWZuJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGlucHV0RnVuY3Rpb24sIG9wdGlvbnMgPSB7fSkgPT4ge1xuXHRpZiAodHlwZW9mIGlucHV0RnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiwgZ290IFxcYCR7dHlwZW9mIGlucHV0RnVuY3Rpb259XFxgYCk7XG5cdH1cblxuXHRjb25zdCB7XG5cdFx0d2FpdCA9IDAsXG5cdFx0YmVmb3JlID0gZmFsc2UsXG5cdFx0YWZ0ZXIgPSB0cnVlXG5cdH0gPSBvcHRpb25zO1xuXG5cdGlmICghYmVmb3JlICYmICFhZnRlcikge1xuXHRcdHRocm93IG5ldyBFcnJvcignQm90aCBgYmVmb3JlYCBhbmQgYGFmdGVyYCBhcmUgZmFsc2UsIGZ1bmN0aW9uIHdvdWxkblxcJ3QgYmUgY2FsbGVkLicpO1xuXHR9XG5cblx0bGV0IHRpbWVvdXQ7XG5cdGxldCByZXN1bHQ7XG5cblx0Y29uc3QgZGVib3VuY2VkRnVuY3Rpb24gPSBmdW5jdGlvbiAoLi4uYXJndW1lbnRzXykge1xuXHRcdGNvbnN0IGNvbnRleHQgPSB0aGlzO1xuXG5cdFx0Y29uc3QgbGF0ZXIgPSAoKSA9PiB7XG5cdFx0XHR0aW1lb3V0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoYWZ0ZXIpIHtcblx0XHRcdFx0cmVzdWx0ID0gaW5wdXRGdW5jdGlvbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHNfKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Y29uc3Qgc2hvdWxkQ2FsbE5vdyA9IGJlZm9yZSAmJiAhdGltZW91dDtcblx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0dGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuXG5cdFx0aWYgKHNob3VsZENhbGxOb3cpIHtcblx0XHRcdHJlc3VsdCA9IGlucHV0RnVuY3Rpb24uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzXyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRtaW1pY0ZuKGRlYm91bmNlZEZ1bmN0aW9uLCBpbnB1dEZ1bmN0aW9uKTtcblxuXHRkZWJvdW5jZWRGdW5jdGlvbi5jYW5jZWwgPSAoKSA9PiB7XG5cdFx0aWYgKHRpbWVvdXQpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHRcdHRpbWVvdXQgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBkZWJvdW5jZWRGdW5jdGlvbjtcbn07XG4iLCIvLyBOb3RlOiB0aGlzIGlzIHRoZSBzZW12ZXIub3JnIHZlcnNpb24gb2YgdGhlIHNwZWMgdGhhdCBpdCBpbXBsZW1lbnRzXG4vLyBOb3QgbmVjZXNzYXJpbHkgdGhlIHBhY2thZ2UgdmVyc2lvbiBvZiB0aGlzIGNvZGUuXG5jb25zdCBTRU1WRVJfU1BFQ19WRVJTSU9OID0gJzIuMC4wJ1xuXG5jb25zdCBNQVhfTEVOR1RIID0gMjU2XG5jb25zdCBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHxcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIDkwMDcxOTkyNTQ3NDA5OTFcblxuLy8gTWF4IHNhZmUgc2VnbWVudCBsZW5ndGggZm9yIGNvZXJjaW9uLlxuY29uc3QgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCA9IDE2XG5cbi8vIE1heCBzYWZlIGxlbmd0aCBmb3IgYSBidWlsZCBpZGVudGlmaWVyLiBUaGUgbWF4IGxlbmd0aCBtaW51cyA2IGNoYXJhY3RlcnMgZm9yXG4vLyB0aGUgc2hvcnRlc3QgdmVyc2lvbiB3aXRoIGEgYnVpbGQgMC4wLjArQlVJTEQuXG5jb25zdCBNQVhfU0FGRV9CVUlMRF9MRU5HVEggPSBNQVhfTEVOR1RIIC0gNlxuXG5jb25zdCBSRUxFQVNFX1RZUEVTID0gW1xuICAnbWFqb3InLFxuICAncHJlbWFqb3InLFxuICAnbWlub3InLFxuICAncHJlbWlub3InLFxuICAncGF0Y2gnLFxuICAncHJlcGF0Y2gnLFxuICAncHJlcmVsZWFzZScsXG5dXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBNQVhfTEVOR1RILFxuICBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RILFxuICBNQVhfU0FGRV9CVUlMRF9MRU5HVEgsXG4gIE1BWF9TQUZFX0lOVEVHRVIsXG4gIFJFTEVBU0VfVFlQRVMsXG4gIFNFTVZFUl9TUEVDX1ZFUlNJT04sXG4gIEZMQUdfSU5DTFVERV9QUkVSRUxFQVNFOiAwYjAwMSxcbiAgRkxBR19MT09TRTogMGIwMTAsXG59XG4iLCJjb25zdCBkZWJ1ZyA9IChcbiAgdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmXG4gIHByb2Nlc3MuZW52ICYmXG4gIHByb2Nlc3MuZW52Lk5PREVfREVCVUcgJiZcbiAgL1xcYnNlbXZlclxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRylcbikgPyAoLi4uYXJncykgPT4gY29uc29sZS5lcnJvcignU0VNVkVSJywgLi4uYXJncylcbiAgOiAoKSA9PiB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYnVnXG4iLCJjb25zdCB7XG4gIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEgsXG4gIE1BWF9TQUZFX0JVSUxEX0xFTkdUSCxcbiAgTUFYX0xFTkdUSCxcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4vZGVidWcnKVxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge31cblxuLy8gVGhlIGFjdHVhbCByZWdleHBzIGdvIG9uIGV4cG9ydHMucmVcbmNvbnN0IHJlID0gZXhwb3J0cy5yZSA9IFtdXG5jb25zdCBzYWZlUmUgPSBleHBvcnRzLnNhZmVSZSA9IFtdXG5jb25zdCBzcmMgPSBleHBvcnRzLnNyYyA9IFtdXG5jb25zdCB0ID0gZXhwb3J0cy50ID0ge31cbmxldCBSID0gMFxuXG5jb25zdCBMRVRURVJEQVNITlVNQkVSID0gJ1thLXpBLVowLTktXSdcblxuLy8gUmVwbGFjZSBzb21lIGdyZWVkeSByZWdleCB0b2tlbnMgdG8gcHJldmVudCByZWdleCBkb3MgaXNzdWVzLiBUaGVzZSByZWdleCBhcmVcbi8vIHVzZWQgaW50ZXJuYWxseSB2aWEgdGhlIHNhZmVSZSBvYmplY3Qgc2luY2UgYWxsIGlucHV0cyBpbiB0aGlzIGxpYnJhcnkgZ2V0XG4vLyBub3JtYWxpemVkIGZpcnN0IHRvIHRyaW0gYW5kIGNvbGxhcHNlIGFsbCBleHRyYSB3aGl0ZXNwYWNlLiBUaGUgb3JpZ2luYWxcbi8vIHJlZ2V4ZXMgYXJlIGV4cG9ydGVkIGZvciB1c2VybGFuZCBjb25zdW1wdGlvbiBhbmQgbG93ZXIgbGV2ZWwgdXNhZ2UuIEFcbi8vIGZ1dHVyZSBicmVha2luZyBjaGFuZ2UgY291bGQgZXhwb3J0IHRoZSBzYWZlciByZWdleCBvbmx5IHdpdGggYSBub3RlIHRoYXRcbi8vIGFsbCBpbnB1dCBzaG91bGQgaGF2ZSBleHRyYSB3aGl0ZXNwYWNlIHJlbW92ZWQuXG5jb25zdCBzYWZlUmVnZXhSZXBsYWNlbWVudHMgPSBbXG4gIFsnXFxcXHMnLCAxXSxcbiAgWydcXFxcZCcsIE1BWF9MRU5HVEhdLFxuICBbTEVUVEVSREFTSE5VTUJFUiwgTUFYX1NBRkVfQlVJTERfTEVOR1RIXSxcbl1cblxuY29uc3QgbWFrZVNhZmVSZWdleCA9ICh2YWx1ZSkgPT4ge1xuICBmb3IgKGNvbnN0IFt0b2tlbiwgbWF4XSBvZiBzYWZlUmVnZXhSZXBsYWNlbWVudHMpIHtcbiAgICB2YWx1ZSA9IHZhbHVlXG4gICAgICAuc3BsaXQoYCR7dG9rZW59KmApLmpvaW4oYCR7dG9rZW59ezAsJHttYXh9fWApXG4gICAgICAuc3BsaXQoYCR7dG9rZW59K2ApLmpvaW4oYCR7dG9rZW59ezEsJHttYXh9fWApXG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbmNvbnN0IGNyZWF0ZVRva2VuID0gKG5hbWUsIHZhbHVlLCBpc0dsb2JhbCkgPT4ge1xuICBjb25zdCBzYWZlID0gbWFrZVNhZmVSZWdleCh2YWx1ZSlcbiAgY29uc3QgaW5kZXggPSBSKytcbiAgZGVidWcobmFtZSwgaW5kZXgsIHZhbHVlKVxuICB0W25hbWVdID0gaW5kZXhcbiAgc3JjW2luZGV4XSA9IHZhbHVlXG4gIHJlW2luZGV4XSA9IG5ldyBSZWdFeHAodmFsdWUsIGlzR2xvYmFsID8gJ2cnIDogdW5kZWZpbmVkKVxuICBzYWZlUmVbaW5kZXhdID0gbmV3IFJlZ0V4cChzYWZlLCBpc0dsb2JhbCA/ICdnJyA6IHVuZGVmaW5lZClcbn1cblxuLy8gVGhlIGZvbGxvd2luZyBSZWd1bGFyIEV4cHJlc3Npb25zIGNhbiBiZSB1c2VkIGZvciB0b2tlbml6aW5nLFxuLy8gdmFsaWRhdGluZywgYW5kIHBhcnNpbmcgU2VtVmVyIHZlcnNpb24gc3RyaW5ncy5cblxuLy8gIyMgTnVtZXJpYyBJZGVudGlmaWVyXG4vLyBBIHNpbmdsZSBgMGAsIG9yIGEgbm9uLXplcm8gZGlnaXQgZm9sbG93ZWQgYnkgemVybyBvciBtb3JlIGRpZ2l0cy5cblxuY3JlYXRlVG9rZW4oJ05VTUVSSUNJREVOVElGSUVSJywgJzB8WzEtOV1cXFxcZConKVxuY3JlYXRlVG9rZW4oJ05VTUVSSUNJREVOVElGSUVSTE9PU0UnLCAnXFxcXGQrJylcblxuLy8gIyMgTm9uLW51bWVyaWMgSWRlbnRpZmllclxuLy8gWmVybyBvciBtb3JlIGRpZ2l0cywgZm9sbG93ZWQgYnkgYSBsZXR0ZXIgb3IgaHlwaGVuLCBhbmQgdGhlbiB6ZXJvIG9yXG4vLyBtb3JlIGxldHRlcnMsIGRpZ2l0cywgb3IgaHlwaGVucy5cblxuY3JlYXRlVG9rZW4oJ05PTk5VTUVSSUNJREVOVElGSUVSJywgYFxcXFxkKlthLXpBLVotXSR7TEVUVEVSREFTSE5VTUJFUn0qYClcblxuLy8gIyMgTWFpbiBWZXJzaW9uXG4vLyBUaHJlZSBkb3Qtc2VwYXJhdGVkIG51bWVyaWMgaWRlbnRpZmllcnMuXG5cbmNyZWF0ZVRva2VuKCdNQUlOVkVSU0lPTicsIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlgKVxuXG5jcmVhdGVUb2tlbignTUFJTlZFUlNJT05MT09TRScsIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pYClcblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvbiBJZGVudGlmaWVyXG4vLyBBIG51bWVyaWMgaWRlbnRpZmllciwgb3IgYSBub24tbnVtZXJpYyBpZGVudGlmaWVyLlxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRUlERU5USUZJRVInLCBgKD86JHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl1cbn18JHtzcmNbdC5OT05OVU1FUklDSURFTlRJRklFUl19KWApXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFJywgYCg/OiR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV1cbn18JHtzcmNbdC5OT05OVU1FUklDSURFTlRJRklFUl19KWApXG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb25cbi8vIEh5cGhlbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgZG90LXNlcGFyYXRlZCBwcmUtcmVsZWFzZSB2ZXJzaW9uXG4vLyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0UnLCBgKD86LSgke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSXVxufSg/OlxcXFwuJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUl19KSopKWApXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFTE9PU0UnLCBgKD86LT8oJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXVxufSg/OlxcXFwuJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXX0pKikpYClcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGEgSWRlbnRpZmllclxuLy8gQW55IGNvbWJpbmF0aW9uIG9mIGRpZ2l0cywgbGV0dGVycywgb3IgaHlwaGVucy5cblxuY3JlYXRlVG9rZW4oJ0JVSUxESURFTlRJRklFUicsIGAke0xFVFRFUkRBU0hOVU1CRVJ9K2ApXG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhXG4vLyBQbHVzIHNpZ24sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIHBlcmlvZC1zZXBhcmF0ZWQgYnVpbGQgbWV0YWRhdGFcbi8vIGlkZW50aWZpZXJzLlxuXG5jcmVhdGVUb2tlbignQlVJTEQnLCBgKD86XFxcXCsoJHtzcmNbdC5CVUlMRElERU5USUZJRVJdXG59KD86XFxcXC4ke3NyY1t0LkJVSUxESURFTlRJRklFUl19KSopKWApXG5cbi8vICMjIEZ1bGwgVmVyc2lvbiBTdHJpbmdcbi8vIEEgbWFpbiB2ZXJzaW9uLCBmb2xsb3dlZCBvcHRpb25hbGx5IGJ5IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiBhbmRcbi8vIGJ1aWxkIG1ldGFkYXRhLlxuXG4vLyBOb3RlIHRoYXQgdGhlIG9ubHkgbWFqb3IsIG1pbm9yLCBwYXRjaCwgYW5kIHByZS1yZWxlYXNlIHNlY3Rpb25zIG9mXG4vLyB0aGUgdmVyc2lvbiBzdHJpbmcgYXJlIGNhcHR1cmluZyBncm91cHMuICBUaGUgYnVpbGQgbWV0YWRhdGEgaXMgbm90IGFcbi8vIGNhcHR1cmluZyBncm91cCwgYmVjYXVzZSBpdCBzaG91bGQgbm90IGV2ZXIgYmUgdXNlZCBpbiB2ZXJzaW9uXG4vLyBjb21wYXJpc29uLlxuXG5jcmVhdGVUb2tlbignRlVMTFBMQUlOJywgYHY/JHtzcmNbdC5NQUlOVkVSU0lPTl1cbn0ke3NyY1t0LlBSRVJFTEVBU0VdfT8ke1xuICBzcmNbdC5CVUlMRF19P2ApXG5cbmNyZWF0ZVRva2VuKCdGVUxMJywgYF4ke3NyY1t0LkZVTExQTEFJTl19JGApXG5cbi8vIGxpa2UgZnVsbCwgYnV0IGFsbG93cyB2MS4yLjMgYW5kID0xLjIuMywgd2hpY2ggcGVvcGxlIGRvIHNvbWV0aW1lcy5cbi8vIGFsc28sIDEuMC4wYWxwaGExIChwcmVyZWxlYXNlIHdpdGhvdXQgdGhlIGh5cGhlbikgd2hpY2ggaXMgcHJldHR5XG4vLyBjb21tb24gaW4gdGhlIG5wbSByZWdpc3RyeS5cbmNyZWF0ZVRva2VuKCdMT09TRVBMQUlOJywgYFt2PVxcXFxzXSoke3NyY1t0Lk1BSU5WRVJTSU9OTE9PU0VdXG59JHtzcmNbdC5QUkVSRUxFQVNFTE9PU0VdfT8ke1xuICBzcmNbdC5CVUlMRF19P2ApXG5cbmNyZWF0ZVRva2VuKCdMT09TRScsIGBeJHtzcmNbdC5MT09TRVBMQUlOXX0kYClcblxuY3JlYXRlVG9rZW4oJ0dUTFQnLCAnKCg/Ojx8Pik/PT8pJylcblxuLy8gU29tZXRoaW5nIGxpa2UgXCIyLipcIiBvciBcIjEuMi54XCIuXG4vLyBOb3RlIHRoYXQgXCJ4LnhcIiBpcyBhIHZhbGlkIHhSYW5nZSBpZGVudGlmZXIsIG1lYW5pbmcgXCJhbnkgdmVyc2lvblwiXG4vLyBPbmx5IHRoZSBmaXJzdCBpdGVtIGlzIHN0cmljdGx5IHJlcXVpcmVkLlxuY3JlYXRlVG9rZW4oJ1hSQU5HRUlERU5USUZJRVJMT09TRScsIGAke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfXx4fFh8XFxcXCpgKVxuY3JlYXRlVG9rZW4oJ1hSQU5HRUlERU5USUZJRVInLCBgJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19fHh8WHxcXFxcKmApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0VQTEFJTicsIGBbdj1cXFxcc10qKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJdfSlgICtcbiAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYCg/OiR7c3JjW3QuUFJFUkVMRUFTRV19KT8ke1xuICAgICAgICAgICAgICAgICAgICAgc3JjW3QuQlVJTERdfT9gICtcbiAgICAgICAgICAgICAgICAgICBgKT8pP2ApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0VQTEFJTkxPT1NFJywgYFt2PVxcXFxzXSooJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKD86JHtzcmNbdC5QUkVSRUxFQVNFTE9PU0VdfSk/JHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjW3QuQlVJTERdfT9gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGApPyk/YClcblxuY3JlYXRlVG9rZW4oJ1hSQU5HRScsIGBeJHtzcmNbdC5HVExUXX1cXFxccyoke3NyY1t0LlhSQU5HRVBMQUlOXX0kYClcbmNyZWF0ZVRva2VuKCdYUkFOR0VMT09TRScsIGBeJHtzcmNbdC5HVExUXX1cXFxccyoke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKVxuXG4vLyBDb2VyY2lvbi5cbi8vIEV4dHJhY3QgYW55dGhpbmcgdGhhdCBjb3VsZCBjb25jZWl2YWJseSBiZSBhIHBhcnQgb2YgYSB2YWxpZCBzZW12ZXJcbmNyZWF0ZVRva2VuKCdDT0VSQ0UnLCBgJHsnKF58W15cXFxcZF0pJyArXG4gICAgICAgICAgICAgICcoXFxcXGR7MSwnfSR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KWAgK1xuICAgICAgICAgICAgICBgKD86XFxcXC4oXFxcXGR7MSwke01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEh9fSkpP2AgK1xuICAgICAgICAgICAgICBgKD86XFxcXC4oXFxcXGR7MSwke01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEh9fSkpP2AgK1xuICAgICAgICAgICAgICBgKD86JHxbXlxcXFxkXSlgKVxuY3JlYXRlVG9rZW4oJ0NPRVJDRVJUTCcsIHNyY1t0LkNPRVJDRV0sIHRydWUpXG5cbi8vIFRpbGRlIHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJyZWFzb25hYmx5IGF0IG9yIGdyZWF0ZXIgdGhhblwiXG5jcmVhdGVUb2tlbignTE9ORVRJTERFJywgJyg/On4+PyknKVxuXG5jcmVhdGVUb2tlbignVElMREVUUklNJywgYChcXFxccyopJHtzcmNbdC5MT05FVElMREVdfVxcXFxzK2AsIHRydWUpXG5leHBvcnRzLnRpbGRlVHJpbVJlcGxhY2UgPSAnJDF+J1xuXG5jcmVhdGVUb2tlbignVElMREUnLCBgXiR7c3JjW3QuTE9ORVRJTERFXX0ke3NyY1t0LlhSQU5HRVBMQUlOXX0kYClcbmNyZWF0ZVRva2VuKCdUSUxERUxPT1NFJywgYF4ke3NyY1t0LkxPTkVUSUxERV19JHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQ2FyZXQgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcImF0IGxlYXN0IGFuZCBiYWNrd2FyZHMgY29tcGF0aWJsZSB3aXRoXCJcbmNyZWF0ZVRva2VuKCdMT05FQ0FSRVQnLCAnKD86XFxcXF4pJylcblxuY3JlYXRlVG9rZW4oJ0NBUkVUVFJJTScsIGAoXFxcXHMqKSR7c3JjW3QuTE9ORUNBUkVUXX1cXFxccytgLCB0cnVlKVxuZXhwb3J0cy5jYXJldFRyaW1SZXBsYWNlID0gJyQxXidcblxuY3JlYXRlVG9rZW4oJ0NBUkVUJywgYF4ke3NyY1t0LkxPTkVDQVJFVF19JHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignQ0FSRVRMT09TRScsIGBeJHtzcmNbdC5MT05FQ0FSRVRdfSR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19JGApXG5cbi8vIEEgc2ltcGxlIGd0L2x0L2VxIHRoaW5nLCBvciBqdXN0IFwiXCIgdG8gaW5kaWNhdGUgXCJhbnkgdmVyc2lvblwiXG5jcmVhdGVUb2tlbignQ09NUEFSQVRPUkxPT1NFJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKigke3NyY1t0LkxPT1NFUExBSU5dfSkkfF4kYClcbmNyZWF0ZVRva2VuKCdDT01QQVJBVE9SJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKigke3NyY1t0LkZVTExQTEFJTl19KSR8XiRgKVxuXG4vLyBBbiBleHByZXNzaW9uIHRvIHN0cmlwIGFueSB3aGl0ZXNwYWNlIGJldHdlZW4gdGhlIGd0bHQgYW5kIHRoZSB0aGluZ1xuLy8gaXQgbW9kaWZpZXMsIHNvIHRoYXQgYD4gMS4yLjNgID09PiBgPjEuMi4zYFxuY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1JUUklNJywgYChcXFxccyopJHtzcmNbdC5HVExUXVxufVxcXFxzKigke3NyY1t0LkxPT1NFUExBSU5dfXwke3NyY1t0LlhSQU5HRVBMQUlOXX0pYCwgdHJ1ZSlcbmV4cG9ydHMuY29tcGFyYXRvclRyaW1SZXBsYWNlID0gJyQxJDIkMydcblxuLy8gU29tZXRoaW5nIGxpa2UgYDEuMi4zIC0gMS4yLjRgXG4vLyBOb3RlIHRoYXQgdGhlc2UgYWxsIHVzZSB0aGUgbG9vc2UgZm9ybSwgYmVjYXVzZSB0aGV5J2xsIGJlXG4vLyBjaGVja2VkIGFnYWluc3QgZWl0aGVyIHRoZSBzdHJpY3Qgb3IgbG9vc2UgY29tcGFyYXRvciBmb3JtXG4vLyBsYXRlci5cbmNyZWF0ZVRva2VuKCdIWVBIRU5SQU5HRScsIGBeXFxcXHMqKCR7c3JjW3QuWFJBTkdFUExBSU5dfSlgICtcbiAgICAgICAgICAgICAgICAgICBgXFxcXHMrLVxcXFxzK2AgK1xuICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5YUkFOR0VQTEFJTl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGBcXFxccyokYClcblxuY3JlYXRlVG9rZW4oJ0hZUEhFTlJBTkdFTE9PU0UnLCBgXlxcXFxzKigke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcXFxccystXFxcXHMrYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYFxcXFxzKiRgKVxuXG4vLyBTdGFyIHJhbmdlcyBiYXNpY2FsbHkganVzdCBhbGxvdyBhbnl0aGluZyBhdCBhbGwuXG5jcmVhdGVUb2tlbignU1RBUicsICcoPHw+KT89P1xcXFxzKlxcXFwqJylcbi8vID49MC4wLjAgaXMgbGlrZSBhIHN0YXJcbmNyZWF0ZVRva2VuKCdHVEUwJywgJ15cXFxccyo+PVxcXFxzKjBcXFxcLjBcXFxcLjBcXFxccyokJylcbmNyZWF0ZVRva2VuKCdHVEUwUFJFJywgJ15cXFxccyo+PVxcXFxzKjBcXFxcLjBcXFxcLjAtMFxcXFxzKiQnKVxuIiwiLy8gcGFyc2Ugb3V0IGp1c3QgdGhlIG9wdGlvbnMgd2UgY2FyZSBhYm91dFxuY29uc3QgbG9vc2VPcHRpb24gPSBPYmplY3QuZnJlZXplKHsgbG9vc2U6IHRydWUgfSlcbmNvbnN0IGVtcHR5T3B0cyA9IE9iamVjdC5mcmVlemUoeyB9KVxuY29uc3QgcGFyc2VPcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIHJldHVybiBlbXB0eU9wdHNcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbG9vc2VPcHRpb25cbiAgfVxuXG4gIHJldHVybiBvcHRpb25zXG59XG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlT3B0aW9uc1xuIiwiY29uc3QgbnVtZXJpYyA9IC9eWzAtOV0rJC9cbmNvbnN0IGNvbXBhcmVJZGVudGlmaWVycyA9IChhLCBiKSA9PiB7XG4gIGNvbnN0IGFudW0gPSBudW1lcmljLnRlc3QoYSlcbiAgY29uc3QgYm51bSA9IG51bWVyaWMudGVzdChiKVxuXG4gIGlmIChhbnVtICYmIGJudW0pIHtcbiAgICBhID0gK2FcbiAgICBiID0gK2JcbiAgfVxuXG4gIHJldHVybiBhID09PSBiID8gMFxuICAgIDogKGFudW0gJiYgIWJudW0pID8gLTFcbiAgICA6IChibnVtICYmICFhbnVtKSA/IDFcbiAgICA6IGEgPCBiID8gLTFcbiAgICA6IDFcbn1cblxuY29uc3QgcmNvbXBhcmVJZGVudGlmaWVycyA9IChhLCBiKSA9PiBjb21wYXJlSWRlbnRpZmllcnMoYiwgYSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXBhcmVJZGVudGlmaWVycyxcbiAgcmNvbXBhcmVJZGVudGlmaWVycyxcbn1cbiIsImNvbnN0IGRlYnVnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvZGVidWcnKVxuY29uc3QgeyBNQVhfTEVOR1RILCBNQVhfU0FGRV9JTlRFR0VSIH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9jb25zdGFudHMnKVxuY29uc3QgeyBzYWZlUmU6IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgeyBjb21wYXJlSWRlbnRpZmllcnMgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lkZW50aWZpZXJzJylcbmNsYXNzIFNlbVZlciB7XG4gIGNvbnN0cnVjdG9yICh2ZXJzaW9uLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICAgIGlmICh2ZXJzaW9uLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UgJiZcbiAgICAgICAgICB2ZXJzaW9uLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgICAgcmV0dXJuIHZlcnNpb25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnZlcnNpb25cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCB2ZXJzaW9uLiBNdXN0IGJlIGEgc3RyaW5nLiBHb3QgdHlwZSBcIiR7dHlwZW9mIHZlcnNpb259XCIuYClcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBgdmVyc2lvbiBpcyBsb25nZXIgdGhhbiAke01BWF9MRU5HVEh9IGNoYXJhY3RlcnNgXG4gICAgICApXG4gICAgfVxuXG4gICAgZGVidWcoJ1NlbVZlcicsIHZlcnNpb24sIG9wdGlvbnMpXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgICAvLyB0aGlzIGlzbid0IGFjdHVhbGx5IHJlbGV2YW50IGZvciB2ZXJzaW9ucywgYnV0IGtlZXAgaXQgc28gdGhhdCB3ZVxuICAgIC8vIGRvbid0IHJ1biBpbnRvIHRyb3VibGUgcGFzc2luZyB0aGlzLm9wdGlvbnMgYXJvdW5kLlxuICAgIHRoaXMuaW5jbHVkZVByZXJlbGVhc2UgPSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcblxuICAgIGNvbnN0IG0gPSB2ZXJzaW9uLnRyaW0oKS5tYXRjaChvcHRpb25zLmxvb3NlID8gcmVbdC5MT09TRV0gOiByZVt0LkZVTExdKVxuXG4gICAgaWYgKCFtKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFZlcnNpb246ICR7dmVyc2lvbn1gKVxuICAgIH1cblxuICAgIHRoaXMucmF3ID0gdmVyc2lvblxuXG4gICAgLy8gdGhlc2UgYXJlIGFjdHVhbGx5IG51bWJlcnNcbiAgICB0aGlzLm1ham9yID0gK21bMV1cbiAgICB0aGlzLm1pbm9yID0gK21bMl1cbiAgICB0aGlzLnBhdGNoID0gK21bM11cblxuICAgIGlmICh0aGlzLm1ham9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1ham9yIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWpvciB2ZXJzaW9uJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5taW5vciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5taW5vciA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWlub3IgdmVyc2lvbicpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGF0Y2ggPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMucGF0Y2ggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHBhdGNoIHZlcnNpb24nKVxuICAgIH1cblxuICAgIC8vIG51bWJlcmlmeSBhbnkgcHJlcmVsZWFzZSBudW1lcmljIGlkc1xuICAgIGlmICghbVs0XSkge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gbVs0XS5zcGxpdCgnLicpLm1hcCgoaWQpID0+IHtcbiAgICAgICAgaWYgKC9eWzAtOV0rJC8udGVzdChpZCkpIHtcbiAgICAgICAgICBjb25zdCBudW0gPSAraWRcbiAgICAgICAgICBpZiAobnVtID49IDAgJiYgbnVtIDwgTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgcmV0dXJuIG51bVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5idWlsZCA9IG1bNV0gPyBtWzVdLnNwbGl0KCcuJykgOiBbXVxuICAgIHRoaXMuZm9ybWF0KClcbiAgfVxuXG4gIGZvcm1hdCAoKSB7XG4gICAgdGhpcy52ZXJzaW9uID0gYCR7dGhpcy5tYWpvcn0uJHt0aGlzLm1pbm9yfS4ke3RoaXMucGF0Y2h9YFxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICB0aGlzLnZlcnNpb24gKz0gYC0ke3RoaXMucHJlcmVsZWFzZS5qb2luKCcuJyl9YFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy52ZXJzaW9uXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVyc2lvblxuICB9XG5cbiAgY29tcGFyZSAob3RoZXIpIHtcbiAgICBkZWJ1ZygnU2VtVmVyLmNvbXBhcmUnLCB0aGlzLnZlcnNpb24sIHRoaXMub3B0aW9ucywgb3RoZXIpXG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBpZiAodHlwZW9mIG90aGVyID09PSAnc3RyaW5nJyAmJiBvdGhlciA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICBpZiAob3RoZXIudmVyc2lvbiA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbXBhcmVNYWluKG90aGVyKSB8fCB0aGlzLmNvbXBhcmVQcmUob3RoZXIpXG4gIH1cblxuICBjb21wYXJlTWFpbiAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5tYWpvciwgb3RoZXIubWFqb3IpIHx8XG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5taW5vciwgb3RoZXIubWlub3IpIHx8XG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5wYXRjaCwgb3RoZXIucGF0Y2gpXG4gICAgKVxuICB9XG5cbiAgY29tcGFyZVByZSAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIC8vIE5PVCBoYXZpbmcgYSBwcmVyZWxlYXNlIGlzID4gaGF2aW5nIG9uZVxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfSBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiBvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICBsZXQgaSA9IDBcbiAgICBkbyB7XG4gICAgICBjb25zdCBhID0gdGhpcy5wcmVyZWxlYXNlW2ldXG4gICAgICBjb25zdCBiID0gb3RoZXIucHJlcmVsZWFzZVtpXVxuICAgICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgY29tcGFyZUJ1aWxkIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgbGV0IGkgPSAwXG4gICAgZG8ge1xuICAgICAgY29uc3QgYSA9IHRoaXMuYnVpbGRbaV1cbiAgICAgIGNvbnN0IGIgPSBvdGhlci5idWlsZFtpXVxuICAgICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgLy8gcHJlbWlub3Igd2lsbCBidW1wIHRoZSB2ZXJzaW9uIHVwIHRvIHRoZSBuZXh0IG1pbm9yIHJlbGVhc2UsIGFuZCBpbW1lZGlhdGVseVxuICAvLyBkb3duIHRvIHByZS1yZWxlYXNlLiBwcmVtYWpvciBhbmQgcHJlcGF0Y2ggd29yayB0aGUgc2FtZSB3YXkuXG4gIGluYyAocmVsZWFzZSwgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpIHtcbiAgICBzd2l0Y2ggKHJlbGVhc2UpIHtcbiAgICAgIGNhc2UgJ3ByZW1ham9yJzpcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5taW5vciA9IDBcbiAgICAgICAgdGhpcy5tYWpvcisrXG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3ByZW1pbm9yJzpcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5taW5vcisrXG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3ByZXBhdGNoJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhbHJlYWR5IGEgcHJlcmVsZWFzZSwgaXQgd2lsbCBidW1wIHRvIHRoZSBuZXh0IHZlcnNpb25cbiAgICAgICAgLy8gZHJvcCBhbnkgcHJlcmVsZWFzZXMgdGhhdCBtaWdodCBhbHJlYWR5IGV4aXN0LCBzaW5jZSB0aGV5IGFyZSBub3RcbiAgICAgICAgLy8gcmVsZXZhbnQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSlcbiAgICAgICAgYnJlYWtcbiAgICAgIC8vIElmIHRoZSBpbnB1dCBpcyBhIG5vbi1wcmVyZWxlYXNlIHZlcnNpb24sIHRoaXMgYWN0cyB0aGUgc2FtZSBhc1xuICAgICAgLy8gcHJlcGF0Y2guXG4gICAgICBjYXNlICdwcmVyZWxlYXNlJzpcbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSlcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ21ham9yJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1tYWpvciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1ham9yIHZlcnNpb24uXG4gICAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWFqb3IuXG4gICAgICAgIC8vIDEuMC4wLTUgYnVtcHMgdG8gMS4wLjBcbiAgICAgICAgLy8gMS4xLjAgYnVtcHMgdG8gMi4wLjBcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMubWlub3IgIT09IDAgfHxcbiAgICAgICAgICB0aGlzLnBhdGNoICE9PSAwIHx8XG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLm1ham9yKytcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1pbm9yID0gMFxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnbWlub3InOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1pbm9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWlub3IgdmVyc2lvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtaW5vci5cbiAgICAgICAgLy8gMS4yLjAtNSBidW1wcyB0byAxLjIuMFxuICAgICAgICAvLyAxLjIuMSBidW1wcyB0byAxLjMuMFxuICAgICAgICBpZiAodGhpcy5wYXRjaCAhPT0gMCB8fCB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5taW5vcisrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3BhdGNoJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uLCBpdCB3aWxsIGluY3JlbWVudCB0aGUgcGF0Y2guXG4gICAgICAgIC8vIElmIGl0IGlzIGEgcHJlLXJlbGVhc2UgaXQgd2lsbCBidW1wIHVwIHRvIHRoZSBzYW1lIHBhdGNoIHZlcnNpb24uXG4gICAgICAgIC8vIDEuMi4wLTUgcGF0Y2hlcyB0byAxLjIuMFxuICAgICAgICAvLyAxLjIuMCBwYXRjaGVzIHRvIDEuMi4xXG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5wYXRjaCsrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIC8vIFRoaXMgcHJvYmFibHkgc2hvdWxkbid0IGJlIHVzZWQgcHVibGljbHkuXG4gICAgICAvLyAxLjAuMCAncHJlJyB3b3VsZCBiZWNvbWUgMS4wLjAtMCB3aGljaCBpcyB0aGUgd3JvbmcgZGlyZWN0aW9uLlxuICAgICAgY2FzZSAncHJlJzoge1xuICAgICAgICBjb25zdCBiYXNlID0gTnVtYmVyKGlkZW50aWZpZXJCYXNlKSA/IDEgOiAwXG5cbiAgICAgICAgaWYgKCFpZGVudGlmaWVyICYmIGlkZW50aWZpZXJCYXNlID09PSBmYWxzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6IGlkZW50aWZpZXIgaXMgZW1wdHknKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbYmFzZV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgaSA9IHRoaXMucHJlcmVsZWFzZS5sZW5ndGhcbiAgICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcmVyZWxlYXNlW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2VbaV0rK1xuICAgICAgICAgICAgICBpID0gLTJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBkaWRuJ3QgaW5jcmVtZW50IGFueXRoaW5nXG4gICAgICAgICAgICBpZiAoaWRlbnRpZmllciA9PT0gdGhpcy5wcmVyZWxlYXNlLmpvaW4oJy4nKSAmJiBpZGVudGlmaWVyQmFzZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluY3JlbWVudCBhcmd1bWVudDogaWRlbnRpZmllciBhbHJlYWR5IGV4aXN0cycpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UucHVzaChiYXNlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgICAgIC8vIDEuMi4wLWJldGEuMSBidW1wcyB0byAxLjIuMC1iZXRhLjIsXG4gICAgICAgICAgLy8gMS4yLjAtYmV0YS5mb29ibHogb3IgMS4yLjAtYmV0YSBidW1wcyB0byAxLjIuMC1iZXRhLjBcbiAgICAgICAgICBsZXQgcHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCBiYXNlXVxuICAgICAgICAgIGlmIChpZGVudGlmaWVyQmFzZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHByZXJlbGVhc2UgPSBbaWRlbnRpZmllcl1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLnByZXJlbGVhc2VbMF0sIGlkZW50aWZpZXIpID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4odGhpcy5wcmVyZWxlYXNlWzFdKSkge1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBwcmVyZWxlYXNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IHByZXJlbGVhc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6ICR7cmVsZWFzZX1gKVxuICAgIH1cbiAgICB0aGlzLnJhdyA9IHRoaXMuZm9ybWF0KClcbiAgICBpZiAodGhpcy5idWlsZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmF3ICs9IGArJHt0aGlzLmJ1aWxkLmpvaW4oJy4nKX1gXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZW1WZXJcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IHBhcnNlID0gKHZlcnNpb24sIG9wdGlvbnMsIHRocm93RXJyb3JzID0gZmFsc2UpID0+IHtcbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICByZXR1cm4gdmVyc2lvblxuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAoIXRocm93RXJyb3JzKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICB0aHJvdyBlclxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VcbiIsImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCB2YWxpZCA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHYgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKVxuICByZXR1cm4gdiA/IHYudmVyc2lvbiA6IG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRcbiIsImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCBjbGVhbiA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHMgPSBwYXJzZSh2ZXJzaW9uLnRyaW0oKS5yZXBsYWNlKC9eWz12XSsvLCAnJyksIG9wdGlvbnMpXG4gIHJldHVybiBzID8gcy52ZXJzaW9uIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBjbGVhblxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuXG5jb25zdCBpbmMgPSAodmVyc2lvbiwgcmVsZWFzZSwgb3B0aW9ucywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpID0+IHtcbiAgaWYgKHR5cGVvZiAob3B0aW9ucykgPT09ICdzdHJpbmcnKSB7XG4gICAgaWRlbnRpZmllckJhc2UgPSBpZGVudGlmaWVyXG4gICAgaWRlbnRpZmllciA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKFxuICAgICAgdmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlciA/IHZlcnNpb24udmVyc2lvbiA6IHZlcnNpb24sXG4gICAgICBvcHRpb25zXG4gICAgKS5pbmMocmVsZWFzZSwgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpLnZlcnNpb25cbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluY1xuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlLmpzJylcblxuY29uc3QgZGlmZiA9ICh2ZXJzaW9uMSwgdmVyc2lvbjIpID0+IHtcbiAgY29uc3QgdjEgPSBwYXJzZSh2ZXJzaW9uMSwgbnVsbCwgdHJ1ZSlcbiAgY29uc3QgdjIgPSBwYXJzZSh2ZXJzaW9uMiwgbnVsbCwgdHJ1ZSlcbiAgY29uc3QgY29tcGFyaXNvbiA9IHYxLmNvbXBhcmUodjIpXG5cbiAgaWYgKGNvbXBhcmlzb24gPT09IDApIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgdjFIaWdoZXIgPSBjb21wYXJpc29uID4gMFxuICBjb25zdCBoaWdoVmVyc2lvbiA9IHYxSGlnaGVyID8gdjEgOiB2MlxuICBjb25zdCBsb3dWZXJzaW9uID0gdjFIaWdoZXIgPyB2MiA6IHYxXG4gIGNvbnN0IGhpZ2hIYXNQcmUgPSAhIWhpZ2hWZXJzaW9uLnByZXJlbGVhc2UubGVuZ3RoXG4gIGNvbnN0IGxvd0hhc1ByZSA9ICEhbG93VmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aFxuXG4gIGlmIChsb3dIYXNQcmUgJiYgIWhpZ2hIYXNQcmUpIHtcbiAgICAvLyBHb2luZyBmcm9tIHByZXJlbGVhc2UgLT4gbm8gcHJlcmVsZWFzZSByZXF1aXJlcyBzb21lIHNwZWNpYWwgY2FzaW5nXG5cbiAgICAvLyBJZiB0aGUgbG93IHZlcnNpb24gaGFzIG9ubHkgYSBtYWpvciwgdGhlbiBpdCB3aWxsIGFsd2F5cyBiZSBhIG1ham9yXG4gICAgLy8gU29tZSBleGFtcGxlczpcbiAgICAvLyAxLjAuMC0xIC0+IDEuMC4wXG4gICAgLy8gMS4wLjAtMSAtPiAxLjEuMVxuICAgIC8vIDEuMC4wLTEgLT4gMi4wLjBcbiAgICBpZiAoIWxvd1ZlcnNpb24ucGF0Y2ggJiYgIWxvd1ZlcnNpb24ubWlub3IpIHtcbiAgICAgIHJldHVybiAnbWFqb3InXG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlIGl0IGNhbiBiZSBkZXRlcm1pbmVkIGJ5IGNoZWNraW5nIHRoZSBoaWdoIHZlcnNpb25cblxuICAgIGlmIChoaWdoVmVyc2lvbi5wYXRjaCkge1xuICAgICAgLy8gYW55dGhpbmcgaGlnaGVyIHRoYW4gYSBwYXRjaCBidW1wIHdvdWxkIHJlc3VsdCBpbiB0aGUgd3JvbmcgdmVyc2lvblxuICAgICAgcmV0dXJuICdwYXRjaCdcbiAgICB9XG5cbiAgICBpZiAoaGlnaFZlcnNpb24ubWlub3IpIHtcbiAgICAgIC8vIGFueXRoaW5nIGhpZ2hlciB0aGFuIGEgbWlub3IgYnVtcCB3b3VsZCByZXN1bHQgaW4gdGhlIHdyb25nIHZlcnNpb25cbiAgICAgIHJldHVybiAnbWlub3InXG4gICAgfVxuXG4gICAgLy8gYnVtcGluZyBtYWpvci9taW5vci9wYXRjaCBhbGwgaGF2ZSBzYW1lIHJlc3VsdFxuICAgIHJldHVybiAnbWFqb3InXG4gIH1cblxuICAvLyBhZGQgdGhlIGBwcmVgIHByZWZpeCBpZiB3ZSBhcmUgZ29pbmcgdG8gYSBwcmVyZWxlYXNlIHZlcnNpb25cbiAgY29uc3QgcHJlZml4ID0gaGlnaEhhc1ByZSA/ICdwcmUnIDogJydcblxuICBpZiAodjEubWFqb3IgIT09IHYyLm1ham9yKSB7XG4gICAgcmV0dXJuIHByZWZpeCArICdtYWpvcidcbiAgfVxuXG4gIGlmICh2MS5taW5vciAhPT0gdjIubWlub3IpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgJ21pbm9yJ1xuICB9XG5cbiAgaWYgKHYxLnBhdGNoICE9PSB2Mi5wYXRjaCkge1xuICAgIHJldHVybiBwcmVmaXggKyAncGF0Y2gnXG4gIH1cblxuICAvLyBoaWdoIGFuZCBsb3cgYXJlIHByZWxlYXNlc1xuICByZXR1cm4gJ3ByZXJlbGVhc2UnXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGlmZlxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgbWFqb3IgPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1ham9yXG5tb2R1bGUuZXhwb3J0cyA9IG1ham9yXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBtaW5vciA9IChhLCBsb29zZSkgPT4gbmV3IFNlbVZlcihhLCBsb29zZSkubWlub3Jcbm1vZHVsZS5leHBvcnRzID0gbWlub3JcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IHBhdGNoID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5wYXRjaFxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaFxuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHByZXJlbGVhc2UgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBwYXJzZWQgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKVxuICByZXR1cm4gKHBhcnNlZCAmJiBwYXJzZWQucHJlcmVsZWFzZS5sZW5ndGgpID8gcGFyc2VkLnByZXJlbGVhc2UgOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IHByZXJlbGVhc2VcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IGNvbXBhcmUgPSAoYSwgYiwgbG9vc2UpID0+XG4gIG5ldyBTZW1WZXIoYSwgbG9vc2UpLmNvbXBhcmUobmV3IFNlbVZlcihiLCBsb29zZSkpXG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZVxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCByY29tcGFyZSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShiLCBhLCBsb29zZSlcbm1vZHVsZS5leHBvcnRzID0gcmNvbXBhcmVcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgY29tcGFyZUxvb3NlID0gKGEsIGIpID0+IGNvbXBhcmUoYSwgYiwgdHJ1ZSlcbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZUxvb3NlXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBjb21wYXJlQnVpbGQgPSAoYSwgYiwgbG9vc2UpID0+IHtcbiAgY29uc3QgdmVyc2lvbkEgPSBuZXcgU2VtVmVyKGEsIGxvb3NlKVxuICBjb25zdCB2ZXJzaW9uQiA9IG5ldyBTZW1WZXIoYiwgbG9vc2UpXG4gIHJldHVybiB2ZXJzaW9uQS5jb21wYXJlKHZlcnNpb25CKSB8fCB2ZXJzaW9uQS5jb21wYXJlQnVpbGQodmVyc2lvbkIpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVCdWlsZFxuIiwiY29uc3QgY29tcGFyZUJ1aWxkID0gcmVxdWlyZSgnLi9jb21wYXJlLWJ1aWxkJylcbmNvbnN0IHNvcnQgPSAobGlzdCwgbG9vc2UpID0+IGxpc3Quc29ydCgoYSwgYikgPT4gY29tcGFyZUJ1aWxkKGEsIGIsIGxvb3NlKSlcbm1vZHVsZS5leHBvcnRzID0gc29ydFxuIiwiY29uc3QgY29tcGFyZUJ1aWxkID0gcmVxdWlyZSgnLi9jb21wYXJlLWJ1aWxkJylcbmNvbnN0IHJzb3J0ID0gKGxpc3QsIGxvb3NlKSA9PiBsaXN0LnNvcnQoKGEsIGIpID0+IGNvbXBhcmVCdWlsZChiLCBhLCBsb29zZSkpXG5tb2R1bGUuZXhwb3J0cyA9IHJzb3J0XG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGd0ID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+IDBcbm1vZHVsZS5leHBvcnRzID0gZ3RcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbHQgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpIDwgMFxubW9kdWxlLmV4cG9ydHMgPSBsdFxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBlcSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPT09IDBcbm1vZHVsZS5leHBvcnRzID0gZXFcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbmVxID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSAhPT0gMFxubW9kdWxlLmV4cG9ydHMgPSBuZXFcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZ3RlID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGd0ZVxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBsdGUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpIDw9IDBcbm1vZHVsZS5leHBvcnRzID0gbHRlXG4iLCJjb25zdCBlcSA9IHJlcXVpcmUoJy4vZXEnKVxuY29uc3QgbmVxID0gcmVxdWlyZSgnLi9uZXEnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuL2d0JylcbmNvbnN0IGd0ZSA9IHJlcXVpcmUoJy4vZ3RlJylcbmNvbnN0IGx0ID0gcmVxdWlyZSgnLi9sdCcpXG5jb25zdCBsdGUgPSByZXF1aXJlKCcuL2x0ZScpXG5cbmNvbnN0IGNtcCA9IChhLCBvcCwgYiwgbG9vc2UpID0+IHtcbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgJz09PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGEgPSBhLnZlcnNpb25cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYiA9IGIudmVyc2lvblxuICAgICAgfVxuICAgICAgcmV0dXJuIGEgPT09IGJcblxuICAgIGNhc2UgJyE9PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGEgPSBhLnZlcnNpb25cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYiA9IGIudmVyc2lvblxuICAgICAgfVxuICAgICAgcmV0dXJuIGEgIT09IGJcblxuICAgIGNhc2UgJyc6XG4gICAgY2FzZSAnPSc6XG4gICAgY2FzZSAnPT0nOlxuICAgICAgcmV0dXJuIGVxKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnIT0nOlxuICAgICAgcmV0dXJuIG5lcShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJz4nOlxuICAgICAgcmV0dXJuIGd0KGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPj0nOlxuICAgICAgcmV0dXJuIGd0ZShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJzwnOlxuICAgICAgcmV0dXJuIGx0KGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPD0nOlxuICAgICAgcmV0dXJuIGx0ZShhLCBiLCBsb29zZSlcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIG9wZXJhdG9yOiAke29wfWApXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gY21wXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgeyBzYWZlUmU6IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IGNvZXJjZSA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgcmV0dXJuIHZlcnNpb25cbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ251bWJlcicpIHtcbiAgICB2ZXJzaW9uID0gU3RyaW5nKHZlcnNpb24pXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgbGV0IG1hdGNoID0gbnVsbFxuICBpZiAoIW9wdGlvbnMucnRsKSB7XG4gICAgbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKHJlW3QuQ09FUkNFXSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5kIHRoZSByaWdodC1tb3N0IGNvZXJjaWJsZSBzdHJpbmcgdGhhdCBkb2VzIG5vdCBzaGFyZVxuICAgIC8vIGEgdGVybWludXMgd2l0aCBhIG1vcmUgbGVmdC13YXJkIGNvZXJjaWJsZSBzdHJpbmcuXG4gICAgLy8gRWcsICcxLjIuMy40JyB3YW50cyB0byBjb2VyY2UgJzIuMy40Jywgbm90ICczLjQnIG9yICc0J1xuICAgIC8vXG4gICAgLy8gV2FsayB0aHJvdWdoIHRoZSBzdHJpbmcgY2hlY2tpbmcgd2l0aCBhIC9nIHJlZ2V4cFxuICAgIC8vIE1hbnVhbGx5IHNldCB0aGUgaW5kZXggc28gYXMgdG8gcGljayB1cCBvdmVybGFwcGluZyBtYXRjaGVzLlxuICAgIC8vIFN0b3Agd2hlbiB3ZSBnZXQgYSBtYXRjaCB0aGF0IGVuZHMgYXQgdGhlIHN0cmluZyBlbmQsIHNpbmNlIG5vXG4gICAgLy8gY29lcmNpYmxlIHN0cmluZyBjYW4gYmUgbW9yZSByaWdodC13YXJkIHdpdGhvdXQgdGhlIHNhbWUgdGVybWludXMuXG4gICAgbGV0IG5leHRcbiAgICB3aGlsZSAoKG5leHQgPSByZVt0LkNPRVJDRVJUTF0uZXhlYyh2ZXJzaW9uKSkgJiZcbiAgICAgICAgKCFtYXRjaCB8fCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCAhPT0gdmVyc2lvbi5sZW5ndGgpXG4gICAgKSB7XG4gICAgICBpZiAoIW1hdGNoIHx8XG4gICAgICAgICAgICBuZXh0LmluZGV4ICsgbmV4dFswXS5sZW5ndGggIT09IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSB7XG4gICAgICAgIG1hdGNoID0gbmV4dFxuICAgICAgfVxuICAgICAgcmVbdC5DT0VSQ0VSVExdLmxhc3RJbmRleCA9IG5leHQuaW5kZXggKyBuZXh0WzFdLmxlbmd0aCArIG5leHRbMl0ubGVuZ3RoXG4gICAgfVxuICAgIC8vIGxlYXZlIGl0IGluIGEgY2xlYW4gc3RhdGVcbiAgICByZVt0LkNPRVJDRVJUTF0ubGFzdEluZGV4ID0gLTFcbiAgfVxuXG4gIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4gcGFyc2UoYCR7bWF0Y2hbMl19LiR7bWF0Y2hbM10gfHwgJzAnfS4ke21hdGNoWzRdIHx8ICcwJ31gLCBvcHRpb25zKVxufVxubW9kdWxlLmV4cG9ydHMgPSBjb2VyY2VcbiIsIid1c2Ugc3RyaWN0J1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoWWFsbGlzdCkge1xuICBZYWxsaXN0LnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24qICgpIHtcbiAgICBmb3IgKGxldCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlcjsgd2Fsa2VyID0gd2Fsa2VyLm5leHQpIHtcbiAgICAgIHlpZWxkIHdhbGtlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IFlhbGxpc3RcblxuWWFsbGlzdC5Ob2RlID0gTm9kZVxuWWFsbGlzdC5jcmVhdGUgPSBZYWxsaXN0XG5cbmZ1bmN0aW9uIFlhbGxpc3QgKGxpc3QpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghKHNlbGYgaW5zdGFuY2VvZiBZYWxsaXN0KSkge1xuICAgIHNlbGYgPSBuZXcgWWFsbGlzdCgpXG4gIH1cblxuICBzZWxmLnRhaWwgPSBudWxsXG4gIHNlbGYuaGVhZCA9IG51bGxcbiAgc2VsZi5sZW5ndGggPSAwXG5cbiAgaWYgKGxpc3QgJiYgdHlwZW9mIGxpc3QuZm9yRWFjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgc2VsZi5wdXNoKGl0ZW0pXG4gICAgfSlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgc2VsZi5wdXNoKGFyZ3VtZW50c1tpXSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VsZlxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZW1vdmVOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUubGlzdCAhPT0gdGhpcykge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVtb3Zpbmcgbm9kZSB3aGljaCBkb2VzIG5vdCBiZWxvbmcgdG8gdGhpcyBsaXN0JylcbiAgfVxuXG4gIHZhciBuZXh0ID0gbm9kZS5uZXh0XG4gIHZhciBwcmV2ID0gbm9kZS5wcmV2XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0LnByZXYgPSBwcmV2XG4gIH1cblxuICBpZiAocHJldikge1xuICAgIHByZXYubmV4dCA9IG5leHRcbiAgfVxuXG4gIGlmIChub2RlID09PSB0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQgPSBuZXh0XG4gIH1cbiAgaWYgKG5vZGUgPT09IHRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbCA9IHByZXZcbiAgfVxuXG4gIG5vZGUubGlzdC5sZW5ndGgtLVxuICBub2RlLm5leHQgPSBudWxsXG4gIG5vZGUucHJldiA9IG51bGxcbiAgbm9kZS5saXN0ID0gbnVsbFxuXG4gIHJldHVybiBuZXh0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnVuc2hpZnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKG5vZGUubGlzdCkge1xuICAgIG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpXG4gIH1cblxuICB2YXIgaGVhZCA9IHRoaXMuaGVhZFxuICBub2RlLmxpc3QgPSB0aGlzXG4gIG5vZGUubmV4dCA9IGhlYWRcbiAgaWYgKGhlYWQpIHtcbiAgICBoZWFkLnByZXYgPSBub2RlXG4gIH1cblxuICB0aGlzLmhlYWQgPSBub2RlXG4gIGlmICghdGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsID0gbm9kZVxuICB9XG4gIHRoaXMubGVuZ3RoKytcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucHVzaE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAobm9kZS5saXN0KSB7XG4gICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSlcbiAgfVxuXG4gIHZhciB0YWlsID0gdGhpcy50YWlsXG4gIG5vZGUubGlzdCA9IHRoaXNcbiAgbm9kZS5wcmV2ID0gdGFpbFxuICBpZiAodGFpbCkge1xuICAgIHRhaWwubmV4dCA9IG5vZGVcbiAgfVxuXG4gIHRoaXMudGFpbCA9IG5vZGVcbiAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQgPSBub2RlXG4gIH1cbiAgdGhpcy5sZW5ndGgrK1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBwdXNoKHRoaXMsIGFyZ3VtZW50c1tpXSlcbiAgfVxuICByZXR1cm4gdGhpcy5sZW5ndGhcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdW5zaGlmdCh0aGlzLCBhcmd1bWVudHNbaV0pXG4gIH1cbiAgcmV0dXJuIHRoaXMubGVuZ3RoXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICB2YXIgcmVzID0gdGhpcy50YWlsLnZhbHVlXG4gIHRoaXMudGFpbCA9IHRoaXMudGFpbC5wcmV2XG4gIGlmICh0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwubmV4dCA9IG51bGxcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhlYWQgPSBudWxsXG4gIH1cbiAgdGhpcy5sZW5ndGgtLVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHZhciByZXMgPSB0aGlzLmhlYWQudmFsdWVcbiAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHRcbiAgaWYgKHRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZC5wcmV2ID0gbnVsbFxuICB9IGVsc2Uge1xuICAgIHRoaXMudGFpbCA9IG51bGxcbiAgfVxuICB0aGlzLmxlbmd0aC0tXG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMuaGVhZCwgaSA9IDA7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCBpLCB0aGlzKVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZm9yRWFjaFJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWwsIGkgPSB0aGlzLmxlbmd0aCAtIDE7IHdhbGtlciAhPT0gbnVsbDsgaS0tKSB7XG4gICAgZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCBpLCB0aGlzKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG4pIHtcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBuOyBpKyspIHtcbiAgICAvLyBhYm9ydCBvdXQgb2YgdGhlIGxpc3QgZWFybHkgaWYgd2UgaGl0IGEgY3ljbGVcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIGlmIChpID09PSBuICYmIHdhbGtlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB3YWxrZXIudmFsdWVcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5nZXRSZXZlcnNlID0gZnVuY3Rpb24gKG4pIHtcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBuOyBpKyspIHtcbiAgICAvLyBhYm9ydCBvdXQgb2YgdGhlIGxpc3QgZWFybHkgaWYgd2UgaGl0IGEgY3ljbGVcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIGlmIChpID09PSBuICYmIHdhbGtlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB3YWxrZXIudmFsdWVcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QoKVxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5tYXBSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgdmFyIHJlcyA9IG5ldyBZYWxsaXN0KClcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgcmVzLnB1c2goZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCB0aGlzKSlcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsKSB7XG4gIHZhciBhY2NcbiAgdmFyIHdhbGtlciA9IHRoaXMuaGVhZFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsXG4gIH0gZWxzZSBpZiAodGhpcy5oZWFkKSB7XG4gICAgd2Fsa2VyID0gdGhpcy5oZWFkLm5leHRcbiAgICBhY2MgPSB0aGlzLmhlYWQudmFsdWVcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYWNjID0gZm4oYWNjLCB3YWxrZXIudmFsdWUsIGkpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuXG4gIHJldHVybiBhY2Ncbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVkdWNlUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgaW5pdGlhbCkge1xuICB2YXIgYWNjXG4gIHZhciB3YWxrZXIgPSB0aGlzLnRhaWxcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgYWNjID0gaW5pdGlhbFxuICB9IGVsc2UgaWYgKHRoaXMudGFpbCkge1xuICAgIHdhbGtlciA9IHRoaXMudGFpbC5wcmV2XG4gICAgYWNjID0gdGhpcy50YWlsLnZhbHVlXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGxpc3Qgd2l0aCBubyBpbml0aWFsIHZhbHVlJylcbiAgfVxuXG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IHdhbGtlciAhPT0gbnVsbDsgaS0tKSB7XG4gICAgYWNjID0gZm4oYWNjLCB3YWxrZXIudmFsdWUsIGkpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuXG4gIHJldHVybiBhY2Ncbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhcnJbaV0gPSB3YWxrZXIudmFsdWVcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIHJldHVybiBhcnJcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudG9BcnJheVJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYXJyW2ldID0gd2Fsa2VyLnZhbHVlXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuICByZXR1cm4gYXJyXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gIHRvID0gdG8gfHwgdGhpcy5sZW5ndGhcbiAgaWYgKHRvIDwgMCkge1xuICAgIHRvICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZnJvbSA9IGZyb20gfHwgMFxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgdmFyIHJldCA9IG5ldyBZYWxsaXN0KClcbiAgaWYgKHRvIDwgZnJvbSB8fCB0byA8IDApIHtcbiAgICByZXR1cm4gcmV0XG4gIH1cbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSA9IDBcbiAgfVxuICBpZiAodG8gPiB0aGlzLmxlbmd0aCkge1xuICAgIHRvID0gdGhpcy5sZW5ndGhcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IGZyb207IGkrKykge1xuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgZm9yICg7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgdG87IGkrKywgd2Fsa2VyID0gd2Fsa2VyLm5leHQpIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5zbGljZVJldmVyc2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aFxuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICBmcm9tID0gZnJvbSB8fCAwXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKVxuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXRcbiAgfVxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tID0gMFxuICB9XG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGwgJiYgaSA+IHRvOyBpLS0pIHtcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIGZvciAoOyB3YWxrZXIgIT09IG51bGwgJiYgaSA+IGZyb207IGktLSwgd2Fsa2VyID0gd2Fsa2VyLnByZXYpIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5zcGxpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGRlbGV0ZUNvdW50LCAuLi5ub2Rlcykge1xuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGggLSAxXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGggKyBzdGFydDtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgc3RhcnQ7IGkrKykge1xuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cblxuICB2YXIgcmV0ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IHdhbGtlciAmJiBpIDwgZGVsZXRlQ291bnQ7IGkrKykge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgICB3YWxrZXIgPSB0aGlzLnJlbW92ZU5vZGUod2Fsa2VyKVxuICB9XG4gIGlmICh3YWxrZXIgPT09IG51bGwpIHtcbiAgICB3YWxrZXIgPSB0aGlzLnRhaWxcbiAgfVxuXG4gIGlmICh3YWxrZXIgIT09IHRoaXMuaGVhZCAmJiB3YWxrZXIgIT09IHRoaXMudGFpbCkge1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgd2Fsa2VyID0gaW5zZXJ0KHRoaXMsIHdhbGtlciwgbm9kZXNbaV0pXG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhlYWQgPSB0aGlzLmhlYWRcbiAgdmFyIHRhaWwgPSB0aGlzLnRhaWxcbiAgZm9yICh2YXIgd2Fsa2VyID0gaGVhZDsgd2Fsa2VyICE9PSBudWxsOyB3YWxrZXIgPSB3YWxrZXIucHJldikge1xuICAgIHZhciBwID0gd2Fsa2VyLnByZXZcbiAgICB3YWxrZXIucHJldiA9IHdhbGtlci5uZXh0XG4gICAgd2Fsa2VyLm5leHQgPSBwXG4gIH1cbiAgdGhpcy5oZWFkID0gdGFpbFxuICB0aGlzLnRhaWwgPSBoZWFkXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIGluc2VydCAoc2VsZiwgbm9kZSwgdmFsdWUpIHtcbiAgdmFyIGluc2VydGVkID0gbm9kZSA9PT0gc2VsZi5oZWFkID9cbiAgICBuZXcgTm9kZSh2YWx1ZSwgbnVsbCwgbm9kZSwgc2VsZikgOlxuICAgIG5ldyBOb2RlKHZhbHVlLCBub2RlLCBub2RlLm5leHQsIHNlbGYpXG5cbiAgaWYgKGluc2VydGVkLm5leHQgPT09IG51bGwpIHtcbiAgICBzZWxmLnRhaWwgPSBpbnNlcnRlZFxuICB9XG4gIGlmIChpbnNlcnRlZC5wcmV2ID09PSBudWxsKSB7XG4gICAgc2VsZi5oZWFkID0gaW5zZXJ0ZWRcbiAgfVxuXG4gIHNlbGYubGVuZ3RoKytcblxuICByZXR1cm4gaW5zZXJ0ZWRcbn1cblxuZnVuY3Rpb24gcHVzaCAoc2VsZiwgaXRlbSkge1xuICBzZWxmLnRhaWwgPSBuZXcgTm9kZShpdGVtLCBzZWxmLnRhaWwsIG51bGwsIHNlbGYpXG4gIGlmICghc2VsZi5oZWFkKSB7XG4gICAgc2VsZi5oZWFkID0gc2VsZi50YWlsXG4gIH1cbiAgc2VsZi5sZW5ndGgrK1xufVxuXG5mdW5jdGlvbiB1bnNoaWZ0IChzZWxmLCBpdGVtKSB7XG4gIHNlbGYuaGVhZCA9IG5ldyBOb2RlKGl0ZW0sIG51bGwsIHNlbGYuaGVhZCwgc2VsZilcbiAgaWYgKCFzZWxmLnRhaWwpIHtcbiAgICBzZWxmLnRhaWwgPSBzZWxmLmhlYWRcbiAgfVxuICBzZWxmLmxlbmd0aCsrXG59XG5cbmZ1bmN0aW9uIE5vZGUgKHZhbHVlLCBwcmV2LCBuZXh0LCBsaXN0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBOb2RlKSkge1xuICAgIHJldHVybiBuZXcgTm9kZSh2YWx1ZSwgcHJldiwgbmV4dCwgbGlzdClcbiAgfVxuXG4gIHRoaXMubGlzdCA9IGxpc3RcbiAgdGhpcy52YWx1ZSA9IHZhbHVlXG5cbiAgaWYgKHByZXYpIHtcbiAgICBwcmV2Lm5leHQgPSB0aGlzXG4gICAgdGhpcy5wcmV2ID0gcHJldlxuICB9IGVsc2Uge1xuICAgIHRoaXMucHJldiA9IG51bGxcbiAgfVxuXG4gIGlmIChuZXh0KSB7XG4gICAgbmV4dC5wcmV2ID0gdGhpc1xuICAgIHRoaXMubmV4dCA9IG5leHRcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5leHQgPSBudWxsXG4gIH1cbn1cblxudHJ5IHtcbiAgLy8gYWRkIGlmIHN1cHBvcnQgZm9yIFN5bWJvbC5pdGVyYXRvciBpcyBwcmVzZW50XG4gIHJlcXVpcmUoJy4vaXRlcmF0b3IuanMnKShZYWxsaXN0KVxufSBjYXRjaCAoZXIpIHt9XG4iLCIndXNlIHN0cmljdCdcblxuLy8gQSBsaW5rZWQgbGlzdCB0byBrZWVwIHRyYWNrIG9mIHJlY2VudGx5LXVzZWQtbmVzc1xuY29uc3QgWWFsbGlzdCA9IHJlcXVpcmUoJ3lhbGxpc3QnKVxuXG5jb25zdCBNQVggPSBTeW1ib2woJ21heCcpXG5jb25zdCBMRU5HVEggPSBTeW1ib2woJ2xlbmd0aCcpXG5jb25zdCBMRU5HVEhfQ0FMQ1VMQVRPUiA9IFN5bWJvbCgnbGVuZ3RoQ2FsY3VsYXRvcicpXG5jb25zdCBBTExPV19TVEFMRSA9IFN5bWJvbCgnYWxsb3dTdGFsZScpXG5jb25zdCBNQVhfQUdFID0gU3ltYm9sKCdtYXhBZ2UnKVxuY29uc3QgRElTUE9TRSA9IFN5bWJvbCgnZGlzcG9zZScpXG5jb25zdCBOT19ESVNQT1NFX09OX1NFVCA9IFN5bWJvbCgnbm9EaXNwb3NlT25TZXQnKVxuY29uc3QgTFJVX0xJU1QgPSBTeW1ib2woJ2xydUxpc3QnKVxuY29uc3QgQ0FDSEUgPSBTeW1ib2woJ2NhY2hlJylcbmNvbnN0IFVQREFURV9BR0VfT05fR0VUID0gU3ltYm9sKCd1cGRhdGVBZ2VPbkdldCcpXG5cbmNvbnN0IG5haXZlTGVuZ3RoID0gKCkgPT4gMVxuXG4vLyBscnVMaXN0IGlzIGEgeWFsbGlzdCB3aGVyZSB0aGUgaGVhZCBpcyB0aGUgeW91bmdlc3Rcbi8vIGl0ZW0sIGFuZCB0aGUgdGFpbCBpcyB0aGUgb2xkZXN0LiAgdGhlIGxpc3QgY29udGFpbnMgdGhlIEhpdFxuLy8gb2JqZWN0cyBhcyB0aGUgZW50cmllcy5cbi8vIEVhY2ggSGl0IG9iamVjdCBoYXMgYSByZWZlcmVuY2UgdG8gaXRzIFlhbGxpc3QuTm9kZS4gIFRoaXNcbi8vIG5ldmVyIGNoYW5nZXMuXG4vL1xuLy8gY2FjaGUgaXMgYSBNYXAgKG9yIFBzZXVkb01hcCkgdGhhdCBtYXRjaGVzIHRoZSBrZXlzIHRvXG4vLyB0aGUgWWFsbGlzdC5Ob2RlIG9iamVjdC5cbmNsYXNzIExSVUNhY2hlIHtcbiAgY29uc3RydWN0b3IgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKVxuICAgICAgb3B0aW9ucyA9IHsgbWF4OiBvcHRpb25zIH1cblxuICAgIGlmICghb3B0aW9ucylcbiAgICAgIG9wdGlvbnMgPSB7fVxuXG4gICAgaWYgKG9wdGlvbnMubWF4ICYmICh0eXBlb2Ygb3B0aW9ucy5tYXggIT09ICdudW1iZXInIHx8IG9wdGlvbnMubWF4IDwgMCkpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXggbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKVxuICAgIC8vIEtpbmQgb2Ygd2VpcmQgdG8gaGF2ZSBhIGRlZmF1bHQgbWF4IG9mIEluZmluaXR5LCBidXQgb2ggd2VsbC5cbiAgICBjb25zdCBtYXggPSB0aGlzW01BWF0gPSBvcHRpb25zLm1heCB8fCBJbmZpbml0eVxuXG4gICAgY29uc3QgbGMgPSBvcHRpb25zLmxlbmd0aCB8fCBuYWl2ZUxlbmd0aFxuICAgIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdID0gKHR5cGVvZiBsYyAhPT0gJ2Z1bmN0aW9uJykgPyBuYWl2ZUxlbmd0aCA6IGxjXG4gICAgdGhpc1tBTExPV19TVEFMRV0gPSBvcHRpb25zLnN0YWxlIHx8IGZhbHNlXG4gICAgaWYgKG9wdGlvbnMubWF4QWdlICYmIHR5cGVvZiBvcHRpb25zLm1heEFnZSAhPT0gJ251bWJlcicpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhBZ2UgbXVzdCBiZSBhIG51bWJlcicpXG4gICAgdGhpc1tNQVhfQUdFXSA9IG9wdGlvbnMubWF4QWdlIHx8IDBcbiAgICB0aGlzW0RJU1BPU0VdID0gb3B0aW9ucy5kaXNwb3NlXG4gICAgdGhpc1tOT19ESVNQT1NFX09OX1NFVF0gPSBvcHRpb25zLm5vRGlzcG9zZU9uU2V0IHx8IGZhbHNlXG4gICAgdGhpc1tVUERBVEVfQUdFX09OX0dFVF0gPSBvcHRpb25zLnVwZGF0ZUFnZU9uR2V0IHx8IGZhbHNlXG4gICAgdGhpcy5yZXNldCgpXG4gIH1cblxuICAvLyByZXNpemUgdGhlIGNhY2hlIHdoZW4gdGhlIG1heCBjaGFuZ2VzLlxuICBzZXQgbWF4IChtTCkge1xuICAgIGlmICh0eXBlb2YgbUwgIT09ICdudW1iZXInIHx8IG1MIDwgMClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpXG5cbiAgICB0aGlzW01BWF0gPSBtTCB8fCBJbmZpbml0eVxuICAgIHRyaW0odGhpcylcbiAgfVxuICBnZXQgbWF4ICgpIHtcbiAgICByZXR1cm4gdGhpc1tNQVhdXG4gIH1cblxuICBzZXQgYWxsb3dTdGFsZSAoYWxsb3dTdGFsZSkge1xuICAgIHRoaXNbQUxMT1dfU1RBTEVdID0gISFhbGxvd1N0YWxlXG4gIH1cbiAgZ2V0IGFsbG93U3RhbGUgKCkge1xuICAgIHJldHVybiB0aGlzW0FMTE9XX1NUQUxFXVxuICB9XG5cbiAgc2V0IG1heEFnZSAobUEpIHtcbiAgICBpZiAodHlwZW9mIG1BICE9PSAnbnVtYmVyJylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heEFnZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpXG5cbiAgICB0aGlzW01BWF9BR0VdID0gbUFcbiAgICB0cmltKHRoaXMpXG4gIH1cbiAgZ2V0IG1heEFnZSAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTUFYX0FHRV1cbiAgfVxuXG4gIC8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbGVuZ3RoQ2FsY3VsYXRvciBjaGFuZ2VzLlxuICBzZXQgbGVuZ3RoQ2FsY3VsYXRvciAobEMpIHtcbiAgICBpZiAodHlwZW9mIGxDICE9PSAnZnVuY3Rpb24nKVxuICAgICAgbEMgPSBuYWl2ZUxlbmd0aFxuXG4gICAgaWYgKGxDICE9PSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSkge1xuICAgICAgdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gPSBsQ1xuICAgICAgdGhpc1tMRU5HVEhdID0gMFxuICAgICAgdGhpc1tMUlVfTElTVF0uZm9yRWFjaChoaXQgPT4ge1xuICAgICAgICBoaXQubGVuZ3RoID0gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0oaGl0LnZhbHVlLCBoaXQua2V5KVxuICAgICAgICB0aGlzW0xFTkdUSF0gKz0gaGl0Lmxlbmd0aFxuICAgICAgfSlcbiAgICB9XG4gICAgdHJpbSh0aGlzKVxuICB9XG4gIGdldCBsZW5ndGhDYWxjdWxhdG9yICgpIHsgcmV0dXJuIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdIH1cblxuICBnZXQgbGVuZ3RoICgpIHsgcmV0dXJuIHRoaXNbTEVOR1RIXSB9XG4gIGdldCBpdGVtQ291bnQgKCkgeyByZXR1cm4gdGhpc1tMUlVfTElTVF0ubGVuZ3RoIH1cblxuICByZm9yRWFjaCAoZm4sIHRoaXNwKSB7XG4gICAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gICAgZm9yIChsZXQgd2Fsa2VyID0gdGhpc1tMUlVfTElTVF0udGFpbDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgICAgY29uc3QgcHJldiA9IHdhbGtlci5wcmV2XG4gICAgICBmb3JFYWNoU3RlcCh0aGlzLCBmbiwgd2Fsa2VyLCB0aGlzcClcbiAgICAgIHdhbGtlciA9IHByZXZcbiAgICB9XG4gIH1cblxuICBmb3JFYWNoIChmbiwgdGhpc3ApIHtcbiAgICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgICBmb3IgKGxldCB3YWxrZXIgPSB0aGlzW0xSVV9MSVNUXS5oZWFkOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICBjb25zdCBuZXh0ID0gd2Fsa2VyLm5leHRcbiAgICAgIGZvckVhY2hTdGVwKHRoaXMsIGZuLCB3YWxrZXIsIHRoaXNwKVxuICAgICAgd2Fsa2VyID0gbmV4dFxuICAgIH1cbiAgfVxuXG4gIGtleXMgKCkge1xuICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXS50b0FycmF5KCkubWFwKGsgPT4gay5rZXkpXG4gIH1cblxuICB2YWx1ZXMgKCkge1xuICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXS50b0FycmF5KCkubWFwKGsgPT4gay52YWx1ZSlcbiAgfVxuXG4gIHJlc2V0ICgpIHtcbiAgICBpZiAodGhpc1tESVNQT1NFXSAmJlxuICAgICAgICB0aGlzW0xSVV9MSVNUXSAmJlxuICAgICAgICB0aGlzW0xSVV9MSVNUXS5sZW5ndGgpIHtcbiAgICAgIHRoaXNbTFJVX0xJU1RdLmZvckVhY2goaGl0ID0+IHRoaXNbRElTUE9TRV0oaGl0LmtleSwgaGl0LnZhbHVlKSlcbiAgICB9XG5cbiAgICB0aGlzW0NBQ0hFXSA9IG5ldyBNYXAoKSAvLyBoYXNoIG9mIGl0ZW1zIGJ5IGtleVxuICAgIHRoaXNbTFJVX0xJU1RdID0gbmV3IFlhbGxpc3QoKSAvLyBsaXN0IG9mIGl0ZW1zIGluIG9yZGVyIG9mIHVzZSByZWNlbmN5XG4gICAgdGhpc1tMRU5HVEhdID0gMCAvLyBsZW5ndGggb2YgaXRlbXMgaW4gdGhlIGxpc3RcbiAgfVxuXG4gIGR1bXAgKCkge1xuICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXS5tYXAoaGl0ID0+XG4gICAgICBpc1N0YWxlKHRoaXMsIGhpdCkgPyBmYWxzZSA6IHtcbiAgICAgICAgazogaGl0LmtleSxcbiAgICAgICAgdjogaGl0LnZhbHVlLFxuICAgICAgICBlOiBoaXQubm93ICsgKGhpdC5tYXhBZ2UgfHwgMClcbiAgICAgIH0pLnRvQXJyYXkoKS5maWx0ZXIoaCA9PiBoKVxuICB9XG5cbiAgZHVtcExydSAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdXG4gIH1cblxuICBzZXQgKGtleSwgdmFsdWUsIG1heEFnZSkge1xuICAgIG1heEFnZSA9IG1heEFnZSB8fCB0aGlzW01BWF9BR0VdXG5cbiAgICBpZiAobWF4QWdlICYmIHR5cGVvZiBtYXhBZ2UgIT09ICdudW1iZXInKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4QWdlIG11c3QgYmUgYSBudW1iZXInKVxuXG4gICAgY29uc3Qgbm93ID0gbWF4QWdlID8gRGF0ZS5ub3coKSA6IDBcbiAgICBjb25zdCBsZW4gPSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSh2YWx1ZSwga2V5KVxuXG4gICAgaWYgKHRoaXNbQ0FDSEVdLmhhcyhrZXkpKSB7XG4gICAgICBpZiAobGVuID4gdGhpc1tNQVhdKSB7XG4gICAgICAgIGRlbCh0aGlzLCB0aGlzW0NBQ0hFXS5nZXQoa2V5KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzW0NBQ0hFXS5nZXQoa2V5KVxuICAgICAgY29uc3QgaXRlbSA9IG5vZGUudmFsdWVcblxuICAgICAgLy8gZGlzcG9zZSBvZiB0aGUgb2xkIG9uZSBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgICAgIC8vIHNwbGl0IG91dCBpbnRvIDIgaWZzIGZvciBiZXR0ZXIgY292ZXJhZ2UgdHJhY2tpbmdcbiAgICAgIGlmICh0aGlzW0RJU1BPU0VdKSB7XG4gICAgICAgIGlmICghdGhpc1tOT19ESVNQT1NFX09OX1NFVF0pXG4gICAgICAgICAgdGhpc1tESVNQT1NFXShrZXksIGl0ZW0udmFsdWUpXG4gICAgICB9XG5cbiAgICAgIGl0ZW0ubm93ID0gbm93XG4gICAgICBpdGVtLm1heEFnZSA9IG1heEFnZVxuICAgICAgaXRlbS52YWx1ZSA9IHZhbHVlXG4gICAgICB0aGlzW0xFTkdUSF0gKz0gbGVuIC0gaXRlbS5sZW5ndGhcbiAgICAgIGl0ZW0ubGVuZ3RoID0gbGVuXG4gICAgICB0aGlzLmdldChrZXkpXG4gICAgICB0cmltKHRoaXMpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IGhpdCA9IG5ldyBFbnRyeShrZXksIHZhbHVlLCBsZW4sIG5vdywgbWF4QWdlKVxuXG4gICAgLy8gb3ZlcnNpemVkIG9iamVjdHMgZmFsbCBvdXQgb2YgY2FjaGUgYXV0b21hdGljYWxseS5cbiAgICBpZiAoaGl0Lmxlbmd0aCA+IHRoaXNbTUFYXSkge1xuICAgICAgaWYgKHRoaXNbRElTUE9TRV0pXG4gICAgICAgIHRoaXNbRElTUE9TRV0oa2V5LCB2YWx1ZSlcblxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdGhpc1tMRU5HVEhdICs9IGhpdC5sZW5ndGhcbiAgICB0aGlzW0xSVV9MSVNUXS51bnNoaWZ0KGhpdClcbiAgICB0aGlzW0NBQ0hFXS5zZXQoa2V5LCB0aGlzW0xSVV9MSVNUXS5oZWFkKVxuICAgIHRyaW0odGhpcylcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaGFzIChrZXkpIHtcbiAgICBpZiAoIXRoaXNbQ0FDSEVdLmhhcyhrZXkpKSByZXR1cm4gZmFsc2VcbiAgICBjb25zdCBoaXQgPSB0aGlzW0NBQ0hFXS5nZXQoa2V5KS52YWx1ZVxuICAgIHJldHVybiAhaXNTdGFsZSh0aGlzLCBoaXQpXG4gIH1cblxuICBnZXQgKGtleSkge1xuICAgIHJldHVybiBnZXQodGhpcywga2V5LCB0cnVlKVxuICB9XG5cbiAgcGVlayAoa2V5KSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBrZXksIGZhbHNlKVxuICB9XG5cbiAgcG9wICgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpc1tMUlVfTElTVF0udGFpbFxuICAgIGlmICghbm9kZSlcbiAgICAgIHJldHVybiBudWxsXG5cbiAgICBkZWwodGhpcywgbm9kZSlcbiAgICByZXR1cm4gbm9kZS52YWx1ZVxuICB9XG5cbiAgZGVsIChrZXkpIHtcbiAgICBkZWwodGhpcywgdGhpc1tDQUNIRV0uZ2V0KGtleSkpXG4gIH1cblxuICBsb2FkIChhcnIpIHtcbiAgICAvLyByZXNldCB0aGUgY2FjaGVcbiAgICB0aGlzLnJlc2V0KClcblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KClcbiAgICAvLyBBIHByZXZpb3VzIHNlcmlhbGl6ZWQgY2FjaGUgaGFzIHRoZSBtb3N0IHJlY2VudCBpdGVtcyBmaXJzdFxuICAgIGZvciAobGV0IGwgPSBhcnIubGVuZ3RoIC0gMTsgbCA+PSAwOyBsLS0pIHtcbiAgICAgIGNvbnN0IGhpdCA9IGFycltsXVxuICAgICAgY29uc3QgZXhwaXJlc0F0ID0gaGl0LmUgfHwgMFxuICAgICAgaWYgKGV4cGlyZXNBdCA9PT0gMClcbiAgICAgICAgLy8gdGhlIGl0ZW0gd2FzIGNyZWF0ZWQgd2l0aG91dCBleHBpcmF0aW9uIGluIGEgbm9uIGFnZWQgY2FjaGVcbiAgICAgICAgdGhpcy5zZXQoaGl0LmssIGhpdC52KVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG1heEFnZSA9IGV4cGlyZXNBdCAtIG5vd1xuICAgICAgICAvLyBkb250IGFkZCBhbHJlYWR5IGV4cGlyZWQgaXRlbXNcbiAgICAgICAgaWYgKG1heEFnZSA+IDApIHtcbiAgICAgICAgICB0aGlzLnNldChoaXQuaywgaGl0LnYsIG1heEFnZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBydW5lICgpIHtcbiAgICB0aGlzW0NBQ0hFXS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiBnZXQodGhpcywga2V5LCBmYWxzZSkpXG4gIH1cbn1cblxuY29uc3QgZ2V0ID0gKHNlbGYsIGtleSwgZG9Vc2UpID0+IHtcbiAgY29uc3Qgbm9kZSA9IHNlbGZbQ0FDSEVdLmdldChrZXkpXG4gIGlmIChub2RlKSB7XG4gICAgY29uc3QgaGl0ID0gbm9kZS52YWx1ZVxuICAgIGlmIChpc1N0YWxlKHNlbGYsIGhpdCkpIHtcbiAgICAgIGRlbChzZWxmLCBub2RlKVxuICAgICAgaWYgKCFzZWxmW0FMTE9XX1NUQUxFXSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZG9Vc2UpIHtcbiAgICAgICAgaWYgKHNlbGZbVVBEQVRFX0FHRV9PTl9HRVRdKVxuICAgICAgICAgIG5vZGUudmFsdWUubm93ID0gRGF0ZS5ub3coKVxuICAgICAgICBzZWxmW0xSVV9MSVNUXS51bnNoaWZ0Tm9kZShub2RlKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGl0LnZhbHVlXG4gIH1cbn1cblxuY29uc3QgaXNTdGFsZSA9IChzZWxmLCBoaXQpID0+IHtcbiAgaWYgKCFoaXQgfHwgKCFoaXQubWF4QWdlICYmICFzZWxmW01BWF9BR0VdKSlcbiAgICByZXR1cm4gZmFsc2VcblxuICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIGhpdC5ub3dcbiAgcmV0dXJuIGhpdC5tYXhBZ2UgPyBkaWZmID4gaGl0Lm1heEFnZVxuICAgIDogc2VsZltNQVhfQUdFXSAmJiAoZGlmZiA+IHNlbGZbTUFYX0FHRV0pXG59XG5cbmNvbnN0IHRyaW0gPSBzZWxmID0+IHtcbiAgaWYgKHNlbGZbTEVOR1RIXSA+IHNlbGZbTUFYXSkge1xuICAgIGZvciAobGV0IHdhbGtlciA9IHNlbGZbTFJVX0xJU1RdLnRhaWw7XG4gICAgICBzZWxmW0xFTkdUSF0gPiBzZWxmW01BWF0gJiYgd2Fsa2VyICE9PSBudWxsOykge1xuICAgICAgLy8gV2Uga25vdyB0aGF0IHdlJ3JlIGFib3V0IHRvIGRlbGV0ZSB0aGlzIG9uZSwgYW5kIGFsc29cbiAgICAgIC8vIHdoYXQgdGhlIG5leHQgbGVhc3QgcmVjZW50bHkgdXNlZCBrZXkgd2lsbCBiZSwgc28ganVzdFxuICAgICAgLy8gZ28gYWhlYWQgYW5kIHNldCBpdCBub3cuXG4gICAgICBjb25zdCBwcmV2ID0gd2Fsa2VyLnByZXZcbiAgICAgIGRlbChzZWxmLCB3YWxrZXIpXG4gICAgICB3YWxrZXIgPSBwcmV2XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGRlbCA9IChzZWxmLCBub2RlKSA9PiB7XG4gIGlmIChub2RlKSB7XG4gICAgY29uc3QgaGl0ID0gbm9kZS52YWx1ZVxuICAgIGlmIChzZWxmW0RJU1BPU0VdKVxuICAgICAgc2VsZltESVNQT1NFXShoaXQua2V5LCBoaXQudmFsdWUpXG5cbiAgICBzZWxmW0xFTkdUSF0gLT0gaGl0Lmxlbmd0aFxuICAgIHNlbGZbQ0FDSEVdLmRlbGV0ZShoaXQua2V5KVxuICAgIHNlbGZbTFJVX0xJU1RdLnJlbW92ZU5vZGUobm9kZSlcbiAgfVxufVxuXG5jbGFzcyBFbnRyeSB7XG4gIGNvbnN0cnVjdG9yIChrZXksIHZhbHVlLCBsZW5ndGgsIG5vdywgbWF4QWdlKSB7XG4gICAgdGhpcy5rZXkgPSBrZXlcbiAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aFxuICAgIHRoaXMubm93ID0gbm93XG4gICAgdGhpcy5tYXhBZ2UgPSBtYXhBZ2UgfHwgMFxuICB9XG59XG5cbmNvbnN0IGZvckVhY2hTdGVwID0gKHNlbGYsIGZuLCBub2RlLCB0aGlzcCkgPT4ge1xuICBsZXQgaGl0ID0gbm9kZS52YWx1ZVxuICBpZiAoaXNTdGFsZShzZWxmLCBoaXQpKSB7XG4gICAgZGVsKHNlbGYsIG5vZGUpXG4gICAgaWYgKCFzZWxmW0FMTE9XX1NUQUxFXSlcbiAgICAgIGhpdCA9IHVuZGVmaW5lZFxuICB9XG4gIGlmIChoaXQpXG4gICAgZm4uY2FsbCh0aGlzcCwgaGl0LnZhbHVlLCBoaXQua2V5LCBzZWxmKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExSVUNhY2hlXG4iLCIvLyBob2lzdGVkIGNsYXNzIGZvciBjeWNsaWMgZGVwZW5kZW5jeVxuY2xhc3MgUmFuZ2Uge1xuICBjb25zdHJ1Y3RvciAocmFuZ2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkge1xuICAgICAgaWYgKFxuICAgICAgICByYW5nZS5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlICYmXG4gICAgICAgIHJhbmdlLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gcmFuZ2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UucmF3LCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICAgIC8vIGp1c3QgcHV0IGl0IGluIHRoZSBzZXQgYW5kIHJldHVyblxuICAgICAgdGhpcy5yYXcgPSByYW5nZS52YWx1ZVxuICAgICAgdGhpcy5zZXQgPSBbW3JhbmdlXV1cbiAgICAgIHRoaXMuZm9ybWF0KClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgICB0aGlzLmluY2x1ZGVQcmVyZWxlYXNlID0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlXG5cbiAgICAvLyBGaXJzdCByZWR1Y2UgYWxsIHdoaXRlc3BhY2UgYXMgbXVjaCBhcyBwb3NzaWJsZSBzbyB3ZSBkbyBub3QgaGF2ZSB0byByZWx5XG4gICAgLy8gb24gcG90ZW50aWFsbHkgc2xvdyByZWdleGVzIGxpa2UgXFxzKi4gVGhpcyBpcyB0aGVuIHN0b3JlZCBhbmQgdXNlZCBmb3JcbiAgICAvLyBmdXR1cmUgZXJyb3IgbWVzc2FnZXMgYXMgd2VsbC5cbiAgICB0aGlzLnJhdyA9IHJhbmdlXG4gICAgICAudHJpbSgpXG4gICAgICAuc3BsaXQoL1xccysvKVxuICAgICAgLmpvaW4oJyAnKVxuXG4gICAgLy8gRmlyc3QsIHNwbGl0IG9uIHx8XG4gICAgdGhpcy5zZXQgPSB0aGlzLnJhd1xuICAgICAgLnNwbGl0KCd8fCcpXG4gICAgICAvLyBtYXAgdGhlIHJhbmdlIHRvIGEgMmQgYXJyYXkgb2YgY29tcGFyYXRvcnNcbiAgICAgIC5tYXAociA9PiB0aGlzLnBhcnNlUmFuZ2Uoci50cmltKCkpKVxuICAgICAgLy8gdGhyb3cgb3V0IGFueSBjb21wYXJhdG9yIGxpc3RzIHRoYXQgYXJlIGVtcHR5XG4gICAgICAvLyB0aGlzIGdlbmVyYWxseSBtZWFucyB0aGF0IGl0IHdhcyBub3QgYSB2YWxpZCByYW5nZSwgd2hpY2ggaXMgYWxsb3dlZFxuICAgICAgLy8gaW4gbG9vc2UgbW9kZSwgYnV0IHdpbGwgc3RpbGwgdGhyb3cgaWYgdGhlIFdIT0xFIHJhbmdlIGlzIGludmFsaWQuXG4gICAgICAuZmlsdGVyKGMgPT4gYy5sZW5ndGgpXG5cbiAgICBpZiAoIXRoaXMuc2V0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBTZW1WZXIgUmFuZ2U6ICR7dGhpcy5yYXd9YClcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGFueSB0aGF0IGFyZSBub3QgdGhlIG51bGwgc2V0LCB0aHJvdyBvdXQgbnVsbCBzZXRzLlxuICAgIGlmICh0aGlzLnNldC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBrZWVwIHRoZSBmaXJzdCBvbmUsIGluIGNhc2UgdGhleSdyZSBhbGwgbnVsbCBzZXRzXG4gICAgICBjb25zdCBmaXJzdCA9IHRoaXMuc2V0WzBdXG4gICAgICB0aGlzLnNldCA9IHRoaXMuc2V0LmZpbHRlcihjID0+ICFpc051bGxTZXQoY1swXSkpXG4gICAgICBpZiAodGhpcy5zZXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuc2V0ID0gW2ZpcnN0XVxuICAgICAgfSBlbHNlIGlmICh0aGlzLnNldC5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYW55IHRoYXQgYXJlICosIHRoZW4gdGhlIHJhbmdlIGlzIGp1c3QgKlxuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgdGhpcy5zZXQpIHtcbiAgICAgICAgICBpZiAoYy5sZW5ndGggPT09IDEgJiYgaXNBbnkoY1swXSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gW2NdXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZm9ybWF0KClcbiAgfVxuXG4gIGZvcm1hdCAoKSB7XG4gICAgdGhpcy5yYW5nZSA9IHRoaXMuc2V0XG4gICAgICAubWFwKChjb21wcykgPT4gY29tcHMuam9pbignICcpLnRyaW0oKSlcbiAgICAgIC5qb2luKCd8fCcpXG4gICAgICAudHJpbSgpXG4gICAgcmV0dXJuIHRoaXMucmFuZ2VcbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5yYW5nZVxuICB9XG5cbiAgcGFyc2VSYW5nZSAocmFuZ2UpIHtcbiAgICAvLyBtZW1vaXplIHJhbmdlIHBhcnNpbmcgZm9yIHBlcmZvcm1hbmNlLlxuICAgIC8vIHRoaXMgaXMgYSB2ZXJ5IGhvdCBwYXRoLCBhbmQgZnVsbHkgZGV0ZXJtaW5pc3RpYy5cbiAgICBjb25zdCBtZW1vT3B0cyA9XG4gICAgICAodGhpcy5vcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmIEZMQUdfSU5DTFVERV9QUkVSRUxFQVNFKSB8XG4gICAgICAodGhpcy5vcHRpb25zLmxvb3NlICYmIEZMQUdfTE9PU0UpXG4gICAgY29uc3QgbWVtb0tleSA9IG1lbW9PcHRzICsgJzonICsgcmFuZ2VcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQobWVtb0tleSlcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkXG4gICAgfVxuXG4gICAgY29uc3QgbG9vc2UgPSB0aGlzLm9wdGlvbnMubG9vc2VcbiAgICAvLyBgMS4yLjMgLSAxLjIuNGAgPT4gYD49MS4yLjMgPD0xLjIuNGBcbiAgICBjb25zdCBociA9IGxvb3NlID8gcmVbdC5IWVBIRU5SQU5HRUxPT1NFXSA6IHJlW3QuSFlQSEVOUkFOR0VdXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKGhyLCBoeXBoZW5SZXBsYWNlKHRoaXMub3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkpXG4gICAgZGVidWcoJ2h5cGhlbiByZXBsYWNlJywgcmFuZ2UpXG5cbiAgICAvLyBgPiAxLjIuMyA8IDEuMi41YCA9PiBgPjEuMi4zIDwxLjIuNWBcbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5DT01QQVJBVE9SVFJJTV0sIGNvbXBhcmF0b3JUcmltUmVwbGFjZSlcbiAgICBkZWJ1ZygnY29tcGFyYXRvciB0cmltJywgcmFuZ2UpXG5cbiAgICAvLyBgfiAxLjIuM2AgPT4gYH4xLjIuM2BcbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5USUxERVRSSU1dLCB0aWxkZVRyaW1SZXBsYWNlKVxuICAgIGRlYnVnKCd0aWxkZSB0cmltJywgcmFuZ2UpXG5cbiAgICAvLyBgXiAxLjIuM2AgPT4gYF4xLjIuM2BcbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5DQVJFVFRSSU1dLCBjYXJldFRyaW1SZXBsYWNlKVxuICAgIGRlYnVnKCdjYXJldCB0cmltJywgcmFuZ2UpXG5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSB0cmltbWVkIGFuZFxuICAgIC8vIHJlYWR5IHRvIGJlIHNwbGl0IGludG8gY29tcGFyYXRvcnMuXG5cbiAgICBsZXQgcmFuZ2VMaXN0ID0gcmFuZ2VcbiAgICAgIC5zcGxpdCgnICcpXG4gICAgICAubWFwKGNvbXAgPT4gcGFyc2VDb21wYXJhdG9yKGNvbXAsIHRoaXMub3B0aW9ucykpXG4gICAgICAuam9pbignICcpXG4gICAgICAuc3BsaXQoL1xccysvKVxuICAgICAgLy8gPj0wLjAuMCBpcyBlcXVpdmFsZW50IHRvICpcbiAgICAgIC5tYXAoY29tcCA9PiByZXBsYWNlR1RFMChjb21wLCB0aGlzLm9wdGlvbnMpKVxuXG4gICAgaWYgKGxvb3NlKSB7XG4gICAgICAvLyBpbiBsb29zZSBtb2RlLCB0aHJvdyBvdXQgYW55IHRoYXQgYXJlIG5vdCB2YWxpZCBjb21wYXJhdG9yc1xuICAgICAgcmFuZ2VMaXN0ID0gcmFuZ2VMaXN0LmZpbHRlcihjb21wID0+IHtcbiAgICAgICAgZGVidWcoJ2xvb3NlIGludmFsaWQgZmlsdGVyJywgY29tcCwgdGhpcy5vcHRpb25zKVxuICAgICAgICByZXR1cm4gISFjb21wLm1hdGNoKHJlW3QuQ09NUEFSQVRPUkxPT1NFXSlcbiAgICAgIH0pXG4gICAgfVxuICAgIGRlYnVnKCdyYW5nZSBsaXN0JywgcmFuZ2VMaXN0KVxuXG4gICAgLy8gaWYgYW55IGNvbXBhcmF0b3JzIGFyZSB0aGUgbnVsbCBzZXQsIHRoZW4gcmVwbGFjZSB3aXRoIEpVU1QgbnVsbCBzZXRcbiAgICAvLyBpZiBtb3JlIHRoYW4gb25lIGNvbXBhcmF0b3IsIHJlbW92ZSBhbnkgKiBjb21wYXJhdG9yc1xuICAgIC8vIGFsc28sIGRvbid0IGluY2x1ZGUgdGhlIHNhbWUgY29tcGFyYXRvciBtb3JlIHRoYW4gb25jZVxuICAgIGNvbnN0IHJhbmdlTWFwID0gbmV3IE1hcCgpXG4gICAgY29uc3QgY29tcGFyYXRvcnMgPSByYW5nZUxpc3QubWFwKGNvbXAgPT4gbmV3IENvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKSlcbiAgICBmb3IgKGNvbnN0IGNvbXAgb2YgY29tcGFyYXRvcnMpIHtcbiAgICAgIGlmIChpc051bGxTZXQoY29tcCkpIHtcbiAgICAgICAgcmV0dXJuIFtjb21wXVxuICAgICAgfVxuICAgICAgcmFuZ2VNYXAuc2V0KGNvbXAudmFsdWUsIGNvbXApXG4gICAgfVxuICAgIGlmIChyYW5nZU1hcC5zaXplID4gMSAmJiByYW5nZU1hcC5oYXMoJycpKSB7XG4gICAgICByYW5nZU1hcC5kZWxldGUoJycpXG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gWy4uLnJhbmdlTWFwLnZhbHVlcygpXVxuICAgIGNhY2hlLnNldChtZW1vS2V5LCByZXN1bHQpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgaW50ZXJzZWN0cyAocmFuZ2UsIG9wdGlvbnMpIHtcbiAgICBpZiAoIShyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBSYW5nZSBpcyByZXF1aXJlZCcpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2V0LnNvbWUoKHRoaXNDb21wYXJhdG9ycykgPT4ge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgaXNTYXRpc2ZpYWJsZSh0aGlzQ29tcGFyYXRvcnMsIG9wdGlvbnMpICYmXG4gICAgICAgIHJhbmdlLnNldC5zb21lKChyYW5nZUNvbXBhcmF0b3JzKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlzU2F0aXNmaWFibGUocmFuZ2VDb21wYXJhdG9ycywgb3B0aW9ucykgJiZcbiAgICAgICAgICAgIHRoaXNDb21wYXJhdG9ycy5ldmVyeSgodGhpc0NvbXBhcmF0b3IpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlQ29tcGFyYXRvcnMuZXZlcnkoKHJhbmdlQ29tcGFyYXRvcikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzQ29tcGFyYXRvci5pbnRlcnNlY3RzKHJhbmdlQ29tcGFyYXRvciwgb3B0aW9ucylcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH0pXG4gIH1cblxuICAvLyBpZiBBTlkgb2YgdGhlIHNldHMgbWF0Y2ggQUxMIG9mIGl0cyBjb21wYXJhdG9ycywgdGhlbiBwYXNzXG4gIHRlc3QgKHZlcnNpb24pIHtcbiAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMub3B0aW9ucylcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0ZXN0U2V0KHRoaXMuc2V0W2ldLCB2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmFuZ2VcblxuY29uc3QgTFJVID0gcmVxdWlyZSgnbHJ1LWNhY2hlJylcbmNvbnN0IGNhY2hlID0gbmV3IExSVSh7IG1heDogMTAwMCB9KVxuXG5jb25zdCBwYXJzZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9wYXJzZS1vcHRpb25zJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuL2NvbXBhcmF0b3InKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuL3NlbXZlcicpXG5jb25zdCB7XG4gIHNhZmVSZTogcmUsXG4gIHQsXG4gIGNvbXBhcmF0b3JUcmltUmVwbGFjZSxcbiAgdGlsZGVUcmltUmVwbGFjZSxcbiAgY2FyZXRUcmltUmVwbGFjZSxcbn0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5jb25zdCB7IEZMQUdfSU5DTFVERV9QUkVSRUxFQVNFLCBGTEFHX0xPT1NFIH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9jb25zdGFudHMnKVxuXG5jb25zdCBpc051bGxTZXQgPSBjID0+IGMudmFsdWUgPT09ICc8MC4wLjAtMCdcbmNvbnN0IGlzQW55ID0gYyA9PiBjLnZhbHVlID09PSAnJ1xuXG4vLyB0YWtlIGEgc2V0IG9mIGNvbXBhcmF0b3JzIGFuZCBkZXRlcm1pbmUgd2hldGhlciB0aGVyZVxuLy8gZXhpc3RzIGEgdmVyc2lvbiB3aGljaCBjYW4gc2F0aXNmeSBpdFxuY29uc3QgaXNTYXRpc2ZpYWJsZSA9IChjb21wYXJhdG9ycywgb3B0aW9ucykgPT4ge1xuICBsZXQgcmVzdWx0ID0gdHJ1ZVxuICBjb25zdCByZW1haW5pbmdDb21wYXJhdG9ycyA9IGNvbXBhcmF0b3JzLnNsaWNlKClcbiAgbGV0IHRlc3RDb21wYXJhdG9yID0gcmVtYWluaW5nQ29tcGFyYXRvcnMucG9wKClcblxuICB3aGlsZSAocmVzdWx0ICYmIHJlbWFpbmluZ0NvbXBhcmF0b3JzLmxlbmd0aCkge1xuICAgIHJlc3VsdCA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLmV2ZXJ5KChvdGhlckNvbXBhcmF0b3IpID0+IHtcbiAgICAgIHJldHVybiB0ZXN0Q29tcGFyYXRvci5pbnRlcnNlY3RzKG90aGVyQ29tcGFyYXRvciwgb3B0aW9ucylcbiAgICB9KVxuXG4gICAgdGVzdENvbXBhcmF0b3IgPSByZW1haW5pbmdDb21wYXJhdG9ycy5wb3AoKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vLyBjb21wcmlzZWQgb2YgeHJhbmdlcywgdGlsZGVzLCBzdGFycywgYW5kIGd0bHQncyBhdCB0aGlzIHBvaW50LlxuLy8gYWxyZWFkeSByZXBsYWNlZCB0aGUgaHlwaGVuIHJhbmdlc1xuLy8gdHVybiBpbnRvIGEgc2V0IG9mIEpVU1QgY29tcGFyYXRvcnMuXG5jb25zdCBwYXJzZUNvbXBhcmF0b3IgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygnY29tcCcsIGNvbXAsIG9wdGlvbnMpXG4gIGNvbXAgPSByZXBsYWNlQ2FyZXRzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCdjYXJldCcsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlVGlsZGVzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCd0aWxkZXMnLCBjb21wKVxuICBjb21wID0gcmVwbGFjZVhSYW5nZXMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3hyYW5nZScsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlU3RhcnMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3N0YXJzJywgY29tcClcbiAgcmV0dXJuIGNvbXBcbn1cblxuY29uc3QgaXNYID0gaWQgPT4gIWlkIHx8IGlkLnRvTG93ZXJDYXNlKCkgPT09ICd4JyB8fCBpZCA9PT0gJyonXG5cbi8vIH4sIH4+IC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gfjIsIH4yLngsIH4yLngueCwgfj4yLCB+PjIueCB+PjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMC0wXG4vLyB+Mi4wLCB+Mi4wLngsIH4+Mi4wLCB+PjIuMC54IC0tPiA+PTIuMC4wIDwyLjEuMC0wXG4vLyB+MS4yLCB+MS4yLngsIH4+MS4yLCB+PjEuMi54IC0tPiA+PTEuMi4wIDwxLjMuMC0wXG4vLyB+MS4yLjMsIH4+MS4yLjMgLS0+ID49MS4yLjMgPDEuMy4wLTBcbi8vIH4xLjIuMCwgfj4xLjIuMCAtLT4gPj0xLjIuMCA8MS4zLjAtMFxuLy8gfjAuMC4xIC0tPiA+PTAuMC4xIDwwLjEuMC0wXG5jb25zdCByZXBsYWNlVGlsZGVzID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIGNvbXBcbiAgICAudHJpbSgpXG4gICAgLnNwbGl0KC9cXHMrLylcbiAgICAubWFwKChjKSA9PiByZXBsYWNlVGlsZGUoYywgb3B0aW9ucykpXG4gICAgLmpvaW4oJyAnKVxufVxuXG5jb25zdCByZXBsYWNlVGlsZGUgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuVElMREVMT09TRV0gOiByZVt0LlRJTERFXVxuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIChfLCBNLCBtLCBwLCBwcikgPT4ge1xuICAgIGRlYnVnKCd0aWxkZScsIGNvbXAsIF8sIE0sIG0sIHAsIHByKVxuICAgIGxldCByZXRcblxuICAgIGlmIChpc1goTSkpIHtcbiAgICAgIHJldCA9ICcnXG4gICAgfSBlbHNlIGlmIChpc1gobSkpIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uMC4wIDwkeytNICsgMX0uMC4wLTBgXG4gICAgfSBlbHNlIGlmIChpc1gocCkpIHtcbiAgICAgIC8vIH4xLjIgPT0gPj0xLjIuMCA8MS4zLjAtMFxuICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAgPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZVRpbGRlIHByJywgcHIpXG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIH4xLjIuMyA9PSA+PTEuMi4zIDwxLjMuMC0wXG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwXG4gICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgfVxuXG4gICAgZGVidWcoJ3RpbGRlIHJldHVybicsIHJldClcbiAgICByZXR1cm4gcmV0XG4gIH0pXG59XG5cbi8vIF4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyBeMiwgXjIueCwgXjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMC0wXG4vLyBeMi4wLCBeMi4wLnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIF4xLjIsIF4xLjIueCAtLT4gPj0xLjIuMCA8Mi4wLjAtMFxuLy8gXjEuMi4zIC0tPiA+PTEuMi4zIDwyLjAuMC0wXG4vLyBeMS4yLjAgLS0+ID49MS4yLjAgPDIuMC4wLTBcbi8vIF4wLjAuMSAtLT4gPj0wLjAuMSA8MC4wLjItMFxuLy8gXjAuMS4wIC0tPiA+PTAuMS4wIDwwLjIuMC0wXG5jb25zdCByZXBsYWNlQ2FyZXRzID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIGNvbXBcbiAgICAudHJpbSgpXG4gICAgLnNwbGl0KC9cXHMrLylcbiAgICAubWFwKChjKSA9PiByZXBsYWNlQ2FyZXQoYywgb3B0aW9ucykpXG4gICAgLmpvaW4oJyAnKVxufVxuXG5jb25zdCByZXBsYWNlQ2FyZXQgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygnY2FyZXQnLCBjb21wLCBvcHRpb25zKVxuICBjb25zdCByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuQ0FSRVRMT09TRV0gOiByZVt0LkNBUkVUXVxuICBjb25zdCB6ID0gb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/ICctMCcgOiAnJ1xuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIChfLCBNLCBtLCBwLCBwcikgPT4ge1xuICAgIGRlYnVnKCdjYXJldCcsIGNvbXAsIF8sIE0sIG0sIHAsIHByKVxuICAgIGxldCByZXRcblxuICAgIGlmIChpc1goTSkpIHtcbiAgICAgIHJldCA9ICcnXG4gICAgfSBlbHNlIGlmIChpc1gobSkpIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uMC4wJHt6fSA8JHsrTSArIDF9LjAuMC0wYFxuICAgIH0gZWxzZSBpZiAoaXNYKHApKSB7XG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wJHt6fSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3p9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcikge1xuICAgICAgZGVidWcoJ3JlcGxhY2VDYXJldCBwcicsIHByKVxuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwclxuICAgICAgICAgIH0gPCR7TX0uJHttfS4keytwICsgMX0tMGBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICAgIH0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ25vIHByJylcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgaWYgKG0gPT09ICcwJykge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgICAgICB9JHt6fSA8JHtNfS4ke219LiR7K3AgKyAxfS0wYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgICAgICB9JHt6fSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwXG4gICAgICAgIH0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWJ1ZygnY2FyZXQgcmV0dXJuJywgcmV0KVxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuY29uc3QgcmVwbGFjZVhSYW5nZXMgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygncmVwbGFjZVhSYW5nZXMnLCBjb21wLCBvcHRpb25zKVxuICByZXR1cm4gY29tcFxuICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgLm1hcCgoYykgPT4gcmVwbGFjZVhSYW5nZShjLCBvcHRpb25zKSlcbiAgICAuam9pbignICcpXG59XG5cbmNvbnN0IHJlcGxhY2VYUmFuZ2UgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBjb21wID0gY29tcC50cmltKClcbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LlhSQU5HRUxPT1NFXSA6IHJlW3QuWFJBTkdFXVxuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIChyZXQsIGd0bHQsIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ3hSYW5nZScsIGNvbXAsIHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpXG4gICAgY29uc3QgeE0gPSBpc1goTSlcbiAgICBjb25zdCB4bSA9IHhNIHx8IGlzWChtKVxuICAgIGNvbnN0IHhwID0geG0gfHwgaXNYKHApXG4gICAgY29uc3QgYW55WCA9IHhwXG5cbiAgICBpZiAoZ3RsdCA9PT0gJz0nICYmIGFueVgpIHtcbiAgICAgIGd0bHQgPSAnJ1xuICAgIH1cblxuICAgIC8vIGlmIHdlJ3JlIGluY2x1ZGluZyBwcmVyZWxlYXNlcyBpbiB0aGUgbWF0Y2gsIHRoZW4gd2UgbmVlZFxuICAgIC8vIHRvIGZpeCB0aGlzIHRvIC0wLCB0aGUgbG93ZXN0IHBvc3NpYmxlIHByZXJlbGVhc2UgdmFsdWVcbiAgICBwciA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyAnLTAnIDogJydcblxuICAgIGlmICh4TSkge1xuICAgICAgaWYgKGd0bHQgPT09ICc+JyB8fCBndGx0ID09PSAnPCcpIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBhbGxvd2VkXG4gICAgICAgIHJldCA9ICc8MC4wLjAtMCdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgaXMgZm9yYmlkZGVuXG4gICAgICAgIHJldCA9ICcqJ1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ3RsdCAmJiBhbnlYKSB7XG4gICAgICAvLyB3ZSBrbm93IHBhdGNoIGlzIGFuIHgsIGJlY2F1c2Ugd2UgaGF2ZSBhbnkgeCBhdCBhbGwuXG4gICAgICAvLyByZXBsYWNlIFggd2l0aCAwXG4gICAgICBpZiAoeG0pIHtcbiAgICAgICAgbSA9IDBcbiAgICAgIH1cbiAgICAgIHAgPSAwXG5cbiAgICAgIGlmIChndGx0ID09PSAnPicpIHtcbiAgICAgICAgLy8gPjEgPT4gPj0yLjAuMFxuICAgICAgICAvLyA+MS4yID0+ID49MS4zLjBcbiAgICAgICAgZ3RsdCA9ICc+PSdcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMVxuICAgICAgICAgIG0gPSAwXG4gICAgICAgICAgcCA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtID0gK20gKyAxXG4gICAgICAgICAgcCA9IDBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChndGx0ID09PSAnPD0nKSB7XG4gICAgICAgIC8vIDw9MC43LnggaXMgYWN0dWFsbHkgPDAuOC4wLCBzaW5jZSBhbnkgMC43Lnggc2hvdWxkXG4gICAgICAgIC8vIHBhc3MuICBTaW1pbGFybHksIDw9Ny54IGlzIGFjdHVhbGx5IDw4LjAuMCwgZXRjLlxuICAgICAgICBndGx0ID0gJzwnXG4gICAgICAgIGlmICh4bSkge1xuICAgICAgICAgIE0gPSArTSArIDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtID0gK20gKyAxXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGd0bHQgPT09ICc8Jykge1xuICAgICAgICBwciA9ICctMCdcbiAgICAgIH1cblxuICAgICAgcmV0ID0gYCR7Z3RsdCArIE19LiR7bX0uJHtwfSR7cHJ9YFxuICAgIH0gZWxzZSBpZiAoeG0pIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uMC4wJHtwcn0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKHhwKSB7XG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7cHJcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9XG5cbiAgICBkZWJ1ZygneFJhbmdlIHJldHVybicsIHJldClcblxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuLy8gQmVjYXVzZSAqIGlzIEFORC1lZCB3aXRoIGV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgY29tcGFyYXRvcixcbi8vIGFuZCAnJyBtZWFucyBcImFueSB2ZXJzaW9uXCIsIGp1c3QgcmVtb3ZlIHRoZSAqcyBlbnRpcmVseS5cbmNvbnN0IHJlcGxhY2VTdGFycyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlU3RhcnMnLCBjb21wLCBvcHRpb25zKVxuICAvLyBMb29zZW5lc3MgaXMgaWdub3JlZCBoZXJlLiAgc3RhciBpcyBhbHdheXMgYXMgbG9vc2UgYXMgaXQgZ2V0cyFcbiAgcmV0dXJuIGNvbXBcbiAgICAudHJpbSgpXG4gICAgLnJlcGxhY2UocmVbdC5TVEFSXSwgJycpXG59XG5cbmNvbnN0IHJlcGxhY2VHVEUwID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ3JlcGxhY2VHVEUwJywgY29tcCwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXBcbiAgICAudHJpbSgpXG4gICAgLnJlcGxhY2UocmVbb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/IHQuR1RFMFBSRSA6IHQuR1RFMF0sICcnKVxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHBhc3NlZCB0byBzdHJpbmcucmVwbGFjZShyZVt0LkhZUEhFTlJBTkdFXSlcbi8vIE0sIG0sIHBhdGNoLCBwcmVyZWxlYXNlLCBidWlsZFxuLy8gMS4yIC0gMy40LjUgPT4gPj0xLjIuMCA8PTMuNC41XG4vLyAxLjIuMyAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMC0wIEFueSAzLjQueCB3aWxsIGRvXG4vLyAxLjIgLSAzLjQgPT4gPj0xLjIuMCA8My41LjAtMFxuY29uc3QgaHlwaGVuUmVwbGFjZSA9IGluY1ByID0+ICgkMCxcbiAgZnJvbSwgZk0sIGZtLCBmcCwgZnByLCBmYixcbiAgdG8sIHRNLCB0bSwgdHAsIHRwciwgdGIpID0+IHtcbiAgaWYgKGlzWChmTSkpIHtcbiAgICBmcm9tID0gJydcbiAgfSBlbHNlIGlmIChpc1goZm0pKSB7XG4gICAgZnJvbSA9IGA+PSR7Zk19LjAuMCR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9IGVsc2UgaWYgKGlzWChmcCkpIHtcbiAgICBmcm9tID0gYD49JHtmTX0uJHtmbX0uMCR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9IGVsc2UgaWYgKGZwcikge1xuICAgIGZyb20gPSBgPj0ke2Zyb219YFxuICB9IGVsc2Uge1xuICAgIGZyb20gPSBgPj0ke2Zyb219JHtpbmNQciA/ICctMCcgOiAnJ31gXG4gIH1cblxuICBpZiAoaXNYKHRNKSkge1xuICAgIHRvID0gJydcbiAgfSBlbHNlIGlmIChpc1godG0pKSB7XG4gICAgdG8gPSBgPCR7K3RNICsgMX0uMC4wLTBgXG4gIH0gZWxzZSBpZiAoaXNYKHRwKSkge1xuICAgIHRvID0gYDwke3RNfS4keyt0bSArIDF9LjAtMGBcbiAgfSBlbHNlIGlmICh0cHIpIHtcbiAgICB0byA9IGA8PSR7dE19LiR7dG19LiR7dHB9LSR7dHByfWBcbiAgfSBlbHNlIGlmIChpbmNQcikge1xuICAgIHRvID0gYDwke3RNfS4ke3RtfS4keyt0cCArIDF9LTBgXG4gIH0gZWxzZSB7XG4gICAgdG8gPSBgPD0ke3RvfWBcbiAgfVxuXG4gIHJldHVybiBgJHtmcm9tfSAke3RvfWAudHJpbSgpXG59XG5cbmNvbnN0IHRlc3RTZXQgPSAoc2V0LCB2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFzZXRbaV0udGVzdCh2ZXJzaW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgaWYgKHZlcnNpb24ucHJlcmVsZWFzZS5sZW5ndGggJiYgIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAvLyBGaW5kIHRoZSBzZXQgb2YgdmVyc2lvbnMgdGhhdCBhcmUgYWxsb3dlZCB0byBoYXZlIHByZXJlbGVhc2VzXG4gICAgLy8gRm9yIGV4YW1wbGUsIF4xLjIuMy1wci4xIGRlc3VnYXJzIHRvID49MS4yLjMtcHIuMSA8Mi4wLjBcbiAgICAvLyBUaGF0IHNob3VsZCBhbGxvdyBgMS4yLjMtcHIuMmAgdG8gcGFzcy5cbiAgICAvLyBIb3dldmVyLCBgMS4yLjQtYWxwaGEubm90cmVhZHlgIHNob3VsZCBOT1QgYmUgYWxsb3dlZCxcbiAgICAvLyBldmVuIHRob3VnaCBpdCdzIHdpdGhpbiB0aGUgcmFuZ2Ugc2V0IGJ5IHRoZSBjb21wYXJhdG9ycy5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgZGVidWcoc2V0W2ldLnNlbXZlcilcbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyID09PSBDb21wYXJhdG9yLkFOWSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAoc2V0W2ldLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IHNldFtpXS5zZW12ZXJcbiAgICAgICAgaWYgKGFsbG93ZWQubWFqb3IgPT09IHZlcnNpb24ubWFqb3IgJiZcbiAgICAgICAgICAgIGFsbG93ZWQubWlub3IgPT09IHZlcnNpb24ubWlub3IgJiZcbiAgICAgICAgICAgIGFsbG93ZWQucGF0Y2ggPT09IHZlcnNpb24ucGF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmVyc2lvbiBoYXMgYSAtcHJlLCBidXQgaXQncyBub3Qgb25lIG9mIHRoZSBvbmVzIHdlIGxpa2UuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwiY29uc3QgQU5ZID0gU3ltYm9sKCdTZW1WZXIgQU5ZJylcbi8vIGhvaXN0ZWQgY2xhc3MgZm9yIGN5Y2xpYyBkZXBlbmRlbmN5XG5jbGFzcyBDb21wYXJhdG9yIHtcbiAgc3RhdGljIGdldCBBTlkgKCkge1xuICAgIHJldHVybiBBTllcbiAgfVxuXG4gIGNvbnN0cnVjdG9yIChjb21wLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgaWYgKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgICBpZiAoY29tcC5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlKSB7XG4gICAgICAgIHJldHVybiBjb21wXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wID0gY29tcC52YWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbXAgPSBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLmpvaW4oJyAnKVxuICAgIGRlYnVnKCdjb21wYXJhdG9yJywgY29tcCwgb3B0aW9ucylcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICAgIHRoaXMucGFyc2UoY29tcClcblxuICAgIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICB0aGlzLnZhbHVlID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMub3BlcmF0b3IgKyB0aGlzLnNlbXZlci52ZXJzaW9uXG4gICAgfVxuXG4gICAgZGVidWcoJ2NvbXAnLCB0aGlzKVxuICB9XG5cbiAgcGFyc2UgKGNvbXApIHtcbiAgICBjb25zdCByID0gdGhpcy5vcHRpb25zLmxvb3NlID8gcmVbdC5DT01QQVJBVE9STE9PU0VdIDogcmVbdC5DT01QQVJBVE9SXVxuICAgIGNvbnN0IG0gPSBjb21wLm1hdGNoKHIpXG5cbiAgICBpZiAoIW0pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgY29tcGFyYXRvcjogJHtjb21wfWApXG4gICAgfVxuXG4gICAgdGhpcy5vcGVyYXRvciA9IG1bMV0gIT09IHVuZGVmaW5lZCA/IG1bMV0gOiAnJ1xuICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSAnPScpIHtcbiAgICAgIHRoaXMub3BlcmF0b3IgPSAnJ1xuICAgIH1cblxuICAgIC8vIGlmIGl0IGxpdGVyYWxseSBpcyBqdXN0ICc+JyBvciAnJyB0aGVuIGFsbG93IGFueXRoaW5nLlxuICAgIGlmICghbVsyXSkge1xuICAgICAgdGhpcy5zZW12ZXIgPSBBTllcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW12ZXIgPSBuZXcgU2VtVmVyKG1bMl0sIHRoaXMub3B0aW9ucy5sb29zZSlcbiAgICB9XG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVcbiAgfVxuXG4gIHRlc3QgKHZlcnNpb24pIHtcbiAgICBkZWJ1ZygnQ29tcGFyYXRvci50ZXN0JywgdmVyc2lvbiwgdGhpcy5vcHRpb25zLmxvb3NlKVxuXG4gICAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkgfHwgdmVyc2lvbiA9PT0gQU5ZKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMub3B0aW9ucylcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbXAodmVyc2lvbiwgdGhpcy5vcGVyYXRvciwgdGhpcy5zZW12ZXIsIHRoaXMub3B0aW9ucylcbiAgfVxuXG4gIGludGVyc2VjdHMgKGNvbXAsIG9wdGlvbnMpIHtcbiAgICBpZiAoIShjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgQ29tcGFyYXRvciBpcyByZXF1aXJlZCcpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgICBpZiAodGhpcy52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmFuZ2UoY29tcC52YWx1ZSwgb3B0aW9ucykudGVzdCh0aGlzLnZhbHVlKVxuICAgIH0gZWxzZSBpZiAoY29tcC5vcGVyYXRvciA9PT0gJycpIHtcbiAgICAgIGlmIChjb21wLnZhbHVlID09PSAnJykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYW5nZSh0aGlzLnZhbHVlLCBvcHRpb25zKS50ZXN0KGNvbXAuc2VtdmVyKVxuICAgIH1cblxuICAgIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucylcblxuICAgIC8vIFNwZWNpYWwgY2FzZXMgd2hlcmUgbm90aGluZyBjYW4gcG9zc2libHkgYmUgbG93ZXJcbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJlxuICAgICAgKHRoaXMudmFsdWUgPT09ICc8MC4wLjAtMCcgfHwgY29tcC52YWx1ZSA9PT0gJzwwLjAuMC0wJykpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiZcbiAgICAgICh0aGlzLnZhbHVlLnN0YXJ0c1dpdGgoJzwwLjAuMCcpIHx8IGNvbXAudmFsdWUuc3RhcnRzV2l0aCgnPDAuMC4wJykpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBTYW1lIGRpcmVjdGlvbiBpbmNyZWFzaW5nICg+IG9yID49KVxuICAgIGlmICh0aGlzLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJz4nKSAmJiBjb21wLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJz4nKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gU2FtZSBkaXJlY3Rpb24gZGVjcmVhc2luZyAoPCBvciA8PSlcbiAgICBpZiAodGhpcy5vcGVyYXRvci5zdGFydHNXaXRoKCc8JykgJiYgY29tcC5vcGVyYXRvci5zdGFydHNXaXRoKCc8JykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIHNhbWUgU2VtVmVyIGFuZCBib3RoIHNpZGVzIGFyZSBpbmNsdXNpdmUgKDw9IG9yID49KVxuICAgIGlmIChcbiAgICAgICh0aGlzLnNlbXZlci52ZXJzaW9uID09PSBjb21wLnNlbXZlci52ZXJzaW9uKSAmJlxuICAgICAgdGhpcy5vcGVyYXRvci5pbmNsdWRlcygnPScpICYmIGNvbXAub3BlcmF0b3IuaW5jbHVkZXMoJz0nKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gb3Bwb3NpdGUgZGlyZWN0aW9ucyBsZXNzIHRoYW5cbiAgICBpZiAoY21wKHRoaXMuc2VtdmVyLCAnPCcsIGNvbXAuc2VtdmVyLCBvcHRpb25zKSAmJlxuICAgICAgdGhpcy5vcGVyYXRvci5zdGFydHNXaXRoKCc+JykgJiYgY29tcC5vcGVyYXRvci5zdGFydHNXaXRoKCc8JykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIG9wcG9zaXRlIGRpcmVjdGlvbnMgZ3JlYXRlciB0aGFuXG4gICAgaWYgKGNtcCh0aGlzLnNlbXZlciwgJz4nLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiZcbiAgICAgIHRoaXMub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPCcpICYmIGNvbXAub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPicpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBhcmF0b3JcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCB7IHNhZmVSZTogcmUsIHQgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcbmNvbnN0IGNtcCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9jbXAnKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4vcmFuZ2UnKVxuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHNhdGlzZmllcyA9ICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICB0cnkge1xuICAgIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiByYW5nZS50ZXN0KHZlcnNpb24pXG59XG5tb2R1bGUuZXhwb3J0cyA9IHNhdGlzZmllc1xuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcblxuLy8gTW9zdGx5IGp1c3QgZm9yIHRlc3RpbmcgYW5kIGxlZ2FjeSBBUEkgcmVhc29uc1xuY29uc3QgdG9Db21wYXJhdG9ycyA9IChyYW5nZSwgb3B0aW9ucykgPT5cbiAgbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKS5zZXRcbiAgICAubWFwKGNvbXAgPT4gY29tcC5tYXAoYyA9PiBjLnZhbHVlKS5qb2luKCcgJykudHJpbSgpLnNwbGl0KCcgJykpXG5cbm1vZHVsZS5leHBvcnRzID0gdG9Db21wYXJhdG9yc1xuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcblxuY29uc3QgbWF4U2F0aXNmeWluZyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgbGV0IG1heCA9IG51bGxcbiAgbGV0IG1heFNWID0gbnVsbFxuICBsZXQgcmFuZ2VPYmogPSBudWxsXG4gIHRyeSB7XG4gICAgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHtcbiAgICAgIC8vIHNhdGlzZmllcyh2LCByYW5nZSwgb3B0aW9ucylcbiAgICAgIGlmICghbWF4IHx8IG1heFNWLmNvbXBhcmUodikgPT09IC0xKSB7XG4gICAgICAgIC8vIGNvbXBhcmUobWF4LCB2LCB0cnVlKVxuICAgICAgICBtYXggPSB2XG4gICAgICAgIG1heFNWID0gbmV3IFNlbVZlcihtYXgsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWF4XG59XG5tb2R1bGUuZXhwb3J0cyA9IG1heFNhdGlzZnlpbmdcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBtaW5TYXRpc2Z5aW5nID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBsZXQgbWluID0gbnVsbFxuICBsZXQgbWluU1YgPSBudWxsXG4gIGxldCByYW5nZU9iaiA9IG51bGxcbiAgdHJ5IHtcbiAgICByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZlcnNpb25zLmZvckVhY2goKHYpID0+IHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkge1xuICAgICAgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtaW4gfHwgbWluU1YuY29tcGFyZSh2KSA9PT0gMSkge1xuICAgICAgICAvLyBjb21wYXJlKG1pbiwgdiwgdHJ1ZSlcbiAgICAgICAgbWluID0gdlxuICAgICAgICBtaW5TViA9IG5ldyBTZW1WZXIobWluLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG1pblxufVxubW9kdWxlLmV4cG9ydHMgPSBtaW5TYXRpc2Z5aW5nXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3QnKVxuXG5jb25zdCBtaW5WZXJzaW9uID0gKHJhbmdlLCBsb29zZSkgPT4ge1xuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpXG5cbiAgbGV0IG1pbnZlciA9IG5ldyBTZW1WZXIoJzAuMC4wJylcbiAgaWYgKHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXJcbiAgfVxuXG4gIG1pbnZlciA9IG5ldyBTZW1WZXIoJzAuMC4wLTAnKVxuICBpZiAocmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgbWludmVyID0gbnVsbFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldXG5cbiAgICBsZXQgc2V0TWluID0gbnVsbFxuICAgIGNvbXBhcmF0b3JzLmZvckVhY2goKGNvbXBhcmF0b3IpID0+IHtcbiAgICAgIC8vIENsb25lIHRvIGF2b2lkIG1hbmlwdWxhdGluZyB0aGUgY29tcGFyYXRvcidzIHNlbXZlciBvYmplY3QuXG4gICAgICBjb25zdCBjb21wdmVyID0gbmV3IFNlbVZlcihjb21wYXJhdG9yLnNlbXZlci52ZXJzaW9uKVxuICAgICAgc3dpdGNoIChjb21wYXJhdG9yLm9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgIGlmIChjb21wdmVyLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb21wdmVyLnBhdGNoKytcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcHZlci5wcmVyZWxlYXNlLnB1c2goMClcbiAgICAgICAgICB9XG4gICAgICAgICAgY29tcHZlci5yYXcgPSBjb21wdmVyLmZvcm1hdCgpXG4gICAgICAgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgIGlmICghc2V0TWluIHx8IGd0KGNvbXB2ZXIsIHNldE1pbikpIHtcbiAgICAgICAgICAgIHNldE1pbiA9IGNvbXB2ZXJcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAvKiBJZ25vcmUgbWF4aW11bSB2ZXJzaW9ucyAqL1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG9wZXJhdGlvbjogJHtjb21wYXJhdG9yLm9wZXJhdG9yfWApXG4gICAgICB9XG4gICAgfSlcbiAgICBpZiAoc2V0TWluICYmICghbWludmVyIHx8IGd0KG1pbnZlciwgc2V0TWluKSkpIHtcbiAgICAgIG1pbnZlciA9IHNldE1pblxuICAgIH1cbiAgfVxuXG4gIGlmIChtaW52ZXIgJiYgcmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gbWluVmVyc2lvblxuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHZhbGlkUmFuZ2UgPSAocmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBSZXR1cm4gJyonIGluc3RlYWQgb2YgJycgc28gdGhhdCB0cnV0aGluZXNzIHdvcmtzLlxuICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiBpdCdzIGludmFsaWQgYW55d2F5XG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucykucmFuZ2UgfHwgJyonXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZFJhbmdlXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBDb21wYXJhdG9yID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9jb21wYXJhdG9yJylcbmNvbnN0IHsgQU5ZIH0gPSBDb21wYXJhdG9yXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcycpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9ndCcpXG5jb25zdCBsdCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9sdCcpXG5jb25zdCBsdGUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvbHRlJylcbmNvbnN0IGd0ZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9ndGUnKVxuXG5jb25zdCBvdXRzaWRlID0gKHZlcnNpb24sIHJhbmdlLCBoaWxvLCBvcHRpb25zKSA9PiB7XG4gIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpXG4gIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuXG4gIGxldCBndGZuLCBsdGVmbiwgbHRmbiwgY29tcCwgZWNvbXBcbiAgc3dpdGNoIChoaWxvKSB7XG4gICAgY2FzZSAnPic6XG4gICAgICBndGZuID0gZ3RcbiAgICAgIGx0ZWZuID0gbHRlXG4gICAgICBsdGZuID0gbHRcbiAgICAgIGNvbXAgPSAnPidcbiAgICAgIGVjb21wID0gJz49J1xuICAgICAgYnJlYWtcbiAgICBjYXNlICc8JzpcbiAgICAgIGd0Zm4gPSBsdFxuICAgICAgbHRlZm4gPSBndGVcbiAgICAgIGx0Zm4gPSBndFxuICAgICAgY29tcCA9ICc8J1xuICAgICAgZWNvbXAgPSAnPD0nXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNdXN0IHByb3ZpZGUgYSBoaWxvIHZhbCBvZiBcIjxcIiBvciBcIj5cIicpXG4gIH1cblxuICAvLyBJZiBpdCBzYXRpc2ZpZXMgdGhlIHJhbmdlIGl0IGlzIG5vdCBvdXRzaWRlXG4gIGlmIChzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBGcm9tIG5vdyBvbiwgdmFyaWFibGUgdGVybXMgYXJlIGFzIGlmIHdlJ3JlIGluIFwiZ3RyXCIgbW9kZS5cbiAgLy8gYnV0IG5vdGUgdGhhdCBldmVyeXRoaW5nIGlzIGZsaXBwZWQgZm9yIHRoZSBcImx0clwiIGZ1bmN0aW9uLlxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV1cblxuICAgIGxldCBoaWdoID0gbnVsbFxuICAgIGxldCBsb3cgPSBudWxsXG5cbiAgICBjb21wYXJhdG9ycy5mb3JFYWNoKChjb21wYXJhdG9yKSA9PiB7XG4gICAgICBpZiAoY29tcGFyYXRvci5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgICBjb21wYXJhdG9yID0gbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKVxuICAgICAgfVxuICAgICAgaGlnaCA9IGhpZ2ggfHwgY29tcGFyYXRvclxuICAgICAgbG93ID0gbG93IHx8IGNvbXBhcmF0b3JcbiAgICAgIGlmIChndGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBoaWdoLnNlbXZlciwgb3B0aW9ucykpIHtcbiAgICAgICAgaGlnaCA9IGNvbXBhcmF0b3JcbiAgICAgIH0gZWxzZSBpZiAobHRmbihjb21wYXJhdG9yLnNlbXZlciwgbG93LnNlbXZlciwgb3B0aW9ucykpIHtcbiAgICAgICAgbG93ID0gY29tcGFyYXRvclxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBJZiB0aGUgZWRnZSB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGEgb3BlcmF0b3IgdGhlbiBvdXIgdmVyc2lvblxuICAgIC8vIGlzbid0IG91dHNpZGUgaXRcbiAgICBpZiAoaGlnaC5vcGVyYXRvciA9PT0gY29tcCB8fCBoaWdoLm9wZXJhdG9yID09PSBlY29tcCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGxvd2VzdCB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGFuIG9wZXJhdG9yIGFuZCBvdXIgdmVyc2lvblxuICAgIC8vIGlzIGxlc3MgdGhhbiBpdCB0aGVuIGl0IGlzbid0IGhpZ2hlciB0aGFuIHRoZSByYW5nZVxuICAgIGlmICgoIWxvdy5vcGVyYXRvciB8fCBsb3cub3BlcmF0b3IgPT09IGNvbXApICYmXG4gICAgICAgIGx0ZWZuKHZlcnNpb24sIGxvdy5zZW12ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2UgaWYgKGxvdy5vcGVyYXRvciA9PT0gZWNvbXAgJiYgbHRmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3V0c2lkZVxuIiwiLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlLlxuY29uc3Qgb3V0c2lkZSA9IHJlcXVpcmUoJy4vb3V0c2lkZScpXG5jb25zdCBndHIgPSAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpID0+IG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc+Jywgb3B0aW9ucylcbm1vZHVsZS5leHBvcnRzID0gZ3RyXG4iLCJjb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9vdXRzaWRlJylcbi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGxlc3MgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZVxuY29uc3QgbHRyID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPCcsIG9wdGlvbnMpXG5tb2R1bGUuZXhwb3J0cyA9IGx0clxuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IGludGVyc2VjdHMgPSAocjEsIHIyLCBvcHRpb25zKSA9PiB7XG4gIHIxID0gbmV3IFJhbmdlKHIxLCBvcHRpb25zKVxuICByMiA9IG5ldyBSYW5nZShyMiwgb3B0aW9ucylcbiAgcmV0dXJuIHIxLmludGVyc2VjdHMocjIsIG9wdGlvbnMpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGludGVyc2VjdHNcbiIsIi8vIGdpdmVuIGEgc2V0IG9mIHZlcnNpb25zIGFuZCBhIHJhbmdlLCBjcmVhdGUgYSBcInNpbXBsaWZpZWRcIiByYW5nZVxuLy8gdGhhdCBpbmNsdWRlcyB0aGUgc2FtZSB2ZXJzaW9ucyB0aGF0IHRoZSBvcmlnaW5hbCByYW5nZSBkb2VzXG4vLyBJZiB0aGUgb3JpZ2luYWwgcmFuZ2UgaXMgc2hvcnRlciB0aGFuIHRoZSBzaW1wbGlmaWVkIG9uZSwgcmV0dXJuIHRoYXQuXG5jb25zdCBzYXRpc2ZpZXMgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzJylcbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvY29tcGFyZS5qcycpXG5tb2R1bGUuZXhwb3J0cyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgc2V0ID0gW11cbiAgbGV0IGZpcnN0ID0gbnVsbFxuICBsZXQgcHJldiA9IG51bGxcbiAgY29uc3QgdiA9IHZlcnNpb25zLnNvcnQoKGEsIGIpID0+IGNvbXBhcmUoYSwgYiwgb3B0aW9ucykpXG4gIGZvciAoY29uc3QgdmVyc2lvbiBvZiB2KSB7XG4gICAgY29uc3QgaW5jbHVkZWQgPSBzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgaWYgKGluY2x1ZGVkKSB7XG4gICAgICBwcmV2ID0gdmVyc2lvblxuICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IHZlcnNpb25cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgc2V0LnB1c2goW2ZpcnN0LCBwcmV2XSlcbiAgICAgIH1cbiAgICAgIHByZXYgPSBudWxsXG4gICAgICBmaXJzdCA9IG51bGxcbiAgICB9XG4gIH1cbiAgaWYgKGZpcnN0KSB7XG4gICAgc2V0LnB1c2goW2ZpcnN0LCBudWxsXSlcbiAgfVxuXG4gIGNvbnN0IHJhbmdlcyA9IFtdXG4gIGZvciAoY29uc3QgW21pbiwgbWF4XSBvZiBzZXQpIHtcbiAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgIHJhbmdlcy5wdXNoKG1pbilcbiAgICB9IGVsc2UgaWYgKCFtYXggJiYgbWluID09PSB2WzBdKSB7XG4gICAgICByYW5nZXMucHVzaCgnKicpXG4gICAgfSBlbHNlIGlmICghbWF4KSB7XG4gICAgICByYW5nZXMucHVzaChgPj0ke21pbn1gKVxuICAgIH0gZWxzZSBpZiAobWluID09PSB2WzBdKSB7XG4gICAgICByYW5nZXMucHVzaChgPD0ke21heH1gKVxuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZXMucHVzaChgJHttaW59IC0gJHttYXh9YClcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2ltcGxpZmllZCA9IHJhbmdlcy5qb2luKCcgfHwgJylcbiAgY29uc3Qgb3JpZ2luYWwgPSB0eXBlb2YgcmFuZ2UucmF3ID09PSAnc3RyaW5nJyA/IHJhbmdlLnJhdyA6IFN0cmluZyhyYW5nZSlcbiAgcmV0dXJuIHNpbXBsaWZpZWQubGVuZ3RoIDwgb3JpZ2luYWwubGVuZ3RoID8gc2ltcGxpZmllZCA6IHJhbmdlXG59XG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UuanMnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvY29tcGFyYXRvci5qcycpXG5jb25zdCB7IEFOWSB9ID0gQ29tcGFyYXRvclxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcy5qcycpXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NvbXBhcmUuanMnKVxuXG4vLyBDb21wbGV4IHJhbmdlIGByMSB8fCByMiB8fCAuLi5gIGlzIGEgc3Vic2V0IG9mIGBSMSB8fCBSMiB8fCAuLi5gIGlmZjpcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgaXMgYSBudWxsIHNldCwgT1Jcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgd2hpY2ggaXMgbm90IGEgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2Zcbi8vICAgc29tZSBgUjEsIFIyLCAuLi5gXG4vL1xuLy8gU2ltcGxlIHJhbmdlIGBjMSBjMiAuLi5gIGlzIGEgc3Vic2V0IG9mIHNpbXBsZSByYW5nZSBgQzEgQzIgLi4uYCBpZmY6XG4vLyAtIElmIGMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBJZiBDIGlzIG9ubHkgdGhlIEFOWSBjb21wYXJhdG9yLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgaWYgaW4gcHJlcmVsZWFzZSBtb2RlLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBlbHNlIHJlcGxhY2UgYyB3aXRoIGBbPj0wLjAuMF1gXG4vLyAtIElmIEMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBpZiBpbiBwcmVyZWxlYXNlIG1vZGUsIHJldHVybiB0cnVlXG4vLyAgIC0gZWxzZSByZXBsYWNlIEMgd2l0aCBgWz49MC4wLjBdYFxuLy8gLSBMZXQgRVEgYmUgdGhlIHNldCBvZiA9IGNvbXBhcmF0b3JzIGluIGNcbi8vIC0gSWYgRVEgaXMgbW9yZSB0aGFuIG9uZSwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gLSBMZXQgR1QgYmUgdGhlIGhpZ2hlc3QgPiBvciA+PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gTGV0IExUIGJlIHRoZSBsb3dlc3QgPCBvciA8PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gSWYgR1QgYW5kIExULCBhbmQgR1Quc2VtdmVyID4gTFQuc2VtdmVyLCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAtIElmIGFueSBDIGlzIGEgPSByYW5nZSwgYW5kIEdUIG9yIExUIGFyZSBzZXQsIHJldHVybiBmYWxzZVxuLy8gLSBJZiBFUVxuLy8gICAtIElmIEdULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBHVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIExULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBMVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIEVRIHNhdGlzZmllcyBldmVyeSBDLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgcmV0dXJuIGZhbHNlXG4vLyAtIElmIEdUXG4vLyAgIC0gSWYgR1Quc2VtdmVyIGlzIGxvd2VyIHRoYW4gYW55ID4gb3IgPj0gY29tcCBpbiBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVCBpcyA+PSwgYW5kIEdULnNlbXZlciBkb2VzIG5vdCBzYXRpc2Z5IGV2ZXJ5IEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIEdULnNlbXZlciBoYXMgYSBwcmVyZWxlYXNlLCBhbmQgbm90IGluIHByZXJlbGVhc2UgbW9kZVxuLy8gICAgIC0gSWYgbm8gQyBoYXMgYSBwcmVyZWxlYXNlIGFuZCB0aGUgR1Quc2VtdmVyIHR1cGxlLCByZXR1cm4gZmFsc2Vcbi8vIC0gSWYgTFRcbi8vICAgLSBJZiBMVC5zZW12ZXIgaXMgZ3JlYXRlciB0aGFuIGFueSA8IG9yIDw9IGNvbXAgaW4gQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgTFQgaXMgPD0sIGFuZCBMVC5zZW12ZXIgZG9lcyBub3Qgc2F0aXNmeSBldmVyeSBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVC5zZW12ZXIgaGFzIGEgcHJlcmVsZWFzZSwgYW5kIG5vdCBpbiBwcmVyZWxlYXNlIG1vZGVcbi8vICAgICAtIElmIG5vIEMgaGFzIGEgcHJlcmVsZWFzZSBhbmQgdGhlIExULnNlbXZlciB0dXBsZSwgcmV0dXJuIGZhbHNlXG4vLyAtIEVsc2UgcmV0dXJuIHRydWVcblxuY29uc3Qgc3Vic2V0ID0gKHN1YiwgZG9tLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKHN1YiA9PT0gZG9tKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHN1YiA9IG5ldyBSYW5nZShzdWIsIG9wdGlvbnMpXG4gIGRvbSA9IG5ldyBSYW5nZShkb20sIG9wdGlvbnMpXG4gIGxldCBzYXdOb25OdWxsID0gZmFsc2VcblxuICBPVVRFUjogZm9yIChjb25zdCBzaW1wbGVTdWIgb2Ygc3ViLnNldCkge1xuICAgIGZvciAoY29uc3Qgc2ltcGxlRG9tIG9mIGRvbS5zZXQpIHtcbiAgICAgIGNvbnN0IGlzU3ViID0gc2ltcGxlU3Vic2V0KHNpbXBsZVN1Yiwgc2ltcGxlRG9tLCBvcHRpb25zKVxuICAgICAgc2F3Tm9uTnVsbCA9IHNhd05vbk51bGwgfHwgaXNTdWIgIT09IG51bGxcbiAgICAgIGlmIChpc1N1Yikge1xuICAgICAgICBjb250aW51ZSBPVVRFUlxuICAgICAgfVxuICAgIH1cbiAgICAvLyB0aGUgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2YgZXZlcnl0aGluZywgYnV0IG51bGwgc2ltcGxlIHJhbmdlcyBpblxuICAgIC8vIGEgY29tcGxleCByYW5nZSBzaG91bGQgYmUgaWdub3JlZC4gIHNvIGlmIHdlIHNhdyBhIG5vbi1udWxsIHJhbmdlLFxuICAgIC8vIHRoZW4gd2Uga25vdyB0aGlzIGlzbid0IGEgc3Vic2V0LCBidXQgaWYgRVZFUlkgc2ltcGxlIHJhbmdlIHdhcyBudWxsLFxuICAgIC8vIHRoZW4gaXQgaXMgYSBzdWJzZXQuXG4gICAgaWYgKHNhd05vbk51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5jb25zdCBtaW5pbXVtVmVyc2lvbldpdGhQcmVSZWxlYXNlID0gW25ldyBDb21wYXJhdG9yKCc+PTAuMC4wLTAnKV1cbmNvbnN0IG1pbmltdW1WZXJzaW9uID0gW25ldyBDb21wYXJhdG9yKCc+PTAuMC4wJyldXG5cbmNvbnN0IHNpbXBsZVN1YnNldCA9IChzdWIsIGRvbSwgb3B0aW9ucykgPT4ge1xuICBpZiAoc3ViID09PSBkb20pIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKHN1Yi5sZW5ndGggPT09IDEgJiYgc3ViWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgaWYgKGRvbS5sZW5ndGggPT09IDEgJiYgZG9tWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgICAgc3ViID0gbWluaW11bVZlcnNpb25XaXRoUHJlUmVsZWFzZVxuICAgIH0gZWxzZSB7XG4gICAgICBzdWIgPSBtaW5pbXVtVmVyc2lvblxuICAgIH1cbiAgfVxuXG4gIGlmIChkb20ubGVuZ3RoID09PSAxICYmIGRvbVswXS5zZW12ZXIgPT09IEFOWSkge1xuICAgIGlmIChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBkb20gPSBtaW5pbXVtVmVyc2lvblxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGVxU2V0ID0gbmV3IFNldCgpXG4gIGxldCBndCwgbHRcbiAgZm9yIChjb25zdCBjIG9mIHN1Yikge1xuICAgIGlmIChjLm9wZXJhdG9yID09PSAnPicgfHwgYy5vcGVyYXRvciA9PT0gJz49Jykge1xuICAgICAgZ3QgPSBoaWdoZXJHVChndCwgYywgb3B0aW9ucylcbiAgICB9IGVsc2UgaWYgKGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nKSB7XG4gICAgICBsdCA9IGxvd2VyTFQobHQsIGMsIG9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGVxU2V0LmFkZChjLnNlbXZlcilcbiAgICB9XG4gIH1cblxuICBpZiAoZXFTZXQuc2l6ZSA+IDEpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgbGV0IGd0bHRDb21wXG4gIGlmIChndCAmJiBsdCkge1xuICAgIGd0bHRDb21wID0gY29tcGFyZShndC5zZW12ZXIsIGx0LnNlbXZlciwgb3B0aW9ucylcbiAgICBpZiAoZ3RsdENvbXAgPiAwKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0gZWxzZSBpZiAoZ3RsdENvbXAgPT09IDAgJiYgKGd0Lm9wZXJhdG9yICE9PSAnPj0nIHx8IGx0Lm9wZXJhdG9yICE9PSAnPD0nKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICAvLyB3aWxsIGl0ZXJhdGUgb25lIG9yIHplcm8gdGltZXNcbiAgZm9yIChjb25zdCBlcSBvZiBlcVNldCkge1xuICAgIGlmIChndCAmJiAhc2F0aXNmaWVzKGVxLCBTdHJpbmcoZ3QpLCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBpZiAobHQgJiYgIXNhdGlzZmllcyhlcSwgU3RyaW5nKGx0KSwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBjIG9mIGRvbSkge1xuICAgICAgaWYgKCFzYXRpc2ZpZXMoZXEsIFN0cmluZyhjKSwgb3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGxldCBoaWdoZXIsIGxvd2VyXG4gIGxldCBoYXNEb21MVCwgaGFzRG9tR1RcbiAgLy8gaWYgdGhlIHN1YnNldCBoYXMgYSBwcmVyZWxlYXNlLCB3ZSBuZWVkIGEgY29tcGFyYXRvciBpbiB0aGUgc3VwZXJzZXRcbiAgLy8gd2l0aCB0aGUgc2FtZSB0dXBsZSBhbmQgYSBwcmVyZWxlYXNlLCBvciBpdCdzIG5vdCBhIHN1YnNldFxuICBsZXQgbmVlZERvbUxUUHJlID0gbHQgJiZcbiAgICAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJlxuICAgIGx0LnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA/IGx0LnNlbXZlciA6IGZhbHNlXG4gIGxldCBuZWVkRG9tR1RQcmUgPSBndCAmJlxuICAgICFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgZ3Quc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID8gZ3Quc2VtdmVyIDogZmFsc2VcbiAgLy8gZXhjZXB0aW9uOiA8MS4yLjMtMCBpcyB0aGUgc2FtZSBhcyA8MS4yLjNcbiAgaWYgKG5lZWREb21MVFByZSAmJiBuZWVkRG9tTFRQcmUucHJlcmVsZWFzZS5sZW5ndGggPT09IDEgJiZcbiAgICAgIGx0Lm9wZXJhdG9yID09PSAnPCcgJiYgbmVlZERvbUxUUHJlLnByZXJlbGVhc2VbMF0gPT09IDApIHtcbiAgICBuZWVkRG9tTFRQcmUgPSBmYWxzZVxuICB9XG5cbiAgZm9yIChjb25zdCBjIG9mIGRvbSkge1xuICAgIGhhc0RvbUdUID0gaGFzRG9tR1QgfHwgYy5vcGVyYXRvciA9PT0gJz4nIHx8IGMub3BlcmF0b3IgPT09ICc+PSdcbiAgICBoYXNEb21MVCA9IGhhc0RvbUxUIHx8IGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nXG4gICAgaWYgKGd0KSB7XG4gICAgICBpZiAobmVlZERvbUdUUHJlKSB7XG4gICAgICAgIGlmIChjLnNlbXZlci5wcmVyZWxlYXNlICYmIGMuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICBjLnNlbXZlci5tYWpvciA9PT0gbmVlZERvbUdUUHJlLm1ham9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5taW5vciA9PT0gbmVlZERvbUdUUHJlLm1pbm9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5wYXRjaCA9PT0gbmVlZERvbUdUUHJlLnBhdGNoKSB7XG4gICAgICAgICAgbmVlZERvbUdUUHJlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGMub3BlcmF0b3IgPT09ICc+JyB8fCBjLm9wZXJhdG9yID09PSAnPj0nKSB7XG4gICAgICAgIGhpZ2hlciA9IGhpZ2hlckdUKGd0LCBjLCBvcHRpb25zKVxuICAgICAgICBpZiAoaGlnaGVyID09PSBjICYmIGhpZ2hlciAhPT0gZ3QpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChndC5vcGVyYXRvciA9PT0gJz49JyAmJiAhc2F0aXNmaWVzKGd0LnNlbXZlciwgU3RyaW5nKGMpLCBvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGx0KSB7XG4gICAgICBpZiAobmVlZERvbUxUUHJlKSB7XG4gICAgICAgIGlmIChjLnNlbXZlci5wcmVyZWxlYXNlICYmIGMuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICBjLnNlbXZlci5tYWpvciA9PT0gbmVlZERvbUxUUHJlLm1ham9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5taW5vciA9PT0gbmVlZERvbUxUUHJlLm1pbm9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5wYXRjaCA9PT0gbmVlZERvbUxUUHJlLnBhdGNoKSB7XG4gICAgICAgICAgbmVlZERvbUxUUHJlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nKSB7XG4gICAgICAgIGxvd2VyID0gbG93ZXJMVChsdCwgYywgb3B0aW9ucylcbiAgICAgICAgaWYgKGxvd2VyID09PSBjICYmIGxvd2VyICE9PSBsdCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGx0Lm9wZXJhdG9yID09PSAnPD0nICYmICFzYXRpc2ZpZXMobHQuc2VtdmVyLCBTdHJpbmcoYyksIG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWMub3BlcmF0b3IgJiYgKGx0IHx8IGd0KSAmJiBndGx0Q29tcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlcmUgd2FzIGEgPCBvciA+LCBhbmQgbm90aGluZyBpbiB0aGUgZG9tLCB0aGVuIG11c3QgYmUgZmFsc2VcbiAgLy8gVU5MRVNTIGl0IHdhcyBsaW1pdGVkIGJ5IGFub3RoZXIgcmFuZ2UgaW4gdGhlIG90aGVyIGRpcmVjdGlvbi5cbiAgLy8gRWcsID4xLjAuMCA8MS4wLjEgaXMgc3RpbGwgYSBzdWJzZXQgb2YgPDIuMC4wXG4gIGlmIChndCAmJiBoYXNEb21MVCAmJiAhbHQgJiYgZ3RsdENvbXAgIT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChsdCAmJiBoYXNEb21HVCAmJiAhZ3QgJiYgZ3RsdENvbXAgIT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIHdlIG5lZWRlZCBhIHByZXJlbGVhc2UgcmFuZ2UgaW4gYSBzcGVjaWZpYyB0dXBsZSwgYnV0IGRpZG4ndCBnZXQgb25lXG4gIC8vIHRoZW4gdGhpcyBpc24ndCBhIHN1YnNldC4gIGVnID49MS4yLjMtcHJlIGlzIG5vdCBhIHN1YnNldCBvZiA+PTEuMC4wLFxuICAvLyBiZWNhdXNlIGl0IGluY2x1ZGVzIHByZXJlbGVhc2VzIGluIHRoZSAxLjIuMyB0dXBsZVxuICBpZiAobmVlZERvbUdUUHJlIHx8IG5lZWREb21MVFByZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gPj0xLjIuMyBpcyBsb3dlciB0aGFuID4xLjIuM1xuY29uc3QgaGlnaGVyR1QgPSAoYSwgYiwgb3B0aW9ucykgPT4ge1xuICBpZiAoIWEpIHtcbiAgICByZXR1cm4gYlxuICB9XG4gIGNvbnN0IGNvbXAgPSBjb21wYXJlKGEuc2VtdmVyLCBiLnNlbXZlciwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAgPiAwID8gYVxuICAgIDogY29tcCA8IDAgPyBiXG4gICAgOiBiLm9wZXJhdG9yID09PSAnPicgJiYgYS5vcGVyYXRvciA9PT0gJz49JyA/IGJcbiAgICA6IGFcbn1cblxuLy8gPD0xLjIuMyBpcyBoaWdoZXIgdGhhbiA8MS4yLjNcbmNvbnN0IGxvd2VyTFQgPSAoYSwgYiwgb3B0aW9ucykgPT4ge1xuICBpZiAoIWEpIHtcbiAgICByZXR1cm4gYlxuICB9XG4gIGNvbnN0IGNvbXAgPSBjb21wYXJlKGEuc2VtdmVyLCBiLnNlbXZlciwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAgPCAwID8gYVxuICAgIDogY29tcCA+IDAgPyBiXG4gICAgOiBiLm9wZXJhdG9yID09PSAnPCcgJiYgYS5vcGVyYXRvciA9PT0gJzw9JyA/IGJcbiAgICA6IGFcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdWJzZXRcbiIsIi8vIGp1c3QgcHJlLWxvYWQgYWxsIHRoZSBzdHVmZiB0aGF0IGluZGV4LmpzIGxhemlseSBleHBvcnRzXG5jb25zdCBpbnRlcm5hbFJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9yZScpXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2ludGVybmFsL2NvbnN0YW50cycpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IGlkZW50aWZpZXJzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9pZGVudGlmaWVycycpXG5jb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3BhcnNlJylcbmNvbnN0IHZhbGlkID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvdmFsaWQnKVxuY29uc3QgY2xlYW4gPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jbGVhbicpXG5jb25zdCBpbmMgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9pbmMnKVxuY29uc3QgZGlmZiA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2RpZmYnKVxuY29uc3QgbWFqb3IgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9tYWpvcicpXG5jb25zdCBtaW5vciA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL21pbm9yJylcbmNvbnN0IHBhdGNoID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvcGF0Y2gnKVxuY29uc3QgcHJlcmVsZWFzZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3ByZXJlbGVhc2UnKVxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvbXBhcmUnKVxuY29uc3QgcmNvbXBhcmUgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9yY29tcGFyZScpXG5jb25zdCBjb21wYXJlTG9vc2UgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb21wYXJlLWxvb3NlJylcbmNvbnN0IGNvbXBhcmVCdWlsZCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvbXBhcmUtYnVpbGQnKVxuY29uc3Qgc29ydCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3NvcnQnKVxuY29uc3QgcnNvcnQgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9yc29ydCcpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2d0JylcbmNvbnN0IGx0ID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvbHQnKVxuY29uc3QgZXEgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9lcScpXG5jb25zdCBuZXEgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9uZXEnKVxuY29uc3QgZ3RlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvZ3RlJylcbmNvbnN0IGx0ZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2x0ZScpXG5jb25zdCBjbXAgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jbXAnKVxuY29uc3QgY29lcmNlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29lcmNlJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuL2NsYXNzZXMvY29tcGFyYXRvcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBzYXRpc2ZpZXMgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9zYXRpc2ZpZXMnKVxuY29uc3QgdG9Db21wYXJhdG9ycyA9IHJlcXVpcmUoJy4vcmFuZ2VzL3RvLWNvbXBhcmF0b3JzJylcbmNvbnN0IG1heFNhdGlzZnlpbmcgPSByZXF1aXJlKCcuL3Jhbmdlcy9tYXgtc2F0aXNmeWluZycpXG5jb25zdCBtaW5TYXRpc2Z5aW5nID0gcmVxdWlyZSgnLi9yYW5nZXMvbWluLXNhdGlzZnlpbmcnKVxuY29uc3QgbWluVmVyc2lvbiA9IHJlcXVpcmUoJy4vcmFuZ2VzL21pbi12ZXJzaW9uJylcbmNvbnN0IHZhbGlkUmFuZ2UgPSByZXF1aXJlKCcuL3Jhbmdlcy92YWxpZCcpXG5jb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9yYW5nZXMvb3V0c2lkZScpXG5jb25zdCBndHIgPSByZXF1aXJlKCcuL3Jhbmdlcy9ndHInKVxuY29uc3QgbHRyID0gcmVxdWlyZSgnLi9yYW5nZXMvbHRyJylcbmNvbnN0IGludGVyc2VjdHMgPSByZXF1aXJlKCcuL3Jhbmdlcy9pbnRlcnNlY3RzJylcbmNvbnN0IHNpbXBsaWZ5UmFuZ2UgPSByZXF1aXJlKCcuL3Jhbmdlcy9zaW1wbGlmeScpXG5jb25zdCBzdWJzZXQgPSByZXF1aXJlKCcuL3Jhbmdlcy9zdWJzZXQnKVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlLFxuICB2YWxpZCxcbiAgY2xlYW4sXG4gIGluYyxcbiAgZGlmZixcbiAgbWFqb3IsXG4gIG1pbm9yLFxuICBwYXRjaCxcbiAgcHJlcmVsZWFzZSxcbiAgY29tcGFyZSxcbiAgcmNvbXBhcmUsXG4gIGNvbXBhcmVMb29zZSxcbiAgY29tcGFyZUJ1aWxkLFxuICBzb3J0LFxuICByc29ydCxcbiAgZ3QsXG4gIGx0LFxuICBlcSxcbiAgbmVxLFxuICBndGUsXG4gIGx0ZSxcbiAgY21wLFxuICBjb2VyY2UsXG4gIENvbXBhcmF0b3IsXG4gIFJhbmdlLFxuICBzYXRpc2ZpZXMsXG4gIHRvQ29tcGFyYXRvcnMsXG4gIG1heFNhdGlzZnlpbmcsXG4gIG1pblNhdGlzZnlpbmcsXG4gIG1pblZlcnNpb24sXG4gIHZhbGlkUmFuZ2UsXG4gIG91dHNpZGUsXG4gIGd0cixcbiAgbHRyLFxuICBpbnRlcnNlY3RzLFxuICBzaW1wbGlmeVJhbmdlLFxuICBzdWJzZXQsXG4gIFNlbVZlcixcbiAgcmU6IGludGVybmFsUmUucmUsXG4gIHNyYzogaW50ZXJuYWxSZS5zcmMsXG4gIHRva2VuczogaW50ZXJuYWxSZS50LFxuICBTRU1WRVJfU1BFQ19WRVJTSU9OOiBjb25zdGFudHMuU0VNVkVSX1NQRUNfVkVSU0lPTixcbiAgUkVMRUFTRV9UWVBFUzogY29uc3RhbnRzLlJFTEVBU0VfVFlQRVMsXG4gIGNvbXBhcmVJZGVudGlmaWVyczogaWRlbnRpZmllcnMuY29tcGFyZUlkZW50aWZpZXJzLFxuICByY29tcGFyZUlkZW50aWZpZXJzOiBpZGVudGlmaWVycy5yY29tcGFyZUlkZW50aWZpZXJzLFxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBtaW1pY0ZuID0gKHRvLCBmcm9tKSA9PiB7XG5cdGZvciAoY29uc3QgcHJvcCBvZiBSZWZsZWN0Lm93bktleXMoZnJvbSkpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodG8sIHByb3AsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZnJvbSwgcHJvcCkpO1xuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtaW1pY0ZuO1xuLy8gVE9ETzogUmVtb3ZlIHRoaXMgZm9yIHRoZSBuZXh0IG1ham9yIHJlbGVhc2Vcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtaW1pY0ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgbWltaWNGbiA9IHJlcXVpcmUoJ21pbWljLWZuJyk7XG5cbmNvbnN0IGNhbGxlZEZ1bmN0aW9ucyA9IG5ldyBXZWFrTWFwKCk7XG5cbmNvbnN0IG9uZXRpbWUgPSAoZnVuY3Rpb25fLCBvcHRpb25zID0ge30pID0+IHtcblx0aWYgKHR5cGVvZiBmdW5jdGlvbl8gIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIGZ1bmN0aW9uJyk7XG5cdH1cblxuXHRsZXQgcmV0dXJuVmFsdWU7XG5cdGxldCBjYWxsQ291bnQgPSAwO1xuXHRjb25zdCBmdW5jdGlvbk5hbWUgPSBmdW5jdGlvbl8uZGlzcGxheU5hbWUgfHwgZnVuY3Rpb25fLm5hbWUgfHwgJzxhbm9ueW1vdXM+JztcblxuXHRjb25zdCBvbmV0aW1lID0gZnVuY3Rpb24gKC4uLmFyZ3VtZW50c18pIHtcblx0XHRjYWxsZWRGdW5jdGlvbnMuc2V0KG9uZXRpbWUsICsrY2FsbENvdW50KTtcblxuXHRcdGlmIChjYWxsQ291bnQgPT09IDEpIHtcblx0XHRcdHJldHVyblZhbHVlID0gZnVuY3Rpb25fLmFwcGx5KHRoaXMsIGFyZ3VtZW50c18pO1xuXHRcdFx0ZnVuY3Rpb25fID0gbnVsbDtcblx0XHR9IGVsc2UgaWYgKG9wdGlvbnMudGhyb3cgPT09IHRydWUpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgRnVuY3Rpb24gXFxgJHtmdW5jdGlvbk5hbWV9XFxgIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlYCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldHVyblZhbHVlO1xuXHR9O1xuXG5cdG1pbWljRm4ob25ldGltZSwgZnVuY3Rpb25fKTtcblx0Y2FsbGVkRnVuY3Rpb25zLnNldChvbmV0aW1lLCBjYWxsQ291bnQpO1xuXG5cdHJldHVybiBvbmV0aW1lO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBvbmV0aW1lO1xuLy8gVE9ETzogUmVtb3ZlIHRoaXMgZm9yIHRoZSBuZXh0IG1ham9yIHJlbGVhc2Vcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBvbmV0aW1lO1xuXG5tb2R1bGUuZXhwb3J0cy5jYWxsQ291bnQgPSBmdW5jdGlvbl8gPT4ge1xuXHRpZiAoIWNhbGxlZEZ1bmN0aW9ucy5oYXMoZnVuY3Rpb25fKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihgVGhlIGdpdmVuIGZ1bmN0aW9uIFxcYCR7ZnVuY3Rpb25fLm5hbWV9XFxgIGlzIG5vdCB3cmFwcGVkIGJ5IHRoZSBcXGBvbmV0aW1lXFxgIHBhY2thZ2VgKTtcblx0fVxuXG5cdHJldHVybiBjYWxsZWRGdW5jdGlvbnMuZ2V0KGZ1bmN0aW9uXyk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX2EsIF9iO1xudmFyIF9Db25mX3ZhbGlkYXRvciwgX0NvbmZfZW5jcnlwdGlvbktleSwgX0NvbmZfb3B0aW9ucywgX0NvbmZfZGVmYXVsdFZhbHVlcztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IGRvdFByb3AgPSByZXF1aXJlKFwiZG90LXByb3BcIik7XG5jb25zdCBwa2dVcCA9IHJlcXVpcmUoXCJwa2ctdXBcIik7XG5jb25zdCBlbnZQYXRocyA9IHJlcXVpcmUoXCJlbnYtcGF0aHNcIik7XG5jb25zdCBhdG9taWNhbGx5ID0gcmVxdWlyZShcImF0b21pY2FsbHlcIik7XG5jb25zdCBhanZfMSA9IHJlcXVpcmUoXCJhanZcIik7XG5jb25zdCBhanZfZm9ybWF0c18xID0gcmVxdWlyZShcImFqdi1mb3JtYXRzXCIpO1xuY29uc3QgZGVib3VuY2VGbiA9IHJlcXVpcmUoXCJkZWJvdW5jZS1mblwiKTtcbmNvbnN0IHNlbXZlciA9IHJlcXVpcmUoXCJzZW12ZXJcIik7XG5jb25zdCBvbmV0aW1lID0gcmVxdWlyZShcIm9uZXRpbWVcIik7XG5jb25zdCBlbmNyeXB0aW9uQWxnb3JpdGhtID0gJ2Flcy0yNTYtY2JjJztcbmNvbnN0IGNyZWF0ZVBsYWluT2JqZWN0ID0gKCkgPT4ge1xuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xufTtcbmNvbnN0IGlzRXhpc3QgPSAoZGF0YSkgPT4ge1xuICAgIHJldHVybiBkYXRhICE9PSB1bmRlZmluZWQgJiYgZGF0YSAhPT0gbnVsbDtcbn07XG5sZXQgcGFyZW50RGlyID0gJyc7XG50cnkge1xuICAgIC8vIFByZXZlbnQgY2FjaGluZyBvZiB0aGlzIG1vZHVsZSBzbyBtb2R1bGUucGFyZW50IGlzIGFsd2F5cyBhY2N1cmF0ZS5cbiAgICAvLyBOb3RlOiBUaGlzIHRyaWNrIHdvbid0IHdvcmsgd2l0aCBFU00gb3IgaW5zaWRlIGEgd2Vid29ya2VyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1keW5hbWljLWRlbGV0ZVxuICAgIGRlbGV0ZSByZXF1aXJlLmNhY2hlW19fZmlsZW5hbWVdO1xuICAgIHBhcmVudERpciA9IHBhdGguZGlybmFtZSgoX2IgPSAoX2EgPSBtb2R1bGUucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlsZW5hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcuJyk7XG59XG5jYXRjaCAoX2MpIHsgfVxuY29uc3QgY2hlY2tWYWx1ZVR5cGUgPSAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IG5vbkpzb25UeXBlcyA9IG5ldyBTZXQoW1xuICAgICAgICAndW5kZWZpbmVkJyxcbiAgICAgICAgJ3N5bWJvbCcsXG4gICAgICAgICdmdW5jdGlvbidcbiAgICBdKTtcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGlmIChub25Kc29uVHlwZXMuaGFzKHR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFNldHRpbmcgYSB2YWx1ZSBvZiB0eXBlIFxcYCR7dHlwZX1cXGAgZm9yIGtleSBcXGAke2tleX1cXGAgaXMgbm90IGFsbG93ZWQgYXMgaXQncyBub3Qgc3VwcG9ydGVkIGJ5IEpTT05gKTtcbiAgICB9XG59O1xuY29uc3QgSU5URVJOQUxfS0VZID0gJ19faW50ZXJuYWxfXyc7XG5jb25zdCBNSUdSQVRJT05fS0VZID0gYCR7SU5URVJOQUxfS0VZfS5taWdyYXRpb25zLnZlcnNpb25gO1xuY2xhc3MgQ29uZiB7XG4gICAgY29uc3RydWN0b3IocGFydGlhbE9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIF9Db25mX3ZhbGlkYXRvci5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0NvbmZfZW5jcnlwdGlvbktleS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0NvbmZfb3B0aW9ucy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0NvbmZfZGVmYXVsdFZhbHVlcy5zZXQodGhpcywge30pO1xuICAgICAgICB0aGlzLl9kZXNlcmlhbGl6ZSA9IHZhbHVlID0+IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICB0aGlzLl9zZXJpYWxpemUgPSB2YWx1ZSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgdW5kZWZpbmVkLCAnXFx0Jyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBjb25maWdOYW1lOiAnY29uZmlnJyxcbiAgICAgICAgICAgIGZpbGVFeHRlbnNpb246ICdqc29uJyxcbiAgICAgICAgICAgIHByb2plY3RTdWZmaXg6ICdub2RlanMnLFxuICAgICAgICAgICAgY2xlYXJJbnZhbGlkQ29uZmlnOiBmYWxzZSxcbiAgICAgICAgICAgIGFjY2Vzc1Byb3BlcnRpZXNCeURvdE5vdGF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlnRmlsZU1vZGU6IDBvNjY2LFxuICAgICAgICAgICAgLi4ucGFydGlhbE9wdGlvbnNcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZ2V0UGFja2FnZURhdGEgPSBvbmV0aW1lKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhY2thZ2VQYXRoID0gcGtnVXAuc3luYyh7IGN3ZDogcGFyZW50RGlyIH0pO1xuICAgICAgICAgICAgLy8gQ2FuJ3QgdXNlIGByZXF1aXJlYCBiZWNhdXNlIG9mIFdlYnBhY2sgYmVpbmcgYW5ub3lpbmc6XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrL2lzc3Vlcy8xOTZcbiAgICAgICAgICAgIGNvbnN0IHBhY2thZ2VEYXRhID0gcGFja2FnZVBhdGggJiYgSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMocGFja2FnZVBhdGgsICd1dGY4JykpO1xuICAgICAgICAgICAgcmV0dXJuIHBhY2thZ2VEYXRhICE9PSBudWxsICYmIHBhY2thZ2VEYXRhICE9PSB2b2lkIDAgPyBwYWNrYWdlRGF0YSA6IHt9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFvcHRpb25zLmN3ZCkge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnByb2plY3ROYW1lKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wcm9qZWN0TmFtZSA9IGdldFBhY2thZ2VEYXRhKCkubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wcm9qZWN0TmFtZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvamVjdCBuYW1lIGNvdWxkIG5vdCBiZSBpbmZlcnJlZC4gUGxlYXNlIHNwZWNpZnkgdGhlIGBwcm9qZWN0TmFtZWAgb3B0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy5jd2QgPSBlbnZQYXRocyhvcHRpb25zLnByb2plY3ROYW1lLCB7IHN1ZmZpeDogb3B0aW9ucy5wcm9qZWN0U3VmZml4IH0pLmNvbmZpZztcbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Db25mX29wdGlvbnMsIG9wdGlvbnMsIFwiZlwiKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2NoZW1hKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuc2NoZW1hICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBgc2NoZW1hYCBvcHRpb24gbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhanYgPSBuZXcgYWp2XzEuZGVmYXVsdCh7XG4gICAgICAgICAgICAgICAgYWxsRXJyb3JzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHVzZURlZmF1bHRzOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICgwLCBhanZfZm9ybWF0c18xLmRlZmF1bHQpKGFqdik7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogb3B0aW9ucy5zY2hlbWFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Db25mX3ZhbGlkYXRvciwgYWp2LmNvbXBpbGUoc2NoZW1hKSwgXCJmXCIpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0aW9ucy5zY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZGVmYXVsdFZhbHVlcywgXCJmXCIpW2tleV0gPSB2YWx1ZS5kZWZhdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ29uZl9kZWZhdWx0VmFsdWVzLCB7XG4gICAgICAgICAgICAgICAgLi4uX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9kZWZhdWx0VmFsdWVzLCBcImZcIiksXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5kZWZhdWx0c1xuICAgICAgICAgICAgfSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnNlcmlhbGl6ZSkge1xuICAgICAgICAgICAgdGhpcy5fc2VyaWFsaXplID0gb3B0aW9ucy5zZXJpYWxpemU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZGVzZXJpYWxpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rlc2VyaWFsaXplID0gb3B0aW9ucy5kZXNlcmlhbGl6ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyBldmVudHNfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBvcHRpb25zLmVuY3J5cHRpb25LZXksIFwiZlwiKTtcbiAgICAgICAgY29uc3QgZmlsZUV4dGVuc2lvbiA9IG9wdGlvbnMuZmlsZUV4dGVuc2lvbiA/IGAuJHtvcHRpb25zLmZpbGVFeHRlbnNpb259YCA6ICcnO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoLnJlc29sdmUob3B0aW9ucy5jd2QsIGAkeyhfYSA9IG9wdGlvbnMuY29uZmlnTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ2NvbmZpZyd9JHtmaWxlRXh0ZW5zaW9ufWApO1xuICAgICAgICBjb25zdCBmaWxlU3RvcmUgPSB0aGlzLnN0b3JlO1xuICAgICAgICBjb25zdCBzdG9yZSA9IE9iamVjdC5hc3NpZ24oY3JlYXRlUGxhaW5PYmplY3QoKSwgb3B0aW9ucy5kZWZhdWx0cywgZmlsZVN0b3JlKTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGUoc3RvcmUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChmaWxlU3RvcmUsIHN0b3JlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2IpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy53YXRjaCkge1xuICAgICAgICAgICAgdGhpcy5fd2F0Y2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5taWdyYXRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMucHJvamVjdFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnByb2plY3RWZXJzaW9uID0gZ2V0UGFja2FnZURhdGEoKS52ZXJzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnByb2plY3RWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0IHZlcnNpb24gY291bGQgbm90IGJlIGluZmVycmVkLiBQbGVhc2Ugc3BlY2lmeSB0aGUgYHByb2plY3RWZXJzaW9uYCBvcHRpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9taWdyYXRlKG9wdGlvbnMubWlncmF0aW9ucywgb3B0aW9ucy5wcm9qZWN0VmVyc2lvbiwgb3B0aW9ucy5iZWZvcmVFYWNoTWlncmF0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfb3B0aW9ucywgXCJmXCIpLmFjY2Vzc1Byb3BlcnRpZXNCeURvdE5vdGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0KGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0b3JlIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ga2V5IGluIHN0b3JlID8gc3RvcmVba2V5XSA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBrZXkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBrZXlcXGAgdG8gYmUgb2YgdHlwZSBcXGBzdHJpbmdcXGAgb3IgXFxgb2JqZWN0XFxgLCBnb3QgJHt0eXBlb2Yga2V5fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnb2JqZWN0JyAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVc2UgYGRlbGV0ZSgpYCB0byBjbGVhciB2YWx1ZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY29udGFpbnNSZXNlcnZlZEtleShrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQbGVhc2UgZG9uJ3QgdXNlIHRoZSAke0lOVEVSTkFMX0tFWX0ga2V5LCBhcyBpdCdzIHVzZWQgdG8gbWFuYWdlIHRoaXMgbW9kdWxlIGludGVybmFsIG9wZXJhdGlvbnMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdG9yZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc2V0ID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNoZWNrVmFsdWVUeXBlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfb3B0aW9ucywgXCJmXCIpLmFjY2Vzc1Byb3BlcnRpZXNCeURvdE5vdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZG90UHJvcC5zZXQoc3RvcmUsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RvcmVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdCA9IGtleTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICBzZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayBpZiBhbiBpdGVtIGV4aXN0cy5cblxuICAgIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIGNoZWNrLlxuICAgICovXG4gICAgaGFzKGtleSkge1xuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9vcHRpb25zLCBcImZcIikuYWNjZXNzUHJvcGVydGllc0J5RG90Tm90YXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBkb3RQcm9wLmhhcyh0aGlzLnN0b3JlLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXkgaW4gdGhpcy5zdG9yZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVzZXQgaXRlbXMgdG8gdGhlaXIgZGVmYXVsdCB2YWx1ZXMsIGFzIGRlZmluZWQgYnkgdGhlIGBkZWZhdWx0c2Agb3IgYHNjaGVtYWAgb3B0aW9uLlxuXG4gICAgQHNlZSBgY2xlYXIoKWAgdG8gcmVzZXQgYWxsIGl0ZW1zLlxuXG4gICAgQHBhcmFtIGtleXMgLSBUaGUga2V5cyBvZiB0aGUgaXRlbXMgdG8gcmVzZXQuXG4gICAgKi9cbiAgICByZXNldCguLi5rZXlzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIGlmIChpc0V4aXN0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZGVmYXVsdFZhbHVlcywgXCJmXCIpW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX2RlZmF1bHRWYWx1ZXMsIFwiZlwiKVtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBEZWxldGUgYW4gaXRlbS5cblxuICAgIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIGRlbGV0ZS5cbiAgICAqL1xuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgY29uc3QgeyBzdG9yZSB9ID0gdGhpcztcbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfb3B0aW9ucywgXCJmXCIpLmFjY2Vzc1Byb3BlcnRpZXNCeURvdE5vdGF0aW9uKSB7XG4gICAgICAgICAgICBkb3RQcm9wLmRlbGV0ZShzdG9yZSwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGVcbiAgICAgICAgICAgIGRlbGV0ZSBzdG9yZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVsZXRlIGFsbCBpdGVtcy5cblxuICAgIFRoaXMgcmVzZXRzIGtub3duIGl0ZW1zIHRvIHRoZWlyIGRlZmF1bHQgdmFsdWVzLCBpZiBkZWZpbmVkIGJ5IHRoZSBgZGVmYXVsdHNgIG9yIGBzY2hlbWFgIG9wdGlvbi5cbiAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnN0b3JlID0gY3JlYXRlUGxhaW5PYmplY3QoKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9kZWZhdWx0VmFsdWVzLCBcImZcIikpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgV2F0Y2hlcyB0aGUgZ2l2ZW4gYGtleWAsIGNhbGxpbmcgYGNhbGxiYWNrYCBvbiBhbnkgY2hhbmdlcy5cblxuICAgIEBwYXJhbSBrZXkgLSBUaGUga2V5IHdvIHdhdGNoLlxuICAgIEBwYXJhbSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgb24gYW55IGNoYW5nZXMuIFdoZW4gYSBga2V5YCBpcyBmaXJzdCBzZXQgYG9sZFZhbHVlYCB3aWxsIGJlIGB1bmRlZmluZWRgLCBhbmQgd2hlbiBhIGtleSBpcyBkZWxldGVkIGBuZXdWYWx1ZWAgd2lsbCBiZSBgdW5kZWZpbmVkYC5cbiAgICBAcmV0dXJucyBBIGZ1bmN0aW9uLCB0aGF0IHdoZW4gY2FsbGVkLCB3aWxsIHVuc3Vic2NyaWJlLlxuICAgICovXG4gICAgb25EaWRDaGFuZ2Uoa2V5LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFxcYGtleVxcYCB0byBiZSBvZiB0eXBlIFxcYHN0cmluZ1xcYCwgZ290ICR7dHlwZW9mIGtleX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBjYWxsYmFja1xcYCB0byBiZSBvZiB0eXBlIFxcYGZ1bmN0aW9uXFxgLCBnb3QgJHt0eXBlb2YgY2FsbGJhY2t9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUNoYW5nZSgoKSA9PiB0aGlzLmdldChrZXkpLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgIFdhdGNoZXMgdGhlIHdob2xlIGNvbmZpZyBvYmplY3QsIGNhbGxpbmcgYGNhbGxiYWNrYCBvbiBhbnkgY2hhbmdlcy5cblxuICAgIEBwYXJhbSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgb24gYW55IGNoYW5nZXMuIFdoZW4gYSBga2V5YCBpcyBmaXJzdCBzZXQgYG9sZFZhbHVlYCB3aWxsIGJlIGB1bmRlZmluZWRgLCBhbmQgd2hlbiBhIGtleSBpcyBkZWxldGVkIGBuZXdWYWx1ZWAgd2lsbCBiZSBgdW5kZWZpbmVkYC5cbiAgICBAcmV0dXJucyBBIGZ1bmN0aW9uLCB0aGF0IHdoZW4gY2FsbGVkLCB3aWxsIHVuc3Vic2NyaWJlLlxuICAgICovXG4gICAgb25EaWRBbnlDaGFuZ2UoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgY2FsbGJhY2tcXGAgdG8gYmUgb2YgdHlwZSBcXGBmdW5jdGlvblxcYCwgZ290ICR7dHlwZW9mIGNhbGxiYWNrfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVDaGFuZ2UoKCkgPT4gdGhpcy5zdG9yZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc3RvcmUpLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0IHN0b3JlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGZzLnJlYWRGaWxlU3luYyh0aGlzLnBhdGgsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZW5jcnlwdGlvbktleSwgXCJmXCIpID8gbnVsbCA6ICd1dGY4Jyk7XG4gICAgICAgICAgICBjb25zdCBkYXRhU3RyaW5nID0gdGhpcy5fZW5jcnlwdERhdGEoZGF0YSk7XG4gICAgICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZWREYXRhID0gdGhpcy5fZGVzZXJpYWxpemUoZGF0YVN0cmluZyk7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0ZShkZXNlcmlhbGl6ZWREYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGNyZWF0ZVBsYWluT2JqZWN0KCksIGRlc2VyaWFsaXplZERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IuY29kZSkgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5zdXJlRGlyZWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVBsYWluT2JqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9vcHRpb25zLCBcImZcIikuY2xlYXJJbnZhbGlkQ29uZmlnICYmIGVycm9yLm5hbWUgPT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUGxhaW5PYmplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldCBzdG9yZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9lbnN1cmVEaXJlY3RvcnkoKTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGUodmFsdWUpO1xuICAgICAgICB0aGlzLl93cml0ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ2NoYW5nZScpO1xuICAgIH1cbiAgICAqWyhfQ29uZl92YWxpZGF0b3IgPSBuZXcgV2Vha01hcCgpLCBfQ29uZl9lbmNyeXB0aW9uS2V5ID0gbmV3IFdlYWtNYXAoKSwgX0NvbmZfb3B0aW9ucyA9IG5ldyBXZWFrTWFwKCksIF9Db25mX2RlZmF1bHRWYWx1ZXMgPSBuZXcgV2Vha01hcCgpLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5zdG9yZSkpIHtcbiAgICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZW5jcnlwdERhdGEoZGF0YSkge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZW5jcnlwdGlvbktleSwgXCJmXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBhbiBpbml0aWFsaXphdGlvbiB2ZWN0b3IgaGFzIGJlZW4gdXNlZCB0byBlbmNyeXB0IHRoZSBkYXRhXG4gICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBcImZcIikpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5zbGljZSgxNiwgMTcpLnRvU3RyaW5nKCkgPT09ICc6Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhbGl6YXRpb25WZWN0b3IgPSBkYXRhLnNsaWNlKDAsIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhc3N3b3JkID0gY3J5cHRvLnBia2RmMlN5bmMoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBcImZcIiksIGluaXRpYWxpemF0aW9uVmVjdG9yLnRvU3RyaW5nKCksIDEwMDAwLCAzMiwgJ3NoYTUxMicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihlbmNyeXB0aW9uQWxnb3JpdGhtLCBwYXNzd29yZCwgaW5pdGlhbGl6YXRpb25WZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IEJ1ZmZlci5jb25jYXQoW2RlY2lwaGVyLnVwZGF0ZShCdWZmZXIuZnJvbShkYXRhLnNsaWNlKDE3KSkpLCBkZWNpcGhlci5maW5hbCgpXSkudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcihlbmNyeXB0aW9uQWxnb3JpdGhtLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX2VuY3J5cHRpb25LZXksIFwiZlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gQnVmZmVyLmNvbmNhdChbZGVjaXBoZXIudXBkYXRlKEJ1ZmZlci5mcm9tKGRhdGEpKSwgZGVjaXBoZXIuZmluYWwoKV0pLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2IpIHsgfVxuICAgICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cbiAgICBfaGFuZGxlQ2hhbmdlKGdldHRlciwgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IGN1cnJlbnRWYWx1ZSA9IGdldHRlcigpO1xuICAgICAgICBjb25zdCBvbkNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBnZXR0ZXIoKTtcbiAgICAgICAgICAgIGlmICgoMCwgdXRpbF8xLmlzRGVlcFN0cmljdEVxdWFsKShuZXdWYWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB0aGlzLmV2ZW50cy5yZW1vdmVMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIH1cbiAgICBfdmFsaWRhdGUoZGF0YSkge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfdmFsaWRhdG9yLCBcImZcIikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfdmFsaWRhdG9yLCBcImZcIikuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICAgICAgaWYgKHZhbGlkIHx8ICFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX3ZhbGlkYXRvciwgXCJmXCIpLmVycm9ycykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfdmFsaWRhdG9yLCBcImZcIikuZXJyb3JzXG4gICAgICAgICAgICAubWFwKCh7IGluc3RhbmNlUGF0aCwgbWVzc2FnZSA9ICcnIH0pID0+IGBcXGAke2luc3RhbmNlUGF0aC5zbGljZSgxKX1cXGAgJHttZXNzYWdlfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmZpZyBzY2hlbWEgdmlvbGF0aW9uOiAnICsgZXJyb3JzLmpvaW4oJzsgJykpO1xuICAgIH1cbiAgICBfZW5zdXJlRGlyZWN0b3J5KCkge1xuICAgICAgICAvLyBFbnN1cmUgdGhlIGRpcmVjdG9yeSBleGlzdHMgYXMgaXQgY291bGQgaGF2ZSBiZWVuIGRlbGV0ZWQgaW4gdGhlIG1lYW50aW1lLlxuICAgICAgICBmcy5ta2RpclN5bmMocGF0aC5kaXJuYW1lKHRoaXMucGF0aCksIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIH1cbiAgICBfd3JpdGUodmFsdWUpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLl9zZXJpYWxpemUodmFsdWUpO1xuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBcImZcIikpIHtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxpemF0aW9uVmVjdG9yID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KTtcbiAgICAgICAgICAgIGNvbnN0IHBhc3N3b3JkID0gY3J5cHRvLnBia2RmMlN5bmMoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBcImZcIiksIGluaXRpYWxpemF0aW9uVmVjdG9yLnRvU3RyaW5nKCksIDEwMDAwLCAzMiwgJ3NoYTUxMicpO1xuICAgICAgICAgICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KGVuY3J5cHRpb25BbGdvcml0aG0sIHBhc3N3b3JkLCBpbml0aWFsaXphdGlvblZlY3Rvcik7XG4gICAgICAgICAgICBkYXRhID0gQnVmZmVyLmNvbmNhdChbaW5pdGlhbGl6YXRpb25WZWN0b3IsIEJ1ZmZlci5mcm9tKCc6JyksIGNpcGhlci51cGRhdGUoQnVmZmVyLmZyb20oZGF0YSkpLCBjaXBoZXIuZmluYWwoKV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlbXBvcmFyeSB3b3JrYXJvdW5kIGZvciBDb25mIGJlaW5nIHBhY2thZ2VkIGluIGEgVWJ1bnR1IFNuYXAgYXBwLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9jb25mL3B1bGwvODJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52LlNOQVApIHtcbiAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmModGhpcy5wYXRoLCBkYXRhLCB7IG1vZGU6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfb3B0aW9ucywgXCJmXCIpLmNvbmZpZ0ZpbGVNb2RlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhdG9taWNhbGx5LndyaXRlRmlsZVN5bmModGhpcy5wYXRoLCBkYXRhLCB7IG1vZGU6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfb3B0aW9ucywgXCJmXCIpLmNvbmZpZ0ZpbGVNb2RlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gRml4IGZvciBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2VsZWN0cm9uLXN0b3JlL2lzc3Vlcy8xMDZcbiAgICAgICAgICAgICAgICAvLyBTb21ldGltZXMgb24gV2luZG93cywgd2Ugd2lsbCBnZXQgYW4gRVhERVYgZXJyb3Igd2hlbiBhdG9taWMgd3JpdGluZ1xuICAgICAgICAgICAgICAgIC8vIChldmVuIHRob3VnaCB0byB0aGUgc2FtZSBkaXJlY3RvcnkpLCBzbyB3ZSBmYWxsIGJhY2sgdG8gbm9uIGF0b21pYyB3cml0ZVxuICAgICAgICAgICAgICAgIGlmICgoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLmNvZGUpID09PSAnRVhERVYnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmModGhpcy5wYXRoLCBkYXRhLCB7IG1vZGU6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfb3B0aW9ucywgXCJmXCIpLmNvbmZpZ0ZpbGVNb2RlIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF93YXRjaCgpIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlRGlyZWN0b3J5KCk7XG4gICAgICAgIGlmICghZnMuZXhpc3RzU3luYyh0aGlzLnBhdGgpKSB7XG4gICAgICAgICAgICB0aGlzLl93cml0ZShjcmVhdGVQbGFpbk9iamVjdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgICAgICAgICAgZnMud2F0Y2godGhpcy5wYXRoLCB7IHBlcnNpc3RlbnQ6IGZhbHNlIH0sIGRlYm91bmNlRm4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIE9uIExpbnV4IGFuZCBXaW5kb3dzLCB3cml0aW5nIHRvIHRoZSBjb25maWcgZmlsZSBlbWl0cyBhIGByZW5hbWVgIGV2ZW50LCBzbyB3ZSBza2lwIGNoZWNraW5nIHRoZSBldmVudCB0eXBlLlxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ2NoYW5nZScpO1xuICAgICAgICAgICAgfSwgeyB3YWl0OiAxMDAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnMud2F0Y2hGaWxlKHRoaXMucGF0aCwgeyBwZXJzaXN0ZW50OiBmYWxzZSB9LCBkZWJvdW5jZUZuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KCdjaGFuZ2UnKTtcbiAgICAgICAgICAgIH0sIHsgd2FpdDogNTAwMCB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX21pZ3JhdGUobWlncmF0aW9ucywgdmVyc2lvblRvTWlncmF0ZSwgYmVmb3JlRWFjaE1pZ3JhdGlvbikge1xuICAgICAgICBsZXQgcHJldmlvdXNNaWdyYXRlZFZlcnNpb24gPSB0aGlzLl9nZXQoTUlHUkFUSU9OX0tFWSwgJzAuMC4wJyk7XG4gICAgICAgIGNvbnN0IG5ld2VyVmVyc2lvbnMgPSBPYmplY3Qua2V5cyhtaWdyYXRpb25zKVxuICAgICAgICAgICAgLmZpbHRlcihjYW5kaWRhdGVWZXJzaW9uID0+IHRoaXMuX3Nob3VsZFBlcmZvcm1NaWdyYXRpb24oY2FuZGlkYXRlVmVyc2lvbiwgcHJldmlvdXNNaWdyYXRlZFZlcnNpb24sIHZlcnNpb25Ub01pZ3JhdGUpKTtcbiAgICAgICAgbGV0IHN0b3JlQmFja3VwID0geyAuLi50aGlzLnN0b3JlIH07XG4gICAgICAgIGZvciAoY29uc3QgdmVyc2lvbiBvZiBuZXdlclZlcnNpb25zKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChiZWZvcmVFYWNoTWlncmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2hNaWdyYXRpb24odGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbVZlcnNpb246IHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9WZXJzaW9uOiB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxWZXJzaW9uOiB2ZXJzaW9uVG9NaWdyYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbnM6IG5ld2VyVmVyc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG1pZ3JhdGlvbiA9IG1pZ3JhdGlvbnNbdmVyc2lvbl07XG4gICAgICAgICAgICAgICAgbWlncmF0aW9uKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldChNSUdSQVRJT05fS0VZLCB2ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c01pZ3JhdGVkVmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgICAgICAgc3RvcmVCYWNrdXAgPSB7IC4uLnRoaXMuc3RvcmUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZUJhY2t1cDtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyB0aGUgbWlncmF0aW9uISBDaGFuZ2VzIGFwcGxpZWQgdG8gdGhlIHN0b3JlIHVudGlsIHRoaXMgZmFpbGVkIG1pZ3JhdGlvbiB3aWxsIGJlIHJlc3RvcmVkLiAke2Vycm9yfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pc1ZlcnNpb25JblJhbmdlRm9ybWF0KHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uKSB8fCAhc2VtdmVyLmVxKHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uLCB2ZXJzaW9uVG9NaWdyYXRlKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0KE1JR1JBVElPTl9LRVksIHZlcnNpb25Ub01pZ3JhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jb250YWluc1Jlc2VydmVkS2V5KGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnNLZXkgPSBPYmplY3Qua2V5cyhrZXkpWzBdO1xuICAgICAgICAgICAgaWYgKGZpcnNLZXkgPT09IElOVEVSTkFMX0tFWSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX29wdGlvbnMsIFwiZlwiKS5hY2Nlc3NQcm9wZXJ0aWVzQnlEb3ROb3RhdGlvbikge1xuICAgICAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKGAke0lOVEVSTkFMX0tFWX0uYCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9pc1ZlcnNpb25JblJhbmdlRm9ybWF0KHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHNlbXZlci5jbGVhbih2ZXJzaW9uKSA9PT0gbnVsbDtcbiAgICB9XG4gICAgX3Nob3VsZFBlcmZvcm1NaWdyYXRpb24oY2FuZGlkYXRlVmVyc2lvbiwgcHJldmlvdXNNaWdyYXRlZFZlcnNpb24sIHZlcnNpb25Ub01pZ3JhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVmVyc2lvbkluUmFuZ2VGb3JtYXQoY2FuZGlkYXRlVmVyc2lvbikpIHtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c01pZ3JhdGVkVmVyc2lvbiAhPT0gJzAuMC4wJyAmJiBzZW12ZXIuc2F0aXNmaWVzKHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uLCBjYW5kaWRhdGVWZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZW12ZXIuc2F0aXNmaWVzKHZlcnNpb25Ub01pZ3JhdGUsIGNhbmRpZGF0ZVZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZW12ZXIubHRlKGNhbmRpZGF0ZVZlcnNpb24sIHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZW12ZXIuZ3QoY2FuZGlkYXRlVmVyc2lvbiwgdmVyc2lvblRvTWlncmF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX2dldChrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gZG90UHJvcC5nZXQodGhpcy5zdG9yZSwga2V5LCBkZWZhdWx0VmFsdWUpO1xuICAgIH1cbiAgICBfc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgeyBzdG9yZSB9ID0gdGhpcztcbiAgICAgICAgZG90UHJvcC5zZXQoc3RvcmUsIGtleSwgdmFsdWUpO1xuICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ29uZjtcbi8vIEZvciBDb21tb25KUyBkZWZhdWx0IGV4cG9ydCBzdXBwb3J0XG5tb2R1bGUuZXhwb3J0cyA9IENvbmY7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQ29uZjtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCB7YXBwLCBpcGNNYWluLCBpcGNSZW5kZXJlciwgc2hlbGx9ID0gcmVxdWlyZSgnZWxlY3Ryb24nKTtcbmNvbnN0IENvbmYgPSByZXF1aXJlKCdjb25mJyk7XG5cbmxldCBpc0luaXRpYWxpemVkID0gZmFsc2U7XG5cbi8vIFNldCB1cCB0aGUgYGlwY01haW5gIGhhbmRsZXIgZm9yIGNvbW11bmljYXRpb24gYmV0d2VlbiByZW5kZXJlciBhbmQgbWFpbiBwcm9jZXNzLlxuY29uc3QgaW5pdERhdGFMaXN0ZW5lciA9ICgpID0+IHtcblx0aWYgKCFpcGNNYWluIHx8ICFhcHApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0VsZWN0cm9uIFN0b3JlOiBZb3UgbmVlZCB0byBjYWxsIGAuaW5pdFJlbmRlcmVyKClgIGZyb20gdGhlIG1haW4gcHJvY2Vzcy4nKTtcblx0fVxuXG5cdGNvbnN0IGFwcERhdGEgPSB7XG5cdFx0ZGVmYXVsdEN3ZDogYXBwLmdldFBhdGgoJ3VzZXJEYXRhJyksXG5cdFx0YXBwVmVyc2lvbjogYXBwLmdldFZlcnNpb24oKVxuXHR9O1xuXG5cdGlmIChpc0luaXRpYWxpemVkKSB7XG5cdFx0cmV0dXJuIGFwcERhdGE7XG5cdH1cblxuXHRpcGNNYWluLm9uKCdlbGVjdHJvbi1zdG9yZS1nZXQtZGF0YScsIGV2ZW50ID0+IHtcblx0XHRldmVudC5yZXR1cm5WYWx1ZSA9IGFwcERhdGE7XG5cdH0pO1xuXG5cdGlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG5cdHJldHVybiBhcHBEYXRhO1xufTtcblxuY2xhc3MgRWxlY3Ryb25TdG9yZSBleHRlbmRzIENvbmYge1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0bGV0IGRlZmF1bHRDd2Q7XG5cdFx0bGV0IGFwcFZlcnNpb247XG5cblx0XHQvLyBJZiB3ZSBhcmUgaW4gdGhlIHJlbmRlcmVyIHByb2Nlc3MsIHdlIGNvbW11bmljYXRlIHdpdGggdGhlIG1haW4gcHJvY2Vzc1xuXHRcdC8vIHRvIGdldCB0aGUgcmVxdWlyZWQgZGF0YSBmb3IgdGhlIG1vZHVsZSBvdGhlcndpc2UsIHdlIHB1bGwgZnJvbSB0aGUgbWFpbiBwcm9jZXNzLlxuXHRcdGlmIChpcGNSZW5kZXJlcikge1xuXHRcdFx0Y29uc3QgYXBwRGF0YSA9IGlwY1JlbmRlcmVyLnNlbmRTeW5jKCdlbGVjdHJvbi1zdG9yZS1nZXQtZGF0YScpO1xuXG5cdFx0XHRpZiAoIWFwcERhdGEpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFbGVjdHJvbiBTdG9yZTogWW91IG5lZWQgdG8gY2FsbCBgLmluaXRSZW5kZXJlcigpYCBmcm9tIHRoZSBtYWluIHByb2Nlc3MuJyk7XG5cdFx0XHR9XG5cblx0XHRcdCh7ZGVmYXVsdEN3ZCwgYXBwVmVyc2lvbn0gPSBhcHBEYXRhKTtcblx0XHR9IGVsc2UgaWYgKGlwY01haW4gJiYgYXBwKSB7XG5cdFx0XHQoe2RlZmF1bHRDd2QsIGFwcFZlcnNpb259ID0gaW5pdERhdGFMaXN0ZW5lcigpKTtcblx0XHR9XG5cblx0XHRvcHRpb25zID0ge1xuXHRcdFx0bmFtZTogJ2NvbmZpZycsXG5cdFx0XHQuLi5vcHRpb25zXG5cdFx0fTtcblxuXHRcdGlmICghb3B0aW9ucy5wcm9qZWN0VmVyc2lvbikge1xuXHRcdFx0b3B0aW9ucy5wcm9qZWN0VmVyc2lvbiA9IGFwcFZlcnNpb247XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuY3dkKSB7XG5cdFx0XHRvcHRpb25zLmN3ZCA9IHBhdGguaXNBYnNvbHV0ZShvcHRpb25zLmN3ZCkgPyBvcHRpb25zLmN3ZCA6IHBhdGguam9pbihkZWZhdWx0Q3dkLCBvcHRpb25zLmN3ZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9wdGlvbnMuY3dkID0gZGVmYXVsdEN3ZDtcblx0XHR9XG5cblx0XHRvcHRpb25zLmNvbmZpZ05hbWUgPSBvcHRpb25zLm5hbWU7XG5cdFx0ZGVsZXRlIG9wdGlvbnMubmFtZTtcblxuXHRcdHN1cGVyKG9wdGlvbnMpO1xuXHR9XG5cblx0c3RhdGljIGluaXRSZW5kZXJlcigpIHtcblx0XHRpbml0RGF0YUxpc3RlbmVyKCk7XG5cdH1cblxuXHRvcGVuSW5FZGl0b3IoKSB7XG5cdFx0c2hlbGwub3BlblBhdGgodGhpcy5wYXRoKTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVsZWN0cm9uU3RvcmU7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1taXhlZC1zcGFjZXMtYW5kLXRhYnMgKi9cbmltcG9ydCBTdG9yZSBmcm9tICdlbGVjdHJvbi1zdG9yZSc7XG5cbmNvbnN0IHNjaGVtYSA9IHtcblx0bm90ZXM6IHtcblx0XHR0eXBlOiAnb2JqZWN0JyxcbiAgICBwYXR0ZXJuUHJvcGVydGllczoge1xuICAgICAgJ1tBLVphLXowLTlfLV0nOiB7XG4gICAgICBcdHR5cGU6ICdvYmplY3QnLFxuICAgICAgXHRwcm9wZXJ0aWVzOiB7XG4gICAgICBcdFx0aWQ6IHsgdHlwZTogJ3N0cmluZycsIGRlZmF1bHQ6ICcnIH0sXG4gICAgICBcdFx0dGl0bGU6IHsgdHlwZTogJ3N0cmluZycsIGRlZmF1bHQ6ICcnIH0sXG4gICAgICBcdFx0Y29udGVudDogeyB0eXBlOiAnb2JqZWN0JywgZGVmYXVsdDogeyB0eXBlOiAnZG9jJywgY29udGVudDogW10gfSB9LFxuICAgICAgXHRcdGxhYmVsczogeyB0eXBlOiAnYXJyYXknLCBkZWZhdWx0OiBbXSB9LFxuICAgICAgXHRcdGNyZWF0ZWRBdDogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogRGF0ZS5ub3coKSB9LFxuICAgICAgXHRcdHVwZGF0ZWRBdDogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogRGF0ZS5ub3coKSB9LFxuICAgICAgXHRcdGlzQm9va21hcmtlZDogeyB0eXBlOiAnYm9vbGVhbicsIGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICBcdFx0aXNBcmNoaXZlZDogeyB0eXBlOiAnYm9vbGVhbicsIGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgICAgbGFzdEN1cnNvclBvc2l0aW9uOiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAwIH0sXG4gICAgICBcdH0sXG4gICAgICB9LFxuICAgIH0sXG5cdH0sXG4gIGxhYmVsczoge1xuICAgIHR5cGU6ICdhcnJheScsXG4gIH0sXG59O1xuXG5jb25zdCBzdG9yZSA9IG5ldyBTdG9yZSh7XG5cdHNjaGVtYSxcbiAgZW5jcnlwdGlvbktleTogaW1wb3J0Lm1ldGEuZW52LlZJVEVfRU5DUllQVF9LRVksXG59KTtcblxuLy8gc3RvcmUub25EaWRDaGFuZ2UoJ25vdGVzJywgKHZhbHVlKSA9PiB7XG4vLyAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbi8vIH0pO1xuXG5leHBvcnQgZGVmYXVsdCBzdG9yZTtcbiIsImltcG9ydCBTdG9yZSBmcm9tICdlbGVjdHJvbi1zdG9yZSc7XG5pbXBvcnQgeyBhcHAgfSBmcm9tICdlbGVjdHJvbic7XG5cbmNvbnN0IHNjaGVtYSA9IHtcblx0ZGF0YURpcjoge1xuXHRcdHR5cGU6ICdzdHJpbmcnLFxuXHRcdGRlZmF1bHQ6IGFwcC5nZXRQYXRoKCd1c2VyRGF0YScpLFxuXHR9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgbmV3IFN0b3JlKHsgbmFtZTogJ3NldHRpbmdzJywgc2NoZW1hLCBlbmNyeXB0aW9uS2V5OiBwcm9jZXNzLmVudi5WSVRFX0VOQ1JZUFRfS0VZIH0pO1xuIiwiaW1wb3J0IGRhdGEgZnJvbSAnLi9tb2R1bGVzL2RhdGEuc3RvcmUnO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4vbW9kdWxlcy9zZXR0aW5ncy5zdG9yZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblx0ZGF0YSxcblx0c2V0dGluZ3MsXG59O1xuIiwiaW1wb3J0IHsgYXBwLCBCcm93c2VyV2luZG93LCBkaWFsb2csIHByb3RvY29sLCBuYXRpdmVUaGVtZSwgc2hlbGwgfSBmcm9tICdlbGVjdHJvbic7XG5pbXBvcnQgeyBpcGNNYWluIH0gZnJvbSAnZWxlY3Ryb24tYmV0dGVyLWlwYyc7XG5pbXBvcnQgeyBqb2luLCBub3JtYWxpemUgfSBmcm9tICdwYXRoJztcbmltcG9ydCB7IFVSTCB9IGZyb20gJ3VybCc7XG5pbXBvcnQgeyByZW1vdmUsIHJlYWRKc29uLCBlbnN1cmVEaXIsIGNvcHksIG91dHB1dEpzb24sIHBhdGhFeGlzdHNTeW5jIH0gZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHN0b3JlIGZyb20gJy4vc3RvcmUnO1xuXG5jb25zdCBpc1NpbmdsZUluc3RhbmNlID0gYXBwLnJlcXVlc3RTaW5nbGVJbnN0YW5jZUxvY2soKTtcblxuaWYgKCFpc1NpbmdsZUluc3RhbmNlKSB7XG4gIGFwcC5xdWl0KCk7XG4gIHByb2Nlc3MuZXhpdCgwKTtcbn1cblxuYXBwLmRpc2FibGVIYXJkd2FyZUFjY2VsZXJhdGlvbigpO1xuXG4vKipcbiAqIFdvcmthcm91bmQgZm9yIFR5cGVTY3JpcHQgYnVnXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvNDE0NjgjaXNzdWVjb21tZW50LTcyNzU0MzQwMFxuICovXG5jb25zdCBlbnYgPSBpbXBvcnQubWV0YS5lbnY7XG5cbmxldCBtYWluV2luZG93ID0gbnVsbDtcblxuY29uc3QgY3JlYXRlV2luZG93ID0gYXN5bmMgKCkgPT4ge1xuICBtYWluV2luZG93ID0gbmV3IEJyb3dzZXJXaW5kb3coe1xuICAgIHNob3c6IGZhbHNlLFxuICAgIHdpZHRoOiA5NTAsXG4gICAgaGVpZ2h0OiA2MDAsXG4gICAgd2ViUHJlZmVyZW5jZXM6IHtcbiAgICAgIHByZWxvYWQ6IGpvaW4oX19kaXJuYW1lLCAnLi4vLi4vcHJlbG9hZC9kaXN0L2luZGV4LmNqcycpLFxuICAgICAgY29udGV4dElzb2xhdGlvbjogZW52Lk1PREUgIT09ICd0ZXN0JyxcbiAgICAgIGVuYWJsZVJlbW90ZU1vZHVsZTogZW52Lk1PREUgPT09ICd0ZXN0JyxcbiAgICAgIG5vZGVJbnRlZ3JhdGlvbjogdHJ1ZSxcbiAgICB9LFxuICB9KTtcblxuICBtYWluV2luZG93LnNldE1lbnVCYXJWaXNpYmlsaXR5KGZhbHNlKTtcblxuICBtYWluV2luZG93Lm9uKCdyZWFkeS10by1zaG93JywgKCkgPT4ge1xuICAgIG1haW5XaW5kb3c/LnNob3coKTtcblxuICAgIGlmIChlbnYuTU9ERSA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgbWFpbldpbmRvdz8ud2ViQ29udGVudHMub3BlbkRldlRvb2xzKCk7XG4gICAgfVxuICB9KTtcblxuICBtYWluV2luZG93Py53ZWJDb250ZW50cy5vbignbmV3LXdpbmRvdycsIGZ1bmN0aW9uKGV2ZW50LCB1cmwpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgaWYgKHVybC5zdGFydHNXaXRoKCdub3RlOi8vJykpIHJldHVybjtcblxuICAgIHNoZWxsLm9wZW5FeHRlcm5hbCh1cmwpO1xuICB9KTtcblxuICBjb25zdCBwYWdlVXJsID0gZW52Lk1PREUgPT09ICdkZXZlbG9wbWVudCdcbiAgICA/IGVudi5WSVRFX0RFVl9TRVJWRVJfVVJMXG4gICAgOiBuZXcgVVJMKCcuLi9yZW5kZXJlci9kaXN0L2luZGV4Lmh0bWwnLCAnZmlsZTovLycgKyBfX2Rpcm5hbWUpLnRvU3RyaW5nKCk7XG5cbiAgYXdhaXQgbWFpbldpbmRvdy5sb2FkVVJMKHBhZ2VVcmwpO1xufTtcblxuYXBwLm9uKCdOU0FwcGxpY2F0aW9uRGVsZWdhdGUuYXBwbGljYXRpb25TdXBwb3J0c1NlY3VyZVJlc3RvcmFibGVTdGF0ZScsICgpID0+IHtcbiAgcmV0dXJuIHRydWU7XG59KTtcblxuYXBwLm9uKCdzZWNvbmQtaW5zdGFuY2UnLCAoKSA9PiB7XG4gIGlmIChtYWluV2luZG93KSB7XG4gICAgaWYgKG1haW5XaW5kb3cuaXNNaW5pbWl6ZWQoKSkgbWFpbldpbmRvdy5yZXN0b3JlKCk7XG4gICAgbWFpbldpbmRvdy5mb2N1cygpO1xuICB9XG59KTtcblxuYXBwLm9uKCd3aW5kb3ctYWxsLWNsb3NlZCcsICgpID0+IHtcbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gIT09ICdkYXJ3aW4nKSB7XG4gICAgYXBwLnF1aXQoKTtcbiAgfVxufSk7XG5cbmFwcC53aGVuUmVhZHkoKVxuICAudGhlbihhc3luYyAoKSA9PiB7XG4gICAgcHJvdG9jb2wucmVnaXN0ZXJGaWxlUHJvdG9jb2woJ2Fzc2V0cycsIChyZXF1ZXN0LCBjYWxsYmFjaykgPT4ge1xuICAgICAgY29uc3QgdXJsID0gcmVxdWVzdC51cmwuc3Vic3RyKDkpO1xuXG4gICAgICBjb25zdCBkaXIgPSBzdG9yZS5zZXR0aW5ncy5nZXQoJ2RhdGFEaXInKTtcbiAgICAgIGNvbnN0IGltZ1BhdGggPSBgJHtkaXJ9L25vdGVzLWFzc2V0cy8ke3VybH1gO1xuXG4gICAgICBjYWxsYmFjayh7IHBhdGg6IG5vcm1hbGl6ZShpbWdQYXRoKSB9KTtcbiAgICB9KTtcblxuICAgIGF3YWl0IGVuc3VyZURpcihqb2luKGFwcC5nZXRQYXRoKCd1c2VyRGF0YScpLCAnbm90ZXMtYXNzZXRzJykpO1xuICAgIGF3YWl0IGNyZWF0ZVdpbmRvdygpO1xuICB9KVxuICAuY2F0Y2goKGUpID0+IGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCBjcmVhdGUgd2luZG93OicsIGUpKTtcblxuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignYXBwOmluZm8nLCAoKSA9PiAoe1xuICBuYW1lOiBhcHAuZ2V0TmFtZSgpLFxuICB2ZXJzaW9uOiBhcHAuZ2V0VmVyc2lvbigpLFxufSkpO1xuXG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdkaWFsb2c6b3BlbicsIChwcm9wcykgPT4gZGlhbG9nLnNob3dPcGVuRGlhbG9nKHByb3BzKSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdkaWFsb2c6bWVzc2FnZScsIChwcm9wcykgPT4gZGlhbG9nLnNob3dNZXNzYWdlQm94KHByb3BzKSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdkaWFsb2c6c2F2ZScsIChwcm9wcykgPT4gZGlhbG9nLnNob3dTYXZlRGlhbG9nKHByb3BzKSk7XG5cbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2ZzOmNvcHknLCAoeyBwYXRoLCBkZXN0IH0pID0+IGNvcHkocGF0aCwgZGVzdCkpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignZnM6b3V0cHV0LWpzb24nLCAoeyBwYXRoLCBkYXRhIH0pID0+IG91dHB1dEpzb24ocGF0aCwgZGF0YSkpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignZnM6cmVhZC1qc29uJywgKHBhdGgpID0+IHJlYWRKc29uKHBhdGgpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2ZzOmVuc3VyZURpcicsIChwYXRoKSA9PiBlbnN1cmVEaXIocGF0aCkpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignZnM6cGF0aEV4aXN0cycsIChwYXRoKSA9PiBwYXRoRXhpc3RzU3luYyhwYXRoKSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdmczpyZW1vdmUnLCAocGF0aCkgPT4gcmVtb3ZlKHBhdGgpKTtcblxuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignaGVscGVyOnJlbGF1bmNoJywgKG9wdGlvbnMgPSB7fSkgPT4ge1xuICBhcHAucmVsYXVuY2goeyBhcmdzOiBwcm9jZXNzLmFyZ3Yuc2xpY2UoMSkuY29uY2F0KFsnLS1yZWxhdW5jaCddKSwgLi4ub3B0aW9ucyB9KTtcbiAgYXBwLmV4aXQoMCk7XG59KTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2hlbHBlcjpnZXQtcGF0aCcsIChuYW1lKSA9PiBhcHAuZ2V0UGF0aChuYW1lKSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdoZWxwZXI6aXMtZGFyay10aGVtZScsICgpID0+IG5hdGl2ZVRoZW1lLnNob3VsZFVzZURhcmtDb2xvcnMpO1xuXG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdzdG9yYWdlOnN0b3JlJywgKG5hbWUpID0+IHN0b3JlW25hbWVdPy5zdG9yZSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdzdG9yYWdlOnJlcGxhY2UnLCAoeyBuYW1lLCBkYXRhIH0pID0+IChzdG9yZVtuYW1lXS5zdG9yZSA9IGRhdGEpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ3N0b3JhZ2U6Z2V0JywgKHsgbmFtZSwga2V5LCBkZWYgfSkgPT4gc3RvcmVbbmFtZV0/LmdldChrZXksIGRlZikpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignc3RvcmFnZTpzZXQnLCAoeyBuYW1lLCBrZXksIHZhbHVlIH0pID0+IHN0b3JlW25hbWVdPy5zZXQoa2V5LCB2YWx1ZSkpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignc3RvcmFnZTpkZWxldGUnLCAoeyBuYW1lLCBrZXkgfSkgPT4gc3RvcmVbbmFtZV0/LmRlbGV0ZShrZXkpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ3N0b3JhZ2U6aGFzJywgKHsgbmFtZSwga2V5IH0pID0+IHN0b3JlW25hbWVdPy5oYXMoa2V5KSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdzdG9yYWdlOmNsZWFyJywgKG5hbWUpID0+IHN0b3JlW25hbWVdPy5jbGVhcigpKTtcbiJdLCJuYW1lcyI6WyJqc29uIiwidXRpbCIsImlkIiwicmVxdWlyZSQkMSIsInJlcXVpcmUkJDIiLCJpcGNSZW5kZXJlciIsInJlc29sdmUiLCJlcnJvciIsImlwY01haW4iLCJ3aW5kb3ciLCJjaGFubmVsIiwiZGF0YSIsInJlcXVpcmUkJDAiLCJ1bml2ZXJzYWxpZnkiLCJjb25zdGFudHMiLCJwb2x5ZmlsbHMiLCJwYXRjaCIsImZzIiwicGF0aCIsInJlbmFtZSIsImVyciIsImVycjIiLCJlciIsImVyMiIsImxlZ2FjeSIsInNlbGYiLCJjbG9uZSIsImNvcHkiLCJyZXF1aXJlJCQzIiwiZGVidWciLCJnbG9iYWwiLCJyZWFkRmlsZSIsIm9wdGlvbnMiLCJjYiIsIndyaXRlRmlsZSIsImNvcHlGaWxlIiwic3JjIiwiZGVzdCIsImZsYWdzIiwiZ28kcmVhZGRpciIsIm1vZGUiLCJ1IiwiZXhwb3J0cyIsImJ1ZmZlciIsImJ1ZmZlcnMiLCJ1dGlscyIsImNoZWNrUGF0aCIsImRlZmF1bHRzIiwibWFrZURpciIsIm1rZGlycyIsInBhdGhFeGlzdHMiLCJ1dGltZXNNaWxsaXMiLCJ1dGltZXNNaWxsaXNTeW5jIiwiZ2V0U3RhdHMiLCJmaWxlIiwiYXJlSWRlbnRpY2FsIiwic3RhdCIsInJlcXVpcmUkJDQiLCJyZXF1aXJlJCQ1Iiwib25EaXIiLCJvbkZpbGUiLCJvbkxpbmsiLCJmaWxlSXNOb3RXcml0YWJsZSIsIm1ha2VGaWxlV3JpdGFibGUiLCJpdGVtcyIsImRlc3RTdGF0IiwibWtkaXJzU3luYyIsImNvcHlTeW5jIiwicmVtb3ZlIiwicmVtb3ZlU3luYyIsIm1rZGlyIiwiZW1wdHlEaXIiLCJjcmVhdGVGaWxlIiwiY3JlYXRlRmlsZVN5bmMiLCJjcmVhdGVMaW5rIiwiY3JlYXRlTGlua1N5bmMiLCJzeW1saW5rUGF0aHMiLCJzeW1saW5rUGF0aHNTeW5jIiwiZXhpc3RzIiwic3ltbGlua1R5cGUiLCJ0eXBlIiwic3ltbGlua1R5cGVTeW5jIiwicmVxdWlyZSQkNiIsInJlcXVpcmUkJDciLCJjcmVhdGVTeW1saW5rIiwiY3JlYXRlU3ltbGlua1N5bmMiLCJzdHJpbmdpZnkiLCJzdHJpcEJvbSIsInJlYWRGaWxlU3luYyIsIndyaXRlRmlsZVN5bmMiLCJqc29uZmlsZSIsImpzb25GaWxlIiwib3V0cHV0RmlsZSIsIm91dHB1dEZpbGVTeW5jIiwibW92ZSIsImRvUmVuYW1lIiwibW92ZUFjcm9zc0RldmljZSIsInJlcXVpcmUkJDgiLCJyZXF1aXJlJCQ5IiwiaXNPYmoiLCJwYXRoRXhpc3RzTW9kdWxlIiwicFRyeSIsInBUcnlNb2R1bGUiLCJwTGltaXQiLCJlbnF1ZXVlIiwicExpbWl0TW9kdWxlIiwicExvY2F0ZSIsImxpbWl0IiwibG9jYXRlUGF0aE1vZHVsZSIsImZpbmRVcE1vZHVsZSIsInBrZ1VwTW9kdWxlIiwiY3dkIiwiZW52IiwiZW52UGF0aHNNb2R1bGUiLCJjb25zdHNfMSIsImNvZGUiLCJmc18xIiwidXRpbF8xIiwiZGlzdCIsIm5hbWVzIiwiY29kZV8xIiwiVXNlZFZhbHVlU3RhdGUiLCJkZWYiLCJOb2RlIiwibm90IiwiY29kZWdlbl8xIiwic2NoZW1hIiwicnVsZXMiLCJrZXl3b3JkIiwiVHlwZSIsIm5hbWVzXzEiLCJlcnJvcnNfMSIsInZhbGlkIiwiYXBwbGljYWJpbGl0eV8xIiwiRGF0YVR5cGUiLCJ0eXBlcyIsInQiLCJkYXRhVHlwZSIsInByb3BlcnRpZXMiLCJ1dGlsXzIiLCJwYXR0ZXJuIiwidmFsaWRhdGUiLCJlcnJvcnMiLCJfYSIsInN1YnNjaGVtYSIsInRyYXZlcnNlIiwianNvblNjaGVtYVRyYXZlcnNlTW9kdWxlIiwiZXF1YWwiLCJiYXNlSWQiLCJyZWYiLCJkYXRhVHlwZV8xIiwicmVzb2x2ZV8xIiwicmVxdWlyZSQkMTAiLCJWYWxpZGF0aW9uRXJyb3IiLCJ2YWxpZGF0ZV8xIiwidGhpcyIsInNvdXJjZSIsIkhFWERJRyQkIiwiUENUX0VOQ09ERUQkIiwiVU5SRVNFUlZFRCQkIiwiZXJyb3IkMSIsInVjczJlbmNvZGUiLCJiYXNpY1RvRGlnaXQiLCJkaWdpdFRvQmFzaWMiLCJhZGFwdCIsImRlY29kZSIsImVuY29kZSIsInRvVW5pY29kZSIsInRvQVNDSUkiLCJkZWNvZGVVbnJlc2VydmVkIiwicGFyc2UiLCJiYXNlIiwidXJpIiwic2VyaWFsaXplIiwidXJpXzEiLCJ2YWxpZGF0aW9uX2Vycm9yXzEiLCJyZWZfZXJyb3JfMSIsImNvbXBpbGVfMSIsIiRzY2hlbWEiLCJkZWZpbml0aW9ucyIsImZvcm1hdCIsImNvcmVfMSIsInVjczJsZW5ndGhfMSIsImVxdWFsXzEiLCJ2YWxpZGF0aW9uXzEiLCJpdGVtc18xIiwiYWRkaXRpb25hbEl0ZW1zXzEiLCJwcmVmaXhJdGVtcyIsImFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEiLCJyZXF1aXJlJCQxMSIsInJlcXVpcmUkJDEyIiwicmVxdWlyZSQkMTMiLCJyZXF1aXJlJCQxNCIsInJlcXVpcmUkJDE1IiwiYXBwbGljYXRvciIsImZvcm1hdF8yIiwiZm9ybWF0XzEiLCJvbmVPZiIsInJlcXVpcmVkIiwibW9kdWxlIiwiY29tcGFyZSIsIm9wcyIsIktXRHMiLCJhanYiLCJmb3JtYXRzIiwibWltaWNGbiIsIk1BWF9MRU5HVEgiLCJNQVhfU0FGRV9JTlRFR0VSIiwiTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCIsIk1BWF9TQUZFX0JVSUxEX0xFTkdUSCIsInJlIiwicGFyc2VPcHRpb25zIiwiY29tcGFyZUlkZW50aWZpZXJzIiwiaWRlbnRpZmllcnMiLCJwcmVyZWxlYXNlIiwic2VtdmVyIiwiU2VtVmVyIiwiY2xlYW4iLCJpbmMiLCJkaWZmIiwibWFqb3IiLCJtaW5vciIsInJjb21wYXJlIiwiY29tcGFyZUxvb3NlIiwiY29tcGFyZUJ1aWxkIiwic29ydCIsInJzb3J0IiwiZ3QiLCJsdCIsImVxIiwibmVxIiwiZ3RlIiwibHRlIiwiY21wIiwiY29lcmNlIiwiWWFsbGlzdCIsIlJhbmdlIiwicmFuZ2UiLCJDb21wYXJhdG9yIiwiQU5ZIiwic2F0aXNmaWVzIiwidG9Db21wYXJhdG9ycyIsIm1heFNhdGlzZnlpbmciLCJtaW5TYXRpc2Z5aW5nIiwibWluVmVyc2lvbiIsImNvbXBhcmF0b3IiLCJ2YWxpZFJhbmdlIiwib3V0c2lkZSIsImd0ciIsImx0ciIsImludGVyc2VjdHMiLCJzdWJzZXQiLCJyZXF1aXJlJCQxNiIsInJlcXVpcmUkJDE3IiwicmVxdWlyZSQkMTgiLCJyZXF1aXJlJCQxOSIsInJlcXVpcmUkJDIwIiwicmVxdWlyZSQkMjEiLCJyZXF1aXJlJCQyMiIsInJlcXVpcmUkJDIzIiwicmVxdWlyZSQkMjQiLCJyZXF1aXJlJCQyNSIsInJlcXVpcmUkJDI2IiwicmVxdWlyZSQkMjciLCJyZXF1aXJlJCQyOCIsInJlcXVpcmUkJDI5IiwicmVxdWlyZSQkMzAiLCJyZXF1aXJlJCQzMSIsInJlcXVpcmUkJDMyIiwicmVxdWlyZSQkMzMiLCJyZXF1aXJlJCQzNCIsInJlcXVpcmUkJDM1IiwicmVxdWlyZSQkMzYiLCJyZXF1aXJlJCQzNyIsInJlcXVpcmUkJDM4IiwicmVxdWlyZSQkMzkiLCJyZXF1aXJlJCQ0MCIsIm1pbWljRm5Nb2R1bGUiLCJvbmV0aW1lIiwib25ldGltZU1vZHVsZSIsImRvdFByb3AiLCJwa2dVcCIsImVudlBhdGhzIiwiZGVib3VuY2VGbiIsIkNvbmYiLCJzdG9yZSIsIl9iIiwia2V5IiwidmFsdWUiLCJkZWZpbmVfaW1wb3J0X21ldGFfZW52X2RlZmF1bHQiLCJhcHAiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFFQSxNQUFNLGlCQUFpQixNQUFNO0FBQUEsSUFDNUIsWUFBWSxTQUFTO0FBQ3BCLFlBQU0sU0FBUyxxQkFBcUIsT0FBTyxDQUFDO0FBQzVDLGFBQU8sZUFBZSxNQUFNLFFBQVE7QUFBQSxRQUNuQyxPQUFPO0FBQUEsUUFDUCxjQUFjO0FBQUEsUUFDZCxVQUFVO0FBQUEsTUFDYixDQUFHO0FBRUQsVUFBSSxNQUFNLG1CQUFtQjtBQUM1QixjQUFNLGtCQUFrQixNQUFNLFFBQVE7QUFBQSxNQUN0QztBQUFBLElBQ0Q7QUFBQSxJQUVELE9BQU8scUJBQXFCLFNBQVM7QUFDcEMsVUFBSTtBQUNILGVBQU8sS0FBSyxVQUFVLE9BQU87QUFBQSxNQUNoQyxRQUFVO0FBQ1AsZUFBTyxPQUFPLE9BQU87QUFBQSxNQUNyQjtBQUFBLElBQ0Q7QUFBQSxFQUNEO0FBRUQsUUFBTSxtQkFBbUI7QUFBQSxJQUN4QixFQUFDLFVBQVUsUUFBUSxZQUFZLE1BQUs7QUFBQSxJQUNwQyxFQUFDLFVBQVUsV0FBVyxZQUFZLE1BQUs7QUFBQSxJQUN2QyxFQUFDLFVBQVUsU0FBUyxZQUFZLE1BQUs7QUFBQSxJQUNyQyxFQUFDLFVBQVUsUUFBUSxZQUFZLEtBQUk7QUFBQSxFQUNwQztBQUVBLFFBQU0sV0FBVyxPQUFPLGdCQUFnQjtBQUV4QyxRQUFNLFNBQVMsVUFBUTtBQUN0QixTQUFLLFFBQVEsSUFBSTtBQUNqQixVQUFNQSxRQUFPLEtBQUs7QUFDbEIsV0FBTyxLQUFLLFFBQVE7QUFDcEIsV0FBT0E7QUFBQSxFQUNSO0FBRUEsUUFBTSxrQkFBa0IsQ0FBQztBQUFBLElBQ3hCO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxFQUNELE1BQU07QUFDTCxVQUFNLEtBQUssUUFBUSxNQUFNLFFBQVEsSUFBSSxJQUFJLENBQUEsSUFBSyxDQUFBO0FBRTlDLFNBQUssS0FBSyxJQUFJO0FBRWQsUUFBSSxTQUFTLFVBQVU7QUFDdEIsYUFBTztBQUFBLElBQ1A7QUFFRCxRQUFJLE9BQU8sS0FBSyxXQUFXLGNBQWMsS0FBSyxRQUFRLE1BQU0sTUFBTTtBQUNqRSxhQUFPLE9BQU8sSUFBSTtBQUFBLElBQ2xCO0FBRUQsZUFBVyxDQUFDLEtBQUssS0FBSyxLQUFLLE9BQU8sUUFBUSxJQUFJLEdBQUc7QUFDaEQsVUFBSSxPQUFPLFdBQVcsY0FBYyxPQUFPLFNBQVMsS0FBSyxHQUFHO0FBQzNELFdBQUcsR0FBRyxJQUFJO0FBQ1Y7QUFBQSxNQUNBO0FBRUQsVUFBSSxPQUFPLFVBQVUsWUFBWTtBQUNoQztBQUFBLE1BQ0E7QUFFRCxVQUFJLENBQUMsU0FBUyxPQUFPLFVBQVUsVUFBVTtBQUN4QyxXQUFHLEdBQUcsSUFBSTtBQUNWO0FBQUEsTUFDQTtBQUVELFVBQUksQ0FBQyxLQUFLLFNBQVMsS0FBSyxHQUFHLENBQUMsR0FBRztBQUM5QjtBQUVBLFdBQUcsR0FBRyxJQUFJLGdCQUFnQjtBQUFBLFVBQ3pCLE1BQU0sS0FBSyxHQUFHO0FBQUEsVUFDZCxNQUFNLEtBQUssTUFBTztBQUFBLFVBQ2xCO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxRQUNKLENBQUk7QUFDRDtBQUFBLE1BQ0E7QUFFRCxTQUFHLEdBQUcsSUFBSTtBQUFBLElBQ1Y7QUFFRCxlQUFXLEVBQUMsVUFBVSxXQUFVLEtBQUssa0JBQWtCO0FBQ3RELFVBQUksT0FBTyxLQUFLLFFBQVEsTUFBTSxVQUFVO0FBQ3ZDLGVBQU8sZUFBZSxJQUFJLFVBQVU7QUFBQSxVQUNuQyxPQUFPLEtBQUssUUFBUTtBQUFBLFVBQ3BCLFlBQVksa0JBQWtCLE9BQU87QUFBQSxVQUNyQyxjQUFjO0FBQUEsVUFDZCxVQUFVO0FBQUEsUUFDZCxDQUFJO0FBQUEsTUFDRDtBQUFBLElBQ0Q7QUFFRCxXQUFPO0FBQUEsRUFDUjtBQUVBLFFBQU0saUJBQWlCLENBQUMsT0FBTyxVQUFVLENBQUEsTUFBTztBQUMvQyxVQUFNLEVBQUMsV0FBVyxPQUFPLGtCQUFpQixJQUFJO0FBRTlDLFFBQUksT0FBTyxVQUFVLFlBQVksVUFBVSxNQUFNO0FBQ2hELGFBQU8sZ0JBQWdCO0FBQUEsUUFDdEIsTUFBTTtBQUFBLFFBQ04sTUFBTSxDQUFFO0FBQUEsUUFDUixpQkFBaUI7QUFBQSxRQUNqQjtBQUFBLFFBQ0EsT0FBTztBQUFBLE1BQ1YsQ0FBRztBQUFBLElBQ0Q7QUFHRCxRQUFJLE9BQU8sVUFBVSxZQUFZO0FBRWhDLGFBQU8sY0FBZSxNQUFNLFFBQVEsV0FBVztBQUFBLElBQy9DO0FBRUQsV0FBTztBQUFBLEVBQ1I7QUFFQSxRQUFNLG1CQUFtQixDQUFDLE9BQU8sVUFBVSxDQUFBLE1BQU87QUFDakQsVUFBTSxFQUFDLFdBQVcsT0FBTyxrQkFBaUIsSUFBSTtBQUU5QyxRQUFJLGlCQUFpQixPQUFPO0FBQzNCLGFBQU87QUFBQSxJQUNQO0FBRUQsUUFBSSxPQUFPLFVBQVUsWUFBWSxVQUFVLFFBQVEsQ0FBQyxNQUFNLFFBQVEsS0FBSyxHQUFHO0FBQ3pFLFlBQU0sV0FBVyxJQUFJO0FBQ3JCLHNCQUFnQjtBQUFBLFFBQ2YsTUFBTTtBQUFBLFFBQ04sTUFBTSxDQUFFO0FBQUEsUUFDUixLQUFLO0FBQUEsUUFDTDtBQUFBLFFBQ0EsT0FBTztBQUFBLE1BQ1YsQ0FBRztBQUNELGFBQU87QUFBQSxJQUNQO0FBRUQsV0FBTyxJQUFJLFNBQVMsS0FBSztBQUFBLEVBQzFCO0FBRUEscUJBQWlCO0FBQUEsSUFDaEI7QUFBQSxJQUNBO0FBQUE7Ozs7Ozs7OztBQ3RKRCxRQUFNLGNBQWMsTUFBTSxHQUFHLEtBQUssS0FBSyxJQUFJLEtBQUssT0FBUSxDQUFBO0FBRXhELFFBQU0saUJBQWlCLGFBQVcsNEJBQTRCLE9BQU87QUFDckUsUUFBTSx5QkFBeUIsYUFBVyw0QkFBNEIsT0FBTztBQUUxQ0MsU0FBQSx1QkFBRztBQUVUQSxTQUFBLGlCQUFHO0FBQ0tBLFNBQUEseUJBQUc7QUFFTkEsU0FBQSxzQkFBRyxhQUFXO0FBQy9DLFVBQU1DLE1BQUs7QUFDWCxXQUFPO0FBQUEsTUFDTixhQUFhLGVBQWUsT0FBTztBQUFBLE1BQ25DLGFBQWEscUNBQXFDLE9BQU8sSUFBSUEsR0FBRTtBQUFBLE1BQy9ELGNBQWMsc0NBQXNDLE9BQU8sSUFBSUEsR0FBRTtBQUFBLElBQ25FO0FBQUEsRUFDQTtBQUUwQ0QsU0FBQSw4QkFBRyxhQUFXO0FBQ3ZELFVBQU1DLE1BQUs7QUFDWCxXQUFPO0FBQUEsTUFDTixhQUFhLHVCQUF1QixPQUFPO0FBQUEsTUFDM0MsYUFBYSxxQ0FBcUMsT0FBTyxJQUFJQSxHQUFFO0FBQUEsTUFDL0QsY0FBYyxzQ0FBc0MsT0FBTyxJQUFJQSxHQUFFO0FBQUEsSUFDbkU7QUFBQTs7Ozs7Ozs7O0FDMUJBLFFBQU0sV0FBVztBQUNqQixRQUFNLEVBQUMsZ0JBQWdCLGlCQUFnQixJQUFJQztBQUMzQyxRQUFNRixRQUFPRztBQUViLFFBQU0sRUFBQyxhQUFBQyxhQUFXLElBQUk7QUFDdEIsUUFBTSxNQUFNLE9BQU8sT0FBT0EsZ0JBQWUsQ0FBRSxDQUFBO0FBRTNDLE1BQUksV0FBVyxDQUFDLFNBQVMsU0FBUyxJQUFJLFFBQVEsQ0FBQ0MsVUFBUyxXQUFXO0FBQ2xFLFVBQU0sRUFBQyxhQUFhLGFBQWEsYUFBWSxJQUFJTCxNQUFLLG9CQUFvQixPQUFPO0FBRWpGLFVBQU0sVUFBVSxNQUFNO0FBQ3JCLE1BQUFJLGFBQVksSUFBSSxhQUFhLE1BQU07QUFDbkMsTUFBQUEsYUFBWSxJQUFJLGNBQWMsT0FBTztBQUFBLElBQ3ZDO0FBRUMsVUFBTSxTQUFTLENBQUMsUUFBUSxXQUFXO0FBQ2xDO0FBQ0EsTUFBQUMsU0FBUSxNQUFNO0FBQUEsSUFDaEI7QUFFQyxVQUFNLFVBQVUsQ0FBQyxRQUFRQyxXQUFVO0FBQ2xDO0FBQ0EsYUFBTyxpQkFBaUJBLE1BQUssQ0FBQztBQUFBLElBQ2hDO0FBRUMsSUFBQUYsYUFBWSxLQUFLLGFBQWEsTUFBTTtBQUNwQyxJQUFBQSxhQUFZLEtBQUssY0FBYyxPQUFPO0FBRXRDLFVBQU0sZUFBZTtBQUFBLE1BQ3BCO0FBQUEsTUFDQTtBQUFBLE1BQ0EsVUFBVTtBQUFBLElBQ1o7QUFFQyxJQUFBQSxhQUFZLEtBQUssYUFBYSxZQUFZO0FBQUEsRUFDM0MsQ0FBQztBQUVELE1BQUksYUFBYSxDQUFDLFNBQVMsYUFBYTtBQUN2QyxVQUFNLGNBQWNKLE1BQUssdUJBQXVCLE9BQU87QUFFdkQsVUFBTSxXQUFXLE9BQU8sUUFBUSxTQUFTO0FBQ3hDLFlBQU0sRUFBQyxhQUFhLGNBQWMsU0FBUSxJQUFJO0FBRTlDLFVBQUk7QUFDSCxRQUFBSSxhQUFZLEtBQUssYUFBYSxNQUFNLFNBQVMsUUFBUSxDQUFDO0FBQUEsTUFDdEQsU0FBUUUsUUFBTztBQUNmLFFBQUFGLGFBQVksS0FBSyxjQUFjLGVBQWVFLE1BQUssQ0FBQztBQUFBLE1BQ3BEO0FBQUEsSUFDSDtBQUVDLElBQUFGLGFBQVksR0FBRyxhQUFhLFFBQVE7QUFFcEMsV0FBTyxNQUFNO0FBQ1osTUFBQUEsYUFBWSxJQUFJLGFBQWEsUUFBUTtBQUFBLElBQ3ZDO0FBQUEsRUFDQTtBQUVBLGFBQWlCOzs7Ozs7Ozs7QUN6RGpCLFFBQU0sV0FBVztBQUNqQixRQUFNLEVBQUMsZ0JBQWdCLGlCQUFnQixJQUFJRjtBQUMzQyxRQUFNRixRQUFPRztBQUViLFFBQU0sRUFBQyxTQUFBSSxVQUFTLGNBQWEsSUFBSTtBQUNqQyxRQUFNLE1BQU0sT0FBTyxPQUFPQSxZQUFXLENBQUUsQ0FBQTtBQUV2QyxNQUFJLGVBQWUsQ0FBQyxlQUFlLFNBQVMsU0FBUyxJQUFJLFFBQVEsQ0FBQ0YsVUFBUyxXQUFXO0FBQ3JGLFFBQUksQ0FBQyxlQUFlO0FBQ25CLFlBQU0sSUFBSSxNQUFNLHlCQUF5QjtBQUFBLElBQ3pDO0FBRUQsVUFBTSxFQUFDLGFBQWEsYUFBYSxhQUFZLElBQUlMLE1BQUssNEJBQTRCLE9BQU87QUFFekYsVUFBTSxVQUFVLE1BQU07QUFDckIsTUFBQU8sU0FBUSxJQUFJLGFBQWEsTUFBTTtBQUMvQixNQUFBQSxTQUFRLElBQUksY0FBYyxPQUFPO0FBQUEsSUFDbkM7QUFFQyxVQUFNLFNBQVMsQ0FBQyxPQUFPLFdBQVc7QUFDakMsWUFBTUMsVUFBUyxjQUFjLGdCQUFnQixNQUFNLE1BQU07QUFDekQsVUFBSUEsUUFBTyxPQUFPLGNBQWMsSUFBSTtBQUNuQztBQUNBLFFBQUFILFNBQVEsTUFBTTtBQUFBLE1BQ2Q7QUFBQSxJQUNIO0FBRUMsVUFBTSxVQUFVLENBQUMsT0FBT0MsV0FBVTtBQUNqQyxZQUFNRSxVQUFTLGNBQWMsZ0JBQWdCLE1BQU0sTUFBTTtBQUN6RCxVQUFJQSxRQUFPLE9BQU8sY0FBYyxJQUFJO0FBQ25DO0FBQ0EsZUFBTyxpQkFBaUJGLE1BQUssQ0FBQztBQUFBLE1BQzlCO0FBQUEsSUFDSDtBQUVDLElBQUFDLFNBQVEsR0FBRyxhQUFhLE1BQU07QUFDOUIsSUFBQUEsU0FBUSxHQUFHLGNBQWMsT0FBTztBQUVoQyxVQUFNLGVBQWU7QUFBQSxNQUNwQjtBQUFBLE1BQ0E7QUFBQSxNQUNBLFVBQVU7QUFBQSxJQUNaO0FBRUMsUUFBSSxjQUFjLGFBQWE7QUFDOUIsb0JBQWMsWUFBWSxLQUFLLGFBQWEsWUFBWTtBQUFBLElBQ3hEO0FBQUEsRUFDRixDQUFDO0FBRUQsTUFBSSxzQkFBc0IsVUFBVSxTQUFTO0FBQzVDLFVBQU0sZ0JBQWdCLGNBQWM7QUFDcEMsUUFBSSxDQUFDLGVBQWU7QUFDbkIsWUFBTSxJQUFJLE1BQU0sNEJBQTRCO0FBQUEsSUFDNUM7QUFFRCxXQUFPLElBQUksYUFBYSxlQUFlLEdBQUcsSUFBSTtBQUFBLEVBQy9DO0FBRUEsTUFBSSxpQkFBaUIsQ0FBQyx3QkFBd0IsbUJBQW1CLHNCQUFzQjtBQUN0RixRQUFJQztBQUNKLFFBQUk7QUFDSixRQUFJO0FBRUosUUFBSSxzQkFBc0IsUUFBVztBQUNwQyxnQkFBVTtBQUNWLGlCQUFXO0FBQUEsSUFDYixPQUFRO0FBQ04sTUFBQUEsVUFBUztBQUNULGdCQUFVO0FBQ1YsaUJBQVc7QUFFWCxVQUFJLENBQUNBLFNBQVE7QUFDWixjQUFNLElBQUksTUFBTSx5QkFBeUI7QUFBQSxNQUN6QztBQUFBLElBQ0Q7QUFFRCxVQUFNLGNBQWNSLE1BQUssZUFBZSxPQUFPO0FBRS9DLFVBQU0sV0FBVyxPQUFPLE9BQU8sU0FBUztBQUN2QyxZQUFNLGdCQUFnQixjQUFjLGdCQUFnQixNQUFNLE1BQU07QUFFaEUsVUFBSVEsV0FBVUEsUUFBTyxPQUFPLGNBQWMsSUFBSTtBQUM3QztBQUFBLE1BQ0E7QUFFRCxZQUFNLE9BQU8sQ0FBQ0MsVUFBU0MsVUFBUztBQUMvQixZQUFJLEVBQUUsaUJBQWlCLGNBQWMsWUFBYSxJQUFHO0FBQ3BELGdCQUFNLE9BQU8sS0FBS0QsVUFBU0MsS0FBSTtBQUFBLFFBQy9CO0FBQUEsTUFDSjtBQUVFLFlBQU0sRUFBQyxhQUFhLGNBQWMsU0FBUSxJQUFJO0FBRTlDLFVBQUk7QUFDSCxhQUFLLGFBQWEsTUFBTSxTQUFTLFVBQVUsYUFBYSxDQUFDO0FBQUEsTUFDekQsU0FBUUosUUFBTztBQUNmLGFBQUssY0FBYyxlQUFlQSxNQUFLLENBQUM7QUFBQSxNQUN4QztBQUFBLElBQ0g7QUFFQyxJQUFBQyxTQUFRLEdBQUcsYUFBYSxRQUFRO0FBRWhDLFdBQU8sTUFBTTtBQUNaLE1BQUFBLFNBQVEsSUFBSSxhQUFhLFFBQVE7QUFBQSxJQUNuQztBQUFBLEVBQ0E7QUFFQSxNQUFJLGtCQUFrQixDQUFDLFNBQVMsU0FBUztBQUN4QyxlQUFXLGlCQUFpQixjQUFjLGlCQUFpQjtBQUMxRCxVQUFJLGNBQWMsYUFBYTtBQUM5QixzQkFBYyxZQUFZLEtBQUssU0FBUyxJQUFJO0FBQUEsTUFDNUM7QUFBQSxJQUNEO0FBQUEsRUFDRjtBQUVBLFNBQWlCOzs7O0FDbEhqQixJQUFJLFFBQVEsU0FBUyxZQUFZO0FBQ0hJO0FBQzlCLE9BQU87QUFDTkosY0FBeUJMLFlBQUE7QUFDMUI7OztBQ0pvQlUsZUFBQSxlQUFHLFNBQVUsSUFBSTtBQUNuQyxTQUFPLE9BQU8sZUFBZSxZQUFhLE1BQU07QUFDOUMsUUFBSSxPQUFPLEtBQUssS0FBSyxTQUFTLENBQUMsTUFBTTtBQUFZLFNBQUcsTUFBTSxNQUFNLElBQUk7QUFBQSxTQUMvRDtBQUNILGFBQU8sSUFBSSxRQUFRLENBQUNQLFVBQVMsV0FBVztBQUN0QyxhQUFLLEtBQUssQ0FBQyxLQUFLLFFBQVMsT0FBTyxPQUFRLE9BQU8sR0FBRyxJQUFJQSxTQUFRLEdBQUcsQ0FBQztBQUNsRSxXQUFHLE1BQU0sTUFBTSxJQUFJO0FBQUEsTUFDM0IsQ0FBTztBQUFBLElBQ0Y7QUFBQSxFQUNGLEdBQUUsUUFBUSxFQUFFLE9BQU8sR0FBRyxLQUFJLENBQUU7QUFDL0I7QUFFbUJPLGVBQUEsY0FBRyxTQUFVLElBQUk7QUFDbEMsU0FBTyxPQUFPLGVBQWUsWUFBYSxNQUFNO0FBQzlDLFVBQU0sS0FBSyxLQUFLLEtBQUssU0FBUyxDQUFDO0FBQy9CLFFBQUksT0FBTyxPQUFPO0FBQVksYUFBTyxHQUFHLE1BQU0sTUFBTSxJQUFJO0FBQUEsU0FDbkQ7QUFDSCxXQUFLLElBQUs7QUFDVixTQUFHLE1BQU0sTUFBTSxJQUFJLEVBQUUsS0FBSyxPQUFLLEdBQUcsTUFBTSxDQUFDLEdBQUcsRUFBRTtBQUFBLElBQy9DO0FBQUEsRUFDRixHQUFFLFFBQVEsRUFBRSxPQUFPLEdBQUcsS0FBSSxDQUFFO0FBQy9CO0FDdkJBLElBQUlDLGNBQVlGO0FBRWhCLElBQUksVUFBVSxRQUFRO0FBQ3RCLElBQUksTUFBTTtBQUVWLElBQUksV0FBVyxRQUFRLElBQUksd0JBQXdCLFFBQVE7QUFFM0QsUUFBUSxNQUFNLFdBQVc7QUFDdkIsTUFBSSxDQUFDO0FBQ0gsVUFBTSxRQUFRLEtBQUssT0FBTztBQUM1QixTQUFPO0FBQ1Q7QUFDQSxJQUFJO0FBQ0YsVUFBUSxJQUFLO0FBQ2YsU0FBUyxJQUFJO0FBQUU7QUFHZixJQUFJLE9BQU8sUUFBUSxVQUFVLFlBQVk7QUFDdkMsTUFBSSxRQUFRLFFBQVE7QUFDcEIsVUFBUSxRQUFRLFNBQVUsR0FBRztBQUMzQixVQUFNO0FBQ04sVUFBTSxLQUFLLFNBQVMsQ0FBQztBQUFBLEVBQ3RCO0FBQ0QsTUFBSSxPQUFPO0FBQWdCLFdBQU8sZUFBZSxRQUFRLE9BQU8sS0FBSztBQUN2RTtBQUVBLElBQUFHLGNBQWlCQztBQUVqQixTQUFTQSxRQUFPQyxLQUFJO0FBS2xCLE1BQUlILFlBQVUsZUFBZSxXQUFXLEtBQ3BDLFFBQVEsUUFBUSxNQUFNLHdCQUF3QixHQUFHO0FBQ25ELGdCQUFZRyxHQUFFO0FBQUEsRUFDZjtBQUdELE1BQUksQ0FBQ0EsSUFBRyxTQUFTO0FBQ2YsaUJBQWFBLEdBQUU7QUFBQSxFQUNoQjtBQU9ELEVBQUFBLElBQUcsUUFBUSxTQUFTQSxJQUFHLEtBQUs7QUFDNUIsRUFBQUEsSUFBRyxTQUFTLFNBQVNBLElBQUcsTUFBTTtBQUM5QixFQUFBQSxJQUFHLFNBQVMsU0FBU0EsSUFBRyxNQUFNO0FBRTlCLEVBQUFBLElBQUcsUUFBUSxTQUFTQSxJQUFHLEtBQUs7QUFDNUIsRUFBQUEsSUFBRyxTQUFTLFNBQVNBLElBQUcsTUFBTTtBQUM5QixFQUFBQSxJQUFHLFNBQVMsU0FBU0EsSUFBRyxNQUFNO0FBRTlCLEVBQUFBLElBQUcsWUFBWSxhQUFhQSxJQUFHLFNBQVM7QUFDeEMsRUFBQUEsSUFBRyxhQUFhLGFBQWFBLElBQUcsVUFBVTtBQUMxQyxFQUFBQSxJQUFHLGFBQWEsYUFBYUEsSUFBRyxVQUFVO0FBRTFDLEVBQUFBLElBQUcsWUFBWSxhQUFhQSxJQUFHLFNBQVM7QUFDeEMsRUFBQUEsSUFBRyxhQUFhLGFBQWFBLElBQUcsVUFBVTtBQUMxQyxFQUFBQSxJQUFHLGFBQWEsYUFBYUEsSUFBRyxVQUFVO0FBRTFDLEVBQUFBLElBQUcsT0FBTyxRQUFRQSxJQUFHLElBQUk7QUFDekIsRUFBQUEsSUFBRyxRQUFRLFFBQVFBLElBQUcsS0FBSztBQUMzQixFQUFBQSxJQUFHLFFBQVEsUUFBUUEsSUFBRyxLQUFLO0FBRTNCLEVBQUFBLElBQUcsV0FBVyxZQUFZQSxJQUFHLFFBQVE7QUFDckMsRUFBQUEsSUFBRyxZQUFZLFlBQVlBLElBQUcsU0FBUztBQUN2QyxFQUFBQSxJQUFHLFlBQVksWUFBWUEsSUFBRyxTQUFTO0FBR3ZDLE1BQUlBLElBQUcsU0FBUyxDQUFDQSxJQUFHLFFBQVE7QUFDMUIsSUFBQUEsSUFBRyxTQUFTLFNBQVVDLE9BQU0sTUFBTSxJQUFJO0FBQ3BDLFVBQUk7QUFBSSxnQkFBUSxTQUFTLEVBQUU7QUFBQSxJQUM1QjtBQUNELElBQUFELElBQUcsYUFBYSxXQUFZO0FBQUEsSUFBRTtBQUFBLEVBQy9CO0FBQ0QsTUFBSUEsSUFBRyxTQUFTLENBQUNBLElBQUcsUUFBUTtBQUMxQixJQUFBQSxJQUFHLFNBQVMsU0FBVUMsT0FBTSxLQUFLLEtBQUssSUFBSTtBQUN4QyxVQUFJO0FBQUksZ0JBQVEsU0FBUyxFQUFFO0FBQUEsSUFDNUI7QUFDRCxJQUFBRCxJQUFHLGFBQWEsV0FBWTtBQUFBLElBQUU7QUFBQSxFQUMvQjtBQVdELE1BQUksYUFBYSxTQUFTO0FBQ3hCLElBQUFBLElBQUcsU0FBUyxPQUFPQSxJQUFHLFdBQVcsYUFBYUEsSUFBRyxTQUM5QyxTQUFVLFdBQVc7QUFDdEIsZUFBU0UsUUFBUSxNQUFNLElBQUksSUFBSTtBQUM3QixZQUFJLFFBQVEsS0FBSyxJQUFLO0FBQ3RCLFlBQUksVUFBVTtBQUNkLGtCQUFVLE1BQU0sSUFBSSxTQUFTLEdBQUksSUFBSTtBQUNuQyxjQUFJLE9BQ0ksR0FBRyxTQUFTLFlBQVksR0FBRyxTQUFTLFdBQVcsR0FBRyxTQUFTLFlBQzVELEtBQUssSUFBRyxJQUFLLFFBQVEsS0FBTztBQUNqQyx1QkFBVyxXQUFXO0FBQ3BCLGNBQUFGLElBQUcsS0FBSyxJQUFJLFNBQVUsUUFBUSxJQUFJO0FBQ2hDLG9CQUFJLFVBQVUsT0FBTyxTQUFTO0FBQzVCLDRCQUFVLE1BQU0sSUFBSSxFQUFFO0FBQUE7QUFFdEIscUJBQUcsRUFBRTtBQUFBLGNBQ3ZCLENBQWU7QUFBQSxZQUNGLEdBQUUsT0FBTztBQUNWLGdCQUFJLFVBQVU7QUFDWix5QkFBVztBQUNiO0FBQUEsVUFDRDtBQUNELGNBQUk7QUFBSSxlQUFHLEVBQUU7QUFBQSxRQUN2QixDQUFTO0FBQUEsTUFDRjtBQUNELFVBQUksT0FBTztBQUFnQixlQUFPLGVBQWVFLFNBQVEsU0FBUztBQUNsRSxhQUFPQTtBQUFBLElBQ2IsRUFBT0YsSUFBRyxNQUFNO0FBQUEsRUFDYjtBQUdELEVBQUFBLElBQUcsT0FBTyxPQUFPQSxJQUFHLFNBQVMsYUFBYUEsSUFBRyxPQUMxQyxTQUFVLFNBQVM7QUFDcEIsYUFBUyxLQUFNLElBQUksUUFBUSxRQUFRLFFBQVEsVUFBVSxXQUFXO0FBQzlELFVBQUk7QUFDSixVQUFJLGFBQWEsT0FBTyxjQUFjLFlBQVk7QUFDaEQsWUFBSSxhQUFhO0FBQ2pCLG1CQUFXLFNBQVUsSUFBSSxHQUFHLElBQUk7QUFDOUIsY0FBSSxNQUFNLEdBQUcsU0FBUyxZQUFZLGFBQWEsSUFBSTtBQUNqRDtBQUNBLG1CQUFPLFFBQVEsS0FBS0EsS0FBSSxJQUFJLFFBQVEsUUFBUSxRQUFRLFVBQVUsUUFBUTtBQUFBLFVBQ3ZFO0FBQ0Qsb0JBQVUsTUFBTSxNQUFNLFNBQVM7QUFBQSxRQUNoQztBQUFBLE1BQ0Y7QUFDRCxhQUFPLFFBQVEsS0FBS0EsS0FBSSxJQUFJLFFBQVEsUUFBUSxRQUFRLFVBQVUsUUFBUTtBQUFBLElBQ3ZFO0FBR0QsUUFBSSxPQUFPO0FBQWdCLGFBQU8sZUFBZSxNQUFNLE9BQU87QUFDOUQsV0FBTztBQUFBLEVBQ1gsRUFBS0EsSUFBRyxJQUFJO0FBRVYsRUFBQUEsSUFBRyxXQUFXLE9BQU9BLElBQUcsYUFBYSxhQUFhQSxJQUFHLFdBQ2xELHlCQUFVLGFBQWE7QUFBRSxXQUFPLFNBQVUsSUFBSSxRQUFRLFFBQVEsUUFBUSxVQUFVO0FBQ2pGLFVBQUksYUFBYTtBQUNqQixhQUFPLE1BQU07QUFDWCxZQUFJO0FBQ0YsaUJBQU8sWUFBWSxLQUFLQSxLQUFJLElBQUksUUFBUSxRQUFRLFFBQVEsUUFBUTtBQUFBLFFBQ2pFLFNBQVEsSUFBSTtBQUNYLGNBQUksR0FBRyxTQUFTLFlBQVksYUFBYSxJQUFJO0FBQzNDO0FBQ0E7QUFBQSxVQUNEO0FBQ0QsZ0JBQU07QUFBQSxRQUNQO0FBQUEsTUFDRjtBQUFBLElBQ0w7QUFBQSxFQUFHLEVBQUdBLElBQUcsUUFBUTtBQUVmLFdBQVMsWUFBYUEsS0FBSTtBQUN4QixJQUFBQSxJQUFHLFNBQVMsU0FBVUMsT0FBTSxNQUFNLFVBQVU7QUFDMUMsTUFBQUQsSUFBRztBQUFBLFFBQU1DO0FBQUEsUUFDQUosWUFBVSxXQUFXQSxZQUFVO0FBQUEsUUFDL0I7QUFBQSxRQUNBLFNBQVUsS0FBSyxJQUFJO0FBQzFCLGNBQUksS0FBSztBQUNQLGdCQUFJO0FBQVUsdUJBQVMsR0FBRztBQUMxQjtBQUFBLFVBQ0Q7QUFHRCxVQUFBRyxJQUFHLE9BQU8sSUFBSSxNQUFNLFNBQVVHLE1BQUs7QUFDakMsWUFBQUgsSUFBRyxNQUFNLElBQUksU0FBU0ksT0FBTTtBQUMxQixrQkFBSTtBQUFVLHlCQUFTRCxRQUFPQyxLQUFJO0FBQUEsWUFDOUMsQ0FBVztBQUFBLFVBQ1gsQ0FBUztBQUFBLFFBQ1Q7QUFBQSxNQUFPO0FBQUEsSUFDRjtBQUVELElBQUFKLElBQUcsYUFBYSxTQUFVQyxPQUFNLE1BQU07QUFDcEMsVUFBSSxLQUFLRCxJQUFHLFNBQVNDLE9BQU1KLFlBQVUsV0FBV0EsWUFBVSxXQUFXLElBQUk7QUFJekUsVUFBSSxRQUFRO0FBQ1osVUFBSTtBQUNKLFVBQUk7QUFDRixjQUFNRyxJQUFHLFdBQVcsSUFBSSxJQUFJO0FBQzVCLGdCQUFRO0FBQUEsTUFDaEIsVUFBZ0I7QUFDUixZQUFJLE9BQU87QUFDVCxjQUFJO0FBQ0YsWUFBQUEsSUFBRyxVQUFVLEVBQUU7QUFBQSxVQUMzQixTQUFtQixJQUFJO0FBQUEsVUFBRTtBQUFBLFFBQ3pCLE9BQWU7QUFDTCxVQUFBQSxJQUFHLFVBQVUsRUFBRTtBQUFBLFFBQ2hCO0FBQUEsTUFDRjtBQUNELGFBQU87QUFBQSxJQUNSO0FBQUEsRUFDRjtBQUVELFdBQVMsYUFBY0EsS0FBSTtBQUN6QixRQUFJSCxZQUFVLGVBQWUsV0FBVyxLQUFLRyxJQUFHLFNBQVM7QUFDdkQsTUFBQUEsSUFBRyxVQUFVLFNBQVVDLE9BQU0sSUFBSSxJQUFJLElBQUk7QUFDdkMsUUFBQUQsSUFBRyxLQUFLQyxPQUFNSixZQUFVLFdBQVcsU0FBVSxJQUFJLElBQUk7QUFDbkQsY0FBSSxJQUFJO0FBQ04sZ0JBQUk7QUFBSSxpQkFBRyxFQUFFO0FBQ2I7QUFBQSxVQUNEO0FBQ0QsVUFBQUcsSUFBRyxRQUFRLElBQUksSUFBSSxJQUFJLFNBQVVLLEtBQUk7QUFDbkMsWUFBQUwsSUFBRyxNQUFNLElBQUksU0FBVU0sTUFBSztBQUMxQixrQkFBSTtBQUFJLG1CQUFHRCxPQUFNQyxJQUFHO0FBQUEsWUFDbEMsQ0FBYTtBQUFBLFVBQ2IsQ0FBVztBQUFBLFFBQ1gsQ0FBUztBQUFBLE1BQ0Y7QUFFRCxNQUFBTixJQUFHLGNBQWMsU0FBVUMsT0FBTSxJQUFJLElBQUk7QUFDdkMsWUFBSSxLQUFLRCxJQUFHLFNBQVNDLE9BQU1KLFlBQVUsU0FBUztBQUM5QyxZQUFJO0FBQ0osWUFBSSxRQUFRO0FBQ1osWUFBSTtBQUNGLGdCQUFNRyxJQUFHLFlBQVksSUFBSSxJQUFJLEVBQUU7QUFDL0Isa0JBQVE7QUFBQSxRQUNsQixVQUFrQjtBQUNSLGNBQUksT0FBTztBQUNULGdCQUFJO0FBQ0YsY0FBQUEsSUFBRyxVQUFVLEVBQUU7QUFBQSxZQUM3QixTQUFxQixJQUFJO0FBQUEsWUFBRTtBQUFBLFVBQzNCLE9BQWlCO0FBQ0wsWUFBQUEsSUFBRyxVQUFVLEVBQUU7QUFBQSxVQUNoQjtBQUFBLFFBQ0Y7QUFDRCxlQUFPO0FBQUEsTUFDUjtBQUFBLElBRVAsV0FBZUEsSUFBRyxTQUFTO0FBQ3JCLE1BQUFBLElBQUcsVUFBVSxTQUFVLElBQUksSUFBSSxJQUFJLElBQUk7QUFBRSxZQUFJO0FBQUksa0JBQVEsU0FBUyxFQUFFO0FBQUEsTUFBRztBQUN2RSxNQUFBQSxJQUFHLGNBQWMsV0FBWTtBQUFBLE1BQUU7QUFBQSxJQUNoQztBQUFBLEVBQ0Y7QUFFRCxXQUFTLFNBQVUsTUFBTTtBQUN2QixRQUFJLENBQUM7QUFBTSxhQUFPO0FBQ2xCLFdBQU8sU0FBVSxRQUFRLE1BQU0sSUFBSTtBQUNqQyxhQUFPLEtBQUssS0FBS0EsS0FBSSxRQUFRLE1BQU0sU0FBVSxJQUFJO0FBQy9DLFlBQUksVUFBVSxFQUFFO0FBQUcsZUFBSztBQUN4QixZQUFJO0FBQUksYUFBRyxNQUFNLE1BQU0sU0FBUztBQUFBLE1BQ3hDLENBQU87QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUVELFdBQVMsYUFBYyxNQUFNO0FBQzNCLFFBQUksQ0FBQztBQUFNLGFBQU87QUFDbEIsV0FBTyxTQUFVLFFBQVEsTUFBTTtBQUM3QixVQUFJO0FBQ0YsZUFBTyxLQUFLLEtBQUtBLEtBQUksUUFBUSxJQUFJO0FBQUEsTUFDbEMsU0FBUSxJQUFJO0FBQ1gsWUFBSSxDQUFDLFVBQVUsRUFBRTtBQUFHLGdCQUFNO0FBQUEsTUFDM0I7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUdELFdBQVMsU0FBVSxNQUFNO0FBQ3ZCLFFBQUksQ0FBQztBQUFNLGFBQU87QUFDbEIsV0FBTyxTQUFVLFFBQVEsS0FBSyxLQUFLLElBQUk7QUFDckMsYUFBTyxLQUFLLEtBQUtBLEtBQUksUUFBUSxLQUFLLEtBQUssU0FBVSxJQUFJO0FBQ25ELFlBQUksVUFBVSxFQUFFO0FBQUcsZUFBSztBQUN4QixZQUFJO0FBQUksYUFBRyxNQUFNLE1BQU0sU0FBUztBQUFBLE1BQ3hDLENBQU87QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUVELFdBQVMsYUFBYyxNQUFNO0FBQzNCLFFBQUksQ0FBQztBQUFNLGFBQU87QUFDbEIsV0FBTyxTQUFVLFFBQVEsS0FBSyxLQUFLO0FBQ2pDLFVBQUk7QUFDRixlQUFPLEtBQUssS0FBS0EsS0FBSSxRQUFRLEtBQUssR0FBRztBQUFBLE1BQ3RDLFNBQVEsSUFBSTtBQUNYLFlBQUksQ0FBQyxVQUFVLEVBQUU7QUFBRyxnQkFBTTtBQUFBLE1BQzNCO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFFRCxXQUFTLFFBQVMsTUFBTTtBQUN0QixRQUFJLENBQUM7QUFBTSxhQUFPO0FBR2xCLFdBQU8sU0FBVSxRQUFRLFNBQVMsSUFBSTtBQUNwQyxVQUFJLE9BQU8sWUFBWSxZQUFZO0FBQ2pDLGFBQUs7QUFDTCxrQkFBVTtBQUFBLE1BQ1g7QUFDRCxlQUFTLFNBQVUsSUFBSSxPQUFPO0FBQzVCLFlBQUksT0FBTztBQUNULGNBQUksTUFBTSxNQUFNO0FBQUcsa0JBQU0sT0FBTztBQUNoQyxjQUFJLE1BQU0sTUFBTTtBQUFHLGtCQUFNLE9BQU87QUFBQSxRQUNqQztBQUNELFlBQUk7QUFBSSxhQUFHLE1BQU0sTUFBTSxTQUFTO0FBQUEsTUFDakM7QUFDRCxhQUFPLFVBQVUsS0FBSyxLQUFLQSxLQUFJLFFBQVEsU0FBUyxRQUFRLElBQ3BELEtBQUssS0FBS0EsS0FBSSxRQUFRLFFBQVE7QUFBQSxJQUNuQztBQUFBLEVBQ0Y7QUFFRCxXQUFTLFlBQWEsTUFBTTtBQUMxQixRQUFJLENBQUM7QUFBTSxhQUFPO0FBR2xCLFdBQU8sU0FBVSxRQUFRLFNBQVM7QUFDaEMsVUFBSSxRQUFRLFVBQVUsS0FBSyxLQUFLQSxLQUFJLFFBQVEsT0FBTyxJQUMvQyxLQUFLLEtBQUtBLEtBQUksTUFBTTtBQUN4QixVQUFJLE9BQU87QUFDVCxZQUFJLE1BQU0sTUFBTTtBQUFHLGdCQUFNLE9BQU87QUFDaEMsWUFBSSxNQUFNLE1BQU07QUFBRyxnQkFBTSxPQUFPO0FBQUEsTUFDakM7QUFDRCxhQUFPO0FBQUEsSUFDUjtBQUFBLEVBQ0Y7QUFjRCxXQUFTLFVBQVcsSUFBSTtBQUN0QixRQUFJLENBQUM7QUFDSCxhQUFPO0FBRVQsUUFBSSxHQUFHLFNBQVM7QUFDZCxhQUFPO0FBRVQsUUFBSSxVQUFVLENBQUMsUUFBUSxVQUFVLFFBQVEsT0FBTSxNQUFPO0FBQ3RELFFBQUksU0FBUztBQUNYLFVBQUksR0FBRyxTQUFTLFlBQVksR0FBRyxTQUFTO0FBQ3RDLGVBQU87QUFBQSxJQUNWO0FBRUQsV0FBTztBQUFBLEVBQ1I7QUFDSDtBQ2xXQSxJQUFJLFNBQVNMLGFBQWtCO0FBRS9CLElBQUEsZ0JBQWlCWTtBQUVqQixTQUFTQSxTQUFRUCxLQUFJO0FBQ25CLFNBQU87QUFBQSxJQUNMO0FBQUEsSUFDQTtBQUFBLEVBQ0Q7QUFFRCxXQUFTLFdBQVlDLE9BQU0sU0FBUztBQUNsQyxRQUFJLEVBQUUsZ0JBQWdCO0FBQWEsYUFBTyxJQUFJLFdBQVdBLE9BQU0sT0FBTztBQUV0RSxXQUFPLEtBQUssSUFBSTtBQUVoQixRQUFJTyxRQUFPO0FBRVgsU0FBSyxPQUFPUDtBQUNaLFNBQUssS0FBSztBQUNWLFNBQUssV0FBVztBQUNoQixTQUFLLFNBQVM7QUFFZCxTQUFLLFFBQVE7QUFDYixTQUFLLE9BQU87QUFDWixTQUFLLGFBQWEsS0FBSztBQUV2QixjQUFVLFdBQVc7QUFHckIsUUFBSSxPQUFPLE9BQU8sS0FBSyxPQUFPO0FBQzlCLGFBQVMsUUFBUSxHQUFHLFNBQVMsS0FBSyxRQUFRLFFBQVEsUUFBUSxTQUFTO0FBQ2pFLFVBQUksTUFBTSxLQUFLLEtBQUs7QUFDcEIsV0FBSyxHQUFHLElBQUksUUFBUSxHQUFHO0FBQUEsSUFDeEI7QUFFRCxRQUFJLEtBQUs7QUFBVSxXQUFLLFlBQVksS0FBSyxRQUFRO0FBRWpELFFBQUksS0FBSyxVQUFVLFFBQVc7QUFDNUIsVUFBSSxhQUFhLE9BQU8sS0FBSyxPQUFPO0FBQ2xDLGNBQU0sVUFBVSx3QkFBd0I7QUFBQSxNQUN6QztBQUNELFVBQUksS0FBSyxRQUFRLFFBQVc7QUFDMUIsYUFBSyxNQUFNO0FBQUEsTUFDWixXQUFVLGFBQWEsT0FBTyxLQUFLLEtBQUs7QUFDdkMsY0FBTSxVQUFVLHNCQUFzQjtBQUFBLE1BQ3ZDO0FBRUQsVUFBSSxLQUFLLFFBQVEsS0FBSyxLQUFLO0FBQ3pCLGNBQU0sSUFBSSxNQUFNLHNCQUFzQjtBQUFBLE1BQ3ZDO0FBRUQsV0FBSyxNQUFNLEtBQUs7QUFBQSxJQUNqQjtBQUVELFFBQUksS0FBSyxPQUFPLE1BQU07QUFDcEIsY0FBUSxTQUFTLFdBQVc7QUFDMUIsUUFBQU8sTUFBSyxNQUFLO0FBQUEsTUFDbEIsQ0FBTztBQUNEO0FBQUEsSUFDRDtBQUVELElBQUFSLElBQUcsS0FBSyxLQUFLLE1BQU0sS0FBSyxPQUFPLEtBQUssTUFBTSxTQUFVLEtBQUssSUFBSTtBQUMzRCxVQUFJLEtBQUs7QUFDUCxRQUFBUSxNQUFLLEtBQUssU0FBUyxHQUFHO0FBQ3RCLFFBQUFBLE1BQUssV0FBVztBQUNoQjtBQUFBLE1BQ0Q7QUFFRCxNQUFBQSxNQUFLLEtBQUs7QUFDVixNQUFBQSxNQUFLLEtBQUssUUFBUSxFQUFFO0FBQ3BCLE1BQUFBLE1BQUssTUFBSztBQUFBLElBQ2hCLENBQUs7QUFBQSxFQUNGO0FBRUQsV0FBUyxZQUFhUCxPQUFNLFNBQVM7QUFDbkMsUUFBSSxFQUFFLGdCQUFnQjtBQUFjLGFBQU8sSUFBSSxZQUFZQSxPQUFNLE9BQU87QUFFeEUsV0FBTyxLQUFLLElBQUk7QUFFaEIsU0FBSyxPQUFPQTtBQUNaLFNBQUssS0FBSztBQUNWLFNBQUssV0FBVztBQUVoQixTQUFLLFFBQVE7QUFDYixTQUFLLFdBQVc7QUFDaEIsU0FBSyxPQUFPO0FBQ1osU0FBSyxlQUFlO0FBRXBCLGNBQVUsV0FBVztBQUdyQixRQUFJLE9BQU8sT0FBTyxLQUFLLE9BQU87QUFDOUIsYUFBUyxRQUFRLEdBQUcsU0FBUyxLQUFLLFFBQVEsUUFBUSxRQUFRLFNBQVM7QUFDakUsVUFBSSxNQUFNLEtBQUssS0FBSztBQUNwQixXQUFLLEdBQUcsSUFBSSxRQUFRLEdBQUc7QUFBQSxJQUN4QjtBQUVELFFBQUksS0FBSyxVQUFVLFFBQVc7QUFDNUIsVUFBSSxhQUFhLE9BQU8sS0FBSyxPQUFPO0FBQ2xDLGNBQU0sVUFBVSx3QkFBd0I7QUFBQSxNQUN6QztBQUNELFVBQUksS0FBSyxRQUFRLEdBQUc7QUFDbEIsY0FBTSxJQUFJLE1BQU0sdUJBQXVCO0FBQUEsTUFDeEM7QUFFRCxXQUFLLE1BQU0sS0FBSztBQUFBLElBQ2pCO0FBRUQsU0FBSyxPQUFPO0FBQ1osU0FBSyxTQUFTO0FBRWQsUUFBSSxLQUFLLE9BQU8sTUFBTTtBQUNwQixXQUFLLFFBQVFELElBQUc7QUFDaEIsV0FBSyxPQUFPLEtBQUssQ0FBQyxLQUFLLE9BQU8sS0FBSyxNQUFNLEtBQUssT0FBTyxLQUFLLE1BQU0sTUFBUyxDQUFDO0FBQzFFLFdBQUssTUFBSztBQUFBLElBQ1g7QUFBQSxFQUNGO0FBQ0g7QUNuSEEsSUFBQSxVQUFpQlM7QUFFakIsSUFBSSxpQkFBaUIsT0FBTyxrQkFBa0IsU0FBVSxLQUFLO0FBQzNELFNBQU8sSUFBSTtBQUNiO0FBRUEsU0FBU0EsUUFBTyxLQUFLO0FBQ25CLE1BQUksUUFBUSxRQUFRLE9BQU8sUUFBUTtBQUNqQyxXQUFPO0FBRVQsTUFBSSxlQUFlO0FBQ2pCLFFBQUlDLFFBQU8sRUFBRSxXQUFXLGVBQWUsR0FBRyxFQUFHO0FBQUE7QUFFN0MsUUFBSUEsUUFBTyx1QkFBTyxPQUFPLElBQUk7QUFFL0IsU0FBTyxvQkFBb0IsR0FBRyxFQUFFLFFBQVEsU0FBVSxLQUFLO0FBQ3JELFdBQU8sZUFBZUEsT0FBTSxLQUFLLE9BQU8seUJBQXlCLEtBQUssR0FBRyxDQUFDO0FBQUEsRUFDOUUsQ0FBRztBQUVELFNBQU9BO0FBQ1Q7QUN0QkEsSUFBSVYsT0FBS0w7QUFDVCxJQUFJLFlBQVlUO0FBQ2hCLElBQUksU0FBU0M7QUFDYixJQUFJLFFBQVF3QjtBQUVaLElBQUkzQixTQUFPO0FBR1gsSUFBSTtBQUNKLElBQUk7QUFHSixJQUFJLE9BQU8sV0FBVyxjQUFjLE9BQU8sT0FBTyxRQUFRLFlBQVk7QUFDcEUsa0JBQWdCLE9BQU8sSUFBSSxtQkFBbUI7QUFFOUMsbUJBQWlCLE9BQU8sSUFBSSxzQkFBc0I7QUFDcEQsT0FBTztBQUNMLGtCQUFnQjtBQUNoQixtQkFBaUI7QUFDbkI7QUFFQSxTQUFTLE9BQVE7QUFBRTtBQUVuQixTQUFTLGFBQWEsU0FBUyxPQUFPO0FBQ3BDLFNBQU8sZUFBZSxTQUFTLGVBQWU7QUFBQSxJQUM1QyxLQUFLLFdBQVc7QUFDZCxhQUFPO0FBQUEsSUFDUjtBQUFBLEVBQ0wsQ0FBRztBQUNIO0FBRUEsSUFBSTRCLFVBQVE7QUFDWixJQUFJNUIsT0FBSztBQUNQNEIsWUFBUTVCLE9BQUssU0FBUyxNQUFNO0FBQUEsU0FDckIsWUFBWSxLQUFLLFFBQVEsSUFBSSxjQUFjLEVBQUU7QUFDcEQ0QixZQUFRLFdBQVc7QUFDakIsUUFBSSxJQUFJNUIsT0FBSyxPQUFPLE1BQU1BLFFBQU0sU0FBUztBQUN6QyxRQUFJLFdBQVcsRUFBRSxNQUFNLElBQUksRUFBRSxLQUFLLFVBQVU7QUFDNUMsWUFBUSxNQUFNLENBQUM7QUFBQSxFQUNoQjtBQUdILElBQUksQ0FBQ2dCLEtBQUcsYUFBYSxHQUFHO0FBRXRCLE1BQUksUUFBUWEsZUFBTyxhQUFhLEtBQUssQ0FBRTtBQUN2QyxlQUFhYixNQUFJLEtBQUs7QUFNdEJBLE9BQUcsUUFBUyxTQUFVLFVBQVU7QUFDOUIsYUFBUyxNQUFPLElBQUksSUFBSTtBQUN0QixhQUFPLFNBQVMsS0FBS0EsTUFBSSxJQUFJLFNBQVUsS0FBSztBQUUxQyxZQUFJLENBQUMsS0FBSztBQUNSLHFCQUFZO0FBQUEsUUFDYjtBQUVELFlBQUksT0FBTyxPQUFPO0FBQ2hCLGFBQUcsTUFBTSxNQUFNLFNBQVM7QUFBQSxNQUNsQyxDQUFPO0FBQUEsSUFDRjtBQUVELFdBQU8sZUFBZSxPQUFPLGdCQUFnQjtBQUFBLE1BQzNDLE9BQU87QUFBQSxJQUNiLENBQUs7QUFDRCxXQUFPO0FBQUEsRUFDWCxFQUFLQSxLQUFHLEtBQUs7QUFFWEEsT0FBRyxZQUFhLFNBQVUsY0FBYztBQUN0QyxhQUFTLFVBQVcsSUFBSTtBQUV0QixtQkFBYSxNQUFNQSxNQUFJLFNBQVM7QUFDaEMsaUJBQVk7QUFBQSxJQUNiO0FBRUQsV0FBTyxlQUFlLFdBQVcsZ0JBQWdCO0FBQUEsTUFDL0MsT0FBTztBQUFBLElBQ2IsQ0FBSztBQUNELFdBQU87QUFBQSxFQUNYLEVBQUtBLEtBQUcsU0FBUztBQUVmLE1BQUksWUFBWSxLQUFLLFFBQVEsSUFBSSxjQUFjLEVBQUUsR0FBRztBQUNsRCxZQUFRLEdBQUcsUUFBUSxXQUFXO0FBQzVCWSxjQUFNWixLQUFHLGFBQWEsQ0FBQztBQUN2QixpQkFBa0IsTUFBTUEsS0FBRyxhQUFhLEVBQUUsUUFBUSxDQUFDO0FBQUEsSUFDekQsQ0FBSztBQUFBLEVBQ0Y7QUFDSDtBQUVBLElBQUksQ0FBQ2EsZUFBTyxhQUFhLEdBQUc7QUFDMUIsZUFBYUEsZ0JBQVFiLEtBQUcsYUFBYSxDQUFDO0FBQ3hDO0FBRUEsSUFBQSxhQUFpQkQsUUFBTSxNQUFNQyxJQUFFLENBQUM7QUFDaEMsSUFBSSxRQUFRLElBQUksaUNBQWlDLENBQUNBLEtBQUcsV0FBVztBQUM1RCxlQUFpQkQsUUFBTUMsSUFBRTtBQUN6QkEsT0FBRyxZQUFZO0FBQ25CO0FBRUEsU0FBU0QsUUFBT0MsS0FBSTtBQUVsQixZQUFVQSxHQUFFO0FBQ1osRUFBQUEsSUFBRyxjQUFjRDtBQUVqQixFQUFBQyxJQUFHLG1CQUFtQjtBQUN0QixFQUFBQSxJQUFHLG9CQUFvQjtBQUN2QixNQUFJLGNBQWNBLElBQUc7QUFDckIsRUFBQUEsSUFBRyxXQUFXYztBQUNkLFdBQVNBLFVBQVViLE9BQU0sU0FBUyxJQUFJO0FBQ3BDLFFBQUksT0FBTyxZQUFZO0FBQ3JCLFdBQUssU0FBUyxVQUFVO0FBRTFCLFdBQU8sWUFBWUEsT0FBTSxTQUFTLEVBQUU7QUFFcEMsYUFBUyxZQUFhQSxPQUFNYyxVQUFTQyxLQUFJLFdBQVc7QUFDbEQsYUFBTyxZQUFZZixPQUFNYyxVQUFTLFNBQVUsS0FBSztBQUMvQyxZQUFJLFFBQVEsSUFBSSxTQUFTLFlBQVksSUFBSSxTQUFTO0FBQ2hELGtCQUFRLENBQUMsYUFBYSxDQUFDZCxPQUFNYyxVQUFTQyxHQUFFLEdBQUcsS0FBSyxhQUFhLEtBQUssSUFBRyxHQUFJLEtBQUssSUFBSyxDQUFBLENBQUM7QUFBQSxhQUNqRjtBQUNILGNBQUksT0FBT0EsUUFBTztBQUNoQixZQUFBQSxJQUFHLE1BQU0sTUFBTSxTQUFTO0FBQUEsUUFDM0I7QUFBQSxNQUNULENBQU87QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUVELE1BQUksZUFBZWhCLElBQUc7QUFDdEIsRUFBQUEsSUFBRyxZQUFZaUI7QUFDZixXQUFTQSxXQUFXaEIsT0FBTSxNQUFNLFNBQVMsSUFBSTtBQUMzQyxRQUFJLE9BQU8sWUFBWTtBQUNyQixXQUFLLFNBQVMsVUFBVTtBQUUxQixXQUFPLGFBQWFBLE9BQU0sTUFBTSxTQUFTLEVBQUU7QUFFM0MsYUFBUyxhQUFjQSxPQUFNUCxPQUFNcUIsVUFBU0MsS0FBSSxXQUFXO0FBQ3pELGFBQU8sYUFBYWYsT0FBTVAsT0FBTXFCLFVBQVMsU0FBVSxLQUFLO0FBQ3RELFlBQUksUUFBUSxJQUFJLFNBQVMsWUFBWSxJQUFJLFNBQVM7QUFDaEQsa0JBQVEsQ0FBQyxjQUFjLENBQUNkLE9BQU1QLE9BQU1xQixVQUFTQyxHQUFFLEdBQUcsS0FBSyxhQUFhLEtBQUssSUFBSyxHQUFFLEtBQUssSUFBRyxDQUFFLENBQUM7QUFBQSxhQUN4RjtBQUNILGNBQUksT0FBT0EsUUFBTztBQUNoQixZQUFBQSxJQUFHLE1BQU0sTUFBTSxTQUFTO0FBQUEsUUFDM0I7QUFBQSxNQUNULENBQU87QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUVELE1BQUksZ0JBQWdCaEIsSUFBRztBQUN2QixNQUFJO0FBQ0YsSUFBQUEsSUFBRyxhQUFhO0FBQ2xCLFdBQVMsV0FBWUMsT0FBTSxNQUFNLFNBQVMsSUFBSTtBQUM1QyxRQUFJLE9BQU8sWUFBWTtBQUNyQixXQUFLLFNBQVMsVUFBVTtBQUUxQixXQUFPLGNBQWNBLE9BQU0sTUFBTSxTQUFTLEVBQUU7QUFFNUMsYUFBUyxjQUFlQSxPQUFNUCxPQUFNcUIsVUFBU0MsS0FBSSxXQUFXO0FBQzFELGFBQU8sY0FBY2YsT0FBTVAsT0FBTXFCLFVBQVMsU0FBVSxLQUFLO0FBQ3ZELFlBQUksUUFBUSxJQUFJLFNBQVMsWUFBWSxJQUFJLFNBQVM7QUFDaEQsa0JBQVEsQ0FBQyxlQUFlLENBQUNkLE9BQU1QLE9BQU1xQixVQUFTQyxHQUFFLEdBQUcsS0FBSyxhQUFhLEtBQUssSUFBSyxHQUFFLEtBQUssSUFBRyxDQUFFLENBQUM7QUFBQSxhQUN6RjtBQUNILGNBQUksT0FBT0EsUUFBTztBQUNoQixZQUFBQSxJQUFHLE1BQU0sTUFBTSxTQUFTO0FBQUEsUUFDM0I7QUFBQSxNQUNULENBQU87QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUVELE1BQUksY0FBY2hCLElBQUc7QUFDckIsTUFBSTtBQUNGLElBQUFBLElBQUcsV0FBV2tCO0FBQ2hCLFdBQVNBLFVBQVUsS0FBSyxNQUFNLE9BQU8sSUFBSTtBQUN2QyxRQUFJLE9BQU8sVUFBVSxZQUFZO0FBQy9CLFdBQUs7QUFDTCxjQUFRO0FBQUEsSUFDVDtBQUNELFdBQU8sWUFBWSxLQUFLLE1BQU0sT0FBTyxFQUFFO0FBRXZDLGFBQVMsWUFBYUMsTUFBS0MsT0FBTUMsUUFBT0wsS0FBSSxXQUFXO0FBQ3JELGFBQU8sWUFBWUcsTUFBS0MsT0FBTUMsUUFBTyxTQUFVLEtBQUs7QUFDbEQsWUFBSSxRQUFRLElBQUksU0FBUyxZQUFZLElBQUksU0FBUztBQUNoRCxrQkFBUSxDQUFDLGFBQWEsQ0FBQ0YsTUFBS0MsT0FBTUMsUUFBT0wsR0FBRSxHQUFHLEtBQUssYUFBYSxLQUFLLElBQUssR0FBRSxLQUFLLElBQUcsQ0FBRSxDQUFDO0FBQUEsYUFDcEY7QUFDSCxjQUFJLE9BQU9BLFFBQU87QUFDaEIsWUFBQUEsSUFBRyxNQUFNLE1BQU0sU0FBUztBQUFBLFFBQzNCO0FBQUEsTUFDVCxDQUFPO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFFRCxNQUFJLGFBQWFoQixJQUFHO0FBQ3BCLEVBQUFBLElBQUcsVUFBVTtBQUNiLE1BQUksMEJBQTBCO0FBQzlCLFdBQVMsUUFBU0MsT0FBTSxTQUFTLElBQUk7QUFDbkMsUUFBSSxPQUFPLFlBQVk7QUFDckIsV0FBSyxTQUFTLFVBQVU7QUFFMUIsUUFBSSxhQUFhLHdCQUF3QixLQUFLLFFBQVEsT0FBTyxJQUN6RCxTQUFTcUIsWUFBWXJCLE9BQU1jLFVBQVNDLEtBQUksV0FBVztBQUNuRCxhQUFPLFdBQVdmLE9BQU07QUFBQSxRQUN0QkE7QUFBQSxRQUFNYztBQUFBLFFBQVNDO0FBQUEsUUFBSTtBQUFBLE1BQzdCLENBQVM7QUFBQSxJQUNGLElBQ0MsU0FBU00sWUFBWXJCLE9BQU1jLFVBQVNDLEtBQUksV0FBVztBQUNuRCxhQUFPLFdBQVdmLE9BQU1jLFVBQVM7QUFBQSxRQUMvQmQ7QUFBQSxRQUFNYztBQUFBLFFBQVNDO0FBQUEsUUFBSTtBQUFBLE1BQzdCLENBQVM7QUFBQSxJQUNGO0FBRUgsV0FBTyxXQUFXZixPQUFNLFNBQVMsRUFBRTtBQUVuQyxhQUFTLG1CQUFvQkEsT0FBTWMsVUFBU0MsS0FBSSxXQUFXO0FBQ3pELGFBQU8sU0FBVSxLQUFLLE9BQU87QUFDM0IsWUFBSSxRQUFRLElBQUksU0FBUyxZQUFZLElBQUksU0FBUztBQUNoRCxrQkFBUTtBQUFBLFlBQ047QUFBQSxZQUNBLENBQUNmLE9BQU1jLFVBQVNDLEdBQUU7QUFBQSxZQUNsQjtBQUFBLFlBQ0EsYUFBYSxLQUFLLElBQUs7QUFBQSxZQUN2QixLQUFLLElBQUs7QUFBQSxVQUN0QixDQUFXO0FBQUEsYUFDRTtBQUNILGNBQUksU0FBUyxNQUFNO0FBQ2pCLGtCQUFNLEtBQU07QUFFZCxjQUFJLE9BQU9BLFFBQU87QUFDaEIsWUFBQUEsSUFBRyxLQUFLLE1BQU0sS0FBSyxLQUFLO0FBQUEsUUFDM0I7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFFRCxNQUFJLFFBQVEsUUFBUSxPQUFPLEdBQUcsQ0FBQyxNQUFNLFFBQVE7QUFDM0MsUUFBSSxhQUFhLE9BQU9oQixHQUFFO0FBQzFCLGlCQUFhLFdBQVc7QUFDeEIsa0JBQWMsV0FBVztBQUFBLEVBQzFCO0FBRUQsTUFBSSxnQkFBZ0JBLElBQUc7QUFDdkIsTUFBSSxlQUFlO0FBQ2pCLGVBQVcsWUFBWSxPQUFPLE9BQU8sY0FBYyxTQUFTO0FBQzVELGVBQVcsVUFBVSxPQUFPO0FBQUEsRUFDN0I7QUFFRCxNQUFJLGlCQUFpQkEsSUFBRztBQUN4QixNQUFJLGdCQUFnQjtBQUNsQixnQkFBWSxZQUFZLE9BQU8sT0FBTyxlQUFlLFNBQVM7QUFDOUQsZ0JBQVksVUFBVSxPQUFPO0FBQUEsRUFDOUI7QUFFRCxTQUFPLGVBQWVBLEtBQUksY0FBYztBQUFBLElBQ3RDLEtBQUssV0FBWTtBQUNmLGFBQU87QUFBQSxJQUNSO0FBQUEsSUFDRCxLQUFLLFNBQVUsS0FBSztBQUNsQixtQkFBYTtBQUFBLElBQ2Q7QUFBQSxJQUNELFlBQVk7QUFBQSxJQUNaLGNBQWM7QUFBQSxFQUNsQixDQUFHO0FBQ0QsU0FBTyxlQUFlQSxLQUFJLGVBQWU7QUFBQSxJQUN2QyxLQUFLLFdBQVk7QUFDZixhQUFPO0FBQUEsSUFDUjtBQUFBLElBQ0QsS0FBSyxTQUFVLEtBQUs7QUFDbEIsb0JBQWM7QUFBQSxJQUNmO0FBQUEsSUFDRCxZQUFZO0FBQUEsSUFDWixjQUFjO0FBQUEsRUFDbEIsQ0FBRztBQUdELE1BQUksaUJBQWlCO0FBQ3JCLFNBQU8sZUFBZUEsS0FBSSxrQkFBa0I7QUFBQSxJQUMxQyxLQUFLLFdBQVk7QUFDZixhQUFPO0FBQUEsSUFDUjtBQUFBLElBQ0QsS0FBSyxTQUFVLEtBQUs7QUFDbEIsdUJBQWlCO0FBQUEsSUFDbEI7QUFBQSxJQUNELFlBQVk7QUFBQSxJQUNaLGNBQWM7QUFBQSxFQUNsQixDQUFHO0FBQ0QsTUFBSSxrQkFBa0I7QUFDdEIsU0FBTyxlQUFlQSxLQUFJLG1CQUFtQjtBQUFBLElBQzNDLEtBQUssV0FBWTtBQUNmLGFBQU87QUFBQSxJQUNSO0FBQUEsSUFDRCxLQUFLLFNBQVUsS0FBSztBQUNsQix3QkFBa0I7QUFBQSxJQUNuQjtBQUFBLElBQ0QsWUFBWTtBQUFBLElBQ1osY0FBYztBQUFBLEVBQ2xCLENBQUc7QUFFRCxXQUFTLFdBQVlDLE9BQU0sU0FBUztBQUNsQyxRQUFJLGdCQUFnQjtBQUNsQixhQUFPLGNBQWMsTUFBTSxNQUFNLFNBQVMsR0FBRztBQUFBO0FBRTdDLGFBQU8sV0FBVyxNQUFNLE9BQU8sT0FBTyxXQUFXLFNBQVMsR0FBRyxTQUFTO0FBQUEsRUFDekU7QUFFRCxXQUFTLGtCQUFtQjtBQUMxQixRQUFJLE9BQU87QUFDWCxTQUFLLEtBQUssTUFBTSxLQUFLLE9BQU8sS0FBSyxNQUFNLFNBQVUsS0FBSyxJQUFJO0FBQ3hELFVBQUksS0FBSztBQUNQLFlBQUksS0FBSztBQUNQLGVBQUssUUFBUztBQUVoQixhQUFLLEtBQUssU0FBUyxHQUFHO0FBQUEsTUFDOUIsT0FBYTtBQUNMLGFBQUssS0FBSztBQUNWLGFBQUssS0FBSyxRQUFRLEVBQUU7QUFDcEIsYUFBSyxLQUFNO0FBQUEsTUFDWjtBQUFBLElBQ1AsQ0FBSztBQUFBLEVBQ0Y7QUFFRCxXQUFTLFlBQWFBLE9BQU0sU0FBUztBQUNuQyxRQUFJLGdCQUFnQjtBQUNsQixhQUFPLGVBQWUsTUFBTSxNQUFNLFNBQVMsR0FBRztBQUFBO0FBRTlDLGFBQU8sWUFBWSxNQUFNLE9BQU8sT0FBTyxZQUFZLFNBQVMsR0FBRyxTQUFTO0FBQUEsRUFDM0U7QUFFRCxXQUFTLG1CQUFvQjtBQUMzQixRQUFJLE9BQU87QUFDWCxTQUFLLEtBQUssTUFBTSxLQUFLLE9BQU8sS0FBSyxNQUFNLFNBQVUsS0FBSyxJQUFJO0FBQ3hELFVBQUksS0FBSztBQUNQLGFBQUssUUFBUztBQUNkLGFBQUssS0FBSyxTQUFTLEdBQUc7QUFBQSxNQUM5QixPQUFhO0FBQ0wsYUFBSyxLQUFLO0FBQ1YsYUFBSyxLQUFLLFFBQVEsRUFBRTtBQUFBLE1BQ3JCO0FBQUEsSUFDUCxDQUFLO0FBQUEsRUFDRjtBQUVELFdBQVMsaUJBQWtCQSxPQUFNLFNBQVM7QUFDeEMsV0FBTyxJQUFJRCxJQUFHLFdBQVdDLE9BQU0sT0FBTztBQUFBLEVBQ3ZDO0FBRUQsV0FBUyxrQkFBbUJBLE9BQU0sU0FBUztBQUN6QyxXQUFPLElBQUlELElBQUcsWUFBWUMsT0FBTSxPQUFPO0FBQUEsRUFDeEM7QUFFRCxNQUFJLFVBQVVELElBQUc7QUFDakIsRUFBQUEsSUFBRyxPQUFPO0FBQ1YsV0FBUyxLQUFNQyxPQUFNLE9BQU8sTUFBTSxJQUFJO0FBQ3BDLFFBQUksT0FBTyxTQUFTO0FBQ2xCLFdBQUssTUFBTSxPQUFPO0FBRXBCLFdBQU8sUUFBUUEsT0FBTSxPQUFPLE1BQU0sRUFBRTtBQUVwQyxhQUFTLFFBQVNBLE9BQU1vQixRQUFPRSxPQUFNUCxLQUFJLFdBQVc7QUFDbEQsYUFBTyxRQUFRZixPQUFNb0IsUUFBT0UsT0FBTSxTQUFVLEtBQUssSUFBSTtBQUNuRCxZQUFJLFFBQVEsSUFBSSxTQUFTLFlBQVksSUFBSSxTQUFTO0FBQ2hELGtCQUFRLENBQUMsU0FBUyxDQUFDdEIsT0FBTW9CLFFBQU9FLE9BQU1QLEdBQUUsR0FBRyxLQUFLLGFBQWEsS0FBSyxJQUFLLEdBQUUsS0FBSyxJQUFHLENBQUUsQ0FBQztBQUFBLGFBQ2pGO0FBQ0gsY0FBSSxPQUFPQSxRQUFPO0FBQ2hCLFlBQUFBLElBQUcsTUFBTSxNQUFNLFNBQVM7QUFBQSxRQUMzQjtBQUFBLE1BQ1QsQ0FBTztBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBRUQsU0FBT2hCO0FBQ1Q7QUFFQSxTQUFTLFFBQVMsTUFBTTtBQUN0QlksVUFBTSxXQUFXLEtBQUssQ0FBQyxFQUFFLE1BQU0sS0FBSyxDQUFDLENBQUM7QUFDdENaLE9BQUcsYUFBYSxFQUFFLEtBQUssSUFBSTtBQUMzQixRQUFPO0FBQ1Q7QUFHQSxJQUFJO0FBS0osU0FBUyxhQUFjO0FBQ3JCLE1BQUksTUFBTSxLQUFLLElBQUs7QUFDcEIsV0FBUyxJQUFJLEdBQUcsSUFBSUEsS0FBRyxhQUFhLEVBQUUsUUFBUSxFQUFFLEdBQUc7QUFHakQsUUFBSUEsS0FBRyxhQUFhLEVBQUUsQ0FBQyxFQUFFLFNBQVMsR0FBRztBQUNuQ0EsV0FBRyxhQUFhLEVBQUUsQ0FBQyxFQUFFLENBQUMsSUFBSTtBQUMxQkEsV0FBRyxhQUFhLEVBQUUsQ0FBQyxFQUFFLENBQUMsSUFBSTtBQUFBLElBQzNCO0FBQUEsRUFDRjtBQUVELFFBQU87QUFDVDtBQUVBLFNBQVMsUUFBUztBQUVoQixlQUFhLFVBQVU7QUFDdkIsZUFBYTtBQUViLE1BQUlBLEtBQUcsYUFBYSxFQUFFLFdBQVc7QUFDL0I7QUFFRixNQUFJLE9BQU9BLEtBQUcsYUFBYSxFQUFFLE1BQU87QUFDcEMsTUFBSSxLQUFLLEtBQUssQ0FBQztBQUNmLE1BQUksT0FBTyxLQUFLLENBQUM7QUFFakIsTUFBSSxNQUFNLEtBQUssQ0FBQztBQUNoQixNQUFJLFlBQVksS0FBSyxDQUFDO0FBQ3RCLE1BQUksV0FBVyxLQUFLLENBQUM7QUFJckIsTUFBSSxjQUFjLFFBQVc7QUFDM0JZLFlBQU0sU0FBUyxHQUFHLE1BQU0sSUFBSTtBQUM1QixPQUFHLE1BQU0sTUFBTSxJQUFJO0FBQUEsRUFDcEIsV0FBVSxLQUFLLFFBQVEsYUFBYSxLQUFPO0FBRTFDQSxZQUFNLFdBQVcsR0FBRyxNQUFNLElBQUk7QUFDOUIsUUFBSSxLQUFLLEtBQUssSUFBSztBQUNuQixRQUFJLE9BQU8sT0FBTztBQUNoQixTQUFHLEtBQUssTUFBTSxHQUFHO0FBQUEsRUFDdkIsT0FBUztBQUVMLFFBQUksZUFBZSxLQUFLLElBQUcsSUFBSztBQUdoQyxRQUFJLGFBQWEsS0FBSyxJQUFJLFdBQVcsV0FBVyxDQUFDO0FBR2pELFFBQUksZUFBZSxLQUFLLElBQUksYUFBYSxLQUFLLEdBQUc7QUFFakQsUUFBSSxnQkFBZ0IsY0FBYztBQUNoQ0EsY0FBTSxTQUFTLEdBQUcsTUFBTSxJQUFJO0FBQzVCLFNBQUcsTUFBTSxNQUFNLEtBQUssT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDN0MsT0FBVztBQUdMWixXQUFHLGFBQWEsRUFBRSxLQUFLLElBQUk7QUFBQSxJQUM1QjtBQUFBLEVBQ0Y7QUFHRCxNQUFJLGVBQWUsUUFBVztBQUM1QixpQkFBYSxXQUFXLE9BQU8sQ0FBQztBQUFBLEVBQ2pDO0FBQ0g7QUFBQTtBQzViQSxRQUFNd0IsS0FBSTdCLGVBQXdCO0FBQ2xDLFFBQU1LLE1BQUtkO0FBRVgsUUFBTSxNQUFNO0FBQUEsSUFDVjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0YsRUFBRSxPQUFPLFNBQU87QUFJZCxXQUFPLE9BQU9jLElBQUcsR0FBRyxNQUFNO0FBQUEsRUFDNUIsQ0FBQztBQUdELFNBQU8sT0FBT3lCLFVBQVN6QixHQUFFO0FBR3pCLE1BQUksUUFBUSxZQUFVO0FBQ3BCLElBQUF5QixTQUFRLE1BQU0sSUFBSUQsR0FBRXhCLElBQUcsTUFBTSxDQUFDO0FBQUEsRUFDaEMsQ0FBQztBQUlELEVBQUF5QixTQUFBLFNBQWlCLFNBQVUsVUFBVSxVQUFVO0FBQzdDLFFBQUksT0FBTyxhQUFhLFlBQVk7QUFDbEMsYUFBT3pCLElBQUcsT0FBTyxVQUFVLFFBQVE7QUFBQSxJQUNwQztBQUNELFdBQU8sSUFBSSxRQUFRLENBQUFYLGFBQVc7QUFDNUIsYUFBT1csSUFBRyxPQUFPLFVBQVVYLFFBQU87QUFBQSxJQUN0QyxDQUFHO0FBQUEsRUFDRjtBQUlELEVBQUFvQyxTQUFBLE9BQWUsU0FBVSxJQUFJLFFBQVEsUUFBUSxRQUFRLFVBQVUsVUFBVTtBQUN2RSxRQUFJLE9BQU8sYUFBYSxZQUFZO0FBQ2xDLGFBQU96QixJQUFHLEtBQUssSUFBSSxRQUFRLFFBQVEsUUFBUSxVQUFVLFFBQVE7QUFBQSxJQUM5RDtBQUNELFdBQU8sSUFBSSxRQUFRLENBQUNYLFVBQVMsV0FBVztBQUN0QyxNQUFBVyxJQUFHLEtBQUssSUFBSSxRQUFRLFFBQVEsUUFBUSxVQUFVLENBQUMsS0FBSyxXQUFXMEIsWUFBVztBQUN4RSxZQUFJO0FBQUssaUJBQU8sT0FBTyxHQUFHO0FBQzFCLFFBQUFyQyxTQUFRLEVBQUUsV0FBVyxRQUFBcUMsU0FBUTtBQUFBLE1BQ25DLENBQUs7QUFBQSxJQUNMLENBQUc7QUFBQSxFQUNGO0FBT0QsRUFBQUQsU0FBQSxRQUFnQixTQUFVLElBQUksV0FBVyxNQUFNO0FBQzdDLFFBQUksT0FBTyxLQUFLLEtBQUssU0FBUyxDQUFDLE1BQU0sWUFBWTtBQUMvQyxhQUFPekIsSUFBRyxNQUFNLElBQUksUUFBUSxHQUFHLElBQUk7QUFBQSxJQUNwQztBQUVELFdBQU8sSUFBSSxRQUFRLENBQUNYLFVBQVMsV0FBVztBQUN0QyxNQUFBVyxJQUFHLE1BQU0sSUFBSSxRQUFRLEdBQUcsTUFBTSxDQUFDLEtBQUssY0FBYzBCLFlBQVc7QUFDM0QsWUFBSTtBQUFLLGlCQUFPLE9BQU8sR0FBRztBQUMxQixRQUFBckMsU0FBUSxFQUFFLGNBQWMsUUFBQXFDLFNBQVE7QUFBQSxNQUN0QyxDQUFLO0FBQUEsSUFDTCxDQUFHO0FBQUEsRUFDRjtBQUtELEVBQUFELFNBQUEsUUFBZ0IsU0FBVSxJQUFJLFlBQVksTUFBTTtBQUM5QyxRQUFJLE9BQU8sS0FBSyxLQUFLLFNBQVMsQ0FBQyxNQUFNLFlBQVk7QUFDL0MsYUFBT3pCLElBQUcsTUFBTSxJQUFJLFNBQVMsR0FBRyxJQUFJO0FBQUEsSUFDckM7QUFFRCxXQUFPLElBQUksUUFBUSxDQUFDWCxVQUFTLFdBQVc7QUFDdEMsTUFBQVcsSUFBRyxNQUFNLElBQUksU0FBUyxHQUFHLE1BQU0sQ0FBQyxLQUFLLFdBQVcyQixhQUFZO0FBQzFELFlBQUk7QUFBSyxpQkFBTyxPQUFPLEdBQUc7QUFDMUIsUUFBQXRDLFNBQVEsRUFBRSxXQUFXLFNBQUFzQyxVQUFTO0FBQUEsTUFDcEMsQ0FBSztBQUFBLElBQ0wsQ0FBRztBQUFBLEVBQ0Y7QUFLRCxFQUFBRixTQUFBLFNBQWlCLFNBQVUsSUFBSSxZQUFZLE1BQU07QUFDL0MsUUFBSSxPQUFPLEtBQUssS0FBSyxTQUFTLENBQUMsTUFBTSxZQUFZO0FBQy9DLGFBQU96QixJQUFHLE9BQU8sSUFBSSxTQUFTLEdBQUcsSUFBSTtBQUFBLElBQ3RDO0FBRUQsV0FBTyxJQUFJLFFBQVEsQ0FBQ1gsVUFBUyxXQUFXO0FBQ3RDLE1BQUFXLElBQUcsT0FBTyxJQUFJLFNBQVMsR0FBRyxNQUFNLENBQUMsS0FBSyxjQUFjMkIsYUFBWTtBQUM5RCxZQUFJO0FBQUssaUJBQU8sT0FBTyxHQUFHO0FBQzFCLFFBQUF0QyxTQUFRLEVBQUUsY0FBYyxTQUFBc0MsVUFBUztBQUFBLE1BQ3ZDLENBQUs7QUFBQSxJQUNMLENBQUc7QUFBQSxFQUNGO0FBR0QsTUFBSSxPQUFPM0IsSUFBRyxTQUFTLFdBQVcsWUFBWTtBQUM1QyxJQUFBeUIsU0FBUSxTQUFTLFNBQVNELEdBQUV4QixJQUFHLFNBQVMsTUFBTTtBQUFBLEVBQ2hELE9BQU87QUFDTCxZQUFRO0FBQUEsTUFDTjtBQUFBLE1BQ0E7QUFBQSxNQUFXO0FBQUEsSUFDWjtBQUFBLEVBQ0g7Ozs7QUNySUEsTUFBTUMsU0FBT047QUFJYmlDLFFBQUEsWUFBMkIsU0FBUyxVQUFXLEtBQUs7QUFDbEQsTUFBSSxRQUFRLGFBQWEsU0FBUztBQUNoQyxVQUFNLDhCQUE4QixZQUFZLEtBQUssSUFBSSxRQUFRM0IsT0FBSyxNQUFNLEdBQUcsRUFBRSxNQUFNLEVBQUUsQ0FBQztBQUUxRixRQUFJLDZCQUE2QjtBQUMvQixZQUFNWCxTQUFRLElBQUksTUFBTSxxQ0FBcUMsR0FBRyxFQUFFO0FBQ2xFLE1BQUFBLE9BQU0sT0FBTztBQUNiLFlBQU1BO0FBQUEsSUFDUDtBQUFBLEVBQ0Y7QUFDSDtBQ25CQSxNQUFNVSxPQUFLTDtBQUNYLE1BQU0sRUFBRSxXQUFBa0MsV0FBVyxJQUFHM0M7QUFFdEIsTUFBTSxVQUFVLGFBQVc7QUFDekIsUUFBTTRDLFlBQVcsRUFBRSxNQUFNLElBQU87QUFDaEMsTUFBSSxPQUFPLFlBQVk7QUFBVSxXQUFPO0FBQ3hDLFNBQVEsRUFBRSxHQUFHQSxXQUFVLEdBQUcsUUFBUyxFQUFFO0FBQ3ZDO0FBRUFDLFVBQUEsVUFBeUIsT0FBTyxLQUFLLFlBQVk7QUFDL0MsRUFBQUYsV0FBVSxHQUFHO0FBRWIsU0FBTzdCLEtBQUcsTUFBTSxLQUFLO0FBQUEsSUFDbkIsTUFBTSxRQUFRLE9BQU87QUFBQSxJQUNyQixXQUFXO0FBQUEsRUFDZixDQUFHO0FBQ0g7QUFFQStCLFVBQUEsY0FBNkIsQ0FBQyxLQUFLLFlBQVk7QUFDN0MsRUFBQUYsV0FBVSxHQUFHO0FBRWIsU0FBTzdCLEtBQUcsVUFBVSxLQUFLO0FBQUEsSUFDdkIsTUFBTSxRQUFRLE9BQU87QUFBQSxJQUNyQixXQUFXO0FBQUEsRUFDZixDQUFHO0FBQ0g7QUN6QkEsTUFBTXdCLE1BQUk3QixlQUF3QjtBQUNsQyxNQUFNLEVBQUUsU0FBUyxVQUFVLFlBQVcsSUFBS1Q7QUFDM0MsTUFBTSxVQUFVc0MsSUFBRSxRQUFRO0FBRTFCLElBQUFRLFdBQWlCO0FBQUEsRUFDZixRQUFRO0FBQUEsRUFDUixZQUFZO0FBQUE7QUFBQSxFQUVaLFFBQVE7QUFBQSxFQUNSLFlBQVk7QUFBQSxFQUNaLFdBQVc7QUFBQSxFQUNYLGVBQWU7QUFDakI7QUNaQSxNQUFNUixNQUFJN0IsZUFBd0I7QUFDbEMsTUFBTUssT0FBS2Q7QUFFWCxTQUFTK0MsYUFBWWhDLE9BQU07QUFDekIsU0FBT0QsS0FBRyxPQUFPQyxLQUFJLEVBQUUsS0FBSyxNQUFNLElBQUksRUFBRSxNQUFNLE1BQU0sS0FBSztBQUMzRDtBQUVBLElBQUEsZUFBaUI7QUFBQSxFQUNmLFlBQVl1QixJQUFFUyxZQUFVO0FBQUEsRUFDeEIsZ0JBQWdCakMsS0FBRztBQUNyQjtBQ1RBLE1BQU1BLE9BQUtMO0FBQ1gsTUFBTTZCLE1BQUl0QyxlQUF3QjtBQUVsQyxlQUFlZ0QsZUFBY2pDLE9BQU0sT0FBTyxPQUFPO0FBRS9DLFFBQU0sS0FBSyxNQUFNRCxLQUFHLEtBQUtDLE9BQU0sSUFBSTtBQUVuQyxNQUFJLFdBQVc7QUFFZixNQUFJO0FBQ0YsVUFBTUQsS0FBRyxRQUFRLElBQUksT0FBTyxLQUFLO0FBQUEsRUFDckMsVUFBWTtBQUNSLFFBQUk7QUFDRixZQUFNQSxLQUFHLE1BQU0sRUFBRTtBQUFBLElBQ2xCLFNBQVEsR0FBRztBQUNWLGlCQUFXO0FBQUEsSUFDWjtBQUFBLEVBQ0Y7QUFFRCxNQUFJLFVBQVU7QUFDWixVQUFNO0FBQUEsRUFDUDtBQUNIO0FBRUEsU0FBU21DLG1CQUFrQmxDLE9BQU0sT0FBTyxPQUFPO0FBQzdDLFFBQU0sS0FBS0QsS0FBRyxTQUFTQyxPQUFNLElBQUk7QUFDakNELE9BQUcsWUFBWSxJQUFJLE9BQU8sS0FBSztBQUMvQixTQUFPQSxLQUFHLFVBQVUsRUFBRTtBQUN4QjtBQUVBLElBQUEsU0FBaUI7QUFBQSxFQUNmLGNBQWN3QixJQUFFVSxjQUFZO0FBQUEsRUFDOUIsa0JBQUVDO0FBQ0Y7QUNqQ0EsTUFBTW5DLE9BQUtMO0FBQ1gsTUFBTU0sU0FBTztBQUNiLE1BQU11QixNQUFJckMsZUFBd0I7QUFFbEMsU0FBU2lELFdBQVUsS0FBSyxNQUFNLE1BQU07QUFDbEMsUUFBTSxXQUFXLEtBQUssY0FDbEIsQ0FBQ0MsVUFBU3JDLEtBQUcsS0FBS3FDLE9BQU0sRUFBRSxRQUFRLE1BQU0sSUFDeEMsQ0FBQ0EsVUFBU3JDLEtBQUcsTUFBTXFDLE9BQU0sRUFBRSxRQUFRLE1BQU07QUFDN0MsU0FBTyxRQUFRLElBQUk7QUFBQSxJQUNqQixTQUFTLEdBQUc7QUFBQSxJQUNaLFNBQVMsSUFBSSxFQUFFLE1BQU0sU0FBTztBQUMxQixVQUFJLElBQUksU0FBUztBQUFVLGVBQU87QUFDbEMsWUFBTTtBQUFBLElBQ1osQ0FBSztBQUFBLEVBQ0wsQ0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDLFNBQVMsUUFBUSxPQUFPLEVBQUUsU0FBUyxTQUFRLEVBQUc7QUFDMUQ7QUFFQSxTQUFTLGFBQWMsS0FBSyxNQUFNLE1BQU07QUFDdEMsTUFBSTtBQUNKLFFBQU0sV0FBVyxLQUFLLGNBQ2xCLENBQUNBLFVBQVNyQyxLQUFHLFNBQVNxQyxPQUFNLEVBQUUsUUFBUSxNQUFNLElBQzVDLENBQUNBLFVBQVNyQyxLQUFHLFVBQVVxQyxPQUFNLEVBQUUsUUFBUSxNQUFNO0FBQ2pELFFBQU0sVUFBVSxTQUFTLEdBQUc7QUFDNUIsTUFBSTtBQUNGLGVBQVcsU0FBUyxJQUFJO0FBQUEsRUFDekIsU0FBUSxLQUFLO0FBQ1osUUFBSSxJQUFJLFNBQVM7QUFBVSxhQUFPLEVBQUUsU0FBUyxVQUFVLEtBQU07QUFDN0QsVUFBTTtBQUFBLEVBQ1A7QUFDRCxTQUFPLEVBQUUsU0FBUyxTQUFVO0FBQzlCO0FBRUEsZUFBZSxXQUFZLEtBQUssTUFBTSxVQUFVLE1BQU07QUFDcEQsUUFBTSxFQUFFLFNBQVMsU0FBVSxJQUFHLE1BQU1ELFdBQVMsS0FBSyxNQUFNLElBQUk7QUFDNUQsTUFBSSxVQUFVO0FBQ1osUUFBSUUsZUFBYSxTQUFTLFFBQVEsR0FBRztBQUNuQyxZQUFNLGNBQWNyQyxPQUFLLFNBQVMsR0FBRztBQUNyQyxZQUFNLGVBQWVBLE9BQUssU0FBUyxJQUFJO0FBQ3ZDLFVBQUksYUFBYSxVQUNmLGdCQUFnQixnQkFDaEIsWUFBWSxZQUFXLE1BQU8sYUFBYSxZQUFXLEdBQUk7QUFDMUQsZUFBTyxFQUFFLFNBQVMsVUFBVSxnQkFBZ0IsS0FBTTtBQUFBLE1BQ25EO0FBQ0QsWUFBTSxJQUFJLE1BQU0sOENBQThDO0FBQUEsSUFDL0Q7QUFDRCxRQUFJLFFBQVEsWUFBVyxLQUFNLENBQUMsU0FBUyxZQUFXLEdBQUk7QUFDcEQsWUFBTSxJQUFJLE1BQU0sbUNBQW1DLElBQUkscUJBQXFCLEdBQUcsSUFBSTtBQUFBLElBQ3BGO0FBQ0QsUUFBSSxDQUFDLFFBQVEsWUFBYSxLQUFJLFNBQVMsWUFBVyxHQUFJO0FBQ3BELFlBQU0sSUFBSSxNQUFNLCtCQUErQixJQUFJLHlCQUF5QixHQUFHLElBQUk7QUFBQSxJQUNwRjtBQUFBLEVBQ0Y7QUFFRCxNQUFJLFFBQVEsWUFBYSxLQUFJLFlBQVksS0FBSyxJQUFJLEdBQUc7QUFDbkQsVUFBTSxJQUFJLE1BQU0sT0FBTyxLQUFLLE1BQU0sUUFBUSxDQUFDO0FBQUEsRUFDNUM7QUFFRCxTQUFPLEVBQUUsU0FBUyxTQUFVO0FBQzlCO0FBRUEsU0FBUyxlQUFnQixLQUFLLE1BQU0sVUFBVSxNQUFNO0FBQ2xELFFBQU0sRUFBRSxTQUFTLFNBQVUsSUFBRyxhQUFhLEtBQUssTUFBTSxJQUFJO0FBRTFELE1BQUksVUFBVTtBQUNaLFFBQUlxQyxlQUFhLFNBQVMsUUFBUSxHQUFHO0FBQ25DLFlBQU0sY0FBY3JDLE9BQUssU0FBUyxHQUFHO0FBQ3JDLFlBQU0sZUFBZUEsT0FBSyxTQUFTLElBQUk7QUFDdkMsVUFBSSxhQUFhLFVBQ2YsZ0JBQWdCLGdCQUNoQixZQUFZLFlBQVcsTUFBTyxhQUFhLFlBQVcsR0FBSTtBQUMxRCxlQUFPLEVBQUUsU0FBUyxVQUFVLGdCQUFnQixLQUFNO0FBQUEsTUFDbkQ7QUFDRCxZQUFNLElBQUksTUFBTSw4Q0FBOEM7QUFBQSxJQUMvRDtBQUNELFFBQUksUUFBUSxZQUFXLEtBQU0sQ0FBQyxTQUFTLFlBQVcsR0FBSTtBQUNwRCxZQUFNLElBQUksTUFBTSxtQ0FBbUMsSUFBSSxxQkFBcUIsR0FBRyxJQUFJO0FBQUEsSUFDcEY7QUFDRCxRQUFJLENBQUMsUUFBUSxZQUFhLEtBQUksU0FBUyxZQUFXLEdBQUk7QUFDcEQsWUFBTSxJQUFJLE1BQU0sK0JBQStCLElBQUkseUJBQXlCLEdBQUcsSUFBSTtBQUFBLElBQ3BGO0FBQUEsRUFDRjtBQUVELE1BQUksUUFBUSxZQUFhLEtBQUksWUFBWSxLQUFLLElBQUksR0FBRztBQUNuRCxVQUFNLElBQUksTUFBTSxPQUFPLEtBQUssTUFBTSxRQUFRLENBQUM7QUFBQSxFQUM1QztBQUNELFNBQU8sRUFBRSxTQUFTLFNBQVU7QUFDOUI7QUFNQSxlQUFlLGlCQUFrQixLQUFLLFNBQVMsTUFBTSxVQUFVO0FBQzdELFFBQU0sWUFBWUEsT0FBSyxRQUFRQSxPQUFLLFFBQVEsR0FBRyxDQUFDO0FBQ2hELFFBQU0sYUFBYUEsT0FBSyxRQUFRQSxPQUFLLFFBQVEsSUFBSSxDQUFDO0FBQ2xELE1BQUksZUFBZSxhQUFhLGVBQWVBLE9BQUssTUFBTSxVQUFVLEVBQUU7QUFBTTtBQUU1RSxNQUFJO0FBQ0osTUFBSTtBQUNGLGVBQVcsTUFBTUQsS0FBRyxLQUFLLFlBQVksRUFBRSxRQUFRLE1BQU07QUFBQSxFQUN0RCxTQUFRLEtBQUs7QUFDWixRQUFJLElBQUksU0FBUztBQUFVO0FBQzNCLFVBQU07QUFBQSxFQUNQO0FBRUQsTUFBSXNDLGVBQWEsU0FBUyxRQUFRLEdBQUc7QUFDbkMsVUFBTSxJQUFJLE1BQU0sT0FBTyxLQUFLLE1BQU0sUUFBUSxDQUFDO0FBQUEsRUFDNUM7QUFFRCxTQUFPLGlCQUFpQixLQUFLLFNBQVMsWUFBWSxRQUFRO0FBQzVEO0FBRUEsU0FBUyxxQkFBc0IsS0FBSyxTQUFTLE1BQU0sVUFBVTtBQUMzRCxRQUFNLFlBQVlyQyxPQUFLLFFBQVFBLE9BQUssUUFBUSxHQUFHLENBQUM7QUFDaEQsUUFBTSxhQUFhQSxPQUFLLFFBQVFBLE9BQUssUUFBUSxJQUFJLENBQUM7QUFDbEQsTUFBSSxlQUFlLGFBQWEsZUFBZUEsT0FBSyxNQUFNLFVBQVUsRUFBRTtBQUFNO0FBQzVFLE1BQUk7QUFDSixNQUFJO0FBQ0YsZUFBV0QsS0FBRyxTQUFTLFlBQVksRUFBRSxRQUFRLE1BQU07QUFBQSxFQUNwRCxTQUFRLEtBQUs7QUFDWixRQUFJLElBQUksU0FBUztBQUFVO0FBQzNCLFVBQU07QUFBQSxFQUNQO0FBQ0QsTUFBSXNDLGVBQWEsU0FBUyxRQUFRLEdBQUc7QUFDbkMsVUFBTSxJQUFJLE1BQU0sT0FBTyxLQUFLLE1BQU0sUUFBUSxDQUFDO0FBQUEsRUFDNUM7QUFDRCxTQUFPLHFCQUFxQixLQUFLLFNBQVMsWUFBWSxRQUFRO0FBQ2hFO0FBRUEsU0FBU0EsZUFBYyxTQUFTLFVBQVU7QUFDeEMsU0FBTyxTQUFTLE9BQU8sU0FBUyxPQUFPLFNBQVMsUUFBUSxRQUFRLE9BQU8sU0FBUyxRQUFRLFFBQVE7QUFDbEc7QUFJQSxTQUFTLFlBQWEsS0FBSyxNQUFNO0FBQy9CLFFBQU0sU0FBU3JDLE9BQUssUUFBUSxHQUFHLEVBQUUsTUFBTUEsT0FBSyxHQUFHLEVBQUUsT0FBTyxPQUFLLENBQUM7QUFDOUQsUUFBTSxVQUFVQSxPQUFLLFFBQVEsSUFBSSxFQUFFLE1BQU1BLE9BQUssR0FBRyxFQUFFLE9BQU8sT0FBSyxDQUFDO0FBQ2hFLFNBQU8sT0FBTyxNQUFNLENBQUMsS0FBSyxNQUFNLFFBQVEsQ0FBQyxNQUFNLEdBQUc7QUFDcEQ7QUFFQSxTQUFTLE9BQVEsS0FBSyxNQUFNLFVBQVU7QUFDcEMsU0FBTyxVQUFVLFFBQVEsS0FBSyxHQUFHLG1DQUFtQyxJQUFJO0FBQzFFO0FBRUEsSUFBQXNDLFNBQWlCO0FBQUE7QUFBQSxFQUVmLFlBQVlmLElBQUUsVUFBVTtBQUFBLEVBQ3hCO0FBQUE7QUFBQSxFQUVBLGtCQUFrQkEsSUFBRSxnQkFBZ0I7QUFBQSxFQUNwQztBQUFBO0FBQUEsRUFFQTtBQUFBLEVBQ0YsY0FBRWM7QUFDRjtBQzNKQSxNQUFNdEMsT0FBS0w7QUFDWCxNQUFNTSxTQUFPO0FBQ2IsTUFBTSxFQUFFK0IsUUFBQUEsU0FBUSxJQUFHN0M7QUFDbkIsTUFBTSxFQUFFOEMsWUFBQUEsYUFBWSxJQUFHdEI7QUFDdkIsTUFBTSxFQUFFLGFBQWMsSUFBRzZCO0FBQ3pCLE1BQU1ELFNBQU9FO0FBRWIsZUFBZS9CLE9BQU0sS0FBSyxNQUFNLE9BQU8sQ0FBQSxHQUFJO0FBQ3pDLE1BQUksT0FBTyxTQUFTLFlBQVk7QUFDOUIsV0FBTyxFQUFFLFFBQVEsS0FBTTtBQUFBLEVBQ3hCO0FBRUQsT0FBSyxVQUFVLGFBQWEsT0FBTyxDQUFDLENBQUMsS0FBSyxVQUFVO0FBQ3BELE9BQUssWUFBWSxlQUFlLE9BQU8sQ0FBQyxDQUFDLEtBQUssWUFBWSxLQUFLO0FBRy9ELE1BQUksS0FBSyxzQkFBc0IsUUFBUSxTQUFTLFFBQVE7QUFDdEQsWUFBUTtBQUFBLE1BQ047QUFBQSxNQUVBO0FBQUEsTUFBVztBQUFBLElBQ1o7QUFBQSxFQUNGO0FBRUQsUUFBTSxFQUFFLFNBQVMsU0FBUSxJQUFLLE1BQU02QixPQUFLLFdBQVcsS0FBSyxNQUFNLFFBQVEsSUFBSTtBQUUzRSxRQUFNQSxPQUFLLGlCQUFpQixLQUFLLFNBQVMsTUFBTSxNQUFNO0FBRXRELFFBQU0sVUFBVSxNQUFNLFVBQVUsS0FBSyxNQUFNLElBQUk7QUFFL0MsTUFBSSxDQUFDO0FBQVM7QUFHZCxRQUFNLGFBQWF0QyxPQUFLLFFBQVEsSUFBSTtBQUNwQyxRQUFNLFlBQVksTUFBTWdDLGFBQVcsVUFBVTtBQUM3QyxNQUFJLENBQUMsV0FBVztBQUNkLFVBQU1ELFNBQU8sVUFBVTtBQUFBLEVBQ3hCO0FBRUQsUUFBTSx1QkFBdUIsVUFBVSxLQUFLLE1BQU0sSUFBSTtBQUN4RDtBQUVBLGVBQWUsVUFBVyxLQUFLLE1BQU0sTUFBTTtBQUN6QyxNQUFJLENBQUMsS0FBSztBQUFRLFdBQU87QUFDekIsU0FBTyxLQUFLLE9BQU8sS0FBSyxJQUFJO0FBQzlCO0FBRUEsZUFBZSx1QkFBd0IsVUFBVSxLQUFLLE1BQU0sTUFBTTtBQUNoRSxRQUFNLFNBQVMsS0FBSyxjQUFjaEMsS0FBRyxPQUFPQSxLQUFHO0FBQy9DLFFBQU0sVUFBVSxNQUFNLE9BQU8sR0FBRztBQUVoQyxNQUFJLFFBQVEsWUFBYTtBQUFFLFdBQU8wQyxRQUFNLFNBQVMsVUFBVSxLQUFLLE1BQU0sSUFBSTtBQUUxRSxNQUNFLFFBQVEsT0FBUSxLQUNoQixRQUFRLGtCQUFtQixLQUMzQixRQUFRLGNBQWU7QUFDdkIsV0FBT0MsU0FBTyxTQUFTLFVBQVUsS0FBSyxNQUFNLElBQUk7QUFFbEQsTUFBSSxRQUFRLGVBQWM7QUFBSSxXQUFPQyxTQUFPLFVBQVUsS0FBSyxNQUFNLElBQUk7QUFDckUsTUFBSSxRQUFRLFNBQVE7QUFBSSxVQUFNLElBQUksTUFBTSw4QkFBOEIsR0FBRyxFQUFFO0FBQzNFLE1BQUksUUFBUSxPQUFNO0FBQUksVUFBTSxJQUFJLE1BQU0sNEJBQTRCLEdBQUcsRUFBRTtBQUN2RSxRQUFNLElBQUksTUFBTSxpQkFBaUIsR0FBRyxFQUFFO0FBQ3hDO0FBRUEsZUFBZUQsU0FBUSxTQUFTLFVBQVUsS0FBSyxNQUFNLE1BQU07QUFDekQsTUFBSSxDQUFDO0FBQVUsV0FBT3pCLFdBQVMsU0FBUyxLQUFLLE1BQU0sSUFBSTtBQUV2RCxNQUFJLEtBQUssV0FBVztBQUNsQixVQUFNbEIsS0FBRyxPQUFPLElBQUk7QUFDcEIsV0FBT2tCLFdBQVMsU0FBUyxLQUFLLE1BQU0sSUFBSTtBQUFBLEVBQ3pDO0FBQ0QsTUFBSSxLQUFLLGNBQWM7QUFDckIsVUFBTSxJQUFJLE1BQU0sSUFBSSxJQUFJLGtCQUFrQjtBQUFBLEVBQzNDO0FBQ0g7QUFFQSxlQUFlQSxXQUFVLFNBQVMsS0FBSyxNQUFNLE1BQU07QUFDakQsUUFBTWxCLEtBQUcsU0FBUyxLQUFLLElBQUk7QUFDM0IsTUFBSSxLQUFLLG9CQUFvQjtBQUkzQixRQUFJNkMsb0JBQWtCLFFBQVEsSUFBSSxHQUFHO0FBQ25DLFlBQU1DLG1CQUFpQixNQUFNLFFBQVEsSUFBSTtBQUFBLElBQzFDO0FBT0QsVUFBTSxpQkFBaUIsTUFBTTlDLEtBQUcsS0FBSyxHQUFHO0FBQ3hDLFVBQU0sYUFBYSxNQUFNLGVBQWUsT0FBTyxlQUFlLEtBQUs7QUFBQSxFQUNwRTtBQUVELFNBQU9BLEtBQUcsTUFBTSxNQUFNLFFBQVEsSUFBSTtBQUNwQztBQUVBLFNBQVM2QyxvQkFBbUIsU0FBUztBQUNuQyxVQUFRLFVBQVUsU0FBVztBQUMvQjtBQUVBLFNBQVNDLG1CQUFrQixNQUFNLFNBQVM7QUFDeEMsU0FBTzlDLEtBQUcsTUFBTSxNQUFNLFVBQVUsR0FBSztBQUN2QztBQUVBLGVBQWUwQyxRQUFPLFNBQVMsVUFBVSxLQUFLLE1BQU0sTUFBTTtBQUV4RCxNQUFJLENBQUMsVUFBVTtBQUNiLFVBQU0xQyxLQUFHLE1BQU0sSUFBSTtBQUFBLEVBQ3BCO0FBRUQsUUFBTStDLFNBQVEsTUFBTS9DLEtBQUcsUUFBUSxHQUFHO0FBR2xDLFFBQU0sUUFBUSxJQUFJK0MsT0FBTSxJQUFJLE9BQU0sU0FBUTtBQUN4QyxVQUFNLFVBQVU5QyxPQUFLLEtBQUssS0FBSyxJQUFJO0FBQ25DLFVBQU0sV0FBV0EsT0FBSyxLQUFLLE1BQU0sSUFBSTtBQUdyQyxVQUFNLFVBQVUsTUFBTSxVQUFVLFNBQVMsVUFBVSxJQUFJO0FBQ3ZELFFBQUksQ0FBQztBQUFTO0FBRWQsVUFBTSxFQUFFLFVBQUErQyxVQUFVLElBQUcsTUFBTVQsT0FBSyxXQUFXLFNBQVMsVUFBVSxRQUFRLElBQUk7QUFJMUUsV0FBTyx1QkFBdUJTLFdBQVUsU0FBUyxVQUFVLElBQUk7QUFBQSxFQUNuRSxDQUFHLENBQUM7QUFFRixNQUFJLENBQUMsVUFBVTtBQUNiLFVBQU1oRCxLQUFHLE1BQU0sTUFBTSxRQUFRLElBQUk7QUFBQSxFQUNsQztBQUNIO0FBRUEsZUFBZTRDLFNBQVEsVUFBVSxLQUFLLE1BQU0sTUFBTTtBQUNoRCxNQUFJLGNBQWMsTUFBTTVDLEtBQUcsU0FBUyxHQUFHO0FBQ3ZDLE1BQUksS0FBSyxhQUFhO0FBQ3BCLGtCQUFjQyxPQUFLLFFBQVEsUUFBUSxJQUFHLEdBQUksV0FBVztBQUFBLEVBQ3REO0FBQ0QsTUFBSSxDQUFDLFVBQVU7QUFDYixXQUFPRCxLQUFHLFFBQVEsYUFBYSxJQUFJO0FBQUEsRUFDcEM7QUFFRCxNQUFJLGVBQWU7QUFDbkIsTUFBSTtBQUNGLG1CQUFlLE1BQU1BLEtBQUcsU0FBUyxJQUFJO0FBQUEsRUFDdEMsU0FBUSxHQUFHO0FBSVYsUUFBSSxFQUFFLFNBQVMsWUFBWSxFQUFFLFNBQVM7QUFBVyxhQUFPQSxLQUFHLFFBQVEsYUFBYSxJQUFJO0FBQ3BGLFVBQU07QUFBQSxFQUNQO0FBQ0QsTUFBSSxLQUFLLGFBQWE7QUFDcEIsbUJBQWVDLE9BQUssUUFBUSxRQUFRLElBQUcsR0FBSSxZQUFZO0FBQUEsRUFDeEQ7QUFDRCxNQUFJc0MsT0FBSyxZQUFZLGFBQWEsWUFBWSxHQUFHO0FBQy9DLFVBQU0sSUFBSSxNQUFNLGdCQUFnQixXQUFXLG1DQUFtQyxZQUFZLElBQUk7QUFBQSxFQUMvRjtBQUtELE1BQUlBLE9BQUssWUFBWSxjQUFjLFdBQVcsR0FBRztBQUMvQyxVQUFNLElBQUksTUFBTSxxQkFBcUIsWUFBWSxXQUFXLFdBQVcsSUFBSTtBQUFBLEVBQzVFO0FBR0QsUUFBTXZDLEtBQUcsT0FBTyxJQUFJO0FBQ3BCLFNBQU9BLEtBQUcsUUFBUSxhQUFhLElBQUk7QUFDckM7QUFFQSxJQUFBLFNBQWlCVTtBQzlLakIsTUFBTVYsT0FBS0w7QUFDWCxNQUFNTSxTQUFPO0FBQ2IsTUFBTWdELGVBQWE5RCxTQUFxQjtBQUN4QyxNQUFNLG1CQUFtQndCLE9BQTBCO0FBQ25ELE1BQU00QixTQUFPQztBQUViLFNBQVNVLFdBQVUsS0FBSyxNQUFNLE1BQU07QUFDbEMsTUFBSSxPQUFPLFNBQVMsWUFBWTtBQUM5QixXQUFPLEVBQUUsUUFBUSxLQUFNO0FBQUEsRUFDeEI7QUFFRCxTQUFPLFFBQVEsQ0FBRTtBQUNqQixPQUFLLFVBQVUsYUFBYSxPQUFPLENBQUMsQ0FBQyxLQUFLLFVBQVU7QUFDcEQsT0FBSyxZQUFZLGVBQWUsT0FBTyxDQUFDLENBQUMsS0FBSyxZQUFZLEtBQUs7QUFHL0QsTUFBSSxLQUFLLHNCQUFzQixRQUFRLFNBQVMsUUFBUTtBQUN0RCxZQUFRO0FBQUEsTUFDTjtBQUFBLE1BRUE7QUFBQSxNQUFXO0FBQUEsSUFDWjtBQUFBLEVBQ0Y7QUFFRCxRQUFNLEVBQUUsU0FBUyxTQUFRLElBQUtYLE9BQUssZUFBZSxLQUFLLE1BQU0sUUFBUSxJQUFJO0FBQ3pFQSxTQUFLLHFCQUFxQixLQUFLLFNBQVMsTUFBTSxNQUFNO0FBQ3BELE1BQUksS0FBSyxVQUFVLENBQUMsS0FBSyxPQUFPLEtBQUssSUFBSTtBQUFHO0FBQzVDLFFBQU0sYUFBYXRDLE9BQUssUUFBUSxJQUFJO0FBQ3BDLE1BQUksQ0FBQ0QsS0FBRyxXQUFXLFVBQVU7QUFBR2lELGlCQUFXLFVBQVU7QUFDckQsU0FBTyxTQUFTLFVBQVUsS0FBSyxNQUFNLElBQUk7QUFDM0M7QUFFQSxTQUFTLFNBQVUsVUFBVSxLQUFLLE1BQU0sTUFBTTtBQUM1QyxRQUFNLFdBQVcsS0FBSyxjQUFjakQsS0FBRyxXQUFXQSxLQUFHO0FBQ3JELFFBQU0sVUFBVSxTQUFTLEdBQUc7QUFFNUIsTUFBSSxRQUFRLFlBQWE7QUFBRSxXQUFPLE1BQU0sU0FBUyxVQUFVLEtBQUssTUFBTSxJQUFJO0FBQUEsV0FDakUsUUFBUSxPQUFRLEtBQ2hCLFFBQVEsa0JBQW1CLEtBQzNCLFFBQVEsY0FBZTtBQUFFLFdBQU8sT0FBTyxTQUFTLFVBQVUsS0FBSyxNQUFNLElBQUk7QUFBQSxXQUN6RSxRQUFRLGVBQWM7QUFBSSxXQUFPLE9BQU8sVUFBVSxLQUFLLE1BQU0sSUFBSTtBQUFBLFdBQ2pFLFFBQVEsU0FBUTtBQUFJLFVBQU0sSUFBSSxNQUFNLDhCQUE4QixHQUFHLEVBQUU7QUFBQSxXQUN2RSxRQUFRLE9BQU07QUFBSSxVQUFNLElBQUksTUFBTSw0QkFBNEIsR0FBRyxFQUFFO0FBQzVFLFFBQU0sSUFBSSxNQUFNLGlCQUFpQixHQUFHLEVBQUU7QUFDeEM7QUFFQSxTQUFTLE9BQVEsU0FBUyxVQUFVLEtBQUssTUFBTSxNQUFNO0FBQ25ELE1BQUksQ0FBQztBQUFVLFdBQU8sU0FBUyxTQUFTLEtBQUssTUFBTSxJQUFJO0FBQ3ZELFNBQU8sWUFBWSxTQUFTLEtBQUssTUFBTSxJQUFJO0FBQzdDO0FBRUEsU0FBUyxZQUFhLFNBQVMsS0FBSyxNQUFNLE1BQU07QUFDOUMsTUFBSSxLQUFLLFdBQVc7QUFDbEJBLFNBQUcsV0FBVyxJQUFJO0FBQ2xCLFdBQU8sU0FBUyxTQUFTLEtBQUssTUFBTSxJQUFJO0FBQUEsRUFDNUMsV0FBYSxLQUFLLGNBQWM7QUFDNUIsVUFBTSxJQUFJLE1BQU0sSUFBSSxJQUFJLGtCQUFrQjtBQUFBLEVBQzNDO0FBQ0g7QUFFQSxTQUFTLFNBQVUsU0FBUyxLQUFLLE1BQU0sTUFBTTtBQUMzQ0EsT0FBRyxhQUFhLEtBQUssSUFBSTtBQUN6QixNQUFJLEtBQUs7QUFBb0IscUJBQWlCLFFBQVEsTUFBTSxLQUFLLElBQUk7QUFDckUsU0FBTyxZQUFZLE1BQU0sUUFBUSxJQUFJO0FBQ3ZDO0FBRUEsU0FBUyxpQkFBa0IsU0FBUyxLQUFLLE1BQU07QUFJN0MsTUFBSSxrQkFBa0IsT0FBTztBQUFHLHFCQUFpQixNQUFNLE9BQU87QUFDOUQsU0FBTyxrQkFBa0IsS0FBSyxJQUFJO0FBQ3BDO0FBRUEsU0FBUyxrQkFBbUIsU0FBUztBQUNuQyxVQUFRLFVBQVUsU0FBVztBQUMvQjtBQUVBLFNBQVMsaUJBQWtCLE1BQU0sU0FBUztBQUN4QyxTQUFPLFlBQVksTUFBTSxVQUFVLEdBQUs7QUFDMUM7QUFFQSxTQUFTLFlBQWEsTUFBTSxTQUFTO0FBQ25DLFNBQU9BLEtBQUcsVUFBVSxNQUFNLE9BQU87QUFDbkM7QUFFQSxTQUFTLGtCQUFtQixLQUFLLE1BQU07QUFJckMsUUFBTSxpQkFBaUJBLEtBQUcsU0FBUyxHQUFHO0FBQ3RDLFNBQU8saUJBQWlCLE1BQU0sZUFBZSxPQUFPLGVBQWUsS0FBSztBQUMxRTtBQUVBLFNBQVMsTUFBTyxTQUFTLFVBQVUsS0FBSyxNQUFNLE1BQU07QUFDbEQsTUFBSSxDQUFDO0FBQVUsV0FBTyxhQUFhLFFBQVEsTUFBTSxLQUFLLE1BQU0sSUFBSTtBQUNoRSxTQUFPLFFBQVEsS0FBSyxNQUFNLElBQUk7QUFDaEM7QUFFQSxTQUFTLGFBQWMsU0FBUyxLQUFLLE1BQU0sTUFBTTtBQUMvQ0EsT0FBRyxVQUFVLElBQUk7QUFDakIsVUFBUSxLQUFLLE1BQU0sSUFBSTtBQUN2QixTQUFPLFlBQVksTUFBTSxPQUFPO0FBQ2xDO0FBRUEsU0FBUyxRQUFTLEtBQUssTUFBTSxNQUFNO0FBQ2pDQSxPQUFHLFlBQVksR0FBRyxFQUFFLFFBQVEsVUFBUSxZQUFZLE1BQU0sS0FBSyxNQUFNLElBQUksQ0FBQztBQUN4RTtBQUVBLFNBQVMsWUFBYSxNQUFNLEtBQUssTUFBTSxNQUFNO0FBQzNDLFFBQU0sVUFBVUMsT0FBSyxLQUFLLEtBQUssSUFBSTtBQUNuQyxRQUFNLFdBQVdBLE9BQUssS0FBSyxNQUFNLElBQUk7QUFDckMsTUFBSSxLQUFLLFVBQVUsQ0FBQyxLQUFLLE9BQU8sU0FBUyxRQUFRO0FBQUc7QUFDcEQsUUFBTSxFQUFFLFNBQVUsSUFBR3NDLE9BQUssZUFBZSxTQUFTLFVBQVUsUUFBUSxJQUFJO0FBQ3hFLFNBQU8sU0FBUyxVQUFVLFNBQVMsVUFBVSxJQUFJO0FBQ25EO0FBRUEsU0FBUyxPQUFRLFVBQVUsS0FBSyxNQUFNLE1BQU07QUFDMUMsTUFBSSxjQUFjdkMsS0FBRyxhQUFhLEdBQUc7QUFDckMsTUFBSSxLQUFLLGFBQWE7QUFDcEIsa0JBQWNDLE9BQUssUUFBUSxRQUFRLElBQUcsR0FBSSxXQUFXO0FBQUEsRUFDdEQ7QUFFRCxNQUFJLENBQUMsVUFBVTtBQUNiLFdBQU9ELEtBQUcsWUFBWSxhQUFhLElBQUk7QUFBQSxFQUMzQyxPQUFTO0FBQ0wsUUFBSTtBQUNKLFFBQUk7QUFDRixxQkFBZUEsS0FBRyxhQUFhLElBQUk7QUFBQSxJQUNwQyxTQUFRLEtBQUs7QUFJWixVQUFJLElBQUksU0FBUyxZQUFZLElBQUksU0FBUztBQUFXLGVBQU9BLEtBQUcsWUFBWSxhQUFhLElBQUk7QUFDNUYsWUFBTTtBQUFBLElBQ1A7QUFDRCxRQUFJLEtBQUssYUFBYTtBQUNwQixxQkFBZUMsT0FBSyxRQUFRLFFBQVEsSUFBRyxHQUFJLFlBQVk7QUFBQSxJQUN4RDtBQUNELFFBQUlzQyxPQUFLLFlBQVksYUFBYSxZQUFZLEdBQUc7QUFDL0MsWUFBTSxJQUFJLE1BQU0sZ0JBQWdCLFdBQVcsbUNBQW1DLFlBQVksSUFBSTtBQUFBLElBQy9GO0FBS0QsUUFBSUEsT0FBSyxZQUFZLGNBQWMsV0FBVyxHQUFHO0FBQy9DLFlBQU0sSUFBSSxNQUFNLHFCQUFxQixZQUFZLFdBQVcsV0FBVyxJQUFJO0FBQUEsSUFDNUU7QUFDRCxXQUFPLFNBQVMsYUFBYSxJQUFJO0FBQUEsRUFDbEM7QUFDSDtBQUVBLFNBQVMsU0FBVSxhQUFhLE1BQU07QUFDcEN2QyxPQUFHLFdBQVcsSUFBSTtBQUNsQixTQUFPQSxLQUFHLFlBQVksYUFBYSxJQUFJO0FBQ3pDO0FBRUEsSUFBQSxhQUFpQmtEO0FDOUpqQixNQUFNMUIsTUFBSTdCLGVBQXdCO0FBQ2xDLElBQUFlLFNBQWlCO0FBQUEsRUFDZixNQUFNYyxJQUFFdEMsTUFBaUI7QUFBQSxFQUN6QixVQUFVQztBQUNaO0FDSkEsTUFBTWEsT0FBS0w7QUFDWCxNQUFNNkIsTUFBSXRDLGVBQXdCO0FBRWxDLFNBQVNpRSxTQUFRbEQsT0FBTSxVQUFVO0FBQy9CRCxPQUFHLEdBQUdDLE9BQU0sRUFBRSxXQUFXLE1BQU0sT0FBTyxLQUFNLEdBQUUsUUFBUTtBQUN4RDtBQUVBLFNBQVNtRCxhQUFZbkQsT0FBTTtBQUN6QkQsT0FBRyxPQUFPQyxPQUFNLEVBQUUsV0FBVyxNQUFNLE9BQU8sTUFBTTtBQUNsRDtBQUVBLElBQUEsV0FBaUI7QUFBQSxFQUNmLFFBQVF1QixJQUFFMkIsUUFBTTtBQUFBLEVBQ2xCLFlBQUVDO0FBQ0Y7QUNkQSxNQUFNNUIsTUFBSTdCLGVBQXdCO0FBQ2xDLE1BQU1LLE9BQUtkO0FBQ1gsTUFBTWUsU0FBT2Q7QUFDYixNQUFNa0UsVUFBUTFDO0FBQ2QsTUFBTXdDLFdBQVNYO0FBRWYsTUFBTSxXQUFXaEIsSUFBRSxlQUFlOEIsVUFBVSxLQUFLO0FBQy9DLE1BQUlQO0FBQ0osTUFBSTtBQUNGLElBQUFBLFNBQVEsTUFBTS9DLEtBQUcsUUFBUSxHQUFHO0FBQUEsRUFDaEMsUUFBVTtBQUNOLFdBQU9xRCxRQUFNLE9BQU8sR0FBRztBQUFBLEVBQ3hCO0FBRUQsU0FBTyxRQUFRLElBQUlOLE9BQU0sSUFBSSxVQUFRSSxTQUFPLE9BQU9sRCxPQUFLLEtBQUssS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQzNFLENBQUM7QUFFRCxTQUFTLGFBQWMsS0FBSztBQUMxQixNQUFJOEM7QUFDSixNQUFJO0FBQ0YsSUFBQUEsU0FBUS9DLEtBQUcsWUFBWSxHQUFHO0FBQUEsRUFDOUIsUUFBVTtBQUNOLFdBQU9xRCxRQUFNLFdBQVcsR0FBRztBQUFBLEVBQzVCO0FBRUQsRUFBQU4sT0FBTSxRQUFRLFVBQVE7QUFDcEIsV0FBTzlDLE9BQUssS0FBSyxLQUFLLElBQUk7QUFDMUJrRCxhQUFPLFdBQVcsSUFBSTtBQUFBLEVBQzFCLENBQUc7QUFDSDtBQUVBLElBQUEsUUFBaUI7QUFBQSxFQUNmO0FBQUEsRUFDQSxjQUFjO0FBQUEsRUFDZDtBQUFBLEVBQ0EsVUFBVTtBQUNaO0FDcENBLE1BQU0zQixNQUFJN0IsZUFBd0I7QUFDbEMsTUFBTU0sU0FBTztBQUNiLE1BQU1ELE9BQUtiO0FBQ1gsTUFBTWtFLFVBQVExQztBQUVkLGVBQWU0QyxhQUFZbEIsT0FBTTtBQUMvQixNQUFJO0FBQ0osTUFBSTtBQUNGLFlBQVEsTUFBTXJDLEtBQUcsS0FBS3FDLEtBQUk7QUFBQSxFQUMzQixRQUFPO0FBQUEsRUFBRztBQUNYLE1BQUksU0FBUyxNQUFNLE9BQU07QUFBSTtBQUU3QixRQUFNLE1BQU1wQyxPQUFLLFFBQVFvQyxLQUFJO0FBRTdCLE1BQUksV0FBVztBQUNmLE1BQUk7QUFDRixlQUFXLE1BQU1yQyxLQUFHLEtBQUssR0FBRztBQUFBLEVBQzdCLFNBQVEsS0FBSztBQUVaLFFBQUksSUFBSSxTQUFTLFVBQVU7QUFDekIsWUFBTXFELFFBQU0sT0FBTyxHQUFHO0FBQ3RCLFlBQU1yRCxLQUFHLFVBQVVxQyxPQUFNLEVBQUU7QUFDM0I7QUFBQSxJQUNOLE9BQVc7QUFDTCxZQUFNO0FBQUEsSUFDUDtBQUFBLEVBQ0Y7QUFFRCxNQUFJLFNBQVMsZUFBZTtBQUMxQixVQUFNckMsS0FBRyxVQUFVcUMsT0FBTSxFQUFFO0FBQUEsRUFDL0IsT0FBUztBQUdMLFVBQU1yQyxLQUFHLFFBQVEsR0FBRztBQUFBLEVBQ3JCO0FBQ0g7QUFFQSxTQUFTd0QsaUJBQWdCbkIsT0FBTTtBQUM3QixNQUFJO0FBQ0osTUFBSTtBQUNGLFlBQVFyQyxLQUFHLFNBQVNxQyxLQUFJO0FBQUEsRUFDekIsUUFBTztBQUFBLEVBQUc7QUFDWCxNQUFJLFNBQVMsTUFBTSxPQUFNO0FBQUk7QUFFN0IsUUFBTSxNQUFNcEMsT0FBSyxRQUFRb0MsS0FBSTtBQUM3QixNQUFJO0FBQ0YsUUFBSSxDQUFDckMsS0FBRyxTQUFTLEdBQUcsRUFBRSxZQUFXLEdBQUk7QUFHbkNBLFdBQUcsWUFBWSxHQUFHO0FBQUEsSUFDbkI7QUFBQSxFQUNGLFNBQVEsS0FBSztBQUVaLFFBQUksT0FBTyxJQUFJLFNBQVM7QUFBVXFELGNBQU0sV0FBVyxHQUFHO0FBQUE7QUFDakQsWUFBTTtBQUFBLEVBQ1o7QUFFRHJELE9BQUcsY0FBY3FDLE9BQU0sRUFBRTtBQUMzQjtBQUVBLElBQUEsT0FBaUI7QUFBQSxFQUNmLFlBQVliLElBQUUrQixZQUFVO0FBQUEsRUFDMUIsZ0JBQUVDO0FBQ0Y7QUMvREEsTUFBTWhDLE1BQUk3QixlQUF3QjtBQUNsQyxNQUFNTSxTQUFPO0FBQ2IsTUFBTUQsT0FBS2I7QUFDWCxNQUFNa0UsVUFBUTFDO0FBQ2QsTUFBTSxFQUFFc0IsWUFBQUEsYUFBWSxJQUFHTztBQUN2QixNQUFNLEVBQUVGLGNBQUFBLGVBQWMsSUFBR0c7QUFFekIsZUFBZWdCLGFBQVksU0FBUyxTQUFTO0FBQzNDLE1BQUk7QUFDSixNQUFJO0FBQ0YsY0FBVSxNQUFNekQsS0FBRyxNQUFNLE9BQU87QUFBQSxFQUNwQyxRQUFVO0FBQUEsRUFFUDtBQUVELE1BQUk7QUFDSixNQUFJO0FBQ0YsY0FBVSxNQUFNQSxLQUFHLE1BQU0sT0FBTztBQUFBLEVBQ2pDLFNBQVEsS0FBSztBQUNaLFFBQUksVUFBVSxJQUFJLFFBQVEsUUFBUSxTQUFTLFlBQVk7QUFDdkQsVUFBTTtBQUFBLEVBQ1A7QUFFRCxNQUFJLFdBQVdzQyxlQUFhLFNBQVMsT0FBTztBQUFHO0FBRS9DLFFBQU0sTUFBTXJDLE9BQUssUUFBUSxPQUFPO0FBRWhDLFFBQU0sWUFBWSxNQUFNZ0MsYUFBVyxHQUFHO0FBRXRDLE1BQUksQ0FBQyxXQUFXO0FBQ2QsVUFBTW9CLFFBQU0sT0FBTyxHQUFHO0FBQUEsRUFDdkI7QUFFRCxRQUFNckQsS0FBRyxLQUFLLFNBQVMsT0FBTztBQUNoQztBQUVBLFNBQVMwRCxpQkFBZ0IsU0FBUyxTQUFTO0FBQ3pDLE1BQUk7QUFDSixNQUFJO0FBQ0YsY0FBVTFELEtBQUcsVUFBVSxPQUFPO0FBQUEsRUFDL0IsUUFBTztBQUFBLEVBQUU7QUFFVixNQUFJO0FBQ0YsVUFBTSxVQUFVQSxLQUFHLFVBQVUsT0FBTztBQUNwQyxRQUFJLFdBQVdzQyxlQUFhLFNBQVMsT0FBTztBQUFHO0FBQUEsRUFDaEQsU0FBUSxLQUFLO0FBQ1osUUFBSSxVQUFVLElBQUksUUFBUSxRQUFRLFNBQVMsWUFBWTtBQUN2RCxVQUFNO0FBQUEsRUFDUDtBQUVELFFBQU0sTUFBTXJDLE9BQUssUUFBUSxPQUFPO0FBQ2hDLFFBQU0sWUFBWUQsS0FBRyxXQUFXLEdBQUc7QUFDbkMsTUFBSTtBQUFXLFdBQU9BLEtBQUcsU0FBUyxTQUFTLE9BQU87QUFDbERxRCxVQUFNLFdBQVcsR0FBRztBQUVwQixTQUFPckQsS0FBRyxTQUFTLFNBQVMsT0FBTztBQUNyQztBQUVBLElBQUEsT0FBaUI7QUFBQSxFQUNmLFlBQVl3QixJQUFFaUMsWUFBVTtBQUFBLEVBQzFCLGdCQUFFQztBQUNGO0FDN0RBLE1BQU16RCxTQUFPTjtBQUNiLE1BQU1LLE9BQUtkO0FBQ1gsTUFBTSxFQUFFK0MsWUFBQUEsYUFBWSxJQUFHOUM7QUFFdkIsTUFBTXFDLE1BQUliLGVBQXdCO0FBd0JsQyxlQUFlZ0QsZUFBYyxTQUFTLFNBQVM7QUFDN0MsTUFBSTFELE9BQUssV0FBVyxPQUFPLEdBQUc7QUFDNUIsUUFBSTtBQUNGLFlBQU1ELEtBQUcsTUFBTSxPQUFPO0FBQUEsSUFDdkIsU0FBUSxLQUFLO0FBQ1osVUFBSSxVQUFVLElBQUksUUFBUSxRQUFRLFNBQVMsZUFBZTtBQUMxRCxZQUFNO0FBQUEsSUFDUDtBQUVELFdBQU87QUFBQSxNQUNMLE9BQU87QUFBQSxNQUNQLE9BQU87QUFBQSxJQUNSO0FBQUEsRUFDRjtBQUVELFFBQU0sU0FBU0MsT0FBSyxRQUFRLE9BQU87QUFDbkMsUUFBTSxnQkFBZ0JBLE9BQUssS0FBSyxRQUFRLE9BQU87QUFFL0MsUUFBTSxTQUFTLE1BQU1nQyxhQUFXLGFBQWE7QUFDN0MsTUFBSSxRQUFRO0FBQ1YsV0FBTztBQUFBLE1BQ0wsT0FBTztBQUFBLE1BQ1AsT0FBTztBQUFBLElBQ1I7QUFBQSxFQUNGO0FBRUQsTUFBSTtBQUNGLFVBQU1qQyxLQUFHLE1BQU0sT0FBTztBQUFBLEVBQ3ZCLFNBQVEsS0FBSztBQUNaLFFBQUksVUFBVSxJQUFJLFFBQVEsUUFBUSxTQUFTLGVBQWU7QUFDMUQsVUFBTTtBQUFBLEVBQ1A7QUFFRCxTQUFPO0FBQUEsSUFDTCxPQUFPO0FBQUEsSUFDUCxPQUFPQyxPQUFLLFNBQVMsUUFBUSxPQUFPO0FBQUEsRUFDckM7QUFDSDtBQUVBLFNBQVMyRCxtQkFBa0IsU0FBUyxTQUFTO0FBQzNDLE1BQUkzRCxPQUFLLFdBQVcsT0FBTyxHQUFHO0FBQzVCLFVBQU00RCxVQUFTN0QsS0FBRyxXQUFXLE9BQU87QUFDcEMsUUFBSSxDQUFDNkQ7QUFBUSxZQUFNLElBQUksTUFBTSxpQ0FBaUM7QUFDOUQsV0FBTztBQUFBLE1BQ0wsT0FBTztBQUFBLE1BQ1AsT0FBTztBQUFBLElBQ1I7QUFBQSxFQUNGO0FBRUQsUUFBTSxTQUFTNUQsT0FBSyxRQUFRLE9BQU87QUFDbkMsUUFBTSxnQkFBZ0JBLE9BQUssS0FBSyxRQUFRLE9BQU87QUFDL0MsUUFBTSxTQUFTRCxLQUFHLFdBQVcsYUFBYTtBQUMxQyxNQUFJLFFBQVE7QUFDVixXQUFPO0FBQUEsTUFDTCxPQUFPO0FBQUEsTUFDUCxPQUFPO0FBQUEsSUFDUjtBQUFBLEVBQ0Y7QUFFRCxRQUFNLFlBQVlBLEtBQUcsV0FBVyxPQUFPO0FBQ3ZDLE1BQUksQ0FBQztBQUFXLFVBQU0sSUFBSSxNQUFNLGlDQUFpQztBQUNqRSxTQUFPO0FBQUEsSUFDTCxPQUFPO0FBQUEsSUFDUCxPQUFPQyxPQUFLLFNBQVMsUUFBUSxPQUFPO0FBQUEsRUFDckM7QUFDSDtBQUVBLElBQUEsaUJBQWlCO0FBQUEsRUFDZixjQUFjdUIsSUFBRW1DLGNBQVk7QUFBQSxFQUM5QixrQkFBRUM7QUFDRjtBQ2xHQSxNQUFNNUQsT0FBS0w7QUFDWCxNQUFNNkIsTUFBSXRDLGVBQXdCO0FBRWxDLGVBQWU0RSxjQUFhLFNBQVNDLE9BQU07QUFDekMsTUFBSUE7QUFBTSxXQUFPQTtBQUVqQixNQUFJO0FBQ0osTUFBSTtBQUNGLFlBQVEsTUFBTS9ELEtBQUcsTUFBTSxPQUFPO0FBQUEsRUFDbEMsUUFBVTtBQUNOLFdBQU87QUFBQSxFQUNSO0FBRUQsU0FBUSxTQUFTLE1BQU0sWUFBYSxJQUFJLFFBQVE7QUFDbEQ7QUFFQSxTQUFTZ0Usa0JBQWlCLFNBQVNELE9BQU07QUFDdkMsTUFBSUE7QUFBTSxXQUFPQTtBQUVqQixNQUFJO0FBQ0osTUFBSTtBQUNGLFlBQVEvRCxLQUFHLFVBQVUsT0FBTztBQUFBLEVBQ2hDLFFBQVU7QUFDTixXQUFPO0FBQUEsRUFDUjtBQUNELFNBQVEsU0FBUyxNQUFNLFlBQWEsSUFBSSxRQUFRO0FBQ2xEO0FBRUEsSUFBQSxnQkFBaUI7QUFBQSxFQUNmLGFBQWF3QixJQUFFc0MsYUFBVztBQUFBLEVBQzVCLGlCQUFFRTtBQUNGO0FDL0JBLE1BQU14QyxNQUFJN0IsZUFBd0I7QUFDbEMsTUFBTU0sU0FBTztBQUNiLE1BQU1ELE9BQUtiO0FBRVgsTUFBTSxFQUFFLFFBQVEsV0FBVSxJQUFLd0I7QUFFL0IsTUFBTSxFQUFFLGNBQWMsaUJBQWdCLElBQUs2QjtBQUMzQyxNQUFNLEVBQUUsYUFBYSxnQkFBZSxJQUFLQztBQUV6QyxNQUFNLEVBQUVSLFlBQUFBLGFBQVksSUFBR2dDO0FBRXZCLE1BQU0sRUFBRSxhQUFjLElBQUdDO0FBRXpCLGVBQWVDLGdCQUFlLFNBQVMsU0FBU0osT0FBTTtBQUNwRCxNQUFJO0FBQ0osTUFBSTtBQUNGLFlBQVEsTUFBTS9ELEtBQUcsTUFBTSxPQUFPO0FBQUEsRUFDL0IsUUFBTztBQUFBLEVBQUc7QUFFWCxNQUFJLFNBQVMsTUFBTSxrQkFBa0I7QUFDbkMsVUFBTSxDQUFDLFNBQVMsT0FBTyxJQUFJLE1BQU0sUUFBUSxJQUFJO0FBQUEsTUFDM0NBLEtBQUcsS0FBSyxPQUFPO0FBQUEsTUFDZkEsS0FBRyxLQUFLLE9BQU87QUFBQSxJQUNyQixDQUFLO0FBRUQsUUFBSSxhQUFhLFNBQVMsT0FBTztBQUFHO0FBQUEsRUFDckM7QUFFRCxRQUFNLFdBQVcsTUFBTSxhQUFhLFNBQVMsT0FBTztBQUNwRCxZQUFVLFNBQVM7QUFDbkIsUUFBTSxTQUFTLE1BQU0sWUFBWSxTQUFTLE9BQU8rRCxLQUFJO0FBQ3JELFFBQU0sTUFBTTlELE9BQUssUUFBUSxPQUFPO0FBRWhDLE1BQUksQ0FBRSxNQUFNZ0MsYUFBVyxHQUFHLEdBQUk7QUFDNUIsVUFBTSxPQUFPLEdBQUc7QUFBQSxFQUNqQjtBQUVELFNBQU9qQyxLQUFHLFFBQVEsU0FBUyxTQUFTLE1BQU07QUFDNUM7QUFFQSxTQUFTb0Usb0JBQW1CLFNBQVMsU0FBU0wsT0FBTTtBQUNsRCxNQUFJO0FBQ0osTUFBSTtBQUNGLFlBQVEvRCxLQUFHLFVBQVUsT0FBTztBQUFBLEVBQzdCLFFBQU87QUFBQSxFQUFHO0FBQ1gsTUFBSSxTQUFTLE1BQU0sa0JBQWtCO0FBQ25DLFVBQU0sVUFBVUEsS0FBRyxTQUFTLE9BQU87QUFDbkMsVUFBTSxVQUFVQSxLQUFHLFNBQVMsT0FBTztBQUNuQyxRQUFJLGFBQWEsU0FBUyxPQUFPO0FBQUc7QUFBQSxFQUNyQztBQUVELFFBQU0sV0FBVyxpQkFBaUIsU0FBUyxPQUFPO0FBQ2xELFlBQVUsU0FBUztBQUNuQixFQUFBK0QsUUFBTyxnQkFBZ0IsU0FBUyxPQUFPQSxLQUFJO0FBQzNDLFFBQU0sTUFBTTlELE9BQUssUUFBUSxPQUFPO0FBQ2hDLFFBQU0sU0FBU0QsS0FBRyxXQUFXLEdBQUc7QUFDaEMsTUFBSTtBQUFRLFdBQU9BLEtBQUcsWUFBWSxTQUFTLFNBQVMrRCxLQUFJO0FBQ3hELGFBQVcsR0FBRztBQUNkLFNBQU8vRCxLQUFHLFlBQVksU0FBUyxTQUFTK0QsS0FBSTtBQUM5QztBQUVBLElBQUEsVUFBaUI7QUFBQSxFQUNmLGVBQWV2QyxJQUFFMkMsZUFBYTtBQUFBLEVBQ2hDLG1CQUFFQztBQUNGO0FDaEVBLE1BQU0sRUFBRSxZQUFZLGVBQWMsSUFBS3pFO0FBQ3ZDLE1BQU0sRUFBRSxZQUFZLGVBQWMsSUFBS1Q7QUFDdkMsTUFBTSxFQUFFLGVBQWUsa0JBQWlCLElBQUtDO0FBRTdDLElBQUEsU0FBaUI7QUFBQTtBQUFBLEVBRWY7QUFBQSxFQUNBO0FBQUEsRUFDQSxZQUFZO0FBQUEsRUFDWixnQkFBZ0I7QUFBQTtBQUFBLEVBRWhCO0FBQUEsRUFDQTtBQUFBLEVBQ0EsWUFBWTtBQUFBLEVBQ1osZ0JBQWdCO0FBQUE7QUFBQSxFQUVoQjtBQUFBLEVBQ0E7QUFBQSxFQUNBLGVBQWU7QUFBQSxFQUNmLG1CQUFtQjtBQUNyQjtBQ3RCQSxTQUFTa0YsWUFBVyxLQUFLLEVBQUUsTUFBTSxNQUFNLFdBQVcsTUFBTSxXQUFXLE1BQU0sT0FBTSxJQUFLLENBQUEsR0FBSTtBQUN0RixRQUFNLE1BQU0sV0FBVyxNQUFNO0FBQzdCLFFBQU0sTUFBTSxLQUFLLFVBQVUsS0FBSyxVQUFVLE1BQU07QUFFaEQsU0FBTyxJQUFJLFFBQVEsT0FBTyxHQUFHLElBQUk7QUFDbkM7QUFFQSxTQUFTQyxXQUFVLFNBQVM7QUFFMUIsTUFBSSxPQUFPLFNBQVMsT0FBTztBQUFHLGNBQVUsUUFBUSxTQUFTLE1BQU07QUFDL0QsU0FBTyxRQUFRLFFBQVEsV0FBVyxFQUFFO0FBQ3RDO0FBRUEsSUFBQSxRQUFpQixFQUFFRCxXQUFBQSx1QkFBV0MsV0FBUTtBQ2J0QyxJQUFJO0FBQ0osSUFBSTtBQUNGLFFBQU0zRTtBQUNSLFNBQVMsR0FBRztBQUNWLFFBQU1UO0FBQ1I7QUFDQSxNQUFNLGVBQWVDO0FBQ3JCLE1BQU0sYUFBRWtGLGFBQVcsU0FBUSxJQUFLMUQ7QUFFaEMsZUFBZSxVQUFXMEIsT0FBTSxVQUFVLElBQUk7QUFDNUMsTUFBSSxPQUFPLFlBQVksVUFBVTtBQUMvQixjQUFVLEVBQUUsVUFBVSxRQUFTO0FBQUEsRUFDaEM7QUFFRCxRQUFNckMsTUFBSyxRQUFRLE1BQU07QUFFekIsUUFBTSxjQUFjLFlBQVksVUFBVSxRQUFRLFNBQVM7QUFFM0QsTUFBSSxPQUFPLE1BQU0sYUFBYSxhQUFhQSxJQUFHLFFBQVEsRUFBRXFDLE9BQU0sT0FBTztBQUVyRSxTQUFPLFNBQVMsSUFBSTtBQUVwQixNQUFJO0FBQ0osTUFBSTtBQUNGLFVBQU0sS0FBSyxNQUFNLE1BQU0sVUFBVSxRQUFRLFVBQVUsSUFBSTtBQUFBLEVBQ3hELFNBQVEsS0FBSztBQUNaLFFBQUksYUFBYTtBQUNmLFVBQUksVUFBVSxHQUFHQSxLQUFJLEtBQUssSUFBSSxPQUFPO0FBQ3JDLFlBQU07QUFBQSxJQUNaLE9BQVc7QUFDTCxhQUFPO0FBQUEsSUFDUjtBQUFBLEVBQ0Y7QUFFRCxTQUFPO0FBQ1Q7QUFFQSxNQUFNdkIsYUFBVyxhQUFhLFlBQVksU0FBUztBQUVuRCxTQUFTeUQsZUFBY2xDLE9BQU0sVUFBVSxJQUFJO0FBQ3pDLE1BQUksT0FBTyxZQUFZLFVBQVU7QUFDL0IsY0FBVSxFQUFFLFVBQVUsUUFBUztBQUFBLEVBQ2hDO0FBRUQsUUFBTXJDLE1BQUssUUFBUSxNQUFNO0FBRXpCLFFBQU0sY0FBYyxZQUFZLFVBQVUsUUFBUSxTQUFTO0FBRTNELE1BQUk7QUFDRixRQUFJLFVBQVVBLElBQUcsYUFBYXFDLE9BQU0sT0FBTztBQUMzQyxjQUFVLFNBQVMsT0FBTztBQUMxQixXQUFPLEtBQUssTUFBTSxTQUFTLFFBQVEsT0FBTztBQUFBLEVBQzNDLFNBQVEsS0FBSztBQUNaLFFBQUksYUFBYTtBQUNmLFVBQUksVUFBVSxHQUFHQSxLQUFJLEtBQUssSUFBSSxPQUFPO0FBQ3JDLFlBQU07QUFBQSxJQUNaLE9BQVc7QUFDTCxhQUFPO0FBQUEsSUFDUjtBQUFBLEVBQ0Y7QUFDSDtBQUVBLGVBQWUsV0FBWUEsT0FBTSxLQUFLLFVBQVUsQ0FBQSxHQUFJO0FBQ2xELFFBQU1yQyxNQUFLLFFBQVEsTUFBTTtBQUV6QixRQUFNLE1BQU1xRSxZQUFVLEtBQUssT0FBTztBQUVsQyxRQUFNLGFBQWEsYUFBYXJFLElBQUcsU0FBUyxFQUFFcUMsT0FBTSxLQUFLLE9BQU87QUFDbEU7QUFFQSxNQUFNcEIsY0FBWSxhQUFhLFlBQVksVUFBVTtBQUVyRCxTQUFTdUQsZ0JBQWVuQyxPQUFNLEtBQUssVUFBVSxDQUFBLEdBQUk7QUFDL0MsUUFBTXJDLE1BQUssUUFBUSxNQUFNO0FBRXpCLFFBQU0sTUFBTXFFLFlBQVUsS0FBSyxPQUFPO0FBRWxDLFNBQU9yRSxJQUFHLGNBQWNxQyxPQUFNLEtBQUssT0FBTztBQUM1QztBQUVBLE1BQU1vQyxhQUFXO0FBQUEsRUFDakIsVUFBRTNEO0FBQUFBLEVBQ0YsY0FBRXlEO0FBQUFBLEVBQ0YsV0FBRXREO0FBQUFBLEVBQ0YsZUFBRXVEO0FBQ0Y7QUFFQSxJQUFBLGFBQWlCQztBQ3JGakIsTUFBTUMsYUFBVy9FO0FBRWpCLElBQUEsV0FBaUI7QUFBQTtBQUFBLEVBRWYsVUFBVStFLFdBQVM7QUFBQSxFQUNuQixjQUFjQSxXQUFTO0FBQUEsRUFDdkIsV0FBV0EsV0FBUztBQUFBLEVBQ3BCLGVBQWVBLFdBQVM7QUFDMUI7QUNSQSxNQUFNbEQsTUFBSTdCLGVBQXdCO0FBQ2xDLE1BQU1LLE9BQUtkO0FBQ1gsTUFBTWUsU0FBT2Q7QUFDYixNQUFNLFFBQVF3QjtBQUNkLE1BQU1zQixlQUFhTyxhQUEwQjtBQUU3QyxlQUFlbUMsYUFBWXRDLE9BQU0sTUFBTSxXQUFXLFNBQVM7QUFDekQsUUFBTSxNQUFNcEMsT0FBSyxRQUFRb0MsS0FBSTtBQUU3QixNQUFJLENBQUUsTUFBTUosYUFBVyxHQUFHLEdBQUk7QUFDNUIsVUFBTSxNQUFNLE9BQU8sR0FBRztBQUFBLEVBQ3ZCO0FBRUQsU0FBT2pDLEtBQUcsVUFBVXFDLE9BQU0sTUFBTSxRQUFRO0FBQzFDO0FBRUEsU0FBU3VDLGlCQUFnQnZDLFVBQVMsTUFBTTtBQUN0QyxRQUFNLE1BQU1wQyxPQUFLLFFBQVFvQyxLQUFJO0FBQzdCLE1BQUksQ0FBQ3JDLEtBQUcsV0FBVyxHQUFHLEdBQUc7QUFDdkIsVUFBTSxXQUFXLEdBQUc7QUFBQSxFQUNyQjtBQUVEQSxPQUFHLGNBQWNxQyxPQUFNLEdBQUcsSUFBSTtBQUNoQztBQUVBLElBQUEsZUFBaUI7QUFBQSxFQUNmLFlBQVliLElBQUVtRCxZQUFVO0FBQUEsRUFDMUIsZ0JBQUVDO0FBQ0Y7QUM1QkEsTUFBTSxFQUFFUCxXQUFBQSxZQUFXLElBQUcxRTtBQUN0QixNQUFNLEVBQUUsV0FBWSxJQUFHVDtBQUV2QixlQUFlLFdBQVltRCxPQUFNLE1BQU0sVUFBVSxDQUFBLEdBQUk7QUFDbkQsUUFBTSxNQUFNZ0MsWUFBVSxNQUFNLE9BQU87QUFFbkMsUUFBTSxXQUFXaEMsT0FBTSxLQUFLLE9BQU87QUFDckM7QUFFQSxJQUFBLGVBQWlCO0FDVGpCLE1BQU0sRUFBRSxVQUFXLElBQUcxQztBQUN0QixNQUFNLEVBQUUsZUFBZ0IsSUFBR1Q7QUFFM0IsU0FBUyxlQUFnQm1ELE9BQU0sTUFBTSxTQUFTO0FBQzVDLFFBQU0sTUFBTSxVQUFVLE1BQU0sT0FBTztBQUVuQyxpQkFBZUEsT0FBTSxLQUFLLE9BQU87QUFDbkM7QUFFQSxJQUFBLG1CQUFpQjtBQ1RqQixNQUFNYixNQUFJN0IsZUFBd0I7QUFDbEMsTUFBTSxXQUFXVDtBQUVqQixTQUFTLGFBQWFzQyxJQUFFckMsWUFBd0I7QUFDaEQsU0FBUyxpQkFBaUJ3QjtBQUUxQixTQUFTLGFBQWEsU0FBUztBQUMvQixTQUFTLGlCQUFpQixTQUFTO0FBQ25DLFNBQVMsWUFBWSxTQUFTO0FBQzlCLFNBQVMsZ0JBQWdCLFNBQVM7QUFDbEMsU0FBUyxXQUFXLFNBQVM7QUFDN0IsU0FBUyxlQUFlLFNBQVM7QUFFakMsSUFBQSxPQUFpQjtBQ2JqQixNQUFNWCxPQUFLTDtBQUNYLE1BQU1NLFNBQU87QUFDYixNQUFNLEVBQUUsS0FBTSxJQUFHZDtBQUNqQixNQUFNLEVBQUUsT0FBUSxJQUFHd0I7QUFDbkIsTUFBTSxFQUFFLE9BQVEsSUFBRzZCO0FBQ25CLE1BQU0sRUFBRVAsWUFBQUEsYUFBWSxJQUFHUTtBQUN2QixNQUFNRixTQUFPMEI7QUFFYixlQUFlWSxPQUFNLEtBQUssTUFBTSxPQUFPLENBQUEsR0FBSTtBQUN6QyxRQUFNLFlBQVksS0FBSyxhQUFhLEtBQUssV0FBVztBQUVwRCxRQUFNLEVBQUUsU0FBUyxpQkFBaUIsVUFBVSxNQUFNdEMsT0FBSyxXQUFXLEtBQUssTUFBTSxRQUFRLElBQUk7QUFFekYsUUFBTUEsT0FBSyxpQkFBaUIsS0FBSyxTQUFTLE1BQU0sTUFBTTtBQUd0RCxRQUFNLGFBQWF0QyxPQUFLLFFBQVEsSUFBSTtBQUNwQyxRQUFNLG1CQUFtQkEsT0FBSyxNQUFNLFVBQVU7QUFDOUMsTUFBSSxpQkFBaUIsU0FBUyxZQUFZO0FBQ3hDLFVBQU0sT0FBTyxVQUFVO0FBQUEsRUFDeEI7QUFFRCxTQUFPNkUsV0FBUyxLQUFLLE1BQU0sV0FBVyxjQUFjO0FBQ3REO0FBRUEsZUFBZUEsV0FBVSxLQUFLLE1BQU0sV0FBVyxnQkFBZ0I7QUFDN0QsTUFBSSxDQUFDLGdCQUFnQjtBQUNuQixRQUFJLFdBQVc7QUFDYixZQUFNLE9BQU8sSUFBSTtBQUFBLElBQ3ZCLFdBQWUsTUFBTTdDLGFBQVcsSUFBSSxHQUFHO0FBQ2pDLFlBQU0sSUFBSSxNQUFNLHNCQUFzQjtBQUFBLElBQ3ZDO0FBQUEsRUFDRjtBQUVELE1BQUk7QUFFRixVQUFNakMsS0FBRyxPQUFPLEtBQUssSUFBSTtBQUFBLEVBQzFCLFNBQVEsS0FBSztBQUNaLFFBQUksSUFBSSxTQUFTLFNBQVM7QUFDeEIsWUFBTTtBQUFBLElBQ1A7QUFDRCxVQUFNK0UsbUJBQWlCLEtBQUssTUFBTSxTQUFTO0FBQUEsRUFDNUM7QUFDSDtBQUVBLGVBQWVBLG1CQUFrQixLQUFLLE1BQU0sV0FBVztBQUNyRCxRQUFNLE9BQU87QUFBQSxJQUNYO0FBQUEsSUFDQSxjQUFjO0FBQUEsSUFDZCxvQkFBb0I7QUFBQSxFQUNyQjtBQUVELFFBQU0sS0FBSyxLQUFLLE1BQU0sSUFBSTtBQUMxQixTQUFPLE9BQU8sR0FBRztBQUNuQjtBQUVBLElBQUEsU0FBaUJGO0FDeERqQixNQUFNN0UsT0FBS0w7QUFDWCxNQUFNTSxTQUFPO0FBQ2IsTUFBTSxXQUFXZCxPQUFtQjtBQUNwQyxNQUFNLGFBQWF3QixTQUFxQjtBQUN4QyxNQUFNLGFBQWE2QixTQUFxQjtBQUN4QyxNQUFNLE9BQU9DO0FBRWIsU0FBUyxTQUFVLEtBQUssTUFBTSxNQUFNO0FBQ2xDLFNBQU8sUUFBUSxDQUFFO0FBQ2pCLFFBQU0sWUFBWSxLQUFLLGFBQWEsS0FBSyxXQUFXO0FBRXBELFFBQU0sRUFBRSxTQUFTLGlCQUFpQixVQUFVLEtBQUssZUFBZSxLQUFLLE1BQU0sUUFBUSxJQUFJO0FBQ3ZGLE9BQUsscUJBQXFCLEtBQUssU0FBUyxNQUFNLE1BQU07QUFDcEQsTUFBSSxDQUFDLGFBQWEsSUFBSTtBQUFHLGVBQVd4QyxPQUFLLFFBQVEsSUFBSSxDQUFDO0FBQ3RELFNBQU8sU0FBUyxLQUFLLE1BQU0sV0FBVyxjQUFjO0FBQ3REO0FBRUEsU0FBUyxhQUFjLE1BQU07QUFDM0IsUUFBTSxTQUFTQSxPQUFLLFFBQVEsSUFBSTtBQUNoQyxRQUFNLGFBQWFBLE9BQUssTUFBTSxNQUFNO0FBQ3BDLFNBQU8sV0FBVyxTQUFTO0FBQzdCO0FBRUEsU0FBUyxTQUFVLEtBQUssTUFBTSxXQUFXLGdCQUFnQjtBQUN2RCxNQUFJO0FBQWdCLFdBQU8sT0FBTyxLQUFLLE1BQU0sU0FBUztBQUN0RCxNQUFJLFdBQVc7QUFDYixlQUFXLElBQUk7QUFDZixXQUFPLE9BQU8sS0FBSyxNQUFNLFNBQVM7QUFBQSxFQUNuQztBQUNELE1BQUlELEtBQUcsV0FBVyxJQUFJO0FBQUcsVUFBTSxJQUFJLE1BQU0sc0JBQXNCO0FBQy9ELFNBQU8sT0FBTyxLQUFLLE1BQU0sU0FBUztBQUNwQztBQUVBLFNBQVMsT0FBUSxLQUFLLE1BQU0sV0FBVztBQUNyQyxNQUFJO0FBQ0ZBLFNBQUcsV0FBVyxLQUFLLElBQUk7QUFBQSxFQUN4QixTQUFRLEtBQUs7QUFDWixRQUFJLElBQUksU0FBUztBQUFTLFlBQU07QUFDaEMsV0FBTyxpQkFBaUIsS0FBSyxNQUFNLFNBQVM7QUFBQSxFQUM3QztBQUNIO0FBRUEsU0FBUyxpQkFBa0IsS0FBSyxNQUFNLFdBQVc7QUFDL0MsUUFBTSxPQUFPO0FBQUEsSUFDWDtBQUFBLElBQ0EsY0FBYztBQUFBLElBQ2Qsb0JBQW9CO0FBQUEsRUFDckI7QUFDRCxXQUFTLEtBQUssTUFBTSxJQUFJO0FBQ3hCLFNBQU8sV0FBVyxHQUFHO0FBQ3ZCO0FBRUEsSUFBQSxhQUFpQjtBQ3BEakIsTUFBTSxJQUFJTCxlQUF3QjtBQUNsQyxJQUFBLE9BQWlCO0FBQUEsRUFDZixNQUFNLEVBQUVULE1BQWlCO0FBQUEsRUFDekIsVUFBVUM7QUFDWjtBQ0pBLElBQUEsTUFBaUI7QUFBQTtBQUFBLEVBRWYsR0FBR1E7QUFBQUE7QUFBQUEsRUFFSCxHQUFHVDtBQUFBQSxFQUNILEdBQUdDO0FBQUFBLEVBQ0gsR0FBR3dCO0FBQUFBLEVBQ0gsR0FBRzZCO0FBQUFBLEVBQ0gsR0FBR0M7QUFBQUEsRUFDSCxHQUFHd0I7QUFBQUEsRUFDSCxHQUFHQztBQUFBQSxFQUNILEdBQUdjO0FBQUFBLEVBQ0gsR0FBR0M7QUFDTDs7SUNiQUMsVUFBaUIsV0FBUztBQUN6QixRQUFNbkIsUUFBTyxPQUFPO0FBQ3BCLFNBQU8sVUFBVSxTQUFTQSxVQUFTLFlBQVlBLFVBQVM7QUFDekQ7QUNKQSxNQUFNLFFBQVFwRTtBQUVkLE1BQU0saUJBQWlCLG9CQUFJLElBQUk7QUFBQSxFQUM5QjtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQ0QsQ0FBQztBQUVELE1BQU0sY0FBYyxrQkFBZ0IsQ0FBQyxhQUFhLEtBQUssYUFBVyxlQUFlLElBQUksT0FBTyxDQUFDO0FBRTdGLFNBQVMsZ0JBQWdCTSxPQUFNO0FBQzlCLFFBQU0sWUFBWUEsTUFBSyxNQUFNLEdBQUc7QUFDaEMsUUFBTSxRQUFRLENBQUE7QUFFZCxXQUFTLElBQUksR0FBRyxJQUFJLFVBQVUsUUFBUSxLQUFLO0FBQzFDLFFBQUksSUFBSSxVQUFVLENBQUM7QUFFbkIsV0FBTyxFQUFFLEVBQUUsU0FBUyxDQUFDLE1BQU0sUUFBUSxVQUFVLElBQUksQ0FBQyxNQUFNLFFBQVc7QUFDbEUsVUFBSSxFQUFFLE1BQU0sR0FBRyxFQUFFLElBQUk7QUFDckIsV0FBSyxVQUFVLEVBQUUsQ0FBQztBQUFBLElBQ2xCO0FBRUQsVUFBTSxLQUFLLENBQUM7QUFBQSxFQUNaO0FBRUQsTUFBSSxDQUFDLFlBQVksS0FBSyxHQUFHO0FBQ3hCLFdBQU87RUFDUDtBQUVELFNBQU87QUFDUjtBQUVBLElBQUEsVUFBaUI7QUFBQSxFQUNoQixJQUFJLFFBQVFBLE9BQU0sT0FBTztBQUN4QixRQUFJLENBQUMsTUFBTSxNQUFNLEtBQUssT0FBT0EsVUFBUyxVQUFVO0FBQy9DLGFBQU8sVUFBVSxTQUFZLFNBQVM7QUFBQSxJQUN0QztBQUVELFVBQU0sWUFBWSxnQkFBZ0JBLEtBQUk7QUFDdEMsUUFBSSxVQUFVLFdBQVcsR0FBRztBQUMzQjtBQUFBLElBQ0E7QUFFRCxhQUFTLElBQUksR0FBRyxJQUFJLFVBQVUsUUFBUSxLQUFLO0FBQzFDLGVBQVMsT0FBTyxVQUFVLENBQUMsQ0FBQztBQUU1QixVQUFJLFdBQVcsVUFBYSxXQUFXLE1BQU07QUFNNUMsWUFBSSxNQUFNLFVBQVUsU0FBUyxHQUFHO0FBQy9CLGlCQUFPO0FBQUEsUUFDUDtBQUVEO0FBQUEsTUFDQTtBQUFBLElBQ0Q7QUFFRCxXQUFPLFdBQVcsU0FBWSxRQUFRO0FBQUEsRUFDdEM7QUFBQSxFQUVELElBQUksUUFBUUEsT0FBTSxPQUFPO0FBQ3hCLFFBQUksQ0FBQyxNQUFNLE1BQU0sS0FBSyxPQUFPQSxVQUFTLFVBQVU7QUFDL0MsYUFBTztBQUFBLElBQ1A7QUFFRCxVQUFNLE9BQU87QUFDYixVQUFNLFlBQVksZ0JBQWdCQSxLQUFJO0FBRXRDLGFBQVMsSUFBSSxHQUFHLElBQUksVUFBVSxRQUFRLEtBQUs7QUFDMUMsWUFBTSxJQUFJLFVBQVUsQ0FBQztBQUVyQixVQUFJLENBQUMsTUFBTSxPQUFPLENBQUMsQ0FBQyxHQUFHO0FBQ3RCLGVBQU8sQ0FBQyxJQUFJO01BQ1o7QUFFRCxVQUFJLE1BQU0sVUFBVSxTQUFTLEdBQUc7QUFDL0IsZUFBTyxDQUFDLElBQUk7QUFBQSxNQUNaO0FBRUQsZUFBUyxPQUFPLENBQUM7QUFBQSxJQUNqQjtBQUVELFdBQU87QUFBQSxFQUNQO0FBQUEsRUFFRCxPQUFPLFFBQVFBLE9BQU07QUFDcEIsUUFBSSxDQUFDLE1BQU0sTUFBTSxLQUFLLE9BQU9BLFVBQVMsVUFBVTtBQUMvQyxhQUFPO0FBQUEsSUFDUDtBQUVELFVBQU0sWUFBWSxnQkFBZ0JBLEtBQUk7QUFFdEMsYUFBUyxJQUFJLEdBQUcsSUFBSSxVQUFVLFFBQVEsS0FBSztBQUMxQyxZQUFNLElBQUksVUFBVSxDQUFDO0FBRXJCLFVBQUksTUFBTSxVQUFVLFNBQVMsR0FBRztBQUMvQixlQUFPLE9BQU8sQ0FBQztBQUNmLGVBQU87QUFBQSxNQUNQO0FBRUQsZUFBUyxPQUFPLENBQUM7QUFFakIsVUFBSSxDQUFDLE1BQU0sTUFBTSxHQUFHO0FBQ25CLGVBQU87QUFBQSxNQUNQO0FBQUEsSUFDRDtBQUFBLEVBQ0Q7QUFBQSxFQUVELElBQUksUUFBUUEsT0FBTTtBQUNqQixRQUFJLENBQUMsTUFBTSxNQUFNLEtBQUssT0FBT0EsVUFBUyxVQUFVO0FBQy9DLGFBQU87QUFBQSxJQUNQO0FBRUQsVUFBTSxZQUFZLGdCQUFnQkEsS0FBSTtBQUN0QyxRQUFJLFVBQVUsV0FBVyxHQUFHO0FBQzNCLGFBQU87QUFBQSxJQUNQO0FBR0QsYUFBUyxJQUFJLEdBQUcsSUFBSSxVQUFVLFFBQVEsS0FBSztBQUMxQyxVQUFJLE1BQU0sTUFBTSxHQUFHO0FBQ2xCLFlBQUksRUFBRSxVQUFVLENBQUMsS0FBSyxTQUFTO0FBQzlCLGlCQUFPO0FBQUEsUUFDUDtBQUVELGlCQUFTLE9BQU8sVUFBVSxDQUFDLENBQUM7QUFBQSxNQUNoQyxPQUFVO0FBQ04sZUFBTztBQUFBLE1BQ1A7QUFBQSxJQUNEO0FBRUQsV0FBTztBQUFBLEVBQ1A7QUFDRjs7Ozs7QUN4SUEsTUFBTUQsT0FBS0w7QUFFWHdGLGFBQUEsVUFBaUIsUUFBTSxJQUFJLFFBQVEsQ0FBQTlGLGFBQVc7QUFDN0NXLE9BQUcsT0FBTyxJQUFJLFNBQU87QUFDcEIsSUFBQVgsU0FBUSxDQUFDLEdBQUc7QUFBQSxFQUNkLENBQUU7QUFDRixDQUFDO0FBRWtCOEYsYUFBQSxRQUFBLE9BQUcsUUFBTTtBQUMzQixNQUFJO0FBQ0huRixTQUFHLFdBQVcsRUFBRTtBQUNoQixXQUFPO0FBQUEsRUFDUCxTQUFRLEtBQUs7QUFDYixXQUFPO0FBQUEsRUFDUDtBQUNGOzs7O0FDZEEsTUFBTW9GLFNBQU8sQ0FBQyxPQUFPLGVBQWUsSUFBSSxRQUFRLENBQUEvRixhQUFXO0FBQzFELEVBQUFBLFNBQVEsR0FBRyxHQUFHLFVBQVUsQ0FBQztBQUMxQixDQUFDO0FBRURnRyxPQUFjLFVBQUdEO0FBRWpCQyxPQUFBLFFBQUEsVUFBeUJEOztBQ1B6QixNQUFNLE9BQU96RjtBQUViLE1BQU0yRixXQUFTLGlCQUFlO0FBQzdCLE1BQUksR0FBRyxPQUFPLFVBQVUsV0FBVyxLQUFLLGdCQUFnQixhQUFhLGNBQWMsSUFBSTtBQUN0RixXQUFPLFFBQVEsT0FBTyxJQUFJLFVBQVUscURBQXFELENBQUM7QUFBQSxFQUMxRjtBQUVELFFBQU0sUUFBUSxDQUFBO0FBQ2QsTUFBSSxjQUFjO0FBRWxCLFFBQU0sT0FBTyxNQUFNO0FBQ2xCO0FBRUEsUUFBSSxNQUFNLFNBQVMsR0FBRztBQUNyQixZQUFNLE1BQUs7SUFDWDtBQUFBLEVBQ0g7QUFFQyxRQUFNLE1BQU0sQ0FBQyxJQUFJakcsYUFBWSxTQUFTO0FBQ3JDO0FBRUEsVUFBTSxTQUFTLEtBQUssSUFBSSxHQUFHLElBQUk7QUFFL0IsSUFBQUEsU0FBUSxNQUFNO0FBRWQsV0FBTyxLQUFLLE1BQU0sSUFBSTtBQUFBLEVBQ3hCO0FBRUMsUUFBTWtHLFdBQVUsQ0FBQyxJQUFJbEcsYUFBWSxTQUFTO0FBQ3pDLFFBQUksY0FBYyxhQUFhO0FBQzlCLFVBQUksSUFBSUEsVUFBUyxHQUFHLElBQUk7QUFBQSxJQUMzQixPQUFTO0FBQ04sWUFBTSxLQUFLLElBQUksS0FBSyxNQUFNLElBQUlBLFVBQVMsR0FBRyxJQUFJLENBQUM7QUFBQSxJQUMvQztBQUFBLEVBQ0g7QUFFQyxRQUFNLFlBQVksQ0FBQyxPQUFPLFNBQVMsSUFBSSxRQUFRLENBQUFBLGFBQVdrRyxTQUFRLElBQUlsRyxVQUFTLEdBQUcsSUFBSSxDQUFDO0FBQ3ZGLFNBQU8saUJBQWlCLFdBQVc7QUFBQSxJQUNsQyxhQUFhO0FBQUEsTUFDWixLQUFLLE1BQU07QUFBQSxJQUNYO0FBQUEsSUFDRCxjQUFjO0FBQUEsTUFDYixLQUFLLE1BQU0sTUFBTTtBQUFBLElBQ2pCO0FBQUEsSUFDRCxZQUFZO0FBQUEsTUFDWCxPQUFPLE1BQU07QUFDWixjQUFNLFNBQVM7QUFBQSxNQUNmO0FBQUEsSUFDRDtBQUFBLEVBQ0gsQ0FBRTtBQUVELFNBQU87QUFDUjtBQUVBbUcsU0FBYyxVQUFHRjtBQUNqQkUsU0FBQSxRQUFBLFVBQXlCRjs7QUN2RHpCLE1BQU0sU0FBUzNGO0FBRWYsTUFBTSxpQkFBaUIsTUFBTTtBQUFBLEVBQzVCLFlBQVksT0FBTztBQUNsQjtBQUNBLFNBQUssUUFBUTtBQUFBLEVBQ2I7QUFDRjtBQUdBLE1BQU0sY0FBYyxDQUFDLElBQUksV0FBVyxRQUFRLFFBQVEsRUFBRSxFQUFFLEtBQUssTUFBTTtBQUduRSxNQUFNLFNBQVMsUUFBTSxRQUFRLElBQUksRUFBRSxFQUFFLEtBQUssU0FBTyxJQUFJLENBQUMsTUFBTSxRQUFRLFFBQVEsT0FBTyxJQUFJLFNBQVMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBRXhHLElBQUE4RixZQUFpQixDQUFDLFVBQVUsUUFBUSxTQUFTO0FBQzVDLFNBQU8sT0FBTyxPQUFPO0FBQUEsSUFDcEIsYUFBYTtBQUFBLElBQ2IsZUFBZTtBQUFBLEVBQ2YsR0FBRSxJQUFJO0FBRVAsUUFBTUMsU0FBUSxPQUFPLEtBQUssV0FBVztBQUdyQyxRQUFNM0MsU0FBUSxDQUFDLEdBQUcsUUFBUSxFQUFFLElBQUksUUFBTSxDQUFDLElBQUkyQyxPQUFNLGFBQWEsSUFBSSxNQUFNLENBQUMsQ0FBQztBQUcxRSxRQUFNLGFBQWEsT0FBTyxLQUFLLGdCQUFnQixJQUFJLFFBQVE7QUFFM0QsU0FBTyxRQUFRLElBQUkzQyxPQUFNLElBQUksUUFBTSxXQUFXLFFBQVEsRUFBRSxDQUFDLENBQUMsRUFDeEQsS0FBSyxNQUFNO0FBQUEsRUFBQSxDQUFFLEVBQ2IsTUFBTSxTQUFPLGVBQWUsV0FBVyxJQUFJLFFBQVEsUUFBUSxPQUFPLEdBQUcsQ0FBQztBQUN6RTtBQ2hDQSxNQUFNOUMsU0FBT047QUFDYixNQUFNLGFBQWFUO0FBQ25CLE1BQU0sVUFBVUM7QUFFaEJ3RyxhQUFBLFVBQWlCLENBQUMsVUFBVSxZQUFZO0FBQ3ZDLFlBQVUsT0FBTyxPQUFPO0FBQUEsSUFDdkIsS0FBSyxRQUFRLElBQUs7QUFBQSxFQUNsQixHQUFFLE9BQU87QUFFVixTQUFPLFFBQVEsVUFBVSxRQUFNLFdBQVcxRixPQUFLLFFBQVEsUUFBUSxLQUFLLEVBQUUsQ0FBQyxHQUFHLE9BQU87QUFDbEY7QUFFQTBGLGFBQUEsUUFBQSxPQUFzQixDQUFDLFVBQVUsWUFBWTtBQUM1QyxZQUFVLE9BQU8sT0FBTztBQUFBLElBQ3ZCLEtBQUssUUFBUSxJQUFLO0FBQUEsRUFDbEIsR0FBRSxPQUFPO0FBRVYsYUFBVyxNQUFNLFVBQVU7QUFDMUIsUUFBSSxXQUFXLEtBQUsxRixPQUFLLFFBQVEsUUFBUSxLQUFLLEVBQUUsQ0FBQyxHQUFHO0FBQ25ELGFBQU87QUFBQSxJQUNQO0FBQUEsRUFDRDtBQUNGOztBQ3RCQSxNQUFNQSxTQUFPTjtBQUNiLE1BQU0sYUFBYVQ7QUFFbkIwRyxTQUFBLFVBQWlCLENBQUMsVUFBVSxPQUFPLENBQUEsTUFBTztBQUN6QyxRQUFNLFdBQVczRixPQUFLLFFBQVEsS0FBSyxPQUFPLEVBQUU7QUFDNUMsUUFBTSxFQUFDLEtBQUksSUFBSUEsT0FBSyxNQUFNLFFBQVE7QUFFbEMsUUFBTSxZQUFZLENBQUEsRUFBRyxPQUFPLFFBQVE7QUFFcEMsU0FBTyxJQUFJLFFBQVEsQ0FBQVosYUFBVztBQUM3QixLQUFDLFNBQVMsS0FBSyxLQUFLO0FBQ25CLGlCQUFXLFdBQVcsRUFBQyxLQUFLLElBQUcsQ0FBQyxFQUFFLEtBQUssQ0FBQWdELFVBQVE7QUFDOUMsWUFBSUEsT0FBTTtBQUNULFVBQUFoRCxTQUFRWSxPQUFLLEtBQUssS0FBS29DLEtBQUksQ0FBQztBQUFBLFFBQ2pDLFdBQWUsUUFBUSxNQUFNO0FBQ3hCLFVBQUFoRCxTQUFRLElBQUk7QUFBQSxRQUNqQixPQUFXO0FBQ04sZUFBS1ksT0FBSyxRQUFRLEdBQUcsQ0FBQztBQUFBLFFBQ3RCO0FBQUEsTUFDTCxDQUFJO0FBQUEsSUFDRCxHQUFFLFFBQVE7QUFBQSxFQUNiLENBQUU7QUFDRjtBQUVBMkYsU0FBQSxRQUFBLE9BQXNCLENBQUMsVUFBVSxPQUFPLENBQUEsTUFBTztBQUM5QyxNQUFJLE1BQU0zRixPQUFLLFFBQVEsS0FBSyxPQUFPLEVBQUU7QUFDckMsUUFBTSxFQUFDLEtBQUksSUFBSUEsT0FBSyxNQUFNLEdBQUc7QUFFN0IsUUFBTSxZQUFZLENBQUEsRUFBRyxPQUFPLFFBQVE7QUFHcEMsU0FBTyxNQUFNO0FBQ1osVUFBTW9DLFFBQU8sV0FBVyxLQUFLLFdBQVcsRUFBQyxLQUFLLElBQUcsQ0FBQztBQUVsRCxRQUFJQSxPQUFNO0FBQ1QsYUFBT3BDLE9BQUssS0FBSyxLQUFLb0MsS0FBSTtBQUFBLElBQzFCO0FBRUQsUUFBSSxRQUFRLE1BQU07QUFDakIsYUFBTztBQUFBLElBQ1A7QUFFRCxVQUFNcEMsT0FBSyxRQUFRLEdBQUc7QUFBQSxFQUN0QjtBQUNGOztBQzVDQSxNQUFNLFNBQVNOO0FBRWZrRyxNQUFBLFVBQWlCLE9BQU8sRUFBQyxLQUFBQyxLQUFHLElBQUksQ0FBQSxNQUFPLE9BQU8sZ0JBQWdCLEVBQUMsS0FBQUEsS0FBRyxDQUFDO0FBQ25FRCxNQUFBLFFBQUEsT0FBc0IsQ0FBQyxFQUFDLEtBQUFDLEtBQUcsSUFBSSxPQUFPLE9BQU8sS0FBSyxnQkFBZ0IsRUFBQyxLQUFBQSxLQUFHLENBQUM7OztBQ0h2RSxNQUFNN0YsU0FBT047QUFDYixNQUFNLEtBQUtUO0FBRVgsTUFBTSxVQUFVLEdBQUc7QUFDbkIsTUFBTSxTQUFTLEdBQUc7QUFDbEIsTUFBTSxFQUFDNkcsS0FBQUEsTUFBRyxJQUFJO0FBRWQsTUFBTSxRQUFRLFVBQVE7QUFDckIsUUFBTSxVQUFVOUYsT0FBSyxLQUFLLFNBQVMsU0FBUztBQUU1QyxTQUFPO0FBQUEsSUFDTixNQUFNQSxPQUFLLEtBQUssU0FBUyx1QkFBdUIsSUFBSTtBQUFBLElBQ3BELFFBQVFBLE9BQUssS0FBSyxTQUFTLGVBQWUsSUFBSTtBQUFBLElBQzlDLE9BQU9BLE9BQUssS0FBSyxTQUFTLFVBQVUsSUFBSTtBQUFBLElBQ3hDLEtBQUtBLE9BQUssS0FBSyxTQUFTLFFBQVEsSUFBSTtBQUFBLElBQ3BDLE1BQU1BLE9BQUssS0FBSyxRQUFRLElBQUk7QUFBQSxFQUM5QjtBQUNBO0FBRUEsTUFBTSxVQUFVLFVBQVE7QUFDdkIsUUFBTSxVQUFVOEYsTUFBSSxXQUFXOUYsT0FBSyxLQUFLLFNBQVMsV0FBVyxTQUFTO0FBQ3RFLFFBQU0sZUFBZThGLE1BQUksZ0JBQWdCOUYsT0FBSyxLQUFLLFNBQVMsV0FBVyxPQUFPO0FBRTlFLFNBQU87QUFBQTtBQUFBLElBRU4sTUFBTUEsT0FBSyxLQUFLLGNBQWMsTUFBTSxNQUFNO0FBQUEsSUFDMUMsUUFBUUEsT0FBSyxLQUFLLFNBQVMsTUFBTSxRQUFRO0FBQUEsSUFDekMsT0FBT0EsT0FBSyxLQUFLLGNBQWMsTUFBTSxPQUFPO0FBQUEsSUFDNUMsS0FBS0EsT0FBSyxLQUFLLGNBQWMsTUFBTSxLQUFLO0FBQUEsSUFDeEMsTUFBTUEsT0FBSyxLQUFLLFFBQVEsSUFBSTtBQUFBLEVBQzlCO0FBQ0E7QUFHQSxNQUFNLFFBQVEsVUFBUTtBQUNyQixRQUFNLFdBQVdBLE9BQUssU0FBUyxPQUFPO0FBRXRDLFNBQU87QUFBQSxJQUNOLE1BQU1BLE9BQUssS0FBSzhGLE1BQUksaUJBQWlCOUYsT0FBSyxLQUFLLFNBQVMsVUFBVSxPQUFPLEdBQUcsSUFBSTtBQUFBLElBQ2hGLFFBQVFBLE9BQUssS0FBSzhGLE1BQUksbUJBQW1COUYsT0FBSyxLQUFLLFNBQVMsU0FBUyxHQUFHLElBQUk7QUFBQSxJQUM1RSxPQUFPQSxPQUFLLEtBQUs4RixNQUFJLGtCQUFrQjlGLE9BQUssS0FBSyxTQUFTLFFBQVEsR0FBRyxJQUFJO0FBQUE7QUFBQSxJQUV6RSxLQUFLQSxPQUFLLEtBQUs4RixNQUFJLGtCQUFrQjlGLE9BQUssS0FBSyxTQUFTLFVBQVUsT0FBTyxHQUFHLElBQUk7QUFBQSxJQUNoRixNQUFNQSxPQUFLLEtBQUssUUFBUSxVQUFVLElBQUk7QUFBQSxFQUN4QztBQUNBO0FBRUEsTUFBTSxXQUFXLENBQUMsTUFBTSxZQUFZO0FBQ25DLE1BQUksT0FBTyxTQUFTLFVBQVU7QUFDN0IsVUFBTSxJQUFJLFVBQVUsd0JBQXdCLE9BQU8sSUFBSSxFQUFFO0FBQUEsRUFDekQ7QUFFRCxZQUFVLE9BQU8sT0FBTyxFQUFDLFFBQVEsU0FBUSxHQUFHLE9BQU87QUFFbkQsTUFBSSxRQUFRLFFBQVE7QUFFbkIsWUFBUSxJQUFJLFFBQVEsTUFBTTtBQUFBLEVBQzFCO0FBRUQsTUFBSSxRQUFRLGFBQWEsVUFBVTtBQUNsQyxXQUFPLE1BQU0sSUFBSTtBQUFBLEVBQ2pCO0FBRUQsTUFBSSxRQUFRLGFBQWEsU0FBUztBQUNqQyxXQUFPLFFBQVEsSUFBSTtBQUFBLEVBQ25CO0FBRUQsU0FBTyxNQUFNLElBQUk7QUFDbEI7QUFFQStGLFdBQWMsVUFBRztBQUVqQkEsV0FBQSxRQUFBLFVBQXlCOzs7O0FDdkV6QixPQUFPLGVBQWUsUUFBUyxjQUFjLEVBQUUsT0FBTyxLQUFJLENBQUU7QUFDaEQsT0FBQSxPQUFrQyxPQUFBLDBCQUFnQyxPQUFBLDhDQUEwQixPQUFBLFdBQW1CLE9BQUEsdUJBQStCLE9BQUEsd0JBQTZELE9BQUEsd0JBQStCLE9BQUEsdUJBQThCLE9BQUEsc0JBQTRCLE9BQUEsb0JBQTJCLE9BQUEsbUJBQUc7QUFDOVUsTUFBTSxtQkFBbUI7QUFDRCxPQUFBLG1CQUFHO0FBQzNCLE1BQU0sb0JBQW9CO0FBQ0QsT0FBQSxvQkFBRztBQUM1QixNQUFNLHNCQUFzQjtBQUNELE9BQUEsc0JBQUc7QUFDOUIsTUFBTSx1QkFBdUIsQ0FBQTtBQUNELE9BQUEsdUJBQUc7QUFDL0IsTUFBTSx3QkFBd0IsQ0FBQTtBQUNELE9BQUEsd0JBQUc7QUFDaEMsTUFBTSx3QkFBd0I7QUFDRCxPQUFBLHdCQUFHO0FBQ2hDLE1BQU0sdUJBQXVCO0FBQ0QsT0FBQSx1QkFBRztBQUMvQixNQUFNLFdBQVcsQ0FBQyxDQUFDLFFBQVE7QUFDWCxPQUFBLFdBQUc7QUFDbkIsTUFBTSxlQUFlLFFBQVEsU0FBUyxDQUFDLFFBQVEsT0FBUSxJQUFHO0FBQ3RDLE9BQUEsZUFBRztBQUN2QixNQUFNLHdCQUF3QjtBQUNELE9BQUEsd0JBQUc7QUFDaEMsTUFBTSwwQkFBMEI7QUFDRCxPQUFBLDBCQUFHO0FBQ2xDLE1BQU0sT0FBTyxNQUFNO0FBQUE7QUFDbkIsT0FBQSxPQUFlOzs7QUN6QmYsT0FBTyxlQUFlLFlBQVMsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQzVELFdBQUEsaUJBQXlCLFdBQUEsa0JBQTBCO0FBQ25ELE1BQU1DLGFBQVd0RztBQUlqQixNQUFNLGtCQUFrQixDQUFDLElBQUksVUFBVXNHLFdBQVMsU0FBUztBQUNyRCxTQUFPLFdBQVk7QUFDZixXQUFPLEdBQUcsTUFBTSxRQUFXLFNBQVMsRUFBRSxNQUFNLE9BQU87QUFBQSxFQUMzRDtBQUNBO0FBQ3VCLFdBQUEsa0JBQUc7QUFDMUIsTUFBTSxpQkFBaUIsQ0FBQyxJQUFJLFVBQVVBLFdBQVMsU0FBUztBQUNwRCxTQUFPLFdBQVk7QUFDZixRQUFJO0FBQ0EsYUFBTyxHQUFHLE1BQU0sUUFBVyxTQUFTO0FBQUEsSUFDdkMsU0FDTTNHLFFBQU87QUFDVixhQUFPLFFBQVFBLE1BQUs7QUFBQSxJQUN2QjtBQUFBLEVBQ1Q7QUFDQTtBQUNBLFdBQUEsaUJBQXlCOztBQ3RCekIsT0FBTyxlQUFlLGFBQVMsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQzVELE1BQU0yRyxhQUFXdEc7QUFFakIsTUFBTSxXQUFXO0FBQUEsRUFDYixpQkFBaUIsQ0FBQ0wsV0FBVTtBQUN4QixVQUFNLEVBQUUsTUFBQTRHLE1BQU0sSUFBRzVHO0FBQ2pCLFFBQUk0RyxVQUFTO0FBQ1QsYUFBTztBQUNYLFFBQUksQ0FBQ0QsV0FBUyxpQkFBaUJDLFVBQVMsWUFBWUEsVUFBUztBQUN6RCxhQUFPO0FBQ1gsV0FBTztBQUFBLEVBQ1Y7QUFBQSxFQUNELGtCQUFrQixDQUFDNUcsV0FBVTtBQUN6QixVQUFNLEVBQUUsTUFBQTRHLE1BQU0sSUFBRzVHO0FBQ2pCLFFBQUk0RyxVQUFTLFlBQVlBLFVBQVMsWUFBWUEsVUFBUyxZQUFZQSxVQUFTLFdBQVdBLFVBQVMsYUFBYUEsVUFBUyxXQUFXQSxVQUFTO0FBQ3RJLGFBQU87QUFDWCxXQUFPO0FBQUEsRUFDVjtBQUFBLEVBQ0QsZUFBZSxDQUFDNUcsV0FBVTtBQUN0QixRQUFJLFNBQVMsZ0JBQWdCQSxNQUFLO0FBQzlCO0FBQ0osVUFBTUE7QUFBQSxFQUNUO0FBQ0w7QUFFQSxZQUFBLFVBQWtCOzs7QUN6QmxCLE9BQU8sZUFBZSxnQkFBUyxjQUFjLEVBQUUsT0FBTyxLQUFJLENBQUU7QUFDNUQsTUFBTTJHLGFBQVd0RztBQUVqQixNQUFNLGVBQWU7QUFBQSxFQUNqQixVQUFVO0FBQUEsRUFDVixZQUFZO0FBQUEsRUFDWixPQUFPc0csV0FBUztBQUFBLEVBQ2hCLGFBQWEsb0JBQUksSUFBSztBQUFBLEVBQ3RCLGNBQWMsb0JBQUksSUFBSztBQUFBLEVBQ3ZCLE1BQU0sTUFBTTtBQUNSLFFBQUksYUFBYTtBQUNiO0FBQ0osaUJBQWEsYUFBYSxZQUFZLGFBQWEsTUFBTSxhQUFhLFFBQVE7QUFBQSxFQUNqRjtBQUFBLEVBQ0QsT0FBTyxNQUFNO0FBQ1QsUUFBSSxDQUFDLGFBQWE7QUFDZDtBQUNKLGtCQUFjLGFBQWEsVUFBVTtBQUNyQyxXQUFPLGFBQWE7QUFBQSxFQUN2QjtBQUFBLEVBQ0QsS0FBSyxDQUFDLE9BQU87QUFDVCxpQkFBYSxhQUFhLElBQUksRUFBRTtBQUNoQyxRQUFJLGFBQWEsWUFBWSxPQUFRLGFBQWEsUUFBUSxHQUFJO0FBQzFELG1CQUFhLEtBQUk7QUFBQSxJQUNwQixPQUNJO0FBQ0QsbUJBQWEsS0FBSTtBQUFBLElBQ3BCO0FBQUEsRUFDSjtBQUFBLEVBQ0QsUUFBUSxDQUFDLE9BQU87QUFDWixpQkFBYSxhQUFhLE9BQU8sRUFBRTtBQUNuQyxpQkFBYSxZQUFZLE9BQU8sRUFBRTtBQUFBLEVBQ3JDO0FBQUEsRUFDRCxVQUFVLE1BQU07QUFDWixXQUFPLElBQUksUUFBUSxDQUFBNUcsYUFBVztBQUMxQixZQUFNLFVBQVUsTUFBTSxhQUFhLE9BQU8sUUFBUTtBQUNsRCxZQUFNLFdBQVcsTUFBTUEsU0FBUSxPQUFPO0FBQ3RDLG1CQUFhLElBQUksUUFBUTtBQUFBLElBQ3JDLENBQVM7QUFBQSxFQUNKO0FBQUEsRUFDRCxNQUFNLE1BQU07QUFDUixRQUFJLGFBQWEsWUFBWSxRQUFRLGFBQWE7QUFDOUM7QUFDSixRQUFJLENBQUMsYUFBYSxhQUFhO0FBQzNCLGFBQU8sYUFBYTtBQUN4QixlQUFXLE1BQU0sYUFBYSxjQUFjO0FBQ3hDLFVBQUksYUFBYSxZQUFZLFFBQVEsYUFBYTtBQUM5QztBQUNKLG1CQUFhLGFBQWEsT0FBTyxFQUFFO0FBQ25DLG1CQUFhLFlBQVksSUFBSSxFQUFFO0FBQy9CO0lBQ0g7QUFBQSxFQUNKO0FBQ0w7QUFFQSxlQUFBLFVBQWtCO0FDdkRsQixPQUFPLGVBQWUsVUFBUyxjQUFjLEVBQUUsT0FBTyxLQUFJLENBQUU7QUFDNUQsU0FBQSxlQUF1QixTQUFBLGdCQUF3QjtBQUMvQyxNQUFNLG1CQUFtQk07QUFFekIsTUFBTSxnQkFBZ0IsQ0FBQyxJQUFJLHFCQUFxQjtBQUM1QyxTQUFPLFNBQVUsV0FBVztBQUN4QixXQUFPLFNBQVMsVUFBVTtBQUN0QixhQUFPLGlCQUFpQixRQUFRLFNBQVEsRUFBRyxLQUFLLGFBQVc7QUFDdkQsZUFBTyxHQUFHLE1BQU0sUUFBVyxTQUFTLEVBQUUsS0FBSyxZQUFVO0FBQ2pEO0FBQ0EsaUJBQU87QUFBQSxRQUNWLEdBQUUsQ0FBQUwsV0FBUztBQUNSO0FBQ0EsY0FBSSxLQUFLLElBQUcsS0FBTTtBQUNkLGtCQUFNQTtBQUNWLGNBQUksaUJBQWlCQSxNQUFLLEdBQUc7QUFDekIsa0JBQU0sUUFBUSxLQUFLLE1BQU0sTUFBTyxNQUFNLEtBQUssT0FBUSxDQUFDLEdBQUcsZUFBZSxJQUFJLFFBQVEsQ0FBQUQsYUFBVyxXQUFXQSxVQUFTLEtBQUssQ0FBQztBQUN2SCxtQkFBTyxhQUFhLEtBQUssTUFBTSxRQUFRLE1BQU0sUUFBVyxTQUFTLENBQUM7QUFBQSxVQUNyRTtBQUNELGdCQUFNQztBQUFBLFFBQzFCLENBQWlCO0FBQUEsTUFDakIsQ0FBYTtBQUFBLElBQ2I7QUFBQSxFQUNBO0FBQ0E7QUFDcUIsU0FBQSxnQkFBRztBQUN4QixNQUFNLGVBQWUsQ0FBQyxJQUFJLHFCQUFxQjtBQUMzQyxTQUFPLFNBQVUsV0FBVztBQUN4QixXQUFPLFNBQVMsVUFBVTtBQUN0QixVQUFJO0FBQ0EsZUFBTyxHQUFHLE1BQU0sUUFBVyxTQUFTO0FBQUEsTUFDdkMsU0FDTUEsUUFBTztBQUNWLFlBQUksS0FBSyxJQUFHLElBQUs7QUFDYixnQkFBTUE7QUFDVixZQUFJLGlCQUFpQkEsTUFBSztBQUN0QixpQkFBTyxRQUFRLE1BQU0sUUFBVyxTQUFTO0FBQzdDLGNBQU1BO0FBQUEsTUFDVDtBQUFBLElBQ2I7QUFBQSxFQUNBO0FBQ0E7QUFDQSxTQUFBLGVBQXVCO0FDMUN2QixPQUFPLGVBQWU2RyxNQUFTLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUM1RCxNQUFNLEtBQUt4RztBQUNYLE1BQU15RyxXQUFTbEg7QUFDZixNQUFNLGVBQWVDO0FBQ3JCLE1BQU0sZ0JBQWdCd0I7QUFDdEIsTUFBTSxhQUFhNkI7QUFFbkIsTUFBTSxLQUFLO0FBQUEsRUFDUCxjQUFjLGFBQWEsZ0JBQWdCNEQsU0FBTyxVQUFVLEdBQUcsS0FBSyxHQUFHLGNBQWMsUUFBUSxhQUFhO0FBQUEsRUFDMUcsY0FBYyxhQUFhLGdCQUFnQkEsU0FBTyxVQUFVLEdBQUcsS0FBSyxHQUFHLGNBQWMsUUFBUSxhQUFhO0FBQUEsRUFDMUcsY0FBYyxhQUFhLGdCQUFnQkEsU0FBTyxVQUFVLEdBQUcsS0FBSyxDQUFDO0FBQUEsRUFDckUsY0FBYyxhQUFhLGdCQUFnQkEsU0FBTyxVQUFVLEdBQUcsS0FBSyxDQUFDO0FBQUEsRUFDckUsY0FBYyxhQUFhLGdCQUFnQkEsU0FBTyxVQUFVLEdBQUcsS0FBSyxDQUFDO0FBQUEsRUFDckUsaUJBQWlCLGFBQWEsZ0JBQWdCQSxTQUFPLFVBQVUsR0FBRyxRQUFRLENBQUM7QUFBQSxFQUMzRSxhQUFhLGFBQWEsZ0JBQWdCQSxTQUFPLFVBQVUsR0FBRyxJQUFJLENBQUM7QUFBQSxFQUNuRSxlQUFlLGFBQWEsZ0JBQWdCQSxTQUFPLFVBQVUsR0FBRyxNQUFNLENBQUM7QUFBQSxFQUN2RSxZQUFZLFdBQVcsY0FBY0EsU0FBTyxVQUFVLEdBQUcsS0FBSyxHQUFHLGNBQWMsUUFBUSxnQkFBZ0I7QUFBQSxFQUN2RyxZQUFZLFdBQVcsY0FBY0EsU0FBTyxVQUFVLEdBQUcsS0FBSyxHQUFHLGNBQWMsUUFBUSxnQkFBZ0I7QUFBQSxFQUN2RyxXQUFXLFdBQVcsY0FBY0EsU0FBTyxVQUFVLEdBQUcsSUFBSSxHQUFHLGNBQWMsUUFBUSxnQkFBZ0I7QUFBQSxFQUNyRyxlQUFlLFdBQVcsY0FBY0EsU0FBTyxVQUFVLEdBQUcsUUFBUSxHQUFHLGNBQWMsUUFBUSxnQkFBZ0I7QUFBQSxFQUM3RyxhQUFhLFdBQVcsY0FBY0EsU0FBTyxVQUFVLEdBQUcsTUFBTSxHQUFHLGNBQWMsUUFBUSxnQkFBZ0I7QUFBQSxFQUN6RyxXQUFXLFdBQVcsY0FBY0EsU0FBTyxVQUFVLEdBQUcsSUFBSSxHQUFHLGNBQWMsUUFBUSxnQkFBZ0I7QUFBQSxFQUNyRyxZQUFZLFdBQVcsY0FBY0EsU0FBTyxVQUFVLEdBQUcsS0FBSyxHQUFHLGNBQWMsUUFBUSxnQkFBZ0I7QUFBQSxFQUN2RyxrQkFBa0IsYUFBYSxlQUFlLEdBQUcsV0FBVyxjQUFjLFFBQVEsYUFBYTtBQUFBLEVBQy9GLGtCQUFrQixhQUFhLGVBQWUsR0FBRyxXQUFXLGNBQWMsUUFBUSxhQUFhO0FBQUEsRUFDL0Ysa0JBQWtCLGFBQWEsZUFBZSxHQUFHLFNBQVM7QUFBQSxFQUMxRCxrQkFBa0IsYUFBYSxlQUFlLEdBQUcsU0FBUztBQUFBLEVBQzFELHFCQUFxQixhQUFhLGVBQWUsR0FBRyxZQUFZO0FBQUEsRUFDaEUsaUJBQWlCLGFBQWEsZUFBZSxHQUFHLFFBQVE7QUFBQSxFQUN4RCxtQkFBbUIsYUFBYSxlQUFlLEdBQUcsVUFBVTtBQUFBLEVBQzVELGdCQUFnQixXQUFXLGFBQWEsR0FBRyxXQUFXLGNBQWMsUUFBUSxnQkFBZ0I7QUFBQSxFQUM1RixnQkFBZ0IsV0FBVyxhQUFhLEdBQUcsV0FBVyxjQUFjLFFBQVEsZ0JBQWdCO0FBQUEsRUFDNUYsZUFBZSxXQUFXLGFBQWEsR0FBRyxVQUFVLGNBQWMsUUFBUSxnQkFBZ0I7QUFBQSxFQUMxRixtQkFBbUIsV0FBVyxhQUFhLEdBQUcsY0FBYyxjQUFjLFFBQVEsZ0JBQWdCO0FBQUEsRUFDbEcsaUJBQWlCLFdBQVcsYUFBYSxHQUFHLFlBQVksY0FBYyxRQUFRLGdCQUFnQjtBQUFBLEVBQzlGLGVBQWUsV0FBVyxhQUFhLEdBQUcsVUFBVSxjQUFjLFFBQVEsZ0JBQWdCO0FBQUEsRUFDMUYsZ0JBQWdCLFdBQVcsYUFBYSxHQUFHLFdBQVcsY0FBYyxRQUFRLGdCQUFnQjtBQUNoRztBQUVBRCxLQUFBLFVBQWtCOztBQ3ZDbEIsT0FBTyxlQUFlLE1BQVMsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQzVELE1BQU0sT0FBTztBQUFBLEVBQ1QsWUFBWSxDQUFDLE1BQU07QUFDZixXQUFPLE9BQU8sTUFBTTtBQUFBLEVBQ3ZCO0FBQUEsRUFDRCxVQUFVLENBQUMsTUFBTTtBQUNiLFdBQU8sT0FBTyxNQUFNO0FBQUEsRUFDdkI7QUFBQSxFQUNELGFBQWEsQ0FBQyxNQUFNO0FBQ2hCLFdBQU8sT0FBTyxNQUFNO0FBQUEsRUFDdkI7QUFDTDtBQUVBLEtBQUEsVUFBa0I7O0FDYmxCLE9BQU8sZUFBZSxXQUFTLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUU1RCxNQUFNLFNBQVMsQ0FBQTtBQUdmLE1BQU0sWUFBWTtBQUFBLEVBQ2QsTUFBTSxDQUFDbEgsUUFBTztBQUNWLFVBQU0sUUFBUSxPQUFPQSxHQUFFO0FBQ3ZCLFFBQUksQ0FBQztBQUNEO0FBQ0osVUFBTSxNQUFLO0FBQ1gsVUFBTSxNQUFNLE1BQU0sQ0FBQztBQUNuQixRQUFJLEtBQUs7QUFDTCxVQUFJLE1BQU0sVUFBVSxLQUFLQSxHQUFFLENBQUM7QUFBQSxJQUMvQixPQUNJO0FBQ0QsYUFBTyxPQUFPQSxHQUFFO0FBQUEsSUFDbkI7QUFBQSxFQUNKO0FBQUEsRUFDRCxVQUFVLENBQUNBLFFBQU87QUFDZCxXQUFPLElBQUksUUFBUSxDQUFBSSxhQUFXO0FBQzFCLFVBQUksUUFBUSxPQUFPSixHQUFFO0FBQ3JCLFVBQUksQ0FBQztBQUNELGdCQUFRLE9BQU9BLEdBQUUsSUFBSTtBQUN6QixZQUFNLEtBQUtJLFFBQU87QUFDbEIsVUFBSSxNQUFNLFNBQVM7QUFDZjtBQUNKLE1BQUFBLFNBQVEsTUFBTSxVQUFVLEtBQUtKLEdBQUUsQ0FBQztBQUFBLElBQzVDLENBQVM7QUFBQSxFQUNKO0FBQ0w7QUFFQSxVQUFBLFVBQWtCOztBQ2hDbEIsT0FBTyxlQUFlLE1BQVMsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQzVELE1BQU1nQixTQUFPTjtBQUNiLE1BQU1zRyxhQUFXL0c7QUFDakIsTUFBTWlILFNBQU9oSDtBQUdiLE1BQU0sT0FBTztBQUFBLEVBQ1QsT0FBTyxDQUFFO0FBQUEsRUFDVCxRQUFRLENBQUMsYUFBYTtBQUNsQixVQUFNLGFBQWEsU0FBUyxLQUFLLE1BQU0sS0FBSyxPQUFNLElBQUssUUFBUSxFQUFFLFNBQVMsRUFBRSxDQUFDLEdBQUcsTUFBTSxFQUFFLEdBQ3hGLFlBQVksS0FBSyxJQUFLLEVBQUMsU0FBUSxFQUFHLE1BQU0sR0FBRyxHQUMzQyxTQUFTLFFBQVEsU0FBUyxJQUFJLE1BQU0sR0FBRyxTQUFTLEdBQUcsVUFBVSxJQUFJLFdBQVcsR0FBRyxRQUFRLEdBQUcsTUFBTTtBQUNoRyxXQUFPO0FBQUEsRUFDVjtBQUFBLEVBQ0QsS0FBSyxDQUFDLFVBQVUsU0FBUyxRQUFRLFNBQVM7QUFDdEMsVUFBTSxXQUFXLEtBQUssU0FBUyxRQUFRLFFBQVEsQ0FBQztBQUNoRCxRQUFJLFlBQVksS0FBSztBQUNqQixhQUFPLEtBQUssSUFBSSxVQUFVLFNBQVMsS0FBSztBQUM1QyxTQUFLLE1BQU0sUUFBUSxJQUFJO0FBQ3ZCLFVBQU0sV0FBVyxNQUFNLE9BQU8sS0FBSyxNQUFNLFFBQVE7QUFDakQsV0FBTyxDQUFDLFVBQVUsUUFBUTtBQUFBLEVBQzdCO0FBQUEsRUFDRCxPQUFPLENBQUMsYUFBYTtBQUNqQixRQUFJLENBQUMsS0FBSyxNQUFNLFFBQVE7QUFDcEI7QUFDSixXQUFPLEtBQUssTUFBTSxRQUFRO0FBQzFCZ0gsV0FBSyxRQUFRLGNBQWMsUUFBUTtBQUFBLEVBQ3RDO0FBQUEsRUFDRCxXQUFXLENBQUMsYUFBYTtBQUNyQixRQUFJLENBQUMsS0FBSyxNQUFNLFFBQVE7QUFDcEI7QUFDSixXQUFPLEtBQUssTUFBTSxRQUFRO0FBQzFCQSxXQUFLLFFBQVEsa0JBQWtCLFFBQVE7QUFBQSxFQUMxQztBQUFBLEVBQ0QsY0FBYyxNQUFNO0FBQ2hCLGVBQVcsWUFBWSxLQUFLLE9BQU87QUFDL0IsV0FBSyxVQUFVLFFBQVE7QUFBQSxJQUMxQjtBQUFBLEVBQ0o7QUFBQSxFQUNELFVBQVUsQ0FBQyxhQUFhO0FBQ3BCLFVBQU0sV0FBV2xHLE9BQUssU0FBUyxRQUFRO0FBQ3ZDLFFBQUksU0FBUyxVQUFVZ0csV0FBUztBQUM1QixhQUFPO0FBQ1gsVUFBTSxZQUFZLHlEQUF5RCxLQUFLLFFBQVE7QUFDeEYsUUFBSSxDQUFDO0FBQ0QsYUFBTztBQUNYLFVBQU0sbUJBQW1CLFNBQVMsU0FBU0EsV0FBUztBQUNwRCxXQUFPLEdBQUcsU0FBUyxNQUFNLEdBQUcsQ0FBQyxTQUFTLE1BQU0sQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLEVBQUUsTUFBTSxHQUFHLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQztBQUFBLEVBQ3pIO0FBQ0w7QUFFQSxRQUFRLEdBQUcsUUFBUSxLQUFLLFlBQVk7QUFFcEMsS0FBQSxVQUFrQjtBQ3JEbEIsT0FBTyxlQUFlSSxRQUFTLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUN2Q0EsT0FBQSxtQ0FBdUJBLE9BQUEsZUFBdUNBLE9BQUEsV0FBRztBQUN0RixNQUFNcEcsU0FBT047QUFDYixNQUFNLFdBQVdUO0FBQ2pCLE1BQU0sT0FBT0M7QUFDYixNQUFNLFNBQVN3QjtBQUNmLE1BQU0sY0FBYzZCO0FBQ3BCLE1BQU0sU0FBU0M7QUFDZixTQUFTLFNBQVMsVUFBVSxVQUFVLFNBQVMsc0JBQXNCO0FBQ2pFLE1BQUk7QUFDSixNQUFJLE9BQU8sUUFBUSxTQUFTLE9BQU87QUFDL0IsV0FBTyxTQUFTLFVBQVUsRUFBRSxVQUFVLFFBQVMsQ0FBQTtBQUNuRCxRQUFNLFVBQVUsS0FBSyxJQUFLLE1BQUssS0FBSyxRQUFRLGFBQWEsUUFBUSxPQUFPLFNBQVMsS0FBSyxTQUFTO0FBQy9GLFNBQU8sS0FBSyxRQUFRLGNBQWMsT0FBTyxFQUFFLFVBQVUsT0FBTztBQUNoRTtBQUNnQjRELE9BQUEsV0FBRztBQUVuQixTQUFTLGFBQWEsVUFBVSxVQUFVLFNBQVMsc0JBQXNCO0FBQ3JFLE1BQUk7QUFDSixNQUFJLE9BQU8sUUFBUSxTQUFTLE9BQU87QUFDL0IsV0FBTyxhQUFhLFVBQVUsRUFBRSxVQUFVLFFBQVMsQ0FBQTtBQUN2RCxRQUFNLFVBQVUsS0FBSyxJQUFLLE1BQUssS0FBSyxRQUFRLGFBQWEsUUFBUSxPQUFPLFNBQVMsS0FBSyxTQUFTO0FBQy9GLFNBQU8sS0FBSyxRQUFRLGtCQUFrQixPQUFPLEVBQUUsVUFBVSxPQUFPO0FBQ3BFO0FBQ29CQSxPQUFBLGVBQUc7QUFFdkIsTUFBTSxZQUFZLENBQUMsVUFBVSxNQUFNLFNBQVMsYUFBYTtBQUNyRCxNQUFJLE9BQU8sUUFBUSxXQUFXLE9BQU87QUFDakMsV0FBTyxVQUFVLFVBQVUsTUFBTSxTQUFTLHVCQUF1QixPQUFPO0FBQzVFLFFBQU0sVUFBVSxlQUFlLFVBQVUsTUFBTSxPQUFPO0FBQ3RELE1BQUk7QUFDQSxZQUFRLEtBQUssVUFBVSxRQUFRO0FBQ25DLFNBQU87QUFDWDtBQUNpQkEsT0FBQSxZQUFHO0FBQ3BCLE1BQU0saUJBQWlCLE9BQU8sVUFBVSxNQUFNLFVBQVUsU0FBUywwQkFBMEI7QUFDdkYsTUFBSTtBQUNKLE1BQUksT0FBTyxRQUFRLFNBQVMsT0FBTztBQUMvQixXQUFPLGVBQWUsVUFBVSxNQUFNLEVBQUUsVUFBVSxRQUFPLENBQUU7QUFDL0QsUUFBTSxVQUFVLEtBQUssSUFBSyxNQUFLLEtBQUssUUFBUSxhQUFhLFFBQVEsT0FBTyxTQUFTLEtBQUssU0FBUztBQUMvRixNQUFJLDBCQUEwQixNQUFNLG9CQUFvQixNQUFNLGVBQWUsTUFBTSxXQUFXLE1BQU0sS0FBSztBQUN6RyxNQUFJO0FBQ0EsUUFBSSxRQUFRO0FBQ1IsZ0NBQTBCLE1BQU0sUUFBUSxTQUFTLFFBQVE7QUFDN0Qsd0JBQW9CLE1BQU0sWUFBWSxRQUFRLFNBQVMsUUFBUTtBQUMvRCxlQUFXLE1BQU0sS0FBSyxRQUFRLGdCQUFnQixRQUFRLEtBQUs7QUFDM0QsS0FBQyxVQUFVLFlBQVksSUFBSSxPQUFPLFFBQVEsSUFBSSxVQUFVLFFBQVEsYUFBYSxPQUFPLFFBQVEsUUFBUSxFQUFFLFFBQVEsYUFBYSxNQUFNO0FBQ2pJLFVBQU0sZUFBZSxTQUFTLFlBQVksT0FBTyxRQUFRLFlBQVksUUFBUSxLQUFLLEdBQUcsY0FBYyxPQUFPLFFBQVEsWUFBWSxRQUFRLElBQUk7QUFDMUksUUFBSSxnQkFBZ0IsYUFBYTtBQUM3QixZQUFNOUQsUUFBTyxNQUFNLEtBQUssUUFBUSxZQUFZLFFBQVE7QUFDcEQsVUFBSUEsT0FBTTtBQUNOLGtCQUFVLEVBQUUsR0FBRztBQUNmLFlBQUk7QUFDQSxrQkFBUSxRQUFRLEVBQUUsS0FBS0EsTUFBSyxLQUFLLEtBQUtBLE1BQUs7QUFDL0MsWUFBSTtBQUNBLGtCQUFRLE9BQU9BLE1BQUs7QUFBQSxNQUMzQjtBQUFBLElBQ0o7QUFDRCxVQUFNLGFBQWF0QyxPQUFLLFFBQVEsUUFBUTtBQUN4QyxVQUFNLEtBQUssUUFBUSxhQUFhLFlBQVk7QUFBQSxNQUN4QyxNQUFNLFNBQVM7QUFBQSxNQUNmLFdBQVc7QUFBQSxJQUN2QixDQUFTO0FBQ0QsU0FBSyxNQUFNLEtBQUssUUFBUSxVQUFVLE9BQU8sRUFBRSxVQUFVLEtBQUssUUFBUSxRQUFRLFNBQVMsaUJBQWlCO0FBQ3BHLFFBQUksUUFBUTtBQUNSLGNBQVEsV0FBVyxRQUFRO0FBQy9CLFFBQUksT0FBTyxRQUFRLFNBQVMsSUFBSSxHQUFHO0FBQy9CLFlBQU0sS0FBSyxRQUFRLFdBQVcsT0FBTyxFQUFFLElBQUksTUFBTSxHQUFHLFFBQVEsWUFBWSxTQUFTLGdCQUFnQjtBQUFBLElBQ3BHLFdBQ1EsQ0FBQyxPQUFPLFFBQVEsWUFBWSxJQUFJLEdBQUc7QUFDeEMsWUFBTSxLQUFLLFFBQVEsV0FBVyxPQUFPLEVBQUUsSUFBSSxNQUFNLEdBQUcsS0FBSyxRQUFRLENBQUM7QUFBQSxJQUNyRTtBQUNELFFBQUksUUFBUSxVQUFVLE9BQU87QUFDekIsVUFBSSxRQUFRLGNBQWMsT0FBTztBQUM3QixjQUFNLEtBQUssUUFBUSxXQUFXLE9BQU8sRUFBRSxFQUFFO0FBQUEsTUFDNUMsT0FDSTtBQUNELGFBQUssUUFBUSxhQUFhLEVBQUU7QUFBQSxNQUMvQjtBQUFBLElBQ0o7QUFDRCxVQUFNLEtBQUssUUFBUSxXQUFXLE9BQU8sRUFBRSxFQUFFO0FBQ3pDLFNBQUs7QUFDTCxRQUFJLFFBQVE7QUFDUixZQUFNLEtBQUssUUFBUSxhQUFhLFVBQVUsUUFBUSxNQUFNLEtBQUssUUFBUSxNQUFNLEdBQUc7QUFDbEYsUUFBSSxRQUFRO0FBQ1IsWUFBTSxLQUFLLFFBQVEsYUFBYSxVQUFVLFFBQVEsSUFBSTtBQUMxRCxRQUFJO0FBQ0EsWUFBTSxLQUFLLFFBQVEsWUFBWSxPQUFPLEVBQUUsVUFBVSxRQUFRO0FBQUEsSUFDN0QsU0FDTVgsUUFBTztBQUNWLFVBQUlBLE9BQU0sU0FBUztBQUNmLGNBQU1BO0FBQ1YsWUFBTSxLQUFLLFFBQVEsWUFBWSxPQUFPLEVBQUUsVUFBVSxPQUFPLFFBQVEsU0FBUyxRQUFRLENBQUM7QUFBQSxJQUN0RjtBQUNEO0FBQ0EsZUFBVztBQUFBLEVBQ2QsVUFDTztBQUNKLFFBQUk7QUFDQSxZQUFNLEtBQUssUUFBUSxhQUFhLEVBQUU7QUFDdEMsUUFBSTtBQUNBLGFBQU8sUUFBUSxNQUFNLFFBQVE7QUFDakMsUUFBSTtBQUNBO0FBQ0osUUFBSTtBQUNBO0VBQ1A7QUFDTDtBQUNBLE1BQU0sZ0JBQWdCLENBQUMsVUFBVSxNQUFNLFVBQVUsU0FBUywwQkFBMEI7QUFDaEYsTUFBSTtBQUNKLE1BQUksT0FBTyxRQUFRLFNBQVMsT0FBTztBQUMvQixXQUFPLGNBQWMsVUFBVSxNQUFNLEVBQUUsVUFBVSxRQUFPLENBQUU7QUFDOUQsUUFBTSxVQUFVLEtBQUssSUFBSyxNQUFLLEtBQUssUUFBUSxhQUFhLFFBQVEsT0FBTyxTQUFTLEtBQUssU0FBUztBQUMvRixNQUFJLGVBQWUsTUFBTSxXQUFXLE1BQU0sS0FBSztBQUMvQyxNQUFJO0FBQ0EsZUFBVyxLQUFLLFFBQVEsb0JBQW9CLFFBQVEsS0FBSztBQUN6RCxLQUFDLFVBQVUsWUFBWSxJQUFJLE9BQU8sUUFBUSxJQUFJLFVBQVUsUUFBUSxhQUFhLE9BQU8sUUFBUSxRQUFRLEVBQUUsUUFBUSxhQUFhLE1BQU07QUFDakksVUFBTSxlQUFlLFNBQVMsWUFBWSxPQUFPLFFBQVEsWUFBWSxRQUFRLEtBQUssR0FBRyxjQUFjLE9BQU8sUUFBUSxZQUFZLFFBQVEsSUFBSTtBQUMxSSxRQUFJLGdCQUFnQixhQUFhO0FBQzdCLFlBQU1pRCxRQUFPLEtBQUssUUFBUSxnQkFBZ0IsUUFBUTtBQUNsRCxVQUFJQSxPQUFNO0FBQ04sa0JBQVUsRUFBRSxHQUFHO0FBQ2YsWUFBSTtBQUNBLGtCQUFRLFFBQVEsRUFBRSxLQUFLQSxNQUFLLEtBQUssS0FBS0EsTUFBSztBQUMvQyxZQUFJO0FBQ0Esa0JBQVEsT0FBT0EsTUFBSztBQUFBLE1BQzNCO0FBQUEsSUFDSjtBQUNELFVBQU0sYUFBYXRDLE9BQUssUUFBUSxRQUFRO0FBQ3hDLFNBQUssUUFBUSxpQkFBaUIsWUFBWTtBQUFBLE1BQ3RDLE1BQU0sU0FBUztBQUFBLE1BQ2YsV0FBVztBQUFBLElBQ3ZCLENBQVM7QUFDRCxTQUFLLEtBQUssUUFBUSxjQUFjLE9BQU8sRUFBRSxVQUFVLEtBQUssUUFBUSxRQUFRLFNBQVMsaUJBQWlCO0FBQ2xHLFFBQUksUUFBUTtBQUNSLGNBQVEsV0FBVyxRQUFRO0FBQy9CLFFBQUksT0FBTyxRQUFRLFNBQVMsSUFBSSxHQUFHO0FBQy9CLFdBQUssUUFBUSxlQUFlLE9BQU8sRUFBRSxJQUFJLE1BQU0sR0FBRyxRQUFRLFlBQVksU0FBUyxnQkFBZ0I7QUFBQSxJQUNsRyxXQUNRLENBQUMsT0FBTyxRQUFRLFlBQVksSUFBSSxHQUFHO0FBQ3hDLFdBQUssUUFBUSxlQUFlLE9BQU8sRUFBRSxJQUFJLE1BQU0sR0FBRyxLQUFLLFFBQVEsQ0FBQztBQUFBLElBQ25FO0FBQ0QsUUFBSSxRQUFRLFVBQVUsT0FBTztBQUN6QixVQUFJLFFBQVEsY0FBYyxPQUFPO0FBQzdCLGFBQUssUUFBUSxlQUFlLE9BQU8sRUFBRSxFQUFFO0FBQUEsTUFDMUMsT0FDSTtBQUNELGFBQUssUUFBUSxhQUFhLEVBQUU7QUFBQSxNQUMvQjtBQUFBLElBQ0o7QUFDRCxTQUFLLFFBQVEsZUFBZSxPQUFPLEVBQUUsRUFBRTtBQUN2QyxTQUFLO0FBQ0wsUUFBSSxRQUFRO0FBQ1IsV0FBSyxRQUFRLGlCQUFpQixVQUFVLFFBQVEsTUFBTSxLQUFLLFFBQVEsTUFBTSxHQUFHO0FBQ2hGLFFBQUksUUFBUTtBQUNSLFdBQUssUUFBUSxpQkFBaUIsVUFBVSxRQUFRLElBQUk7QUFDeEQsUUFBSTtBQUNBLFdBQUssUUFBUSxnQkFBZ0IsT0FBTyxFQUFFLFVBQVUsUUFBUTtBQUFBLElBQzNELFNBQ01YLFFBQU87QUFDVixVQUFJQSxPQUFNLFNBQVM7QUFDZixjQUFNQTtBQUNWLFdBQUssUUFBUSxnQkFBZ0IsT0FBTyxFQUFFLFVBQVUsT0FBTyxRQUFRLFNBQVMsUUFBUSxDQUFDO0FBQUEsSUFDcEY7QUFDRDtBQUNBLGVBQVc7QUFBQSxFQUNkLFVBQ087QUFDSixRQUFJO0FBQ0EsV0FBSyxRQUFRLGlCQUFpQixFQUFFO0FBQ3BDLFFBQUk7QUFDQSxhQUFPLFFBQVEsTUFBTSxRQUFRO0FBQUEsRUFDcEM7QUFDTDtBQUNBK0csT0FBQSxnQkFBd0I7Ozs7Ozs7OztBQy9LeEIsU0FBTyxlQUFjNUUsVUFBVSxjQUFjLEVBQUUsT0FBTyxLQUFJLENBQUU7QUFDNUQsRUFBQUEsU0FBQSxhQUFxQkEsU0FBMkIsbUJBQUFBLFNBQUEsY0FBc0JBLFNBQXdCLGdCQUFBQSxTQUFBLFlBQW9CQSxxQkFBb0JBLFNBQXFCLGFBQUFBLFNBQUEsTUFBY0EsU0FBWSxJQUFBQSxTQUFBLE1BQWNBLGlCQUFnQkEsU0FBZSxPQUFBQSxTQUFBLGFBQXFCQSxTQUFzQixjQUFBO0FBQUEsRUFDN1EsTUFBTSxZQUFZO0FBQUEsRUFDakI7QUFDRCxFQUFBQSxTQUFBLGNBQXNCO0FBQ3RCLEVBQUFBLFNBQUEsYUFBcUI7QUFBQSxFQUNyQixNQUFNLGFBQWEsWUFBWTtBQUFBLElBQzNCLFlBQVksR0FBRztBQUNYO0FBQ0EsVUFBSSxDQUFDQSxTQUFRLFdBQVcsS0FBSyxDQUFDO0FBQzFCLGNBQU0sSUFBSSxNQUFNLDBDQUEwQztBQUM5RCxXQUFLLE1BQU07QUFBQSxJQUNkO0FBQUEsSUFDRCxXQUFXO0FBQ1AsYUFBTyxLQUFLO0FBQUEsSUFDZjtBQUFBLElBQ0QsV0FBVztBQUNQLGFBQU87QUFBQSxJQUNWO0FBQUEsSUFDRCxJQUFJLFFBQVE7QUFDUixhQUFPLEVBQUUsQ0FBQyxLQUFLLEdBQUcsR0FBRyxFQUFDO0FBQUEsSUFDekI7QUFBQSxFQUNKO0FBQ0QsRUFBQUEsU0FBQSxPQUFlO0FBQUEsRUFDZixNQUFNLGNBQWMsWUFBWTtBQUFBLElBQzVCLFlBQVl5RSxPQUFNO0FBQ2Q7QUFDQSxXQUFLLFNBQVMsT0FBT0EsVUFBUyxXQUFXLENBQUNBLEtBQUksSUFBSUE7QUFBQSxJQUNyRDtBQUFBLElBQ0QsV0FBVztBQUNQLGFBQU8sS0FBSztBQUFBLElBQ2Y7QUFBQSxJQUNELFdBQVc7QUFDUCxVQUFJLEtBQUssT0FBTyxTQUFTO0FBQ3JCLGVBQU87QUFDWCxZQUFNLE9BQU8sS0FBSyxPQUFPLENBQUM7QUFDMUIsYUFBTyxTQUFTLE1BQU0sU0FBUztBQUFBLElBQ2xDO0FBQUEsSUFDRCxJQUFJLE1BQU07QUFDTixVQUFJO0FBQ0osY0FBUyxLQUFLLEtBQUssVUFBVSxRQUFRLE9BQU8sU0FBUyxLQUFNLEtBQUssT0FBTyxLQUFLLE9BQU8sT0FBTyxDQUFDLEdBQUcsTUFBTSxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRTtBQUFBLElBQ3JIO0FBQUEsSUFDRCxJQUFJLFFBQVE7QUFDUixVQUFJO0FBQ0osY0FBUyxLQUFLLEtBQUssWUFBWSxRQUFRLE9BQU8sU0FBUyxLQUFNLEtBQUssU0FBUyxLQUFLLE9BQU8sT0FBTyxDQUFDSSxRQUFPLE1BQU07QUFDeEcsWUFBSSxhQUFhO0FBQ2IsVUFBQUEsT0FBTSxFQUFFLEdBQUcsS0FBS0EsT0FBTSxFQUFFLEdBQUcsS0FBSyxLQUFLO0FBQ3pDLGVBQU9BO0FBQUEsTUFDbkIsR0FBVyxDQUFBLENBQUU7QUFBQSxJQUNSO0FBQUEsRUFDSjtBQUNELEVBQUE3RSxTQUFBLFFBQWdCO0FBQ2hCLEVBQUFBLFNBQUEsTUFBYyxJQUFJLE1BQU0sRUFBRTtBQUMxQixXQUFTLEVBQUUsU0FBUyxNQUFNO0FBQ3RCLFVBQU15RSxRQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDckIsUUFBSSxJQUFJO0FBQ1IsV0FBTyxJQUFJLEtBQUssUUFBUTtBQUNwQixpQkFBV0EsT0FBTSxLQUFLLENBQUMsQ0FBQztBQUN4QixNQUFBQSxNQUFLLEtBQUssS0FBSyxFQUFFLENBQUMsQ0FBQztBQUFBLElBQ3RCO0FBQ0QsV0FBTyxJQUFJLE1BQU1BLEtBQUk7QUFBQSxFQUN4QjtBQUNELEVBQUF6RSxTQUFBLElBQVk7QUFDWixRQUFNLE9BQU8sSUFBSSxNQUFNLEdBQUc7QUFDMUIsV0FBUyxJQUFJLFNBQVMsTUFBTTtBQUN4QixVQUFNLE9BQU8sQ0FBQyxjQUFjLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDcEMsUUFBSSxJQUFJO0FBQ1IsV0FBTyxJQUFJLEtBQUssUUFBUTtBQUNwQixXQUFLLEtBQUssSUFBSTtBQUNkLGlCQUFXLE1BQU0sS0FBSyxDQUFDLENBQUM7QUFDeEIsV0FBSyxLQUFLLE1BQU0sY0FBYyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFBQSxJQUMzQztBQUNELGFBQVMsSUFBSTtBQUNiLFdBQU8sSUFBSSxNQUFNLElBQUk7QUFBQSxFQUN4QjtBQUNELEVBQUFBLFNBQUEsTUFBYztBQUNkLFdBQVMsV0FBV3lFLE9BQU0sS0FBSztBQUMzQixRQUFJLGVBQWU7QUFDZixNQUFBQSxNQUFLLEtBQUssR0FBRyxJQUFJLE1BQU07QUFBQSxhQUNsQixlQUFlO0FBQ3BCLE1BQUFBLE1BQUssS0FBSyxHQUFHO0FBQUE7QUFFYixNQUFBQSxNQUFLLEtBQUssWUFBWSxHQUFHLENBQUM7QUFBQSxFQUNqQztBQUNELEVBQUF6RSxTQUFBLGFBQXFCO0FBQ3JCLFdBQVMsU0FBUyxNQUFNO0FBQ3BCLFFBQUksSUFBSTtBQUNSLFdBQU8sSUFBSSxLQUFLLFNBQVMsR0FBRztBQUN4QixVQUFJLEtBQUssQ0FBQyxNQUFNLE1BQU07QUFDbEIsY0FBTSxNQUFNLGVBQWUsS0FBSyxJQUFJLENBQUMsR0FBRyxLQUFLLElBQUksQ0FBQyxDQUFDO0FBQ25ELFlBQUksUUFBUSxRQUFXO0FBQ25CLGVBQUssT0FBTyxJQUFJLEdBQUcsR0FBRyxHQUFHO0FBQ3pCO0FBQUEsUUFDSDtBQUNELGFBQUssR0FBRyxJQUFJO0FBQUEsTUFDZjtBQUNEO0FBQUEsSUFDSDtBQUFBLEVBQ0o7QUFDRCxXQUFTLGVBQWUsR0FBRyxHQUFHO0FBQzFCLFFBQUksTUFBTTtBQUNOLGFBQU87QUFDWCxRQUFJLE1BQU07QUFDTixhQUFPO0FBQ1gsUUFBSSxPQUFPLEtBQUssVUFBVTtBQUN0QixVQUFJLGFBQWEsUUFBUSxFQUFFLEVBQUUsU0FBUyxDQUFDLE1BQU07QUFDekM7QUFDSixVQUFJLE9BQU8sS0FBSztBQUNaLGVBQU8sR0FBRyxFQUFFLE1BQU0sR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO0FBQ2hDLFVBQUksRUFBRSxDQUFDLE1BQU07QUFDVCxlQUFPLEVBQUUsTUFBTSxHQUFHLEVBQUUsSUFBSSxFQUFFLE1BQU0sQ0FBQztBQUNyQztBQUFBLElBQ0g7QUFDRCxRQUFJLE9BQU8sS0FBSyxZQUFZLEVBQUUsQ0FBQyxNQUFNLE9BQU8sRUFBRSxhQUFhO0FBQ3ZELGFBQU8sSUFBSSxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUM3QjtBQUFBLEVBQ0g7QUFDRCxXQUFTLFVBQVUsSUFBSSxJQUFJO0FBQ3ZCLFdBQU8sR0FBRyxTQUFRLElBQUssS0FBSyxHQUFHLFNBQVEsSUFBSyxLQUFLLE1BQU8sRUFBRSxHQUFHLEVBQUU7QUFBQSxFQUNsRTtBQUNELEVBQUFBLFNBQUEsWUFBb0I7QUFFcEIsV0FBUyxZQUFZLEdBQUc7QUFDcEIsV0FBTyxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssYUFBYSxNQUFNLE9BQ3hELElBQ0EsY0FBYyxNQUFNLFFBQVEsQ0FBQyxJQUFJLEVBQUUsS0FBSyxHQUFHLElBQUksQ0FBQztBQUFBLEVBQ3pEO0FBQ0QsV0FBUzRDLFdBQVUsR0FBRztBQUNsQixXQUFPLElBQUksTUFBTSxjQUFjLENBQUMsQ0FBQztBQUFBLEVBQ3BDO0FBQ0QsRUFBQTVDLFNBQUEsWUFBb0I0QztBQUNwQixXQUFTLGNBQWMsR0FBRztBQUN0QixXQUFPLEtBQUssVUFBVSxDQUFDLEVBQ2xCLFFBQVEsV0FBVyxTQUFTLEVBQzVCLFFBQVEsV0FBVyxTQUFTO0FBQUEsRUFDcEM7QUFDRCxFQUFBNUMsU0FBQSxnQkFBd0I7QUFDeEIsV0FBUyxZQUFZLEtBQUs7QUFDdEIsV0FBTyxPQUFPLE9BQU8sWUFBWUEsU0FBUSxXQUFXLEtBQUssR0FBRyxJQUFJLElBQUksTUFBTSxJQUFJLEdBQUcsRUFBRSxJQUFJLEtBQU0sR0FBRztBQUFBLEVBQ25HO0FBQ0QsRUFBQUEsU0FBQSxjQUFzQjtBQUV0QixXQUFTLGlCQUFpQixLQUFLO0FBQzNCLFFBQUksT0FBTyxPQUFPLFlBQVlBLFNBQVEsV0FBVyxLQUFLLEdBQUcsR0FBRztBQUN4RCxhQUFPLElBQUksTUFBTSxHQUFHLEdBQUcsRUFBRTtBQUFBLElBQzVCO0FBQ0QsVUFBTSxJQUFJLE1BQU0saUNBQWlDLEdBQUcsaUNBQWlDO0FBQUEsRUFDeEY7QUFDRCxFQUFBQSxTQUFBLG1CQUEyQjtBQUMzQixXQUFTLFdBQVcsSUFBSTtBQUNwQixXQUFPLElBQUksTUFBTSxHQUFHLFNBQVUsQ0FBQTtBQUFBLEVBQ2pDO0FBQ0QsRUFBQUEsU0FBQSxhQUFxQjs7OztBQ3hKckIsU0FBTyxlQUFjQSxVQUFVLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUM1RCxFQUFBQSxTQUFBLGFBQXFCQSwwQkFBeUJBLFNBQWdCLFFBQUFBLFNBQUEsV0FBbUJBLFNBQXlCLGlCQUFBO0FBQzFHLFFBQU04RSxVQUFTNUc7QUFBQUEsRUFDZixNQUFNLG1CQUFtQixNQUFNO0FBQUEsSUFDM0IsWUFBWSxNQUFNO0FBQ2QsWUFBTSx1QkFBdUIsSUFBSSxjQUFjO0FBQy9DLFdBQUssUUFBUSxLQUFLO0FBQUEsSUFDckI7QUFBQSxFQUNKO0FBQ0QsTUFBSTtBQUNKLEdBQUMsU0FBVTZHLGlCQUFnQjtBQUN2QixJQUFBQSxnQkFBZUEsZ0JBQWUsU0FBUyxJQUFJLENBQUMsSUFBSTtBQUNoRCxJQUFBQSxnQkFBZUEsZ0JBQWUsV0FBVyxJQUFJLENBQUMsSUFBSTtBQUFBLEtBQ25ELGlCQUFpQi9FLFNBQVEsbUJBQW1CQSxTQUF5QixpQkFBQSxDQUFFLEVBQUM7QUFDM0UsRUFBQUEsU0FBbUIsV0FBQTtBQUFBLElBQ2YsT0FBTyxJQUFJOEUsUUFBTyxLQUFLLE9BQU87QUFBQSxJQUM5QixLQUFLLElBQUlBLFFBQU8sS0FBSyxLQUFLO0FBQUEsSUFDMUIsS0FBSyxJQUFJQSxRQUFPLEtBQUssS0FBSztBQUFBLEVBQzlCO0FBQUEsRUFDQSxNQUFNLE1BQU07QUFBQSxJQUNSLFlBQVksRUFBRSxVQUFVLE9BQU0sSUFBSyxDQUFBLEdBQUk7QUFDbkMsV0FBSyxTQUFTO0FBQ2QsV0FBSyxZQUFZO0FBQ2pCLFdBQUssVUFBVTtBQUFBLElBQ2xCO0FBQUEsSUFDRCxPQUFPLGNBQWM7QUFDakIsYUFBTyx3QkFBd0JBLFFBQU8sT0FBTyxlQUFlLEtBQUssS0FBSyxZQUFZO0FBQUEsSUFDckY7QUFBQSxJQUNELEtBQUssUUFBUTtBQUNULGFBQU8sSUFBSUEsUUFBTyxLQUFLLEtBQUssU0FBUyxNQUFNLENBQUM7QUFBQSxJQUMvQztBQUFBLElBQ0QsU0FBUyxRQUFRO0FBQ2IsWUFBTSxLQUFLLEtBQUssT0FBTyxNQUFNLEtBQUssS0FBSyxXQUFXLE1BQU07QUFDeEQsYUFBTyxHQUFHLE1BQU0sR0FBRyxHQUFHLE9BQU87QUFBQSxJQUNoQztBQUFBLElBQ0QsV0FBVyxRQUFRO0FBQ2YsVUFBSSxJQUFJO0FBQ1IsWUFBTSxNQUFNLEtBQUssS0FBSyxhQUFhLFFBQVEsT0FBTyxTQUFTLFNBQVMsR0FBRyxlQUFlLFFBQVEsT0FBTyxTQUFTLFNBQVMsR0FBRyxJQUFJLE1BQU0sTUFBTyxLQUFLLGFBQWEsQ0FBQyxLQUFLLFVBQVUsSUFBSSxNQUFNLEdBQUk7QUFDdkwsY0FBTSxJQUFJLE1BQU0sb0JBQW9CLE1BQU0sZ0NBQWdDO0FBQUEsTUFDN0U7QUFDRCxhQUFRLEtBQUssT0FBTyxNQUFNLElBQUksRUFBRSxRQUFRLE9BQU87SUFDbEQ7QUFBQSxFQUNKO0FBQ0QsRUFBQTlFLFNBQUEsUUFBZ0I7QUFBQSxFQUNoQixNQUFNLHVCQUF1QjhFLFFBQU8sS0FBSztBQUFBLElBQ3JDLFlBQVksUUFBUSxTQUFTO0FBQ3pCLFlBQU0sT0FBTztBQUNiLFdBQUssU0FBUztBQUFBLElBQ2pCO0FBQUEsSUFDRCxTQUFTLE9BQU8sRUFBRSxVQUFVLFVBQVMsR0FBSTtBQUNyQyxXQUFLLFFBQVE7QUFDYixXQUFLLGFBQVksR0FBSUEsUUFBTyxNQUFPLElBQUlBLFFBQU8sS0FBSyxRQUFRLENBQUMsSUFBSSxTQUFTO0FBQUEsSUFDNUU7QUFBQSxFQUNKO0FBQ0QsRUFBQTlFLFNBQUEsaUJBQXlCO0FBQ3pCLFFBQU0sUUFBVyxHQUFBOEUsUUFBTztBQUFBLEVBQ3hCLE1BQU0sbUJBQW1CLE1BQU07QUFBQSxJQUMzQixZQUFZLE1BQU07QUFDZCxZQUFNLElBQUk7QUFDVixXQUFLLFVBQVU7QUFDZixXQUFLLFNBQVMsS0FBSztBQUNuQixXQUFLLE9BQU8sRUFBRSxHQUFHLE1BQU0sSUFBSSxLQUFLLFFBQVEsT0FBT0EsUUFBTztJQUN6RDtBQUFBLElBQ0QsTUFBTTtBQUNGLGFBQU8sS0FBSztBQUFBLElBQ2Y7QUFBQSxJQUNELEtBQUssUUFBUTtBQUNULGFBQU8sSUFBSSxlQUFlLFFBQVEsS0FBSyxTQUFTLE1BQU0sQ0FBQztBQUFBLElBQzFEO0FBQUEsSUFDRCxNQUFNLGNBQWMsT0FBTztBQUN2QixVQUFJO0FBQ0osVUFBSSxNQUFNLFFBQVE7QUFDZCxjQUFNLElBQUksTUFBTSxzQ0FBc0M7QUFDMUQsWUFBTSxPQUFPLEtBQUssT0FBTyxZQUFZO0FBQ3JDLFlBQU0sRUFBRSxPQUFRLElBQUc7QUFDbkIsWUFBTSxZQUFZLEtBQUssTUFBTSxTQUFTLFFBQVEsT0FBTyxTQUFTLEtBQUssTUFBTTtBQUN6RSxVQUFJLEtBQUssS0FBSyxRQUFRLE1BQU07QUFDNUIsVUFBSSxJQUFJO0FBQ0osY0FBTSxRQUFRLEdBQUcsSUFBSSxRQUFRO0FBQzdCLFlBQUk7QUFDQSxpQkFBTztBQUFBLE1BQ2QsT0FDSTtBQUNELGFBQUssS0FBSyxRQUFRLE1BQU0sSUFBSSxvQkFBSSxJQUFHO0FBQUEsTUFDdEM7QUFDRCxTQUFHLElBQUksVUFBVSxJQUFJO0FBQ3JCLFlBQU0sSUFBSSxLQUFLLE9BQU8sTUFBTSxNQUFNLEtBQUssT0FBTyxNQUFNLElBQUksQ0FBQTtBQUN4RCxZQUFNLFlBQVksRUFBRTtBQUNwQixRQUFFLFNBQVMsSUFBSSxNQUFNO0FBQ3JCLFdBQUssU0FBUyxPQUFPLEVBQUUsVUFBVSxRQUFRLFVBQVMsQ0FBRTtBQUNwRCxhQUFPO0FBQUEsSUFDVjtBQUFBLElBQ0QsU0FBUyxRQUFRLFVBQVU7QUFDdkIsWUFBTSxLQUFLLEtBQUssUUFBUSxNQUFNO0FBQzlCLFVBQUksQ0FBQztBQUNEO0FBQ0osYUFBTyxHQUFHLElBQUksUUFBUTtBQUFBLElBQ3pCO0FBQUEsSUFDRCxVQUFVLFdBQVcsU0FBUyxLQUFLLFNBQVM7QUFDeEMsYUFBTyxLQUFLLGNBQWMsUUFBUSxDQUFDLFNBQVM7QUFDeEMsWUFBSSxLQUFLLGNBQWM7QUFDbkIsZ0JBQU0sSUFBSSxNQUFNLGtCQUFrQixJQUFJLGdCQUFnQjtBQUMxRCxnQkFBVyxHQUFBQSxRQUFPLEtBQU0sU0FBUyxHQUFHLEtBQUssU0FBUztBQUFBLE1BQzlELENBQVM7QUFBQSxJQUNKO0FBQUEsSUFDRCxVQUFVLFNBQVMsS0FBSyxTQUFTLFlBQVksU0FBUztBQUNsRCxhQUFPLEtBQUssY0FBYyxRQUFRLENBQUMsU0FBUztBQUN4QyxZQUFJLEtBQUssVUFBVTtBQUNmLGdCQUFNLElBQUksTUFBTSxrQkFBa0IsSUFBSSxnQkFBZ0I7QUFDMUQsZUFBTyxLQUFLLE1BQU07QUFBQSxNQUM5QixHQUFXLFlBQVksT0FBTztBQUFBLElBQ3pCO0FBQUEsSUFDRCxjQUFjLFFBQVEsV0FBVyxhQUFhLENBQUEsR0FBSSxTQUFTO0FBQ3ZELFVBQUlMLFFBQU9LLFFBQU87QUFDbEIsaUJBQVcsVUFBVSxRQUFRO0FBQ3pCLGNBQU0sS0FBSyxPQUFPLE1BQU07QUFDeEIsWUFBSSxDQUFDO0FBQ0Q7QUFDSixjQUFNLFVBQVcsV0FBVyxNQUFNLElBQUksV0FBVyxNQUFNLEtBQUssb0JBQUksSUFBRztBQUNuRSxXQUFHLFFBQVEsQ0FBQyxTQUFTO0FBQ2pCLGNBQUksUUFBUSxJQUFJLElBQUk7QUFDaEI7QUFDSixrQkFBUSxJQUFJLE1BQU0sZUFBZSxPQUFPO0FBQ3hDLGNBQUksSUFBSSxVQUFVLElBQUk7QUFDdEIsY0FBSSxHQUFHO0FBQ0gsa0JBQU1FLE9BQU0sS0FBSyxLQUFLLE1BQU1oRixTQUFRLFNBQVMsTUFBTUEsU0FBUSxTQUFTO0FBQ3BFLFlBQUF5RSxTQUFXLEdBQUFLLFFBQU8sS0FBTUwsS0FBSSxHQUFHTyxJQUFHLElBQUksSUFBSSxNQUFNLENBQUMsSUFBSSxLQUFLLEtBQUssRUFBRTtBQUFBLFVBQ3BFLFdBQ1MsSUFBSSxZQUFZLFFBQVEsWUFBWSxTQUFTLFNBQVMsUUFBUSxJQUFJLEdBQUk7QUFDNUUsWUFBQVAsU0FBVyxHQUFBSyxRQUFPLEtBQU1MLEtBQUksR0FBRyxDQUFDLEdBQUcsS0FBSyxLQUFLLEVBQUU7QUFBQSxVQUNsRCxPQUNJO0FBQ0Qsa0JBQU0sSUFBSSxXQUFXLElBQUk7QUFBQSxVQUM1QjtBQUNELGtCQUFRLElBQUksTUFBTSxlQUFlLFNBQVM7QUFBQSxRQUMxRCxDQUFhO0FBQUEsTUFDSjtBQUNELGFBQU9BO0FBQUEsSUFDVjtBQUFBLEVBQ0o7QUFDRCxFQUFBekUsU0FBQSxhQUFxQjs7O0FDNUlyQixTQUFPLGVBQWNBLFVBQVUsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQzVELEVBQUFBLFNBQUEsS0FBYUEsZUFBY0EsU0FBYyxNQUFBQSxTQUFBLFVBQWtCQSxxQkFBb0JBLFNBQW1CLFdBQUFBLFNBQUEsaUJBQXlCQSxzQkFBcUJBLFNBQWdCLFFBQUFBLFNBQUEsT0FBZUEsU0FBcUIsYUFBQUEsU0FBQSxZQUFvQkEsdUJBQXNCQSxTQUFjLE1BQUFBLFNBQUEsWUFBb0JBLGVBQWNBLFNBQVksSUFBQTtBQUMxUyxRQUFNOEUsVUFBUzVHO0FBQ2YsUUFBTSxVQUFVVDtBQUNoQixNQUFJLFNBQVNTO0FBQ2IsU0FBTyxlQUFlOEIsVUFBUyxLQUFLLEVBQUUsWUFBWSxNQUFNLEtBQUssV0FBWTtBQUFFLFdBQU8sT0FBTztBQUFBLEVBQUUsRUFBSSxDQUFBO0FBQy9GLFNBQU8sZUFBZUEsVUFBUyxPQUFPLEVBQUUsWUFBWSxNQUFNLEtBQUssV0FBWTtBQUFFLFdBQU8sT0FBTztBQUFBLEVBQUksRUFBSSxDQUFBO0FBQ25HLFNBQU8sZUFBZUEsVUFBUyxhQUFhLEVBQUUsWUFBWSxNQUFNLEtBQUssV0FBWTtBQUFFLFdBQU8sT0FBTztBQUFBLEVBQVUsRUFBSSxDQUFBO0FBQy9HLFNBQU8sZUFBZUEsVUFBUyxPQUFPLEVBQUUsWUFBWSxNQUFNLEtBQUssV0FBWTtBQUFFLFdBQU8sT0FBTztBQUFBLEVBQUksRUFBSSxDQUFBO0FBQ25HLFNBQU8sZUFBZUEsVUFBUyxlQUFlLEVBQUUsWUFBWSxNQUFNLEtBQUssV0FBWTtBQUFFLFdBQU8sT0FBTztBQUFBLEVBQVksRUFBSSxDQUFBO0FBQ25ILFNBQU8sZUFBZUEsVUFBUyxhQUFhLEVBQUUsWUFBWSxNQUFNLEtBQUssV0FBWTtBQUFFLFdBQU8sT0FBTztBQUFBLEVBQVUsRUFBSSxDQUFBO0FBQy9HLFNBQU8sZUFBZUEsVUFBUyxjQUFjLEVBQUUsWUFBWSxNQUFNLEtBQUssV0FBWTtBQUFFLFdBQU8sT0FBTztBQUFBLEVBQVcsRUFBSSxDQUFBO0FBQ2pILFNBQU8sZUFBZUEsVUFBUyxRQUFRLEVBQUUsWUFBWSxNQUFNLEtBQUssV0FBWTtBQUFFLFdBQU8sT0FBTztBQUFBLEVBQUssRUFBSSxDQUFBO0FBQ3JHLE1BQUksVUFBVXZDO0FBQ2QsU0FBTyxlQUFldUMsVUFBUyxTQUFTLEVBQUUsWUFBWSxNQUFNLEtBQUssV0FBWTtBQUFFLFdBQU8sUUFBUTtBQUFBLEVBQU0sRUFBSSxDQUFBO0FBQ3hHLFNBQU8sZUFBZUEsVUFBUyxjQUFjLEVBQUUsWUFBWSxNQUFNLEtBQUssV0FBWTtBQUFFLFdBQU8sUUFBUTtBQUFBLEVBQVcsRUFBSSxDQUFBO0FBQ2xILFNBQU8sZUFBZUEsVUFBUyxrQkFBa0IsRUFBRSxZQUFZLE1BQU0sS0FBSyxXQUFZO0FBQUUsV0FBTyxRQUFRO0FBQUEsRUFBZSxFQUFJLENBQUE7QUFDMUgsU0FBTyxlQUFlQSxVQUFTLFlBQVksRUFBRSxZQUFZLE1BQU0sS0FBSyxXQUFZO0FBQUUsV0FBTyxRQUFRO0FBQUEsRUFBUyxFQUFJLENBQUE7QUFDOUcsRUFBQUEsU0FBb0IsWUFBQTtBQUFBLElBQ2hCLElBQUksSUFBSThFLFFBQU8sTUFBTSxHQUFHO0FBQUEsSUFDeEIsS0FBSyxJQUFJQSxRQUFPLE1BQU0sSUFBSTtBQUFBLElBQzFCLElBQUksSUFBSUEsUUFBTyxNQUFNLEdBQUc7QUFBQSxJQUN4QixLQUFLLElBQUlBLFFBQU8sTUFBTSxJQUFJO0FBQUEsSUFDMUIsSUFBSSxJQUFJQSxRQUFPLE1BQU0sS0FBSztBQUFBLElBQzFCLEtBQUssSUFBSUEsUUFBTyxNQUFNLEtBQUs7QUFBQSxJQUMzQixLQUFLLElBQUlBLFFBQU8sTUFBTSxHQUFHO0FBQUEsSUFDekIsSUFBSSxJQUFJQSxRQUFPLE1BQU0sSUFBSTtBQUFBLElBQ3pCLEtBQUssSUFBSUEsUUFBTyxNQUFNLElBQUk7QUFBQSxJQUMxQixLQUFLLElBQUlBLFFBQU8sTUFBTSxHQUFHO0FBQUEsRUFDN0I7QUFBQSxFQUNBLE1BQU1HLE1BQUs7QUFBQSxJQUNQLGdCQUFnQjtBQUNaLGFBQU87QUFBQSxJQUNWO0FBQUEsSUFDRCxjQUFjLFFBQVEsWUFBWTtBQUM5QixhQUFPO0FBQUEsSUFDVjtBQUFBLEVBQ0o7QUFBQSxFQUNELE1BQU0sWUFBWUEsTUFBSztBQUFBLElBQ25CLFlBQVksU0FBUyxNQUFNLEtBQUs7QUFDNUI7QUFDQSxXQUFLLFVBQVU7QUFDZixXQUFLLE9BQU87QUFDWixXQUFLLE1BQU07QUFBQSxJQUNkO0FBQUEsSUFDRCxPQUFPLEVBQUUsS0FBSyxNQUFNO0FBQ2hCLFlBQU0sVUFBVSxNQUFNLFFBQVEsU0FBUyxNQUFNLEtBQUs7QUFDbEQsWUFBTSxNQUFNLEtBQUssUUFBUSxTQUFZLEtBQUssTUFBTSxLQUFLLEdBQUc7QUFDeEQsYUFBTyxHQUFHLE9BQU8sSUFBSSxLQUFLLElBQUksR0FBRyxHQUFHLE1BQU07QUFBQSxJQUM3QztBQUFBLElBQ0QsY0FBY0osUUFBT3pHLFlBQVc7QUFDNUIsVUFBSSxDQUFDeUcsT0FBTSxLQUFLLEtBQUssR0FBRztBQUNwQjtBQUNKLFVBQUksS0FBSztBQUNMLGFBQUssTUFBTSxhQUFhLEtBQUssS0FBS0EsUUFBT3pHLFVBQVM7QUFDdEQsYUFBTztBQUFBLElBQ1Y7QUFBQSxJQUNELElBQUksUUFBUTtBQUNSLGFBQU8sS0FBSyxlQUFlMEcsUUFBTyxjQUFjLEtBQUssSUFBSSxRQUFRO0lBQ3BFO0FBQUEsRUFDSjtBQUFBLEVBQ0QsTUFBTSxlQUFlRyxNQUFLO0FBQUEsSUFDdEIsWUFBWSxLQUFLLEtBQUssYUFBYTtBQUMvQjtBQUNBLFdBQUssTUFBTTtBQUNYLFdBQUssTUFBTTtBQUNYLFdBQUssY0FBYztBQUFBLElBQ3RCO0FBQUEsSUFDRCxPQUFPLEVBQUUsTUFBTTtBQUNYLGFBQU8sR0FBRyxLQUFLLEdBQUcsTUFBTSxLQUFLLEdBQUcsTUFBTTtBQUFBLElBQ3pDO0FBQUEsSUFDRCxjQUFjSixRQUFPekcsWUFBVztBQUM1QixVQUFJLEtBQUssZUFBZTBHLFFBQU8sUUFBUSxDQUFDRCxPQUFNLEtBQUssSUFBSSxHQUFHLEtBQUssQ0FBQyxLQUFLO0FBQ2pFO0FBQ0osV0FBSyxNQUFNLGFBQWEsS0FBSyxLQUFLQSxRQUFPekcsVUFBUztBQUNsRCxhQUFPO0FBQUEsSUFDVjtBQUFBLElBQ0QsSUFBSSxRQUFRO0FBQ1IsWUFBTXlHLFNBQVEsS0FBSyxlQUFlQyxRQUFPLE9BQU8sQ0FBRSxJQUFHLEVBQUUsR0FBRyxLQUFLLElBQUksTUFBSztBQUN4RSxhQUFPLGFBQWFELFFBQU8sS0FBSyxHQUFHO0FBQUEsSUFDdEM7QUFBQSxFQUNKO0FBQUEsRUFDRCxNQUFNLGlCQUFpQixPQUFPO0FBQUEsSUFDMUIsWUFBWSxLQUFLLElBQUksS0FBSyxhQUFhO0FBQ25DLFlBQU0sS0FBSyxLQUFLLFdBQVc7QUFDM0IsV0FBSyxLQUFLO0FBQUEsSUFDYjtBQUFBLElBQ0QsT0FBTyxFQUFFLE1BQU07QUFDWCxhQUFPLEdBQUcsS0FBSyxHQUFHLElBQUksS0FBSyxFQUFFLEtBQUssS0FBSyxHQUFHLE1BQU07QUFBQSxJQUNuRDtBQUFBLEVBQ0o7QUFBQSxFQUNELE1BQU0sY0FBY0ksTUFBSztBQUFBLElBQ3JCLFlBQVksT0FBTztBQUNmO0FBQ0EsV0FBSyxRQUFRO0FBQ2IsV0FBSyxRQUFRO0lBQ2hCO0FBQUEsSUFDRCxPQUFPLEVBQUUsTUFBTTtBQUNYLGFBQU8sR0FBRyxLQUFLLEtBQUssTUFBTTtBQUFBLElBQzdCO0FBQUEsRUFDSjtBQUFBLEVBQ0QsTUFBTSxjQUFjQSxNQUFLO0FBQUEsSUFDckIsWUFBWSxPQUFPO0FBQ2Y7QUFDQSxXQUFLLFFBQVE7QUFDYixXQUFLLFFBQVE7SUFDaEI7QUFBQSxJQUNELE9BQU8sRUFBRSxNQUFNO0FBQ1gsWUFBTSxRQUFRLEtBQUssUUFBUSxJQUFJLEtBQUssS0FBSyxLQUFLO0FBQzlDLGFBQU8sUUFBUSxLQUFLLE1BQU07QUFBQSxJQUM3QjtBQUFBLEVBQ0o7QUFBQSxFQUNELE1BQU0sY0FBY0EsTUFBSztBQUFBLElBQ3JCLFlBQVlwSCxRQUFPO0FBQ2Y7QUFDQSxXQUFLLFFBQVFBO0FBQUEsSUFDaEI7QUFBQSxJQUNELE9BQU8sRUFBRSxNQUFNO0FBQ1gsYUFBTyxTQUFTLEtBQUssS0FBSyxNQUFNO0FBQUEsSUFDbkM7QUFBQSxJQUNELElBQUksUUFBUTtBQUNSLGFBQU8sS0FBSyxNQUFNO0FBQUEsSUFDckI7QUFBQSxFQUNKO0FBQUEsRUFDRCxNQUFNLGdCQUFnQm9ILE1BQUs7QUFBQSxJQUN2QixZQUFZUixPQUFNO0FBQ2Q7QUFDQSxXQUFLLE9BQU9BO0FBQUEsSUFDZjtBQUFBLElBQ0QsT0FBTyxFQUFFLE1BQU07QUFDWCxhQUFPLEdBQUcsS0FBSyxJQUFJLE1BQU07QUFBQSxJQUM1QjtBQUFBLElBQ0QsZ0JBQWdCO0FBQ1osYUFBTyxHQUFHLEtBQUssSUFBSSxLQUFLLE9BQU87QUFBQSxJQUNsQztBQUFBLElBQ0QsY0FBY0ksUUFBT3pHLFlBQVc7QUFDNUIsV0FBSyxPQUFPLGFBQWEsS0FBSyxNQUFNeUcsUUFBT3pHLFVBQVM7QUFDcEQsYUFBTztBQUFBLElBQ1Y7QUFBQSxJQUNELElBQUksUUFBUTtBQUNSLGFBQU8sS0FBSyxnQkFBZ0IwRyxRQUFPLGNBQWMsS0FBSyxLQUFLLFFBQVE7SUFDdEU7QUFBQSxFQUNKO0FBQUEsRUFDRCxNQUFNLG1CQUFtQkcsTUFBSztBQUFBLElBQzFCLFlBQVksUUFBUSxJQUFJO0FBQ3BCO0FBQ0EsV0FBSyxRQUFRO0FBQUEsSUFDaEI7QUFBQSxJQUNELE9BQU8sTUFBTTtBQUNULGFBQU8sS0FBSyxNQUFNLE9BQU8sQ0FBQ1IsT0FBTSxNQUFNQSxRQUFPLEVBQUUsT0FBTyxJQUFJLEdBQUcsRUFBRTtBQUFBLElBQ2xFO0FBQUEsSUFDRCxnQkFBZ0I7QUFDWixZQUFNLEVBQUUsTUFBTyxJQUFHO0FBQ2xCLFVBQUksSUFBSSxNQUFNO0FBQ2QsYUFBTyxLQUFLO0FBQ1IsY0FBTSxJQUFJLE1BQU0sQ0FBQyxFQUFFLGNBQWE7QUFDaEMsWUFBSSxNQUFNLFFBQVEsQ0FBQztBQUNmLGdCQUFNLE9BQU8sR0FBRyxHQUFHLEdBQUcsQ0FBQztBQUFBLGlCQUNsQjtBQUNMLGdCQUFNLENBQUMsSUFBSTtBQUFBO0FBRVgsZ0JBQU0sT0FBTyxHQUFHLENBQUM7QUFBQSxNQUN4QjtBQUNELGFBQU8sTUFBTSxTQUFTLElBQUksT0FBTztBQUFBLElBQ3BDO0FBQUEsSUFDRCxjQUFjSSxRQUFPekcsWUFBVztBQUM1QixZQUFNLEVBQUUsTUFBTyxJQUFHO0FBQ2xCLFVBQUksSUFBSSxNQUFNO0FBQ2QsYUFBTyxLQUFLO0FBRVIsY0FBTSxJQUFJLE1BQU0sQ0FBQztBQUNqQixZQUFJLEVBQUUsY0FBY3lHLFFBQU96RyxVQUFTO0FBQ2hDO0FBQ0osc0JBQWN5RyxRQUFPLEVBQUUsS0FBSztBQUM1QixjQUFNLE9BQU8sR0FBRyxDQUFDO0FBQUEsTUFDcEI7QUFDRCxhQUFPLE1BQU0sU0FBUyxJQUFJLE9BQU87QUFBQSxJQUNwQztBQUFBLElBQ0QsSUFBSSxRQUFRO0FBQ1IsYUFBTyxLQUFLLE1BQU0sT0FBTyxDQUFDQSxRQUFPLE1BQU0sU0FBU0EsUUFBTyxFQUFFLEtBQUssR0FBRyxDQUFFLENBQUE7QUFBQSxJQUN0RTtBQUFBLEVBQ0o7QUFBQSxFQUNELE1BQU0sa0JBQWtCLFdBQVc7QUFBQSxJQUMvQixPQUFPLE1BQU07QUFDVCxhQUFPLE1BQU0sS0FBSyxLQUFLLE1BQU0sT0FBTyxJQUFJLElBQUksTUFBTSxLQUFLO0FBQUEsSUFDMUQ7QUFBQSxFQUNKO0FBQUEsRUFDRCxNQUFNLGFBQWEsV0FBVztBQUFBLEVBQzdCO0FBQUEsRUFDRCxNQUFNLGFBQWEsVUFBVTtBQUFBLEVBQzVCO0FBQ0QsT0FBSyxPQUFPO0FBQUEsRUFDWixNQUFNLFdBQVcsVUFBVTtBQUFBLElBQ3ZCLFlBQVksV0FBVyxPQUFPO0FBQzFCLFlBQU0sS0FBSztBQUNYLFdBQUssWUFBWTtBQUFBLElBQ3BCO0FBQUEsSUFDRCxPQUFPLE1BQU07QUFDVCxVQUFJSixRQUFPLE1BQU0sS0FBSyxTQUFTLE1BQU0sTUFBTSxPQUFPLElBQUk7QUFDdEQsVUFBSSxLQUFLO0FBQ0wsUUFBQUEsU0FBUSxVQUFVLEtBQUssS0FBSyxPQUFPLElBQUk7QUFDM0MsYUFBT0E7QUFBQSxJQUNWO0FBQUEsSUFDRCxnQkFBZ0I7QUFDWixZQUFNLGNBQWE7QUFDbkIsWUFBTSxPQUFPLEtBQUs7QUFDbEIsVUFBSSxTQUFTO0FBQ1QsZUFBTyxLQUFLO0FBQ2hCLFVBQUksSUFBSSxLQUFLO0FBQ2IsVUFBSSxHQUFHO0FBQ0gsY0FBTSxLQUFLLEVBQUU7QUFDYixZQUFJLEtBQUssT0FBTyxNQUFNLFFBQVEsRUFBRSxJQUFJLElBQUksS0FBSyxFQUFFLElBQUk7QUFBQSxNQUN0RDtBQUNELFVBQUksR0FBRztBQUNILFlBQUksU0FBUztBQUNULGlCQUFPLGFBQWEsS0FBSyxJQUFJLEVBQUU7QUFDbkMsWUFBSSxLQUFLLE1BQU07QUFDWCxpQkFBTztBQUNYLGVBQU8sSUFBSSxHQUFHUyxLQUFJLElBQUksR0FBRyxhQUFhLEtBQUssQ0FBQyxDQUFDLElBQUksRUFBRSxLQUFLO0FBQUEsTUFDM0Q7QUFDRCxVQUFJLFNBQVMsU0FBUyxDQUFDLEtBQUssTUFBTTtBQUM5QixlQUFPO0FBQ1gsYUFBTztBQUFBLElBQ1Y7QUFBQSxJQUNELGNBQWNMLFFBQU96RyxZQUFXO0FBQzVCLFVBQUk7QUFDSixXQUFLLFFBQVEsS0FBSyxLQUFLLFVBQVUsUUFBUSxPQUFPLFNBQVMsU0FBUyxHQUFHLGNBQWN5RyxRQUFPekcsVUFBUztBQUNuRyxVQUFJLEVBQUUsTUFBTSxjQUFjeUcsUUFBT3pHLFVBQVMsS0FBSyxLQUFLO0FBQ2hEO0FBQ0osV0FBSyxZQUFZLGFBQWEsS0FBSyxXQUFXeUcsUUFBT3pHLFVBQVM7QUFDOUQsYUFBTztBQUFBLElBQ1Y7QUFBQSxJQUNELElBQUksUUFBUTtBQUNSLFlBQU15RyxTQUFRLE1BQU07QUFDcEIsbUJBQWFBLFFBQU8sS0FBSyxTQUFTO0FBQ2xDLFVBQUksS0FBSztBQUNMLGlCQUFTQSxRQUFPLEtBQUssS0FBSyxLQUFLO0FBQ25DLGFBQU9BO0FBQUEsSUFDVjtBQUFBLEVBQ0o7QUFDRCxLQUFHLE9BQU87QUFBQSxFQUNWLE1BQU0sWUFBWSxVQUFVO0FBQUEsRUFDM0I7QUFDRCxNQUFJLE9BQU87QUFBQSxFQUNYLE1BQU0sZ0JBQWdCLElBQUk7QUFBQSxJQUN0QixZQUFZLFdBQVc7QUFDbkI7QUFDQSxXQUFLLFlBQVk7QUFBQSxJQUNwQjtBQUFBLElBQ0QsT0FBTyxNQUFNO0FBQ1QsYUFBTyxPQUFPLEtBQUssU0FBUyxNQUFNLE1BQU0sT0FBTyxJQUFJO0FBQUEsSUFDdEQ7QUFBQSxJQUNELGNBQWNBLFFBQU96RyxZQUFXO0FBQzVCLFVBQUksQ0FBQyxNQUFNLGNBQWN5RyxRQUFPekcsVUFBUztBQUNyQztBQUNKLFdBQUssWUFBWSxhQUFhLEtBQUssV0FBV3lHLFFBQU96RyxVQUFTO0FBQzlELGFBQU87QUFBQSxJQUNWO0FBQUEsSUFDRCxJQUFJLFFBQVE7QUFDUixhQUFPLFNBQVMsTUFBTSxPQUFPLEtBQUssVUFBVSxLQUFLO0FBQUEsSUFDcEQ7QUFBQSxFQUNKO0FBQUEsRUFDRCxNQUFNLGlCQUFpQixJQUFJO0FBQUEsSUFDdkIsWUFBWSxTQUFTLE1BQU0sTUFBTSxJQUFJO0FBQ2pDO0FBQ0EsV0FBSyxVQUFVO0FBQ2YsV0FBSyxPQUFPO0FBQ1osV0FBSyxPQUFPO0FBQ1osV0FBSyxLQUFLO0FBQUEsSUFDYjtBQUFBLElBQ0QsT0FBTyxNQUFNO0FBQ1QsWUFBTSxVQUFVLEtBQUssTUFBTSxRQUFRLFNBQVMsTUFBTSxLQUFLO0FBQ3ZELFlBQU0sRUFBRSxNQUFNLE1BQU0sR0FBRSxJQUFLO0FBQzNCLGFBQU8sT0FBTyxPQUFPLElBQUksSUFBSSxJQUFJLElBQUksS0FBSyxJQUFJLElBQUksRUFBRSxLQUFLLElBQUksUUFBUSxNQUFNLE9BQU8sSUFBSTtBQUFBLElBQ3pGO0FBQUEsSUFDRCxJQUFJLFFBQVE7QUFDUixZQUFNeUcsU0FBUSxhQUFhLE1BQU0sT0FBTyxLQUFLLElBQUk7QUFDakQsYUFBTyxhQUFhQSxRQUFPLEtBQUssRUFBRTtBQUFBLElBQ3JDO0FBQUEsRUFDSjtBQUFBLEVBQ0QsTUFBTSxnQkFBZ0IsSUFBSTtBQUFBLElBQ3RCLFlBQVksTUFBTSxTQUFTLE1BQU0sVUFBVTtBQUN2QztBQUNBLFdBQUssT0FBTztBQUNaLFdBQUssVUFBVTtBQUNmLFdBQUssT0FBTztBQUNaLFdBQUssV0FBVztBQUFBLElBQ25CO0FBQUEsSUFDRCxPQUFPLE1BQU07QUFDVCxhQUFPLE9BQU8sS0FBSyxPQUFPLElBQUksS0FBSyxJQUFJLElBQUksS0FBSyxJQUFJLElBQUksS0FBSyxRQUFRLE1BQU0sTUFBTSxPQUFPLElBQUk7QUFBQSxJQUMvRjtBQUFBLElBQ0QsY0FBY0EsUUFBT3pHLFlBQVc7QUFDNUIsVUFBSSxDQUFDLE1BQU0sY0FBY3lHLFFBQU96RyxVQUFTO0FBQ3JDO0FBQ0osV0FBSyxXQUFXLGFBQWEsS0FBSyxVQUFVeUcsUUFBT3pHLFVBQVM7QUFDNUQsYUFBTztBQUFBLElBQ1Y7QUFBQSxJQUNELElBQUksUUFBUTtBQUNSLGFBQU8sU0FBUyxNQUFNLE9BQU8sS0FBSyxTQUFTLEtBQUs7QUFBQSxJQUNuRDtBQUFBLEVBQ0o7QUFBQSxFQUNELE1BQU0sYUFBYSxVQUFVO0FBQUEsSUFDekIsWUFBWSxNQUFNLE1BQU0sT0FBTztBQUMzQjtBQUNBLFdBQUssT0FBTztBQUNaLFdBQUssT0FBTztBQUNaLFdBQUssUUFBUTtBQUFBLElBQ2hCO0FBQUEsSUFDRCxPQUFPLE1BQU07QUFDVCxZQUFNLFNBQVMsS0FBSyxRQUFRLFdBQVc7QUFDdkMsYUFBTyxHQUFHLE1BQU0sWUFBWSxLQUFLLElBQUksSUFBSSxLQUFLLElBQUksTUFBTSxNQUFNLE9BQU8sSUFBSTtBQUFBLElBQzVFO0FBQUEsRUFDSjtBQUNELE9BQUssT0FBTztBQUFBLEVBQ1osTUFBTSxlQUFlLFdBQVc7QUFBQSxJQUM1QixPQUFPLE1BQU07QUFDVCxhQUFPLFlBQVksTUFBTSxPQUFPLElBQUk7QUFBQSxJQUN2QztBQUFBLEVBQ0o7QUFDRCxTQUFPLE9BQU87QUFBQSxFQUNkLE1BQU0sWUFBWSxVQUFVO0FBQUEsSUFDeEIsT0FBTyxNQUFNO0FBQ1QsVUFBSXFHLFFBQU8sUUFBUSxNQUFNLE9BQU8sSUFBSTtBQUNwQyxVQUFJLEtBQUs7QUFDTCxRQUFBQSxTQUFRLEtBQUssTUFBTSxPQUFPLElBQUk7QUFDbEMsVUFBSSxLQUFLO0FBQ0wsUUFBQUEsU0FBUSxLQUFLLFFBQVEsT0FBTyxJQUFJO0FBQ3BDLGFBQU9BO0FBQUEsSUFDVjtBQUFBLElBQ0QsZ0JBQWdCO0FBQ1osVUFBSSxJQUFJO0FBQ1IsWUFBTSxjQUFhO0FBQ25CLE9BQUMsS0FBSyxLQUFLLFdBQVcsUUFBUSxPQUFPLFNBQVMsU0FBUyxHQUFHLGNBQWE7QUFDdkUsT0FBQyxLQUFLLEtBQUssYUFBYSxRQUFRLE9BQU8sU0FBUyxTQUFTLEdBQUcsY0FBYTtBQUN6RSxhQUFPO0FBQUEsSUFDVjtBQUFBLElBQ0QsY0FBY0ksUUFBT3pHLFlBQVc7QUFDNUIsVUFBSSxJQUFJO0FBQ1IsWUFBTSxjQUFjeUcsUUFBT3pHLFVBQVM7QUFDcEMsT0FBQyxLQUFLLEtBQUssV0FBVyxRQUFRLE9BQU8sU0FBUyxTQUFTLEdBQUcsY0FBY3lHLFFBQU96RyxVQUFTO0FBQ3hGLE9BQUMsS0FBSyxLQUFLLGFBQWEsUUFBUSxPQUFPLFNBQVMsU0FBUyxHQUFHLGNBQWN5RyxRQUFPekcsVUFBUztBQUMxRixhQUFPO0FBQUEsSUFDVjtBQUFBLElBQ0QsSUFBSSxRQUFRO0FBQ1IsWUFBTXlHLFNBQVEsTUFBTTtBQUNwQixVQUFJLEtBQUs7QUFDTCxpQkFBU0EsUUFBTyxLQUFLLE1BQU0sS0FBSztBQUNwQyxVQUFJLEtBQUs7QUFDTCxpQkFBU0EsUUFBTyxLQUFLLFFBQVEsS0FBSztBQUN0QyxhQUFPQTtBQUFBLElBQ1Y7QUFBQSxFQUNKO0FBQUEsRUFDRCxNQUFNLGNBQWMsVUFBVTtBQUFBLElBQzFCLFlBQVloSCxRQUFPO0FBQ2Y7QUFDQSxXQUFLLFFBQVFBO0FBQUEsSUFDaEI7QUFBQSxJQUNELE9BQU8sTUFBTTtBQUNULGFBQU8sU0FBUyxLQUFLLEtBQUssTUFBTSxNQUFNLE9BQU8sSUFBSTtBQUFBLElBQ3BEO0FBQUEsRUFDSjtBQUNELFFBQU0sT0FBTztBQUFBLEVBQ2IsTUFBTSxnQkFBZ0IsVUFBVTtBQUFBLElBQzVCLE9BQU8sTUFBTTtBQUNULGFBQU8sWUFBWSxNQUFNLE9BQU8sSUFBSTtBQUFBLElBQ3ZDO0FBQUEsRUFDSjtBQUNELFVBQVEsT0FBTztBQUFBLEVBQ2YsTUFBTSxRQUFRO0FBQUEsSUFDVixZQUFZLFVBQVUsT0FBTyxJQUFJO0FBQzdCLFdBQUssVUFBVTtBQUNmLFdBQUssZUFBZTtBQUNwQixXQUFLLGFBQWE7QUFDbEIsV0FBSyxPQUFPLEVBQUUsR0FBRyxNQUFNLElBQUksS0FBSyxRQUFRLE9BQU87QUFDL0MsV0FBSyxZQUFZO0FBQ2pCLFdBQUssU0FBUyxJQUFJLFFBQVEsTUFBTSxFQUFFLFFBQVEsU0FBUSxDQUFFO0FBQ3BELFdBQUssU0FBUyxDQUFDLElBQUksS0FBTSxDQUFBO0FBQUEsSUFDNUI7QUFBQSxJQUNELFdBQVc7QUFDUCxhQUFPLEtBQUssTUFBTSxPQUFPLEtBQUssSUFBSTtBQUFBLElBQ3JDO0FBQUE7QUFBQSxJQUVELEtBQUssUUFBUTtBQUNULGFBQU8sS0FBSyxPQUFPLEtBQUssTUFBTTtBQUFBLElBQ2pDO0FBQUE7QUFBQSxJQUVELFVBQVUsUUFBUTtBQUNkLGFBQU8sS0FBSyxVQUFVLEtBQUssTUFBTTtBQUFBLElBQ3BDO0FBQUE7QUFBQSxJQUVELFdBQVcsY0FBYyxPQUFPO0FBQzVCLFlBQU0sT0FBTyxLQUFLLFVBQVUsTUFBTSxjQUFjLEtBQUs7QUFDckQsWUFBTSxLQUFLLEtBQUssUUFBUSxLQUFLLE1BQU0sTUFBTSxLQUFLLFFBQVEsS0FBSyxNQUFNLElBQUksb0JBQUksSUFBSztBQUM5RSxTQUFHLElBQUksSUFBSTtBQUNYLGFBQU87QUFBQSxJQUNWO0FBQUEsSUFDRCxjQUFjLFFBQVEsVUFBVTtBQUM1QixhQUFPLEtBQUssVUFBVSxTQUFTLFFBQVEsUUFBUTtBQUFBLElBQ2xEO0FBQUE7QUFBQTtBQUFBLElBR0QsVUFBVSxXQUFXO0FBQ2pCLGFBQU8sS0FBSyxVQUFVLFVBQVUsV0FBVyxLQUFLLE9BQU87QUFBQSxJQUMxRDtBQUFBLElBQ0QsWUFBWTtBQUNSLGFBQU8sS0FBSyxVQUFVLFVBQVUsS0FBSyxPQUFPO0FBQUEsSUFDL0M7QUFBQSxJQUNELEtBQUssU0FBUyxjQUFjLEtBQUssVUFBVTtBQUN2QyxZQUFNLE9BQU8sS0FBSyxPQUFPLE9BQU8sWUFBWTtBQUM1QyxVQUFJLFFBQVEsVUFBYTtBQUNyQixhQUFLLFdBQVcsS0FBSyxHQUFHLElBQUk7QUFDaEMsV0FBSyxVQUFVLElBQUksSUFBSSxTQUFTLE1BQU0sR0FBRyxDQUFDO0FBQzFDLGFBQU87QUFBQSxJQUNWO0FBQUE7QUFBQSxJQUVELE1BQU0sY0FBYyxLQUFLLFdBQVc7QUFDaEMsYUFBTyxLQUFLLEtBQUssUUFBUSxTQUFTLE9BQU8sY0FBYyxLQUFLLFNBQVM7QUFBQSxJQUN4RTtBQUFBO0FBQUEsSUFFRCxJQUFJLGNBQWMsS0FBSyxXQUFXO0FBQzlCLGFBQU8sS0FBSyxLQUFLLFFBQVEsU0FBUyxLQUFLLGNBQWMsS0FBSyxTQUFTO0FBQUEsSUFDdEU7QUFBQTtBQUFBLElBRUQsSUFBSSxjQUFjLEtBQUssV0FBVztBQUM5QixhQUFPLEtBQUssS0FBSyxRQUFRLFNBQVMsS0FBSyxjQUFjLEtBQUssU0FBUztBQUFBLElBQ3RFO0FBQUE7QUFBQSxJQUVELE9BQU8sS0FBSyxLQUFLLGFBQWE7QUFDMUIsYUFBTyxLQUFLLFVBQVUsSUFBSSxPQUFPLEtBQUssS0FBSyxXQUFXLENBQUM7QUFBQSxJQUMxRDtBQUFBO0FBQUEsSUFFRCxJQUFJLEtBQUssS0FBSztBQUNWLGFBQU8sS0FBSyxVQUFVLElBQUksU0FBUyxLQUFLbUMsU0FBUSxVQUFVLEtBQUssR0FBRyxDQUFDO0FBQUEsSUFDdEU7QUFBQTtBQUFBLElBRUQsS0FBSyxHQUFHO0FBQ0osVUFBSSxPQUFPLEtBQUs7QUFDWjtlQUNLLE1BQU04RSxRQUFPO0FBQ2xCLGFBQUssVUFBVSxJQUFJLFFBQVEsQ0FBQyxDQUFDO0FBQ2pDLGFBQU87QUFBQSxJQUNWO0FBQUE7QUFBQSxJQUVELFVBQVUsV0FBVztBQUNqQixZQUFNTCxRQUFPLENBQUMsR0FBRztBQUNqQixpQkFBVyxDQUFDLEtBQUssS0FBSyxLQUFLLFdBQVc7QUFDbEMsWUFBSUEsTUFBSyxTQUFTO0FBQ2QsVUFBQUEsTUFBSyxLQUFLLEdBQUc7QUFDakIsUUFBQUEsTUFBSyxLQUFLLEdBQUc7QUFDYixZQUFJLFFBQVEsU0FBUyxLQUFLLEtBQUssS0FBSztBQUNoQyxVQUFBQSxNQUFLLEtBQUssR0FBRztBQUNiLFdBQUEsR0FBSUssUUFBTyxZQUFZTCxPQUFNLEtBQUs7QUFBQSxRQUNyQztBQUFBLE1BQ0o7QUFDRCxNQUFBQSxNQUFLLEtBQUssR0FBRztBQUNiLGFBQU8sSUFBSUssUUFBTyxNQUFNTCxLQUFJO0FBQUEsSUFDL0I7QUFBQTtBQUFBLElBRUQsR0FBRyxXQUFXLFVBQVUsVUFBVTtBQUM5QixXQUFLLFdBQVcsSUFBSSxHQUFHLFNBQVMsQ0FBQztBQUNqQyxVQUFJLFlBQVksVUFBVTtBQUN0QixhQUFLLEtBQUssUUFBUSxFQUFFLEtBQU0sRUFBQyxLQUFLLFFBQVEsRUFBRTtNQUM3QyxXQUNRLFVBQVU7QUFDZixhQUFLLEtBQUssUUFBUSxFQUFFLE1BQUs7QUFBQSxNQUM1QixXQUNRLFVBQVU7QUFDZixjQUFNLElBQUksTUFBTSwwQ0FBMEM7QUFBQSxNQUM3RDtBQUNELGFBQU87QUFBQSxJQUNWO0FBQUE7QUFBQSxJQUVELE9BQU8sV0FBVztBQUNkLGFBQU8sS0FBSyxVQUFVLElBQUksR0FBRyxTQUFTLENBQUM7QUFBQSxJQUMxQztBQUFBO0FBQUEsSUFFRCxPQUFPO0FBQ0gsYUFBTyxLQUFLLFVBQVUsSUFBSSxLQUFNLENBQUE7QUFBQSxJQUNuQztBQUFBO0FBQUEsSUFFRCxRQUFRO0FBQ0osYUFBTyxLQUFLLGNBQWMsSUFBSSxJQUFJO0FBQUEsSUFDckM7QUFBQSxJQUNELEtBQUssTUFBTSxTQUFTO0FBQ2hCLFdBQUssV0FBVyxJQUFJO0FBQ3BCLFVBQUk7QUFDQSxhQUFLLEtBQUssT0FBTyxFQUFFLE9BQU07QUFDN0IsYUFBTztBQUFBLElBQ1Y7QUFBQTtBQUFBLElBRUQsSUFBSSxXQUFXLFNBQVM7QUFDcEIsYUFBTyxLQUFLLEtBQUssSUFBSSxRQUFRLFNBQVMsR0FBRyxPQUFPO0FBQUEsSUFDbkQ7QUFBQTtBQUFBLElBRUQsU0FBUyxjQUFjLE1BQU0sSUFBSSxTQUFTLFVBQVUsS0FBSyxLQUFLLE1BQU0sUUFBUSxTQUFTLE1BQU0sUUFBUSxTQUFTLEtBQUs7QUFDN0csWUFBTSxPQUFPLEtBQUssT0FBTyxPQUFPLFlBQVk7QUFDNUMsYUFBTyxLQUFLLEtBQUssSUFBSSxTQUFTLFNBQVMsTUFBTSxNQUFNLEVBQUUsR0FBRyxNQUFNLFFBQVEsSUFBSSxDQUFDO0FBQUEsSUFDOUU7QUFBQTtBQUFBLElBRUQsTUFBTSxjQUFjLFVBQVUsU0FBUyxVQUFVLFFBQVEsU0FBUyxPQUFPO0FBQ3JFLFlBQU0sT0FBTyxLQUFLLE9BQU8sT0FBTyxZQUFZO0FBQzVDLFVBQUksS0FBSyxLQUFLLEtBQUs7QUFDZixjQUFNLE1BQU0sb0JBQW9CSyxRQUFPLE9BQU8sV0FBVyxLQUFLLElBQUksUUFBUSxRQUFRO0FBQ2xGLGVBQU8sS0FBSyxTQUFTLE1BQU0sSUFBTyxHQUFBQSxRQUFPLEtBQU0sR0FBRyxXQUFXLENBQUMsTUFBTTtBQUNoRSxlQUFLLElBQUksT0FBTSxHQUFJQSxRQUFPLEtBQU0sR0FBRyxJQUFJLENBQUMsR0FBRztBQUMzQyxrQkFBUSxJQUFJO0FBQUEsUUFDNUIsQ0FBYTtBQUFBLE1BQ0o7QUFDRCxhQUFPLEtBQUssS0FBSyxJQUFJLFFBQVEsTUFBTSxTQUFTLE1BQU0sUUFBUSxHQUFHLE1BQU0sUUFBUSxJQUFJLENBQUM7QUFBQSxJQUNuRjtBQUFBO0FBQUE7QUFBQSxJQUdELE1BQU0sY0FBYyxLQUFLLFNBQVMsVUFBVSxLQUFLLEtBQUssTUFBTSxRQUFRLFNBQVMsTUFBTSxRQUFRLFNBQVMsT0FBTztBQUN2RyxVQUFJLEtBQUssS0FBSyxlQUFlO0FBQ3pCLGVBQU8sS0FBSyxNQUFNLGVBQWtCLEdBQUFBLFFBQU8saUJBQWtCLEdBQUcsS0FBSyxPQUFPO0FBQUEsTUFDL0U7QUFDRCxZQUFNLE9BQU8sS0FBSyxPQUFPLE9BQU8sWUFBWTtBQUM1QyxhQUFPLEtBQUssS0FBSyxJQUFJLFFBQVEsTUFBTSxTQUFTLE1BQU0sR0FBRyxHQUFHLE1BQU0sUUFBUSxJQUFJLENBQUM7QUFBQSxJQUM5RTtBQUFBO0FBQUEsSUFFRCxTQUFTO0FBQ0wsYUFBTyxLQUFLLGNBQWMsR0FBRztBQUFBLElBQ2hDO0FBQUE7QUFBQSxJQUVELE1BQU0sT0FBTztBQUNULGFBQU8sS0FBSyxVQUFVLElBQUksTUFBTSxLQUFLLENBQUM7QUFBQSxJQUN6QztBQUFBO0FBQUEsSUFFRCxNQUFNLE9BQU87QUFDVCxhQUFPLEtBQUssVUFBVSxJQUFJLE1BQU0sS0FBSyxDQUFDO0FBQUEsSUFDekM7QUFBQTtBQUFBLElBRUQsT0FBTyxPQUFPO0FBQ1YsWUFBTSxPQUFPLElBQUk7QUFDakIsV0FBSyxXQUFXLElBQUk7QUFDcEIsV0FBSyxLQUFLLEtBQUs7QUFDZixVQUFJLEtBQUssTUFBTSxXQUFXO0FBQ3RCLGNBQU0sSUFBSSxNQUFNLHdDQUF3QztBQUM1RCxhQUFPLEtBQUssY0FBYyxNQUFNO0FBQUEsSUFDbkM7QUFBQTtBQUFBLElBRUQsSUFBSSxTQUFTLFdBQVcsYUFBYTtBQUNqQyxVQUFJLENBQUMsYUFBYSxDQUFDO0FBQ2YsY0FBTSxJQUFJLE1BQU0sOENBQThDO0FBQ2xFLFlBQU0sT0FBTyxJQUFJO0FBQ2pCLFdBQUssV0FBVyxJQUFJO0FBQ3BCLFdBQUssS0FBSyxPQUFPO0FBQ2pCLFVBQUksV0FBVztBQUNYLGNBQU1qSCxTQUFRLEtBQUssS0FBSyxHQUFHO0FBQzNCLGFBQUssWUFBWSxLQUFLLFFBQVEsSUFBSSxNQUFNQSxNQUFLO0FBQzdDLGtCQUFVQSxNQUFLO0FBQUEsTUFDbEI7QUFDRCxVQUFJLGFBQWE7QUFDYixhQUFLLFlBQVksS0FBSyxVQUFVLElBQUksUUFBTztBQUMzQyxhQUFLLEtBQUssV0FBVztBQUFBLE1BQ3hCO0FBQ0QsYUFBTyxLQUFLLGNBQWMsT0FBTyxPQUFPO0FBQUEsSUFDM0M7QUFBQTtBQUFBLElBRUQsTUFBTUEsUUFBTztBQUNULGFBQU8sS0FBSyxVQUFVLElBQUksTUFBTUEsTUFBSyxDQUFDO0FBQUEsSUFDekM7QUFBQTtBQUFBLElBRUQsTUFBTSxNQUFNLFdBQVc7QUFDbkIsV0FBSyxhQUFhLEtBQUssS0FBSyxPQUFPLE1BQU07QUFDekMsVUFBSTtBQUNBLGFBQUssS0FBSyxJQUFJLEVBQUUsU0FBUyxTQUFTO0FBQ3RDLGFBQU87QUFBQSxJQUNWO0FBQUE7QUFBQSxJQUVELFNBQVMsV0FBVztBQUNoQixZQUFNLE1BQU0sS0FBSyxhQUFhLElBQUc7QUFDakMsVUFBSSxRQUFRO0FBQ1IsY0FBTSxJQUFJLE1BQU0sc0NBQXNDO0FBQzFELFlBQU0sVUFBVSxLQUFLLE9BQU8sU0FBUztBQUNyQyxVQUFJLFVBQVUsS0FBTSxjQUFjLFVBQWEsWUFBWSxXQUFZO0FBQ25FLGNBQU0sSUFBSSxNQUFNLG1DQUFtQyxPQUFPLE9BQU8sU0FBUyxXQUFXO0FBQUEsTUFDeEY7QUFDRCxXQUFLLE9BQU8sU0FBUztBQUNyQixhQUFPO0FBQUEsSUFDVjtBQUFBO0FBQUEsSUFFRCxLQUFLLE1BQU0sT0FBT2lILFFBQU8sS0FBSyxPQUFPLFVBQVU7QUFDM0MsV0FBSyxXQUFXLElBQUksS0FBSyxNQUFNLE1BQU0sS0FBSyxDQUFDO0FBQzNDLFVBQUk7QUFDQSxhQUFLLEtBQUssUUFBUSxFQUFFLFFBQU87QUFDL0IsYUFBTztBQUFBLElBQ1Y7QUFBQTtBQUFBLElBRUQsVUFBVTtBQUNOLGFBQU8sS0FBSyxjQUFjLElBQUk7QUFBQSxJQUNqQztBQUFBLElBQ0QsU0FBUyxJQUFJLEdBQUc7QUFDWixhQUFPLE1BQU0sR0FBRztBQUNaLGFBQUssTUFBTTtBQUNYLGFBQUssTUFBTSxjQUFjLEtBQUssTUFBTSxPQUFPLEtBQUssVUFBVTtBQUFBLE1BQzdEO0FBQUEsSUFDSjtBQUFBLElBQ0QsVUFBVSxNQUFNO0FBQ1osV0FBSyxVQUFVLE1BQU0sS0FBSyxJQUFJO0FBQzlCLGFBQU87QUFBQSxJQUNWO0FBQUEsSUFDRCxXQUFXLE1BQU07QUFDYixXQUFLLFVBQVUsTUFBTSxLQUFLLElBQUk7QUFDOUIsV0FBSyxPQUFPLEtBQUssSUFBSTtBQUFBLElBQ3hCO0FBQUEsSUFDRCxjQUFjLElBQUksSUFBSTtBQUNsQixZQUFNLElBQUksS0FBSztBQUNmLFVBQUksYUFBYSxNQUFPLE1BQU0sYUFBYSxJQUFLO0FBQzVDLGFBQUssT0FBTztBQUNaLGVBQU87QUFBQSxNQUNWO0FBQ0QsWUFBTSxJQUFJLE1BQU0sMEJBQTBCLEtBQUssR0FBRyxHQUFHLElBQUksSUFBSSxHQUFHLElBQUksS0FBSyxHQUFHLElBQUksR0FBRztBQUFBLElBQ3RGO0FBQUEsSUFDRCxVQUFVLE1BQU07QUFDWixZQUFNLElBQUksS0FBSztBQUNmLFVBQUksRUFBRSxhQUFhLEtBQUs7QUFDcEIsY0FBTSxJQUFJLE1BQU0sOEJBQThCO0FBQUEsTUFDakQ7QUFDRCxXQUFLLFlBQVksRUFBRSxPQUFPO0FBQzFCLGFBQU87QUFBQSxJQUNWO0FBQUEsSUFDRCxJQUFJLFFBQVE7QUFDUixhQUFPLEtBQUssT0FBTyxDQUFDO0FBQUEsSUFDdkI7QUFBQSxJQUNELElBQUksWUFBWTtBQUNaLFlBQU0sS0FBSyxLQUFLO0FBQ2hCLGFBQU8sR0FBRyxHQUFHLFNBQVMsQ0FBQztBQUFBLElBQzFCO0FBQUEsSUFDRCxJQUFJLFVBQVUsTUFBTTtBQUNoQixZQUFNLEtBQUssS0FBSztBQUNoQixTQUFHLEdBQUcsU0FBUyxDQUFDLElBQUk7QUFBQSxJQUN2QjtBQUFBLEVBQ0o7QUFDRCxFQUFBOUUsU0FBQSxVQUFrQjtBQUNsQixXQUFTLFNBQVM2RSxRQUFPLE1BQU07QUFDM0IsZUFBVyxLQUFLO0FBQ1osTUFBQUEsT0FBTSxDQUFDLEtBQUtBLE9BQU0sQ0FBQyxLQUFLLE1BQU0sS0FBSyxDQUFDLEtBQUs7QUFDN0MsV0FBT0E7QUFBQSxFQUNWO0FBQ0QsV0FBUyxhQUFhQSxRQUFPLE1BQU07QUFDL0IsV0FBTyxnQkFBZ0JDLFFBQU8sY0FBYyxTQUFTRCxRQUFPLEtBQUssS0FBSyxJQUFJQTtBQUFBLEVBQzdFO0FBQ0QsV0FBUyxhQUFhLE1BQU1BLFFBQU96RyxZQUFXO0FBQzFDLFFBQUksZ0JBQWdCMEcsUUFBTztBQUN2QixhQUFPLFlBQVksSUFBSTtBQUMzQixRQUFJLENBQUMsWUFBWSxJQUFJO0FBQ2pCLGFBQU87QUFDWCxXQUFPLElBQUlBLFFBQU8sTUFBTSxLQUFLLE9BQU8sT0FBTyxDQUFDeEQsUUFBTyxNQUFNO0FBQ3JELFVBQUksYUFBYXdELFFBQU87QUFDcEIsWUFBSSxZQUFZLENBQUM7QUFDckIsVUFBSSxhQUFhQSxRQUFPO0FBQ3BCLFFBQUF4RCxPQUFNLEtBQUssR0FBRyxFQUFFLE1BQU07QUFBQTtBQUV0QixRQUFBQSxPQUFNLEtBQUssQ0FBQztBQUNoQixhQUFPQTtBQUFBLElBQ2YsR0FBTyxDQUFBLENBQUUsQ0FBQztBQUNOLGFBQVMsWUFBWSxHQUFHO0FBQ3BCLFlBQU0sSUFBSWxELFdBQVUsRUFBRSxHQUFHO0FBQ3pCLFVBQUksTUFBTSxVQUFheUcsT0FBTSxFQUFFLEdBQUcsTUFBTTtBQUNwQyxlQUFPO0FBQ1gsYUFBT0EsT0FBTSxFQUFFLEdBQUc7QUFDbEIsYUFBTztBQUFBLElBQ1Y7QUFDRCxhQUFTLFlBQVksR0FBRztBQUNwQixhQUFRLGFBQWFDLFFBQU8sU0FDeEIsRUFBRSxPQUFPLEtBQUssQ0FBQyxNQUFNLGFBQWFBLFFBQU8sUUFBUUQsT0FBTSxFQUFFLEdBQUcsTUFBTSxLQUFLekcsV0FBVSxFQUFFLEdBQUcsTUFBTSxNQUFTO0FBQUEsSUFDNUc7QUFBQSxFQUNKO0FBQ0QsV0FBUyxjQUFjeUcsUUFBTyxNQUFNO0FBQ2hDLGVBQVcsS0FBSztBQUNaLE1BQUFBLE9BQU0sQ0FBQyxLQUFLQSxPQUFNLENBQUMsS0FBSyxNQUFNLEtBQUssQ0FBQyxLQUFLO0FBQUEsRUFDaEQ7QUFDRCxXQUFTSyxLQUFJLEdBQUc7QUFDWixXQUFPLE9BQU8sS0FBSyxhQUFhLE9BQU8sS0FBSyxZQUFZLE1BQU0sT0FBTyxDQUFDLEtBQVEsR0FBQUosUUFBTyxNQUFPLElBQUksQ0FBQyxDQUFDO0FBQUEsRUFDckc7QUFDRCxFQUFBOUUsU0FBQSxNQUFja0Y7QUFDZCxRQUFNLFVBQVUsUUFBUWxGLFNBQVEsVUFBVSxHQUFHO0FBRTdDLFdBQVMsT0FBTyxNQUFNO0FBQ2xCLFdBQU8sS0FBSyxPQUFPLE9BQU87QUFBQSxFQUM3QjtBQUNELEVBQUFBLFNBQUEsTUFBYztBQUNkLFFBQU0sU0FBUyxRQUFRQSxTQUFRLFVBQVUsRUFBRTtBQUUzQyxXQUFTLE1BQU0sTUFBTTtBQUNqQixXQUFPLEtBQUssT0FBTyxNQUFNO0FBQUEsRUFDNUI7QUFDRCxFQUFBQSxTQUFBLEtBQWE7QUFDYixXQUFTLFFBQVEsSUFBSTtBQUNqQixXQUFPLENBQUMsR0FBRyxNQUFPLE1BQU04RSxRQUFPLE1BQU0sSUFBSSxNQUFNQSxRQUFPLE1BQU0sS0FBSSxHQUFJQSxRQUFPLEtBQU0sSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLElBQUksSUFBSSxDQUFDLENBQUM7QUFBQSxFQUMxRztBQUNELFdBQVMsSUFBSSxHQUFHO0FBQ1osV0FBTyxhQUFhQSxRQUFPLE9BQU8sS0FBSSxHQUFJQSxRQUFPLE1BQU8sQ0FBQztBQUFBLEVBQzVEOzs7O0FDdHJCRCxTQUFPLGVBQWM5RSxVQUFVLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUM1RCxFQUFBQSxTQUFBLGtCQUEwQkEsd0JBQXVCQSxTQUFlLE9BQUFBLFNBQUEsVUFBa0JBLHdCQUF1QkEsU0FBK0IsdUJBQUFBLFNBQUEsaUJBQXlCQSxvQkFBbUJBLFNBQThCLHNCQUFBQSxTQUFBLG9CQUE0QkEsMEJBQXlCQSxTQUEyQixtQkFBQUEsU0FBQSxpQkFBeUJBLGdDQUErQkEsU0FBeUIsaUJBQUFBLFNBQUEsb0JBQTRCQSw2QkFBNEJBLFNBQWlCLFNBQUE7QUFDNWIsUUFBTW1GLGFBQVlqSDtBQUNsQixRQUFNNEcsVUFBU3JIO0FBRWYsV0FBUyxPQUFPLEtBQUs7QUFDakIsVUFBTSxPQUFPLENBQUE7QUFDYixlQUFXLFFBQVE7QUFDZixXQUFLLElBQUksSUFBSTtBQUNqQixXQUFPO0FBQUEsRUFDVjtBQUNELEVBQUF1QyxTQUFBLFNBQWlCO0FBQ2pCLFdBQVMsa0JBQWtCLElBQUlvRixTQUFRO0FBQ25DLFFBQUksT0FBT0EsV0FBVTtBQUNqQixhQUFPQTtBQUNYLFFBQUksT0FBTyxLQUFLQSxPQUFNLEVBQUUsV0FBVztBQUMvQixhQUFPO0FBQ1gsc0JBQWtCLElBQUlBLE9BQU07QUFDNUIsV0FBTyxDQUFDLGVBQWVBLFNBQVEsR0FBRyxLQUFLLE1BQU0sR0FBRztBQUFBLEVBQ25EO0FBQ0QsRUFBQXBGLFNBQUEsb0JBQTRCO0FBQzVCLFdBQVMsa0JBQWtCLElBQUlvRixVQUFTLEdBQUcsUUFBUTtBQUMvQyxVQUFNLEVBQUUsTUFBTSxNQUFBckcsTUFBTSxJQUFHO0FBQ3ZCLFFBQUksQ0FBQyxLQUFLO0FBQ047QUFDSixRQUFJLE9BQU9xRyxZQUFXO0FBQ2xCO0FBQ0osVUFBTUMsU0FBUXRHLE1BQUssTUFBTTtBQUN6QixlQUFXLE9BQU9xRyxTQUFRO0FBQ3RCLFVBQUksQ0FBQ0MsT0FBTSxHQUFHO0FBQ1Ysd0JBQWdCLElBQUkscUJBQXFCLEdBQUcsR0FBRztBQUFBLElBQ3REO0FBQUEsRUFDSjtBQUNELEVBQUFyRixTQUFBLG9CQUE0QjtBQUM1QixXQUFTLGVBQWVvRixTQUFRQyxRQUFPO0FBQ25DLFFBQUksT0FBT0QsV0FBVTtBQUNqQixhQUFPLENBQUNBO0FBQ1osZUFBVyxPQUFPQTtBQUNkLFVBQUlDLE9BQU0sR0FBRztBQUNULGVBQU87QUFDZixXQUFPO0FBQUEsRUFDVjtBQUNELEVBQUFyRixTQUFBLGlCQUF5QjtBQUN6QixXQUFTLHFCQUFxQm9GLFNBQVEsT0FBTztBQUN6QyxRQUFJLE9BQU9BLFdBQVU7QUFDakIsYUFBTyxDQUFDQTtBQUNaLGVBQVcsT0FBT0E7QUFDZCxVQUFJLFFBQVEsVUFBVSxNQUFNLElBQUksR0FBRztBQUMvQixlQUFPO0FBQ2YsV0FBTztBQUFBLEVBQ1Y7QUFDRCxFQUFBcEYsU0FBQSx1QkFBK0I7QUFDL0IsV0FBUyxlQUFlLEVBQUUsY0FBYyxXQUFZLEdBQUVvRixTQUFRRSxVQUFTLE9BQU87QUFDMUUsUUFBSSxDQUFDLE9BQU87QUFDUixVQUFJLE9BQU9GLFdBQVUsWUFBWSxPQUFPQSxXQUFVO0FBQzlDLGVBQU9BO0FBQ1gsVUFBSSxPQUFPQSxXQUFVO0FBQ2pCLGdCQUFXLEdBQUFELFdBQVUsS0FBTUMsT0FBTTtBQUFBLElBQ3hDO0FBQ0QsZUFBV0QsV0FBVSxLQUFNLFlBQVksR0FBRyxVQUFVLElBQU8sR0FBQUEsV0FBVSxhQUFhRyxRQUFPLENBQUM7QUFBQSxFQUM3RjtBQUNELEVBQUF0RixTQUFBLGlCQUF5QjtBQUN6QixXQUFTLGlCQUFpQixLQUFLO0FBQzNCLFdBQU8sb0JBQW9CLG1CQUFtQixHQUFHLENBQUM7QUFBQSxFQUNyRDtBQUNELEVBQUFBLFNBQUEsbUJBQTJCO0FBQzNCLFdBQVMsZUFBZSxLQUFLO0FBQ3pCLFdBQU8sbUJBQW1CLGtCQUFrQixHQUFHLENBQUM7QUFBQSxFQUNuRDtBQUNELEVBQUFBLFNBQUEsaUJBQXlCO0FBQ3pCLFdBQVMsa0JBQWtCLEtBQUs7QUFDNUIsUUFBSSxPQUFPLE9BQU87QUFDZCxhQUFPLEdBQUcsR0FBRztBQUNqQixXQUFPLElBQUksUUFBUSxNQUFNLElBQUksRUFBRSxRQUFRLE9BQU8sSUFBSTtBQUFBLEVBQ3JEO0FBQ0QsRUFBQUEsU0FBQSxvQkFBNEI7QUFDNUIsV0FBUyxvQkFBb0IsS0FBSztBQUM5QixXQUFPLElBQUksUUFBUSxPQUFPLEdBQUcsRUFBRSxRQUFRLE9BQU8sR0FBRztBQUFBLEVBQ3BEO0FBQ0QsRUFBQUEsU0FBQSxzQkFBOEI7QUFDOUIsV0FBUyxTQUFTLElBQUksR0FBRztBQUNyQixRQUFJLE1BQU0sUUFBUSxFQUFFLEdBQUc7QUFDbkIsaUJBQVcsS0FBSztBQUNaLFVBQUUsQ0FBQztBQUFBLElBQ1YsT0FDSTtBQUNELFFBQUUsRUFBRTtBQUFBLElBQ1A7QUFBQSxFQUNKO0FBQ0QsRUFBQUEsU0FBQSxXQUFtQjtBQUNuQixXQUFTLG1CQUFtQixFQUFFLFlBQVksYUFBYSxhQUFhLGFBQVksR0FBSztBQUNqRixXQUFPLENBQUMsS0FBSyxNQUFNLElBQUksV0FBVztBQUM5QixZQUFNLE1BQU0sT0FBTyxTQUNiLE9BQ0EsY0FBY21GLFdBQVUsUUFDbkIsZ0JBQWdCQSxXQUFVLE9BQU8sV0FBVyxLQUFLLE1BQU0sRUFBRSxJQUFJLFlBQVksS0FBSyxNQUFNLEVBQUUsR0FBRyxNQUMxRixnQkFBZ0JBLFdBQVUsUUFDckIsWUFBWSxLQUFLLElBQUksSUFBSSxHQUFHLFFBQzdCLFlBQVksTUFBTSxFQUFFO0FBQ2xDLGFBQU8sV0FBV0EsV0FBVSxRQUFRLEVBQUUsZUFBZUEsV0FBVSxRQUFRLGFBQWEsS0FBSyxHQUFHLElBQUk7QUFBQSxJQUN4RztBQUFBLEVBQ0M7QUFDRCxFQUFBbkYsU0FBeUIsaUJBQUE7QUFBQSxJQUNyQixPQUFPLG1CQUFtQjtBQUFBLE1BQ3RCLFlBQVksQ0FBQyxLQUFLLE1BQU0sT0FBTyxJQUFJLElBQUcsR0FBSW1GLFdBQVUsS0FBTSxFQUFFLGdCQUFnQixJQUFJLGtCQUFrQixNQUFNO0FBQ3BHLFlBQUksSUFBTyxHQUFBQSxXQUFVLEtBQU0sSUFBSSxhQUFhLE1BQU0sSUFBSSxPQUFPLElBQUksSUFBSSxHQUFHLE1BQU0sSUFBSSxPQUFPLEtBQVEsR0FBQUEsV0FBVSxLQUFNLEVBQUUsUUFBUSxFQUFFLE1BQVMsR0FBQUEsV0FBVSxtQkFBb0IsRUFBRSxLQUFLLElBQUksR0FBRyxDQUFDO0FBQUEsTUFDL0wsQ0FBUztBQUFBLE1BQ0QsYUFBYSxDQUFDLEtBQUssTUFBTSxPQUFPLElBQUksSUFBTyxHQUFBQSxXQUFVLEtBQU0sRUFBRSxhQUFhLE1BQU07QUFDNUUsWUFBSSxTQUFTLE1BQU07QUFDZixjQUFJLE9BQU8sSUFBSSxJQUFJO0FBQUEsUUFDdEIsT0FDSTtBQUNELGNBQUksT0FBTyxRQUFRQSxXQUFVLEtBQU0sRUFBRSxRQUFRO0FBQzdDLHVCQUFhLEtBQUssSUFBSSxJQUFJO0FBQUEsUUFDN0I7QUFBQSxNQUNiLENBQVM7QUFBQSxNQUNELGFBQWEsQ0FBQyxNQUFNLE9BQVEsU0FBUyxPQUFPLE9BQU8sRUFBRSxHQUFHLE1BQU0sR0FBRztNQUNqRSxjQUFjO0FBQUEsSUFDdEIsQ0FBSztBQUFBLElBQ0QsT0FBTyxtQkFBbUI7QUFBQSxNQUN0QixZQUFZLENBQUMsS0FBSyxNQUFNLE9BQU8sSUFBSSxJQUFHLEdBQUlBLFdBQVUsS0FBTSxFQUFFLGdCQUFnQixJQUFJLGtCQUFrQixNQUFNLElBQUksT0FBTyxLQUFJLEdBQUlBLFdBQVUsS0FBTSxJQUFJLHNCQUFzQixFQUFFLE1BQU0sSUFBSSxNQUFNLEVBQUUsTUFBTSxJQUFJLEVBQUUsQ0FBQztBQUFBLE1BQ3RNLGFBQWEsQ0FBQyxLQUFLLE1BQU0sT0FBTyxJQUFJLElBQUcsR0FBSUEsV0FBVSxLQUFNLEVBQUUsYUFBYSxNQUFNLElBQUksT0FBTyxJQUFJLFNBQVMsT0FBTyxRQUFXLEdBQUFBLFdBQVUsS0FBTSxFQUFFLE1BQU0sSUFBSSxNQUFNLEVBQUUsTUFBTSxJQUFJLEVBQUUsQ0FBQztBQUFBLE1BQzNLLGFBQWEsQ0FBQyxNQUFNLE9BQVEsU0FBUyxPQUFPLE9BQU8sS0FBSyxJQUFJLE1BQU0sRUFBRTtBQUFBLE1BQ3BFLGNBQWMsQ0FBQyxLQUFLN0QsV0FBVSxJQUFJLElBQUksU0FBU0EsTUFBSztBQUFBLElBQzVELENBQUs7QUFBQSxFQUNMO0FBQ0EsV0FBUyxxQkFBcUIsS0FBSyxJQUFJO0FBQ25DLFFBQUksT0FBTztBQUNQLGFBQU8sSUFBSSxJQUFJLFNBQVMsSUFBSTtBQUNoQyxVQUFNLFFBQVEsSUFBSSxJQUFJLFVBQWEsR0FBQTZELFdBQVUsTUFBTztBQUNwRCxRQUFJLE9BQU87QUFDUCxtQkFBYSxLQUFLLE9BQU8sRUFBRTtBQUMvQixXQUFPO0FBQUEsRUFDVjtBQUNELEVBQUFuRixTQUFBLHVCQUErQjtBQUMvQixXQUFTLGFBQWEsS0FBSyxPQUFPLElBQUk7QUFDbEMsV0FBTyxLQUFLLEVBQUUsRUFBRSxRQUFRLENBQUMsTUFBTSxJQUFJLFdBQVdtRixXQUFVLEtBQU0sS0FBSyxJQUFHLEdBQUlBLFdBQVUsYUFBYSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUM7QUFBQSxFQUMvRztBQUNELEVBQUFuRixTQUFBLGVBQXVCO0FBQ3ZCLFFBQU0sV0FBVyxDQUFBO0FBQ2pCLFdBQVMsUUFBUSxLQUFLLEdBQUc7QUFDckIsV0FBTyxJQUFJLFdBQVcsUUFBUTtBQUFBLE1BQzFCLEtBQUs7QUFBQSxNQUNMLE1BQU0sU0FBUyxFQUFFLElBQUksTUFBTSxTQUFTLEVBQUUsSUFBSSxJQUFJLElBQUk4RSxRQUFPLE1BQU0sRUFBRSxJQUFJO0FBQUEsSUFDN0UsQ0FBSztBQUFBLEVBQ0o7QUFDRCxFQUFBOUUsU0FBQSxVQUFrQjtBQUNsQixNQUFJO0FBQ0osR0FBQyxTQUFVdUYsT0FBTTtBQUNiLElBQUFBLE1BQUtBLE1BQUssS0FBSyxJQUFJLENBQUMsSUFBSTtBQUN4QixJQUFBQSxNQUFLQSxNQUFLLEtBQUssSUFBSSxDQUFDLElBQUk7QUFBQSxLQUN6QixPQUFPdkYsU0FBUSxTQUFTQSxTQUFlLE9BQUEsQ0FBRSxFQUFDO0FBQzdDLFdBQVMsYUFBYSxVQUFVLGNBQWMsa0JBQWtCO0FBRTVELFFBQUksb0JBQW9CbUYsV0FBVSxNQUFNO0FBQ3BDLFlBQU0sV0FBVyxpQkFBaUIsS0FBSztBQUN2QyxhQUFPLG1CQUNELFlBQ0ksR0FBSUEsV0FBVSxXQUFZLFFBQVEsWUFDbEMsR0FBSUEsV0FBVSxZQUFhLFFBQVEsWUFDdkMsWUFDSSxHQUFJQSxXQUFVLFdBQVksUUFBUSxNQUM5QixHQUFBQSxXQUFVLFdBQVksUUFBUTtBQUFBLElBQy9DO0FBQ0QsV0FBTyxvQkFBbUIsR0FBSUEsV0FBVSxhQUFhLFFBQVEsRUFBRSxTQUFRLElBQUssTUFBTSxrQkFBa0IsUUFBUTtBQUFBLEVBQy9HO0FBQ0QsRUFBQW5GLFNBQUEsZUFBdUI7QUFDdkIsV0FBUyxnQkFBZ0IsSUFBSSxLQUFLLE9BQU8sR0FBRyxLQUFLLGNBQWM7QUFDM0QsUUFBSSxDQUFDO0FBQ0Q7QUFDSixVQUFNLGdCQUFnQixHQUFHO0FBQ3pCLFFBQUksU0FBUztBQUNULFlBQU0sSUFBSSxNQUFNLEdBQUc7QUFDdkIsT0FBRyxLQUFLLE9BQU8sS0FBSyxHQUFHO0FBQUEsRUFDMUI7QUFDRCxFQUFBQSxTQUFBLGtCQUEwQjs7O0FDL0sxQixPQUFPLGVBQWV3RixTQUFTLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUM1RCxNQUFNTCxjQUFZakg7QUFDbEIsTUFBTSxRQUFRO0FBQUE7QUFBQSxFQUVWLE1BQU0sSUFBSWlILFlBQVUsS0FBSyxNQUFNO0FBQUE7QUFBQSxFQUUvQixRQUFRLElBQUlBLFlBQVUsS0FBSyxRQUFRO0FBQUEsRUFDbkMsY0FBYyxJQUFJQSxZQUFVLEtBQUssY0FBYztBQUFBLEVBQy9DLFlBQVksSUFBSUEsWUFBVSxLQUFLLFlBQVk7QUFBQSxFQUMzQyxvQkFBb0IsSUFBSUEsWUFBVSxLQUFLLG9CQUFvQjtBQUFBLEVBQzNELFVBQVUsSUFBSUEsWUFBVSxLQUFLLFVBQVU7QUFBQSxFQUN2QyxnQkFBZ0IsSUFBSUEsWUFBVSxLQUFLLGdCQUFnQjtBQUFBO0FBQUEsRUFFbkQsU0FBUyxJQUFJQSxZQUFVLEtBQUssU0FBUztBQUFBLEVBQ3JDLFFBQVEsSUFBSUEsWUFBVSxLQUFLLFFBQVE7QUFBQSxFQUNuQyxNQUFNLElBQUlBLFlBQVUsS0FBSyxNQUFNO0FBQUE7QUFBQSxFQUUvQixNQUFNLElBQUlBLFlBQVUsS0FBSyxNQUFNO0FBQUEsRUFDL0IsT0FBTyxJQUFJQSxZQUFVLEtBQUssT0FBTztBQUFBO0FBQUEsRUFFakMsTUFBTSxJQUFJQSxZQUFVLEtBQUssTUFBTTtBQUFBLEVBQy9CLFNBQVMsSUFBSUEsWUFBVSxLQUFLLFNBQVM7QUFBQSxFQUNyQyxTQUFTLElBQUlBLFlBQVUsS0FBSyxTQUFTO0FBQUEsRUFDckMsVUFBVSxJQUFJQSxZQUFVLEtBQUssVUFBVTtBQUMzQztBQUNlSyxRQUFBLFVBQUc7QUFBQTtBQ3pCbEIsU0FBTyxlQUFjeEYsVUFBVSxjQUFjLEVBQUUsT0FBTyxLQUFJLENBQUU7QUFDNUQsRUFBQUEsU0FBQSxlQUF1QkEsNEJBQTJCQSxTQUEyQixtQkFBQUEsU0FBQSxjQUFzQkEsNkJBQTRCQSxTQUF1QixlQUFBO0FBQ3RKLFFBQU1tRixhQUFZakg7QUFDbEIsUUFBTXlHLFVBQVNsSDtBQUNmLFFBQU0rSCxXQUFVOUg7QUFDaEIsRUFBQXNDLFNBQXVCLGVBQUE7QUFBQSxJQUNuQixTQUFTLENBQUMsRUFBRSxTQUFBc0YsU0FBTyxPQUFXLEdBQUFILFdBQVUsa0JBQW1CRyxRQUFPO0FBQUEsRUFDdEU7QUFDQSxFQUFBdEYsU0FBNEIsb0JBQUE7QUFBQSxJQUN4QixTQUFTLENBQUMsRUFBRSxTQUFBc0YsVUFBUyxXQUFZLE1BQUssY0FDNUIsR0FBQUgsV0FBVSxRQUFTRyxRQUFPLHFCQUFxQixVQUFVLGNBQzdELEdBQUlILFdBQVUsUUFBU0csUUFBTztBQUFBLEVBQ3hDO0FBQ0EsV0FBUyxZQUFZLEtBQUt6SCxTQUFRbUMsU0FBUSxjQUFjLFlBQVksbUJBQW1CO0FBQ25GLFVBQU0sRUFBRSxHQUFJLElBQUc7QUFDZixVQUFNLEVBQUUsS0FBSyxlQUFlLFVBQVMsSUFBSztBQUMxQyxVQUFNLFNBQVMsZ0JBQWdCLEtBQUtuQyxRQUFPLFVBQVU7QUFDckQsUUFBSSxzQkFBc0IsUUFBUSxzQkFBc0IsU0FBUyxvQkFBcUIsaUJBQWlCLFdBQVk7QUFDL0csZUFBUyxLQUFLLE1BQU07QUFBQSxJQUN2QixPQUNJO0FBQ0QsbUJBQWEsS0FBSSxHQUFJc0gsV0FBVSxNQUFPLE1BQU0sR0FBRztBQUFBLElBQ2xEO0FBQUEsRUFDSjtBQUNELEVBQUFuRixTQUFBLGNBQXNCO0FBQ3RCLFdBQVMsaUJBQWlCLEtBQUtuQyxTQUFRbUMsU0FBUSxjQUFjLFlBQVk7QUFDckUsVUFBTSxFQUFFLEdBQUksSUFBRztBQUNmLFVBQU0sRUFBRSxLQUFLLGVBQWUsVUFBUyxJQUFLO0FBQzFDLFVBQU0sU0FBUyxnQkFBZ0IsS0FBS25DLFFBQU8sVUFBVTtBQUNyRCxhQUFTLEtBQUssTUFBTTtBQUNwQixRQUFJLEVBQUUsaUJBQWlCLFlBQVk7QUFDL0IsbUJBQWEsSUFBSTJILFNBQVEsUUFBUSxPQUFPO0FBQUEsSUFDM0M7QUFBQSxFQUNKO0FBQ0QsRUFBQXhGLFNBQUEsbUJBQTJCO0FBQzNCLFdBQVMsaUJBQWlCLEtBQUssV0FBVztBQUN0QyxRQUFJLE9BQU93RixTQUFRLFFBQVEsUUFBUSxTQUFTO0FBQzVDLFFBQUksSUFBTyxHQUFBTCxXQUFVLEtBQU1LLFNBQVEsUUFBUSxPQUFPLGFBQWEsTUFBTSxJQUFJLEdBQUcsV0FBVyxNQUFNLElBQUksUUFBTyxHQUFJTCxXQUFVLEtBQU1LLFNBQVEsUUFBUSxPQUFPLFdBQVcsU0FBUyxHQUFHLE1BQU0sSUFBSSxPQUFPQSxTQUFRLFFBQVEsU0FBUyxJQUFJLENBQUMsQ0FBQztBQUFBLEVBQzdOO0FBQ0QsRUFBQXhGLFNBQUEsbUJBQTJCO0FBQzNCLFdBQVMsYUFBYSxFQUFFLEtBQUssU0FBQXNGLFVBQVMsYUFBYSxNQUFNLFdBQVcsTUFBTztBQUV2RSxRQUFJLGNBQWM7QUFDZCxZQUFNLElBQUksTUFBTSwwQkFBMEI7QUFDOUMsVUFBTSxNQUFNLElBQUksS0FBSyxLQUFLO0FBQzFCLFFBQUksU0FBUyxLQUFLLFdBQVdFLFNBQVEsUUFBUSxRQUFRLENBQUMsTUFBTTtBQUN4RCxVQUFJLE1BQU0sTUFBSyxHQUFJTCxXQUFVLEtBQU1LLFNBQVEsUUFBUSxPQUFPLElBQUksQ0FBQyxHQUFHO0FBQ2xFLFVBQUksT0FBT0wsV0FBVSxLQUFNLEdBQUcsK0JBQStCLE1BQU0sSUFBSSxRQUFXLEdBQUFBLFdBQVUsS0FBTSxHQUFHLGtCQUFpQixHQUFJQSxXQUFVLFdBQVdLLFNBQVEsUUFBUSxjQUFjLEdBQUcsU0FBUyxDQUFDLENBQUM7QUFDM0wsVUFBSSxXQUFXTCxXQUFVLEtBQU0sR0FBRyxnQkFBbUIsR0FBQUEsV0FBVSxPQUFRLEdBQUcsYUFBYSxJQUFJRyxRQUFPLEVBQUU7QUFDcEcsVUFBSSxHQUFHLEtBQUssU0FBUztBQUNqQixZQUFJLFFBQVcsR0FBQUgsV0FBVSxLQUFNLEdBQUcsV0FBVyxXQUFXO0FBQ3hELFlBQUksUUFBVyxHQUFBQSxXQUFVLEtBQU0sR0FBRyxTQUFTLElBQUk7QUFBQSxNQUNsRDtBQUFBLElBQ1QsQ0FBSztBQUFBLEVBQ0o7QUFDRCxFQUFBbkYsU0FBQSxlQUF1QjtBQUN2QixXQUFTLFNBQVMsS0FBSyxRQUFRO0FBQzNCLFVBQU0sTUFBTSxJQUFJLE1BQU0sT0FBTyxNQUFNO0FBQ25DLFFBQUksSUFBTyxHQUFBbUYsV0FBVSxLQUFNSyxTQUFRLFFBQVEsT0FBTyxhQUFhLE1BQU0sSUFBSSxPQUFPQSxTQUFRLFFBQVEsVUFBUyxHQUFJTCxXQUFVLE1BQU8sR0FBRyxHQUFHLElBQUcsR0FBSUEsV0FBVSxLQUFNSyxTQUFRLFFBQVEsT0FBTyxTQUFTLEdBQUcsR0FBRztBQUNqTSxRQUFJLFNBQVNMLFdBQVUsS0FBTUssU0FBUSxRQUFRLE1BQU0sSUFBSTtBQUFBLEVBQzFEO0FBQ0QsV0FBUyxhQUFhLElBQUksTUFBTTtBQUM1QixVQUFNLEVBQUUsS0FBSyxjQUFjLFVBQVMsSUFBSztBQUN6QyxRQUFJLFVBQVUsUUFBUTtBQUNsQixVQUFJLFVBQVVMLFdBQVUsU0FBVSxHQUFHLGVBQWUsSUFBSSxJQUFJLEdBQUc7QUFBQSxJQUNsRSxPQUNJO0FBQ0QsVUFBSSxRQUFXLEdBQUFBLFdBQVUsS0FBTSxZQUFZLFdBQVcsSUFBSTtBQUMxRCxVQUFJLE9BQU8sS0FBSztBQUFBLElBQ25CO0FBQUEsRUFDSjtBQUNELFFBQU0sSUFBSTtBQUFBLElBQ04sU0FBUyxJQUFJQSxXQUFVLEtBQUssU0FBUztBQUFBLElBQ3JDLFlBQVksSUFBSUEsV0FBVSxLQUFLLFlBQVk7QUFBQSxJQUMzQyxRQUFRLElBQUlBLFdBQVUsS0FBSyxRQUFRO0FBQUEsSUFDbkMsY0FBYyxJQUFJQSxXQUFVLEtBQUssY0FBYztBQUFBLElBQy9DLFNBQVMsSUFBSUEsV0FBVSxLQUFLLFNBQVM7QUFBQSxJQUNyQyxRQUFRLElBQUlBLFdBQVUsS0FBSyxRQUFRO0FBQUEsSUFDbkMsY0FBYyxJQUFJQSxXQUFVLEtBQUssY0FBYztBQUFBLEVBQ25EO0FBQ0EsV0FBUyxnQkFBZ0IsS0FBS3RILFFBQU8sWUFBWTtBQUM3QyxVQUFNLEVBQUUsYUFBWSxJQUFLLElBQUk7QUFDN0IsUUFBSSxpQkFBaUI7QUFDakIsaUJBQVdzSCxXQUFVO0FBQ3pCLFdBQU8sWUFBWSxLQUFLdEgsUUFBTyxVQUFVO0FBQUEsRUFDNUM7QUFDRCxXQUFTLFlBQVksS0FBS0EsUUFBTyxhQUFhLENBQUEsR0FBSTtBQUM5QyxVQUFNLEVBQUUsS0FBSyxHQUFJLElBQUc7QUFDcEIsVUFBTSxZQUFZO0FBQUEsTUFDZCxrQkFBa0IsSUFBSSxVQUFVO0FBQUEsTUFDaEMsZ0JBQWdCLEtBQUssVUFBVTtBQUFBLElBQ3ZDO0FBQ0ksb0JBQWdCLEtBQUtBLFFBQU8sU0FBUztBQUNyQyxXQUFPLElBQUksT0FBTyxHQUFHLFNBQVM7QUFBQSxFQUNqQztBQUNELFdBQVMsa0JBQWtCLEVBQUUsYUFBYSxFQUFFLGFBQVksR0FBSTtBQUN4RCxVQUFNLFdBQVcsZ0JBQ1gsR0FBSXNILFdBQVUsT0FBUSxTQUFTLElBQU8sR0FBQVIsUUFBTyxjQUFjLGNBQWNBLFFBQU8sS0FBSyxHQUFHLENBQUMsS0FDekY7QUFDTixXQUFPLENBQUNhLFNBQVEsUUFBUSxlQUFjLEdBQUlMLFdBQVUsV0FBV0ssU0FBUSxRQUFRLGNBQWMsUUFBUSxDQUFDO0FBQUEsRUFDekc7QUFDRCxXQUFTLGdCQUFnQixFQUFFLFNBQUFGLFVBQVMsSUFBSSxFQUFFLGNBQWEsS0FBTSxFQUFFLFlBQVksZ0JBQWdCO0FBQ3ZGLFFBQUksVUFBVSxlQUFlLG9CQUFvQkgsV0FBVSxPQUFRLGFBQWEsSUFBSUcsUUFBTztBQUMzRixRQUFJLFlBQVk7QUFDWixpQkFBVSxHQUFJSCxXQUFVLE9BQVEsT0FBTyxJQUFHLEdBQUlSLFFBQU8sY0FBYyxZQUFZQSxRQUFPLEtBQUssR0FBRyxDQUFDO0FBQUEsSUFDbEc7QUFDRCxXQUFPLENBQUMsRUFBRSxZQUFZLE9BQU87QUFBQSxFQUNoQztBQUNELFdBQVMsZ0JBQWdCLEtBQUssRUFBRSxRQUFRLFFBQU8sR0FBSSxXQUFXO0FBQzFELFVBQU0sRUFBRSxTQUFBVyxVQUFTLE1BQU0sYUFBYSxHQUFFLElBQUs7QUFDM0MsVUFBTSxFQUFFLE1BQU0sY0FBYyxjQUFjLFdBQVUsSUFBSztBQUN6RCxjQUFVLEtBQUssQ0FBQyxFQUFFLFNBQVNBLFFBQU8sR0FBRyxDQUFDLEVBQUUsUUFBUSxPQUFPLFVBQVUsYUFBYSxPQUFPLEdBQUcsSUFBSSxXQUFVLEdBQUlILFdBQVUsTUFBTyxDQUFDO0FBQzVILFFBQUksS0FBSyxVQUFVO0FBQ2YsZ0JBQVUsS0FBSyxDQUFDLEVBQUUsU0FBUyxPQUFPLFdBQVcsYUFBYSxRQUFRLEdBQUcsSUFBSSxPQUFPLENBQUM7QUFBQSxJQUNwRjtBQUNELFFBQUksS0FBSyxTQUFTO0FBQ2QsZ0JBQVUsS0FBSyxDQUFDLEVBQUUsUUFBUSxXQUFXLEdBQUcsQ0FBQyxFQUFFLGVBQWMsR0FBSUEsV0FBVSxLQUFNLFlBQVksR0FBRyxVQUFVLEVBQUUsR0FBRyxDQUFDSyxTQUFRLFFBQVEsTUFBTSxJQUFJLENBQUM7QUFBQSxJQUMxSTtBQUNELFFBQUk7QUFDQSxnQkFBVSxLQUFLLENBQUMsRUFBRSxjQUFjLFlBQVksQ0FBQztBQUFBLEVBQ3BEOztBQ3hIRCxPQUFPLGVBQWUsWUFBUyxjQUFjLEVBQUUsT0FBTyxLQUFJLENBQUU7QUFDNUQsV0FBQSxvQkFBNEIsV0FBQSx1QkFBK0I7QUFDM0QsTUFBTUMsYUFBV3ZIO0FBQ2pCLE1BQU1pSCxjQUFZMUg7QUFDbEIsTUFBTStILFlBQVU5SDtBQUNoQixNQUFNLFlBQVk7QUFBQSxFQUNkLFNBQVM7QUFDYjtBQUNBLFNBQVMscUJBQXFCLElBQUk7QUFDOUIsUUFBTSxFQUFFLEtBQUssUUFBQTBILFNBQVEsYUFBWSxJQUFLO0FBQ3RDLE1BQUlBLFlBQVcsT0FBTztBQUNsQixxQkFBaUIsSUFBSSxLQUFLO0FBQUEsRUFDN0IsV0FDUSxPQUFPQSxXQUFVLFlBQVlBLFFBQU8sV0FBVyxNQUFNO0FBQzFELFFBQUksT0FBT0ksVUFBUSxRQUFRLElBQUk7QUFBQSxFQUNsQyxPQUNJO0FBQ0QsUUFBSSxRQUFXTCxHQUFBQSxZQUFVLEtBQU0sWUFBWSxXQUFXLElBQUk7QUFDMUQsUUFBSSxPQUFPLElBQUk7QUFBQSxFQUNsQjtBQUNMO0FBQzRCLFdBQUEsdUJBQUc7QUFDL0IsU0FBUyxrQkFBa0IsSUFBSU8sUUFBTztBQUNsQyxRQUFNLEVBQUUsS0FBSyxRQUFBTixRQUFRLElBQUc7QUFDeEIsTUFBSUEsWUFBVyxPQUFPO0FBQ2xCLFFBQUksSUFBSU0sUUFBTyxLQUFLO0FBQ3BCLHFCQUFpQixFQUFFO0FBQUEsRUFDdEIsT0FDSTtBQUNELFFBQUksSUFBSUEsUUFBTyxJQUFJO0FBQUEsRUFDdEI7QUFDTDtBQUN5QixXQUFBLG9CQUFHO0FBQzVCLFNBQVMsaUJBQWlCLElBQUksbUJBQW1CO0FBQzdDLFFBQU0sRUFBRSxLQUFLLEtBQU0sSUFBRztBQUV0QixRQUFNLE1BQU07QUFBQSxJQUNSO0FBQUEsSUFDQSxTQUFTO0FBQUEsSUFDVDtBQUFBLElBQ0EsUUFBUTtBQUFBLElBQ1IsWUFBWTtBQUFBLElBQ1osYUFBYTtBQUFBLElBQ2IsUUFBUSxDQUFFO0FBQUEsSUFDVjtBQUFBLEVBQ1I7QUFDSSxHQUFJRCxHQUFBQSxXQUFTLGFBQWEsS0FBSyxXQUFXLFFBQVcsaUJBQWlCO0FBQzFFOzs7QUMvQ0EsT0FBTyxlQUFlLE9BQVMsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQzVELE1BQUEsV0FBbUIsTUFBQSxhQUFxQjtBQUN4QyxNQUFNLGFBQWEsQ0FBQyxVQUFVLFVBQVUsV0FBVyxXQUFXLFFBQVEsVUFBVSxPQUFPO0FBQ3ZGLE1BQU0sWUFBWSxJQUFJLElBQUksVUFBVTtBQUNwQyxTQUFTLFdBQVcsR0FBRztBQUNuQixTQUFPLE9BQU8sS0FBSyxZQUFZLFVBQVUsSUFBSSxDQUFDO0FBQ2xEO0FBQ2tCLE1BQUEsYUFBRztBQUNyQixTQUFTLFdBQVc7QUFDaEIsUUFBTSxTQUFTO0FBQUEsSUFDWCxRQUFRLEVBQUUsTUFBTSxVQUFVLE9BQU8sQ0FBQSxFQUFJO0FBQUEsSUFDckMsUUFBUSxFQUFFLE1BQU0sVUFBVSxPQUFPLENBQUEsRUFBSTtBQUFBLElBQ3JDLE9BQU8sRUFBRSxNQUFNLFNBQVMsT0FBTyxDQUFBLEVBQUk7QUFBQSxJQUNuQyxRQUFRLEVBQUUsTUFBTSxVQUFVLE9BQU8sQ0FBQSxFQUFJO0FBQUEsRUFDN0M7QUFDSSxTQUFPO0FBQUEsSUFDSCxPQUFPLEVBQUUsR0FBRyxRQUFRLFNBQVMsTUFBTSxTQUFTLE1BQU0sTUFBTSxLQUFNO0FBQUEsSUFDOUQsT0FBTyxDQUFDLEVBQUUsT0FBTyxDQUFFLEVBQUEsR0FBSSxPQUFPLFFBQVEsT0FBTyxRQUFRLE9BQU8sT0FBTyxPQUFPLE1BQU07QUFBQSxJQUNoRixNQUFNLEVBQUUsT0FBTyxHQUFJO0FBQUEsSUFDbkIsS0FBSyxDQUFFO0FBQUEsSUFDUCxVQUFVLENBQUU7QUFBQSxFQUNwQjtBQUNBO0FBQ2dCLE1BQUEsV0FBRzs7QUN2Qm5CLE9BQU8sZUFBZSxlQUFTLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUM1RCxjQUFBLGdCQUE4QyxjQUFBLHVEQUFtQztBQUNqRixTQUFTLHNCQUFzQixFQUFFLFFBQUFMLFNBQVEsTUFBQXJHLE1BQUksR0FBSXVELE9BQU07QUFDbkQsUUFBTSxRQUFRdkQsTUFBSyxNQUFNLE1BQU11RCxLQUFJO0FBQ25DLFNBQU8sU0FBUyxVQUFVLFFBQVEsZUFBZThDLFNBQVEsS0FBSztBQUNsRTtBQUM2QixjQUFBLHdCQUFHO0FBQ2hDLFNBQVMsZUFBZUEsU0FBUSxPQUFPO0FBQ25DLFNBQU8sTUFBTSxNQUFNLEtBQUssQ0FBQyxTQUFTLGNBQWNBLFNBQVEsSUFBSSxDQUFDO0FBQ2pFO0FBQ3NCLGNBQUEsaUJBQUc7QUFDekIsU0FBUyxjQUFjQSxTQUFRLE1BQU07QUFDakMsTUFBSTtBQUNKLFNBQVFBLFFBQU8sS0FBSyxPQUFPLE1BQU0sWUFDM0IsS0FBSyxLQUFLLFdBQVcsZ0JBQWdCLFFBQVEsT0FBTyxTQUFTLFNBQVMsR0FBRyxLQUFLLENBQUMsUUFBUUEsUUFBTyxHQUFHLE1BQU0sTUFBUztBQUMxSDtBQUNxQixjQUFBLGdCQUFHO0FBQUE7QUNoQnhCLFNBQU8sZUFBY3BGLFVBQVUsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQzVELEVBQUFBLFNBQTBCLGtCQUFBQSxTQUFBLGlCQUF5QkEseUJBQXdCQSxTQUFpQyx5QkFBQUEsU0FBQSxlQUF1QkEsMEJBQXlCQSxTQUFtQixXQUFBO0FBQy9LLFFBQU0sVUFBVTlCO0FBQ2hCLFFBQU15SCxtQkFBa0JsSTtBQUN4QixRQUFNZ0ksWUFBVy9IO0FBQ2pCLFFBQU15SCxhQUFZakc7QUFDbEIsUUFBTXlGLFVBQVM1RDtBQUNmLE1BQUk7QUFDSixHQUFDLFNBQVU2RSxXQUFVO0FBQ2pCLElBQUFBLFVBQVNBLFVBQVMsU0FBUyxJQUFJLENBQUMsSUFBSTtBQUNwQyxJQUFBQSxVQUFTQSxVQUFTLE9BQU8sSUFBSSxDQUFDLElBQUk7QUFBQSxLQUNuQyxXQUFXNUYsU0FBUSxhQUFhQSxTQUFtQixXQUFBLENBQUUsRUFBQztBQUN6RCxXQUFTLGVBQWVvRixTQUFRO0FBQzVCLFVBQU1TLFNBQVEsYUFBYVQsUUFBTyxJQUFJO0FBQ3RDLFVBQU0sVUFBVVMsT0FBTSxTQUFTLE1BQU07QUFDckMsUUFBSSxTQUFTO0FBQ1QsVUFBSVQsUUFBTyxhQUFhO0FBQ3BCLGNBQU0sSUFBSSxNQUFNLHdDQUF3QztBQUFBLElBQy9ELE9BQ0k7QUFDRCxVQUFJLENBQUNTLE9BQU0sVUFBVVQsUUFBTyxhQUFhLFFBQVc7QUFDaEQsY0FBTSxJQUFJLE1BQU0sMENBQTBDO0FBQUEsTUFDN0Q7QUFDRCxVQUFJQSxRQUFPLGFBQWE7QUFDcEIsUUFBQVMsT0FBTSxLQUFLLE1BQU07QUFBQSxJQUN4QjtBQUNELFdBQU9BO0FBQUEsRUFDVjtBQUNELEVBQUE3RixTQUFBLGlCQUF5QjtBQUN6QixXQUFTLGFBQWEsSUFBSTtBQUN0QixVQUFNNkYsU0FBUSxNQUFNLFFBQVEsRUFBRSxJQUFJLEtBQUssS0FBSyxDQUFDLEVBQUUsSUFBSTtBQUNuRCxRQUFJQSxPQUFNLE1BQU0sUUFBUSxVQUFVO0FBQzlCLGFBQU9BO0FBQ1gsVUFBTSxJQUFJLE1BQU0sMENBQTBDQSxPQUFNLEtBQUssR0FBRyxDQUFDO0FBQUEsRUFDNUU7QUFDRCxFQUFBN0YsU0FBQSxlQUF1QjtBQUN2QixXQUFTLHVCQUF1QixJQUFJNkYsUUFBTztBQUN2QyxVQUFNLEVBQUUsS0FBSyxNQUFNLEtBQUksSUFBSztBQUM1QixVQUFNLFdBQVcsY0FBY0EsUUFBTyxLQUFLLFdBQVc7QUFDdEQsVUFBTSxhQUFhQSxPQUFNLFNBQVMsS0FDOUIsRUFBRSxTQUFTLFdBQVcsS0FBS0EsT0FBTSxXQUFXLFNBQVNGLGlCQUFnQix1QkFBdUIsSUFBSUUsT0FBTSxDQUFDLENBQUM7QUFDNUcsUUFBSSxZQUFZO0FBQ1osWUFBTSxZQUFZLGVBQWVBLFFBQU8sTUFBTSxLQUFLLGVBQWUsU0FBUyxLQUFLO0FBQ2hGLFVBQUksR0FBRyxXQUFXLE1BQU07QUFDcEIsWUFBSSxTQUFTO0FBQ1QscUJBQVcsSUFBSUEsUUFBTyxRQUFRO0FBQUE7QUFFOUIsMEJBQWdCLEVBQUU7QUFBQSxNQUNsQyxDQUFTO0FBQUEsSUFDSjtBQUNELFdBQU87QUFBQSxFQUNWO0FBQ0QsRUFBQTdGLFNBQUEseUJBQWlDO0FBQ2pDLFFBQU0sWUFBWSxvQkFBSSxJQUFJLENBQUMsVUFBVSxVQUFVLFdBQVcsV0FBVyxNQUFNLENBQUM7QUFDNUUsV0FBUyxjQUFjNkYsUUFBTyxhQUFhO0FBQ3ZDLFdBQU8sY0FDREEsT0FBTSxPQUFPLENBQUNDLE9BQU0sVUFBVSxJQUFJQSxFQUFDLEtBQU0sZ0JBQWdCLFdBQVdBLE9BQU0sT0FBUSxJQUNsRjtFQUNUO0FBQ0QsV0FBUyxXQUFXLElBQUlELFFBQU8sVUFBVTtBQUNyQyxVQUFNLEVBQUUsS0FBSyxNQUFNLEtBQUksSUFBSztBQUM1QixVQUFNRSxZQUFXLElBQUksSUFBSSxhQUFZLEdBQUlaLFdBQVUsWUFBYSxJQUFJLEVBQUU7QUFDdEUsVUFBTSxVQUFVLElBQUksSUFBSSxZQUFlLEdBQUFBLFdBQVUsYUFBYztBQUMvRCxRQUFJLEtBQUssZ0JBQWdCLFNBQVM7QUFDOUIsVUFBSSxJQUFHLEdBQUlBLFdBQVUsS0FBTVksU0FBUSxpQ0FBaUMsSUFBSSxRQUFRLElBQUksZ0JBQWdCLE1BQU0sSUFDckcsT0FBTyxVQUFVWixXQUFVLEtBQU0sSUFBSSxLQUFLLEVBQzFDLE9BQU9ZLGVBQWNaLFdBQVUsWUFBYSxJQUFJLEVBQUUsRUFDbEQsR0FBRyxlQUFlVSxRQUFPLE1BQU0sS0FBSyxhQUFhLEdBQUcsTUFBTSxJQUFJLE9BQU8sU0FBUyxJQUFJLENBQUMsQ0FBQztBQUFBLElBQzVGO0FBQ0QsUUFBSSxJQUFHLEdBQUlWLFdBQVUsS0FBTSxPQUFPLGdCQUFnQjtBQUNsRCxlQUFXVyxNQUFLLFVBQVU7QUFDdEIsVUFBSSxVQUFVLElBQUlBLEVBQUMsS0FBTUEsT0FBTSxXQUFXLEtBQUssZ0JBQWdCLFNBQVU7QUFDckUsMkJBQW1CQSxFQUFDO0FBQUEsTUFDdkI7QUFBQSxJQUNKO0FBQ0QsUUFBSSxLQUFJO0FBQ1Isb0JBQWdCLEVBQUU7QUFDbEIsUUFBSSxNQUFLO0FBQ1QsUUFBSSxJQUFHLEdBQUlYLFdBQVUsS0FBTSxPQUFPLGtCQUFrQixNQUFNO0FBQ3RELFVBQUksT0FBTyxNQUFNLE9BQU87QUFDeEIsdUJBQWlCLElBQUksT0FBTztBQUFBLElBQ3BDLENBQUs7QUFDRCxhQUFTLG1CQUFtQlcsSUFBRztBQUMzQixjQUFRQSxJQUFDO0FBQUEsUUFDTCxLQUFLO0FBQ0QsY0FDSyxRQUFPLEdBQUlYLFdBQVUsS0FBTVksU0FBUSxtQkFBbUJBLFNBQVEsZUFBZSxFQUM3RSxPQUFPLGFBQWFaLFdBQVUsVUFBVyxJQUFJLEVBQUUsRUFDL0MsUUFBVyxHQUFBQSxXQUFVLEtBQU0sSUFBSSxXQUFXLEVBQzFDLE9BQU8sVUFBYSxHQUFBQSxXQUFVLE1BQU87QUFDMUM7QUFBQSxRQUNKLEtBQUs7QUFDRCxjQUNLLFFBQVcsR0FBQUEsV0FBVSxLQUFNWSxTQUFRLG9CQUFvQixJQUFJO0FBQUEsb0JBQzVEQSxTQUFRLG1CQUFtQixJQUFJLE9BQU8sSUFBSSxRQUFRLElBQUksR0FBRyxFQUN4RCxPQUFPLFVBQVMsR0FBSVosV0FBVSxNQUFPLElBQUksRUFBRTtBQUNoRDtBQUFBLFFBQ0osS0FBSztBQUNELGNBQ0ssUUFBVyxHQUFBQSxXQUFVLEtBQU1ZLFNBQVEscUJBQXFCLElBQUk7QUFBQSxvQkFDN0RBLFNBQVEsb0JBQW9CLElBQUksT0FBTyxJQUFJLFFBQVEsSUFBSSxTQUFTLElBQUksUUFBUSxFQUMzRSxPQUFPLFVBQVMsR0FBSVosV0FBVSxNQUFPLElBQUksRUFBRTtBQUNoRDtBQUFBLFFBQ0osS0FBSztBQUNELGNBQ0ssUUFBVyxHQUFBQSxXQUFVLEtBQU0sSUFBSSxtQkFBbUIsSUFBSSxhQUFhLElBQUksV0FBVyxFQUNsRixPQUFPLFNBQVMsS0FBSyxFQUNyQixRQUFPLEdBQUlBLFdBQVUsS0FBTSxJQUFJLGtCQUFrQixJQUFJLFFBQVEsRUFDN0QsT0FBTyxTQUFTLElBQUk7QUFDekI7QUFBQSxRQUNKLEtBQUs7QUFDRCxjQUFJLFFBQU8sR0FBSUEsV0FBVSxLQUFNLElBQUksY0FBYyxJQUFJLGFBQWEsSUFBSSxZQUFZO0FBQ2xGLGNBQUksT0FBTyxTQUFTLElBQUk7QUFDeEI7QUFBQSxRQUNKLEtBQUs7QUFDRCxjQUNLLFFBQVcsR0FBQUEsV0FBVSxLQUFNWSxTQUFRLG9CQUFvQkEsU0FBUTtBQUFBLG1CQUNqRUEsU0FBUSxxQkFBcUIsSUFBSSxXQUFXLEVBQzFDLE9BQU8sVUFBUyxHQUFJWixXQUFVLE1BQU8sSUFBSSxHQUFHO0FBQUEsTUFDeEQ7QUFBQSxJQUNKO0FBQUEsRUFDSjtBQUNELFdBQVMsaUJBQWlCLEVBQUUsS0FBSyxZQUFZLG1CQUFrQixHQUFJLE1BQU07QUFFckUsUUFBSSxJQUFPLEdBQUFBLFdBQVUsS0FBTSxVQUFVLGtCQUFrQixNQUFNLElBQUksUUFBTyxHQUFJQSxXQUFVLEtBQU0sVUFBVSxJQUFJLGtCQUFrQixLQUFLLElBQUksQ0FBQztBQUFBLEVBQ3pJO0FBQ0QsV0FBUyxjQUFjWSxXQUFVLE1BQU0sWUFBWSxVQUFVLFNBQVMsU0FBUztBQUMzRSxVQUFNLEtBQUssWUFBWSxTQUFTLFVBQVVaLFdBQVUsVUFBVSxLQUFLQSxXQUFVLFVBQVU7QUFDdkYsUUFBSTtBQUNKLFlBQVFZLFdBQVE7QUFBQSxNQUNaLEtBQUs7QUFDRCxnQkFBVyxHQUFBWixXQUFVLEtBQU0sSUFBSSxJQUFJLEVBQUU7QUFBQSxNQUN6QyxLQUFLO0FBQ0QsZ0JBQVcsR0FBQUEsV0FBVSxtQkFBb0IsSUFBSTtBQUM3QztBQUFBLE1BQ0osS0FBSztBQUNELGdCQUFXLEdBQUFBLFdBQVUsS0FBTSxJQUFJLGNBQWMsSUFBSSxrQ0FBa0MsSUFBSTtBQUN2RjtBQUFBLE1BQ0osS0FBSztBQUNELGVBQU8sWUFBWUEsV0FBVSxPQUFRLElBQUksbUJBQW1CLElBQUksR0FBRztBQUNuRTtBQUFBLE1BQ0osS0FBSztBQUNELGVBQU8sUUFBTztBQUNkO0FBQUEsTUFDSjtBQUNJLG1CQUFXQSxXQUFVLFlBQWEsSUFBSSxJQUFJLEVBQUUsSUFBSVksU0FBUTtBQUFBLElBQy9EO0FBQ0QsV0FBTyxZQUFZLFNBQVMsVUFBVSxRQUFPLEdBQUlaLFdBQVUsS0FBSyxJQUFJO0FBQ3BFLGFBQVMsUUFBUSxRQUFRQSxXQUFVLEtBQUs7QUFDcEMsY0FBVyxHQUFBQSxXQUFVLFNBQVNBLFdBQVUsWUFBYSxJQUFJLGdCQUFnQixPQUFPLGNBQWlCLEdBQUFBLFdBQVUsY0FBZSxJQUFJLE1BQU1BLFdBQVUsR0FBRztBQUFBLElBQ3BKO0FBQUEsRUFDSjtBQUNELEVBQUFuRixTQUFBLGdCQUF3QjtBQUN4QixXQUFTLGVBQWUsV0FBVyxNQUFNLFlBQVksU0FBUztBQUMxRCxRQUFJLFVBQVUsV0FBVyxHQUFHO0FBQ3hCLGFBQU8sY0FBYyxVQUFVLENBQUMsR0FBRyxNQUFNLFlBQVksT0FBTztBQUFBLElBQy9EO0FBQ0QsUUFBSTtBQUNKLFVBQU02RixVQUFZLEdBQUFsQixRQUFPLFFBQVEsU0FBUztBQUMxQyxRQUFJa0IsT0FBTSxTQUFTQSxPQUFNLFFBQVE7QUFDN0IsWUFBTSxVQUFTLEdBQUlWLFdBQVUsWUFBYSxJQUFJO0FBQzlDLGFBQU9VLE9BQU0sT0FBTyxVQUFTLEdBQUlWLFdBQVUsTUFBTyxJQUFJLE9BQU8sTUFBTTtBQUNuRSxhQUFPVSxPQUFNO0FBQ2IsYUFBT0EsT0FBTTtBQUNiLGFBQU9BLE9BQU07QUFBQSxJQUNoQixPQUNJO0FBQ0QsYUFBT1YsV0FBVTtBQUFBLElBQ3BCO0FBQ0QsUUFBSVUsT0FBTTtBQUNOLGFBQU9BLE9BQU07QUFDakIsZUFBV0MsTUFBS0Q7QUFDWixjQUFXLEdBQUFWLFdBQVUsS0FBSyxNQUFNLGNBQWNXLElBQUcsTUFBTSxZQUFZLE9BQU8sQ0FBQztBQUMvRSxXQUFPO0FBQUEsRUFDVjtBQUNELEVBQUE5RixTQUFBLGlCQUF5QjtBQUN6QixRQUFNLFlBQVk7QUFBQSxJQUNkLFNBQVMsQ0FBQyxFQUFFLFFBQUFvRixRQUFNLE1BQU8sV0FBV0EsT0FBTTtBQUFBLElBQzFDLFFBQVEsQ0FBQyxFQUFFLFFBQUFBLFNBQVEsWUFBVyxNQUFPLE9BQU9BLFdBQVUsWUFBZSxHQUFBRCxXQUFVLFlBQWFDLE9BQU0sT0FBVSxHQUFBRCxXQUFVLFlBQWEsV0FBVztBQUFBLEVBQ2xKO0FBQ0EsV0FBUyxnQkFBZ0IsSUFBSTtBQUN6QixVQUFNLE1BQU0sb0JBQW9CLEVBQUU7QUFDbEMsS0FBQSxHQUFJTSxVQUFTLGFBQWEsS0FBSyxTQUFTO0FBQUEsRUFDM0M7QUFDRCxFQUFBekYsU0FBQSxrQkFBMEI7QUFDMUIsV0FBUyxvQkFBb0IsSUFBSTtBQUM3QixVQUFNLEVBQUUsS0FBSyxNQUFNLFFBQUFvRixRQUFNLElBQUs7QUFDOUIsVUFBTSxjQUFhLEdBQUlULFFBQU8sZ0JBQWdCLElBQUlTLFNBQVEsTUFBTTtBQUNoRSxXQUFPO0FBQUEsTUFDSDtBQUFBLE1BQ0EsU0FBUztBQUFBLE1BQ1Q7QUFBQSxNQUNBLFFBQVFBLFFBQU87QUFBQSxNQUNmO0FBQUEsTUFDQSxhQUFhO0FBQUEsTUFDYixjQUFjQTtBQUFBLE1BQ2QsUUFBUSxDQUFFO0FBQUEsTUFDVjtBQUFBLElBQ1I7QUFBQSxFQUNDOzs7QUN2TUQsT0FBTyxlQUFlLFVBQVMsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQ3RDLFNBQUEsaUJBQUc7QUFDekIsTUFBTUQsY0FBWWpIO0FBQ2xCLE1BQU15RyxXQUFTbEg7QUFDZixTQUFTLGVBQWUsSUFBSSxJQUFJO0FBQzVCLFFBQU0sRUFBRSxZQUFBdUksYUFBWSxPQUFBMUUsV0FBVSxHQUFHO0FBQ2pDLE1BQUksT0FBTyxZQUFZMEUsYUFBWTtBQUMvQixlQUFXLE9BQU9BLGFBQVk7QUFDMUIsb0JBQWMsSUFBSSxLQUFLQSxZQUFXLEdBQUcsRUFBRSxPQUFPO0FBQUEsSUFDakQ7QUFBQSxFQUNKLFdBQ1EsT0FBTyxXQUFXLE1BQU0sUUFBUTFFLE1BQUssR0FBRztBQUM3QyxJQUFBQSxPQUFNLFFBQVEsQ0FBQyxLQUFLLE1BQU0sY0FBYyxJQUFJLEdBQUcsSUFBSSxPQUFPLENBQUM7QUFBQSxFQUM5RDtBQUNMO0FBQ3NCLFNBQUEsaUJBQUc7QUFDekIsU0FBUyxjQUFjLElBQUksTUFBTSxjQUFjO0FBQzNDLFFBQU0sRUFBRSxLQUFLLGVBQWUsTUFBTSxLQUFJLElBQUs7QUFDM0MsTUFBSSxpQkFBaUI7QUFDakI7QUFDSixRQUFNLGFBQVksR0FBSTZELFlBQVUsS0FBTSxJQUFJLElBQUcsR0FBSUEsWUFBVSxhQUFhLElBQUksQ0FBQztBQUM3RSxNQUFJLGVBQWU7QUFDZixLQUFJUixHQUFBQSxTQUFPLGlCQUFpQixJQUFJLDJCQUEyQixTQUFTLEVBQUU7QUFDdEU7QUFBQSxFQUNIO0FBQ0QsTUFBSSxhQUFZLEdBQUlRLFlBQVUsS0FBTSxTQUFTO0FBQzdDLE1BQUksS0FBSyxnQkFBZ0IsU0FBUztBQUM5QixpQkFBZ0JBLEdBQUFBLFlBQVUsS0FBTSxTQUFTLE9BQU8sU0FBUyxnQkFBZ0IsU0FBUztBQUFBLEVBQ3JGO0FBR0QsTUFBSSxHQUFHLFlBQVcsR0FBSUEsWUFBVSxLQUFNLFNBQVMsT0FBVUEsR0FBQUEsWUFBVSxXQUFXLFlBQVksQ0FBQyxFQUFFO0FBQ2pHOzs7QUNoQ0EsT0FBTyxlQUFlLE1BQVMsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQ3ZDLEtBQUEsZ0JBQXdCLEtBQUEsZ0JBQXFCLEtBQUEsYUFBMkIsS0FBQSxtQkFBMkIsS0FBQSxtQkFBOEIsS0FBQSxzQkFBMkIsS0FBQSxtQkFBeUIsS0FBQSxpQkFBd0IsS0FBQSxnQkFBc0IsS0FBQSxjQUE0QixLQUFBLG9CQUEyQixLQUFBLG1CQUFpQyxLQUFBLHlCQUFHO0FBQ25WLE1BQU1BLGNBQVlqSDtBQUNsQixNQUFNeUcsV0FBU2xIO0FBQ2YsTUFBTStILFlBQVU5SDtBQUNoQixNQUFNdUksV0FBU3hJO0FBQ2YsU0FBUyx1QkFBdUIsS0FBSyxNQUFNO0FBQ3ZDLFFBQU0sRUFBRSxLQUFLLE1BQU0sR0FBRSxJQUFLO0FBQzFCLE1BQUksR0FBRyxpQkFBaUIsS0FBSyxNQUFNLE1BQU0sR0FBRyxLQUFLLGFBQWEsR0FBRyxNQUFNO0FBQ25FLFFBQUksVUFBVSxFQUFFLHFCQUFxQjBILFlBQVUsS0FBTSxJQUFJLEdBQUksR0FBRSxJQUFJO0FBQ25FLFFBQUksTUFBSztBQUFBLEVBQ2pCLENBQUs7QUFDTDtBQUM4QixLQUFBLHlCQUFHO0FBQ2pDLFNBQVMsaUJBQWlCLEVBQUUsS0FBSyxNQUFNLElBQUksRUFBRSxLQUFNLEVBQUEsR0FBSWEsYUFBWSxTQUFTO0FBQ3hFLGFBQVdiLFlBQVUsSUFBSSxHQUFHYSxZQUFXLElBQUksQ0FBQyxhQUFhYixZQUFVLEtBQUssaUJBQWlCLEtBQUssTUFBTSxNQUFNLEtBQUssYUFBYSxJQUFHLEdBQUlBLFlBQVUsS0FBTSxPQUFPLE1BQU0sSUFBSSxFQUFFLENBQUMsQ0FBQztBQUM1SztBQUN3QixLQUFBLG1CQUFHO0FBQzNCLFNBQVMsa0JBQWtCLEtBQUssU0FBUztBQUNyQyxNQUFJLFVBQVUsRUFBRSxpQkFBaUIsUUFBUyxHQUFFLElBQUk7QUFDaEQsTUFBSSxNQUFLO0FBQ2I7QUFDeUIsS0FBQSxvQkFBRztBQUM1QixTQUFTLFlBQVksS0FBSztBQUN0QixTQUFPLElBQUksV0FBVyxRQUFRO0FBQUE7QUFBQSxJQUUxQixLQUFLLE9BQU8sVUFBVTtBQUFBLElBQ3RCLE9BQVVBLEdBQUFBLFlBQVU7QUFBQSxFQUM1QixDQUFLO0FBQ0w7QUFDbUIsS0FBQSxjQUFHO0FBQ3RCLFNBQVMsY0FBYyxLQUFLLE1BQU0sVUFBVTtBQUN4QyxhQUFXQSxZQUFVLEtBQU0sWUFBWSxHQUFHLENBQUMsU0FBUyxJQUFJLEtBQUssUUFBUTtBQUN6RTtBQUNxQixLQUFBLGdCQUFHO0FBQ3hCLFNBQVMsZUFBZSxLQUFLLE1BQU0sVUFBVSxlQUFlO0FBQ3hELFFBQU0sUUFBTyxHQUFJQSxZQUFVLEtBQU0sSUFBSSxJQUFHLEdBQUlBLFlBQVUsYUFBYSxRQUFRLENBQUM7QUFDNUUsU0FBTyxpQkFBb0JBLEdBQUFBLFlBQVUsS0FBTSxJQUFJLE9BQU8sY0FBYyxLQUFLLE1BQU0sUUFBUSxDQUFDLEtBQUs7QUFDakc7QUFDc0IsS0FBQSxpQkFBRztBQUN6QixTQUFTLGlCQUFpQixLQUFLLE1BQU0sVUFBVSxlQUFlO0FBQzFELFFBQU0sUUFBTyxHQUFJQSxZQUFVLEtBQU0sSUFBSSxJQUFHLEdBQUlBLFlBQVUsYUFBYSxRQUFRLENBQUM7QUFDNUUsU0FBTyxpQkFBb0JBLEdBQUFBLFlBQVUsSUFBSSxPQUFNLEdBQUlBLFlBQVUsS0FBSyxjQUFjLEtBQUssTUFBTSxRQUFRLENBQUMsQ0FBQyxJQUFJO0FBQzdHO0FBQ3dCLEtBQUEsbUJBQUc7QUFDM0IsU0FBUyxvQkFBb0IsV0FBVztBQUNwQyxTQUFPLFlBQVksT0FBTyxLQUFLLFNBQVMsRUFBRSxPQUFPLENBQUMsTUFBTSxNQUFNLFdBQVcsSUFBSSxDQUFBO0FBQ2pGO0FBQzJCLEtBQUEsc0JBQUc7QUFDOUIsU0FBUyxpQkFBaUIsSUFBSSxXQUFXO0FBQ3JDLFNBQU8sb0JBQW9CLFNBQVMsRUFBRSxPQUFPLENBQUMsTUFBTSxLQUFLUixTQUFPLG1CQUFtQixJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUM7QUFDeEc7QUFDd0IsS0FBQSxtQkFBRztBQUMzQixTQUFTLGlCQUFpQixFQUFFLFlBQVksTUFBTSxJQUFJLEVBQUUsS0FBSyxjQUFjLFlBQVksVUFBVyxHQUFFLEdBQUUsR0FBSSxNQUFNLFNBQVMsWUFBWTtBQUM3SCxRQUFNLGdCQUFnQixjQUFhLEdBQUlRLFlBQVUsS0FBTSxVQUFVLEtBQUssSUFBSSxLQUFLLFlBQVksR0FBRyxVQUFVLEtBQUs7QUFDN0csUUFBTSxTQUFTO0FBQUEsSUFDWCxDQUFDSyxVQUFRLFFBQVEsa0JBQWtCTCxZQUFVLFdBQVdLLFVBQVEsUUFBUSxjQUFjLFNBQVMsQ0FBQztBQUFBLElBQ2hHLENBQUNBLFVBQVEsUUFBUSxZQUFZLEdBQUcsVUFBVTtBQUFBLElBQzFDLENBQUNBLFVBQVEsUUFBUSxvQkFBb0IsR0FBRyxrQkFBa0I7QUFBQSxJQUMxRCxDQUFDQSxVQUFRLFFBQVEsVUFBVUEsVUFBUSxRQUFRLFFBQVE7QUFBQSxFQUMzRDtBQUNJLE1BQUksR0FBRyxLQUFLO0FBQ1IsV0FBTyxLQUFLLENBQUNBLFVBQVEsUUFBUSxnQkFBZ0JBLFVBQVEsUUFBUSxjQUFjLENBQUM7QUFDaEYsUUFBTSxRQUFPLEdBQUlMLFlBQVUsS0FBTSxhQUFhLEtBQUssSUFBSSxPQUFPLEdBQUcsTUFBTSxDQUFDO0FBQ3hFLFNBQU8sWUFBWUEsWUFBVSxPQUFVQSxHQUFBQSxZQUFVLEtBQU0sSUFBSSxTQUFTLE9BQU8sS0FBSyxJQUFJLE9BQVVBLEdBQUFBLFlBQVUsS0FBTSxJQUFJLElBQUksSUFBSTtBQUM5SDtBQUN3QixLQUFBLG1CQUFHO0FBQzNCLE1BQU0sYUFBWSxHQUFJQSxZQUFVO0FBQ2hDLFNBQVMsV0FBVyxFQUFFLEtBQUssSUFBSSxFQUFFLEtBQUksRUFBSSxHQUFFZSxVQUFTO0FBQ2hELFFBQU1uRyxLQUFJLEtBQUssZ0JBQWdCLE1BQU07QUFDckMsUUFBTSxFQUFFLE9BQU0sSUFBSyxLQUFLO0FBQ3hCLFFBQU0sS0FBSyxPQUFPbUcsVUFBU25HLEVBQUM7QUFDNUIsU0FBTyxJQUFJLFdBQVcsV0FBVztBQUFBLElBQzdCLEtBQUssR0FBRyxTQUFVO0FBQUEsSUFDbEIsS0FBSztBQUFBLElBQ0wsT0FBTSxHQUFJb0YsWUFBVSxLQUFNLE9BQU8sU0FBUyxlQUFlLGFBQVksR0FBSWMsU0FBTyxTQUFTLEtBQUssTUFBTSxDQUFDLElBQUlDLFFBQU8sS0FBS25HLEVBQUM7QUFBQSxFQUM5SCxDQUFLO0FBQ0w7QUFDa0IsS0FBQSxhQUFHO0FBQ3JCLFNBQVMsY0FBYyxLQUFLO0FBQ3hCLFFBQU0sRUFBRSxLQUFLLE1BQU0sU0FBQXVGLFVBQVMsR0FBRSxJQUFLO0FBQ25DLFFBQU1JLFNBQVEsSUFBSSxLQUFLLE9BQU87QUFDOUIsTUFBSSxHQUFHLFdBQVc7QUFDZCxVQUFNLFdBQVcsSUFBSSxJQUFJLFNBQVMsSUFBSTtBQUN0QyxrQkFBYyxNQUFNLElBQUksT0FBTyxVQUFVLEtBQUssQ0FBQztBQUMvQyxXQUFPO0FBQUEsRUFDVjtBQUNELE1BQUksSUFBSUEsUUFBTyxJQUFJO0FBQ25CLGdCQUFjLE1BQU0sSUFBSSxNQUFLLENBQUU7QUFDL0IsU0FBT0E7QUFDUCxXQUFTLGNBQWMsVUFBVTtBQUM3QixVQUFNLE1BQU0sSUFBSSxNQUFNLFFBQU8sR0FBSVAsWUFBVSxLQUFNLElBQUksU0FBUztBQUM5RCxRQUFJLFNBQVMsS0FBSyxHQUFHLEtBQUssQ0FBQyxNQUFNO0FBQzdCLFVBQUksVUFBVTtBQUFBLFFBQ1YsU0FBQUc7QUFBQSxRQUNBLFVBQVU7QUFBQSxRQUNWLGNBQWNYLFNBQU8sS0FBSztBQUFBLE1BQzdCLEdBQUVlLE1BQUs7QUFDUixVQUFJLE9BQU9QLFlBQVUsS0FBS08sTUFBSyxHQUFHLFFBQVE7QUFBQSxJQUN0RCxDQUFTO0FBQUEsRUFDSjtBQUNMO0FBQ3FCLEtBQUEsZ0JBQUc7QUFDeEIsU0FBUyxjQUFjLEtBQUs7QUFDeEIsUUFBTSxFQUFFLEtBQUssUUFBQU4sU0FBUSxTQUFBRSxVQUFTLEdBQUUsSUFBSztBQUVyQyxNQUFJLENBQUMsTUFBTSxRQUFRRixPQUFNO0FBQ3JCLFVBQU0sSUFBSSxNQUFNLDBCQUEwQjtBQUM5QyxRQUFNLGNBQWNBLFFBQU8sS0FBSyxDQUFDLFlBQVlULFNBQU8sbUJBQW1CLElBQUksR0FBRyxDQUFDO0FBQy9FLE1BQUksZUFBZSxDQUFDLEdBQUcsS0FBSztBQUN4QjtBQUNKLFFBQU1lLFNBQVEsSUFBSSxJQUFJLFNBQVMsS0FBSztBQUNwQyxRQUFNLFdBQVcsSUFBSSxLQUFLLFFBQVE7QUFDbEMsTUFBSSxNQUFNLE1BQU1OLFFBQU8sUUFBUSxDQUFDLE1BQU0sTUFBTTtBQUN4QyxVQUFNLFNBQVMsSUFBSSxVQUFVO0FBQUEsTUFDekIsU0FBQUU7QUFBQSxNQUNBLFlBQVk7QUFBQSxNQUNaLGVBQWU7QUFBQSxJQUNsQixHQUFFLFFBQVE7QUFDWCxRQUFJLE9BQU9JLFNBQU8sR0FBSVAsWUFBVSxLQUFNTyxNQUFLLE9BQU8sUUFBUSxFQUFFO0FBQzVELFVBQU0sU0FBUyxJQUFJLG9CQUFvQixRQUFRLFFBQVE7QUFHdkQsUUFBSSxDQUFDO0FBQ0QsVUFBSSxJQUFPUCxHQUFBQSxZQUFVLEtBQUtPLE1BQUssQ0FBQztBQUFBLEVBQ3ZDLENBQUEsQ0FBQztBQUNGLE1BQUksT0FBT0EsUUFBTyxNQUFNLElBQUksU0FBUyxNQUFNLElBQUksTUFBTSxJQUFJLENBQUM7QUFDOUQ7QUFDcUIsS0FBQSxnQkFBRztBQ2hJeEIsT0FBTyxlQUFlLFNBQVMsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQ2hDLFFBQUEsaURBQTZCLFFBQUEsa0JBQWtELFFBQUEsbUJBQUc7QUFDOUcsTUFBTVAsY0FBWWpIO0FBQ2xCLE1BQU1zSCxZQUFVL0g7QUFDaEIsTUFBTXFILFdBQVNwSDtBQUNmLE1BQU0rSCxhQUFXdkc7QUFDakIsU0FBUyxpQkFBaUIsS0FBSzhGLE1BQUs7QUFDaEMsUUFBTSxFQUFFLEtBQUssU0FBQU0sVUFBUyxRQUFBRixTQUFRLGNBQWMsR0FBSSxJQUFHO0FBQ25ELFFBQU0sY0FBY0osS0FBSSxNQUFNLEtBQUssR0FBRyxNQUFNSSxTQUFRLGNBQWMsRUFBRTtBQUNwRSxRQUFNLFlBQVksV0FBVyxLQUFLRSxVQUFTLFdBQVc7QUFDdEQsTUFBSSxHQUFHLEtBQUssbUJBQW1CO0FBQzNCLE9BQUcsS0FBSyxlQUFlLGFBQWEsSUFBSTtBQUM1QyxRQUFNSSxTQUFRLElBQUksS0FBSyxPQUFPO0FBQzlCLE1BQUksVUFBVTtBQUFBLElBQ1YsUUFBUTtBQUFBLElBQ1IsWUFBWVAsWUFBVTtBQUFBLElBQ3RCLGVBQWUsR0FBRyxHQUFHLGFBQWEsSUFBSUcsUUFBTztBQUFBLElBQzdDLGNBQWM7QUFBQSxJQUNkLGVBQWU7QUFBQSxFQUNsQixHQUFFSSxNQUFLO0FBQ1IsTUFBSSxLQUFLQSxRQUFPLE1BQU0sSUFBSSxNQUFNLElBQUksQ0FBQztBQUN6QztBQUN3QixRQUFBLG1CQUFHO0FBQzNCLFNBQVMsZ0JBQWdCLEtBQUtWLE1BQUs7QUFDL0IsTUFBSTtBQUNKLFFBQU0sRUFBRSxLQUFLLFNBQUFNLFVBQVMsUUFBQUYsU0FBUSxjQUFjLE9BQU8sR0FBSSxJQUFHO0FBQzFELG9CQUFrQixJQUFJSixJQUFHO0FBQ3pCLFFBQU1tQixZQUFXLENBQUMsU0FBU25CLEtBQUksVUFBVUEsS0FBSSxRQUFRLEtBQUssR0FBRyxNQUFNSSxTQUFRLGNBQWMsRUFBRSxJQUFJSixLQUFJO0FBQ25HLFFBQU0sY0FBYyxXQUFXLEtBQUtNLFVBQVNhLFNBQVE7QUFDckQsUUFBTVQsU0FBUSxJQUFJLElBQUksT0FBTztBQUM3QixNQUFJLFdBQVdBLFFBQU8sZUFBZTtBQUNyQyxNQUFJLElBQUksS0FBS1YsS0FBSSxXQUFXLFFBQVEsT0FBTyxTQUFTLEtBQUtVLE1BQUs7QUFDOUQsV0FBUyxrQkFBa0I7QUFDdkIsUUFBSVYsS0FBSSxXQUFXLE9BQU87QUFDdEI7QUFDQSxVQUFJQSxLQUFJO0FBQ0osbUJBQVcsR0FBRztBQUNsQixpQkFBVyxNQUFNLElBQUksTUFBSyxDQUFFO0FBQUEsSUFDL0IsT0FDSTtBQUNELFlBQU0sV0FBV0EsS0FBSSxRQUFRLGNBQWUsSUFBRyxhQUFZO0FBQzNELFVBQUlBLEtBQUk7QUFDSixtQkFBVyxHQUFHO0FBQ2xCLGlCQUFXLE1BQU0sUUFBUSxLQUFLLFFBQVEsQ0FBQztBQUFBLElBQzFDO0FBQUEsRUFDSjtBQUNELFdBQVMsZ0JBQWdCO0FBQ3JCLFVBQU0sV0FBVyxJQUFJLElBQUksWUFBWSxJQUFJO0FBQ3pDLFFBQUksSUFBSSxNQUFNLGFBQVksR0FBSUcsWUFBVSxVQUFXLEdBQUcsQ0FBQyxNQUFNLElBQUksT0FBT08sUUFBTyxLQUFLLEVBQUUsSUFBT1AsR0FBQUEsWUFBVSxLQUFNLENBQUMsZUFBZSxHQUFHLGVBQWUsSUFBSSxNQUFNLElBQUksT0FBTyxjQUFjQSxZQUFVLEtBQU0sQ0FBQyxTQUFTLEdBQUcsTUFBTSxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDbE8sV0FBTztBQUFBLEVBQ1Y7QUFDRCxXQUFTLGVBQWU7QUFDcEIsVUFBTSxnQkFBZSxHQUFJQSxZQUFVLEtBQU0sV0FBVztBQUNwRCxRQUFJLE9BQU8sY0FBYyxJQUFJO0FBQzdCLGdCQUFZQSxZQUFVLEdBQUc7QUFDekIsV0FBTztBQUFBLEVBQ1Y7QUFDRCxXQUFTLFlBQVksU0FBU0gsS0FBSSxTQUFRLEdBQUlHLFlBQVUsYUFBY0EsWUFBVSxLQUFLO0FBQ2pGLFVBQU0sVUFBVSxHQUFHLEtBQUssY0FBY0ssVUFBUSxRQUFRLE9BQU9BLFVBQVEsUUFBUTtBQUM3RSxVQUFNLGFBQWEsRUFBRyxhQUFhUixRQUFPLENBQUMsU0FBVUEsS0FBSSxXQUFXO0FBQ3BFLFFBQUksT0FBT1UsU0FBV1AsR0FBQUEsWUFBVSxLQUFNLE1BQU0sSUFBT0wsR0FBQUEsU0FBTyxrQkFBa0IsS0FBSyxhQUFhLFNBQVMsVUFBVSxDQUFDLElBQUlFLEtBQUksU0FBUztBQUFBLEVBQ3RJO0FBQ0QsV0FBUyxXQUFXb0IsU0FBUTtBQUN4QixRQUFJQztBQUNKLFFBQUksSUFBT2xCLEdBQUFBLFlBQVUsTUFBTWtCLE1BQUtyQixLQUFJLFdBQVcsUUFBUXFCLFFBQU8sU0FBU0EsTUFBS1gsTUFBSyxHQUFHVSxPQUFNO0FBQUEsRUFDN0Y7QUFDTDtBQUN1QixRQUFBLGtCQUFHO0FBQzFCLFNBQVMsV0FBVyxLQUFLO0FBQ3JCLFFBQU0sRUFBRSxLQUFLLE1BQU0sR0FBRSxJQUFLO0FBQzFCLE1BQUksR0FBRyxHQUFHLFlBQVksTUFBTSxJQUFJLE9BQU8sVUFBVWpCLFlBQVUsS0FBTSxHQUFHLFVBQVUsSUFBSSxHQUFHLGtCQUFrQixHQUFHLENBQUM7QUFDL0c7QUFDQSxTQUFTLFFBQVEsS0FBSyxNQUFNO0FBQ3hCLFFBQU0sRUFBRSxJQUFLLElBQUc7QUFDaEIsTUFBSSxJQUFHLEdBQUlBLFlBQVUsbUJBQW9CLElBQUksS0FBSyxNQUFNO0FBQ3BELFFBQ0ssT0FBT0ssVUFBUSxRQUFRLFVBQWFMLEdBQUFBLFlBQVUsS0FBTUssVUFBUSxRQUFRLE9BQU8sZUFBZSxJQUFJLE1BQU1BLFVBQVEsUUFBUSxPQUFPLFdBQVcsSUFBSSxHQUFHLEVBQzdJLE9BQU9BLFVBQVEsUUFBUSxTQUFZTCxHQUFBQSxZQUFVLEtBQU1LLFVBQVEsUUFBUSxPQUFPLFNBQVM7QUFDeEYsUUFBSUMsV0FBUyxjQUFjLEdBQUc7QUFBQSxFQUN0QyxHQUFPLE1BQU0sSUFBSSxNQUFLLENBQUU7QUFDeEI7QUFDQSxTQUFTLGtCQUFrQixFQUFFLFVBQVcsR0FBRVQsTUFBSztBQUMzQyxNQUFJQSxLQUFJLFNBQVMsQ0FBQyxVQUFVO0FBQ3hCLFVBQU0sSUFBSSxNQUFNLDhCQUE4QjtBQUN0RDtBQUNBLFNBQVMsV0FBVyxLQUFLTSxVQUFTLFFBQVE7QUFDdEMsTUFBSSxXQUFXO0FBQ1gsVUFBTSxJQUFJLE1BQU0sWUFBWUEsUUFBTyxxQkFBcUI7QUFDNUQsU0FBTyxJQUFJLFdBQVcsV0FBVyxPQUFPLFVBQVUsYUFBYSxFQUFFLEtBQUssT0FBTSxJQUFLLEVBQUUsS0FBSyxRQUFRLE9BQU0sR0FBSUgsWUFBVSxXQUFXLE1BQU0sRUFBQyxDQUFFO0FBQzVJO0FBQ0EsU0FBUyxnQkFBZ0JDLFNBQVEsWUFBWSxpQkFBaUIsT0FBTztBQUVqRSxTQUFRLENBQUMsV0FBVyxVQUNoQixXQUFXLEtBQUssQ0FBQyxPQUFPLE9BQU8sVUFDekIsTUFBTSxRQUFRQSxPQUFNLElBQ3BCLE9BQU8sV0FDSEEsV0FBVSxPQUFPQSxXQUFVLFlBQVksQ0FBQyxNQUFNLFFBQVFBLE9BQU0sSUFDNUQsT0FBT0EsV0FBVSxNQUFPLGtCQUFrQixPQUFPQSxXQUFVLFdBQVk7QUFDekY7QUFDdUIsUUFBQSxrQkFBRztBQUMxQixTQUFTLHFCQUFxQixFQUFFLFFBQUFBLFNBQVEsTUFBTSxNQUFBckcsT0FBTSxjQUFlLEdBQUVpRyxNQUFLTSxVQUFTO0FBRS9FLE1BQUksTUFBTSxRQUFRTixLQUFJLE9BQU8sSUFBSSxDQUFDQSxLQUFJLFFBQVEsU0FBU00sUUFBTyxJQUFJTixLQUFJLFlBQVlNLFVBQVM7QUFDdkYsVUFBTSxJQUFJLE1BQU0sMEJBQTBCO0FBQUEsRUFDN0M7QUFDRCxRQUFNLE9BQU9OLEtBQUk7QUFDakIsTUFBSSxTQUFTLFFBQVEsU0FBUyxTQUFTLFNBQVMsS0FBSyxLQUFLLENBQUMsUUFBUSxDQUFDLE9BQU8sVUFBVSxlQUFlLEtBQUtJLFNBQVEsR0FBRyxDQUFDLEdBQUc7QUFDcEgsVUFBTSxJQUFJLE1BQU0sMkNBQTJDRSxRQUFPLEtBQUssS0FBSyxLQUFLLEdBQUcsQ0FBQyxFQUFFO0FBQUEsRUFDMUY7QUFDRCxNQUFJTixLQUFJLGdCQUFnQjtBQUNwQixVQUFNVSxTQUFRVixLQUFJLGVBQWVJLFFBQU9FLFFBQU8sQ0FBQztBQUNoRCxRQUFJLENBQUNJLFFBQU87QUFDUixZQUFNLE1BQU0sWUFBWUosUUFBTywrQkFBK0IsYUFBYSxRQUN2RXZHLE1BQUssV0FBV2lHLEtBQUksZUFBZSxNQUFNO0FBQzdDLFVBQUksS0FBSyxtQkFBbUI7QUFDeEIsUUFBQWpHLE1BQUssT0FBTyxNQUFNLEdBQUc7QUFBQTtBQUVyQixjQUFNLElBQUksTUFBTSxHQUFHO0FBQUEsSUFDMUI7QUFBQSxFQUNKO0FBQ0w7QUFDNEIsUUFBQSx1QkFBRzs7QUN6SC9CLE9BQU8sZUFBZSxXQUFTLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUM1RCxVQUFBLHNCQUF5RCxVQUFBLCtDQUEwQjtBQUNuRixNQUFNb0csY0FBWWpIO0FBQ2xCLE1BQU15RyxXQUFTbEg7QUFDZixTQUFTLGFBQWEsSUFBSSxFQUFFLFNBQUE2SCxVQUFTLFlBQVksUUFBQUYsU0FBUSxZQUFZLGVBQWUsZ0JBQWdCO0FBQ2hHLE1BQUlFLGFBQVksVUFBYUYsWUFBVyxRQUFXO0FBQy9DLFVBQU0sSUFBSSxNQUFNLHNEQUFzRDtBQUFBLEVBQ3pFO0FBQ0QsTUFBSUUsYUFBWSxRQUFXO0FBQ3ZCLFVBQU0sTUFBTSxHQUFHLE9BQU9BLFFBQU87QUFDN0IsV0FBTyxlQUFlLFNBQ2hCO0FBQUEsTUFDRSxRQUFRO0FBQUEsTUFDUixhQUFnQkgsR0FBQUEsWUFBVSxLQUFNLEdBQUcsVUFBVSxPQUFPQSxZQUFVLGFBQWFHLFFBQU8sQ0FBQztBQUFBLE1BQ25GLGVBQWUsR0FBRyxHQUFHLGFBQWEsSUFBSUEsUUFBTztBQUFBLElBQ2hELElBQ0M7QUFBQSxNQUNFLFFBQVEsSUFBSSxVQUFVO0FBQUEsTUFDdEIsYUFBZ0JILEdBQUFBLFlBQVUsS0FBTSxHQUFHLFVBQVUsSUFBRyxHQUFJQSxZQUFVLGFBQWFHLFFBQU8sQ0FBQyxJQUFHLEdBQUlILFlBQVUsYUFBYSxVQUFVLENBQUM7QUFBQSxNQUM1SCxlQUFlLEdBQUcsR0FBRyxhQUFhLElBQUlHLFFBQU8sUUFBUVgsU0FBTyxnQkFBZ0IsVUFBVSxDQUFDO0FBQUEsSUFDdkc7QUFBQSxFQUNLO0FBQ0QsTUFBSVMsWUFBVyxRQUFXO0FBQ3RCLFFBQUksZUFBZSxVQUFhLGtCQUFrQixVQUFhLGlCQUFpQixRQUFXO0FBQ3ZGLFlBQU0sSUFBSSxNQUFNLDZFQUE2RTtBQUFBLElBQ2hHO0FBQ0QsV0FBTztBQUFBLE1BQ0gsUUFBQUE7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNaO0FBQUEsRUFDSztBQUNELFFBQU0sSUFBSSxNQUFNLDZDQUE2QztBQUNqRTtBQUNvQixVQUFBLGVBQUc7QUFDdkIsU0FBUyxvQkFBb0JrQixZQUFXLElBQUksRUFBRSxVQUFVLGNBQWMsUUFBUSxNQUFNLFdBQVcsZ0JBQWdCO0FBQzNHLE1BQUksU0FBUyxVQUFhLGFBQWEsUUFBVztBQUM5QyxVQUFNLElBQUksTUFBTSxxREFBcUQ7QUFBQSxFQUN4RTtBQUNELFFBQU0sRUFBRSxJQUFLLElBQUc7QUFDaEIsTUFBSSxhQUFhLFFBQVc7QUFDeEIsVUFBTSxFQUFFLFdBQVcsYUFBYSxLQUFJLElBQUs7QUFDekMsVUFBTSxXQUFXLElBQUksSUFBSSxTQUFZbkIsR0FBQUEsWUFBVSxLQUFNLEdBQUcsSUFBSSxJQUFHLEdBQUlBLFlBQVUsYUFBYSxRQUFRLENBQUMsSUFBSSxJQUFJO0FBQzNHLHFCQUFpQixRQUFRO0FBQ3pCLElBQUFtQixXQUFVLGFBQWdCbkIsR0FBQUEsWUFBVSxPQUFRLFNBQVMsSUFBT1IsR0FBQUEsU0FBTyxjQUFjLFVBQVUsUUFBUSxLQUFLLGdCQUFnQixDQUFDO0FBQ3pILElBQUEyQixXQUFVLHlCQUF5Qm5CLFlBQVUsS0FBTSxRQUFRO0FBQzNELElBQUFtQixXQUFVLGNBQWMsQ0FBQyxHQUFHLGFBQWFBLFdBQVUsa0JBQWtCO0FBQUEsRUFDeEU7QUFDRCxNQUFJLFNBQVMsUUFBVztBQUNwQixVQUFNLFdBQVcsZ0JBQWdCbkIsWUFBVSxPQUFPLE9BQU8sSUFBSSxJQUFJLFFBQVEsTUFBTSxJQUFJO0FBQ25GLHFCQUFpQixRQUFRO0FBQ3pCLFFBQUksaUJBQWlCO0FBQ2pCLE1BQUFtQixXQUFVLGVBQWU7QUFBQSxFQUVoQztBQUNELE1BQUk7QUFDQSxJQUFBQSxXQUFVLFlBQVk7QUFDMUIsV0FBUyxpQkFBaUIsV0FBVztBQUNqQyxJQUFBQSxXQUFVLE9BQU87QUFDakIsSUFBQUEsV0FBVSxZQUFZLEdBQUcsWUFBWTtBQUNyQyxJQUFBQSxXQUFVLFlBQVk7QUFDdEIsT0FBRyxvQkFBb0Isb0JBQUk7QUFDM0IsSUFBQUEsV0FBVSxhQUFhLEdBQUc7QUFDMUIsSUFBQUEsV0FBVSxZQUFZLENBQUMsR0FBRyxHQUFHLFdBQVcsU0FBUztBQUFBLEVBQ3BEO0FBQ0w7QUFDMkIsVUFBQSxzQkFBRztBQUM5QixTQUFTLG9CQUFvQkEsWUFBVyxFQUFFLGtCQUFrQixhQUFhLGVBQWUsY0FBYyxhQUFhO0FBQy9HLE1BQUksa0JBQWtCO0FBQ2xCLElBQUFBLFdBQVUsZ0JBQWdCO0FBQzlCLE1BQUksaUJBQWlCO0FBQ2pCLElBQUFBLFdBQVUsZUFBZTtBQUM3QixNQUFJLGNBQWM7QUFDZCxJQUFBQSxXQUFVLFlBQVk7QUFDMUIsRUFBQUEsV0FBVSxtQkFBbUI7QUFDN0IsRUFBQUEsV0FBVSxjQUFjO0FBQzVCO0FBQzJCLFVBQUEsc0JBQUc7O0FDekU5QixJQUFBLGdCQUFpQixTQUFTLE1BQU0sR0FBRyxHQUFHO0FBQ3BDLE1BQUksTUFBTTtBQUFHLFdBQU87QUFFcEIsTUFBSSxLQUFLLEtBQUssT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFVBQVU7QUFDMUQsUUFBSSxFQUFFLGdCQUFnQixFQUFFO0FBQWEsYUFBTztBQUU1QyxRQUFJLFFBQVEsR0FBRztBQUNmLFFBQUksTUFBTSxRQUFRLENBQUMsR0FBRztBQUNwQixlQUFTLEVBQUU7QUFDWCxVQUFJLFVBQVUsRUFBRTtBQUFRLGVBQU87QUFDL0IsV0FBSyxJQUFJLFFBQVEsUUFBUTtBQUN2QixZQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztBQUFHLGlCQUFPO0FBQ2pDLGFBQU87QUFBQSxJQUNSO0FBSUQsUUFBSSxFQUFFLGdCQUFnQjtBQUFRLGFBQU8sRUFBRSxXQUFXLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRTtBQUM1RSxRQUFJLEVBQUUsWUFBWSxPQUFPLFVBQVU7QUFBUyxhQUFPLEVBQUUsUUFBTyxNQUFPLEVBQUUsUUFBTztBQUM1RSxRQUFJLEVBQUUsYUFBYSxPQUFPLFVBQVU7QUFBVSxhQUFPLEVBQUUsU0FBUSxNQUFPLEVBQUUsU0FBUTtBQUVoRixXQUFPLE9BQU8sS0FBSyxDQUFDO0FBQ3BCLGFBQVMsS0FBSztBQUNkLFFBQUksV0FBVyxPQUFPLEtBQUssQ0FBQyxFQUFFO0FBQVEsYUFBTztBQUU3QyxTQUFLLElBQUksUUFBUSxRQUFRO0FBQ3ZCLFVBQUksQ0FBQyxPQUFPLFVBQVUsZUFBZSxLQUFLLEdBQUcsS0FBSyxDQUFDLENBQUM7QUFBRyxlQUFPO0FBRWhFLFNBQUssSUFBSSxRQUFRLFFBQVEsS0FBSTtBQUMzQixVQUFJLE1BQU0sS0FBSyxDQUFDO0FBRWhCLFVBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxHQUFHLEVBQUUsR0FBRyxDQUFDO0FBQUcsZUFBTztBQUFBLElBQ3BDO0FBRUQsV0FBTztBQUFBLEVBQ1I7QUFHRCxTQUFPLE1BQUksS0FBSyxNQUFJO0FBQ3RCOztBQzNDQSxJQUFJQyxhQUFXQyxtQkFBQSxVQUFpQixTQUFVcEIsU0FBUSxNQUFNLElBQUk7QUFFMUQsTUFBSSxPQUFPLFFBQVEsWUFBWTtBQUM3QixTQUFLO0FBQ0wsV0FBTyxDQUFBO0FBQUEsRUFDUjtBQUVELE9BQUssS0FBSyxNQUFNO0FBQ2hCLE1BQUksTUFBTyxPQUFPLE1BQU0sYUFBYyxLQUFLLEdBQUcsT0FBTyxXQUFXO0FBQUE7QUFDaEUsTUFBSSxPQUFPLEdBQUcsUUFBUSxXQUFXO0FBQUEsRUFBQTtBQUVqQyxZQUFVLE1BQU0sS0FBSyxNQUFNQSxTQUFRLElBQUlBLE9BQU07QUFDL0M7QUFHQW1CLFdBQVMsV0FBVztBQUFBLEVBQ2xCLGlCQUFpQjtBQUFBLEVBQ2pCLE9BQU87QUFBQSxFQUNQLFVBQVU7QUFBQSxFQUNWLHNCQUFzQjtBQUFBLEVBQ3RCLGVBQWU7QUFBQSxFQUNmLEtBQUs7QUFBQSxFQUNMLElBQUk7QUFBQSxFQUNKLE1BQU07QUFBQSxFQUNOLE1BQU07QUFDUjtBQUVBQSxXQUFTLGdCQUFnQjtBQUFBLEVBQ3ZCLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFDVDtBQUVBQSxXQUFTLGdCQUFnQjtBQUFBLEVBQ3ZCLE9BQU87QUFBQSxFQUNQLGFBQWE7QUFBQSxFQUNiLFlBQVk7QUFBQSxFQUNaLG1CQUFtQjtBQUFBLEVBQ25CLGNBQWM7QUFDaEI7QUFFQUEsV0FBUyxlQUFlO0FBQUEsRUFDdEIsU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sT0FBTztBQUFBLEVBQ1AsVUFBVTtBQUFBLEVBQ1YsU0FBUztBQUFBLEVBQ1QsU0FBUztBQUFBLEVBQ1Qsa0JBQWtCO0FBQUEsRUFDbEIsa0JBQWtCO0FBQUEsRUFDbEIsWUFBWTtBQUFBLEVBQ1osV0FBVztBQUFBLEVBQ1gsV0FBVztBQUFBLEVBQ1gsU0FBUztBQUFBLEVBQ1QsUUFBUTtBQUFBLEVBQ1IsVUFBVTtBQUFBLEVBQ1YsVUFBVTtBQUFBLEVBQ1YsYUFBYTtBQUFBLEVBQ2IsZUFBZTtBQUFBLEVBQ2YsZUFBZTtBQUNqQjtBQUdBLFNBQVMsVUFBVSxNQUFNLEtBQUssTUFBTW5CLFNBQVEsU0FBUyxZQUFZLGVBQWUsZUFBZSxjQUFjLFVBQVU7QUFDckgsTUFBSUEsV0FBVSxPQUFPQSxXQUFVLFlBQVksQ0FBQyxNQUFNLFFBQVFBLE9BQU0sR0FBRztBQUNqRSxRQUFJQSxTQUFRLFNBQVMsWUFBWSxlQUFlLGVBQWUsY0FBYyxRQUFRO0FBQ3JGLGFBQVMsT0FBT0EsU0FBUTtBQUN0QixVQUFJLE1BQU1BLFFBQU8sR0FBRztBQUNwQixVQUFJLE1BQU0sUUFBUSxHQUFHLEdBQUc7QUFDdEIsWUFBSSxPQUFPbUIsV0FBUyxlQUFlO0FBQ2pDLG1CQUFTLElBQUUsR0FBRyxJQUFFLElBQUksUUFBUTtBQUMxQixzQkFBVSxNQUFNLEtBQUssTUFBTSxJQUFJLENBQUMsR0FBRyxVQUFVLE1BQU0sTUFBTSxNQUFNLEdBQUcsWUFBWSxTQUFTLEtBQUtuQixTQUFRLENBQUM7QUFBQSxRQUN4RztBQUFBLE1BQ1QsV0FBaUIsT0FBT21CLFdBQVMsZUFBZTtBQUN4QyxZQUFJLE9BQU8sT0FBTyxPQUFPLFVBQVU7QUFDakMsbUJBQVMsUUFBUTtBQUNmLHNCQUFVLE1BQU0sS0FBSyxNQUFNLElBQUksSUFBSSxHQUFHLFVBQVUsTUFBTSxNQUFNLE1BQU0sY0FBYyxJQUFJLEdBQUcsWUFBWSxTQUFTLEtBQUtuQixTQUFRLElBQUk7QUFBQSxRQUNoSTtBQUFBLE1BQ0YsV0FBVSxPQUFPbUIsV0FBUyxZQUFhLEtBQUssV0FBVyxFQUFFLE9BQU9BLFdBQVMsZUFBZ0I7QUFDeEYsa0JBQVUsTUFBTSxLQUFLLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxZQUFZLFNBQVMsS0FBS25CLE9BQU07QUFBQSxNQUN0RjtBQUFBLElBQ0Y7QUFDRCxTQUFLQSxTQUFRLFNBQVMsWUFBWSxlQUFlLGVBQWUsY0FBYyxRQUFRO0FBQUEsRUFDdkY7QUFDSDtBQUdBLFNBQVMsY0FBYyxLQUFLO0FBQzFCLFNBQU8sSUFBSSxRQUFRLE1BQU0sSUFBSSxFQUFFLFFBQVEsT0FBTyxJQUFJO0FBQ3BEOztBQzNGQSxPQUFPLGVBQWV4SCxXQUFTLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUM1REEsVUFBQSxnQkFBd0JBLFVBQUEsYUFBcUJBLFVBQUEsY0FBc0JBLFVBQUEsZUFBdUJBLFVBQUEsY0FBc0JBLFVBQUEsWUFBb0I7QUFDcEksTUFBTStHLFdBQVN6RztBQUNmLE1BQU11SSxVQUFRaEo7QUFDZCxNQUFNLFdBQVdDO0FBRWpCLE1BQU0saUJBQWlCLG9CQUFJLElBQUk7QUFBQSxFQUMzQjtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUNKLENBQUM7QUFDRCxTQUFTLFVBQVUwSCxTQUFRbkIsU0FBUSxNQUFNO0FBQ3JDLE1BQUksT0FBT21CLFdBQVU7QUFDakIsV0FBTztBQUNYLE1BQUluQixXQUFVO0FBQ1YsV0FBTyxDQUFDLE9BQU9tQixPQUFNO0FBQ3pCLE1BQUksQ0FBQ25CO0FBQ0QsV0FBTztBQUNYLFNBQU8sVUFBVW1CLE9BQU0sS0FBS25CO0FBQ2hDO0FBQ2lCckcsVUFBQSxZQUFHO0FBQ3BCLE1BQU0sZUFBZSxvQkFBSSxJQUFJO0FBQUEsRUFDekI7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQ0osQ0FBQztBQUNELFNBQVMsT0FBT3dILFNBQVE7QUFDcEIsYUFBVyxPQUFPQSxTQUFRO0FBQ3RCLFFBQUksYUFBYSxJQUFJLEdBQUc7QUFDcEIsYUFBTztBQUNYLFVBQU0sTUFBTUEsUUFBTyxHQUFHO0FBQ3RCLFFBQUksTUFBTSxRQUFRLEdBQUcsS0FBSyxJQUFJLEtBQUssTUFBTTtBQUNyQyxhQUFPO0FBQ1gsUUFBSSxPQUFPLE9BQU8sWUFBWSxPQUFPLEdBQUc7QUFDcEMsYUFBTztBQUFBLEVBQ2Q7QUFDRCxTQUFPO0FBQ1g7QUFDQSxTQUFTLFVBQVVBLFNBQVE7QUFDdkIsTUFBSSxRQUFRO0FBQ1osYUFBVyxPQUFPQSxTQUFRO0FBQ3RCLFFBQUksUUFBUTtBQUNSLGFBQU87QUFDWDtBQUNBLFFBQUksZUFBZSxJQUFJLEdBQUc7QUFDdEI7QUFDSixRQUFJLE9BQU9BLFFBQU8sR0FBRyxLQUFLLFVBQVU7QUFDaEMsT0FBQSxHQUFJVCxTQUFPLFVBQVVTLFFBQU8sR0FBRyxHQUFHLENBQUMsUUFBUyxTQUFTLFVBQVUsR0FBRyxDQUFFO0FBQUEsSUFDdkU7QUFDRCxRQUFJLFVBQVU7QUFDVixhQUFPO0FBQUEsRUFDZDtBQUNELFNBQU87QUFDWDtBQUNBLFNBQVMsWUFBWSxVQUFVNUgsTUFBSyxJQUFJLFdBQVc7QUFDL0MsTUFBSSxjQUFjO0FBQ2QsSUFBQUEsTUFBSyxZQUFZQSxHQUFFO0FBQ3ZCLFFBQU0sSUFBSSxTQUFTLE1BQU1BLEdBQUU7QUFDM0IsU0FBTyxhQUFhLFVBQVUsQ0FBQztBQUNuQztBQUNtQkksVUFBQSxjQUFHO0FBQ3RCLFNBQVMsYUFBYSxVQUFVLEdBQUc7QUFDL0IsUUFBTSxhQUFhLFNBQVMsVUFBVSxDQUFDO0FBQ3ZDLFNBQU8sV0FBVyxNQUFNLEdBQUcsRUFBRSxDQUFDLElBQUk7QUFDdEM7QUFDb0JBLFVBQUEsZUFBRztBQUN2QixNQUFNLHNCQUFzQjtBQUM1QixTQUFTLFlBQVlKLEtBQUk7QUFDckIsU0FBT0EsTUFBS0EsSUFBRyxRQUFRLHFCQUFxQixFQUFFLElBQUk7QUFDdEQ7QUFDbUJJLFVBQUEsY0FBRztBQUN0QixTQUFTLFdBQVcsVUFBVSxRQUFRSixLQUFJO0FBQ3RDLEVBQUFBLE1BQUssWUFBWUEsR0FBRTtBQUNuQixTQUFPLFNBQVMsUUFBUSxRQUFRQSxHQUFFO0FBQ3RDO0FBQ2tCSSxVQUFBLGFBQUc7QUFDckIsTUFBTSxTQUFTO0FBQ2YsU0FBUyxjQUFjd0gsU0FBUSxRQUFRO0FBQ25DLE1BQUksT0FBT0EsV0FBVTtBQUNqQixXQUFPO0FBQ1gsUUFBTSxFQUFFLFVBQVUsZ0JBQWdCLEtBQUs7QUFDdkMsUUFBTSxRQUFRLFlBQVlBLFFBQU8sUUFBUSxLQUFLLE1BQU07QUFDcEQsUUFBTSxVQUFVLEVBQUUsSUFBSTtBQUN0QixRQUFNLGFBQWEsWUFBWSxhQUFhLE9BQU8sS0FBSztBQUN4RCxRQUFNLFlBQVksQ0FBQTtBQUNsQixRQUFNLGFBQWEsb0JBQUk7QUFDdkIsV0FBU0EsU0FBUSxFQUFFLFNBQVMsS0FBSSxHQUFJLENBQUMsS0FBSyxTQUFTLEdBQUcsa0JBQWtCO0FBQ3BFLFFBQUksa0JBQWtCO0FBQ2xCO0FBQ0osVUFBTSxXQUFXLGFBQWE7QUFDOUIsUUFBSXNCLFVBQVMsUUFBUSxhQUFhO0FBQ2xDLFFBQUksT0FBTyxJQUFJLFFBQVEsS0FBSztBQUN4QixNQUFBQSxVQUFTLE9BQU8sS0FBSyxNQUFNLElBQUksUUFBUSxDQUFDO0FBQzVDLGNBQVUsS0FBSyxNQUFNLElBQUksT0FBTztBQUNoQyxjQUFVLEtBQUssTUFBTSxJQUFJLGNBQWM7QUFDdkMsWUFBUSxPQUFPLElBQUlBO0FBQ25CLGFBQVMsT0FBT0MsTUFBSztBQUVqQixZQUFNLFdBQVcsS0FBSyxLQUFLLFlBQVk7QUFDdkMsTUFBQUEsT0FBTSxZQUFZRCxVQUFTLFNBQVNBLFNBQVFDLElBQUcsSUFBSUEsSUFBRztBQUN0RCxVQUFJLFdBQVcsSUFBSUEsSUFBRztBQUNsQixjQUFNLFNBQVNBLElBQUc7QUFDdEIsaUJBQVcsSUFBSUEsSUFBRztBQUNsQixVQUFJLFdBQVcsS0FBSyxLQUFLQSxJQUFHO0FBQzVCLFVBQUksT0FBTyxZQUFZO0FBQ25CLG1CQUFXLEtBQUssS0FBSyxRQUFRO0FBQ2pDLFVBQUksT0FBTyxZQUFZLFVBQVU7QUFDN0IseUJBQWlCLEtBQUssU0FBUyxRQUFRQSxJQUFHO0FBQUEsTUFDN0MsV0FDUUEsU0FBUSxZQUFZLFFBQVEsR0FBRztBQUNwQyxZQUFJQSxLQUFJLENBQUMsTUFBTSxLQUFLO0FBQ2hCLDJCQUFpQixLQUFLLFVBQVVBLElBQUcsR0FBR0EsSUFBRztBQUN6QyxvQkFBVUEsSUFBRyxJQUFJO0FBQUEsUUFDcEIsT0FDSTtBQUNELGVBQUssS0FBS0EsSUFBRyxJQUFJO0FBQUEsUUFDcEI7QUFBQSxNQUNKO0FBQ0QsYUFBT0E7QUFBQSxJQUNWO0FBQ0QsYUFBUyxVQUFVLFFBQVE7QUFDdkIsVUFBSSxPQUFPLFVBQVUsVUFBVTtBQUMzQixZQUFJLENBQUMsT0FBTyxLQUFLLE1BQU07QUFDbkIsZ0JBQU0sSUFBSSxNQUFNLG1CQUFtQixNQUFNLEdBQUc7QUFDaEQsZUFBTyxLQUFLLE1BQU0sSUFBSSxNQUFNLEVBQUU7QUFBQSxNQUNqQztBQUFBLElBQ0o7QUFBQSxFQUNULENBQUs7QUFDRCxTQUFPO0FBQ1AsV0FBUyxpQkFBaUIsTUFBTSxNQUFNQSxNQUFLO0FBQ3ZDLFFBQUksU0FBUyxVQUFhLENBQUNGLFFBQU0sTUFBTSxJQUFJO0FBQ3ZDLFlBQU0sU0FBU0UsSUFBRztBQUFBLEVBQ3pCO0FBQ0QsV0FBUyxTQUFTQSxNQUFLO0FBQ25CLFdBQU8sSUFBSSxNQUFNLGNBQWNBLElBQUcsb0NBQW9DO0FBQUEsRUFDekU7QUFDTDtBQUNxQi9JLFVBQUEsZ0JBQUc7QUN4SnhCLE9BQU8sZUFBZSxVQUFTLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUM1RCxTQUFBLFVBQW9DLFNBQUEsNkNBQWtDO0FBQ3RFLE1BQU0sZUFBZU07QUFDckIsTUFBTTBJLGVBQWFuSjtBQUNuQixNQUFNLGtCQUFrQkM7QUFDeEIsTUFBTSxhQUFhRDtBQUNuQixNQUFNLGFBQWF5QjtBQUNuQixNQUFNLFlBQVk2QjtBQUNsQixNQUFNLGNBQWNDO0FBQ3BCLE1BQU1tRSxjQUFZM0M7QUFDbEIsTUFBTWdELFlBQVUvQztBQUNoQixNQUFNb0UsY0FBWXREO0FBQ2xCLE1BQU1vQixXQUFTbkI7QUFDZixNQUFNLFdBQVdzRDtBQUVqQixTQUFTLHFCQUFxQixJQUFJO0FBQzlCLE1BQUksWUFBWSxFQUFFLEdBQUc7QUFDakIsa0JBQWMsRUFBRTtBQUNoQixRQUFJLGtCQUFrQixFQUFFLEdBQUc7QUFDdkIsdUJBQWlCLEVBQUU7QUFDbkI7QUFBQSxJQUNIO0FBQUEsRUFDSjtBQUNELG1CQUFpQixJQUFJLE9BQU0sR0FBSSxhQUFhLHNCQUFzQixFQUFFLENBQUM7QUFDekU7QUFDNEIsU0FBQSx1QkFBRztBQUMvQixTQUFTLGlCQUFpQixFQUFFLEtBQUssY0FBYyxRQUFBMUIsU0FBUSxXQUFXLEtBQU0sR0FBRSxNQUFNO0FBQzVFLE1BQUksS0FBSyxLQUFLLEtBQUs7QUFDZixRQUFJLEtBQUssZUFBYyxHQUFJRCxZQUFVLEtBQU1LLFVBQVEsUUFBUSxJQUFJLEtBQUtBLFVBQVEsUUFBUSxNQUFNLElBQUksVUFBVSxRQUFRLE1BQU07QUFDbEgsVUFBSSxTQUFTTCxZQUFVLG1CQUFvQixjQUFjQyxTQUFRLElBQUksQ0FBQyxFQUFFO0FBQ3hFLDJCQUFxQixLQUFLLElBQUk7QUFDOUIsVUFBSSxLQUFLLElBQUk7QUFBQSxJQUN6QixDQUFTO0FBQUEsRUFDSixPQUNJO0FBQ0QsUUFBSSxLQUFLLGVBQWMsR0FBSUQsWUFBVSxLQUFNSyxVQUFRLFFBQVEsSUFBSSxLQUFLLGtCQUFrQixJQUFJLENBQUMsSUFBSSxVQUFVLFFBQVEsTUFBTSxJQUFJLEtBQUssY0FBY0osU0FBUSxJQUFJLENBQUMsRUFBRSxLQUFLLElBQUksQ0FBQztBQUFBLEVBQzFLO0FBQ0w7QUFDQSxTQUFTLGtCQUFrQixNQUFNO0FBQzdCLFVBQU8sR0FBSUQsWUFBVSxNQUFPSyxVQUFRLFFBQVEsWUFBWSxRQUFRQSxVQUFRLFFBQVEsVUFBVSxLQUFLQSxVQUFRLFFBQVEsa0JBQWtCLEtBQUtBLFVBQVEsUUFBUSxRQUFRLElBQUlBLFVBQVEsUUFBUSxJQUFJLEdBQUcsS0FBSyxjQUFpQkwsR0FBQUEsWUFBVSxPQUFRSyxVQUFRLFFBQVEsY0FBYyxRQUFRTCxZQUFVLEdBQUc7QUFDeFI7QUFDQSxTQUFTLHFCQUFxQixLQUFLLE1BQU07QUFDckMsTUFBSSxHQUFHSyxVQUFRLFFBQVEsUUFBUSxNQUFNO0FBQ2pDLFFBQUksSUFBSUEsVUFBUSxRQUFRLGVBQWMsR0FBSUwsWUFBVSxLQUFNSyxVQUFRLFFBQVEsTUFBTSxJQUFJQSxVQUFRLFFBQVEsWUFBWSxFQUFFO0FBQ2xILFFBQUksSUFBSUEsVUFBUSxRQUFRLGFBQVksR0FBSUwsWUFBVSxLQUFNSyxVQUFRLFFBQVEsTUFBTSxJQUFJQSxVQUFRLFFBQVEsVUFBVSxFQUFFO0FBQzlHLFFBQUksSUFBSUEsVUFBUSxRQUFRLHFCQUFvQixHQUFJTCxZQUFVLEtBQU1LLFVBQVEsUUFBUSxNQUFNLElBQUlBLFVBQVEsUUFBUSxrQkFBa0IsRUFBRTtBQUM5SCxRQUFJLElBQUlBLFVBQVEsUUFBUSxXQUFVLEdBQUlMLFlBQVUsS0FBTUssVUFBUSxRQUFRLE1BQU0sSUFBSUEsVUFBUSxRQUFRLFFBQVEsRUFBRTtBQUMxRyxRQUFJLEtBQUs7QUFDTCxVQUFJLElBQUlBLFVBQVEsUUFBUSxpQkFBZ0IsR0FBSUwsWUFBVSxLQUFNSyxVQUFRLFFBQVEsTUFBTSxJQUFJQSxVQUFRLFFBQVEsY0FBYyxFQUFFO0FBQUEsRUFDbEksR0FBTyxNQUFNO0FBQ0wsUUFBSSxJQUFJQSxVQUFRLFFBQVEsZUFBa0JMLEdBQUFBLFlBQVUsTUFBTztBQUMzRCxRQUFJLElBQUlLLFVBQVEsUUFBUSxhQUFnQkwsR0FBQUEsWUFBVSxhQUFjO0FBQ2hFLFFBQUksSUFBSUssVUFBUSxRQUFRLHFCQUF3QkwsR0FBQUEsWUFBVSxhQUFjO0FBQ3hFLFFBQUksSUFBSUssVUFBUSxRQUFRLFVBQVVBLFVBQVEsUUFBUSxJQUFJO0FBQ3RELFFBQUksS0FBSztBQUNMLFVBQUksSUFBSUEsVUFBUSxRQUFRLGlCQUFvQkwsR0FBQUEsWUFBVSxNQUFPO0FBQUEsRUFDekUsQ0FBSztBQUNMO0FBQ0EsU0FBUyxpQkFBaUIsSUFBSTtBQUMxQixRQUFNLEVBQUUsUUFBQUMsU0FBUSxNQUFNLElBQUcsSUFBSztBQUM5QixtQkFBaUIsSUFBSSxNQUFNO0FBQ3ZCLFFBQUksS0FBSyxZQUFZQSxRQUFPO0FBQ3hCLHFCQUFlLEVBQUU7QUFDckIsbUJBQWUsRUFBRTtBQUNqQixRQUFJLElBQUlJLFVBQVEsUUFBUSxTQUFTLElBQUk7QUFDckMsUUFBSSxJQUFJQSxVQUFRLFFBQVEsUUFBUSxDQUFDO0FBQ2pDLFFBQUksS0FBSztBQUNMLHFCQUFlLEVBQUU7QUFDckIsb0JBQWdCLEVBQUU7QUFDbEIsa0JBQWMsRUFBRTtBQUFBLEVBQ3hCLENBQUs7QUFDRDtBQUNKO0FBQ0EsU0FBUyxlQUFlLElBQUk7QUFFeEIsUUFBTSxFQUFFLEtBQUssYUFBYyxJQUFHO0FBQzlCLEtBQUcsWUFBWSxJQUFJLE1BQU0sY0FBYSxHQUFJTCxZQUFVLEtBQU0sWUFBWSxZQUFZO0FBQ2xGLE1BQUksT0FBT0EsWUFBVSxLQUFNLEdBQUcsU0FBUyxpQkFBaUIsTUFBTSxJQUFJLFdBQVdBLFlBQVUsS0FBTSxHQUFHLFNBQVMsV0FBY0EsR0FBQUEsWUFBVSxhQUFjLENBQUM7QUFDaEosTUFBSSxPQUFPQSxZQUFVLEtBQU0sR0FBRyxTQUFTLGlCQUFpQixNQUFNLElBQUksV0FBV0EsWUFBVSxLQUFNLEdBQUcsU0FBUyxXQUFjQSxHQUFBQSxZQUFVLGFBQWMsQ0FBQztBQUNwSjtBQUNBLFNBQVMsY0FBY0MsU0FBUSxNQUFNO0FBQ2pDLFFBQU0sUUFBUSxPQUFPQSxXQUFVLFlBQVlBLFFBQU8sS0FBSyxRQUFRO0FBQy9ELFNBQU8sVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssWUFBZUQsR0FBQUEsWUFBVSxtQkFBb0IsS0FBSyxRQUFRQSxZQUFVO0FBQ3ZIO0FBRUEsU0FBUyxjQUFjLElBQUlPLFFBQU87QUFDOUIsTUFBSSxZQUFZLEVBQUUsR0FBRztBQUNqQixrQkFBYyxFQUFFO0FBQ2hCLFFBQUksa0JBQWtCLEVBQUUsR0FBRztBQUN2Qix1QkFBaUIsSUFBSUEsTUFBSztBQUMxQjtBQUFBLElBQ0g7QUFBQSxFQUNKO0FBQ0QsR0FBQSxHQUFJLGFBQWEsbUJBQW1CLElBQUlBLE1BQUs7QUFDakQ7QUFDQSxTQUFTLGtCQUFrQixFQUFFLFFBQUFOLFNBQVEsTUFBQXJHLFNBQVE7QUFDekMsTUFBSSxPQUFPcUcsV0FBVTtBQUNqQixXQUFPLENBQUNBO0FBQ1osYUFBVyxPQUFPQTtBQUNkLFFBQUlyRyxNQUFLLE1BQU0sSUFBSSxHQUFHO0FBQ2xCLGFBQU87QUFDZixTQUFPO0FBQ1g7QUFDQSxTQUFTLFlBQVksSUFBSTtBQUNyQixTQUFPLE9BQU8sR0FBRyxVQUFVO0FBQy9CO0FBQ0EsU0FBUyxpQkFBaUIsSUFBSTJHLFFBQU87QUFDakMsUUFBTSxFQUFFLFFBQUFOLFNBQVEsS0FBSyxLQUFJLElBQUs7QUFDOUIsTUFBSSxLQUFLLFlBQVlBLFFBQU87QUFDeEIsbUJBQWUsRUFBRTtBQUNyQixnQkFBYyxFQUFFO0FBQ2hCLG1CQUFpQixFQUFFO0FBQ25CLFFBQU0sWUFBWSxJQUFJLE1BQU0sU0FBU0ksVUFBUSxRQUFRLE1BQU07QUFDM0Qsa0JBQWdCLElBQUksU0FBUztBQUU3QixNQUFJLElBQUlFLFNBQVdQLEdBQUFBLFlBQVUsS0FBTSxTQUFTLFFBQVFLLFVBQVEsUUFBUSxNQUFNLEVBQUU7QUFDaEY7QUFDQSxTQUFTLGNBQWMsSUFBSTtBQUN2QixNQUFJYixTQUFPLG1CQUFtQixFQUFFO0FBQ2hDLHVCQUFxQixFQUFFO0FBQzNCO0FBQ0EsU0FBUyxnQkFBZ0IsSUFBSSxXQUFXO0FBQ3BDLE1BQUksR0FBRyxLQUFLO0FBQ1IsV0FBTyxlQUFlLElBQUksQ0FBRSxHQUFFLE9BQU8sU0FBUztBQUNsRCxRQUFNa0IsVUFBUSxHQUFJZSxhQUFXLGdCQUFnQixHQUFHLE1BQU07QUFDdEQsUUFBTSxnQkFBZSxHQUFJQSxhQUFXLHdCQUF3QixJQUFJZixNQUFLO0FBQ3JFLGlCQUFlLElBQUlBLFFBQU8sQ0FBQyxjQUFjLFNBQVM7QUFDdEQ7QUFDQSxTQUFTLHFCQUFxQixJQUFJO0FBQzlCLFFBQU0sRUFBRSxRQUFBVCxTQUFRLGVBQWUsTUFBTSxNQUFBckcsTUFBSSxJQUFLO0FBQzlDLE1BQUlxRyxRQUFPLFFBQVEsS0FBSywwQkFBeUIsR0FBSVQsU0FBTyxzQkFBc0JTLFNBQVFyRyxNQUFLLEtBQUssR0FBRztBQUNuRyxJQUFBQSxNQUFLLE9BQU8sS0FBSyw2Q0FBNkMsYUFBYSxHQUFHO0FBQUEsRUFDakY7QUFDTDtBQUNBLFNBQVMsZUFBZSxJQUFJO0FBQ3hCLFFBQU0sRUFBRSxRQUFBcUcsU0FBUSxLQUFNLElBQUc7QUFDekIsTUFBSUEsUUFBTyxZQUFZLFVBQWEsS0FBSyxlQUFlLEtBQUssY0FBYztBQUN2RSxLQUFBLEdBQUlULFNBQU8saUJBQWlCLElBQUksdUNBQXVDO0FBQUEsRUFDMUU7QUFDTDtBQUNBLFNBQVMsY0FBYyxJQUFJO0FBQ3ZCLFFBQU0sUUFBUSxHQUFHLE9BQU8sR0FBRyxLQUFLLFFBQVE7QUFDeEMsTUFBSTtBQUNBLE9BQUcsYUFBYWtDLFlBQVUsWUFBWSxHQUFHLEtBQUssYUFBYSxHQUFHLFFBQVEsS0FBSztBQUNuRjtBQUNBLFNBQVMsaUJBQWlCLElBQUk7QUFDMUIsTUFBSSxHQUFHLE9BQU8sVUFBVSxDQUFDLEdBQUcsVUFBVTtBQUNsQyxVQUFNLElBQUksTUFBTSw2QkFBNkI7QUFDckQ7QUFDQSxTQUFTLGVBQWUsRUFBRSxLQUFLLFdBQVcsUUFBQXpCLFNBQVEsZUFBZSxRQUFRO0FBQ3JFLFFBQU0sTUFBTUEsUUFBTztBQUNuQixNQUFJLEtBQUssYUFBYSxNQUFNO0FBQ3hCLFFBQUksTUFBSyxHQUFJRCxZQUFVLEtBQU1LLFVBQVEsUUFBUSxJQUFJLGVBQWUsR0FBRyxHQUFHO0FBQUEsRUFDekUsV0FDUSxPQUFPLEtBQUssWUFBWSxZQUFZO0FBQ3pDLFVBQU0sY0FBYSxHQUFJTCxZQUFVLE9BQVEsYUFBYTtBQUN0RCxVQUFNLFdBQVcsSUFBSSxXQUFXLFFBQVEsRUFBRSxLQUFLLFVBQVUsS0FBSSxDQUFFO0FBQy9ELFFBQUksU0FBU0EsWUFBVSxLQUFNSyxVQUFRLFFBQVEsSUFBSSxrQkFBa0IsR0FBRyxLQUFLLFVBQVUsS0FBSyxRQUFRLFVBQVU7QUFBQSxFQUMvRztBQUNMO0FBQ0EsU0FBUyxjQUFjLElBQUk7QUFDdkIsUUFBTSxFQUFFLEtBQUssV0FBVyxjQUFjLGlCQUFBdUIsa0JBQWlCLEtBQU0sSUFBRztBQUNoRSxNQUFJLFVBQVUsUUFBUTtBQUVsQixRQUFJLElBQUcsR0FBSTVCLFlBQVUsS0FBTUssVUFBUSxRQUFRLE1BQU0sVUFBVSxNQUFNLElBQUksT0FBT0EsVUFBUSxRQUFRLElBQUksR0FBRyxNQUFNLElBQUksT0FBVUwsR0FBQUEsWUFBVSxTQUFVNEIsZ0JBQWUsSUFBSXZCLFVBQVEsUUFBUSxPQUFPLEdBQUcsQ0FBQztBQUFBLEVBQzVMLE9BQ0k7QUFDRCxRQUFJLFdBQVdMLFlBQVUsS0FBTSxZQUFZLFdBQVdLLFVBQVEsUUFBUSxPQUFPO0FBQzdFLFFBQUksS0FBSztBQUNMLHNCQUFnQixFQUFFO0FBQ3RCLFFBQUksV0FBV0wsWUFBVSxLQUFNSyxVQUFRLFFBQVEsTUFBTSxRQUFRO0FBQUEsRUFDaEU7QUFDTDtBQUNBLFNBQVMsZ0JBQWdCLEVBQUUsS0FBSyxXQUFXLE9BQU8sT0FBQWxFLE9BQUssR0FBSTtBQUN2RCxNQUFJLGlCQUFpQjZELFlBQVU7QUFDM0IsUUFBSSxRQUFXQSxHQUFBQSxZQUFVLEtBQU0sU0FBUyxVQUFVLEtBQUs7QUFDM0QsTUFBSTdELGtCQUFpQjZELFlBQVU7QUFDM0IsUUFBSSxRQUFXQSxHQUFBQSxZQUFVLEtBQU0sU0FBUyxVQUFVN0QsTUFBSztBQUMvRDtBQUNBLFNBQVMsZUFBZSxJQUFJdUUsUUFBTyxZQUFZLFdBQVc7QUFDdEQsUUFBTSxFQUFFLEtBQUssUUFBQVQsU0FBUSxNQUFNLFdBQVcsTUFBTSxNQUFBckcsTUFBTSxJQUFHO0FBQ3JELFFBQU0sRUFBRSxNQUFPLElBQUdBO0FBQ2xCLE1BQUlxRyxRQUFPLFNBQVMsS0FBSyx5QkFBeUIsS0FBS1QsU0FBTyxzQkFBc0JTLFNBQVEsS0FBSyxJQUFJO0FBQ2pHLFFBQUksTUFBTSxNQUFNLFlBQVksSUFBSSxRQUFRLE1BQU0sSUFBSSxLQUFLLFVBQVUsQ0FBQztBQUNsRTtBQUFBLEVBQ0g7QUFDRCxNQUFJLENBQUMsS0FBSztBQUNOLHFCQUFpQixJQUFJUyxNQUFLO0FBQzlCLE1BQUksTUFBTSxNQUFNO0FBQ1osZUFBVyxTQUFTLE1BQU07QUFDdEIsb0JBQWMsS0FBSztBQUN2QixrQkFBYyxNQUFNLElBQUk7QUFBQSxFQUNoQyxDQUFLO0FBQ0QsV0FBUyxjQUFjLE9BQU87QUFDMUIsUUFBSSxFQUFDLEdBQUksZ0JBQWdCLGdCQUFnQlQsU0FBUSxLQUFLO0FBQ2xEO0FBQ0osUUFBSSxNQUFNLE1BQU07QUFDWixVQUFJLE9BQU8sV0FBVyxlQUFlLE1BQU0sTUFBTSxNQUFNLEtBQUssYUFBYSxDQUFDO0FBQzFFLHNCQUFnQixJQUFJLEtBQUs7QUFDekIsVUFBSVMsT0FBTSxXQUFXLEtBQUtBLE9BQU0sQ0FBQyxNQUFNLE1BQU0sUUFBUSxZQUFZO0FBQzdELFlBQUksS0FBSTtBQUNSLFlBQUksV0FBVyxpQkFBaUIsRUFBRTtBQUFBLE1BQ3JDO0FBQ0QsVUFBSSxNQUFLO0FBQUEsSUFDWixPQUNJO0FBQ0Qsc0JBQWdCLElBQUksS0FBSztBQUFBLElBQzVCO0FBRUQsUUFBSSxDQUFDO0FBQ0QsVUFBSSxJQUFHLEdBQUlWLFlBQVUsS0FBTUssVUFBUSxRQUFRLE1BQU0sUUFBUSxhQUFhLENBQUMsRUFBRTtBQUFBLEVBQ2hGO0FBQ0w7QUFDQSxTQUFTLGdCQUFnQixJQUFJLE9BQU87QUFDaEMsUUFBTSxFQUFFLEtBQUssUUFBQUosU0FBUSxNQUFNLEVBQUUsWUFBVyxFQUFLLElBQUc7QUFDaEQsTUFBSTtBQUNBLEtBQUEsR0FBSSxXQUFXLGdCQUFnQixJQUFJLE1BQU0sSUFBSTtBQUNqRCxNQUFJLE1BQU0sTUFBTTtBQUNaLGVBQVcsUUFBUSxNQUFNLE9BQU87QUFDNUIsV0FBUSxHQUFBLGdCQUFnQixlQUFlQSxTQUFRLElBQUksR0FBRztBQUNsRCxvQkFBWSxJQUFJLEtBQUssU0FBUyxLQUFLLFlBQVksTUFBTSxJQUFJO0FBQUEsTUFDNUQ7QUFBQSxJQUNKO0FBQUEsRUFDVCxDQUFLO0FBQ0w7QUFDQSxTQUFTLGlCQUFpQixJQUFJUyxRQUFPO0FBQ2pDLE1BQUksR0FBRyxVQUFVLFFBQVEsQ0FBQyxHQUFHLEtBQUs7QUFDOUI7QUFDSixvQkFBa0IsSUFBSUEsTUFBSztBQUMzQixNQUFJLENBQUMsR0FBRyxLQUFLO0FBQ1QsdUJBQW1CLElBQUlBLE1BQUs7QUFDaEMsb0JBQWtCLElBQUksR0FBRyxTQUFTO0FBQ3RDO0FBQ0EsU0FBUyxrQkFBa0IsSUFBSUEsUUFBTztBQUNsQyxNQUFJLENBQUNBLE9BQU07QUFDUDtBQUNKLE1BQUksQ0FBQyxHQUFHLFVBQVUsUUFBUTtBQUN0QixPQUFHLFlBQVlBO0FBQ2Y7QUFBQSxFQUNIO0FBQ0QsRUFBQUEsT0FBTSxRQUFRLENBQUNDLE9BQU07QUFDakIsUUFBSSxDQUFDLGFBQWEsR0FBRyxXQUFXQSxFQUFDLEdBQUc7QUFDaEMsdUJBQWlCLElBQUksU0FBU0EsRUFBQyw2QkFBNkIsR0FBRyxVQUFVLEtBQUssR0FBRyxDQUFDLEdBQUc7QUFBQSxJQUN4RjtBQUFBLEVBQ1QsQ0FBSztBQUNELG9CQUFrQixJQUFJRCxNQUFLO0FBQy9CO0FBQ0EsU0FBUyxtQkFBbUIsSUFBSSxJQUFJO0FBQ2hDLE1BQUksR0FBRyxTQUFTLEtBQUssRUFBRSxHQUFHLFdBQVcsS0FBSyxHQUFHLFNBQVMsTUFBTSxJQUFJO0FBQzVELHFCQUFpQixJQUFJLGlEQUFpRDtBQUFBLEVBQ3pFO0FBQ0w7QUFDQSxTQUFTLGtCQUFrQixJQUFJLElBQUk7QUFDL0IsUUFBTVIsU0FBUSxHQUFHLEtBQUssTUFBTTtBQUM1QixhQUFXQyxZQUFXRCxRQUFPO0FBQ3pCLFVBQU0sT0FBT0EsT0FBTUMsUUFBTztBQUMxQixRQUFJLE9BQU8sUUFBUSxhQUFnQixHQUFBLGdCQUFnQixlQUFlLEdBQUcsUUFBUSxJQUFJLEdBQUc7QUFDaEYsWUFBTSxFQUFFLE1BQUFoRCxNQUFJLElBQUssS0FBSztBQUN0QixVQUFJQSxNQUFLLFVBQVUsQ0FBQ0EsTUFBSyxLQUFLLENBQUN3RCxPQUFNLGtCQUFrQixJQUFJQSxFQUFDLENBQUMsR0FBRztBQUM1RCx5QkFBaUIsSUFBSSxpQkFBaUJ4RCxNQUFLLEtBQUssR0FBRyxDQUFDLGtCQUFrQmdELFFBQU8sR0FBRztBQUFBLE1BQ25GO0FBQUEsSUFDSjtBQUFBLEVBQ0o7QUFDTDtBQUNBLFNBQVMsa0JBQWtCLE9BQU8sTUFBTTtBQUNwQyxTQUFPLE1BQU0sU0FBUyxJQUFJLEtBQU0sU0FBUyxZQUFZLE1BQU0sU0FBUyxTQUFTO0FBQ2pGO0FBQ0EsU0FBUyxhQUFhLElBQUlRLElBQUc7QUFDekIsU0FBTyxHQUFHLFNBQVNBLEVBQUMsS0FBTUEsT0FBTSxhQUFhLEdBQUcsU0FBUyxRQUFRO0FBQ3JFO0FBQ0EsU0FBUyxrQkFBa0IsSUFBSSxXQUFXO0FBQ3RDLFFBQU0sS0FBSyxDQUFBO0FBQ1gsYUFBV0EsTUFBSyxHQUFHLFdBQVc7QUFDMUIsUUFBSSxhQUFhLFdBQVdBLEVBQUM7QUFDekIsU0FBRyxLQUFLQSxFQUFDO0FBQUEsYUFDSixVQUFVLFNBQVMsU0FBUyxLQUFLQSxPQUFNO0FBQzVDLFNBQUcsS0FBSyxTQUFTO0FBQUEsRUFDeEI7QUFDRCxLQUFHLFlBQVk7QUFDbkI7QUFDQSxTQUFTLGlCQUFpQixJQUFJLEtBQUs7QUFDL0IsUUFBTSxhQUFhLEdBQUcsVUFBVSxTQUFTLEdBQUc7QUFDNUMsU0FBTyxRQUFRLFVBQVU7QUFDekIsR0FBSW5CLEdBQUFBLFNBQU8saUJBQWlCLElBQUksS0FBSyxHQUFHLEtBQUssV0FBVztBQUM1RDtBQUNBLE1BQU0sV0FBVztBQUFBLEVBQ2IsWUFBWSxJQUFJSyxNQUFLTSxVQUFTO0FBQzFCLEtBQUEsR0FBSSxVQUFVLHNCQUFzQixJQUFJTixNQUFLTSxRQUFPO0FBQ3BELFNBQUssTUFBTSxHQUFHO0FBQ2QsU0FBSyxZQUFZLEdBQUc7QUFDcEIsU0FBSyxVQUFVQTtBQUNmLFNBQUssT0FBTyxHQUFHO0FBQ2YsU0FBSyxTQUFTLEdBQUcsT0FBT0EsUUFBTztBQUMvQixTQUFLLFFBQVFOLEtBQUksU0FBUyxHQUFHLEtBQUssU0FBUyxLQUFLLFVBQVUsS0FBSyxPQUFPO0FBQ3RFLFNBQUssa0JBQWtCTCxTQUFPLGdCQUFnQixJQUFJLEtBQUssUUFBUVcsVUFBUyxLQUFLLEtBQUs7QUFDbEYsU0FBSyxhQUFhTixLQUFJO0FBQ3RCLFNBQUssZUFBZSxHQUFHO0FBQ3ZCLFNBQUssU0FBUztBQUNkLFNBQUssS0FBSztBQUNWLFNBQUssTUFBTUE7QUFDWCxRQUFJLEtBQUssT0FBTztBQUNaLFdBQUssYUFBYSxHQUFHLElBQUksTUFBTSxXQUFXLFFBQVEsS0FBSyxPQUFPLEVBQUUsQ0FBQztBQUFBLElBQ3BFLE9BQ0k7QUFDRCxXQUFLLGFBQWEsS0FBSztBQUN2QixVQUFJLEVBQUMsR0FBSSxVQUFVLGlCQUFpQixLQUFLLFFBQVFBLEtBQUksWUFBWUEsS0FBSSxjQUFjLEdBQUc7QUFDbEYsY0FBTSxJQUFJLE1BQU0sR0FBR00sUUFBTyxrQkFBa0IsS0FBSyxVQUFVTixLQUFJLFVBQVUsQ0FBQyxFQUFFO0FBQUEsTUFDL0U7QUFBQSxJQUNKO0FBQ0QsUUFBSSxVQUFVQSxPQUFNQSxLQUFJLGNBQWNBLEtBQUksV0FBVyxPQUFPO0FBQ3hELFdBQUssWUFBWSxHQUFHLElBQUksTUFBTSxTQUFTUSxVQUFRLFFBQVEsTUFBTTtBQUFBLElBQ2hFO0FBQUEsRUFDSjtBQUFBLEVBQ0QsT0FBTyxXQUFXLGVBQWUsWUFBWTtBQUN6QyxTQUFLLFlBQVcsR0FBSUwsWUFBVSxLQUFLLFNBQVMsR0FBRyxlQUFlLFVBQVU7QUFBQSxFQUMzRTtBQUFBLEVBQ0QsV0FBVyxXQUFXLGVBQWUsWUFBWTtBQUM3QyxTQUFLLElBQUksR0FBRyxTQUFTO0FBQ3JCLFFBQUk7QUFDQTs7QUFFQSxXQUFLLE1BQUs7QUFDZCxRQUFJLGVBQWU7QUFDZixXQUFLLElBQUk7QUFDVDtBQUNBLFVBQUksS0FBSztBQUNMLGFBQUssSUFBSTtJQUNoQixPQUNJO0FBQ0QsVUFBSSxLQUFLO0FBQ0wsYUFBSyxJQUFJOztBQUVULGFBQUssSUFBSTtJQUNoQjtBQUFBLEVBQ0o7QUFBQSxFQUNELEtBQUssV0FBVyxZQUFZO0FBQ3hCLFNBQUssWUFBVyxHQUFJQSxZQUFVLEtBQUssU0FBUyxHQUFHLFFBQVcsVUFBVTtBQUFBLEVBQ3ZFO0FBQUEsRUFDRCxLQUFLLFdBQVc7QUFDWixRQUFJLGNBQWMsUUFBVztBQUN6QixXQUFLLE1BQUs7QUFDVixVQUFJLENBQUMsS0FBSztBQUNOLGFBQUssSUFBSSxHQUFHLEtBQUs7QUFDckI7QUFBQSxJQUNIO0FBQ0QsU0FBSyxJQUFJLEdBQUcsU0FBUztBQUNyQixTQUFLLE1BQUs7QUFDVixRQUFJLEtBQUs7QUFDTCxXQUFLLElBQUk7O0FBRVQsV0FBSyxJQUFJO0VBQ2hCO0FBQUEsRUFDRCxVQUFVLFdBQVc7QUFDakIsUUFBSSxDQUFDLEtBQUs7QUFDTixhQUFPLEtBQUssS0FBSyxTQUFTO0FBQzlCLFVBQU0sRUFBRSxXQUFZLElBQUc7QUFDdkIsU0FBSyxNQUFTQSxHQUFBQSxZQUFVLEtBQU0sVUFBVSx1QkFBMEJBLEdBQUFBLFlBQVUsSUFBSSxLQUFLLGFBQVksR0FBSSxTQUFTLENBQUMsR0FBRztBQUFBLEVBQ3JIO0FBQUEsRUFDRCxNQUFNLFFBQVEsYUFBYSxZQUFZO0FBQ25DLFFBQUksYUFBYTtBQUNiLFdBQUssVUFBVSxXQUFXO0FBQzFCLFdBQUssT0FBTyxRQUFRLFVBQVU7QUFDOUIsV0FBSyxVQUFVLENBQUEsQ0FBRTtBQUNqQjtBQUFBLElBQ0g7QUFDRCxTQUFLLE9BQU8sUUFBUSxVQUFVO0FBQUEsRUFDakM7QUFBQSxFQUNELE9BQU8sUUFBUSxZQUFZO0FBRXZCLEtBQUMsU0FBUyxTQUFTLG1CQUFtQixTQUFTLGFBQWEsTUFBTSxLQUFLLElBQUksT0FBTyxVQUFVO0FBQUEsRUFDL0Y7QUFBQSxFQUNELGFBQWE7QUFDVCxRQUFJLFNBQVMsYUFBYSxNQUFNLEtBQUssSUFBSSxjQUFjLFNBQVMsaUJBQWlCO0FBQUEsRUFDcEY7QUFBQSxFQUNELFFBQVE7QUFDSixRQUFJLEtBQUssY0FBYztBQUNuQixZQUFNLElBQUksTUFBTSx5Q0FBeUM7QUFDN0QsS0FBSSxHQUFBLFNBQVMsa0JBQWtCLEtBQUssS0FBSyxLQUFLLFNBQVM7QUFBQSxFQUMxRDtBQUFBLEVBQ0QsR0FBRyxNQUFNO0FBQ0wsUUFBSSxDQUFDLEtBQUs7QUFDTixXQUFLLElBQUksR0FBRyxJQUFJO0FBQUEsRUFDdkI7QUFBQSxFQUNELFVBQVUsS0FBSyxRQUFRO0FBQ25CLFFBQUk7QUFDQSxhQUFPLE9BQU8sS0FBSyxRQUFRLEdBQUc7QUFBQTtBQUU5QixXQUFLLFNBQVM7QUFBQSxFQUNyQjtBQUFBLEVBQ0QsV0FBV08sUUFBTyxXQUFXLGFBQWFQLFlBQVUsS0FBSztBQUNyRCxTQUFLLElBQUksTUFBTSxNQUFNO0FBQ2pCLFdBQUssV0FBV08sUUFBTyxVQUFVO0FBQ2pDO0lBQ1osQ0FBUztBQUFBLEVBQ0o7QUFBQSxFQUNELFdBQVdBLFNBQVFQLFlBQVUsS0FBSyxhQUFhQSxZQUFVLEtBQUs7QUFDMUQsUUFBSSxDQUFDLEtBQUs7QUFDTjtBQUNKLFVBQU0sRUFBRSxLQUFLLFlBQVksWUFBWSxLQUFBSCxLQUFHLElBQUs7QUFDN0MsUUFBSSxJQUFHLEdBQUlHLFlBQVUsS0FBSSxHQUFJQSxZQUFVLEtBQU0sVUFBVSxrQkFBa0IsVUFBVSxDQUFDO0FBQ3BGLFFBQUlPLFdBQVVQLFlBQVU7QUFDcEIsVUFBSSxPQUFPTyxRQUFPLElBQUk7QUFDMUIsUUFBSSxXQUFXLFVBQVVWLEtBQUksZ0JBQWdCO0FBQ3pDLFVBQUksT0FBTyxLQUFLLGFBQWMsQ0FBQTtBQUM5QixXQUFLLFdBQVU7QUFDZixVQUFJVSxXQUFVUCxZQUFVO0FBQ3BCLFlBQUksT0FBT08sUUFBTyxLQUFLO0FBQUEsSUFDOUI7QUFDRCxRQUFJLEtBQUk7QUFBQSxFQUNYO0FBQUEsRUFDRCxlQUFlO0FBQ1gsVUFBTSxFQUFFLEtBQUssWUFBWSxZQUFZLEtBQUFWLE1BQUssR0FBSSxJQUFHO0FBQ2pELFlBQU8sR0FBSUcsWUFBVSxJQUFJLGVBQWMsR0FBSSxtQkFBb0IsQ0FBQTtBQUMvRCxhQUFTLGlCQUFpQjtBQUN0QixVQUFJLFdBQVcsUUFBUTtBQUVuQixZQUFJLEVBQUUsc0JBQXNCQSxZQUFVO0FBQ2xDLGdCQUFNLElBQUksTUFBTSwwQkFBMEI7QUFDOUMsY0FBTSxLQUFLLE1BQU0sUUFBUSxVQUFVLElBQUksYUFBYSxDQUFDLFVBQVU7QUFDL0QsZ0JBQU8sR0FBSUEsWUFBVSxNQUFVLEdBQUEsV0FBVyxnQkFBZ0IsSUFBSSxZQUFZLEdBQUcsS0FBSyxlQUFlLFdBQVcsU0FBUyxLQUFLLENBQUM7QUFBQSxNQUM5SDtBQUNELGFBQU9BLFlBQVU7QUFBQSxJQUNwQjtBQUNELGFBQVMscUJBQXFCO0FBQzFCLFVBQUlILEtBQUksZ0JBQWdCO0FBQ3BCLGNBQU0sb0JBQW9CLElBQUksV0FBVyxpQkFBaUIsRUFBRSxLQUFLQSxLQUFJLGVBQWMsQ0FBRTtBQUNyRixnQkFBV0csR0FBQUEsWUFBVSxNQUFPLGlCQUFpQixJQUFJLFVBQVU7QUFBQSxNQUM5RDtBQUNELGFBQU9BLFlBQVU7QUFBQSxJQUNwQjtBQUFBLEVBQ0o7QUFBQSxFQUNELFVBQVUsTUFBTU8sUUFBTztBQUNuQixVQUFNWSxjQUFZLEdBQUksWUFBWSxjQUFjLEtBQUssSUFBSSxJQUFJO0FBQzdELEtBQUksR0FBQSxZQUFZLHFCQUFxQkEsWUFBVyxLQUFLLElBQUksSUFBSTtBQUM3RCxLQUFBLEdBQUksWUFBWSxxQkFBcUJBLFlBQVcsSUFBSTtBQUNwRCxVQUFNLGNBQWMsRUFBRSxHQUFHLEtBQUssSUFBSSxHQUFHQSxZQUFXLE9BQU8sUUFBVyxPQUFPO0FBQ3pFLGtCQUFjLGFBQWFaLE1BQUs7QUFDaEMsV0FBTztBQUFBLEVBQ1Y7QUFBQSxFQUNELGVBQWUsV0FBVyxRQUFRO0FBQzlCLFVBQU0sRUFBRSxJQUFJLElBQUssSUFBRztBQUNwQixRQUFJLENBQUMsR0FBRyxLQUFLO0FBQ1Q7QUFDSixRQUFJLEdBQUcsVUFBVSxRQUFRLFVBQVUsVUFBVSxRQUFXO0FBQ3BELFNBQUcsUUFBUWYsU0FBTyxlQUFlLE1BQU0sS0FBSyxVQUFVLE9BQU8sR0FBRyxPQUFPLE1BQU07QUFBQSxJQUNoRjtBQUNELFFBQUksR0FBRyxVQUFVLFFBQVEsVUFBVSxVQUFVLFFBQVc7QUFDcEQsU0FBRyxRQUFRQSxTQUFPLGVBQWUsTUFBTSxLQUFLLFVBQVUsT0FBTyxHQUFHLE9BQU8sTUFBTTtBQUFBLElBQ2hGO0FBQUEsRUFDSjtBQUFBLEVBQ0Qsb0JBQW9CLFdBQVdlLFFBQU87QUFDbEMsVUFBTSxFQUFFLElBQUksSUFBSyxJQUFHO0FBQ3BCLFFBQUksR0FBRyxLQUFLLGdCQUFnQixHQUFHLFVBQVUsUUFBUSxHQUFHLFVBQVUsT0FBTztBQUNqRSxVQUFJLEdBQUdBLFFBQU8sTUFBTSxLQUFLLGVBQWUsV0FBV1AsWUFBVSxJQUFJLENBQUM7QUFDbEUsYUFBTztBQUFBLElBQ1Y7QUFBQSxFQUNKO0FBQ0w7QUFDa0IsU0FBQSxhQUFHO0FBQ3JCLFNBQVMsWUFBWSxJQUFJRyxVQUFTTixNQUFLLFVBQVU7QUFDN0MsUUFBTSxNQUFNLElBQUksV0FBVyxJQUFJQSxNQUFLTSxRQUFPO0FBQzNDLE1BQUksVUFBVU4sTUFBSztBQUNmLElBQUFBLEtBQUksS0FBSyxLQUFLLFFBQVE7QUFBQSxFQUN6QixXQUNRLElBQUksU0FBU0EsS0FBSSxVQUFVO0FBQ2hDLEtBQUEsR0FBSSxVQUFVLGlCQUFpQixLQUFLQSxJQUFHO0FBQUEsRUFDMUMsV0FDUSxXQUFXQSxNQUFLO0FBQ3JCLEtBQUEsR0FBSSxVQUFVLGtCQUFrQixLQUFLQSxJQUFHO0FBQUEsRUFDM0MsV0FDUUEsS0FBSSxXQUFXQSxLQUFJLFVBQVU7QUFDbEMsS0FBQSxHQUFJLFVBQVUsaUJBQWlCLEtBQUtBLElBQUc7QUFBQSxFQUMxQztBQUNMO0FBQ0EsTUFBTSxlQUFlO0FBQ3JCLE1BQU0sd0JBQXdCO0FBQzlCLFNBQVMsUUFBUSxPQUFPLEVBQUUsV0FBVyxXQUFXLFlBQVcsR0FBSTtBQUMzRCxNQUFJO0FBQ0osTUFBSTtBQUNKLE1BQUksVUFBVTtBQUNWLFdBQU9RLFVBQVEsUUFBUTtBQUMzQixNQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUs7QUFDbEIsUUFBSSxDQUFDLGFBQWEsS0FBSyxLQUFLO0FBQ3hCLFlBQU0sSUFBSSxNQUFNLHlCQUF5QixLQUFLLEVBQUU7QUFDcEQsa0JBQWM7QUFDZCxXQUFPQSxVQUFRLFFBQVE7QUFBQSxFQUMxQixPQUNJO0FBQ0QsVUFBTSxVQUFVLHNCQUFzQixLQUFLLEtBQUs7QUFDaEQsUUFBSSxDQUFDO0FBQ0QsWUFBTSxJQUFJLE1BQU0seUJBQXlCLEtBQUssRUFBRTtBQUNwRCxVQUFNLEtBQUssQ0FBQyxRQUFRLENBQUM7QUFDckIsa0JBQWMsUUFBUSxDQUFDO0FBQ3ZCLFFBQUksZ0JBQWdCLEtBQUs7QUFDckIsVUFBSSxNQUFNO0FBQ04sY0FBTSxJQUFJLE1BQU0sU0FBUyxrQkFBa0IsRUFBRSxDQUFDO0FBQ2xELGFBQU8sWUFBWSxZQUFZLEVBQUU7QUFBQSxJQUNwQztBQUNELFFBQUksS0FBSztBQUNMLFlBQU0sSUFBSSxNQUFNLFNBQVMsUUFBUSxFQUFFLENBQUM7QUFDeEMsV0FBTyxVQUFVLFlBQVksRUFBRTtBQUMvQixRQUFJLENBQUM7QUFDRCxhQUFPO0FBQUEsRUFDZDtBQUNELE1BQUksT0FBTztBQUNYLFFBQU0sV0FBVyxZQUFZLE1BQU0sR0FBRztBQUN0QyxhQUFXLFdBQVcsVUFBVTtBQUM1QixRQUFJLFNBQVM7QUFDVCxjQUFPLEdBQUlMLFlBQVUsS0FBTSxJQUFJLElBQUcsR0FBSUEsWUFBVSxjQUFpQlIsR0FBQUEsU0FBTyxxQkFBcUIsT0FBTyxDQUFDLENBQUM7QUFDdEcsY0FBTyxHQUFJUSxZQUFVLEtBQU0sSUFBSSxPQUFPLElBQUk7QUFBQSxJQUM3QztBQUFBLEVBQ0o7QUFDRCxTQUFPO0FBQ1AsV0FBUyxTQUFTLGFBQWEsSUFBSTtBQUMvQixXQUFPLGlCQUFpQixXQUFXLElBQUksRUFBRSxnQ0FBZ0MsU0FBUztBQUFBLEVBQ3JGO0FBQ0w7QUFDZSxTQUFBLFVBQUc7O0FDcmdCbEIsT0FBTyxlQUFlLGtCQUFTLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUM1RCxNQUFNLHdCQUF3QixNQUFNO0FBQUEsRUFDaEMsWUFBWWlCLFNBQVE7QUFDaEIsVUFBTSxtQkFBbUI7QUFDekIsU0FBSyxTQUFTQTtBQUNkLFNBQUssTUFBTSxLQUFLLGFBQWE7QUFBQSxFQUNoQztBQUNMO0FBQ2UsaUJBQUEsVUFBRzs7QUNSbEIsT0FBTyxlQUFlLFdBQVMsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQzVELE1BQU1TLGNBQVkzSTtBQUNsQixNQUFNLHdCQUF3QixNQUFNO0FBQUEsRUFDaEMsWUFBWSxVQUFVLFFBQVF5SSxNQUFLLEtBQUs7QUFDcEMsVUFBTSxPQUFPLDJCQUEyQkEsSUFBRyxZQUFZLE1BQU0sRUFBRTtBQUMvRCxTQUFLLGlCQUFpQkUsWUFBVSxZQUFZLFVBQVUsUUFBUUYsSUFBRztBQUNqRSxTQUFLLG9CQUFvQkUsWUFBVSxjQUFhLEdBQUlBLFlBQVUsYUFBYSxVQUFVLEtBQUssVUFBVSxDQUFDO0FBQUEsRUFDeEc7QUFDTDtBQUNlLFVBQUEsVUFBRzs7QUNUbEIsT0FBTyxlQUFlLFNBQVMsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQ3ZDLFFBQUEsZ0JBQTZCLFFBQUEscUJBQXFCLFFBQUEsYUFBd0IsUUFBQSxnQkFBb0IsUUFBQSxZQUFHO0FBQ3RILE1BQU0xQixjQUFZakg7QUFDbEIsTUFBTSxxQkFBcUJUO0FBQzNCLE1BQU0rSCxZQUFVOUg7QUFDaEIsTUFBTSxZQUFZd0I7QUFDbEIsTUFBTXlGLFdBQVM1RDtBQUNmLE1BQU1pRyxlQUFhaEc7QUFDbkIsTUFBTSxVQUFVO0FBQUEsRUFDWixZQUFZc0QsTUFBSztBQUNiLFFBQUk7QUFDSixTQUFLLE9BQU87QUFDWixTQUFLLGlCQUFpQjtBQUN0QixRQUFJYztBQUNKLFFBQUksT0FBT2QsS0FBSSxVQUFVO0FBQ3JCLE1BQUFjLFVBQVNkLEtBQUk7QUFDakIsU0FBSyxTQUFTQSxLQUFJO0FBQ2xCLFNBQUssV0FBV0EsS0FBSTtBQUNwQixTQUFLLE9BQU9BLEtBQUksUUFBUTtBQUN4QixTQUFLLFVBQVUsS0FBS0EsS0FBSSxZQUFZLFFBQVEsT0FBTyxTQUFTLE1BQUssR0FBSSxVQUFVLGFBQWFjLFlBQVcsUUFBUUEsWUFBVyxTQUFTLFNBQVNBLFFBQU9kLEtBQUksWUFBWSxLQUFLLENBQUM7QUFDekssU0FBSyxhQUFhQSxLQUFJO0FBQ3RCLFNBQUssWUFBWUEsS0FBSTtBQUNyQixTQUFLLE9BQU9BLEtBQUk7QUFDaEIsU0FBSyxTQUFTYyxZQUFXLFFBQVFBLFlBQVcsU0FBUyxTQUFTQSxRQUFPO0FBQ3JFLFNBQUssT0FBTztFQUNmO0FBQ0w7QUFDaUIsUUFBQSxZQUFHO0FBSXBCLFNBQVMsY0FBYyxLQUFLO0FBRXhCLFFBQU0sT0FBTyxtQkFBbUIsS0FBSyxNQUFNLEdBQUc7QUFDOUMsTUFBSTtBQUNBLFdBQU87QUFDWCxRQUFNLFVBQVMsR0FBSSxVQUFVLGFBQWEsS0FBSyxLQUFLLGFBQWEsSUFBSSxLQUFLLE1BQU07QUFDaEYsUUFBTSxFQUFFLEtBQUssTUFBSyxJQUFLLEtBQUssS0FBSztBQUNqQyxRQUFNLEVBQUUsY0FBYSxJQUFLLEtBQUs7QUFDL0IsUUFBTSxNQUFNLElBQUlELFlBQVUsUUFBUSxLQUFLLE9BQU8sRUFBRSxLQUFLLE9BQU8sY0FBYSxDQUFFO0FBQzNFLE1BQUk7QUFDSixNQUFJLElBQUksUUFBUTtBQUNaLHVCQUFtQixJQUFJLFdBQVcsU0FBUztBQUFBLE1BQ3ZDLEtBQUssbUJBQW1CO0FBQUEsTUFDeEIsT0FBVUEsR0FBQUEsWUFBVTtBQUFBLElBQ2hDLENBQVM7QUFBQSxFQUNKO0FBQ0QsUUFBTSxlQUFlLElBQUksVUFBVSxVQUFVO0FBQzdDLE1BQUksZUFBZTtBQUNuQixRQUFNLFlBQVk7QUFBQSxJQUNkO0FBQUEsSUFDQSxXQUFXLEtBQUssS0FBSztBQUFBLElBQ3JCLE1BQU1LLFVBQVEsUUFBUTtBQUFBLElBQ3RCLFlBQVlBLFVBQVEsUUFBUTtBQUFBLElBQzVCLG9CQUFvQkEsVUFBUSxRQUFRO0FBQUEsSUFDcEMsV0FBVyxDQUFDQSxVQUFRLFFBQVEsSUFBSTtBQUFBLElBQ2hDLGFBQWEsQ0FBQ0wsWUFBVSxHQUFHO0FBQUEsSUFDM0IsV0FBVztBQUFBLElBQ1gsV0FBVyxDQUFFO0FBQUEsSUFDYixtQkFBbUIsb0JBQUksSUFBSztBQUFBLElBQzVCLGNBQWMsSUFBSSxXQUFXLFVBQVUsS0FBSyxLQUFLLEtBQUssV0FBVyxPQUMzRCxFQUFFLEtBQUssSUFBSSxRQUFRLE9BQVVBLEdBQUFBLFlBQVUsV0FBVyxJQUFJLE1BQU0sRUFBRyxJQUMvRCxFQUFFLEtBQUssSUFBSSxRQUFRO0FBQUEsSUFDekI7QUFBQSxJQUNBLGlCQUFpQjtBQUFBLElBQ2pCLFFBQVEsSUFBSTtBQUFBLElBQ1osV0FBVztBQUFBLElBQ1g7QUFBQSxJQUNBLFFBQVEsSUFBSSxVQUFVO0FBQUEsSUFDdEIsWUFBWUEsWUFBVTtBQUFBLElBQ3RCLGVBQWUsSUFBSSxlQUFlLEtBQUssS0FBSyxNQUFNLEtBQUs7QUFBQSxJQUN2RCxZQUFlQSxHQUFBQSxZQUFVO0FBQUEsSUFDekIsTUFBTSxLQUFLO0FBQUEsSUFDWCxNQUFNO0FBQUEsRUFDZDtBQUNJLE1BQUk7QUFDSixNQUFJO0FBQ0EsU0FBSyxjQUFjLElBQUksR0FBRztBQUMxQixLQUFDLEdBQUc2QixhQUFXLHNCQUFzQixTQUFTO0FBQzlDLFFBQUksU0FBUyxLQUFLLEtBQUssS0FBSyxRQUFRO0FBRXBDLFVBQU0sZUFBZSxJQUFJO0FBQ3pCLGlCQUFhLEdBQUcsSUFBSSxVQUFVeEIsVUFBUSxRQUFRLEtBQUssQ0FBQyxVQUFVLFlBQVk7QUFFMUUsUUFBSSxLQUFLLEtBQUssS0FBSztBQUNmLG1CQUFhLEtBQUssS0FBSyxLQUFLLFFBQVEsWUFBWSxHQUFHO0FBRXZELFVBQU0sZUFBZSxJQUFJLFNBQVMsR0FBR0EsVUFBUSxRQUFRLElBQUksSUFBSSxHQUFHQSxVQUFRLFFBQVEsS0FBSyxJQUFJLFVBQVU7QUFDbkcsVUFBTVcsWUFBVyxhQUFhLE1BQU0sS0FBSyxNQUFNLElBQUcsQ0FBRTtBQUNwRCxTQUFLLE1BQU0sTUFBTSxjQUFjLEVBQUUsS0FBS0EsVUFBUSxDQUFFO0FBQ2hELElBQUFBLFVBQVMsU0FBUztBQUNsQixJQUFBQSxVQUFTLFNBQVMsSUFBSTtBQUN0QixJQUFBQSxVQUFTLFlBQVk7QUFDckIsUUFBSSxJQUFJO0FBQ0osTUFBQUEsVUFBUyxTQUFTO0FBQ3RCLFFBQUksS0FBSyxLQUFLLEtBQUssV0FBVyxNQUFNO0FBQ2hDLE1BQUFBLFVBQVMsU0FBUyxFQUFFLGNBQWMsY0FBYyxhQUFhLElBQUk7SUFDcEU7QUFDRCxRQUFJLEtBQUssS0FBSyxhQUFhO0FBQ3ZCLFlBQU0sRUFBRSxPQUFPLE9BQUE3RSxPQUFPLElBQUc7QUFDekIsTUFBQTZFLFVBQVMsWUFBWTtBQUFBLFFBQ2pCLE9BQU8saUJBQWlCaEIsWUFBVSxPQUFPLFNBQVk7QUFBQSxRQUNyRCxPQUFPN0Qsa0JBQWlCNkQsWUFBVSxPQUFPLFNBQVk3RDtBQUFBLFFBQ3JELGNBQWMsaUJBQWlCNkQsWUFBVTtBQUFBLFFBQ3pDLGNBQWM3RCxrQkFBaUI2RCxZQUFVO0FBQUEsTUFDekQ7QUFDWSxVQUFJZ0IsVUFBUztBQUNULFFBQUFBLFVBQVMsT0FBTyxhQUFhLEdBQUdoQixZQUFVLFdBQVdnQixVQUFTLFNBQVM7QUFBQSxJQUM5RTtBQUNELFFBQUksV0FBV0E7QUFDZixXQUFPO0FBQUEsRUFDVixTQUNNLEdBQUc7QUFDTixXQUFPLElBQUk7QUFDWCxXQUFPLElBQUk7QUFDWCxRQUFJO0FBQ0EsV0FBSyxPQUFPLE1BQU0sMENBQTBDLFVBQVU7QUFFMUUsVUFBTTtBQUFBLEVBQ1QsVUFDTztBQUNKLFNBQUssY0FBYyxPQUFPLEdBQUc7QUFBQSxFQUNoQztBQUNMO0FBQ3FCLFFBQUEsZ0JBQUc7QUFDeEIsU0FBUyxXQUFXLE1BQU0sUUFBUVEsTUFBSztBQUNuQyxNQUFJO0FBQ0osRUFBQUEsUUFBTSxHQUFJLFVBQVUsWUFBWSxLQUFLLEtBQUssYUFBYSxRQUFRQSxJQUFHO0FBQ2xFLFFBQU0sWUFBWSxLQUFLLEtBQUtBLElBQUc7QUFDL0IsTUFBSTtBQUNBLFdBQU87QUFDWCxNQUFJLE9BQU8sUUFBUSxLQUFLLE1BQU0sTUFBTUEsSUFBRztBQUN2QyxNQUFJLFNBQVMsUUFBVztBQUNwQixVQUFNdkIsV0FBVSxLQUFLLEtBQUssZUFBZSxRQUFRLE9BQU8sU0FBUyxTQUFTLEdBQUd1QixJQUFHO0FBQ2hGLFVBQU0sRUFBRSxTQUFRLElBQUssS0FBSztBQUMxQixRQUFJdkI7QUFDQSxhQUFPLElBQUksVUFBVSxFQUFFLFFBQUFBLFNBQVEsVUFBVSxNQUFNLE9BQU0sQ0FBRTtBQUFBLEVBQzlEO0FBQ0QsTUFBSSxTQUFTO0FBQ1Q7QUFDSixTQUFRLEtBQUssS0FBS3VCLElBQUcsSUFBSSxnQkFBZ0IsS0FBSyxNQUFNLElBQUk7QUFDNUQ7QUFDa0IsUUFBQSxhQUFHO0FBQ3JCLFNBQVMsZ0JBQWdCLEtBQUs7QUFDMUIsT0FBSSxHQUFJLFVBQVUsV0FBVyxJQUFJLFFBQVEsS0FBSyxLQUFLLFVBQVU7QUFDekQsV0FBTyxJQUFJO0FBQ2YsU0FBTyxJQUFJLFdBQVcsTUFBTSxjQUFjLEtBQUssTUFBTSxHQUFHO0FBQzVEO0FBRUEsU0FBUyxtQkFBbUIsUUFBUTtBQUNoQyxhQUFXLE9BQU8sS0FBSyxlQUFlO0FBQ2xDLFFBQUksY0FBYyxLQUFLLE1BQU07QUFDekIsYUFBTztBQUFBLEVBQ2Q7QUFDTDtBQUMwQixRQUFBLHFCQUFHO0FBQzdCLFNBQVMsY0FBYyxJQUFJLElBQUk7QUFDM0IsU0FBTyxHQUFHLFdBQVcsR0FBRyxVQUFVLEdBQUcsU0FBUyxHQUFHLFFBQVEsR0FBRyxXQUFXLEdBQUc7QUFDOUU7QUFHQSxTQUFTLFFBQVEsTUFDakJBLE1BQ0U7QUFDRSxNQUFJO0FBQ0osU0FBTyxRQUFRLE1BQU0sS0FBSyxLQUFLQSxJQUFHLE1BQU07QUFDcEMsSUFBQUEsT0FBTTtBQUNWLFNBQU8sT0FBTyxLQUFLLFFBQVFBLElBQUcsS0FBSyxjQUFjLEtBQUssTUFBTSxNQUFNQSxJQUFHO0FBQ3pFO0FBRUEsU0FBUyxjQUFjLE1BQ3ZCQSxNQUNFO0FBQ0UsUUFBTSxJQUFJLEtBQUssS0FBSyxZQUFZLE1BQU1BLElBQUc7QUFDekMsUUFBTSxXQUFjLEdBQUEsVUFBVSxjQUFjLEtBQUssS0FBSyxhQUFhLENBQUM7QUFDcEUsTUFBSSxVQUFTLEdBQUksVUFBVSxhQUFhLEtBQUssS0FBSyxhQUFhLEtBQUssUUFBUSxNQUFTO0FBRXJGLE1BQUksT0FBTyxLQUFLLEtBQUssTUFBTSxFQUFFLFNBQVMsS0FBSyxZQUFZLFFBQVE7QUFDM0QsV0FBTyxlQUFlLEtBQUssTUFBTSxHQUFHLElBQUk7QUFBQSxFQUMzQztBQUNELFFBQU1uSixPQUFTLEdBQUEsVUFBVSxhQUFhLE9BQU87QUFDN0MsUUFBTSxXQUFXLEtBQUssS0FBS0EsR0FBRSxLQUFLLEtBQUssUUFBUUEsR0FBRTtBQUNqRCxNQUFJLE9BQU8sWUFBWSxVQUFVO0FBQzdCLFVBQU0sTUFBTSxjQUFjLEtBQUssTUFBTSxNQUFNLFFBQVE7QUFDbkQsUUFBSSxRQUFRLFFBQVEsUUFBUSxRQUFRLFNBQVMsU0FBUyxJQUFJLFlBQVk7QUFDbEU7QUFDSixXQUFPLGVBQWUsS0FBSyxNQUFNLEdBQUcsR0FBRztBQUFBLEVBQzFDO0FBQ0QsTUFBSSxRQUFRLGFBQWEsUUFBUSxhQUFhLFNBQVMsU0FBUyxTQUFTLFlBQVk7QUFDakY7QUFDSixNQUFJLENBQUMsU0FBUztBQUNWLGtCQUFjLEtBQUssTUFBTSxRQUFRO0FBQ3JDLE1BQUlBLFNBQVcsR0FBQSxVQUFVLGFBQWFtSixJQUFHLEdBQUc7QUFDeEMsVUFBTSxFQUFFLFFBQUF2QixRQUFRLElBQUc7QUFDbkIsVUFBTSxFQUFFLFNBQVEsSUFBSyxLQUFLO0FBQzFCLFVBQU0sUUFBUUEsUUFBTyxRQUFRO0FBQzdCLFFBQUk7QUFDQSxnQkFBUyxHQUFJLFVBQVUsWUFBWSxLQUFLLEtBQUssYUFBYSxRQUFRLEtBQUs7QUFDM0UsV0FBTyxJQUFJLFVBQVUsRUFBRSxRQUFBQSxTQUFRLFVBQVUsTUFBTSxPQUFNLENBQUU7QUFBQSxFQUMxRDtBQUNELFNBQU8sZUFBZSxLQUFLLE1BQU0sR0FBRyxRQUFRO0FBQ2hEO0FBQ3FCLFFBQUEsZ0JBQUc7QUFDeEIsTUFBTSx1QkFBdUIsb0JBQUksSUFBSTtBQUFBLEVBQ2pDO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUNKLENBQUM7QUFDRCxTQUFTLGVBQWUsV0FBVyxFQUFFLFFBQVEsUUFBQUEsU0FBUSxLQUFJLEdBQUk7QUFDekQsTUFBSTtBQUNKLFFBQU0sS0FBSyxVQUFVLGNBQWMsUUFBUSxPQUFPLFNBQVMsU0FBUyxHQUFHLENBQUMsT0FBTztBQUMzRTtBQUNKLGFBQVcsUUFBUSxVQUFVLFNBQVMsTUFBTSxDQUFDLEVBQUUsTUFBTSxHQUFHLEdBQUc7QUFDdkQsUUFBSSxPQUFPQSxZQUFXO0FBQ2xCO0FBQ0osVUFBTSxhQUFhQSxTQUFPLEdBQUlULFNBQU8sa0JBQWtCLElBQUksQ0FBQztBQUM1RCxRQUFJLGVBQWU7QUFDZjtBQUNKLElBQUFTLFVBQVM7QUFFVCxVQUFNLFFBQVEsT0FBT0EsWUFBVyxZQUFZQSxRQUFPLEtBQUssS0FBSyxRQUFRO0FBQ3JFLFFBQUksQ0FBQyxxQkFBcUIsSUFBSSxJQUFJLEtBQUssT0FBTztBQUMxQyxnQkFBUyxHQUFJLFVBQVUsWUFBWSxLQUFLLEtBQUssYUFBYSxRQUFRLEtBQUs7QUFBQSxJQUMxRTtBQUFBLEVBQ0o7QUFDRCxNQUFJZDtBQUNKLE1BQUksT0FBT2MsV0FBVSxhQUFhQSxRQUFPLFFBQVEsS0FBS1QsU0FBTyxzQkFBc0JTLFNBQVEsS0FBSyxLQUFLLEdBQUc7QUFDcEcsVUFBTSxRQUFPLEdBQUksVUFBVSxZQUFZLEtBQUssS0FBSyxhQUFhLFFBQVFBLFFBQU8sSUFBSTtBQUNqRixJQUFBZCxPQUFNLGNBQWMsS0FBSyxNQUFNLE1BQU0sSUFBSTtBQUFBLEVBQzVDO0FBR0QsUUFBTSxFQUFFLFNBQVEsSUFBSyxLQUFLO0FBQzFCLEVBQUFBLE9BQU1BLFFBQU8sSUFBSSxVQUFVLEVBQUUsUUFBQWMsU0FBUSxVQUFVLE1BQU0sT0FBTSxDQUFFO0FBQzdELE1BQUlkLEtBQUksV0FBV0EsS0FBSSxLQUFLO0FBQ3hCLFdBQU9BO0FBQ1gsU0FBTztBQUNYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvT0EsR0FBQyxTQUFVbEYsU0FBUSxTQUFTO0FBQ29DLFlBQVFZLFFBQU87QUFBQSxLQUc3RWlILGdCQUFPLFNBQVVqSCxVQUFTO0FBRTVCLGFBQVMsUUFBUTtBQUNiLGVBQVMsT0FBTyxVQUFVLFFBQVEsT0FBTyxNQUFNLElBQUksR0FBRyxPQUFPLEdBQUcsT0FBTyxNQUFNLFFBQVE7QUFDakYsYUFBSyxJQUFJLElBQUksVUFBVSxJQUFJO0FBQUEsTUFDOUI7QUFFRCxVQUFJLEtBQUssU0FBUyxHQUFHO0FBQ2pCLGFBQUssQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFLE1BQU0sR0FBRyxFQUFFO0FBQzdCLFlBQUksS0FBSyxLQUFLLFNBQVM7QUFDdkIsaUJBQVMsSUFBSSxHQUFHLElBQUksSUFBSSxFQUFFLEdBQUc7QUFDekIsZUFBSyxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUUsTUFBTSxHQUFHLEVBQUU7QUFBQSxRQUNoQztBQUNELGFBQUssRUFBRSxJQUFJLEtBQUssRUFBRSxFQUFFLE1BQU0sQ0FBQztBQUMzQixlQUFPLEtBQUssS0FBSyxFQUFFO0FBQUEsTUFDM0IsT0FBVztBQUNILGVBQU8sS0FBSyxDQUFDO0FBQUEsTUFDaEI7QUFBQSxJQUNKO0FBQ0QsYUFBUyxPQUFPLEtBQUs7QUFDakIsYUFBTyxRQUFRLE1BQU07QUFBQSxJQUN4QjtBQUNELGFBQVMsT0FBTyxHQUFHO0FBQ2YsYUFBTyxNQUFNLFNBQVksY0FBYyxNQUFNLE9BQU8sU0FBUyxPQUFPLFVBQVUsU0FBUyxLQUFLLENBQUMsRUFBRSxNQUFNLEdBQUcsRUFBRSxJQUFLLEVBQUMsTUFBTSxHQUFHLEVBQUUsUUFBUTtJQUN0STtBQUNELGFBQVMsWUFBWSxLQUFLO0FBQ3RCLGFBQU8sSUFBSTtJQUNkO0FBQ0QsYUFBUyxRQUFRLEtBQUs7QUFDbEIsYUFBTyxRQUFRLFVBQWEsUUFBUSxPQUFPLGVBQWUsUUFBUSxNQUFNLE9BQU8sSUFBSSxXQUFXLFlBQVksSUFBSSxTQUFTLElBQUksZUFBZSxJQUFJLE9BQU8sQ0FBQyxHQUFHLElBQUksTUFBTSxVQUFVLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQTtBQUFBLElBQ2xNO0FBQ0QsYUFBUyxPQUFPLFFBQVFrSCxTQUFRO0FBQzVCLFVBQUksTUFBTTtBQUNWLFVBQUlBLFNBQVE7QUFDUixpQkFBUyxPQUFPQSxTQUFRO0FBQ3BCLGNBQUksR0FBRyxJQUFJQSxRQUFPLEdBQUc7QUFBQSxRQUN4QjtBQUFBLE1BQ0o7QUFDRCxhQUFPO0FBQUEsSUFDVjtBQUVELGFBQVMsVUFBVSxPQUFPO0FBQ3RCLFVBQUksVUFBVSxZQUVWLFVBQVUsU0FFVkMsWUFBVyxNQUFNLFNBQVMsVUFBVSxHQUlwQ0MsZ0JBQWUsT0FBTyxPQUFPLFlBQVlELFlBQVcsTUFBTUEsWUFBV0EsWUFBVyxNQUFNQSxZQUFXQSxTQUFRLElBQUksTUFBTSxPQUFPLGdCQUFnQkEsWUFBVyxNQUFNQSxZQUFXQSxTQUFRLElBQUksTUFBTSxPQUFPLE1BQU1BLFlBQVdBLFNBQVEsQ0FBQyxHQUU3TixlQUFlLDJCQUNYLGVBQWUsdUNBQ2YsYUFBYSxNQUFNLGNBQWMsWUFBWSxHQUM3QyxZQUFZLFFBQVEsZ0ZBQWdGLE1BRXhHLGFBQWEsUUFBUSxzQkFBc0IsTUFFM0NFLGdCQUFlLE1BQU0sU0FBUyxTQUFTLGtCQUFrQixTQUFTO0FBQ3BELGFBQU8sVUFBVSxNQUFNLFNBQVMsU0FBUyxhQUFhLElBQUksR0FBRztBQUMzRCxhQUFPLE9BQU9ELGdCQUFlLE1BQU0sTUFBTUMsZUFBYyxjQUFjLE9BQU8sQ0FBQyxJQUFJLEdBQUc7QUFDeEcsVUFDUSxxQkFBcUIsT0FBTyxPQUFPLFNBQVMsSUFBSSxNQUFNLE9BQU8sV0FBVyxPQUFPLElBQUksTUFBTSxPQUFPLE1BQU0sVUFBVSxPQUFPLElBQUksTUFBTSxPQUFPLFlBQVksT0FBTyxJQUFJLFVBQVUsT0FBTyxHQUVwTCxlQUFlLE9BQU8scUJBQXFCLFFBQVEscUJBQXFCLFFBQVEscUJBQXFCLFFBQVEsa0JBQWtCLEdBQzNILE9BQU8sT0FBT0YsWUFBVyxPQUFPLEdBQ2hDLFFBQVEsT0FBTyxPQUFPLE9BQU8sUUFBUSxJQUFJLElBQUksTUFBTSxZQUFZLEdBQy9ELGdCQUFnQixPQUFPLE9BQU8sT0FBTyxLQUFLLElBQUksUUFBUSxLQUFLLEdBRS9ELGdCQUFnQixPQUFPLFdBQVcsT0FBTyxPQUFPLEtBQUssSUFBSSxRQUFRLEtBQUssR0FFdEUsZ0JBQWdCLE9BQU8sT0FBTyxJQUFJLElBQUksWUFBWSxPQUFPLE9BQU8sS0FBSyxJQUFJLFFBQVEsS0FBSyxHQUV0RixnQkFBZ0IsT0FBTyxPQUFPLE9BQU8sT0FBTyxLQUFLLElBQUksVUFBVSxJQUFJLElBQUksWUFBWSxPQUFPLE9BQU8sS0FBSyxJQUFJLFFBQVEsS0FBSyxHQUV2SCxnQkFBZ0IsT0FBTyxPQUFPLE9BQU8sT0FBTyxLQUFLLElBQUksVUFBVSxJQUFJLElBQUksWUFBWSxPQUFPLE9BQU8sS0FBSyxJQUFJLFFBQVEsS0FBSyxHQUV2SCxnQkFBZ0IsT0FBTyxPQUFPLE9BQU8sT0FBTyxLQUFLLElBQUksVUFBVSxJQUFJLElBQUksWUFBWSxPQUFPLFFBQVEsS0FBSyxHQUV2RyxnQkFBZ0IsT0FBTyxPQUFPLE9BQU8sT0FBTyxLQUFLLElBQUksVUFBVSxJQUFJLElBQUksWUFBWSxLQUFLLEdBRXhGLGdCQUFnQixPQUFPLE9BQU8sT0FBTyxPQUFPLEtBQUssSUFBSSxVQUFVLElBQUksSUFBSSxZQUFZLElBQUksR0FFdkYsZ0JBQWdCLE9BQU8sT0FBTyxPQUFPLE9BQU8sS0FBSyxJQUFJLFVBQVUsSUFBSSxJQUFJLFNBQVMsR0FFaEYsZUFBZSxPQUFPLENBQUMsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGFBQWEsRUFBRSxLQUFLLEdBQUcsQ0FBQyxHQUNuSyxVQUFVLE9BQU8sT0FBT0UsZ0JBQWUsTUFBTUQsYUFBWSxJQUFJLEdBQUc7QUFNdkQsYUFBTyxTQUFTRCxZQUFXLFNBQVMsTUFBTUUsZUFBYyxjQUFjLE9BQU8sSUFBSSxHQUFHO0FBR3JGLGFBQU8sT0FBT0QsZ0JBQWUsTUFBTSxNQUFNQyxlQUFjLFlBQVksQ0FBQyxJQUFJLEdBQUc7QUFDM0YsVUFHUSxTQUFTLE9BQU9ELGdCQUFlLE1BQU0sTUFBTUMsZUFBYyxjQUFjLFVBQVUsQ0FBQztBQUdqRSxhQUFPLE9BQU9ELGdCQUFlLE1BQU0sTUFBTUMsZUFBYyxjQUFjLE9BQU8sQ0FBQyxJQUFJLEdBQUc7QUFVNUYsYUFBTyxPQUFPLFNBQVMsTUFBTSxNQUFNLFlBQVksVUFBVSxDQUFDLElBQUksR0FBRztBQWE5RSxhQUFPO0FBQUEsUUFDSCxZQUFZLElBQUksT0FBTyxNQUFNLE9BQU8sU0FBUyxTQUFTLGFBQWEsR0FBRyxHQUFHO0FBQUEsUUFDekUsY0FBYyxJQUFJLE9BQU8sTUFBTSxhQUFhQSxlQUFjLFlBQVksR0FBRyxHQUFHO0FBQUEsUUFDNUUsVUFBVSxJQUFJLE9BQU8sTUFBTSxtQkFBbUJBLGVBQWMsWUFBWSxHQUFHLEdBQUc7QUFBQSxRQUM5RSxVQUFVLElBQUksT0FBTyxNQUFNLG1CQUFtQkEsZUFBYyxZQUFZLEdBQUcsR0FBRztBQUFBLFFBQzlFLG1CQUFtQixJQUFJLE9BQU8sTUFBTSxnQkFBZ0JBLGVBQWMsWUFBWSxHQUFHLEdBQUc7QUFBQSxRQUNwRixXQUFXLElBQUksT0FBTyxNQUFNLFVBQVVBLGVBQWMsY0FBYyxrQkFBa0IsVUFBVSxHQUFHLEdBQUc7QUFBQSxRQUNwRyxjQUFjLElBQUksT0FBTyxNQUFNLFVBQVVBLGVBQWMsY0FBYyxnQkFBZ0IsR0FBRyxHQUFHO0FBQUEsUUFDM0YsUUFBUSxJQUFJLE9BQU8sTUFBTSxPQUFPQSxlQUFjLFlBQVksR0FBRyxHQUFHO0FBQUEsUUFDaEUsWUFBWSxJQUFJLE9BQU9BLGVBQWMsR0FBRztBQUFBLFFBQ3hDLGFBQWEsSUFBSSxPQUFPLE1BQU0sVUFBVUEsZUFBYyxVQUFVLEdBQUcsR0FBRztBQUFBLFFBQ3RFLGFBQWEsSUFBSSxPQUFPRCxlQUFjLEdBQUc7QUFBQSxRQUN6QyxhQUFhLElBQUksT0FBTyxPQUFPLGVBQWUsSUFBSTtBQUFBLFFBQ2xELGFBQWEsSUFBSSxPQUFPLFdBQVcsZUFBZSxNQUFNLE9BQU8sT0FBTyxpQkFBaUJELFlBQVcsTUFBTSxJQUFJLE1BQU0sVUFBVSxHQUFHLElBQUksUUFBUTtBQUFBO0FBQUEsTUFDbko7QUFBQSxJQUNDO0FBQ0QsUUFBSSxlQUFlLFVBQVUsS0FBSztBQUVsQyxRQUFJLGVBQWUsVUFBVSxJQUFJO0FBRWpDLFFBQUksZ0JBQWdCLDJCQUFZO0FBQzlCLGVBQVMsY0FBYyxLQUFLLEdBQUc7QUFDN0IsWUFBSSxPQUFPLENBQUE7QUFDWCxZQUFJLEtBQUs7QUFDVCxZQUFJLEtBQUs7QUFDVCxZQUFJLEtBQUs7QUFFVCxZQUFJO0FBQ0YsbUJBQVMsS0FBSyxJQUFJLE9BQU8sUUFBUSxFQUFHLEdBQUUsSUFBSSxFQUFFLE1BQU0sS0FBSyxHQUFHLEtBQUksR0FBSSxPQUFPLEtBQUssTUFBTTtBQUNsRixpQkFBSyxLQUFLLEdBQUcsS0FBSztBQUVsQixnQkFBSSxLQUFLLEtBQUssV0FBVztBQUFHO0FBQUEsVUFDN0I7QUFBQSxRQUNGLFNBQVEsS0FBSztBQUNaLGVBQUs7QUFDTCxlQUFLO0FBQUEsUUFDWCxVQUFjO0FBQ1IsY0FBSTtBQUNGLGdCQUFJLENBQUMsTUFBTSxHQUFHLFFBQVE7QUFBRyxpQkFBRyxRQUFRO1VBQzVDLFVBQWdCO0FBQ1IsZ0JBQUk7QUFBSSxvQkFBTTtBQUFBLFVBQ2Y7QUFBQSxRQUNGO0FBRUQsZUFBTztBQUFBLE1BQ1I7QUFFRCxhQUFPLFNBQVUsS0FBSyxHQUFHO0FBQ3ZCLFlBQUksTUFBTSxRQUFRLEdBQUcsR0FBRztBQUN0QixpQkFBTztBQUFBLFFBQ1IsV0FBVSxPQUFPLFlBQVksT0FBTyxHQUFHLEdBQUc7QUFDekMsaUJBQU8sY0FBYyxLQUFLLENBQUM7QUFBQSxRQUNqQyxPQUFXO0FBQ0wsZ0JBQU0sSUFBSSxVQUFVLHNEQUFzRDtBQUFBLFFBQzNFO0FBQUEsTUFDTDtBQUFBLElBQ0E7QUFjQSxRQUFJLG9CQUFvQixTQUFVLEtBQUs7QUFDckMsVUFBSSxNQUFNLFFBQVEsR0FBRyxHQUFHO0FBQ3RCLGlCQUFTLElBQUksR0FBRyxPQUFPLE1BQU0sSUFBSSxNQUFNLEdBQUcsSUFBSSxJQUFJLFFBQVE7QUFBSyxlQUFLLENBQUMsSUFBSSxJQUFJLENBQUM7QUFFOUUsZUFBTztBQUFBLE1BQ1gsT0FBUztBQUNMLGVBQU8sTUFBTSxLQUFLLEdBQUc7QUFBQSxNQUN0QjtBQUFBLElBQ0g7QUFJQSxRQUFJLFNBQVM7QUFHYixRQUFJLE9BQU87QUFDWCxRQUFJLE9BQU87QUFDWCxRQUFJLE9BQU87QUFDWCxRQUFJLE9BQU87QUFDWCxRQUFJLE9BQU87QUFDWCxRQUFJLGNBQWM7QUFDbEIsUUFBSSxXQUFXO0FBQ2YsUUFBSSxZQUFZO0FBR2hCLFFBQUksZ0JBQWdCO0FBQ3BCLFFBQUksZ0JBQWdCO0FBQ3BCLFFBQUksa0JBQWtCO0FBR3RCLFFBQUlmLFVBQVM7QUFBQSxNQUNaLFlBQVk7QUFBQSxNQUNaLGFBQWE7QUFBQSxNQUNiLGlCQUFpQjtBQUFBLElBQ2xCO0FBR0EsUUFBSSxnQkFBZ0IsT0FBTztBQUMzQixRQUFJLFFBQVEsS0FBSztBQUNqQixRQUFJLHFCQUFxQixPQUFPO0FBVWhDLGFBQVNrQixTQUFRaEYsT0FBTTtBQUN0QixZQUFNLElBQUksV0FBVzhELFFBQU85RCxLQUFJLENBQUM7QUFBQSxJQUNqQztBQVVELGFBQVMsSUFBSSxPQUFPLElBQUk7QUFDdkIsVUFBSSxTQUFTLENBQUE7QUFDYixVQUFJLFNBQVMsTUFBTTtBQUNuQixhQUFPLFVBQVU7QUFDaEIsZUFBTyxNQUFNLElBQUksR0FBRyxNQUFNLE1BQU0sQ0FBQztBQUFBLE1BQ2pDO0FBQ0QsYUFBTztBQUFBLElBQ1A7QUFZRCxhQUFTLFVBQVUsUUFBUSxJQUFJO0FBQzlCLFVBQUksUUFBUSxPQUFPLE1BQU0sR0FBRztBQUM1QixVQUFJLFNBQVM7QUFDYixVQUFJLE1BQU0sU0FBUyxHQUFHO0FBR3JCLGlCQUFTLE1BQU0sQ0FBQyxJQUFJO0FBQ3BCLGlCQUFTLE1BQU0sQ0FBQztBQUFBLE1BQ2hCO0FBRUQsZUFBUyxPQUFPLFFBQVEsaUJBQWlCLEdBQU07QUFDL0MsVUFBSSxTQUFTLE9BQU8sTUFBTSxHQUFHO0FBQzdCLFVBQUksVUFBVSxJQUFJLFFBQVEsRUFBRSxFQUFFLEtBQUssR0FBRztBQUN0QyxhQUFPLFNBQVM7QUFBQSxJQUNoQjtBQWVELGFBQVMsV0FBVyxRQUFRO0FBQzNCLFVBQUksU0FBUyxDQUFBO0FBQ2IsVUFBSSxVQUFVO0FBQ2QsVUFBSSxTQUFTLE9BQU87QUFDcEIsYUFBTyxVQUFVLFFBQVE7QUFDeEIsWUFBSSxRQUFRLE9BQU8sV0FBVyxTQUFTO0FBQ3ZDLFlBQUksU0FBUyxTQUFVLFNBQVMsU0FBVSxVQUFVLFFBQVE7QUFFM0QsY0FBSSxRQUFRLE9BQU8sV0FBVyxTQUFTO0FBQ3ZDLGVBQUssUUFBUSxVQUFXLE9BQVE7QUFFL0IsbUJBQU8sT0FBTyxRQUFRLFNBQVUsT0FBTyxRQUFRLFFBQVMsS0FBTztBQUFBLFVBQ25FLE9BQVU7QUFHTixtQkFBTyxLQUFLLEtBQUs7QUFDakI7QUFBQSxVQUNBO0FBQUEsUUFDSixPQUFTO0FBQ04saUJBQU8sS0FBSyxLQUFLO0FBQUEsUUFDakI7QUFBQSxNQUNEO0FBQ0QsYUFBTztBQUFBLElBQ1A7QUFVRCxRQUFJLGFBQWEsU0FBU2lGLFlBQVcsT0FBTztBQUMzQyxhQUFPLE9BQU8sY0FBYyxNQUFNLFFBQVEsa0JBQWtCLEtBQUssQ0FBQztBQUFBLElBQ25FO0FBV0EsUUFBSSxlQUFlLFNBQVNDLGNBQWEsV0FBVztBQUNuRCxVQUFJLFlBQVksS0FBTyxJQUFNO0FBQzVCLGVBQU8sWUFBWTtBQUFBLE1BQ25CO0FBQ0QsVUFBSSxZQUFZLEtBQU8sSUFBTTtBQUM1QixlQUFPLFlBQVk7QUFBQSxNQUNuQjtBQUNELFVBQUksWUFBWSxLQUFPLElBQU07QUFDNUIsZUFBTyxZQUFZO0FBQUEsTUFDbkI7QUFDRCxhQUFPO0FBQUEsSUFDUjtBQWFBLFFBQUksZUFBZSxTQUFTQyxjQUFhLE9BQU8sTUFBTTtBQUdyRCxhQUFPLFFBQVEsS0FBSyxNQUFNLFFBQVEsUUFBUSxRQUFRLE1BQU07QUFBQSxJQUN6RDtBQU9BLFFBQUksUUFBUSxTQUFTQyxPQUFNLE9BQU8sV0FBVyxXQUFXO0FBQ3ZELFVBQUksSUFBSTtBQUNSLGNBQVEsWUFBWSxNQUFNLFFBQVEsSUFBSSxJQUFJLFNBQVM7QUFDbkQsZUFBUyxNQUFNLFFBQVEsU0FBUztBQUNoQztBQUFBO0FBQUE7QUFBQSxRQUE4QixRQUFRLGdCQUFnQixRQUFRO0FBQUEsUUFBRyxLQUFLO0FBQUEsUUFBTTtBQUMzRSxnQkFBUSxNQUFNLFFBQVEsYUFBYTtBQUFBLE1BQ25DO0FBQ0QsYUFBTyxNQUFNLEtBQUssZ0JBQWdCLEtBQUssU0FBUyxRQUFRLEtBQUs7QUFBQSxJQUM5RDtBQVNBLFFBQUksU0FBUyxTQUFTQyxRQUFPLE9BQU87QUFFbkMsVUFBSSxTQUFTLENBQUE7QUFDYixVQUFJLGNBQWMsTUFBTTtBQUN4QixVQUFJLElBQUk7QUFDUixVQUFJLElBQUk7QUFDUixVQUFJLE9BQU87QUFNWCxVQUFJLFFBQVEsTUFBTSxZQUFZLFNBQVM7QUFDdkMsVUFBSSxRQUFRLEdBQUc7QUFDZCxnQkFBUTtBQUFBLE1BQ1I7QUFFRCxlQUFTLElBQUksR0FBRyxJQUFJLE9BQU8sRUFBRSxHQUFHO0FBRS9CLFlBQUksTUFBTSxXQUFXLENBQUMsS0FBSyxLQUFNO0FBQ2hDLFVBQUFMLFNBQVEsV0FBVztBQUFBLFFBQ25CO0FBQ0QsZUFBTyxLQUFLLE1BQU0sV0FBVyxDQUFDLENBQUM7QUFBQSxNQUMvQjtBQUtELGVBQVMsUUFBUSxRQUFRLElBQUksUUFBUSxJQUFJLEdBQUcsUUFBUSxlQUF1QztBQU8xRixZQUFJLE9BQU87QUFDWDtBQUFBLGNBQVMsSUFBSSxHQUFHLElBQUk7QUFBQTtBQUFBO0FBQUEsVUFBeUIsS0FBSztBQUFBLFVBQU07QUFFdkQsY0FBSSxTQUFTLGFBQWE7QUFDekIsWUFBQUEsU0FBUSxlQUFlO0FBQUEsVUFDdkI7QUFFRCxjQUFJLFFBQVEsYUFBYSxNQUFNLFdBQVcsT0FBTyxDQUFDO0FBRWxELGNBQUksU0FBUyxRQUFRLFFBQVEsT0FBTyxTQUFTLEtBQUssQ0FBQyxHQUFHO0FBQ3JELFlBQUFBLFNBQVEsVUFBVTtBQUFBLFVBQ2xCO0FBRUQsZUFBSyxRQUFRO0FBQ2IsY0FBSXhCLEtBQUksS0FBSyxPQUFPLE9BQU8sS0FBSyxPQUFPLE9BQU8sT0FBTyxJQUFJO0FBRXpELGNBQUksUUFBUUEsSUFBRztBQUNkO0FBQUEsVUFDQTtBQUVELGNBQUksYUFBYSxPQUFPQTtBQUN4QixjQUFJLElBQUksTUFBTSxTQUFTLFVBQVUsR0FBRztBQUNuQyxZQUFBd0IsU0FBUSxVQUFVO0FBQUEsVUFDbEI7QUFFRCxlQUFLO0FBQUEsUUFDTDtBQUVELFlBQUksTUFBTSxPQUFPLFNBQVM7QUFDMUIsZUFBTyxNQUFNLElBQUksTUFBTSxLQUFLLFFBQVEsQ0FBQztBQUlyQyxZQUFJLE1BQU0sSUFBSSxHQUFHLElBQUksU0FBUyxHQUFHO0FBQ2hDLFVBQUFBLFNBQVEsVUFBVTtBQUFBLFFBQ2xCO0FBRUQsYUFBSyxNQUFNLElBQUksR0FBRztBQUNsQixhQUFLO0FBR0wsZUFBTyxPQUFPLEtBQUssR0FBRyxDQUFDO0FBQUEsTUFDdkI7QUFFRCxhQUFPLE9BQU8sY0FBYyxNQUFNLFFBQVEsTUFBTTtBQUFBLElBQ2pEO0FBU0EsUUFBSSxTQUFTLFNBQVNNLFFBQU8sT0FBTztBQUNuQyxVQUFJLFNBQVMsQ0FBQTtBQUdiLGNBQVEsV0FBVyxLQUFLO0FBR3hCLFVBQUksY0FBYyxNQUFNO0FBR3hCLFVBQUksSUFBSTtBQUNSLFVBQUksUUFBUTtBQUNaLFVBQUksT0FBTztBQUdYLFVBQUksNEJBQTRCO0FBQ2hDLFVBQUksb0JBQW9CO0FBQ3hCLFVBQUksaUJBQWlCO0FBRXJCLFVBQUk7QUFDSCxpQkFBUyxZQUFZLE1BQU0sT0FBTyxRQUFRLEVBQUcsR0FBRSxPQUFPLEVBQUUsNkJBQTZCLFFBQVEsVUFBVSxLQUFJLEdBQUksT0FBTyw0QkFBNEIsTUFBTTtBQUN2SixjQUFJLGlCQUFpQixNQUFNO0FBRTNCLGNBQUksaUJBQWlCLEtBQU07QUFDMUIsbUJBQU8sS0FBSyxtQkFBbUIsY0FBYyxDQUFDO0FBQUEsVUFDOUM7QUFBQSxRQUNEO0FBQUEsTUFDRCxTQUFRLEtBQUs7QUFDYiw0QkFBb0I7QUFDcEIseUJBQWlCO0FBQUEsTUFDbkIsVUFBVztBQUNULFlBQUk7QUFDSCxjQUFJLENBQUMsNkJBQTZCLFVBQVUsUUFBUTtBQUNuRCxzQkFBVSxPQUFNO0FBQUEsVUFDaEI7QUFBQSxRQUNKLFVBQVk7QUFDVCxjQUFJLG1CQUFtQjtBQUN0QixrQkFBTTtBQUFBLFVBQ047QUFBQSxRQUNEO0FBQUEsTUFDRDtBQUVELFVBQUksY0FBYyxPQUFPO0FBQ3pCLFVBQUksaUJBQWlCO0FBTXJCLFVBQUksYUFBYTtBQUNoQixlQUFPLEtBQUssU0FBUztBQUFBLE1BQ3JCO0FBR0QsYUFBTyxpQkFBaUIsYUFBYTtBQUlwQyxZQUFJLElBQUk7QUFDUixZQUFJLDZCQUE2QjtBQUNqQyxZQUFJLHFCQUFxQjtBQUN6QixZQUFJLGtCQUFrQjtBQUV0QixZQUFJO0FBQ0gsbUJBQVMsYUFBYSxNQUFNLE9BQU8sUUFBUSxFQUFHLEdBQUUsUUFBUSxFQUFFLDhCQUE4QixTQUFTLFdBQVcsS0FBSSxHQUFJLE9BQU8sNkJBQTZCLE1BQU07QUFDN0osZ0JBQUksZUFBZSxPQUFPO0FBRTFCLGdCQUFJLGdCQUFnQixLQUFLLGVBQWUsR0FBRztBQUMxQyxrQkFBSTtBQUFBLFlBQ0o7QUFBQSxVQUNEO0FBQUEsUUFJRCxTQUFRLEtBQUs7QUFDYiwrQkFBcUI7QUFDckIsNEJBQWtCO0FBQUEsUUFDckIsVUFBWTtBQUNULGNBQUk7QUFDSCxnQkFBSSxDQUFDLDhCQUE4QixXQUFXLFFBQVE7QUFDckQseUJBQVcsT0FBTTtBQUFBLFlBQ2pCO0FBQUEsVUFDTCxVQUFhO0FBQ1QsZ0JBQUksb0JBQW9CO0FBQ3ZCLG9CQUFNO0FBQUEsWUFDTjtBQUFBLFVBQ0Q7QUFBQSxRQUNEO0FBRUQsWUFBSSx3QkFBd0IsaUJBQWlCO0FBQzdDLFlBQUksSUFBSSxJQUFJLE9BQU8sU0FBUyxTQUFTLHFCQUFxQixHQUFHO0FBQzVELFVBQUFOLFNBQVEsVUFBVTtBQUFBLFFBQ2xCO0FBRUQsa0JBQVUsSUFBSSxLQUFLO0FBQ25CLFlBQUk7QUFFSixZQUFJLDZCQUE2QjtBQUNqQyxZQUFJLHFCQUFxQjtBQUN6QixZQUFJLGtCQUFrQjtBQUV0QixZQUFJO0FBQ0gsbUJBQVMsYUFBYSxNQUFNLE9BQU8sUUFBUSxFQUFHLEdBQUUsUUFBUSxFQUFFLDhCQUE4QixTQUFTLFdBQVcsS0FBSSxHQUFJLE9BQU8sNkJBQTZCLE1BQU07QUFDN0osZ0JBQUksZ0JBQWdCLE9BQU87QUFFM0IsZ0JBQUksZ0JBQWdCLEtBQUssRUFBRSxRQUFRLFFBQVE7QUFDMUMsY0FBQUEsU0FBUSxVQUFVO0FBQUEsWUFDbEI7QUFDRCxnQkFBSSxpQkFBaUIsR0FBRztBQUV2QixrQkFBSSxJQUFJO0FBQ1I7QUFBQSxvQkFBUyxJQUFJO0FBQUE7QUFBQTtBQUFBLGdCQUF5QixLQUFLO0FBQUEsZ0JBQU07QUFDaEQsb0JBQUl4QixLQUFJLEtBQUssT0FBTyxPQUFPLEtBQUssT0FBTyxPQUFPLE9BQU8sSUFBSTtBQUN6RCxvQkFBSSxJQUFJQSxJQUFHO0FBQ1Y7QUFBQSxnQkFDQTtBQUNELG9CQUFJLFVBQVUsSUFBSUE7QUFDbEIsb0JBQUksYUFBYSxPQUFPQTtBQUN4Qix1QkFBTyxLQUFLLG1CQUFtQixhQUFhQSxLQUFJLFVBQVUsWUFBWSxDQUFDLENBQUMsQ0FBQztBQUN6RSxvQkFBSSxNQUFNLFVBQVUsVUFBVTtBQUFBLGNBQzlCO0FBRUQscUJBQU8sS0FBSyxtQkFBbUIsYUFBYSxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ2xELHFCQUFPLE1BQU0sT0FBTyx1QkFBdUIsa0JBQWtCLFdBQVc7QUFDeEUsc0JBQVE7QUFDUixnQkFBRTtBQUFBLFlBQ0Y7QUFBQSxVQUNEO0FBQUEsUUFDRCxTQUFRLEtBQUs7QUFDYiwrQkFBcUI7QUFDckIsNEJBQWtCO0FBQUEsUUFDckIsVUFBWTtBQUNULGNBQUk7QUFDSCxnQkFBSSxDQUFDLDhCQUE4QixXQUFXLFFBQVE7QUFDckQseUJBQVcsT0FBTTtBQUFBLFlBQ2pCO0FBQUEsVUFDTCxVQUFhO0FBQ1QsZ0JBQUksb0JBQW9CO0FBQ3ZCLG9CQUFNO0FBQUEsWUFDTjtBQUFBLFVBQ0Q7QUFBQSxRQUNEO0FBRUQsVUFBRTtBQUNGLFVBQUU7QUFBQSxNQUNGO0FBQ0QsYUFBTyxPQUFPLEtBQUssRUFBRTtBQUFBLElBQ3RCO0FBYUEsUUFBSSxZQUFZLFNBQVMrQixXQUFVLE9BQU87QUFDekMsYUFBTyxVQUFVLE9BQU8sU0FBVSxRQUFRO0FBQ3pDLGVBQU8sY0FBYyxLQUFLLE1BQU0sSUFBSSxPQUFPLE9BQU8sTUFBTSxDQUFDLEVBQUUsWUFBYSxDQUFBLElBQUk7QUFBQSxNQUM5RSxDQUFFO0FBQUEsSUFDRjtBQWFBLFFBQUksVUFBVSxTQUFTQyxTQUFRLE9BQU87QUFDckMsYUFBTyxVQUFVLE9BQU8sU0FBVSxRQUFRO0FBQ3pDLGVBQU8sY0FBYyxLQUFLLE1BQU0sSUFBSSxTQUFTLE9BQU8sTUFBTSxJQUFJO0FBQUEsTUFDaEUsQ0FBRTtBQUFBLElBQ0Y7QUFLQSxRQUFJLFdBQVc7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNZCxXQUFXO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFYLFFBQVE7QUFBQSxRQUNQLFVBQVU7QUFBQSxRQUNWLFVBQVU7QUFBQSxNQUNWO0FBQUEsTUFDRCxVQUFVO0FBQUEsTUFDVixVQUFVO0FBQUEsTUFDVixXQUFXO0FBQUEsTUFDWCxhQUFhO0FBQUEsSUFDZDtBQW9DQSxRQUFJLFVBQVUsQ0FBQTtBQUNkLGFBQVMsV0FBVyxLQUFLO0FBQ3JCLFVBQUksSUFBSSxJQUFJLFdBQVcsQ0FBQztBQUN4QixVQUFJLElBQUk7QUFDUixVQUFJLElBQUk7QUFBSSxZQUFJLE9BQU8sRUFBRSxTQUFTLEVBQUUsRUFBRSxZQUFhO0FBQUEsZUFBVSxJQUFJO0FBQUssWUFBSSxNQUFNLEVBQUUsU0FBUyxFQUFFLEVBQUUsWUFBYTtBQUFBLGVBQVUsSUFBSTtBQUFNLFlBQUksT0FBTyxLQUFLLElBQUksS0FBSyxTQUFTLEVBQUUsRUFBRSxZQUFXLElBQUssT0FBTyxJQUFJLEtBQUssS0FBSyxTQUFTLEVBQUUsRUFBRSxZQUFXO0FBQUE7QUFBUSxZQUFJLE9BQU8sS0FBSyxLQUFLLEtBQUssU0FBUyxFQUFFLEVBQUUsWUFBVyxJQUFLLE9BQU8sS0FBSyxJQUFJLEtBQUssS0FBSyxTQUFTLEVBQUUsRUFBRSxZQUFhLElBQUcsT0FBTyxJQUFJLEtBQUssS0FBSyxTQUFTLEVBQUUsRUFBRTtBQUMzWCxhQUFPO0FBQUEsSUFDVjtBQUNELGFBQVMsWUFBWSxLQUFLO0FBQ3RCLFVBQUksU0FBUztBQUNiLFVBQUksSUFBSTtBQUNSLFVBQUksS0FBSyxJQUFJO0FBQ2IsYUFBTyxJQUFJLElBQUk7QUFDWCxZQUFJLElBQUksU0FBUyxJQUFJLE9BQU8sSUFBSSxHQUFHLENBQUMsR0FBRyxFQUFFO0FBQ3pDLFlBQUksSUFBSSxLQUFLO0FBQ1Qsb0JBQVUsT0FBTyxhQUFhLENBQUM7QUFDL0IsZUFBSztBQUFBLFFBQ1IsV0FBVSxLQUFLLE9BQU8sSUFBSSxLQUFLO0FBQzVCLGNBQUksS0FBSyxLQUFLLEdBQUc7QUFDYixnQkFBSSxLQUFLLFNBQVMsSUFBSSxPQUFPLElBQUksR0FBRyxDQUFDLEdBQUcsRUFBRTtBQUMxQyxzQkFBVSxPQUFPLGNBQWMsSUFBSSxPQUFPLElBQUksS0FBSyxFQUFFO0FBQUEsVUFDckUsT0FBbUI7QUFDSCxzQkFBVSxJQUFJLE9BQU8sR0FBRyxDQUFDO0FBQUEsVUFDNUI7QUFDRCxlQUFLO0FBQUEsUUFDakIsV0FBbUIsS0FBSyxLQUFLO0FBQ2pCLGNBQUksS0FBSyxLQUFLLEdBQUc7QUFDYixnQkFBSSxLQUFLLFNBQVMsSUFBSSxPQUFPLElBQUksR0FBRyxDQUFDLEdBQUcsRUFBRTtBQUMxQyxnQkFBSSxLQUFLLFNBQVMsSUFBSSxPQUFPLElBQUksR0FBRyxDQUFDLEdBQUcsRUFBRTtBQUMxQyxzQkFBVSxPQUFPLGNBQWMsSUFBSSxPQUFPLE1BQU0sS0FBSyxPQUFPLElBQUksS0FBSyxFQUFFO0FBQUEsVUFDdkYsT0FBbUI7QUFDSCxzQkFBVSxJQUFJLE9BQU8sR0FBRyxDQUFDO0FBQUEsVUFDNUI7QUFDRCxlQUFLO0FBQUEsUUFDakIsT0FBZTtBQUNILG9CQUFVLElBQUksT0FBTyxHQUFHLENBQUM7QUFDekIsZUFBSztBQUFBLFFBQ1I7QUFBQSxNQUNKO0FBQ0QsYUFBTztBQUFBLElBQ1Y7QUFDRCxhQUFTLDRCQUE0QixZQUFZLFVBQVU7QUFDdkQsZUFBU0Msa0JBQWlCLEtBQUs7QUFDM0IsWUFBSSxTQUFTLFlBQVksR0FBRztBQUM1QixlQUFPLENBQUMsT0FBTyxNQUFNLFNBQVMsVUFBVSxJQUFJLE1BQU07QUFBQSxNQUNyRDtBQUNELFVBQUksV0FBVztBQUFRLG1CQUFXLFNBQVMsT0FBTyxXQUFXLE1BQU0sRUFBRSxRQUFRLFNBQVMsYUFBYUEsaUJBQWdCLEVBQUUsWUFBYSxFQUFDLFFBQVEsU0FBUyxZQUFZLEVBQUU7QUFDbEssVUFBSSxXQUFXLGFBQWE7QUFBVyxtQkFBVyxXQUFXLE9BQU8sV0FBVyxRQUFRLEVBQUUsUUFBUSxTQUFTLGFBQWFBLGlCQUFnQixFQUFFLFFBQVEsU0FBUyxjQUFjLFVBQVUsRUFBRSxRQUFRLFNBQVMsYUFBYSxXQUFXO0FBQzdOLFVBQUksV0FBVyxTQUFTO0FBQVcsbUJBQVcsT0FBTyxPQUFPLFdBQVcsSUFBSSxFQUFFLFFBQVEsU0FBUyxhQUFhQSxpQkFBZ0IsRUFBRSxZQUFXLEVBQUcsUUFBUSxTQUFTLFVBQVUsVUFBVSxFQUFFLFFBQVEsU0FBUyxhQUFhLFdBQVc7QUFDM04sVUFBSSxXQUFXLFNBQVM7QUFBVyxtQkFBVyxPQUFPLE9BQU8sV0FBVyxJQUFJLEVBQUUsUUFBUSxTQUFTLGFBQWFBLGlCQUFnQixFQUFFLFFBQVEsV0FBVyxTQUFTLFNBQVMsV0FBVyxTQUFTLG1CQUFtQixVQUFVLEVBQUUsUUFBUSxTQUFTLGFBQWEsV0FBVztBQUM5UCxVQUFJLFdBQVcsVUFBVTtBQUFXLG1CQUFXLFFBQVEsT0FBTyxXQUFXLEtBQUssRUFBRSxRQUFRLFNBQVMsYUFBYUEsaUJBQWdCLEVBQUUsUUFBUSxTQUFTLFdBQVcsVUFBVSxFQUFFLFFBQVEsU0FBUyxhQUFhLFdBQVc7QUFDak4sVUFBSSxXQUFXLGFBQWE7QUFBVyxtQkFBVyxXQUFXLE9BQU8sV0FBVyxRQUFRLEVBQUUsUUFBUSxTQUFTLGFBQWFBLGlCQUFnQixFQUFFLFFBQVEsU0FBUyxjQUFjLFVBQVUsRUFBRSxRQUFRLFNBQVMsYUFBYSxXQUFXO0FBQzdOLGFBQU87QUFBQSxJQUNWO0FBRUQsYUFBUyxtQkFBbUIsS0FBSztBQUM3QixhQUFPLElBQUksUUFBUSxXQUFXLElBQUksS0FBSztBQUFBLElBQzFDO0FBQ0QsYUFBUyxlQUFlLE1BQU0sVUFBVTtBQUNwQyxVQUFJLFVBQVUsS0FBSyxNQUFNLFNBQVMsV0FBVyxLQUFLO0FBRWxELFVBQUksV0FBVyxjQUFjLFNBQVMsQ0FBQyxHQUNuQyxVQUFVLFNBQVMsQ0FBQztBQUV4QixVQUFJLFNBQVM7QUFDVCxlQUFPLFFBQVEsTUFBTSxHQUFHLEVBQUUsSUFBSSxrQkFBa0IsRUFBRSxLQUFLLEdBQUc7QUFBQSxNQUNsRSxPQUFXO0FBQ0gsZUFBTztBQUFBLE1BQ1Y7QUFBQSxJQUNKO0FBQ0QsYUFBUyxlQUFlLE1BQU0sVUFBVTtBQUNwQyxVQUFJLFVBQVUsS0FBSyxNQUFNLFNBQVMsV0FBVyxLQUFLO0FBRWxELFVBQUksWUFBWSxjQUFjLFNBQVMsQ0FBQyxHQUNwQyxVQUFVLFVBQVUsQ0FBQyxHQUNyQixPQUFPLFVBQVUsQ0FBQztBQUV0QixVQUFJLFNBQVM7QUFDVCxZQUFJLHdCQUF3QixRQUFRLFlBQVcsRUFBRyxNQUFNLElBQUksRUFBRSxRQUFTLEdBQ25FLHlCQUF5QixjQUFjLHVCQUF1QixDQUFDLEdBQy9ELE9BQU8sdUJBQXVCLENBQUMsR0FDL0IsUUFBUSx1QkFBdUIsQ0FBQztBQUVwQyxZQUFJLGNBQWMsUUFBUSxNQUFNLE1BQU0sR0FBRyxFQUFFLElBQUksa0JBQWtCLElBQUk7QUFDckUsWUFBSSxhQUFhLEtBQUssTUFBTSxHQUFHLEVBQUUsSUFBSSxrQkFBa0I7QUFDdkQsWUFBSSx5QkFBeUIsU0FBUyxZQUFZLEtBQUssV0FBVyxXQUFXLFNBQVMsQ0FBQyxDQUFDO0FBQ3hGLFlBQUksYUFBYSx5QkFBeUIsSUFBSTtBQUM5QyxZQUFJLGtCQUFrQixXQUFXLFNBQVM7QUFDMUMsWUFBSSxTQUFTLE1BQU0sVUFBVTtBQUM3QixpQkFBUyxJQUFJLEdBQUcsSUFBSSxZQUFZLEVBQUUsR0FBRztBQUNqQyxpQkFBTyxDQUFDLElBQUksWUFBWSxDQUFDLEtBQUssV0FBVyxrQkFBa0IsQ0FBQyxLQUFLO0FBQUEsUUFDcEU7QUFDRCxZQUFJLHdCQUF3QjtBQUN4QixpQkFBTyxhQUFhLENBQUMsSUFBSSxlQUFlLE9BQU8sYUFBYSxDQUFDLEdBQUcsUUFBUTtBQUFBLFFBQzNFO0FBQ0QsWUFBSSxnQkFBZ0IsT0FBTyxPQUFPLFNBQVUsS0FBSyxPQUFPLE9BQU87QUFDM0QsY0FBSSxDQUFDLFNBQVMsVUFBVSxLQUFLO0FBQ3pCLGdCQUFJLGNBQWMsSUFBSSxJQUFJLFNBQVMsQ0FBQztBQUNwQyxnQkFBSSxlQUFlLFlBQVksUUFBUSxZQUFZLFdBQVcsT0FBTztBQUNqRSwwQkFBWTtBQUFBLFlBQ2hDLE9BQXVCO0FBQ0gsa0JBQUksS0FBSyxFQUFFLE9BQWMsUUFBUSxFQUFDLENBQUU7QUFBQSxZQUN2QztBQUFBLFVBQ0o7QUFDRCxpQkFBTztBQUFBLFFBQ1YsR0FBRSxDQUFFLENBQUE7QUFDTCxZQUFJLG9CQUFvQixjQUFjLEtBQUssU0FBVSxHQUFHLEdBQUc7QUFDdkQsaUJBQU8sRUFBRSxTQUFTLEVBQUU7QUFBQSxRQUNoQyxDQUFTLEVBQUUsQ0FBQztBQUNKLFlBQUksVUFBVTtBQUNkLFlBQUkscUJBQXFCLGtCQUFrQixTQUFTLEdBQUc7QUFDbkQsY0FBSSxXQUFXLE9BQU8sTUFBTSxHQUFHLGtCQUFrQixLQUFLO0FBQ3RELGNBQUksVUFBVSxPQUFPLE1BQU0sa0JBQWtCLFFBQVEsa0JBQWtCLE1BQU07QUFDN0Usb0JBQVUsU0FBUyxLQUFLLEdBQUcsSUFBSSxPQUFPLFFBQVEsS0FBSyxHQUFHO0FBQUEsUUFDbEUsT0FBZTtBQUNILG9CQUFVLE9BQU8sS0FBSyxHQUFHO0FBQUEsUUFDNUI7QUFDRCxZQUFJLE1BQU07QUFDTixxQkFBVyxNQUFNO0FBQUEsUUFDcEI7QUFDRCxlQUFPO0FBQUEsTUFDZixPQUFXO0FBQ0gsZUFBTztBQUFBLE1BQ1Y7QUFBQSxJQUNKO0FBQ0QsUUFBSSxZQUFZO0FBQ2hCLFFBQUksd0JBQXdCLEdBQUcsTUFBTSxPQUFPLEVBQUUsQ0FBQyxNQUFNO0FBQ3JELGFBQVNDLE9BQU0sV0FBVztBQUN0QixVQUFJLFVBQVUsVUFBVSxTQUFTLEtBQUssVUFBVSxDQUFDLE1BQU0sU0FBWSxVQUFVLENBQUMsSUFBSSxDQUFBO0FBRWxGLFVBQUksYUFBYSxDQUFBO0FBQ2pCLFVBQUksV0FBVyxRQUFRLFFBQVEsUUFBUSxlQUFlO0FBQ3RELFVBQUksUUFBUSxjQUFjO0FBQVUscUJBQWEsUUFBUSxTQUFTLFFBQVEsU0FBUyxNQUFNLE1BQU0sT0FBTztBQUN0RyxVQUFJLFVBQVUsVUFBVSxNQUFNLFNBQVM7QUFDdkMsVUFBSSxTQUFTO0FBQ1QsWUFBSSx1QkFBdUI7QUFFdkIscUJBQVcsU0FBUyxRQUFRLENBQUM7QUFDN0IscUJBQVcsV0FBVyxRQUFRLENBQUM7QUFDL0IscUJBQVcsT0FBTyxRQUFRLENBQUM7QUFDM0IscUJBQVcsT0FBTyxTQUFTLFFBQVEsQ0FBQyxHQUFHLEVBQUU7QUFDekMscUJBQVcsT0FBTyxRQUFRLENBQUMsS0FBSztBQUNoQyxxQkFBVyxRQUFRLFFBQVEsQ0FBQztBQUM1QixxQkFBVyxXQUFXLFFBQVEsQ0FBQztBQUUvQixjQUFJLE1BQU0sV0FBVyxJQUFJLEdBQUc7QUFDeEIsdUJBQVcsT0FBTyxRQUFRLENBQUM7QUFBQSxVQUM5QjtBQUFBLFFBQ2IsT0FBZTtBQUdILHFCQUFXLFNBQVMsUUFBUSxDQUFDLEtBQUs7QUFDbEMscUJBQVcsV0FBVyxVQUFVLFFBQVEsR0FBRyxNQUFNLEtBQUssUUFBUSxDQUFDLElBQUk7QUFDbkUscUJBQVcsT0FBTyxVQUFVLFFBQVEsSUFBSSxNQUFNLEtBQUssUUFBUSxDQUFDLElBQUk7QUFDaEUscUJBQVcsT0FBTyxTQUFTLFFBQVEsQ0FBQyxHQUFHLEVBQUU7QUFDekMscUJBQVcsT0FBTyxRQUFRLENBQUMsS0FBSztBQUNoQyxxQkFBVyxRQUFRLFVBQVUsUUFBUSxHQUFHLE1BQU0sS0FBSyxRQUFRLENBQUMsSUFBSTtBQUNoRSxxQkFBVyxXQUFXLFVBQVUsUUFBUSxHQUFHLE1BQU0sS0FBSyxRQUFRLENBQUMsSUFBSTtBQUVuRSxjQUFJLE1BQU0sV0FBVyxJQUFJLEdBQUc7QUFDeEIsdUJBQVcsT0FBTyxVQUFVLE1BQU0sK0JBQStCLElBQUksUUFBUSxDQUFDLElBQUk7QUFBQSxVQUNyRjtBQUFBLFFBQ0o7QUFDRCxZQUFJLFdBQVcsTUFBTTtBQUVqQixxQkFBVyxPQUFPLGVBQWUsZUFBZSxXQUFXLE1BQU0sUUFBUSxHQUFHLFFBQVE7QUFBQSxRQUN2RjtBQUVELFlBQUksV0FBVyxXQUFXLFVBQWEsV0FBVyxhQUFhLFVBQWEsV0FBVyxTQUFTLFVBQWEsV0FBVyxTQUFTLFVBQWEsQ0FBQyxXQUFXLFFBQVEsV0FBVyxVQUFVLFFBQVc7QUFDOUwscUJBQVcsWUFBWTtBQUFBLFFBQ25DLFdBQW1CLFdBQVcsV0FBVyxRQUFXO0FBQ3hDLHFCQUFXLFlBQVk7QUFBQSxRQUNuQyxXQUFtQixXQUFXLGFBQWEsUUFBVztBQUMxQyxxQkFBVyxZQUFZO0FBQUEsUUFDbkMsT0FBZTtBQUNILHFCQUFXLFlBQVk7QUFBQSxRQUMxQjtBQUVELFlBQUksUUFBUSxhQUFhLFFBQVEsY0FBYyxZQUFZLFFBQVEsY0FBYyxXQUFXLFdBQVc7QUFDbkcscUJBQVcsUUFBUSxXQUFXLFNBQVMsa0JBQWtCLFFBQVEsWUFBWTtBQUFBLFFBQ2hGO0FBRUQsWUFBSSxnQkFBZ0IsU0FBUyxRQUFRLFVBQVUsV0FBVyxVQUFVLElBQUksWUFBVyxDQUFFO0FBRXJGLFlBQUksQ0FBQyxRQUFRLG1CQUFtQixDQUFDLGlCQUFpQixDQUFDLGNBQWMsaUJBQWlCO0FBRTlFLGNBQUksV0FBVyxTQUFTLFFBQVEsY0FBYyxpQkFBaUIsY0FBYyxhQUFhO0FBRXRGLGdCQUFJO0FBQ0EseUJBQVcsT0FBTyxTQUFTLFFBQVEsV0FBVyxLQUFLLFFBQVEsU0FBUyxhQUFhLFdBQVcsRUFBRSxZQUFhLENBQUE7QUFBQSxZQUM5RyxTQUFRLEdBQUc7QUFDUix5QkFBVyxRQUFRLFdBQVcsU0FBUyxvRUFBb0U7QUFBQSxZQUM5RztBQUFBLFVBQ0o7QUFFRCxzQ0FBNEIsWUFBWSxZQUFZO0FBQUEsUUFDaEUsT0FBZTtBQUVILHNDQUE0QixZQUFZLFFBQVE7QUFBQSxRQUNuRDtBQUVELFlBQUksaUJBQWlCLGNBQWMsT0FBTztBQUN0Qyx3QkFBYyxNQUFNLFlBQVksT0FBTztBQUFBLFFBQzFDO0FBQUEsTUFDVCxPQUFXO0FBQ0gsbUJBQVcsUUFBUSxXQUFXLFNBQVM7QUFBQSxNQUMxQztBQUNELGFBQU87QUFBQSxJQUNWO0FBRUQsYUFBUyxvQkFBb0IsWUFBWSxTQUFTO0FBQzlDLFVBQUksV0FBVyxRQUFRLFFBQVEsUUFBUSxlQUFlO0FBQ3RELFVBQUksWUFBWSxDQUFBO0FBQ2hCLFVBQUksV0FBVyxhQUFhLFFBQVc7QUFDbkMsa0JBQVUsS0FBSyxXQUFXLFFBQVE7QUFDbEMsa0JBQVUsS0FBSyxHQUFHO0FBQUEsTUFDckI7QUFDRCxVQUFJLFdBQVcsU0FBUyxRQUFXO0FBRS9CLGtCQUFVLEtBQUssZUFBZSxlQUFlLE9BQU8sV0FBVyxJQUFJLEdBQUcsUUFBUSxHQUFHLFFBQVEsRUFBRSxRQUFRLFNBQVMsYUFBYSxTQUFVLEdBQUcsSUFBSSxJQUFJO0FBQzFJLGlCQUFPLE1BQU0sTUFBTSxLQUFLLFFBQVEsS0FBSyxNQUFNO0FBQUEsUUFDOUMsQ0FBQSxDQUFDO0FBQUEsTUFDTDtBQUNELFVBQUksT0FBTyxXQUFXLFNBQVMsWUFBWSxPQUFPLFdBQVcsU0FBUyxVQUFVO0FBQzVFLGtCQUFVLEtBQUssR0FBRztBQUNsQixrQkFBVSxLQUFLLE9BQU8sV0FBVyxJQUFJLENBQUM7QUFBQSxNQUN6QztBQUNELGFBQU8sVUFBVSxTQUFTLFVBQVUsS0FBSyxFQUFFLElBQUk7QUFBQSxJQUNsRDtBQUVELFFBQUksT0FBTztBQUNYLFFBQUksT0FBTztBQUNYLFFBQUksT0FBTztBQUNYLFFBQUksT0FBTztBQUNYLGFBQVMsa0JBQWtCLE9BQU87QUFDOUIsVUFBSSxTQUFTLENBQUE7QUFDYixhQUFPLE1BQU0sUUFBUTtBQUNqQixZQUFJLE1BQU0sTUFBTSxJQUFJLEdBQUc7QUFDbkIsa0JBQVEsTUFBTSxRQUFRLE1BQU0sRUFBRTtBQUFBLFFBQ2pDLFdBQVUsTUFBTSxNQUFNLElBQUksR0FBRztBQUMxQixrQkFBUSxNQUFNLFFBQVEsTUFBTSxHQUFHO0FBQUEsUUFDbEMsV0FBVSxNQUFNLE1BQU0sSUFBSSxHQUFHO0FBQzFCLGtCQUFRLE1BQU0sUUFBUSxNQUFNLEdBQUc7QUFDL0IsaUJBQU8sSUFBRztBQUFBLFFBQ2IsV0FBVSxVQUFVLE9BQU8sVUFBVSxNQUFNO0FBQ3hDLGtCQUFRO0FBQUEsUUFDcEIsT0FBZTtBQUNILGNBQUksS0FBSyxNQUFNLE1BQU0sSUFBSTtBQUN6QixjQUFJLElBQUk7QUFDSixnQkFBSSxJQUFJLEdBQUcsQ0FBQztBQUNaLG9CQUFRLE1BQU0sTUFBTSxFQUFFLE1BQU07QUFDNUIsbUJBQU8sS0FBSyxDQUFDO0FBQUEsVUFDN0IsT0FBbUI7QUFDSCxrQkFBTSxJQUFJLE1BQU0sa0NBQWtDO0FBQUEsVUFDckQ7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUNELGFBQU8sT0FBTyxLQUFLLEVBQUU7QUFBQSxJQUN4QjtBQUVELGFBQVMsVUFBVSxZQUFZO0FBQzNCLFVBQUksVUFBVSxVQUFVLFNBQVMsS0FBSyxVQUFVLENBQUMsTUFBTSxTQUFZLFVBQVUsQ0FBQyxJQUFJLENBQUE7QUFFbEYsVUFBSSxXQUFXLFFBQVEsTUFBTSxlQUFlO0FBQzVDLFVBQUksWUFBWSxDQUFBO0FBRWhCLFVBQUksZ0JBQWdCLFNBQVMsUUFBUSxVQUFVLFdBQVcsVUFBVSxJQUFJLFlBQVcsQ0FBRTtBQUVyRixVQUFJLGlCQUFpQixjQUFjO0FBQVcsc0JBQWMsVUFBVSxZQUFZLE9BQU87QUFDekYsVUFBSSxXQUFXLE1BQU07QUFFakIsWUFBSSxTQUFTLFlBQVksS0FBSyxXQUFXLElBQUk7QUFBRztBQUFBLGlCQUl2QyxRQUFRLGNBQWMsaUJBQWlCLGNBQWMsWUFBWTtBQUVsRSxjQUFJO0FBQ0EsdUJBQVcsT0FBTyxDQUFDLFFBQVEsTUFBTSxTQUFTLFFBQVEsV0FBVyxLQUFLLFFBQVEsU0FBUyxhQUFhLFdBQVcsRUFBRSxZQUFhLENBQUEsSUFBSSxTQUFTLFVBQVUsV0FBVyxJQUFJO0FBQUEsVUFDbkssU0FBUSxHQUFHO0FBQ1IsdUJBQVcsUUFBUSxXQUFXLFNBQVMsaURBQWlELENBQUMsUUFBUSxNQUFNLFVBQVUsYUFBYSxvQkFBb0I7QUFBQSxVQUNySjtBQUFBLFFBQ0o7QUFBQSxNQUNSO0FBRUQsa0NBQTRCLFlBQVksUUFBUTtBQUNoRCxVQUFJLFFBQVEsY0FBYyxZQUFZLFdBQVcsUUFBUTtBQUNyRCxrQkFBVSxLQUFLLFdBQVcsTUFBTTtBQUNoQyxrQkFBVSxLQUFLLEdBQUc7QUFBQSxNQUNyQjtBQUNELFVBQUksWUFBWSxvQkFBb0IsWUFBWSxPQUFPO0FBQ3ZELFVBQUksY0FBYyxRQUFXO0FBQ3pCLFlBQUksUUFBUSxjQUFjLFVBQVU7QUFDaEMsb0JBQVUsS0FBSyxJQUFJO0FBQUEsUUFDdEI7QUFDRCxrQkFBVSxLQUFLLFNBQVM7QUFDeEIsWUFBSSxXQUFXLFFBQVEsV0FBVyxLQUFLLE9BQU8sQ0FBQyxNQUFNLEtBQUs7QUFDdEQsb0JBQVUsS0FBSyxHQUFHO0FBQUEsUUFDckI7QUFBQSxNQUNKO0FBQ0QsVUFBSSxXQUFXLFNBQVMsUUFBVztBQUMvQixZQUFJLElBQUksV0FBVztBQUNuQixZQUFJLENBQUMsUUFBUSxpQkFBaUIsQ0FBQyxpQkFBaUIsQ0FBQyxjQUFjLGVBQWU7QUFDMUUsY0FBSSxrQkFBa0IsQ0FBQztBQUFBLFFBQzFCO0FBQ0QsWUFBSSxjQUFjLFFBQVc7QUFDekIsY0FBSSxFQUFFLFFBQVEsU0FBUyxNQUFNO0FBQUEsUUFDaEM7QUFDRCxrQkFBVSxLQUFLLENBQUM7QUFBQSxNQUNuQjtBQUNELFVBQUksV0FBVyxVQUFVLFFBQVc7QUFDaEMsa0JBQVUsS0FBSyxHQUFHO0FBQ2xCLGtCQUFVLEtBQUssV0FBVyxLQUFLO0FBQUEsTUFDbEM7QUFDRCxVQUFJLFdBQVcsYUFBYSxRQUFXO0FBQ25DLGtCQUFVLEtBQUssR0FBRztBQUNsQixrQkFBVSxLQUFLLFdBQVcsUUFBUTtBQUFBLE1BQ3JDO0FBQ0QsYUFBTyxVQUFVLEtBQUssRUFBRTtBQUFBLElBQzNCO0FBRUQsYUFBUyxrQkFBa0JDLE9BQU0sVUFBVTtBQUN2QyxVQUFJLFVBQVUsVUFBVSxTQUFTLEtBQUssVUFBVSxDQUFDLE1BQU0sU0FBWSxVQUFVLENBQUMsSUFBSSxDQUFBO0FBQ2xGLFVBQUksb0JBQW9CLFVBQVUsQ0FBQztBQUVuQyxVQUFJLFNBQVMsQ0FBQTtBQUNiLFVBQUksQ0FBQyxtQkFBbUI7QUFDcEIsUUFBQUEsUUFBT0QsT0FBTSxVQUFVQyxPQUFNLE9BQU8sR0FBRyxPQUFPO0FBQzlDLG1CQUFXRCxPQUFNLFVBQVUsVUFBVSxPQUFPLEdBQUcsT0FBTztBQUFBLE1BQ3pEO0FBQ0QsZ0JBQVUsV0FBVztBQUNyQixVQUFJLENBQUMsUUFBUSxZQUFZLFNBQVMsUUFBUTtBQUN0QyxlQUFPLFNBQVMsU0FBUztBQUV6QixlQUFPLFdBQVcsU0FBUztBQUMzQixlQUFPLE9BQU8sU0FBUztBQUN2QixlQUFPLE9BQU8sU0FBUztBQUN2QixlQUFPLE9BQU8sa0JBQWtCLFNBQVMsUUFBUSxFQUFFO0FBQ25ELGVBQU8sUUFBUSxTQUFTO0FBQUEsTUFDaEMsT0FBVztBQUNILFlBQUksU0FBUyxhQUFhLFVBQWEsU0FBUyxTQUFTLFVBQWEsU0FBUyxTQUFTLFFBQVc7QUFFL0YsaUJBQU8sV0FBVyxTQUFTO0FBQzNCLGlCQUFPLE9BQU8sU0FBUztBQUN2QixpQkFBTyxPQUFPLFNBQVM7QUFDdkIsaUJBQU8sT0FBTyxrQkFBa0IsU0FBUyxRQUFRLEVBQUU7QUFDbkQsaUJBQU8sUUFBUSxTQUFTO0FBQUEsUUFDcEMsT0FBZTtBQUNILGNBQUksQ0FBQyxTQUFTLE1BQU07QUFDaEIsbUJBQU8sT0FBT0MsTUFBSztBQUNuQixnQkFBSSxTQUFTLFVBQVUsUUFBVztBQUM5QixxQkFBTyxRQUFRLFNBQVM7QUFBQSxZQUM1QyxPQUF1QjtBQUNILHFCQUFPLFFBQVFBLE1BQUs7QUFBQSxZQUN2QjtBQUFBLFVBQ2pCLE9BQW1CO0FBQ0gsZ0JBQUksU0FBUyxLQUFLLE9BQU8sQ0FBQyxNQUFNLEtBQUs7QUFDakMscUJBQU8sT0FBTyxrQkFBa0IsU0FBUyxJQUFJO0FBQUEsWUFDakUsT0FBdUI7QUFDSCxtQkFBS0EsTUFBSyxhQUFhLFVBQWFBLE1BQUssU0FBUyxVQUFhQSxNQUFLLFNBQVMsV0FBYyxDQUFDQSxNQUFLLE1BQU07QUFDbkcsdUJBQU8sT0FBTyxNQUFNLFNBQVM7QUFBQSxjQUNyRCxXQUErQixDQUFDQSxNQUFLLE1BQU07QUFDbkIsdUJBQU8sT0FBTyxTQUFTO0FBQUEsY0FDL0MsT0FBMkI7QUFDSCx1QkFBTyxPQUFPQSxNQUFLLEtBQUssTUFBTSxHQUFHQSxNQUFLLEtBQUssWUFBWSxHQUFHLElBQUksQ0FBQyxJQUFJLFNBQVM7QUFBQSxjQUMvRTtBQUNELHFCQUFPLE9BQU8sa0JBQWtCLE9BQU8sSUFBSTtBQUFBLFlBQzlDO0FBQ0QsbUJBQU8sUUFBUSxTQUFTO0FBQUEsVUFDM0I7QUFFRCxpQkFBTyxXQUFXQSxNQUFLO0FBQ3ZCLGlCQUFPLE9BQU9BLE1BQUs7QUFDbkIsaUJBQU8sT0FBT0EsTUFBSztBQUFBLFFBQ3RCO0FBQ0QsZUFBTyxTQUFTQSxNQUFLO0FBQUEsTUFDeEI7QUFDRCxhQUFPLFdBQVcsU0FBUztBQUMzQixhQUFPO0FBQUEsSUFDVjtBQUVELGFBQVNySyxTQUFRLFNBQVMsYUFBYSxTQUFTO0FBQzVDLFVBQUksb0JBQW9CLE9BQU8sRUFBRSxRQUFRLE9BQU0sR0FBSSxPQUFPO0FBQzFELGFBQU8sVUFBVSxrQkFBa0JvSyxPQUFNLFNBQVMsaUJBQWlCLEdBQUdBLE9BQU0sYUFBYSxpQkFBaUIsR0FBRyxtQkFBbUIsSUFBSSxHQUFHLGlCQUFpQjtBQUFBLElBQzNKO0FBRUQsYUFBUyxVQUFVRSxNQUFLLFNBQVM7QUFDN0IsVUFBSSxPQUFPQSxTQUFRLFVBQVU7QUFDekIsUUFBQUEsT0FBTSxVQUFVRixPQUFNRSxNQUFLLE9BQU8sR0FBRyxPQUFPO0FBQUEsTUFDL0MsV0FBVSxPQUFPQSxJQUFHLE1BQU0sVUFBVTtBQUNqQyxRQUFBQSxPQUFNRixPQUFNLFVBQVVFLE1BQUssT0FBTyxHQUFHLE9BQU87QUFBQSxNQUMvQztBQUNELGFBQU9BO0FBQUEsSUFDVjtBQUVELGFBQVN6QixPQUFNLE1BQU0sTUFBTSxTQUFTO0FBQ2hDLFVBQUksT0FBTyxTQUFTLFVBQVU7QUFDMUIsZUFBTyxVQUFVdUIsT0FBTSxNQUFNLE9BQU8sR0FBRyxPQUFPO0FBQUEsTUFDakQsV0FBVSxPQUFPLElBQUksTUFBTSxVQUFVO0FBQ2xDLGVBQU8sVUFBVSxNQUFNLE9BQU87QUFBQSxNQUNqQztBQUNELFVBQUksT0FBTyxTQUFTLFVBQVU7QUFDMUIsZUFBTyxVQUFVQSxPQUFNLE1BQU0sT0FBTyxHQUFHLE9BQU87QUFBQSxNQUNqRCxXQUFVLE9BQU8sSUFBSSxNQUFNLFVBQVU7QUFDbEMsZUFBTyxVQUFVLE1BQU0sT0FBTztBQUFBLE1BQ2pDO0FBQ0QsYUFBTyxTQUFTO0FBQUEsSUFDbkI7QUFFRCxhQUFTLGdCQUFnQixLQUFLLFNBQVM7QUFDbkMsYUFBTyxPQUFPLElBQUksU0FBVSxFQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsUUFBUSxNQUFNLGFBQWEsU0FBUyxhQUFhLFFBQVEsVUFBVTtBQUFBLElBQ3hIO0FBRUQsYUFBUyxrQkFBa0IsS0FBSyxTQUFTO0FBQ3JDLGFBQU8sT0FBTyxJQUFJLFNBQVUsRUFBQyxRQUFRLENBQUMsV0FBVyxDQUFDLFFBQVEsTUFBTSxhQUFhLGNBQWMsYUFBYSxhQUFhLFdBQVc7QUFBQSxJQUNuSTtBQUVELFFBQUksVUFBVTtBQUFBLE1BQ1YsUUFBUTtBQUFBLE1BQ1IsWUFBWTtBQUFBLE1BQ1osT0FBTyxTQUFTQSxPQUFNLFlBQVksU0FBUztBQUV2QyxZQUFJLENBQUMsV0FBVyxNQUFNO0FBQ2xCLHFCQUFXLFFBQVEsV0FBVyxTQUFTO0FBQUEsUUFDMUM7QUFDRCxlQUFPO0FBQUEsTUFDVjtBQUFBLE1BQ0QsV0FBVyxTQUFTRyxXQUFVLFlBQVksU0FBUztBQUMvQyxZQUFJLFNBQVMsT0FBTyxXQUFXLE1BQU0sRUFBRSxZQUFhLE1BQUs7QUFFekQsWUFBSSxXQUFXLFVBQVUsU0FBUyxNQUFNLE9BQU8sV0FBVyxTQUFTLElBQUk7QUFDbkUscUJBQVcsT0FBTztBQUFBLFFBQ3JCO0FBRUQsWUFBSSxDQUFDLFdBQVcsTUFBTTtBQUNsQixxQkFBVyxPQUFPO0FBQUEsUUFDckI7QUFJRCxlQUFPO0FBQUEsTUFDVjtBQUFBLElBQ0w7QUFFQSxRQUFJLFlBQVk7QUFBQSxNQUNaLFFBQVE7QUFBQSxNQUNSLFlBQVksUUFBUTtBQUFBLE1BQ3BCLE9BQU8sUUFBUTtBQUFBLE1BQ2YsV0FBVyxRQUFRO0FBQUEsSUFDdkI7QUFFQSxhQUFTLFNBQVMsY0FBYztBQUM1QixhQUFPLE9BQU8sYUFBYSxXQUFXLFlBQVksYUFBYSxTQUFTLE9BQU8sYUFBYSxNQUFNLEVBQUUsWUFBVyxNQUFPO0FBQUEsSUFDekg7QUFFRCxRQUFJLFlBQVk7QUFBQSxNQUNaLFFBQVE7QUFBQSxNQUNSLFlBQVk7QUFBQSxNQUNaLE9BQU8sU0FBU0gsT0FBTSxZQUFZLFNBQVM7QUFDdkMsWUFBSSxlQUFlO0FBRW5CLHFCQUFhLFNBQVMsU0FBUyxZQUFZO0FBRTNDLHFCQUFhLGdCQUFnQixhQUFhLFFBQVEsUUFBUSxhQUFhLFFBQVEsTUFBTSxhQUFhLFFBQVE7QUFDMUcscUJBQWEsT0FBTztBQUNwQixxQkFBYSxRQUFRO0FBQ3JCLGVBQU87QUFBQSxNQUNWO0FBQUEsTUFDRCxXQUFXLFNBQVNHLFdBQVUsY0FBYyxTQUFTO0FBRWpELFlBQUksYUFBYSxVQUFVLFNBQVMsWUFBWSxJQUFJLE1BQU0sT0FBTyxhQUFhLFNBQVMsSUFBSTtBQUN2Rix1QkFBYSxPQUFPO0FBQUEsUUFDdkI7QUFFRCxZQUFJLE9BQU8sYUFBYSxXQUFXLFdBQVc7QUFDMUMsdUJBQWEsU0FBUyxhQUFhLFNBQVMsUUFBUTtBQUNwRCx1QkFBYSxTQUFTO0FBQUEsUUFDekI7QUFFRCxZQUFJLGFBQWEsY0FBYztBQUMzQixjQUFJLHdCQUF3QixhQUFhLGFBQWEsTUFBTSxHQUFHLEdBQzNELHlCQUF5QixjQUFjLHVCQUF1QixDQUFDLEdBQy9EM0osUUFBTyx1QkFBdUIsQ0FBQyxHQUMvQixRQUFRLHVCQUF1QixDQUFDO0FBRXBDLHVCQUFhLE9BQU9BLFNBQVFBLFVBQVMsTUFBTUEsUUFBTztBQUNsRCx1QkFBYSxRQUFRO0FBQ3JCLHVCQUFhLGVBQWU7QUFBQSxRQUMvQjtBQUVELHFCQUFhLFdBQVc7QUFDeEIsZUFBTztBQUFBLE1BQ1Y7QUFBQSxJQUNMO0FBRUEsUUFBSSxZQUFZO0FBQUEsTUFDWixRQUFRO0FBQUEsTUFDUixZQUFZLFVBQVU7QUFBQSxNQUN0QixPQUFPLFVBQVU7QUFBQSxNQUNqQixXQUFXLFVBQVU7QUFBQSxJQUN6QjtBQUVBLFFBQUksSUFBSSxDQUFBO0FBR1IsUUFBSSxlQUFlO0FBQ25CLFFBQUksV0FBVztBQUNmLFFBQUksZUFBZSxPQUFPLE9BQU8sWUFBWSxXQUFXLE1BQU0sV0FBVyxXQUFXLE1BQU0sV0FBVyxRQUFRLElBQUksTUFBTSxPQUFPLGdCQUFnQixXQUFXLE1BQU0sV0FBVyxRQUFRLElBQUksTUFBTSxPQUFPLE1BQU0sV0FBVyxRQUFRLENBQUM7QUFZN04sUUFBSSxVQUFVO0FBQ2QsUUFBSSxVQUFVO0FBQ2QsUUFBSSxVQUFVLE1BQU0sU0FBUyxXQUFZO0FBQ3pDLFFBQUksZ0JBQWdCO0FBQ3BCLFFBQUksYUFBYSxJQUFJLE9BQU8sY0FBYyxHQUFHO0FBQzdDLFFBQUksY0FBYyxJQUFJLE9BQU8sY0FBYyxHQUFHO0FBQzlDLFFBQUksaUJBQWlCLElBQUksT0FBTyxNQUFNLE9BQU8sU0FBUyxTQUFTLFNBQVMsT0FBTyxHQUFHLEdBQUc7QUFDckYsUUFBSSxhQUFhLElBQUksT0FBTyxNQUFNLE9BQU8sY0FBYyxhQUFhLEdBQUcsR0FBRztBQUMxRSxRQUFJLGNBQWM7QUFDbEIsYUFBUyxpQkFBaUIsS0FBSztBQUMzQixVQUFJLFNBQVMsWUFBWSxHQUFHO0FBQzVCLGFBQU8sQ0FBQyxPQUFPLE1BQU0sVUFBVSxJQUFJLE1BQU07QUFBQSxJQUM1QztBQUNELFFBQUksWUFBWTtBQUFBLE1BQ1osUUFBUTtBQUFBLE1BQ1IsT0FBTyxTQUFTLFNBQVMsWUFBWSxTQUFTO0FBQzFDLFlBQUksbUJBQW1CO0FBQ3ZCLFlBQUksS0FBSyxpQkFBaUIsS0FBSyxpQkFBaUIsT0FBTyxpQkFBaUIsS0FBSyxNQUFNLEdBQUcsSUFBSSxDQUFBO0FBQzFGLHlCQUFpQixPQUFPO0FBQ3hCLFlBQUksaUJBQWlCLE9BQU87QUFDeEIsY0FBSSxpQkFBaUI7QUFDckIsY0FBSSxVQUFVLENBQUE7QUFDZCxjQUFJLFVBQVUsaUJBQWlCLE1BQU0sTUFBTSxHQUFHO0FBQzlDLG1CQUFTLElBQUksR0FBRyxLQUFLLFFBQVEsUUFBUSxJQUFJLElBQUksRUFBRSxHQUFHO0FBQzlDLGdCQUFJLFNBQVMsUUFBUSxDQUFDLEVBQUUsTUFBTSxHQUFHO0FBQ2pDLG9CQUFRLE9BQU8sQ0FBQyxHQUFDO0FBQUEsY0FDYixLQUFLO0FBQ0Qsb0JBQUksVUFBVSxPQUFPLENBQUMsRUFBRSxNQUFNLEdBQUc7QUFDakMseUJBQVMsS0FBSyxHQUFHLE1BQU0sUUFBUSxRQUFRLEtBQUssS0FBSyxFQUFFLElBQUk7QUFDbkQscUJBQUcsS0FBSyxRQUFRLEVBQUUsQ0FBQztBQUFBLGdCQUN0QjtBQUNEO0FBQUEsY0FDSixLQUFLO0FBQ0QsaUNBQWlCLFVBQVUsa0JBQWtCLE9BQU8sQ0FBQyxHQUFHLE9BQU87QUFDL0Q7QUFBQSxjQUNKLEtBQUs7QUFDRCxpQ0FBaUIsT0FBTyxrQkFBa0IsT0FBTyxDQUFDLEdBQUcsT0FBTztBQUM1RDtBQUFBLGNBQ0o7QUFDSSxpQ0FBaUI7QUFDakIsd0JBQVEsa0JBQWtCLE9BQU8sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxJQUFJLGtCQUFrQixPQUFPLENBQUMsR0FBRyxPQUFPO0FBQ3JGO0FBQUEsWUFDUDtBQUFBLFVBQ0o7QUFDRCxjQUFJO0FBQWdCLDZCQUFpQixVQUFVO0FBQUEsUUFDbEQ7QUFDRCx5QkFBaUIsUUFBUTtBQUN6QixpQkFBUyxNQUFNLEdBQUcsT0FBTyxHQUFHLFFBQVEsTUFBTSxNQUFNLEVBQUUsS0FBSztBQUNuRCxjQUFJLE9BQU8sR0FBRyxHQUFHLEVBQUUsTUFBTSxHQUFHO0FBQzVCLGVBQUssQ0FBQyxJQUFJLGtCQUFrQixLQUFLLENBQUMsQ0FBQztBQUNuQyxjQUFJLENBQUMsUUFBUSxnQkFBZ0I7QUFFekIsZ0JBQUk7QUFDQSxtQkFBSyxDQUFDLElBQUksU0FBUyxRQUFRLGtCQUFrQixLQUFLLENBQUMsR0FBRyxPQUFPLEVBQUUsWUFBYSxDQUFBO0FBQUEsWUFDL0UsU0FBUSxHQUFHO0FBQ1IsK0JBQWlCLFFBQVEsaUJBQWlCLFNBQVMsNkVBQTZFO0FBQUEsWUFDbkk7QUFBQSxVQUNqQixPQUFtQjtBQUNILGlCQUFLLENBQUMsSUFBSSxrQkFBa0IsS0FBSyxDQUFDLEdBQUcsT0FBTyxFQUFFO1VBQ2pEO0FBQ0QsYUFBRyxHQUFHLElBQUksS0FBSyxLQUFLLEdBQUc7QUFBQSxRQUMxQjtBQUNELGVBQU87QUFBQSxNQUNWO0FBQUEsTUFDRCxXQUFXLFNBQVMsYUFBYSxrQkFBa0IsU0FBUztBQUN4RCxZQUFJLGFBQWE7QUFDakIsWUFBSSxLQUFLLFFBQVEsaUJBQWlCLEVBQUU7QUFDcEMsWUFBSSxJQUFJO0FBQ0osbUJBQVMsSUFBSSxHQUFHLEtBQUssR0FBRyxRQUFRLElBQUksSUFBSSxFQUFFLEdBQUc7QUFDekMsZ0JBQUksU0FBUyxPQUFPLEdBQUcsQ0FBQyxDQUFDO0FBQ3pCLGdCQUFJLFFBQVEsT0FBTyxZQUFZLEdBQUc7QUFDbEMsZ0JBQUksWUFBWSxPQUFPLE1BQU0sR0FBRyxLQUFLLEVBQUUsUUFBUSxhQUFhLGdCQUFnQixFQUFFLFFBQVEsYUFBYSxXQUFXLEVBQUUsUUFBUSxnQkFBZ0IsVUFBVTtBQUNsSixnQkFBSSxTQUFTLE9BQU8sTUFBTSxRQUFRLENBQUM7QUFFbkMsZ0JBQUk7QUFDQSx1QkFBUyxDQUFDLFFBQVEsTUFBTSxTQUFTLFFBQVEsa0JBQWtCLFFBQVEsT0FBTyxFQUFFLFlBQVcsQ0FBRSxJQUFJLFNBQVMsVUFBVSxNQUFNO0FBQUEsWUFDekgsU0FBUSxHQUFHO0FBQ1IseUJBQVcsUUFBUSxXQUFXLFNBQVMsMERBQTBELENBQUMsUUFBUSxNQUFNLFVBQVUsYUFBYSxvQkFBb0I7QUFBQSxZQUM5SjtBQUNELGVBQUcsQ0FBQyxJQUFJLFlBQVksTUFBTTtBQUFBLFVBQzdCO0FBQ0QscUJBQVcsT0FBTyxHQUFHLEtBQUssR0FBRztBQUFBLFFBQ2hDO0FBQ0QsWUFBSSxVQUFVLGlCQUFpQixVQUFVLGlCQUFpQixXQUFXLENBQUE7QUFDckUsWUFBSSxpQkFBaUI7QUFBUyxrQkFBUSxTQUFTLElBQUksaUJBQWlCO0FBQ3BFLFlBQUksaUJBQWlCO0FBQU0sa0JBQVEsTUFBTSxJQUFJLGlCQUFpQjtBQUM5RCxZQUFJLFNBQVMsQ0FBQTtBQUNiLGlCQUFTLFFBQVEsU0FBUztBQUN0QixjQUFJLFFBQVEsSUFBSSxNQUFNLEVBQUUsSUFBSSxHQUFHO0FBQzNCLG1CQUFPLEtBQUssS0FBSyxRQUFRLGFBQWEsZ0JBQWdCLEVBQUUsUUFBUSxhQUFhLFdBQVcsRUFBRSxRQUFRLFlBQVksVUFBVSxJQUFJLE1BQU0sUUFBUSxJQUFJLEVBQUUsUUFBUSxhQUFhLGdCQUFnQixFQUFFLFFBQVEsYUFBYSxXQUFXLEVBQUUsUUFBUSxhQUFhLFVBQVUsQ0FBQztBQUFBLFVBQzVQO0FBQUEsUUFDSjtBQUNELFlBQUksT0FBTyxRQUFRO0FBQ2YscUJBQVcsUUFBUSxPQUFPLEtBQUssR0FBRztBQUFBLFFBQ3JDO0FBQ0QsZUFBTztBQUFBLE1BQ1Y7QUFBQSxJQUNMO0FBRUEsUUFBSSxZQUFZO0FBRWhCLFFBQUksWUFBWTtBQUFBLE1BQ1osUUFBUTtBQUFBLE1BQ1IsT0FBTyxTQUFTLFNBQVMsWUFBWSxTQUFTO0FBQzFDLFlBQUksVUFBVSxXQUFXLFFBQVEsV0FBVyxLQUFLLE1BQU0sU0FBUztBQUNoRSxZQUFJLGdCQUFnQjtBQUNwQixZQUFJLFNBQVM7QUFDVCxjQUFJLFNBQVMsUUFBUSxVQUFVLGNBQWMsVUFBVTtBQUN2RCxjQUFJLE1BQU0sUUFBUSxDQUFDLEVBQUUsWUFBVztBQUNoQyxjQUFJLE1BQU0sUUFBUSxDQUFDO0FBQ25CLGNBQUksWUFBWSxTQUFTLE9BQU8sUUFBUSxPQUFPO0FBQy9DLGNBQUksZ0JBQWdCLFFBQVEsU0FBUztBQUNyQyx3QkFBYyxNQUFNO0FBQ3BCLHdCQUFjLE1BQU07QUFDcEIsd0JBQWMsT0FBTztBQUNyQixjQUFJLGVBQWU7QUFDZiw0QkFBZ0IsY0FBYyxNQUFNLGVBQWUsT0FBTztBQUFBLFVBQzdEO0FBQUEsUUFDYixPQUFlO0FBQ0gsd0JBQWMsUUFBUSxjQUFjLFNBQVM7QUFBQSxRQUNoRDtBQUNELGVBQU87QUFBQSxNQUNWO0FBQUEsTUFDRCxXQUFXLFNBQVMsYUFBYSxlQUFlLFNBQVM7QUFDckQsWUFBSSxTQUFTLFFBQVEsVUFBVSxjQUFjLFVBQVU7QUFDdkQsWUFBSSxNQUFNLGNBQWM7QUFDeEIsWUFBSSxZQUFZLFNBQVMsT0FBTyxRQUFRLE9BQU87QUFDL0MsWUFBSSxnQkFBZ0IsUUFBUSxTQUFTO0FBQ3JDLFlBQUksZUFBZTtBQUNmLDBCQUFnQixjQUFjLFVBQVUsZUFBZSxPQUFPO0FBQUEsUUFDakU7QUFDRCxZQUFJLGdCQUFnQjtBQUNwQixZQUFJLE1BQU0sY0FBYztBQUN4QixzQkFBYyxRQUFRLE9BQU8sUUFBUSxPQUFPLE1BQU07QUFDbEQsZUFBTztBQUFBLE1BQ1Y7QUFBQSxJQUNMO0FBRUEsUUFBSSxPQUFPO0FBRVgsUUFBSSxZQUFZO0FBQUEsTUFDWixRQUFRO0FBQUEsTUFDUixPQUFPLFNBQVN3SixPQUFNLGVBQWUsU0FBUztBQUMxQyxZQUFJLGlCQUFpQjtBQUNyQix1QkFBZSxPQUFPLGVBQWU7QUFDckMsdUJBQWUsTUFBTTtBQUNyQixZQUFJLENBQUMsUUFBUSxhQUFhLENBQUMsZUFBZSxRQUFRLENBQUMsZUFBZSxLQUFLLE1BQU0sSUFBSSxJQUFJO0FBQ2pGLHlCQUFlLFFBQVEsZUFBZSxTQUFTO0FBQUEsUUFDbEQ7QUFDRCxlQUFPO0FBQUEsTUFDVjtBQUFBLE1BQ0QsV0FBVyxTQUFTRyxXQUFVLGdCQUFnQixTQUFTO0FBQ25ELFlBQUksZ0JBQWdCO0FBRXBCLHNCQUFjLE9BQU8sZUFBZSxRQUFRLElBQUk7QUFDaEQsZUFBTztBQUFBLE1BQ1Y7QUFBQSxJQUNMO0FBRUEsWUFBUSxRQUFRLE1BQU0sSUFBSTtBQUMxQixZQUFRLFVBQVUsTUFBTSxJQUFJO0FBQzVCLFlBQVEsVUFBVSxNQUFNLElBQUk7QUFDNUIsWUFBUSxVQUFVLE1BQU0sSUFBSTtBQUM1QixZQUFRLFVBQVUsTUFBTSxJQUFJO0FBQzVCLFlBQVEsVUFBVSxNQUFNLElBQUk7QUFDNUIsWUFBUSxVQUFVLE1BQU0sSUFBSTtBQUU1QixJQUFBbkksU0FBUSxVQUFVO0FBQ2xCLElBQUFBLFNBQVEsYUFBYTtBQUNyQixJQUFBQSxTQUFRLGNBQWM7QUFDdEIsSUFBQUEsU0FBUSxRQUFRZ0k7QUFDaEIsSUFBQWhJLFNBQVEsb0JBQW9CO0FBQzVCLElBQUFBLFNBQVEsWUFBWTtBQUNwQixJQUFBQSxTQUFRLG9CQUFvQjtBQUM1QixJQUFBQSxTQUFRLFVBQVVwQztBQUNsQixJQUFBb0MsU0FBUSxZQUFZO0FBQ3BCLElBQUFBLFNBQVEsUUFBUXlHO0FBQ2hCLElBQUF6RyxTQUFRLGtCQUFrQjtBQUMxQixJQUFBQSxTQUFRLG9CQUFvQjtBQUU1QixXQUFPLGVBQWVBLFVBQVMsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQUEsRUFFNUQ7OztBQ2g2Q0EsT0FBTyxlQUFlb0ksT0FBUyxjQUFjLEVBQUUsT0FBTyxLQUFJLENBQUU7QUFDNUQsTUFBTSxNQUFNbEs7QUFDWixJQUFJLE9BQU87QUFDSWtLLE1BQUEsVUFBRztBQUFBO0FDSGxCLFNBQU8sZUFBY3BJLFVBQVUsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQzVELEVBQUFBLFNBQWtCLFVBQUFBLFNBQUEsT0FBZUEsZUFBY0EsU0FBb0IsWUFBQUEsU0FBQSxNQUFjQSxhQUFZQSxTQUFxQixhQUFBO0FBQ2xILE1BQUlnSCxjQUFhOUk7QUFDakIsU0FBTyxlQUFlOEIsVUFBUyxjQUFjLEVBQUUsWUFBWSxNQUFNLEtBQUssV0FBWTtBQUFFLFdBQU9nSCxZQUFXO0FBQUEsRUFBVyxFQUFJLENBQUE7QUFDckgsTUFBSTdCLGFBQVkxSDtBQUNoQixTQUFPLGVBQWV1QyxVQUFTLEtBQUssRUFBRSxZQUFZLE1BQU0sS0FBSyxXQUFZO0FBQUUsV0FBT21GLFdBQVU7QUFBQSxFQUFFLEVBQUksQ0FBQTtBQUNsRyxTQUFPLGVBQWVuRixVQUFTLE9BQU8sRUFBRSxZQUFZLE1BQU0sS0FBSyxXQUFZO0FBQUUsV0FBT21GLFdBQVU7QUFBQSxFQUFJLEVBQUksQ0FBQTtBQUN0RyxTQUFPLGVBQWVuRixVQUFTLGFBQWEsRUFBRSxZQUFZLE1BQU0sS0FBSyxXQUFZO0FBQUUsV0FBT21GLFdBQVU7QUFBQSxFQUFVLEVBQUksQ0FBQTtBQUNsSCxTQUFPLGVBQWVuRixVQUFTLE9BQU8sRUFBRSxZQUFZLE1BQU0sS0FBSyxXQUFZO0FBQUUsV0FBT21GLFdBQVU7QUFBQSxFQUFJLEVBQUksQ0FBQTtBQUN0RyxTQUFPLGVBQWVuRixVQUFTLFFBQVEsRUFBRSxZQUFZLE1BQU0sS0FBSyxXQUFZO0FBQUUsV0FBT21GLFdBQVU7QUFBQSxFQUFLLEVBQUksQ0FBQTtBQUN4RyxTQUFPLGVBQWVuRixVQUFTLFdBQVcsRUFBRSxZQUFZLE1BQU0sS0FBSyxXQUFZO0FBQUUsV0FBT21GLFdBQVU7QUFBQSxFQUFRLEVBQUksQ0FBQTtBQUM5RyxRQUFNa0Qsc0JBQXFCM0s7QUFDM0IsUUFBTTRLLGVBQWNwSjtBQUNwQixRQUFNLFVBQVU2QjtBQUNoQixRQUFNd0gsYUFBWXZIO0FBQ2xCLFFBQU0sWUFBWXZEO0FBQ2xCLFFBQU1vSixhQUFZckU7QUFDbEIsUUFBTW9FLGNBQWFuRTtBQUNuQixRQUFNa0MsVUFBU3BCO0FBQ2YsUUFBTSxpQkFBaUI7QUFDdkIsUUFBTSxRQUFRdUQ7QUFDZCxRQUFNLGdCQUFnQixDQUFDLEtBQUssVUFBVSxJQUFJLE9BQU8sS0FBSyxLQUFLO0FBQzNELGdCQUFjLE9BQU87QUFDckIsUUFBTSxzQkFBc0IsQ0FBQyxvQkFBb0IsZUFBZSxhQUFhO0FBQzdFLFFBQU0sa0JBQWtCLG9CQUFJLElBQUk7QUFBQSxJQUM1QjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0osQ0FBQztBQUNELFFBQU0saUJBQWlCO0FBQUEsSUFDbkIsZUFBZTtBQUFBLElBQ2YsUUFBUTtBQUFBLElBQ1IsVUFBVTtBQUFBLElBQ1YsY0FBYztBQUFBLElBQ2QsWUFBWTtBQUFBLElBQ1osYUFBYTtBQUFBLElBQ2IsYUFBYTtBQUFBLElBQ2IsWUFBWTtBQUFBLElBQ1osZ0JBQWdCO0FBQUEsSUFDaEIsZ0JBQWdCO0FBQUEsSUFDaEIsYUFBYTtBQUFBLElBQ2IsZ0JBQWdCO0FBQUEsSUFDaEIsT0FBTztBQUFBLElBQ1AsV0FBVztBQUFBLElBQ1gsV0FBVztBQUFBLEVBQ2Y7QUFDQSxRQUFNLG9CQUFvQjtBQUFBLElBQ3RCLHVCQUF1QjtBQUFBLElBQ3ZCLGtCQUFrQjtBQUFBLElBQ2xCLFNBQVM7QUFBQSxFQUNiO0FBQ0EsUUFBTSxpQkFBaUI7QUFFdkIsV0FBUyxnQkFBZ0IsR0FBRztBQUN4QixRQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJO0FBQ3BHLFVBQU0sSUFBSSxFQUFFO0FBQ1osVUFBTSxTQUFTLEtBQUssRUFBRSxVQUFVLFFBQVEsT0FBTyxTQUFTLFNBQVMsR0FBRztBQUNwRSxVQUFNLFdBQVcsVUFBVSxRQUFRLFVBQVUsU0FBWSxJQUFJLFNBQVM7QUFDdEUsVUFBTSxVQUFVLE1BQU0sS0FBSyxFQUFFLFVBQVUsUUFBUSxPQUFPLFNBQVMsU0FBUyxHQUFHLFlBQVksUUFBUSxPQUFPLFNBQVMsS0FBSztBQUNwSCxVQUFNLGVBQWUsS0FBSyxFQUFFLGlCQUFpQixRQUFRLE9BQU8sU0FBUyxLQUFLLE1BQU07QUFDaEYsV0FBTztBQUFBLE1BQ0gsZUFBZSxNQUFNLEtBQUssRUFBRSxrQkFBa0IsUUFBUSxPQUFPLFNBQVMsS0FBSyxPQUFPLFFBQVEsT0FBTyxTQUFTLEtBQUs7QUFBQSxNQUMvRyxnQkFBZ0IsTUFBTSxLQUFLLEVBQUUsbUJBQW1CLFFBQVEsT0FBTyxTQUFTLEtBQUssT0FBTyxRQUFRLE9BQU8sU0FBUyxLQUFLO0FBQUEsTUFDakgsY0FBYyxNQUFNLEtBQUssRUFBRSxpQkFBaUIsUUFBUSxPQUFPLFNBQVMsS0FBSyxPQUFPLFFBQVEsT0FBTyxTQUFTLEtBQUs7QUFBQSxNQUM3RyxlQUFlLE1BQU0sS0FBSyxFQUFFLGtCQUFrQixRQUFRLE9BQU8sU0FBUyxLQUFLLE9BQU8sUUFBUSxPQUFPLFNBQVMsS0FBSztBQUFBLE1BQy9HLGlCQUFpQixNQUFNLEtBQUssRUFBRSxvQkFBb0IsUUFBUSxPQUFPLFNBQVMsS0FBSyxPQUFPLFFBQVEsT0FBTyxTQUFTLEtBQUs7QUFBQSxNQUNuSCxNQUFNLEVBQUUsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLFVBQVUsT0FBTSxJQUFLLEVBQUUsVUFBVSxPQUFRO0FBQUEsTUFDckUsZUFBZSxLQUFLLEVBQUUsa0JBQWtCLFFBQVEsT0FBTyxTQUFTLEtBQUs7QUFBQSxNQUNyRSxXQUFXLEtBQUssRUFBRSxjQUFjLFFBQVEsT0FBTyxTQUFTLEtBQUs7QUFBQSxNQUM3RCxPQUFPLEtBQUssRUFBRSxVQUFVLFFBQVEsT0FBTyxTQUFTLEtBQUs7QUFBQSxNQUNyRCxXQUFXLEtBQUssRUFBRSxjQUFjLFFBQVEsT0FBTyxTQUFTLEtBQUs7QUFBQSxNQUM3RCxhQUFhLEtBQUssRUFBRSxnQkFBZ0IsUUFBUSxPQUFPLFNBQVMsS0FBSztBQUFBLE1BQ2pFLFdBQVcsS0FBSyxFQUFFLGNBQWMsUUFBUSxPQUFPLFNBQVMsS0FBSztBQUFBLE1BQzdELGdCQUFnQixLQUFLLEVBQUUsbUJBQW1CLFFBQVEsT0FBTyxTQUFTLEtBQUs7QUFBQSxNQUN2RSxpQkFBaUIsS0FBSyxFQUFFLG9CQUFvQixRQUFRLE9BQU8sU0FBUyxLQUFLO0FBQUEsTUFDekUsa0JBQWtCLEtBQUssRUFBRSxxQkFBcUIsUUFBUSxPQUFPLFNBQVMsS0FBSztBQUFBLE1BQzNFLGdCQUFnQixLQUFLLEVBQUUsbUJBQW1CLFFBQVEsT0FBTyxTQUFTLEtBQUs7QUFBQSxNQUN2RSxhQUFhLEtBQUssRUFBRSxnQkFBZ0IsUUFBUSxPQUFPLFNBQVMsS0FBSztBQUFBLE1BQ2pFO0FBQUEsSUFDUjtBQUFBLEVBQ0M7QUFBQSxFQUNELE1BQU0sSUFBSTtBQUFBLElBQ04sWUFBWSxPQUFPLElBQUk7QUFDbkIsV0FBSyxVQUFVO0FBQ2YsV0FBSyxPQUFPO0FBQ1osV0FBSyxVQUFVO0FBQ2YsV0FBSyxnQkFBZ0Isb0JBQUk7QUFDekIsV0FBSyxXQUFXO0FBQ2hCLFdBQUssU0FBUyxvQkFBSTtBQUNsQixhQUFPLEtBQUssT0FBTyxFQUFFLEdBQUcsTUFBTSxHQUFHLGdCQUFnQixJQUFJO0FBQ3JELFlBQU0sRUFBRSxLQUFLLE1BQUssSUFBSyxLQUFLLEtBQUs7QUFDakMsV0FBSyxRQUFRLElBQUksVUFBVSxXQUFXLEVBQUUsT0FBTyxDQUFFLEdBQUUsVUFBVSxpQkFBaUIsS0FBSyxNQUFPLENBQUE7QUFDMUYsV0FBSyxTQUFTLFVBQVUsS0FBSyxNQUFNO0FBQ25DLFlBQU0sWUFBWSxLQUFLO0FBQ3ZCLFdBQUssa0JBQWtCO0FBQ3ZCLFdBQUssWUFBWSxRQUFRLFVBQVE7QUFDakMsbUJBQWEsS0FBSyxNQUFNLGdCQUFnQixNQUFNLGVBQWU7QUFDN0QsbUJBQWEsS0FBSyxNQUFNLG1CQUFtQixNQUFNLGNBQWMsTUFBTTtBQUNyRSxXQUFLLFlBQVkscUJBQXFCLEtBQUssSUFBSTtBQUMvQyxVQUFJLEtBQUs7QUFDTCwwQkFBa0IsS0FBSyxJQUFJO0FBQy9CLFdBQUssaUJBQWdCO0FBQ3JCLFdBQUssc0JBQXFCO0FBQzFCLFVBQUksS0FBSztBQUNMLDJCQUFtQixLQUFLLE1BQU0sS0FBSyxRQUFRO0FBQy9DLFVBQUksT0FBTyxLQUFLLFFBQVE7QUFDcEIsYUFBSyxjQUFjLEtBQUssSUFBSTtBQUNoQyx3QkFBa0IsS0FBSyxJQUFJO0FBQzNCLFdBQUssa0JBQWtCO0FBQUEsSUFDMUI7QUFBQSxJQUNELG1CQUFtQjtBQUNmLFdBQUssV0FBVyxRQUFRO0FBQUEsSUFDM0I7QUFBQSxJQUNELHdCQUF3QjtBQUNwQixZQUFNLEVBQUUsT0FBTyxNQUFNLFNBQVEsSUFBSyxLQUFLO0FBQ3ZDLFVBQUksaUJBQWlCO0FBQ3JCLFVBQUksYUFBYSxNQUFNO0FBQ25CLHlCQUFpQixFQUFFLEdBQUc7QUFDdEIsdUJBQWUsS0FBSyxlQUFlO0FBQ25DLGVBQU8sZUFBZTtBQUFBLE1BQ3pCO0FBQ0QsVUFBSSxRQUFRO0FBQ1IsYUFBSyxjQUFjLGdCQUFnQixlQUFlLFFBQVEsR0FBRyxLQUFLO0FBQUEsSUFDekU7QUFBQSxJQUNELGNBQWM7QUFDVixZQUFNLEVBQUUsTUFBTSxhQUFhLEtBQUs7QUFDaEMsYUFBUSxLQUFLLEtBQUssY0FBYyxPQUFPLFFBQVEsV0FBVyxLQUFLLFFBQVEsS0FBSyxPQUFPO0FBQUEsSUFDdEY7QUFBQSxJQUNELFNBQVMsY0FDVCxNQUNFO0FBQ0UsVUFBSTtBQUNKLFVBQUksT0FBTyxnQkFBZ0IsVUFBVTtBQUNqQyxZQUFJLEtBQUssVUFBVSxZQUFZO0FBQy9CLFlBQUksQ0FBQztBQUNELGdCQUFNLElBQUksTUFBTSw4QkFBOEIsWUFBWSxHQUFHO0FBQUEsTUFDcEUsT0FDSTtBQUNELFlBQUksS0FBSyxRQUFRLFlBQVk7QUFBQSxNQUNoQztBQUNELFlBQU1wQixTQUFRLEVBQUUsSUFBSTtBQUNwQixVQUFJLEVBQUUsWUFBWTtBQUNkLGFBQUssU0FBUyxFQUFFO0FBQ3BCLGFBQU9BO0FBQUEsSUFDVjtBQUFBLElBQ0QsUUFBUU4sU0FBUSxPQUFPO0FBQ25CLFlBQU0sTUFBTSxLQUFLLFdBQVdBLFNBQVEsS0FBSztBQUN6QyxhQUFRLElBQUksWUFBWSxLQUFLLGtCQUFrQixHQUFHO0FBQUEsSUFDckQ7QUFBQSxJQUNELGFBQWFBLFNBQVEsTUFBTTtBQUN2QixVQUFJLE9BQU8sS0FBSyxLQUFLLGNBQWMsWUFBWTtBQUMzQyxjQUFNLElBQUksTUFBTSx5Q0FBeUM7QUFBQSxNQUM1RDtBQUNELFlBQU0sRUFBRSxXQUFVLElBQUssS0FBSztBQUM1QixhQUFPLGdCQUFnQixLQUFLLE1BQU1BLFNBQVEsSUFBSTtBQUM5QyxxQkFBZSxnQkFBZ0IsU0FBUyxPQUFPO0FBQzNDLGNBQU0sZUFBZSxLQUFLLE1BQU0sUUFBUSxPQUFPO0FBQy9DLGNBQU0sTUFBTSxLQUFLLFdBQVcsU0FBUyxLQUFLO0FBQzFDLGVBQU8sSUFBSSxZQUFZLGNBQWMsS0FBSyxNQUFNLEdBQUc7QUFBQSxNQUN0RDtBQUNELHFCQUFlLGVBQWUsTUFBTTtBQUNoQyxZQUFJLFFBQVEsQ0FBQyxLQUFLLFVBQVUsSUFBSSxHQUFHO0FBQy9CLGdCQUFNLGdCQUFnQixLQUFLLE1BQU0sRUFBRSxLQUFJLEdBQUksSUFBSTtBQUFBLFFBQ2xEO0FBQUEsTUFDSjtBQUNELHFCQUFlLGNBQWMsS0FBSztBQUM5QixZQUFJO0FBQ0EsaUJBQU8sS0FBSyxrQkFBa0IsR0FBRztBQUFBLFFBQ3BDLFNBQ00sR0FBRztBQUNOLGNBQUksRUFBRSxhQUFha0QsYUFBWTtBQUMzQixrQkFBTTtBQUNWLHNCQUFZLEtBQUssTUFBTSxDQUFDO0FBQ3hCLGdCQUFNLGtCQUFrQixLQUFLLE1BQU0sRUFBRSxhQUFhO0FBQ2xELGlCQUFPLGNBQWMsS0FBSyxNQUFNLEdBQUc7QUFBQSxRQUN0QztBQUFBLE1BQ0o7QUFDRCxlQUFTLFlBQVksRUFBRSxlQUFlM0IsTUFBSyxXQUFVLEdBQUk7QUFDckQsWUFBSSxLQUFLLEtBQUtBLElBQUcsR0FBRztBQUNoQixnQkFBTSxJQUFJLE1BQU0sYUFBYUEsSUFBRyxrQkFBa0IsVUFBVSxxQkFBcUI7QUFBQSxRQUNwRjtBQUFBLE1BQ0o7QUFDRCxxQkFBZSxrQkFBa0JBLE1BQUs7QUFDbEMsY0FBTSxVQUFVLE1BQU0sWUFBWSxLQUFLLE1BQU1BLElBQUc7QUFDaEQsWUFBSSxDQUFDLEtBQUssS0FBS0EsSUFBRztBQUNkLGdCQUFNLGVBQWUsS0FBSyxNQUFNLFFBQVEsT0FBTztBQUNuRCxZQUFJLENBQUMsS0FBSyxLQUFLQSxJQUFHO0FBQ2QsZUFBSyxVQUFVLFNBQVNBLE1BQUssSUFBSTtBQUFBLE1BQ3hDO0FBQ0QscUJBQWUsWUFBWUEsTUFBSztBQUM1QixjQUFNLElBQUksS0FBSyxTQUFTQSxJQUFHO0FBQzNCLFlBQUk7QUFDQSxpQkFBTztBQUNYLFlBQUk7QUFDQSxpQkFBTyxPQUFPLEtBQUssU0FBU0EsSUFBRyxJQUFJLFdBQVdBLElBQUc7QUFBQSxRQUNwRCxVQUNPO0FBQ0osaUJBQU8sS0FBSyxTQUFTQSxJQUFHO0FBQUEsUUFDM0I7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUFBO0FBQUEsSUFFRCxVQUFVdkIsU0FDVixLQUNBLE9BQ0Esa0JBQWtCLEtBQUssS0FBSyxnQkFDMUI7QUFDRSxVQUFJLE1BQU0sUUFBUUEsT0FBTSxHQUFHO0FBQ3ZCLG1CQUFXLE9BQU9BO0FBQ2QsZUFBSyxVQUFVLEtBQUssUUFBVyxPQUFPLGVBQWU7QUFDekQsZUFBTztBQUFBLE1BQ1Y7QUFDRCxVQUFJNUg7QUFDSixVQUFJLE9BQU80SCxZQUFXLFVBQVU7QUFDNUIsY0FBTSxFQUFFLFNBQVEsSUFBSyxLQUFLO0FBQzFCLFFBQUE1SCxNQUFLNEgsUUFBTyxRQUFRO0FBQ3BCLFlBQUk1SCxRQUFPLFVBQWEsT0FBT0EsT0FBTSxVQUFVO0FBQzNDLGdCQUFNLElBQUksTUFBTSxVQUFVLFFBQVEsaUJBQWlCO0FBQUEsUUFDdEQ7QUFBQSxNQUNKO0FBQ0QsYUFBTSxHQUFJcUosV0FBVSxhQUFhLE9BQU9ySixHQUFFO0FBQzFDLFdBQUssYUFBYSxHQUFHO0FBQ3JCLFdBQUssUUFBUSxHQUFHLElBQUksS0FBSyxXQUFXNEgsU0FBUSxPQUFPLEtBQUssaUJBQWlCLElBQUk7QUFDN0UsYUFBTztBQUFBLElBQ1Y7QUFBQTtBQUFBO0FBQUEsSUFHRCxjQUFjQSxTQUFRLEtBQ3RCLGtCQUFrQixLQUFLLEtBQUssZ0JBQzFCO0FBQ0UsV0FBSyxVQUFVQSxTQUFRLEtBQUssTUFBTSxlQUFlO0FBQ2pELGFBQU87QUFBQSxJQUNWO0FBQUE7QUFBQSxJQUVELGVBQWVBLFNBQVEsaUJBQWlCO0FBQ3BDLFVBQUksT0FBT0EsV0FBVTtBQUNqQixlQUFPO0FBQ1gsVUFBSW9EO0FBQ0osTUFBQUEsV0FBVXBELFFBQU87QUFDakIsVUFBSW9ELGFBQVksVUFBYSxPQUFPQSxZQUFXLFVBQVU7QUFDckQsY0FBTSxJQUFJLE1BQU0sMEJBQTBCO0FBQUEsTUFDN0M7QUFDRCxNQUFBQSxXQUFVQSxZQUFXLEtBQUssS0FBSyxlQUFlLEtBQUs7QUFDbkQsVUFBSSxDQUFDQSxVQUFTO0FBQ1YsYUFBSyxPQUFPLEtBQUssMkJBQTJCO0FBQzVDLGFBQUssU0FBUztBQUNkLGVBQU87QUFBQSxNQUNWO0FBQ0QsWUFBTTlDLFNBQVEsS0FBSyxTQUFTOEMsVUFBU3BELE9BQU07QUFDM0MsVUFBSSxDQUFDTSxVQUFTLGlCQUFpQjtBQUMzQixjQUFNLFVBQVUsd0JBQXdCLEtBQUssV0FBVTtBQUN2RCxZQUFJLEtBQUssS0FBSyxtQkFBbUI7QUFDN0IsZUFBSyxPQUFPLE1BQU0sT0FBTztBQUFBO0FBRXpCLGdCQUFNLElBQUksTUFBTSxPQUFPO0FBQUEsTUFDOUI7QUFDRCxhQUFPQTtBQUFBLElBQ1Y7QUFBQTtBQUFBO0FBQUEsSUFHRCxVQUFVLFFBQVE7QUFDZCxVQUFJO0FBQ0osYUFBTyxRQUFRLE1BQU0sVUFBVSxLQUFLLE1BQU0sTUFBTSxNQUFNO0FBQ2xELGlCQUFTO0FBQ2IsVUFBSSxRQUFRLFFBQVc7QUFDbkIsY0FBTSxFQUFFLFNBQVEsSUFBSyxLQUFLO0FBQzFCLGNBQU0sT0FBTyxJQUFJNkMsV0FBVSxVQUFVLEVBQUUsUUFBUSxDQUFFLEdBQUUsU0FBUSxDQUFFO0FBQzdELGNBQU1BLFdBQVUsY0FBYyxLQUFLLE1BQU0sTUFBTSxNQUFNO0FBQ3JELFlBQUksQ0FBQztBQUNEO0FBQ0osYUFBSyxLQUFLLE1BQU0sSUFBSTtBQUFBLE1BQ3ZCO0FBQ0QsYUFBUSxJQUFJLFlBQVksS0FBSyxrQkFBa0IsR0FBRztBQUFBLElBQ3JEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUtELGFBQWEsY0FBYztBQUN2QixVQUFJLHdCQUF3QixRQUFRO0FBQ2hDLGFBQUssa0JBQWtCLEtBQUssU0FBUyxZQUFZO0FBQ2pELGFBQUssa0JBQWtCLEtBQUssTUFBTSxZQUFZO0FBQzlDLGVBQU87QUFBQSxNQUNWO0FBQ0QsY0FBUSxPQUFPLGNBQVk7QUFBQSxRQUN2QixLQUFLO0FBQ0QsZUFBSyxrQkFBa0IsS0FBSyxPQUFPO0FBQ25DLGVBQUssa0JBQWtCLEtBQUssSUFBSTtBQUNoQyxlQUFLLE9BQU87QUFDWixpQkFBTztBQUFBLFFBQ1gsS0FBSyxVQUFVO0FBQ1gsZ0JBQU0sTUFBTSxVQUFVLEtBQUssTUFBTSxZQUFZO0FBQzdDLGNBQUksT0FBTyxPQUFPO0FBQ2QsaUJBQUssT0FBTyxPQUFPLElBQUksTUFBTTtBQUNqQyxpQkFBTyxLQUFLLFFBQVEsWUFBWTtBQUNoQyxpQkFBTyxLQUFLLEtBQUssWUFBWTtBQUM3QixpQkFBTztBQUFBLFFBQ1Y7QUFBQSxRQUNELEtBQUssVUFBVTtBQUNYLGdCQUFNLFdBQVc7QUFDakIsZUFBSyxPQUFPLE9BQU8sUUFBUTtBQUMzQixjQUFJL0ssTUFBSyxhQUFhLEtBQUssS0FBSyxRQUFRO0FBQ3hDLGNBQUlBLEtBQUk7QUFDSixZQUFBQSxPQUFTLEdBQUFxSixXQUFVLGFBQWFySixHQUFFO0FBQ2xDLG1CQUFPLEtBQUssUUFBUUEsR0FBRTtBQUN0QixtQkFBTyxLQUFLLEtBQUtBLEdBQUU7QUFBQSxVQUN0QjtBQUNELGlCQUFPO0FBQUEsUUFDVjtBQUFBLFFBQ0Q7QUFDSSxnQkFBTSxJQUFJLE1BQU0scUNBQXFDO0FBQUEsTUFDNUQ7QUFBQSxJQUNKO0FBQUE7QUFBQSxJQUVELGNBQWNpTCxjQUFhO0FBQ3ZCLGlCQUFXekQsUUFBT3lEO0FBQ2QsYUFBSyxXQUFXekQsSUFBRztBQUN2QixhQUFPO0FBQUEsSUFDVjtBQUFBLElBQ0QsV0FBVyxVQUFVQSxNQUNuQjtBQUNFLFVBQUlNO0FBQ0osVUFBSSxPQUFPLFlBQVksVUFBVTtBQUM3QixRQUFBQSxXQUFVO0FBQ1YsWUFBSSxPQUFPTixRQUFPLFVBQVU7QUFDeEIsZUFBSyxPQUFPLEtBQUssMERBQTBEO0FBQzNFLFVBQUFBLEtBQUksVUFBVU07QUFBQSxRQUNqQjtBQUFBLE1BQ0osV0FDUSxPQUFPLFlBQVksWUFBWU4sU0FBUSxRQUFXO0FBQ3ZELFFBQUFBLE9BQU07QUFDTixRQUFBTSxXQUFVTixLQUFJO0FBQ2QsWUFBSSxNQUFNLFFBQVFNLFFBQU8sS0FBSyxDQUFDQSxTQUFRLFFBQVE7QUFDM0MsZ0JBQU0sSUFBSSxNQUFNLHdEQUF3RDtBQUFBLFFBQzNFO0FBQUEsTUFDSixPQUNJO0FBQ0QsY0FBTSxJQUFJLE1BQU0sZ0NBQWdDO0FBQUEsTUFDbkQ7QUFDRCxtQkFBYSxLQUFLLE1BQU1BLFVBQVNOLElBQUc7QUFDcEMsVUFBSSxDQUFDQSxNQUFLO0FBQ04sWUFBSUwsUUFBTyxVQUFVVyxVQUFTLENBQUMsUUFBUSxRQUFRLEtBQUssTUFBTSxHQUFHLENBQUM7QUFDOUQsZUFBTztBQUFBLE1BQ1Y7QUFDRCx3QkFBa0IsS0FBSyxNQUFNTixJQUFHO0FBQ2hDLFlBQU0sYUFBYTtBQUFBLFFBQ2YsR0FBR0E7QUFBQSxRQUNILE9BQU0sR0FBSTRCLFlBQVcsY0FBYzVCLEtBQUksSUFBSTtBQUFBLFFBQzNDLGFBQVksR0FBSTRCLFlBQVcsY0FBYzVCLEtBQUksVUFBVTtBQUFBLE1BQ25FO0FBQ1EsT0FBSSxHQUFBTCxRQUFPLFVBQVVXLFVBQVMsV0FBVyxLQUFLLFdBQVcsSUFDbkQsQ0FBQyxNQUFNLFFBQVEsS0FBSyxNQUFNLEdBQUcsVUFBVSxJQUN2QyxDQUFDLE1BQU0sV0FBVyxLQUFLLFFBQVEsQ0FBQ1EsT0FBTSxRQUFRLEtBQUssTUFBTSxHQUFHLFlBQVlBLEVBQUMsQ0FBQyxDQUFDO0FBQ2pGLGFBQU87QUFBQSxJQUNWO0FBQUEsSUFDRCxXQUFXUixVQUFTO0FBQ2hCLFlBQU0sT0FBTyxLQUFLLE1BQU0sSUFBSUEsUUFBTztBQUNuQyxhQUFPLE9BQU8sUUFBUSxXQUFXLEtBQUssYUFBYSxDQUFDLENBQUM7QUFBQSxJQUN4RDtBQUFBO0FBQUEsSUFFRCxjQUFjQSxVQUFTO0FBRW5CLFlBQU0sRUFBRSxNQUFPLElBQUc7QUFDbEIsYUFBTyxNQUFNLFNBQVNBLFFBQU87QUFDN0IsYUFBTyxNQUFNLElBQUlBLFFBQU87QUFDeEIsaUJBQVcsU0FBUyxNQUFNLE9BQU87QUFDN0IsY0FBTSxJQUFJLE1BQU0sTUFBTSxVQUFVLENBQUMsU0FBUyxLQUFLLFlBQVlBLFFBQU87QUFDbEUsWUFBSSxLQUFLO0FBQ0wsZ0JBQU0sTUFBTSxPQUFPLEdBQUcsQ0FBQztBQUFBLE1BQzlCO0FBQ0QsYUFBTztBQUFBLElBQ1Y7QUFBQTtBQUFBLElBRUQsVUFBVSxNQUFNb0QsU0FBUTtBQUNwQixVQUFJLE9BQU9BLFdBQVU7QUFDakIsUUFBQUEsVUFBUyxJQUFJLE9BQU9BLE9BQU07QUFDOUIsV0FBSyxRQUFRLElBQUksSUFBSUE7QUFDckIsYUFBTztBQUFBLElBQ1Y7QUFBQSxJQUNELFdBQVd0QyxVQUFTLEtBQUssUUFDekIsRUFBRSxZQUFZLE1BQU0sVUFBVSxPQUFRLElBQUcsQ0FBRSxHQUN6QztBQUNFLFVBQUksQ0FBQ0EsV0FBVUEsUUFBTyxXQUFXO0FBQzdCLGVBQU87QUFDWCxhQUFPQSxRQUNGLElBQUksQ0FBQyxNQUFNLEdBQUcsT0FBTyxHQUFHLEVBQUUsWUFBWSxJQUFJLEVBQUUsT0FBTyxFQUFFLEVBQ3JELE9BQU8sQ0FBQyxNQUFNLFFBQVEsT0FBTyxZQUFZLEdBQUc7QUFBQSxJQUNwRDtBQUFBLElBQ0QsZ0JBQWdCLFlBQVksc0JBQXNCO0FBQzlDLFlBQU1mLFNBQVEsS0FBSyxNQUFNO0FBQ3pCLG1CQUFhLEtBQUssTUFBTSxLQUFLLFVBQVUsVUFBVSxDQUFDO0FBQ2xELGlCQUFXLGVBQWUsc0JBQXNCO0FBQzVDLGNBQU0sV0FBVyxZQUFZLE1BQU0sR0FBRyxFQUFFLE1BQU0sQ0FBQztBQUMvQyxZQUFJLFdBQVc7QUFDZixtQkFBVyxPQUFPO0FBQ2QscUJBQVcsU0FBUyxHQUFHO0FBQzNCLG1CQUFXLE9BQU9BLFFBQU87QUFDckIsZ0JBQU0sT0FBT0EsT0FBTSxHQUFHO0FBQ3RCLGNBQUksT0FBTyxRQUFRO0FBQ2Y7QUFDSixnQkFBTSxFQUFFLE1BQUssSUFBSyxLQUFLO0FBQ3ZCLGdCQUFNRCxVQUFTLFNBQVMsR0FBRztBQUMzQixjQUFJLFNBQVNBO0FBQ1QscUJBQVMsR0FBRyxJQUFJLGFBQWFBLE9BQU07QUFBQSxRQUMxQztBQUFBLE1BQ0o7QUFDRCxhQUFPO0FBQUEsSUFDVjtBQUFBLElBQ0Qsa0JBQWtCLFNBQVMsT0FBTztBQUM5QixpQkFBVyxVQUFVLFNBQVM7QUFDMUIsY0FBTSxNQUFNLFFBQVEsTUFBTTtBQUMxQixZQUFJLENBQUMsU0FBUyxNQUFNLEtBQUssTUFBTSxHQUFHO0FBQzlCLGNBQUksT0FBTyxPQUFPLFVBQVU7QUFDeEIsbUJBQU8sUUFBUSxNQUFNO0FBQUEsVUFDeEIsV0FDUSxPQUFPLENBQUMsSUFBSSxNQUFNO0FBQ3ZCLGlCQUFLLE9BQU8sT0FBTyxJQUFJLE1BQU07QUFDN0IsbUJBQU8sUUFBUSxNQUFNO0FBQUEsVUFDeEI7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFBQSxJQUNELFdBQVdBLFNBQVEsTUFBTSxRQUFRLGlCQUFpQixLQUFLLEtBQUssZ0JBQWdCLFlBQVksS0FBSyxLQUFLLGVBQWU7QUFDN0csVUFBSTVIO0FBQ0osWUFBTSxFQUFFLFNBQVEsSUFBSyxLQUFLO0FBQzFCLFVBQUksT0FBTzRILFdBQVUsVUFBVTtBQUMzQixRQUFBNUgsTUFBSzRILFFBQU8sUUFBUTtBQUFBLE1BQ3ZCLE9BQ0k7QUFDRCxZQUFJLEtBQUssS0FBSztBQUNWLGdCQUFNLElBQUksTUFBTSx1QkFBdUI7QUFBQSxpQkFDbEMsT0FBT0EsV0FBVTtBQUN0QixnQkFBTSxJQUFJLE1BQU0sa0NBQWtDO0FBQUEsTUFDekQ7QUFDRCxVQUFJLE1BQU0sS0FBSyxPQUFPLElBQUlBLE9BQU07QUFDaEMsVUFBSSxRQUFRO0FBQ1IsZUFBTztBQUNYLGdCQUFTLEdBQUl5QixXQUFVLGFBQWFySixPQUFNLE1BQU07QUFDaEQsWUFBTSxZQUFZcUosV0FBVSxjQUFjLEtBQUssTUFBTXpCLFNBQVEsTUFBTTtBQUNuRSxZQUFNLElBQUltRCxXQUFVLFVBQVUsRUFBRSxRQUFBbkQsU0FBUSxVQUFVLE1BQU0sUUFBUSxVQUFTLENBQUU7QUFDM0UsV0FBSyxPQUFPLElBQUksSUFBSSxRQUFRLEdBQUc7QUFDL0IsVUFBSSxhQUFhLENBQUMsT0FBTyxXQUFXLEdBQUcsR0FBRztBQUV0QyxZQUFJO0FBQ0EsZUFBSyxhQUFhLE1BQU07QUFDNUIsYUFBSyxLQUFLLE1BQU0sSUFBSTtBQUFBLE1BQ3ZCO0FBQ0QsVUFBSTtBQUNBLGFBQUssZUFBZUEsU0FBUSxJQUFJO0FBQ3BDLGFBQU87QUFBQSxJQUNWO0FBQUEsSUFDRCxhQUFhNUgsS0FBSTtBQUNiLFVBQUksS0FBSyxRQUFRQSxHQUFFLEtBQUssS0FBSyxLQUFLQSxHQUFFLEdBQUc7QUFDbkMsY0FBTSxJQUFJLE1BQU0sMEJBQTBCQSxHQUFFLGtCQUFrQjtBQUFBLE1BQ2pFO0FBQUEsSUFDSjtBQUFBLElBQ0Qsa0JBQWtCLEtBQUs7QUFDbkIsVUFBSSxJQUFJO0FBQ0osYUFBSyxtQkFBbUIsR0FBRztBQUFBO0FBRTNCLFFBQUErSyxXQUFVLGNBQWMsS0FBSyxNQUFNLEdBQUc7QUFFMUMsVUFBSSxDQUFDLElBQUk7QUFDTCxjQUFNLElBQUksTUFBTSwwQkFBMEI7QUFDOUMsYUFBTyxJQUFJO0FBQUEsSUFDZDtBQUFBLElBQ0QsbUJBQW1CLEtBQUs7QUFDcEIsWUFBTSxjQUFjLEtBQUs7QUFDekIsV0FBSyxPQUFPLEtBQUs7QUFDakIsVUFBSTtBQUNBLFFBQUFBLFdBQVUsY0FBYyxLQUFLLE1BQU0sR0FBRztBQUFBLE1BQ3pDLFVBQ087QUFDSixhQUFLLE9BQU87QUFBQSxNQUNmO0FBQUEsSUFDSjtBQUFBLEVBQ0o7QUFDRCxFQUFBdkksU0FBQSxVQUFrQjtBQUNsQixNQUFJLGtCQUFrQnFJLG9CQUFtQjtBQUN6QyxNQUFJLGtCQUFrQkMsYUFBWTtBQUNsQyxXQUFTLGFBQWEsV0FBVyxTQUFTLEtBQUssTUFBTSxTQUFTO0FBQzFELGVBQVcsT0FBTyxXQUFXO0FBQ3pCLFlBQU0sTUFBTTtBQUNaLFVBQUksT0FBTztBQUNQLGFBQUssT0FBTyxHQUFHLEVBQUUsR0FBRyxHQUFHLFlBQVksR0FBRyxLQUFLLFVBQVUsR0FBRyxDQUFDLEVBQUU7QUFBQSxJQUNsRTtBQUFBLEVBQ0o7QUFDRCxXQUFTLFVBQVUsUUFBUTtBQUN2QixjQUFhLEdBQUF6QixXQUFVLGFBQWEsTUFBTTtBQUMxQyxXQUFPLEtBQUssUUFBUSxNQUFNLEtBQUssS0FBSyxLQUFLLE1BQU07QUFBQSxFQUNsRDtBQUNELFdBQVMsb0JBQW9CO0FBQ3pCLFVBQU0sY0FBYyxLQUFLLEtBQUs7QUFDOUIsUUFBSSxDQUFDO0FBQ0Q7QUFDSixRQUFJLE1BQU0sUUFBUSxXQUFXO0FBQ3pCLFdBQUssVUFBVSxXQUFXO0FBQUE7QUFFMUIsaUJBQVcsT0FBTztBQUNkLGFBQUssVUFBVSxZQUFZLEdBQUcsR0FBRyxHQUFHO0FBQUEsRUFDL0M7QUFDRCxXQUFTLG9CQUFvQjtBQUN6QixlQUFXLFFBQVEsS0FBSyxLQUFLLFNBQVM7QUFDbEMsWUFBTTZCLFVBQVMsS0FBSyxLQUFLLFFBQVEsSUFBSTtBQUNyQyxVQUFJQTtBQUNBLGFBQUssVUFBVSxNQUFNQSxPQUFNO0FBQUEsSUFDbEM7QUFBQSxFQUNKO0FBQ0QsV0FBUyxtQkFBbUIsTUFBTTtBQUM5QixRQUFJLE1BQU0sUUFBUSxJQUFJLEdBQUc7QUFDckIsV0FBSyxjQUFjLElBQUk7QUFDdkI7QUFBQSxJQUNIO0FBQ0QsU0FBSyxPQUFPLEtBQUssa0RBQWtEO0FBQ25FLGVBQVdwRCxZQUFXLE1BQU07QUFDeEIsWUFBTU4sT0FBTSxLQUFLTSxRQUFPO0FBQ3hCLFVBQUksQ0FBQ04sS0FBSTtBQUNMLFFBQUFBLEtBQUksVUFBVU07QUFDbEIsV0FBSyxXQUFXTixJQUFHO0FBQUEsSUFDdEI7QUFBQSxFQUNKO0FBQ0QsV0FBUyx1QkFBdUI7QUFDNUIsVUFBTSxXQUFXLEVBQUUsR0FBRyxLQUFLLEtBQUk7QUFDL0IsZUFBVyxPQUFPO0FBQ2QsYUFBTyxTQUFTLEdBQUc7QUFDdkIsV0FBTztBQUFBLEVBQ1Y7QUFDRCxRQUFNLFNBQVMsRUFBRSxNQUFNO0FBQUEsRUFBRyxHQUFFLE9BQU87QUFBQSxLQUFLLFFBQVE7QUFBQSxFQUFBO0FBQ2hELFdBQVMsVUFBVSxRQUFRO0FBQ3ZCLFFBQUksV0FBVztBQUNYLGFBQU87QUFDWCxRQUFJLFdBQVc7QUFDWCxhQUFPO0FBQ1gsUUFBSSxPQUFPLE9BQU8sT0FBTyxRQUFRLE9BQU87QUFDcEMsYUFBTztBQUNYLFVBQU0sSUFBSSxNQUFNLG1EQUFtRDtBQUFBLEVBQ3RFO0FBQ0QsUUFBTSxlQUFlO0FBQ3JCLFdBQVMsYUFBYU0sVUFBU04sTUFBSztBQUNoQyxVQUFNLEVBQUUsTUFBTyxJQUFHO0FBQ2xCLEtBQUEsR0FBSUwsUUFBTyxVQUFVVyxVQUFTLENBQUMsUUFBUTtBQUNuQyxVQUFJLE1BQU0sU0FBUyxHQUFHO0FBQ2xCLGNBQU0sSUFBSSxNQUFNLFdBQVcsR0FBRyxxQkFBcUI7QUFDdkQsVUFBSSxDQUFDLGFBQWEsS0FBSyxHQUFHO0FBQ3RCLGNBQU0sSUFBSSxNQUFNLFdBQVcsR0FBRyxtQkFBbUI7QUFBQSxJQUM3RCxDQUFLO0FBQ0QsUUFBSSxDQUFDTjtBQUNEO0FBQ0osUUFBSUEsS0FBSSxTQUFTLEVBQUUsVUFBVUEsUUFBTyxjQUFjQSxPQUFNO0FBQ3BELFlBQU0sSUFBSSxNQUFNLHVEQUF1RDtBQUFBLElBQzFFO0FBQUEsRUFDSjtBQUNELFdBQVMsUUFBUU0sVUFBUyxZQUFZUyxXQUFVO0FBQzVDLFFBQUk7QUFDSixVQUFNLE9BQU8sZUFBZSxRQUFRLGVBQWUsU0FBUyxTQUFTLFdBQVc7QUFDaEYsUUFBSUEsYUFBWTtBQUNaLFlBQU0sSUFBSSxNQUFNLDZDQUE2QztBQUNqRSxVQUFNLEVBQUUsTUFBTyxJQUFHO0FBQ2xCLFFBQUksWUFBWSxPQUFPLE1BQU0sT0FBTyxNQUFNLE1BQU0sS0FBSyxDQUFDLEVBQUUsTUFBTUQsR0FBRyxNQUFLQSxPQUFNQyxTQUFRO0FBQ3BGLFFBQUksQ0FBQyxXQUFXO0FBQ1osa0JBQVksRUFBRSxNQUFNQSxXQUFVLE9BQU8sQ0FBRSxFQUFBO0FBQ3ZDLFlBQU0sTUFBTSxLQUFLLFNBQVM7QUFBQSxJQUM3QjtBQUNELFVBQU0sU0FBU1QsUUFBTyxJQUFJO0FBQzFCLFFBQUksQ0FBQztBQUNEO0FBQ0osVUFBTSxPQUFPO0FBQUEsTUFDVCxTQUFBQTtBQUFBLE1BQ0EsWUFBWTtBQUFBLFFBQ1IsR0FBRztBQUFBLFFBQ0gsT0FBTSxHQUFJc0IsWUFBVyxjQUFjLFdBQVcsSUFBSTtBQUFBLFFBQ2xELGFBQVksR0FBSUEsWUFBVyxjQUFjLFdBQVcsVUFBVTtBQUFBLE1BQ2pFO0FBQUEsSUFDVDtBQUNJLFFBQUksV0FBVztBQUNYLG9CQUFjLEtBQUssTUFBTSxXQUFXLE1BQU0sV0FBVyxNQUFNO0FBQUE7QUFFM0QsZ0JBQVUsTUFBTSxLQUFLLElBQUk7QUFDN0IsVUFBTSxJQUFJdEIsUUFBTyxJQUFJO0FBQ3JCLEtBQUMsS0FBSyxXQUFXLGdCQUFnQixRQUFRLE9BQU8sU0FBUyxTQUFTLEdBQUcsUUFBUSxDQUFDLFFBQVEsS0FBSyxXQUFXLEdBQUcsQ0FBQztBQUFBLEVBQzdHO0FBQ0QsV0FBUyxjQUFjLFdBQVcsTUFBTSxRQUFRO0FBQzVDLFVBQU0sSUFBSSxVQUFVLE1BQU0sVUFBVSxDQUFDLFVBQVUsTUFBTSxZQUFZLE1BQU07QUFDdkUsUUFBSSxLQUFLLEdBQUc7QUFDUixnQkFBVSxNQUFNLE9BQU8sR0FBRyxHQUFHLElBQUk7QUFBQSxJQUNwQyxPQUNJO0FBQ0QsZ0JBQVUsTUFBTSxLQUFLLElBQUk7QUFDekIsV0FBSyxPQUFPLEtBQUssUUFBUSxNQUFNLGlCQUFpQjtBQUFBLElBQ25EO0FBQUEsRUFDSjtBQUNELFdBQVMsa0JBQWtCTixNQUFLO0FBQzVCLFFBQUksRUFBRSxXQUFZLElBQUdBO0FBQ3JCLFFBQUksZUFBZTtBQUNmO0FBQ0osUUFBSUEsS0FBSSxTQUFTLEtBQUssS0FBSztBQUN2QixtQkFBYSxhQUFhLFVBQVU7QUFDeEMsSUFBQUEsS0FBSSxpQkFBaUIsS0FBSyxRQUFRLFlBQVksSUFBSTtBQUFBLEVBQ3JEO0FBQ0QsUUFBTSxXQUFXO0FBQUEsSUFDYixNQUFNO0FBQUEsRUFDVjtBQUNBLFdBQVMsYUFBYUksU0FBUTtBQUMxQixXQUFPLEVBQUUsT0FBTyxDQUFDQSxTQUFRLFFBQVEsRUFBQztBQUFBLEVBQ3JDOzs7OztBQ3RtQkQsT0FBTyxlQUFlLElBQVMsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQzVELE1BQU1KLFFBQU07QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULE9BQU87QUFDSCxVQUFNLElBQUksTUFBTSxzREFBc0Q7QUFBQSxFQUN6RTtBQUNMO0FBQ2UsR0FBQSxVQUFHQTs7QUNQbEIsT0FBTyxlQUFlLEtBQVMsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQzVELElBQUEsVUFBa0IsSUFBQSxjQUFzQjtBQUN4QyxNQUFNLGNBQWM5RztBQUNwQixNQUFNNEcsV0FBU3JIO0FBQ2YsTUFBTTBILGNBQVl6SDtBQUNsQixNQUFNOEgsWUFBVXRHO0FBQ2hCLE1BQU1xSixjQUFZeEg7QUFDbEIsTUFBTTRELFdBQVMzRDtBQUNmLE1BQU1nRSxRQUFNO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxZQUFZO0FBQUEsRUFDWixLQUFLLEtBQUs7QUFDTixVQUFNLEVBQUUsS0FBSyxRQUFRLE1BQU0sR0FBRSxJQUFLO0FBQ2xDLFVBQU0sRUFBRSxRQUFRLFdBQVdWLE1BQUssY0FBYyxNQUFNLE1BQUF2RixNQUFNLElBQUc7QUFDN0QsVUFBTSxFQUFFLEtBQU0sSUFBR3VGO0FBQ2pCLFNBQUssU0FBUyxPQUFPLFNBQVMsU0FBUyxXQUFXLEtBQUs7QUFDbkQsYUFBTyxZQUFXO0FBQ3RCLFVBQU0sV0FBV2lFLFlBQVUsV0FBVyxLQUFLeEosT0FBTSxNQUFNLFFBQVEsSUFBSTtBQUNuRSxRQUFJLGFBQWE7QUFDYixZQUFNLElBQUksWUFBWSxRQUFRLEdBQUcsS0FBSyxhQUFhLFFBQVEsSUFBSTtBQUNuRSxRQUFJLG9CQUFvQndKLFlBQVU7QUFDOUIsYUFBTyxhQUFhLFFBQVE7QUFDaEMsV0FBTyxnQkFBZ0IsUUFBUTtBQUMvQixhQUFTLGNBQWM7QUFDbkIsVUFBSWpFLFNBQVE7QUFDUixlQUFPLFFBQVEsS0FBSyxjQUFjQSxNQUFLQSxLQUFJLE1BQU07QUFDckQsWUFBTSxXQUFXLElBQUksV0FBVyxRQUFRLEVBQUUsS0FBSyxLQUFJLENBQUU7QUFDckQsYUFBTyxRQUFRLE1BQVNhLEdBQUFBLFlBQVUsS0FBTSxRQUFRLGFBQWEsTUFBTSxLQUFLLE1BQU07QUFBQSxJQUNqRjtBQUNELGFBQVMsYUFBYSxLQUFLO0FBQ3ZCLFlBQU0sSUFBSSxZQUFZLEtBQUssR0FBRztBQUM5QixjQUFRLEtBQUssR0FBRyxLQUFLLElBQUksTUFBTTtBQUFBLElBQ2xDO0FBQ0QsYUFBUyxnQkFBZ0IsS0FBSztBQUMxQixZQUFNLFVBQVUsSUFBSSxXQUFXLFVBQVUsS0FBSyxLQUFLLFdBQVcsT0FBTyxFQUFFLEtBQUssS0FBSyxVQUFVQSxZQUFVLFdBQVcsR0FBRyxFQUFDLElBQUssRUFBRSxLQUFLLElBQUcsQ0FBRTtBQUNySSxZQUFNTyxTQUFRLElBQUksS0FBSyxPQUFPO0FBQzlCLFlBQU0sU0FBUyxJQUFJLFVBQVU7QUFBQSxRQUN6QixRQUFRO0FBQUEsUUFDUixXQUFXLENBQUU7QUFBQSxRQUNiLFlBQVlQLFlBQVU7QUFBQSxRQUN0QixjQUFjO0FBQUEsUUFDZCxlQUFlO0FBQUEsTUFDbEIsR0FBRU8sTUFBSztBQUNSLFVBQUksZUFBZSxNQUFNO0FBQ3pCLFVBQUksR0FBR0EsTUFBSztBQUFBLElBQ2Y7QUFBQSxFQUNKO0FBQ0w7QUFDQSxTQUFTLFlBQVksS0FBSyxLQUFLO0FBQzNCLFFBQU0sRUFBRSxJQUFLLElBQUc7QUFDaEIsU0FBTyxJQUFJLFdBQ0wsSUFBSSxXQUFXLFlBQVksRUFBRSxLQUFLLElBQUksVUFBVSxLQUNoRCxHQUFJUCxZQUFVLEtBQU0sSUFBSSxXQUFXLFdBQVcsRUFBRSxLQUFLLEtBQUssQ0FBQztBQUNyRTtBQUNtQixJQUFBLGNBQUc7QUFDdEIsU0FBUyxRQUFRLEtBQUssR0FBRyxLQUFLLFFBQVE7QUFDbEMsUUFBTSxFQUFFLEtBQUssR0FBSSxJQUFHO0FBQ3BCLFFBQU0sRUFBRSxXQUFXLFdBQVdiLE1BQUssS0FBSSxJQUFLO0FBQzVDLFFBQU0sVUFBVSxLQUFLLGNBQWNrQixVQUFRLFFBQVEsT0FBT0wsWUFBVTtBQUNwRSxNQUFJO0FBQ0E7O0FBRUE7QUFDSixXQUFTLGVBQWU7QUFDcEIsUUFBSSxDQUFDYixLQUFJO0FBQ0wsWUFBTSxJQUFJLE1BQU0sd0NBQXdDO0FBQzVELFVBQU1vQixTQUFRLElBQUksSUFBSSxPQUFPO0FBQzdCLFFBQUksSUFBSSxNQUFNO0FBQ1YsVUFBSSxNQUFLLEdBQUlQLFlBQVUsWUFBWSxHQUFJTCxTQUFPLGtCQUFrQixLQUFLLEdBQUcsT0FBTyxDQUFDLEVBQUU7QUFDbEYsdUJBQWlCLENBQUM7QUFDbEIsVUFBSSxDQUFDO0FBQ0QsWUFBSSxPQUFPWSxRQUFPLElBQUk7QUFBQSxJQUM3QixHQUFFLENBQUMsTUFBTTtBQUNOLFVBQUksSUFBT1AsR0FBQUEsWUFBVSxPQUFRLENBQUMsZUFBZSxHQUFHLGVBQWUsS0FBSyxNQUFNLElBQUksTUFBTSxDQUFDLENBQUM7QUFDdEYsb0JBQWMsQ0FBQztBQUNmLFVBQUksQ0FBQztBQUNELFlBQUksT0FBT08sUUFBTyxLQUFLO0FBQUEsSUFDdkMsQ0FBUztBQUNELFFBQUksR0FBR0EsTUFBSztBQUFBLEVBQ2Y7QUFDRCxXQUFTLGNBQWM7QUFDbkIsUUFBSSxRQUFXWixHQUFBQSxTQUFPLGtCQUFrQixLQUFLLEdBQUcsT0FBTyxHQUFHLE1BQU0saUJBQWlCLENBQUMsR0FBRyxNQUFNLGNBQWMsQ0FBQyxDQUFDO0FBQUEsRUFDOUc7QUFDRCxXQUFTLGNBQWNvQyxTQUFRO0FBQzNCLFVBQU0sUUFBTyxHQUFJL0IsWUFBVSxLQUFNK0IsT0FBTTtBQUN2QyxRQUFJLE9BQU8xQixVQUFRLFFBQVEsVUFBYUwsR0FBQUEsWUFBVSxLQUFNSyxVQUFRLFFBQVEsT0FBTyxlQUFlLElBQUksTUFBTUEsVUFBUSxRQUFRLE9BQU8sV0FBVyxJQUFJLEdBQUc7QUFDakosUUFBSSxPQUFPQSxVQUFRLFFBQVEsU0FBUSxHQUFJTCxZQUFVLEtBQU1LLFVBQVEsUUFBUSxPQUFPLFNBQVM7QUFBQSxFQUMxRjtBQUNELFdBQVMsaUJBQWlCMEIsU0FBUTtBQUM5QixRQUFJO0FBQ0osUUFBSSxDQUFDLEdBQUcsS0FBSztBQUNUO0FBQ0osVUFBTSxnQkFBZ0IsS0FBSyxRQUFRLFFBQVEsUUFBUSxTQUFTLFNBQVMsSUFBSSxjQUFjLFFBQVEsT0FBTyxTQUFTLFNBQVMsR0FBRztBQUUzSCxRQUFJLEdBQUcsVUFBVSxNQUFNO0FBQ25CLFVBQUksZ0JBQWdCLENBQUMsYUFBYSxjQUFjO0FBQzVDLFlBQUksYUFBYSxVQUFVLFFBQVc7QUFDbEMsYUFBRyxRQUFRdkMsU0FBTyxlQUFlLE1BQU0sS0FBSyxhQUFhLE9BQU8sR0FBRyxLQUFLO0FBQUEsUUFDM0U7QUFBQSxNQUNKLE9BQ0k7QUFDRCxjQUFNLFFBQVEsSUFBSSxJQUFJLFVBQVMsR0FBSVEsWUFBVSxLQUFNK0IsT0FBTSxrQkFBa0I7QUFDM0UsV0FBRyxRQUFRdkMsU0FBTyxlQUFlLE1BQU0sS0FBSyxPQUFPLEdBQUcsT0FBT1EsWUFBVSxJQUFJO0FBQUEsTUFDOUU7QUFBQSxJQUNKO0FBQ0QsUUFBSSxHQUFHLFVBQVUsTUFBTTtBQUNuQixVQUFJLGdCQUFnQixDQUFDLGFBQWEsY0FBYztBQUM1QyxZQUFJLGFBQWEsVUFBVSxRQUFXO0FBQ2xDLGFBQUcsUUFBUVIsU0FBTyxlQUFlLE1BQU0sS0FBSyxhQUFhLE9BQU8sR0FBRyxLQUFLO0FBQUEsUUFDM0U7QUFBQSxNQUNKLE9BQ0k7QUFDRCxjQUFNckQsU0FBUSxJQUFJLElBQUksVUFBUyxHQUFJNkQsWUFBVSxLQUFNK0IsT0FBTSxrQkFBa0I7QUFDM0UsV0FBRyxRQUFRdkMsU0FBTyxlQUFlLE1BQU0sS0FBS3JELFFBQU8sR0FBRyxPQUFPNkQsWUFBVSxJQUFJO0FBQUEsTUFDOUU7QUFBQSxJQUNKO0FBQUEsRUFDSjtBQUNMO0FBQ2UsSUFBQSxVQUFHO0FBQ0gsSUFBQSxVQUFHSDtBQ3ZIbEIsT0FBTyxlQUFlMkQsUUFBUyxjQUFjLEVBQUUsT0FBTyxLQUFJLENBQUU7QUFDNUQsTUFBTSxPQUFPeks7QUFDYixNQUFNLFFBQVFUO0FBQ2QsTUFBTSxPQUFPO0FBQUEsRUFDVDtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0EsRUFBRSxTQUFTLFdBQVk7QUFBQSxFQUN2QjtBQUFBLEVBQ0EsS0FBSztBQUFBLEVBQ0wsTUFBTTtBQUNWO0FBQ2VrTCxPQUFBLFVBQUc7OztBQ2JsQixPQUFPLGVBQWUsYUFBUyxjQUFjLEVBQUUsT0FBTyxLQUFJLENBQUU7QUFDNUQsTUFBTXhELGNBQVlqSDtBQUNsQixNQUFNLE1BQU1pSCxZQUFVO0FBQ3RCLE1BQU0sT0FBTztBQUFBLEVBQ1QsU0FBUyxFQUFFLE9BQU8sTUFBTSxJQUFJLElBQUksS0FBSyxNQUFNLElBQUksR0FBSTtBQUFBLEVBQ25ELFNBQVMsRUFBRSxPQUFPLE1BQU0sSUFBSSxJQUFJLEtBQUssTUFBTSxJQUFJLEdBQUk7QUFBQSxFQUNuRCxrQkFBa0IsRUFBRSxPQUFPLEtBQUssSUFBSSxJQUFJLElBQUksTUFBTSxJQUFJLElBQUs7QUFBQSxFQUMzRCxrQkFBa0IsRUFBRSxPQUFPLEtBQUssSUFBSSxJQUFJLElBQUksTUFBTSxJQUFJLElBQUs7QUFDL0Q7QUFDQSxNQUFNdEgsVUFBUTtBQUFBLEVBQ1YsU0FBUyxDQUFDLEVBQUUsU0FBQXlILFVBQVMsV0FBVSxPQUFPLEdBQUlILFlBQVUsZUFBZ0IsS0FBS0csUUFBTyxFQUFFLEtBQUssSUFBSSxVQUFVO0FBQUEsRUFDckcsUUFBUSxDQUFDLEVBQUUsU0FBQUEsVUFBUyxXQUFVLE9BQU8sR0FBSUgsWUFBVSxrQkFBbUIsS0FBS0csUUFBTyxFQUFFLEtBQUssWUFBWSxVQUFVO0FBQ25IO0FBQ0EsTUFBTU4sUUFBTTtBQUFBLEVBQ1IsU0FBUyxPQUFPLEtBQUssSUFBSTtBQUFBLEVBQ3pCLE1BQU07QUFBQSxFQUNOLFlBQVk7QUFBQSxFQUNaLE9BQU87QUFBQSxFQUNYLE9BQUluSDtBQUFBQSxFQUNBLEtBQUssS0FBSztBQUNOLFVBQU0sRUFBRSxTQUFBeUgsVUFBUyxNQUFNLFdBQVUsSUFBSztBQUN0QyxRQUFJLGNBQWNILFlBQVUsS0FBTSxJQUFJLElBQUksS0FBS0csUUFBTyxFQUFFLElBQUksSUFBSSxVQUFVLGFBQWEsSUFBSSxHQUFHO0FBQUEsRUFDakc7QUFDTDtBQUNlLFlBQUEsVUFBR047O0FDeEJsQixPQUFPLGVBQWUsWUFBUyxjQUFjLEVBQUUsT0FBTyxLQUFJLENBQUU7QUFDNUQsTUFBTUcsY0FBWWpIO0FBQ2xCLE1BQU1MLFVBQVE7QUFBQSxFQUNWLFNBQVMsQ0FBQyxFQUFFLGtCQUFpQixHQUFJc0gsWUFBVSwyQkFBNEIsVUFBVTtBQUFBLEVBQ2pGLFFBQVEsQ0FBQyxFQUFFLFdBQVUsT0FBV0EsR0FBQUEsWUFBVSxrQkFBbUIsVUFBVTtBQUMzRTtBQUNBLE1BQU1ILFFBQU07QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLFlBQVk7QUFBQSxFQUNaLE9BQU87QUFBQSxFQUNYLE9BQUluSDtBQUFBQSxFQUNBLEtBQUssS0FBSztBQUNOLFVBQU0sRUFBRSxLQUFLLE1BQU0sWUFBWSxHQUFFLElBQUs7QUFFdEMsVUFBTSxPQUFPLEdBQUcsS0FBSztBQUNyQixVQUFNLE1BQU0sSUFBSSxJQUFJLEtBQUs7QUFDekIsVUFBTSxVQUFVLFdBQ05zSCxZQUFVLHlCQUEwQixHQUFHLE9BQU8sR0FBRyxVQUFVLElBQUksTUFDL0RBLEdBQUFBLFlBQVUsS0FBTSxHQUFHLGlCQUFpQixHQUFHO0FBQ2pELFFBQUksY0FBY0EsWUFBVSxNQUFPLFVBQVUsY0FBYyxHQUFHLE1BQU0sSUFBSSxJQUFJLFVBQVUsS0FBSyxPQUFPLElBQUk7QUFBQSxFQUN6RztBQUNMO0FBQ2UsV0FBQSxVQUFHSDs7O0FDdkJsQixPQUFPLGVBQWU0RCxjQUFTLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUc1RCxTQUFTLFdBQVcsS0FBSztBQUNyQixRQUFNLE1BQU0sSUFBSTtBQUNoQixNQUFJLFNBQVM7QUFDYixNQUFJLE1BQU07QUFDVixNQUFJO0FBQ0osU0FBTyxNQUFNLEtBQUs7QUFDZDtBQUNBLFlBQVEsSUFBSSxXQUFXLEtBQUs7QUFDNUIsUUFBSSxTQUFTLFNBQVUsU0FBUyxTQUFVLE1BQU0sS0FBSztBQUVqRCxjQUFRLElBQUksV0FBVyxHQUFHO0FBQzFCLFdBQUssUUFBUSxXQUFZO0FBQ3JCO0FBQUEsSUFDUDtBQUFBLEVBQ0o7QUFDRCxTQUFPO0FBQ1g7QUFDZUEsYUFBQSxVQUFHO0FBQ2xCLFdBQVcsT0FBTztBQ3JCbEIsT0FBTyxlQUFlLGFBQVMsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQzVELE1BQU16RCxjQUFZakg7QUFDbEIsTUFBTXlHLFdBQVNsSDtBQUNmLE1BQU0sZUFBZUM7QUFDckIsTUFBTUcsVUFBUTtBQUFBLEVBQ1YsUUFBUSxFQUFFLFNBQUF5SCxVQUFTLGNBQWM7QUFDN0IsVUFBTSxPQUFPQSxhQUFZLGNBQWMsU0FBUztBQUNoRCxZQUFXSCxHQUFBQSxZQUFVLHFCQUFzQixJQUFJLFNBQVMsVUFBVTtBQUFBLEVBQ3JFO0FBQUEsRUFDRCxRQUFRLENBQUMsRUFBRSxXQUFVLE9BQVdBLEdBQUFBLFlBQVUsYUFBYyxVQUFVO0FBQ3RFO0FBQ0EsTUFBTUgsUUFBTTtBQUFBLEVBQ1IsU0FBUyxDQUFDLGFBQWEsV0FBVztBQUFBLEVBQ2xDLE1BQU07QUFBQSxFQUNOLFlBQVk7QUFBQSxFQUNaLE9BQU87QUFBQSxFQUNYLE9BQUluSDtBQUFBQSxFQUNBLEtBQUssS0FBSztBQUNOLFVBQU0sRUFBRSxTQUFBeUgsVUFBUyxNQUFNLFlBQVksR0FBRSxJQUFLO0FBQzFDLFVBQU0sS0FBS0EsYUFBWSxjQUFjSCxZQUFVLFVBQVUsS0FBS0EsWUFBVSxVQUFVO0FBQ2xGLFVBQU0sTUFBTSxHQUFHLEtBQUssWUFBWSxZQUFZQSxZQUFVLEtBQU0sSUFBSSxhQUFnQkEsR0FBQUEsWUFBVSxNQUFNLEdBQUlSLFNBQU8sU0FBUyxJQUFJLEtBQUssYUFBYSxPQUFPLENBQUMsSUFBSSxJQUFJO0FBQzFKLFFBQUksY0FBY1EsWUFBVSxLQUFNLEdBQUcsSUFBSSxFQUFFLElBQUksVUFBVSxFQUFFO0FBQUEsRUFDOUQ7QUFDTDtBQUNlLFlBQUEsVUFBR0g7O0FDeEJsQixPQUFPLGVBQWUsU0FBUyxjQUFjLEVBQUUsT0FBTyxLQUFJLENBQUU7QUFDNUQsTUFBTUYsV0FBUzVHO0FBQ2YsTUFBTWlILGNBQVkxSDtBQUNsQixNQUFNSSxVQUFRO0FBQUEsRUFDVixTQUFTLENBQUMsRUFBRSxXQUFVLE9BQVdzSCxHQUFBQSxZQUFVLDJCQUE0QixVQUFVO0FBQUEsRUFDakYsUUFBUSxDQUFDLEVBQUUsV0FBVSxPQUFXQSxHQUFBQSxZQUFVLGVBQWdCLFVBQVU7QUFDeEU7QUFDQSxNQUFNSCxRQUFNO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixZQUFZO0FBQUEsRUFDWixPQUFPO0FBQUEsRUFDWCxPQUFJbkg7QUFBQUEsRUFDQSxLQUFLLEtBQUs7QUFDTixVQUFNLEVBQUUsTUFBTSxPQUFPLFFBQUF1SCxTQUFRLFlBQVksR0FBSSxJQUFHO0FBRWhELFVBQU1yRixLQUFJLEdBQUcsS0FBSyxnQkFBZ0IsTUFBTTtBQUN4QyxVQUFNLFNBQVMsU0FBUSxHQUFJb0YsWUFBVSxpQkFBa0IsVUFBVSxLQUFLcEYsRUFBQyxRQUFXK0UsR0FBQUEsU0FBTyxZQUFZLEtBQUtNLE9BQU07QUFDaEgsUUFBSSxjQUFjRCxZQUFVLE1BQU8sTUFBTSxTQUFTLElBQUksR0FBRztBQUFBLEVBQzVEO0FBQ0w7QUFDZSxRQUFBLFVBQUdIOztBQ3JCbEIsT0FBTyxlQUFlLGlCQUFTLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUM1RCxNQUFNRyxjQUFZakg7QUFDbEIsTUFBTUwsVUFBUTtBQUFBLEVBQ1YsUUFBUSxFQUFFLFNBQUF5SCxVQUFTLGNBQWM7QUFDN0IsVUFBTSxPQUFPQSxhQUFZLGtCQUFrQixTQUFTO0FBQ3BELFlBQVdILEdBQUFBLFlBQVUscUJBQXNCLElBQUksU0FBUyxVQUFVO0FBQUEsRUFDckU7QUFBQSxFQUNELFFBQVEsQ0FBQyxFQUFFLFdBQVUsT0FBV0EsR0FBQUEsWUFBVSxhQUFjLFVBQVU7QUFDdEU7QUFDQSxNQUFNSCxRQUFNO0FBQUEsRUFDUixTQUFTLENBQUMsaUJBQWlCLGVBQWU7QUFBQSxFQUMxQyxNQUFNO0FBQUEsRUFDTixZQUFZO0FBQUEsRUFDWixPQUFPO0FBQUEsRUFDWCxPQUFJbkg7QUFBQUEsRUFDQSxLQUFLLEtBQUs7QUFDTixVQUFNLEVBQUUsU0FBQXlILFVBQVMsTUFBTSxXQUFVLElBQUs7QUFDdEMsVUFBTSxLQUFLQSxhQUFZLGtCQUFrQkgsWUFBVSxVQUFVLEtBQUtBLFlBQVUsVUFBVTtBQUN0RixRQUFJLFdBQVUsR0FBSUEsWUFBVSxpQkFBa0IsSUFBSSxZQUFZLEVBQUUsSUFBSSxVQUFVLEVBQUU7QUFBQSxFQUNuRjtBQUNMO0FBQ2UsZ0JBQUEsVUFBR0g7O0FDckJsQixPQUFPLGVBQWUsVUFBUyxjQUFjLEVBQUUsT0FBTyxLQUFJLENBQUU7QUFDNUQsTUFBTUYsV0FBUzVHO0FBQ2YsTUFBTWlILGNBQVkxSDtBQUNsQixNQUFNa0gsV0FBU2pIO0FBQ2YsTUFBTUcsVUFBUTtBQUFBLEVBQ1YsU0FBUyxDQUFDLEVBQUUsUUFBUSxFQUFFLGdCQUFlLEVBQUksVUFBU3NILFlBQVUsb0NBQXFDLGVBQWU7QUFBQSxFQUNoSCxRQUFRLENBQUMsRUFBRSxRQUFRLEVBQUUsZ0JBQWUsRUFBSSxVQUFTQSxZQUFVLHVCQUF3QixlQUFlO0FBQ3RHO0FBQ0EsTUFBTUgsUUFBTTtBQUFBLEVBQ1IsU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sWUFBWTtBQUFBLEVBQ1osT0FBTztBQUFBLEVBQ1gsT0FBSW5IO0FBQUFBLEVBQ0EsS0FBSyxLQUFLO0FBQ04sVUFBTSxFQUFFLEtBQUssUUFBQXVILFNBQVEsWUFBWSxNQUFNLE9BQU8sR0FBSSxJQUFHO0FBQ3JELFVBQU0sRUFBRSxLQUFNLElBQUc7QUFDakIsUUFBSSxDQUFDLFNBQVNBLFFBQU8sV0FBVztBQUM1QjtBQUNKLFVBQU0sVUFBVUEsUUFBTyxVQUFVLEtBQUs7QUFDdEMsUUFBSSxHQUFHO0FBQ0g7O0FBRUE7QUFDSixRQUFJLEtBQUssZ0JBQWdCO0FBQ3JCLFlBQU0sUUFBUSxJQUFJLGFBQWE7QUFDL0IsWUFBTSxFQUFFLGtCQUFpQixJQUFLLElBQUk7QUFDbEMsaUJBQVcsZUFBZUEsU0FBUTtBQUM5QixhQUFLLFVBQVUsUUFBUSxVQUFVLFNBQVMsU0FBUyxNQUFNLFdBQVcsT0FBTyxVQUFhLENBQUMsa0JBQWtCLElBQUksV0FBVyxHQUFHO0FBQ3pILGdCQUFNLGFBQWEsR0FBRyxVQUFVLFNBQVMsR0FBRztBQUM1QyxnQkFBTSxNQUFNLHNCQUFzQixXQUFXLHdCQUF3QixVQUFVO0FBQy9FLFdBQUlULEdBQUFBLFNBQU8saUJBQWlCLElBQUksS0FBSyxHQUFHLEtBQUssY0FBYztBQUFBLFFBQzlEO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFDRCxhQUFTLGdCQUFnQjtBQUNyQixVQUFJLFdBQVcsT0FBTztBQUNsQixZQUFJLFdBQVdRLFlBQVUsS0FBSyxlQUFlO0FBQUEsTUFDaEQsT0FDSTtBQUNELG1CQUFXLFFBQVFDLFNBQVE7QUFDdkIsV0FBQSxHQUFJTixTQUFPLHdCQUF3QixLQUFLLElBQUk7QUFBQSxRQUMvQztBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBQ0QsYUFBUyxrQkFBa0I7QUFDdkIsWUFBTSxVQUFVLElBQUksSUFBSSxTQUFTO0FBQ2pDLFVBQUksV0FBVyxPQUFPO0FBQ2xCLGNBQU1ZLFNBQVEsSUFBSSxJQUFJLFNBQVMsSUFBSTtBQUNuQyxZQUFJLFdBQVdBLFFBQU8sTUFBTSxpQkFBaUIsU0FBU0EsTUFBSyxDQUFDO0FBQzVELFlBQUksR0FBR0EsTUFBSztBQUFBLE1BQ2YsT0FDSTtBQUNELFlBQUksSUFBRyxHQUFJWixTQUFPLGtCQUFrQixLQUFLTSxTQUFRLE9BQU8sQ0FBQztBQUN6RCxTQUFBLEdBQUlOLFNBQU8sbUJBQW1CLEtBQUssT0FBTztBQUMxQyxZQUFJLEtBQUk7QUFBQSxNQUNYO0FBQUEsSUFDSjtBQUNELGFBQVMsa0JBQWtCO0FBQ3ZCLFVBQUksTUFBTSxRQUFRLFlBQVksQ0FBQyxTQUFTO0FBQ3BDLFlBQUksVUFBVSxFQUFFLGlCQUFpQixLQUFNLENBQUE7QUFDdkMsWUFBSSxJQUFHLEdBQUlBLFNBQU8sa0JBQWtCLEtBQUssTUFBTSxNQUFNLEtBQUssYUFBYSxHQUFHLE1BQU0sSUFBSSxNQUFPLENBQUE7QUFBQSxNQUMzRyxDQUFhO0FBQUEsSUFDSjtBQUNELGFBQVMsaUJBQWlCLFNBQVNZLFFBQU87QUFDdEMsVUFBSSxVQUFVLEVBQUUsaUJBQWlCLFFBQVMsQ0FBQTtBQUMxQyxVQUFJLE1BQU0sU0FBUyxZQUFZLE1BQU07QUFDakMsWUFBSSxPQUFPQSxTQUFPLEdBQUlaLFNBQU8sZ0JBQWdCLEtBQUssTUFBTSxTQUFTLEtBQUssYUFBYSxDQUFDO0FBQ3BGLFlBQUksSUFBT0ssR0FBQUEsWUFBVSxLQUFLTyxNQUFLLEdBQUcsTUFBTTtBQUNwQyxjQUFJLE1BQUs7QUFDVCxjQUFJLE1BQUs7QUFBQSxRQUM3QixDQUFpQjtBQUFBLE1BQ2pCLEdBQWVQLFlBQVUsR0FBRztBQUFBLElBQ25CO0FBQUEsRUFDSjtBQUNMO0FBQ2UsU0FBQSxVQUFHSDs7QUM1RWxCLE9BQU8sZUFBZSxZQUFTLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUM1RCxNQUFNRyxjQUFZakg7QUFDbEIsTUFBTUwsVUFBUTtBQUFBLEVBQ1YsUUFBUSxFQUFFLFNBQUF5SCxVQUFTLGNBQWM7QUFDN0IsVUFBTSxPQUFPQSxhQUFZLGFBQWEsU0FBUztBQUMvQyxZQUFXSCxHQUFBQSxZQUFVLHFCQUFzQixJQUFJLFNBQVMsVUFBVTtBQUFBLEVBQ3JFO0FBQUEsRUFDRCxRQUFRLENBQUMsRUFBRSxXQUFVLE9BQVdBLEdBQUFBLFlBQVUsYUFBYyxVQUFVO0FBQ3RFO0FBQ0EsTUFBTUgsUUFBTTtBQUFBLEVBQ1IsU0FBUyxDQUFDLFlBQVksVUFBVTtBQUFBLEVBQ2hDLE1BQU07QUFBQSxFQUNOLFlBQVk7QUFBQSxFQUNaLE9BQU87QUFBQSxFQUNYLE9BQUluSDtBQUFBQSxFQUNBLEtBQUssS0FBSztBQUNOLFVBQU0sRUFBRSxTQUFBeUgsVUFBUyxNQUFNLFdBQVUsSUFBSztBQUN0QyxVQUFNLEtBQUtBLGFBQVksYUFBYUgsWUFBVSxVQUFVLEtBQUtBLFlBQVUsVUFBVTtBQUNqRixRQUFJLGNBQWNBLFlBQVUsS0FBTSxJQUFJLFdBQVcsRUFBRSxJQUFJLFVBQVUsRUFBRTtBQUFBLEVBQ3RFO0FBQ0w7QUFDZSxXQUFBLFVBQUdIOzs7QUNyQmxCLE9BQU8sZUFBZTZELFNBQVMsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBRTVELE1BQU1wQyxTQUFRdkk7QUFDZHVJLE9BQU0sT0FBTztBQUNFb0MsUUFBQSxVQUFHcEM7QUNKbEIsT0FBTyxlQUFlLGFBQVMsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQzVELE1BQU0sYUFBYXZJO0FBQ25CLE1BQU1pSCxjQUFZMUg7QUFDbEIsTUFBTWtILFdBQVNqSDtBQUNmLE1BQU1tTCxZQUFVM0o7QUFDaEIsTUFBTXJCLFVBQVE7QUFBQSxFQUNWLFNBQVMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUcsRUFBQSxPQUFPLEdBQUlzSCxZQUFVLCtDQUFnRCxDQUFDLFFBQVEsQ0FBQztBQUFBLEVBQzNHLFFBQVEsQ0FBQyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUcsRUFBQSxPQUFPLEdBQUlBLFlBQVUsU0FBVSxDQUFDLFFBQVEsQ0FBQztBQUN4RTtBQUNBLE1BQU1ILFFBQU07QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLFlBQVk7QUFBQSxFQUNaLE9BQU87QUFBQSxFQUNYLE9BQUluSDtBQUFBQSxFQUNBLEtBQUssS0FBSztBQUNOLFVBQU0sRUFBRSxLQUFLLE1BQU0sT0FBTyxRQUFBdUgsU0FBUSxjQUFjLFlBQVksR0FBSSxJQUFHO0FBQ25FLFFBQUksQ0FBQyxTQUFTLENBQUNBO0FBQ1g7QUFDSixVQUFNTSxTQUFRLElBQUksSUFBSSxPQUFPO0FBQzdCLFVBQU0sWUFBWSxhQUFhLFNBQVksR0FBQSxXQUFXLGdCQUFnQixhQUFhLEtBQUssSUFBSTtBQUM1RixRQUFJLFdBQVdBLFFBQU8sc0JBQXlCUCxHQUFBQSxZQUFVLEtBQU0sVUFBVSxZQUFZO0FBQ3JGLFFBQUksR0FBR08sTUFBSztBQUNaLGFBQVMsc0JBQXNCO0FBQzNCLFlBQU0sSUFBSSxJQUFJLElBQUksTUFBSyxHQUFJUCxZQUFVLEtBQU0sSUFBSSxTQUFTO0FBQ3hELFlBQU0sSUFBSSxJQUFJLElBQUksR0FBRztBQUNyQixVQUFJLFVBQVUsRUFBRSxHQUFHLEVBQUcsQ0FBQTtBQUN0QixVQUFJLE9BQU9PLFFBQU8sSUFBSTtBQUN0QixVQUFJLElBQU9QLEdBQUFBLFlBQVUsS0FBTSxDQUFDLFFBQVEsT0FBTyxZQUFhLElBQUcsUUFBUSxRQUFRLEdBQUcsQ0FBQyxDQUFDO0FBQUEsSUFDbkY7QUFDRCxhQUFTLGNBQWM7QUFDbkIsYUFBTyxVQUFVLFNBQVMsS0FBSyxDQUFDLFVBQVUsS0FBSyxDQUFDVyxPQUFNQSxPQUFNLFlBQVlBLE9BQU0sT0FBTztBQUFBLElBQ3hGO0FBQ0QsYUFBUyxNQUFNLEdBQUcsR0FBRztBQUNqQixZQUFNLE9BQU8sSUFBSSxLQUFLLE1BQU07QUFDNUIsWUFBTSxhQUFnQixHQUFBLFdBQVcsZ0JBQWdCLFdBQVcsTUFBTSxHQUFHLEtBQUssZUFBZSxXQUFXLFNBQVMsS0FBSztBQUNsSCxZQUFNLFVBQVUsSUFBSSxNQUFNLFlBQWVYLEdBQUFBLFlBQVUsTUFBTztBQUMxRCxVQUFJLEtBQUksR0FBSUEsWUFBVSxNQUFPLENBQUMsT0FBTyxNQUFNO0FBQ3ZDLFlBQUksSUFBSSxPQUFNLEdBQUlBLFlBQVUsS0FBTSxJQUFJLElBQUksQ0FBQyxHQUFHO0FBQzlDLFlBQUksR0FBRyxZQUFXLEdBQUlBLFlBQVUsWUFBYTtBQUM3QyxZQUFJLFVBQVUsU0FBUztBQUNuQixjQUFJLElBQU9BLEdBQUFBLFlBQVUsWUFBYSxJQUFJLGlCQUFnQixHQUFJQSxZQUFVLEtBQU0sSUFBSSxTQUFTO0FBQzNGLFlBQ0ssSUFBRyxHQUFJQSxZQUFVLFlBQWEsT0FBTyxJQUFJLElBQUksaUJBQWlCLE1BQU07QUFDckUsY0FBSSxPQUFPLElBQUcsR0FBSUEsWUFBVSxLQUFNLE9BQU8sSUFBSSxJQUFJLEdBQUc7QUFDcEQsY0FBSSxNQUFLO0FBQ1QsY0FBSSxPQUFPTyxRQUFPLEtBQUssRUFBRSxNQUFLO0FBQUEsUUFDbEQsQ0FBaUIsRUFDSSxNQUFTUCxHQUFBQSxZQUFVLEtBQU0sT0FBTyxJQUFJLElBQUksT0FBTyxDQUFDLEVBQUU7QUFBQSxNQUN2RSxDQUFhO0FBQUEsSUFDSjtBQUNELGFBQVMsT0FBTyxHQUFHLEdBQUc7QUFDbEIsWUFBTSxPQUFNLEdBQUlSLFNBQU8sU0FBUyxLQUFLa0UsVUFBUSxPQUFPO0FBQ3BELFlBQU0sUUFBUSxJQUFJLEtBQUssT0FBTztBQUM5QixVQUFJLE1BQU0sS0FBSyxFQUFFLEtBQUksR0FBSTFELFlBQVUsTUFBTyxDQUFDLE9BQU8sTUFBTSxJQUFJLEtBQVFBLEdBQUFBLFlBQVUsS0FBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxNQUFNLElBQUksT0FBT0EsWUFBVSxLQUFNLEdBQUcsSUFBSSxJQUFJLElBQUksQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sTUFBTTtBQUNqTCxZQUFJLE1BQUs7QUFDVCxZQUFJLE9BQU9PLFFBQU8sS0FBSyxFQUFFLE1BQU0sS0FBSztBQUFBLE1BQ3ZDLENBQUEsQ0FBQyxDQUFDO0FBQUEsSUFDTjtBQUFBLEVBQ0o7QUFDTDtBQUNlLFlBQUEsVUFBR1Y7O0FDN0RsQixPQUFPLGVBQWUsUUFBUyxjQUFjLEVBQUUsT0FBTyxLQUFJLENBQUU7QUFDNUQsTUFBTUcsY0FBWWpIO0FBQ2xCLE1BQU15RyxXQUFTbEg7QUFDZixNQUFNb0wsWUFBVW5MO0FBQ2hCLE1BQU1HLFVBQVE7QUFBQSxFQUNWLFNBQVM7QUFBQSxFQUNULFFBQVEsQ0FBQyxFQUFFLFdBQVUsT0FBV3NILEdBQUFBLFlBQVUsb0JBQXFCLFVBQVU7QUFDN0U7QUFDQSxNQUFNSCxRQUFNO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDWCxPQUFJbkg7QUFBQUEsRUFDQSxLQUFLLEtBQUs7QUFDTixVQUFNLEVBQUUsS0FBSyxNQUFNLE9BQU8sWUFBWSxRQUFBdUgsUUFBUSxJQUFHO0FBQ2pELFFBQUksU0FBVUEsV0FBVSxPQUFPQSxXQUFVLFVBQVc7QUFDaEQsVUFBSSxjQUFjRCxZQUFVLE9BQVdSLEdBQUFBLFNBQU8sU0FBUyxLQUFLa0UsVUFBUSxPQUFPLENBQUMsSUFBSSxJQUFJLEtBQUssVUFBVSxHQUFHO0FBQUEsSUFDekcsT0FDSTtBQUNELFVBQUksTUFBUzFELEdBQUFBLFlBQVUsS0FBTUMsT0FBTSxRQUFRLElBQUksRUFBRTtBQUFBLElBQ3BEO0FBQUEsRUFDSjtBQUNMO0FBQ2UsT0FBQSxVQUFHSjs7QUN0QmxCLE9BQU8sZUFBZSxPQUFTLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUM1RCxNQUFNRyxjQUFZakg7QUFDbEIsTUFBTXlHLFdBQVNsSDtBQUNmLE1BQU0sVUFBVUM7QUFDaEIsTUFBTUcsVUFBUTtBQUFBLEVBQ1YsU0FBUztBQUFBLEVBQ1QsUUFBUSxDQUFDLEVBQUUsV0FBVSxPQUFXc0gsR0FBQUEsWUFBVSxxQkFBc0IsVUFBVTtBQUM5RTtBQUNBLE1BQU1ILFFBQU07QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULFlBQVk7QUFBQSxFQUNaLE9BQU87QUFBQSxFQUNYLE9BQUluSDtBQUFBQSxFQUNBLEtBQUssS0FBSztBQUNOLFVBQU0sRUFBRSxLQUFLLE1BQU0sT0FBTyxRQUFBdUgsU0FBUSxZQUFZLEdBQUksSUFBRztBQUNyRCxRQUFJLENBQUMsU0FBU0EsUUFBTyxXQUFXO0FBQzVCLFlBQU0sSUFBSSxNQUFNLGdDQUFnQztBQUNwRCxVQUFNLFVBQVVBLFFBQU8sVUFBVSxHQUFHLEtBQUs7QUFDekMsUUFBSTtBQUNKLFVBQU0sU0FBUyxNQUFPLFFBQVEsUUFBUSxRQUFRLFNBQVMsTUFBTyxPQUFVVCxHQUFBQSxTQUFPLFNBQVMsS0FBSyxRQUFRLE9BQU87QUFDNUcsUUFBSWU7QUFDSixRQUFJLFdBQVcsT0FBTztBQUNsQixNQUFBQSxTQUFRLElBQUksSUFBSSxPQUFPO0FBQ3ZCLFVBQUksV0FBV0EsUUFBTyxRQUFRO0FBQUEsSUFDakMsT0FDSTtBQUVELFVBQUksQ0FBQyxNQUFNLFFBQVFOLE9BQU07QUFDckIsY0FBTSxJQUFJLE1BQU0sMEJBQTBCO0FBQzlDLFlBQU0sVUFBVSxJQUFJLE1BQU0sV0FBVyxVQUFVO0FBQy9DLE1BQUFNLFVBQVEsR0FBSVAsWUFBVSxJQUFJLEdBQUdDLFFBQU8sSUFBSSxDQUFDLElBQUksTUFBTSxVQUFVLFNBQVMsQ0FBQyxDQUFDLENBQUM7QUFBQSxJQUM1RTtBQUNELFFBQUksS0FBS00sTUFBSztBQUNkLGFBQVMsV0FBVztBQUNoQixVQUFJLE9BQU9BLFFBQU8sS0FBSztBQUN2QixVQUFJLE1BQU0sS0FBSyxZQUFZLENBQUMsTUFBTSxJQUFJLElBQUcsR0FBSVAsWUFBVSxLQUFNLE9BQVEsQ0FBQSxJQUFJLElBQUksS0FBSyxDQUFDLEtBQUssTUFBTSxJQUFJLE9BQU9PLFFBQU8sSUFBSSxFQUFFLE1BQUssQ0FBRSxDQUFDO0FBQUEsSUFDakk7QUFDRCxhQUFTLFVBQVUsU0FBUyxHQUFHO0FBQzNCLFlBQU0sTUFBTU4sUUFBTyxDQUFDO0FBQ3BCLGFBQU8sT0FBTyxRQUFRLFlBQVksUUFBUSxRQUNwQyxHQUFJRCxZQUFVLEtBQU0sT0FBTSxDQUFFLElBQUksSUFBSSxLQUFLLE9BQU8sSUFBSSxDQUFDLFFBQ2pEQSxHQUFBQSxZQUFVLEtBQU0sSUFBSSxRQUFRLEdBQUc7QUFBQSxJQUM1QztBQUFBLEVBQ0o7QUFDTDtBQUNlLE1BQUEsVUFBR0g7QUM3Q2xCLE9BQU8sZUFBZThELGNBQVMsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQzVELE1BQU0sZ0JBQWdCNUs7QUFDdEIsTUFBTSxlQUFlVDtBQUNyQixNQUFNLGdCQUFnQkM7QUFDdEIsTUFBTSxZQUFZd0I7QUFDbEIsTUFBTSxvQkFBb0I2QjtBQUMxQixNQUFNLGFBQWFDO0FBQ25CLE1BQU0sZUFBZXdCO0FBQ3JCLE1BQU0sZ0JBQWdCQztBQUN0QixNQUFNLFVBQVVjO0FBQ2hCLE1BQU0sU0FBU0M7QUFDZixNQUFNLGFBQWE7QUFBQTtBQUFBLEVBRWYsY0FBYztBQUFBLEVBQ2QsYUFBYTtBQUFBO0FBQUEsRUFFYixjQUFjO0FBQUEsRUFDZCxVQUFVO0FBQUE7QUFBQSxFQUVWLGtCQUFrQjtBQUFBLEVBQ2xCLFdBQVc7QUFBQTtBQUFBLEVBRVgsYUFBYTtBQUFBLEVBQ2IsY0FBYztBQUFBO0FBQUEsRUFFZCxFQUFFLFNBQVMsUUFBUSxZQUFZLENBQUMsVUFBVSxPQUFPLEVBQUc7QUFBQSxFQUNwRCxFQUFFLFNBQVMsWUFBWSxZQUFZLFVBQVc7QUFBQSxFQUM5QyxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQ1g7QUFDZXNGLGFBQUEsVUFBRzs7O0FDOUJsQixPQUFPLGVBQWUsaUJBQVMsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQzdCLGdCQUFBLDBCQUFHO0FBQ2xDLE1BQU0zRCxjQUFZakg7QUFDbEIsTUFBTXlHLFdBQVNsSDtBQUNmLE1BQU1JLFVBQVE7QUFBQSxFQUNWLFNBQVMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxJQUFHLEVBQUksVUFBU3NILFlBQVUsK0JBQWdDLEdBQUc7QUFBQSxFQUNuRixRQUFRLENBQUMsRUFBRSxRQUFRLEVBQUUsSUFBRyxFQUFJLFVBQVNBLFlBQVUsYUFBYyxHQUFHO0FBQ3BFO0FBQ0EsTUFBTUgsUUFBTTtBQUFBLEVBQ1IsU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sWUFBWSxDQUFDLFdBQVcsUUFBUTtBQUFBLEVBQ2hDLFFBQVE7QUFBQSxFQUNaLE9BQUluSDtBQUFBQSxFQUNBLEtBQUssS0FBSztBQUNOLFVBQU0sRUFBRSxjQUFjLEdBQUksSUFBRztBQUM3QixVQUFNLEVBQUUsT0FBQXlELE9BQU8sSUFBRztBQUNsQixRQUFJLENBQUMsTUFBTSxRQUFRQSxNQUFLLEdBQUc7QUFDdkIsT0FBQSxHQUFJcUQsU0FBTyxpQkFBaUIsSUFBSSxzRUFBc0U7QUFDdEc7QUFBQSxJQUNIO0FBQ0QsNEJBQXdCLEtBQUtyRCxNQUFLO0FBQUEsRUFDckM7QUFDTDtBQUNBLFNBQVMsd0JBQXdCLEtBQUtBLFFBQU87QUFDekMsUUFBTSxFQUFFLEtBQUssUUFBQThELFNBQVEsTUFBTSxTQUFBRSxVQUFTLEdBQUksSUFBRztBQUMzQyxLQUFHLFFBQVE7QUFDWCxRQUFNLE1BQU0sSUFBSSxNQUFNLFFBQU8sR0FBSUgsWUFBVSxLQUFNLElBQUksU0FBUztBQUM5RCxNQUFJQyxZQUFXLE9BQU87QUFDbEIsUUFBSSxVQUFVLEVBQUUsS0FBSzlELE9BQU0sT0FBUSxDQUFBO0FBQ25DLFFBQUksU0FBUzZELFlBQVUsS0FBTSxHQUFHLE9BQU83RCxPQUFNLE1BQU0sRUFBRTtBQUFBLEVBQ3hELFdBQ1EsT0FBTzhELFdBQVUsWUFBWSxFQUFDLEdBQUlULFNBQU8sbUJBQW1CLElBQUlTLE9BQU0sR0FBRztBQUM5RSxVQUFNTSxTQUFRLElBQUksSUFBSSxVQUFhUCxHQUFBQSxZQUFVLEtBQU0sR0FBRyxPQUFPN0QsT0FBTSxNQUFNLEVBQUU7QUFDM0UsUUFBSSxJQUFPNkQsR0FBQUEsWUFBVSxLQUFLTyxNQUFLLEdBQUcsTUFBTSxjQUFjQSxNQUFLLENBQUM7QUFDNUQsUUFBSSxHQUFHQSxNQUFLO0FBQUEsRUFDZjtBQUNELFdBQVMsY0FBY0EsUUFBTztBQUMxQixRQUFJLFNBQVMsS0FBS3BFLE9BQU0sUUFBUSxLQUFLLENBQUMsTUFBTTtBQUN4QyxVQUFJLFVBQVUsRUFBRSxTQUFBZ0UsVUFBUyxVQUFVLEdBQUcsY0FBY1gsU0FBTyxLQUFLLElBQUssR0FBRWUsTUFBSztBQUM1RSxVQUFJLENBQUMsR0FBRztBQUNKLFlBQUksSUFBT1AsR0FBQUEsWUFBVSxLQUFLTyxNQUFLLEdBQUcsTUFBTSxJQUFJLE1BQUssQ0FBRTtBQUFBLElBQ25FLENBQVM7QUFBQSxFQUNKO0FBQ0w7QUFDK0IsZ0JBQUEsMEJBQUc7QUFDbkIsZ0JBQUEsVUFBR1Y7OztBQzlDbEIsT0FBTyxlQUFlLE9BQVMsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQ3ZDLE1BQUEsZ0JBQUc7QUFDeEIsTUFBTUcsY0FBWWpIO0FBQ2xCLE1BQU15RyxXQUFTbEg7QUFDZixNQUFNcUgsV0FBU3BIO0FBQ2YsTUFBTXNILFFBQU07QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLFlBQVksQ0FBQyxVQUFVLFNBQVMsU0FBUztBQUFBLEVBQ3pDLFFBQVE7QUFBQSxFQUNSLEtBQUssS0FBSztBQUNOLFVBQU0sRUFBRSxRQUFBSSxTQUFRLEdBQUksSUFBRztBQUN2QixRQUFJLE1BQU0sUUFBUUEsT0FBTTtBQUNwQixhQUFPLGNBQWMsS0FBSyxtQkFBbUJBLE9BQU07QUFDdkQsT0FBRyxRQUFRO0FBQ1gsWUFBUVQsU0FBTyxtQkFBbUIsSUFBSVMsT0FBTTtBQUN4QztBQUNKLFFBQUksSUFBT04sR0FBQUEsU0FBTyxlQUFlLEdBQUcsQ0FBQztBQUFBLEVBQ3hDO0FBQ0w7QUFDQSxTQUFTLGNBQWMsS0FBSyxZQUFZLFNBQVMsSUFBSSxRQUFRO0FBQ3pELFFBQU0sRUFBRSxLQUFLLGNBQWMsTUFBTSxTQUFBUSxVQUFTLEdBQUksSUFBRztBQUNqRCxtQkFBaUIsWUFBWTtBQUM3QixNQUFJLEdBQUcsS0FBSyxlQUFlLE9BQU8sVUFBVSxHQUFHLFVBQVUsTUFBTTtBQUMzRCxPQUFHLFFBQVFYLFNBQU8sZUFBZSxNQUFNLEtBQUssT0FBTyxRQUFRLEdBQUcsS0FBSztBQUFBLEVBQ3RFO0FBQ0QsUUFBTWUsU0FBUSxJQUFJLEtBQUssT0FBTztBQUM5QixRQUFNLE1BQU0sSUFBSSxNQUFNLFFBQU8sR0FBSVAsWUFBVSxLQUFNLElBQUksU0FBUztBQUM5RCxTQUFPLFFBQVEsQ0FBQyxLQUFLLE1BQU07QUFDdkIsWUFBUVIsU0FBTyxtQkFBbUIsSUFBSSxHQUFHO0FBQ3JDO0FBQ0osUUFBSSxPQUFPUSxZQUFVLEtBQU0sR0FBRyxNQUFNLENBQUMsSUFBSSxNQUFNLElBQUksVUFBVTtBQUFBLE1BQ3pELFNBQUFHO0FBQUEsTUFDQSxZQUFZO0FBQUEsTUFDWixVQUFVO0FBQUEsSUFDdEIsR0FBV0ksTUFBSyxDQUFDO0FBQ1QsUUFBSSxHQUFHQSxNQUFLO0FBQUEsRUFDcEIsQ0FBSztBQUNELFdBQVMsaUJBQWlCLEtBQUs7QUFDM0IsVUFBTSxFQUFFLE1BQU0sY0FBZSxJQUFHO0FBQ2hDLFVBQU0sSUFBSSxPQUFPO0FBQ2pCLFVBQU0sWUFBWSxNQUFNLElBQUksYUFBYSxNQUFNLElBQUksWUFBWSxJQUFJLFVBQVUsTUFBTTtBQUNuRixRQUFJLEtBQUssZ0JBQWdCLENBQUMsV0FBVztBQUNqQyxZQUFNLE1BQU0sSUFBSUosUUFBTyxRQUFRLENBQUMsb0NBQW9DLFVBQVUsNENBQTRDLGFBQWE7QUFDdkksT0FBSVgsR0FBQUEsU0FBTyxpQkFBaUIsSUFBSSxLQUFLLEtBQUssWUFBWTtBQUFBLElBQ3pEO0FBQUEsRUFDSjtBQUNMO0FBQ3FCLE1BQUEsZ0JBQUc7QUFDVCxNQUFBLFVBQUdLO0FDakRsQixPQUFPLGVBQWUsYUFBUyxjQUFjLEVBQUUsT0FBTyxLQUFJLENBQUU7QUFDNUQsTUFBTStELFlBQVU3SztBQUNoQixNQUFNOEcsUUFBTTtBQUFBLEVBQ1IsU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sWUFBWSxDQUFDLE9BQU87QUFBQSxFQUNwQixRQUFRO0FBQUEsRUFDUixNQUFNLENBQUMsU0FBUSxHQUFJK0QsVUFBUSxlQUFlLEtBQUssT0FBTztBQUMxRDtBQUNlLFlBQUEsVUFBRy9EOztBQ1RsQixPQUFPLGVBQWUsV0FBUyxjQUFjLEVBQUUsT0FBTyxLQUFJLENBQUU7QUFDNUQsTUFBTUcsY0FBWWpIO0FBQ2xCLE1BQU15RyxXQUFTbEg7QUFDZixNQUFNcUgsV0FBU3BIO0FBQ2YsTUFBTXNMLHNCQUFvQjlKO0FBQzFCLE1BQU1yQixVQUFRO0FBQUEsRUFDVixTQUFTLENBQUMsRUFBRSxRQUFRLEVBQUUsSUFBRyxFQUFJLFVBQVNzSCxZQUFVLCtCQUFnQyxHQUFHO0FBQUEsRUFDbkYsUUFBUSxDQUFDLEVBQUUsUUFBUSxFQUFFLElBQUcsRUFBSSxVQUFTQSxZQUFVLGFBQWMsR0FBRztBQUNwRTtBQUNBLE1BQU1ILFFBQU07QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLFlBQVksQ0FBQyxVQUFVLFNBQVM7QUFBQSxFQUNoQyxRQUFRO0FBQUEsRUFDWixPQUFJbkg7QUFBQUEsRUFDQSxLQUFLLEtBQUs7QUFDTixVQUFNLEVBQUUsUUFBQXVILFNBQVEsY0FBYyxHQUFFLElBQUs7QUFDckMsVUFBTSxFQUFFLGFBQUE2RCxhQUFhLElBQUc7QUFDeEIsT0FBRyxRQUFRO0FBQ1gsWUFBUXRFLFNBQU8sbUJBQW1CLElBQUlTLE9BQU07QUFDeEM7QUFDSixRQUFJNkQ7QUFDQSxPQUFBLEdBQUlELG9CQUFrQix5QkFBeUIsS0FBS0MsWUFBVztBQUFBO0FBRS9ELFVBQUksSUFBT25FLEdBQUFBLFNBQU8sZUFBZSxHQUFHLENBQUM7QUFBQSxFQUM1QztBQUNMO0FBQ2UsVUFBQSxVQUFHRTs7QUMzQmxCLE9BQU8sZUFBZSxVQUFTLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUM1RCxNQUFNRyxjQUFZakg7QUFDbEIsTUFBTXlHLFdBQVNsSDtBQUNmLE1BQU1JLFVBQVE7QUFBQSxFQUNWLFNBQVMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxLQUFLLElBQUssRUFBQSxNQUFPLFFBQVEsVUFDekMsR0FBSXNILFlBQVUsNkJBQThCLEdBQUcsb0JBQzNDQSxHQUFBQSxZQUFVLDZCQUE4QixHQUFHLHFCQUFxQixHQUFHO0FBQUEsRUFDN0UsUUFBUSxDQUFDLEVBQUUsUUFBUSxFQUFFLEtBQUssTUFBTyxNQUFLLFFBQVEsVUFBZ0JBLEdBQUFBLFlBQVUsbUJBQW9CLEdBQUcsT0FBTSxHQUFJQSxZQUFVLG1CQUFvQixHQUFHLGtCQUFrQixHQUFHO0FBQ25LO0FBQ0EsTUFBTUgsUUFBTTtBQUFBLEVBQ1IsU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sWUFBWSxDQUFDLFVBQVUsU0FBUztBQUFBLEVBQ2hDLFFBQVE7QUFBQSxFQUNSLGFBQWE7QUFBQSxFQUNqQixPQUFJbkg7QUFBQUEsRUFDQSxLQUFLLEtBQUs7QUFDTixVQUFNLEVBQUUsS0FBSyxRQUFBdUgsU0FBUSxjQUFjLE1BQU0sR0FBSSxJQUFHO0FBQ2hELFFBQUk7QUFDSixRQUFJO0FBQ0osVUFBTSxFQUFFLGFBQWEsWUFBYSxJQUFHO0FBQ3JDLFFBQUksR0FBRyxLQUFLLE1BQU07QUFDZCxZQUFNLGdCQUFnQixTQUFZLElBQUk7QUFDdEMsWUFBTTtBQUFBLElBQ1QsT0FDSTtBQUNELFlBQU07QUFBQSxJQUNUO0FBQ0QsVUFBTSxNQUFNLElBQUksTUFBTSxRQUFPLEdBQUlELFlBQVUsS0FBTSxJQUFJLFNBQVM7QUFDOUQsUUFBSSxVQUFVLEVBQUUsS0FBSyxJQUFLLENBQUE7QUFDMUIsUUFBSSxRQUFRLFVBQWEsUUFBUSxHQUFHO0FBQ2hDLE9BQUEsR0FBSVIsU0FBTyxpQkFBaUIsSUFBSSxzRUFBc0U7QUFDdEc7QUFBQSxJQUNIO0FBQ0QsUUFBSSxRQUFRLFVBQWEsTUFBTSxLQUFLO0FBQ2hDLE9BQUEsR0FBSUEsU0FBTyxpQkFBaUIsSUFBSSxpREFBaUQ7QUFDakYsVUFBSSxLQUFJO0FBQ1I7QUFBQSxJQUNIO0FBQ0QsU0FBUUEsR0FBQUEsU0FBTyxtQkFBbUIsSUFBSVMsT0FBTSxHQUFHO0FBQzNDLFVBQUksUUFBV0QsR0FBQUEsWUFBVSxLQUFNLEdBQUcsT0FBTyxHQUFHO0FBQzVDLFVBQUksUUFBUTtBQUNSLGdCQUFXQSxHQUFBQSxZQUFVLEtBQU0sSUFBSSxPQUFPLEdBQUcsT0FBTyxHQUFHO0FBQ3ZELFVBQUksS0FBSyxJQUFJO0FBQ2I7QUFBQSxJQUNIO0FBQ0QsT0FBRyxRQUFRO0FBQ1gsVUFBTU8sU0FBUSxJQUFJLEtBQUssT0FBTztBQUM5QixRQUFJLFFBQVEsVUFBYSxRQUFRLEdBQUc7QUFDaEMsb0JBQWNBLFFBQU8sTUFBTSxJQUFJLEdBQUdBLFFBQU8sTUFBTSxJQUFJLE1BQU8sQ0FBQSxDQUFDO0FBQUEsSUFDOUQsV0FDUSxRQUFRLEdBQUc7QUFDaEIsVUFBSSxJQUFJQSxRQUFPLElBQUk7QUFDbkIsVUFBSSxRQUFRO0FBQ1IsWUFBSSxJQUFPUCxHQUFBQSxZQUFVLEtBQU0sSUFBSSxlQUFlLHNCQUFzQjtBQUFBLElBQzNFLE9BQ0k7QUFDRCxVQUFJLElBQUlPLFFBQU8sS0FBSztBQUNwQjtJQUNIO0FBQ0QsUUFBSSxPQUFPQSxRQUFPLE1BQU0sSUFBSSxNQUFPLENBQUE7QUFDbkMsYUFBUyx5QkFBeUI7QUFDOUIsWUFBTSxXQUFXLElBQUksS0FBSyxRQUFRO0FBQ2xDLFlBQU0sUUFBUSxJQUFJLElBQUksU0FBUyxDQUFDO0FBQ2hDLG9CQUFjLFVBQVUsTUFBTSxJQUFJLEdBQUcsVUFBVSxNQUFNLFlBQVksS0FBSyxDQUFDLENBQUM7QUFBQSxJQUMzRTtBQUNELGFBQVMsY0FBYyxRQUFRLE9BQU87QUFDbEMsVUFBSSxTQUFTLEtBQUssR0FBRyxLQUFLLENBQUMsTUFBTTtBQUM3QixZQUFJLFVBQVU7QUFBQSxVQUNWLFNBQVM7QUFBQSxVQUNULFVBQVU7QUFBQSxVQUNWLGNBQWNmLFNBQU8sS0FBSztBQUFBLFVBQzFCLGVBQWU7QUFBQSxRQUNsQixHQUFFLE1BQU07QUFDVDtNQUNoQixDQUFhO0FBQUEsSUFDSjtBQUNELGFBQVMsWUFBWSxPQUFPO0FBQ3hCLFVBQUksTUFBSyxHQUFJUSxZQUFVLEtBQU0sS0FBSyxJQUFJO0FBQ3RDLFVBQUksUUFBUSxRQUFXO0FBQ25CLFlBQUksT0FBT0EsWUFBVSxLQUFNLEtBQUssT0FBTyxHQUFHLElBQUksTUFBTSxJQUFJLE9BQU9PLFFBQU8sSUFBSSxFQUFFLE1BQUssQ0FBRTtBQUFBLE1BQ3RGLE9BQ0k7QUFDRCxZQUFJLE9BQU9QLFlBQVUsS0FBTSxLQUFLLE1BQU0sR0FBRyxJQUFJLE1BQU0sSUFBSSxPQUFPTyxRQUFPLEtBQUssRUFBRSxNQUFLLENBQUU7QUFDbkYsWUFBSSxRQUFRO0FBQ1IsY0FBSSxPQUFPQSxRQUFPLElBQUk7QUFBQTtBQUV0QixjQUFJLElBQU9QLEdBQUFBLFlBQVUsS0FBTSxLQUFLLE9BQU8sR0FBRyxJQUFJLE1BQU0sSUFBSSxPQUFPTyxRQUFPLElBQUksQ0FBQztBQUFBLE1BQ2xGO0FBQUEsSUFDSjtBQUFBLEVBQ0o7QUFDTDtBQUNlLFNBQUEsVUFBR1Y7OztBQzVGbEIsU0FBTyxlQUFjaEYsVUFBVSxjQUFjLEVBQUUsT0FBTyxLQUFJLENBQUU7QUFDNUQsRUFBQUEsU0FBQSxxQkFBNkJBLFNBQStCLHVCQUFBQSxTQUFBLFFBQWdCO0FBQzVFLFFBQU1tRixhQUFZakg7QUFDbEIsUUFBTXlHLFVBQVNsSDtBQUNmLFFBQU1xSCxVQUFTcEg7QUFDZixFQUFBc0MsU0FBZ0IsUUFBQTtBQUFBLElBQ1osU0FBUyxDQUFDLEVBQUUsUUFBUSxFQUFFLFVBQVUsV0FBVyxLQUFJLFFBQVM7QUFDcEQsWUFBTSxlQUFlLGNBQWMsSUFBSSxhQUFhO0FBQ3BELGlCQUFXbUYsV0FBVSxpQkFBa0IsWUFBWSxJQUFJLElBQUksa0JBQWtCLFFBQVE7QUFBQSxJQUN4RjtBQUFBLElBQ0QsUUFBUSxDQUFDLEVBQUUsUUFBUSxFQUFFLFVBQVUsV0FBVyxNQUFNLGdCQUFpQixFQUFBLE9BQU8sR0FBSUEsV0FBVSxnQkFBaUIsUUFBUTtBQUFBLHVCQUM1RixlQUFlO0FBQUEsaUJBQ3JCLFNBQVM7QUFBQSxZQUNkLElBQUk7QUFBQTtBQUFBLEVBQ2hCO0FBQ0EsUUFBTUgsT0FBTTtBQUFBLElBQ1IsU0FBUztBQUFBLElBQ1QsTUFBTTtBQUFBLElBQ04sWUFBWTtBQUFBLElBQ1osT0FBT2hGLFNBQVE7QUFBQSxJQUNmLEtBQUssS0FBSztBQUNOLFlBQU0sQ0FBQyxVQUFVLE9BQU8sSUFBSSxrQkFBa0IsR0FBRztBQUNqRCwyQkFBcUIsS0FBSyxRQUFRO0FBQ2xDLHlCQUFtQixLQUFLLE9BQU87QUFBQSxJQUNsQztBQUFBLEVBQ0w7QUFDQSxXQUFTLGtCQUFrQixFQUFFLFFBQUFvRixXQUFVO0FBQ25DLFVBQU0sZUFBZSxDQUFBO0FBQ3JCLFVBQU0sYUFBYSxDQUFBO0FBQ25CLGVBQVcsT0FBT0EsU0FBUTtBQUN0QixVQUFJLFFBQVE7QUFDUjtBQUNKLFlBQU0sT0FBTyxNQUFNLFFBQVFBLFFBQU8sR0FBRyxDQUFDLElBQUksZUFBZTtBQUN6RCxXQUFLLEdBQUcsSUFBSUEsUUFBTyxHQUFHO0FBQUEsSUFDekI7QUFDRCxXQUFPLENBQUMsY0FBYyxVQUFVO0FBQUEsRUFDbkM7QUFDRCxXQUFTLHFCQUFxQixLQUFLLGVBQWUsSUFBSSxRQUFRO0FBQzFELFVBQU0sRUFBRSxLQUFLLE1BQU0sR0FBRSxJQUFLO0FBQzFCLFFBQUksT0FBTyxLQUFLLFlBQVksRUFBRSxXQUFXO0FBQ3JDO0FBQ0osVUFBTSxVQUFVLElBQUksSUFBSSxTQUFTO0FBQ2pDLGVBQVcsUUFBUSxjQUFjO0FBQzdCLFlBQU0sT0FBTyxhQUFhLElBQUk7QUFDOUIsVUFBSSxLQUFLLFdBQVc7QUFDaEI7QUFDSixZQUFNLGVBQWMsR0FBSU4sUUFBTyxnQkFBZ0IsS0FBSyxNQUFNLE1BQU0sR0FBRyxLQUFLLGFBQWE7QUFDckYsVUFBSSxVQUFVO0FBQUEsUUFDVixVQUFVO0FBQUEsUUFDVixXQUFXLEtBQUs7QUFBQSxRQUNoQixNQUFNLEtBQUssS0FBSyxJQUFJO0FBQUEsTUFDaEMsQ0FBUztBQUNELFVBQUksR0FBRyxXQUFXO0FBQ2QsWUFBSSxHQUFHLGFBQWEsTUFBTTtBQUN0QixxQkFBVyxXQUFXLE1BQU07QUFDeEIsYUFBQSxHQUFJQSxRQUFPLHdCQUF3QixLQUFLLE9BQU87QUFBQSxVQUNsRDtBQUFBLFFBQ2pCLENBQWE7QUFBQSxNQUNKLE9BQ0k7QUFDRCxZQUFJLElBQU8sR0FBQUssV0FBVSxLQUFNLFdBQVcsU0FBWSxHQUFBTCxRQUFPLGtCQUFrQixLQUFLLE1BQU0sT0FBTyxDQUFDLEdBQUc7QUFDakcsU0FBQSxHQUFJQSxRQUFPLG1CQUFtQixLQUFLLE9BQU87QUFDMUMsWUFBSSxLQUFJO0FBQUEsTUFDWDtBQUFBLElBQ0o7QUFBQSxFQUNKO0FBQ0QsRUFBQTlFLFNBQUEsdUJBQStCO0FBQy9CLFdBQVMsbUJBQW1CLEtBQUssYUFBYSxJQUFJLFFBQVE7QUFDdEQsVUFBTSxFQUFFLEtBQUssTUFBTSxTQUFBc0YsVUFBUyxHQUFFLElBQUs7QUFDbkMsVUFBTUksU0FBUSxJQUFJLEtBQUssT0FBTztBQUM5QixlQUFXLFFBQVEsWUFBWTtBQUMzQixXQUFJLEdBQUlmLFFBQU8sbUJBQW1CLElBQUksV0FBVyxJQUFJLENBQUM7QUFDbEQ7QUFDSixVQUFJO0FBQUEsWUFBT0csUUFBTyxnQkFBZ0IsS0FBSyxNQUFNLE1BQU0sR0FBRyxLQUFLLGFBQWE7QUFBQSxRQUFHLE1BQU07QUFDN0UsZ0JBQU0sU0FBUyxJQUFJLFVBQVUsRUFBRSxTQUFBUSxVQUFTLFlBQVksUUFBUUksTUFBSztBQUNqRSxjQUFJLG9CQUFvQixRQUFRQSxNQUFLO0FBQUEsUUFDeEM7QUFBQSxRQUFFLE1BQU0sSUFBSSxJQUFJQSxRQUFPLElBQUk7QUFBQTtBQUFBLE1BQ3BDO0FBQ1EsVUFBSSxHQUFHQSxNQUFLO0FBQUEsSUFDZjtBQUFBLEVBQ0o7QUFDRCxFQUFBMUYsU0FBQSxxQkFBNkI7QUFDN0IsRUFBQUEsU0FBQSxVQUFrQmdGOzs7QUNsRmxCLE9BQU8sZUFBZSxlQUFTLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUM1RCxNQUFNRyxjQUFZakg7QUFDbEIsTUFBTXlHLFdBQVNsSDtBQUNmLE1BQU1JLFVBQVE7QUFBQSxFQUNWLFNBQVM7QUFBQSxFQUNULFFBQVEsQ0FBQyxFQUFFLE9BQVEsVUFBU3NILFlBQVUsb0JBQXFCLE9BQU8sWUFBWTtBQUNsRjtBQUNBLE1BQU1ILFFBQU07QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLFlBQVksQ0FBQyxVQUFVLFNBQVM7QUFBQSxFQUNwQyxPQUFJbkg7QUFBQUEsRUFDQSxLQUFLLEtBQUs7QUFDTixVQUFNLEVBQUUsS0FBSyxRQUFBdUgsU0FBUSxNQUFNLEdBQUUsSUFBSztBQUNsQyxZQUFRVCxTQUFPLG1CQUFtQixJQUFJUyxPQUFNO0FBQ3hDO0FBQ0osVUFBTU0sU0FBUSxJQUFJLEtBQUssT0FBTztBQUM5QixRQUFJLE1BQU0sT0FBTyxNQUFNLENBQUMsUUFBUTtBQUM1QixVQUFJLFVBQVUsRUFBRSxjQUFjLElBQUssQ0FBQTtBQUNuQyxVQUFJLFVBQVU7QUFBQSxRQUNWLFNBQVM7QUFBQSxRQUNULE1BQU07QUFBQSxRQUNOLFdBQVcsQ0FBQyxRQUFRO0FBQUEsUUFDcEIsY0FBYztBQUFBLFFBQ2QsZUFBZTtBQUFBLE1BQ2xCLEdBQUVBLE1BQUs7QUFDUixVQUFJLElBQU9QLEdBQUFBLFlBQVUsS0FBS08sTUFBSyxHQUFHLE1BQU07QUFDcEMsWUFBSSxNQUFNLElBQUk7QUFDZCxZQUFJLENBQUMsR0FBRztBQUNKLGNBQUksTUFBSztBQUFBLE1BQzdCLENBQWE7QUFBQSxJQUNiLENBQVM7QUFDRCxRQUFJLEdBQUdBLE1BQUs7QUFBQSxFQUNmO0FBQ0w7QUFDZSxjQUFBLFVBQUdWOztBQ25DbEIsT0FBTyxlQUFlLHNCQUFTLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUM1RCxNQUFNRixXQUFTNUc7QUFDZixNQUFNaUgsY0FBWTFIO0FBQ2xCLE1BQU0sVUFBVUM7QUFDaEIsTUFBTWlILFdBQVN6RjtBQUNmLE1BQU1yQixVQUFRO0FBQUEsRUFDVixTQUFTO0FBQUEsRUFDVCxRQUFRLENBQUMsRUFBRSxPQUFRLFVBQVNzSCxZQUFVLDBCQUEyQixPQUFPLGtCQUFrQjtBQUM5RjtBQUNBLE1BQU1ILFFBQU07QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULE1BQU0sQ0FBQyxRQUFRO0FBQUEsRUFDZixZQUFZLENBQUMsV0FBVyxRQUFRO0FBQUEsRUFDaEMsZ0JBQWdCO0FBQUEsRUFDaEIsYUFBYTtBQUFBLEVBQ2pCLE9BQUluSDtBQUFBQSxFQUNBLEtBQUssS0FBSztBQUNOLFVBQU0sRUFBRSxLQUFLLFFBQUF1SCxTQUFRLGNBQWMsTUFBTSxXQUFXLEdBQUksSUFBRztBQUUzRCxRQUFJLENBQUM7QUFDRCxZQUFNLElBQUksTUFBTSwwQkFBMEI7QUFDOUMsVUFBTSxFQUFFLFdBQVcsS0FBTSxJQUFHO0FBQzVCLE9BQUcsUUFBUTtBQUNYLFFBQUksS0FBSyxxQkFBcUIsVUFBYVQsR0FBQUEsU0FBTyxtQkFBbUIsSUFBSVMsT0FBTTtBQUMzRTtBQUNKLFVBQU0sU0FBUSxHQUFJTixTQUFPLHFCQUFxQixhQUFhLFVBQVU7QUFDckUsVUFBTSxZQUFXLEdBQUlBLFNBQU8scUJBQXFCLGFBQWEsaUJBQWlCO0FBQy9FO0FBQ0EsUUFBSSxPQUFPSyxZQUFVLEtBQU0sU0FBUyxRQUFRLFFBQVEsUUFBUSxNQUFNLEVBQUU7QUFDcEUsYUFBUyw0QkFBNEI7QUFDakMsVUFBSSxNQUFNLE9BQU8sTUFBTSxDQUFDLFFBQVE7QUFDNUIsWUFBSSxDQUFDLE1BQU0sVUFBVSxDQUFDLFNBQVM7QUFDM0IsaUNBQXVCLEdBQUc7QUFBQTtBQUUxQixjQUFJLEdBQUcsYUFBYSxHQUFHLEdBQUcsTUFBTSx1QkFBdUIsR0FBRyxDQUFDO0FBQUEsTUFDL0UsQ0FBYTtBQUFBLElBQ0o7QUFDRCxhQUFTLGFBQWEsS0FBSztBQUN2QixVQUFJO0FBQ0osVUFBSSxNQUFNLFNBQVMsR0FBRztBQUVsQixjQUFNLGVBQWtCUixHQUFBQSxTQUFPLGdCQUFnQixJQUFJLGFBQWEsWUFBWSxZQUFZO0FBQ3hGLHVCQUFrQkcsR0FBQUEsU0FBTyxlQUFlLEtBQUssYUFBYSxHQUFHO0FBQUEsTUFDaEUsV0FDUSxNQUFNLFFBQVE7QUFDbkIsdUJBQWtCSyxHQUFBQSxZQUFVLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQyxPQUFVQSxHQUFBQSxZQUFVLEtBQU0sR0FBRyxRQUFRLENBQUMsRUFBRSxDQUFDO0FBQUEsTUFDMUYsT0FDSTtBQUNELHNCQUFjQSxZQUFVO0FBQUEsTUFDM0I7QUFDRCxVQUFJLFNBQVMsUUFBUTtBQUNqQix1QkFBYyxHQUFJQSxZQUFVLElBQUksYUFBYSxHQUFHLFNBQVMsSUFBSSxDQUFDLE9BQU0sR0FBSUEsWUFBVSxNQUFVTCxHQUFBQSxTQUFPLFlBQVksS0FBSyxDQUFDLENBQUMsU0FBUyxHQUFHLEdBQUcsQ0FBQztBQUFBLE1BQ3pJO0FBQ0QsaUJBQVdLLFlBQVUsS0FBSyxXQUFXO0FBQUEsSUFDeEM7QUFDRCxhQUFTLGlCQUFpQixLQUFLO0FBQzNCLFVBQUksU0FBU0EsWUFBVSxZQUFhLElBQUksSUFBSSxHQUFHLEdBQUc7QUFBQSxJQUNyRDtBQUNELGFBQVMsdUJBQXVCLEtBQUs7QUFDakMsVUFBSSxLQUFLLHFCQUFxQixTQUFVLEtBQUssb0JBQW9CQyxZQUFXLE9BQVE7QUFDaEYseUJBQWlCLEdBQUc7QUFDcEI7QUFBQSxNQUNIO0FBQ0QsVUFBSUEsWUFBVyxPQUFPO0FBQ2xCLFlBQUksVUFBVSxFQUFFLG9CQUFvQixJQUFLLENBQUE7QUFDekMsWUFBSSxNQUFLO0FBQ1QsWUFBSSxDQUFDO0FBQ0QsY0FBSSxNQUFLO0FBQ2I7QUFBQSxNQUNIO0FBQ0QsVUFBSSxPQUFPQSxXQUFVLFlBQVksRUFBQyxHQUFJVCxTQUFPLG1CQUFtQixJQUFJUyxPQUFNLEdBQUc7QUFDekUsY0FBTU0sU0FBUSxJQUFJLEtBQUssT0FBTztBQUM5QixZQUFJLEtBQUsscUJBQXFCLFdBQVc7QUFDckMsZ0NBQXNCLEtBQUtBLFFBQU8sS0FBSztBQUN2QyxjQUFJLElBQU9QLEdBQUFBLFlBQVUsS0FBS08sTUFBSyxHQUFHLE1BQU07QUFDcEMsZ0JBQUksTUFBSztBQUNULDZCQUFpQixHQUFHO0FBQUEsVUFDNUMsQ0FBcUI7QUFBQSxRQUNKLE9BQ0k7QUFDRCxnQ0FBc0IsS0FBS0EsTUFBSztBQUNoQyxjQUFJLENBQUM7QUFDRCxnQkFBSSxJQUFPUCxHQUFBQSxZQUFVLEtBQUtPLE1BQUssR0FBRyxNQUFNLElBQUksTUFBSyxDQUFFO0FBQUEsUUFDMUQ7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUNELGFBQVMsc0JBQXNCLEtBQUtBLFFBQU9VLFNBQVE7QUFDL0MsWUFBTUUsYUFBWTtBQUFBLFFBQ2QsU0FBUztBQUFBLFFBQ1QsVUFBVTtBQUFBLFFBQ1YsY0FBYzNCLFNBQU8sS0FBSztBQUFBLE1BQzFDO0FBQ1ksVUFBSXlCLFlBQVcsT0FBTztBQUNsQixlQUFPLE9BQU9FLFlBQVc7QUFBQSxVQUNyQixlQUFlO0FBQUEsVUFDZixjQUFjO0FBQUEsVUFDZCxXQUFXO0FBQUEsUUFDL0IsQ0FBaUI7QUFBQSxNQUNKO0FBQ0QsVUFBSSxVQUFVQSxZQUFXWixNQUFLO0FBQUEsSUFDakM7QUFBQSxFQUNKO0FBQ0w7QUFDZSxxQkFBQSxVQUFHVjs7QUN2R2xCLE9BQU8sZUFBZWdCLGNBQVMsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQzVELE1BQU0sYUFBYTlIO0FBQ25CLE1BQU00RyxXQUFTckg7QUFDZixNQUFNa0gsV0FBU2pIO0FBQ2YsTUFBTXdMLDJCQUF5QmhLO0FBQy9CLE1BQU04RixRQUFNO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixZQUFZO0FBQUEsRUFDWixLQUFLLEtBQUs7QUFDTixVQUFNLEVBQUUsS0FBSyxRQUFBSSxTQUFRLGNBQWMsTUFBTSxHQUFJLElBQUc7QUFDaEQsUUFBSSxHQUFHLEtBQUsscUJBQXFCLFNBQVMsYUFBYSx5QkFBeUIsUUFBVztBQUN2RjhELCtCQUF1QixRQUFRLEtBQUssSUFBSSxXQUFXLFdBQVcsSUFBSUEseUJBQXVCLFNBQVMsc0JBQXNCLENBQUM7QUFBQSxJQUM1SDtBQUNELFVBQU0sWUFBZXBFLEdBQUFBLFNBQU8scUJBQXFCTSxPQUFNO0FBQ3ZELGVBQVcsUUFBUSxVQUFVO0FBQ3pCLFNBQUcsa0JBQWtCLElBQUksSUFBSTtBQUFBLElBQ2hDO0FBQ0QsUUFBSSxHQUFHLEtBQUssZUFBZSxTQUFTLFVBQVUsR0FBRyxVQUFVLE1BQU07QUFDN0QsU0FBRyxRQUFRVCxTQUFPLGVBQWUsTUFBTSxTQUFTQSxTQUFPLFFBQVEsUUFBUSxHQUFHLEdBQUcsS0FBSztBQUFBLElBQ3JGO0FBQ0QsVUFBTXFCLGNBQWEsU0FBUyxPQUFPLENBQUMsTUFBTSxFQUFDLEdBQUlyQixTQUFPLG1CQUFtQixJQUFJUyxRQUFPLENBQUMsQ0FBQyxDQUFDO0FBQ3ZGLFFBQUlZLFlBQVcsV0FBVztBQUN0QjtBQUNKLFVBQU1OLFNBQVEsSUFBSSxLQUFLLE9BQU87QUFDOUIsZUFBVyxRQUFRTSxhQUFZO0FBQzNCLFVBQUksV0FBVyxJQUFJLEdBQUc7QUFDbEIsNEJBQW9CLElBQUk7QUFBQSxNQUMzQixPQUNJO0FBQ0QsWUFBSSxPQUFPbEIsU0FBTyxnQkFBZ0IsS0FBSyxNQUFNLE1BQU0sR0FBRyxLQUFLLGFBQWEsQ0FBQztBQUN6RSw0QkFBb0IsSUFBSTtBQUN4QixZQUFJLENBQUMsR0FBRztBQUNKLGNBQUksS0FBTSxFQUFDLElBQUlZLFFBQU8sSUFBSTtBQUM5QixZQUFJLE1BQUs7QUFBQSxNQUNaO0FBQ0QsVUFBSSxHQUFHLGtCQUFrQixJQUFJLElBQUk7QUFDakMsVUFBSSxHQUFHQSxNQUFLO0FBQUEsSUFDZjtBQUNELGFBQVMsV0FBVyxNQUFNO0FBQ3RCLGFBQU8sR0FBRyxLQUFLLGVBQWUsQ0FBQyxHQUFHLGlCQUFpQk4sUUFBTyxJQUFJLEVBQUUsWUFBWTtBQUFBLElBQy9FO0FBQ0QsYUFBUyxvQkFBb0IsTUFBTTtBQUMvQixVQUFJLFVBQVU7QUFBQSxRQUNWLFNBQVM7QUFBQSxRQUNULFlBQVk7QUFBQSxRQUNaLFVBQVU7QUFBQSxNQUNiLEdBQUVNLE1BQUs7QUFBQSxJQUNYO0FBQUEsRUFDSjtBQUNMO0FBQ2VNLGFBQUEsVUFBR2hCOztBQ25EbEIsT0FBTyxlQUFlLG1CQUFTLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUM1RCxNQUFNRixXQUFTNUc7QUFDZixNQUFNaUgsY0FBWTFIO0FBQ2xCLE1BQU1rSCxXQUFTakg7QUFDZixNQUFNLFNBQVNBO0FBQ2YsTUFBTXNILFFBQU07QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLFlBQVk7QUFBQSxFQUNaLEtBQUssS0FBSztBQUNOLFVBQU0sRUFBRSxLQUFLLFFBQUFJLFNBQVEsTUFBTSxjQUFjLEdBQUksSUFBRztBQUNoRCxVQUFNLEVBQUUsS0FBTSxJQUFHO0FBQ2pCLFVBQU0sWUFBZU4sR0FBQUEsU0FBTyxxQkFBcUJNLE9BQU07QUFDdkQsVUFBTSxzQkFBc0IsU0FBUyxPQUFPLENBQUMsT0FBTSxHQUFJVCxTQUFPLG1CQUFtQixJQUFJUyxRQUFPLENBQUMsQ0FBQyxDQUFDO0FBQy9GLFFBQUksU0FBUyxXQUFXLEtBQ25CLG9CQUFvQixXQUFXLFNBQVMsV0FDcEMsQ0FBQyxHQUFHLEtBQUssZUFBZSxHQUFHLFVBQVUsT0FBUTtBQUNsRDtBQUFBLElBQ0g7QUFDRCxVQUFNLGtCQUFrQixLQUFLLGdCQUFnQixDQUFDLEtBQUssMkJBQTJCLGFBQWE7QUFDM0YsVUFBTU0sU0FBUSxJQUFJLEtBQUssT0FBTztBQUM5QixRQUFJLEdBQUcsVUFBVSxRQUFRLEVBQUUsR0FBRyxpQkFBaUJQLFlBQVUsT0FBTztBQUM1RCxTQUFHLFlBQVksT0FBTyxzQkFBc0IsS0FBSyxHQUFHLEtBQUs7QUFBQSxJQUM1RDtBQUNELFVBQU0sRUFBRSxNQUFPLElBQUc7QUFDbEI7QUFDQSxhQUFTLDRCQUE0QjtBQUNqQyxpQkFBVyxPQUFPLFVBQVU7QUFDeEIsWUFBSTtBQUNBLGtDQUF3QixHQUFHO0FBQy9CLFlBQUksR0FBRyxXQUFXO0FBQ2QsNkJBQW1CLEdBQUc7QUFBQSxRQUN6QixPQUNJO0FBQ0QsY0FBSSxJQUFJTyxRQUFPLElBQUk7QUFDbkIsNkJBQW1CLEdBQUc7QUFDdEIsY0FBSSxHQUFHQSxNQUFLO0FBQUEsUUFDZjtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBQ0QsYUFBUyx3QkFBd0IsS0FBSztBQUNsQyxpQkFBVyxRQUFRLGlCQUFpQjtBQUNoQyxZQUFJLElBQUksT0FBTyxHQUFHLEVBQUUsS0FBSyxJQUFJLEdBQUc7QUFDNUIsY0FBSWYsU0FBTyxpQkFBaUIsSUFBSSxZQUFZLElBQUksb0JBQW9CLEdBQUcsZ0NBQWdDO0FBQUEsUUFDMUc7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUNELGFBQVMsbUJBQW1CLEtBQUs7QUFDN0IsVUFBSSxNQUFNLE9BQU8sTUFBTSxDQUFDLFFBQVE7QUFDNUIsWUFBSSxJQUFPUSxHQUFBQSxZQUFVLE1BQU0sR0FBSUwsU0FBTyxZQUFZLEtBQUssR0FBRyxDQUFDLFNBQVMsR0FBRyxLQUFLLE1BQU07QUFDOUUsZ0JBQU0sY0FBYyxvQkFBb0IsU0FBUyxHQUFHO0FBQ3BELGNBQUksQ0FBQyxhQUFhO0FBQ2QsZ0JBQUksVUFBVTtBQUFBLGNBQ1YsU0FBUztBQUFBLGNBQ1QsWUFBWTtBQUFBLGNBQ1osVUFBVTtBQUFBLGNBQ1YsY0FBYyxPQUFPLEtBQUs7QUFBQSxZQUM3QixHQUFFWSxNQUFLO0FBQUEsVUFDWDtBQUNELGNBQUksR0FBRyxLQUFLLGVBQWUsVUFBVSxNQUFNO0FBQ3ZDLGdCQUFJLFdBQVdQLFlBQVUsS0FBTSxLQUFLLElBQUksR0FBRyxLQUFLLElBQUk7QUFBQSxVQUN2RCxXQUNRLENBQUMsZUFBZSxDQUFDLEdBQUcsV0FBVztBQUdwQyxnQkFBSSxJQUFPQSxHQUFBQSxZQUFVLEtBQUtPLE1BQUssR0FBRyxNQUFNLElBQUksTUFBSyxDQUFFO0FBQUEsVUFDdEQ7QUFBQSxRQUNyQixDQUFpQjtBQUFBLE1BQ2pCLENBQWE7QUFBQSxJQUNKO0FBQUEsRUFDSjtBQUNMO0FBQ2Usa0JBQUEsVUFBR1Y7O0FDeEVsQixPQUFPLGVBQWUsS0FBUyxjQUFjLEVBQUUsT0FBTyxLQUFJLENBQUU7QUFDNUQsTUFBTUwsV0FBU3pHO0FBQ2YsTUFBTThHLFFBQU07QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULFlBQVksQ0FBQyxVQUFVLFNBQVM7QUFBQSxFQUNoQyxhQUFhO0FBQUEsRUFDYixLQUFLLEtBQUs7QUFDTixVQUFNLEVBQUUsS0FBSyxRQUFBSSxTQUFRLEdBQUUsSUFBSztBQUM1QixTQUFRVCxHQUFBQSxTQUFPLG1CQUFtQixJQUFJUyxPQUFNLEdBQUc7QUFDM0MsVUFBSSxLQUFJO0FBQ1I7QUFBQSxJQUNIO0FBQ0QsVUFBTU0sU0FBUSxJQUFJLEtBQUssT0FBTztBQUM5QixRQUFJLFVBQVU7QUFBQSxNQUNWLFNBQVM7QUFBQSxNQUNULGVBQWU7QUFBQSxNQUNmLGNBQWM7QUFBQSxNQUNkLFdBQVc7QUFBQSxJQUNkLEdBQUVBLE1BQUs7QUFDUixRQUFJLFdBQVdBLFFBQU8sTUFBTSxJQUFJLE1BQUssR0FBSSxNQUFNLElBQUksTUFBSyxDQUFFO0FBQUEsRUFDN0Q7QUFBQSxFQUNELE9BQU8sRUFBRSxTQUFTLG9CQUFxQjtBQUMzQztBQUNlLElBQUEsVUFBR1Y7O0FDdkJsQixPQUFPLGVBQWUsT0FBUyxjQUFjLEVBQUUsT0FBTyxLQUFJLENBQUU7QUFDNUQsTUFBTSxTQUFTOUc7QUFDZixNQUFNOEcsUUFBTTtBQUFBLEVBQ1IsU0FBUztBQUFBLEVBQ1QsWUFBWTtBQUFBLEVBQ1osYUFBYTtBQUFBLEVBQ2IsTUFBTSxPQUFPO0FBQUEsRUFDYixPQUFPLEVBQUUsU0FBUywrQkFBZ0M7QUFDdEQ7QUFDZSxNQUFBLFVBQUdBOztBQ1RsQixPQUFPLGVBQWUsT0FBUyxjQUFjLEVBQUUsT0FBTyxLQUFJLENBQUU7QUFDNUQsTUFBTUcsY0FBWWpIO0FBQ2xCLE1BQU15RyxXQUFTbEg7QUFDZixNQUFNSSxVQUFRO0FBQUEsRUFDVixTQUFTO0FBQUEsRUFDVCxRQUFRLENBQUMsRUFBRSxPQUFRLFVBQVNzSCxZQUFVLHNCQUF1QixPQUFPLE9BQU87QUFDL0U7QUFDQSxNQUFNSCxRQUFNO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxZQUFZO0FBQUEsRUFDWixhQUFhO0FBQUEsRUFDakIsT0FBSW5IO0FBQUFBLEVBQ0EsS0FBSyxLQUFLO0FBQ04sVUFBTSxFQUFFLEtBQUssUUFBQXVILFNBQVEsY0FBYyxHQUFFLElBQUs7QUFFMUMsUUFBSSxDQUFDLE1BQU0sUUFBUUEsT0FBTTtBQUNyQixZQUFNLElBQUksTUFBTSwwQkFBMEI7QUFDOUMsUUFBSSxHQUFHLEtBQUssaUJBQWlCLGFBQWE7QUFDdEM7QUFDSixVQUFNLFNBQVNBO0FBQ2YsVUFBTU0sU0FBUSxJQUFJLElBQUksU0FBUyxLQUFLO0FBQ3BDLFVBQU0sVUFBVSxJQUFJLElBQUksV0FBVyxJQUFJO0FBQ3ZDLFVBQU0sV0FBVyxJQUFJLEtBQUssUUFBUTtBQUNsQyxRQUFJLFVBQVUsRUFBRSxRQUFPLENBQUU7QUFFekIsUUFBSSxNQUFNLGFBQWE7QUFDdkIsUUFBSSxPQUFPQSxRQUFPLE1BQU0sSUFBSSxTQUFTLE1BQU0sSUFBSSxNQUFNLElBQUksQ0FBQztBQUMxRCxhQUFTLGdCQUFnQjtBQUNyQixhQUFPLFFBQVEsQ0FBQyxLQUFLLE1BQU07QUFDdkIsWUFBSTtBQUNKLGFBQVFmLEdBQUFBLFNBQU8sbUJBQW1CLElBQUksR0FBRyxHQUFHO0FBQ3hDLGNBQUksSUFBSSxVQUFVLElBQUk7QUFBQSxRQUN6QixPQUNJO0FBQ0QsbUJBQVMsSUFBSSxVQUFVO0FBQUEsWUFDbkIsU0FBUztBQUFBLFlBQ1QsWUFBWTtBQUFBLFlBQ1osZUFBZTtBQUFBLFVBQ2xCLEdBQUUsUUFBUTtBQUFBLFFBQ2Q7QUFDRCxZQUFJLElBQUksR0FBRztBQUNQLGNBQ0ssSUFBRyxHQUFJUSxZQUFVLEtBQU0sUUFBUSxPQUFPTyxNQUFLLEVBQUUsRUFDN0MsT0FBT0EsUUFBTyxLQUFLLEVBQ25CLE9BQU8sYUFBYVAsWUFBVSxNQUFPLE9BQU8sS0FBSyxDQUFDLEdBQUcsRUFDckQ7UUFDUjtBQUNELFlBQUksR0FBRyxVQUFVLE1BQU07QUFDbkIsY0FBSSxPQUFPTyxRQUFPLElBQUk7QUFDdEIsY0FBSSxPQUFPLFNBQVMsQ0FBQztBQUNyQixjQUFJO0FBQ0EsZ0JBQUksZUFBZSxRQUFRUCxZQUFVLElBQUk7QUFBQSxRQUNqRSxDQUFpQjtBQUFBLE1BQ2pCLENBQWE7QUFBQSxJQUNKO0FBQUEsRUFDSjtBQUNMO0FBQ2UsTUFBQSxVQUFHSDs7QUN6RGxCLE9BQU8sZUFBZSxPQUFTLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUM1RCxNQUFNTCxXQUFTekc7QUFDZixNQUFNOEcsUUFBTTtBQUFBLEVBQ1IsU0FBUztBQUFBLEVBQ1QsWUFBWTtBQUFBLEVBQ1osS0FBSyxLQUFLO0FBQ04sVUFBTSxFQUFFLEtBQUssUUFBQUksU0FBUSxHQUFFLElBQUs7QUFFNUIsUUFBSSxDQUFDLE1BQU0sUUFBUUEsT0FBTTtBQUNyQixZQUFNLElBQUksTUFBTSwwQkFBMEI7QUFDOUMsVUFBTU0sU0FBUSxJQUFJLEtBQUssT0FBTztBQUM5QixJQUFBTixRQUFPLFFBQVEsQ0FBQyxLQUFLLE1BQU07QUFDdkIsY0FBUVQsU0FBTyxtQkFBbUIsSUFBSSxHQUFHO0FBQ3JDO0FBQ0osWUFBTSxTQUFTLElBQUksVUFBVSxFQUFFLFNBQVMsU0FBUyxZQUFZLEtBQUtlLE1BQUs7QUFDdkUsVUFBSSxHQUFHQSxNQUFLO0FBQ1osVUFBSSxlQUFlLE1BQU07QUFBQSxJQUNyQyxDQUFTO0FBQUEsRUFDSjtBQUNMO0FBQ2UsTUFBQSxVQUFHVjs7QUNwQmxCLE9BQU8sZUFBZSxLQUFTLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUM1RCxNQUFNRyxjQUFZakg7QUFDbEIsTUFBTXlHLFdBQVNsSDtBQUNmLE1BQU1JLFVBQVE7QUFBQSxFQUNWLFNBQVMsQ0FBQyxFQUFFLE9BQVEsVUFBU3NILFlBQVUsbUJBQW9CLE9BQU8sUUFBUTtBQUFBLEVBQzFFLFFBQVEsQ0FBQyxFQUFFLE9BQVEsVUFBU0EsWUFBVSxzQkFBdUIsT0FBTyxRQUFRO0FBQ2hGO0FBQ0EsTUFBTUgsUUFBTTtBQUFBLEVBQ1IsU0FBUztBQUFBLEVBQ1QsWUFBWSxDQUFDLFVBQVUsU0FBUztBQUFBLEVBQ2hDLGFBQWE7QUFBQSxFQUNqQixPQUFJbkg7QUFBQUEsRUFDQSxLQUFLLEtBQUs7QUFDTixVQUFNLEVBQUUsS0FBSyxjQUFjLEdBQUUsSUFBSztBQUNsQyxRQUFJLGFBQWEsU0FBUyxVQUFhLGFBQWEsU0FBUyxRQUFXO0FBQ3BFLE9BQUEsR0FBSThHLFNBQU8saUJBQWlCLElBQUksMkNBQTJDO0FBQUEsSUFDOUU7QUFDRCxVQUFNLFVBQVUsVUFBVSxJQUFJLE1BQU07QUFDcEMsVUFBTSxVQUFVLFVBQVUsSUFBSSxNQUFNO0FBQ3BDLFFBQUksQ0FBQyxXQUFXLENBQUM7QUFDYjtBQUNKLFVBQU1lLFNBQVEsSUFBSSxJQUFJLFNBQVMsSUFBSTtBQUNuQyxVQUFNLFdBQVcsSUFBSSxLQUFLLFFBQVE7QUFDbEM7QUFDQSxRQUFJLE1BQUs7QUFDVCxRQUFJLFdBQVcsU0FBUztBQUNwQixZQUFNLFdBQVcsSUFBSSxJQUFJLFVBQVU7QUFDbkMsVUFBSSxVQUFVLEVBQUUsU0FBUSxDQUFFO0FBQzFCLFVBQUksR0FBRyxVQUFVLGVBQWUsUUFBUSxRQUFRLEdBQUcsZUFBZSxRQUFRLFFBQVEsQ0FBQztBQUFBLElBQ3RGLFdBQ1EsU0FBUztBQUNkLFVBQUksR0FBRyxVQUFVLGVBQWUsTUFBTSxDQUFDO0FBQUEsSUFDMUMsT0FDSTtBQUNELFVBQUksSUFBRyxHQUFJUCxZQUFVLEtBQUssUUFBUSxHQUFHLGVBQWUsTUFBTSxDQUFDO0FBQUEsSUFDOUQ7QUFDRCxRQUFJLEtBQUtPLFFBQU8sTUFBTSxJQUFJLE1BQU0sSUFBSSxDQUFDO0FBQ3JDLGFBQVMsYUFBYTtBQUNsQixZQUFNLFNBQVMsSUFBSSxVQUFVO0FBQUEsUUFDekIsU0FBUztBQUFBLFFBQ1QsZUFBZTtBQUFBLFFBQ2YsY0FBYztBQUFBLFFBQ2QsV0FBVztBQUFBLE1BQ2QsR0FBRSxRQUFRO0FBQ1gsVUFBSSxlQUFlLE1BQU07QUFBQSxJQUM1QjtBQUNELGFBQVMsZUFBZUosVUFBUyxVQUFVO0FBQ3ZDLGFBQU8sTUFBTTtBQUNULGNBQU0sU0FBUyxJQUFJLFVBQVUsRUFBRSxTQUFBQSxTQUFPLEdBQUksUUFBUTtBQUNsRCxZQUFJLE9BQU9JLFFBQU8sUUFBUTtBQUMxQixZQUFJLG9CQUFvQixRQUFRQSxNQUFLO0FBQ3JDLFlBQUk7QUFDQSxjQUFJLE9BQU8sV0FBY1AsR0FBQUEsWUFBVSxLQUFNRyxRQUFPLEVBQUU7QUFBQTtBQUVsRCxjQUFJLFVBQVUsRUFBRSxVQUFVQSxTQUFTLENBQUE7QUFBQSxNQUN2RDtBQUFBLElBQ1M7QUFBQSxFQUNKO0FBQ0w7QUFDQSxTQUFTLFVBQVUsSUFBSUEsVUFBUztBQUM1QixRQUFNRixVQUFTLEdBQUcsT0FBT0UsUUFBTztBQUNoQyxTQUFPRixZQUFXLFVBQWEsRUFBQyxHQUFJVCxTQUFPLG1CQUFtQixJQUFJUyxPQUFNO0FBQzVFO0FBQ2UsSUFBQSxVQUFHSjs7QUMvRGxCLE9BQU8sZUFBZSxVQUFTLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUM1RCxNQUFNTCxXQUFTekc7QUFDZixNQUFNOEcsUUFBTTtBQUFBLEVBQ1IsU0FBUyxDQUFDLFFBQVEsTUFBTTtBQUFBLEVBQ3hCLFlBQVksQ0FBQyxVQUFVLFNBQVM7QUFBQSxFQUNoQyxLQUFLLEVBQUUsU0FBQU0sVUFBUyxjQUFjLEdBQUUsR0FBSTtBQUNoQyxRQUFJLGFBQWEsT0FBTztBQUNwQixPQUFJWCxHQUFBQSxTQUFPLGlCQUFpQixJQUFJLElBQUlXLFFBQU8sMkJBQTJCO0FBQUEsRUFDN0U7QUFDTDtBQUNlLFNBQUEsVUFBR047QUNWbEIsT0FBTyxlQUFlLFlBQVMsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQzVELE1BQU0sb0JBQW9COUc7QUFDMUIsTUFBTSxnQkFBZ0JUO0FBQ3RCLE1BQU0sVUFBVUM7QUFDaEIsTUFBTSxjQUFjd0I7QUFDcEIsTUFBTSxhQUFhNkI7QUFDbkIsTUFBTSxpQkFBaUJDO0FBQ3ZCLE1BQU0sa0JBQWtCd0I7QUFDeEIsTUFBTSx5QkFBeUJDO0FBQy9CLE1BQU0sZUFBZWM7QUFDckIsTUFBTSxzQkFBc0JDO0FBQzVCLE1BQU0sUUFBUXNEO0FBQ2QsTUFBTSxVQUFVcUM7QUFDaEIsTUFBTSxVQUFVQztBQUNoQixNQUFNLFVBQVVDO0FBQ2hCLE1BQU0sT0FBT0M7QUFDYixNQUFNLGFBQWFDO0FBQ25CLFNBQVMsY0FBYyxZQUFZLE9BQU87QUFDdEMsUUFBTUMsY0FBYTtBQUFBO0FBQUEsSUFFZixNQUFNO0FBQUEsSUFDTixRQUFRO0FBQUEsSUFDUixRQUFRO0FBQUEsSUFDUixRQUFRO0FBQUEsSUFDUixLQUFLO0FBQUEsSUFDTCxXQUFXO0FBQUE7QUFBQSxJQUVYLGdCQUFnQjtBQUFBLElBQ2hCLHVCQUF1QjtBQUFBLElBQ3ZCLGVBQWU7QUFBQSxJQUNmLGFBQWE7QUFBQSxJQUNiLG9CQUFvQjtBQUFBLEVBQzVCO0FBRUksTUFBSTtBQUNBLElBQUFBLFlBQVcsS0FBSyxjQUFjLFNBQVMsWUFBWSxPQUFPO0FBQUE7QUFFMUQsSUFBQUEsWUFBVyxLQUFLLGtCQUFrQixTQUFTLFFBQVEsT0FBTztBQUM5RCxFQUFBQSxZQUFXLEtBQUssV0FBVyxPQUFPO0FBQ2xDLFNBQU9BO0FBQ1g7QUFDZSxXQUFBLFVBQUc7OztBQ3pDbEIsT0FBTyxlQUFlZCxVQUFTLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUM1RCxNQUFNdkQsY0FBWWpIO0FBQ2xCLE1BQU1MLFVBQVE7QUFBQSxFQUNWLFNBQVMsQ0FBQyxFQUFFLFdBQVUsT0FBV3NILEdBQUFBLFlBQVUsMEJBQTJCLFVBQVU7QUFBQSxFQUNoRixRQUFRLENBQUMsRUFBRSxXQUFVLE9BQVdBLEdBQUFBLFlBQVUsY0FBZSxVQUFVO0FBQ3ZFO0FBQ0EsTUFBTUgsUUFBTTtBQUFBLEVBQ1IsU0FBUztBQUFBLEVBQ1QsTUFBTSxDQUFDLFVBQVUsUUFBUTtBQUFBLEVBQ3pCLFlBQVk7QUFBQSxFQUNaLE9BQU87QUFBQSxFQUNYLE9BQUluSDtBQUFBQSxFQUNBLEtBQUssS0FBSyxVQUFVO0FBQ2hCLFVBQU0sRUFBRSxLQUFLLE1BQU0sT0FBTyxRQUFBdUgsU0FBUSxZQUFZLEdBQUksSUFBRztBQUNyRCxVQUFNLEVBQUUsTUFBTSxlQUFlLFdBQVcsTUFBQXJHLE1BQUksSUFBSztBQUNqRCxRQUFJLENBQUMsS0FBSztBQUNOO0FBQ0osUUFBSTtBQUNBOztBQUVBO0FBQ0osYUFBUyxzQkFBc0I7QUFDM0IsWUFBTSxPQUFPLElBQUksV0FBVyxXQUFXO0FBQUEsUUFDbkMsS0FBS0EsTUFBSztBQUFBLFFBQ1YsTUFBTSxLQUFLLEtBQUs7QUFBQSxNQUNoQyxDQUFhO0FBQ0QsWUFBTSxPQUFPLElBQUksTUFBTSxTQUFRLEdBQUlvRyxZQUFVLEtBQU0sSUFBSSxJQUFJLFVBQVUsR0FBRztBQUN4RSxZQUFNLFFBQVEsSUFBSSxJQUFJLE9BQU87QUFDN0IsWUFBTXVELFVBQVMsSUFBSSxJQUFJLFFBQVE7QUFFL0IsVUFBSSxJQUFHLEdBQUl2RCxZQUFVLFlBQWEsSUFBSSxxQkFBcUIsSUFBSSx1QkFBdUIsTUFBTSxJQUFJLE9BQU8sUUFBV0EsR0FBQUEsWUFBVSxLQUFNLElBQUksbUJBQW1CLEVBQUUsT0FBT3VELFVBQVEsR0FBSXZELFlBQVUsS0FBTSxJQUFJLFdBQVcsR0FBRyxNQUFNLElBQUksT0FBTyxRQUFXQSxHQUFBQSxZQUFVLFlBQWEsRUFBRSxPQUFPdUQsU0FBUSxJQUFJLENBQUM7QUFDelIsVUFBSSxXQUFVLEdBQUl2RCxZQUFVLElBQUksY0FBYyxXQUFZLENBQUEsQ0FBQztBQUMzRCxlQUFTLGFBQWE7QUFDbEIsWUFBSSxLQUFLLGlCQUFpQjtBQUN0QixpQkFBT0EsWUFBVTtBQUNyQixnQkFBTyxHQUFJQSxZQUFVLEtBQU0sVUFBVSxRQUFRdUQsT0FBTTtBQUFBLE1BQ3REO0FBQ0QsZUFBUyxhQUFhO0FBQ2xCLGNBQU0sYUFBYSxVQUFVLFVBQ3ZCLEdBQUl2RCxZQUFVLE1BQU8sSUFBSSxrQkFBa0J1RCxPQUFNLElBQUksSUFBSSxPQUFPQSxPQUFNLElBQUksSUFBSSxRQUMxRXZELEdBQUFBLFlBQVUsS0FBTXVELE9BQU0sSUFBSSxJQUFJO0FBQ3hDLGNBQU0sYUFBZ0J2RCxHQUFBQSxZQUFVLGFBQWN1RCxPQUFNLG9CQUFvQixVQUFVLE1BQU1BLE9BQU0sU0FBUyxJQUFJO0FBQzNHLGdCQUFXdkQsR0FBQUEsWUFBVSxLQUFNdUQsT0FBTSxPQUFPQSxPQUFNLGdCQUFnQixLQUFLLFFBQVEsUUFBUSxRQUFRLFNBQVM7QUFBQSxNQUN2RztBQUFBLElBQ0o7QUFDRCxhQUFTLGlCQUFpQjtBQUN0QixZQUFNLFlBQVkzSixNQUFLLFFBQVFxRyxPQUFNO0FBQ3JDLFVBQUksQ0FBQyxXQUFXO0FBQ1o7QUFDQTtBQUFBLE1BQ0g7QUFDRCxVQUFJLGNBQWM7QUFDZDtBQUNKLFlBQU0sQ0FBQyxTQUFTc0QsU0FBUSxNQUFNLElBQUksVUFBVSxTQUFTO0FBQ3JELFVBQUksWUFBWTtBQUNaLFlBQUksS0FBSyxlQUFjLENBQUU7QUFDN0IsZUFBUyxnQkFBZ0I7QUFDckIsWUFBSSxLQUFLLGlCQUFpQixPQUFPO0FBQzdCLFVBQUEzSixNQUFLLE9BQU8sS0FBSyxXQUFZLENBQUE7QUFDN0I7QUFBQSxRQUNIO0FBQ0QsY0FBTSxJQUFJLE1BQU0sV0FBVSxDQUFFO0FBQzVCLGlCQUFTLGFBQWE7QUFDbEIsaUJBQU8sbUJBQW1CcUcsT0FBTSxnQ0FBZ0MsYUFBYTtBQUFBLFFBQ2hGO0FBQUEsTUFDSjtBQUNELGVBQVMsVUFBVSxRQUFRO0FBQ3ZCLGNBQU1YLFFBQU8sa0JBQWtCLGFBQ3JCVSxZQUFVLFlBQVksTUFBTSxJQUNoQyxLQUFLLEtBQUssV0FDTixHQUFJQSxZQUFVLEtBQU0sS0FBSyxLQUFLLE9BQU8sT0FBT0EsWUFBVSxhQUFhQyxPQUFNLENBQUMsS0FDMUU7QUFDVixjQUFNLE1BQU0sSUFBSSxXQUFXLFdBQVcsRUFBRSxLQUFLQSxTQUFRLEtBQUssUUFBUSxNQUFBWCxNQUFNLENBQUE7QUFDeEUsWUFBSSxPQUFPLFVBQVUsWUFBWSxFQUFFLGtCQUFrQixTQUFTO0FBQzFELGlCQUFPLENBQUMsT0FBTyxRQUFRLFVBQVUsT0FBTyxjQUFjVSxZQUFVLEtBQU0sR0FBRyxXQUFXO0FBQUEsUUFDdkY7QUFDRCxlQUFPLENBQUMsVUFBVSxRQUFRLEdBQUc7QUFBQSxNQUNoQztBQUNELGVBQVMsaUJBQWlCO0FBQ3RCLFlBQUksT0FBTyxhQUFhLFlBQVksRUFBRSxxQkFBcUIsV0FBVyxVQUFVLE9BQU87QUFDbkYsY0FBSSxDQUFDLFVBQVU7QUFDWCxrQkFBTSxJQUFJLE1BQU0sNkJBQTZCO0FBQ2pELGtCQUFXQSxHQUFBQSxZQUFVLFdBQVksTUFBTSxJQUFJLElBQUk7QUFBQSxRQUNsRDtBQUNELGVBQU8sT0FBT3VELFdBQVUsY0FBaUJ2RCxHQUFBQSxZQUFVLEtBQU0sTUFBTSxJQUFJLElBQUksT0FBTSxHQUFJQSxZQUFVLEtBQU0sTUFBTSxTQUFTLElBQUk7QUFBQSxNQUN2SDtBQUFBLElBQ0o7QUFBQSxFQUNKO0FBQ0w7QUFDZXVELFNBQUEsVUFBRzFEO0FDekZsQixPQUFPLGVBQWV5RSxVQUFTLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUM1RCxNQUFNQyxhQUFXeEw7QUFDakIsTUFBTSxTQUFTLENBQUN3TCxXQUFTLE9BQU87QUFDakJELFNBQUEsVUFBRzs7QUNIbEIsT0FBTyxlQUFlLFVBQVMsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQzVELFNBQUEsb0JBQTRCLFNBQUEscUJBQTZCO0FBQ3pELFNBQUEscUJBQTZCO0FBQUEsRUFDekI7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFDSjtBQUNBLFNBQUEsb0JBQTRCO0FBQUEsRUFDeEI7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUNKO0FDZkEsT0FBTyxlQUFlLFFBQVMsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQzVELE1BQU0sU0FBU3ZMO0FBQ2YsTUFBTSxlQUFlVDtBQUNyQixNQUFNLGVBQWVDO0FBQ3JCLE1BQU0sV0FBV3dCO0FBQ2pCLE1BQU0sYUFBYTZCO0FBQ25CLE1BQU0scUJBQXFCO0FBQUEsRUFDdkIsT0FBTztBQUFBLEVBQ1AsYUFBYTtBQUFBLEdBQ1QsR0FBQSxhQUFhLFNBQVU7QUFBQSxFQUMzQixTQUFTO0FBQUEsRUFDVCxXQUFXO0FBQUEsRUFDWCxXQUFXO0FBQ2Y7QUFDZSxPQUFBLFVBQUc7Ozs7QUNkbEIsU0FBTyxlQUFjZixVQUFVLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUM1RCxFQUFBQSxTQUFxQixhQUFBO0FBRXJCLEdBQUMsU0FBVSxZQUFZO0FBQ25CLGVBQVcsS0FBSyxJQUFJO0FBQ3BCLGVBQVcsU0FBUyxJQUFJO0FBQUEsS0FDWkEsU0FBUSxlQUFlQSxTQUFxQixhQUFBLENBQUEsRUFBRzs7QUNOL0QsT0FBTyxlQUFlLGVBQVMsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQzVELE1BQU0sWUFBWTlCO0FBQ2xCLE1BQU0sVUFBVVQ7QUFDaEIsTUFBTSxZQUFZQztBQUNsQixNQUFNLFNBQVN3QjtBQUNmLE1BQU0sUUFBUTtBQUFBLEVBQ1YsU0FBUyxDQUFDLEVBQUUsUUFBUSxFQUFFLFlBQVksUUFBUyxFQUFBLE1BQU8sZUFBZSxRQUFRLFdBQVcsTUFDOUUsUUFBUSxPQUFPLHFCQUNmLGlCQUFpQixPQUFPO0FBQUEsRUFDOUIsUUFBUSxDQUFDLEVBQUUsUUFBUSxFQUFFLFlBQVksS0FBSyxRQUFTLEVBQUEsT0FBVyxHQUFBLFVBQVUsYUFBYyxVQUFVLFVBQVUsT0FBTyxlQUFlLEdBQUc7QUFDbkk7QUFDQSxNQUFNLE1BQU07QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLFlBQVk7QUFBQSxFQUNaO0FBQUEsRUFDQSxLQUFLLEtBQUs7QUFDTixVQUFNLEVBQUUsS0FBSyxNQUFNLFFBQUFrRyxTQUFRLGNBQWMsR0FBSSxJQUFHO0FBQ2hELFVBQU0sRUFBRSxPQUFBdUUsT0FBTyxJQUFHO0FBQ2xCLFFBQUksQ0FBQyxHQUFHLEtBQUssZUFBZTtBQUN4QixZQUFNLElBQUksTUFBTSw4Q0FBOEM7QUFBQSxJQUNqRTtBQUNELFVBQU0sVUFBVXZFLFFBQU87QUFDdkIsUUFBSSxPQUFPLFdBQVc7QUFDbEIsWUFBTSxJQUFJLE1BQU0sc0NBQXNDO0FBQzFELFFBQUlBLFFBQU87QUFDUCxZQUFNLElBQUksTUFBTSx5Q0FBeUM7QUFDN0QsUUFBSSxDQUFDdUU7QUFDRCxZQUFNLElBQUksTUFBTSx1Q0FBdUM7QUFDM0QsVUFBTWpFLFNBQVEsSUFBSSxJQUFJLFNBQVMsS0FBSztBQUNwQyxVQUFNLE1BQU0sSUFBSSxNQUFNLFFBQU8sR0FBSSxVQUFVLEtBQU0sSUFBSSxJQUFHLEdBQUksVUFBVSxhQUFhLE9BQU8sQ0FBQyxFQUFFO0FBQzdGLFFBQUksSUFBTyxHQUFBLFVBQVUsWUFBYSxHQUFHLGdCQUFnQixNQUFNLGdCQUFpQixHQUFFLE1BQU0sSUFBSSxNQUFNLE9BQU8sRUFBRSxZQUFZLFFBQVEsV0FBVyxLQUFLLEtBQUssUUFBUyxDQUFBLENBQUM7QUFDMUosUUFBSSxHQUFHQSxNQUFLO0FBQ1osYUFBUyxrQkFBa0I7QUFDdkIsWUFBTSxVQUFVO0FBQ2hCLFVBQUksR0FBRyxLQUFLO0FBQ1osaUJBQVcsWUFBWSxTQUFTO0FBQzVCLFlBQUksUUFBVyxHQUFBLFVBQVUsS0FBTSxHQUFHLFFBQVEsUUFBUSxFQUFFO0FBQ3BELFlBQUksT0FBT0EsUUFBTyxlQUFlLFFBQVEsUUFBUSxDQUFDLENBQUM7QUFBQSxNQUN0RDtBQUNELFVBQUksS0FBSTtBQUNSLFVBQUksTUFBTSxPQUFPLEVBQUUsWUFBWSxRQUFRLFdBQVcsU0FBUyxLQUFLLFFBQU8sQ0FBRTtBQUN6RSxVQUFJLE1BQUs7QUFBQSxJQUNaO0FBQ0QsYUFBUyxlQUFlLFlBQVk7QUFDaEMsWUFBTSxTQUFTLElBQUksS0FBSyxPQUFPO0FBQy9CLFlBQU0sU0FBUyxJQUFJLFVBQVUsRUFBRSxTQUFTLFNBQVMsY0FBYyxNQUFNO0FBQ3JFLFVBQUksZUFBZSxRQUFRLFVBQVUsSUFBSTtBQUN6QyxhQUFPO0FBQUEsSUFDVjtBQUNELGFBQVMsYUFBYTtBQUNsQixVQUFJO0FBQ0osWUFBTSxlQUFlLENBQUE7QUFDckIsWUFBTSxjQUFjLFlBQVksWUFBWTtBQUM1QyxVQUFJLGNBQWM7QUFDbEIsZUFBUyxJQUFJLEdBQUcsSUFBSWlFLE9BQU0sUUFBUSxLQUFLO0FBQ25DLFlBQUksTUFBTUEsT0FBTSxDQUFDO0FBQ2pCLGFBQUssUUFBUSxRQUFRLFFBQVEsU0FBUyxTQUFTLElBQUksU0FBUyxFQUFDLEdBQUksT0FBTyxzQkFBc0IsS0FBSyxHQUFHLEtBQUssS0FBSyxHQUFHO0FBQy9HLGdCQUFNLFVBQVUsV0FBVyxLQUFLLEdBQUcsTUFBTSxHQUFHLFVBQVUsTUFBTSxHQUFHLFFBQVEsUUFBUSxRQUFRLFFBQVEsU0FBUyxTQUFTLElBQUksSUFBSTtBQUN6SCxjQUFJLGVBQWUsVUFBVTtBQUN6QixrQkFBTSxJQUFJO0FBQUEsUUFDakI7QUFDRCxjQUFNLFdBQVcsS0FBSyxRQUFRLFFBQVEsUUFBUSxTQUFTLFNBQVMsSUFBSSxnQkFBZ0IsUUFBUSxPQUFPLFNBQVMsU0FBUyxHQUFHLE9BQU87QUFDL0gsWUFBSSxPQUFPLFdBQVcsVUFBVTtBQUM1QixnQkFBTSxJQUFJLE1BQU0saUZBQWlGLE9BQU8sR0FBRztBQUFBLFFBQzlHO0FBQ0Qsc0JBQWMsZ0JBQWdCLGVBQWUsWUFBWSxHQUFHO0FBQzVELG9CQUFZLFNBQVMsQ0FBQztBQUFBLE1BQ3pCO0FBQ0QsVUFBSSxDQUFDO0FBQ0QsY0FBTSxJQUFJLE1BQU0sbUJBQW1CLE9BQU8sb0JBQW9CO0FBQ2xFLGFBQU87QUFDUCxlQUFTLFlBQVksRUFBRSxVQUFBQyxhQUFZO0FBQy9CLGVBQU8sTUFBTSxRQUFRQSxTQUFRLEtBQUtBLFVBQVMsU0FBUyxPQUFPO0FBQUEsTUFDOUQ7QUFDRCxlQUFTLFlBQVksS0FBSyxHQUFHO0FBQ3pCLFlBQUksSUFBSSxPQUFPO0FBQ1gscUJBQVcsSUFBSSxPQUFPLENBQUM7QUFBQSxRQUMxQixXQUNRLElBQUksTUFBTTtBQUNmLHFCQUFXLFlBQVksSUFBSSxNQUFNO0FBQzdCLHVCQUFXLFVBQVUsQ0FBQztBQUFBLFVBQ3pCO0FBQUEsUUFDSixPQUNJO0FBQ0QsZ0JBQU0sSUFBSSxNQUFNLDhCQUE4QixPQUFPLCtCQUErQjtBQUFBLFFBQ3ZGO0FBQUEsTUFDSjtBQUNELGVBQVMsV0FBVyxVQUFVLEdBQUc7QUFDN0IsWUFBSSxPQUFPLFlBQVksWUFBWSxZQUFZLGNBQWM7QUFDekQsZ0JBQU0sSUFBSSxNQUFNLG1CQUFtQixPQUFPLGlDQUFpQztBQUFBLFFBQzlFO0FBQ0QscUJBQWEsUUFBUSxJQUFJO0FBQUEsTUFDNUI7QUFBQSxJQUNKO0FBQUEsRUFDSjtBQUNMO0FBQ2UsY0FBQSxVQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqR2xCLFNBQU8sZUFBYzVKLFVBQVUsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQzVELEVBQUFBLFNBQTBCLGtCQUFBQSxTQUFBLGtCQUEwQkEsU0FBa0IsVUFBQUEsU0FBQSxPQUFlQSxTQUFjLE1BQUFBLFNBQUEsWUFBb0JBLGVBQWNBLFNBQVksSUFBQUEsU0FBQSxhQUFxQjtBQUN0SyxRQUFNMkksVUFBU3pLO0FBQ2YsUUFBTSxXQUFXVDtBQUNqQixRQUFNLGtCQUFrQkM7QUFDeEIsUUFBTSxtQkFBbUI7QUFDekIsUUFBTSxvQkFBb0IsQ0FBQyxhQUFhO0FBQ3hDLFFBQU0saUJBQWlCO0FBQUEsRUFDdkIsTUFBTSxZQUFZaUwsUUFBTyxRQUFRO0FBQUEsSUFDN0IsbUJBQW1CO0FBQ2YsWUFBTSxpQkFBZ0I7QUFDdEIsZUFBUyxRQUFRLFFBQVEsQ0FBQyxNQUFNLEtBQUssY0FBYyxDQUFDLENBQUM7QUFDckQsVUFBSSxLQUFLLEtBQUs7QUFDVixhQUFLLFdBQVcsZ0JBQWdCLE9BQU87QUFBQSxJQUM5QztBQUFBLElBQ0Qsd0JBQXdCO0FBQ3BCLFlBQU0sc0JBQXFCO0FBQzNCLFVBQUksQ0FBQyxLQUFLLEtBQUs7QUFDWDtBQUNKLFlBQU0sYUFBYSxLQUFLLEtBQUssUUFDdkIsS0FBSyxnQkFBZ0Isa0JBQWtCLGlCQUFpQixJQUN4RDtBQUNOLFdBQUssY0FBYyxZQUFZLGdCQUFnQixLQUFLO0FBQ3BELFdBQUssS0FBSywrQkFBK0IsSUFBSTtBQUFBLElBQ2hEO0FBQUEsSUFDRCxjQUFjO0FBQ1YsYUFBUSxLQUFLLEtBQUssY0FDZCxNQUFNLFlBQWEsTUFBSyxLQUFLLFVBQVUsY0FBYyxJQUFJLGlCQUFpQjtBQUFBLElBQ2pGO0FBQUEsRUFDSjtBQUNELEVBQUFrQixRQUFpQixVQUFBN0osV0FBVTtBQUMzQixTQUFPLGVBQWNBLFVBQVUsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQzVELEVBQUFBLFNBQUEsVUFBa0I7QUFDbEIsTUFBSWdILGNBQWFqRztBQUNqQixTQUFPLGVBQWVmLFVBQVMsY0FBYyxFQUFFLFlBQVksTUFBTSxLQUFLLFdBQVk7QUFBRSxXQUFPZ0gsWUFBVztBQUFBLEVBQVcsRUFBSSxDQUFBO0FBQ3JILE1BQUk3QixhQUFZbkU7QUFDaEIsU0FBTyxlQUFlaEIsVUFBUyxLQUFLLEVBQUUsWUFBWSxNQUFNLEtBQUssV0FBWTtBQUFFLFdBQU9tRixXQUFVO0FBQUEsRUFBRSxFQUFJLENBQUE7QUFDbEcsU0FBTyxlQUFlbkYsVUFBUyxPQUFPLEVBQUUsWUFBWSxNQUFNLEtBQUssV0FBWTtBQUFFLFdBQU9tRixXQUFVO0FBQUEsRUFBSSxFQUFJLENBQUE7QUFDdEcsU0FBTyxlQUFlbkYsVUFBUyxhQUFhLEVBQUUsWUFBWSxNQUFNLEtBQUssV0FBWTtBQUFFLFdBQU9tRixXQUFVO0FBQUEsRUFBVSxFQUFJLENBQUE7QUFDbEgsU0FBTyxlQUFlbkYsVUFBUyxPQUFPLEVBQUUsWUFBWSxNQUFNLEtBQUssV0FBWTtBQUFFLFdBQU9tRixXQUFVO0FBQUEsRUFBSSxFQUFJLENBQUE7QUFDdEcsU0FBTyxlQUFlbkYsVUFBUyxRQUFRLEVBQUUsWUFBWSxNQUFNLEtBQUssV0FBWTtBQUFFLFdBQU9tRixXQUFVO0FBQUEsRUFBSyxFQUFJLENBQUE7QUFDeEcsU0FBTyxlQUFlbkYsVUFBUyxXQUFXLEVBQUUsWUFBWSxNQUFNLEtBQUssV0FBWTtBQUFFLFdBQU9tRixXQUFVO0FBQUEsRUFBUSxFQUFJLENBQUE7QUFDOUcsTUFBSWtELHNCQUFxQjdGO0FBQ3pCLFNBQU8sZUFBZXhDLFVBQVMsbUJBQW1CLEVBQUUsWUFBWSxNQUFNLEtBQUssV0FBWTtBQUFFLFdBQU9xSSxvQkFBbUI7QUFBQSxFQUFRLEVBQUksQ0FBQTtBQUMvSCxNQUFJQyxlQUFjN0Y7QUFDbEIsU0FBTyxlQUFlekMsVUFBUyxtQkFBbUIsRUFBRSxZQUFZLE1BQU0sS0FBSyxXQUFZO0FBQUUsV0FBT3NJLGFBQVk7QUFBQSxFQUFRLEVBQUksQ0FBQTs7Ozs7O0FDN0N4SCxTQUFPLGVBQWN0SSxVQUFVLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUM1RCxFQUFBQSxTQUFBLGNBQXNCQSxTQUFzQixjQUFBQSxTQUFBLGNBQXNCO0FBQ2xFLFdBQVMsT0FBT21HLFdBQVUyRCxVQUFTO0FBQy9CLFdBQU8sRUFBRSxVQUFBM0QsV0FBVSxTQUFBMkQ7RUFDdEI7QUFDRCxFQUFBOUosU0FBc0IsY0FBQTtBQUFBO0FBQUEsSUFFbEIsTUFBTSxPQUFPLE1BQU0sV0FBVztBQUFBO0FBQUEsSUFFOUIsTUFBTSxPQUFPLE1BQU0sV0FBVztBQUFBLElBQzlCLGFBQWEsT0FBTyxXQUFXLGVBQWU7QUFBQTtBQUFBLElBRTlDLFVBQVU7QUFBQSxJQUNWLEtBQUFrSTtBQUFBLElBQ0EsaUJBQWlCO0FBQUE7QUFBQSxJQUVqQixnQkFBZ0I7QUFBQTtBQUFBO0FBQUEsSUFHaEIsS0FBSztBQUFBLElBQ0wsT0FBTztBQUFBLElBQ1AsVUFBVTtBQUFBO0FBQUEsSUFFVixNQUFNO0FBQUEsSUFDTixNQUFNO0FBQUEsSUFDTjtBQUFBO0FBQUEsSUFFQSxNQUFNO0FBQUE7QUFBQTtBQUFBLElBR04sZ0JBQWdCO0FBQUEsSUFDaEIsNkJBQTZCO0FBQUE7QUFBQSxJQUU3Qix5QkFBeUI7QUFBQTtBQUFBO0FBQUEsSUFHekI7QUFBQTtBQUFBLElBRUEsT0FBTyxFQUFFLE1BQU0sVUFBVSxVQUFVLGNBQWU7QUFBQTtBQUFBLElBRWxELE9BQU8sRUFBRSxNQUFNLFVBQVUsVUFBVSxjQUFlO0FBQUE7QUFBQSxJQUVsRCxPQUFPLEVBQUUsTUFBTSxVQUFVLFVBQVUsZUFBZ0I7QUFBQTtBQUFBLElBRW5ELFFBQVEsRUFBRSxNQUFNLFVBQVUsVUFBVSxlQUFnQjtBQUFBO0FBQUEsSUFFcEQsVUFBVTtBQUFBO0FBQUEsSUFFVixRQUFRO0FBQUEsRUFDWjtBQUNBLEVBQUFsSSxTQUFzQixjQUFBO0FBQUEsSUFDbEIsR0FBR0EsU0FBUTtBQUFBLElBQ1gsTUFBTSxPQUFPLDhCQUE4QixXQUFXO0FBQUEsSUFDdEQsTUFBTSxPQUFPLCtFQUErRSxXQUFXO0FBQUEsSUFDdkcsYUFBYSxPQUFPLDJHQUEyRyxlQUFlO0FBQUE7QUFBQSxJQUU5SSxLQUFLO0FBQUEsSUFDTCxpQkFBaUI7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUlqQixPQUFPO0FBQUEsRUFDWDtBQUNBLEVBQUFBLFNBQXNCLGNBQUEsT0FBTyxLQUFLQSxTQUFRLFdBQVc7QUFDckQsV0FBUyxXQUFXLE1BQU07QUFFdEIsV0FBTyxPQUFPLE1BQU0sTUFBTSxPQUFPLFFBQVEsS0FBSyxPQUFPLFFBQVE7QUFBQSxFQUNoRTtBQUNELFFBQU0sT0FBTztBQUNiLFFBQU0sT0FBTyxDQUFDLEdBQUcsSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLEVBQUU7QUFDL0QsV0FBUyxLQUFLLEtBQUs7QUFFZixVQUFNLFVBQVUsS0FBSyxLQUFLLEdBQUc7QUFDN0IsUUFBSSxDQUFDO0FBQ0QsYUFBTztBQUNYLFVBQU0sT0FBTyxDQUFDLFFBQVEsQ0FBQztBQUN2QixVQUFNLFFBQVEsQ0FBQyxRQUFRLENBQUM7QUFDeEIsVUFBTSxNQUFNLENBQUMsUUFBUSxDQUFDO0FBQ3RCLFdBQVEsU0FBUyxLQUNiLFNBQVMsTUFDVCxPQUFPLEtBQ1AsUUFBUSxVQUFVLEtBQUssV0FBVyxJQUFJLElBQUksS0FBSyxLQUFLLEtBQUs7QUFBQSxFQUNoRTtBQUNELFdBQVMsWUFBWSxJQUFJLElBQUk7QUFDekIsUUFBSSxFQUFFLE1BQU07QUFDUixhQUFPO0FBQ1gsUUFBSSxLQUFLO0FBQ0wsYUFBTztBQUNYLFFBQUksS0FBSztBQUNMLGFBQU87QUFDWCxXQUFPO0FBQUEsRUFDVjtBQUNELFFBQU0sT0FBTztBQUNiLFdBQVMsS0FBSyxLQUFLLGNBQWM7QUFDN0IsVUFBTSxVQUFVLEtBQUssS0FBSyxHQUFHO0FBQzdCLFFBQUksQ0FBQztBQUNELGFBQU87QUFDWCxVQUFNLE9BQU8sQ0FBQyxRQUFRLENBQUM7QUFDdkIsVUFBTSxTQUFTLENBQUMsUUFBUSxDQUFDO0FBQ3pCLFVBQU0sU0FBUyxDQUFDLFFBQVEsQ0FBQztBQUN6QixVQUFNLFdBQVcsUUFBUSxDQUFDO0FBQzFCLFlBQVUsUUFBUSxNQUFNLFVBQVUsTUFBTSxVQUFVLE1BQzdDLFNBQVMsTUFBTSxXQUFXLE1BQU0sV0FBVyxRQUMzQyxDQUFDLGdCQUFnQixhQUFhO0FBQUEsRUFDdEM7QUFDRCxXQUFTLFlBQVksSUFBSSxJQUFJO0FBQ3pCLFFBQUksRUFBRSxNQUFNO0FBQ1IsYUFBTztBQUNYLFVBQU0sS0FBSyxLQUFLLEtBQUssRUFBRTtBQUN2QixVQUFNLEtBQUssS0FBSyxLQUFLLEVBQUU7QUFDdkIsUUFBSSxFQUFFLE1BQU07QUFDUixhQUFPO0FBQ1gsU0FBSyxHQUFHLENBQUMsSUFBSSxHQUFHLENBQUMsSUFBSSxHQUFHLENBQUMsS0FBSyxHQUFHLENBQUMsS0FBSztBQUN2QyxTQUFLLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxLQUFLO0FBQ3ZDLFFBQUksS0FBSztBQUNMLGFBQU87QUFDWCxRQUFJLEtBQUs7QUFDTCxhQUFPO0FBQ1gsV0FBTztBQUFBLEVBQ1Y7QUFDRCxRQUFNLHNCQUFzQjtBQUM1QixXQUFTLFVBQVUsS0FBSztBQUVwQixVQUFNLFdBQVcsSUFBSSxNQUFNLG1CQUFtQjtBQUM5QyxXQUFPLFNBQVMsV0FBVyxLQUFLLEtBQUssU0FBUyxDQUFDLENBQUMsS0FBSyxLQUFLLFNBQVMsQ0FBQyxHQUFHLElBQUk7QUFBQSxFQUM5RTtBQUNELFdBQVMsZ0JBQWdCLEtBQUssS0FBSztBQUMvQixRQUFJLEVBQUUsT0FBTztBQUNULGFBQU87QUFDWCxVQUFNLENBQUMsSUFBSSxFQUFFLElBQUksSUFBSSxNQUFNLG1CQUFtQjtBQUM5QyxVQUFNLENBQUMsSUFBSSxFQUFFLElBQUksSUFBSSxNQUFNLG1CQUFtQjtBQUM5QyxVQUFNLE1BQU0sWUFBWSxJQUFJLEVBQUU7QUFDOUIsUUFBSSxRQUFRO0FBQ1IsYUFBTztBQUNYLFdBQU8sT0FBTyxZQUFZLElBQUksRUFBRTtBQUFBLEVBQ25DO0FBQ0QsUUFBTSxtQkFBbUI7QUFDekIsUUFBTSxNQUFNO0FBQ1osV0FBU2tJLEtBQUksS0FBSztBQUVkLFdBQU8saUJBQWlCLEtBQUssR0FBRyxLQUFLLElBQUksS0FBSyxHQUFHO0FBQUEsRUFDcEQ7QUFDRCxRQUFNLE9BQU87QUFDYixXQUFTLEtBQUssS0FBSztBQUNmLFNBQUssWUFBWTtBQUNqQixXQUFPLEtBQUssS0FBSyxHQUFHO0FBQUEsRUFDdkI7QUFDRCxRQUFNLFlBQVksRUFBRSxLQUFLO0FBQ3pCLFFBQU0sWUFBWSxLQUFLLEtBQUs7QUFDNUIsV0FBUyxjQUFjLE9BQU87QUFDMUIsV0FBTyxPQUFPLFVBQVUsS0FBSyxLQUFLLFNBQVMsYUFBYSxTQUFTO0FBQUEsRUFDcEU7QUFDRCxXQUFTLGNBQWMsT0FBTztBQUUxQixXQUFPLE9BQU8sVUFBVSxLQUFLO0FBQUEsRUFDaEM7QUFDRCxXQUFTLGlCQUFpQjtBQUN0QixXQUFPO0FBQUEsRUFDVjtBQUNELFFBQU0sV0FBVztBQUNqQixXQUFTLE1BQU0sS0FBSztBQUNoQixRQUFJLFNBQVMsS0FBSyxHQUFHO0FBQ2pCLGFBQU87QUFDWCxRQUFJO0FBQ0EsVUFBSSxPQUFPLEdBQUc7QUFDZCxhQUFPO0FBQUEsSUFDVixTQUNNLEdBQUc7QUFDTixhQUFPO0FBQUEsSUFDVjtBQUFBLEVBQ0o7Ozs7QUMxS0QsU0FBTyxlQUFjbEksVUFBVSxjQUFjLEVBQUUsT0FBTyxLQUFJLENBQUU7QUFDNUQsRUFBQUEsU0FBZ0Msd0JBQUE7QUFDaEMsUUFBTSxRQUFROUI7QUFDZCxRQUFNaUgsYUFBWTFIO0FBQ2xCLFFBQU1zTSxPQUFNNUUsV0FBVTtBQUN0QixRQUFNNkUsUUFBTztBQUFBLElBQ1QsZUFBZSxFQUFFLE9BQU8sTUFBTSxJQUFJRCxLQUFJLEtBQUssTUFBTUEsS0FBSSxHQUFJO0FBQUEsSUFDekQsZUFBZSxFQUFFLE9BQU8sTUFBTSxJQUFJQSxLQUFJLEtBQUssTUFBTUEsS0FBSSxHQUFJO0FBQUEsSUFDekQsd0JBQXdCLEVBQUUsT0FBTyxLQUFLLElBQUlBLEtBQUksSUFBSSxNQUFNQSxLQUFJLElBQUs7QUFBQSxJQUNqRSx3QkFBd0IsRUFBRSxPQUFPLEtBQUssSUFBSUEsS0FBSSxJQUFJLE1BQU1BLEtBQUksSUFBSztBQUFBLEVBQ3JFO0FBQ0EsUUFBTWxNLFNBQVE7QUFBQSxJQUNWLFNBQVMsQ0FBQyxFQUFFLFNBQUF5SCxVQUFTLFdBQVksTUFBS0gsV0FBVSxnQkFBaUI2RSxNQUFLMUUsUUFBTyxFQUFFLEtBQUssSUFBSSxVQUFVO0FBQUEsSUFDbEcsUUFBUSxDQUFDLEVBQUUsU0FBQUEsVUFBUyxXQUFVLE1BQU9ILFdBQVUsaUJBQWtCNkUsTUFBSzFFLFFBQU8sRUFBRSxLQUFLLFlBQVksVUFBVTtBQUFBLEVBQzlHO0FBQ0EsRUFBQXRGLFNBQWdDLHdCQUFBO0FBQUEsSUFDNUIsU0FBUyxPQUFPLEtBQUtnSyxLQUFJO0FBQUEsSUFDekIsTUFBTTtBQUFBLElBQ04sWUFBWTtBQUFBLElBQ1osT0FBTztBQUFBLElBQ1AsT0FBQW5NO0FBQUEsSUFDQSxLQUFLLEtBQUs7QUFDTixZQUFNLEVBQUUsS0FBSyxNQUFNLFlBQVksU0FBQXlILFVBQVMsR0FBSSxJQUFHO0FBQy9DLFlBQU0sRUFBRSxNQUFNLE1BQUF2RyxNQUFNLElBQUc7QUFDdkIsVUFBSSxDQUFDLEtBQUs7QUFDTjtBQUNKLFlBQU0sT0FBTyxJQUFJLE1BQU0sV0FBVyxJQUFJQSxNQUFLLE1BQU0sSUFBSSxPQUFPLFlBQVksUUFBUTtBQUNoRixVQUFJLEtBQUs7QUFDTDs7QUFFQTtBQUNKLGVBQVMsc0JBQXNCO0FBQzNCLGNBQU0sT0FBTyxJQUFJLFdBQVcsV0FBVztBQUFBLFVBQ25DLEtBQUtBLE1BQUs7QUFBQSxVQUNWLE1BQU0sS0FBSyxLQUFLO0FBQUEsUUFDaEMsQ0FBYTtBQUNELGNBQU0sTUFBTSxJQUFJLE1BQU0sT0FBT29HLFdBQVUsSUFBSyxJQUFJLElBQUksS0FBSyxVQUFVLEdBQUc7QUFDdEUsWUFBSSxVQUFVQSxXQUFVLEdBQUdBLFdBQVUsV0FBWSxHQUFHLGdCQUFnQkEsV0FBVSxJQUFLLEdBQUcsc0JBQXNCQSxXQUFVLFdBQVksR0FBRywwQkFBMEIsWUFBWSxHQUFHLENBQUMsQ0FBQztBQUFBLE1BQ25MO0FBQ0QsZUFBUyxpQkFBaUI7QUFDdEIsY0FBTXVELFVBQVMsS0FBSztBQUNwQixjQUFNLFNBQVMzSixNQUFLLFFBQVEySixPQUFNO0FBQ2xDLFlBQUksQ0FBQyxVQUFVLFdBQVc7QUFDdEI7QUFDSixZQUFJLE9BQU8sVUFBVSxZQUNqQixrQkFBa0IsVUFDbEIsT0FBTyxPQUFPLFdBQVcsWUFBWTtBQUNyQyxnQkFBTSxJQUFJLE1BQU0sSUFBSXBELFFBQU8sY0FBY29ELE9BQU0sc0NBQXNDO0FBQUEsUUFDeEY7QUFDRCxjQUFNLE1BQU0sSUFBSSxXQUFXLFdBQVc7QUFBQSxVQUNsQyxLQUFLQTtBQUFBLFVBQ0wsS0FBSztBQUFBLFVBQ0wsTUFBTSxLQUFLLEtBQUssVUFBVXZELFdBQVUsSUFBSyxLQUFLLEtBQUssT0FBTyxHQUFHQSxXQUFVLFlBQVl1RCxPQUFNLENBQUMsS0FBSztBQUFBLFFBQy9HLENBQWE7QUFDRCxZQUFJLFVBQVUsWUFBWSxHQUFHLENBQUM7QUFBQSxNQUNqQztBQUNELGVBQVMsWUFBWSxLQUFLO0FBQ3RCLGVBQU92RCxXQUFVLElBQUssR0FBRyxZQUFZLElBQUksS0FBSyxVQUFVLEtBQUs2RSxNQUFLMUUsUUFBTyxFQUFFLElBQUk7QUFBQSxNQUNsRjtBQUFBLElBQ0o7QUFBQSxJQUNELGNBQWMsQ0FBQyxRQUFRO0FBQUEsRUFDM0I7QUFDQSxRQUFNLG9CQUFvQixDQUFDMkUsU0FBUTtBQUMvQixJQUFBQSxLQUFJLFdBQVdqSyxTQUFRLHFCQUFxQjtBQUM1QyxXQUFPaUs7QUFBQSxFQUNYO0FBQ0EsRUFBQWpLLFNBQUEsVUFBa0I7OztBQ2xFbEIsU0FBTyxlQUFjQSxVQUFVLGNBQWMsRUFBRSxPQUFPLEtBQUksQ0FBRTtBQUM1RCxRQUFNLFlBQVk5QjtBQUNsQixRQUFNLFVBQVVUO0FBQ2hCLFFBQU0wSCxhQUFZekg7QUFDbEIsUUFBTSxXQUFXLElBQUl5SCxXQUFVLEtBQUssYUFBYTtBQUNqRCxRQUFNLFdBQVcsSUFBSUEsV0FBVSxLQUFLLGFBQWE7QUFDakQsUUFBTSxnQkFBZ0IsQ0FBQzhFLE1BQUssT0FBTyxFQUFFLFVBQVUsV0FBVztBQUN0RCxRQUFJLE1BQU0sUUFBUSxJQUFJLEdBQUc7QUFDckIsaUJBQVdBLE1BQUssTUFBTSxVQUFVLGFBQWEsUUFBUTtBQUNyRCxhQUFPQTtBQUFBLElBQ1Y7QUFDRCxVQUFNLENBQUNDLFVBQVMsVUFBVSxJQUFJLEtBQUssU0FBUyxTQUFTLENBQUMsVUFBVSxhQUFhLFFBQVEsSUFBSSxDQUFDLFVBQVUsYUFBYSxRQUFRO0FBQ3pILFVBQU0sT0FBTyxLQUFLLFdBQVcsVUFBVTtBQUN2QyxlQUFXRCxNQUFLLE1BQU1DLFVBQVMsVUFBVTtBQUN6QyxRQUFJLEtBQUs7QUFDTCxjQUFRLFFBQVFELElBQUc7QUFDdkIsV0FBT0E7QUFBQSxFQUNYO0FBQ0EsZ0JBQWMsTUFBTSxDQUFDLE1BQU0sT0FBTyxXQUFXO0FBQ3pDLFVBQU1DLFdBQVUsU0FBUyxTQUFTLFVBQVUsY0FBYyxVQUFVO0FBQ3BFLFVBQU0sSUFBSUEsU0FBUSxJQUFJO0FBQ3RCLFFBQUksQ0FBQztBQUNELFlBQU0sSUFBSSxNQUFNLG1CQUFtQixJQUFJLEdBQUc7QUFDOUMsV0FBTztBQUFBLEVBQ1g7QUFDQSxXQUFTLFdBQVdELE1BQUssTUFBTTFMLEtBQUksWUFBWTtBQUMzQyxRQUFJO0FBQ0osUUFBSTtBQUNKLEtBQUMsTUFBTSxLQUFLMEwsS0FBSSxLQUFLLE1BQU0sYUFBYSxRQUFRLE9BQU8sU0FBUyxLQUFNLEdBQUcsVUFBVTlFLFdBQVUsd0NBQXlDLFVBQVU7QUFDaEosZUFBVyxLQUFLO0FBQ1osTUFBQThFLEtBQUksVUFBVSxHQUFHMUwsSUFBRyxDQUFDLENBQUM7QUFBQSxFQUM3QjtBQUNELEVBQUFzTCxRQUFpQixVQUFBN0osV0FBVTtBQUMzQixTQUFPLGVBQWNBLFVBQVUsY0FBYyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQzVELEVBQUFBLFNBQUEsVUFBa0I7OztBQ2pDbEIsTUFBTSxlQUFlLENBQUMsSUFBSSxNQUFNLFVBQVUsMEJBQTBCO0FBR25FLE1BQUksYUFBYSxZQUFZLGFBQWEsYUFBYTtBQUN0RDtBQUFBLEVBQ0E7QUFHRCxNQUFJLGFBQWEsZUFBZSxhQUFhLFVBQVU7QUFDdEQ7QUFBQSxFQUNBO0FBRUQsUUFBTSxlQUFlLE9BQU8seUJBQXlCLElBQUksUUFBUTtBQUNqRSxRQUFNLGlCQUFpQixPQUFPLHlCQUF5QixNQUFNLFFBQVE7QUFFckUsTUFBSSxDQUFDLGdCQUFnQixjQUFjLGNBQWMsS0FBSyx1QkFBdUI7QUFDNUU7QUFBQSxFQUNBO0FBRUQsU0FBTyxlQUFlLElBQUksVUFBVSxjQUFjO0FBQ25EO0FBS0EsTUFBTSxrQkFBa0IsU0FBVSxjQUFjLGdCQUFnQjtBQUMvRCxTQUFPLGlCQUFpQixVQUFhLGFBQWEsZ0JBQ2pELGFBQWEsYUFBYSxlQUFlLFlBQ3pDLGFBQWEsZUFBZSxlQUFlLGNBQzNDLGFBQWEsaUJBQWlCLGVBQWUsaUJBQzVDLGFBQWEsWUFBWSxhQUFhLFVBQVUsZUFBZTtBQUVsRTtBQUVBLE1BQU0sa0JBQWtCLENBQUMsSUFBSSxTQUFTO0FBQ3JDLFFBQU0sZ0JBQWdCLE9BQU8sZUFBZSxJQUFJO0FBQ2hELE1BQUksa0JBQWtCLE9BQU8sZUFBZSxFQUFFLEdBQUc7QUFDaEQ7QUFBQSxFQUNBO0FBRUQsU0FBTyxlQUFlLElBQUksYUFBYTtBQUN4QztBQUVBLE1BQU0sa0JBQWtCLENBQUMsVUFBVSxhQUFhLGNBQWMsUUFBUTtBQUFBLEVBQU8sUUFBUTtBQUVyRixNQUFNLHFCQUFxQixPQUFPLHlCQUF5QixTQUFTLFdBQVcsVUFBVTtBQUN6RixNQUFNLGVBQWUsT0FBTyx5QkFBeUIsU0FBUyxVQUFVLFVBQVUsTUFBTTtBQUt4RixNQUFNLGlCQUFpQixDQUFDLElBQUksTUFBTSxTQUFTO0FBQzFDLFFBQU0sV0FBVyxTQUFTLEtBQUssS0FBSyxRQUFRLEtBQUssTUFBTTtBQUN2RCxRQUFNLGNBQWMsZ0JBQWdCLEtBQUssTUFBTSxVQUFVLEtBQUssU0FBUSxDQUFFO0FBRXhFLFNBQU8sZUFBZSxhQUFhLFFBQVEsWUFBWTtBQUN2RCxTQUFPLGVBQWUsSUFBSSxZQUFZLEVBQUMsR0FBRyxvQkFBb0IsT0FBTyxZQUFXLENBQUM7QUFDbEY7QUFFQSxNQUFNbUssWUFBVSxDQUFDLElBQUksTUFBTSxFQUFDLHdCQUF3QixNQUFLLElBQUksT0FBTztBQUNuRSxRQUFNLEVBQUMsS0FBSSxJQUFJO0FBRWYsYUFBVyxZQUFZLFFBQVEsUUFBUSxJQUFJLEdBQUc7QUFDN0MsaUJBQWEsSUFBSSxNQUFNLFVBQVUscUJBQXFCO0FBQUEsRUFDdEQ7QUFFRCxrQkFBZ0IsSUFBSSxJQUFJO0FBQ3hCLGlCQUFlLElBQUksTUFBTSxJQUFJO0FBRTdCLFNBQU87QUFDUjtBQUVBLElBQUEsWUFBaUJBO0FDekVqQixNQUFNQSxZQUFVak07QUFFaEIsSUFBQSxhQUFpQixDQUFDLGVBQWUsVUFBVSxPQUFPO0FBQ2pELE1BQUksT0FBTyxrQkFBa0IsWUFBWTtBQUN4QyxVQUFNLElBQUksVUFBVSx1REFBdUQsT0FBTyxhQUFhLElBQUk7QUFBQSxFQUNuRztBQUVELFFBQU07QUFBQSxJQUNMLE9BQU87QUFBQSxJQUNQLFNBQVM7QUFBQSxJQUNULFFBQVE7QUFBQSxFQUNSLElBQUc7QUFFSixNQUFJLENBQUMsVUFBVSxDQUFDLE9BQU87QUFDdEIsVUFBTSxJQUFJLE1BQU0sbUVBQW9FO0FBQUEsRUFDcEY7QUFFRCxNQUFJO0FBQ0osTUFBSTtBQUVKLFFBQU0sb0JBQW9CLFlBQWEsWUFBWTtBQUNsRCxVQUFNLFVBQVU7QUFFaEIsVUFBTSxRQUFRLE1BQU07QUFDbkIsZ0JBQVU7QUFFVixVQUFJLE9BQU87QUFDVixpQkFBUyxjQUFjLE1BQU0sU0FBUyxVQUFVO0FBQUEsTUFDaEQ7QUFBQSxJQUNKO0FBRUUsVUFBTSxnQkFBZ0IsVUFBVSxDQUFDO0FBQ2pDLGlCQUFhLE9BQU87QUFDcEIsY0FBVSxXQUFXLE9BQU8sSUFBSTtBQUVoQyxRQUFJLGVBQWU7QUFDbEIsZUFBUyxjQUFjLE1BQU0sU0FBUyxVQUFVO0FBQUEsSUFDaEQ7QUFFRCxXQUFPO0FBQUEsRUFDVDtBQUVDaU0sWUFBUSxtQkFBbUIsYUFBYTtBQUV4QyxvQkFBa0IsU0FBUyxNQUFNO0FBQ2hDLFFBQUksU0FBUztBQUNaLG1CQUFhLE9BQU87QUFDcEIsZ0JBQVU7QUFBQSxJQUNWO0FBQUEsRUFDSDtBQUVDLFNBQU87QUFDUjs7QUNuREEsTUFBTSxzQkFBc0I7QUFFNUIsTUFBTUMsZUFBYTtBQUNuQixNQUFNQyxxQkFBbUIsT0FBTztBQUNMO0FBRzNCLE1BQU0sNEJBQTRCO0FBSWxDLE1BQU0sd0JBQXdCRCxlQUFhO0FBRTNDLE1BQU0sZ0JBQWdCO0FBQUEsRUFDcEI7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFDRjtBQUVBLElBQUFoTSxjQUFpQjtBQUFBLEVBQ2pCLFlBQUVnTTtBQUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0Ysa0JBQUVDO0FBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQSx5QkFBeUI7QUFBQSxFQUN6QixZQUFZO0FBQ2Q7QUNsQ0EsTUFBTWxMLFVBQ0osT0FBTyxZQUFZLFlBQ25CLFFBQVEsT0FDUixRQUFRLElBQUksY0FDWixjQUFjLEtBQUssUUFBUSxJQUFJLFVBQVUsSUFDdkMsSUFBSSxTQUFTLFFBQVEsTUFBTSxVQUFVLEdBQUcsSUFBSSxJQUM1QyxNQUFNO0FBQUU7QUFFWixJQUFBLFVBQWlCQTtBQUFBQTtBQ1JqQixRQUFNO0FBQUEsSUFDSiwyQkFBQW1MO0FBQUEsSUFDQSx1QkFBQUM7QUFBQSxJQUNBLFlBQUFIO0FBQUEsRUFDRixJQUFJbE07QUFDSixRQUFNaUIsU0FBUTFCO0FBQ2QsRUFBQXVDLFdBQVU2SixrQkFBaUIsQ0FBRTtBQUc3QixRQUFNVyxNQUFLeEssU0FBQSxLQUFhLENBQUU7QUFDMUIsUUFBTSxTQUFTQSxTQUFBLFNBQWlCLENBQUU7QUFDbEMsUUFBTSxNQUFNQSxTQUFBLE1BQWMsQ0FBRTtBQUM1QixRQUFNOEYsS0FBSTlGLFNBQUEsSUFBWSxDQUFFO0FBQ3hCLE1BQUksSUFBSTtBQUVSLFFBQU0sbUJBQW1CO0FBUXpCLFFBQU0sd0JBQXdCO0FBQUEsSUFDNUIsQ0FBQyxPQUFPLENBQUM7QUFBQSxJQUNULENBQUMsT0FBT29LLFdBQVU7QUFBQSxJQUNsQixDQUFDLGtCQUFrQkcsc0JBQXFCO0FBQUEsRUFDekM7QUFFRCxRQUFNLGdCQUFnQixDQUFDLFVBQVU7QUFDL0IsZUFBVyxDQUFDLE9BQU8sR0FBRyxLQUFLLHVCQUF1QjtBQUNoRCxjQUFRLE1BQ0wsTUFBTSxHQUFHLEtBQUssR0FBRyxFQUFFLEtBQUssR0FBRyxLQUFLLE1BQU0sR0FBRyxHQUFHLEVBQzVDLE1BQU0sR0FBRyxLQUFLLEdBQUcsRUFBRSxLQUFLLEdBQUcsS0FBSyxNQUFNLEdBQUcsR0FBRztBQUFBLElBQ2hEO0FBQ0QsV0FBTztBQUFBLEVBQ1I7QUFFRCxRQUFNLGNBQWMsQ0FBQyxNQUFNLE9BQU8sYUFBYTtBQUM3QyxVQUFNLE9BQU8sY0FBYyxLQUFLO0FBQ2hDLFVBQU0sUUFBUTtBQUNkLElBQUFwTCxPQUFNLE1BQU0sT0FBTyxLQUFLO0FBQ3hCLElBQUEyRyxHQUFFLElBQUksSUFBSTtBQUNWLFFBQUksS0FBSyxJQUFJO0FBQ2IsSUFBQTBFLElBQUcsS0FBSyxJQUFJLElBQUksT0FBTyxPQUFPLFdBQVcsTUFBTSxNQUFTO0FBQ3hELFdBQU8sS0FBSyxJQUFJLElBQUksT0FBTyxNQUFNLFdBQVcsTUFBTSxNQUFTO0FBQUEsRUFDNUQ7QUFRRCxjQUFZLHFCQUFxQixhQUFhO0FBQzlDLGNBQVksMEJBQTBCLE1BQU07QUFNNUMsY0FBWSx3QkFBd0IsZ0JBQWdCLGdCQUFnQixHQUFHO0FBS3ZFLGNBQVksZUFBZSxJQUFJLElBQUkxRSxHQUFFLGlCQUFpQixDQUFDLFFBQ2hDLElBQUlBLEdBQUUsaUJBQWlCLENBQUMsUUFDeEIsSUFBSUEsR0FBRSxpQkFBaUIsQ0FBQyxHQUFHO0FBRWxELGNBQVksb0JBQW9CLElBQUksSUFBSUEsR0FBRSxzQkFBc0IsQ0FBQyxRQUNyQyxJQUFJQSxHQUFFLHNCQUFzQixDQUFDLFFBQzdCLElBQUlBLEdBQUUsc0JBQXNCLENBQUMsR0FBRztBQUs1RCxjQUFZLHdCQUF3QixNQUFNLElBQUlBLEdBQUUsaUJBQWlCLENBQ2hFLElBQUcsSUFBSUEsR0FBRSxvQkFBb0IsQ0FBQyxHQUFHO0FBRWxDLGNBQVksNkJBQTZCLE1BQU0sSUFBSUEsR0FBRSxzQkFBc0IsQ0FDMUUsSUFBRyxJQUFJQSxHQUFFLG9CQUFvQixDQUFDLEdBQUc7QUFNbEMsY0FBWSxjQUFjLFFBQVEsSUFBSUEsR0FBRSxvQkFBb0IsQ0FDM0QsU0FBUSxJQUFJQSxHQUFFLG9CQUFvQixDQUFDLE1BQU07QUFFMUMsY0FBWSxtQkFBbUIsU0FBUyxJQUFJQSxHQUFFLHlCQUF5QixDQUN0RSxTQUFRLElBQUlBLEdBQUUseUJBQXlCLENBQUMsTUFBTTtBQUsvQyxjQUFZLG1CQUFtQixHQUFHLGdCQUFnQixHQUFHO0FBTXJELGNBQVksU0FBUyxVQUFVLElBQUlBLEdBQUUsZUFBZSxDQUNuRCxTQUFRLElBQUlBLEdBQUUsZUFBZSxDQUFDLE1BQU07QUFXckMsY0FBWSxhQUFhLEtBQUssSUFBSUEsR0FBRSxXQUFXLENBQzlDLEdBQUUsSUFBSUEsR0FBRSxVQUFVLENBQUMsSUFDbEIsSUFBSUEsR0FBRSxLQUFLLENBQUMsR0FBRztBQUVqQixjQUFZLFFBQVEsSUFBSSxJQUFJQSxHQUFFLFNBQVMsQ0FBQyxHQUFHO0FBSzNDLGNBQVksY0FBYyxXQUFXLElBQUlBLEdBQUUsZ0JBQWdCLENBQzFELEdBQUUsSUFBSUEsR0FBRSxlQUFlLENBQUMsSUFDdkIsSUFBSUEsR0FBRSxLQUFLLENBQUMsR0FBRztBQUVqQixjQUFZLFNBQVMsSUFBSSxJQUFJQSxHQUFFLFVBQVUsQ0FBQyxHQUFHO0FBRTdDLGNBQVksUUFBUSxjQUFjO0FBS2xDLGNBQVkseUJBQXlCLEdBQUcsSUFBSUEsR0FBRSxzQkFBc0IsQ0FBQyxVQUFVO0FBQy9FLGNBQVksb0JBQW9CLEdBQUcsSUFBSUEsR0FBRSxpQkFBaUIsQ0FBQyxVQUFVO0FBRXJFLGNBQVksZUFBZSxZQUFZLElBQUlBLEdBQUUsZ0JBQWdCLENBQUMsV0FDakMsSUFBSUEsR0FBRSxnQkFBZ0IsQ0FBQyxXQUN2QixJQUFJQSxHQUFFLGdCQUFnQixDQUFDLE9BQzNCLElBQUlBLEdBQUUsVUFBVSxDQUFDLEtBQ3JCLElBQUlBLEdBQUUsS0FBSyxDQUFDLE9BQ1I7QUFFekIsY0FBWSxvQkFBb0IsWUFBWSxJQUFJQSxHQUFFLHFCQUFxQixDQUFDLFdBQ3RDLElBQUlBLEdBQUUscUJBQXFCLENBQUMsV0FDNUIsSUFBSUEsR0FBRSxxQkFBcUIsQ0FBQyxPQUNoQyxJQUFJQSxHQUFFLGVBQWUsQ0FBQyxLQUMxQixJQUFJQSxHQUFFLEtBQUssQ0FBQyxPQUNSO0FBRTlCLGNBQVksVUFBVSxJQUFJLElBQUlBLEdBQUUsSUFBSSxDQUFDLE9BQU8sSUFBSUEsR0FBRSxXQUFXLENBQUMsR0FBRztBQUNqRSxjQUFZLGVBQWUsSUFBSSxJQUFJQSxHQUFFLElBQUksQ0FBQyxPQUFPLElBQUlBLEdBQUUsZ0JBQWdCLENBQUMsR0FBRztBQUkzRSxjQUFZLFVBQVUsR0FBRyxtQkFDRixHQUFHd0UsMEJBQXlCLGtCQUNyQkEsMEJBQXlCLG9CQUN6QkEsMEJBQXlCLGtCQUMzQjtBQUM1QixjQUFZLGFBQWEsSUFBSXhFLEdBQUUsTUFBTSxHQUFHLElBQUk7QUFJNUMsY0FBWSxhQUFhLFNBQVM7QUFFbEMsY0FBWSxhQUFhLFNBQVMsSUFBSUEsR0FBRSxTQUFTLENBQUMsUUFBUSxJQUFJO0FBQzlELEVBQUE5RixTQUFBLG1CQUEyQjtBQUUzQixjQUFZLFNBQVMsSUFBSSxJQUFJOEYsR0FBRSxTQUFTLENBQUMsR0FBRyxJQUFJQSxHQUFFLFdBQVcsQ0FBQyxHQUFHO0FBQ2pFLGNBQVksY0FBYyxJQUFJLElBQUlBLEdBQUUsU0FBUyxDQUFDLEdBQUcsSUFBSUEsR0FBRSxnQkFBZ0IsQ0FBQyxHQUFHO0FBSTNFLGNBQVksYUFBYSxTQUFTO0FBRWxDLGNBQVksYUFBYSxTQUFTLElBQUlBLEdBQUUsU0FBUyxDQUFDLFFBQVEsSUFBSTtBQUM5RCxFQUFBOUYsU0FBQSxtQkFBMkI7QUFFM0IsY0FBWSxTQUFTLElBQUksSUFBSThGLEdBQUUsU0FBUyxDQUFDLEdBQUcsSUFBSUEsR0FBRSxXQUFXLENBQUMsR0FBRztBQUNqRSxjQUFZLGNBQWMsSUFBSSxJQUFJQSxHQUFFLFNBQVMsQ0FBQyxHQUFHLElBQUlBLEdBQUUsZ0JBQWdCLENBQUMsR0FBRztBQUczRSxjQUFZLG1CQUFtQixJQUFJLElBQUlBLEdBQUUsSUFBSSxDQUFDLFFBQVEsSUFBSUEsR0FBRSxVQUFVLENBQUMsT0FBTztBQUM5RSxjQUFZLGNBQWMsSUFBSSxJQUFJQSxHQUFFLElBQUksQ0FBQyxRQUFRLElBQUlBLEdBQUUsU0FBUyxDQUFDLE9BQU87QUFJeEUsY0FBWSxrQkFBa0IsU0FBUyxJQUFJQSxHQUFFLElBQUksQ0FDaEQsUUFBTyxJQUFJQSxHQUFFLFVBQVUsQ0FBQyxJQUFJLElBQUlBLEdBQUUsV0FBVyxDQUFDLEtBQUssSUFBSTtBQUN4RCxFQUFBOUYsU0FBQSx3QkFBZ0M7QUFNaEMsY0FBWSxlQUFlLFNBQVMsSUFBSThGLEdBQUUsV0FBVyxDQUFDLGNBRS9CLElBQUlBLEdBQUUsV0FBVyxDQUFDLFFBQ2Y7QUFFMUIsY0FBWSxvQkFBb0IsU0FBUyxJQUFJQSxHQUFFLGdCQUFnQixDQUFDLGNBRXBDLElBQUlBLEdBQUUsZ0JBQWdCLENBQUMsUUFDcEI7QUFHL0IsY0FBWSxRQUFRLGlCQUFpQjtBQUVyQyxjQUFZLFFBQVEsMkJBQTJCO0FBQy9DLGNBQVksV0FBVyw2QkFBNkI7OztBQ2xOcEQsTUFBTSxjQUFjLE9BQU8sT0FBTyxFQUFFLE9BQU8sS0FBSSxDQUFFO0FBQ2pELE1BQU0sWUFBWSxPQUFPLE9BQU8sRUFBRztBQUNuQyxNQUFNMkUsaUJBQWUsYUFBVztBQUM5QixNQUFJLENBQUMsU0FBUztBQUNaLFdBQU87QUFBQSxFQUNSO0FBRUQsTUFBSSxPQUFPLFlBQVksVUFBVTtBQUMvQixXQUFPO0FBQUEsRUFDUjtBQUVELFNBQU87QUFDVDtBQUNBLElBQUEsaUJBQWlCQTtBQ2RqQixNQUFNLFVBQVU7QUFDaEIsTUFBTUMsdUJBQXFCLENBQUMsR0FBRyxNQUFNO0FBQ25DLFFBQU0sT0FBTyxRQUFRLEtBQUssQ0FBQztBQUMzQixRQUFNLE9BQU8sUUFBUSxLQUFLLENBQUM7QUFFM0IsTUFBSSxRQUFRLE1BQU07QUFDaEIsUUFBSSxDQUFDO0FBQ0wsUUFBSSxDQUFDO0FBQUEsRUFDTjtBQUVELFNBQU8sTUFBTSxJQUFJLElBQ1osUUFBUSxDQUFDLE9BQVEsS0FDakIsUUFBUSxDQUFDLE9BQVEsSUFDbEIsSUFBSSxJQUFJLEtBQ1I7QUFDTjtBQUVBLE1BQU0sc0JBQXNCLENBQUMsR0FBRyxNQUFNQSxxQkFBbUIsR0FBRyxDQUFDO0FBRTdELElBQUFDLGdCQUFpQjtBQUFBLEVBQ2pCLG9CQUFFRDtBQUFBQSxFQUNBO0FBQ0Y7QUN0QkEsTUFBTSxRQUFReE07QUFDZCxNQUFNLEVBQUUsWUFBWSxpQkFBZ0IsSUFBS1Q7QUFDekMsTUFBTSxFQUFFLFFBQVErTSxTQUFJMUUsSUFBQyxJQUFLcEk7QUFFMUIsTUFBTSxlQUFld0I7QUFDckIsTUFBTSxFQUFFLG1CQUFvQixJQUFHNkI7QUFDL0IsSUFBQSxXQUFBLE1BQU0sT0FBTztBQUFBLEVBQ1gsWUFBYSxTQUFTLFNBQVM7QUFDN0IsY0FBVSxhQUFhLE9BQU87QUFFOUIsUUFBSSxtQkFBbUIsUUFBUTtBQUM3QixVQUFJLFFBQVEsVUFBVSxDQUFDLENBQUMsUUFBUSxTQUM1QixRQUFRLHNCQUFzQixDQUFDLENBQUMsUUFBUSxtQkFBbUI7QUFDN0QsZUFBTztBQUFBLE1BQ2YsT0FBYTtBQUNMLGtCQUFVLFFBQVE7QUFBQSxNQUNuQjtBQUFBLElBQ1AsV0FBZSxPQUFPLFlBQVksVUFBVTtBQUN0QyxZQUFNLElBQUksVUFBVSxnREFBZ0QsT0FBTyxPQUFPLElBQUk7QUFBQSxJQUN2RjtBQUVELFFBQUksUUFBUSxTQUFTLFlBQVk7QUFDL0IsWUFBTSxJQUFJO0FBQUEsUUFDUiwwQkFBMEIsVUFBVTtBQUFBLE1BQ3JDO0FBQUEsSUFDRjtBQUVELFVBQU0sVUFBVSxTQUFTLE9BQU87QUFDaEMsU0FBSyxVQUFVO0FBQ2YsU0FBSyxRQUFRLENBQUMsQ0FBQyxRQUFRO0FBR3ZCLFNBQUssb0JBQW9CLENBQUMsQ0FBQyxRQUFRO0FBRW5DLFVBQU0sSUFBSSxRQUFRLEtBQUksRUFBRyxNQUFNLFFBQVEsUUFBUXlKLEtBQUcxRSxJQUFFLEtBQUssSUFBSTBFLEtBQUcxRSxJQUFFLElBQUksQ0FBQztBQUV2RSxRQUFJLENBQUMsR0FBRztBQUNOLFlBQU0sSUFBSSxVQUFVLG9CQUFvQixPQUFPLEVBQUU7QUFBQSxJQUNsRDtBQUVELFNBQUssTUFBTTtBQUdYLFNBQUssUUFBUSxDQUFDLEVBQUUsQ0FBQztBQUNqQixTQUFLLFFBQVEsQ0FBQyxFQUFFLENBQUM7QUFDakIsU0FBSyxRQUFRLENBQUMsRUFBRSxDQUFDO0FBRWpCLFFBQUksS0FBSyxRQUFRLG9CQUFvQixLQUFLLFFBQVEsR0FBRztBQUNuRCxZQUFNLElBQUksVUFBVSx1QkFBdUI7QUFBQSxJQUM1QztBQUVELFFBQUksS0FBSyxRQUFRLG9CQUFvQixLQUFLLFFBQVEsR0FBRztBQUNuRCxZQUFNLElBQUksVUFBVSx1QkFBdUI7QUFBQSxJQUM1QztBQUVELFFBQUksS0FBSyxRQUFRLG9CQUFvQixLQUFLLFFBQVEsR0FBRztBQUNuRCxZQUFNLElBQUksVUFBVSx1QkFBdUI7QUFBQSxJQUM1QztBQUdELFFBQUksQ0FBQyxFQUFFLENBQUMsR0FBRztBQUNULFdBQUssYUFBYSxDQUFFO0FBQUEsSUFDMUIsT0FBVztBQUNMLFdBQUssYUFBYSxFQUFFLENBQUMsRUFBRSxNQUFNLEdBQUcsRUFBRSxJQUFJLENBQUN0SSxRQUFPO0FBQzVDLFlBQUksV0FBVyxLQUFLQSxHQUFFLEdBQUc7QUFDdkIsZ0JBQU0sTUFBTSxDQUFDQTtBQUNiLGNBQUksT0FBTyxLQUFLLE1BQU0sa0JBQWtCO0FBQ3RDLG1CQUFPO0FBQUEsVUFDUjtBQUFBLFFBQ0Y7QUFDRCxlQUFPQTtBQUFBLE1BQ2YsQ0FBTztBQUFBLElBQ0Y7QUFFRCxTQUFLLFFBQVEsRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsTUFBTSxHQUFHLElBQUksQ0FBRTtBQUN4QyxTQUFLLE9BQVE7QUFBQSxFQUNkO0FBQUEsRUFFRCxTQUFVO0FBQ1IsU0FBSyxVQUFVLEdBQUcsS0FBSyxLQUFLLElBQUksS0FBSyxLQUFLLElBQUksS0FBSyxLQUFLO0FBQ3hELFFBQUksS0FBSyxXQUFXLFFBQVE7QUFDMUIsV0FBSyxXQUFXLElBQUksS0FBSyxXQUFXLEtBQUssR0FBRyxDQUFDO0FBQUEsSUFDOUM7QUFDRCxXQUFPLEtBQUs7QUFBQSxFQUNiO0FBQUEsRUFFRCxXQUFZO0FBQ1YsV0FBTyxLQUFLO0FBQUEsRUFDYjtBQUFBLEVBRUQsUUFBUyxPQUFPO0FBQ2QsVUFBTSxrQkFBa0IsS0FBSyxTQUFTLEtBQUssU0FBUyxLQUFLO0FBQ3pELFFBQUksRUFBRSxpQkFBaUIsU0FBUztBQUM5QixVQUFJLE9BQU8sVUFBVSxZQUFZLFVBQVUsS0FBSyxTQUFTO0FBQ3ZELGVBQU87QUFBQSxNQUNSO0FBQ0QsY0FBUSxJQUFJLE9BQU8sT0FBTyxLQUFLLE9BQU87QUFBQSxJQUN2QztBQUVELFFBQUksTUFBTSxZQUFZLEtBQUssU0FBUztBQUNsQyxhQUFPO0FBQUEsSUFDUjtBQUVELFdBQU8sS0FBSyxZQUFZLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSztBQUFBLEVBQ3hEO0FBQUEsRUFFRCxZQUFhLE9BQU87QUFDbEIsUUFBSSxFQUFFLGlCQUFpQixTQUFTO0FBQzlCLGNBQVEsSUFBSSxPQUFPLE9BQU8sS0FBSyxPQUFPO0FBQUEsSUFDdkM7QUFFRCxXQUNFLG1CQUFtQixLQUFLLE9BQU8sTUFBTSxLQUFLLEtBQzFDLG1CQUFtQixLQUFLLE9BQU8sTUFBTSxLQUFLLEtBQzFDLG1CQUFtQixLQUFLLE9BQU8sTUFBTSxLQUFLO0FBQUEsRUFFN0M7QUFBQSxFQUVELFdBQVksT0FBTztBQUNqQixRQUFJLEVBQUUsaUJBQWlCLFNBQVM7QUFDOUIsY0FBUSxJQUFJLE9BQU8sT0FBTyxLQUFLLE9BQU87QUFBQSxJQUN2QztBQUdELFFBQUksS0FBSyxXQUFXLFVBQVUsQ0FBQyxNQUFNLFdBQVcsUUFBUTtBQUN0RCxhQUFPO0FBQUEsSUFDYixXQUFlLENBQUMsS0FBSyxXQUFXLFVBQVUsTUFBTSxXQUFXLFFBQVE7QUFDN0QsYUFBTztBQUFBLElBQ2IsV0FBZSxDQUFDLEtBQUssV0FBVyxVQUFVLENBQUMsTUFBTSxXQUFXLFFBQVE7QUFDOUQsYUFBTztBQUFBLElBQ1I7QUFFRCxRQUFJLElBQUk7QUFDUixPQUFHO0FBQ0QsWUFBTSxJQUFJLEtBQUssV0FBVyxDQUFDO0FBQzNCLFlBQU0sSUFBSSxNQUFNLFdBQVcsQ0FBQztBQUM1QixZQUFNLHNCQUFzQixHQUFHLEdBQUcsQ0FBQztBQUNuQyxVQUFJLE1BQU0sVUFBYSxNQUFNLFFBQVc7QUFDdEMsZUFBTztBQUFBLE1BQ2YsV0FBaUIsTUFBTSxRQUFXO0FBQzFCLGVBQU87QUFBQSxNQUNmLFdBQWlCLE1BQU0sUUFBVztBQUMxQixlQUFPO0FBQUEsTUFDZixXQUFpQixNQUFNLEdBQUc7QUFDbEI7QUFBQSxNQUNSLE9BQWE7QUFDTCxlQUFPLG1CQUFtQixHQUFHLENBQUM7QUFBQSxNQUMvQjtBQUFBLElBQ0YsU0FBUSxFQUFFO0FBQUEsRUFDWjtBQUFBLEVBRUQsYUFBYyxPQUFPO0FBQ25CLFFBQUksRUFBRSxpQkFBaUIsU0FBUztBQUM5QixjQUFRLElBQUksT0FBTyxPQUFPLEtBQUssT0FBTztBQUFBLElBQ3ZDO0FBRUQsUUFBSSxJQUFJO0FBQ1IsT0FBRztBQUNELFlBQU0sSUFBSSxLQUFLLE1BQU0sQ0FBQztBQUN0QixZQUFNLElBQUksTUFBTSxNQUFNLENBQUM7QUFDdkIsWUFBTSxzQkFBc0IsR0FBRyxHQUFHLENBQUM7QUFDbkMsVUFBSSxNQUFNLFVBQWEsTUFBTSxRQUFXO0FBQ3RDLGVBQU87QUFBQSxNQUNmLFdBQWlCLE1BQU0sUUFBVztBQUMxQixlQUFPO0FBQUEsTUFDZixXQUFpQixNQUFNLFFBQVc7QUFDMUIsZUFBTztBQUFBLE1BQ2YsV0FBaUIsTUFBTSxHQUFHO0FBQ2xCO0FBQUEsTUFDUixPQUFhO0FBQ0wsZUFBTyxtQkFBbUIsR0FBRyxDQUFDO0FBQUEsTUFDL0I7QUFBQSxJQUNGLFNBQVEsRUFBRTtBQUFBLEVBQ1o7QUFBQTtBQUFBO0FBQUEsRUFJRCxJQUFLLFNBQVMsWUFBWSxnQkFBZ0I7QUFDeEMsWUFBUSxTQUFPO0FBQUEsTUFDYixLQUFLO0FBQ0gsYUFBSyxXQUFXLFNBQVM7QUFDekIsYUFBSyxRQUFRO0FBQ2IsYUFBSyxRQUFRO0FBQ2IsYUFBSztBQUNMLGFBQUssSUFBSSxPQUFPLFlBQVksY0FBYztBQUMxQztBQUFBLE1BQ0YsS0FBSztBQUNILGFBQUssV0FBVyxTQUFTO0FBQ3pCLGFBQUssUUFBUTtBQUNiLGFBQUs7QUFDTCxhQUFLLElBQUksT0FBTyxZQUFZLGNBQWM7QUFDMUM7QUFBQSxNQUNGLEtBQUs7QUFJSCxhQUFLLFdBQVcsU0FBUztBQUN6QixhQUFLLElBQUksU0FBUyxZQUFZLGNBQWM7QUFDNUMsYUFBSyxJQUFJLE9BQU8sWUFBWSxjQUFjO0FBQzFDO0FBQUEsTUFHRixLQUFLO0FBQ0gsWUFBSSxLQUFLLFdBQVcsV0FBVyxHQUFHO0FBQ2hDLGVBQUssSUFBSSxTQUFTLFlBQVksY0FBYztBQUFBLFFBQzdDO0FBQ0QsYUFBSyxJQUFJLE9BQU8sWUFBWSxjQUFjO0FBQzFDO0FBQUEsTUFFRixLQUFLO0FBS0gsWUFDRSxLQUFLLFVBQVUsS0FDZixLQUFLLFVBQVUsS0FDZixLQUFLLFdBQVcsV0FBVyxHQUMzQjtBQUNBLGVBQUs7QUFBQSxRQUNOO0FBQ0QsYUFBSyxRQUFRO0FBQ2IsYUFBSyxRQUFRO0FBQ2IsYUFBSyxhQUFhLENBQUU7QUFDcEI7QUFBQSxNQUNGLEtBQUs7QUFLSCxZQUFJLEtBQUssVUFBVSxLQUFLLEtBQUssV0FBVyxXQUFXLEdBQUc7QUFDcEQsZUFBSztBQUFBLFFBQ047QUFDRCxhQUFLLFFBQVE7QUFDYixhQUFLLGFBQWEsQ0FBRTtBQUNwQjtBQUFBLE1BQ0YsS0FBSztBQUtILFlBQUksS0FBSyxXQUFXLFdBQVcsR0FBRztBQUNoQyxlQUFLO0FBQUEsUUFDTjtBQUNELGFBQUssYUFBYSxDQUFFO0FBQ3BCO0FBQUEsTUFHRixLQUFLLE9BQU87QUFDVixjQUFNLE9BQU8sT0FBTyxjQUFjLElBQUksSUFBSTtBQUUxQyxZQUFJLENBQUMsY0FBYyxtQkFBbUIsT0FBTztBQUMzQyxnQkFBTSxJQUFJLE1BQU0saURBQWlEO0FBQUEsUUFDbEU7QUFFRCxZQUFJLEtBQUssV0FBVyxXQUFXLEdBQUc7QUFDaEMsZUFBSyxhQUFhLENBQUMsSUFBSTtBQUFBLFFBQ2pDLE9BQWU7QUFDTCxjQUFJLElBQUksS0FBSyxXQUFXO0FBQ3hCLGlCQUFPLEVBQUUsS0FBSyxHQUFHO0FBQ2YsZ0JBQUksT0FBTyxLQUFLLFdBQVcsQ0FBQyxNQUFNLFVBQVU7QUFDMUMsbUJBQUssV0FBVyxDQUFDO0FBQ2pCLGtCQUFJO0FBQUEsWUFDTDtBQUFBLFVBQ0Y7QUFDRCxjQUFJLE1BQU0sSUFBSTtBQUVaLGdCQUFJLGVBQWUsS0FBSyxXQUFXLEtBQUssR0FBRyxLQUFLLG1CQUFtQixPQUFPO0FBQ3hFLG9CQUFNLElBQUksTUFBTSx1REFBdUQ7QUFBQSxZQUN4RTtBQUNELGlCQUFLLFdBQVcsS0FBSyxJQUFJO0FBQUEsVUFDMUI7QUFBQSxRQUNGO0FBQ0QsWUFBSSxZQUFZO0FBR2QsY0FBSW9OLGNBQWEsQ0FBQyxZQUFZLElBQUk7QUFDbEMsY0FBSSxtQkFBbUIsT0FBTztBQUM1QixZQUFBQSxjQUFhLENBQUMsVUFBVTtBQUFBLFVBQ3pCO0FBQ0QsY0FBSSxtQkFBbUIsS0FBSyxXQUFXLENBQUMsR0FBRyxVQUFVLE1BQU0sR0FBRztBQUM1RCxnQkFBSSxNQUFNLEtBQUssV0FBVyxDQUFDLENBQUMsR0FBRztBQUM3QixtQkFBSyxhQUFhQTtBQUFBLFlBQ25CO0FBQUEsVUFDYixPQUFpQjtBQUNMLGlCQUFLLGFBQWFBO0FBQUEsVUFDbkI7QUFBQSxRQUNGO0FBQ0Q7QUFBQSxNQUNEO0FBQUEsTUFDRDtBQUNFLGNBQU0sSUFBSSxNQUFNLCtCQUErQixPQUFPLEVBQUU7QUFBQSxJQUMzRDtBQUNELFNBQUssTUFBTSxLQUFLLE9BQVE7QUFDeEIsUUFBSSxLQUFLLE1BQU0sUUFBUTtBQUNyQixXQUFLLE9BQU8sSUFBSSxLQUFLLE1BQU0sS0FBSyxHQUFHLENBQUM7QUFBQSxJQUNyQztBQUNELFdBQU87QUFBQSxFQUNSO0FBQ0g7QUFFQSxJQUFBQyxXQUFpQkM7QUM3U2pCLE1BQU1BLFdBQVM1TTtBQUNmLE1BQU04SixVQUFRLENBQUMsU0FBUyxTQUFTLGNBQWMsVUFBVTtBQUN2RCxNQUFJLG1CQUFtQjhDLFVBQVE7QUFDN0IsV0FBTztBQUFBLEVBQ1I7QUFDRCxNQUFJO0FBQ0YsV0FBTyxJQUFJQSxTQUFPLFNBQVMsT0FBTztBQUFBLEVBQ25DLFNBQVEsSUFBSTtBQUNYLFFBQUksQ0FBQyxhQUFhO0FBQ2hCLGFBQU87QUFBQSxJQUNSO0FBQ0QsVUFBTTtBQUFBLEVBQ1A7QUFDSDtBQUVBLElBQUEsVUFBaUI5QztBQ2ZqQixNQUFNQSxVQUFROUo7QUFDZCxNQUFNd0gsVUFBUSxDQUFDLFNBQVMsWUFBWTtBQUNsQyxRQUFNLElBQUlzQyxRQUFNLFNBQVMsT0FBTztBQUNoQyxTQUFPLElBQUksRUFBRSxVQUFVO0FBQ3pCO0FBQ0EsSUFBQSxVQUFpQnRDO0FDTGpCLE1BQU1zQyxVQUFROUo7QUFDZCxNQUFNNk0sVUFBUSxDQUFDLFNBQVMsWUFBWTtBQUNsQyxRQUFNLElBQUkvQyxRQUFNLFFBQVEsS0FBSSxFQUFHLFFBQVEsVUFBVSxFQUFFLEdBQUcsT0FBTztBQUM3RCxTQUFPLElBQUksRUFBRSxVQUFVO0FBQ3pCO0FBQ0EsSUFBQSxVQUFpQitDO0FDTGpCLE1BQU1ELFdBQVM1TTtBQUVmLE1BQU04TSxRQUFNLENBQUMsU0FBUyxTQUFTLFNBQVMsWUFBWSxtQkFBbUI7QUFDckUsTUFBSSxPQUFRLFlBQWEsVUFBVTtBQUNqQyxxQkFBaUI7QUFDakIsaUJBQWE7QUFDYixjQUFVO0FBQUEsRUFDWDtBQUVELE1BQUk7QUFDRixXQUFPLElBQUlGO0FBQUFBLE1BQ1QsbUJBQW1CQSxXQUFTLFFBQVEsVUFBVTtBQUFBLE1BQzlDO0FBQUEsSUFDRCxFQUFDLElBQUksU0FBUyxZQUFZLGNBQWMsRUFBRTtBQUFBLEVBQzVDLFNBQVEsSUFBSTtBQUNYLFdBQU87QUFBQSxFQUNSO0FBQ0g7QUFDQSxJQUFBLFFBQWlCRTtBQ2xCakIsTUFBTWhELFVBQVE5SjtBQUVkLE1BQU0rTSxTQUFPLENBQUMsVUFBVSxhQUFhO0FBQ25DLFFBQU0sS0FBS2pELFFBQU0sVUFBVSxNQUFNLElBQUk7QUFDckMsUUFBTSxLQUFLQSxRQUFNLFVBQVUsTUFBTSxJQUFJO0FBQ3JDLFFBQU0sYUFBYSxHQUFHLFFBQVEsRUFBRTtBQUVoQyxNQUFJLGVBQWUsR0FBRztBQUNwQixXQUFPO0FBQUEsRUFDUjtBQUVELFFBQU0sV0FBVyxhQUFhO0FBQzlCLFFBQU0sY0FBYyxXQUFXLEtBQUs7QUFDcEMsUUFBTSxhQUFhLFdBQVcsS0FBSztBQUNuQyxRQUFNLGFBQWEsQ0FBQyxDQUFDLFlBQVksV0FBVztBQUM1QyxRQUFNLFlBQVksQ0FBQyxDQUFDLFdBQVcsV0FBVztBQUUxQyxNQUFJLGFBQWEsQ0FBQyxZQUFZO0FBUTVCLFFBQUksQ0FBQyxXQUFXLFNBQVMsQ0FBQyxXQUFXLE9BQU87QUFDMUMsYUFBTztBQUFBLElBQ1I7QUFJRCxRQUFJLFlBQVksT0FBTztBQUVyQixhQUFPO0FBQUEsSUFDUjtBQUVELFFBQUksWUFBWSxPQUFPO0FBRXJCLGFBQU87QUFBQSxJQUNSO0FBR0QsV0FBTztBQUFBLEVBQ1I7QUFHRCxRQUFNLFNBQVMsYUFBYSxRQUFRO0FBRXBDLE1BQUksR0FBRyxVQUFVLEdBQUcsT0FBTztBQUN6QixXQUFPLFNBQVM7QUFBQSxFQUNqQjtBQUVELE1BQUksR0FBRyxVQUFVLEdBQUcsT0FBTztBQUN6QixXQUFPLFNBQVM7QUFBQSxFQUNqQjtBQUVELE1BQUksR0FBRyxVQUFVLEdBQUcsT0FBTztBQUN6QixXQUFPLFNBQVM7QUFBQSxFQUNqQjtBQUdELFNBQU87QUFDVDtBQUVBLElBQUEsU0FBaUJpRDtBQ2hFakIsTUFBTUgsV0FBUzVNO0FBQ2YsTUFBTWdOLFVBQVEsQ0FBQyxHQUFHLFVBQVUsSUFBSUosU0FBTyxHQUFHLEtBQUssRUFBRTtBQUNqRCxJQUFBLFVBQWlCSTtBQ0ZqQixNQUFNSixXQUFTNU07QUFDZixNQUFNaU4sVUFBUSxDQUFDLEdBQUcsVUFBVSxJQUFJTCxTQUFPLEdBQUcsS0FBSyxFQUFFO0FBQ2pELElBQUEsVUFBaUJLO0FDRmpCLE1BQU1MLFdBQVM1TTtBQUNmLE1BQU1JLFVBQVEsQ0FBQyxHQUFHLFVBQVUsSUFBSXdNLFNBQU8sR0FBRyxLQUFLLEVBQUU7QUFDakQsSUFBQSxVQUFpQnhNO0FDRmpCLE1BQU0wSixVQUFROUo7QUFDZCxNQUFNME0sZUFBYSxDQUFDLFNBQVMsWUFBWTtBQUN2QyxRQUFNLFNBQVM1QyxRQUFNLFNBQVMsT0FBTztBQUNyQyxTQUFRLFVBQVUsT0FBTyxXQUFXLFNBQVUsT0FBTyxhQUFhO0FBQ3BFO0FBQ0EsSUFBQSxlQUFpQjRDO0FDTGpCLE1BQU1FLFdBQVM1TTtBQUNmLE1BQU00TCxZQUFVLENBQUMsR0FBRyxHQUFHLFVBQ3JCLElBQUlnQixTQUFPLEdBQUcsS0FBSyxFQUFFLFFBQVEsSUFBSUEsU0FBTyxHQUFHLEtBQUssQ0FBQztBQUVuRCxJQUFBLFlBQWlCaEI7QUNKakIsTUFBTUEsWUFBVTVMO0FBQ2hCLE1BQU1rTixhQUFXLENBQUMsR0FBRyxHQUFHLFVBQVV0QixVQUFRLEdBQUcsR0FBRyxLQUFLO0FBQ3JELElBQUEsYUFBaUJzQjtBQ0ZqQixNQUFNdEIsWUFBVTVMO0FBQ2hCLE1BQU1tTixpQkFBZSxDQUFDLEdBQUcsTUFBTXZCLFVBQVEsR0FBRyxHQUFHLElBQUk7QUFDakQsSUFBQSxpQkFBaUJ1QjtBQ0ZqQixNQUFNUCxXQUFTNU07QUFDZixNQUFNb04saUJBQWUsQ0FBQyxHQUFHLEdBQUcsVUFBVTtBQUNwQyxRQUFNLFdBQVcsSUFBSVIsU0FBTyxHQUFHLEtBQUs7QUFDcEMsUUFBTSxXQUFXLElBQUlBLFNBQU8sR0FBRyxLQUFLO0FBQ3BDLFNBQU8sU0FBUyxRQUFRLFFBQVEsS0FBSyxTQUFTLGFBQWEsUUFBUTtBQUNyRTtBQUNBLElBQUEsaUJBQWlCUTtBQ05qQixNQUFNQSxpQkFBZXBOO0FBQ3JCLE1BQU1xTixTQUFPLENBQUMsTUFBTSxVQUFVLEtBQUssS0FBSyxDQUFDLEdBQUcsTUFBTUQsZUFBYSxHQUFHLEdBQUcsS0FBSyxDQUFDO0FBQzNFLElBQUEsU0FBaUJDO0FDRmpCLE1BQU1ELGlCQUFlcE47QUFDckIsTUFBTXNOLFVBQVEsQ0FBQyxNQUFNLFVBQVUsS0FBSyxLQUFLLENBQUMsR0FBRyxNQUFNRixlQUFhLEdBQUcsR0FBRyxLQUFLLENBQUM7QUFDNUUsSUFBQSxVQUFpQkU7QUNGakIsTUFBTTFCLFlBQVU1TDtBQUNoQixNQUFNdU4sT0FBSyxDQUFDLEdBQUcsR0FBRyxVQUFVM0IsVUFBUSxHQUFHLEdBQUcsS0FBSyxJQUFJO0FBQ25ELElBQUEsT0FBaUIyQjtBQ0ZqQixNQUFNM0IsWUFBVTVMO0FBQ2hCLE1BQU13TixPQUFLLENBQUMsR0FBRyxHQUFHLFVBQVU1QixVQUFRLEdBQUcsR0FBRyxLQUFLLElBQUk7QUFDbkQsSUFBQSxPQUFpQjRCO0FDRmpCLE1BQU01QixZQUFVNUw7QUFDaEIsTUFBTXlOLE9BQUssQ0FBQyxHQUFHLEdBQUcsVUFBVTdCLFVBQVEsR0FBRyxHQUFHLEtBQUssTUFBTTtBQUNyRCxJQUFBLE9BQWlCNkI7QUNGakIsTUFBTTdCLFlBQVU1TDtBQUNoQixNQUFNME4sUUFBTSxDQUFDLEdBQUcsR0FBRyxVQUFVOUIsVUFBUSxHQUFHLEdBQUcsS0FBSyxNQUFNO0FBQ3RELElBQUEsUUFBaUI4QjtBQ0ZqQixNQUFNOUIsWUFBVTVMO0FBQ2hCLE1BQU0yTixRQUFNLENBQUMsR0FBRyxHQUFHLFVBQVUvQixVQUFRLEdBQUcsR0FBRyxLQUFLLEtBQUs7QUFDckQsSUFBQSxRQUFpQitCO0FDRmpCLE1BQU0vQixZQUFVNUw7QUFDaEIsTUFBTTROLFFBQU0sQ0FBQyxHQUFHLEdBQUcsVUFBVWhDLFVBQVEsR0FBRyxHQUFHLEtBQUssS0FBSztBQUNyRCxJQUFBLFFBQWlCZ0M7QUNGakIsTUFBTUgsT0FBS3pOO0FBQ1gsTUFBTTBOLFFBQU1uTztBQUNaLE1BQU1nTyxPQUFLL047QUFDWCxNQUFNbU8sUUFBTTNNO0FBQ1osTUFBTXdNLE9BQUszSztBQUNYLE1BQU0rSyxRQUFNOUs7QUFFWixNQUFNK0ssUUFBTSxDQUFDLEdBQUcsSUFBSSxHQUFHLFVBQVU7QUFDL0IsVUFBUSxJQUFFO0FBQUEsSUFDUixLQUFLO0FBQ0gsVUFBSSxPQUFPLE1BQU0sVUFBVTtBQUN6QixZQUFJLEVBQUU7QUFBQSxNQUNQO0FBQ0QsVUFBSSxPQUFPLE1BQU0sVUFBVTtBQUN6QixZQUFJLEVBQUU7QUFBQSxNQUNQO0FBQ0QsYUFBTyxNQUFNO0FBQUEsSUFFZixLQUFLO0FBQ0gsVUFBSSxPQUFPLE1BQU0sVUFBVTtBQUN6QixZQUFJLEVBQUU7QUFBQSxNQUNQO0FBQ0QsVUFBSSxPQUFPLE1BQU0sVUFBVTtBQUN6QixZQUFJLEVBQUU7QUFBQSxNQUNQO0FBQ0QsYUFBTyxNQUFNO0FBQUEsSUFFZixLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQ0gsYUFBT0osS0FBRyxHQUFHLEdBQUcsS0FBSztBQUFBLElBRXZCLEtBQUs7QUFDSCxhQUFPQyxNQUFJLEdBQUcsR0FBRyxLQUFLO0FBQUEsSUFFeEIsS0FBSztBQUNILGFBQU9ILEtBQUcsR0FBRyxHQUFHLEtBQUs7QUFBQSxJQUV2QixLQUFLO0FBQ0gsYUFBT0ksTUFBSSxHQUFHLEdBQUcsS0FBSztBQUFBLElBRXhCLEtBQUs7QUFDSCxhQUFPSCxLQUFHLEdBQUcsR0FBRyxLQUFLO0FBQUEsSUFFdkIsS0FBSztBQUNILGFBQU9JLE1BQUksR0FBRyxHQUFHLEtBQUs7QUFBQSxJQUV4QjtBQUNFLFlBQU0sSUFBSSxVQUFVLHFCQUFxQixFQUFFLEVBQUU7QUFBQSxFQUNoRDtBQUNIO0FBQ0EsSUFBQSxRQUFpQkM7QUNuRGpCLE1BQU1qQixXQUFTNU07QUFDZixNQUFNOEosVUFBUXZLO0FBQ2QsTUFBTSxFQUFFLFFBQVEsSUFBSSxFQUFDLElBQUtDO0FBRTFCLE1BQU1zTyxXQUFTLENBQUMsU0FBUyxZQUFZO0FBQ25DLE1BQUksbUJBQW1CbEIsVUFBUTtBQUM3QixXQUFPO0FBQUEsRUFDUjtBQUVELE1BQUksT0FBTyxZQUFZLFVBQVU7QUFDL0IsY0FBVSxPQUFPLE9BQU87QUFBQSxFQUN6QjtBQUVELE1BQUksT0FBTyxZQUFZLFVBQVU7QUFDL0IsV0FBTztBQUFBLEVBQ1I7QUFFRCxZQUFVLFdBQVcsQ0FBRTtBQUV2QixNQUFJLFFBQVE7QUFDWixNQUFJLENBQUMsUUFBUSxLQUFLO0FBQ2hCLFlBQVEsUUFBUSxNQUFNLEdBQUcsRUFBRSxNQUFNLENBQUM7QUFBQSxFQUN0QyxPQUFTO0FBU0wsUUFBSTtBQUNKLFlBQVEsT0FBTyxHQUFHLEVBQUUsU0FBUyxFQUFFLEtBQUssT0FBTyxPQUN0QyxDQUFDLFNBQVMsTUFBTSxRQUFRLE1BQU0sQ0FBQyxFQUFFLFdBQVcsUUFBUSxTQUN2RDtBQUNBLFVBQUksQ0FBQyxTQUNDLEtBQUssUUFBUSxLQUFLLENBQUMsRUFBRSxXQUFXLE1BQU0sUUFBUSxNQUFNLENBQUMsRUFBRSxRQUFRO0FBQ25FLGdCQUFRO0FBQUEsTUFDVDtBQUNELFNBQUcsRUFBRSxTQUFTLEVBQUUsWUFBWSxLQUFLLFFBQVEsS0FBSyxDQUFDLEVBQUUsU0FBUyxLQUFLLENBQUMsRUFBRTtBQUFBLElBQ25FO0FBRUQsT0FBRyxFQUFFLFNBQVMsRUFBRSxZQUFZO0FBQUEsRUFDN0I7QUFFRCxNQUFJLFVBQVUsTUFBTTtBQUNsQixXQUFPO0FBQUEsRUFDUjtBQUVELFNBQU85QyxRQUFNLEdBQUcsTUFBTSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsS0FBSyxHQUFHLElBQUksTUFBTSxDQUFDLEtBQUssR0FBRyxJQUFJLE9BQU87QUFDM0U7QUFDQSxJQUFBLFdBQWlCZ0U7Ozs7Ozs7QUNsREgsYUFBRyxTQUFVQyxVQUFTO0FBQ2xDLElBQUFBLFNBQVEsVUFBVSxPQUFPLFFBQVEsSUFBSSxhQUFhO0FBQ2hELGVBQVMsU0FBUyxLQUFLLE1BQU0sUUFBUSxTQUFTLE9BQU8sTUFBTTtBQUN6RCxjQUFNLE9BQU87QUFBQSxNQUNkO0FBQUEsSUFDRjtBQUFBLEVBQ0g7OztBQ05BLElBQUEsVUFBaUJBO0FBRWpCQSxVQUFRLE9BQU87QUFDZkEsVUFBUSxTQUFTQTtBQUVqQixTQUFTQSxVQUFTLE1BQU07QUFDdEIsTUFBSWxOLFFBQU87QUFDWCxNQUFJLEVBQUVBLGlCQUFnQmtOLFlBQVU7QUFDOUIsSUFBQWxOLFFBQU8sSUFBSWtOLFVBQVM7QUFBQSxFQUNyQjtBQUVELEVBQUFsTixNQUFLLE9BQU87QUFDWixFQUFBQSxNQUFLLE9BQU87QUFDWixFQUFBQSxNQUFLLFNBQVM7QUFFZCxNQUFJLFFBQVEsT0FBTyxLQUFLLFlBQVksWUFBWTtBQUM5QyxTQUFLLFFBQVEsU0FBVSxNQUFNO0FBQzNCLE1BQUFBLE1BQUssS0FBSyxJQUFJO0FBQUEsSUFDcEIsQ0FBSztBQUFBLEVBQ0wsV0FBYSxVQUFVLFNBQVMsR0FBRztBQUMvQixhQUFTLElBQUksR0FBRyxJQUFJLFVBQVUsUUFBUSxJQUFJLEdBQUcsS0FBSztBQUNoRCxNQUFBQSxNQUFLLEtBQUssVUFBVSxDQUFDLENBQUM7QUFBQSxJQUN2QjtBQUFBLEVBQ0Y7QUFFRCxTQUFPQTtBQUNUO0FBRUFrTixVQUFRLFVBQVUsYUFBYSxTQUFVLE1BQU07QUFDN0MsTUFBSSxLQUFLLFNBQVMsTUFBTTtBQUN0QixVQUFNLElBQUksTUFBTSxrREFBa0Q7QUFBQSxFQUNuRTtBQUVELE1BQUksT0FBTyxLQUFLO0FBQ2hCLE1BQUksT0FBTyxLQUFLO0FBRWhCLE1BQUksTUFBTTtBQUNSLFNBQUssT0FBTztBQUFBLEVBQ2I7QUFFRCxNQUFJLE1BQU07QUFDUixTQUFLLE9BQU87QUFBQSxFQUNiO0FBRUQsTUFBSSxTQUFTLEtBQUssTUFBTTtBQUN0QixTQUFLLE9BQU87QUFBQSxFQUNiO0FBQ0QsTUFBSSxTQUFTLEtBQUssTUFBTTtBQUN0QixTQUFLLE9BQU87QUFBQSxFQUNiO0FBRUQsT0FBSyxLQUFLO0FBQ1YsT0FBSyxPQUFPO0FBQ1osT0FBSyxPQUFPO0FBQ1osT0FBSyxPQUFPO0FBRVosU0FBTztBQUNUO0FBRUFBLFVBQVEsVUFBVSxjQUFjLFNBQVUsTUFBTTtBQUM5QyxNQUFJLFNBQVMsS0FBSyxNQUFNO0FBQ3RCO0FBQUEsRUFDRDtBQUVELE1BQUksS0FBSyxNQUFNO0FBQ2IsU0FBSyxLQUFLLFdBQVcsSUFBSTtBQUFBLEVBQzFCO0FBRUQsTUFBSSxPQUFPLEtBQUs7QUFDaEIsT0FBSyxPQUFPO0FBQ1osT0FBSyxPQUFPO0FBQ1osTUFBSSxNQUFNO0FBQ1IsU0FBSyxPQUFPO0FBQUEsRUFDYjtBQUVELE9BQUssT0FBTztBQUNaLE1BQUksQ0FBQyxLQUFLLE1BQU07QUFDZCxTQUFLLE9BQU87QUFBQSxFQUNiO0FBQ0QsT0FBSztBQUNQO0FBRUFBLFVBQVEsVUFBVSxXQUFXLFNBQVUsTUFBTTtBQUMzQyxNQUFJLFNBQVMsS0FBSyxNQUFNO0FBQ3RCO0FBQUEsRUFDRDtBQUVELE1BQUksS0FBSyxNQUFNO0FBQ2IsU0FBSyxLQUFLLFdBQVcsSUFBSTtBQUFBLEVBQzFCO0FBRUQsTUFBSSxPQUFPLEtBQUs7QUFDaEIsT0FBSyxPQUFPO0FBQ1osT0FBSyxPQUFPO0FBQ1osTUFBSSxNQUFNO0FBQ1IsU0FBSyxPQUFPO0FBQUEsRUFDYjtBQUVELE9BQUssT0FBTztBQUNaLE1BQUksQ0FBQyxLQUFLLE1BQU07QUFDZCxTQUFLLE9BQU87QUFBQSxFQUNiO0FBQ0QsT0FBSztBQUNQO0FBRUFBLFVBQVEsVUFBVSxPQUFPLFdBQVk7QUFDbkMsV0FBUyxJQUFJLEdBQUcsSUFBSSxVQUFVLFFBQVEsSUFBSSxHQUFHLEtBQUs7QUFDaEQsU0FBSyxNQUFNLFVBQVUsQ0FBQyxDQUFDO0FBQUEsRUFDeEI7QUFDRCxTQUFPLEtBQUs7QUFDZDtBQUVBQSxVQUFRLFVBQVUsVUFBVSxXQUFZO0FBQ3RDLFdBQVMsSUFBSSxHQUFHLElBQUksVUFBVSxRQUFRLElBQUksR0FBRyxLQUFLO0FBQ2hELFlBQVEsTUFBTSxVQUFVLENBQUMsQ0FBQztBQUFBLEVBQzNCO0FBQ0QsU0FBTyxLQUFLO0FBQ2Q7QUFFQUEsVUFBUSxVQUFVLE1BQU0sV0FBWTtBQUNsQyxNQUFJLENBQUMsS0FBSyxNQUFNO0FBQ2QsV0FBTztBQUFBLEVBQ1I7QUFFRCxNQUFJLE1BQU0sS0FBSyxLQUFLO0FBQ3BCLE9BQUssT0FBTyxLQUFLLEtBQUs7QUFDdEIsTUFBSSxLQUFLLE1BQU07QUFDYixTQUFLLEtBQUssT0FBTztBQUFBLEVBQ3JCLE9BQVM7QUFDTCxTQUFLLE9BQU87QUFBQSxFQUNiO0FBQ0QsT0FBSztBQUNMLFNBQU87QUFDVDtBQUVBQSxVQUFRLFVBQVUsUUFBUSxXQUFZO0FBQ3BDLE1BQUksQ0FBQyxLQUFLLE1BQU07QUFDZCxXQUFPO0FBQUEsRUFDUjtBQUVELE1BQUksTUFBTSxLQUFLLEtBQUs7QUFDcEIsT0FBSyxPQUFPLEtBQUssS0FBSztBQUN0QixNQUFJLEtBQUssTUFBTTtBQUNiLFNBQUssS0FBSyxPQUFPO0FBQUEsRUFDckIsT0FBUztBQUNMLFNBQUssT0FBTztBQUFBLEVBQ2I7QUFDRCxPQUFLO0FBQ0wsU0FBTztBQUNUO0FBRUFBLFVBQVEsVUFBVSxVQUFVLFNBQVUsSUFBSSxPQUFPO0FBQy9DLFVBQVEsU0FBUztBQUNqQixXQUFTLFNBQVMsS0FBSyxNQUFNLElBQUksR0FBRyxXQUFXLE1BQU0sS0FBSztBQUN4RCxPQUFHLEtBQUssT0FBTyxPQUFPLE9BQU8sR0FBRyxJQUFJO0FBQ3BDLGFBQVMsT0FBTztBQUFBLEVBQ2pCO0FBQ0g7QUFFQUEsVUFBUSxVQUFVLGlCQUFpQixTQUFVLElBQUksT0FBTztBQUN0RCxVQUFRLFNBQVM7QUFDakIsV0FBUyxTQUFTLEtBQUssTUFBTSxJQUFJLEtBQUssU0FBUyxHQUFHLFdBQVcsTUFBTSxLQUFLO0FBQ3RFLE9BQUcsS0FBSyxPQUFPLE9BQU8sT0FBTyxHQUFHLElBQUk7QUFDcEMsYUFBUyxPQUFPO0FBQUEsRUFDakI7QUFDSDtBQUVBQSxVQUFRLFVBQVUsTUFBTSxTQUFVLEdBQUc7QUFDbkMsV0FBUyxJQUFJLEdBQUcsU0FBUyxLQUFLLE1BQU0sV0FBVyxRQUFRLElBQUksR0FBRyxLQUFLO0FBRWpFLGFBQVMsT0FBTztBQUFBLEVBQ2pCO0FBQ0QsTUFBSSxNQUFNLEtBQUssV0FBVyxNQUFNO0FBQzlCLFdBQU8sT0FBTztBQUFBLEVBQ2Y7QUFDSDtBQUVBQSxVQUFRLFVBQVUsYUFBYSxTQUFVLEdBQUc7QUFDMUMsV0FBUyxJQUFJLEdBQUcsU0FBUyxLQUFLLE1BQU0sV0FBVyxRQUFRLElBQUksR0FBRyxLQUFLO0FBRWpFLGFBQVMsT0FBTztBQUFBLEVBQ2pCO0FBQ0QsTUFBSSxNQUFNLEtBQUssV0FBVyxNQUFNO0FBQzlCLFdBQU8sT0FBTztBQUFBLEVBQ2Y7QUFDSDtBQUVBQSxVQUFRLFVBQVUsTUFBTSxTQUFVLElBQUksT0FBTztBQUMzQyxVQUFRLFNBQVM7QUFDakIsTUFBSSxNQUFNLElBQUlBLFVBQVM7QUFDdkIsV0FBUyxTQUFTLEtBQUssTUFBTSxXQUFXLFFBQU87QUFDN0MsUUFBSSxLQUFLLEdBQUcsS0FBSyxPQUFPLE9BQU8sT0FBTyxJQUFJLENBQUM7QUFDM0MsYUFBUyxPQUFPO0FBQUEsRUFDakI7QUFDRCxTQUFPO0FBQ1Q7QUFFQUEsVUFBUSxVQUFVLGFBQWEsU0FBVSxJQUFJLE9BQU87QUFDbEQsVUFBUSxTQUFTO0FBQ2pCLE1BQUksTUFBTSxJQUFJQSxVQUFTO0FBQ3ZCLFdBQVMsU0FBUyxLQUFLLE1BQU0sV0FBVyxRQUFPO0FBQzdDLFFBQUksS0FBSyxHQUFHLEtBQUssT0FBTyxPQUFPLE9BQU8sSUFBSSxDQUFDO0FBQzNDLGFBQVMsT0FBTztBQUFBLEVBQ2pCO0FBQ0QsU0FBTztBQUNUO0FBRUFBLFVBQVEsVUFBVSxTQUFTLFNBQVUsSUFBSSxTQUFTO0FBQ2hELE1BQUk7QUFDSixNQUFJLFNBQVMsS0FBSztBQUNsQixNQUFJLFVBQVUsU0FBUyxHQUFHO0FBQ3hCLFVBQU07QUFBQSxFQUNWLFdBQWEsS0FBSyxNQUFNO0FBQ3BCLGFBQVMsS0FBSyxLQUFLO0FBQ25CLFVBQU0sS0FBSyxLQUFLO0FBQUEsRUFDcEIsT0FBUztBQUNMLFVBQU0sSUFBSSxVQUFVLDRDQUE0QztBQUFBLEVBQ2pFO0FBRUQsV0FBUyxJQUFJLEdBQUcsV0FBVyxNQUFNLEtBQUs7QUFDcEMsVUFBTSxHQUFHLEtBQUssT0FBTyxPQUFPLENBQUM7QUFDN0IsYUFBUyxPQUFPO0FBQUEsRUFDakI7QUFFRCxTQUFPO0FBQ1Q7QUFFQUEsVUFBUSxVQUFVLGdCQUFnQixTQUFVLElBQUksU0FBUztBQUN2RCxNQUFJO0FBQ0osTUFBSSxTQUFTLEtBQUs7QUFDbEIsTUFBSSxVQUFVLFNBQVMsR0FBRztBQUN4QixVQUFNO0FBQUEsRUFDVixXQUFhLEtBQUssTUFBTTtBQUNwQixhQUFTLEtBQUssS0FBSztBQUNuQixVQUFNLEtBQUssS0FBSztBQUFBLEVBQ3BCLE9BQVM7QUFDTCxVQUFNLElBQUksVUFBVSw0Q0FBNEM7QUFBQSxFQUNqRTtBQUVELFdBQVMsSUFBSSxLQUFLLFNBQVMsR0FBRyxXQUFXLE1BQU0sS0FBSztBQUNsRCxVQUFNLEdBQUcsS0FBSyxPQUFPLE9BQU8sQ0FBQztBQUM3QixhQUFTLE9BQU87QUFBQSxFQUNqQjtBQUVELFNBQU87QUFDVDtBQUVBQSxVQUFRLFVBQVUsVUFBVSxXQUFZO0FBQ3RDLE1BQUksTUFBTSxJQUFJLE1BQU0sS0FBSyxNQUFNO0FBQy9CLFdBQVMsSUFBSSxHQUFHLFNBQVMsS0FBSyxNQUFNLFdBQVcsTUFBTSxLQUFLO0FBQ3hELFFBQUksQ0FBQyxJQUFJLE9BQU87QUFDaEIsYUFBUyxPQUFPO0FBQUEsRUFDakI7QUFDRCxTQUFPO0FBQ1Q7QUFFQUEsVUFBUSxVQUFVLGlCQUFpQixXQUFZO0FBQzdDLE1BQUksTUFBTSxJQUFJLE1BQU0sS0FBSyxNQUFNO0FBQy9CLFdBQVMsSUFBSSxHQUFHLFNBQVMsS0FBSyxNQUFNLFdBQVcsTUFBTSxLQUFLO0FBQ3hELFFBQUksQ0FBQyxJQUFJLE9BQU87QUFDaEIsYUFBUyxPQUFPO0FBQUEsRUFDakI7QUFDRCxTQUFPO0FBQ1Q7QUFFQUEsVUFBUSxVQUFVLFFBQVEsU0FBVSxNQUFNLElBQUk7QUFDNUMsT0FBSyxNQUFNLEtBQUs7QUFDaEIsTUFBSSxLQUFLLEdBQUc7QUFDVixVQUFNLEtBQUs7QUFBQSxFQUNaO0FBQ0QsU0FBTyxRQUFRO0FBQ2YsTUFBSSxPQUFPLEdBQUc7QUFDWixZQUFRLEtBQUs7QUFBQSxFQUNkO0FBQ0QsTUFBSSxNQUFNLElBQUlBLFVBQVM7QUFDdkIsTUFBSSxLQUFLLFFBQVEsS0FBSyxHQUFHO0FBQ3ZCLFdBQU87QUFBQSxFQUNSO0FBQ0QsTUFBSSxPQUFPLEdBQUc7QUFDWixXQUFPO0FBQUEsRUFDUjtBQUNELE1BQUksS0FBSyxLQUFLLFFBQVE7QUFDcEIsU0FBSyxLQUFLO0FBQUEsRUFDWDtBQUNELFdBQVMsSUFBSSxHQUFHLFNBQVMsS0FBSyxNQUFNLFdBQVcsUUFBUSxJQUFJLE1BQU0sS0FBSztBQUNwRSxhQUFTLE9BQU87QUFBQSxFQUNqQjtBQUNELFNBQU8sV0FBVyxRQUFRLElBQUksSUFBSSxLQUFLLFNBQVMsT0FBTyxNQUFNO0FBQzNELFFBQUksS0FBSyxPQUFPLEtBQUs7QUFBQSxFQUN0QjtBQUNELFNBQU87QUFDVDtBQUVBQSxVQUFRLFVBQVUsZUFBZSxTQUFVLE1BQU0sSUFBSTtBQUNuRCxPQUFLLE1BQU0sS0FBSztBQUNoQixNQUFJLEtBQUssR0FBRztBQUNWLFVBQU0sS0FBSztBQUFBLEVBQ1o7QUFDRCxTQUFPLFFBQVE7QUFDZixNQUFJLE9BQU8sR0FBRztBQUNaLFlBQVEsS0FBSztBQUFBLEVBQ2Q7QUFDRCxNQUFJLE1BQU0sSUFBSUEsVUFBUztBQUN2QixNQUFJLEtBQUssUUFBUSxLQUFLLEdBQUc7QUFDdkIsV0FBTztBQUFBLEVBQ1I7QUFDRCxNQUFJLE9BQU8sR0FBRztBQUNaLFdBQU87QUFBQSxFQUNSO0FBQ0QsTUFBSSxLQUFLLEtBQUssUUFBUTtBQUNwQixTQUFLLEtBQUs7QUFBQSxFQUNYO0FBQ0QsV0FBUyxJQUFJLEtBQUssUUFBUSxTQUFTLEtBQUssTUFBTSxXQUFXLFFBQVEsSUFBSSxJQUFJLEtBQUs7QUFDNUUsYUFBUyxPQUFPO0FBQUEsRUFDakI7QUFDRCxTQUFPLFdBQVcsUUFBUSxJQUFJLE1BQU0sS0FBSyxTQUFTLE9BQU8sTUFBTTtBQUM3RCxRQUFJLEtBQUssT0FBTyxLQUFLO0FBQUEsRUFDdEI7QUFDRCxTQUFPO0FBQ1Q7QUFFQUEsVUFBUSxVQUFVLFNBQVMsU0FBVSxPQUFPLGdCQUFnQixPQUFPO0FBQ2pFLE1BQUksUUFBUSxLQUFLLFFBQVE7QUFDdkIsWUFBUSxLQUFLLFNBQVM7QUFBQSxFQUN2QjtBQUNELE1BQUksUUFBUSxHQUFHO0FBQ2IsWUFBUSxLQUFLLFNBQVM7QUFBQSxFQUN2QjtBQUVELFdBQVMsSUFBSSxHQUFHLFNBQVMsS0FBSyxNQUFNLFdBQVcsUUFBUSxJQUFJLE9BQU8sS0FBSztBQUNyRSxhQUFTLE9BQU87QUFBQSxFQUNqQjtBQUVELE1BQUksTUFBTSxDQUFFO0FBQ1osV0FBUyxJQUFJLEdBQUcsVUFBVSxJQUFJLGFBQWEsS0FBSztBQUM5QyxRQUFJLEtBQUssT0FBTyxLQUFLO0FBQ3JCLGFBQVMsS0FBSyxXQUFXLE1BQU07QUFBQSxFQUNoQztBQUNELE1BQUksV0FBVyxNQUFNO0FBQ25CLGFBQVMsS0FBSztBQUFBLEVBQ2Y7QUFFRCxNQUFJLFdBQVcsS0FBSyxRQUFRLFdBQVcsS0FBSyxNQUFNO0FBQ2hELGFBQVMsT0FBTztBQUFBLEVBQ2pCO0FBRUQsV0FBUyxJQUFJLEdBQUcsSUFBSSxNQUFNLFFBQVEsS0FBSztBQUNyQyxhQUFTLE9BQU8sTUFBTSxRQUFRLE1BQU0sQ0FBQyxDQUFDO0FBQUEsRUFDdkM7QUFDRCxTQUFPO0FBQ1Q7QUFFQUEsVUFBUSxVQUFVLFVBQVUsV0FBWTtBQUN0QyxNQUFJLE9BQU8sS0FBSztBQUNoQixNQUFJLE9BQU8sS0FBSztBQUNoQixXQUFTLFNBQVMsTUFBTSxXQUFXLE1BQU0sU0FBUyxPQUFPLE1BQU07QUFDN0QsUUFBSSxJQUFJLE9BQU87QUFDZixXQUFPLE9BQU8sT0FBTztBQUNyQixXQUFPLE9BQU87QUFBQSxFQUNmO0FBQ0QsT0FBSyxPQUFPO0FBQ1osT0FBSyxPQUFPO0FBQ1osU0FBTztBQUNUO0FBRUEsU0FBUyxPQUFRbE4sT0FBTSxNQUFNLE9BQU87QUFDbEMsTUFBSSxXQUFXLFNBQVNBLE1BQUssT0FDM0IsSUFBSSxLQUFLLE9BQU8sTUFBTSxNQUFNQSxLQUFJLElBQ2hDLElBQUksS0FBSyxPQUFPLE1BQU0sS0FBSyxNQUFNQSxLQUFJO0FBRXZDLE1BQUksU0FBUyxTQUFTLE1BQU07QUFDMUIsSUFBQUEsTUFBSyxPQUFPO0FBQUEsRUFDYjtBQUNELE1BQUksU0FBUyxTQUFTLE1BQU07QUFDMUIsSUFBQUEsTUFBSyxPQUFPO0FBQUEsRUFDYjtBQUVELEVBQUFBLE1BQUs7QUFFTCxTQUFPO0FBQ1Q7QUFFQSxTQUFTLEtBQU1BLE9BQU0sTUFBTTtBQUN6QixFQUFBQSxNQUFLLE9BQU8sSUFBSSxLQUFLLE1BQU1BLE1BQUssTUFBTSxNQUFNQSxLQUFJO0FBQ2hELE1BQUksQ0FBQ0EsTUFBSyxNQUFNO0FBQ2QsSUFBQUEsTUFBSyxPQUFPQSxNQUFLO0FBQUEsRUFDbEI7QUFDRCxFQUFBQSxNQUFLO0FBQ1A7QUFFQSxTQUFTLFFBQVNBLE9BQU0sTUFBTTtBQUM1QixFQUFBQSxNQUFLLE9BQU8sSUFBSSxLQUFLLE1BQU0sTUFBTUEsTUFBSyxNQUFNQSxLQUFJO0FBQ2hELE1BQUksQ0FBQ0EsTUFBSyxNQUFNO0FBQ2QsSUFBQUEsTUFBSyxPQUFPQSxNQUFLO0FBQUEsRUFDbEI7QUFDRCxFQUFBQSxNQUFLO0FBQ1A7QUFFQSxTQUFTLEtBQU0sT0FBTyxNQUFNLE1BQU0sTUFBTTtBQUN0QyxNQUFJLEVBQUUsZ0JBQWdCLE9BQU87QUFDM0IsV0FBTyxJQUFJLEtBQUssT0FBTyxNQUFNLE1BQU0sSUFBSTtBQUFBLEVBQ3hDO0FBRUQsT0FBSyxPQUFPO0FBQ1osT0FBSyxRQUFRO0FBRWIsTUFBSSxNQUFNO0FBQ1IsU0FBSyxPQUFPO0FBQ1osU0FBSyxPQUFPO0FBQUEsRUFDaEIsT0FBUztBQUNMLFNBQUssT0FBTztBQUFBLEVBQ2I7QUFFRCxNQUFJLE1BQU07QUFDUixTQUFLLE9BQU87QUFDWixTQUFLLE9BQU87QUFBQSxFQUNoQixPQUFTO0FBQ0wsU0FBSyxPQUFPO0FBQUEsRUFDYjtBQUNIO0FBRUEsSUFBSTtBQUVGYixrQkFBQSxFQUF5QitOLFNBQU87QUFDbEMsU0FBUyxJQUFJO0FBQUE7QUN0YWIsTUFBTSxVQUFVL047QUFFaEIsTUFBTSxNQUFNLE9BQU8sS0FBSztBQUN4QixNQUFNLFNBQVMsT0FBTyxRQUFRO0FBQzlCLE1BQU0sb0JBQW9CLE9BQU8sa0JBQWtCO0FBQ25ELE1BQU0sY0FBYyxPQUFPLFlBQVk7QUFDdkMsTUFBTSxVQUFVLE9BQU8sUUFBUTtBQUMvQixNQUFNLFVBQVUsT0FBTyxTQUFTO0FBQ2hDLE1BQU0sb0JBQW9CLE9BQU8sZ0JBQWdCO0FBQ2pELE1BQU0sV0FBVyxPQUFPLFNBQVM7QUFDakMsTUFBTSxRQUFRLE9BQU8sT0FBTztBQUM1QixNQUFNLG9CQUFvQixPQUFPLGdCQUFnQjtBQUVqRCxNQUFNLGNBQWMsTUFBTTtBQVUxQixNQUFNLFNBQVM7QUFBQSxFQUNiLFlBQWEsU0FBUztBQUNwQixRQUFJLE9BQU8sWUFBWTtBQUNyQixnQkFBVSxFQUFFLEtBQUssUUFBUztBQUU1QixRQUFJLENBQUM7QUFDSCxnQkFBVSxDQUFFO0FBRWQsUUFBSSxRQUFRLFFBQVEsT0FBTyxRQUFRLFFBQVEsWUFBWSxRQUFRLE1BQU07QUFDbkUsWUFBTSxJQUFJLFVBQVUsbUNBQW1DO0FBRTdDLFNBQUssR0FBRyxJQUFJLFFBQVEsT0FBTztBQUV2QyxVQUFNLEtBQUssUUFBUSxVQUFVO0FBQzdCLFNBQUssaUJBQWlCLElBQUssT0FBTyxPQUFPLGFBQWMsY0FBYztBQUNyRSxTQUFLLFdBQVcsSUFBSSxRQUFRLFNBQVM7QUFDckMsUUFBSSxRQUFRLFVBQVUsT0FBTyxRQUFRLFdBQVc7QUFDOUMsWUFBTSxJQUFJLFVBQVUseUJBQXlCO0FBQy9DLFNBQUssT0FBTyxJQUFJLFFBQVEsVUFBVTtBQUNsQyxTQUFLLE9BQU8sSUFBSSxRQUFRO0FBQ3hCLFNBQUssaUJBQWlCLElBQUksUUFBUSxrQkFBa0I7QUFDcEQsU0FBSyxpQkFBaUIsSUFBSSxRQUFRLGtCQUFrQjtBQUNwRCxTQUFLLE1BQU87QUFBQSxFQUNiO0FBQUE7QUFBQSxFQUdELElBQUksSUFBSyxJQUFJO0FBQ1gsUUFBSSxPQUFPLE9BQU8sWUFBWSxLQUFLO0FBQ2pDLFlBQU0sSUFBSSxVQUFVLG1DQUFtQztBQUV6RCxTQUFLLEdBQUcsSUFBSSxNQUFNO0FBQ2xCLFNBQUssSUFBSTtBQUFBLEVBQ1Y7QUFBQSxFQUNELElBQUksTUFBTztBQUNULFdBQU8sS0FBSyxHQUFHO0FBQUEsRUFDaEI7QUFBQSxFQUVELElBQUksV0FBWSxZQUFZO0FBQzFCLFNBQUssV0FBVyxJQUFJLENBQUMsQ0FBQztBQUFBLEVBQ3ZCO0FBQUEsRUFDRCxJQUFJLGFBQWM7QUFDaEIsV0FBTyxLQUFLLFdBQVc7QUFBQSxFQUN4QjtBQUFBLEVBRUQsSUFBSSxPQUFRLElBQUk7QUFDZCxRQUFJLE9BQU8sT0FBTztBQUNoQixZQUFNLElBQUksVUFBVSxzQ0FBc0M7QUFFNUQsU0FBSyxPQUFPLElBQUk7QUFDaEIsU0FBSyxJQUFJO0FBQUEsRUFDVjtBQUFBLEVBQ0QsSUFBSSxTQUFVO0FBQ1osV0FBTyxLQUFLLE9BQU87QUFBQSxFQUNwQjtBQUFBO0FBQUEsRUFHRCxJQUFJLGlCQUFrQixJQUFJO0FBQ3hCLFFBQUksT0FBTyxPQUFPO0FBQ2hCLFdBQUs7QUFFUCxRQUFJLE9BQU8sS0FBSyxpQkFBaUIsR0FBRztBQUNsQyxXQUFLLGlCQUFpQixJQUFJO0FBQzFCLFdBQUssTUFBTSxJQUFJO0FBQ2YsV0FBSyxRQUFRLEVBQUUsUUFBUSxTQUFPO0FBQzVCLFlBQUksU0FBUyxLQUFLLGlCQUFpQixFQUFFLElBQUksT0FBTyxJQUFJLEdBQUc7QUFDdkQsYUFBSyxNQUFNLEtBQUssSUFBSTtBQUFBLE1BQzVCLENBQU87QUFBQSxJQUNGO0FBQ0QsU0FBSyxJQUFJO0FBQUEsRUFDVjtBQUFBLEVBQ0QsSUFBSSxtQkFBb0I7QUFBRSxXQUFPLEtBQUssaUJBQWlCO0FBQUEsRUFBRztBQUFBLEVBRTFELElBQUksU0FBVTtBQUFFLFdBQU8sS0FBSyxNQUFNO0FBQUEsRUFBRztBQUFBLEVBQ3JDLElBQUksWUFBYTtBQUFFLFdBQU8sS0FBSyxRQUFRLEVBQUU7QUFBQSxFQUFRO0FBQUEsRUFFakQsU0FBVSxJQUFJLE9BQU87QUFDbkIsWUFBUSxTQUFTO0FBQ2pCLGFBQVMsU0FBUyxLQUFLLFFBQVEsRUFBRSxNQUFNLFdBQVcsUUFBTztBQUN2RCxZQUFNLE9BQU8sT0FBTztBQUNwQixrQkFBWSxNQUFNLElBQUksUUFBUSxLQUFLO0FBQ25DLGVBQVM7QUFBQSxJQUNWO0FBQUEsRUFDRjtBQUFBLEVBRUQsUUFBUyxJQUFJLE9BQU87QUFDbEIsWUFBUSxTQUFTO0FBQ2pCLGFBQVMsU0FBUyxLQUFLLFFBQVEsRUFBRSxNQUFNLFdBQVcsUUFBTztBQUN2RCxZQUFNLE9BQU8sT0FBTztBQUNwQixrQkFBWSxNQUFNLElBQUksUUFBUSxLQUFLO0FBQ25DLGVBQVM7QUFBQSxJQUNWO0FBQUEsRUFDRjtBQUFBLEVBRUQsT0FBUTtBQUNOLFdBQU8sS0FBSyxRQUFRLEVBQUUsUUFBTyxFQUFHLElBQUksT0FBSyxFQUFFLEdBQUc7QUFBQSxFQUMvQztBQUFBLEVBRUQsU0FBVTtBQUNSLFdBQU8sS0FBSyxRQUFRLEVBQUUsUUFBTyxFQUFHLElBQUksT0FBSyxFQUFFLEtBQUs7QUFBQSxFQUNqRDtBQUFBLEVBRUQsUUFBUztBQUNQLFFBQUksS0FBSyxPQUFPLEtBQ1osS0FBSyxRQUFRLEtBQ2IsS0FBSyxRQUFRLEVBQUUsUUFBUTtBQUN6QixXQUFLLFFBQVEsRUFBRSxRQUFRLFNBQU8sS0FBSyxPQUFPLEVBQUUsSUFBSSxLQUFLLElBQUksS0FBSyxDQUFDO0FBQUEsSUFDaEU7QUFFRCxTQUFLLEtBQUssSUFBSSxvQkFBSSxJQUFLO0FBQ3ZCLFNBQUssUUFBUSxJQUFJLElBQUksUUFBUztBQUM5QixTQUFLLE1BQU0sSUFBSTtBQUFBLEVBQ2hCO0FBQUEsRUFFRCxPQUFRO0FBQ04sV0FBTyxLQUFLLFFBQVEsRUFBRSxJQUFJLFNBQ3hCLFFBQVEsTUFBTSxHQUFHLElBQUksUUFBUTtBQUFBLE1BQzNCLEdBQUcsSUFBSTtBQUFBLE1BQ1AsR0FBRyxJQUFJO0FBQUEsTUFDUCxHQUFHLElBQUksT0FBTyxJQUFJLFVBQVU7QUFBQSxJQUM3QixDQUFBLEVBQUUsUUFBUyxFQUFDLE9BQU8sT0FBSyxDQUFDO0FBQUEsRUFDN0I7QUFBQSxFQUVELFVBQVc7QUFDVCxXQUFPLEtBQUssUUFBUTtBQUFBLEVBQ3JCO0FBQUEsRUFFRCxJQUFLLEtBQUssT0FBTyxRQUFRO0FBQ3ZCLGFBQVMsVUFBVSxLQUFLLE9BQU87QUFFL0IsUUFBSSxVQUFVLE9BQU8sV0FBVztBQUM5QixZQUFNLElBQUksVUFBVSx5QkFBeUI7QUFFL0MsVUFBTSxNQUFNLFNBQVMsS0FBSyxJQUFLLElBQUc7QUFDbEMsVUFBTSxNQUFNLEtBQUssaUJBQWlCLEVBQUUsT0FBTyxHQUFHO0FBRTlDLFFBQUksS0FBSyxLQUFLLEVBQUUsSUFBSSxHQUFHLEdBQUc7QUFDeEIsVUFBSSxNQUFNLEtBQUssR0FBRyxHQUFHO0FBQ25CLFlBQUksTUFBTSxLQUFLLEtBQUssRUFBRSxJQUFJLEdBQUcsQ0FBQztBQUM5QixlQUFPO0FBQUEsTUFDUjtBQUVELFlBQU0sT0FBTyxLQUFLLEtBQUssRUFBRSxJQUFJLEdBQUc7QUFDaEMsWUFBTSxPQUFPLEtBQUs7QUFJbEIsVUFBSSxLQUFLLE9BQU8sR0FBRztBQUNqQixZQUFJLENBQUMsS0FBSyxpQkFBaUI7QUFDekIsZUFBSyxPQUFPLEVBQUUsS0FBSyxLQUFLLEtBQUs7QUFBQSxNQUNoQztBQUVELFdBQUssTUFBTTtBQUNYLFdBQUssU0FBUztBQUNkLFdBQUssUUFBUTtBQUNiLFdBQUssTUFBTSxLQUFLLE1BQU0sS0FBSztBQUMzQixXQUFLLFNBQVM7QUFDZCxXQUFLLElBQUksR0FBRztBQUNaLFdBQUssSUFBSTtBQUNULGFBQU87QUFBQSxJQUNSO0FBRUQsVUFBTSxNQUFNLElBQUksTUFBTSxLQUFLLE9BQU8sS0FBSyxLQUFLLE1BQU07QUFHbEQsUUFBSSxJQUFJLFNBQVMsS0FBSyxHQUFHLEdBQUc7QUFDMUIsVUFBSSxLQUFLLE9BQU87QUFDZCxhQUFLLE9BQU8sRUFBRSxLQUFLLEtBQUs7QUFFMUIsYUFBTztBQUFBLElBQ1I7QUFFRCxTQUFLLE1BQU0sS0FBSyxJQUFJO0FBQ3BCLFNBQUssUUFBUSxFQUFFLFFBQVEsR0FBRztBQUMxQixTQUFLLEtBQUssRUFBRSxJQUFJLEtBQUssS0FBSyxRQUFRLEVBQUUsSUFBSTtBQUN4QyxTQUFLLElBQUk7QUFDVCxXQUFPO0FBQUEsRUFDUjtBQUFBLEVBRUQsSUFBSyxLQUFLO0FBQ1IsUUFBSSxDQUFDLEtBQUssS0FBSyxFQUFFLElBQUksR0FBRztBQUFHLGFBQU87QUFDbEMsVUFBTSxNQUFNLEtBQUssS0FBSyxFQUFFLElBQUksR0FBRyxFQUFFO0FBQ2pDLFdBQU8sQ0FBQyxRQUFRLE1BQU0sR0FBRztBQUFBLEVBQzFCO0FBQUEsRUFFRCxJQUFLLEtBQUs7QUFDUixXQUFPLElBQUksTUFBTSxLQUFLLElBQUk7QUFBQSxFQUMzQjtBQUFBLEVBRUQsS0FBTSxLQUFLO0FBQ1QsV0FBTyxJQUFJLE1BQU0sS0FBSyxLQUFLO0FBQUEsRUFDNUI7QUFBQSxFQUVELE1BQU87QUFDTCxVQUFNLE9BQU8sS0FBSyxRQUFRLEVBQUU7QUFDNUIsUUFBSSxDQUFDO0FBQ0gsYUFBTztBQUVULFFBQUksTUFBTSxJQUFJO0FBQ2QsV0FBTyxLQUFLO0FBQUEsRUFDYjtBQUFBLEVBRUQsSUFBSyxLQUFLO0FBQ1IsUUFBSSxNQUFNLEtBQUssS0FBSyxFQUFFLElBQUksR0FBRyxDQUFDO0FBQUEsRUFDL0I7QUFBQSxFQUVELEtBQU0sS0FBSztBQUVULFNBQUssTUFBTztBQUVaLFVBQU0sTUFBTSxLQUFLLElBQUs7QUFFdEIsYUFBUyxJQUFJLElBQUksU0FBUyxHQUFHLEtBQUssR0FBRyxLQUFLO0FBQ3hDLFlBQU0sTUFBTSxJQUFJLENBQUM7QUFDakIsWUFBTSxZQUFZLElBQUksS0FBSztBQUMzQixVQUFJLGNBQWM7QUFFaEIsYUFBSyxJQUFJLElBQUksR0FBRyxJQUFJLENBQUM7QUFBQSxXQUNsQjtBQUNILGNBQU0sU0FBUyxZQUFZO0FBRTNCLFlBQUksU0FBUyxHQUFHO0FBQ2QsZUFBSyxJQUFJLElBQUksR0FBRyxJQUFJLEdBQUcsTUFBTTtBQUFBLFFBQzlCO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQUEsRUFFRCxRQUFTO0FBQ1AsU0FBSyxLQUFLLEVBQUUsUUFBUSxDQUFDLE9BQU8sUUFBUSxJQUFJLE1BQU0sS0FBSyxLQUFLLENBQUM7QUFBQSxFQUMxRDtBQUNIO0FBRUEsTUFBTSxNQUFNLENBQUNhLE9BQU0sS0FBSyxVQUFVO0FBQ2hDLFFBQU0sT0FBT0EsTUFBSyxLQUFLLEVBQUUsSUFBSSxHQUFHO0FBQ2hDLE1BQUksTUFBTTtBQUNSLFVBQU0sTUFBTSxLQUFLO0FBQ2pCLFFBQUksUUFBUUEsT0FBTSxHQUFHLEdBQUc7QUFDdEIsVUFBSUEsT0FBTSxJQUFJO0FBQ2QsVUFBSSxDQUFDQSxNQUFLLFdBQVc7QUFDbkIsZUFBTztBQUFBLElBQ2YsT0FBVztBQUNMLFVBQUksT0FBTztBQUNULFlBQUlBLE1BQUssaUJBQWlCO0FBQ3hCLGVBQUssTUFBTSxNQUFNLEtBQUssSUFBSztBQUM3QixRQUFBQSxNQUFLLFFBQVEsRUFBRSxZQUFZLElBQUk7QUFBQSxNQUNoQztBQUFBLElBQ0Y7QUFDRCxXQUFPLElBQUk7QUFBQSxFQUNaO0FBQ0g7QUFFQSxNQUFNLFVBQVUsQ0FBQ0EsT0FBTSxRQUFRO0FBQzdCLE1BQUksQ0FBQyxPQUFRLENBQUMsSUFBSSxVQUFVLENBQUNBLE1BQUssT0FBTztBQUN2QyxXQUFPO0FBRVQsUUFBTWtNLFFBQU8sS0FBSyxJQUFLLElBQUcsSUFBSTtBQUM5QixTQUFPLElBQUksU0FBU0EsUUFBTyxJQUFJLFNBQzNCbE0sTUFBSyxPQUFPLEtBQU1rTSxRQUFPbE0sTUFBSyxPQUFPO0FBQzNDO0FBRUEsTUFBTSxPQUFPLENBQUFBLFVBQVE7QUFDbkIsTUFBSUEsTUFBSyxNQUFNLElBQUlBLE1BQUssR0FBRyxHQUFHO0FBQzVCLGFBQVMsU0FBU0EsTUFBSyxRQUFRLEVBQUUsTUFDL0JBLE1BQUssTUFBTSxJQUFJQSxNQUFLLEdBQUcsS0FBSyxXQUFXLFFBQU87QUFJOUMsWUFBTSxPQUFPLE9BQU87QUFDcEIsVUFBSUEsT0FBTSxNQUFNO0FBQ2hCLGVBQVM7QUFBQSxJQUNWO0FBQUEsRUFDRjtBQUNIO0FBRUEsTUFBTSxNQUFNLENBQUNBLE9BQU0sU0FBUztBQUMxQixNQUFJLE1BQU07QUFDUixVQUFNLE1BQU0sS0FBSztBQUNqQixRQUFJQSxNQUFLLE9BQU87QUFDZCxNQUFBQSxNQUFLLE9BQU8sRUFBRSxJQUFJLEtBQUssSUFBSSxLQUFLO0FBRWxDLElBQUFBLE1BQUssTUFBTSxLQUFLLElBQUk7QUFDcEIsSUFBQUEsTUFBSyxLQUFLLEVBQUUsT0FBTyxJQUFJLEdBQUc7QUFDMUIsSUFBQUEsTUFBSyxRQUFRLEVBQUUsV0FBVyxJQUFJO0FBQUEsRUFDL0I7QUFDSDtBQUVBLE1BQU0sTUFBTTtBQUFBLEVBQ1YsWUFBYSxLQUFLLE9BQU8sUUFBUSxLQUFLLFFBQVE7QUFDNUMsU0FBSyxNQUFNO0FBQ1gsU0FBSyxRQUFRO0FBQ2IsU0FBSyxTQUFTO0FBQ2QsU0FBSyxNQUFNO0FBQ1gsU0FBSyxTQUFTLFVBQVU7QUFBQSxFQUN6QjtBQUNIO0FBRUEsTUFBTSxjQUFjLENBQUNBLE9BQU0sSUFBSSxNQUFNLFVBQVU7QUFDN0MsTUFBSSxNQUFNLEtBQUs7QUFDZixNQUFJLFFBQVFBLE9BQU0sR0FBRyxHQUFHO0FBQ3RCLFFBQUlBLE9BQU0sSUFBSTtBQUNkLFFBQUksQ0FBQ0EsTUFBSyxXQUFXO0FBQ25CLFlBQU07QUFBQSxFQUNUO0FBQ0QsTUFBSTtBQUNGLE9BQUcsS0FBSyxPQUFPLElBQUksT0FBTyxJQUFJLEtBQUtBLEtBQUk7QUFDM0M7QUFFQSxJQUFBLFdBQWlCOzs7Ozs7O0VDNVVqQixNQUFNbU4sT0FBTTtBQUFBLElBQ1YsWUFBYUMsUUFBTyxTQUFTO0FBQzNCLGdCQUFVMUIsY0FBYSxPQUFPO0FBRTlCLFVBQUkwQixrQkFBaUJELFFBQU87QUFDMUIsWUFDRUMsT0FBTSxVQUFVLENBQUMsQ0FBQyxRQUFRLFNBQzFCQSxPQUFNLHNCQUFzQixDQUFDLENBQUMsUUFBUSxtQkFDdEM7QUFDQSxpQkFBT0E7QUFBQSxRQUNmLE9BQWE7QUFDTCxpQkFBTyxJQUFJRCxPQUFNQyxPQUFNLEtBQUssT0FBTztBQUFBLFFBQ3BDO0FBQUEsTUFDRjtBQUVELFVBQUlBLGtCQUFpQkMsYUFBWTtBQUUvQixhQUFLLE1BQU1ELE9BQU07QUFDakIsYUFBSyxNQUFNLENBQUMsQ0FBQ0EsTUFBSyxDQUFDO0FBQ25CLGFBQUssT0FBUTtBQUNiLGVBQU87QUFBQSxNQUNSO0FBRUQsV0FBSyxVQUFVO0FBQ2YsV0FBSyxRQUFRLENBQUMsQ0FBQyxRQUFRO0FBQ3ZCLFdBQUssb0JBQW9CLENBQUMsQ0FBQyxRQUFRO0FBS25DLFdBQUssTUFBTUEsT0FDUixLQUFNLEVBQ04sTUFBTSxLQUFLLEVBQ1gsS0FBSyxHQUFHO0FBR1gsV0FBSyxNQUFNLEtBQUssSUFDYixNQUFNLElBQUksRUFFVixJQUFJLE9BQUssS0FBSyxXQUFXLEVBQUUsS0FBSSxDQUFFLENBQUMsRUFJbEMsT0FBTyxPQUFLLEVBQUUsTUFBTTtBQUV2QixVQUFJLENBQUMsS0FBSyxJQUFJLFFBQVE7QUFDcEIsY0FBTSxJQUFJLFVBQVUseUJBQXlCLEtBQUssR0FBRyxFQUFFO0FBQUEsTUFDeEQ7QUFHRCxVQUFJLEtBQUssSUFBSSxTQUFTLEdBQUc7QUFFdkIsY0FBTSxRQUFRLEtBQUssSUFBSSxDQUFDO0FBQ3hCLGFBQUssTUFBTSxLQUFLLElBQUksT0FBTyxPQUFLLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ2hELFlBQUksS0FBSyxJQUFJLFdBQVcsR0FBRztBQUN6QixlQUFLLE1BQU0sQ0FBQyxLQUFLO0FBQUEsUUFDbEIsV0FBVSxLQUFLLElBQUksU0FBUyxHQUFHO0FBRTlCLHFCQUFXLEtBQUssS0FBSyxLQUFLO0FBQ3hCLGdCQUFJLEVBQUUsV0FBVyxLQUFLLE1BQU0sRUFBRSxDQUFDLENBQUMsR0FBRztBQUNqQyxtQkFBSyxNQUFNLENBQUMsQ0FBQztBQUNiO0FBQUEsWUFDRDtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUVELFdBQUssT0FBUTtBQUFBLElBQ2Q7QUFBQSxJQUVELFNBQVU7QUFDUixXQUFLLFFBQVEsS0FBSyxJQUNmLElBQUksQ0FBQyxVQUFVLE1BQU0sS0FBSyxHQUFHLEVBQUUsTUFBTSxFQUNyQyxLQUFLLElBQUksRUFDVCxLQUFNO0FBQ1QsYUFBTyxLQUFLO0FBQUEsSUFDYjtBQUFBLElBRUQsV0FBWTtBQUNWLGFBQU8sS0FBSztBQUFBLElBQ2I7QUFBQSxJQUVELFdBQVlBLFFBQU87QUFHakIsWUFBTSxZQUNILEtBQUssUUFBUSxxQkFBcUIsNEJBQ2xDLEtBQUssUUFBUSxTQUFTO0FBQ3pCLFlBQU0sVUFBVSxXQUFXLE1BQU1BO0FBQ2pDLFlBQU0sU0FBUyxNQUFNLElBQUksT0FBTztBQUNoQyxVQUFJLFFBQVE7QUFDVixlQUFPO0FBQUEsTUFDUjtBQUVELFlBQU0sUUFBUSxLQUFLLFFBQVE7QUFFM0IsWUFBTSxLQUFLLFFBQVEzQixJQUFHMUUsR0FBRSxnQkFBZ0IsSUFBSTBFLElBQUcxRSxHQUFFLFdBQVc7QUFDNUQsTUFBQXFHLFNBQVFBLE9BQU0sUUFBUSxJQUFJLGNBQWMsS0FBSyxRQUFRLGlCQUFpQixDQUFDO0FBQ3ZFLE1BQUFoTixPQUFNLGtCQUFrQmdOLE1BQUs7QUFHN0IsTUFBQUEsU0FBUUEsT0FBTSxRQUFRM0IsSUFBRzFFLEdBQUUsY0FBYyxHQUFHLHFCQUFxQjtBQUNqRSxNQUFBM0csT0FBTSxtQkFBbUJnTixNQUFLO0FBRzlCLE1BQUFBLFNBQVFBLE9BQU0sUUFBUTNCLElBQUcxRSxHQUFFLFNBQVMsR0FBRyxnQkFBZ0I7QUFDdkQsTUFBQTNHLE9BQU0sY0FBY2dOLE1BQUs7QUFHekIsTUFBQUEsU0FBUUEsT0FBTSxRQUFRM0IsSUFBRzFFLEdBQUUsU0FBUyxHQUFHLGdCQUFnQjtBQUN2RCxNQUFBM0csT0FBTSxjQUFjZ04sTUFBSztBQUt6QixVQUFJLFlBQVlBLE9BQ2IsTUFBTSxHQUFHLEVBQ1QsSUFBSSxVQUFRLGdCQUFnQixNQUFNLEtBQUssT0FBTyxDQUFDLEVBQy9DLEtBQUssR0FBRyxFQUNSLE1BQU0sS0FBSyxFQUVYLElBQUksVUFBUSxZQUFZLE1BQU0sS0FBSyxPQUFPLENBQUM7QUFFOUMsVUFBSSxPQUFPO0FBRVQsb0JBQVksVUFBVSxPQUFPLFVBQVE7QUFDbkMsVUFBQWhOLE9BQU0sd0JBQXdCLE1BQU0sS0FBSyxPQUFPO0FBQ2hELGlCQUFPLENBQUMsQ0FBQyxLQUFLLE1BQU1xTCxJQUFHMUUsR0FBRSxlQUFlLENBQUM7QUFBQSxRQUNqRCxDQUFPO0FBQUEsTUFDRjtBQUNELE1BQUEzRyxPQUFNLGNBQWMsU0FBUztBQUs3QixZQUFNLFdBQVcsb0JBQUksSUFBSztBQUMxQixZQUFNLGNBQWMsVUFBVSxJQUFJLFVBQVEsSUFBSWlOLFlBQVcsTUFBTSxLQUFLLE9BQU8sQ0FBQztBQUM1RSxpQkFBVyxRQUFRLGFBQWE7QUFDOUIsWUFBSSxVQUFVLElBQUksR0FBRztBQUNuQixpQkFBTyxDQUFDLElBQUk7QUFBQSxRQUNiO0FBQ0QsaUJBQVMsSUFBSSxLQUFLLE9BQU8sSUFBSTtBQUFBLE1BQzlCO0FBQ0QsVUFBSSxTQUFTLE9BQU8sS0FBSyxTQUFTLElBQUksRUFBRSxHQUFHO0FBQ3pDLGlCQUFTLE9BQU8sRUFBRTtBQUFBLE1BQ25CO0FBRUQsWUFBTSxTQUFTLENBQUMsR0FBRyxTQUFTLE9BQU0sQ0FBRTtBQUNwQyxZQUFNLElBQUksU0FBUyxNQUFNO0FBQ3pCLGFBQU87QUFBQSxJQUNSO0FBQUEsSUFFRCxXQUFZRCxRQUFPLFNBQVM7QUFDMUIsVUFBSSxFQUFFQSxrQkFBaUJELFNBQVE7QUFDN0IsY0FBTSxJQUFJLFVBQVUscUJBQXFCO0FBQUEsTUFDMUM7QUFFRCxhQUFPLEtBQUssSUFBSSxLQUFLLENBQUMsb0JBQW9CO0FBQ3hDLGVBQ0UsY0FBYyxpQkFBaUIsT0FBTyxLQUN0Q0MsT0FBTSxJQUFJLEtBQUssQ0FBQyxxQkFBcUI7QUFDbkMsaUJBQ0UsY0FBYyxrQkFBa0IsT0FBTyxLQUN2QyxnQkFBZ0IsTUFBTSxDQUFDLG1CQUFtQjtBQUN4QyxtQkFBTyxpQkFBaUIsTUFBTSxDQUFDLG9CQUFvQjtBQUNqRCxxQkFBTyxlQUFlLFdBQVcsaUJBQWlCLE9BQU87QUFBQSxZQUN6RSxDQUFlO0FBQUEsVUFDZixDQUFhO0FBQUEsUUFFYixDQUFTO0FBQUEsTUFFVCxDQUFLO0FBQUEsSUFDRjtBQUFBO0FBQUEsSUFHRCxLQUFNLFNBQVM7QUFDYixVQUFJLENBQUMsU0FBUztBQUNaLGVBQU87QUFBQSxNQUNSO0FBRUQsVUFBSSxPQUFPLFlBQVksVUFBVTtBQUMvQixZQUFJO0FBQ0Ysb0JBQVUsSUFBSXJCLFFBQU8sU0FBUyxLQUFLLE9BQU87QUFBQSxRQUMzQyxTQUFRLElBQUk7QUFDWCxpQkFBTztBQUFBLFFBQ1I7QUFBQSxNQUNGO0FBRUQsZUFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLElBQUksUUFBUSxLQUFLO0FBQ3hDLFlBQUksUUFBUSxLQUFLLElBQUksQ0FBQyxHQUFHLFNBQVMsS0FBSyxPQUFPLEdBQUc7QUFDL0MsaUJBQU87QUFBQSxRQUNSO0FBQUEsTUFDRjtBQUNELGFBQU87QUFBQSxJQUNSO0FBQUEsRUFDRjtBQUVELFVBQWlCb0I7QUFFakIsUUFBTSxNQUFNaE87QUFDWixRQUFNLFFBQVEsSUFBSSxJQUFJLEVBQUUsS0FBSyxJQUFJLENBQUU7QUFFbkMsUUFBTXVNLGdCQUFlaE47QUFDckIsUUFBTTJPLGNBQWExTyxrQkFBdUI7QUFDMUMsUUFBTXlCLFNBQVFEO0FBQ2QsUUFBTTRMLFVBQVMvSjtBQUNmLFFBQU07QUFBQSxJQUNKLFFBQVF5SjtBQUFBLElBQ1IsR0FBQTFFO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsRUFDRixJQUFJOUU7QUFDSixRQUFNLEVBQUUseUJBQXlCLFdBQVUsSUFBS3dCO0FBRWhELFFBQU0sWUFBWSxPQUFLLEVBQUUsVUFBVTtBQUNuQyxRQUFNLFFBQVEsT0FBSyxFQUFFLFVBQVU7QUFJL0IsUUFBTSxnQkFBZ0IsQ0FBQyxhQUFhLFlBQVk7QUFDOUMsUUFBSSxTQUFTO0FBQ2IsVUFBTSx1QkFBdUIsWUFBWSxNQUFPO0FBQ2hELFFBQUksaUJBQWlCLHFCQUFxQixJQUFLO0FBRS9DLFdBQU8sVUFBVSxxQkFBcUIsUUFBUTtBQUM1QyxlQUFTLHFCQUFxQixNQUFNLENBQUMsb0JBQW9CO0FBQ3ZELGVBQU8sZUFBZSxXQUFXLGlCQUFpQixPQUFPO0FBQUEsTUFDL0QsQ0FBSztBQUVELHVCQUFpQixxQkFBcUIsSUFBSztBQUFBLElBQzVDO0FBRUQsV0FBTztBQUFBLEVBQ1I7QUFLRCxRQUFNLGtCQUFrQixDQUFDLE1BQU0sWUFBWTtBQUN6QyxJQUFBckQsT0FBTSxRQUFRLE1BQU0sT0FBTztBQUMzQixXQUFPLGNBQWMsTUFBTSxPQUFPO0FBQ2xDLElBQUFBLE9BQU0sU0FBUyxJQUFJO0FBQ25CLFdBQU8sY0FBYyxNQUFNLE9BQU87QUFDbEMsSUFBQUEsT0FBTSxVQUFVLElBQUk7QUFDcEIsV0FBTyxlQUFlLE1BQU0sT0FBTztBQUNuQyxJQUFBQSxPQUFNLFVBQVUsSUFBSTtBQUNwQixXQUFPLGFBQWEsTUFBTSxPQUFPO0FBQ2pDLElBQUFBLE9BQU0sU0FBUyxJQUFJO0FBQ25CLFdBQU87QUFBQSxFQUNSO0FBRUQsUUFBTSxNQUFNLENBQUEzQixRQUFNLENBQUNBLE9BQU1BLElBQUcsWUFBYSxNQUFLLE9BQU9BLFFBQU87QUFTNUQsUUFBTSxnQkFBZ0IsQ0FBQyxNQUFNLFlBQVk7QUFDdkMsV0FBTyxLQUNKLEtBQU0sRUFDTixNQUFNLEtBQUssRUFDWCxJQUFJLENBQUMsTUFBTSxhQUFhLEdBQUcsT0FBTyxDQUFDLEVBQ25DLEtBQUssR0FBRztBQUFBLEVBQ1o7QUFFRCxRQUFNLGVBQWUsQ0FBQyxNQUFNLFlBQVk7QUFDdEMsVUFBTSxJQUFJLFFBQVEsUUFBUWdOLElBQUcxRSxHQUFFLFVBQVUsSUFBSTBFLElBQUcxRSxHQUFFLEtBQUs7QUFDdkQsV0FBTyxLQUFLLFFBQVEsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsT0FBTztBQUN6QyxNQUFBM0csT0FBTSxTQUFTLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFO0FBQ25DLFVBQUk7QUFFSixVQUFJLElBQUksQ0FBQyxHQUFHO0FBQ1YsY0FBTTtBQUFBLE1BQ1osV0FBZSxJQUFJLENBQUMsR0FBRztBQUNqQixjQUFNLEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDO0FBQUEsTUFDakMsV0FBZSxJQUFJLENBQUMsR0FBRztBQUVqQixjQUFNLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7QUFBQSxNQUNwQyxXQUFVLElBQUk7QUFDYixRQUFBQSxPQUFNLG1CQUFtQixFQUFFO0FBQzNCLGNBQU0sS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUNoQyxLQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztBQUFBLE1BQ3RCLE9BQVc7QUFFTCxjQUFNLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUMzQixLQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztBQUFBLE1BQ2pCO0FBRUQsTUFBQUEsT0FBTSxnQkFBZ0IsR0FBRztBQUN6QixhQUFPO0FBQUEsSUFDWCxDQUFHO0FBQUEsRUFDRjtBQVVELFFBQU0sZ0JBQWdCLENBQUMsTUFBTSxZQUFZO0FBQ3ZDLFdBQU8sS0FDSixLQUFNLEVBQ04sTUFBTSxLQUFLLEVBQ1gsSUFBSSxDQUFDLE1BQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxFQUNuQyxLQUFLLEdBQUc7QUFBQSxFQUNaO0FBRUQsUUFBTSxlQUFlLENBQUMsTUFBTSxZQUFZO0FBQ3RDLElBQUFBLE9BQU0sU0FBUyxNQUFNLE9BQU87QUFDNUIsVUFBTSxJQUFJLFFBQVEsUUFBUXFMLElBQUcxRSxHQUFFLFVBQVUsSUFBSTBFLElBQUcxRSxHQUFFLEtBQUs7QUFDdkQsVUFBTSxJQUFJLFFBQVEsb0JBQW9CLE9BQU87QUFDN0MsV0FBTyxLQUFLLFFBQVEsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsT0FBTztBQUN6QyxNQUFBM0csT0FBTSxTQUFTLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFO0FBQ25DLFVBQUk7QUFFSixVQUFJLElBQUksQ0FBQyxHQUFHO0FBQ1YsY0FBTTtBQUFBLE1BQ1osV0FBZSxJQUFJLENBQUMsR0FBRztBQUNqQixjQUFNLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQztBQUFBLE1BQ3JDLFdBQWUsSUFBSSxDQUFDLEdBQUc7QUFDakIsWUFBSSxNQUFNLEtBQUs7QUFDYixnQkFBTSxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztBQUFBLFFBQy9DLE9BQWE7QUFDTCxnQkFBTSxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDO0FBQUEsUUFDbkM7QUFBQSxNQUNGLFdBQVUsSUFBSTtBQUNiLFFBQUFBLE9BQU0sbUJBQW1CLEVBQUU7QUFDM0IsWUFBSSxNQUFNLEtBQUs7QUFDYixjQUFJLE1BQU0sS0FBSztBQUNiLGtCQUFNLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFDcEMsS0FBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO0FBQUEsVUFDL0IsT0FBZTtBQUNMLGtCQUFNLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFDcEMsS0FBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7QUFBQSxVQUNqQjtBQUFBLFFBQ1QsT0FBYTtBQUNMLGdCQUFNLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFDekIsS0FBSSxDQUFDLElBQUksQ0FBQztBQUFBLFFBQ1o7QUFBQSxNQUNQLE9BQVc7QUFDTCxRQUFBQSxPQUFNLE9BQU87QUFDYixZQUFJLE1BQU0sS0FBSztBQUNiLGNBQUksTUFBTSxLQUFLO0FBQ2Isa0JBQU0sS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQy9CLEdBQWEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7QUFBQSxVQUNuQyxPQUFlO0FBQ0wsa0JBQU0sS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQy9CLEdBQWEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztBQUFBLFVBQ3JCO0FBQUEsUUFDVCxPQUFhO0FBQ0wsZ0JBQU0sS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQ3BCLEtBQUksQ0FBQyxJQUFJLENBQUM7QUFBQSxRQUNaO0FBQUEsTUFDRjtBQUVELE1BQUFBLE9BQU0sZ0JBQWdCLEdBQUc7QUFDekIsYUFBTztBQUFBLElBQ1gsQ0FBRztBQUFBLEVBQ0Y7QUFFRCxRQUFNLGlCQUFpQixDQUFDLE1BQU0sWUFBWTtBQUN4QyxJQUFBQSxPQUFNLGtCQUFrQixNQUFNLE9BQU87QUFDckMsV0FBTyxLQUNKLE1BQU0sS0FBSyxFQUNYLElBQUksQ0FBQyxNQUFNLGNBQWMsR0FBRyxPQUFPLENBQUMsRUFDcEMsS0FBSyxHQUFHO0FBQUEsRUFDWjtBQUVELFFBQU0sZ0JBQWdCLENBQUMsTUFBTSxZQUFZO0FBQ3ZDLFdBQU8sS0FBSyxLQUFNO0FBQ2xCLFVBQU0sSUFBSSxRQUFRLFFBQVFxTCxJQUFHMUUsR0FBRSxXQUFXLElBQUkwRSxJQUFHMUUsR0FBRSxNQUFNO0FBQ3pELFdBQU8sS0FBSyxRQUFRLEdBQUcsQ0FBQyxLQUFLLE1BQU0sR0FBRyxHQUFHLEdBQUcsT0FBTztBQUNqRCxNQUFBM0csT0FBTSxVQUFVLE1BQU0sS0FBSyxNQUFNLEdBQUcsR0FBRyxHQUFHLEVBQUU7QUFDNUMsWUFBTSxLQUFLLElBQUksQ0FBQztBQUNoQixZQUFNLEtBQUssTUFBTSxJQUFJLENBQUM7QUFDdEIsWUFBTSxLQUFLLE1BQU0sSUFBSSxDQUFDO0FBQ3RCLFlBQU0sT0FBTztBQUViLFVBQUksU0FBUyxPQUFPLE1BQU07QUFDeEIsZUFBTztBQUFBLE1BQ1I7QUFJRCxXQUFLLFFBQVEsb0JBQW9CLE9BQU87QUFFeEMsVUFBSSxJQUFJO0FBQ04sWUFBSSxTQUFTLE9BQU8sU0FBUyxLQUFLO0FBRWhDLGdCQUFNO0FBQUEsUUFDZCxPQUFhO0FBRUwsZ0JBQU07QUFBQSxRQUNQO0FBQUEsTUFDUCxXQUFlLFFBQVEsTUFBTTtBQUd2QixZQUFJLElBQUk7QUFDTixjQUFJO0FBQUEsUUFDTDtBQUNELFlBQUk7QUFFSixZQUFJLFNBQVMsS0FBSztBQUdoQixpQkFBTztBQUNQLGNBQUksSUFBSTtBQUNOLGdCQUFJLENBQUMsSUFBSTtBQUNULGdCQUFJO0FBQ0osZ0JBQUk7QUFBQSxVQUNkLE9BQWU7QUFDTCxnQkFBSSxDQUFDLElBQUk7QUFDVCxnQkFBSTtBQUFBLFVBQ0w7QUFBQSxRQUNULFdBQWlCLFNBQVMsTUFBTTtBQUd4QixpQkFBTztBQUNQLGNBQUksSUFBSTtBQUNOLGdCQUFJLENBQUMsSUFBSTtBQUFBLFVBQ25CLE9BQWU7QUFDTCxnQkFBSSxDQUFDLElBQUk7QUFBQSxVQUNWO0FBQUEsUUFDRjtBQUVELFlBQUksU0FBUyxLQUFLO0FBQ2hCLGVBQUs7QUFBQSxRQUNOO0FBRUQsY0FBTSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRTtBQUFBLE1BQ2pDLFdBQVUsSUFBSTtBQUNiLGNBQU0sS0FBSyxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDO0FBQUEsTUFDakMsV0FBVSxJQUFJO0FBQ2IsY0FBTSxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssRUFDNUIsS0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7QUFBQSxNQUNqQjtBQUVELE1BQUFBLE9BQU0saUJBQWlCLEdBQUc7QUFFMUIsYUFBTztBQUFBLElBQ1gsQ0FBRztBQUFBLEVBQ0Y7QUFJRCxRQUFNLGVBQWUsQ0FBQyxNQUFNLFlBQVk7QUFDdEMsSUFBQUEsT0FBTSxnQkFBZ0IsTUFBTSxPQUFPO0FBRW5DLFdBQU8sS0FDSixLQUFNLEVBQ04sUUFBUXFMLElBQUcxRSxHQUFFLElBQUksR0FBRyxFQUFFO0FBQUEsRUFDMUI7QUFFRCxRQUFNLGNBQWMsQ0FBQyxNQUFNLFlBQVk7QUFDckMsSUFBQTNHLE9BQU0sZUFBZSxNQUFNLE9BQU87QUFDbEMsV0FBTyxLQUNKLEtBQU0sRUFDTixRQUFRcUwsSUFBRyxRQUFRLG9CQUFvQjFFLEdBQUUsVUFBVUEsR0FBRSxJQUFJLEdBQUcsRUFBRTtBQUFBLEVBQ2xFO0FBT0QsUUFBTSxnQkFBZ0IsV0FBUyxDQUFDLElBQzlCLE1BQU0sSUFBSSxJQUFJLElBQUksS0FBSyxJQUN2QixJQUFJLElBQUksSUFBSSxJQUFJLEtBQUssT0FBTztBQUM1QixRQUFJLElBQUksRUFBRSxHQUFHO0FBQ1gsYUFBTztBQUFBLElBQ1gsV0FBYSxJQUFJLEVBQUUsR0FBRztBQUNsQixhQUFPLEtBQUssRUFBRSxPQUFPLFFBQVEsT0FBTyxFQUFFO0FBQUEsSUFDMUMsV0FBYSxJQUFJLEVBQUUsR0FBRztBQUNsQixhQUFPLEtBQUssRUFBRSxJQUFJLEVBQUUsS0FBSyxRQUFRLE9BQU8sRUFBRTtBQUFBLElBQzNDLFdBQVUsS0FBSztBQUNkLGFBQU8sS0FBSyxJQUFJO0FBQUEsSUFDcEIsT0FBUztBQUNMLGFBQU8sS0FBSyxJQUFJLEdBQUcsUUFBUSxPQUFPLEVBQUU7QUFBQSxJQUNyQztBQUVELFFBQUksSUFBSSxFQUFFLEdBQUc7QUFDWCxXQUFLO0FBQUEsSUFDVCxXQUFhLElBQUksRUFBRSxHQUFHO0FBQ2xCLFdBQUssSUFBSSxDQUFDLEtBQUssQ0FBQztBQUFBLElBQ3BCLFdBQWEsSUFBSSxFQUFFLEdBQUc7QUFDbEIsV0FBSyxJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQztBQUFBLElBQ3ZCLFdBQVUsS0FBSztBQUNkLFdBQUssS0FBSyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxHQUFHO0FBQUEsSUFDaEMsV0FBVSxPQUFPO0FBQ2hCLFdBQUssSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDO0FBQUEsSUFDaEMsT0FBUztBQUNMLFdBQUssS0FBSyxFQUFFO0FBQUEsSUFDYjtBQUVELFdBQU8sR0FBRyxJQUFJLElBQUksRUFBRSxHQUFHLEtBQU07QUFBQSxFQUM5QjtBQUVELFFBQU0sVUFBVSxDQUFDLEtBQUssU0FBUyxZQUFZO0FBQ3pDLGFBQVMsSUFBSSxHQUFHLElBQUksSUFBSSxRQUFRLEtBQUs7QUFDbkMsVUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUssT0FBTyxHQUFHO0FBQ3pCLGVBQU87QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUVELFFBQUksUUFBUSxXQUFXLFVBQVUsQ0FBQyxRQUFRLG1CQUFtQjtBQU0zRCxlQUFTLElBQUksR0FBRyxJQUFJLElBQUksUUFBUSxLQUFLO0FBQ25DLFFBQUEzRyxPQUFNLElBQUksQ0FBQyxFQUFFLE1BQU07QUFDbkIsWUFBSSxJQUFJLENBQUMsRUFBRSxXQUFXaU4sWUFBVyxLQUFLO0FBQ3BDO0FBQUEsUUFDRDtBQUVELFlBQUksSUFBSSxDQUFDLEVBQUUsT0FBTyxXQUFXLFNBQVMsR0FBRztBQUN2QyxnQkFBTSxVQUFVLElBQUksQ0FBQyxFQUFFO0FBQ3ZCLGNBQUksUUFBUSxVQUFVLFFBQVEsU0FDMUIsUUFBUSxVQUFVLFFBQVEsU0FDMUIsUUFBUSxVQUFVLFFBQVEsT0FBTztBQUNuQyxtQkFBTztBQUFBLFVBQ1I7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUdELGFBQU87QUFBQSxJQUNSO0FBRUQsV0FBTztBQUFBLEVBQ1Q7Ozs7Ozs7OztBQzFoQkEsUUFBTUMsT0FBTSxPQUFPLFlBQVk7QUFBQSxFQUUvQixNQUFNRCxZQUFXO0FBQUEsSUFDZixXQUFXLE1BQU87QUFDaEIsYUFBT0M7QUFBQSxJQUNSO0FBQUEsSUFFRCxZQUFhLE1BQU0sU0FBUztBQUMxQixnQkFBVTVCLGNBQWEsT0FBTztBQUU5QixVQUFJLGdCQUFnQjJCLGFBQVk7QUFDOUIsWUFBSSxLQUFLLFVBQVUsQ0FBQyxDQUFDLFFBQVEsT0FBTztBQUNsQyxpQkFBTztBQUFBLFFBQ2YsT0FBYTtBQUNMLGlCQUFPLEtBQUs7QUFBQSxRQUNiO0FBQUEsTUFDRjtBQUVELGFBQU8sS0FBSyxLQUFNLEVBQUMsTUFBTSxLQUFLLEVBQUUsS0FBSyxHQUFHO0FBQ3hDLE1BQUFqTixPQUFNLGNBQWMsTUFBTSxPQUFPO0FBQ2pDLFdBQUssVUFBVTtBQUNmLFdBQUssUUFBUSxDQUFDLENBQUMsUUFBUTtBQUN2QixXQUFLLE1BQU0sSUFBSTtBQUVmLFVBQUksS0FBSyxXQUFXa04sTUFBSztBQUN2QixhQUFLLFFBQVE7QUFBQSxNQUNuQixPQUFXO0FBQ0wsYUFBSyxRQUFRLEtBQUssV0FBVyxLQUFLLE9BQU87QUFBQSxNQUMxQztBQUVELE1BQUFsTixPQUFNLFFBQVEsSUFBSTtBQUFBLElBQ25CO0FBQUEsSUFFRCxNQUFPLE1BQU07QUFDWCxZQUFNLElBQUksS0FBSyxRQUFRLFFBQVFxTCxJQUFHMUUsR0FBRSxlQUFlLElBQUkwRSxJQUFHMUUsR0FBRSxVQUFVO0FBQ3RFLFlBQU0sSUFBSSxLQUFLLE1BQU0sQ0FBQztBQUV0QixVQUFJLENBQUMsR0FBRztBQUNOLGNBQU0sSUFBSSxVQUFVLHVCQUF1QixJQUFJLEVBQUU7QUFBQSxNQUNsRDtBQUVELFdBQUssV0FBVyxFQUFFLENBQUMsTUFBTSxTQUFZLEVBQUUsQ0FBQyxJQUFJO0FBQzVDLFVBQUksS0FBSyxhQUFhLEtBQUs7QUFDekIsYUFBSyxXQUFXO0FBQUEsTUFDakI7QUFHRCxVQUFJLENBQUMsRUFBRSxDQUFDLEdBQUc7QUFDVCxhQUFLLFNBQVN1RztBQUFBLE1BQ3BCLE9BQVc7QUFDTCxhQUFLLFNBQVMsSUFBSXZCLFFBQU8sRUFBRSxDQUFDLEdBQUcsS0FBSyxRQUFRLEtBQUs7QUFBQSxNQUNsRDtBQUFBLElBQ0Y7QUFBQSxJQUVELFdBQVk7QUFDVixhQUFPLEtBQUs7QUFBQSxJQUNiO0FBQUEsSUFFRCxLQUFNLFNBQVM7QUFDYixNQUFBM0wsT0FBTSxtQkFBbUIsU0FBUyxLQUFLLFFBQVEsS0FBSztBQUVwRCxVQUFJLEtBQUssV0FBV2tOLFFBQU8sWUFBWUEsTUFBSztBQUMxQyxlQUFPO0FBQUEsTUFDUjtBQUVELFVBQUksT0FBTyxZQUFZLFVBQVU7QUFDL0IsWUFBSTtBQUNGLG9CQUFVLElBQUl2QixRQUFPLFNBQVMsS0FBSyxPQUFPO0FBQUEsUUFDM0MsU0FBUSxJQUFJO0FBQ1gsaUJBQU87QUFBQSxRQUNSO0FBQUEsTUFDRjtBQUVELGFBQU9pQixLQUFJLFNBQVMsS0FBSyxVQUFVLEtBQUssUUFBUSxLQUFLLE9BQU87QUFBQSxJQUM3RDtBQUFBLElBRUQsV0FBWSxNQUFNLFNBQVM7QUFDekIsVUFBSSxFQUFFLGdCQUFnQkssY0FBYTtBQUNqQyxjQUFNLElBQUksVUFBVSwwQkFBMEI7QUFBQSxNQUMvQztBQUVELFVBQUksS0FBSyxhQUFhLElBQUk7QUFDeEIsWUFBSSxLQUFLLFVBQVUsSUFBSTtBQUNyQixpQkFBTztBQUFBLFFBQ1I7QUFDRCxlQUFPLElBQUlGLE9BQU0sS0FBSyxPQUFPLE9BQU8sRUFBRSxLQUFLLEtBQUssS0FBSztBQUFBLE1BQzNELFdBQWUsS0FBSyxhQUFhLElBQUk7QUFDL0IsWUFBSSxLQUFLLFVBQVUsSUFBSTtBQUNyQixpQkFBTztBQUFBLFFBQ1I7QUFDRCxlQUFPLElBQUlBLE9BQU0sS0FBSyxPQUFPLE9BQU8sRUFBRSxLQUFLLEtBQUssTUFBTTtBQUFBLE1BQ3ZEO0FBRUQsZ0JBQVV6QixjQUFhLE9BQU87QUFHOUIsVUFBSSxRQUFRLHNCQUNULEtBQUssVUFBVSxjQUFjLEtBQUssVUFBVSxhQUFhO0FBQzFELGVBQU87QUFBQSxNQUNSO0FBQ0QsVUFBSSxDQUFDLFFBQVEsc0JBQ1YsS0FBSyxNQUFNLFdBQVcsUUFBUSxLQUFLLEtBQUssTUFBTSxXQUFXLFFBQVEsSUFBSTtBQUN0RSxlQUFPO0FBQUEsTUFDUjtBQUdELFVBQUksS0FBSyxTQUFTLFdBQVcsR0FBRyxLQUFLLEtBQUssU0FBUyxXQUFXLEdBQUcsR0FBRztBQUNsRSxlQUFPO0FBQUEsTUFDUjtBQUVELFVBQUksS0FBSyxTQUFTLFdBQVcsR0FBRyxLQUFLLEtBQUssU0FBUyxXQUFXLEdBQUcsR0FBRztBQUNsRSxlQUFPO0FBQUEsTUFDUjtBQUVELFVBQ0csS0FBSyxPQUFPLFlBQVksS0FBSyxPQUFPLFdBQ3JDLEtBQUssU0FBUyxTQUFTLEdBQUcsS0FBSyxLQUFLLFNBQVMsU0FBUyxHQUFHLEdBQUc7QUFDNUQsZUFBTztBQUFBLE1BQ1I7QUFFRCxVQUFJc0IsS0FBSSxLQUFLLFFBQVEsS0FBSyxLQUFLLFFBQVEsT0FBTyxLQUM1QyxLQUFLLFNBQVMsV0FBVyxHQUFHLEtBQUssS0FBSyxTQUFTLFdBQVcsR0FBRyxHQUFHO0FBQ2hFLGVBQU87QUFBQSxNQUNSO0FBRUQsVUFBSUEsS0FBSSxLQUFLLFFBQVEsS0FBSyxLQUFLLFFBQVEsT0FBTyxLQUM1QyxLQUFLLFNBQVMsV0FBVyxHQUFHLEtBQUssS0FBSyxTQUFTLFdBQVcsR0FBRyxHQUFHO0FBQ2hFLGVBQU87QUFBQSxNQUNSO0FBQ0QsYUFBTztBQUFBLElBQ1I7QUFBQSxFQUNGO0FBRUQsZUFBaUJLO0FBRWpCLFFBQU0zQixnQkFBZXZNO0FBQ3JCLFFBQU0sRUFBRSxRQUFRc00sS0FBSSxHQUFBMUUsR0FBRyxJQUFHckk7QUFDMUIsUUFBTXNPLE9BQU1yTztBQUNaLFFBQU15QixTQUFRRDtBQUNkLFFBQU00TCxVQUFTL0o7QUFDZixRQUFNbUwsU0FBUWxMLGFBQUE7OztBQzVJZCxNQUFNa0wsVUFBUWhPLGFBQTJCO0FBQ3pDLE1BQU1vTyxjQUFZLENBQUMsU0FBU0gsUUFBTyxZQUFZO0FBQzdDLE1BQUk7QUFDRixJQUFBQSxTQUFRLElBQUlELFFBQU1DLFFBQU8sT0FBTztBQUFBLEVBQ2pDLFNBQVEsSUFBSTtBQUNYLFdBQU87QUFBQSxFQUNSO0FBQ0QsU0FBT0EsT0FBTSxLQUFLLE9BQU87QUFDM0I7QUFDQSxJQUFBLGNBQWlCRztBQ1RqQixNQUFNSixVQUFRaE8sYUFBMkI7QUFHekMsTUFBTXFPLGtCQUFnQixDQUFDSixRQUFPLFlBQzVCLElBQUlELFFBQU1DLFFBQU8sT0FBTyxFQUFFLElBQ3ZCLElBQUksVUFBUSxLQUFLLElBQUksT0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEdBQUcsRUFBRSxLQUFNLEVBQUMsTUFBTSxHQUFHLENBQUM7QUFFbkUsSUFBQSxrQkFBaUJJO0FDUGpCLE1BQU16QixXQUFTNU07QUFDZixNQUFNZ08sVUFBUXpPLGFBQTJCO0FBRXpDLE1BQU0rTyxrQkFBZ0IsQ0FBQyxVQUFVTCxRQUFPLFlBQVk7QUFDbEQsTUFBSSxNQUFNO0FBQ1YsTUFBSSxRQUFRO0FBQ1osTUFBSSxXQUFXO0FBQ2YsTUFBSTtBQUNGLGVBQVcsSUFBSUQsUUFBTUMsUUFBTyxPQUFPO0FBQUEsRUFDcEMsU0FBUSxJQUFJO0FBQ1gsV0FBTztBQUFBLEVBQ1I7QUFDRCxXQUFTLFFBQVEsQ0FBQyxNQUFNO0FBQ3RCLFFBQUksU0FBUyxLQUFLLENBQUMsR0FBRztBQUVwQixVQUFJLENBQUMsT0FBTyxNQUFNLFFBQVEsQ0FBQyxNQUFNLElBQUk7QUFFbkMsY0FBTTtBQUNOLGdCQUFRLElBQUlyQixTQUFPLEtBQUssT0FBTztBQUFBLE1BQ2hDO0FBQUEsSUFDRjtBQUFBLEVBQ0wsQ0FBRztBQUNELFNBQU87QUFDVDtBQUNBLElBQUEsa0JBQWlCMEI7QUN4QmpCLE1BQU0xQixXQUFTNU07QUFDZixNQUFNZ08sVUFBUXpPLGFBQTJCO0FBQ3pDLE1BQU1nUCxrQkFBZ0IsQ0FBQyxVQUFVTixRQUFPLFlBQVk7QUFDbEQsTUFBSSxNQUFNO0FBQ1YsTUFBSSxRQUFRO0FBQ1osTUFBSSxXQUFXO0FBQ2YsTUFBSTtBQUNGLGVBQVcsSUFBSUQsUUFBTUMsUUFBTyxPQUFPO0FBQUEsRUFDcEMsU0FBUSxJQUFJO0FBQ1gsV0FBTztBQUFBLEVBQ1I7QUFDRCxXQUFTLFFBQVEsQ0FBQyxNQUFNO0FBQ3RCLFFBQUksU0FBUyxLQUFLLENBQUMsR0FBRztBQUVwQixVQUFJLENBQUMsT0FBTyxNQUFNLFFBQVEsQ0FBQyxNQUFNLEdBQUc7QUFFbEMsY0FBTTtBQUNOLGdCQUFRLElBQUlyQixTQUFPLEtBQUssT0FBTztBQUFBLE1BQ2hDO0FBQUEsSUFDRjtBQUFBLEVBQ0wsQ0FBRztBQUNELFNBQU87QUFDVDtBQUNBLElBQUEsa0JBQWlCMkI7QUN2QmpCLE1BQU0zQixXQUFTNU07QUFDZixNQUFNZ08sVUFBUXpPLGFBQTJCO0FBQ3pDLE1BQU1nTyxPQUFLL047QUFFWCxNQUFNZ1AsZUFBYSxDQUFDUCxRQUFPLFVBQVU7QUFDbkMsRUFBQUEsU0FBUSxJQUFJRCxRQUFNQyxRQUFPLEtBQUs7QUFFOUIsTUFBSSxTQUFTLElBQUlyQixTQUFPLE9BQU87QUFDL0IsTUFBSXFCLE9BQU0sS0FBSyxNQUFNLEdBQUc7QUFDdEIsV0FBTztBQUFBLEVBQ1I7QUFFRCxXQUFTLElBQUlyQixTQUFPLFNBQVM7QUFDN0IsTUFBSXFCLE9BQU0sS0FBSyxNQUFNLEdBQUc7QUFDdEIsV0FBTztBQUFBLEVBQ1I7QUFFRCxXQUFTO0FBQ1QsV0FBUyxJQUFJLEdBQUcsSUFBSUEsT0FBTSxJQUFJLFFBQVEsRUFBRSxHQUFHO0FBQ3pDLFVBQU0sY0FBY0EsT0FBTSxJQUFJLENBQUM7QUFFL0IsUUFBSSxTQUFTO0FBQ2IsZ0JBQVksUUFBUSxDQUFDUSxnQkFBZTtBQUVsQyxZQUFNLFVBQVUsSUFBSTdCLFNBQU82QixZQUFXLE9BQU8sT0FBTztBQUNwRCxjQUFRQSxZQUFXLFVBQVE7QUFBQSxRQUN6QixLQUFLO0FBQ0gsY0FBSSxRQUFRLFdBQVcsV0FBVyxHQUFHO0FBQ25DLG9CQUFRO0FBQUEsVUFDcEIsT0FBaUI7QUFDTCxvQkFBUSxXQUFXLEtBQUssQ0FBQztBQUFBLFVBQzFCO0FBQ0Qsa0JBQVEsTUFBTSxRQUFRLE9BQVE7QUFBQSxRQUVoQyxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQ0gsY0FBSSxDQUFDLFVBQVVsQixLQUFHLFNBQVMsTUFBTSxHQUFHO0FBQ2xDLHFCQUFTO0FBQUEsVUFDVjtBQUNEO0FBQUEsUUFDRixLQUFLO0FBQUEsUUFDTCxLQUFLO0FBRUg7QUFBQSxRQUVGO0FBQ0UsZ0JBQU0sSUFBSSxNQUFNLHlCQUF5QmtCLFlBQVcsUUFBUSxFQUFFO0FBQUEsTUFDakU7QUFBQSxJQUNQLENBQUs7QUFDRCxRQUFJLFdBQVcsQ0FBQyxVQUFVbEIsS0FBRyxRQUFRLE1BQU0sSUFBSTtBQUM3QyxlQUFTO0FBQUEsSUFDVjtBQUFBLEVBQ0Y7QUFFRCxNQUFJLFVBQVVVLE9BQU0sS0FBSyxNQUFNLEdBQUc7QUFDaEMsV0FBTztBQUFBLEVBQ1I7QUFFRCxTQUFPO0FBQ1Q7QUFDQSxJQUFBLGVBQWlCTztBQzVEakIsTUFBTVIsVUFBUWhPLGFBQTJCO0FBQ3pDLE1BQU0wTyxlQUFhLENBQUNULFFBQU8sWUFBWTtBQUNyQyxNQUFJO0FBR0YsV0FBTyxJQUFJRCxRQUFNQyxRQUFPLE9BQU8sRUFBRSxTQUFTO0FBQUEsRUFDM0MsU0FBUSxJQUFJO0FBQ1gsV0FBTztBQUFBLEVBQ1I7QUFDSDtBQUNBLElBQUF6RyxVQUFpQmtIO0FDVmpCLE1BQU05QixXQUFTNU07QUFDZixNQUFNa08sZUFBYTNPLGtCQUFnQztBQUNuRCxNQUFNLEVBQUU0TyxLQUFBQSxNQUFLLElBQUdEO0FBQ2hCLE1BQU1GLFVBQVF4TyxhQUEyQjtBQUN6QyxNQUFNNE8sY0FBWXBOO0FBQ2xCLE1BQU11TSxPQUFLMUs7QUFDWCxNQUFNMkssT0FBSzFLO0FBQ1gsTUFBTThLLFFBQU10SjtBQUNaLE1BQU1xSixRQUFNcEo7QUFFWixNQUFNb0ssWUFBVSxDQUFDLFNBQVNWLFFBQU8sTUFBTSxZQUFZO0FBQ2pELFlBQVUsSUFBSXJCLFNBQU8sU0FBUyxPQUFPO0FBQ3JDLEVBQUFxQixTQUFRLElBQUlELFFBQU1DLFFBQU8sT0FBTztBQUVoQyxNQUFJLE1BQU0sT0FBTyxNQUFNLE1BQU07QUFDN0IsVUFBUSxNQUFJO0FBQUEsSUFDVixLQUFLO0FBQ0gsYUFBT1Y7QUFDUCxjQUFRSztBQUNSLGFBQU9KO0FBQ1AsYUFBTztBQUNQLGNBQVE7QUFDUjtBQUFBLElBQ0YsS0FBSztBQUNILGFBQU9BO0FBQ1AsY0FBUUc7QUFDUixhQUFPSjtBQUNQLGFBQU87QUFDUCxjQUFRO0FBQ1I7QUFBQSxJQUNGO0FBQ0UsWUFBTSxJQUFJLFVBQVUsdUNBQXVDO0FBQUEsRUFDOUQ7QUFHRCxNQUFJYSxZQUFVLFNBQVNILFFBQU8sT0FBTyxHQUFHO0FBQ3RDLFdBQU87QUFBQSxFQUNSO0FBS0QsV0FBUyxJQUFJLEdBQUcsSUFBSUEsT0FBTSxJQUFJLFFBQVEsRUFBRSxHQUFHO0FBQ3pDLFVBQU0sY0FBY0EsT0FBTSxJQUFJLENBQUM7QUFFL0IsUUFBSSxPQUFPO0FBQ1gsUUFBSSxNQUFNO0FBRVYsZ0JBQVksUUFBUSxDQUFDUSxnQkFBZTtBQUNsQyxVQUFJQSxZQUFXLFdBQVdOLE9BQUs7QUFDN0IsUUFBQU0sY0FBYSxJQUFJUCxhQUFXLFNBQVM7QUFBQSxNQUN0QztBQUNELGFBQU8sUUFBUU87QUFDZixZQUFNLE9BQU9BO0FBQ2IsVUFBSSxLQUFLQSxZQUFXLFFBQVEsS0FBSyxRQUFRLE9BQU8sR0FBRztBQUNqRCxlQUFPQTtBQUFBLE1BQ2YsV0FBaUIsS0FBS0EsWUFBVyxRQUFRLElBQUksUUFBUSxPQUFPLEdBQUc7QUFDdkQsY0FBTUE7QUFBQSxNQUNQO0FBQUEsSUFDUCxDQUFLO0FBSUQsUUFBSSxLQUFLLGFBQWEsUUFBUSxLQUFLLGFBQWEsT0FBTztBQUNyRCxhQUFPO0FBQUEsSUFDUjtBQUlELFNBQUssQ0FBQyxJQUFJLFlBQVksSUFBSSxhQUFhLFNBQ25DLE1BQU0sU0FBUyxJQUFJLE1BQU0sR0FBRztBQUM5QixhQUFPO0FBQUEsSUFDYixXQUFlLElBQUksYUFBYSxTQUFTLEtBQUssU0FBUyxJQUFJLE1BQU0sR0FBRztBQUM5RCxhQUFPO0FBQUEsSUFDUjtBQUFBLEVBQ0Y7QUFDRCxTQUFPO0FBQ1Q7QUFFQSxJQUFBLFlBQWlCRTtBQzlFakIsTUFBTUEsWUFBVTNPO0FBQ2hCLE1BQU00TyxRQUFNLENBQUMsU0FBU1gsUUFBTyxZQUFZVSxVQUFRLFNBQVNWLFFBQU8sS0FBSyxPQUFPO0FBQzdFLElBQUEsUUFBaUJXO0FDSGpCLE1BQU1ELFlBQVUzTztBQUVoQixNQUFNNk8sUUFBTSxDQUFDLFNBQVNaLFFBQU8sWUFBWVUsVUFBUSxTQUFTVixRQUFPLEtBQUssT0FBTztBQUM3RSxJQUFBLFFBQWlCWTtBQ0hqQixNQUFNYixVQUFRaE8sYUFBMkI7QUFDekMsTUFBTThPLGVBQWEsQ0FBQyxJQUFJLElBQUksWUFBWTtBQUN0QyxPQUFLLElBQUlkLFFBQU0sSUFBSSxPQUFPO0FBQzFCLE9BQUssSUFBSUEsUUFBTSxJQUFJLE9BQU87QUFDMUIsU0FBTyxHQUFHLFdBQVcsSUFBSSxPQUFPO0FBQ2xDO0FBQ0EsSUFBQSxlQUFpQmM7QUNIakIsTUFBTVYsY0FBWXBPO0FBQ2xCLE1BQU00TCxZQUFVck07QUFDaEIsSUFBQSxXQUFpQixDQUFDLFVBQVUwTyxRQUFPLFlBQVk7QUFDN0MsUUFBTSxNQUFNLENBQUU7QUFDZCxNQUFJLFFBQVE7QUFDWixNQUFJLE9BQU87QUFDWCxRQUFNLElBQUksU0FBUyxLQUFLLENBQUMsR0FBRyxNQUFNckMsVUFBUSxHQUFHLEdBQUcsT0FBTyxDQUFDO0FBQ3hELGFBQVcsV0FBVyxHQUFHO0FBQ3ZCLFVBQU0sV0FBV3dDLFlBQVUsU0FBU0gsUUFBTyxPQUFPO0FBQ2xELFFBQUksVUFBVTtBQUNaLGFBQU87QUFDUCxVQUFJLENBQUMsT0FBTztBQUNWLGdCQUFRO0FBQUEsTUFDVDtBQUFBLElBQ1AsT0FBVztBQUNMLFVBQUksTUFBTTtBQUNSLFlBQUksS0FBSyxDQUFDLE9BQU8sSUFBSSxDQUFDO0FBQUEsTUFDdkI7QUFDRCxhQUFPO0FBQ1AsY0FBUTtBQUFBLElBQ1Q7QUFBQSxFQUNGO0FBQ0QsTUFBSSxPQUFPO0FBQ1QsUUFBSSxLQUFLLENBQUMsT0FBTyxJQUFJLENBQUM7QUFBQSxFQUN2QjtBQUVELFFBQU0sU0FBUyxDQUFFO0FBQ2pCLGFBQVcsQ0FBQyxLQUFLLEdBQUcsS0FBSyxLQUFLO0FBQzVCLFFBQUksUUFBUSxLQUFLO0FBQ2YsYUFBTyxLQUFLLEdBQUc7QUFBQSxJQUNoQixXQUFVLENBQUMsT0FBTyxRQUFRLEVBQUUsQ0FBQyxHQUFHO0FBQy9CLGFBQU8sS0FBSyxHQUFHO0FBQUEsSUFDckIsV0FBZSxDQUFDLEtBQUs7QUFDZixhQUFPLEtBQUssS0FBSyxHQUFHLEVBQUU7QUFBQSxJQUN2QixXQUFVLFFBQVEsRUFBRSxDQUFDLEdBQUc7QUFDdkIsYUFBTyxLQUFLLEtBQUssR0FBRyxFQUFFO0FBQUEsSUFDNUIsT0FBVztBQUNMLGFBQU8sS0FBSyxHQUFHLEdBQUcsTUFBTSxHQUFHLEVBQUU7QUFBQSxJQUM5QjtBQUFBLEVBQ0Y7QUFDRCxRQUFNLGFBQWEsT0FBTyxLQUFLLE1BQU07QUFDckMsUUFBTSxXQUFXLE9BQU9BLE9BQU0sUUFBUSxXQUFXQSxPQUFNLE1BQU0sT0FBT0EsTUFBSztBQUN6RSxTQUFPLFdBQVcsU0FBUyxTQUFTLFNBQVMsYUFBYUE7QUFDNUQ7QUM5Q0EsTUFBTUQsVUFBUWhPLGFBQThCO0FBQzVDLE1BQU1rTyxlQUFhM08sa0JBQW1DO0FBQ3RELE1BQU0sRUFBRSxJQUFLLElBQUcyTztBQUNoQixNQUFNRSxjQUFZNU87QUFDbEIsTUFBTW9NLFlBQVU1SztBQXNDaEIsTUFBTStOLFdBQVMsQ0FBQyxLQUFLLEtBQUssVUFBVSxDQUFBLE1BQU87QUFDekMsTUFBSSxRQUFRLEtBQUs7QUFDZixXQUFPO0FBQUEsRUFDUjtBQUVELFFBQU0sSUFBSWYsUUFBTSxLQUFLLE9BQU87QUFDNUIsUUFBTSxJQUFJQSxRQUFNLEtBQUssT0FBTztBQUM1QixNQUFJLGFBQWE7QUFFakI7QUFBTyxlQUFXLGFBQWEsSUFBSSxLQUFLO0FBQ3RDLGlCQUFXLGFBQWEsSUFBSSxLQUFLO0FBQy9CLGNBQU0sUUFBUSxhQUFhLFdBQVcsV0FBVyxPQUFPO0FBQ3hELHFCQUFhLGNBQWMsVUFBVTtBQUNyQyxZQUFJLE9BQU87QUFDVCxtQkFBUztBQUFBLFFBQ1Y7QUFBQSxNQUNGO0FBS0QsVUFBSSxZQUFZO0FBQ2QsZUFBTztBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQ0QsU0FBTztBQUNUO0FBRUEsTUFBTSwrQkFBK0IsQ0FBQyxJQUFJRSxhQUFXLFdBQVcsQ0FBQztBQUNqRSxNQUFNLGlCQUFpQixDQUFDLElBQUlBLGFBQVcsU0FBUyxDQUFDO0FBRWpELE1BQU0sZUFBZSxDQUFDLEtBQUssS0FBSyxZQUFZO0FBQzFDLE1BQUksUUFBUSxLQUFLO0FBQ2YsV0FBTztBQUFBLEVBQ1I7QUFFRCxNQUFJLElBQUksV0FBVyxLQUFLLElBQUksQ0FBQyxFQUFFLFdBQVcsS0FBSztBQUM3QyxRQUFJLElBQUksV0FBVyxLQUFLLElBQUksQ0FBQyxFQUFFLFdBQVcsS0FBSztBQUM3QyxhQUFPO0FBQUEsSUFDYixXQUFlLFFBQVEsbUJBQW1CO0FBQ3BDLFlBQU07QUFBQSxJQUNaLE9BQVc7QUFDTCxZQUFNO0FBQUEsSUFDUDtBQUFBLEVBQ0Y7QUFFRCxNQUFJLElBQUksV0FBVyxLQUFLLElBQUksQ0FBQyxFQUFFLFdBQVcsS0FBSztBQUM3QyxRQUFJLFFBQVEsbUJBQW1CO0FBQzdCLGFBQU87QUFBQSxJQUNiLE9BQVc7QUFDTCxZQUFNO0FBQUEsSUFDUDtBQUFBLEVBQ0Y7QUFFRCxRQUFNLFFBQVEsb0JBQUksSUFBSztBQUN2QixNQUFJWCxLQUFJQztBQUNSLGFBQVcsS0FBSyxLQUFLO0FBQ25CLFFBQUksRUFBRSxhQUFhLE9BQU8sRUFBRSxhQUFhLE1BQU07QUFDN0MsTUFBQUQsTUFBSyxTQUFTQSxLQUFJLEdBQUcsT0FBTztBQUFBLElBQ2xDLFdBQWUsRUFBRSxhQUFhLE9BQU8sRUFBRSxhQUFhLE1BQU07QUFDcEQsTUFBQUMsTUFBSyxRQUFRQSxLQUFJLEdBQUcsT0FBTztBQUFBLElBQ2pDLE9BQVc7QUFDTCxZQUFNLElBQUksRUFBRSxNQUFNO0FBQUEsSUFDbkI7QUFBQSxFQUNGO0FBRUQsTUFBSSxNQUFNLE9BQU8sR0FBRztBQUNsQixXQUFPO0FBQUEsRUFDUjtBQUVELE1BQUk7QUFDSixNQUFJRCxPQUFNQyxLQUFJO0FBQ1osZUFBVzVCLFVBQVEyQixJQUFHLFFBQVFDLElBQUcsUUFBUSxPQUFPO0FBQ2hELFFBQUksV0FBVyxHQUFHO0FBQ2hCLGFBQU87QUFBQSxJQUNiLFdBQWUsYUFBYSxNQUFNRCxJQUFHLGFBQWEsUUFBUUMsSUFBRyxhQUFhLE9BQU87QUFDM0UsYUFBTztBQUFBLElBQ1I7QUFBQSxFQUNGO0FBR0QsYUFBV0MsT0FBTSxPQUFPO0FBQ3RCLFFBQUlGLE9BQU0sQ0FBQ2EsWUFBVVgsS0FBSSxPQUFPRixHQUFFLEdBQUcsT0FBTyxHQUFHO0FBQzdDLGFBQU87QUFBQSxJQUNSO0FBRUQsUUFBSUMsT0FBTSxDQUFDWSxZQUFVWCxLQUFJLE9BQU9ELEdBQUUsR0FBRyxPQUFPLEdBQUc7QUFDN0MsYUFBTztBQUFBLElBQ1I7QUFFRCxlQUFXLEtBQUssS0FBSztBQUNuQixVQUFJLENBQUNZLFlBQVVYLEtBQUksT0FBTyxDQUFDLEdBQUcsT0FBTyxHQUFHO0FBQ3RDLGVBQU87QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUVELFdBQU87QUFBQSxFQUNSO0FBRUQsTUFBSSxRQUFRO0FBQ1osTUFBSSxVQUFVO0FBR2QsTUFBSSxlQUFlRCxPQUNqQixDQUFDLFFBQVEscUJBQ1RBLElBQUcsT0FBTyxXQUFXLFNBQVNBLElBQUcsU0FBUztBQUM1QyxNQUFJLGVBQWVELE9BQ2pCLENBQUMsUUFBUSxxQkFDVEEsSUFBRyxPQUFPLFdBQVcsU0FBU0EsSUFBRyxTQUFTO0FBRTVDLE1BQUksZ0JBQWdCLGFBQWEsV0FBVyxXQUFXLEtBQ25EQyxJQUFHLGFBQWEsT0FBTyxhQUFhLFdBQVcsQ0FBQyxNQUFNLEdBQUc7QUFDM0QsbUJBQWU7QUFBQSxFQUNoQjtBQUVELGFBQVcsS0FBSyxLQUFLO0FBQ25CLGVBQVcsWUFBWSxFQUFFLGFBQWEsT0FBTyxFQUFFLGFBQWE7QUFDNUQsZUFBVyxZQUFZLEVBQUUsYUFBYSxPQUFPLEVBQUUsYUFBYTtBQUM1RCxRQUFJRCxLQUFJO0FBQ04sVUFBSSxjQUFjO0FBQ2hCLFlBQUksRUFBRSxPQUFPLGNBQWMsRUFBRSxPQUFPLFdBQVcsVUFDM0MsRUFBRSxPQUFPLFVBQVUsYUFBYSxTQUNoQyxFQUFFLE9BQU8sVUFBVSxhQUFhLFNBQ2hDLEVBQUUsT0FBTyxVQUFVLGFBQWEsT0FBTztBQUN6Qyx5QkFBZTtBQUFBLFFBQ2hCO0FBQUEsTUFDRjtBQUNELFVBQUksRUFBRSxhQUFhLE9BQU8sRUFBRSxhQUFhLE1BQU07QUFDN0MsaUJBQVMsU0FBU0EsS0FBSSxHQUFHLE9BQU87QUFDaEMsWUFBSSxXQUFXLEtBQUssV0FBV0EsS0FBSTtBQUNqQyxpQkFBTztBQUFBLFFBQ1I7QUFBQSxNQUNGLFdBQVVBLElBQUcsYUFBYSxRQUFRLENBQUNhLFlBQVViLElBQUcsUUFBUSxPQUFPLENBQUMsR0FBRyxPQUFPLEdBQUc7QUFDNUUsZUFBTztBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQ0QsUUFBSUMsS0FBSTtBQUNOLFVBQUksY0FBYztBQUNoQixZQUFJLEVBQUUsT0FBTyxjQUFjLEVBQUUsT0FBTyxXQUFXLFVBQzNDLEVBQUUsT0FBTyxVQUFVLGFBQWEsU0FDaEMsRUFBRSxPQUFPLFVBQVUsYUFBYSxTQUNoQyxFQUFFLE9BQU8sVUFBVSxhQUFhLE9BQU87QUFDekMseUJBQWU7QUFBQSxRQUNoQjtBQUFBLE1BQ0Y7QUFDRCxVQUFJLEVBQUUsYUFBYSxPQUFPLEVBQUUsYUFBYSxNQUFNO0FBQzdDLGdCQUFRLFFBQVFBLEtBQUksR0FBRyxPQUFPO0FBQzlCLFlBQUksVUFBVSxLQUFLLFVBQVVBLEtBQUk7QUFDL0IsaUJBQU87QUFBQSxRQUNSO0FBQUEsTUFDRixXQUFVQSxJQUFHLGFBQWEsUUFBUSxDQUFDWSxZQUFVWixJQUFHLFFBQVEsT0FBTyxDQUFDLEdBQUcsT0FBTyxHQUFHO0FBQzVFLGVBQU87QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUNELFFBQUksQ0FBQyxFQUFFLGFBQWFBLE9BQU1ELFFBQU8sYUFBYSxHQUFHO0FBQy9DLGFBQU87QUFBQSxJQUNSO0FBQUEsRUFDRjtBQUtELE1BQUlBLE9BQU0sWUFBWSxDQUFDQyxPQUFNLGFBQWEsR0FBRztBQUMzQyxXQUFPO0FBQUEsRUFDUjtBQUVELE1BQUlBLE9BQU0sWUFBWSxDQUFDRCxPQUFNLGFBQWEsR0FBRztBQUMzQyxXQUFPO0FBQUEsRUFDUjtBQUtELE1BQUksZ0JBQWdCLGNBQWM7QUFDaEMsV0FBTztBQUFBLEVBQ1I7QUFFRCxTQUFPO0FBQ1Q7QUFHQSxNQUFNLFdBQVcsQ0FBQyxHQUFHLEdBQUcsWUFBWTtBQUNsQyxNQUFJLENBQUMsR0FBRztBQUNOLFdBQU87QUFBQSxFQUNSO0FBQ0QsUUFBTSxPQUFPM0IsVUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLE9BQU87QUFDaEQsU0FBTyxPQUFPLElBQUksSUFDZCxPQUFPLElBQUksSUFDWCxFQUFFLGFBQWEsT0FBTyxFQUFFLGFBQWEsT0FBTyxJQUM1QztBQUNOO0FBR0EsTUFBTSxVQUFVLENBQUMsR0FBRyxHQUFHLFlBQVk7QUFDakMsTUFBSSxDQUFDLEdBQUc7QUFDTixXQUFPO0FBQUEsRUFDUjtBQUNELFFBQU0sT0FBT0EsVUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLE9BQU87QUFDaEQsU0FBTyxPQUFPLElBQUksSUFDZCxPQUFPLElBQUksSUFDWCxFQUFFLGFBQWEsT0FBTyxFQUFFLGFBQWEsT0FBTyxJQUM1QztBQUNOO0FBRUEsSUFBQSxXQUFpQm1EO0FDclBqQixNQUFNLGFBQWEvTztBQUNuQixNQUFNLFlBQVlUO0FBQ2xCLE1BQU1xTixVQUFTcE47QUFDZixNQUFNLGNBQWN3QjtBQUNwQixNQUFNLFFBQVE2QjtBQUNkLE1BQU0sUUFBUUM7QUFDZCxNQUFNLFFBQVF3QjtBQUNkLE1BQU0sTUFBTUM7QUFDWixNQUFNLE9BQU9jO0FBQ2IsTUFBTSxRQUFRQztBQUNkLE1BQU0sUUFBUXNEO0FBQ2QsTUFBTSxRQUFRcUM7QUFDZCxNQUFNLGFBQWFDO0FBQ25CLE1BQU0sVUFBVUM7QUFDaEIsTUFBTSxXQUFXQztBQUNqQixNQUFNLGVBQWVDO0FBQ3JCLE1BQU0sZUFBZTJEO0FBQ3JCLE1BQU0sT0FBT0M7QUFDYixNQUFNLFFBQVFDO0FBQ2QsTUFBTSxLQUFLQztBQUNYLE1BQU0sS0FBS0M7QUFDWCxNQUFNLEtBQUtDO0FBQ1gsTUFBTSxNQUFNQztBQUNaLE1BQU0sTUFBTUM7QUFDWixNQUFNLE1BQU1DO0FBQ1osTUFBTSxNQUFNQztBQUNaLE1BQU0sU0FBU0M7QUFDZixNQUFNLGFBQWFDLGtCQUErQjtBQUNsRCxNQUFNLFFBQVFDLGFBQTBCO0FBQ3hDLE1BQU0sWUFBWUM7QUFDbEIsTUFBTSxnQkFBZ0JDO0FBQ3RCLE1BQU0sZ0JBQWdCQztBQUN0QixNQUFNLGdCQUFnQkM7QUFDdEIsTUFBTSxhQUFhQztBQUNuQixNQUFNLGFBQWFDO0FBQ25CLE1BQU0sVUFBVUM7QUFDaEIsTUFBTSxNQUFNQztBQUNaLE1BQU0sTUFBTUM7QUFDWixNQUFNLGFBQWFDO0FBQ25CLE1BQU0sZ0JBQWdCQztBQUN0QixNQUFNLFNBQVNDO0FBQ2YsSUFBQSxTQUFpQjtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBLFFBQUE1RDtBQUFBLEVBQ0EsSUFBSSxXQUFXO0FBQUEsRUFDZixLQUFLLFdBQVc7QUFBQSxFQUNoQixRQUFRLFdBQVc7QUFBQSxFQUNuQixxQkFBcUIsVUFBVTtBQUFBLEVBQy9CLGVBQWUsVUFBVTtBQUFBLEVBQ3pCLG9CQUFvQixZQUFZO0FBQUEsRUFDaEMscUJBQXFCLFlBQVk7QUFDbkM7OztBQ3RGQSxNQUFNWCxZQUFVLENBQUMsSUFBSSxTQUFTO0FBQzdCLGFBQVcsUUFBUSxRQUFRLFFBQVEsSUFBSSxHQUFHO0FBQ3pDLFdBQU8sZUFBZSxJQUFJLE1BQU0sT0FBTyx5QkFBeUIsTUFBTSxJQUFJLENBQUM7QUFBQSxFQUMzRTtBQUVELFNBQU87QUFDUjtBQUVBd0UsVUFBYyxVQUFHeEU7QUFFakJ3RSxVQUFBLFFBQUEsVUFBeUJ4RTs7QUNYekIsTUFBTSxVQUFVak07QUFFaEIsTUFBTSxrQkFBa0Isb0JBQUk7QUFFNUIsTUFBTSxVQUFVLENBQUMsV0FBVyxVQUFVLE9BQU87QUFDNUMsTUFBSSxPQUFPLGNBQWMsWUFBWTtBQUNwQyxVQUFNLElBQUksVUFBVSxxQkFBcUI7QUFBQSxFQUN6QztBQUVELE1BQUk7QUFDSixNQUFJLFlBQVk7QUFDaEIsUUFBTSxlQUFlLFVBQVUsZUFBZSxVQUFVLFFBQVE7QUFFaEUsUUFBTTBRLFdBQVUsWUFBYSxZQUFZO0FBQ3hDLG9CQUFnQixJQUFJQSxVQUFTLEVBQUUsU0FBUztBQUV4QyxRQUFJLGNBQWMsR0FBRztBQUNwQixvQkFBYyxVQUFVLE1BQU0sTUFBTSxVQUFVO0FBQzlDLGtCQUFZO0FBQUEsSUFDZixXQUFhLFFBQVEsVUFBVSxNQUFNO0FBQ2xDLFlBQU0sSUFBSSxNQUFNLGNBQWMsWUFBWSw0QkFBNEI7QUFBQSxJQUN0RTtBQUVELFdBQU87QUFBQSxFQUNUO0FBRUMsVUFBUUEsVUFBUyxTQUFTO0FBQzFCLGtCQUFnQixJQUFJQSxVQUFTLFNBQVM7QUFFdEMsU0FBT0E7QUFDUjtBQUVBQyxVQUFjLFVBQUc7QUFFS0EsVUFBQSxRQUFBLFVBQUc7QUFFREEsVUFBQSxRQUFBLFlBQUcsZUFBYTtBQUN2QyxNQUFJLENBQUMsZ0JBQWdCLElBQUksU0FBUyxHQUFHO0FBQ3BDLFVBQU0sSUFBSSxNQUFNLHdCQUF3QixVQUFVLElBQUksOENBQThDO0FBQUEsRUFDcEc7QUFFRCxTQUFPLGdCQUFnQixJQUFJLFNBQVM7QUFDckM7OztBQzFDQSxNQUFJLHlCQUEwQjVILGtCQUFRQSxlQUFLLDBCQUEyQixTQUFVLFVBQVUsT0FBTyxPQUFPLE1BQU0sR0FBRztBQUM3RyxRQUFJLFNBQVM7QUFBSyxZQUFNLElBQUksVUFBVSxnQ0FBZ0M7QUFDdEUsUUFBSSxTQUFTLE9BQU8sQ0FBQztBQUFHLFlBQU0sSUFBSSxVQUFVLCtDQUErQztBQUMzRixRQUFJLE9BQU8sVUFBVSxhQUFhLGFBQWEsU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLElBQUksUUFBUTtBQUFHLFlBQU0sSUFBSSxVQUFVLHlFQUF5RTtBQUNoTCxXQUFRLFNBQVMsTUFBTSxFQUFFLEtBQUssVUFBVSxLQUFLLElBQUksSUFBSSxFQUFFLFFBQVEsUUFBUSxNQUFNLElBQUksVUFBVSxLQUFLLEdBQUk7QUFBQSxFQUN4RztBQUNBLE1BQUkseUJBQTBCQSxrQkFBUUEsZUFBSywwQkFBMkIsU0FBVSxVQUFVLE9BQU8sTUFBTSxHQUFHO0FBQ3RHLFFBQUksU0FBUyxPQUFPLENBQUM7QUFBRyxZQUFNLElBQUksVUFBVSwrQ0FBK0M7QUFDM0YsUUFBSSxPQUFPLFVBQVUsYUFBYSxhQUFhLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxJQUFJLFFBQVE7QUFBRyxZQUFNLElBQUksVUFBVSwwRUFBMEU7QUFDakwsV0FBTyxTQUFTLE1BQU0sSUFBSSxTQUFTLE1BQU0sRUFBRSxLQUFLLFFBQVEsSUFBSSxJQUFJLEVBQUUsUUFBUSxNQUFNLElBQUksUUFBUTtBQUFBLEVBQ2hHO0FBQ0EsTUFBSSxJQUFJO0FBQ1IsTUFBSSxpQkFBaUIscUJBQXFCLGVBQWU7QUFDekQsU0FBTyxlQUFjakgsVUFBVSxjQUFjLEVBQUUsT0FBTyxLQUFJLENBQUU7QUFDNUQsUUFBTTJFLFVBQVN6RztBQUNmLFFBQU1LLE1BQUtkO0FBQ1gsUUFBTWUsUUFBT2Q7QUFDYixRQUFNLFNBQVN3QjtBQUNmLFFBQU0sU0FBUzZCO0FBQ2YsUUFBTSxXQUFXQztBQUNqQixRQUFNOE4sWUFBVXRNO0FBQ2hCLFFBQU11TSxTQUFRdE07QUFDZCxRQUFNdU0sWUFBV3pMO0FBQ2pCLFFBQU0sYUFBYUM7QUFDbkIsUUFBTSxRQUFRc0Q7QUFDZCxRQUFNLGdCQUFnQnFDO0FBQ3RCLFFBQU04RixlQUFhN0Y7QUFDbkIsUUFBTXlCLFlBQVN4QjtBQUNmLFFBQU11RixXQUFVdEY7QUFDaEIsUUFBTSxzQkFBc0I7QUFDNUIsUUFBTSxvQkFBb0IsTUFBTTtBQUM1QixXQUFPLHVCQUFPLE9BQU8sSUFBSTtBQUFBLEVBQzdCO0FBQ0EsUUFBTSxVQUFVLENBQUMsU0FBUztBQUN0QixXQUFPLFNBQVMsVUFBYSxTQUFTO0FBQUEsRUFDMUM7QUFDQSxNQUFJLFlBQVk7QUFDaEIsTUFBSTtBQUlBLFdBQU8sUUFBUSxNQUFNLFVBQVU7QUFDL0IsZ0JBQVk5SyxNQUFLLFNBQVMsTUFBTSxLQUFLcUwsUUFBTyxZQUFZLFFBQVEsT0FBTyxTQUFTLFNBQVMsR0FBRyxjQUFjLFFBQVEsT0FBTyxTQUFTLEtBQUssR0FBRztBQUFBLEVBQzdJLFNBQ00sSUFBSTtBQUFBLEVBQUc7QUFDZCxRQUFNLGlCQUFpQixDQUFDLEtBQUssVUFBVTtBQUNuQyxVQUFNLGVBQWUsb0JBQUksSUFBSTtBQUFBLE1BQ3pCO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNSLENBQUs7QUFDRCxVQUFNdkgsUUFBTyxPQUFPO0FBQ3BCLFFBQUksYUFBYSxJQUFJQSxLQUFJLEdBQUc7QUFDeEIsWUFBTSxJQUFJLFVBQVUsNkJBQTZCQSxLQUFJLGdCQUFnQixHQUFHLGlEQUFpRDtBQUFBLElBQzVIO0FBQUEsRUFDTDtBQUNBLFFBQU0sZUFBZTtBQUNyQixRQUFNLGdCQUFnQixHQUFHLFlBQVk7QUFBQSxFQUNyQyxNQUFNNE0sTUFBSztBQUFBLElBQ1AsWUFBWSxpQkFBaUIsSUFBSTtBQUM3QixVQUFJN0k7QUFDSixzQkFBZ0IsSUFBSSxNQUFNLE1BQU07QUFDaEMsMEJBQW9CLElBQUksTUFBTSxNQUFNO0FBQ3BDLG9CQUFjLElBQUksTUFBTSxNQUFNO0FBQzlCLDBCQUFvQixJQUFJLE1BQU0sQ0FBQSxDQUFFO0FBQ2hDLFdBQUssZUFBZSxXQUFTLEtBQUssTUFBTSxLQUFLO0FBQzdDLFdBQUssYUFBYSxXQUFTLEtBQUssVUFBVSxPQUFPLFFBQVcsR0FBSTtBQUNoRSxZQUFNLFVBQVU7QUFBQSxRQUNaLFlBQVk7QUFBQSxRQUNaLGVBQWU7QUFBQSxRQUNmLGVBQWU7QUFBQSxRQUNmLG9CQUFvQjtBQUFBLFFBQ3BCLCtCQUErQjtBQUFBLFFBQy9CLGdCQUFnQjtBQUFBLFFBQ2hCLEdBQUc7QUFBQSxNQUNmO0FBQ1EsWUFBTSxpQkFBaUJ1SSxTQUFRLE1BQU07QUFDakMsY0FBTSxjQUFjRyxPQUFNLEtBQUssRUFBRSxLQUFLLFVBQVMsQ0FBRTtBQUdqRCxjQUFNLGNBQWMsZUFBZSxLQUFLLE1BQU14USxJQUFHLGFBQWEsYUFBYSxNQUFNLENBQUM7QUFDbEYsZUFBTyxnQkFBZ0IsUUFBUSxnQkFBZ0IsU0FBUyxjQUFjO01BQ2xGLENBQVM7QUFDRCxVQUFJLENBQUMsUUFBUSxLQUFLO0FBQ2QsWUFBSSxDQUFDLFFBQVEsYUFBYTtBQUN0QixrQkFBUSxjQUFjLGVBQWdCLEVBQUM7QUFBQSxRQUMxQztBQUNELFlBQUksQ0FBQyxRQUFRLGFBQWE7QUFDdEIsZ0JBQU0sSUFBSSxNQUFNLDhFQUE4RTtBQUFBLFFBQ2pHO0FBQ0QsZ0JBQVEsTUFBTXlRLFVBQVMsUUFBUSxhQUFhLEVBQUUsUUFBUSxRQUFRLGVBQWUsRUFBRTtBQUFBLE1BQ2xGO0FBQ0QsNkJBQXVCLE1BQU0sZUFBZSxTQUFTLEdBQUc7QUFDeEQsVUFBSSxRQUFRLFFBQVE7QUFDaEIsWUFBSSxPQUFPLFFBQVEsV0FBVyxVQUFVO0FBQ3BDLGdCQUFNLElBQUksVUFBVSx3Q0FBd0M7QUFBQSxRQUMvRDtBQUNELGNBQU0vRSxPQUFNLElBQUksTUFBTSxRQUFRO0FBQUEsVUFDMUIsV0FBVztBQUFBLFVBQ1gsYUFBYTtBQUFBLFFBQzdCLENBQWE7QUFDRCxZQUFJLGNBQWMsU0FBU0EsSUFBRztBQUM5QixjQUFNN0UsVUFBUztBQUFBLFVBQ1gsTUFBTTtBQUFBLFVBQ04sWUFBWSxRQUFRO0FBQUEsUUFDcEM7QUFDWSwrQkFBdUIsTUFBTSxpQkFBaUI2RSxLQUFJLFFBQVE3RSxPQUFNLEdBQUcsR0FBRztBQUN0RSxtQkFBVyxDQUFDLEtBQUssS0FBSyxLQUFLLE9BQU8sUUFBUSxRQUFRLE1BQU0sR0FBRztBQUN2RCxjQUFJLFVBQVUsUUFBUSxVQUFVLFNBQVMsU0FBUyxNQUFNLFNBQVM7QUFDN0QsbUNBQXVCLE1BQU0scUJBQXFCLEdBQUcsRUFBRSxHQUFHLElBQUksTUFBTTtBQUFBLFVBQ3ZFO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFDRCxVQUFJLFFBQVEsVUFBVTtBQUNsQiwrQkFBdUIsTUFBTSxxQkFBcUI7QUFBQSxVQUM5QyxHQUFHLHVCQUF1QixNQUFNLHFCQUFxQixHQUFHO0FBQUEsVUFDeEQsR0FBRyxRQUFRO0FBQUEsUUFDZCxHQUFFLEdBQUc7QUFBQSxNQUNUO0FBQ0QsVUFBSSxRQUFRLFdBQVc7QUFDbkIsYUFBSyxhQUFhLFFBQVE7QUFBQSxNQUM3QjtBQUNELFVBQUksUUFBUSxhQUFhO0FBQ3JCLGFBQUssZUFBZSxRQUFRO0FBQUEsTUFDL0I7QUFDRCxXQUFLLFNBQVMsSUFBSSxTQUFTLGFBQVk7QUFDdkMsNkJBQXVCLE1BQU0scUJBQXFCLFFBQVEsZUFBZSxHQUFHO0FBQzVFLFlBQU0sZ0JBQWdCLFFBQVEsZ0JBQWdCLElBQUksUUFBUSxhQUFhLEtBQUs7QUFDNUUsV0FBSyxPQUFPNUcsTUFBSyxRQUFRLFFBQVEsS0FBSyxJQUFJNkgsTUFBSyxRQUFRLGdCQUFnQixRQUFRQSxRQUFPLFNBQVNBLE1BQUssUUFBUSxHQUFHLGFBQWEsRUFBRTtBQUM5SCxZQUFNLFlBQVksS0FBSztBQUN2QixZQUFNOEksU0FBUSxPQUFPLE9BQU8sa0JBQW1CLEdBQUUsUUFBUSxVQUFVLFNBQVM7QUFDNUUsV0FBSyxVQUFVQSxNQUFLO0FBQ3BCLFVBQUk7QUFDQSxlQUFPLFVBQVUsV0FBV0EsTUFBSztBQUFBLE1BQ3BDLFNBQ01DLEtBQUk7QUFDUCxhQUFLLFFBQVFEO0FBQUEsTUFDaEI7QUFDRCxVQUFJLFFBQVEsT0FBTztBQUNmLGFBQUssT0FBTTtBQUFBLE1BQ2Q7QUFDRCxVQUFJLFFBQVEsWUFBWTtBQUNwQixZQUFJLENBQUMsUUFBUSxnQkFBZ0I7QUFDekIsa0JBQVEsaUJBQWlCLGVBQWdCLEVBQUM7QUFBQSxRQUM3QztBQUNELFlBQUksQ0FBQyxRQUFRLGdCQUFnQjtBQUN6QixnQkFBTSxJQUFJLE1BQU0sb0ZBQW9GO0FBQUEsUUFDdkc7QUFDRCxhQUFLLFNBQVMsUUFBUSxZQUFZLFFBQVEsZ0JBQWdCLFFBQVEsbUJBQW1CO0FBQUEsTUFDeEY7QUFBQSxJQUNKO0FBQUEsSUFDRCxJQUFJLEtBQUssY0FBYztBQUNuQixVQUFJLHVCQUF1QixNQUFNLGVBQWUsR0FBRyxFQUFFLCtCQUErQjtBQUNoRixlQUFPLEtBQUssS0FBSyxLQUFLLFlBQVk7QUFBQSxNQUNyQztBQUNELFlBQU0sRUFBRSxPQUFBQSxPQUFPLElBQUc7QUFDbEIsYUFBTyxPQUFPQSxTQUFRQSxPQUFNLEdBQUcsSUFBSTtBQUFBLElBQ3RDO0FBQUEsSUFDRCxJQUFJLEtBQUssT0FBTztBQUNaLFVBQUksT0FBTyxRQUFRLFlBQVksT0FBTyxRQUFRLFVBQVU7QUFDcEQsY0FBTSxJQUFJLFVBQVUsZ0VBQWdFLE9BQU8sR0FBRyxFQUFFO0FBQUEsTUFDbkc7QUFDRCxVQUFJLE9BQU8sUUFBUSxZQUFZLFVBQVUsUUFBVztBQUNoRCxjQUFNLElBQUksVUFBVSxnQ0FBZ0M7QUFBQSxNQUN2RDtBQUNELFVBQUksS0FBSyxxQkFBcUIsR0FBRyxHQUFHO0FBQ2hDLGNBQU0sSUFBSSxVQUFVLHdCQUF3QixZQUFZLCtEQUErRDtBQUFBLE1BQzFIO0FBQ0QsWUFBTSxFQUFFLE9BQUFBLE9BQU8sSUFBRztBQUNsQixZQUFNLE1BQU0sQ0FBQ0UsTUFBS0MsV0FBVTtBQUN4Qix1QkFBZUQsTUFBS0MsTUFBSztBQUN6QixZQUFJLHVCQUF1QixNQUFNLGVBQWUsR0FBRyxFQUFFLCtCQUErQjtBQUNoRlIsb0JBQVEsSUFBSUssUUFBT0UsTUFBS0MsTUFBSztBQUFBLFFBQ2hDLE9BQ0k7QUFDRCxVQUFBSCxPQUFNRSxJQUFHLElBQUlDO0FBQUEsUUFDaEI7QUFBQSxNQUNiO0FBQ1EsVUFBSSxPQUFPLFFBQVEsVUFBVTtBQUN6QixjQUFNLFNBQVM7QUFDZixtQkFBVyxDQUFDRCxNQUFLQyxNQUFLLEtBQUssT0FBTyxRQUFRLE1BQU0sR0FBRztBQUMvQyxjQUFJRCxNQUFLQyxNQUFLO0FBQUEsUUFDakI7QUFBQSxNQUNKLE9BQ0k7QUFDRCxZQUFJLEtBQUssS0FBSztBQUFBLE1BQ2pCO0FBQ0QsV0FBSyxRQUFRSDtBQUFBLElBQ2hCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBTUQsSUFBSSxLQUFLO0FBQ0wsVUFBSSx1QkFBdUIsTUFBTSxlQUFlLEdBQUcsRUFBRSwrQkFBK0I7QUFDaEYsZUFBT0wsVUFBUSxJQUFJLEtBQUssT0FBTyxHQUFHO0FBQUEsTUFDckM7QUFDRCxhQUFPLE9BQU8sS0FBSztBQUFBLElBQ3RCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQVFELFNBQVMsTUFBTTtBQUNYLGlCQUFXLE9BQU8sTUFBTTtBQUNwQixZQUFJLFFBQVEsdUJBQXVCLE1BQU0scUJBQXFCLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRztBQUN0RSxlQUFLLElBQUksS0FBSyx1QkFBdUIsTUFBTSxxQkFBcUIsR0FBRyxFQUFFLEdBQUcsQ0FBQztBQUFBLFFBQzVFO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFNRCxPQUFPLEtBQUs7QUFDUixZQUFNLEVBQUUsT0FBQUssT0FBTyxJQUFHO0FBQ2xCLFVBQUksdUJBQXVCLE1BQU0sZUFBZSxHQUFHLEVBQUUsK0JBQStCO0FBQ2hGTCxrQkFBUSxPQUFPSyxRQUFPLEdBQUc7QUFBQSxNQUM1QixPQUNJO0FBRUQsZUFBT0EsT0FBTSxHQUFHO0FBQUEsTUFDbkI7QUFDRCxXQUFLLFFBQVFBO0FBQUEsSUFDaEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFNRCxRQUFRO0FBQ0osV0FBSyxRQUFRO0FBQ2IsaUJBQVcsT0FBTyxPQUFPLEtBQUssdUJBQXVCLE1BQU0scUJBQXFCLEdBQUcsQ0FBQyxHQUFHO0FBQ25GLGFBQUssTUFBTSxHQUFHO0FBQUEsTUFDakI7QUFBQSxJQUNKO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQVFELFlBQVksS0FBSyxVQUFVO0FBQ3ZCLFVBQUksT0FBTyxRQUFRLFVBQVU7QUFDekIsY0FBTSxJQUFJLFVBQVUsa0RBQWtELE9BQU8sR0FBRyxFQUFFO0FBQUEsTUFDckY7QUFDRCxVQUFJLE9BQU8sYUFBYSxZQUFZO0FBQ2hDLGNBQU0sSUFBSSxVQUFVLHlEQUF5RCxPQUFPLFFBQVEsRUFBRTtBQUFBLE1BQ2pHO0FBQ0QsYUFBTyxLQUFLLGNBQWMsTUFBTSxLQUFLLElBQUksR0FBRyxHQUFHLFFBQVE7QUFBQSxJQUMxRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBT0QsZUFBZSxVQUFVO0FBQ3JCLFVBQUksT0FBTyxhQUFhLFlBQVk7QUFDaEMsY0FBTSxJQUFJLFVBQVUseURBQXlELE9BQU8sUUFBUSxFQUFFO0FBQUEsTUFDakc7QUFDRCxhQUFPLEtBQUssY0FBYyxNQUFNLEtBQUssT0FBTyxRQUFRO0FBQUEsSUFDdkQ7QUFBQSxJQUNELElBQUksT0FBTztBQUNQLGFBQU8sT0FBTyxLQUFLLEtBQUssS0FBSyxFQUFFO0FBQUEsSUFDbEM7QUFBQSxJQUNELElBQUksUUFBUTtBQUNSLFVBQUk7QUFDQSxjQUFNLE9BQU81USxJQUFHLGFBQWEsS0FBSyxNQUFNLHVCQUF1QixNQUFNLHFCQUFxQixHQUFHLElBQUksT0FBTyxNQUFNO0FBQzlHLGNBQU0sYUFBYSxLQUFLLGFBQWEsSUFBSTtBQUN6QyxjQUFNLG1CQUFtQixLQUFLLGFBQWEsVUFBVTtBQUNyRCxhQUFLLFVBQVUsZ0JBQWdCO0FBQy9CLGVBQU8sT0FBTyxPQUFPLGtCQUFtQixHQUFFLGdCQUFnQjtBQUFBLE1BQzdELFNBQ01WLFFBQU87QUFDVixhQUFLQSxXQUFVLFFBQVFBLFdBQVUsU0FBUyxTQUFTQSxPQUFNLFVBQVUsVUFBVTtBQUN6RSxlQUFLLGlCQUFnQjtBQUNyQixpQkFBTyxrQkFBaUI7QUFBQSxRQUMzQjtBQUNELFlBQUksdUJBQXVCLE1BQU0sZUFBZSxHQUFHLEVBQUUsc0JBQXNCQSxPQUFNLFNBQVMsZUFBZTtBQUNyRyxpQkFBTyxrQkFBaUI7QUFBQSxRQUMzQjtBQUNELGNBQU1BO0FBQUEsTUFDVDtBQUFBLElBQ0o7QUFBQSxJQUNELElBQUksTUFBTSxPQUFPO0FBQ2IsV0FBSyxpQkFBZ0I7QUFDckIsV0FBSyxVQUFVLEtBQUs7QUFDcEIsV0FBSyxPQUFPLEtBQUs7QUFDakIsV0FBSyxPQUFPLEtBQUssUUFBUTtBQUFBLElBQzVCO0FBQUEsSUFDRCxHQUFHLGtCQUFrQixvQkFBSSxRQUFPLEdBQUksc0JBQXNCLG9CQUFJLFFBQU8sR0FBSSxnQkFBZ0Isb0JBQUksUUFBTyxHQUFJLHNCQUFzQixvQkFBSSxRQUFPLEdBQUksT0FBTyxhQUFhO0FBQzdKLGlCQUFXLENBQUMsS0FBSyxLQUFLLEtBQUssT0FBTyxRQUFRLEtBQUssS0FBSyxHQUFHO0FBQ25ELGNBQU0sQ0FBQyxLQUFLLEtBQUs7QUFBQSxNQUNwQjtBQUFBLElBQ0o7QUFBQSxJQUNELGFBQWEsTUFBTTtBQUNmLFVBQUksQ0FBQyx1QkFBdUIsTUFBTSxxQkFBcUIsR0FBRyxHQUFHO0FBQ3pELGVBQU8sS0FBSztNQUNmO0FBQ0QsVUFBSTtBQUVBLFlBQUksdUJBQXVCLE1BQU0scUJBQXFCLEdBQUcsR0FBRztBQUN4RCxjQUFJO0FBQ0EsZ0JBQUksS0FBSyxNQUFNLElBQUksRUFBRSxFQUFFLFNBQVUsTUFBSyxLQUFLO0FBQ3ZDLG9CQUFNLHVCQUF1QixLQUFLLE1BQU0sR0FBRyxFQUFFO0FBQzdDLG9CQUFNLFdBQVcsT0FBTyxXQUFXLHVCQUF1QixNQUFNLHFCQUFxQixHQUFHLEdBQUcscUJBQXFCLFNBQVUsR0FBRSxLQUFPLElBQUksUUFBUTtBQUMvSSxvQkFBTSxXQUFXLE9BQU8saUJBQWlCLHFCQUFxQixVQUFVLG9CQUFvQjtBQUM1RixxQkFBTyxPQUFPLE9BQU8sQ0FBQyxTQUFTLE9BQU8sT0FBTyxLQUFLLEtBQUssTUFBTSxFQUFFLENBQUMsQ0FBQyxHQUFHLFNBQVMsTUFBTyxDQUFBLENBQUMsRUFBRSxTQUFTLE1BQU07QUFBQSxZQUN6RyxPQUNJO0FBRUQsb0JBQU0sV0FBVyxPQUFPLGVBQWUscUJBQXFCLHVCQUF1QixNQUFNLHFCQUFxQixHQUFHLENBQUM7QUFDbEgscUJBQU8sT0FBTyxPQUFPLENBQUMsU0FBUyxPQUFPLE9BQU8sS0FBSyxJQUFJLENBQUMsR0FBRyxTQUFTLE1BQUssQ0FBRSxDQUFDLEVBQUUsU0FBUyxNQUFNO0FBQUEsWUFDL0Y7QUFBQSxVQUNKLFNBQ013SSxLQUFJO0FBQUEsVUFBRztBQUFBLFFBQ2pCO0FBQUEsTUFDSixTQUNNK0ksS0FBSTtBQUFBLE1BQUc7QUFDZCxhQUFPLEtBQUs7SUFDZjtBQUFBLElBQ0QsY0FBYyxRQUFRLFVBQVU7QUFDNUIsVUFBSSxlQUFlO0FBQ25CLFlBQU0sV0FBVyxNQUFNO0FBQ25CLGNBQU0sV0FBVztBQUNqQixjQUFNLFdBQVc7QUFDakIsYUFBUSxHQUFBekssUUFBTyxtQkFBbUIsVUFBVSxRQUFRLEdBQUc7QUFDbkQ7QUFBQSxRQUNIO0FBQ0QsdUJBQWU7QUFDZixpQkFBUyxLQUFLLE1BQU0sVUFBVSxRQUFRO0FBQUEsTUFDbEQ7QUFDUSxXQUFLLE9BQU8sR0FBRyxVQUFVLFFBQVE7QUFDakMsYUFBTyxNQUFNLEtBQUssT0FBTyxlQUFlLFVBQVUsUUFBUTtBQUFBLElBQzdEO0FBQUEsSUFDRCxVQUFVLE1BQU07QUFDWixVQUFJLENBQUMsdUJBQXVCLE1BQU0saUJBQWlCLEdBQUcsR0FBRztBQUNyRDtBQUFBLE1BQ0g7QUFDRCxZQUFNZSxTQUFRLHVCQUF1QixNQUFNLGlCQUFpQixHQUFHLEVBQUUsS0FBSyxNQUFNLElBQUk7QUFDaEYsVUFBSUEsVUFBUyxDQUFDLHVCQUF1QixNQUFNLGlCQUFpQixHQUFHLEVBQUUsUUFBUTtBQUNyRTtBQUFBLE1BQ0g7QUFDRCxZQUFNVSxVQUFTLHVCQUF1QixNQUFNLGlCQUFpQixHQUFHLEVBQUUsT0FDN0QsSUFBSSxDQUFDLEVBQUUsY0FBYyxVQUFVLEdBQUksTUFBSyxLQUFLLGFBQWEsTUFBTSxDQUFDLENBQUMsTUFBTSxPQUFPLEVBQUU7QUFDdEYsWUFBTSxJQUFJLE1BQU0sOEJBQThCQSxRQUFPLEtBQUssSUFBSSxDQUFDO0FBQUEsSUFDbEU7QUFBQSxJQUNELG1CQUFtQjtBQUVmLE1BQUE3SCxJQUFHLFVBQVVDLE1BQUssUUFBUSxLQUFLLElBQUksR0FBRyxFQUFFLFdBQVcsS0FBSSxDQUFFO0FBQUEsSUFDNUQ7QUFBQSxJQUNELE9BQU8sT0FBTztBQUNWLFVBQUksT0FBTyxLQUFLLFdBQVcsS0FBSztBQUNoQyxVQUFJLHVCQUF1QixNQUFNLHFCQUFxQixHQUFHLEdBQUc7QUFDeEQsY0FBTSx1QkFBdUIsT0FBTyxZQUFZLEVBQUU7QUFDbEQsY0FBTSxXQUFXLE9BQU8sV0FBVyx1QkFBdUIsTUFBTSxxQkFBcUIsR0FBRyxHQUFHLHFCQUFxQixTQUFVLEdBQUUsS0FBTyxJQUFJLFFBQVE7QUFDL0ksY0FBTSxTQUFTLE9BQU8sZUFBZSxxQkFBcUIsVUFBVSxvQkFBb0I7QUFDeEYsZUFBTyxPQUFPLE9BQU8sQ0FBQyxzQkFBc0IsT0FBTyxLQUFLLEdBQUcsR0FBRyxPQUFPLE9BQU8sT0FBTyxLQUFLLElBQUksQ0FBQyxHQUFHLE9BQU8sTUFBTyxDQUFBLENBQUM7QUFBQSxNQUNsSDtBQUdELFVBQUksUUFBUSxJQUFJLE1BQU07QUFDbEIsUUFBQUQsSUFBRyxjQUFjLEtBQUssTUFBTSxNQUFNLEVBQUUsTUFBTSx1QkFBdUIsTUFBTSxlQUFlLEdBQUcsRUFBRSxlQUFnQixDQUFBO0FBQUEsTUFDOUcsT0FDSTtBQUNELFlBQUk7QUFDQSxxQkFBVyxjQUFjLEtBQUssTUFBTSxNQUFNLEVBQUUsTUFBTSx1QkFBdUIsTUFBTSxlQUFlLEdBQUcsRUFBRSxlQUFnQixDQUFBO0FBQUEsUUFDdEgsU0FDTVYsUUFBTztBQUlWLGVBQUtBLFdBQVUsUUFBUUEsV0FBVSxTQUFTLFNBQVNBLE9BQU0sVUFBVSxTQUFTO0FBQ3hFLFlBQUFVLElBQUcsY0FBYyxLQUFLLE1BQU0sTUFBTSxFQUFFLE1BQU0sdUJBQXVCLE1BQU0sZUFBZSxHQUFHLEVBQUUsZUFBZ0IsQ0FBQTtBQUMzRztBQUFBLFVBQ0g7QUFDRCxnQkFBTVY7QUFBQSxRQUNUO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFBQSxJQUNELFNBQVM7QUFDTCxXQUFLLGlCQUFnQjtBQUNyQixVQUFJLENBQUNVLElBQUcsV0FBVyxLQUFLLElBQUksR0FBRztBQUMzQixhQUFLLE9BQU8sa0JBQWlCLENBQUU7QUFBQSxNQUNsQztBQUNELFVBQUksUUFBUSxhQUFhLFNBQVM7QUFDOUIsUUFBQUEsSUFBRyxNQUFNLEtBQUssTUFBTSxFQUFFLFlBQVksTUFBSyxHQUFJMFEsYUFBVyxNQUFNO0FBRXhELGVBQUssT0FBTyxLQUFLLFFBQVE7QUFBQSxRQUM1QixHQUFFLEVBQUUsTUFBTSxJQUFLLENBQUEsQ0FBQztBQUFBLE1BQ3BCLE9BQ0k7QUFDRCxRQUFBMVEsSUFBRyxVQUFVLEtBQUssTUFBTSxFQUFFLFlBQVksTUFBSyxHQUFJMFEsYUFBVyxNQUFNO0FBQzVELGVBQUssT0FBTyxLQUFLLFFBQVE7QUFBQSxRQUM1QixHQUFFLEVBQUUsTUFBTSxJQUFNLENBQUEsQ0FBQztBQUFBLE1BQ3JCO0FBQUEsSUFDSjtBQUFBLElBQ0QsU0FBUyxZQUFZLGtCQUFrQixxQkFBcUI7QUFDeEQsVUFBSSwwQkFBMEIsS0FBSyxLQUFLLGVBQWUsT0FBTztBQUM5RCxZQUFNLGdCQUFnQixPQUFPLEtBQUssVUFBVSxFQUN2QyxPQUFPLHNCQUFvQixLQUFLLHdCQUF3QixrQkFBa0IseUJBQXlCLGdCQUFnQixDQUFDO0FBQ3pILFVBQUksY0FBYyxFQUFFLEdBQUcsS0FBSyxNQUFLO0FBQ2pDLGlCQUFXLFdBQVcsZUFBZTtBQUNqQyxZQUFJO0FBQ0EsY0FBSSxxQkFBcUI7QUFDckIsZ0NBQW9CLE1BQU07QUFBQSxjQUN0QixhQUFhO0FBQUEsY0FDYixXQUFXO0FBQUEsY0FDWCxjQUFjO0FBQUEsY0FDZCxVQUFVO0FBQUEsWUFDbEMsQ0FBcUI7QUFBQSxVQUNKO0FBQ0QsZ0JBQU0sWUFBWSxXQUFXLE9BQU87QUFDcEMsb0JBQVUsSUFBSTtBQUNkLGVBQUssS0FBSyxlQUFlLE9BQU87QUFDaEMsb0NBQTBCO0FBQzFCLHdCQUFjLEVBQUUsR0FBRyxLQUFLO1FBQzNCLFNBQ01wUixRQUFPO0FBQ1YsZUFBSyxRQUFRO0FBQ2IsZ0JBQU0sSUFBSSxNQUFNLHlIQUF5SEEsTUFBSyxFQUFFO0FBQUEsUUFDbko7QUFBQSxNQUNKO0FBQ0QsVUFBSSxLQUFLLHdCQUF3Qix1QkFBdUIsS0FBSyxDQUFDZ04sVUFBTyxHQUFHLHlCQUF5QixnQkFBZ0IsR0FBRztBQUNoSCxhQUFLLEtBQUssZUFBZSxnQkFBZ0I7QUFBQSxNQUM1QztBQUFBLElBQ0o7QUFBQSxJQUNELHFCQUFxQixLQUFLO0FBQ3RCLFVBQUksT0FBTyxRQUFRLFVBQVU7QUFDekIsY0FBTSxVQUFVLE9BQU8sS0FBSyxHQUFHLEVBQUUsQ0FBQztBQUNsQyxZQUFJLFlBQVksY0FBYztBQUMxQixpQkFBTztBQUFBLFFBQ1Y7QUFBQSxNQUNKO0FBQ0QsVUFBSSxPQUFPLFFBQVEsVUFBVTtBQUN6QixlQUFPO0FBQUEsTUFDVjtBQUNELFVBQUksdUJBQXVCLE1BQU0sZUFBZSxHQUFHLEVBQUUsK0JBQStCO0FBQ2hGLFlBQUksSUFBSSxXQUFXLEdBQUcsWUFBWSxHQUFHLEdBQUc7QUFDcEMsaUJBQU87QUFBQSxRQUNWO0FBQ0QsZUFBTztBQUFBLE1BQ1Y7QUFDRCxhQUFPO0FBQUEsSUFDVjtBQUFBLElBQ0Qsd0JBQXdCLFNBQVM7QUFDN0IsYUFBT0EsVUFBTyxNQUFNLE9BQU8sTUFBTTtBQUFBLElBQ3BDO0FBQUEsSUFDRCx3QkFBd0Isa0JBQWtCLHlCQUF5QixrQkFBa0I7QUFDakYsVUFBSSxLQUFLLHdCQUF3QixnQkFBZ0IsR0FBRztBQUNoRCxZQUFJLDRCQUE0QixXQUFXQSxVQUFPLFVBQVUseUJBQXlCLGdCQUFnQixHQUFHO0FBQ3BHLGlCQUFPO0FBQUEsUUFDVjtBQUNELGVBQU9BLFVBQU8sVUFBVSxrQkFBa0IsZ0JBQWdCO0FBQUEsTUFDN0Q7QUFDRCxVQUFJQSxVQUFPLElBQUksa0JBQWtCLHVCQUF1QixHQUFHO0FBQ3ZELGVBQU87QUFBQSxNQUNWO0FBQ0QsVUFBSUEsVUFBTyxHQUFHLGtCQUFrQixnQkFBZ0IsR0FBRztBQUMvQyxlQUFPO0FBQUEsTUFDVjtBQUNELGFBQU87QUFBQSxJQUNWO0FBQUEsSUFDRCxLQUFLLEtBQUssY0FBYztBQUNwQixhQUFPaUUsVUFBUSxJQUFJLEtBQUssT0FBTyxLQUFLLFlBQVk7QUFBQSxJQUNuRDtBQUFBLElBQ0QsS0FBSyxLQUFLLE9BQU87QUFDYixZQUFNLEVBQUUsT0FBQUssT0FBTyxJQUFHO0FBQ2xCTCxnQkFBUSxJQUFJSyxRQUFPLEtBQUssS0FBSztBQUM3QixXQUFLLFFBQVFBO0FBQUEsSUFDaEI7QUFBQSxFQUNKO0FBQ0QsRUFBQW5QLFNBQUEsVUFBa0JrUDtBQUVsQixFQUFBckYsUUFBQSxVQUFpQnFGO0FBQ2pCLEVBQUFyRixRQUFBLFFBQUEsVUFBeUJxRjs7O0FDbGV6QixNQUFNLE9BQU9oUjtBQUNiLE1BQU0sRUFBQyxLQUFLLFNBQVMsYUFBYSxNQUFLLElBQUlUO0FBQzNDLE1BQU0sT0FBT0M7QUFFYixJQUFJLGdCQUFnQjtBQUdwQixNQUFNLG1CQUFtQixNQUFNO0FBQzlCLE1BQUksQ0FBQyxXQUFXLENBQUMsS0FBSztBQUNyQixVQUFNLElBQUksTUFBTSwyRUFBMkU7QUFBQSxFQUMzRjtBQUVELFFBQU0sVUFBVTtBQUFBLElBQ2YsWUFBWSxJQUFJLFFBQVEsVUFBVTtBQUFBLElBQ2xDLFlBQVksSUFBSSxXQUFZO0FBQUEsRUFDOUI7QUFFQyxNQUFJLGVBQWU7QUFDbEIsV0FBTztBQUFBLEVBQ1A7QUFFRCxVQUFRLEdBQUcsMkJBQTJCLFdBQVM7QUFDOUMsVUFBTSxjQUFjO0FBQUEsRUFDdEIsQ0FBRTtBQUVELGtCQUFnQjtBQUVoQixTQUFPO0FBQ1I7QUFFQSxNQUFNLHNCQUFzQixLQUFLO0FBQUEsRUFDaEMsWUFBWSxTQUFTO0FBQ3BCLFFBQUk7QUFDSixRQUFJO0FBSUosUUFBSSxhQUFhO0FBQ2hCLFlBQU0sVUFBVSxZQUFZLFNBQVMseUJBQXlCO0FBRTlELFVBQUksQ0FBQyxTQUFTO0FBQ2IsY0FBTSxJQUFJLE1BQU0sMkVBQTJFO0FBQUEsTUFDM0Y7QUFFRCxPQUFDLEVBQUMsWUFBWSxXQUFVLElBQUk7QUFBQSxJQUMvQixXQUFhLFdBQVcsS0FBSztBQUMxQixPQUFDLEVBQUMsWUFBWSxXQUFVLElBQUksaUJBQWdCO0FBQUEsSUFDNUM7QUFFRCxjQUFVO0FBQUEsTUFDVCxNQUFNO0FBQUEsTUFDTixHQUFHO0FBQUEsSUFDTjtBQUVFLFFBQUksQ0FBQyxRQUFRLGdCQUFnQjtBQUM1QixjQUFRLGlCQUFpQjtBQUFBLElBQ3pCO0FBRUQsUUFBSSxRQUFRLEtBQUs7QUFDaEIsY0FBUSxNQUFNLEtBQUssV0FBVyxRQUFRLEdBQUcsSUFBSSxRQUFRLE1BQU0sS0FBSyxLQUFLLFlBQVksUUFBUSxHQUFHO0FBQUEsSUFDL0YsT0FBUztBQUNOLGNBQVEsTUFBTTtBQUFBLElBQ2Q7QUFFRCxZQUFRLGFBQWEsUUFBUTtBQUM3QixXQUFPLFFBQVE7QUFFZixVQUFNLE9BQU87QUFBQSxFQUNiO0FBQUEsRUFFRCxPQUFPLGVBQWU7QUFDckI7RUFDQTtBQUFBLEVBRUQsZUFBZTtBQUNkLFVBQU0sU0FBUyxLQUFLLElBQUk7QUFBQSxFQUN4QjtBQUNGO0FBRUEsSUFBQSxnQkFBaUI7O0FDaEZqQixJQUFDNlIsbUNBQUEsRUFBQSxxQkFBdUIsMEJBQTBCLFVBQVksS0FBSyxNQUFRLGVBQWUsS0FBTyxNQUFNLE1BQVEsT0FBTyxLQUFPLE1BQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDR2xJLE1BQU0sU0FBUztBQUFBLEVBQ2QsU0FBUztBQUFBLElBQ1IsTUFBTTtBQUFBLElBQ04sU0FBU0MsV0FBQUEsSUFBSSxRQUFRLFVBQVU7QUFBQSxFQUMvQjtBQUNGO0FBRUEsTUFBQSxXQUFlLElBQUksTUFBTSxFQUFFLE1BQU0sWUFBWSxRQUFRLGVBQWUsUUFBUSxJQUFJLGtCQUFrQjtBQ1BsRyxNQUFlLFFBQUE7QUFBQSxFQUNmLE1BQUN2UjtBQUFBQSxFQUNBO0FBQ0Q7QUNOQSxJQUFDLGlDQUFBLEVBQUEscUJBQXVCLDBCQUEwQixVQUFZLEtBQUssTUFBUSxlQUFlLEtBQU8sTUFBTSxNQUFRLE9BQU8sS0FBTyxNQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyIsInhfZ29vZ2xlX2lnbm9yZUxpc3QiOlswLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDI2LDI3LDI4LDI5LDMwLDMxLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDM5LDQwLDQxLDQyLDQzLDQ0LDQ1LDQ2LDQ3LDQ4LDQ5LDUwLDUxLDUyLDUzLDU0LDU1LDU2LDU3LDU4LDU5LDYwLDYxLDYyLDYzLDY0LDY1LDY2LDY3LDY4LDY5LDcwLDcxLDcyLDczLDc0LDc1LDc2LDc3LDc4LDc5LDgwLDgxLDgyLDgzLDg0LDg1LDg2LDg3LDg4LDg5LDkwLDkxLDkyLDkzLDk0LDk1LDk2LDk3LDk4LDk5LDEwMCwxMDEsMTAyLDEwMywxMDQsMTA1LDEwNiwxMDcsMTA4LDEwOSwxMTAsMTExLDExMiwxMTMsMTE0LDExNSwxMTYsMTE3LDExOCwxMTksMTIwLDEyMSwxMjIsMTIzLDEyNCwxMjUsMTI2LDEyNywxMjgsMTI5LDEzMCwxMzEsMTMyLDEzMywxMzQsMTM1LDEzNiwxMzcsMTM4LDEzOSwxNDAsMTQxLDE0MiwxNDMsMTQ0LDE0NSwxNDYsMTQ3LDE0OCwxNDksMTUwLDE1MSwxNTIsMTUzLDE1NCwxNTUsMTU2LDE1NywxNTgsMTU5LDE2MCwxNjEsMTYyLDE2MywxNjQsMTY1LDE2NiwxNjcsMTY4LDE2OSwxNzAsMTcxLDE3MiwxNzMsMTc0LDE3NSwxNzYsMTc3LDE3OF19
